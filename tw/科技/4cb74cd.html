<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記 | 极客快訊</title><meta property="og:title" content="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b9d102263d0f46a0b5b203d7b6cd4a2e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><meta property="article:published_time" content="2020-10-29T20:59:18+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:18+08:00"><meta name=Keywords content><meta name=description content="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4cb74cd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-center><br></p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9d102263d0f46a0b5b203d7b6cd4a2e><p class=pgc-img-caption></p></div><p><strong>引言有點長</strong></p><p>前端的寶寶會用ajax,用異步編程到快樂的不行~ 我們java也有異步,用起來比他們還快樂~ 我們bia<sub>ji</sub>一個注(gǒupí)解(gāoyào),也是快樂風男...</p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76774e1aae234e1fb0cd43b2cd9efe23><p class=pgc-img-caption></p></div><p>且看下面的栗子:</p><p>註冊一個用戶,給他的賬戶初始化積分(也可以想象成註冊獎勵),再給用戶發個註冊通知短信,再發個郵件,(只是舉栗子,切莫牛角大法),這樣一個流程,短信和郵件我覺得完全可以拆分出來,沒必要拖在在主流程上來(再補充上<strong>事務</strong>[ACID:原子性,一致性,隔離性,持久性]就好了):</p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64c95c7e357b4756aedc1df7d658f878><p class=pgc-img-caption></p></div><p>今天就這點業務,我在暗想,這不是一個註解就搞掂的嘛~~~ <sub>哈哈哈</sub></p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/39c186d466d1403b9163b08677a2675f><p class=pgc-img-caption></p></div><p>結果不是想象中的那麼完美~~ 來看我的<strong>異(dind)步(ding)歷險記</strong></p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9fea1352e1e44ad89441576d6bb309ca><p class=pgc-img-caption></p></div><p>我的首發原創博客地址:<strong>你的@Async就真的異步嗎 ☞ 異步歷險奇遇記</strong><sup><strong>[1] https://juejin.im/post/5d47a80a6fb9a06ad3470f9a </strong></sup>裡面有gitHub項目地址,關注我,裡面實戰多多哦~</p><hr><p><strong>奇遇一 循環依賴異常</strong></p><p>看code:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserService userService;  @Override @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用戶成功:" + user); userService.senMsg(user); userService.senEmail(user); return insert; } @Async @Override public Boolean senMsg(User user) { try { TimeUnit.SECONDS.sleep(2); System.out.println("發送短信中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",手機號:" + user.getMobile() + "發送短信成功"); return true; } @Async @Override public Boolean senEmail(User user) { try { TimeUnit.SECONDS.sleep(3); System.out.println("發送郵件中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",郵箱:" + user.getEmail() + "發送郵件成功"); return true; }</pre><p>結果:啟動不起來,Spring循環依賴問題。 Spring不是解決了循環依賴問題嗎，它是支持循環依賴的呀？怎麼會呢？</p><p>不可否認，在這之前我也是這麼堅信的，倘若你目前也和我有一樣堅挺的想法,那就讓異常UnsatisfiedDependencyException,has been injected into other beans [userServiceImpl] in its raw version as part of a circular reference,,來鼓勵你,擁抱你, 就是這麼的不給面子,赤裸裸的circular reference。</p><p>談到Spring Bean的循環依賴，有的小夥伴可能比較陌生，畢竟開發過程中好像對循環依賴這個概念無感知。其實不然，你有這種錯覺，那是因為你工作在Spring的<strong>襁褓</strong>中，從而讓你“<strong>高枕無憂</strong>”~ 其實我們的代碼中肯定被我們寫了循環依賴,比如像這樣:</p><pre>@Servicepublic class AServiceImpl implements AService { @Autowired private BService bService; ...}@Servicepublic class BServiceImpl implements BService { @Autowired private AService aService; ...}</pre><p><strong>通過實驗總結出</strong>，出現使用@Async導致循環依賴問題的必要條件：</p><ul><li>已開啟@EnableAsync的支持</li><li>@Async註解所在的Bean被循環依賴了</li></ul><p><strong>奇遇二 異步失效異常</strong></p><p>那麼既然不能循環依賴,我們就不循環依賴,我們這麼來:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Autowired SendService sendService;  @Override @Transactional() public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用戶成功:" + user); this.senMsg(user); this.senEmail(user); return insert; } @Async @Override public Boolean senMsg(User user) { System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",手機號:" + user.getMobile() + "發送短信成功"); return true; } @Async @Override public Boolean senEmail(User user) { System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",郵箱:" + user.getEmail() + "發送郵件成功"); return true; }</pre><p>結果我們測試了幾把,我打印一下結果:</p><pre>2019-08-05 21:59:32.304 INFO 14360 --- [nio-8080-exec-3] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} inited2019-08-05 21:59:32.346 DEBUG 14360 --- [nio-8080-exec-3] c.b.lea.mybot.mapper.UserMapper.insert : ==&gt; Preparing: insert into t_user (username, sex, mobile,email) values (?, ?, ?,?) 2019-08-05 21:59:32.454 DEBUG 14360 --- [nio-8080-exec-3] c.b.lea.mybot.mapper.UserMapper.insert : ==&gt; Parameters: 王麻子(String), 男(String), 18820158833(String), 22qq@qq.com(String)2019-08-05 21:59:32.463 DEBUG 14360 --- [nio-8080-exec-3] c.b.lea.mybot.mapper.UserMapper.insert : &lt;== Updates: 1User 保存用戶成功:User(id=101, username=王麻子, mobile=18820158833, email=22qq@qq.com, sex=男, password=123435, createTime=Mon Aug 05 12:20:51 CST 2019, updateTime=null)發送短信中:.....http-nio-8080-exec-3給用戶id:101,手機號:18820158833發送短信成功發送郵件中:.....http-nio-8080-exec-3給用戶id:101,郵箱:22qq@qq.com發送郵件成功</pre><p>這不白瞎了嗎?感知不到我的愛,白寫了,難受~~線程依然是http-nio-8080-exec-3,那麼為什麼了呢? 下面會講的哦,先說結論:</p><p><strong>通過實驗總結出</strong>，出現使用@Async導致異步失效的原因：</p><ul><li>在本類中使用了異步是不支持異步的</li><li>調用者其實是this,是當前對象,不是真正的代理對象userService,spring無法截獲這個方法調用 所以不在不在本類中去調用,網上的解決方法有applicationContext.getBean(UserService.class)和AopContext.currentProxy()</li></ul><p><strong>奇遇三 事務失效異常</strong></p><p>那麼,既然不能用當前對象,那我們用代理,AopContext.currentProxy(),然鵝,你發現,報錯了,對Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.就他:</p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/412d5981a2be4f9182be7f899e5d94d2><p class=pgc-img-caption></p></div><p>但是你去網上百度就會發現,都這麼搞</p><pre>@EnableAspectJAutoProxy(exposeProxy = true)</pre><p>我也這麼搞,但是又報錯了,細細的看報錯內容,才發現少了個jar包這東西要配合切面織入,要配合,懂嗎?,來上包</p><pre> &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt;</pre><p>再來看為撒: 這是一個性感的話題,exposeProxy = true它的作用就是<strong>啟用切面的自動代理</strong>,說人話就是<strong>暴露當前代理對象到當前線程綁定</strong>, 看個報錯Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.就是AopContext搞得鬼.</p><p>public final class AopContext {</p><p>private static final ThreadLocal&lt;Object> currentProxy = new NamedThreadLocal&lt;>("Current AOP proxy");</p><p>private AopContext() {</p><p>}</p><p>// 該方法是public static方法，說明可以被任意類進行調用</p><p>public static Object currentProxy() throws IllegalStateException {</p><p>Object proxy = currentProxy.get();</p><p>// 它拋出異常的原因是當前線程並沒有綁定對象</p><p>// 而給線程綁定對象的方法在下面：特別有意思的是它的訪問權限是default級別，也就是說只能Spring內部去調用</p><p>if (proxy == null) {</p><p>throw new IllegalStateException("Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.");</p><p>}</p><p>return proxy;</p><p>}</p><p>// 它最有意思的地方是它的訪問權限是default的，表示只能給Spring內部去調用</p><p>// 調用它的類有CglibAopProxy和JdkDynamicAopProxy</p><p>@Nullable</p><p>static Object setCurrentProxy(@Nullable Object proxy) {</p><p>Object old = currentProxy.get();</p><p>if (proxy != null) {</p><p>currentProxy.set(proxy);</p><p>} else {</p><p>currentProxy.remove();</p><p>}</p><p>return old;</p><p>}</p><p>}</p><p>所以我們要做啟用代理設置,讓代理生效,來走起,主線程的方法使用來調用異步方法,來測試走起: no code said niao:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Override@Transactional(propagation = Propagation.REQUIRED) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用戶成功:" + user); UserService currentProxy = UserService.class.cast(AopContext.currentProxy()); currentProxy.senMsg(user); currentProxy.senEmail(user); int i = 1 / 0; return insert; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void senMsg(User user) { user.setUsername(Thread.currentThread().getName()+"發短信測試事務...."+ new Random().nextInt()); userMapper.insert(user); System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",手機號:" + user.getMobile() + "發送短信成功"); } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void senEmail(User user) { user.setUsername("發郵件測試事務...."+ new Random().nextInt()); userMapper.insert(user); int i = 1 / 0; System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",郵箱:" + user.getEmail() + "發送郵件成功"); }} </pre><p>測試結果:</p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f866b864cb644be946b2cde2f587dd3><p class=pgc-img-caption></p></div><p>如我們所願,事務和異步都生效了</p><pre>1. 異步線程SimpleAsyncTaskExecutor-1和SimpleAsyncTaskExecutor-2分別發短信和郵件,主線程保存用戶2. 實際結果,主線程保存的那個用戶失敗,名字叫'發送短信'的也保存失敗,只有叫'發郵件'的用戶插入成功3. 那麼就做到了事務的線程隔離,事務的互不影響,完美4. 親,你這麼寫了嗎?這麼寫不優美,雖然有用,但是寫的另闢蹊徑啊</pre><p><strong>奇遇四 異步嵌套異常</strong></p><p>來,我們看個更騷氣的,異步中嵌套異步,來上code:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Override@Transactional(propagation = Propagation.REQUIRED) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用戶成功:" + user); UserService currentProxy = UserService.class.cast(AopContext.currentProxy()); currentProxy.send(user); return insert; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void send(User user) { //發短信 user.setUsername(Thread.currentThread().getName()+"發短信測試事務...."+ new Random().nextInt()); userMapper.insert(user); System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",手機號:" + user.getMobile() + "發送短信成功"); //發郵件 UserService currentProxy = UserService.class.cast(AopContext.currentProxy()); currentProxy.senEmail(user); }  @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void senEmail(User user) { user.setUsername("發郵件測試事務...."+ new Random().nextInt()); userMapper.insert(user); System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",郵箱:" + user.getEmail() + "發送郵件成功"); }}</pre><p>看我們猜下結果? 數據庫會新增幾個數據?3個?2個?1個?0個?納尼報錯?</p><p>哈哈``` 上結果:</p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c410d8e4542447e299cb8c9aac2578e6><p class=pgc-img-caption></p></div><p><strong>答案</strong>:只有一條數據主線程保存成功,短信和郵件的插入都失敗了,最主要的是還報錯了,又是那個~~~Set 'exposeProxy' property on Advised to 'true'磨人的小妖精</p><p><strong>通過實驗總結出</strong>，出現導致異步嵌套使用失敗的原因：</p><ul><li>在本類中使用了異步嵌套異步是不支持的</li><li>調用者其實被代理過一次了,再嵌套會出現'二次代理',其實是達不到代理了效果,因為已經異步了.即時你在嵌套中不使用代理去獲取,即使不保存,但是事務和異步效果都會跟隨當前的代理,即嵌套的效果是達不到再次異步的.</li><li>解決辦法應該有,但是我覺得我還沒找到.這個寫法是我們應該規避的,我們應該遵循規範,啟用新的服務類去完成我們的異步工作</li></ul><p>下面我們舉個栗子:正確的寫法,優雅的寫法</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Autowired SendService sendService; @Override@Transactional(propagation = Propagation.REQUIRED) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用戶成功:" + user); sendService.senMsg(user); sendService.senEmail(user); return insert; }}---------------無責任分割線--------------------@Servicepublic class SendServiceImpl implements SendService { @Override @Async @Transactional(propagation = Propagation.REQUIRES_NEW) public Boolean senMsg(User user) { try { TimeUnit.SECONDS.sleep(2); System.out.println("發送短信中:....."); } catch (InterruptedException e) { e.printStackTrace(); } int i = 1 / 0; System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",手機號:" + user.getMobile() + "發送短信成功"); return true; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public Boolean senEmail(User user) { try { TimeUnit.SECONDS.sleep(3); System.out.println("發送郵件中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",郵箱:" + user.getEmail() + "發送郵件成功"); return true; }}</pre><p>結果肯定完美:</p><div class=pgc-img><img alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8aaae381bb5f4a8cb5a6d47557519a76><p class=pgc-img-caption></p></div><p>因此當你看到你同事就在本類寫個方法標註上@Async然後調用，請制止他吧，做的無用功~~~（關鍵自己還以為有用，這是最可怕的深坑~）</p><p>那我補充點:@EnableAspectJAutoProxy(exposeProxy = true)的作用: 此註解它導入了AspectJAutoProxyRegistrar，最終設置此註解的兩個屬性的方法為：</p><pre>public abstract class AopConfigUtils { ...正在加(sheng)載(lue)代碼中 請稍後....	public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {			BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);			definition.getPropertyValues().add("proxyTargetClass", Boolean.TRUE);		}	}	public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {			BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);			definition.getPropertyValues().add("exposeProxy", Boolean.TRUE);		}	}}</pre><p>看到此註解標註的屬性值最終都被設置到了internalAutoProxyCreator身上，也就是它：<strong>自動代理創建器</strong>。 首先我們需要明晰的是：@Async的代理對象並不是由自動代理創建器來創建的，而是由AsyncAnnotationBeanPostProcessor一個單純的BeanPostProcessor實現的,很顯然當執行AopContext.currentProxy()這句代碼的時候報錯了。@EnableAsync給容器注入的是AsyncAnnotationBeanPostProcessor，它用於給@Async生成代理，但是它僅僅是個BeanPostProcessor並不屬於自動代理創建器，因此exposeProxy = true對它無效。 所以AopContext.setCurrentProxy(proxy);這個set方法肯定就不會執行，所以,因此,但凡只要業務方法中調用AopContext.currentProxy()方法就鐵定拋異常~~</p><p><strong>奇遇五 基本類型異常</strong></p><p>看嘛,發短信其實是一些網關調用,我想寫個看短信,郵件發送成功的標誌,是否調用成功的狀態,來走起</p><pre>....省略...UserService---------------無責任分割線--------------------@Servicepublic class SendServiceImpl implements SendService { @Override @Async @Transactional(propagation = Propagation.REQUIRES_NEW) public boolean senMsg(User user) { try { TimeUnit.SECONDS.sleep(2); System.out.println("發送短信中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",手機號:" + user.getMobile() + "發送短信成功"); return true; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public boolean senEmail(User user) { try { TimeUnit.SECONDS.sleep(3); System.out.println("發送郵件中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "給用戶id:" + user.getId() + ",郵箱:" + user.getEmail() + "發送郵件成功"); return true; }}</pre><p>瞪大眼睛看,我的返回結果是boolean,屬於基本類型,雖然沒有用,但是報錯了:</p><pre>org.springframework.aop.AopInvocationException: Null return value from advice does not match primitive return type for: public boolean com.boot.lea.mybot.service.impl.SendServiceImpl.senMsg(com.boot.lea.mybot.entity.User)</pre><p>導致我的數據庫一條數據都沒有,影響到主線程了,可見問題發生在主線程<strong>觸發</strong>異步線程的時候,那我們找原因: 是走代理觸發的:我先找這個類CglibAopProxy再順藤摸瓜</p><pre>/**	 * Process a return value. Wraps a return of {@code this} if necessary to be the	 * {@code proxy} and also verifies that {@code null} is not returned as a primitive.	 */	private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {		// Massage return value if necessary		if (retVal != null &amp;&amp; retVal == target &amp;&amp;				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {			// Special case: it returned "this". Note that we can't help			// if the target sets a reference to itself in another returned object.			retVal = proxy;		}		Class&lt;?&gt; returnType = method.getReturnType();		if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {			throw new AopInvocationException(					"Null return value from advice does not match primitive return type for: " + method);		}		return retVal;	}</pre><p>在這retVal == null && returnType != Void.TYPE && returnType.isPrimitive(),因為我們的這種異步其實是不支持友好的返回結果的,我們的結果應該是void,因為這個異步線程被主線程觸發後其實被當做一個任務提交到Spring的異步的一個線程池中進行異步的處理任務了,線程之間的通信是不能之間返回的,其實用這種寫法我們就應該用void去異步執行,不要有返回值,而且我們的返回值是isPrimitive(),是基本類型,剛好達標....</p><p><strong>那麼我大聲喊出,使用異步的時候儘量不要有返回值,實在要有你也不能用基本類型.</strong></p><p><strong>奇遇六 返回異步結果</strong></p><p>有些人就是難受,就是想要返回結果,那麼也是可以滴:但是要藉助Furtrue小姐姐的get()來進行線程之間的阻塞通信,畢竟小姐姐⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄害羞.</p><p>醬紫寫,你就可以阻塞等到執行任務有結果的時候去獲取真正的結果了,這個寫法和我之前的文章<strong>JAVA併發異步編程 原來十個接口的活現在只需要一個接口就搞定!</strong><sup><strong>[2]</strong></sup>是一樣的道理了</p><pre>import com.boot.lea.mybot.service.AsyncService;import com.boot.lea.mybot.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.AsyncResult;import org.springframework.stereotype.Service;@Service@Async("taskExecutor")public class AsyncServiceImpl implements AsyncService { @Autowired private UserService userService; @Override public Future&lt;Long&gt; queryUserMsgCount(final Long userId) { System.out.println("當前線程:" + Thread.currentThread().getName() + "=-=====queryUserMsgCount"); long countByUserId = userService.countMsgCountByUserId(userId); return new AsyncResult&lt;&gt;(countByUserId); } @Override public Future&lt;Long&gt; queryCollectCount(final Long userId) { System.out.println("當前線程:" + Thread.currentThread().getName() + "=-====queryCollectCount"); long collectCount = userService.countCollectCountByUserId(userId); return new AsyncResult&lt;&gt;(collectCount); }</pre><p><strong>你需要知道的九大異步注意事項</strong></p><ol><li>儘量不要在本類中異步調用</li><li>儘量不要有返回值</li><li>不能使用本類的私有方法或者非接口化加註@Async,因為代理不到失效</li><li>異步方法不能使用static修飾</li><li>異步類沒有使用@Component註解（或其他註解）導致spring無法掃描到異步類</li><li>類中需要使用@Autowired或@Resource等註解自動注入，不能自己手動new對象</li><li>如果使用SpringBoot框架必須在啟動類中增加@EnableAsync註解</li><li>在調用Async方法的方法上標註@Transactional是管理調用方法的事務的</li><li>在Async方法上標註@Transactional是管理異步方法的事務,事務因線程隔離</li></ol><p><strong>你需要懂的異步原理</strong></p><p><strong>@Async的異步</strong>:</p><ul><li>實際是spring 在掃描bean的時候會掃描方法上是否包含@Async的註解，如果包含的，spring會為這個bean動態的生成一個子類，我們稱之為代理類(jdkProxy)， 代理類是繼承我們所寫的bean的，然後把代理類注入進來，那此時，在執行此方法的時候，會到代理類中，代理類判斷了此方法需要異步執行，就不會調用父類 (我們原本寫的bean)的對應方法。</li><li>spring自己維護了一個隊列，他會把需要執行的方法，放入隊列中，等待線程池去讀取這個隊列，完成方法的執行， 從而完成了異步的功能。</li><li>我們可以關注到再配置task的時候，是有參數讓我們配置線程池的數量的。因為這種實現方法，所以在同一個類中的方法調用，添加@Async註解是失效的！，原因是當你在同一個類中的時候，方法調用是在類體內執行的，spring無法截獲這個方法調用(為什麼呢,這個就是下文講的...奸笑...嘻嘻嘻嘻...)。</li><li>那在深入一步，Spring為我們提供了AOP，面向切面的功能。他的原理和異步註解的原理是類似的，spring在啟動容器的時候，會掃描切面所定義的 類。在這些類被注入的時候，所注入的也是代理類，當你調用這些方法的時候，本質上是調用的代理類。通過代理類再去執行父類相對應的方法，那spring只需要在調用之前和之後執行某段代碼就完成了AOP的實現了！</li></ul><p>SpringBoot環境中，要使用@Async註解,我們需要先在啟動類上加上@EnableAsync註解。這個與在SpringBoot中使用@Scheduled註解需要在啟動類中加上@EnableScheduling是一樣的道理（當然你使用古老的XML配置也是可以的，但是在SpringBoot環境中，建議的是全註解開發），具體原理下面會分析。加上@EnableAsync註解後，如果我們想在調用一個方法的時候開啟一個新的線程開始異步操作，我們只需要在這個方法上加上@Async註解，當然前提是，這個方法所在的類必須在Spring環境中。</p><pre>示例:非spingboot項目&lt;task:annotation-driven executor="annotationExecutor" /&gt;&lt;!-- 支持 @Async 註解 --&gt;&lt;task:executor id="annotationExecutor" pool-size="20"/&gt;</pre><p>執行流程:</p><ol><li>掃描是否開啟註解EnableAsync,@EnableAsync註解上有個@Import(AsyncConfigurationSelector.class),springboot的注入老套路了</li><li>請您再移步AsyncConfigurationSelector,看到selectImports方法了沒,這裡使用的是默認使用的是ProxyAsyncConfiguration這個配置類</li><li>繼續觀摩ProxyAsyncConfiguration繼承AbstractAsyncConfiguration,它裡面的的setConfigurers說明了我們可以通過實現AsyncConfigurer接口來完成線程池以及異常處理器的配置,而且在Spring環境中只能配置一個實現類，否則會拋出異常。 上一點代碼:</li></ol><pre> /**	 * Collect any {@link AsyncConfigurer} beans through autowiring.	 */	@Autowired(required = false)	void setConfigurers(Collection&lt;AsyncConfigurer&gt; configurers) { 		if (CollectionUtils.isEmpty(configurers)) {			return;		} //AsyncConfigurer用來配置線程池配置以及異常處理器，而且在Spring環境中最多只能有一個，在這裡我們知道了，如果想要自己去配置線程池，只需要實現AsyncConfigurer接口，並且不可以在Spring環境中有多個實現AsyncConfigurer的類。		if (configurers.size() &gt; 1) {			throw new IllegalStateException("Only one AsyncConfigurer may exist");		}		AsyncConfigurer configurer = configurers.iterator().next();		this.executor = configurer.getAsyncExecutor();		this.exceptionHandler = configurer.getAsyncUncaughtExceptionHandler();	}</pre><ol><li>ProxyAsyncConfiguration注入的bean AsyncAnnotationBeanPostProcessor,這個BeanPostBeanPostProcessor很顯然會對帶有能夠引發異步操作的註解（比如@Async）的Bean進行處理</li><li>我們注意到AsyncAnnotationBeanPostProcessor有重寫父類的setBeanFactory，這個方法是不是有點熟悉呢，它是BeanFactoryAware接口中的方法，AsyncAnnotationBeanPostProcessor的父類實現了這個接口，在我們很久之前分析過的Bean的初始化中，是有提到過這個接口的，實現了Aware類型接口的Bean，會在初始化Bean的時候調用相應的初始化方法，具體可以查看AbstractAutowireCapableBeanFactory#initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)方法</li><li>處理Bean的postProcessAfterInitialization方法在祖先類AbstractAdvisingBeanPostProcessor中。從源碼中可以看到。AsyncAnnotationBeanPostProcessor是對Bean進行後置處理的BeanPostProcessor</li><li>最後代理到JdkDynamicAopProxy的invoke方法中,是用了責任鏈模式:List&lt;Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);,將代理進行攔截來執行,通知鏈會包含setBeanFactory()方法生成的通知,執行鏈會用於創建ReflectiveMethodInvocation對象，最終是調用ReflectiveMethodInvocation的proceed()來完成對方法的增強處理,proceed()方法在這裡會執行最後一個分支</li><li>具體執行的是AsyncExecutionInterceptor的invoke()</li><li><strong>注意</strong>:雖然上文Spring環境中只能有一個AsyncConfigurer實現類，但是不意味著，在Spring環境中只能配置一個線程池，在Spring環境中是可以配置多個線程池，而且我們可以在使用@Async註解進行異步操作的時候，通過在value屬性上指定線程池BeanName,這樣就可以指定相應的線程池來作為任務的載體,參見:determineAsyncExecutor</li></ol><p><strong>小結兄弟:</strong></p><p>當我們想要在SpringBoot中方便的使用@Async註解開啟異步操作的時候，只需要實現AsyncConfigurer接口（這樣就配置了默認線程池配置，當然該類需要在Spring環境中，因為是默認的，所以只能有一個，沒有多個實現類排優先級的說法），實現對線程池的配置，並在啟動類上加上@EnableAsync註解，即可使得@Async註解生效。</p><p>我們甚至可以不顯式的實現AsyncConfigurer，我們可以在Spring環境中配置多個Executor類型的Bean，在使用@Async註解時，將註解的value指定為你Executor類型的BeanName，就可以使用指定的線程池來作為任務的載體，這樣就使用線程池也更加靈活。</p><p><strong>參考資料</strong></p><p>[1]</p><p>你的@Async就真的異步嗎 ☞ 異步歷險奇遇記: <em>https://juejin.im/post/5d47a80a6fb9a06ad3470f9a</em></p><p>[2]</p><p>JAVA併發異步編程 原來十個接口的活現在只需要一個接口就搞定!: <em>https://juejin.im/post/5d3c46d2f265da1b9163dbce</em></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>異步</a></li><li><a>Spring</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面編程AOP的初步瞭解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面編程AOP的初步瞭解>Spring面向切面編程AOP的初步瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面編程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面編程需要知道的事">Spring AOP 面向切面編程需要知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html alt=Spring—面向切面編程（AOP）詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html title=Spring—面向切面編程（AOP）詳解>Spring—面向切面編程（AOP）詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html alt=Spring面向切面編程的AOP的事務增強完整版的配置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html title=Spring面向切面編程的AOP的事務增強完整版的配置>Spring面向切面編程的AOP的事務增強完整版的配置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html alt="Spring：AOP 面向切面編程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html title="Spring：AOP 面向切面編程">Spring：AOP 面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用註解方式配置Spring中的面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用註解方式配置Spring中的面向切面編程AOP>使用註解方式配置Spring中的面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f29dcd0.html alt=使用Spring進行面向切面編程（AOP） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b09bdd90d1394d74a47e1c0363fd950a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f29dcd0.html title=使用Spring進行面向切面編程（AOP）>使用Spring進行面向切面編程（AOP）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd08b19.html alt=異步編程：協作性多任務處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/dbd0ddd7-eda4-430a-8176-da9804319771 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd08b19.html title=異步編程：協作性多任務處理>異步編程：協作性多任務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html alt="Java 異步編程導論" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3c356b1aa9b4416ca7b35a07f3033e13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html title="Java 異步編程導論">Java 異步編程導論</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ff10d3.html alt="Spring Boot 異步請求和異步調用，一文搞定" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3c824262b5b0401cbf72463bf246c13b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ff10d3.html title="Spring Boot 異步請求和異步調用，一文搞定">Spring Boot 異步請求和異步調用，一文搞定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/852c87e.html alt="有了 CompletableFuture，使得異步編程沒有那麼難了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e66a7bcfded64b34b43ebc1565b3e557 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/852c87e.html title="有了 CompletableFuture，使得異步編程沒有那麼難了">有了 CompletableFuture，使得異步編程沒有那麼難了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e8c3b8.html alt=詳解編程中的同步和異步 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b292fb03b256422bb94215ce3ec3bbaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e8c3b8.html title=詳解編程中的同步和異步>詳解編程中的同步和異步</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a0dfd7.html alt="異步編程實例：Java8 API的理解和CompletableFuture類的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522150125651deaa9d51b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a0dfd7.html title="異步編程實例：Java8 API的理解和CompletableFuture類的實現">異步編程實例：Java8 API的理解和CompletableFuture類的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c81ec36.html alt=異步編程提升服務性能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15260210063976700d35c2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c81ec36.html title=異步編程提升服務性能>異步編程提升服務性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>