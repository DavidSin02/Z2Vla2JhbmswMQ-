<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java容器詳解 | 极客快訊</title><meta property="og:title" content="Java容器詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/73c142f92e9348a9b54add71b20d7039"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d4188ef.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d4188ef.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d4188ef.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d4188ef.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d4188ef.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d4188ef.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d4188ef.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d4188ef.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="Java容器詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4d4188ef.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java容器詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>一、容器的概念</p><p>1. 什麼是容器</p><p>在Java當中，有一個類專門用來存放其它類的對象，這個類就叫做容器，它就是將若干性質相同或相近的類對象組合在一起而形成的一個整體 。</p><p>2. 常用的Java</p><div class=pgc-img><img alt=Java容器詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/73c142f92e9348a9b54add71b20d7039><p class=pgc-img-caption></p></div><p>容器二、List，Map，Set，Queue</p><p>1. List</p><p>有序的 collection(也稱為序列)。此接口的用戶可以對列表中每個元素的插入位置進行精確地控制。用戶可以根據元素的整數索引（在列表中的位置）訪問元素，並搜索列表中的元素。與 set 不同，列表通常允許重複的元素。</p><p>Arraylist： Object數組</p><p>Vector： Object數組</p><p>LinkedList： 雙向鏈表(JDK1.6之前為循環鏈表，JDK1.7取消了循環)</p><p>2. Set</p><p>一個不包含重複元素的 collection。更確切地講，set 不包含滿足 e1.equals(e2) 的元素對 e1 和 e2，並且最多包含一個 null 元素。正如其名稱所暗示的，此接口模仿了數學上的 set 抽象。</p><p>HashSet（無序，唯一）: 基於 HashMap 實現的，底層採用 HashMap 來保存元素</p><p>LinkedHashSet： LinkedHashSet 繼承與 HashSet，並且其內部是通過 LinkedHashMap 來實現的。有點類似於我們之前說的LinkedHashMap 其內部是基於 Hashmap 實現一樣，不過還是有一點點區別的。</p><p>TreeSet（有序，唯一）： 紅黑樹(自平衡的排序二叉樹。)</p><p>3. Map</p><p>將鍵映射到值的對象。一個映射不能包含重複的鍵；每個鍵最多隻能映射到一個值。</p><p>HashMap： JDK1.8之前HashMap由數組+鏈表組成的，數組是HashMap的主體，鏈表則是主要為了解決哈希衝突而存在的（“拉鍊法”解決衝突）。JDK1.8以後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間</p><p>LinkedHashMap： LinkedHashMap 繼承自 HashMap，所以它的底層仍然是基於拉鍊式散列結構即由數組和鏈表或紅黑樹組成。另外，LinkedHashMap 在上面結構的基礎上，增加了一條雙向鏈表，使得上面的結構可以保持鍵值對的插入順序。同時通過對鏈表進行相應的操作，實現了訪問順序相關邏輯。</p><p>Hashtable： 數組+鏈表組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的。</p><p>TreeMap： 紅黑樹（自平衡的排序二叉樹）</p><p>4. Queue</p><p>在處理元素前用於保存元素的collection。除了基本的 Collection 操作外，隊列還提供其他的插入、提取和檢查操作。</p><p>5. List Set Map的區別</p><p>List(對付順序的好幫手)： List接口存儲一組不唯一（可以有多個元素引用相同的對象），有序的對象；</p><p>Set(注重獨一無二的性質): 不允許重複的集合。不會有多個元素引用相同的對象。；</p><p>Map(用Key來搜索的專家): 使用鍵值對存儲。Map會維護與Key有關聯的值。兩個Key可以引用相同的對象，但Key不能重複，典型的Key是String類型，但也可以是任何對象。</p><p>三、ArrayList，LinkedList，Vector</p><p>1. ArrayList概念</p><p>public class ArrayList&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, Serializable</p><p>ArrayList 的底層是數組隊列，相當於動態數組。與 Java 中的數組相比，它的容量能動態增長。在添加大量元素前，應用程序可以使用ensureCapacity操作來增加 ArrayList 實例的容量，這可以減少遞增式再分配的數量。</p><p>它繼承於 AbstractList，實現了 List, RandomAccess, Cloneable, java.io.Serializable 這些接口。</p><p>ArrayList 繼承了AbstractList，實現了List。它是一個數組隊列，提供了相關的添加、刪除、修改、遍歷等功能。</p><p>ArrayList 實現了RandomAccess 接口， RandomAccess 是一個標誌接口，表明實現這個這個接口的 List 集合是支持快速隨機訪問的。在 ArrayList 中，我們即可以通過元素的序號快速獲取元素對象，這就是快速隨機訪問。</p><p>ArrayList 實現了Cloneable 接口，即覆蓋了函數 clone()，能被克隆。</p><p>ArrayList 實現java.io.Serializable 接口，這意味著ArrayList支持序列化，能通過序列化去傳輸。</p><p>和 Vector 不同，ArrayList 中的操作不是線程安全的！所以，建議在單線程中才使用 ArrayList，而在多線程中可以選擇 Vector 或者 CopyOnWriteArrayList。</p><p>2. LinkedList概念</p><p>public class LinkedList&lt;E> extends AbstractSequentialList&lt;E> implements List&lt;E>, Deque&lt;E>, Cloneable, Serializable</p><p>LinkedList是一個實現了 List接口 和 Deque接口 的雙端鏈表。</p><p>LinkedList底層的鏈表結構使它支持高效的插入和刪除操作，另外它實現了Deque接口，使得LinkedList類也具有隊列的特性。</p><p>LinkedList不是線程安全的，如果想使其變成線程安全，可以調用靜態類Collections類中的synchronizedList方法：</p><p>List list=Collections.synchronizedList(new LinkedList(...));</p><p>內部結構分析:</p><p>如下圖所示：</p><div class=pgc-img><img alt=Java容器詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1c861d6cff50462eaae78dad04e6079a><p class=pgc-img-caption></p></div><p>看完了圖之後，我們再看LinkedList類中的一個內部私有類Node就很好理解了：</p><pre>private static class Node&lt;E&gt; { E item;//節點值 Node&lt;E&gt; next;//後繼節點 Node&lt;E&gt; prev;//前驅節點 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } }</pre><p>這個類就代表雙端鏈表的節點Node。這個類有三個屬性，分別是前驅節點，本節點的值，後繼結點。</p><p>3. Vector概念</p><p>public class Vector&lt;E> extends AbstractList&lt;E> implements List&lt;E>, RandomAccess, Cloneable, Serializable</p><p>Vector 類可以實現可增長的對象數組。與數組一樣，它包含可以使用整數索引進行訪問的組件。但是Vector 的大小可以根據需要增大或縮小，以適應創建 Vector 後進行添加或移除項的操作。</p><p>Vector 是同步的。</p><p>四、ArrayList，LinkedList，Vector常見面試題</p><p>1. Arraylist 與 LinkedList 有什麼區別？</p><p>1. 是否保證線程安全： ArrayList 和 LinkedList 都是不同步的，也就是都不保證線程安全；</p><p>2. 底層數據結構： Arraylist 底層使用的是 Object 數組；LinkedList 底層使用的是 雙向鏈表 數據結構（JDK1.6之前為循環鏈表，JDK1.7取消了循環）；</p><p>3. 插入和刪除效率： ① ArrayList 採用數組存儲，所以插入和刪除元素的時間複雜度受元素位置的影響。 比如：執行add(E e)方法的時候， ArrayList 會默認在將指定的元素追加到此列表的末尾，這種情況時間複雜度就是O(1)。但是如果要在指定位置 i 插入和刪除元素的話（add(int index, E element)）時間複雜度就為 O(n-i)。因為在進行上述操作的時候集合中第 i 和第 i 個元素之後的(n-i)個元素都要執行向後位/向前移一位的操作。 ② LinkedList 採用鏈表存儲，所以插入，刪除元素時間複雜度不受元素位置的影響，都是近似 O（1）而數組為近似 O（n）。</p><p>4. 是否支持快速隨機訪問： LinkedList 不支持高效的隨機元素訪問，而 ArrayList 支持。快速隨機訪問就是通過元素的序號快速獲取元素對象(對應於get(int index)方法)；</p><p>5. 內存空間佔用： ArrayList的空間浪費主要體現在在list列表的結尾會預留一定的容量空間，而LinkedList的空間花費則體現在它的每一個元素都需要消耗比ArrayList更多的空間（因為要存放直接後繼和直接前驅以及數據）。</p><p>下面再總結一下Arraylist 與 LinkedList的場景選擇：</p><p>綜合來說，在需要頻繁讀取集合中的元素時，更推介使用ArrayList，而在插入和刪除操作較多時，更推介使用LinkedList。2. ArrayList 與 Vector 的區別是什麼?</p><p>Vector類的所有方法都是同步的。可以由兩個線程安全地訪問一個Vector對象、但是一個線程訪問Vector的話代碼要在同步操作上耗費大量的時間。Arraylist不是同步的，所以在不需要保證線程安全時建議使用Arraylist。即：</p><p>線程安全：Vector 使用了 Synchronized 來實現線程同步，是線程安全的，而 ArrayList 是非線程安全的；</p><p>性能：ArrayList 在性能方面要優於 Vector。</p><p>五、HashMap，Hashtable，TreeMap</p><p>1. HashMap概念</p><p>HashMap&lt;K,V> extends AbstractMap&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable</p><p>HashMap 主要用來存放鍵值對，它基於哈希表的Map接口實現，是常用的Java集合之一。</p><p>JDK1.8 之前 HashMap 由 數組+鏈表 組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的（"拉鍊法"解決衝突）。JDK1.8 以後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為 8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><p>JDK1.8 之前 HashMap 底層是 數組和鏈表 結合在一起使用也就是 鏈表散列。HashMap 通過 key 的 hashCode 經過擾動函數處理過後得到 hash 值，然後通過 (n - 1) & hash 判斷當前元素存放的位置（這裡的 n 指的是數組的長度），如果當前位置存在元素的話，就判斷該元素與要存入的元素的 hash 值以及 key 是否相同，如果相同的話，直接覆蓋，不相同就通過拉鍊法解決衝突。</p><p>所謂擾動函數指的就是 HashMap 的 hash 方法。使用 hash 方法也就是擾動函數是為了防止一些實現比較差的 hashCode() 方法，換句話說使用擾動函數之後可以減少碰撞。</p><p>所謂 “拉鍊法” 就是：將鏈表和數組相結合。也就是說創建一個鏈表數組，數組中每一格就是一個鏈表。若遇到哈希衝突，則將衝突的值加到鏈表中即可。</p><div class=pgc-img><img alt=Java容器詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f367abf7e93f4924a2c99c3c33968dcf><p class=pgc-img-caption></p></div><p>相比於之前的版本，JDK1.8在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><div class=pgc-img><img alt=Java容器詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0f6cd5eb326447358a8c1ef9c50f9783><p class=pgc-img-caption></p></div><p>2. Hashtable概念</p><p>public class Hashtable&lt;K,V> extends Dictionary&lt;K,V> implements Map&lt;K,V>, Cloneable, Serializable</p><p>此類實現一個哈希表，該哈希表將鍵映射到相應的值。任何非 null 對象都可以用作鍵或值。</p><p>Hashtable 是同步的。</p><p>HashMap類大致相當於Hashtable ，除了它是不同步的，並允許null。</p><p>3. TreeMap概念</p><p>public class TreeMap&lt;K,V> extends AbstractMap&lt;K,V> implements NavigableMap&lt;K,V>, Cloneable, Serializable</p><p>基於紅黑樹(Red-Black tree)的 NavigableMap實現。該映射根據其鍵的自然順序進行排序，或者根據創建映射時提供的 Comparator 進行排序，具體取決於使用的構造方法。</p><p>此實現為 containsKey、get、put 和 remove 操作提供受保證的log(n)時間開銷。這些算法是 Cormen、Leiserson 和 Rivest 的 Introduction to Algorithms 中的算法的改編。</p><p>注意，此實現不是同步的。如果多個線程同時訪問一個映射，並且其中至少一個線程從結構上修改了該映射，則其必須外部同步。</p><p>五、HashMap，Hashtable，TreeMap常見面試題</p><p>1. HashMap 和 Hashtable 有什麼區別？</p><p>線程是否安全： HashMap 是非線程安全的，HashTable 是線程安全的；因為HashTable 內部的方法基本都經過synchronized 修飾。（如果你要保證線程安全的話就使用 ConcurrentHashMap 吧！）；</p><p>效率： 因為線程安全的問題，HashMap 要比 HashTable 效率高一點。另外，HashTable 基本被淘汰，不要在代碼中使用它；</p><p>對Null key 和Null value的支持： HashMap 中，null 可以作為鍵，這樣的鍵只有一個，可以有一個或多個鍵所對應的值為 null。但是在 HashTable 中 put 進的鍵值只要有一個 null，直接拋出 NullPointerException；</p><p>初始容量大小和每次擴充容量大小的不同 ： 創建時如果不指定容量初始值，HashMap 默認的初始化大小為16，之後每次擴充，容量變為原來的2倍。Hashtable 默認的初始大小為11，之後每次擴充，容量變為原來的2n+1；</p><p>底層數據結構： JDK1.8 以後的 HashMap 在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間，Hashtable 沒有這樣的機制。</p><p>下面這個方法保證了 HashMap 總是使用2的冪作為哈希表的大小。</p><pre> /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }</pre><p>2. ConcurrentHashMap</p><p>底層數據結構： JDK1.8 的 ConcurrentHashMap 底層採用的數據結構跟HashMap1.8的結構一樣，數組+鏈表/紅黑二叉樹；</p><p>實現線程安全的方式（重要）： 到了 JDK1.8 後ConcurrentHashMap（分段鎖）已經摒棄了Segment的概念，而是直接用 Node 數組+鏈表+紅黑樹的數據結構來實現，併發控制使用 synchronized 和 CAS 來操作。（JDK1.6以後 對 synchronized鎖做了很多優化） 整個看起來就像是優化過且線程安全的 HashMap，雖然在JDK1.8中還能看到 Segment 的數據結構，但是已經簡化了屬性，只是為了兼容舊版本。</p><p>兩者的對比圖：</p><p>JDK1.8的ConcurrentHashMap（TreeBin: 紅黑二叉樹節點 Node: 鏈表節點）：</p><div class=pgc-img><img alt=Java容器詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/01974c23106b4416b3d85aead0c8415b><p class=pgc-img-caption></p></div><p>ConcurrentHashMap取消了Segment分段鎖，採用CAS和synchronized來保證併發安全。數據結構跟HashMap1.8的結構類似，數組+鏈表/紅黑二叉樹。Java 8在鏈表長度超過一定閾值（8）時將鏈表（尋址時間複雜度為O(N)）轉換為紅黑樹（尋址時間複雜度為O(log(N))）</p><p>synchronized只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要hash不衝突，就不會產生併發，效率又提升N倍。</p><p>3. HashMap的實現原理是什麼？</p><p>HashMap實現原理</p><p>4. HashMap是有序的還是無序的？</p><p>HashMap 的一個功能缺點就是它的無序性，被存入到 HashMap 中的元素，在遍歷 HashMap 時，其輸出是無序的。如果希望元素保持輸入的順序，可以使用 LinkedHashMap 替代。</p><p>LinkedHashMap 繼承自 HashMap，具有高效性，同時在 HashMap 的基礎上，又在內部增加了一個鏈表，用以存放元素的順序。</p><p>六、HashSet，TreeSet</p><p>1. HashSet概念</p><p>public class HashSet&lt;E> extends AbstractSet&lt;E> implements Set&lt;E>, Cloneable, Serializable</p><p>此類實現Set接口，由哈希表（實際為HashMap實例）支持。對集合的迭代次序不作任何保證，特別是它不能保證訂單在一段時間內保持不變。這個類允許null元素。</p><p>注意，此實現不是同步的。如果多個線程同時訪問一個哈希 set，而其中至少一個線程修改了該 set，那麼它必須保持外部同步。</p><p>2. TreeSet概念</p><p>public class TreeSet&lt;E> extends AbstractSet&lt;E> implements NavigableSet&lt;E>, Cloneable, Serializable</p><p>基於 TreeMap 的 NavigableSet 實現。使用元素的自然順序對元素進行排序，或者根據創建 set 時提供的 Comparator 進行排序，具體取決於使用的構造方法。</p><p>此實現為基本操作（add、remove 和 contains）提供受保證的 log(n) 時間開銷。</p><p>注意，此實現不是同步的。如果多個線程同時訪問一個 TreeSet，而其中至少一個線程修改了該 set，那麼它必須 外部同步。</p><p>3. HashMap 和 HashSet區別</p><p>HashSet 底層就是基於 HashMap 實現的。（HashSet 的源碼非常非常少，因為除了 clone()、writeObject()、readObject()是 HashSet 自己不得不實現之外，其他方法都是直接調用 HashMap 中的方法。</p><div class=pgc-img><img alt=Java容器詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4f3309e85f4945a88db7409a7d302a82><p class=pgc-img-caption></p></div><p>4. HashSet如何檢查重複？</p><p>當把對象加入HashSet時，HashSet會先計算對象的hashcode值來判斷對象加入的位置，同時也會與其他加入的對象的hashcode值作比較，如果沒有相符的hashcode，HashSet會假設對象沒有重複出現。但是如果發現有相同hashcode值的對象，這時會調用equals()方法來檢查hashcode相等的對象是否真的相同。如果兩者相同，HashSet就不會讓加入操作成功。七、對集合的操作</p><p>1. Java針對ArrayList自定義排序的2種實現方法</p><p>1）讓需要進行排序的對象的類實現Comparable接口，重寫compareTo(To)方法，在其中定義排序規則，然後就可以直接調用Collections.sort()來排序對象數組。</p><pre>public class Student implements Comparable{ ...... @Override public int compareTo(Object o) { ...... } }</pre><pre>public class Test { public static void main(String[] args) { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(1, "A", 20, 180)); list.add(new Student(2, "B", 21, 175)); list.add(new Student(3, "C", 22, 190)); list.add(new Student(4, "D", 21, 170)); Collections.sort(list); ...... } }</pre><p>2）實現比較器接口Comparator，重寫compare方法，直接當做參數傳進sort中。</p><pre>public class Test { public static void main(String[] args) { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); list.add(new Student(1, "A", 20, 180)); list.add(new Student(2, "B", 21, 175)); list.add(new Student(3, "C", 22, 190)); list.add(new Student(4, "D", 21, 170)); list.add(new Student(5, "E", 20, 185));  Collections.sort(list, new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { if(o1.getAge() &gt;= o2.getAge()) { return 1; } else { return -1; } } }); ...... }  }</pre><p>2. Java中List去重</p><pre>// 創建一個ArrayList 包含兩個相同元素"111" List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("111"); list.add("111"); list.add("222");</pre><p>使用Set集合特性</p><pre>// 創建HashSet集合 Set set = new HashSet(); set.addAll(list); // 將list所有元素添加到set中 set集合特性會自動去重複 list.clear(); list.addAll(set); // 將list清空並將set中的所有元素添加到list中</pre><p>使用java8 stream api</p><p>// Collectors.toList方法是獲取list類型的收集器 distinct方法進行去重 collect進行轉換</p><p>// list2就是去重後得到的結果，可以看出java8的stream api使用很方便。</p><p>List&lt;Object> list2 = list.stream().distinct().collect(Collectors.toList());</p><p>3. Java中集合如何遍歷時刪除數據？</p><p>使用官方推薦的Iterator迭代器提供的Iterator.remove方法在遍歷集合時刪除集合元素；</p><p>使用Java 8新增的removeIf方法在遍歷集合時刪除集合元素。</p><pre>public static void iteratorRemove() { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= LIST_SIZE; i++) { list.add(new Student(i, "Student" + i)); } Iterator&lt;Student&gt; iterator = list.iterator(); long millionSeconds = System.currentTimeMillis(); while (iterator.hasNext()) { Student student = iterator.next(); if (student.getId() % CONDITION_NUM == 0) { iterator.remove(); } } System.out.println("iteratorRemove操作耗時：" + (System.currentTimeMillis() - millionSeconds)); } /** * 也可以使用Java 8新增的removeIf方法在遍歷時刪除List中的元素，該方法也使用Iterator了，所以刪除是安全的 */ public static void ifRemove() { List&lt;Student&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= LIST_SIZE; i++) { list.add(new Student(i, "Student" + i)); } long millionSeconds = System.currentTimeMillis(); list.removeIf(student -&gt; student.getId() % CONDITION_NUM == 0); System.out.println("ifRemove操作耗時：" + (System.currentTimeMillis() - millionSeconds)); }</pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>詳解</a></li><li><a>容器</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48f7c5e6.html alt=Java工具類教程：詳解正則表達式及應用示例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/4002000140fde581089b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48f7c5e6.html title=Java工具類教程：詳解正則表達式及應用示例>Java工具類教程：詳解正則表達式及應用示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/616d5c2c.html alt=詳解Java輸入輸出數據流模型和Web應用程序開發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/64b3228d-a726-45da-aa12-32b204d6fdd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/616d5c2c.html title=詳解Java輸入輸出數據流模型和Web應用程序開發>詳解Java輸入輸出數據流模型和Web應用程序開發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html alt=Java集合詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d86fadc20bed4a69ad6bf811308371d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html title=Java集合詳解>Java集合詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html alt=詳解Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/88a6dd8200454e0eb96a868562c38b4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html title=詳解Java多態>詳解Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>