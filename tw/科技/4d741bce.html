<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>有一說一！SpringAOP+源碼解析，切就完事了 | 极客快訊</title><meta property="og:title" content="有一說一！SpringAOP+源碼解析，切就完事了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/965c060c22b942c1a3a9f143215f114c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="有一說一！SpringAOP+源碼解析，切就完事了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4d741bce.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>有一說一！SpringAOP+源碼解析，切就完事了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、AOP、SpringAOP、AspectJ的區別</h1><p>AOP為Aspect Oriented Programming的縮寫，意為：<strong>面向切面編程</strong>，通過<strong>預編譯方式和運行期間動態代理</strong>實現程序功能的統一維護的一種技術。利用AOP可以<strong>對業務邏輯的各個部分進行隔離</strong>，從而使得業務邏輯各部分之間的耦合度降低，提高程序的可重用性，同時提高了開發的效率。</p><p>文有文的，沒用過確實很懵，但是用過之後，不說清晰，起碼有點意思了。</p><blockquote><p>Spring AOP：</p><p>它基於動態代理來實現。默認的，如果使用接口的，用 JDK 提供的動態代理實現，如果沒有接口，使用 CGLIB 實現。大家一定要明白背後的意思，包括什麼時候會不用 JDK 提供的動態代理，而用 CGLIB 實現。Spring 3.2 以後，spring-core 直接就把 CGLIB 和 ASM 的源碼包括進來了，這也是為什麼我們不需要顯式引入這兩個依賴Spring 的 IOC 容器和 AOP 都很重要，Spring AOP 需要依賴於 IOC 容器來管理。如果你是 web 開發者，有些時候，你可能需要的是一個 Filter 或一個 Interceptor，而不一定是 AOP。Spring AOP 只能作用於 Spring 容器中的 Bean，它是使用純粹的 Java 代碼實現的，只能作用於 bean 的方法。Spring 提供了 AspectJ 的支持，後面我們會單獨介紹怎麼使用，一般來說我們用純的 Spring AOP 就夠了。很多人會對比 Spring AOP 和 AspectJ 的性能，Spring AOP 是基於代理實現的，在容器啟動的時候需要生成代理實例，在方法調用上也會增加棧的深度，使得 Spring AOP 的性能不如 AspectJ 那麼好。</p><p>AspectJ：</p><p>AspectJ 出身也是名門，來自於 Eclipse 基金會，link：https://www.eclipse.org/aspectj</p><p>屬於靜態植入，它是通過修改代碼來實現的，它的植入時機可以是：</p><p>Compile-time weaving：編譯期織入，如類 A 使用 AspectJ 添加了一個屬性，類 B 引用了它，這個場景就需要編譯器的時候就進行植入，否則沒法編譯類 B。Post-compile weaving：也就是已經生成了 .class 文件，或已經達成 jar 包了，這種情況我們需要增強處理的話，就要用到編譯後織入。Load-time weaving：指的是在加載類的時候進行織入，要實現這個時期的織入，有幾種常見的方法。1、自定義類加載器來幹這個，這個應該是最容易想到的辦法，在被織入類加載到 JVM 前去對它進行加載，這樣就可以在加載的時候定義行為了。2、在 JVM 啟動的時候指定 AspectJ 提供的 agent：-javaagent:xxx/xxx/aspectjweaver.jar。</p><p>AspectJ 能幹很多 Spring AOP 幹不了的事情，它是 AOP 編程的完全解決方案。Spring AOP 致力於解決的是企業級開發中最普遍的 AOP 需求（方法織入），而不是力求成為一個像 AspectJ 一樣的 AOP 編程完全解決方案。</p><p>因為 AspectJ 在實際代碼運行前完成了植入，所以大家會說它生成的類是沒有額外運行時開銷的。</p></blockquote><h1 class=pgc-h-arrow-right><strong>二、AOP關鍵術語</strong></h1><div class=pgc-img><img alt=有一說一！SpringAOP+源碼解析，切就完事了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/965c060c22b942c1a3a9f143215f114c><p class=pgc-img-caption></p></div><ul><li>切面（Aspect）：也就是我們定義的專注於提供輔助功能的模塊，比如安全管理，日誌信息等。</li><li>連接點（JoinPoint）：切面代碼可以通過連接點切入到正常業務之中，圖中每個方法的每個點都是連接點。</li><li>切入點（PointCut）：一個切面不需要通知所有的連接點，而<strong>在連接點的基礎之上增加切入的規則</strong>，選擇需要增強的點，最終真正通知的點就是切入點。</li><li>通知方法（Advice）：就是切面需要執行的工作，主要有五種通知：before，after，afterReturning，afterThrowing，around。</li><li>織入（Weaving）：將切面應用到目標對象並創建代理對象的過程，SpringAOP選擇在目標對象的運行期動態創建代理對</li><li>引入（introduction）：在不修改代碼的前提下，引入可以在運行期為類動態地添加方法或字段。</li></ul><h1 class=pgc-h-arrow-right><strong>三、通知的五種類型</strong></h1><ul><li>前置通知Before：目標方法調用之前執行的通知。</li><li>後置通知After：目標方法完成之後，無論如何都會執行的通知。</li><li>返回通知AfterReturning：目標方法成功之後調用的通知。</li><li>異常通知AfterThrowing：目標方法拋出異常之後調用的通知。</li><li>環繞通知Around：可以看作前面四種通知的綜合。</li></ul><h1 class=pgc-h-arrow-right><strong>四、切入點表達式</strong></h1><p>上面提到：連接點增加切入規則就相當於定義了切入點，當然切入點表達式分為兩種：within和execution，這裡主要學習execution表達式。</p><ul><li>寫法：execution(訪問修飾符 返回值 包名.包名……類名.方法名(參數列表))</li><li>例：execution(public void com.smday.service.impl.AccountServiceImpl.saveAccount())</li><li>訪問修飾符可以省略，返回值可以使用通配符*匹配。</li><li>包名也可以使用*匹配，數量代表包的層級，當前包可以使用..標識，例如* *..AccountServiceImpl.saveAccount()</li><li>類名和方法名也都可以使用*匹配：* *..*.*()</li><li>參數列表使用..可以標識有無參數均可，且參數可為任意類型。</li></ul><blockquote><p>全通配寫法：* *…*.*(…)</p></blockquote><p>通常情況下，切入點應當設置在業務層實現類下的所有方法：* com.smday.service.impl.*.*(..)。</p><h1 class=pgc-h-arrow-right><strong>五、AOP應用場景</strong></h1><ul><li>記錄日誌</li><li>監控性能</li><li>權限控制</li><li>事務管理</li></ul><h1 class=pgc-h-arrow-right><strong>六、AOP源碼分析</strong></h1><h1 class=pgc-h-arrow-right><strong>SpringBean的生命週期</strong></h1><p>寫了好多篇文章，每次都要來回顧一下SpringBean的生命週期，可見它真的十分重要。</p><ul><li>Spring的完整生命週期。</li><li>Spring解決循環依賴，對實例化之後，初始化之前動了手腳。</li></ul><p>Spring的Aop又是在哪完成的對目標對象的代理呢？我們大概也能夠想到，其實就是在執行回調的時候。按照慣例，先複習一下，從getBean開始到返回Bean經歷了什麼：</p><div class=pgc-img><img alt=有一說一！SpringAOP+源碼解析，切就完事了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7b40b58f048d4a25a0eee21e8e3aeace><p class=pgc-img-caption></p></div><p>回顧完SpringBean的創建流程之後，我們以註解方式@EnableAspectJAutoProxy配置Aop開啟@Aspectj為例，進行一波AOP的流程總結：</p><h1 class=pgc-h-arrow-right><strong>AOP的流程總結</strong></h1><p>通過源碼可以發現，其實是通過@EnableAspectJAutoProxy註解注入了一個AnnotationAwareAspectJAutoProxyCreator，但這個類中其實並沒有重寫postProcessAfterInitialization()，最終實現其實是在AbstractAutoProxyCreator中。</p><p>具體乾的事情，我已經通過一張圖總結出來了，如果想要了解更加具體的信息，不妨打開源碼，可以看的更加清晰一些。</p><div class=pgc-img><img alt=有一說一！SpringAOP+源碼解析，切就完事了 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/58d5f2744d3d4b7a9beecbc7f80de87e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>AnnotationAwareAspectJAutoProxyCreator的註冊</strong></h1><p>首先是對AnnotationAwareAspectJAutoProxyCreator的註冊環節：【在此不作贅述】</p><pre><code>class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser {    @Override    @Nullable     // 1. 註冊proxy creator    public BeanDefinition parse(Element element, ParserContext parserContext) {    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);        extendBeanDefinition(element, parserContext);        return null;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>applyBeanPostProcessorsAfterInitialization入口</strong></h1><p>AbstractAutowireCapableBeanFactory.java</p><pre><code>protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {    //如果bean實現了BeanNameAware、BeanClassLoaderAware、BeanFactoryAware接口, 回調    invokeAwareMethods(beanName, bean);    Object wrappedBean = bean;    //aop在init-method之前並沒有進行操作, 目前還是原來那個對象    if (mbd == null || !mbd.isSynthetic()) {        //BeanPostProcessor 的 postProcessBeforeInitialization 回調        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    }     //處理bean中定義的init-method或 bean實現了InitializingBean ,調用afterPropertiesSet() 方法    invokeInitMethods(beanName, wrappedBean, mbd);    if (mbd == null || !mbd.isSynthetic()) {        //BeanPostProcessor 的 postProcessAfterInitialization 回調 注意這裡！        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    }    return wrappedBean;}</code></pre><pre><code>@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)    throws BeansException {    Object result = existingBean;    for (BeanPostProcessor processor : getBeanPostProcessors()) {        //AnnotationAwareAspectJAutoProxyCreator        Object current = processor.postProcessAfterInitialization(result, beanName);        if (current == null) {            return result;        }        result = current;    }    return result;//返回[可能代理後的]結果}</code></pre><h1 class=pgc-h-arrow-right><strong>AbstractAutoProxyCreator的主要方法</strong></h1><pre><code>//SpringAop在IOC容器創建bean實例的最後對bean進行處理,進行代理增強, AbstractAutoProxyCreato	@Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {    if (bean != null) {        Object cacheKey = getCacheKey(bean.getClass(), beanName);        if (this.earlyProxyReferences.remove(cacheKey) != bean) {            return wrapIfNecessary(bean, beanName, cacheKey);//這個方法將返回代理類        }    }    return bean;}</code></pre><pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {    //返回匹配當前bean 的所有的advisor, advice, interceptor    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.put(cacheKey, Boolean.TRUE);        //在這裡創建代理        Object proxy = createProxy(            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }    this.advisedBeans.put(cacheKey, Boolean.FALSE);    return bean;}</code></pre><h1 class=pgc-h-arrow-right><strong>createProxy過程</strong></h1><pre><code>protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,@Nullable Object[] specificInterceptors, TargetSource targetSource) {	//創建ProxyFactory實例    ProxyFactory proxyFactory = new ProxyFactory();    proxyFactory.copyFrom(this);	//在schema-based配置方式裡,可以將 proxy-target-class="true",這樣不管有沒有接口都使用cglib    if (!proxyFactory.isProxyTargetClass()) {        if (shouldProxyTargetClass(beanClass, beanName)) {            proxyFactory.setProxyTargetClass(true);        }        else {            evaluateProxyInterfaces(beanClass, proxyFactory);        }    }	//返回當前bean的advisors數組    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);    proxyFactory.addAdvisors(advisors); //設置advisors數組    proxyFactory.setTargetSource(targetSource);//targetSource 攜帶了真實實現的信息    customizeProxyFactory(proxyFactory);    proxyFactory.setFrozen(this.freezeProxy);    if (advisorsPreFiltered()) {        proxyFactory.setPreFiltered(true);    }    return proxyFactory.getProxy(getProxyClassLoader());//getProxy(getProxyClassLoader())這一步創建代理}</code></pre><h1 class=pgc-h-arrow-right><strong>JDK動態代理和CGLIB動態代理何時使用</strong></h1><p>這一步產生分歧的地方在ProxyFactory的getProxy方法，在getProxy之前，首先需要執行createAopProxy，而createAopProxy方法又被這個AopProxyFactory調用：</p><pre><code>protected final synchronized AopProxy createAopProxy() {    if (!this.active) {        activate();    }    //創建AopProxy之前,需要一個AopProxyFactory    return getAopProxyFactory().createAopProxy(this);}// ProxyCreatorSupport//這個aopProxyFactory用於創建aopProxy, 之後可以用aopProxy.getProxy(classLoader)創建代理public ProxyCreatorSupport() {    this.aopProxyFactory = new DefaultAopProxyFactory();}</code></pre><p>也就是最後會走到DefaultAopProxyFactory中</p><pre><code>@Overridepublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {        if (!IN_NATIVE_IMAGE &amp;&amp;         (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {        Class&lt;?&gt; targetClass = config.getTargetClass();        if (targetClass == null) {            throw new AopConfigException();        }        //如果要代理的類本身就是接口,使用JDK動態代理        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {            return new JdkDynamicAopProxy(config);        }        //jdk動態代理基於接口,只有接口中的方法才會被增強, cglib基於類繼承,如果方法使用了final或者private修飾,也不能增強        return new ObjenesisCglibAopProxy(config);    }    else {        // 如果有接口，會跑到這個分支        return new JdkDynamicAopProxy(config);    }}</code></pre><p>總結：</p><ul><li>如果被代理的目標實現了一個或多個自定義的接口，那麼就會使用JDK動態代理。</li><li>如果沒有實現任何接口，則使用CGLIB實現代理。</li><li>如果設置proxy-target-class=true或&lt;property name="proxyTargetClass" value="true"/>則不管有沒有實現接口都會使用CGLIB。</li></ul><h1 class=pgc-h-arrow-right><strong>七、JDK動態代理的實現</strong></h1><p>最終的最終，都會走到真正創建代理對象的流程上：</p><pre><code>@Overridepublic Object getProxy(@Nullable ClassLoader classLoader) {	//獲取代理接口    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);    //查找代理目標的接口是否定義equals和hashcode方法    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);    //使用jdk動態代理創建代理對象    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);}</code></pre><p>第一個參數：classLoader。</p><p>第二個參數：實現的接口。</p><p>第三個參數：InvocationHandler實例。</p><p>而本身JdkDynamicAopProxy本就實現了InvocationHandler，因此傳入this。至此，當調用被代理類的方法的時候，都會最終調用代理類實現的invoke方法，在這個方法中定義橫切的邏輯。</p><pre><code>public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}</code></pre><ul><li>proxy：代理對象的引用。</li><li>method：當前執行的方法。</li><li>args：當前執行方法所需的參數。</li><li>return：和被代理對象有相同的返回值。</li></ul><pre><code>@Override@Nullablepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 	//當生成的代理類對外提供服務的時候,都會導入到這個invoke方法中    Object oldProxy = null;    boolean setProxyContext = false;	    TargetSource targetSource = this.advised.targetSource;    Object target = null;    try {        if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {            // 對equals方法的代理            return equals(args[0]);        }        else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {            //對hashCode()方法的代理            return hashCode();        }        //...        Object retVal;		//如果設置了exposeProxy,將proxy放入ThreadLocal中        if (this.advised.exposeProxy) {             oldProxy = AopContext.setCurrentProxy(proxy);            setProxyContext = true;        }        // Get as late as possible to minimize the time we "own" the target,        // in case it comes from a pool.        target = targetSource.getTarget();        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);        // 獲取目標方法的攔截鏈，包含所有要執行的 advice        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);        // 檢查一下這個鏈上是不是有advice，如果沒有的話，可以跳過創建MethodInvocation        if (chain.isEmpty()) { //chain如果是空的,表示不需要被增強，直接調用目標方法            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);        }        else {            // 如果chain裡有advice 執行方法,得到返回值            MethodInvocation invocation =                new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);            //沿著攔截器鏈，執行通知            retVal = invocation.proceed();        }        // 對返回值的處理        Class&lt;?&gt; returnType = method.getReturnType();        if (retVal != null &amp;&amp; retVal == target &amp;&amp;            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {            retVal = proxy;        }        else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {            throw new AopInvocationException();        }        return retVal;    }    finally {        if (target != null &amp;&amp; !targetSource.isStatic()) {            // 釋放目標對象            targetSource.releaseTarget(target);        }        if (setProxyContext) {            // 存儲代理對象            AopContext.setCurrentProxy(oldProxy);        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>八、總結</strong></h1><blockquote><p>以@AspectJ註解方式為例</p></blockquote><ul><li>首先，依據&lt;aop:aspectj-autoproxy>或@EnableAspectJAutoProxy，Spring會在容器啟動的時候註冊名叫internalAutoProxyCreator的AnnotationAwareAspectJAutoProxyCreator。</li><li>在bean實例化完成，屬性裝配完成之後，開始執行回調方法，這時取出所有的BeanPostProcessor，執行其postProcessAfterInitialization方法，準備開始對目標對象代理的創建。</li><li>首先創建一個代理工廠ProxyFactory，設置一系列的屬性，如所有的通知方法，增強器，攔截器和目標類等注入代理工廠，再調用ProxyFactory.getProxy(classLoader)獲取代理。</li><li>通過判斷是用JDK動態代理還是CGLIB創建不同的AopProxy，最後獲取getProxy。</li></ul><p>如果感覺本文對你有幫助關注我一起學習進步！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>SpringAOP</a></li><li><a>源碼</a></li><li><a>完事</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html alt="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ab1d67934084ab6bd585f4c84094c76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html title="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究">thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbf8b0cf.html alt=Tomcat源碼分析之整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531465870453535efa0b79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbf8b0cf.html title=Tomcat源碼分析之整體架構>Tomcat源碼分析之整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07f82832.html alt="SynchronousQueue 同步隊列入門使用&源碼詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f76c27ed738844d099b011022d2e054f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07f82832.html title="SynchronousQueue 同步隊列入門使用&源碼詳解">SynchronousQueue 同步隊列入門使用&源碼詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html alt=我是如何閱讀JDK源碼的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25b18fb619994fcbaa58c5e28b7a4e51 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html title=我是如何閱讀JDK源碼的？>我是如何閱讀JDK源碼的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/59958e85.html alt=深入分析java集合框架Collection（源碼分析） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/43efff37d8ff43bc8553cc71e3b99b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/59958e85.html title=深入分析java集合框架Collection（源碼分析）>深入分析java集合框架Collection（源碼分析）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html alt=源碼分析：Java集合類的AbstractCollection源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html title=源碼分析：Java集合類的AbstractCollection源碼解析>源碼分析：Java集合類的AbstractCollection源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc3bb81.html alt=SpringAOP-什麼是面向切面編程？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/93af441322d4418ebbb68664166fb2ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc3bb81.html title=SpringAOP-什麼是面向切面編程？>SpringAOP-什麼是面向切面編程？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e130f24e.html alt=SpringAOP面向切面編程功能測試 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a9c9a71492a84ccc9a4d3722af071d5a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e130f24e.html title=SpringAOP面向切面編程功能測試>SpringAOP面向切面編程功能測試</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ea98537.html alt=源碼：太陽能路燈如何接線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c5ed2247de6949d89b9052d3fddd4921 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ea98537.html title=源碼：太陽能路燈如何接線>源碼：太陽能路燈如何接線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/769d1d2c04b9410aa18cd0add525013f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html title=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了>「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5561fb3.html alt=hdfs源碼分析第一彈 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cf716b17efaf49ae85d773a3f0ac1959 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5561fb3.html title=hdfs源碼分析第一彈>hdfs源碼分析第一彈</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/21ffd2dc.html alt="看vue3源碼可以學到什麼 : 四、代碼模版生成器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5fba6d3b32b5430d8caf459298bc5a06 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/21ffd2dc.html title="看vue3源碼可以學到什麼 : 四、代碼模版生成器">看vue3源碼可以學到什麼 : 四、代碼模版生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be1948c8.html alt=（深度解析）基於規則的中文複合事件抽取，附python源碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/97e3484c0f684ab1b639765267e34178 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be1948c8.html title=（深度解析）基於規則的中文複合事件抽取，附python源碼>（深度解析）基於規則的中文複合事件抽取，附python源碼</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>