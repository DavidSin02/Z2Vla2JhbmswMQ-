<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++ 一篇搞懂多態的實現原理 | 极客快訊</title><meta property="og:title" content="C++ 一篇搞懂多態的實現原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/01b75b1d55184a0b9209f0bc6ef053b3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="C++ 一篇搞懂多態的實現原理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4db23cf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++ 一篇搞懂多態的實現原理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>虛函數和多態</p><h2 class=pgc-h-arrow-right>01 虛函數</h2><pre><code>virtualvirtual</code></pre><pre><code>class Base {    virtual int Fun() ; // 虛函數};int Base::Fun() // virtual 字段不用在函數體時定義{ }</code></pre><h2 class=pgc-h-arrow-right>02 多態的表現形式一</h2><ul><li>「派生類的指針」可以賦給「基類指針」；</li><li>通過基類指針調用基類和派生類中的同名「虛函數」時:若該指針指向一個基類的對象，那麼被調用是基類的虛函數；若該指針指向一個派生類的對象，那麼被調用的是派生類的虛函數。</li></ul><p>這種機制就叫做“多態”，說白點就是 <strong>調用哪個虛函數，取決於指針對象指向哪種類型的對象</strong> 。</p><pre><code>// 基類class CFather {public:    virtual void Fun() { } // 虛函數};// 派生類class CSon : public CFather { public :    virtual void Fun() { }};int main() {    CSon son;    CFather *p = &amp;son;    p-&gt;Fun(); //調用哪個虛函數取決於 p 指向哪種類型的對象    return 0;}</code></pre><p>上例子中的 p 指針對象指向的是 CSon 類對象，所以 p->Fun() 調用的是 CSon 類裡的 Fun 成員函數。</p><h2 class=pgc-h-arrow-right>03 多態的表現形式二</h2><ul><li>派生類的對象可以賦給基類「引用」</li><li>通過基類引用調用基類和派生類中的同名「虛函數」時:若該引用引用的是一個基類的對象，那麼被調用是基類的虛函數；若該引用引用的是一個派生類的對象，那麼被調用的是派生類的虛函數。</li></ul><p>這種機制也叫做“多態”，說白點就是 <strong>調用哪個虛函數，取決於引用的對象是哪種類型的對象</strong> 。</p><pre><code>// 基類class CFather {public:    virtual void Fun() { } // 虛函數};// 派生類class CSon : public CFather { public :    virtual void Fun() { }};int main() {    CSon son;    CFather &amp;r = son;    r.Fun(); //調用哪個虛函數取決於 r 引用哪種類型的對象    return 0;}}</code></pre><p>上例子中的 r 引用的對象是 CSon 類對象，所以 r.Fun() 調用的是 CSon 類裡的 Fun 成員函數。</p><h2 class=pgc-h-arrow-right>04 多態的簡單示例</h2><pre><code>class A {public :    virtual void Print() { cout &lt;&lt; "A::Print"&lt;&lt;endl ; }};// 繼承A類class B: public A {public :    virtual void Print() { cout &lt;&lt; "B::Print" &lt;&lt;endl; }};// 繼承A類class D: public A {public:    virtual void Print() { cout &lt;&lt; "D::Print" &lt;&lt; endl ; }};// 繼承B類class E: public B {    virtual void Print() { cout &lt;&lt; "E::Print" &lt;&lt; endl ; }};</code></pre><p>A類、B類、E類、D類的關係如下圖：</p><div class=pgc-img><img alt="C++ 一篇搞懂多態的實現原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01b75b1d55184a0b9209f0bc6ef053b3><p class=pgc-img-caption></p></div><pre><code>int main() {    A a; B b; E e; D d;        A * pa = &amp;a;     B * pb = &amp;b;    D * pd = &amp;d;     E * pe = &amp;e;        pa-&gt;Print();  // a.Print()被調用，輸出：A::Print        pa = pb;    pa -&gt; Print(); // b.Print()被調用，輸出：B::Print        pa = pd;    pa -&gt; Print(); // d.Print()被調用，輸出：D::Print        pa = pe;    pa -&gt; Print(); // e.Print()被調用，輸出：E::Print        return 0;}</code></pre><h2 class=pgc-h-arrow-right>05 多態作用</h2><p>在面向對象的程序設計中使用「多態」，能夠增強程序的 <strong>可擴充性</strong> ，即程序需要修改或增加功能的時候，需要 <strong>改動和增加的代碼較少</strong> 。</p><h2 class=pgc-h-arrow-right>LOL 英雄聯盟遊戲例子</h2><p>下面我們用設計 LOL 英雄聯盟遊戲的英雄的例子，說明多態為什麼可以在修改或增加功能的時候，可以較少的改動代碼。</p><p>LOL 英雄聯盟是 5v5 競技遊戲，遊戲中有很多英雄，每種英雄都有一個「類」與之對應，每個英雄就是一個「對象」。</p><p>英雄之間能夠互相攻擊，攻擊敵人和被攻擊時都有相應的動作，動作是通過對象的成員函數實現的。</p><p>下面挑了五個英雄：</p><ul><li>探險家 CEzreal</li><li>蓋樓 CGaren</li><li>盲僧 CLeesin</li><li>無極劍聖 CYi</li><li>瑞茲 CRyze</li></ul><div class=pgc-img><img alt="C++ 一篇搞懂多態的實現原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/16e8ecdbee3c4ee99d52854d69547231><p class=pgc-img-caption></p></div><p>基本思路：</p><ol start=1><li>為每個英雄類編寫 Attack 、 FightBack 和 Hurted 成員函數。</li></ol><pre><code>AttackFightBackHurted</code></pre><ol start=1><li>設置基類 CHero ，每個英雄類都繼承此基類</li></ol><div class=pgc-img><img alt="C++ 一篇搞懂多態的實現原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4e6dc532a6814383a86b7d381e4be01e><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>02 非多態的實現方法</h2><pre><code>// 基類class CHero {protected:      int m_nPower ; //代表攻擊力    int m_nLifeValue ; //代表生命值};// 無極劍聖類class CYi : public CHero {public:    // 攻擊蓋倫的攻擊函數    void Attack(CGaren * pGaren)     {        .... // 表現攻擊動作的代碼        pGaren-&gt;Hurted(m_nPower);        pGaren-&gt;FightBack(this);    }    // 攻擊瑞茲的攻擊函數    void Attack(CRyze * pRyze)     {        .... // 表現攻擊動作的代碼        pRyze-&gt;Hurted(m_nPower);        pRyze-&gt;FightBack( this);    }        // 減少自身生命值    void Hurted(int nPower)     {        ... // 表現受傷動作的代碼        m_nLifeValue -= nPower;    }        // 反擊蓋倫的反擊函數    void FightBack(CGaren * pGaren)     {        ...．// 表現反擊動作的代碼        pGaren-&gt;Hurted(m_nPower/2);    }        // 反擊瑞茲的反擊函數    void FightBack(CRyze * pRyze)     {        ...．// 表現反擊動作的代碼        pRyze-&gt;Hurted(m_nPower/2);    }};</code></pre><p>有 n 種英雄， CYi 類中就會有 n 個 Attack 成員函數，以及 n 個 FightBack成員函數。對於其他類也如此。</p><p>如果遊戲版本升級，增加了新的英雄寒冰艾希 CAshe ，則程序改動較大。所有的類都需要增加兩個成員函數:</p><pre><code>void Attack(CAshe * pAshe);void FightBack(CAshe * pAshe);</code></pre><p>這樣工作量是非常大的！！非常的不人性，所以這種設計方式是非常的不好！</p><h2 class=pgc-h-arrow-right>03 多態的實現方式</h2><p>用多態的方式去實現，就能得知多態的優勢了，那麼上面的栗子改成多態的方式如下：</p><pre><code>// 基類class CHero {public:    virtual void Attack(CHero *pHero){}    virtual voidFightBack(CHero *pHero){}    virtual void Hurted(int nPower){}protected:      int m_nPower ; //代表攻擊力    int m_nLifeValue ; //代表生命值};// 派生類 CYi:class CYi : public CHero {public:    // 攻擊函數    void Attack(CHero * pHero)     {        .... // 表現攻擊動作的代碼        pHero-&gt;Hurted(m_nPower); // 多態        pHero-&gt;FightBack(this);  // 多態    }        // 減少自身生命值    void Hurted(int nPower)     {        ... // 表現受傷動作的代碼        m_nLifeValue -= nPower;    }        // 反擊函數    void FightBack(CHero * pHero)     {        ...．// 表現反擊動作的代碼        pHero-&gt;Hurted(m_nPower/2); // 多態    }};</code></pre><p>如果增加了新的英雄寒冰艾希 CAshe ，只需要編寫新類 CAshe ，不再需要在已有的類裡專門為新英雄增加：</p><pre><code>void Attack( CAshe * pAshe) ;void FightBack(CAshe * pAshe) ;</code></pre><p>所以已有的類可以原封不動，那麼使用多態的特性新增英雄的時候，可見改動量是非常少的。</p><p>多態使用方式：</p><pre><code>void CYi::Attack(CHero * pHero) {    pHero-&gt;Hurted(m_nPower); // 多態    pHero-&gt;FightBack(this);  // 多態}CYi yi; CGaren garen; CLeesin leesin; CEzreal ezreal;yi.Attack( &amp;garen );  //(1)yi.Attack( &amp;leesin ); //(2)yi.Attack( &amp;ezreal ); //(3)</code></pre><p>根據多態的規則，上面的(1)，(2)，(3)進入到 CYi::Attack 函數後</p><p>，分別調用：</p><pre><code>CGaren::HurtedCLeesin::HurtedCEzreal::Hurted</code></pre><h2 class=pgc-h-arrow-right>多態的又一例子</h2><p>出一道題考考大家，看大家是否理解到了多態的特性，下面的代碼， pBase->fun1() 輸出結果是什麼呢？</p><pre><code>class Base {public:    void fun1()     {         fun2();     }        virtual void fun2()  // 虛函數    {         cout &lt;&lt; "Base::fun2()" &lt;&lt; endl;     }};class Derived : public Base {public:    virtual void fun2()  // 虛函數    {         cout &lt;&lt; "Derived:fun2()" &lt;&lt; endl;     }};int main() {    Derived d;    Base * pBase = &amp; d;    pBase-&gt;fun1();    return 0;}</code></pre><p>是不是大家覺得 pBase 指針對象雖然指向的是派生類對象，但是派生類裡沒有 fun1 成員函數，則就調用基類的 fun1 成員函數， Base::fun1() 裡又會調用基類的 fun2 成員函數，所以輸出結果是 Base::fun2() ？</p><p>假設我把上面的代碼轉換一下， 大家還覺得輸出的是 Base::fun2() 嗎？</p><pre><code>class Base {public:    void fun1()     {         this-&gt;fun2();  // this是基類指針，fun2是虛函數，所以是多態    }}</code></pre><p>this 指針的作用就是指向成員函數所作用的對象， 所以非靜態成員函數中可以直接使用 this 來代表指向該函數作用的對象的指針。</p><p>pBase 指針對象指向的是派生類對象，派生類裡沒有 fun1 成員函數，所以就會調用基類的 fun1 成員函數，在 Base::fun1() 成員函數體裡執行 this->fun2() 時，實際上指向的是派生類對象的 fun2 成員函數。</p><p>所以正確的輸出結果是：</p><pre><code>Derived:fun2()</code></pre><p>所以我們需要注意：</p><h4 class=pgc-h-arrow-right>在非構造函數，非析構函數的成員函數中調用「虛函數」，是多態!!!</h4><h2 class=pgc-h-arrow-right>構造函數和析構函數中存在多態嗎？</h2><p>在構造函數和析構函數中調用「虛函數」，不是多態。編譯時即可確定，調用的函數是 <strong>自己的類或基類</strong> 中定義的函數，不會等到運行時才決定調用自己的還是派生類的函數。</p><p>我們看如下的代碼例子，來說明：</p><pre><code>// 基類class CFather {public:    virtual void hello() // 虛函數    {        cout&lt;&lt;"hello from father"&lt;&lt;endl;     }        virtual void bye() // 虛函數    {        cout&lt;&lt;"bye from father"&lt;&lt;endl;     }};// 派生類class CSon : public CFather{ public:    CSon() // 構造函數    {         hello();     }        ~CSon()  // 析構函數    {         bye();    }    virtual void hello() // 虛函數    {         cout&lt;&lt;"hello from son"&lt;&lt;endl;    }};int main(){    CSon son;    CFather *pfather;    pfather = &amp; son;    pfather-&gt;hello(); //多態    return 0;}</code></pre><p>輸出結果：</p><pre><code>hello from son  // 構造son對象時執行的構造函數hello from son  // 多態bye from father // son對象析構時，由於CSon類沒有bye成員函數，所以調用了基類的bye成員函數</code></pre><h2 class=pgc-h-arrow-right>多態的實現原理</h2><p>「多態」的關鍵在於通過 <strong>基類指針或引用</strong> 調用一個 <strong>虛函數</strong> 時，編譯時不能確定到底調用的是基類還是派生類的函數，運行時才能確定。</p><p>我們用 sizeof 來運算有有虛函數的類和沒虛函數的類的大小，會是什麼結果呢？</p><pre><code>class A {public:    int i;    virtual void Print() { } // 虛函數};class B{public:    int n;    void Print() { } };int main() {    cout &lt;&lt; sizeof(A) &lt;&lt; ","&lt;&lt; sizeof(B);    return 0;}</code></pre><p>在64位機子，執行的結果：</p><pre><code>16,4</code></pre><p>從上面的結果，可以發現有虛函數的類，多出了 8 個字節，在 64 位機子上指針類型大小正好是 8 個字節，這多出 8 個字節的指針有什麼作用呢？</p><h2 class=pgc-h-arrow-right>01 虛函數表</h2><p>每一個有「虛函數」的類（或有虛函數的類的派生類）都有一個「虛函數表」，該類的任何對象中都放著 <strong>虛函數表的指針</strong> 。「虛函數表」中列出了該類的「虛函數」地址。</p><h4 class=pgc-h-arrow-right>多出來的 8 個字節就是用來放「虛函數表」的地址。</h4><pre><code>// 基類class Base {public:    int i;    virtual void Print() { } // 虛函數};// 派生類class Derived : public Base{public:    int n;    virtual void Print() { } // 虛函數};</code></pre><p>上面 Derived 類繼承了 Base類，兩個類都有「虛函數」，那麼它「虛函數表」的形式可以理解成下圖：</p><div class=pgc-img><img alt="C++ 一篇搞懂多態的實現原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bdbf13ebb0240e1b22a27fe4f7ccf1d><p class=pgc-img-caption></p></div><p>多態的函數調用語句被編譯成一系列根據基類指針所指向的（或基類引用所引用的）對象中 <strong>存放的虛函數表的地址</strong> ，在虛函數表中查找虛函數地址，並調用虛函數的指令。</p><h2 class=pgc-h-arrow-right>02 證明虛函數表指針的作用</h2><p>在上面我們用 sizeof 運算符計算了有虛函數的類的大小，發現是多出了 8 字節大小（64位系統），這多出來的 8 個字節就是指向「虛函數表的指針」。「虛函數表」中列出了該類的「虛函數」地址。</p><p>下面用代碼的例子，來證明「虛函數表指針」的作用：</p><pre><code>// 基類class A {public:     virtual void Func()  // 虛函數    {         cout &lt;&lt; "A::Func" &lt;&lt; endl;     }};// 派生類class B : public A {public:     virtual void Func()  // 虛函數    {         cout &lt;&lt; "B::Func" &lt;&lt; endl;    }};int main() {    A a;        A * pa = new B();    pa-&gt;Func(); // 多態        // 64位程序指針為8字節    int * p1 = (int *) &amp; a;    int * p2 = (int *) pa;        * p2 = * p1;    pa-&gt;Func();        return 0;}</code></pre><p>輸出結果：</p><pre><code>B::FuncA::Func</code></pre><ul><li>第 25-26 行代碼中的 pa 指針指向的是 B 類對象，所以 pa->Func() 調用的是 B 類對象的虛函數 Func() ，輸出內容是 B::Func ；</li><li>第 29-30 行代碼的目的是把 A 類的頭 8 個字節的「虛函數表指針」存放到 p1 指針和把 B 類的頭 8 個字節的「虛函數表指針」存放到 p2 指針；</li><li>第 32 行代碼目的是把 A 類的「虛函數表指針」 賦值給 B 類的「虛函數表指針」，所以相當於把 B 類的「虛函數表指針」 替換 成了 A 類的「虛函數表指針」；</li><li>由於第 32 行的作用，把 B 類的「虛函數表指針」 替換 成了 A 類的「虛函數表指針」，所以第 33 行調用的是 A 類的虛函數 Func() ，輸出內容是 A::Func</li></ul><p>通過上述的代碼和講解，可以有效的證明了「虛函數表的指針」的作用，「虛函數表的指針」指向的是「虛函數表」，「虛函數表」裡存放的是類裡的「虛函數」地址，那麼在調用過程中，就能實現多態的特性。</p><h2 class=pgc-h-arrow-right>虛析構函數</h2><p>析構函數是在刪除對象或退出程序的時候，自動調用的函數，其目的是做一些資源釋放。</p><p>那麼在多態的情景下，通過基類的指針刪除派生類對象時，通常情況下只調用基類的析構函數，這就會存在派生類對象的析構函數沒有調用到，存在資源洩露的情況。</p><p>看如下的例子：</p><pre><code>// 基類class A {public:     A()  // 構造函數    {        cout &lt;&lt; "construct A" &lt;&lt; endl;    }        ~A() // 析構函數    {        cout &lt;&lt; "Destructor A" &lt;&lt; endl;    }};// 派生類class B : public A {public:     B()  // 構造函數    {        cout &lt;&lt; "construct B" &lt;&lt; endl;    }        ~B()// 析構函數    {        cout &lt;&lt; "Destructor B" &lt;&lt; endl;    }};int main() {    A *pa = new B();    delete pa;        return 0;}</code></pre><p>輸出結果：</p><pre><code>construct Aconstruct BDestructor A</code></pre><p>從上面的輸出結果可以看到，在刪除 pa 指針對象時， B 類的析構函數沒有被調用。</p><h4 class=pgc-h-arrow-right>解決辦法：把基類的析構函數聲明為virtual</h4><ul><li>派生類的析構函數可以 virtual 不進行聲明；</li><li>通過基類的指針刪除派生類對象時，首先調用派生類的析構函數，然後調用基類的析構函數，還是遵循「先構造，後虛構」的規則。</li></ul><p>將上述的代碼中的基類的析構函數，定義成「虛析構函數」：</p><pre><code>// 基類class A {public:     A()      {        cout &lt;&lt; "construct A" &lt;&lt; endl;    }        virtual ~A() // 虛析構函數    {        cout &lt;&lt; "Destructor A" &lt;&lt; endl;    }};</code></pre><p>輸出結果：</p><pre><code>construct Aconstruct BDestructor BDestructor A</code></pre><p>所以要養成好習慣:</p><ul><li>一個類如果定義了虛函數，則應該將析構函數也定義成虛函數;</li><li>或者，一個類打算作為基類使用，也應該將析構函數定義成虛函數。</li><li>注意：不允許構造函數不能定義成虛構造函數。</li></ul><h2 class=pgc-h-arrow-right>純虛函數和抽象類</h2><p>純虛函數： 沒有函數體的虛函數</p><pre><code>class A {public:    virtual void Print( ) = 0 ; //純虛函數private:     int a;};</code></pre><p>包含純虛函數的類叫抽象類</p><ul><li>抽象類只能作為基類來派生新類使用，不能創建抽象類的對象</li><li>抽象類的指針和引用可以指向由抽象類派生出來的類的對象</li></ul><pre><code>A a;         // 錯，A 是抽象類，不能創建對象A * pa ;     // ok,可以定義抽象類的指針和引用pa = new A ; // 錯誤, A 是抽象類，不能創建對象</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>搞懂</a></li><li><a>C++</a></li><li><a>多態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/de7a031.html alt=C++多態知識點總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b1d46fcbc2594d44ab36ad5e8407d146 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/de7a031.html title=C++多態知識點總結>C++多態知識點總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html alt=20個機械設計知識點總結，搞懂也是半個行家 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html title=20個機械設計知識點總結，搞懂也是半個行家>20個機械設計知識點總結，搞懂也是半個行家</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e27caade.html alt=python基礎知識，多態實例講解以及多態的作用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2506d9fe7f6641a6a12c35a35a9335db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e27caade.html title=python基礎知識，多態實例講解以及多態的作用>python基礎知識，多態實例講解以及多態的作用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/790fbad0.html alt=多態&動態綁定&方法匹配&方法綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533542565759f64e623e74 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/790fbad0.html title=多態&動態綁定&方法匹配&方法綁定>多態&動態綁定&方法匹配&方法綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html alt=多態的本質，java動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac000493fbc8532b5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html title=多態的本質，java動態綁定>多態的本質，java動態綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2aa5a357.html alt=大白話講解php多態應用實例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2aa5a357.html title=大白話講解php多態應用實例>大白話講解php多態應用實例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html alt=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/47783c95e3a34185be9ff00f54b4fe7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html title=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？>電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>