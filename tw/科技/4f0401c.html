<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>TCP協議原理，有這一篇就夠了 | 极客快訊</title><meta property="og:title" content="TCP協議原理，有這一篇就夠了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/5ceb9203d1364d07bd2472d59aeaa7eb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4f0401c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4f0401c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4f0401c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4f0401c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4f0401c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4f0401c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4f0401c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4f0401c.html><meta property="article:published_time" content="2020-10-29T20:50:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:28+08:00"><meta name=Keywords content><meta name=description content="TCP協議原理，有這一篇就夠了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4f0401c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>TCP協議原理，有這一篇就夠了</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>先亮出這篇文章的思維導圖:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ceb9203d1364d07bd2472d59aeaa7eb><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>TCP 作為傳輸層的協議，是一個軟件工程師素養的體現，也是面試中經常被問到的知識點。在此，我將 TCP 核心的一些問題梳理了一下，希望能幫到各位。</p><p>001. 能不能說一說 TCP 和 UDP 的區別？</p><p>首先概括一下基本的區別:</p><p><strong>TCP是一個面向連接的、可靠的、有序的、基於字節流的傳輸層協議。</strong></p><p>而<strong>UDP是一個面向無連接、不可靠、無序的傳輸層協議。</strong>(就這麼簡單，其它TCP的特性也就沒有了)。</p><p>具體來分析，和 UDP 相比，TCP 有三大核心特性:</p><ol><li><strong>面向連接</strong>。所謂的連接，指的是客戶端和服務器的連接，在雙方互相通信之前，TCP 需要三次握手建立連接，而 UDP 沒有相應建立連接的過程。</li><li><strong>可靠性</strong>。TCP 花了非常多的功夫保證連接的可靠，這個可靠性體現在哪些方面呢？一個是有狀態，另一個是可控制。</li></ol><p>TCP 會精準記錄哪些數據發送了，哪些數據被對方接收了，哪些沒有被接收到，而且保證數據包按序到達，不允許半點差錯。這是<strong>有狀態</strong>。</p><p>當意識到丟包了或者網絡環境不佳，TCP 會根據具體情況調整自己的行為，控制自己的發送速度或者重發。這是<strong>可控制</strong>。</p><p>相應的，UDP 就是無狀態, 不可控的。</p><ol><li><strong>面向字節流</strong>。UDP 的數據傳輸是基於數據報的，這是因為僅僅只是繼承了 IP 層的特性，而 TCP 為了維護狀態，將一個個 IP 包變成了字節流。</li></ol><p>002: 說說 TCP 三次握手的過程？為什麼是三次而不是兩次、四次？</p><p>戀愛模擬</p><p>以談戀愛為例，兩個人能夠在一起最重要的事情是首先確認各自<strong>愛</strong>和<strong>被愛</strong>的能力。接下來我們以此來模擬三次握手的過程。</p><p>第一次:</p><p>男: <strong>我愛你。</strong></p><p>女方收到。</p><p>由此證明男方擁有愛的能力。</p><p>第二次:</p><p>女: <strong>我收到了你的愛，我也愛你。</strong></p><p>男方收到。</p><p>OK，現在的情況說明，女方擁有愛和被愛的能力。</p><p>第三次:</p><p>男: <strong>我收到了你的愛。</strong></p><p>女方收到。</p><p>現在能夠保證男方具備被愛的能力。</p><p>由此完整地確認了雙方愛和被愛的能力，兩人開始一段甜蜜的愛情。</p><p>真實握手</p><p>當然剛剛那段屬於扯淡，不代表本人價值觀，目的是讓大家理解整個握手過程的意義，因為兩個過程非常相似。對應到 TCP 的三次握手，也是需要確認雙方的兩樣能力: 發送的能力和接收的能力。於是便會有下面的三次握手的過程:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/07971f468d814f4186a00c6bde6ff0b8><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>從最開始雙方都處於CLOSED狀態。然後服務端開始監聽某個端口，進入了LISTEN狀態。</p><p>然後客戶端主動發起連接，發送 SYN , 自己變成了SYN-SENT狀態。</p><p>服務端接收到，返回SYN和ACK(對應客戶端發來的SYN)，自己變成了SYN-REVD。</p><p>之後客戶端再發送ACK給服務端，自己變成了ESTABLISHED狀態；服務端收到ACK之後，也變成了ESTABLISHED狀態。</p><p>另外需要提醒你注意的是，從圖中可以看出，SYN 是需要消耗一個序列號的，下次發送對應的 ACK 序列號要加1，為什麼呢？只需要記住一個規則:</p><blockquote><p>凡是需要對端確認的，一定消耗TCP報文的序列號。</p></blockquote><p>SYN 需要對端的確認， 而 ACK 並不需要，因此 SYN 消耗一個序列號而 ACK 不需要。</p><p>為什麼不是兩次？</p><p>根本原因: 無法確認客戶端的接收能力。</p><p>分析如下:</p><p>如果是兩次，你現在發了 SYN 報文想握手，但是這個包<strong>滯留</strong>在了當前的網絡中遲遲沒有到達，TCP 以為這是丟了包，於是重傳，兩次握手建立好了連接。</p><p>看似沒有問題，但是連接關閉後，如果這個<strong>滯留</strong>在網路中的包到達了服務端呢？這時候由於是兩次握手，服務端只要接收到然後發送相應的數據包，就默認<strong>建立連接</strong>，但是現在客戶端已經斷開了。</p><p>看到問題的吧，這就帶來了連接資源的浪費。</p><p>為什麼不是四次？</p><p>三次握手的目的是確認雙方發送和接收的能力，那四次握手可以嘛？</p><p>當然可以，100 次都可以。但為了解決問題，三次就足夠了，再多用處就不大了。</p><p>三次握手過程中可以攜帶數據麼？</p><p>第三次握手的時候，可以攜帶。前兩次握手不能攜帶數據。</p><p>如果前兩次握手能夠攜帶數據，那麼一旦有人想攻擊服務器，那麼他只需要在第一次握手中的 SYN 報文中放大量數據，那麼服務器勢必會消耗更多的<strong>時間</strong>和<strong>內存空間</strong>去處理這些數據，增大了服務器被攻擊的風險。</p><p>第三次握手的時候，客戶端已經處於ESTABLISHED狀態，並且已經能夠確認服務器的接收、發送能力正常，這個時候相對安全了，可以攜帶數據。</p><p>同時打開會怎樣？</p><p>如果雙方同時發 SYN報文，狀態變化會是怎樣的呢？</p><p>這是一個可能會發生的情況。</p><p>狀態變遷如下:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9f85f7e787a843c184ba92b8906a663c><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>在發送方給接收方發SYN報文的同時，接收方也給發送方發SYN報文，兩個人剛上了!</p><p>發完SYN，兩者的狀態都變為SYN-SENT。</p><p>在各自收到對方的SYN後，兩者狀態都變為SYN-REVD。</p><p>接著會回覆對應的ACK + SYN，這個報文在對方接收之後，兩者狀態一起變為ESTABLISHED。</p><p>這就是同時打開情況下的狀態變遷。</p><p>003: 說說 TCP 四次揮手的過程</p><p>過程拆解</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8636045e07394ae59a6f329fe83bc721><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>剛開始雙方處於ESTABLISHED狀態。</p><p>客戶端要斷開了，向服務器發送 FIN 報文，在 TCP 報文中的位置如下圖:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ac8dfe142bfc420e91644e3adb404efd><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>發送後客戶端變成了FIN-WAIT-1狀態。注意, 這時候客戶端同時也變成了half-close(半關閉)狀態，即無法向服務端發送報文，只能接收。</p><p>服務端接收後向客戶端確認，變成了CLOSED-WAIT狀態。</p><p>客戶端接收到了服務端的確認，變成了FIN-WAIT2狀態。</p><p>隨後，服務端向客戶端發送FIN，自己進入LAST-ACK狀態，</p><p>客戶端收到服務端發來的FIN後，自己變成了TIME-WAIT狀態，然後發送 ACK 給服務端。</p><p>注意了，這個時候，客戶端需要等待足夠長的時間，具體來說，是 2 個 MSL(Maximum Segment Lifetime，報文最大生存時間), 在這段時間內如果客戶端沒有收到服務端的重發請求，那麼表示 ACK 成功到達，揮手結束，否則客戶端重發 ACK。</p><p>等待2MSL的意義</p><p>如果不等待會怎樣？</p><p>如果不等待，客戶端直接跑路，當服務端還有很多數據包要給客戶端發，且還在路上的時候，若客戶端的端口此時剛好被新的應用佔用，那麼就接收到了無用數據包，造成數據包混亂。所以，最保險的做法是等服務器發來的數據包都死翹翹再啟動新的應用。</p><p>那，照這樣說一個 MSL 不就不夠了嗎，為什麼要等待 2 MSL?</p><ul><li>1 個 MSL 確保四次揮手中主動關閉方最後的 ACK 報文最終能達到對端</li><li>1 個 MSL 確保對端沒有收到 ACK 重傳的 FIN 報文可以到達</li></ul><p>這就是等待 2MSL 的意義。</p><p>為什麼是四次揮手而不是三次？</p><p>因為服務端在接收到FIN, 往往不會立即返回FIN, 必須等到服務端所有的報文都發送完畢了，才能發FIN。因此先發一個ACK表示已經收到客戶端的FIN，延遲一段時間才發FIN。這就造成了四次揮手。</p><p>如果是三次揮手會有什麼問題？</p><p>等於說服務端將ACK和FIN的發送合併為一次揮手，這個時候長時間的延遲可能會導致客戶端誤以為FIN沒有到達客戶端，從而讓客戶端不斷的重發FIN。</p><p>同時關閉會怎樣？</p><p>如果客戶端和服務端同時發送 FIN ，狀態會如何變化？如圖所示:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b51a2953581a4f9182d2b7511eab877c><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>004: 說說半連接隊列和 SYN Flood 攻擊的關係</p><p>三次握手前，服務端的狀態從CLOSED變為LISTEN, 同時在內部創建了兩個隊列：<strong>半連接隊列</strong>和<strong>全連接隊列</strong>，即<strong>SYN隊列</strong>和<strong>ACCEPT隊列</strong>。</p><p>半連接隊列</p><p>當客戶端發送SYN到服務端，服務端收到以後回覆ACK和SYN，狀態由LISTEN變為SYN_RCVD，此時這個連接就被推入了<strong>SYN隊列</strong>，也就是<strong>半連接隊列</strong>。</p><p>全連接隊列</p><p>當客戶端返回ACK, 服務端接收後，三次握手完成。這個時候連接等待被具體的應用取走，在被取走之前，它會被推入另外一個 TCP 維護的隊列，也就是<strong>全連接隊列(Accept Queue)</strong>。</p><p>SYN Flood 攻擊原理</p><p>SYN Flood 屬於典型的 DoS/DDoS 攻擊。其攻擊的原理很簡單，就是用客戶端在短時間內偽造大量不存在的 IP 地址，並向服務端瘋狂發送SYN。對於服務端而言，會產生兩個危險的後果:</p><ol><li>處理大量的SYN包並返回對應ACK, 勢必有大量連接處於SYN_RCVD狀態，從而佔滿整個<strong>半連接隊列</strong>，無法處理正常的請求。</li><li>由於是不存在的 IP，服務端長時間收不到客戶端的ACK，會導致服務端不斷重發數據，直到耗盡服務端的資源。</li></ol><p>如何應對 SYN Flood 攻擊？</p><ol><li>增加 SYN 連接，也就是增加半連接隊列的容量。</li><li>減少 SYN + ACK 重試次數，避免大量的超時重發。</li><li>利用 SYN Cookie 技術，在服務端接收到SYN後不立即分配連接資源，而是根據這個SYN計算出一個Cookie，連同第二次握手回覆給客戶端，在客戶端回覆ACK的時候帶上這個Cookie值，服務端驗證 Cookie 合法之後才分配連接資源。</li></ol><p>005: 介紹一下 TCP 報文頭部的字段</p><p>報文頭部結構如下(單位為字節):</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dad75cbd5bff47acbbe09fa7c04750c5><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>請大家牢記這張圖！</p><p>源端口、目標端口</p><p>如何標識唯一標識一個連接？答案是 TCP 連接的四元組——源 IP、源端口、目標 IP 和目標端口。</p><p>那 TCP 報文怎麼沒有源 IP 和目標 IP 呢？這是因為在 IP 層就已經處理了 IP 。TCP 只需要記錄兩者的端口即可。</p><p>序列號</p><p>即Sequence number, 指的是本報文段第一個字節的序列號。</p><p>從圖中可以看出，序列號是一個長為 4 個字節，也就是 32 位的無符號整數，表示範圍為 0 ~ 2^32 - 1。如果到達最大值了後就循環到0。</p><p>序列號在 TCP 通信的過程中有兩個作用:</p><ol><li>在 SYN 報文中交換彼此的初始序列號。</li><li>保證數據包按正確的順序組裝。</li></ol><p>ISN</p><p>即Initial Sequence Number（初始序列號）,在三次握手的過程當中，雙方會用過SYN報文來交換彼此的 ISN。</p><p>ISN 並不是一個固定的值，而是每 4 ms 加一，溢出則回到 0，這個算法使得猜測 ISN 變得很困難。那為什麼要這麼做？</p><p>如果 ISN 被攻擊者預測到，要知道源 IP 和源端口號都是很容易偽造的，當攻擊者猜測 ISN 之後，直接偽造一個 RST 後，就可以強制連接關閉的，這是非常危險的。</p><p>而動態增長的 ISN 大大提高了猜測 ISN 的難度。</p><p>確認號</p><p>即ACK(Acknowledgment number)。用來告知對方下一個期望接收的序列號，<strong>小於ACK</strong>的所有字節已經全部收到。</p><p>標記位</p><p>常見的標記位有SYN,ACK,FIN,RST,PSH。</p><p>SYN 和 ACK 已經在上文說過，後三個解釋如下: FIN： 即 Finish，表示發送方準備斷開連接。</p><p>RST：即 Reset，用來強制斷開連接。</p><p>PSH： 即 Push, 告知對方這些數據包收到後應該馬上交給上層的應用，不能緩存。</p><p>窗口大小</p><p>佔用兩個字節，也就是 16 位，但實際上是不夠用的。因此 TCP 引入了窗口縮放的選項，作為窗口縮放的比例因子，這個比例因子的範圍在 0 ~ 14，比例因子可以將窗口的值擴大為原來的 2 ^ n 次方。</p><p>校驗和</p><p>佔用兩個字節，防止傳輸過程中數據包有損壞，如果遇到校驗和有差錯的報文，TCP 直接丟棄之，等待重傳。</p><p>可選項</p><p>可選項的格式如下:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/18f8ca5cb17948939792fb3b4654d2a0><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>常用的可選項有以下幾個:</p><ul><li>TimeStamp: TCP 時間戳，後面詳細介紹。</li><li>MSS: 指的是 TCP 允許的從對方接收的最大報文段。</li><li>SACK: 選擇確認選項。</li><li>Window Scale： 窗口縮放選項。</li></ul><p>006: 說說 TCP 快速打開的原理(TFO)</p><p>第一節講了 TCP 三次握手，可能有人會說，每次都三次握手好麻煩呀！能不能優化一點？</p><p>可以啊。今天來說說這個優化後的 TCP 握手流程，也就是 TCP 快速打開(TCP Fast Open, 即TFO)的原理。</p><p>優化的過程是這樣的，還記得我們說 SYN Flood 攻擊時提到的 SYN Cookie 嗎？這個 Cookie 可不是瀏覽器的Cookie, 用它同樣可以實現 TFO。</p><p>TFO 流程</p><p>首輪三次握手</p><p>首先客戶端發送SYN給服務端，服務端接收到。</p><p>注意哦！現在服務端不是立刻回覆 SYN + ACK，而是通過計算得到一個SYN Cookie, 將這個Cookie放到 TCP 報文的 Fast Open選項中，然後才給客戶端返回。</p><p>客戶端拿到這個 Cookie 的值緩存下來。後面正常完成三次握手。</p><p>首輪三次握手就是這樣的流程。而後面的三次握手就不一樣啦！</p><p>後面的三次握手</p><p>在後面的三次握手中，客戶端會將之前緩存的 Cookie、SYN 和HTTP請求(是的，你沒看錯)發送給服務端，服務端驗證了 Cookie 的合法性，如果不合法直接丟棄；如果是合法的，那麼就正常返回SYN + ACK。</p><p>重點來了，現在服務端能向客戶端發 HTTP 響應了！這是最顯著的改變，三次握手還沒建立，僅僅驗證了 Cookie 的合法性，就可以返回 HTTP 響應了。</p><p>當然，客戶端的ACK還得正常傳過來，不然怎麼叫三次握手嘛。</p><p>流程如下:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/31a01635ffdc479893f7760a8ec9e8ba><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>注意: 客戶端最後握手的 ACK 不一定要等到服務端的 HTTP 響應到達才發送，兩個過程沒有任何關係。</p><p>TFO 的優勢</p><p>TFO 的優勢並不在與首輪三次握手，而在於後面的握手，在拿到客戶端的 Cookie 並驗證通過以後，可以直接返回 HTTP 響應，充分利用了<strong>1 個RTT</strong>(Round-Trip Time，往返時延)的時間<strong>提前進行數據傳輸</strong>，積累起來還是一個比較大的優勢。</p><p>007: 能不能說說TCP報文中時間戳的作用？</p><p>timestamp是 TCP 報文首部的一個可選項，一共佔 10 個字節，格式如下:</p><p>kind(1 字節) + length(1 字節) + info(8 個字節)</p><p>複製代碼</p><p>其中 kind = 8， length = 10， info 有兩部分構成: <strong>timestamp</strong>和<strong>timestamp echo</strong>，各佔 4 個字節。</p><p>那麼這些字段都是幹嘛的呢？它們用來解決那些問題？</p><p>接下來我們就來一一梳理，TCP 的時間戳主要解決兩大問題:</p><ul><li>計算往返時延 RTT(Round-Trip Time)</li><li>防止序列號的迴繞問題</li></ul><p>計算往返時延 RTT</p><p>在沒有時間戳的時候，計算 RTT 會遇到的問題如下圖所示:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b6521d81fcf140f3aca0e8041e362848><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>如果以第一次發包為開始時間的話，就會出現左圖的問題，RTT 明顯偏大，開始時間應該採用第二次的；</p><p>如果以第二次發包為開始時間的話，就會導致右圖的問題，RTT 明顯偏小，開始時間應該採用第一次發包的。</p><p>實際上無論開始時間以第一次發包還是第二次發包為準，都是不準確的。</p><p>那這個時候引入時間戳就很好的解決了這個問題。</p><p>比如現在 a 向 b 發送一個報文 s1，b 向 a 回覆一個含 ACK 的報文 s2 那麼：</p><ul><li><strong>step 1:</strong> a 向 b 發送的時候，timestamp 中存放的內容就是 a 主機發送時的內核時刻 ta1。</li><li><strong>step 2:</strong> b 向 a 回覆 s2 報文的時候，timestamp 中存放的是 b 主機的時刻 tb, timestamp echo字段為從 s1 報文中解析出來的 ta1。</li><li><strong>step 3:</strong> a 收到 b 的 s2 報文之後，此時 a 主機的內核時刻是 ta2, 而在 s2 報文中的 timestamp echo 選項中可以得到 ta1, 也就是 s2 對應的報文最初的發送時刻。然後直接採用 ta2 - ta1 就得到了 RTT 的值。</li></ul><p>防止序列號迴繞問題</p><p>現在我們來模擬一下這個問題。</p><p>序列號的範圍其實是在0 ~ 2 ^ 32 - 1, 為了方便演示，我們縮小一下這個區間，假設範圍是 0 ~ 4，那麼到達 4 的時候會回到 0。</p><p>第幾次發包 發送字節 對應序列號 狀態 1 0 ~ 1 0 ~ 1 成功接收 2 1 ~ 2 1 ~ 2 滯留在網絡中 3 2 ~ 3 2 ~ 3 成功接收 4 3 ~ 4 3 ~ 4 成功接收 5 4 ~ 5 0 ~ 1 成功接收，序列號從0開始 6 5 ~ 6 1 ~ 2 ？？？</p><p>假設在第 6 次的時候，之前還滯留在網路中的包回來了，那麼就有兩個序列號為1 ~ 2的數據包了，怎麼區分誰是誰呢？這個時候就產生了序列號迴繞的問題。</p><p>那麼用 timestamp 就能很好地解決這個問題，因為每次發包的時候都是將發包機器當時的內核時間記錄在報文中，那麼兩次發包序列號即使相同，時間戳也不可能相同，這樣就能夠區分開兩個數據包了。</p><p>008: TCP 的超時重傳時間是如何計算的？</p><p>TCP 具有超時重傳機制，即間隔一段時間沒有等到數據包的回覆時，重傳這個數據包。</p><p>那麼這個重傳間隔是如何來計算的呢？</p><p>今天我們就來討論一下這個問題。</p><p>這個重傳間隔也叫做<strong>超時重傳時間</strong>(Retransmission TimeOut, 簡稱RTO)，它的計算跟上一節提到的 RTT 密切相關。這裡我們將介紹兩種主要的方法，一個是經典方法，一個是標準方法。</p><p>經典方法</p><p>經典方法引入了一個新的概念——SRTT(Smoothed round trip time，即平滑往返時間)，沒產生一次新的 RTT. 就根據一定的算法對 SRTT 進行更新，具體而言，計算方式如下(SRTT 初始值為0):</p><p>SRTT = (α * SRTT) + ((1 - α) * RTT)</p><p>複製代碼</p><p>其中，α 是<strong>平滑因子</strong>，建議值是0.8，範圍是0.8 ~ 0.9。</p><p>拿到 SRTT，我們就可以計算 RTO 的值了:</p><p>RTO = min(ubound, max(lbound, β * SRTT))</p><p>複製代碼</p><p>β 是加權因子，一般為1.3 ~ 2.0， <strong>lbound</strong> 是下界，<strong>ubound</strong> 是上界。</p><p>其實這個算法過程還是很簡單的，但是也存在一定的侷限，就是在 RTT 穩定的地方表現還可以，而在 RTT 變化較大的地方就不行了，因為平滑因子 α 的範圍是0.8 ~ 0.9, RTT 對於 RTO 的影響太小。</p><p>標準方法</p><p>為了解決經典方法對於 RTT 變化不敏感的問題，後面又引出了標準方法，也叫Jacobson / Karels 算法。</p><p>一共有三步。</p><p><strong>第一步</strong>: 計算SRTT，公式如下:</p><p>SRTT = (1 - α) * SRTT + α * RTT</p><p>複製代碼</p><p>注意這個時候的 α跟經典方法中的α取值不一樣了，建議值是1/8，也就是0.125。</p><p><strong>第二步</strong>: 計算RTTVAR(round-trip time variation)這個中間變量。</p><p>RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)</p><p>複製代碼</p><p>β 建議值為 0.25。這個值是這個算法中出彩的地方，也就是說，它記錄了最新的 RTT 與當前 SRTT 之間的差值，給我們在後續感知到 RTT 的變化提供了抓手。</p><p><strong>第三步</strong>: 計算最終的RTO:</p><p>RTO = µ * SRTT + ∂ * RTTVAR</p><p>複製代碼</p><p>µ建議值取1, ∂建議值取4。</p><p>這個公式在 SRTT 的基礎上加上了最新 RTT 與它的偏移，從而很好的感知了 RTT 的變化，這種算法下，RTO 與 RTT 變化的差值關係更加密切。</p><p>009: 能不能說一說 TCP 的流量控制？</p><p>對於發送端和接收端而言，TCP 需要把發送的數據放到<strong>發送緩存區</strong>, 將接收的數據放到<strong>接收緩存區</strong>。</p><p>而流量控制索要做的事情，就是在通過接收緩存區的大小，控制發送端的發送。如果對方的接收緩存區滿了，就不能再繼續發送了。</p><p>要具體理解流量控制，首先需要了解滑動窗口的概念。</p><p>TCP 滑動窗口</p><p>TCP 滑動窗口分為兩種: <strong>發送窗口</strong>和<strong>接收窗口</strong>。</p><p>發送窗口</p><p>發送端的滑動窗口結構如下:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/91e9d97570944647b3034411efffeec0><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>其中包含四大部分:</p><ul><li>已發送且已確認</li><li>已發送但未確認</li><li>未發送但可以發送</li><li>未發送也不可以發送</li></ul><p>其中有一些重要的概念，我標註在圖中:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ccb4c62ba70e430a94d1bba080ae98f5><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>發送窗口就是圖中被框住的範圍。SND 即send, WND 即window, UNA 即unacknowledged, 表示未被確認，NXT 即next, 表示下一個發送的位置。</p><p>接收窗口</p><p>接收端的窗口結構如下:</p><div class=pgc-img><img alt=TCP協議原理，有這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a7a594ae339438d97a4dae8e2590f78><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>REV 即 receive，NXT 表示下一個接收的位置，WND 表示接收窗口大小。</p><p>流量控制過程</p><p>這裡我們不用太複雜的例子，以一個最簡單的來回來模擬一下流量控制的過程，方便大家理解。</p><p>首先雙方三次握手，初始化各自的窗口大小，均為 200 個字節。</p><p>假如當前發送端給接收端發送 100 個字節，那麼此時對於發送端而言，SND.NXT 當然要右移 100 個字節，也就是說當前的可用窗口減少了 100 個字節，這很好理解。</p><p>現在這 100 個到達了接收端，被放到接收端的緩衝隊列中。不過此時由於大量負載的原因，接收端處理不了這麼多字節，只能處理 40 個字節，剩下的 60 個字節被留在了緩衝隊列中。</p><p>注意了，此時接收端的情況是處理能力不夠用啦，你發送端給我少發點，所以此時接收端的接收窗口應該縮小，具體來說，縮小 60 個字節，由 200 個字節變成了 140 字節，因為緩衝隊列還有 60 個字節沒被應用拿走。</p><p>因此，接收端會在 ACK 的報文首部帶上縮小後的滑動窗口 140 字節，發送端對應地調整發送窗口的大小為 140 個字節。</p><p>此時對於發送端而言，已經發送且確認的部分增加 40 字節，也就是 SND.UNA 右移 40 個字節，同時<strong>發送窗口</strong>縮小為 140 個字節。</p><p>這也就是<strong>流量控制</strong>的過程。儘管回合再多，整個控制的過程和原理是一樣的。</p><p>010: 能不能說說 TCP 的擁塞控制？</p><p>上一節所說的<strong>流量控制</strong>發生在發送端跟接收端之間，並沒有考慮到整個網絡環境的影響，如果說當前網絡特別差，特別容易丟包，那麼發送端就應該注意一些了。而這，也正是擁塞控制需要處理的問題。</p><p>對於擁塞控制來說，TCP 每條連接都需要維護兩個核心狀態:</p><ul><li>擁塞窗口（Congestion Window，cwnd）</li><li>慢啟動閾值（Slow Start Threshold，ssthresh）</li></ul><p>涉及到的算法有這幾個:</p><ul><li>慢啟動</li><li>擁塞避免</li><li>快速重傳和快速恢復</li></ul><p>接下來，我們就來一一拆解這些狀態和算法。首先，從擁塞窗口說起。</p><p>擁塞窗口</p><p>擁塞窗口（Congestion Window，cwnd）是指目前自己還能傳輸的數據量大小。</p><p>那麼之前介紹了接收窗口的概念，兩者有什麼區別呢？</p><ul><li>接收窗口(rwnd)是接收端給的限制</li><li>擁塞窗口(cwnd)是發送端的限制</li></ul><p>限制誰呢？</p><p>限制的是發送窗口的大小。</p><p>有了這兩個窗口，如何來計算髮送窗口？</p><p>發送窗口大小 = min(rwnd, cwnd)</p><p>複製代碼</p><p>取兩者的較小值。而擁塞控制，就是來控制cwnd的變化。</p><p>慢啟動</p><p>剛開始進入傳輸數據的時候，你是不知道現在的網路到底是穩定還是擁堵的，如果做的太激進，發包太急，那麼瘋狂丟包，造成雪崩式的網絡災難。</p><p>因此，擁塞控制首先就是要採用一種保守的算法來慢慢地適應整個網路，這種算法叫慢啟動。運作過程如下:</p><ul><li>首先，三次握手，雙方宣告自己的接收窗口大小</li><li>雙方初始化自己的<strong>擁塞窗口</strong>(cwnd)大小</li><li>在開始傳輸的一段時間，發送端每收到一個 ACK，擁塞窗口大小加 1，也就是說，每經過一個 RTT，cwnd 翻倍。如果說初始窗口為 10，那麼第一輪 10 個報文傳完且發送端收到 ACK 後，cwnd 變為 20，第二輪變為 40，第三輪變為 80，依次類推。</li></ul><p>難道就這麼無止境地翻倍下去？當然不可能。它的閾值叫做<strong>慢啟動閾值</strong>，當 cwnd 到達這個閾值之後，好比踩了下剎車，別漲了那麼快了，老鐵，先 hold 住！</p><p>在到達閾值後，如何來控制 cwnd 的大小呢？</p><p>這就是擁塞避免做的事情了。</p><p>擁塞避免</p><p>原來每收到一個 ACK，cwnd 加1，現在到達閾值了，cwnd 只能加這麼一點: <strong>1 / cwnd</strong>。那你仔細算算，一輪 RTT 下來，收到 cwnd 個 ACK, 那最後擁塞窗口的大小 cwnd 總共才增加 1。</p><p>也就是說，以前一個 RTT 下來，cwnd翻倍，現在cwnd只是增加 1 而已。</p><p>當然，<strong>慢啟動</strong>和<strong>擁塞避免</strong>是一起作用的，是一體的。</p><p>快速重傳和快速恢復</p><p>快速重傳</p><p>在 TCP 傳輸的過程中，如果發生了丟包，即接收端發現數據段不是按序到達的時候，接收端的處理是重複發送之前的 ACK。</p><p>比如第 5 個包丟了，即使第 6、7 個包到達的接收端，接收端也一律返回第 4 個包的 ACK。當發送端收到 3 個重複的 ACK 時，意識到丟包了，於是馬上進行重傳，不用等到一個 RTO 的時間到了才重傳。</p><p>這就是<strong>快速重傳</strong>，它解決的是<strong>是否需要重傳</strong>的問題。</p><p>選擇性重傳</p><p>那你可能會問了，既然要重傳，那麼只重傳第 5 個包還是第5、6、7 個包都重傳呢？</p><p>當然第 6、7 個都已經到達了，TCP 的設計者也不傻，已經傳過去幹嘛還要傳？乾脆記錄一下哪些包到了，哪些沒到，針對性地重傳。</p><p>在收到發送端的報文後，接收端回覆一個 ACK 報文，那麼在這個報文首部的可選項中，就可以加上SACK這個屬性，通過left edge和right edge告知發送端已經收到了哪些區間的數據報。因此，即使第 5 個包丟包了，當收到第 6、7 個包之後，接收端依然會告訴發送端，這兩個包到了。剩下第 5 個包沒到，就重傳這個包。這個過程也叫做<strong>選擇性重傳(SACK，Selective Acknowledgment)</strong>，它解決的是<strong>如何重傳</strong>的問題。</p><p>快速恢復</p><p>當然，發送端收到三次重複 ACK 之後，發現丟包，覺得現在的網絡已經有些擁塞了，自己會進入<strong>快速恢復</strong>階段。</p><p>在這個階段，發送端如下改變：</p><ul><li>擁塞閾值降低為 cwnd 的一半</li><li>cwnd 的大小變為擁塞閾值</li><li>cwnd 線性增加</li></ul><p>以上就是 TCP 擁塞控制的經典算法: <strong>慢啟動</strong>、<strong>擁塞避免</strong>、<strong>快速重傳和快速恢復</strong>。</p><p>011: 能不能說說 Nagle 算法和延遲確認？</p><p>Nagle 算法</p><p>試想一個場景，發送端不停地給接收端發很小的包，一次只發 1 個字節，那麼發 1 千個字節需要發 1000 次。這種頻繁的發送是存在問題的，不光是傳輸的時延消耗，發送和確認本身也是需要耗時的，頻繁的發送接收帶來了巨大的時延。</p><p>而避免小包的頻繁發送，這就是 Nagle 算法要做的事情。</p><p>具體來說，Nagle 算法的規則如下:</p><ul><li>當第一次發送數據時不用等待，就算是 1byte 的小包也立即發送</li><li>後面發送滿足下面條件之一就可以發了: 數據包大小達到最大段大小(Max Segment Size, 即 MSS) 之前所有包的 ACK 都已接收到</li></ul><p>延遲確認</p><p>試想這樣一個場景，當我收到了發送端的一個包，然後在極短的時間內又接收到了第二個包，那我是一個個地回覆，還是稍微等一下，把兩個包的 ACK 合併後一起回覆呢？</p><p><strong>延遲確認</strong>(delayed ack)所做的事情，就是後者，稍稍延遲，然後合併 ACK，最後才回復給發送端。TCP 要求這個延遲的時延必須小於500ms，一般操作系統實現都不會超過200ms。</p><p>不過需要主要的是，有一些場景是不能延遲確認的，收到了就要馬上回復:</p><ul><li>接收到了大於一個 frame 的報文，且需要調整窗口大小</li><li>TCP 處於 quickack 模式（通過tcp_in_quickack_mode設置）</li><li>發現了亂序包</li></ul><p>兩者一起使用會怎樣？</p><p>前者意味著延遲發，後者意味著延遲接收，會造成更大的延遲，產生性能問題。</p><p>012. 如何理解 TCP 的 keep-alive？</p><p>大家都聽說過 http 的keep-alive, 不過 TCP 層面也是有keep-alive機制，而且跟應用層不太一樣。</p><p>試想一個場景，當有一方因為網絡故障或者宕機導致連接失效，由於 TCP 並不是一個輪詢的協議，在下一個數據包到達之前，對端對連接失效的情況是一無所知的。</p><p>這個時候就出現了 keep-alive, 它的作用就是探測對端的連接有沒有失效。</p><p>在 Linux 下，可以這樣查看相關的配置:</p><p>sudo sysctl -a | grep keepalive</p><p>// 每隔 7200 s 檢測一次</p><p>net.ipv4.tcp_keepalive_time = 7200</p><p>// 一次最多重傳 9 個包</p><p>net.ipv4.tcp_keepalive_probes = 9</p><p>// 每個包的間隔重傳間隔 75 s</p><p>net.ipv4.tcp_keepalive_intvl = 75</p><p>複製代碼</p><p>不過，現狀是大部分的應用並沒有默認開啟 TCP 的keep-alive選項，為什麼？</p><p>站在應用的角度:</p><ul><li>7200s 也就是兩個小時檢測一次，時間太長</li><li>時間再短一些，也難以體現其設計的初衷, 即檢測長時間的死連接</li></ul><p>因此是一個比較尷尬的設計。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>TCP</a></li><li><a>協議</a></li><li><a>就夠</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce824d7f.html alt=淺談TCP協議（建立與斷開連接） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4112ca2d63f04cddae0aadca168ea063 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce824d7f.html title=淺談TCP協議（建立與斷開連接）>淺談TCP協議（建立與斷開連接）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/049e5b0.html alt="TCP協議詳解 - TCP狀態轉移" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/11f74803a5c140f48e7d9c1a6aa0ae30 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/049e5b0.html title="TCP協議詳解 - TCP狀態轉移">TCP協議詳解 - TCP狀態轉移</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e566ae8.html alt="TCP 協議快被淘汰了，UDP 協議才是新世代的未來？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/b0c59e7c-978c-4b8e-b40c-52d64954c164 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e566ae8.html title="TCP 協議快被淘汰了，UDP 協議才是新世代的未來？">TCP 協議快被淘汰了，UDP 協議才是新世代的未來？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ca6ff7.html alt=TCP協議總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153156590409218ee54748f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ca6ff7.html title=TCP協議總結>TCP協議總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1bd1e17.html alt=一文讀懂TCP/IP協議工作原理和工作流程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ea27784370b9441090baaf9c8cf57977 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1bd1e17.html title=一文讀懂TCP/IP協議工作原理和工作流程>一文讀懂TCP/IP協議工作原理和工作流程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e347b4c.html alt=網絡協議-TCP和UDP最完整的區別介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/4fa7c983-2109-4db9-84ec-5431e01c87ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e347b4c.html title=網絡協議-TCP和UDP最完整的區別介紹>網絡協議-TCP和UDP最完整的區別介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7308701.html alt=網絡協議之TCP和UDP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/50f23be4fe764f69ab2ed27288e88510 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7308701.html title=網絡協議之TCP和UDP>網絡協議之TCP和UDP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8ebfea.html alt="TCP 協議概覽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2f900e98cdba494993003fef43aba139 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8ebfea.html title="TCP 協議概覽">TCP 協議概覽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13955a3.html alt="TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8f291e6a61fa4b45a91b81f2589002c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13955a3.html title="TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）">TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c8da7b9.html alt=TCP/IP協議分為哪四層，具體作用是什麼？http與tcp區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/250b6d508b7a4694baa0371a1f53a17c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c8da7b9.html title=TCP/IP協議分為哪四層，具體作用是什麼？http與tcp區別>TCP/IP協議分為哪四層，具體作用是什麼？http與tcp區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3364d34.html alt=TCP/IP協議是網絡協議中的核心協議，含三次握手，四次分手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fc06324c0dfc4990bb88bbf41769b159 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3364d34.html title=TCP/IP協議是網絡協議中的核心協議，含三次握手，四次分手>TCP/IP協議是網絡協議中的核心協議，含三次握手，四次分手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7302fb0.html alt=TCP/IP協議：傳輸層協議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5bccccba9b1243d3afefcee4cc0d04ed style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7302fb0.html title=TCP/IP協議：傳輸層協議>TCP/IP協議：傳輸層協議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2e5fc9a.html alt=TCP、HTTP協議以及TCP工作方式和HTTP請求完整過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5e2a3e9642b44ff69966b210d29e5a15 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2e5fc9a.html title=TCP、HTTP協議以及TCP工作方式和HTTP請求完整過程>TCP、HTTP協議以及TCP工作方式和HTTP請求完整過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4812b05.html alt=TCP傳輸控制協議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6e36bd33b6ec4310bb31225a085029fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4812b05.html title=TCP傳輸控制協議>TCP傳輸控制協議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a506966.html alt=TCP協議詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/23a1b33d10ec4885a1e3606c1aca021c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a506966.html title=TCP協議詳解>TCP協議詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>