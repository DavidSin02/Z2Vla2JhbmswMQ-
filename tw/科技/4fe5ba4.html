<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ | 极客快訊</title><meta property="og:title" content="你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3ac43ddbdfc44399b9cef800d4dbdd08"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4fe5ba4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4fe5ba4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4fe5ba4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4fe5ba4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4fe5ba4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4fe5ba4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4fe5ba4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4fe5ba4.html><meta property="article:published_time" content="2020-10-29T20:58:49+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:49+08:00"><meta name=Keywords content><meta name=description content="你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4fe5ba4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一. 繼承</h1><h1 class=pgc-h-arrow-right>1.介紹</h1><p style=text-align:start>多個類中存在相同屬性和行為時，將這些內容抽取到單獨一個類中，那麼多個類無需再定義這些屬性和行為，只要繼承那個類即可。此處的多個類稱為子類(此類，派生類，拓展類)，單獨的這個類稱為父類(基類 ，超類)。可以理解為:“子類 is a 父類”。</p><p style=text-align:start><strong>類繼承語法規則: class Subclass extends SuperClass{ };</strong></p><p style=text-align:start><em>以下幾點需要注意：</em></p><ul><li><strong>子類繼承了父類所有可以訪問的數據域和方法</strong>。</li><li>父類中聲明為private的屬性或方法，子類繼承父類以後，仍然認為獲取了父類中私的結構。只因為封裝性的影響，使得子類不能直接調用父類的結構而已。如果父類中定義了公共的訪問器 / 修改器，那麼可以通過這些公共的訪問器 / 修改器來訪問和修改它們。<br></li></ul><ul><li>子類並不是父類的一個子集。實際上，<strong>一個子類通常比它的父類包含更多的信息和方法</strong>。</li><li>在 <strong>Java 中是不允許多重繼承</strong>的。一個 Java 類只可能直接繼承自一個父類。這種限制稱為單一繼承（ single inheritance)。如果使用 extends 關鍵字來定義一個子類，它只允許有一個父類。然而，多重繼承是可以通過接口來實現。<br></li></ul><h1 class=pgc-h-arrow-right>2.super關鍵字</h1><p style=text-align:start>在Java類中使用super來調用父類中的指定操作：</p><ul><li>用於訪問父類中定義的屬性（屬性沒有私有化）</li><li>用於調用父類中定義的成員方法</li><li>用於在子類構造器中調用父類的構造器</li></ul><h1 class=pgc-h-arrow-right>2.1 調用父類的構造方法</h1><p style=text-align:start>構造方法用於構建一個類的實例。不同於屬性和普通方法，父類的構造方法不會被子類繼承。它們只能使用關鍵字 super 從子類的構造方法中調用。</p><p style=text-align:start><em><strong>調用父類構造方法的語法是： super()或者super(parameters);</strong></em></p><ul><li>語句 super（） 調用父類的無參構造方法，而語句 super（arguments) 調用與參數匹配的父類的構造方法。語句 super（） 和 super (arguments) <strong>必須出現在子類構造方法的第一行</strong>，這是顯式調用父類構造方法的唯一方式。</li><li>子類中所有的構造器默認都會訪問父類中空參數的構造器</li><li>如果子類構造器中既未顯式調用父類或本類的構造器，且父類中又沒有無參的構造器，則編譯出錯.所以呢，<strong>一般情況下，最好能為每個類提供一個無參構造方法，以便於對該類進行擴展，同時避免錯誤。</strong></li><li>特殊情況：當<strong>子類和父類中定義了同名的屬性時</strong>，我們要想在子類中調用父類中聲明的屬性，則<strong>必須顯式的使用"super.屬性"</strong>的方式，表明調用的是父類中聲明的屬性。</li><li>特殊情況：當<strong>子類重寫了父類中的方法以後</strong>，我們想在子類的方法中調用父類中被重寫的方法時，則<strong>必須顯式的使用"super.方法</strong>"的方式，表明調用的是父類中被重寫的方法。</li></ul><pre><code>public class Person {    private String name;    private int age;    private Date birthDate;    public Person(String name, int age, Date d) {        this.name = name;        this.age = age;        this.birthDate = d; }    public Person(String name, int age) {        this(name, age, null);    }    public Person(String name, Date d) {        this(name, 30, d);    }    public Person(String name) {        this(name, 30);    }}public class Student extends Person {    private String school;    public Student(String name, int age, String s) {        super(name, age);        school = s; }    public Student(String name, String s) {        super(name);        school = s; }    // 編譯出錯: no super(),系統無法調用父類無參數的構造器。    //There is no default constructor available in 'chapter01.Person'    public Student(String s) {        school = s; }}</code></pre><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3ac43ddbdfc44399b9cef800d4dbdd08><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>2.2 構造方法鏈</h1><p style=text-align:start>在任何情況下，構造一個類的實例時，將會調用<strong>沿著繼承鏈的所有父類的構造方法</strong>。<strong>當構造一個子類的對象時，子類構造方法會在完成自己的任務之前，首先調用它的父類的構造方法。如果父類繼承自其他類，那麼父類構造方法又會在完成自己的任務之前，調用它自己的父類的構造方法。這個過程持續到沿著這個繼承體系結構的最後一個構造方法被調用</strong>為止。這就是構造方法鏈（constructor chaining)。</p><pre><code>public class Faculty extends Employee {    public static void main(String[] args) {        Faculty faculty = new Faculty();    }    public Faculty() {        System.out.println("(4) Performs Faculty's tasks");    }}class Employee extends Person {    public Employee() {        this("(2)Invoke Employee's overloaded constructor");        System.out.println("(3)Performs Employee's tasks ");    }    public Employee(String s) {        System.out.println(s);    }}class Person {    public Person() {        System.out.println("(1) Performs Person's tasks");    }}</code></pre><p style=text-align:start>結果：</p><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b89cb45aa26741cb876b7fb2f928518e><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><em>在第3 行，new Faculty（） 調用Faculty 的無參構造方法。由於 Faculty 是 Employee 的子類，所以，在Faculty 構造方法中的所有語句執行之前，先調用 Employee 的無參構造方法。Employee 的無參構造方法調用Employee 的第二個構造方法（第13 行）。由於 Employee 是 Person 的子類，所以，在 Employee 的第二個構造方法中所有語句執行之前，先調用 Person 的無參構造方法。</em></p><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/abe50683e8c648988ef25bd135059c31><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right>2.3 調用父類的方法</h1><p style=text-align:start><strong>super.方法名（參數）；</strong></p><h1 class=pgc-h-arrow-right>3.方法重寫</h1><p style=text-align:start>子類從父類中繼承方法。有時，子類需要修改父類中定義的方法的實現，這稱作方法重 寫（method overriding)，：要重寫一個方法，<strong>需要在子類中使用和父類一樣的簽名以及一樣的返回值類型</strong>來對該方法進行定義。</p><p style=text-align:start>注意以下幾點：</p><ol start=1><li>僅當實例方法是可訪問時，它才能被覆蓋。因為私有方法在它的類本身以外是不能訪問的，所以它不能被覆蓋。如果子類中定義的方法在父類中是私有的，那麼這兩個方法完全沒有關係。</li><li>子類不能用語法 super.super.toStringO 訪問父類的父類中的toString ，這是一個語法錯誤。</li><li>與實例方法一樣，靜態方法也能被繼承。但是，<strong>靜態方法不能被覆蓋</strong>。如果父類中定義的靜態方法在子類中被重新定義，那麼在父類中定義的靜態方法將被隱藏。可以使用語法：<strong>父類名 .靜態方法名（SuperClassName.staticMethodName) 調用隱藏的靜態方法。</strong></li></ol><p style=text-align:start><em>這個再次詳細說明一下</em></p><pre><code>public class StaticExtends {    public static void main(String[] args) {        //聲明為Father類,son1靜態方法和Father類綁定        Father son = new Son();        son.method();        son.staticMethod();        Son son2 = new Son();        son2.method();        son2.staticMethod();    }}class Father {    void method() {        System.out.println("父類方法");    }    static void staticMethod() {        System.out.println("父類靜態方法");    }}class Son extends Father {    @Override    void method() {        System.out.println("子類方法");    }    static void staticMethod() {        System.out.println("子類靜態方法");    }}</code></pre><p style=text-align:start>輸出結果：</p><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d023a071e4e54717aaf8772a42d5d895><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>在子類中重寫父類的static方法，是不會報錯的，編譯也可以通過，但是在通過一個聲明為父類，實際類型為子類的引用變量調用該方法時，發現被調用的仍是父類中原本以為會被覆蓋的方法，不具有“多態”特性。所以呢，父類的static方法是不會被重寫的。</p><h1 class=pgc-h-arrow-right>4.Object類及其常用方法</h1><p style=text-align:start><strong>Java 中的所有類都繼承自 java.lang.Object 類</strong>，如果在定義一個類時沒有指定繼承性，那麼這個類的父類就被默認為是 Object。</p><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46012e685ebb416d9345079b3087afad><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>4.1 toString（）方法</h1><p style=text-align:start>Object 類中toString（）方法的默認實現是：</p><pre><code>public String toString() {        return getClass().getName() + "@" + Integer.toHexString(hashCode());     }</code></pre><p style=text-align:start>調用一個對象的 toString（） 會返回一個描述該對象的字符串。默認情況下，它<em>返回一個由該對象所屬的類名、at 符號（@)以及該對象十六進制形式的內存地址組成的字符串。</em>這個信息不是很有用，所以重寫。</p><ul><li>像String、Date、File、包裝類等都重寫了Object類中的toString()方法。使得在調用對象的toString()時，返回"實體內容"信息。</li><li>可以根據需要在用戶自定義類型中重寫toString()方法。 如String 類重寫了toString()方法，返回字符串的值。</li></ul><pre><code>s1=“hello”;System.out.println(s1);//相當於System.out.println(s1.toString());</code></pre><ul><li>基本類型數據轉換為String類型時，調用了對應包裝類的toString()方法</li></ul><pre><code>int a=10; System.out.println(“a=”+a);</code></pre><h1 class=pgc-h-arrow-right>4.2 equals（）方法</h1><p style=text-align:start>Object 類中 equals 方法的默認實現是：</p><pre><code>public boolean equals(Object obj) {return (this obj); }</code></pre><p style=text-align:start><em>說明：Object類中定義的equals()和==的作用是相同的：比較兩個對象的地址值是否相同.即兩個引用是否指向同一個對象實體。</em></p><ul><li>像String、Date、File、包裝類等都重寫了Object類中的equals()方法。重寫以後，比較的不是兩個引用的地址是否相同，而是比較兩個對象的"實體內容"是否相同。</li><li>通常情況下，我們自定義的類如果使用equals()的話，也<em>通常是比較兩個對象的"實體內容"是否相同</em>。那麼，我們 就需要對Object類中的equals()進行重寫。<em>重寫的原則：比較兩個對象的實體內容是否相同</em></li></ul><p style=text-align:start>tips：==和equals的區別：</p><ul><li>1 = 既可以比較基本類型也可以比較引用類型。對於基本類型就是比較值，對於引用類型 就是比較內存地址</li><li>2 equals的話，它是屬於java.lang.Object類裡面的方法，如果該方法沒有被重寫過默認也是;我們可以看到String等類的equals方法是被重寫過的，而且String類在日常開發中用的比較多，久而久之，形成了equals是比較值的錯誤觀點。</li><li>3 具體要看自定義類裡有沒有重寫Object的equals方法來判斷。</li><li>4 通常情況下，重寫equals方法，會比較類中的相應屬性是否都相等。</li></ul><h1 class=pgc-h-arrow-right>二. 多態</h1><h1 class=pgc-h-arrow-right>5.1 介紹</h1><p style=text-align:start>首先呢，我們知道繼承關係使一個子類繼承父類的特徵，並且附加一些新特徵。子類是它的父類的特殊化，每個子類的實例都是其父類的實例，但是反過來就不成立。例如：每個圓都是一個幾何對象，但並非每個幾何對象都是圓。因此，總可以將子類的實例傳給需要父類型的參數。<strong>使用父類對象的地方都可以使用子類的對象。這就是通常所說的多態。簡單來說，多態意味著父類型的變量可以引用子類型的對象。</strong></p><h1 class=pgc-h-arrow-right>5.2 動態綁定</h1><p style=text-align:start>我們都知道方法可以在父類中定義而在子類中重寫。（方法可以在沿著繼承鏈的多個類中實現。JVM 決定運行時調用哪個方法。）那麼</p><pre><code>Object o = new SonObject();System.out.println(o.toSting）；</code></pre><p style=text-align:start>這裡的 o 調用哪個 tostring（） 呢？ 我們首先介紹兩個術語：<strong>聲明類型和實際類型</strong>。<strong>一個變量必須被聲明為某種類型。變量的這個類型稱為它的聲明類型（declared type)。</strong>這裡，o 的聲明類型是 Object。一個引用類型變量可以是一個 null 值或者是一個對聲明類型實例的引用。實例可以使用聲明類型或它的子類型的構造方法創建。<strong>變量的實際類型（actual type) 是被變量引用的對象的實際類</strong>。這裡，o 的實際類型是SonObject, 因為 o 指向使用 new SonObject（） 創建的對象。o 調用哪個toString（） 方法由 o 的實際類型決定。這稱為動態綁定（dynamic binding)。 <em><strong>也就是多態情況下，==編譯時，看左邊；運行時，看右邊。== “看左邊”：看的是父類的引用（父類中不具備子類特有的方法） “看右邊”：看的是子類的對象（實際運行的是子類重寫父類的方法）</strong></em></p><p style=text-align:start>態綁定工作機制如下：假設對象 o 是類 Cl, C2, … ，Cn-1, Cn 的實例，其中 C1是 C2的子類，C2 是 C3 的子類，… ，Cn-1是 Cn 的子類。也就是說，Cn 是最通用的類，C1是最特殊的類。在 Java 中，Cn 是 Object 類。如果對象 o 調用一個方法 p, 那麼JVM 會依次在類 Cl，C2, … ，Cn-1，Cri 中查找方法 p 的實現，<em>直到找到為止</em>。<em>一旦找到一個實現，就停止査找，然後調用這個首先找到的實現。</em></p><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/55f92d2f077644029abd0b680aa752e1><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>看以下代碼：</p><pre><code>public class DynamicBindDemo {    public static void main(String[] args) {        m(new GraduateStudent());        m(new Student());        m(new Person());        m(new Object());    }    public static void m(Object x) {        System.out.println(x.toString());    }}class GraduateStudent extends Student {}class Student extends Person {    @Override    public String toString() {        return "Student";    }}class Person {    @Override    public String toString() {        return "Person";    }}</code></pre><p style=text-align:start>輸出結果：</p><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/207a2fa11ce344bc9b7ab83b013659a1><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>5.3 對象轉換和instanceof()運算符</h1><h1 class=pgc-h-arrow-right>5.3.1 對象轉換</h1><p style=text-align:start><strong>對象的引用可以類型轉換為對另外一種對象的引用，這稱為對象轉換。</strong></p><pre><code>Object o = new Student();m(o);</code></pre><p style=text-align:start><strong>Student 的實例也是 Object 的實例</strong>，所以，語句 Object o = new StudentO 是合法的，它稱為隱式轉換（implicit casting)。 但是Student b = o；將會發生編譯錯誤，原因是 Student 對象總是 Object 的實例，但是，Object 對象不一定是 Student 的實例。即使可以看到 0實際上是一個 Student 的對象，但是編譯器還沒有聰明到知道這一點。為了告訴編譯器o就是一個 Student 對象，就要使用顯式轉換( explicit casting)。</p><pre><code>Student b = (Student)o;// Explicit casting</code></pre><p style=text-align:start><strong>總是可以將一個子類的實例轉換為一個父類的變量，稱為向上轉換（upcasting)</strong>,因為子 類的實例永遠是它的父類的實例。當把一個父類的實例轉換為它的子類變量（稱為向下轉換 (downcasting)) 時，必須使用轉換記號 “(子類名)” 進行顯式轉換，向編譯器表明你的意圖。 為使轉換成功，必須確保要轉換的對象是子類的一個實例。如果父類對象不是子類的一個 實例，就會出現一個運行異常 ClassCastException。</p><h1 class=pgc-h-arrow-right>5.3.2instanceof運算符</h1><p style=text-align:start>在嘗試轉換之前確保該對象是另一個對象的實例，可以利用運算符instanceof 來實現的。</p><pre><code>Objecto = new Circle();if (o instanceof Circle){Circle c = ((Circle)o;System.out.println("The circle diameter is + o.getDiameter());</code></pre><ul><li><strong>① a instanceof A:判斷對象a是否是類A的實例。如果是，返回true；如果不是，返回false。</strong></li><li>② 如果 a instanceof A返回true,則 a instanceof B也返回true.其中，類B是類A的父類。</li><li>③ 要求a所屬的類與類A必須是子類和父類的關係，否則編譯錯誤。</li></ul><p style=text-align:start>變量 myObject 被聲明為 Object。<strong>聲明類型 決定了在編譯時匹配哪個方法。</strong>使用 myObject.getDiameter()會引起一個編譯錯誤，因為Object 類沒有 getDiameter 方法。編譯器無法找到和 myObject.getDiameter()匹配的方法。所以，有必要將 myObject 轉換成 Circle 類型，來告訴編譯器 myObject 也是 Circle 的一個實例。<em>同時要注意，引用變量 o和 c指向同一個對象，而在進行基本數據類型轉換時，會創建一個新的對象。</em></p><p style=text-align:start><em>為什麼沒有在一開始就把 myObject定義為 Circle 類型呢？為了能夠進行通用程序設計，一個好的經驗是把變童定義為父類型，這樣，它就可以接收任何子類型的值。</em></p><div class=pgc-img><img alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cd0c93a0b5d84bd78a1b6b696664035c><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>注意：：對象成員訪問運算符（ .）優先於類型轉換運算符。使用圓括號保證在點運算符（ .）之前進行轉換，例如:((Circle)object).getArea();</p><h1 class=pgc-h-arrow-right>最後</h1><p style=text-align:start>大家看完有什麼不懂的可以在下方留言討論.<br>謝謝你的觀看。<br>覺得文章對你有幫助的話記得關注我點個贊支持一下！<br>鏈接：https://juejin.im/post/6864894838878240782</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>繼承</a></li><li><a>多態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af4bb85.html alt=Java基礎系列：理解Java多態的實現機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cd7b252f82e04b6da1d594eab4d030b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af4bb85.html title=Java基礎系列：理解Java多態的實現機制>Java基礎系列：理解Java多態的實現機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html alt=Java基礎（多態的理解與應用) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html title=Java基礎（多態的理解與應用)>Java基礎（多態的理解與應用)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html alt=Java筆記之——多態詳解（重要） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/002a620d6944415d8d650a5636c4ff41 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html title=Java筆記之——多態詳解（重要）>Java筆記之——多態詳解（重要）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d55e8ff.html alt=小白學習——Java多態和動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/43aa8625bbe34057b3f71ee66a2c0ece style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d55e8ff.html title=小白學習——Java多態和動態綁定>小白學習——Java多態和動態綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html alt=詳解Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/88a6dd8200454e0eb96a868562c38b4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html title=詳解Java多態>詳解Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3590ca7.html alt=C#繼承和多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3590ca7.html title=C#繼承和多態>C#繼承和多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ae124314-674a-47ca-b794-c5b32a309a66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html title=Java多態的實現機制是什麼，看完你就知道（值得收藏）>Java多態的實現機制是什麼，看完你就知道（值得收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9427df4.html alt=Java面向對象——多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aeb5a80f2ae143899e63547c947fe881 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9427df4.html title=Java面向對象——多態>Java面向對象——多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51db267.html alt=Java面向對象之：接口、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d3f6934313714e52ae0687177d6ea9ad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51db267.html title=Java面向對象之：接口、多態>Java面向對象之：接口、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ba13aa.html alt=深度分析：理解Java中的多態機制，一篇直接幫你掌握 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/8a2dcdde-0235-4f88-aac0-d3a45f6d83d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ba13aa.html title=深度分析：理解Java中的多態機制，一篇直接幫你掌握>深度分析：理解Java中的多態機制，一篇直接幫你掌握</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>