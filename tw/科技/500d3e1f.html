<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>算法 － 七大排序算法詳細介紹 | 极客快訊</title><meta property="og:title" content="算法 － 七大排序算法詳細介紹 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="算法 － 七大排序算法詳細介紹"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/500d3e1f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>算法 － 七大排序算法詳細介紹</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>排序的相關概念</p><p class=ql-align-justify>排序的分類</p><ul><li class=ql-align-justify>根據在排序過程中<strong>帶排序的記錄</strong>是否全部被放置在內存中，排序分為：</li><li class="ql-align-justify ql-indent-1">內排序</li><li class="ql-align-justify ql-indent-1">外排序</li></ul><p class=ql-align-justify>1.內排序</p><p class=ql-align-justify><strong>內排序是在排序整個過程中，帶排序的所有記錄全部放置在內存中</strong>。</p><p class=ql-align-justify>影響內排序的主要因素</p><ul><li class=ql-align-justify>時間性能。</li><li class="ql-align-justify ql-indent-1">(主要受<strong>比較</strong>和<strong>移動</strong>兩種操作的影響）</li><li class=ql-align-justify>輔助空間。</li><li class=ql-align-justify>算法的複雜性。</li></ul><p class=ql-align-justify><strong>內排序的分類</strong></p><p class=ql-align-justify>根據排序過程中<strong>藉助的主要操作</strong>，內排序分為：</p><ul><li class=ql-align-justify>插入排序</li><li class=ql-align-justify>交換排序</li><li class=ql-align-justify>選擇排序</li><li class=ql-align-justify>歸併排序</li></ul><p class=ql-align-justify>2.外排序</p><p class=ql-align-justify><strong>外排序是由於排序的記錄個數太多，不能同時放置在內存中，整個排序過程需要在內外存之間多次交換數據才能進行</strong>。</p><p class=ql-align-justify>按照算法的複雜度分類</p><ul><li class=ql-align-justify>簡單算法：</li><li class="ql-align-justify ql-indent-1">冒泡排序、簡單選擇排序、直接插入排序。</li><li class=ql-align-justify>複雜排序：</li><li class="ql-align-justify ql-indent-1">希爾排序、堆排序、歸併排序、快速排序。</li></ul><p class=ql-align-justify><br></p><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>一、冒泡排序算法</p><p class=ql-align-justify>因為在冒泡排序中要用到<strong>順序表結構</strong>和<strong>數組兩元素的交換</strong>，先把這些寫成函數</p><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 100#define TRUE 1#define FALSE 0typedef struct {  int r[MAXSIZE + 1]; int length;}SqList;void swap(SqList *L, int i, int j){ int temp = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[j]; L-&gt;r[j] = temp;}</pre><p class=ql-align-justify>1.1 冒泡排序的初級版實現</p><p class=ql-align-justify>冒泡排序（Bubble Sort）是一種<strong>交換排序</strong>，它的基本思想是：<strong>兩兩比較相鄰記錄的關鍵字，如果反序則交換，直到沒有反序的記錄為止</strong>。</p><ul><li><br></li></ul><pre>void BubblSort0(SqList *L){ int i,j;  for (i = 1; i &lt; L-&gt;length; i++) for (j = i+1; j &lt;= L-&gt;length; j++) if (L-&gt;r[i] &gt; L-&gt;r[j]) swap(L, i, j);}</pre><p class=ql-align-justify>對於這段代碼，是最簡單的冒泡，其實就是最簡單的交換排序而已。<strong>它的思路就是讓每一個關鍵字，都和它後面的每一個關鍵字比較，如果大則交換，這樣第一位置的關鍵字在第一次循環後一定變成最小值</strong>。</p><p class=ql-align-justify>假設我們待排序的關鍵字序列是{9，1，5，8，3，7，4，6，2}</p><ul><li class=ql-align-justify>當i = 1時，9與1交換後，在第一位置的1與後面的關鍵字比較都小，因此它就只最小值。</li><li class=ql-align-justify>當i = 2時，第二位置先後由9換成5，換成3，換成2，完成了第二小的數字交換。</li><li class=ql-align-justify>後面數字依次比較和交換，得到最終結果。</li></ul><p class=ql-align-justify><br></p><div class=pgc-img><img alt="算法 － 七大排序算法詳細介紹" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>1.2 冒泡排序的實現</p><p class=ql-align-justify>對於上面的算法，代碼雖然簡單易懂，但是效率非常低。可以改進成接下來的代碼</p><ul><li><br></li></ul><pre>void BubbleSort(SqList *L){ int i,j; for (i = 1; i &lt; L-&gt;length; i++) for (j = L-&gt;length - 1; j &gt;= i; j--) if (L-&gt;r[j] &gt; L-&gt;r[j+1]) swap(L, j, j+1);}</pre><p class=ql-align-justify>代碼解釋</p><p class=ql-align-justify>假設我們待排序的關鍵字序列是{9，1，5，8，3，7，4，6，2}</p><ul><li class=ql-align-justify>當i = 1時，<strong>變量j由8反向循環到1</strong>，逐個比較，將<strong>較小值</strong>交換到前面，直到最後找到最小值放置在了第1的位置。</li><li class=ql-align-justify>當i = 1、 j = 8時，6 > 2 ，因此交換了它們的位置，j = 7時，4 > 2， 所以交換......直到j = 2時，因為 1 &lt; 2， 所以不交換。</li><li class=ql-align-justify>j = 1 時，9 > 1，交換，最終得到最小值1放置第一的位置。</li><li class=ql-align-justify>在不斷循環的過程中，<strong>除了將關鍵字1放到第一的位置，還將關鍵字2從第九位置提到了第三的位置</strong>，顯然比前面的算法有進步。</li><li class=ql-align-justify>當i = 2時，變量j由8反向循環到2，逐個比較，<strong>在將關鍵字2交換到第二位置的同時，也將關鍵字4和3有所提升</strong>。</li></ul><p class=ql-align-justify>1.3 冒泡排序的優化</p><ul><li class=ql-align-justify>在排序的過程中，增加一個標記變量flag來記錄位置是否發生了變化</li><li class=ql-align-justify>如果沒有發生交換，說明數組已經有序了。</li><li><br></li></ul><pre>void BubbleSort1(SqList *L){ int i,j;  int flag = TRUE; for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) { flag = FALSE; for (j = L-&gt;length - 1; j &gt;= i; j--) { if (L-&gt;r[j] &gt; L-&gt;r[j+1]) { swap(L, j, j+1); flag = TRUE; } } }}</pre><p class=ql-align-justify>測試</p><pre>#define N 9int main(int argc, const char * argv[]) {  int i; int d[N] = {9,1,5,8,3,7,4,6,2};  SqList l0; for (i = 0; i &lt; N; i++) l0.r[i+1] = d[i]; l0.length = N;  printf("排序前：\n"); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n");  printf("1.0 初級冒泡排序結果:\n"); BubblSort0(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n");  printf("1.1 冒泡排序結果:\n"); BubbleSort(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n"); printf("1.2 優化後冒泡排序結果:\n"); BubbleSort1(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n"); return 0;}</pre><p class=ql-align-justify>測試結果</p><div class=pgc-img><img alt="算法 － 七大排序算法詳細介紹" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/12563821829046ff9e833e89c948b9d5><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>二、簡單選擇排序</p><p class=ql-align-justify>簡單選擇排序法(Simple Selection Sort)是<strong>通過n-i次關鍵字間的比較</strong>，<strong>從n-i+1個記錄中選出關鍵字最小的記錄，並和第i(1&lt;=i&lt;=n)個記錄交換</strong>。</p><p class=ql-align-justify>簡單選擇排序法的工作原理是：<strong>每一次從無序組的數據元素中選出最小（或最大）的一個元素，存放在無序組的起始位置，無序組元素減少，有序組元素增加，直到全部待排序的數據元素排完</strong>。</p><ul><li><br></li></ul><pre>void SelectSort(SqList *L){ int i, j, min; for (i = 1; i &lt; L-&gt;length; i++) { min = i; for (j = i + 1; j &lt;= L-&gt;length; j++) { if (L-&gt;r[min] &gt; L-&gt;r[j]) min = j; }  if (i != min)  swap(L, i, min); }}</pre><p class=ql-align-justify>代碼說明</p><ul><li class=ql-align-justify>簡單選擇排序相對簡單，交換移動數據的次數相當少，節約時間。</li><li class=ql-align-justify>簡單選擇排序的時間複雜度為O(n^2)。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>三、直接插入排序</p><p class=ql-align-justify>直接插入排序(Straight Insertion Sort)的基本操作是<strong>將一個記錄插入到已經排好序的有序表中，從而得到一個新的、記錄增1的有序表。</strong></p><p class=ql-align-justify>直接插入排序的核心思想：將一個記錄插入到一個已經排序好的表中，以得到一個記錄增加1的有序表。<strong>並且它把當前元素大的記錄都往後移動，用以騰出“自己”該插入的位置。</strong>當n-1趟插入完成後該記錄就是有序序列。</p><pre class=ql-align-justify>void InsertSort(SqList *L){ int i, j; for (i = 2; i &lt; L-&gt;length; i++) {  if (L-&gt;r[i] &lt; L-&gt;r[i-1]) {  L-&gt;r[0] = L-&gt;r[i]; for (j = i-1; L-&gt;r[j] &gt; L-&gt;r[0]; j++) L-&gt;r[j+1] = L-&gt;r[i];  L-&gt;r[j+1] = L-&gt;r[0]; } }}</pre><p class=ql-align-justify>代碼說明</p><ul><li class=ql-align-justify>直接插入排序的時間複雜度為O(n^2)。</li><li class=ql-align-justify>直接插入排序比冒泡和簡單選擇排序的性能要好一些。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>四、希爾排序</p><p class=ql-align-justify>希爾排序是對直接插入排序的改進：</p><ul><li class=ql-align-justify><strong>將原本有大量記錄數的記錄進行分組。分割成若干個子序列</strong>；</li><li class=ql-align-justify>對子序列<strong>分別進行直接插入排序</strong>；</li><li class=ql-align-justify>當整個序列都<strong>基本有序時</strong>（<em>注意是基本有序</em>），再對全體記錄進行一次直接插入排序。</li><li class=ql-align-justify>所謂的<strong>基本有序</strong>，<strong>就是小的關鍵字基本在前，大的基本在後面，不大不小的基本在中間</strong>，如{9,1,5,8,3,7,5,6,2}，變成{2,1,3,6,4,7,8,9}這樣就是<strong>基本有序</strong>，但是像{1,5,9,7,8,2,4,6}這樣9在第三位，2在倒數第三位就不是基本有序。</li><li class=ql-align-justify>對於分割子序列，採取<strong>跳躍分割的策略</strong>：</li><li class=ql-align-justify><strong>將相距某個“增量”的記錄組成一個子序列</strong>，這樣才能保證在子序列內分別進行直接插入排序後得到的結果是基本有序而不是局部有序。</li><li class=ql-align-justify>增量的選取非常關鍵，但是現在還是一個數學難題(迄今沒有找到一種最好的增量序列),大量研究表明，增量序列為dlta[k] = 2^(t-k+1) - 1時，可以獲得不錯的效果。</li></ul><p class=ql-align-justify>希爾排序的核心思想：<strong>希爾排序是把記錄按下標的一定增量分組，對每組使用直接插入排序算法排序；隨著增量逐漸減少，每組包含的關鍵詞越來越多，當增量減至1時，整個文件恰被分成一組，算法便終止</strong></p><ul><li><br></li></ul><pre>void ShellSort(SqList *L){  int i,j;  int increment = L-&gt;length;  do { increment = increment /3 +1;  for (i = increment + 1; i &lt; L-&gt;length; i++) {  if (L-&gt;r[i] &lt; L-&gt;r[i-increment]) {  L-&gt;r[0] = L-&gt;r[i];  for (j = i - increment; i &gt;0 &amp;&amp; L-&gt;r[0] &lt; L-&gt;r[j]; j -= increment) L-&gt;r[j+increment] = L-&gt;r[j];  L-&gt;r[j+increment] = L-&gt;r[0]; } } } while (increment &gt; 1);}</pre><p class=ql-align-justify>代碼說明</p><ul><li class=ql-align-justify>希爾排序的時間複雜度為O(n^(3/2))，要好於直接插入排序的O(n^2);</li><li class=ql-align-justify><strong>增量的最後一個增量之必須等於1才行</strong>。</li><li class=ql-align-justify>由於記錄是跳躍式的移動，所以希爾排序<strong>不是一種穩定的排序算法</strong>。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>五、堆排序</p><p class=ql-align-justify>堆的概念</p><p class=ql-align-justify>堆是具有如下性質的<strong>完全二叉樹</strong>：</p><ul><li class=ql-align-justify>每個結點的值都<strong>大於或等於其其左右孩子結點的值，為大頂堆</strong>。</li><li class=ql-align-justify>或者每個結點的值都<strong>小於或等於其左右孩子結點的值，稱為小頂堆</strong>。</li><li class=ql-align-justify>因此<strong>根節點一定是堆中所有結點最大（小）者</strong>。</li><li class=ql-align-justify>如圖左邊為大頂堆，右邊為小頂堆：</li></ul><div class=pgc-img><img alt="算法 － 七大排序算法詳細介紹" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/38cd58b7790a484fa73f96020a2a12cd><p class=pgc-img-caption></p></div><ul><li class=ql-align-justify><br></li><li class=ql-align-justify>左邊為大頂堆，右邊為小頂堆</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify>堆排序算法</p><p class=ql-align-justify><strong>堆排序（Heap Sort）</strong>是利用堆（假設是大頂堆）進行排序。</p><p class=ql-align-justify>堆排序的核心思想：</p><ul><li class=ql-align-justify>將待排序的序列構造成一個大頂堆。</li><li class=ql-align-justify>此時，<strong>整個序列的最大值就是堆頂的根節點。</strong></li><li class=ql-align-justify>將根節點移走(<strong>其實就是將它與堆數組的末尾元素交換，此時末尾元素就是最大值</strong>)，然後將剩餘的n-1個序列重新構造成一個堆，這樣就會得到n個元素的次小值。</li><li class=ql-align-justify>重複上訴操作，便能得到一個有序序列。</li></ul><p class=ql-align-justify><br></p><div class=pgc-img><img alt="算法 － 七大排序算法詳細介紹" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5515ac00d7e945519f8f771b21b617dd><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>堆排序算法核心</p><ul><li class=ql-align-justify>如何由一個無序序列構建成一個堆</li><li class=ql-align-justify>如何在輸出堆頂元素後，調整剩餘元素成一個新的堆</li></ul><p class=ql-align-justify>堆排序算法代碼實現</p><ul><li><br></li></ul><pre>void HeadAdjust(SqList *L, int s, int m){ int temp, j; temp = L-&gt;r[s];  for (j = 2 *s; j &lt;= m; j *= 2) {  if (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+1]) j++;  if (temp &gt;= L-&gt;r[j]) break;  L-&gt;r[s] = L-&gt;r[j]; s = j; }  L-&gt;r[s] = temp;}void HeapSort(SqList *L){ int i;  for (i = L-&gt;length / 2; i&gt;0; i--) HeadAdjust(L, i, L-&gt;length);  for (i = L-&gt;length; i &gt; 1; i--) { swap(L, 1, i); HeadAdjust(L, 1, i-1); }}</pre><p class=ql-align-justify>堆排序算法代碼說明</p><ul><li class=ql-align-justify>堆排序方法HeapSort中有兩個for循環：</li><li class=ql-align-justify>第一個for循環完成將現在的待排序序列構建成一個大頂堆；</li><li class=ql-align-justify>第二個for循環完成逐漸將每個最大值的根節點與末尾元素交換，並且再調整其成為大頂堆。</li><li class="ql-align-justify ql-indent-1">第一個for循環中的i = L->length / 2,i從[9/2]=4開始，4->3->2->1的變化量。</li><li class="ql-align-justify ql-indent-1">（這裡賦值的原因是這些都是有孩子的結點）</li><li class="ql-align-justify ql-indent-1">構建好有孩子的結點之後，就可以從上到下、從左到右，將每個將每個非終端結點（非葉子結點）當做<strong>根節點</strong>,將其和子樹調整成大頂堆。</li><li class=ql-align-justify>函數HeadAdjust的作用是將數組構建成一個大頂堆，在構建的時候利用了二叉樹的性質。</li><li class=ql-align-justify>構建堆的時間複雜度為O(n)，重建堆的時間複雜度為O(nlogn)，所以總體來說<strong>堆排序的時間複雜度為O(nlogn)</strong>，性能上遠好於冒泡、簡單選擇、直接插入的時間複雜度。</li><li class=ql-align-justify>在空間複雜度上，由於記錄的交換和比較是跳躍式進行的，所以<strong>堆排序是一種不穩定的排序方法</strong>。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>六、歸併排序</p><p class=ql-align-justify><strong>歸併排序(Merging Sort)</strong>是利用歸併的思想實現的。2路歸併排序的核心思想如下：</p><ul><li class=ql-align-justify>假設初始序列有n個記錄，則可以看成是n個有序的子序列，每個子序列的長度為<strong>1</strong>，然後兩兩歸併，得到n/2個長度為2或者1的有序子序列</li><li class=ql-align-justify>再兩兩歸併...如此重複，直至得到一個長度為n的有序序列為止。</li></ul><p class=ql-align-justify>6.1歸併排序的實現思路（遞歸實現）</p><ul><li class=ql-align-justify>將序列平均分成兩部分</li><li class=ql-align-justify>分別對這兩部分用遞歸來歸併</li><li class=ql-align-justify>將這兩部分歸併到一起</li></ul><p class=ql-align-justify>歸併排序的代碼實現（遞歸實現）</p><ul><li><br></li></ul><pre>#pragma - 6.歸併排序(遞歸實現)void Merge(int SR[], int TR[], int i, int m, int n){  int j, k, l;  for (j = m+1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) {  if (SR[i] &lt; SR[j]) TR[k] = SR[i++]; else TR[k] = SR[j++]; }  if (i &lt;= m) { for (l=0; l &lt;= m-i; l++) TR[k+l] = SR[i+l]; }  if (j &lt;= n) { for (l=0; l &lt;= n-j; l++) TR[k+l] = SR[j+l]; }}void MSort(int SR[], int TR1[], int s, int t){ int m; int TR2[MAXSIZE+1];  if (s == t) { TR1[s] = SR[s]; }else{ m = (s+t)/2; MSort(SR, TR2, s, m); MSort(SR, TR2, m+1, t); Merge(TR2, TR1, s, m, t); }}void MergeSort(SqList *L){ MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>歸併排序的總結（遞歸實現）</p><ul><li class=ql-align-justify>歸併排序總的時間複雜度為O(nlogn)，並且這是歸併排序算法中最好、最壞、平均的時間性能。</li><li class=ql-align-justify>歸併排序的空間複雜度為O(n+logn)</li><li class=ql-align-justify>歸併排序是一種比較佔內存，但是<strong>效率高且穩定</strong>的算法。</li></ul><p class=ql-align-justify>6.2歸併排序的實現（迭代非遞歸實現）</p><p class=ql-align-justify>用迭代實現的話，可以<strong>從最小的序列開始歸併直到完成</strong>。</p><ul><li><br></li></ul><pre>#pragma - 7.歸併排序（迭代實現）void MergePass(int SR[], int TR[], int s, int n){  int i = 1; int j;  while (i &lt;= n-2*s+1) { Merge(SR, TR, i, i+s-1, i+2*s-1); i = i+2*s; }  if (i &lt; n-s+1) Merge(SR, TR, i, i+s-1, n); else for (j = i; j &lt;= n; j++) TR[j] = SR[j];}void MergeSort2(SqList *L){  int * TR = (int *)malloc(sizeof(L-&gt;length*sizeof(int))); int k = 1;  while (k &lt; L-&gt;length) { MergePass(L-&gt;r, TR, k, L-&gt;length); k = 2*k;  MergePass(TR, L-&gt;r, k, L-&gt;length); k = 2*k; }}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>歸併的迭代實現總結</p><ul><li class=ql-align-justify>非遞歸的迭代方法，避免了遞歸時深度為log2n的棧空間，空間只是用到申請歸併臨時用的TR數組，因此<strong>空間複雜度為O(n)</strong>.</li><li class=ql-align-justify>並且相對於遞歸，在時間性能上也有一定的提升，所以使用歸併時，<strong>儘量使用非遞歸實現。</strong></li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>七、快速排序</p><p class=ql-align-justify><strong>快速排序(Quick Sort)</strong>的基本思想是：</p><ul><li class=ql-align-justify>通過一趟排序將待排序記錄分割成獨立的兩部分</li><li class=ql-align-justify>其中一部分記錄的關鍵字均比另一部分記錄的關鍵字小；</li><li class=ql-align-justify>則可分別對這兩部分記錄繼續進行排序，以達到整個序列有序的目的。</li></ul><p class=ql-align-justify>快速排序的實現思路</p><ul><li class=ql-align-justify>選取一個<strong>關鍵字</strong>，放到一個位置，<strong>使得它的左邊的值都比它小，右邊的值都比它大</strong>，這個關鍵字叫做<strong>樞軸（pivot)</strong></li><li class=ql-align-justify>然後分別對左邊和右邊進行排序。</li></ul><p class=ql-align-justify>快速排序的代碼實現</p><ul><li><br></li></ul><pre>#pragma - 8.快速排序int Partition(SqList * L, int low, int high){  int pivotkey; pivotkey = L-&gt;r[low];  while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high --; swap(L, low, high);  while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) high++; swap(L, low, high); }  return low;}void QSort(SqList *L, int low, int high){  int pivot; if (low &lt; high) { pivot = Partition(L, low, high); QSort(L, low, pivot-1); QSort(L, pivot+1, high); }}void QuickSort(SqList *L){ QSort(L, 1, L-&gt;length);}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>快速排序的代碼說明</p><ul><li class=ql-align-justify>Partition函數就是將選取的pivotkey不斷交換，<strong>將比它小的換到它的左邊，比它大的交換到它的右邊，它也在交換中不斷更改自己的位置</strong>，直到完全滿足這個要求為止。</li><li class=ql-align-justify>快速排序的時間性能取決於快速遞歸的深度，<strong>快排的時間複雜度為O(nlogn)</strong>。</li><li class=ql-align-justify>快速排序的空間複雜度主要是遞歸造成的棧空間的使用，平均情況下<strong>空間複雜度為O(nlogn)。</strong></li><li class=ql-align-justify>由於關鍵字的比較和交換是跳躍進行的，因此，<strong>快排是一種不穩定的排序算法</strong></li></ul><p class=ql-align-justify>快速排序的優化</p><ol><li class=ql-align-justify><strong>優化選取樞軸</strong></li><li class=ql-align-justify>在上面的代碼中，選取樞軸的方式為：</li><li class=ql-align-justify>pivotkey = L->r[low]，即用序列的第一個元素作為樞軸，這是理想情況下 L->r[low]是中間數。</li><li class=ql-align-justify>但是對於其他情況，這種<strong>固定選取</strong>第一個關鍵子作為首個樞軸的方法就不是很合理。</li><li class=ql-align-justify>於是可以用下面的方法優化：</li></ol><ul><li class="ql-align-justify ql-indent-1"><strong>三數取中(median-of-three)法</strong>：</li><li class="ql-align-justify ql-indent-1"><strong>取三個關鍵子進行排序，將中間數作為樞軸，一般取左端、右端和中間三個數</strong>，也可以隨機選取。</li><li class="ql-align-justify ql-indent-1"><strong>九數取中(median-of-nine)法</strong>：</li><li class="ql-align-justify ql-indent-1">先從數組中分三次取樣，每次取三個數，三個樣品各取中數，然後從這三個數當中再取出一箇中數作為樞軸</li></ul><p class=ql-align-justify><strong>三數取中(median-of-three)法</strong>代碼：</p><ul><li><br></li></ul><pre> int pivotkey;  int m = low + (high - low)/2;  if (L-&gt;r[low] &gt; L-&gt;r[high]) swap(L, low, high);  if (L-&gt;r[m] &gt; L-&gt;r[high]) swap(L, high, m); if (L-&gt;r[m] &gt; L-&gt;r[low]) swap(L, m, low);  pivotkey = L-&gt;r[low];</pre><ol><li class=ql-align-justify><strong>優化不必要的交換</strong></li><li class=ql-align-justify><strong>優化小數組時的排序方案</strong></li><li class=ql-align-justify><strong>優化遞歸操作</strong></li></ol><p class=ql-align-justify>快速排序優化後的代碼</p><ul><li><br></li></ul><pre>int Partition1(SqList * L, int low, int high){  int pivotkey;  int m = low + (high - low)/2;  if (L-&gt;r[low] &gt; L-&gt;r[high]) swap(L, low, high);  if (L-&gt;r[m] &gt; L-&gt;r[high]) swap(L, high, m); if (L-&gt;r[m] &gt; L-&gt;r[low]) swap(L, m, low);  pivotkey = L-&gt;r[low]; L-&gt;r[0] = pivotkey;  while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high--; L-&gt;r[low] = L-&gt;r[high];  while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; L-&gt;r[high] = L-&gt;r[low]; }  L-&gt;r[low] = L-&gt;r[0];  return low;}void QSort1(SqList *L, int low, int high){  int pivot; if ((high -low) &gt; MAX_LINEGIH_INSERT_SORT) { while (low &lt; high) { pivot = Partition1(L, low, high); QSort1(L, low, pivot-1);  low = pivot+1; } }else InsertSort(L);}void QuickSort1(SqList *L){ QSort1(L, 1, L-&gt;length);}</pre><ul><li class=ql-align-justify><strong>希爾排序</strong>相當於<strong>直接插入排序</strong>的升級，同屬於<strong>插入排序類</strong></li><li class=ql-align-justify><strong>堆排序</strong>相當於<strong>簡單選擇排序</strong>的升級，同屬於<strong>選擇排序類</strong></li><li class=ql-align-justify><strong>快速排序</strong>相當於<strong>冒泡排序</strong>的升級，同屬於<strong>交換排序類</strong></li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>算法</a></li><li><a>詳細介紹</a></li><li><a>排序</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html alt=深入淺出排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c898a3bab26542c2965d2bc5bebf9bd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html title=深入淺出排序算法>深入淺出排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html alt=程序員那些必須掌握的排序算法(上) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c32d187d725f4bd59225a5d09a38cb37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html title=程序員那些必須掌握的排序算法(上)>程序員那些必須掌握的排序算法(上)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html alt=算法之旅｜快速排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3b0e0000a716d98c3cba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html title=算法之旅｜快速排序法>算法之旅｜快速排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a35a8e8a.html alt=排序算法（1）——O(n^2) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/593b00001b3fdbe6409a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a35a8e8a.html title=排序算法（1）——O(n^2)>排序算法（1）——O(n^2)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html alt=算法小專欄：散列表（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a831970b0ccf4e4cbe591777ebd3f2a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html title=算法小專欄：散列表（二）>算法小專欄：散列表（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html alt=七大查找算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html title=七大查找算法>七大查找算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html alt=掌握算法-散列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html title=掌握算法-散列>掌握算法-散列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html alt=C#算法系列（1）——二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html title=C#算法系列（1）——二叉樹>C#算法系列（1）——二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3dc85d2e.html alt=JavaScript二叉樹（二叉搜索樹）的詳細介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9f01674b907b45c390bbc94168d16a71 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3dc85d2e.html title=JavaScript二叉樹（二叉搜索樹）的詳細介紹>JavaScript二叉樹（二叉搜索樹）的詳細介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html alt=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9b2026e861ad49e88e1e124dc67edb32 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html title=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）>算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html alt=算法題—完全二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ef7d8ad6eaca4524a71e1e5d1277532b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html title=算法題—完全二叉樹>算法題—完全二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c692a239.html alt=強連通分量與拓撲排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/70f8cf4acc804054acc4c73649b83179 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c692a239.html title=強連通分量與拓撲排序>強連通分量與拓撲排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6c4c12d.html alt=大理石平臺的詳細介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/31409e9fc4594b78add6a2188e972ab8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6c4c12d.html title=大理石平臺的詳細介紹>大理石平臺的詳細介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/566819ee.html alt=板式熱交換器的詳細介紹與優缺點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f16d3c5327ec4bcb979fab065366a299 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/566819ee.html title=板式熱交換器的詳細介紹與優缺點>板式熱交換器的詳細介紹與優缺點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/450f6d7d.html alt=氣焊工藝及操作流程的詳細介紹，焊將的收藏寶典！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153016574698000d1aead76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/450f6d7d.html title=氣焊工藝及操作流程的詳細介紹，焊將的收藏寶典！>氣焊工藝及操作流程的詳細介紹，焊將的收藏寶典！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>