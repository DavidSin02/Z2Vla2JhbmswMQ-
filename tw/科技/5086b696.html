<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>架構師成神之路 | 极客快訊</title><meta property="og:title" content="架構師成神之路 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/f284b547c7aa4e6f857167b519f5c885"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5086b696.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><meta property="article:published_time" content="2020-11-14T21:01:46+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:46+08:00"><meta name=Keywords content><meta name=description content="架構師成神之路"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5086b696.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>架構師成神之路</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>這是本人的架構師學習路線，分享出來希望能幫到大家，謝謝。</strong></p><p>https://blog.csdn.net/hguisu/article/details/78258430 架構設計</p><p>https://blog.csdn.net/u012410733/article/list/3?t=1 dubbo很好的博客</p><p>源碼：springmvc、mybatis、spring、dubbbo、rocketmq</p><p>一、常用設計模式</p><p>1、proxy模式</p><pre>package com.sun.proxy;import com.sun.cglibproxy.Cglibproxy;import com.sun.jdkproxy.JdkProxy;public class Main { public static void main(String[] args) { //靜態代理 Proxy proxy = new Proxy(new RealSubject()); proxy.request(); //jdk動態代理 JdkProxy jdkProxy = new JdkProxy(new RealSubject()); Subject subject1 = (Subject)jdkProxy.getProxyObject(); subject1.request(); //cglib動態代理 Cglibproxy cglibproxy = new Cglibproxy(new RealSubject()); Subject subject2 = (Subject)cglibproxy.getProxyObject(); subject2.request(); }}</pre><p>2、工廠模式</p><p>https://www.cnblogs.com/carryjack/p/7709861.html</p><p>https://www.cnblogs.com/zailushang1996/p/8601808.html</p><p>https://www.jianshu.com/p/74f4c52e1bd9</p><p>1）簡單工廠</p><p>2）工廠方法 //一個產品</p><p>2）抽象工廠 //多個產品，一個產品族</p><p>結合spring中的FactoryBean</p><p>閱讀原碼，FactoryBean是通過泛型傳遞實際對象的類型，它有三個方法：</p><p>a)getObject()，返回生成的對象;</p><p>b)getObjectType()，返回對象類型;</p><p>c)isSingleton() ，是否是單例，true:是，false:不是。</p><p>3、單例（Singleton）模式</p><p>https://www.cnblogs.com/cielosun/p/6582333.html</p><p>單例模式有3個要點：</p><p>某個類只能有一個實例</p><p>它必須自行創建這個實例</p><p>它必須自行向整個系統提供這個實例</p><p>1）懶漢模式</p><pre>public class SingletonDemo { private static SingletonDemo instance; private SingletonDemo(){ } public static SingletonDemo getInstance(){ if(instance==null){ instance=new SingletonDemo(); } return instance; }}</pre><p>如上，通過提供一個靜態的對象instance，利用private權限的構造方法和getInstance()方法來給予訪問者一個單例。</p><p>缺點是，沒有考慮到線程安全，可能存在多個訪問者同時訪問，並同時構造了多個對象的問題。之所以叫做懶漢模式，主要是因為此種方法可以非常明顯的lazy loading。</p><p>2）線程安全的懶漢模式</p><pre>public class SingletonDemo { private static SingletonDemo instance; private SingletonDemo(){ } public static synchronized SingletonDemo getInstance(){ if(instance==null){ instance=new SingletonDemo(); } return instance; }}</pre><p>然而併發其實是一種特殊情況，大多時候這個鎖佔用的額外資源都浪費了，這種打補丁方式寫出來的結構效率很低。</p><p>3）餓漢模式</p><pre>public class EHsingleton { private static EHsingleton instance = new EHsingleton(); private EHsingleton(){} public static EHsingleton getInstance(){ return instance; }}</pre><p>單例加載時就加載,這種方法沒有起到lazy loading的效果</p><p>4)靜態內部類加載</p><pre>public class StaticClasssingleton { private static class StaticClasssingletonHelper{ private static StaticClasssingleton instance = new StaticClasssingleton(); } private StaticClasssingleton(){ System.out.println("Singleton has loaded"); } public static StaticClasssingleton getInstance(){ return StaticClasssingletonHelper.instance; }}</pre><p>使用內部類的好處是，靜態內部類不會在單例加載時就加載，而是在調用getInstance()方法時才進行加載，達到了類似懶漢模式的效果，而這種方法又是線程安全的。</p><p>5)枚舉方法</p><pre>enum SingletonDemo{ INSTANCE; public void otherMethods(){ System.out.println("Something"); }}</pre><p>6)雙重校驗鎖法</p><p>//雙重校驗鎖法</p><pre>public class DoubleSynchronizedSingleton { private static DoubleSynchronizedSingleton instance; private DoubleSynchronizedSingleton(){}; public static DoubleSynchronizedSingleton getInstance(){ if(instance == null){ synchronized (DoubleSynchronizedSingleton.class) { if(instance == null){ instance = new DoubleSynchronizedSingleton(); } } } return instance; }}</pre><p>接下來我解釋一下在併發時，雙重校驗鎖法會有怎樣的情景：</p><p>STEP 1. 線程A訪問getInstance()方法，因為單例還沒有實例化，所以進入了鎖定塊。</p><p>STEP 2. 線程B訪問getInstance()方法，因為單例還沒有實例化，得以訪問接下來代碼塊，而接下來代碼塊已經被線程1鎖定。</p><p>STEP 3. 線程A進入下一判斷，因為單例還沒有實例化，所以進行單例實例化，成功實例化後退出代碼塊，解除鎖定。</p><p>STEP 4. 線程B進入接下來代碼塊，鎖定線程，進入下一判斷，因為已經實例化，退出代碼塊，解除鎖定。</p><p>STEP 5. 線程A初始化並獲取到了單例實例並返回，線程B獲取了在線程A中初始化的單例。</p><p>理論上雙重校驗鎖法是線程安全的，並且，這種方法實現了lazyloading。</p><p>//Spring單例模式與線程安全</p><p>https://www.cnblogs.com/wxd0108/p/5524756.html</p><p>同步機制採用了 “ 以時間換空間 ” 的方式，而 ThreadLocal 採用了 “ 以空間換時間 ” 的方式,前者僅提供一份變量，讓不同的線程排隊訪問，而後者為每一個線程都提供了一份變量，因此可以同時訪問而互不影響</p><p>ThreadLocal 是解決線程安全問題一個很好的思路，它通過為每個線程提供一個獨立的變量副本解決了變量併發訪問的衝突問題。在很多情況下， ThreadLocal 比直接使用 synchronized 同步機制解決線程安全問題更簡單，更方便，且結果程序擁有更高的併發性。</p><p>4、delegate 委派模式</p><pre>class A{ void method1(){...} void method2(){...}}class B{ //delegation A a = new A(); //method with the same name in A void method1(){ a.method1();} void method2(){ a.method2();} //other methods and attributes ...}public class Test{ public static void main(String args[]){ B b = new B(); b.method1();//invoke method2 of class A in fact b.method2();//invoke method1 of class A in fact }}</pre><p>委託的缺點：代碼量大，類更多。</p><p>----- delegate委派模式和Proxy代理模式 -----</p><p>Proxy :譯為代理， 被代理方（B）與代理方（A）的接口完全一致。</p><p>主要使用場景：為簡化編程（或無法操作B）而把請求交給代理方（A），由代理方與被代理方進行通信，以完成請求。</p><p>Delegete : 譯為委託</p><p>主要使用場景：一件事情（或一個請求）對象本身不知道怎樣處理，對象把請求交給其它對象來做。</p><p>簡單來講，可以這麼理解，代理是若干個對象實現了一個共同的接口，而委派只是說明一個對象引用了另一個對象，並不牽扯接口。</p><p>應用場景</p><p>Spring MVC框架中的DispatcherServlet其實就用了委派模式，也有人稱為是代理模式和策略模式的組合。</p><p>DispatcherServlet的委託流程</p><p>用戶發送請求——>DispatcherServlet，前端控制器收到請求後自己不進行處理，而是委託給其他的解析器進行處理，作為統一訪問點，進行全局的流程控制。</p><p>DispatcherServlet——>HandlerMapping，映射處理器將會把請求映射為HandlerExecutionChain對象（包含一個Handler處理器（頁面控制器）對象、多個HandlerInterceptor攔截器）對象。</p><p>DispatcherServlet——>HandlerAdapter，處理器適配器將會把處理器包裝為適配器，從而支持多種類型的處理器，即適配器設計模式的應用，從而很容易支持很多類型的處理器。</p><p>DispatcherServlet——> ViewResolver， 視圖解析器將把ModelAndView對象（包含模型數據、邏輯視圖名）解析為具體的View。</p><p>DispatcherServlet——>View，View會根據傳進來的Model模型數據進行渲染，此處的Model實際是一個Map數據結構。</p><p>返回控制權給DispatcherServlet，由DispatcherServlet返回響應給用戶，到此一個流程結束。</p><p>5、Strategy策略模式</p><p>https://www.jianshu.com/p/7b7de81cdfbe</p><p>準備一組算法，並將每一個算法封裝起來，使得它們可以互換</p><p>這個模式涉及到三個角色：</p><p>● 環境(Context)角色：持有一個Strategy的引用。</p><p>● 抽象策略(Strategy)角色：這是一個抽象角色，通常由一個接口或抽象類實現。此角色給出所有的具體策略類所需的接口。</p><p>● 具體策略(ConcreteStrategy)角色：包裝了相關的算法或行為。</p><p>策略模式的優點：</p><p> 算法可以自由切換；</p><p> 避免使用多重條件判斷；</p><p> 擴展性良好。</p><p>策略模式的缺點：</p><p> 策略類會增多</p><p> 所有策略類都需要對外暴露</p><p>策略模式的適用場景：</p><p> 當一個系統中有許多類，它們之間的區別僅在於它們的行為，希望動態地讓一個對象在許多行為中選擇一種行為時；</p><p> 當一個系統需要動態地在幾種算法中選擇一種時；</p><p> 當一個對象有很多的行為，不想使用多重的條件選擇語句來選擇使用哪個行為時。</p><p>6、prototype 原型模式</p><p>https://www.cnblogs.com/cxxjohnson/p/6403949.html</p><p>原型模式：原型模式就是從一個對象再創建另外一個可定製的對象，而且不需要知道任何創建的細節。</p><p>所謂原型模式，就是java中的克隆技術，以某個對象為原型。複製出新的對象。顯然新的對象具備原型對象的特點。效率高（避免了重新執行構造過程步驟）</p><p>克隆類似於new，但和new不同。new創建新的對象屬性採用的是默認值。克隆出來的對象的屬性值完全和原型對象相同。並且克隆出的新對象不會影響原型對象，克隆後。還可以再修改克隆對象的值。</p><p>要實現原型模式，必須實現Cloneable接口，而這個接口裡面是空的。</p><p>淺克隆：copy該對象，然後保留該對象原有的引用。也就是說不克隆該對象的屬性。</p><p>深克隆：copy該對象，並且把該對象的所有屬性也克隆出一份新的。</p><p>通過序列化和反序列化來實現深克隆對象：序列化需要原型對象實現Serializable接口</p><p>所以，通過原型模式創建對象，可以大大提高創建的效率，直接克隆，避免了重新執行構造過程。原型模式和工廠模式搭配起來，是常用的使用方式。</p><p>新的問題：Java的clone方法實現的是淺複製，對基本類型的複製，這樣的操作是沒有問題的。但對非基本類型的變量，複製的是對象的引用，導致最後兩個變量指向同一個對象。</p><p>解決方法：深複製</p><p>PS：深拷貝與淺拷貝問題中，會發生深拷貝的有java中的8中基本類型以及他們的封裝類型，另外還有String類型。其餘的都是淺拷貝。</p><p>淺拷貝: 對值類型的成員變量進行值的複製,對引用類型的成員變量只複製引用,不復制引用的對象.</p><p>深拷貝: 對值類型的成員變量進行值的複製,對引用類型的成員變量也進行引用對象的複製.</p><p>7、template 模板模式</p><p>https://www.cnblogs.com/qq-361807535/p/6854191.html</p><p>模板模式是使用一個抽象類，裡面定義了一系列模板方法，也就是一個算法骨架，再定義一個總的調用統籌方法。統籌方法就是定義模板方法的執行順序，一般設定該方法為final ，是不讓子類破壞的。</p><p>現在有一個問題：我們能不能用接口去代替AbstractDisplay？答案是：不可以，因為我們這種模式的側重點在於由父類決定處理流程，這處理流程display方法必須要在父類中去實現，但是接口是不能去實現方法的。</p><p>場景:</p><p>jdbcTemplate callback結合使用</p><pre>public abstract class JdbcTemplate {  //template method  public final Object execute(String sql) throws SQLException{  Connection con = HsqldbUtil.getConnection();  Statement stmt = null;  try {  stmt = con.createStatement();  ResultSet rs = stmt.executeQuery(sql);  Object result = doInStatement(rs);//abstract method  return result;  }  catch (SQLException ex) {  ex.printStackTrace();  throw ex;  }  finally {  try {  stmt.close();  } catch (SQLException e) {  e.printStackTrace();  }  try {  if(!con.isClosed()){  try {  con.close();  } catch (SQLException e) {  e.printStackTrace();  }  }  } catch (SQLException e) {  e.printStackTrace();  }  }  }  //implements in subclass  protected abstract Object doInStatement(ResultSet rs); } </pre><p>在上面這個抽象類中，封裝了SUN JDBC API的主要流程，而遍歷ResultSet這一步驟則放到抽象方法doInStatement()中，由子類負責實現。</p><p>好，我們來定義一個子類，並繼承上面的父類：</p><pre>public class JdbcTemplateUserImpl extends JdbcTemplate {  @Override  protected Object doInStatement(ResultSet rs) {  List&lt;User&gt; userList = new ArrayList&lt;User&gt;();  try {  User user = null;  while (rs.next()) {  user = new User();  user.setId(rs.getInt("id"));  user.setUserName(rs.getString("user_name"));  user.setBirth(rs.getDate("birth"));  user.setCreateDate(rs.getDate("create_date"));  userList.add(user);  }  return userList;  } catch (SQLException e) {  e.printStackTrace();  return null;  }  } } </pre><p>由代碼可見，我們在doInStatement()方法中，對ResultSet進行了遍歷，最後並返回。</p><p>有人可能要問：我如何獲取ResultSet 並傳給doInStatement()方法啊？？呵呵，問這個問題的大多是新手。因為此方法不是由子類調用的，而是由父類調用，並把ResultSet傳遞給子類的。我們來看一下測試代碼：</p><p>String sql = "select * from User";</p><p>JdbcTemplate jt = new JdbcTemplateUserImpl();</p><p>List&lt;User> userList = (List&lt;User>) jt.execute(sql);</p><p>為什麼spring不用傳統的模板方法，而加之以Callback進行配合呢？</p><p>試想，如果父類中有10個抽象方法，而繼承它的所有子類則要將這10個抽象方法全部實現，子類顯得非常臃腫。而有時候某個子類只需要定製父類中的某一個方法該怎麼辦呢？這個時候就要用到Callback回調了</p><p>二、spring5</p><p>1、IOC容器設計原理及高級特性</p><p>https://www.cnblogs.com/linjiqin/archive/2013/11/04/3407126.html 設計原理</p><p>https://blog.csdn.net/sugar_rainbow/article/details/76757383 高級特性</p><p>https://www.cnblogs.com/ITtangtang/p/3978349.html 源碼解析</p><p>在Spring IOC容器的代表就是org.springframework.beans包中的BeanFactory接口，BeanFactory接口提供了IOC容器最基本功能；而org.springframework.context包下的ApplicationContext接口擴展了BeanFactory，還提供了與Spring AOP集成、國際化處理、事件傳播及提供不同層次的context實現 (如針對web應用的WebApplicationContext)。簡單說， BeanFactory提供了IOC容器最基本功能，而 ApplicationContext 則增加了更多支持企業級功能支持。ApplicationContext完全繼承BeanFactory，因而BeanFactory所具有的語義也適用於ApplicationContext。</p><p>讓我們來看下IOC容器到底是如何工作。在此我們以xml配置方式來分析一下：</p><p>一、準備配置文件：就像前邊Hello World配置文件一樣，在配置文件中聲明Bean定義也就是為Bean配置元數據。</p><p>二、由IOC容器進行解析元數據： IOC容器的Bean Reader讀取並解析配置文件，根據定義生成BeanDefinition配置元數據對象，IOC容器根據BeanDefinition進行實例化、配置及組裝Bean。</p><p>三、實例化IOC容器：由客戶端實例化容器，獲取需要的Bean。</p><pre>public void refresh() throws BeansException, IllegalStateException {  synchronized (this.startupShutdownMonitor) {  //調用容器準備刷新的方法，獲取容器的當時時間，同時給容器設置同步標識  prepareRefresh();  //告訴子類啟動refreshBeanFactory()方法，Bean定義資源文件的載入從  //子類的refreshBeanFactory()方法啟動  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  //為BeanFactory配置容器特性，例如類加載器、事件處理器等  prepareBeanFactory(beanFactory);  try {  //為容器的某些子類指定特殊的BeanPost事件處理器  postProcessBeanFactory(beanFactory);  //調用所有註冊的BeanFactoryPostProcessor的Bean  invokeBeanFactoryPostProcessors(beanFactory);  //為BeanFactory註冊BeanPost事件處理器.  //BeanPostProcessor是Bean後置處理器，用於監聽容器觸發的事件  registerBeanPostProcessors(beanFactory);  //初始化信息源，和國際化相關.  initMessageSource();  //初始化容器事件傳播器.  initApplicationEventMulticaster();  //調用子類的某些特殊Bean初始化方法  onRefresh();  //為事件傳播器註冊事件監聽器.  registerListeners();  //初始化所有剩餘的單態Bean.  finishBeanFactoryInitialization(beanFactory);  //初始化容器的生命週期事件處理器，併發布容器的生命週期事件  finishRefresh();  }  catch (BeansException ex) {  //銷燬以創建的單態Bean  destroyBeans();  //取消refresh操作，重置容器的同步標識.  cancelRefresh(ex);  throw ex;  }  }  }</pre><p>Spring IoC容器對Bean定義資源的載入是從refresh()函數開始的，refresh()是一個模板方法，refresh()方法的作用是：在創建IoC容器前，如果已經有容器存在，則需要把已有的容器銷燬和關閉，以保證在refresh之後使用的是新建立起來的IoC容器。refresh的作用類似於對IoC容器的重啟，在新建立好的容器中對容器進行初始化，對Bean定義資源進行載入</p><p>FileSystemXmlApplicationContext通過調用其父類AbstractApplicationContext的refresh()函數啟動整個IoC容器對Bean定義的載入過程</p><p>2、spring aop</p><pre>public class MyAspect { private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Pointcut("execution(public void *.method1)") public void pointcutName(){} @Around("pointcutName()") public Object performanceTrace(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { try { logger.info("log....."); return proceedingJoinPoint.proceed(); } finally { logger.info("log end"); } }}</pre><p>定義Aspect</p><pre>@Aspect@Componentpublic class AdviceTest { @Pointcut("@annotation(com.listenzhangbin.aop.Timer)") public void pointcut() { } @Before("pointcut()") public void before() { System.out.println("before"); }}</pre><p>3、spring 事務</p><p>https://baijiahao.baidu.com/s?id=1607466404459549668&wfr=spider&for=pc</p><p>1）、配置文件開啟註解驅動，在相關的類和方法上通過註解@Transactional標識。</p><p>2）、spring 在啟動的時候會去解析生成相關的bean，這時候會查看擁有相關注解的類和方法，並且為這些類和方法生成代理，並根據@Transaction的相關參數進行相關配置注入，這樣就在代理中為我們把相關的事務處理掉了（開啟正常提交事務，異常回滾事務）。</p><p>3）、真正的數據庫層的事務提交和回滾是通過binlog或者redo log實現的。</p><p>4、springmvc九大組件以及手寫springmvc框架</p><p>https://www.cnblogs.com/java1024/p/8556519.html</p><p>https://blog.csdn.net/it_freshman/article/details/81365000 SpringMVC3-處理-源碼跟蹤</p><p>https://www.cnblogs.com/kylyww/p/6405888.html</p><p>初始化流程</p><p>使用Spring MVC 時，需要在web.xml中配置DispatchServlet,這個DispatchServlet可以看成一個控制器的具體實現。作為一個控制器所有的請求都要通過它來處理，進行轉發、匹配、數據處理後並轉由頁面進行展示。因此DispatchServlet是Spring MVC的核心部分。</p><p>在完成ContextLoaderListener的初始化後，Web容器開始初始化DispatcherServlet,這個初始化的啟動與在web.xml中對載入次序的定義有關。DispathcerServlet會建立自己的上下文來持有Spring MVC的Bean,在建立這個自己的IOC容器時，會從ServletContext中得到根上下文作為自己持有上下文的雙親上下文。有了這個根上下文再對自己持有的上下文進行初始化，最後將自己持有的上下文保存到ServletContext中。</p><p>首先看看DispatcherSerlvet的繼承關係：DispatcherServlet繼承自FrameworkServlet,而FrameworkServet繼承自HttpServletBean.HttpServletBean有繼承了HttpServlet.</p><p>DispatcherServlet動作大致可以分為兩個部分：初始化部分由initServletBean()啟動，通過initWebApplicationContext()方法調用DispatcherServlet的initStrategies方法。在這個方法裡，DispatcherServlet對MVC的其他部分進行了初始化，比如handlerMapping,ViewResolver;另一個部分是對Http的請求進行響應，作為一個Servlet，web容器會調用Servlet的doGet()和doPost()方法，在經過FrameServlet的processRequest（）簡單處理後，會調用DispatcherServlet的doService（）方法，在這個方法中封裝了doDispatch().</p><p>在這裡主要介紹初始化部分。</p><p>作為Servlet, DispatcherServlet的啟動過程和Servlet啟動過程是相聯繫的。在Servlet的初始化過程中，Servlet的init方法被調用，已進行初始化。</p><p>HttppServletBean.init()->FrameworkServlet.initWebApplicationContext()->DispatcherServlet.onRefresh().->initStrategies(初始化九大組件)</p><p>springmvc請求流程</p><p>httpServlet#service->protected service->doGet/doPost->frameworkServlet#doGet/doPost->final processRequest(無論成功與否 發佈publishRequestHandledEvent)->abstract doService->DispatcherServlet#doService（設置九大組件的屬性）->doDispatcher</p><p>往下流程：</p><p>用戶發送請求至前端控制器DispatcherServlet</p><p>DispatcherServlet收到請求調用HandlerMapping處理器映射器。</p><p>處理器映射器根據請求url找到具體的處理器，生成處理器對象及處理器攔截器(如果有則生成)一併返回給DispatcherServlet。</p><p>DispatcherServlet通過HandlerAdapter處理器適配器調用處理器</p><p>執行處理器(Controller，也叫後端控制器)。</p><p>Controller執行完成返回ModelAndView</p><p>HandlerAdapter將controller執行結果ModelAndView返回給DispatcherServlet</p><p>DispatcherServlet將ModelAndView傳給ViewReslover視圖解析器</p><p>ViewReslover解析後返回具體View</p><p>DispatcherServlet對View進行渲染視圖（即將模型數據填充至視圖中）。</p><p>DispatcherServlet響應用戶。</p><p>從上面可以看出，DispatcherServlet有接收請求，響應結果，轉發等作用。有了DispatcherServlet之後，可以減少組件之間的耦合度。</p><p>doDispatch()結構</p><p>doDispatch的方法也非常簡潔，從頂層設計了整個請求的處理過程。doDispatch的最核心代碼只有4句，它們的任務分別是：</p><p>根據request找到Handler以及對應的interceptors</p><p>根據Handler找到對應的HandlerAdapter</p><p>用HandlerAdapter處理Handler</p><p>處理上面處理之後的結果（包含找到View並渲染給用戶）,最終調用afterCompletion</p><pre>protected void doDispatcher(HttpServletRequest req, HttpServletResponse res) throws Exception{ HttpServletRequest processRequet = req; HandlerExecutionChain mappedHandler = null; ModelAndView mv = null; processRequet = checkMultipart(req); //獲取handler mappedHandler = getHandler(processRequet); //獲取handlerAdapter HandlerAdapter h = getHandlerAdapter(mappedHandler.getHandler()); //執行handler註冊的interceptors中的preHandle方法 HandlerInterceptor[] interceptors = mappedHandler.getInterceptors(); for(int i = 0 ;i&lt;interceptors.length;i++){ interceptors[i].preHandle(processRequet, res, mappedHandler); } //處理handler mv = h.handle(processRequet, res, mappedHandler.getHandler()); //執行handler註冊的interceptors中的postHandle方法 for(int i = 0 ;i&lt;interceptors.length;i++){ interceptors[i].postHandle(processRequet, res, mappedHandler,mv); } }</pre><p>三、mybatis</p><p>1、mybatis代碼自動生成器</p><p>generatorConfig.xml</p><p>2、mybatis動態代理的實現</p><p>https://blog.csdn.net/xiaokang123456kao/article/details/76228684</p><p>使用jdk動態代理實現</p><p>3、mybatis源碼解析</p><p>https://blog.csdn.net/ma15732625261/article/details/81123349</p><p>https://www.jianshu.com/p/0d7db721c4b5</p><p>總結：</p><p>1）獲取sqlsessionFactory：把配置文件解析關保存在configuration對象中，返回包含了configuration的defaultSqlSession對象</p><p>2）獲取sqlSession：返回sqlsession實現類defaultsqlsession對象，它裡面包含了executor和configuration，executor在這步創建</p><p>3）獲取接口代理對象MapperProxy：getmapper返回接口的代理對象，包含sqlsession對象</p><p>4）代理對象-》defaultsqlsession->executor->statementhandler->parameterhandler,resultsethandler->typehandler->jdbc</p><p>加載全局配置文件->配置類->MapperFactoryBean（MapperFactoryBean 實現了Spring的FactoryBean接口） 創建UserMapper實例，該實例是通過jdk的動態代理實現的</p><p>->MapperProxy(MapperProxyFactory創建)->sqlsessiontemplate->mapperProxy#invoke->mapperMethod#execute->sqlsessiontemplate#select->SqlSessionInterceptor#invoke</p><p>->sqlsession#invoke->sqlSession#commit->sqlSession#closeSqlsession</p><p>主要構件及其相互關係</p><p>從MyBatis代碼實現的角度來看，MyBatis的主要的核心部件有以下幾個：</p><p>SqlSession：作為MyBatis工作的主要頂層API，表示和數據庫交互的會話，完成必要數據庫增刪改查功能；</p><p>Executor：MyBatis執行器，是MyBatis 調度的核心，負責SQL語句的生成和查詢緩存的維護；</p><p>StatementHandler：封裝了JDBC Statement操作，負責對JDBC statement 的操作，如設置參數、將Statement結果集轉換成List集合。</p><p>ParameterHandler：負責對用戶傳遞的參數轉換成JDBC Statement 所需要的參數；</p><p>ResultSetHandler：負責將JDBC返回的ResultSet結果集對象轉換成List類型的集合；</p><p>TypeHandler：負責java數據類型和jdbc數據類型之間的映射和轉換；</p><p>MappedStatement：MappedStatement維護了一條&lt;select|update|delete|insert>節點的封裝；</p><p>SqlSource：負責根據用戶傳遞的parameterObject，動態地生成SQL語句，將信息封裝到BoundSql對象中，並返回；</p><p>BoundSql：表示動態生成的SQL語句以及相應的參數信息；</p><p>Configuration：MyBatis所有的配置信息都維持在Configuration對象之中；</p><p>---------------------</p><p>https://blog.csdn.net/worn_xiao/article/details/78888640 mybatis的工作原理</p><p>如上圖所示是mybatis的工作原理</p><p>1 首先程序加載全局的配置文件，形成配置文件類</p><p>2 通過Mapper的接口形成一個mapper的代理</p><p>3 通過調用mapper的代理執行對應的方法，此時代理中會發現，method.getdeclareClass並不是一個類，而是一個接口</p><p>4 此時通過執行mapperMethod，也就是接口的方法，因為mepperproxy是組合了sqlsession的，當調用mapper接口的方法時，它通過方法的映射，最終還是調用的sqlsession的接口方法。</p><p>5sqlsession本身不帶有接口的實現類，所以此時sqlsession類就組合進來Excutor執行器對接口中從配置文件中獲取到的statement對應的sql進行執行。最終返回結果映射。</p><p>---------------------</p><p>各個Executor簡單分析</p><p>SimpleExecutor是最簡單的執行器，根據對應的sql直接執行即可，不會做一些額外的操作；</p><p>BatchExecutor執行器，顧名思義，通過批量操作來優化性能。通常需要注意的是批量更新操作，由於內部有緩存的實現，使用完成後記得調用flushStatements來清除緩存。</p><p>ReuseExecutor 可重用的執行器，重用的對象是Statement，也就是說該執行器會緩存同一個sql的Statement，省去Statement的重新創建，優化性能。內部的實現是通過一個HashMap來維護Statement對象的。由於當前Map只在該session中有效，所以使用完成後記得調用flushStatements來清除Map</p><p>這些就是mybatis的三種執行器。你可以通過配置文件的settings裡面的元素defaultExecutorType，配置它，默認是採用SimpleExecutor如果你在Spring運用它，那麼你可以這麼配置它：</p><p>如果有二級緩存配置開啟，則創建cachingExecutor</p><p>&lt;bean id="sqlSessionTemplateBatch" class="org.mybatis.spring.SqlSessionTemplate"></p><p>&lt;constructor-arg index="0" ref="sqlSessionFactory" /></p><p>&lt;!--更新採用批量的executor --></p><p>&lt;constructor-arg index="1" value="BATCH"/></p><p>&lt;/bean></p><p>---------------------</p><p>這樣，它便是一個批量的執行器。mybatis的三個executor都有一個共同的父類——BaseExecutor。</p><p>https://blog.csdn.net/qq_38409944/article/details/82494187</p><p>總結：</p><p>1、獲取sqlSessionFactory對象:</p><p>根據配置文件（全局，sql映射）初始化出Configuration對象</p><p>解析文件的每一個信息保存在Configuration中，返回包含Configuration的DefaultSqlSession；</p><p>注意：MappedStatement：代表一個增刪改查的詳細信息</p><p>2、獲取sqlSession對象</p><p>返回一個DefaultSQlSession對象，包含Executor和Configuration;</p><p>這一步會創建Executor對象；</p><p>Executor（根據全局配置文件中的defaultExecutorType創建出對應的Executor）</p><p>3、獲取接口的代理對象（MapperProxy）</p><p>DefaultSqlSession.getMapper（）：拿到Mapper接口對應的MapperProxy；</p><p>使用MapperProxyFactory創建一個MapperProxy的代理對象</p><p>代理對象裡面包含了，DefaultSqlSession（Executor）</p><p>4、執行增刪改查方法</p><p>1）調用DefaultSqlSession的增刪改查（Executor）；</p><p>2）會創建一個StatementHandler對象。</p><p>（同時也會創建出ParameterHandler和ResultSetHandler）</p><p>3）調用StatementHandler預編譯參數以及設置參數值;</p><p>使用ParameterHandler來給sql設置參數</p><p>4）調用StatementHandler的增刪改查方法；</p><p>5）ResultSetHandler封裝結果</p><p>SqlSession是過程級,一個方法中建立,方法結束應該關閉,不是線程安全的</p><p>四、maven</p><p>1、 Maven中的dependency的scope作用域詳解</p><p>1）、test範圍指的是測試範圍有效，在編譯和打包時都不會使用這個依賴</p><p>2）、compile範圍指的是編譯範圍有效，在編譯和打包時都會將依賴存儲進去</p><p>3）、provided依賴：在編譯和測試的過程有效，最後生成war包時不會加入，諸如：servlet-api，因為servlet-api，tomcat等web服務器已經存在了，如果再打包會衝突</p><p>4）、runtime在運行的時候依賴，在編譯的時候不依賴</p><p>2、maven jar包</p><p>https://blog.csdn.net/T2080305/article/details/82144543</p><p>1）maven中jar包的依賴是傳遞依賴</p><p>2）Maven採用了兩種避免衝突的策略： 1、短路優先，2、聲明優先</p><p>解決方案：1、移除多餘的jar包</p><p>五、分佈式架構原理</p><p>1、漫談分佈式架構</p><p>https://blog.csdn.net/lj1314ailj/article/details/80765012</p><p>2、分佈式架構及意義</p><p>https://blog.csdn.net/qq_41555178/article/details/81484473</p><p>https://blog.csdn.net/yp1125/article/details/79125477</p><p>https://www.cnblogs.com/dump/p/8125539.html 大型分佈式架構詳解</p><p>3、分佈式架構網絡通信原理剖析</p><p>RMI（遠程方法調用）：</p><p>1）客戶端發起請求，請求轉交至RMI客戶端的stub類；</p><p>2）stub類將請求的接口、方法、參數等信息進行序列化；</p><p>3）基於socket將序列化後的流傳輸至服務器端；</p><p>4）服務器端接收到流後轉發至相應的skelton類；</p><p>5）skelton類將請求的信息反序列化後調用實際的處理類；</p><p>6）處理類處理完畢後將結果返回給skelton類；</p><p>7）Skelton類將結果序列化，通過socket將流傳送給客戶端的stub；</p><p>8）stub在接收到流後反序列化，將反序列化後的Java Object返回給調用者。</p><p>XML-RPC：</p><p>1）客戶端發起請求，按照XML-RPC協議將請求信息進行填充；</p><p>2）填充完畢後將xml轉化為流，通過傳輸協議進行傳輸；</p><p>3）接收到在接收到流後轉換為xml，按照XML-RPC協議獲取請求的信息並進行處理；</p><p>4）處理完畢後將結果按照XML-RPC協議寫入xml中並返回。</p><p>4、通信協議中的序列化與反序列化</p><p>https://blog.csdn.net/sanyaoxu_2/article/details/79722431</p><p>1）序列化的“鼻祖”</p><p>我知道的第一種序列化協議就是Java默認提供的序列化機制，需要序列化的Java對象只需要實現 Serializable / Externalizable 接口並生成序列化ID，這個類就能夠通過 ObjectInput 和 ObjectOutput 序列化和反序列化，若對Java默認的序列化協議不瞭解，或是遺忘了，請參考：序列化詳解</p><p>但是Java默認提供的序列化有很多問題，主要有以下幾個缺點：</p><p>無法跨語言：我認為這對於Java序列化的發展是致命的“失誤”，因為Java序列化後的字節數組，其它語言無法進行反序列化。；</p><p>序列化後的碼流太大:：相對於目前主流的序列化協議，Java序列化後的碼流太大；</p><p>序列化的性能差：由於Java序列化採用同步阻塞IO，相對於目前主流的序列化協議，它的效率非常差。</p><p>2）.影響序列化性能的關鍵因素</p><p>序列化後的碼流大小（網絡帶寬的佔用）；</p><p>序列化的性能（CPU資源佔用）；</p><p>是否支持跨語言（異構系統的對接和開發語言切換）。</p><p>5、dubbo 管理平臺與監控平臺的安裝與部署</p><p>https://blog.csdn.net/lindonglian/article/details/78562678</p><p>6、Dubbo集群容錯機制及負載均衡策略</p><p>https://www.jianshu.com/p/48acb5707da5</p><p>1）這裡的Invoker是Provider的一個可調用Service的抽象，Invoker封裝了Provider地址及Service接口信息。</p><p>2）Directory代表多個Invoker，可以把它看成List&lt;Invoker>，但與List不同的是，它的值可能是動態變化的，比如註冊中心推送變更。</p><p>3）Cluster將Directory中的多個Invoker偽裝成一個Invoker，對上層透明，偽裝過程包含了容錯邏輯，調用失敗後，重試另一個。</p><p>4）Router負責從多個Invoker中按路由規則選出子集，比如讀寫分離，應用隔離等。</p><p>5）LoadBalance負責從多個Invoker中選出具體的一個用於本次調用，選的過程包含了負載均衡算法，調用失敗後，需要重選。</p><p>7、dubbo 源碼解析</p><p>https://blog.csdn.net/u012410733/article/details/77417497 dubbo說得比較到位</p><p>cluster#join->Directory#list->router#route->LoadBalance#select</p><p>proxyfactory#getInvoker#getProxy</p><p>protocol#export#refer</p><p>referenceconfig#init</p><p>serviceconfig#ref實例</p><p>集群容錯主要包括以下幾種模式：</p><p>Failover Cluster：失敗自動切換，當出現失敗，重試其它服務器 。通常用於讀操作，但重試會帶來更長延遲。可通過 retries="2" 來設置重試次數(不含第一次)。</p><p>Failfast Cluster：快速失敗，只發起一次調用，失敗立即報錯。通常用於非冪等性的寫操作，比如新增記錄。</p><p>Failsafe Cluster：失敗安全，出現異常時，直接忽略。通常用於寫入審計日誌等操作。</p><p>Failback Cluster：失敗自動恢復，後臺記錄失敗請求，定時重發。通常用於消息通知操作。</p><p>Forking Cluster：並行調用多個服務器，只要一個成功即返回。通常用於實時性要求較高的讀操作，但需要浪費更多服務資源。可通過 forks=”2” 來設置最大並行數。</p><p>Broadcast Cluster：廣播調用所有提供者，逐個調用，任意一臺報錯則報錯 2。通常用於通知所有提供者更新緩存或日誌等本地資源信息。</p><p>1）服務提供者暴露一個服務的詳細過程</p><p>具體服務到Invoker的轉化：ServiceConfig類#對外提供服務的實際類引用ref->ProxyFactory#getInvoker->AbstractProxyInvoker</p><p>Invoker轉換到Exporter: DubboProtocol#export->它主要是打開socket偵聽服務，並接收客戶端發來的各種請求，通訊細節由Dubbo自己實現</p><p>serviceconfig#ref實例-》proxyfactory#getInvoker(AbstractProxyInvoker實例，即invoker)->protocol#export</p><p>invoker:interface的class實例、實例類對象、url、當前接口的代理對象wrapper實例</p><p>2）服務消費者消費一個服務的詳細過程</p><p>ReferenceConfig#init->DubboProtocol#refer[獲取invoker]->ProxyFactory#getProxy->ref</p><p>3）dubbo源碼分析 之 架構原理探索</p><p>啟動Zookeeper服務：用於dubbo的註冊中心。</p><p>啟動Zookeeper Inspector:它是Zookeeper服務信息查看工具。</p><p>4）dubbo源碼分析 之 內核SPI實現</p><p>為什麼不使用JDK SPI</p><p>在dubbo中它實現了一套自己的SPI機制。JDK標準的SPI會一次性實例化擴展點所有實現，如果有擴展實現初始化很耗時，但如果沒用上也加載，會很浪費資源.</p><p>增加了對擴展點IoC和AOP的支持，一個擴展點可以直接setter注入其它擴展點。</p><p>dubbo的領域對象</p><p>在dubbo當中它的核心領域對象就是Invoker，它是 Dubbo 的核心模型，其它模型都向它靠擾，或轉換成它。</p><p>在dubbo中通過Protocol這個來管理Invoker的生命週期，包括服務的暴露與引用都是通過它來完成的。而在進行服務調用的時候通過Invocation來保存調用過程中的變量：包括方法名，參數等。所以在整個dubbo調用過程當中：</p><p>Invoker 是實體域，它是 Dubbo 的核心模型，其它模型都向它靠擾，或轉換成它，它代表一個可執行體，可向它發起 invoke 調用，它有可能是一個本地的實現，也可能是一個遠程的實現，也可能一個集群實現。</p><p>Protocol 是服務域，它是 Invoker 暴露和引用的主功能入口，它負責 Invoker 的生命週期管理。</p><p>Invocation 是會話域，它持有調用過程中的變量，比如方法名，參數等。</p><p>dubbo 遠程服務(Provider)暴露最終其實就是創建一個 Netty Serve 服務，然後在 dubbo 在服務引用的時候創建一個 Netty Client 服務。其實 dubbo 遠程通信的原理其實就是基於 Socket 的遠程通信。下面我們來看一下 dubbo 是如何創建一個 Netty 服務的，下面就是它創建的序列圖：</p><p>它通過傳入 URL 與 requestHandler來創建一個 ExchangeServer，通過Netty 基於 NIO的形式通過自定義Channel來接收服務引用方傳遞過來的信息，以及發送調用遠程服務的本地方法後的數據給服務調用者。URL 裡面主要包含 IP 地址 與 端口信息用於創建 Socket 連接，而 requestHandler是一個 ExchangeHandler 通過自定義協議來處理 dubbo 的遠程通信。</p><p>https://www.cnblogs.com/lengfo/p/4293399.html dubbo各協議性能比較</p><p>性能分析</p><p>測試過程中儘管考慮了非常多的影響因素，但仍然有很多侷限性，包括連接數限制、併發量、線程池策略、Cache、IO、硬件性能瓶頸等等因素，而且各自的適用場景不同，測試結果僅供參考。</p><p>從單線程測試結果可以看出，dubbo協議採用NIO複用單一長連接更適合滿足高併發小數據量的rpc調用，而在大數據量下的傳輸性能並不好，建議使用rmi協議，多線程測試中dubbo協議對小數據量的rpc調用同樣保持優勢，在大數據量的傳輸中由於長連接的原因對比rmi協議傳輸耗時差距並不明顯，這點同樣驗證了上述觀點。關於數據的序列化方式選擇需要考慮序列化和反序列化的效率問題，傳輸內容的大小，以及格式的兼容性約束，其中hessian2作為duobb協議下的默認序列化方式，推薦使用。</p><p>8、分佈式消息通信activemq/kafka/rabbitmq/rocketmq</p><p>能夠保證嚴格的消息順序</p><p>提供豐富的消息拉取模式</p><p>高效的訂閱者水平擴展能力</p><p>實時的消息訂閱機制</p><p>億級消息堆積能力</p><p>Metaq3.0 版本改名，產品名稱改為RocketMQ</p><p>RocketMQ是阿里review kafka的java版，如果 消息性能要求高 用rocketmq與kafka可以更優</p><p>總結：</p><p>1、性能小 量小 用什麼都沒有關係，性質是一樣的，如果 消息性能要求高 用rocketmq與kafka可以更優，rocketmq與kafka 比較就看技術選型了，各有利弊，看業務需要。</p><p>2、activemq rabbitmq 與 kafka、rocketmq有很大的區別就是前2個只支持主從模式，後2個是分佈式消息系統，支持分佈式。</p><p>3、持久化消息比較： zeroMq不支持，activeMq和rabbitMq都支持。</p><p>持久化消息主要是指：MQ down或者MQ所在的服務器down了，消息不會丟失的機制。</p><p>4、其中包括持久化消息和瞬時消息的測試。注意這篇文章裡面提到的MQ，都是採用默認配置的，並無調優。</p><p>ZeroMq 最好，RabbitMq 次之， ActiveMq 最差。這個結論來自於以下這兩篇文章。</p><p>http://blog.x-aeon.com/2013/04/10/a-quick-message-queue-benchmark-activemq-rabbitmq-hornetq-qpid-apollo/</p><p>其中包括持久化消息和瞬時消息的測試。注意這篇文章裡面提到的MQ，都是採用默認配置的，並無調優。</p><p>http://www.cnblogs.com/amityat/archive/2011/08/31/2160293.html</p><p>顯示的是發送和接受的每秒鐘的消息數。整個過程共產生1百萬條1K的消息。測試的執行是在一個Windows Vista上進行的。</p><p>5、技術點：可靠性、靈活的路由、集群、事務、高可用的隊列、消息排序、問題追蹤、可視化管理工具、插件系統、社區</p><p>RabbitMq最好，ActiveMq次之，ZeroMq最差。當然ZeroMq也可以做到，不過自己必須手動寫代碼實現，代碼量不小。尤其是可靠性中的：持久性、投遞確認、發佈者證實和高可用性。</p><p>所以在可靠性和可用性上，RabbitMQ是首選，雖然ActiveMQ也具備，但是它性能不及RabbitMQ。</p><p>6、高併發</p><p>從實現語言來看，RabbitMQ最高，原因是它的實現語言是天生具備高併發高可用的erlang語言。</p><p>小結：</p><p>按照目前網絡上的資料，RabbitMQ、activeM、zeroMQ三者中，綜合來看，RabbitMQ是首選。下面提供一篇文章，是淘寶使用RabbitMQ的心得，可以參看一些業務場景。</p><p>http://www.docin.com/p-462677246.html</p><p>7、kafka和RabbitMQ的比較</p><p>關於這兩種MQ的比較，網上的資料並不多，最權威的的是kafka的提交者寫一篇文章。http://www.quora.com/What-are-the-differences-between-Apache-Kafka-and-RabbitMQ</p><p>裡面提到的要點：</p><p>1)、 RabbitMq比kafka成熟，在可用性上，穩定性上，可靠性上，RabbitMq超過kafka</p><p>2)、 Kafka設計的初衷就是處理日誌的，可以看做是一個日誌系統，針對性很強，所以它並沒有具備一個成熟MQ應該具備的特性</p><p>3)、 Kafka的性能（吞吐量、tps）比RabbitMq要強，這篇文章的作者認為，兩者在這方面沒有可比性。</p><p>這裡在附上兩篇文章，也是關於kafka和RabbitMq之間的比較的：</p><p>1)、http://www.mrhaoting.com/?p=139</p><p>2)、http://www.liaoqiqi.com/post/227</p><p>總結：</p><p>兩者對比後，我仍然是選擇RabbitMq，性能其實是很強勁的，同時具備了一個成熟的MQ應該具有的特性，我們無需重新發明輪子。</p><p>8、redis api</p><p>https://blog.csdn.net/zhangguanghui002/article/details/78770071</p><pre>public static void test(){ ShardedJedis jedis = RedisManager.getJedis(); String key = "11"; String value = "11"; //----------value---------------------- boolean ex = jedis.exists(key);//該key是否存在 long count = jedis.del(key);//刪除key,返回刪除key的數量 //返回值：// none (key不存在)// string (字符串)// list (列表)// set (集合)// zset (有序集)// hash (哈希表) String type = jedis.type(key);//返回key的類型 jedis.hkeys(key); jedis.srandmember(key);// 當 key 不存在時，返回 -2 。// 當 key 存在但沒有設置剩餘生存時間時，返回 -1 。// 否則，以秒為單位，返回 key 的剩餘生存時間。 jedis.ttl(key);//獲取剩餘生存時間 返回值時間// 設置成功返回 1 。// 當 key 不存在或者不能為 key 設置生存時間時(比如在低於 2.1.3 版本的 Redis 中你嘗試更新 key 的生存時間)，返回 0  jedis.expire(key, 1);//設置過期時間為1秒// 當生存時間移除成功時，返回 1 .// 如果 key 不存在或 key 沒有設置生存時間，返回 0 jedis.persist(key); //----------String----------------------// 在 Redis 2.6.12 版本以前， SET 命令總是返回 OK 。// 從 Redis 2.6.12 版本開始， SET 在設置操作成功完成時，才返回 OK 。// 如果設置了 NX 或者 XX ，但因為條件沒達到而造成設置操作未執行，那麼命令返回空批量回復（NULL Bulk Reply）。 jedis.set(key, value); jedis.setnx(key, value);//重複不插入 jedis.setex(key, 1, value);//增加數據項並設置有效時間 jedis.del(key); jedis.get(key); jedis.append(key, value);//在key對應的value後面擴展字符串value// 將給定 key 的值設為 value ，並返回 key 的舊值(old value)。 jedis.getSet(key, value);//獲取key對應的value並更新value jedis.getrange(key, 3, 6);//截取得出的子字符串。 jedis.incr(key);//將key對應的值+1 jedis.incrBy(key, 2);//將key對應的值+2 jedis.decr(key);//將key對應的值-1 jedis.decrBy(key, 2);//將key對應的值-2 //----------list---------------------- jedis.lpush(key, "1","a","c");//返回值 執行 LPUSH 命令後，列表的長度 jedis.lpush(key, value);//左插入 jedis.lrange(key, 0, 2);//獲取list對應區間0到2的元素// 根據參數 count 的值，移除列表中與參數 value 相等的元素。//// count 的值可以是以下幾種：//// count &gt; 0 : 從表頭開始向表尾搜索，移除與 value 相等的元素，數量為 count 。// count &lt; 0 : 從表尾開始向表頭搜索，移除與 value 相等的元素，數量為 count 的絕對值。// count = 0 : 移除表中所有與 value 相等的值 jedis.lrem(key, count, value); //刪除list對應區間之外的元素 jedis.ltrim(key, 1, 2); jedis.lpop(key);//key對應list左出棧一個元素 jedis.rpush(key, value);//右插入 jedis.rpop(key);//key對應list右出棧一個元素 jedis.lset(key, 1, value);//修改key對應list指定下標index的值為value jedis.llen(key);//獲取list的長度 jedis.lindex(key, 1);//獲取list下標index的值 jedis.sort(key);//list裡面的值從小到大排序 //----------set---------------------- jedis.sadd(key, "1","2");//將一個或多個 member 元素加入到集合 key 當中，已經存在於集合的 member 元素將被忽略。 jedis.smembers(key);//獲取該set對應的所有元素 jedis.srem(key, value);//刪除一個值為value的元素 jedis.srem(key, "1","2","3");//刪除一個值為value1,value2的元素 jedis.spop(key);//隨機移除一個元素 jedis.scard(key);//獲取set中元素個數 //----------hash---------------------- jedis.hmset(key, new HashMap&lt;String, String&gt;());//添加一個hash jedis.hset(key, "12", value);//往hash插入一個新域 jedis.hgetAll(key);//獲取hash所有元素 jedis.hkeys(key);//獲取hash所有元素的key jedis.hvals(key);//獲取hash所有元素的value jedis.hincrBy(key, "12", 1);//把hash中key對應元素value+1 jedis.hdel(key, "12",value);//從hash中刪除一個域多個元素 jedis.hlen(key);//獲取hash中元素個數 jedis.hexists(key, "12");//判斷hash中是否有12對應的元素 jedis.hmget(key, "12","13");//獲取hash中一個或多個元素value jedis.hget(key, "12");//獲取hash中一個元素value //-----------zsort------------------ jedis.zadd(key, new HashMap&lt;String, Double&gt;());//添加一個zset jedis.zrange(key, 1, 3);//獲取zset中index，1-3中的元素value jedis.zrangeWithScores(key, 1, 3);//獲取zset中index，1-3中的元素 jedis.zscore(key, value);//獲取value為value的score值 jedis.zrank(key, value);//獲取value為value的score排名 jedis.zrem(key, value);//刪除value值為value的元素 jedis.zcard(key);//獲取元素個數 jedis.zincrby(key, 1, value);//將zset中val為value的score+=1 //-----------排序操作------------------ SortingParams s = new SortingParams(); jedis.sort(key, s.alpha());//按首字母a-z排序 jedis.sort(key, s.asc());//按數字升序排 jedis.sort(key, s.desc());//按數字降序排 }</pre><p>9、redis主從複製</p><p>全量同步</p><p>Redis全量複製一般發生在Slave初始化階段，這時Slave需要將Master上的所有數據都複製一份</p><p>增量同步</p><p>Redis增量複製是指Slave初始化後開始正常工作時主服務器發生的寫操作同步到從服務器的過程。</p><p>增量複製的過程主要是主服務器每執行一個寫命令就會向從服務器發送相同的寫命令，從服務器接收並執行收到的寫命令。</p><p>Redis主從同步策略</p><p>主從剛剛連接的時候，進行全量同步；全同步結束後，進行增量同步。當然，如果有需要，slave 在任何時候都可以發起全量同步。redis 策略是，無論如何，首先會嘗試進行增量同步，如不成功，要求從機進行全量同步。</p><p>無磁盤複製</p><p>通常來講，一個完全重新同步需要在磁盤上創建一個RDB文件，然後加載這個文件以便為從服務器發送數據。</p><p>如果使用比較低速的磁盤，這種操作會給主服務器帶來較大的壓力。Redis從2.8.18版本開始嘗試支持無磁盤的複製。</p><p>使用這種設置時，子進程直接將RDB通過網絡發送給從服務器，不使用磁盤作為中間存儲。</p><p>1）RDB方式(默認)</p><p>RDB方式的持久化是通過快照（snapshotting）完成的，當符合一定條件時Redis會自動將內存中的所有數據進行快照並存儲在硬盤上。進行快照的條件可以由用戶在配置文件中自定義，由兩個參數構成：時間和改動的鍵的個數。當在指定的時間內被更改的鍵的個數大於指定的數值時就會進行快照。RDB是redis默認採用的持久化方式，在配置文件中已經預置了3個條件：</p><p>save 900 1 #900秒內有至少1個鍵被更改則進行快照</p><p>save 300 10 #300秒內有至少10個鍵被更改則進行快照</p><p>save 60 10000 #60秒內有至少10000個鍵被更改則進行快照</p><p>可以存在多個條件，條件之間是"或"的關係，只要滿足其中一個條件，就會進行快照。 如果想要禁用自動快照，只需要將所有的save參數刪除即可。</p><p>Redis默認會將快照文件存儲在當前目錄(可CONFIG GET dir來查看)的dump.rdb文件中，可以通過配置dir和dbfilename兩個參數分別指定快照文件的存儲路徑和文件名。</p><p>Redis實現快照的過程</p><p>- Redis使用fork函數複製一份當前進程（父進程）的副本（子進程）；</p><p>- 父進程繼續接收並處理客戶端發來的命令，而子進程開始將內存中的數據寫入硬盤中的臨時文件；</p><p>- 當子進程寫入完所有數據後會用該臨時文件替換舊的RDB文件，至此一次快照操作完成。</p><p>- 在執行fork的時候操作系統（類Unix操作系統）會使用寫時複製（copy-on-write）策略，即fork函數發生的一刻父子進程共享同一內存數據，當父進程要更改其中某片數據時（如執行一個寫命令 ），操作系統會將該片數據複製一份以保證子進程的數據不受影響，所以新的RDB文件存儲的是執行fork一刻的內存數據。</p><p>Redis在進行快照的過程中不會修改RDB文件，只有快照結束後才會將舊的文件替換成新的，也就是說任何時候RDB文件都是完整的。這使得我們可以通過定時備份RDB文件來實 現Redis數據庫備份。RDB文件是經過壓縮（可以配置rdbcompression參數以禁用壓縮節省CPU佔用）的二進制格式，所以佔用的空間會小於內存中的數據大小，更加利於傳輸。</p><p>除了自動快照，還可以手動發送SAVE或BGSAVE命令讓Redis執行快照，兩個命令的區別在於，前者是由主進程進行快照操作，會阻塞住其他請求，後者會通過fork子進程進行快照操作。 Redis啟動後會讀取RDB快照文件，將數據從硬盤載入到內存。根據數據量大小與結構和服務器性能不同，這個時間也不同。通常將一個記錄一千萬個字符串類型鍵、大小為1GB的快照文件載入到內 存中需要花費20～30秒鐘。 通過RDB方式實現持久化，一旦Redis異常退出，就會丟失最後一次快照以後更改的所有數據。這就需要開發者根據具體的應用場合，通過組合設置自動快照條件的方式來將可能發生的數據損失控制在能夠接受的範圍。如果數據很重要以至於無法承受任何損失，則可以考慮使用AOF方式進行持久化。</p><p>2）AOF方式</p><p>默認情況下Redis沒有開啟AOF(append only file)方式的持久化，可以在redis.conf中通過appendonly參數開啟：</p><p>appendonly yes</p><p>在啟動時Redis會逐個執行AOF文件中的命令來將硬盤中的數據載入到內存中，載入的速度相較RDB會慢一些</p><p>開啟AOF持久化後每執行一條會更改Redis中的數據的命令，Redis就會將該命令寫入硬盤中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通過dir參數設置的，默認的文件名是appendonly.aof，可以通過appendfilename參數修改：</p><p>appendfilename appendonly.aof</p><p>配置redis自動重寫AOF文件的條件</p><p>auto-aof-rewrite-percentage 100 # 當目前的AOF文件大小超過上一次重寫時的AOF文件大小的百分之多少時會再次進行重寫，如果之前沒有重寫過，則以啟動時的AOF文件大小為依據</p><p>auto-aof-rewrite-min-size 64mb # 允許重寫的最小AOF文件大小</p><p>配置寫入AOF文件後，要求系統刷新硬盤緩存的機制</p><p># appendfsync always # 每次執行寫入都會執行同步，最安全也最慢</p><p>appendfsync everysec # 每秒執行一次同步操作</p><p># appendfsync no # 不主動進行同步操作，而是完全交由操作系統來做（即每30秒一次），最快也最不安全</p><p>Redis允許同時開啟AOF和RDB，既保證了數據安全又使得進行備份等操作十分容易。此時重新啟動Redis後Redis會使用AOF文件來恢復數據，因為AOF方式的持久化可能丟失的數據更少</p><p>10、nginx反向代理及負載均衡服務配置</p><p>https://www.cnblogs.com/Miss-mickey/p/6734831.html</p><p>11、netty 高性能</p><p>https://www.cnblogs.com/Irving/p/5709130.html</p><p>Netty是一個高性能、異步事件驅動的NIO框架，它提供了對TCP、UDP和文件傳輸的支持，作為一個異步NIO框架，Netty的所有IO操作都是異步非阻塞的，通過Future-Listener機制，用戶可以方便的主動獲取或者通過通知機制獲得IO操作結果。</p><p>Netty架構分析</p><p>Netty 採用了比較典型的三層網絡架構進行設計，邏輯架構圖如下所示：</p><p>第一層：Reactor 通信調度層，它由一系列輔助類完成，包括 Reactor 線程 NioEventLoop 以及其父類、NioSocketChannel/NioServerSocketChannel 以及其父 類、ByteBuffer 以及由其衍生出來的各種 Buffer、Unsafe 以及其衍生出的各種內 部類等。該層的主要職責就是監聽網絡的讀寫和連接操作，負責將網絡層的數據 讀取到內存緩衝區中，然後觸發各種網絡事件，例如連接創建、連接激活、讀事 件、寫事件等等，將這些事件觸發到 PipeLine 中，由 PipeLine 充當的職責鏈來 進行後續的處理。</p><p>第二層：職責鏈 PipeLine，它負責事件在職責鏈中的有序傳播，同時負責動態的 編排職責鏈，職責鏈可以選擇監聽和處理自己關心的事件，它可以攔截處理和向 後/向前傳播事件，不同的應用的 Handler 節點的功能也不同，通常情況下，往往 會開發編解碼 Hanlder 用於消息的編解碼，它可以將外部的協議消息轉換成內部 的 POJO 對象，這樣上層業務側只需要關心處理業務邏輯即可，不需要感知底層 的協議差異和線程模型差異，實現了架構層面的分層隔離。</p><p>第三層：業務邏輯處理層，可以分為兩類：</p><p>純粹的業務邏輯 處理，例如訂單處理。</p><p>應用層協議管理，例如HTTP協議、FTP協議等。</p><p>接下來，我從影響通信性能的三個方面（I/O模型、線程調度模型、序列化方式）來談談Netty的架構。</p><p>12、分佈式全局id</p><p>1)Redis生成ID</p><p>當使用數據庫來生成ID性能不夠要求的時候，我們可以嘗試使用Redis來生成ID。這主要依賴於Redis是單線程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY來實現</p><p>2)SnowFlake算法生成id的結果是一個64bit大小的整數，它的結構如下圖：</p><p>1位，不用。二進制中最高位為1的都是負數，但是我們生成的id一般都使用整數，所以這個最高位固定是0</p><p>41位，用來記錄時間戳（毫秒）。</p><p>41位可以表示個數字，</p><p>如果只用來表示正整數（計算機中正數包含0），可以表示的數值範圍是：0 至 ，減1是因為可表示的數值範圍是從0開始算的，而不是1。</p><p>也就是說41位可以表示個毫秒的值，轉化成單位年則是年</p><p>10位，用來記錄工作機器id。</p><p>可以部署在個節點，包括5位datacenterId和5位workerId</p><p>5位（bit）可以表示的最大正整數是，即可以用0、1、2、3、....31這32個數字，來表示不同的datecenterId或workerId</p><p>12位，序列號，用來記錄同毫秒內產生的不同id。</p><p>12位（bit）可以表示的最大正整數是，即可以用0、1、2、3、....4094這4095個數字，來表示同一機器同一時間截（毫秒)內產生的4095個ID序號</p><p>由於在Java中64bit的整數是long類型，所以在Java中SnowFlake算法生成的id就是long來存儲的。</p><p>SnowFlake可以保證：</p><p>所有生成的id按時間趨勢遞增</p><p>整個分佈式系統內不會產生重複id（因為有datacenterId和workerId來做區分）</p><p>13、session跨域共享 單點登錄</p><p>session cookie 存儲的是JSESSIONID</p><p>session存儲在服務器端 cookie存儲在瀏覽器端</p><p>服務器端(Tomcat) 會生成一個唯一的sessionId號存儲在cookie中 叫 jessionid</p><p>在服務器端（tomcat）中存儲serssion 使用concurrentMap (ConcurrentMap key JSESSIONID values session)</p><p>瀏覽器端下次請求服務器端是將jsessionId帶過來 找到對應的session 獲取session中存儲的信息（用戶信息）</p><p>14、分佈式事務</p><p>https://www.cnblogs.com/lfs2640666960/p/9476241.html</p><p>對於TCC的解釋:</p><p>Try階段：嘗試執行,完成所有業務檢查（一致性）,預留必須業務資源（準隔離性）</p><p>Confirm階段：確認執行真正執行業務，不作任何業務檢查，只使用Try階段預留的業務資源，Confirm操作滿足冪等性。要求具備冪等設計，Confirm失敗後需要進行重試。</p><p>Cancel階段：取消執行，釋放Try階段預留的業務資源</p><p>Cancel操作滿足冪等性Cancel階段的異常和Confirm階段異常處理方案基本上一致。</p><p>舉個簡單的例子如果你用100元買了一瓶水，</p><p>Try階段:你需要向你的錢包檢查是否夠100元並鎖住這100元，水也是一樣的。</p><p>如果有一個失敗，則進行cancel(釋放這100元和這一瓶水)，如果cancel失敗不論什麼失敗都進行重試cancel，所以需要保持冪等。</p><p>如果都成功，則進行confirm,確認這100元扣，和這一瓶水被賣，如果confirm失敗無論什麼失敗則重試(會依靠活動日誌進行重試)</p><p>對於TCC來說適合一些:</p><p>強隔離性，嚴格一致性要求的活動業務。</p><p>執行時間較短的業務</p><p>方案2 – RocketMQ 事務消息</p><p>為了能解決該問題，同時又不和業務耦合，RocketMQ提出了“事務消息”的概念。</p><p>具體來說，就是把消息的發送分成了2個階段：Prepare階段和確認階段。</p><p>具體來說，上面的2個步驟，被分解成3個步驟：</p><p>(1) 發送Prepared消息</p><p>(2) update DB</p><p>(3) 根據update DB結果成功或失敗，Confirm或者取消Prepared消息。</p><p>可能有人會問了，前2步執行成功了，最後1步失敗了怎麼辦？這裡就涉及到了RocketMQ的關鍵點：RocketMQ會定期（默認是1分鐘）掃描所有的Prepared消息，詢問發送方，到底是要確認這條消息發出去？還是取消此條消息？</p><p>可以考慮加定時任務自動掃描，自動努力保持一致性。</p><p>15、服務降級、限流</p><p>https://blog.csdn.net/vtopqx/article/details/79494599 1、mock 2、管理界面手動配置</p><p>https://blog.csdn.net/luckykapok918/article/details/72381992</p><p>查看dubbo的官方文檔，可以發現有個mock的配置，mock只在出現非業務異常(比如超時，網絡異常等)時執行。mock的配置支持兩種，一種為boolean值，默認的為false。如果配置為true，則缺省使用mock類名，即類名+Mock後綴；另外一種則是配置"return null"，可以很簡單的忽略掉異常。</p><p>dubbo開發中，通常是微服務架構，那麼在使用過程中可能會遇到多種問題：</p><p>1）多個服務之間可能由於服務沒有啟動或者網絡不通，調用中會出現遠程調用失敗;</p><p>2) 服務請求過大，需要停止部分服務以保證核心業務的正常運行；</p><p>以上兩個問題可以使用Dubbo的服務降級來實現；</p><p>即：在服務宕掉或者併發數太高導致的RpcException異常時，進行友好的處理或者提示，而不是內部報錯導致系統不可用。</p><p>1）第一種方式：在消費者端屏蔽</p><p>2） &lt;dubbo:reference id="userService" check="false" interface="com.cwh.service.UserService" timeout="3000" mock="return null"/></p><p>3） &lt;dubbo:reference id="userService" check="false" interface="com.cwh.service.UserService" timeout="3000" mock="true"/></p><p>打開soa-user-api項目，在com.cwh.service下也就是同UserService統計目錄下新建一個UserServiceMock，注意這裡名字一點要是該接口名+Mock：</p><pre>package com.cwh.service;import java.util.ArrayList;import java.util.List;import com.cwh.model.Article;import com.cwh.model.User;public class UserServiceMock implements UserService{ public List&lt;Article&gt;getUserArticles(int uid){ return null; } public List&lt;User&gt;getUser(String name){ //throw new RuntimeException("服務降級-----"); User user = new User(); user.setUserName("服務降級啦"); user.setUserAge("500"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user); return list; }}</pre><p>16、分佈式任務調度框架</p><p>https://blog.csdn.net/u012379844/article/details/82716146 總結各分佈式任務調度框架</p><p>下載Elastic-job-lite源碼，使用maven進行打包。在elastic-job-lite/elastic-job-lite-console/target/elastic-job-lite-console-3.0.0.M1-SNAPSHOT/中，然後解壓，會有start.bat和start.sh兩個腳本，啟動。</p><p>六、微服務</p><p>1、微服務框架集成mybatis實現多數據源路由實戰</p><p>https://www.2cto.com/kf/201805/746354.html</p><p>https://blog.csdn.net/xgx120413/article/details/80743959</p><p>2、如何設計微服務及其設計原則</p><p>https://blog.csdn.net/tiandiwuya/article/details/78543336</p><p>我們總結了四個方面的優點，分別如下：</p><p>是每個微服務組件都是簡單靈活的，能夠獨立部署。不再像以前一樣，應用需要一個龐大的應用服務器來支撐。</p><p>可以由一個小團隊負責更專注專業，相應的也就更高效可靠。</p><p>微服務之間是鬆耦合的，微服務內部是高內聚的，每個微服務很容易按需擴展。</p><p>微服務架構與語言工具無關，自由選擇合適的語言和工具，高效的完成業務目標即可。</p><p>我們總結了四個原則推薦給大家：</p><p>AKF拆分原則</p><p>前後端分離</p><p>無狀態服務</p><p>Restful通信風格</p><p>對於無狀態服務，首先說一下什麼是狀態：如果一個數據需要被多個服務共享，才能完成一筆交易，那麼這個數據被稱為狀態。進而依賴這個“狀態”數據的服務被稱為有狀態服務，反之稱為無狀態服務。</p><p>那麼這個無狀態服務原則並不是說在微服務架構裡就不允許存在狀態，表達的真實意思是要把有狀態的業務服務改變為無狀態的計算類服務，那麼狀態數據也就相應的遷移到對應的“有狀態數據服務”中。</p><p>場景說明：例如我們以前在本地內存中建立的數據緩存、Session緩存，到現在的微服務架構中就應該把這些數據遷移到分佈式緩存中存儲，讓業務服務變成一個無狀態的計算節點。遷移後，就可以做到按需動態伸縮，微服務應用在運行時動態增刪節點，就不再需要考慮緩存數據如何同步的問題。</p><p>作為一個原則來講本來應該是個“無狀態通信原則”，在這裡我們直接推薦一個實踐優選的Restful 通信風格 ，因為他有很多好處：</p><p>無狀態協議HTTP，具備先天優勢，擴展能力很強。例如需要安全加密是，有現成的成熟方案HTTPS可用。</p><p>JSON 報文序列化，輕量簡單，人與機器均可讀，學習成本低，搜索引擎友好。</p><p>語言無關，各大熱門語言都提供成熟的Restful API框架，相對其他的一些RPC框架生態更完善。</p><p>當然在有些特殊業務場景下，也需要採用其他的RPC框架，如thrift、avro-rpc、grpc。但絕大多數情況下Restful就足夠用了。</p><p>七、性能優化</p><p>1、性能指標</p><p>https://www.cnblogs.com/wangmo/p/8074879.html</p><p>一．系統吞度量要素：</p><p>一個系統的吞度量（承壓能力）與request對CPU的消耗、外部接口、IO等等緊密關聯。單個reqeust 對CPU消耗越高，外部系統接口、IO影響速度越慢，系統吞吐能力越低，反之越高。</p><p>系統吞吐量幾個重要參數：QPS（TPS）、併發數、響應時間</p><p>QPS（TPS）：每秒鐘request/事務 數量</p><p>併發數： 系統同時處理的request/事務數</p><p>響應時間： 一般取平均響應時間</p><p>（很多人經常會把併發數和TPS理解混淆）</p><p>2、jvm調優</p><p>https://www.cnblogs.com/xingzc/p/5756119.html</p><p>概括：</p><p>1 棧是運行時的單位 , 而堆是存儲的單元。</p><p>2 棧解決程序的運行問題，即程序如何執行，或者說如何處理數據，</p><p>堆解決的是數據存儲的問題，即數據怎麼放，放在哪兒。</p><p>在java中一個線程就會相應有一個線程棧與之對應，這點很容易理解，因為不同的線程執行邏輯有所不同，因此需要一個獨立的線程棧。</p><p>而堆則是所有線程共享的</p><p>java中，棧的大小通過-Xss來設置，當棧中存儲的數據比較多時，需要適當調大這個值，否則會出現 java.lang.StackOverflowError異常。</p><p>常見的出現這個異常的是無法返回的遞歸，因為此時棧中保存的信息都是方法返回的記錄點。</p><p>基本數據類型的大小是固定的，這裡就不多說了，對於非基本類型的java對象，其大小就值得商討。</p><p>在java中，一個空Object對象的大小是8byte，這個大小隻是保存堆中一個沒有任何屬性的對象的大小。看看下面語句：</p><p>Object ob = new Object();</p><p>這樣在程序中完成了一個java對象的聲明，但是它所佔的空間為：4byte+8byte。</p><p>（4byte是上面部分所說的java棧中保存引用的所需要空間，而那8byte則是java堆中對象的信息）。</p><p>持久代：</p><p>用於存放靜態文件，如java類、方法等。持久代對垃圾回收沒有顯著影響，但是有些應用可能動態生成或者調用一些class,例如Hibernate等，在這種時候需要設置一個比較大的持久空間來存放這些運行過程中新增的類。持久代大小通過 -XX:MaxPermSize = &lt;N> 進行設置</p><p>有如下原因可能導致Full GC:</p><p>年老代（Tenured）被寫滿</p><p>持久代（Perm）被寫滿</p><p>System.gc()被顯式調用</p><p>上一次GC之後Heap的各域分配策略動態變化</p><p>選擇合適的垃圾收集算法</p><p>1)串行收集器</p><p>用單線程處理所有垃圾回收工作，因為無需多線程交互，所有效率比較高。但是，也無法使用多處理器的優勢，所以此收集器適合單處理器機器。當然，此收集器也可以用在小數據量（100M左右）情況下的多處理器機器上。可以使用 -XX:+UseSerialGC打開</p><p>2)並行收集器</p><p>對年輕代進行並行垃圾回收，因此可以減少垃圾回收時間。一般在多線程多處理器機器上使用。使用 -XX:+UseParallelGC 打開。並行收集器在 J2SE5.0第六6更新上引入，在java SE6.0中進行了增強 --- 可以對年老代進行並行收集。如果年老代不使用並行收集的話，默認是使用單線程進行垃圾回收，因此會制約擴展能力。使用 -XX:+UseParallelOldGC打開。</p><p>使用 -XX:ParallelGCThreads = &lt;N> 設置並行垃圾回收的線程數。此值可以設置與機器處理器數量相等</p><p>此收集器可以進行如下配置：</p><p>最大垃圾回收暫停：指定垃圾回收時的最長暫停時間，通過-XX:MaxGCPauseMillis = &lt;N>指定。&lt;N> 為毫秒，如果指定了此值的話，堆大小和垃圾回收相關參數會進行調整以達到指定值。設定此值可能會減少應用的吞吐量。</p><p>吞吐量：吞吐量為垃圾回收時間與非垃圾回收時間的比值，通過-XX:GCTimeRatio = &lt;N> 來設定，公式為 1/(1 + N)。例如，-XX:GCTimeRatio = 19時，表示5%的時間用於垃圾回收。默認情況為99，即1%的時間用於垃圾回收。</p><p>3)併發收集器</p><p>可以保證大部分工作都併發進行（應用不停止），垃圾回收只暫停很少的時間，此收集器適合對響應時間要求比較高的中、大規模應用。使用 -XX:+UseConcMarkSweepGC打開。</p><p>小結</p><p>串行處理器：</p><p>-- 適用情況：數據量比較小（100M左右），單處理器下並且對相應時間無要求的應用。</p><p>-- 缺點：只能用於小型應用。</p><p>並行處理器：</p><p>-- 適用情況：“對吞吐量有高要求”，多CPU，對應用過響應時間無要求的中、大型應用。舉例：後臺處理、科學計算。</p><p>-- 缺點：垃圾收集過程中應用響應時間可能加長。</p><p>併發處理器：</p><p>-- 適用情況：“對響應時間有高要求”，多CPU，對應用響應時間有較高要求的中、大型應用。舉例：Web服務器/應用服務器、電信交換、集成開發環境。</p><p>以下配置主要針對分代垃圾回收算法而言。</p><p>堆大小設置</p><p>年輕代的設置很關鍵</p><p>JVM中最大堆大小有三方面限制：相關操作系統的數據模型（32-bit 還是64-bit）限制；系統的可用虛擬內存限制；系統的可用物理內存限制。32位系統下，一般限制在1.5G~2G；64位操作系統對內存無限制。在Windows Server 2003系統，3.5G物理內存，JDK5.0下測試，最大可設置為1478m。</p><p>典型設置：</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p><p>-Xmx3550m：設置JVM最大可用內存為3550m。</p><p>-Xms3550m：設置JVM初始內存為3550m。此值可以設置與 -Xmx 相同，以避免每次垃圾回收完成後JVM重新分配內存。</p><p>-Xmn2g：設置年輕代大小為2G。整個堆大小=年輕代大小+年老代大小+持久代大小。持久代一般固定大小為64m，所以增大年輕代後，將會減小年老代大小。此值對系統性能影響較大，Sun官方推薦配置為整個堆的3/8。</p><p>-Xss128k：設置每個線程的堆棧大小。JDK5.0以後每個線程堆棧大小為1M，以前每個線程堆棧大小為256k。根據應用的線程所需內存大小進行調整。在相同物理內存下，減小這個值能生成更多的線程。但是操作系統對一個進程內的線程數還是有限制的，不能無限生成，經驗值在3000~5000左右。</p><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p><p>-XX:NewRatio=4：設置年輕代（包括Eden和兩個Survivor區）與年老代的比值（除去持久代）。設置為4，則年輕代與年老代所佔比值為1:4，年輕代佔整個堆棧的1/5。</p><p>-XX:SurvivorRatio=4：設置年輕代中Eden區與Survivor區的大小比值。設置為4，則兩個Survivor區與一個Eden區的比值為2:4，一個Survivor區佔整個年輕代的1/6。</p><p>-XX:MaxPermSize=16m：設置持久代大小為16m。</p><p>-XX:MaxTenuringThreshold=0：設置垃圾最大年齡。如果設置為0的話，則年輕代對象不經過Survivor區，直接進入年老代。對於年老代比較多的應用，可以提高效率。如果此值設置為一個較大值，則年輕代對象會在Survivor區進行多次複製，這樣可以增加對象在年輕代的存活時間，增加在年輕代被回收的概率。</p><p>回收器選擇</p><p>JVM給了三種選擇：串行收集器、並行收集器、併發收集器，但是串行收集器只適用於小數據量的情況，所以這裡的選擇主要針對並行收集器和併發收集器。默認情況下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在啟動的時候加入相應參數。JDK5.0以後，JVM會根據當前系統配置進行判斷。</p><p>吞吐量優先的並行收集器</p><p>如上文所述，並行收集器主要以到達一定的吞吐量為目標，適用於科學計算和後臺處理等。</p><p>典型配置：</p><p>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</p><p>-XX:+UseParallelGC：選擇垃圾收集器為並行收集器。此配置僅對年輕代有效。即上述配置下，年輕代使用併發收集，而年老代仍舊使用串行收集。</p><p>-XX:+ParallelGCThreads=20：配置並行收集器的線程數，即：同時多少個線程一起進行垃圾回收。此值最好配置與處理器數目相等。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</p><p>-XX:+UseParallelOldGC：配置年老代垃圾收集方式為並行收集。JDK6.0支持對年老代並行收集。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</p><p>-XX:MaxGCPauseMillis=100：設置每次年輕代垃圾回收的最長時間，如果無法滿足此時間，JVM會自動調整年輕代大小，以滿足此值。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</p><p>-XX:+UseAdaptiveSizePolicy：設置此選項後，並行收集器會自動選擇年輕代區大小和相應的Survivor區比例，以達到目標系統規定的最低響應時間或者收集頻率等，此值建議使用並行收集器時，一直打開。</p><p>響應時間優先的併發收集器</p><p>如上文所述，併發收集器主要是保證系統的響應時間，減少垃圾收集時的停頓時間。適用於應用服務器、電信領域等。</p><p>典型配置：</p><p>java -Xmx3550m -Xms3550 -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</p><p>-XX:+UseConcMarkSweepGC：設置年老代為併發收集。測試中配置這個以後，-XX:NewRatio=4的配置失效了，原因不明。所以，此時年輕代大小最好用-Xmn設置。</p><p>-XX:+UseParNewGC：設置年輕代為並行收集。可與CMS收集同時使用。JDK5.0以上，JVM會根據系統配置自行設置，所以無需再設置此值。</p><p>java -Xmx3550m -Xms3550 -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</p><p>-XX:CMSFullGCsBeforeCompaction：由於併發收集器不對內存空間進行壓縮、整理，所以運行一段時間後會產生“碎片”，使得運行效率降低。此值設置運行多少次GC以後對內存空間進行壓縮、整理。</p><p>-XX:+UseCMSCompactAtFullCollection：打開對年老代的壓縮。可能會影響性能，但是可以消除碎片。</p><p>常見配置彙總</p><p>堆設置</p><p>-Xms：初始堆大小</p><p>-Xmx：最大堆大小</p><p>-XX:NewSize=n：設置年輕代大小</p><p>-XX:NewRatio=n：設置年輕代和年老代的比值。如：為3，表示年輕代與年老代比值為1：3，表示Eden：Survivor=3:2，一個Survivor區佔整個年輕代的1/5。</p><p>-XX:MaxPermSize=n：設置持久代大小</p><p>收集器設置</p><p>-XX:+UseSerialGC：設置串行收集器</p><p>-XX:+UseParallelGC：設置並行收集器</p><p>-XX:+UseParalledlOldGC：設置並行年老代收集器</p><p>-XX:+UseConcMarkSweepGC：設置併發收集器</p><p>垃圾回收統計信息</p><p>-XX:+PrintGC</p><p>-XX:+PrintGCDetails</p><p>-XX:+PrintGCTimeStamps</p><p>-Xloggc:filename</p><p>並行收集器設置</p><p>-XX:ParallelGCThreads=n：設置並行收集器收集時使用的CPU數。並行收集線程數。</p><p>-XX:MaxGCPauseMillis=n：設置並行收集最大暫停時間</p><p>-XX:GCTimeRatio=n：設置垃圾回收時間佔程序運行時間的百分比。公式為1/(1+N)</p><p>併發收集器設置</p><p>-XX:+CMSIncrementalMode：設置為增量模式。適用於單CPU情況。</p><p>-XX:+ParallelGCThreads=n：設置併發收集器年輕代收集方式為並行收集時，使用的CPU數。並行收集線程數。</p><p>八、底層知識</p><p>1、JMM</p><p>JMM簡介：</p><p>JMM：Java Memory Model(Java內存模型)，圍繞著在併發過程中如何處理可見性、原子性、有序性這三個特性而建立的模型。OK，我們看一下三種特徵。</p><p>原子性（atomicity）： 原子性是指一個操作不能被打斷，要麼全部執行完畢，要麼不執行。在這點上有點類似於事務操作，要麼全部執行成功，要麼回退到執行該操作之前的狀態 。由Java內存模型來直接保證原子性變量操作包括read, load, assign, use, store和write。大致可以認為基本數據類型的訪問讀寫是具有原子性的。如果應用場景需要一個更大範圍的原子性保證，Java內存模型還提供了lock和unlock操作來滿足需求，儘管虛擬機沒有把lock和unlock操作直接開放給用戶使用，但是卻提供了更高層次的字節碼指令monitorenter和monitorexit來隱式地使用這兩個操作，這兩個字節碼指令反映到Java代碼中就是同步塊——synchronized關鍵字，因此在synchronized塊之間的操作也具備原子性。</p><p>可見性（visibility）： 可見性是指當一個線程修改了共享變量的值，其他線程能夠立即得知這個修改。Java內存模型是通過在變量修改後將新值同步到主內存，無論是普通變量還是volatile變量都是如此，普通變量與volatile變量的區別是，volatile的特殊規則保證了新值能立即同步到主內存，以及每次使用前立即從主內存刷新。因此，可以說volatile保證了多線程操作時變量的可見性，而普通變量不能保證這一點。</p><p>除了volatile之外，Java還有兩個關鍵字能實現可見性，即synchronized和final。同步塊的可見性是由“對一個變量執行unlock操作之前，必須先把此變量同步回主內存中”這條規則獲得的，而final關鍵字的可見性是指：被final修飾的字段在構造器中一旦初始化完成，並且構造器沒有把"this"的引用傳遞出去（this引用逃逸是一件很危險的事情，其他線程有可能通過這個引用訪問到“初始化了一半”的對象），那在其他線程中就能看見final字段的值。</p><p>有序性： Java程序天然的有序性可以總結為一句話：如果本線程內觀察，所有的操作都是有序的；如果在一個線程中觀察另一個線程，所有的操作都是無序的。前半句是指“線程內表現為串行的語義”，後半句是指“指令重排序”現象和“工作內存與主內存同步延遲”現象。JMM模型提供了volatile和synchronized來保證線程之間操作的有序性。</p><p>總之，JMM模型就是提供一套機制來保證操作的原子性、可見性和有序性。根據數據是否被線程可見將JVM將內存組織為主內存和工作內存兩個部分。主內存中主要包括本地方法區和堆。每個線程都有一個工作內存，工作內存中主要包括兩個部分，一個是屬於該線程的棧和對主存部分變量拷貝的寄存器：</p><p>總結：</p><p>① 線程間通信是通過共享主內存的方式去實現的。</p><p>② 線程間對共享數據操作時必須具備原子性、可見性和有序性。</p><p>③ 為了保證對主內存操作數據時不同步也為了操作的方便性，Java提供了Synchronized保證操作的原子性、可見性和有序性。提供了volatile可以保證操作的可見性。</p><p>volatile寫的內存語義如下：當寫一個volatile變量時，JMM會把該線程對應的本地內存中的共享變量值刷新到主內存。</p><p>volatile讀的內存語義如下：當讀一個volatile變量時，JMM會把該線程對應的本地內存置為無效。線程接下來將從主內存中讀取共享變量。</p><p>1.1線程通信</p><p>https://blog.csdn.net/hqq2023623/article/details/51000854</p><p>https://blog.csdn.net/u012810020/article/details/60765988</p><p>https://www.jianshu.com/p/8a58d8335270</p><p>同步是指程序用於控制不同線程之間操作發生相對順序的機制</p><p>1）共享內存</p><p>在共享內存的併發模型裡，線程之間共享程序的公共狀態，線程之間通過寫-讀內存中的公共狀態來隱式進行通信</p><p>2）消息傳遞</p><p>在消息傳遞的併發模型裡，線程之間沒有公共狀態，線程之間必須通過明確的發送消息來進行通信</p><p>java中典型的消息傳遞方式就是wait()和notify()</p><p>1.2消息傳遞</p><p>java中典型的消息傳遞方式就是wait()和notify()</p><p>對於一個對象的成員變量，不管它是原始類型還是包裝類型，都會被存儲到堆區</p><p>2、徹底搞懂synchronized(從偏向鎖到重量級鎖)</p><p>偏向鎖01->輕量級鎖00（自旋鎖，自適應自旋鎖--輕量級鎖也被稱為非阻塞同步、樂觀鎖，因為這個過程並沒有把線程阻塞掛起，而是讓線程空循環等待，串行執行。）->重量級鎖10（互斥鎖(重量級鎖)也稱為阻塞同步、悲觀鎖）</p><p>https://blog.csdn.net/qq_38462278/article/details/81976428</p><p>synchronized可重入鎖的實現</p><p>之前談到過，每個鎖關聯一個線程持有者和一個計數器。當計數器為0時表示該鎖沒有被任何線程持有，那麼任何線程都都可能獲得該鎖而調用相應方法。當一個線程請求成功後，JVM會記下持有鎖的線程，並將計數器計為1。此時其他線程請求該鎖，則必須等待。而該持有鎖的線程如果再次請求這個鎖，就可以再次拿到這個鎖，同時計數器會遞增。當線程退出一個synchronized方法/塊時，計數器會遞減，如果計數器為0則釋放該鎖。</p><p>剛才我們說，鎖實際上是加在對象上的，那麼被加了鎖的對象我們稱之為鎖對象，在java中，任何一個對象都能成為鎖對象。</p><p>為了讓大家更好著理解虛擬機是如何知道這個對象就是一個鎖對象的，我們下面簡單介紹一下java中一個對象的結構。</p><p>java對象在內存中的存儲結構主要有一下三個部分：</p><p>對象頭</p><p>實例數據</p><p>填充數據</p><p>這裡強調一下，對象頭裡的數據主要是一些運行時的數據。</p><p>其簡單的結構如下</p><p>長度 內容 說明</p><p>32/64bit Mark Work hashCode,GC分代年齡，鎖信息</p><p>32/64bit Class Metadata Address 指向對象類型數據的指針</p><p>32/64bit Array Length 數組的長度(當對象為數組時)</p><p>當我們創建一個對象LockObject時，該對象的部分Markword關鍵數據如下。</p><p>bit fields 是否偏向鎖 鎖標誌位</p><p>hash 0 01</p><p>從圖中可以看出，偏向鎖的標誌位是“01”，狀態是“0”，表示該對象還沒有被加上偏向鎖。（“1”是表示被加上偏向鎖）。該對象被創建出來的那一刻，就有了偏向鎖的標誌位，這也說明了所有對象都是可偏向的，但所有對象的狀態都為“0”，也同時說明所有被創建的對象的偏向鎖並沒有生效。</p><p>1）偏向鎖 （在Jdk1.6中，偏向鎖的開關是默認開啟的，適用於只有一個線程訪問同步塊的場景）</p><p>不過，當線程執行到臨界區（critical section）時，此時會利用CAS(Compare and Swap)操作，將線程ID插入到Markword中，同時修改偏向鎖的標誌位。</p><p>所謂臨界區，就是隻允許一個線程進去執行操作的區域，即同步代碼塊。CAS是一個原子性操作</p><p>此時的Mark word的結構信息如下：</p><p>bit fields 是否偏向鎖 鎖標誌位</p><p>threadId epoch 1 01</p><p>此時偏向鎖的狀態為“1”，說明對象的偏向鎖生效了，同時也可以看到，哪個線程獲得了該對象的鎖。</p><p>bit fields 鎖標誌位</p><p>指向LockRecord的指針 00</p><p>注：鎖標誌位”00”表示輕量級鎖</p><p>輕量級鎖主要有兩種</p><p>自旋鎖</p><p>自適應自旋鎖</p><p>自旋鎖的一些問題</p><p>如果同步代碼塊執行的很慢，需要消耗大量的時間，那麼這個時侯，其他線程在原地等待空消耗cpu，這會讓人很難受。</p><p>本來一個線程把鎖釋放之後，當前線程是能夠獲得鎖的，但是假如這個時候有好幾個線程都在競爭這個鎖的話，那麼有可能當前線程會獲取不到鎖，還得原地等待繼續空循環消耗cup，甚至有可能一直獲取不到鎖。</p><p>默認情況下，自旋的次數為10次，用戶可以通過-XX:PreBlockSpin來進行更改。</p><p>3、併發基礎 aqs、cas</p><p>https://blog.csdn.net/zs064811/article/details/76996727 分獨佔鎖與共享鎖兩類</p><p>4、countdownlatch cyclicbarrier semaphore</p><p>https://www.cnblogs.com/dolphin0520/p/3920397.html</p><p>1）countdownlatch -- await(),countdown()</p><p>2) cyclicbarrier -- await()</p><p>3) semaphore</p><p>Semaphore可以控同時訪問的線程個數，通過 acquire() 獲取一個許可，如果沒有就等待，而 release() 釋放一個許可。</p><p>下面對上面說的三個輔助類進行一個總結：</p><p>1）CountDownLatch和CyclicBarrier都能夠實現線程之間的等待，只不過它們側重點不同：</p><p>CountDownLatch一般用於某個線程A等待若干個其他線程執行完任務之後，它才執行；</p><p>而CyclicBarrier一般用於一組線程互相等待至某個狀態，然後這一組線程再同時執行；</p><p>另外，CountDownLatch是不能夠重用的，而CyclicBarrier是可以重用的。</p><p>2）Semaphore其實和鎖有點類似，它一般用於控制對某組資源的訪問權限。</p><p>5、併發集合concurrentHashMap</p><p>http://www.importnew.com/28263.html</p><p>6、threadlocal (使用場景，數據庫連接，session管理(sessionfactory管理))</p><p>https://www.cnblogs.com/dolphin0520/p/3920407.html</p><p>雖然ThreadLocal的get，set方法可以清除ThreadLocalMap中key為null的value，但是get，set方法在內存洩露後並不會必然調用，所以為了防止此類情況的出現，我們有兩種手段。</p><p>1、使用完線程共享變量後，顯示調用ThreadLocalMap.remove方法清除線程共享變量；</p><p>2、JDK建議ThreadLocal定義為private static，這樣ThreadLocal的弱引用問題則不存在了。</p><p>7、fork/join框架</p><p>https://www.cnblogs.com/senlinyang/p/7885964.html</p><p>任務分割出的子任務會添加到當前工作線程所維護的雙端隊列中，進入隊列的頭部。當一個工作線程的隊列裡暫時沒有任務時，它會隨機從其他工作線程的隊列的尾部獲取一個任務(工作竊取算法)</p><p>https://www.cnblogs.com/wzqjy/p/7921063.html Java--8--新特性--串並行流與ForkJoin框架</p><p>Fork/Join與傳統線程池的區別！</p><p>Fork/Join採用“工作竊取模式”，當執行新的任務時他可以將其拆分成更小的任務執行，並將小任務加到線程隊列中，然後再從一個隨即線程中偷一個並把它加入自己的隊列中。</p><p>就比如兩個CPU上有不同的任務，這時候A已經執行完，B還有任務等待執行，這時候A就會將B隊尾的任務偷過來，加入自己的隊列中，對於傳統的線程，ForkJoin更有效的利用的CPU資源！</p><p>8、callable,future</p><p>https://www.cnblogs.com/dolphin0520/p/3949310.html</p><p>Future類位於java.util.concurrent包下，它是一個接口：</p><pre>public interface Future&lt;V&gt; { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;}</pre><p>9、線程池</p><p>executors創建的fixed,single的線程池，隊列最大是integer.max會出現oom,cached,schedul創建的線程池會無限大integer.max，導致oom</p><div class=pgc-img><img alt=架構師成神之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f284b547c7aa4e6f857167b519f5c885><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>架構</a></li><li><a>師成</a></li><li><a>神之路</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e884df72.html alt=Java工程師成神之路（問題&答案4） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9006a749af324eb9bfbb0637d9a0d54f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e884df72.html title=Java工程師成神之路（問題&答案4）>Java工程師成神之路（問題&答案4）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html alt=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0670cbc9828449c782ac323a238b99e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html title=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效>朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html alt=活動文件櫃的架構是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/104d3629a97947b19d62b03dc3b8d82f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html title=活動文件櫃的架構是什麼>活動文件櫃的架構是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html alt=九年新浪架構師整理PHP架構核心技術教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b3a3c32254344742b6746996f7fab54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html title=九年新浪架構師整理PHP架構核心技術教程>九年新浪架構師整理PHP架構核心技術教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html alt=Kafka整體架構圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/05ae540358854cb3ba0aa4577709330d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html title=Kafka整體架構圖解>Kafka整體架構圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html alt=MyBatis整體架構分析：基礎支持層、核心處理層和接口層 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d6a0b300b114d07b2f3fe66d7ef7005 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html title=MyBatis整體架構分析：基礎支持層、核心處理層和接口層>MyBatis整體架構分析：基礎支持層、核心處理層和接口層</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html alt=K8S整體架構解析，簡單明瞭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/37380f3294a54bbf8c6bec1de3e08ba0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html title=K8S整體架構解析，簡單明瞭>K8S整體架構解析，簡單明瞭</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html alt=支付系統：整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1d94fa40459462fa825d407a1904c7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html title=支付系統：整體架構>支付系統：整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html alt=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bd78fffbaaf54bd79c6e463d5b69ed9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html title=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？>「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html alt=微服務分佈式架構中，如何實現日誌鏈路跟蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3a2cecaee304124a86a864a75c38b5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html title=微服務分佈式架構中，如何實現日誌鏈路跟蹤？>微服務分佈式架構中，如何實現日誌鏈路跟蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48822193.html alt="「前端架構」前端框架(一部): Angular的內幕" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/efd86e8d12f44e7b97726d738e8d6c1d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48822193.html title="「前端架構」前端框架(一部): Angular的內幕">「前端架構」前端框架(一部): Angular的內幕</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4515b9af.html alt="Uber 架構(1)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/da0e1368146f4614836d85f921a0e4a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4515b9af.html title="Uber 架構(1)">Uber 架構(1)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b52ff792.html alt=什麼是分佈式系統！以及分佈式系統架構的優缺點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RSbrXx83dpwdLU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b52ff792.html title=什麼是分佈式系統！以及分佈式系統架構的優缺點>什麼是分佈式系統！以及分佈式系統架構的優缺點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/721c3e45.html alt=千萬級併發流量控制策略，分佈式場景下的架構設計思路 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/79d1d484239a40908c52abf017fa42d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/721c3e45.html title=千萬級併發流量控制策略，分佈式場景下的架構設計思路>千萬級併發流量控制策略，分佈式場景下的架構設計思路</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>