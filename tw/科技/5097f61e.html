<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java常見面試題 非常實用「個人經驗」 | 极客快訊</title><meta property="og:title" content="Java常見面試題 非常實用「個人經驗」 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/2aecf5ead9884b889eb85fbe6627e8e1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5097f61e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5097f61e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5097f61e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5097f61e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5097f61e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5097f61e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5097f61e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5097f61e.html><meta property="article:published_time" content="2020-11-14T21:05:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:09+08:00"><meta name=Keywords content><meta name=description content="Java常見面試題 非常實用「個人經驗」"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5097f61e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java常見面試題 非常實用「個人經驗」</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2aecf5ead9884b889eb85fbe6627e8e1><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right><strong>Java 容器都有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>Collection</strong> <strong>的子類</strong> <strong>List、Set</strong></li><li><strong>List</strong> <strong>的子類</strong> <strong>ArrayList、LinkedList等</strong></li><li><strong>Set</strong> <strong>的子類</strong> <strong>HashSet、TreeSet等</strong></li><li><strong>Map</strong> <strong>的子類</strong> <strong>HashMap、TreeMao等</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Collecion 和 Collections 有什麼區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>java.util,Collection</strong> <strong>是一個集合的頂級接口，它提供了對集合對象進行基本操作的通用接口方法，Collection 接口的意義是為各種具體的集合提供了最大化的統一操作方式，其直接繼承接口的有 List 和 Set</strong></li><li><strong>java.util.Collections</strong> <strong>是一個包裝類（工具類），它包含了各種有關集合操作的靜態多態方法。此類不能被實例化，用於對集合中元素進行排序、搜索以及線程安全等各種操作，服務於 Java 的 Collection 框架</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>List、Set、Map 之間的區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>List、Set 都繼承 Collection 接口，而 Map 則不是</strong></li><li><strong>List 是一個有序集合，元素可重複，可有多個NULL值。可以使用各種循環遍歷集合，因為它是有序的</strong></li><li><strong>Set 是一個無序集合，元素不可重複，重複元素會被覆蓋掉（注意：元素雖然無放入順序，但元素在 Set 中的位置是由該元素的 HashCode 決定的，其位置是固定的，加入 Set 的 Object 必須定義</strong> <strong>equals()方法），Set 只能用迭代，因為它是無序的</strong></li><li><strong>Map 是由一系列鍵值對組成的集合，提供了 key 和 value 的映射。在 Map 中保證 key 與 value 一一對應的關係。一個 key 對應一個 value ，不能存在相同的 key，但 value 可以相同</strong></li><li><strong>Set 與 List 相比較</strong></li></ul><ol start=1><li><strong>Set 檢索元素效率較低，刪除和插入效率高，因為刪除和插入不會引起元素的位置變化</strong></li><li><strong>List 可動態增長，查找元素效率高，但是刪除和插入效率低，因為刪除或插入一條元素，會引起其他元素位置變化</strong></li></ol><ul><li><strong>Map 適合存儲鍵值對的數據</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>HashMap 和 HashTable 的區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>繼承的父類不同，但二者都實現了 Map接口</strong></li></ol><ul><li><strong>HashTable 繼承自</strong> <strong>Dictionary</strong> <strong>類</strong></li><li><strong>HashMap 繼承自</strong> <strong>AbstractMap</strong> <strong>類</strong></li></ul><ol start=1><li><strong>線程</strong><strong>安全</strong><strong>不同</strong></li></ol><ul><li><strong>HashMap 在缺省的情況下是非Synchronize的</strong></li><li><strong>HashTable 的方法是Synchronize的</strong></li><li><strong>在多線程下直接使用 HashTable 不需要自己為它的方法實現同步。但使用 HashMap 時需要手動增加同步處理Map m = Collections.synchronizeMap(hashMap);</strong></li></ul><ol start=1><li><strong>是否提供 contains() 方法</strong></li></ol><ul><li><strong>HashMap 把 HashTable 的 contains() 方法去掉了，改成了 containsValue() 和 containsKey()，因為 contains 容易讓人誤解</strong></li><li><strong>HashTable 則保留了 contains()、containsValue()、containsKey() 三個方法，其中 contains() 與 containsValue() 功能相同</strong></li></ul><ol start=1><li><strong>key 和 value 是否可以為 null 值</strong></li></ol><ul><li><strong>HashTable 中，key 和 value 都不能為 null 值</strong></li><li><strong>HashMap 中，null 作為鍵，但這樣的鍵只有一個。可以有多個 value 為 null 值的鍵。當 get() 方式返回 null 有可能是 HashMap 中沒有該鍵，也有可能返回的 value 為 null。所以 HashMap 用containsKey()方法判斷是否存在鍵</strong></li></ul><ol start=1><li><strong>遍歷方式不同</strong></li></ol><ul><li><strong>HashTable 與 HashMap 都是使用 Iterator 迭代器遍歷，而由於歷史的原因，HashTable 還使用了</strong> <strong>Enumeration</strong> <strong>的方式</strong></li></ul><ol start=1><li><strong>hash 值不同</strong></li></ol><ul><li><strong>哈希值的使用不同，HashTable直接使用對象的HashCode，而 HashMap 重新計算哈希值</strong></li><li><strong>hashCode是jdk根據對象的地址或者字符串或者數字算出來的int類型的數值</strong></li><li><strong>HashTable 使用的取模運算</strong></li><li><strong>HashMap 使用的與運算，先用</strong> <strong>hash & 0x7FFFFFFF</strong> <strong>後，再對 length 取模，&0x7FFFFFFF</strong> <strong>的目的是為了將負的 hash 值轉化為正值，因為 hash 值有可能為負數，而</strong> <strong>&0x7FFFFFFF</strong> <strong>後，只有符號外改變，而後面的位都不變</strong></li></ul><ol start=1><li><strong>內部實現使用的數組初始化和擴容方式不同</strong></li></ol><ul><li><strong>HashTable 在不指定容量的情況下默認是11，而 HashMap 為16，HashTable 不要求底層數組的容量一定要是2的整數次冪，而 HashMap 底層數組則一定為2的整數次冪</strong></li><li><strong>HashTable 擴容時，將容量變成原來的2倍+1 （old * 2 + 1），而 HashMap 則直接改為原來的2倍 （old * 2）</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>如何決定使用 HashMap 還是 TreeMap</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>如果需要得到一個有序的 Map 集合就應該使用 TreeMap （因為 HashMap 的排序順序不是固定的）除此之外，由於 HashMap 有比 TreeMap 更好的性能，在不需要使用排序的情況下使用 HashMap 會更好</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>HashMap 的實現原理</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>利用key的hashCode重新hash計算出當前對象的元素在數組中的下標</strong> <strong>存儲時，如果出現hash值相同的key，此時有兩種情況。(1)如果key相同，則覆蓋原始值；(2)如果key不同（出現衝突），則將當前的key-value放入鏈表中</strong> <strong>獲取時，直接找到hash值對應的下標，在進一步判斷key是否相同，從而找到對應值。</strong> <strong>理解了以上過程就不難明白HashMap是如何解決hash衝突的問題，核心就是使用了數組的存儲方式，然後將衝突的key的對象放入鏈表中，一旦發現衝突就在鏈表中做進一步的對比。</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>HashSet 的實現原理</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>HashSet 實際上是一個</strong> <strong>HashMap</strong> <strong>實例，都是一個存放鏈表的數組。它不保證存儲元素的迭代順序；此類允許使用 null 元素。HashSet 中不允許有重複元素，這是因為 HashSet 是基於 HashMap 實現的，HashSet 中的元素都存放在 HashMap 的 key 上面，而 value 中的值都是統一的一個固定對象</strong> <strong>private static final Object PRESENT = new Object();</strong></li><li><strong>HashSet 中 add() 方法調用的是底層 HashMap 中的 put() 方法，而如果是在 HashMap 中調用 put() ，首先會判斷 key 是否存在，如果 key 存在則修改 value 值，如果 key 不存在</strong><strong>這</strong><strong>插入這個 key-value。而在 set 中，因為 value 值沒有用，也就不存在修改 value 值的說法，因此往 HashSet 中添加元素，首先判斷元素（也就是key）是否存在，如果不存在這插入，如果存在著不插入，這樣 HashSet 中就不存在重複值。所以判斷 key 是否存在就要重寫元素的類的 equals() 和 hashCode() 方法，當向 Set 中添加對象時，首先調用此對象所在類的 hashCode() 方法，計算次對象的哈希值，此哈希值決定了此對象在Set中存放的位置；若此位置沒有被存儲對象則直接存儲，若已有對象則通過對象所在類的 equals() 比較兩個對象是否相同，相同則不能被添加。</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>ArrayList 與 LinkList 的區別是什麼</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>AarrayList 是動態數組構成 LinkList 是鏈表組成</strong></li><li><strong>AarrayList 常用於經常查詢的集合，因為 LinkList 是線性存儲方式，需要移動指針從前往後查找</strong></li><li><strong>LinkList 常用於新增和刪除的集合，因為 ArrayList 是數組構成，刪除某個值會對下標影響，需要進行數據的移動</strong></li><li><strong>AarrayList 自由度較低，需要手動設置固定的大小，但是它的操作比較方便的，①直接創建②添加對象③根據下標進行使用</strong></li><li><strong>LinkList 自由度較高，能夠動態的隨數組的數據量而變化</strong></li><li><strong>ArrayList 主要開銷在List需要預留一定空間</strong></li><li><strong>LinkList 主要開銷在需要存儲結點信息以及結點指針信息</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>如何實現數組與 List 之間的轉換</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>List to Array : 可以使用 List 的</strong> <strong>toArray()</strong> <strong>方法，傳入一個數組的類型例如</strong> <strong>Stirng[] strs = strList.toArray(new String[strList.size()]);</strong></li><li><strong>Array to List : 可以使用</strong> <strong>java.util.Arrays</strong> <strong>的</strong> <strong>asList()方法 例如</strong> <strong>List&lt;String> strList = Arrays.asList(strs);</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>ArrayList 與 Vector 的區別是什麼</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>ArrayList 是非線程安全的，而 Vector 使用了</strong> <strong>Synchronized</strong> <strong>來實現線程同步的</strong></li><li><strong>ArrayList 在性能方面要優於 Vector</strong></li><li><strong>ArrayList 和 Vector 都會根據實際情況來動態擴容的，不同的是 ArrayList 擴容到原大小的1.5倍，而 Vector 擴容到原大小的2倍</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Array 與 ArrayList 有什麼區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>Array 是數組，當定義數組時，必須指定數據類型及數組長度</strong></li><li><strong>ArrayList 是動態數組，長度可以動態改變，會自動擴容，不使用泛型的時候，可以添加不同類型元素</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>在 Queue 中 poll() 與 remove() 有什麼區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>poll() 和 remove() 都是從隊列頭刪除一個元素，如果隊列元素為空，remove() 方法會拋出NoSuchElementException異常，而 poll() 方法只會返回 null</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>哪些集合類是線程安全的</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li>Vector ：比 ArrayList 多了同步化機制（線程安全）</li><li>HashTable ：比 HashMap 多了線程安全</li><li>ConcurrentHashMap ：是一種高效但是線程安全的集合</li><li>Stack ：棧，繼承於 Vector 也是線程安全</li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>迭代器 Iterator 是什麼</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li>Iterator 是集合專用的遍歷方式</li><li>Iterator&lt;E> iterator() : 返回此集合中元素的迭代器，通過集合的iterator()方法得到，所以Iterator是依賴於集合而存在的</li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Iterator 怎麼使用 ? 有什麼特點</strong></h1><blockquote class=pgc-blockquote-abstract><p>Iterator 的使用方法</p></blockquote><ul><li>java.lang.Iterable 接口被 java.util.Collection 接口繼承，java.util.Collection 接口的 iterator() 方法返回一個 Iterator 對象</li><li>next() 方法獲取集合中下一個元素</li><li>hasNext() 方法檢查集合中是否還有元素</li><li>remove() 方法將迭代器新返回的元素刪除</li></ul><p><br></p><blockquote class=pgc-blockquote-abstract><p>Iterator 的特點</p></blockquote><ul><li>Iterator 遍歷集合過程中不允許線程對集合元素進行修改</li><li>Iterator 遍歷集合過程中可以用remove()方法來移除元素，移除的元素是上一次Iterator.next()返回的元素</li><li>Iterator 的next()方法是通過遊標指向的形式返回Iterator下一個元素</li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Iterator 與 LinkIterator 有什麼區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>使用範圍不同</strong></li></ul><ol start=1><li><strong>Iterator 適用於所有集合， Set、List、Map以及這些集合的子類型，而 ListIterator 只適用於 List 及其子類型</strong></li><li><strong>ListIterator 有 add() 方法，可以向 List 中添加元素，而 Iterator 不能</strong></li><li><strong>ListIterator 和 Iterator 都有 hasNext() 和 next() 方法，來實現順序向後遍歷。而 ListIterator 有 hasPrevious() 和 previous() 方法，可以實現逆向遍歷，但是 Iterator 不能</strong></li><li><strong>ListIterator 可以使用 nextIdnex() 和 previousIndex() 方法定位到當前索引位置，而 Iterator 不能</strong></li><li><strong>它們都可以實現 remove() 刪除操作，但是 ListIterator 可以使用 set() 方法實現對象修改，而 Iterator 不能</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>怎麼確保一個集合不能被修改</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>可以採用</strong> <strong>java.util.Collections</strong> <strong>工具類</strong></li><li><strong>Collections.unmodifiableMap(map)</strong></li><li><strong>Collections.unmodifiableList(list)</strong></li><li><strong>Collections.unmodifiableSet(set)</strong></li><li><strong>如諾修改則會報錯java.lang.UnsupportedOperationException</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><em><strong>2</strong></em><strong>|</strong><em><strong>3</strong></em><strong>多線程部分面試題</strong></h1><h1 class=pgc-h-arrow-right><strong>併發和並行有什麼區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>併發：不同的代碼塊交替執行</strong></li><li><strong>並行：不同的代碼塊同時執行</strong></li><li><strong>個人理解</strong></li></ul><ol start=1><li><strong>併發就是放下手頭的任務A去執行另外一個任務B，執行完任務B後，再回來執行任務A，就比如說吃飯時來電話了，去接電話，打完電話後又回來吃飯</strong></li><li><strong>並行就是執行A的同時，接受到任務B，然後我一起執行，就比如說吃飯時來電話了，一邊吃飯一邊打電話</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>線程和進程的區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>根本區別 ：進程是操作系統資源分配的基本單位，而線程是任務調度和執行的基本單位</strong></li><li><strong>在操作系統中能同時運行多個進程，進程中會執行多個線程</strong></li><li><strong>線程是操作系統能夠進行運算調度的最小單位</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>守護線程是什麼</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>JVM內部的實現是如果運行的程序只剩下守護線程的話，程序將終止運行，直接結束。所以守護線程是作為輔助線程存在的</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>創建線程有哪幾種方式</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>繼承Thread類創建線程類</strong></li></ol><ul><li><strong>定義Thread類的子類，並重寫該類的run()方法</strong></li><li><strong>創建Thread子類的實例，即創建了線程對象</strong></li><li><strong>調用線程對象的start()方法來啟動該線程</strong></li></ul><ol start=1><li><strong>實現Runnable接口創建線程類</strong></li></ol><ul><li><strong>創建runnable接口的實現類，並重寫該接口的run()方法</strong></li><li><strong>創建Runnable實現類的實例，並依此實例作為Thread的target來創建Thread對象，該</strong> <strong>Thread對象才是真正的線程對象</strong></li><li><strong>調用線程對象的start()方法來啟動該線程</strong></li></ul><ol start=1><li><strong>通過 Callable 和 Future 創建線程</strong></li></ol><ul><li><strong>創建Callable接口的實現類，並重寫call()方法，該call()方法將作為線程執行體，並且有返回值</strong></li><li><strong>創建Callable實現類的實例，使用FutureTask類來包裝Callable對象，該FutureTask對象封裝了該Callable對象的call()方法的返回值</strong></li><li><strong>使用FutureTask對象作為Thread對象的target創建並啟動新線程</strong></li><li><strong>調用FutureTask對象的get()方法來獲得子線程執行結束後的返回值</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right><strong>怎麼驗證 MySQL 的索引是否滿足需求</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>使用explain函數驗證索引是否有效</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>事務的隔離級別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>Read uncommitted (讀未提交)：最低級別</strong></li><li><strong>Read committed (讀已提交)：讀已提交，可避免髒讀情況發生。</strong></li><li><strong>Repeatable Read（可重複讀）：確保事務可以多次從一個字段中讀取相同的值，在此事務持續期間，禁止其他事務對此字段的更新，可以避免髒讀和不可重複讀，仍會出現幻讀問題</strong></li><li><strong>Serializable （串行化）：最嚴格的事務隔離級別，要求所有事務被串行執行，不能併發執行，可避免髒讀、不可重複讀、幻讀情況的發生</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>MySQL 常用的引擎</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>InnoDB 和 Myisam 都是用 B+Tree 來存儲數據的</strong></p></blockquote><ol start=1><li><strong>InnoDB 支持事務，且支持四種隔離級別（讀未提交、讀已提交、可重複讀、串行化），默認的為可重複讀.</strong></li><li><strong>Myisam 只支持表鎖，且不支持事務.Myisam 由於有單獨的索引文件，在讀取數據方面的性能很高.</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>MySQL 的行鎖、表鎖、頁鎖</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>行級鎖</strong></li></ul><p><strong>是Mysql中鎖定粒度最細的一種鎖，表示只針對當前操作的行進行加鎖。行級鎖能大大減少數據庫操作的衝突。其加鎖粒度最小，但加鎖的開銷也最大。行級鎖分為共享鎖 和 排他鎖。</strong></p><ul><li><strong>行級鎖的特點</strong></li></ul><p><strong>開銷大，加鎖慢；會出現死鎖；鎖定粒度最小，發生鎖衝突的概率最低，併發度也最高。</strong></p><ul><li><strong>表級鎖</strong></li></ul><p><strong>表級鎖是MySQL中鎖定粒度最大的一種鎖，表示對當前操作的整張表加鎖，它實現簡單，資源消耗較少，被大部分MySQL引擎支持。最常使用的MYISAM與INNODB都支持表級鎖定。表級鎖定分為表共享讀鎖（共享鎖）與表獨佔寫鎖（排他鎖）</strong></p><ul><li><strong>表級鎖的特點</strong></li></ul><p><strong>開銷小，加鎖快；不會出現死鎖；鎖定粒度大，發出鎖衝突的概率最高，併發度最低。</strong></p><ul><li><strong>頁級鎖</strong></li></ul><p><strong>頁級鎖是MySQL中鎖定粒度介於行級鎖和表級鎖中間的一種鎖。表級鎖速度快，但衝突多，行級衝突少，但速度慢。所以取了折衷的頁級，一次鎖定相鄰的一組記錄。BDB支持頁級鎖</strong></p><ul><li><strong>頁級鎖的特點</strong></li></ul><p><strong>開銷和加鎖時間界於表鎖和行鎖之間；會出現死鎖；鎖定粒度界於表鎖和行鎖之間，併發度一般</strong></p><ul><li><strong>擴展</strong></li></ul><ol start=1><li><strong>MyISAM和MEMORY採用表級鎖(tabl-level locking)</strong></li><li><strong>BDB採用頁面鎖(page-level locking)或表級鎖，默認為頁面鎖</strong></li><li><strong>InnoDB支持行級鎖(row-level locking)和表級鎖,默認為行級鎖</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>樂觀鎖和悲觀鎖</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>樂觀鎖認為一般情況下數據不會造成衝突，所以在數據進行提交更新時才會對數據的衝突與否進行檢測。如果沒有衝突那就OK；如果出現衝突了，則返回錯誤信息並讓用戶決定如何去做.常見的做法有兩種：版本號控制及時間戳控制</strong></li><li><strong>悲觀鎖，正如其名，它指的是對數據被外界（包括當前系統的其它事務，以及來自外部系統的事務處理）修改持保守態度，因此，在整個數據處理過程中，將數據處於鎖定狀態。悲觀鎖的實現，往往依靠數據庫提供的鎖機制（也只有數據庫層提供的鎖機制才能真正保證數據訪問的排它性，否則，即使在本系統中實現了加鎖機制，也無法保證外部系統不會修改數據）常見做法：select ... for update悲觀鎖語法鎖住記錄</strong> <strong>兩個事務同時修改的話，事務A先執行事務B就會被阻塞，事務A執行update完後，事務B就會看到事務A執行完後更新的結果</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>MySQL 問題排查都有哪些手段</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>使用 show processlist 命令查看當前所有連接信息</strong></li><li><strong>使用 explain 命令查詢 SQL 語句執行計劃</strong></li><li><strong>開啟慢查詢日誌，查看慢查詢的 SQL</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>如何做 MySQL 的性能優化</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>創建索引 儘量避免全盤掃描 首先考慮在 where 和 order by 涉及的列上創建索引</strong></li><li><strong>避免在索引上使用計算 注意就是IN關鍵字不走索引，它是走全盤掃描</strong></li><li><strong>使用預編譯防止 sql 注入</strong></li><li><strong>儘量將多條 SQL語句壓縮到一條 SQL 語句中</strong></li><li><strong>最最最好的就是少用 * ， 應該寫成要查詢的字段名，儘量避免在 where 條件中判斷 null</strong></li><li><strong>儘量不用like 的前置百分比</strong></li><li><strong>對於連續的數值，能用 between 就不要用 in</strong></li><li><strong>在新建臨時表時，如果一次性插入數據量較大.可以用 select into 代替 create table</strong></li><li><strong>選擇正確的存儲引擎</strong></li><li><strong>垂直/水平分割、分庫分表、讀寫分離</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><em><strong>2</strong></em><strong>|</strong><em><strong>7</strong></em><strong>Redis部分面試題</strong></h1><h1 class=pgc-h-arrow-right><strong>Redis 是什麼?有什麼優點?都有哪些使用場景</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>Reids 是完全開源免費的，用C語言編寫的，遵守BSD協議，</strong> <strong>是一個高性能的(key/value)分佈式內存數據庫，基於內存運行</strong> <strong>並支持持久化的NoSQL數據庫，是當前最熱門的NoSql數據庫之一,</strong> <strong>也被人們稱為數據結構服務器</strong></li><li><strong>優點</strong></li></ul><ol start=1><li><strong>Redis支持數據的持久化，可以將內存中的數據保持在磁盤中，重啟的時候可以再次加載進行使用</strong></li><li><strong>Redis不僅僅支持簡單的key-value類型的數據，同時還提供list，set，zset，hash等數據結構的存儲</strong></li><li><strong>Redis支持數據的備份，即master-slave模式的數據備份</strong></li></ol><ul><li><strong>應用場景</strong></li></ul><ol start=1><li><strong>內存存儲和持久化：redis支持異步將內存中的數據寫到硬盤上，同時不影響繼續服務</strong></li><li><strong>取最新N個數據的操作，如：可以將最新的10條評論的ID放在Redis的List集合裡面</strong></li><li><strong>模擬類似於HttpSession這種需要設定過期時間的功能</strong></li><li><strong>發佈、訂閱消息系統</strong></li><li><strong>定時器、計數器</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 為什麼是單線程的</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>Redis是基於內存的操作，CPU不是Redis的瓶頸，Redis的瓶頸最有可能是機器內存的大小或者網絡帶寬。既然單線程容易實現，而且CPU不會成為瓶頸</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 的緩存預熱</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>在項目配置文件中生命自定義的key</strong> <strong>，在項目啟動時會判斷redis是否存在key</strong> <strong>，如果沒有就會創建一個key傳入null值</strong></li><li><strong>數據加熱的含義就是在正式部署之前，我先把可能的數據先預先訪問一遍，這樣部分可能大量訪問的數據就會加載到緩存中</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>redis 緩存雪崩是什麼，怎麼解決 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>緩存雪崩是指，緩存層出現了錯誤，不能正常工作了.於是所有的請求都會達到存儲層，存儲層的調用量會暴增，造成存儲層也會掛掉的情況.</strong></p></blockquote><blockquote class=pgc-blockquote-abstract><p><strong>解決方案</strong></p></blockquote><ol start=1><li><strong>redis 高可用 就是搭建</strong> <strong>redis 集群，其中一臺redis掛掉後 可以使用其他的 redis</strong></li><li><strong>限流降級</strong> <strong>就是每一個 key 只能一個線程來查詢數據和緩存，其他線程等待</strong></li><li><strong>數據預熱</strong> <strong>數據加熱的含義就是在正式部署之前，我先把可能的數據先預先訪問一遍，這樣部分可能大量訪問的數據就會加載到緩存中.在即將發生大併發訪問前手動觸發加載緩存不同的 key ，設置不同的過期時間，讓緩存失效的時間點儘量均勻.</strong>*</li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>緩存穿透是什麼?如何解決</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>就是訪問redis數據庫，查不到數據，就是沒有命中，會去持久化數據庫查詢，還是沒有查到.假如高併發的情況下，持久化數據庫一下增加了很大壓力，就相當於出現了緩存穿透</strong></p></blockquote><blockquote class=pgc-blockquote-abstract><p><strong>解決方案</strong></p></blockquote><ol start=1><li><strong>緩存空對象</strong> <strong>在存儲層命中失敗後，即使返回空對象也將其緩存，並設置一個過期時間，之後訪問的這個數據將會從緩存中取出，很好的保護了後端數據源，這樣也會有出現問題 例如空值被緩存也就會增加大量的緩存空間，設置了過期時間還是會存在緩存層和存儲層的數據會有一段時間窗口的不一致，這對於需要保持一致性的業務會有影響</strong></li><li><strong>布隆過濾器</strong> <strong>對所有可能查詢的參數以 hash 形式存儲，查詢時發現值不存在就直接丟棄，不會去持久層查詢</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 支持的數據類型有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>String、List、Set、Hash、ZSet這5種</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 支持的 Java 客戶端有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>Redisson、Jedis、lettuce 等等，官方推薦使用 Redisson</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Jedis 與 Redisson 有哪些區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>Jedis 和 Redisson 都是Java中對Redis操作的封裝。Jedis 只是簡單的封裝了 Redis 的API庫，可以看作是Redis客戶端，它的方法和Redis 的命令很類似。Redisson 不僅封裝了 redis ，還封裝了對更多數據結構的支持，以及鎖等功能，相比於Jedis 更加大。但Jedis相比於Redisson 更原生一些，更靈活</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>怎麼保證緩存與數據庫數據的一致性</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>對刪除緩存進行重試，數據的一致性要求越高，我越是重試得快。</strong></li><li><strong>定期全量更新，簡單地說，就是我定期把緩存全部清掉，然後再全量加載。</strong></li><li><strong>給所有的緩存一個失效期</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 持久化有幾種方式</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>快照方式（RDB, Redis DataBase）將某一個時刻的內存數據，以二進制的方式寫入磁盤</strong></li><li><strong>文件追加方式（AOF, Append Only File），記錄所有的操作命令，並以文本的形式追加到文件中</strong></li><li><strong>混合持久化方式，Redis 4.0 之後新增的方式，混合持久化是結合了 RDB 和 AOF 的優點，在寫入的時候，先把當前的數據以 RDB 的形式寫入文件的開頭，再將後續的操作命令以 AOF 的格式存入文件，這樣既能保證 Redis 重啟時的速度，又能簡單數據丟失的風險</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 怎麼實現分佈式鎖</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>SET key value [EX seconds] [PX milliseconds] [NX|XX]</strong></li><li><strong>EX second</strong> <strong>:設置鍵的過期時間為second秒</strong></li><li><strong>PX millisecond</strong> <strong>:設置鍵的過期時間為millisecond毫秒</strong></li><li><strong>NX</strong> <strong>:只在鍵不存在時,才對鍵進行設置操作</strong></li><li><strong>XX</strong> <strong>:只在鍵已經存在時,才對鍵進行設置操作</strong></li><li><strong>SET操作成功完成時,返回OK</strong> <strong>,否則返回nil</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 分佈式鎖有什麼缺陷</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>死鎖</strong></li></ol><ul><li><strong>設置鎖的過期時間，且需要保證setNx和設置過期時間操作的原子性</strong></li></ul><ol start=1><li><strong>錯位解鎖</strong></li></ol><ul><li><strong>加鎖時記錄當前線程ID，解鎖時判斷ID是否一致</strong></li><li><strong>解鎖時，查詢redis裡記錄鎖的ID，以及刪除redis中鎖的記錄，這兩步操作可以使用lua腳本保持原子性</strong></li></ul><ol start=1><li><strong>業務併發執行問題</strong></li></ol><ul><li><strong>加鎖成功後開啟守護線程，當臨近過期時間，業務還未完成時，開始續時，重複此步驟直到業務完成</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 如何做內存優化</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>縮減鍵值對象：滿足業務要求下 key 越短越好；value 值進行適當壓縮</strong></li><li><strong>共享對象池：即 Redis 內部維護[0-9999]的整數對象池，開發中在滿足需求的前提下，儘量使用整數對象以節省內存</strong></li><li><strong>儘可能使用散列表(hashes)</strong></li><li><strong>編碼優化，控制編碼類型</strong></li><li><strong>控制 key 的數量</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 淘汰策略有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>noeviction: 不刪除策略, 達到最大內存限制時, 如果需要更多內存, 直接返回錯誤信息。 大多數寫命令都會導致佔用更多的內存(有極少數會例外, 如 DEL )</strong></li><li><strong>allkeys-lru: 所有key通用; 優先刪除最近最少使用(less recently used ,LRU) 的 key</strong></li><li><strong>volatile-lru: 只限於設置了</strong> <strong>expire</strong> <strong>的部分; 優先刪除最近最少使用(less recently used ,LRU) 的 key</strong></li><li><strong>allkeys-random: 所有key通用; 隨機刪除一部分 key</strong></li><li><strong>volatile-random: 只限於設置了 expire 的部分; 隨機刪除一部分 key</strong></li><li><strong>volatile-ttl: 只限於設置了 expire 的部分; 優先刪除剩餘時間(time to live,TTL) 短的key</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Redis 常見的問題有哪些? 該如何解決</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>緩存和數據庫雙寫一致性問題</strong></li></ol><ul><li><strong>就是如果對數據有強一致性要求，不能放緩存。我們所做的一切，只能保證最終一致性</strong></li><li><strong>採取正確更新策略，先更新數據庫，再刪緩存。其次，因為可能存在刪除緩存失敗的問題，提供一個補償措施即可，例如利用消息隊列</strong></li></ul><ol start=1><li><strong>緩存穿透問題</strong></li></ol><ul><li><strong>利用互斥鎖，緩存失效的時候，先去獲得鎖，得到鎖了，再去請求數據庫。沒得到鎖，則休眠一段時間重試</strong></li><li><strong>採用異步更新策略，無論 Key 是否取到值，都直接返回。Value 值中維護一個緩存失效時間，緩存如果過期，異步起一個線程去讀數據庫，更新緩存。需要做緩存預熱(項目啟動前，先加載緩存)操作</strong></li><li><strong>提供一個能迅速判斷請求是否有效的攔截機制，比如，利用布隆過濾器，內部維護一系列合法有效的 Key。迅速判斷出，請求所攜帶的 Key 是否合法有效。如果不合法，則直接返回</strong></li></ul><ol start=1><li><strong>緩存雪崩問題</strong></li></ol><ul><li><strong>給緩存的失效時間，加上一個隨機值，避免集體失效</strong></li><li><strong>使用互斥鎖，但是該方案吞吐量明顯下降</strong></li><li><strong>雙緩存。我們有兩個緩存，緩存 A 和緩存 B。緩存 A 的失效時間為 20 分鐘，緩存 B 不設失效時間。自己做緩存預熱操作(從A中讀不到，就去B讀，返回數據時需要異步啟動一個更新線程，更新線程同時更新緩存 A 和緩存 B)</strong></li></ul><ol start=1><li><strong>緩存的併發競爭問題</strong></li><li><strong>如果對這個 Key 操作，不要求順序</strong></li></ol><ul><li><strong>這種情況下，準備一個分佈式鎖，大家去搶鎖，搶到鎖就做 set 操作即可，比較簡單。</strong></li></ul><ol start=1><li><strong>如果對這個 Key 操作，要求順序</strong></li></ol><ul><li><strong>假設有一個 key1，系統 A 需要將 key1 設置為 valueA，系統 B 需要將 key1 設置為 valueB，系統 C 需要將 key1 設置為 valueC</strong></li><li><strong>期望按照 key1 的 value 值按照 valueA > valueB > valueC 的順序變化。這種時候我們在數據寫入數據庫的時候，需要保存一個時間戳。</strong></li><li><strong>系統A key 1 {valueA 3:00}</strong></li><li><strong>系統B key 1 {valueB 3:05}</strong></li><li><strong>系統C key 1 {valueC 3:10}</strong></li></ul><ul><li><strong>那麼，假設這會系統 B 先搶到鎖，將 key1 設置為{valueB 3:05}。接下來系統 A 搶到鎖，發現自己的 valueA 的時間戳早於緩存中的時間戳，那就不做 set 操作了，以此類推。</strong></li><li><strong>其他方法，比如利用隊列，將 set 方法變成串行訪問也可以。總之，靈活變通。</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><em><strong>2</strong></em><strong>|</strong><em><strong>8</strong></em><strong>RabbitMQ部分面試題</strong></h1><h1 class=pgc-h-arrow-right><strong>RabbitMq 的使用場景有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>多個應用之間的耦合</strong></li><li><strong>跨系統的異步通信</strong></li><li><strong>流量削峰</strong></li></ol><ul><li><strong>比如：註冊用戶、發送激活郵箱、訂單下單等</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 有哪些重要的角色</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>生產者：消息的創建者，負責創建和推送數據到消息服務器</strong></li><li><strong>消費者：消息的接收方，負責處理數據和確認消息</strong></li><li><strong>代理：就是RabbiMQ本身，不生產不消費，只是快遞消息</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 有哪些重要的組件</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>ConnectionFactory（連接管理器）：應用程序與Rabbit之間建立連接的管理器，程序代碼中使用</strong></li><li><strong>Channel（信道）：消息推送使用的通道</strong></li><li><strong>Exchange（交換器）：用於接受、分配消息</strong></li><li><strong>Queue（隊列）：用於存儲生產者的消息</strong></li><li><strong>RoutingKey（路由鍵）：用於把生成者的數據分配到交換器上</strong></li><li><strong>BindingKey（綁定鍵）：用於把交換器的消息綁定到隊列上</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMQ的消息存儲方式</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>RabbitMQ 對於 queue 中的 message 的保存方式有兩種方式：disc</strong> <strong>和</strong> <strong>ram.如果採用disc，則需要對 exchange／queue／delivery mode 都要設置成 durable 模式. Disc 方式的好處是當 RabbitMQ 失效了， message 仍然可以在重啟之後恢復.而使用 ram 方式， RabbitMQ 處理 message 的效率要高很多， ram 和 disc 兩種方式的效率比大概是</strong> <strong>3:1.所以如果在有其它 HA 手段保障的情況下，選用 ram 方式是可以提高消息隊列的工作效率的.</strong></p></blockquote><h1 class=pgc-h-arrow-right><strong>RabbitMq 中 vhost 的作用是什麼</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>vhost本質上是一個mini版的RabbitMQ服務器，擁有自己的隊列、綁定、交換器和權限控制</strong></li><li><strong>從 RabbitMQ 的全局角度 vhost可以作為不同權限隔離的手段(一個典型的例子，不同的應用可以跑在不同的vhost中)</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 的消息是怎麼發送的</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>生產者把生產的小心通過channel發送到Exchange上，Exchange通過綁定的router key來選擇Queue，消費者監聽到Queue上有新的消息，就消費調此消息</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 怎麼保證消息的穩定性</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>提供了事務的功能，通過將 channel 設置為 confirm（確認模式）</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 怎麼避免丟失消息</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>消息持久化</strong></li><li><strong>消費端的ack簽收機制</strong></li><li><strong>設置集群鏡像模式</strong></li><li><strong>消息補償機制</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>要保證消息持久化成功的條件有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>聲明隊列必須設置持久化 durable 設置為 true</strong></li><li><strong>消息推送投遞模式必須設置持久化，deliveryMode 設置為 2（持久）</strong></li><li><strong>消息已經到達持久化交換器</strong></li><li><strong>消息已經到達持久化隊列</strong></li></ol><ul><li><strong>以上四個條件都滿足才能保證消息持久化成功</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 持久化有什麼缺點</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>持久化的缺點就是降低了服務器的吞吐量，因為使用的是磁盤而非內存存儲，從而降低了吞吐量。可儘量使用 ssd 硬盤來緩解吞吐量的問題</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 有幾種廣播方式</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>fanout廣播模式：所有bind到此exchange的queue都可以接收消息</strong></li><li><strong>direct直接交換：通過routingKey和exchange決定的那個唯一的queue可以接收消息</strong></li><li><strong>topic通配符模式：所有符合routingKey(此時可以是一個表達式)的routingKey所bind的queue可以接收消息</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 怎麼實現延遲消息隊列</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>通過消息過期後進入死信交換器，再由交換器轉發到延遲消費隊列，實現延遲功能</strong></li><li><strong>使用 RabbitMQ-delayed-message-exchange 插件實現延遲功能。</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 集群有什麼用</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>高可用：某個服務器出現問題，整個 RabbitMQ 還可以繼續使用</strong></li><li><strong>高容量：集群可以承載更多的消息量。</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 節點的類型有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>磁盤節點：消息會存儲到磁盤</strong></li><li><strong>內存節點：消息都存儲在內存中，重啟服務器消息丟失，性能高於磁盤類型</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 集群搭建需要注意哪些問題</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>各節點之間使用–link連接，此屬性不能忽略</strong></li><li><strong>各節點使用的 erlang cookie 值必須相同，此值相當於祕鑰的功能，用於各節點的認證</strong></li><li><strong>整個集群中必須包含一個磁盤節點</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 每個節點是其他節點的完整拷貝嗎</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>不是</strong></p></blockquote><ul><li><strong>如果每個節點都擁有所有隊列的完全拷貝，這樣新增節點，不但沒有新增存儲空間，反而增加了更多的冗餘數據</strong></li><li><strong>如果每條消息都需要完整拷貝到每一個集群節點，那新增節點並沒有提升處理消息的能力，最多是保持和單節點相同的性能甚至是更糟</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 集群中唯一一個磁盤節點崩潰了會發生什麼</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>唯一磁盤節點崩潰了，集群是可以保持運行的，但不能更改任何東西</strong></li></ul><ol start=1><li><strong>不能創建隊列</strong></li><li><strong>不能創建交換器</strong></li><li><strong>不能創建綁定</strong></li><li><strong>不能添加用戶</strong></li><li><strong>不能更改權限</strong></li><li><strong>不能添加和刪除集群節點</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>RabbitMq 對集群停止順序有要求嗎</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>RabbitMQ 對集群的停止的順序是有要求的，應該先關閉內存節點，最後再關閉磁盤節點。如果順序恰好相反的話，可能會造成消息的丟失</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><em><strong>2</strong></em><strong>|</strong><em><strong>9</strong></em><strong>JVM部分面試題</strong></h1><h1 class=pgc-h-arrow-right><strong>JVM 主要的組成部分?及其作用</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>類加載器（Class Loader）：加載類文件到內存。Class loader只管加載，只要符合文件結構就加載，至於能否運行，它不負責，那是有Exectution Engine 負責的</strong></li><li><strong>執行引擎（Execution Engine）：也叫解釋器，負責解釋命令，交由操作系統執行</strong></li><li><strong>本地庫接口（Native Interface）：本地接口的作用是融合不同的語言為java所用</strong></li><li><strong>運行時數據區（Runtime Data Area）</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>JVM 運行時數據區是什麼</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>堆是java對象的存儲區域，任何用new字段分配的java對象實例和數組，都被分配在堆上，java堆可用-Xms和-Xmx進行內存控制，</strong></li><li><strong>常量池：運行時常量池是方法區的一部分。Class文件中除了有類的版本、字段、方法、接口等描述信息外，還有一項信息是常量池，用於存放編譯期生成的各種字面量和符號引用，這部分內容將在類加載後進入方法區的運行時常量池中存放，jdk1.7以後，運行時常量池從方法區移到了堆上</strong></li><li><strong>方法區：用於存儲已被虛擬機加載的類信息，常量，靜態變量，即是編譯器編譯後的代碼等數據</strong></li><li><strong>虛擬機棧：虛擬機棧中執行每個方法的時候，都會創建一個棧楨用於存儲局部變量表，操作數棧，動態鏈接，方法出口等信息</strong></li><li><strong>本地方法棧：與虛擬機發揮的作用相似，相比於虛擬機棧為Java方法服務，本地方法棧為虛擬機使用的Native方法服務，執行每個本地方法的時候，都會創建一個棧幀用於存儲局部變量表，操作數棧，動態鏈接，方法出口等信息</strong></li><li><strong>程序計數器：指示Java虛擬機下一條需要執行的字節碼指令</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>堆和棧的區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>棧內存用來存儲局部變量和方法調用</strong></li><li><strong>而堆內存用來存儲 Java 中的對象.無論是成員變量，局部變量，還是類變量.，它們指向的對象都存儲在堆內存中.</strong></li><li><strong>棧內存歸屬單個線程，一個棧對應一個線程，其中儲存的變量只能在該線程中可以訪問到，也可以理解為私有內存</strong></li><li><strong>而堆內存中的對象 所有線程均可見，堆內存中對象可以被所有線程訪問到</strong></li><li><strong>棧內存要遠小於堆內存</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>隊列和棧是什麼?有什麼區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>隊列和棧是兩種不同的數據結構</strong></li></ul><ol start=1><li><strong>操作名稱不同</strong></li></ol><ul><li><strong>隊列的插入稱為入隊，隊列的刪除稱為出隊。棧的插入稱為進棧，棧的刪除稱為出棧</strong></li></ul><ol start=1><li><strong>可操作的方式不同</strong></li></ol><ul><li><strong>隊列是在隊尾入隊，隊頭出隊，即兩邊都可操作。而棧的進棧和出棧都是在棧頂進行的，無法對棧底直接進行操作。</strong></li></ul><ol start=1><li><br></li></ol><hr><p><br></p><ul><li><strong>隊列先進先出 FIFO，棧是後進先出 LIFO</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>類加載器有哪些？什麼是雙親委派模型</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>啟動類加載器 Bootstrap ClassLoader：加載&lt;JAVA_HOME>\lib目錄下核心庫</strong></li><li><strong>擴展類加載器 Extension ClassLoader：加載&lt;JAVA_HOME>\lib\ext目錄下擴展包</strong></li><li><strong>應用程序類加載器 Application ClassLoader： 加載用戶路徑(classpath)上指定的類庫</strong></li></ol><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e2951d359b34ceba55b4512ca36ac5e><p class=pgc-img-caption></p></div><p><br></p><blockquote class=pgc-blockquote-abstract><p><strong>雙親委派的意思是如果一個類加載器需要加載類，那麼首先它會把這個類請求委派給父類加載器去完成，每一層都是如此。一直遞歸到頂層，當父加載器無法完成這個請求時，子類才會嘗試去加載。這裡的雙親其實就指的是父類，沒有mother。父類也不是我們平日所說的那種繼承關係，只是調用邏輯是這樣</strong></p></blockquote><h1 class=pgc-h-arrow-right><strong>類加載的執行過程</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>加載</strong></li></ul><ol start=1><li><strong>加載指的是把class字節碼文件從各個來源通過類加載器裝載入內存中</strong></li><li><strong>字節碼來源：一般的加載來源包括從本地路徑下編譯生成的.class文件，從jar包中的.class文件，從遠程網絡，以及動態代理實時編譯類加載器。一般包括啟動類加載器，擴展類加載器，應用類加載器，以及用戶的自定義類加載器</strong></li></ol><ul><li><strong>鏈接</strong></li></ul><ol start=1><li><strong>驗證</strong></li></ol><p><strong>主要是為了保證加載進來的字節流符合虛擬機規範，不會造成安全錯誤，包括對於文件格式的驗證</strong></p><ol start=1><li><strong>準備</strong></li></ol><p><strong>主要是為類變量（注意，不是實例變量）分配內存，並且賦予初值。特別需要注意，初值，不是代碼中具體寫的初始化的值，而是Java虛擬機根據不同變量類型的默認初始值：8種基本類型的初值，默認為0；引用類型的初值則為null；</strong></p><ol start=1><li><strong>解析</strong></li></ol><p><strong>將常量池內的符號引用替換為直接引用的過程。在解析階段，虛擬機會把所有的類名，方法名，字段名這些符號引用替換為具體的內存地址或偏移量，也就是直接引用</strong></p><ul><li><strong>初始化</strong></li></ul><p><strong>這個階段主要是對類變量初始化，是執行類構造器的過程</strong></p><h1 class=pgc-h-arrow-right><strong>怎麼判斷對象是否可以收回</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>引用計數算法</strong></li></ol><ul><li><strong>判斷對象的引用數量</strong></li></ul><ol start=1><li><strong>通過判斷對象的引用數量來決定對象是否可以被回收</strong></li><li><strong>每個對象實例都有一個引用計數器，被引用則+1，完成引用則-1</strong></li><li><strong>任何引用計數為0的對象實例可以被當作垃圾收集</strong></li></ol><ul><li><strong>優缺點</strong></li></ul><ol start=1><li><strong>優點：執行效率高，程序執行受影響較小</strong></li><li><strong>缺點：無法檢測出循環引用的情況，導致內存洩漏</strong></li></ol><ol start=1><li><strong>可達性分析算法</strong></li></ol><ul><li><strong>通過判斷對象的引用鏈是否可達來決定對象是否可以被回收</strong></li><li><strong>可以作為GC Root對象的對象有</strong></li></ul><ol start=1><li><strong>虛擬機棧中引用的對象（棧幀中的本地變量表）</strong></li><li><strong>方法區中的常量引用對象</strong></li><li><strong>方法區中類靜態屬性引用對象</strong></li><li><strong>本地方法棧中JNI（Native方法）的引用對象</strong></li><li><strong>活躍線程中的引用對象</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>Java 中有哪些引用類型</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>強引用（strongreference）</strong></li></ol><p><strong>就是指在程序代碼之中普遍存在的,類似“Object obj=new Object()” 這類的引用,只要強引用還存在,垃圾收集器永遠不會回收掉被引用的對象實例</strong></p><ol start=1><li><strong>軟引用（softreference）</strong></li></ol><p><strong>是用來描述一些還有用但並非必需的對象。對於軟引用關聯著的對象, 在系統將要發生內存溢出異常之前,將會把這些對象實例列進回收範圍之中進行 第二次回收。如果這次回收還沒有足夠的內存,才會拋出內存溢出異常。在 JDK 1.2 之後,提供了SoftReference</strong> <strong>類來實現軟引用</strong></p><ol start=1><li><strong>弱引用（weakreference）</strong></li></ol><p><strong>也是用來描述非必需對象的,但是它的強度比軟引用更弱一些,被弱 引用關聯的對象實例只能生存到下一次垃圾收集發生之前。當垃圾收集器工作時, 無論當前內存是否足夠,都會回收掉只被弱引用關聯的對象實例。在 JDK 1.2 之 後,提供了WeakReference</strong> <strong>類來實現弱引用</strong></p><ol start=1><li><strong>虛引用（phantomreference）</strong></li></ol><p><strong>也稱為幽靈引用或者幻影引用,它是最弱的一種引用關係。一個對象實例是否有虛引用的存在,完全不會對其生存時間構成影響,也無法通過虛引用 來取得一個對象實例。為一個對象設置虛引用關聯的唯一目的就是能在這個對象 實例被收集器回收時收到一個系統通知。在 JDK 1.2 之後,提供了 PhantomReference 類來實現虛引用</strong></p><h1 class=pgc-h-arrow-right><strong>JVM </strong><strong>中</strong><strong>垃圾回收算法</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>標記-清除算法</strong></li></ol><p><strong>標記-清除算法採用從根集合（GC Roots）進行掃描，對存活的對象進行標記，標記完畢後，再掃描整個空間中未被標記的對象，進行回收，如下圖所示。標記-清除算法不需要進行對象的移動，只需對不存活的對象進行處理，在存活對象比較多的情況下極為高效，但由於標記-清除算法直接回收不存活的對象，因此會造成內存碎片</strong></p><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f6e7ebc4375649ce97feaef3ce28f83e><p class=pgc-img-caption></p></div><p><br></p><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>複製除算法</strong></li></ol><p><strong>複製算法的提出是為了克服句柄的開銷和解決內存碎片的問題。它開始時把堆分成 一個對象 面和多個空閒面， 程序從對象面為對象分配空間，當對象滿了，基於copying算法的垃圾 收集就從根集合（GC Roots）中掃描活動對象，並將每個 活動對象複製到空閒面(使得活動對象所佔的內存之間沒有空閒洞)，這樣空閒面變成了對象面，原來的對象面變成了空閒面，程序會在新的對象面中分配內存</strong></p><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9334349f4f5d49888894593b511c7167><p class=pgc-img-caption></p></div><p><br></p><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>標記-整理（壓縮）算法</strong></li></ol><p><strong>標記-整理算法採用標記-清除算法一樣的方式進行對象的標記，但在清除時不同，在回收不存活的對象佔用的空間後，會將所有的存活對象往左端空閒空間移動，並更新對應的指針。標記-整理算法是在標記-清除算法的基礎上，又進行了對象的移動，因此成本更高，但是卻解決了內存碎片的問題</strong></p><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/31a78ec52c514fa68ad28757e4ebdfc3><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>JVM 有哪些垃圾回收器</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>新生代收集器：Serial、ParNew、Parallel Scavenge</strong></li><li><strong>老年代收集器：CMS、Serial Old、Parallel Old</strong></li><li><strong>整堆收集器： G1</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>介紹一下 CMS 垃圾回收器</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>CMS收集器 ：一種以獲取最短回收停頓時間為目標的收集器</strong></li><li><strong>特點：基於標記-清除算法實現。併發收集、低停頓</strong></li><li><strong>應用場景：適用於注重服務的響應速度，希望系統停頓時間最短，給用戶帶來更好的體驗等場景下。如web程序、b/s服務</strong></li><li><strong>CMS收集器的運行過程分為下列4步：</strong></li></ul><ol start=1><li><strong>初始標記：標記GC Roots能直接到的對象，速度很快但是仍存在Stop The World問題</strong></li><li><strong>併發標記：進行GC Roots Tracing 的過程，找出存活對象且用戶線程可併發執行</strong></li><li><strong>重新標記：為了修正併發標記期間因用戶程序繼續運行而導致標記產生變動的那一部分對象的標記記錄。仍然存在Stop The World問題</strong></li><li><strong>併發清除：對標記的對象進行清除回收</strong></li></ol><ul><li><strong>CMS收集器的內存回收過程是與用戶線程一起併發執行的</strong></li><li><strong>CMS收集器的缺點：</strong></li><li><strong>對CPU資源非常敏感</strong></li><li><strong>無法處理浮動垃圾，可能出現Concurrent Model Failure失敗而導致另一次Full GC的產生</strong></li><li><strong>因為採用標記-清除算法所以會存在空間碎片的問題，導致大對象無法分配空間，不得不提前觸發一次Full GC</strong></li></ul><p><br></p><p><strong>CMS收集器的工作過程圖：</strong></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/50a203a2e22b4c68a461c10d90f0698e><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>新生代垃圾回收器和老生代垃圾回收器有哪些？有什麼區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>新生代收集器：Serial、ParNew、Parallel Scavenge</strong></li><li><strong>老年代收集器：CMS、Serial Old、Parallel Old</strong></li><li><strong>區別：</strong></li></ul><p><strong>新生代垃圾回收器一般採用的是複製算法，複製算法的優點是效率高，缺點是內存利用率低；老年代回收器一般採用的是標記-整理的算法進行垃圾回收</strong></p><h1 class=pgc-h-arrow-right><strong>簡述分代垃圾回收器是怎麼工作的</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>分代回收器有兩個分區：老生代和新生代，新生代默認的空間佔比總空間的 1/3，老生代的默認佔比是 2/3。 新生代使用的是複製算法，新生代裡有 3 個分區：Eden、To Survivor、From Survivor，它們的默認佔比是</strong> <strong>8:1:1</strong></li><li><strong>執行流程</strong></li></ul><ol start=1><li><strong>把 Eden + From Survivor 存活的對象放入 To Survivor 區</strong></li><li><strong>清空 Eden 和 From Survivor 分區； From Survivor 和 To Survivor 分區交換，From Survivor 變 To Survivor，To Survivor 變 From Survivor</strong></li><li><strong>每次在 From Survivor 到 To Survivor 移動時都存活的對象，年齡就 +1，當年齡到達 15（默認配置是 15）時，升級為老生代。大對象也會直接進入老生代</strong></li><li><strong>老生代當空間佔用到達某個值之後就會觸發全局垃圾收回，一般使用標記整理的執行算法</strong></li><li><strong>以上這些循環往復就構成了整個分代垃圾回收的整體執行流程</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>JVM 調優的工具有哪些</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>jconsole</strong> <strong>jdk自帶的工具：是一個基於JMX（java management extensions）的GUI性能監測工具（jdk/bin目錄下點擊jconsole.exe即可啟動）</strong></li><li><strong>VisualVM：它提供了一個可視界面，用於查看 Java 虛擬機 (Java Virtual Machine, JVM) 上運行的基於 Java 技術的應用程序（Java 應用程序）的詳細信息（jdk/bin目錄下面雙擊jvisualvm.exe既可使用）</strong></li><li><strong>MAT</strong> <strong>第三方調優工具：一個基於Eclipse的內存分析工具，是一個快速、功能豐富的Java heap分析工具，它可以幫助我們查找內存洩漏和減少內存消耗（MAT以eclipse 插件的形式來安裝）</strong></li><li><strong>GChisto：專業分析gc日誌的工具，可以通過gc日誌來分析：Minor GC、full gc的時間、頻率等等，通過列表、報表、圖表等不同的形式來反應gc的情況（配置好本地的jdk環境之後，雙擊GChisto.jar,在彈出的輸入框中點擊 add 選擇gc.log日誌）</strong></li><li><strong>gcviewer：分析小工具，用於可視化查看由Sun / Oracle, IBM, HP 和 BEA Java 虛擬機產生的垃圾收集器的日誌</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>JVM 調優的參數有哪些</strong></h1><h1 class=pgc-h-arrow-right><em><strong>2</strong></em><strong>|</strong><em><strong>10</strong></em><strong>算法題</strong></h1><h1 class=pgc-h-arrow-right><em><strong>2</strong></em><strong>|</strong><em><strong>11</strong></em><strong>其他部分面試題</strong></h1><h1 class=pgc-h-arrow-right><strong>Api 接口如何實現 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>在類裡使用</strong> <strong>implements</strong> <strong>關鍵字實現 Api 接口</strong></p></blockquote><h1 class=pgc-h-arrow-right><strong>MySQL 鏈接數據庫常用的幾種方式 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>Mybatis 框架</strong></li><li><strong>Hibernate 框架</strong></li><li><strong>JDBC 技術</strong></li><li><strong>c3p0 連接池</strong></li><li><strong>dbcp 連接池</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>SpringBoot 如何集成 Redis ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>在 pom.xml 文件引入 redis 依賴</strong></p></blockquote><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><blockquote class=pgc-blockquote-abstract><p><strong>在 application 配置文件中 書寫 redis 配置</strong></p></blockquote><pre><code>    spring.redis.host=127.0.0.1    #Redis服務器連接端口    spring.redis.port=6379    #Redis服務器連接密碼（默認為空）    #spring.redis.password=</code></pre><h1 class=pgc-h-arrow-right><strong>SpringCloud 的優點 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>服務之間採用Restful等輕量級通訊</strong></li><li><strong>精準的制定優化服務方案，提高系統的可維護性</strong></li><li><strong>服務之間拆分細緻，資源可重複利用，提高開發效率</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>SpringCloud 用了哪些組件 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>netflix Eureka 註冊中心</strong></li><li><strong>netflix Ribbon 負載均衡</strong></li><li><strong>netflix Zuul 網關</strong></li><li><strong>netflix Hystrix 熔斷器</strong></li><li><strong>feign 服務調用</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>List 和 Set 的區別</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>List 允許有多個重複對象，而 Set 不允許有重複對象</strong></li><li><strong>List 允許有多個NULL值，而 Set 只允許有一個NULL值</strong></li><li><strong>List 是一個有序的容器，輸出順序即是輸入順序</strong></li><li><strong>Set 是一個無序的容器無法保證每個元素的順序，但是可以用</strong> <strong>TreeSet</strong> <strong>通過</strong> <strong>Comparator</strong> <strong>或者</strong> <strong>Comparable</strong> <strong>維護排序順序</strong></li><li><strong>List的實現類有 ArrayList、LinkList、Vector 其中 ArrayList 最常用於查詢較多，隨意訪問.LinkList 同於新增和刪除較多的情況，Vector 表示底層數組，線程安全象</strong></li><li><strong>Set的實現類有 HashSet、TreeSet、LinkedHashSet 其中基於 HashMap 實現的 HashSet 最為流行，TreeSet 是一個有序的Set容器象</strong></li></ol><p><strong>擴展</strong> <strong>Map的實現類有HashMap、HashTable、TreeMap</strong></p><h1 class=pgc-h-arrow-right><strong>Java 中 static 的作用</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>表示全局或靜態的意思、用來修飾成員變量和成員方法，也可以形成靜態代碼塊</strong></li><li><strong>達到了不用實例化就可以使用被 public static 修飾的變量或方法</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>什麼單例模式 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>保證整個項目中一個類只有一個對象的實例，實現這種功能就叫做單例模式</strong></p></blockquote><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>單例模式的好處:</strong></li><li>單例模式節省公共資源</li><li>單例模式方便控制</li></ol><ol start=1><li><strong>如何保證是單利模式 ?</strong></li><li>構造私有化</li><li>以靜態方法返回實例</li><li>確保對象實例只有一個</li></ol><ol start=1><li><strong>單例模式有哪幾個 ?</strong></li><li><strong>餓漢模式</strong></li></ol><p>把對象創建好，需要使用的時候直接拿到就行</p><ol start=1><li><strong>懶漢模式</strong></li></ol><p>等你需要的時候在創建對象，後邊就不會再次創建</p><h1 class=pgc-h-arrow-right><strong>SpringBoot 常用的幾個註解 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>@SpringBootApplication SpringBoot的核心註解 啟動類</strong></li><li><strong>@EnableAutoConfiguration 開啟SpringBoot自動配置</strong></li><li><strong>@RestController 在控制層 是@ResponseBody註解與@Controller註解的合集</strong></li><li><strong>@RequestMapper 處理請求地址映射的註解</strong></li><li><strong>@RequestParam 獲取url上傳過來的參數</strong></li><li><strong>@Configuration 聲明配置類</strong></li><li><strong>@Component 通用註解</strong></li><li><strong>@Service 業務邏輯層</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>Java 八大數據類型</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>char 字符型 byte 字節型 boolean 布爾型</strong></p></blockquote><blockquote class=pgc-blockquote-abstract><p><strong>float 單浮點型 double 雙浮點型</strong></p></blockquote><blockquote class=pgc-blockquote-abstract><p><strong>int 整數型 short 短整數型 long 長整數型</strong></p></blockquote><h1 class=pgc-h-arrow-right><strong>MySQL分頁和升序降序如何實現 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>可以用 limit</strong></li></ol><p>select name，age，sex from t_student limit(0，5);</p><ol start=1><li><strong>升序 order by xx asc</strong></li></ol><p>select name，age，sex from t_student order by age asc;</p><ol start=1><li><strong>降序 order by xx desc</strong></li></ol><p>select name，age，sex from t_student order by age desc;</p><h1 class=pgc-h-arrow-right><strong>maven 是幹什麼的，它有什麼好處 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>maven 專門構建和管理Java項目的工具</strong></li><li><strong>maven的好處在於可以將項目過程規範化、自動化、高效化以及強大的可擴展性</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>MySQL 如何添加索引 ?</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ol start=1><li><strong>PRIMARY KEY (主鍵索引)</strong></li><li><strong>添加INDEX(普通索引) ALTER TABLE</strong> <strong>table_name</strong> <strong>ADD INDEX index_name (</strong> <strong>column</strong> <strong>)</strong></li><li><strong>添加UNIQUE(唯一索引) ALTER TABLE</strong> <strong>table_name</strong> <strong>ADD UNIQUE index_name (</strong> <strong>column</strong> <strong>)</strong></li><li><strong>添加FULLTEXT(全文索引) ALTER TABLE</strong> <strong>table_name</strong> <strong>ADD FULLTEXT (</strong> <strong>column)</strong></li><li><strong>添加多列索引 ALTER TABLE</strong> <strong>table_name</strong> <strong>ADD INDEX index_name (</strong> <strong>column1，</strong> <strong>column2，</strong> <strong>column3</strong> <strong>)</strong></li></ol><p><br></p><h1 class=pgc-h-arrow-right><strong>MySQL 索引的實現方式?</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>MySQL 索引底層的實現方式是 B+Tree也就是B+樹 具體查看</strong> <strong>B+Tree實現方式</strong></p></blockquote><h1 class=pgc-h-arrow-right><strong>Vue的數據雙向綁定原理</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>使用v-mode屬性， 它的原理是利用了Object.defineProperty()方法重新定義了對象獲取屬性值(get)和設置屬性值(set)的操作來實現的</strong></p></blockquote><h1 class=pgc-h-arrow-right><strong>ActiveMQ的消息存儲方式</strong></h1><blockquote class=pgc-blockquote-abstract><p><br></p></blockquote><ul><li><strong>採取先進先出模式，同一時間，消息只會發送給某一個消費者，只有當該消息被消費並告知已收到時，它才能在代理的存儲中被刪除.</strong></li><li><strong>對於持久性訂閱來說，每一個消費者都會獲取消息的拷貝.為了節約空間，代理的存儲介質中只存儲了一份消息，存儲介質的持久訂閱對象為其以後的被存儲的消息維護了一個指針，消費者消費時，從存儲介質中複製一個消息.消息被所有訂閱者獲取後才能刪除.</strong></li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>KahaDB消息存儲</strong></h1><blockquote class=pgc-blockquote-abstract><p><strong>基於文件的消息存儲機制，為了提高消息存儲的可靠性和可恢復性，它整合了一個事務日誌.KahaDB擁有高性能和可擴展性等特點.由於KahaDB使用的是基於文件的存儲，所以不需要使用第三方數據庫</strong></p></blockquote><p><br></p><h1 class=pgc-h-arrow-right>學習沒資料，面試找不到方向怎麼辦？</h1><p><strong>下面是針對一到五年開發的Java程序員整理的Java實戰視頻+電子版本書籍+面試試題資料文檔分享給大家學習！</strong></p><p><strong>面試試題資料及答案：</strong></p><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ad1644865f364c5da942f9636f1eabdd><p class=pgc-img-caption></p></div><p>面試試題資料</p><p><strong>電子版本書籍：</strong></p><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f8259a73d6224ce99cfcd4a3eba443c4><p class=pgc-img-caption></p></div><p>電子版本書籍</p><p><br></p><div class=pgc-img><img alt="Java常見面試題 非常實用「個人經驗」" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6467dfb679b44df68d526d7c664b35e6><p class=pgc-img-caption></p></div><p><br></p><p>電子書</p><h1 class=pgc-h-arrow-right>領取步驟：</h1><h1 class=pgc-h-arrow-right>1、轉發+點贊文章</h1><h1 class=pgc-h-arrow-right>2、關注我，私信“電子書”，即可免費領取</h1></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>常見面</a></li><li><a>試題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a6f61ca.html alt=常見面試題總結，數據庫、監控、網絡管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a6f61ca.html title=常見面試題總結，數據庫、監控、網絡管理>常見面試題總結，數據庫、監控、網絡管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1bab896f.html alt="Java 後臺開發面試題分享八" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1bab896f.html title="Java 後臺開發面試題分享八">Java 後臺開發面試題分享八</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d85f0bb3.html alt=史上最全，PHP常見面試題整理彙總，7大模塊共93題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/265dcebdb3f84b93a7409fcc0adec9e0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d85f0bb3.html title=史上最全，PHP常見面試題整理彙總，7大模塊共93題>史上最全，PHP常見面試題整理彙總，7大模塊共93題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7c1cfa7d.html alt=Java高頻面試題160道答案-第7篇（數據庫操作JDBC篇） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/52d9bed7-ad96-4a71-844d-ad36d0965f86 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7c1cfa7d.html title=Java高頻面試題160道答案-第7篇（數據庫操作JDBC篇）>Java高頻面試題160道答案-第7篇（數據庫操作JDBC篇）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1fe2d36.html alt=電工技能大賽試題庫共780題含判斷題和選擇題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/de2dbb89ff604f3ca8ef8cb85f370e0a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1fe2d36.html title=電工技能大賽試題庫共780題含判斷題和選擇題>電工技能大賽試題庫共780題含判斷題和選擇題</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>