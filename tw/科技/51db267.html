<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java面向對象之：接口、多態 | 极客快訊</title><meta property="og:title" content="Java面向對象之：接口、多態 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/d3f6934313714e52ae0687177d6ea9ad"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51db267.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="Java面向對象之：接口、多態"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/51db267.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java面向對象之：接口、多態</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>本篇我們將學習面向對象中的接口和多態：</p><h1 class=pgc-h-arrow-right><strong>第一章：接口</strong></h1><h1 class=pgc-h-arrow-right><strong>1.1-接口概述（瞭解）</strong></h1><p style=text-align:start><strong>什麼是接口</strong></p><h1 class=pgc-h-arrow-right><strong>Java中的接口是 一系列方法的聲明 ，是一些 方法特徵的集合 。</strong></h1><p style=text-align:start>一個接口 <strong>只有方法的特徵（只有聲明）</strong> 沒有 <strong>方法的實現（沒有方法體）</strong> ，因此這些方法可以在不同的地方被不同的類實現，而這些實現可以具有不同的行為（功能）</p><p style=text-align:start>如果說類的內部封裝了成員變量、構造方法和成員方法，那麼接口的內部主要就是 <strong>封裝了方法</strong>，包含抽象方法（JDK 7及以前），默認方法和靜態方法（JDK 8）。</p><p style=text-align:start>總而言之，Java中的接口就是一系列方法聲明的集合。</p><p style=text-align:start><strong>為什麼需要接口</strong></p><p style=text-align:start>接口的優勢：</p><ul><li>是多態的基礎</li><li>可以多實現（可以理解為多繼承）</li></ul><p style=text-align:start><strong>接口是一種引用數據類型</strong></p><p style=text-align:start>接口的定義，它與定義類方式相似，但是使用 interface 關鍵字。它也會被編譯成.class文件，但一定要明確它並不是類，而是另外一種引用數據類型。</p><p style=text-align:start>類和接口都是java代碼，都會轉換為字節碼文件</p><pre><code>public class 類名.java → 類名.classpublic interface 接口名.java → 接口名.class</code></pre><h1 class=pgc-h-arrow-right><strong>1.2-接口的定義格式（記憶）</strong></h1><p style=text-align:start><strong>定義格式：關鍵字 interface</strong></p><pre><code>public interface 接口名稱 {    // 抽象方法    // 默認方法    // 靜態方法}</code></pre><p style=text-align:start><strong>接口中定義抽象方法</strong></p><p style=text-align:start>抽象方法：使用 <strong>abstract </strong>關鍵字修飾，可以省略，沒有方法體。該方法供子類實現使用。</p><pre><code>public interface InterFaceName {    public abstract void method();}</code></pre><p style=text-align:start><strong>接口中定義默認方法和靜態方法</strong></p><p style=text-align:start>默認方法：使用 <strong>default </strong>修飾，不可省略，供子類調用或者子類重寫。</p><p style=text-align:start>靜態方法：使用 <strong>static </strong>修飾，供接口直接調用。</p><pre><code>public interface InterFaceName {    public default void method() {        // 執行語句    }    public static void method2() {        // 執行語句        }}</code></pre><h1 class=pgc-h-arrow-right><strong>1.3-接口的使用方式（記憶）</strong></h1><p style=text-align:start>我們之前學習繼承時，父類需要子類繼承。而接口和繼承中父類相似，也需要一個類似子類的實現類來實現接口。</p><p style=text-align:start><strong>接口的實現</strong></p><p style=text-align:start>類與 <strong>接口</strong> 的關係為實現關係，即 <strong>類實現接口</strong> ，該類可以稱為接口的 <strong>實現類</strong> ，也可以稱為 <strong>接口的子類</strong> 。</p><p style=text-align:start>實現的動作類似繼承，格式相仿，只是關鍵字不同，實現使用 <strong>implements </strong>關鍵字。</p><p style=text-align:start><strong>非抽象類實現接口注意事項</strong></p><ol start=1><li>必須重寫接口中所有抽象方法。</li><li>繼承了接口的默認方法，即可以直接調用，也可以重寫。</li></ol><p style=text-align:start><strong>子類實現接口格式</strong></p><pre><code>public class 類名 implements 接口名 {    // 重寫接口中抽象方法【必須】      // 重寫接口中默認方法【可選】}</code></pre><p style=text-align:start><strong>子類實現接口中的 抽象方法</strong></p><p style=text-align:start>對於接口中定義的抽象方法，子類必須全部實現（重寫）。代碼如下：</p><p style=text-align:start>定義一個接口：LiveAble</p><pre><code>public interface LiveAble {    // 定義抽象方法    public abstract void eat();    public abstract void sleep();}</code></pre><p style=text-align:start>定義一個實現類：Animal</p><pre><code>public class Animal implements LiveAble {    @Override    public void eat() {        System.out.println("吃東西");    }    @Override    public void sleep() {        System.out.println("晚上睡");    }}</code></pre><p style=text-align:start>定義一個測試類：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 創建子類對象          Animal a = new Animal();        // 調用實現後的方法        a.eat();        a.sleep();    }}/*    輸出結果：        吃東西        晚上睡*/</code></pre><p style=text-align:start><strong>子類使用或重寫接口中的 默認方法</strong></p><p style=text-align:start>對於接口中的默認方法，子類可以繼承，也可以重寫，二選一，但是隻能通過實現類的對象來調用。</p><h1 class=pgc-h-arrow-right><strong>直接使用默認方法，代碼如下：</strong></h1><p style=text-align:start>定義接口：LiveAble</p><pre><code>public interface LiveAble {    public default void fly(){        System.out.println("天上飛");    }}</code></pre><p style=text-align:start>定義實現類：Animal</p><pre><code>public class Animal implements LiveAble {    // 繼承，什麼都不用寫，直接調用}</code></pre><p style=text-align:start>定義測試類：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 創建子類對象          Animal a = new Animal();        // 調用默認方法        a.fly();    }}/*    輸出結果：        天上飛*/</code></pre><h1 class=pgc-h-arrow-right><strong>或者重寫默認方法，代碼如下：</strong></h1><p style=text-align:start>定義接口：LiveAble 同上</p><p style=text-align:start>定義實現類：Animal</p><pre><code>public class Animal implements LiveAble {    @Override    public void fly() {        System.out.println("自由自在的飛");    }}</code></pre><p style=text-align:start>定義測試類：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 創建子類對象          Animal a = new Animal();        // 調用重寫方法        a.fly();    }}/*    輸出結果：        自由自在的飛*/</code></pre><p style=text-align:start><strong>接口中 靜態方法 的使用</strong></p><p style=text-align:start>靜態與.class 文件相關， <strong>只能使用接口名調用</strong> ，不可以通過實現類的類名或者實現類的對象調用，代碼如下：</p><p style=text-align:start>定義接口：LiveAble</p><pre><code>public interface LiveAble {    public static void run(){        System.out.println("跑起來~~~");    }}</code></pre><p style=text-align:start>定義實現類：Animal</p><pre><code>public class Animal implements LiveAble {    // 無法重寫靜態方法}</code></pre><p style=text-align:start>定義測試類：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // Animal.run(); // 【錯誤】無法繼承方法,也無法調用        LiveAble.run(); //     }}/*    輸出結果：        跑起來~~~*/</code></pre><p style=text-align:start><strong>接口中 不能定義成員變量 ,可以定義常量</strong></p><p style=text-align:start>接口中，無法定義成員變量，但是可以定義常量，其值不可以改變，默認使用public static final修飾。</p><p style=text-align:start>定義接口：LiveAble</p><pre><code>public interface LiveAble {   int NUM0 ; // 錯誤,必須賦值     int NUM1 =10; // 正確 , 省去了默認修飾符 public static final   public static final int NUM2= 100; // 正確 , 完整寫法}</code></pre><p style=text-align:start>定義測試類：</p><pre><code>public class Test {   public static void main(String[] args) {        System.out.println(Live.NUM1);        System.out.println(Live.NUM2);    }}/*    輸出結果：    10    100*/</code></pre><h1 class=pgc-h-arrow-right><strong>1.4-接口的多實現（記憶）</strong></h1><p style=text-align:start>在繼承體系中，一個類只能繼承一個父類（單繼承）。</p><p style=text-align:start>而對於接口而言，一個類是可以實現多個接口的，這叫做接口的 <strong>多實現</strong> 。</p><p style=text-align:start>並且，一個類能 <strong>繼承一個父類</strong> ，同時 <strong>實現多個接口</strong> 。</p><p style=text-align:start><strong>實現格式</strong></p><pre><code>public class 類名 [extends 父類名] implements 接口名1,接口名2,接口名3... {    // 重寫接口中抽象方法【必須】      // 重寫接口中默認方法【不重名時可選】}</code></pre><p style=text-align:start>[ ]中的格式： 表示可選操作。</p><p style=text-align:start><strong>接口多實現的抽象方法</strong></p><p style=text-align:start>接口中，有多個抽象方法時，實現類必須重寫所有抽象方法 <strong>。如果抽象方法有重名的，只需要重寫一次。</strong> 代碼如下：</p><p style=text-align:start>定義多個接口：</p><pre><code>interface A {    public abstract void showA();    public abstract void show();}interface B {    public abstract void showB();    public abstract void show();}</code></pre><p style=text-align:start>定義實現類：</p><pre><code>public class C implements A,B{    @Override    public void showA() {        System.out.println("showA");    }    @Override    public void showB() {        System.out.println("showB");    }    @Override    public void show() {        System.out.println("show");    }}</code></pre><p style=text-align:start><strong>接口多實現的默認方法</strong></p><p style=text-align:start>接口中，有多個默認方法時，實現類都可繼承使用。 <strong>如果默認方法有重名的，必須重寫一次。</strong>代碼如下：</p><p style=text-align:start>定義多個接口：</p><pre><code>interface A {    public default void methodA(){}    public default void method(){}}interface B {    public default void methodB(){}    public default void method(){}}</code></pre><p style=text-align:start>定義實現類：</p><pre><code>public class C implements A,B{    @Override    public void method() {        System.out.println("method");    }}</code></pre><p style=text-align:start><strong>接口多實現中的靜態方法</strong></p><p style=text-align:start>接口中，存在 <strong>同名的靜態方法並不會衝突</strong> ，原因是隻能通過各自接口名訪問靜態方法。</p><pre><code>public interface MyInterface{    public static void inter(){        system.out.println("接口靜態方法");    }}public class Test{    public static void main(String[] args){        //接口名直接調用        MyInterface.inter();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>1.5 接口的多繼承 （記憶）</strong></h1><p style=text-align:start>一個接口能繼承 <strong>另一個或者多個</strong> 接口，這和類之間的繼承比較相似。</p><p style=text-align:start>接口的繼承使用 extends 關鍵字，子接口繼承父接口的方法。 如果父接口中的默認方法有重名的，那麼子接口需要重寫一次。 代碼如下：</p><p style=text-align:start>定義父接口：</p><pre><code>interface A {    public default void method(){        System.out.println("AAAAAAAAAAAAAAAAAAA");    }}interface B {    public default void method(){        System.out.println("BBBBBBBBBBBBBBBBBBB");    }}</code></pre><p style=text-align:start>定義子接口：</p><pre><code>interface D extends A,B{    @Override    public default void method() {        System.out.println("DDDDDDDDDDDDDD");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>1.6 抽象類和接口的區別（理解）</strong></h1><p style=text-align:start>通過實例進行分析和代碼演示抽象類和接口的用法。</p><p style=text-align:start>舉例：犬和緝毒犬</p><p style=text-align:start>犬：</p><ul><li>行為：吼叫；吃飯；</li></ul><p style=text-align:start>緝毒犬：</p><ul><li>行為：吼叫；吃飯；緝毒；</li></ul><p style=text-align:start>思考</p><p style=text-align:start>由於犬分為很多種類，他們吼叫和吃飯的方式不一樣，在描述的時候不能具體化，也就是吼叫和吃飯的行為不能明確。</p><p style=text-align:start>當描述行為時，行為的具體動作不能明確，這時，可以將這個行為寫為抽象行為，那麼這個類也就是抽象類。</p><p style=text-align:start>可是當緝毒犬有其他額外功能時，而這個功能並不在這個事物的體系中。這時可以讓緝毒犬具備犬科自身特點的同時也有其他額外功能，可以將這個額外功能定義接口中。</p><p style=text-align:start>代碼</p><pre><code>interface 緝毒{    public abstract void 緝毒();}//定義犬科的這個提醒的共性功能abstract class 犬科{    public abstract void 吃飯();    public abstract void 吼叫();}// 緝毒犬屬於犬科一種，讓其繼承犬科，獲取的犬科的特性，//由於緝毒犬具有緝毒功能，那麼它只要實現緝毒接口即可，這樣即保證緝毒犬具備犬科的特性，也擁有了緝毒的功能class 緝毒犬 extends 犬科 implements 緝毒{    public void 緝毒() {    }    void 吃飯() {    }    void 吼叫() {    }}class 緝毒豬 implements 緝毒{    public void 緝毒() {    }}</code></pre><p style=text-align:start><strong>通過示例總結抽象類和接口的區別</strong></p><h1 class=pgc-h-arrow-right><strong>相同點：</strong></h1><ul><li>都位於繼承的頂端，用於被其他類實現或繼承；</li><li>都不能直接實例化對象；</li><li>都包含抽象方法，其子類都必須覆寫這些抽象方法；</li></ul><h1 class=pgc-h-arrow-right><strong>區別：</strong></h1><ul><li>抽象類為部分方法提供實現，避免子類重複實現這些方法，提高代碼重用性；接口只能包含抽象方法；</li><li>一個類只能繼承一個直接父類(可能是抽象類)，卻可以實現多個接口(接口彌補了Java的單繼承)；</li><li>抽象類為繼承體系中的共性內容，接口為繼承體系中的擴展功能；</li></ul><h1 class=pgc-h-arrow-right><strong>語法具體區別：</strong></h1><ul><li>成員區別抽象類變量，常量；有構造方法；有抽象方法，也有非抽象方法接口常量；抽象方法</li><li>關係區別類與類繼承，單繼承類與接口實現，可以單實現，也可以多實現接口與接口繼承，單繼承，多繼承</li><li>設計理念區別抽象類對類抽象，包括屬性、行為接口對行為抽象，主要是行為</li></ul><h1 class=pgc-h-arrow-right><strong>第二章：多態</strong></h1><h1 class=pgc-h-arrow-right><strong>2.1-多態概述（瞭解）</strong></h1><p style=text-align:start><strong>什麼是多態？</strong></p><p style=text-align:start>首先，多態是繼封裝、繼承之後，面向對象的第三大特性。</p><p style=text-align:start>多態Polymorphism，按字面意思就是“多種狀態”。</p><p style=text-align:start>生活中，比如跑的動作，小貓、小狗和大象，跑起來是不一樣的。再比如飛的動作，昆蟲、鳥類和飛機，飛起來也是不一樣的。可見，同一行為，通過不同的事物，可以體現出來的不同的形態。多態，描述的就是這樣的狀態。</p><h1 class=pgc-h-arrow-right><strong>在面向對象編程中，多態是指 同一行為 ，具有 多個不同表現形式 。</strong></h1><div class=pgc-img><img alt=Java面向對象之：接口、多態 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d3f6934313714e52ae0687177d6ea9ad><p class=pgc-img-caption></p></div><p style=text-align:start><strong>多態的前提</strong></p><ol start=1><li>繼承或者實現【二選一】</li><li>方法的重寫【意義體現：不重寫，無意義】</li><li>父類引用指向子類對象【格式體現】</li></ol><h1 class=pgc-h-arrow-right><strong>2.2-多態的語法格式（記憶）</strong></h1><p style=text-align:start><strong>語法格式</strong> ：</p><pre><code>父類類型 變量名 = new 子類()；變量名.方法名();</code></pre><p style=text-align:start>父類類型：是指子類繼承的 <strong>父類類型</strong> ，或者實現的 <strong>父接口類型</strong> 。</p><p style=text-align:start><strong>示例代碼：</strong></p><p style=text-align:start>當使用多態方式調用方法時，首先檢查父類中是否有該方法，如果沒有，則編譯錯誤；如果有，執行的是子類重寫後方法。</p><p style=text-align:start>定義父類：</p><pre><code>public abstract class Animal {      public abstract void eat();  }</code></pre><p style=text-align:start>定義子類：</p><pre><code>class Cat extends Animal {      public void eat() {          System.out.println("吃魚");      }  }  class Dog extends Animal {      public void eat() {          System.out.println("吃骨頭");      }  }</code></pre><p style=text-align:start>定義測試類：</p><pre><code>public class Test {    public static void main(String[] args) {        // 多態形式，創建對象        Animal a1 = new Cat();          // 調用的是 Cat 的 eat        a1.eat();                  // 多態形式，創建對象        Animal a2 = new Dog();         // 調用的是 Dog 的 eat        a2.eat();                   }  }</code></pre><h1 class=pgc-h-arrow-right><strong>2.3-多態的好處（理解）</strong></h1><p style=text-align:start>實際開發的過程中，父類類型作為方法形式參數，傳遞子類對象給方法，進行方法的調用，更能 <strong>體現出多態的擴展性與靈活性</strong> 。</p><p style=text-align:start>示例代碼如下：</p><p style=text-align:start>定義父類：</p><pre><code>public abstract class Animal {      public abstract void eat();  }</code></pre><p style=text-align:start>定義子類：</p><pre><code>class Cat extends Animal {      public void eat() {          System.out.println("吃魚");      }  }  class Dog extends Animal {      public void eat() {          System.out.println("吃骨頭");      }  }</code></pre><p style=text-align:start>定義測試類：</p><pre><code>public class Test {    public static void main(String[] args) {        // 多態形式，創建對象        Cat c = new Cat();          Dog d = new Dog();         // 調用showCatEat         showCatEat(c);        // 調用showDogEat         showDogEat(d);         /*        以上兩個方法, 均可以被showAnimalEat(Animal a)方法所替代        而執行效果一致        */        showAnimalEat(c);        showAnimalEat(d);     }    public static void showCatEat (Cat c){        c.eat();     }    public static void showDogEat (Dog d){        d.eat();    }    public static void showAnimalEat (Animal a){        a.eat();    }}</code></pre><p style=text-align:start>由於多態特性的支持，showAnimalEat方法的Animal類型，是Cat和Dog的父類類型，父類類型接收子類對象，當然可以把Cat對象和Dog對象，傳遞給方法。</p><p style=text-align:start>當eat方法執行時，多態規定，執行的是子類重寫的方法，那麼效果自然與showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上兩方法。</p><p style=text-align:start>不僅僅是替代，在擴展性方面，無論之後再多的子類出現，我們都不需要編寫showXxxEat方法了，直接使用showAnimalEat都可以完成。</p><p style=text-align:start>所以，多態的好處，體現在，可以使程序編寫的更簡單，並有良好的擴展。</p><h1 class=pgc-h-arrow-right><strong>2.4-多態的轉型（理解）</strong></h1><p style=text-align:start>多態的轉型分為 <strong>向上轉型</strong> 與 <strong>向下轉型</strong> 兩種：</p><p style=text-align:start><strong>向上轉型</strong></p><p style=text-align:start>多態本身是子類類型向父類類型向上轉換的過程，這個過程是默認的。</p><p style=text-align:start>表現形式：當父類引用指向一個子類對象時，便是向上轉型。</p><pre><code>父類類型  變量名 = new 子類類型();如：Animal a = new Cat();</code></pre><p style=text-align:start><strong>向下轉型</strong></p><p style=text-align:start>父類類型向子類類型向下轉換的過程，這個過程是強制的。</p><p style=text-align:start>表現形式：一個已經向上轉型的子類對象，將父類引用轉為子類引用，可以使用強制類型轉換的格式，便是向下轉型。</p><pre><code>子類類型 變量名 = (子類類型) 父類變量名;如:    Animal a = new Cat();   // Cat 向上轉型為Animal a表示Cat轉型後的Animal類型    Cat c =(Cat) a;         // 已經向上轉型的Cat類型a，向下強制轉型為Cat</code></pre><p style=text-align:start><strong>為什麼還要向下轉型呢</strong> ？</p><p style=text-align:start>當使用多態方式調用方法時，首先檢查父類中是否有該方法，如果沒有，則編譯錯誤。也就是說， <strong>不能調用</strong> 子類擁有，而父類沒有的方法。編譯都錯誤，更別說運行了。這也是多態給我們帶來的一點"小麻煩"。所以，想要調用子類特有的方法，必須做向下轉型。示例代碼如下：</p><p style=text-align:start>定義類：</p><pre><code>abstract class Animal {      abstract void eat();  }  class Cat extends Animal {      public void eat() {          System.out.println("吃魚");      }      public void catchMouse() {          System.out.println("抓老鼠");      }  }  class Dog extends Animal {      public void eat() {          System.out.println("吃骨頭");      }      public void watchHouse() {          System.out.println("看家");      }  }</code></pre><p style=text-align:start>定義測試類：</p><pre><code>public class Test {    public static void main(String[] args) {        // 向上轉型          Animal a = new Cat();          a.eat();                 // 調用的是 Cat 的 eat        // 向下轉型          Cat c = (Cat)a;               c.catchMouse();         // 調用的是 Cat 的 catchMouse    }  }</code></pre><p style=text-align:start><strong>轉型異常</strong></p><p style=text-align:start>轉型的過程中，一不小心就會遇到這樣的問題，請看如下代碼：</p><pre><code>public class Test {    public static void main(String[] args) {        // 向上轉型          Animal a = new Cat();          a.eat();               // 調用的是 Cat 的 eat        // 向下轉型          Dog d = (Dog)a;               d.watchHouse();        // 調用的是 Dog 的 watchHouse 【運行報錯】    }  }</code></pre><p style=text-align:start>這段代碼可以通過編譯，但是運行時，卻報出了 ClassCastException ，類型轉換異常！這是因為，明明創建了Cat類型對象，運行時，當然不能轉換成Dog對象的。</p><p style=text-align:start>為了避免ClassCastException的發生，Java提供了 instanceof 關鍵字，給引用變量做類型的校驗，格式如下：</p><pre><code>變量名 instanceof 數據類型 // 如果變量屬於該數據類型，返回true。// 如果變量不屬於該數據類型，返回false。</code></pre><p style=text-align:start>所以，轉換前，我們最好先做一個判斷，代碼如下：</p><pre><code>public class Test {    public static void main(String[] args) {        // 向上轉型          Animal a = new Cat();          a.eat();               // 調用的是 Cat 的 eat        // 向下轉型          if (a instanceof Cat){            Cat c = (Cat)a;                   c.catchMouse();        // 調用的是 Cat 的 catchMouse        } else if (a instanceof Dog){            Dog d = (Dog)a;                   d.watchHouse();       // 調用的是 Dog 的 watchHouse        }    }  }</code></pre><h1 class=pgc-h-arrow-right><strong>第三章：綜合案例</strong></h1><p style=text-align:start>需求：</p><p style=text-align:start>定義筆記本類，具備開機，關機和使用USB設備的功能。</p><p style=text-align:start>具體是什麼USB設備，筆記本並不關心，只要符合USB規格的設備都可以。</p><p style=text-align:start>鼠標和鍵盤要想能在電腦上使用，那麼鼠標和鍵盤也必須遵守USB規範，不然鼠標和鍵盤的生產出來無法使用；</p><p style=text-align:start>進行描述筆記本類，實現筆記本使用USB鼠標、USB鍵盤</p><ul><li>USB接口，包含開啟功能、關閉功能</li><li>筆記本類，包含運行功能、關機功能、使用USB設備功能</li><li>鼠標類，要符合USB接口</li><li>鍵盤類，要符合USB接口</li></ul><p style=text-align:start>分析：</p><p style=text-align:start>階段一：使用筆記本，筆記本有運行功能，需要筆記本對象來運行這個功能</p><p style=text-align:start>階段二：想使用一個鼠標，又有一個功能使用鼠標，並多了一個鼠標對象。</p><p style=text-align:start>階段三：還想使用一個鍵盤 ，又要多一個功能和一個對象。</p><p style=text-align:start>問題：每多一個功能就需要在筆記本對象中定義一個方法，不爽，程序擴展性極差。</p><p style=text-align:start>解決：使用多態機制，降低鼠標、鍵盤等外圍設備和筆記本電腦的耦合性。</p><div class=pgc-img><img alt=Java面向對象之：接口、多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4883383d06f14c549c5552cb9019f474><p class=pgc-img-caption></p></div><p style=text-align:start>代碼：</p><pre><code>//定義鼠標、鍵盤，筆記本三者之間應該遵守的規則 public interface USB {    void open();// 開啟功能    void close();// 關閉功能}//鼠標實現USB規則public class Mouse implements USB {    public void open() {        System.out.println("鼠標開啟");    }    public void close() {        System.out.println("鼠標關閉");    }}//鍵盤實現USB規則public class KeyBoard implements USB {    public void open() {        System.out.println("鍵盤開啟");    }    public void close() {        System.out.println("鍵盤關閉");    }}//定義筆記本public class NoteBook {    // 筆記本開啟運行功能    public void run() {        System.out.println("筆記本運行");    }    // 筆記本使用usb設備，這時當筆記本對象調用這個功能時，必須給其傳遞一個符合USB規則的USB設備    public void useUSB(USB usb) {        // 判斷是否有USB設備        if (usb != null) {            usb.open();            usb.close();        }    }    public void shutDown() {        System.out.println("筆記本關閉");    }}//測試public class Test {    public static void main(String[] args) {        // 創建筆記本實體對象        NoteBook nb = new NoteBook();        // 筆記本開啟        nb.run();        // 創建鼠標實體對象        Mouse m = new Mouse();        // 筆記本使用鼠標        nb.useUSB(m);        // 創建鍵盤實體對象        KeyBoard kb = new KeyBoard();        // 筆記本使用鍵盤        nb.useUSB(kb);        // 筆記本關閉        nb.shutDown();    }}</code></pre><p><br></p><div class=pgc-img><img alt=Java面向對象之：接口、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/063bdf869aa44936a5e72836a522cd46><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>對象</a></li><li><a>多態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9427df4.html alt=Java面向對象——多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aeb5a80f2ae143899e63547c947fe881 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9427df4.html title=Java面向對象——多態>Java面向對象——多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f2e3fb3f.html alt=Java面向對象之接口——interface class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/671e9bb3-9c58-4a73-8660-359947cb74f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f2e3fb3f.html title=Java面向對象之接口——interface>Java面向對象之接口——interface</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html alt=Java程序設計-面向對象思路（筆記） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9fcc6e3cac554acc8790d6b14e6aceaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html title=Java程序設計-面向對象思路（筆記）>Java程序設計-面向對象思路（筆記）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af4bb85.html alt=Java基礎系列：理解Java多態的實現機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cd7b252f82e04b6da1d594eab4d030b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af4bb85.html title=Java基礎系列：理解Java多態的實現機制>Java基礎系列：理解Java多態的實現機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html alt=Java基礎（多態的理解與應用) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html title=Java基礎（多態的理解與應用)>Java基礎（多態的理解與應用)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html alt=Java筆記之——多態詳解（重要） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/002a620d6944415d8d650a5636c4ff41 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html title=Java筆記之——多態詳解（重要）>Java筆記之——多態詳解（重要）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4fe5ba4.html alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ac43ddbdfc44399b9cef800d4dbdd08 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4fe5ba4.html title=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？>你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d55e8ff.html alt=小白學習——Java多態和動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/43aa8625bbe34057b3f71ee66a2c0ece style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d55e8ff.html title=小白學習——Java多態和動態綁定>小白學習——Java多態和動態綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html alt=詳解Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/88a6dd8200454e0eb96a868562c38b4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html title=詳解Java多態>詳解Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e802eb3.html alt=面向對象的利器--多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86e2eddadb9d4c50a34ff586bf70dce6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e802eb3.html title=面向對象的利器--多態>面向對象的利器--多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ae124314-674a-47ca-b794-c5b32a309a66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html title=Java多態的實現機制是什麼，看完你就知道（值得收藏）>Java多態的實現機制是什麼，看完你就知道（值得收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c802a4.html alt="Java面向對象編程三大特徵 - 多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a5bb9d2879b949319bd0cff669dad24a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c802a4.html title="Java面向對象編程三大特徵 - 多態">Java面向對象編程三大特徵 - 多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>