<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>掌握算法-散列 | 极客快訊</title><meta property="og:title" content="掌握算法-散列 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51e4e55b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51e4e55b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51e4e55b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51e4e55b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51e4e55b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51e4e55b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51e4e55b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51e4e55b.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="掌握算法-散列"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/51e4e55b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>掌握算法-散列</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>散列</strong>是一種<strong>用於</strong>以常數平均時間執行<strong>插入</strong>、<strong>刪除</strong>和<strong>查找</strong>的技術。但是，那些需要元素間任何排序信息的操作將不會得到有效的支持。因此，諸如FindMin，FindMax以及以線性時間將排序過的整個表進行打印的操作都是散列所不支持的。</p><h1 class=pgc-h-arrow-right>散列的基本思想</h1><p>理想的散列表數據結構只不過是一個包含有關鍵字的具有固定大小的數組。典型情況下，一個關鍵字就是一個帶有相關值（例如工資信息）的字符串。我們把表的大小記作TableSize，並將其理解為散列數據結構的一部分而不僅僅是浮動於全局的某個變量。通常的情況是讓表從0到TableSize-1變化。</p><p>每個關鍵字被映射到從0到TableSize-1這個範圍中的某個數，並且被放到適當的單元中。這個映射就叫<strong>散列函數（hash function）</strong>，理想情況下它應該運算簡單並且應該保證任何兩個不同的關鍵字映射到不同的單元。不過，這是不可能的，因為單元的數目有有限的，而關鍵字實際上是用不完的。因此，我們尋找一個散列函數，該函數要在單元之間均勻地分配關鍵字。</p><p>這就是散列的基本思想。剩下的問題則是要選擇一個函數，決定當兩個關鍵字散列到同一個值到時候（稱為衝突（collision））應該做什麼以及如何確定散列表的大小。</p><h1 class=pgc-h-arrow-right>散列函數</h1><p>如果輸入的關鍵字是整數，則一般合理的方法就是直接返回"Key mod TableSize"的結果，除非Key碰巧具有某些不理想的性質。在這種情況下，散列函數的選擇需要仔細考慮。</p><p>例如，若表的大小是10而關鍵字都以0為個位，則此時上述標準的散列函數就是一個不好的選擇。好的辦法通常是保證表的大小是素數。當輸入的關鍵字是隨機整數時，散列函數不僅算起來簡單而且關鍵字的分配也很均勻。</p><p>通常，關鍵字是字符串，在這種情況下，散列函數需要仔細的選擇。</p><p>一種選擇方法是把字符串中字符的ASCII碼加起來。代碼如下：</p><pre><code>typedef unsigned int Index;Index Hash(const char *Key, int TableSize){    unsigned int HashVal = 0;    while(*Key != '\0'){        HashVal += *Key++;    }    return HashVal % TableSize;}</code></pre><p>這個散列函數實現起來很簡單而建能夠很快地算出答案。不過，如果表很大，則函數將不會很好的分配關鍵字。例如，設TableSize = 10007(10007是素數），並設所有的關鍵字至多8個字符長。由於char型量的值最多127，因此散列函數只能假設值在0和1016（1016 = 127 x 8）之間。顯然這不是一種均勻的分配。</p><p>另一個散列函數，代碼如下：</p><pre><code>typedef unsigned int Index;Index Hash(const char *Key, int TableSize){    return (Key[0] + 27 * Key[1] + 729 * Key[2]) % TableSize;}</code></pre><p>這個散列函數假設Key至少有兩個字符外加NULL結束符。值27表示英文字母表的字母個數外加一個空格，而729 = 27 x 27。該函數只考慮考察前三個字符，但是，加入它們是隨機的，而表的大小像前面那樣還是10007，那麼我們就會得到一個合理的均勻分配。可是不巧的是，英文不是隨機。雖然三個字符（）忽略空格有26^3=17576種可能的組合，但查驗詞彙量足夠大的聯機詞典卻揭示：3個字母的不同組合數實際上只有2851。即使這些組合沒有衝突，也不過只有表的28%被真正散列到。因此，雖然很容易計算，但是當三列表足夠大的時候這個函數還是不合適的。</p><p>下面是第三種散列函數。</p><pre><code>typedef unsigned int Index;Index Hash(const char *Key, int TableSize){    unsigned int HashVal = 0;    while(*Key != '\0'){        HashVal = (HashVal &lt;&lt; 5) + *Key++;  /*****/    }    return HashVal % TableSize;}</code></pre><p>這個散列函數涉及到關鍵字中的所有字符，並且一般可以分佈得很好。這個函數其實計算的是</p><p><br></p><div class=pgc-img><img alt=掌握算法-散列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c><p class=pgc-img-caption></p></div><p>這裡運用Hoerner法則計算了這個多項式。我們之所以用32代替27，是因為32作乘法不是真的去乘，而是移動二進制5位。為了加速，在代碼中的/******/處的加法可以用按位異或來代替。</p><p>這個散列函數未必是最好的，但是確實具有極其簡單的優點。如果關鍵字特別長，那麼該散列函數計算起來將花費過多的時間，不僅如此，前面的字符還會左移出最終的結果。在這種情況下，通常的做法是不使用所有的字符。此時關鍵字的長度和性質將影響選擇。例如，關鍵字可能是完整的街道地址，散列函數可以包括街道地址的幾個字符，也許是城市名和郵政區碼的幾個字符。有些程序設計人員通過只使用奇數位置上的字符來實現他們的三列函數，這裡有這麼一層想法：</p><p><strong>用計算散列函數節省下的時間來補償由此產生的對均勻的分佈的函數的輕微干擾。</strong></p><p>剩下的主要編程細節是解決衝突的消除問題。如果當一個元素被插入的地方已經有另一個元素存在（散列值相同），那麼就產生一個衝突，這個衝突需要消除。解決這種衝突的方法有幾種，我們將討論其中最簡單的兩種：分離鏈接法和開放定址法。</p><h1 class=pgc-h-arrow-right>分離鏈接法</h1><p>其做法就是將散列到同一個值的所有元素保留到一個表中。我們假設關鍵字是i前10個完全平方數並設散列函數就是Hash(X) = X mod 10。如下圖所示：</p><p><br></p><div class=pgc-img><img alt=掌握算法-散列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/43adb57fd413497592c71886f84f8fb8><p class=pgc-img-caption></p></div><p>為執行Find，我們使用散列函數來確定究竟考察哪個表。此時我們以通常的方式遍歷該表並返回所找到的被查找項所在的位置。</p><p>為執行Insert，我們遍歷一個相應的表以檢查該元素是否已經處在適當的位置（如果要插入重複元，那麼通常要留出一個額外的域，這個域當重複元出現時增1）。如果這個元素是新元素，那麼它或者被插入到表的前端，或者被插入到表的末端，哪個容易就執行哪個。當編寫程序的時候這是最容易尋址的一種。有時新元素插入到表的前端不僅因為方便，而且還因為新近插入的元素最有可能最先被訪問。</p><p>代碼如下：</p><pre><code>#ifndef HASHSEP_H#define HASHSEP_Htypedef int ElementType;typedef unsigned int Index;struct ListNode;typedef struct ListNode *Position;struct HashTbl;typedef struct HashTbl* HashTable;HashTable InitializeTable(int TableSize);void DestoryTable(HashTable H);Position Find(ElementType Key, HashTable H);void Insert(ElementType Key, HashTable H);ElementType Retrieve(Position P);#endif</code></pre><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include "HashSep.h"#define MinTableSize (10)struct ListNode{    ElementType Element;    Position Next;};typedef Position List;struct HashTbl{    int TableSize;    List *TheLists;};static int NextPrime(int N){    int i;    if(N%2==0){        N++;    }    for(;;N+=2){        for(i = 3; i*i&lt;=N; i+=2){            if(N%i == 0){               goto ContOuter;             }        }        return N;        ContOuter:;    }}Index Hash(ElementType Key, int TableSize){    return Key % TableSize;}HashTable InitializeTable(int TableSize){    HashTable H;    int i;    if(TableSize &lt; MinTableSize){        return nullptr;    }    H = (HashTable)malloc(sizeof(struct HashTbl));    if(H == nullptr){        printf("Out of space\n");        return nullptr;    }    H-&gt;TableSize = NextPrime(TableSize);    H-&gt;TheLists = (List*)malloc(sizeof(List) * H-&gt;TableSize);    if(H-&gt;TheLists == nullptr){        printf("out of space!!!\n");        return nullptr;    }    for(i = 0; i&lt; H-&gt;TableSize; i++){        H-&gt;TheLists[i] = (List)malloc(sizeof(struct ListNode));        if (H-&gt;TheLists[i]==nullptr){            printf("out of space\n");            return nullptr;        }        else{            H-&gt;TheLists[i]-&gt;Next = NULL;        }    }    return H;}Position Find(ElementType Key, HashTable H){    Position P;    List L;    L = H-&gt;TheLists[Hash(Key, H-&gt;TableSize)];    P = L-&gt;Next;    while(P != nullptr &amp;&amp; P-&gt;Element != Key){        P = P-&gt;Next;    }    return P;}void Insert(ElementType Key, HashTable H){    Position Pos, NewCell;    List L;    Pos = Find(Key, H);    if(Pos == nullptr){        NewCell = (ListNode*)malloc(sizeof(struct ListNode));        if(NewCell == nullptr){            printf("out of space\n");            return;        }        else{            L = H-&gt;TheLists[Hash(Key, H-&gt;TableSize)];            NewCell-&gt;Next = L-&gt;Next;            NewCell-&gt;Element = Key;            L-&gt;Next = NewCell;        }    }}ElementType Retrieve(Position P){    return P-&gt;Element;}void DestoryTable(HashTable H){    int i;    for(i = 0; i &lt; H-&gt;TableSize; ++i){        Position P = H-&gt;TheLists[i];        Position Tmp;        while(P != nullptr){            Tmp = P-&gt;Next;            free(P);            P = Tmp;        }    }    free(H-&gt;TheLists);    free(H);}</code></pre><p>我們定義散列表的裝填因子（load factor）為<strong>散列表中的元素個數與散列表大小的比值</strong>。在上面的例子中這個因子為1。鏈表的平均長度是1。執行一次查找所需要的工作是計算散列函數值所需要的常數時間加上遍歷鏈表所用的時間。</p><p>分離連接散列中，表的大小實際上並不重要，而裝填因子才是最重要的。一般法則是使得表的大小盡量與預料的元素個數差不多，也就是說儘可能讓裝填因子為1。</p><h1 class=pgc-h-arrow-right>開放定址法</h1><p>分離鏈接散列算法的缺點是需要指針，由於給新單元分配地址需要時間，因此這就導致算法的速度多少有所減慢，同時算法實際上還要求對另一種數據結構的實現，除使用鏈表解決衝突外，開放定址散列法（Open addressing bashing)是另外一種用鏈表解決衝突的方法。在開放定址散列算法系統中，如果有衝突發生，那麼就嘗試選擇另外的單元，直到找出空的單元為止。更一般的，單元h0(X)，h1(X)，h2(X)，等等，相繼被試選，其中 hi ( X ) = ( Hash( X ) + F( i ) ) mod TableSize，且F（0）= 0。函數F是衝突解決方法。因為所有的數據都要置入表內，所以開放定址散列法所需要的表比分離鏈表散列用表大。一般來說，對開放定址散列算法來說，裝填因子應該低於0.5。現在我們就來考察三個通常的衝突解決方法。</p><h1 class=pgc-h-arrow-right>線性探測法</h1><p>在線性探測中，函數F是i的線性函數，典型情況是F（i）= i。這相當於逐個探測每個單元（必要時可以繞回）以查找出一個空單元。</p><div class=pgc-img><img alt=掌握算法-散列 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aadde0f03a4a4c2b9be93a8a90e5ea13><p class=pgc-img-caption></p></div><p>如上圖顯示使用與前面相同的散列函數將諸關鍵字[89, 18, 49, 58, 69]插入到一個散列表中的情況。而此時的衝突解決方法就是F（i） = i。</p><p>第一個衝突在插入關鍵字49時產生；它被放入下一個空閒地址，(9 + 試選1次 mod 10)即地址0，該地址是開放的。關鍵字58依次18，89，49發生衝突，(8 + 試選3次 mod 10)試選三次之後才找到一個空單元。對69的衝突用類似的方法處理。只要表足夠大，總能夠找到一個自由單元，但是如此花費的時間是相當多的。更糟的是，即使表相對較空，這樣佔據的數據單元也會開始形成一些區塊。其結果稱為一次聚集（primary clustering）。於是，散列到區塊中的任何關鍵字都需要多次試選單元才能夠解決衝突，然後該關鍵字被添加到相應的區塊中。</p><h1 class=pgc-h-arrow-right>平方探測法</h1><p>平方探測法是消除線性探測中一次聚集問題的衝突解決方法。平方探測就是衝突函數為二次函數的探測方法。流行的選擇是F（i） = i^2。邏輯基本跟線性探測相似。</p><p><br></p><p>對線性探測，讓元素幾乎填滿散列表並不是個好主意，因為此時表的性能會降低。對於平方探測更糟：一旦表被填滿超過一半，當表的大小不是素數時甚至在表被填滿一半之前，就不能保證找到一個空單元了。這是因為最多有表的一半可以用作解決衝突的備選位置。</p><p><strong>如果使用平方探測，且表的大小是素數，那麼當表至少有一半是空的時候，總能夠插入一個新元素。</strong></p><p>代碼如下：</p><pre><code>#ifndef HASHQUAD_H#define HASHQUAD_Htypedef int ElementType;typedef unsigned int Index;typedef Index Position;struct HashTbl;typedef struct  HashTbl *HashTabel;HashTabel InitializeTable(int TableSize);void DestroyTable(HashTabel H);Position Find(ElementType Key, HashTabel H);void Insert(ElementType Key, HashTabel H);ElementType Retrieve(Position P, HashTabel H);HashTabel Rehash(HashTabel H);#endif</code></pre><pre><code>#include "../cmn/fatal.h"#include "hashquad.h"#include &lt;stdlib.h&gt;#define MinTableSize 10enum KindOfEntry { Legitimate, Empty , Deleted};struct HashEntry{    ElementType Element;    KindOfEntry Info;};typedef struct HashEntry Cell;struct HashTbl{    int TableSize;    Cell* TheCells;}; /* Return next prime; assume N &gt;= 10 */static intNextPrime( int N ){    int i;    if( N % 2 == 0 )                N++;    for( ; ; N += 2 )    {        for( i = 3; i * i &lt;= N; i += 2 )            if( N % i == 0 )                goto ContOuter;  /* Sorry about this! */            return N;        ContOuter: ;    }}Index Hash( ElementType Key, int TableSize ){    return Key % TableSize;}HashTabel InitializeTable(int TabelSize){    HashTabel H;    int i;    if(TabelSize &lt; MinTableSize){        Error("Table size too small");        return nullptr;    }    H = (HashTabel)malloc(sizeof(struct HashTbl));    if(H == nullptr){        FatalError("Out of space!!!");    }    H-&gt;TableSize =  NextPrime(TabelSize);    H-&gt;TheCells = (Cell*)malloc(sizeof(Cell)* H-&gt;TableSize);    if (H-&gt;TheCells == nullptr){        FatalError("out of space!!!");    }    for(i=0; i&lt; H-&gt;TableSize; ++i){        H-&gt;TheCells[i].Info = Empty;    }    return H;}Position Find(ElementType Key, HashTabel H){    Position CurrentPos;    int CollisionNum;    CollisionNum = 0;    CurrentPos = Hash(Key, H-&gt;TableSize);    while (H-&gt;TheCells[CurrentPos].Info != Empty &amp;&amp; H-&gt;TheCells[CurrentPos].Element != Key)    {        CurrentPos += 2* CollisionNum -1;        ++CollisionNum;        if(CurrentPos &gt;= H-&gt;TableSize){            CurrentPos -= H-&gt;TableSize;        }    }    return CurrentPos;}void Insert(ElementType Key, HashTabel H){    Position Pos;    Pos = Find(Key, H);    if(H-&gt;TheCells[Pos].Info != Legitimate){        H-&gt;TheCells[Pos].Info = Legitimate;        H-&gt;TheCells[Pos].Element = Key;    }}HashTabel Rehash(HashTabel H){    int i, OldSize;    Cell *OldCells;    OldSize = H-&gt;TableSize;    OldCells = H-&gt;TheCells;    H = InitializeTable(2 * OldSize);    for(i=0; i&lt;OldSize; ++i){        if(OldCells[i].Info == Legitimate){            Insert(OldCells[i].Element, H);        }    }    free(OldCells);    return H;}ElementType Retrieve(Position P, HashTabel H){    return H-&gt;TheCells[P].Element;}void DestoryTable(HashTabel H){    free(H-&gt;TheCells);    free(H);}</code></pre><h1 class=pgc-h-arrow-right>雙散列</h1><p>我們將要考察的最後一個衝突解決方法是雙三列（double hashing）。對於雙散列，一種流行的選擇是F（i）= i × hash2(X)。這個公式是說，我們將第二個散列函數應用到X並在距離hash2(X)， 2hash2(X)等處探測。hash2(X)選擇得不好將會是災難性的。例如，若把99插入到前面例子中的輸入中去，則通常的選擇hashx(X) = X mod 9 將不起作用。因此函數一定不要算得0值。另外，保證所有的單元都能被探測到也是很重要的。諸如hash2(X) = R - (X mod R)這樣的函數將起到良好的作用，其中R為小於TableSize的素數。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>散列</a></li><li><a>算法</a></li><li><a>掌握</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html alt=算法小專欄：散列表（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a831970b0ccf4e4cbe591777ebd3f2a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html title=算法小專欄：散列表（二）>算法小專欄：散列表（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html alt=七大查找算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html title=七大查找算法>七大查找算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html alt=C#算法系列（1）——二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html title=C#算法系列（1）——二叉樹>C#算法系列（1）——二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html alt=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9b2026e861ad49e88e1e124dc67edb32 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html title=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）>算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html alt=算法題—完全二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ef7d8ad6eaca4524a71e1e5d1277532b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html title=算法題—完全二叉樹>算法題—完全二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a4566ba1.html alt=這些佈線穿管技巧你掌握了嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/24d95acc73474f6189cf2a93f2f69a79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a4566ba1.html title=這些佈線穿管技巧你掌握了嗎？>這些佈線穿管技巧你掌握了嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab527964.html alt=這6種編碼方法，你掌握了幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e653c34233a14fc7a0e54773a773af97 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab527964.html title=這6種編碼方法，你掌握了幾個？>這6種編碼方法，你掌握了幾個？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1b7b6866.html alt=基於一致性算法的微網分佈式有功均衡控制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/39fa00034e1eb30ffce3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1b7b6866.html title=基於一致性算法的微網分佈式有功均衡控制>基於一致性算法的微網分佈式有功均衡控制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html alt=深入淺出排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c898a3bab26542c2965d2bc5bebf9bd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html title=深入淺出排序算法>深入淺出排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html alt=程序員那些必須掌握的排序算法(上) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c32d187d725f4bd59225a5d09a38cb37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html title=程序員那些必須掌握的排序算法(上)>程序員那些必須掌握的排序算法(上)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html alt="算法 － 七大排序算法詳細介紹" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html title="算法 － 七大排序算法詳細介紹">算法 － 七大排序算法詳細介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9a28bf0.html alt=算法之旅｜冒泡排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/37e00004d03a88913f18 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9a28bf0.html title=算法之旅｜冒泡排序法>算法之旅｜冒泡排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html alt=算法之旅｜快速排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3b0e0000a716d98c3cba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html title=算法之旅｜快速排序法>算法之旅｜快速排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f03920a.html alt=算法入門篇：簡單的排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fbaa6f801434986af5ed9e339fd77f1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f03920a.html title=算法入門篇：簡單的排序算法>算法入門篇：簡單的排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb1c4077.html alt=算法設計之分治策略 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15394979629303da8548ffa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb1c4077.html title=算法設計之分治策略>算法設計之分治策略</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>