<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ | 极客快訊</title><meta property="og:title" content="從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/219773ca91044af0974b7db00ac40871"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/522013f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/522013f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/522013f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/522013f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/522013f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/522013f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/522013f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/522013f.html><meta property="article:published_time" content="2020-10-29T21:05:40+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:40+08:00"><meta name=Keywords content><meta name=description content="從gem5到ASIP，如何打造一款自己的交換芯片模擬器？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/522013f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從gem5到ASIP，如何打造一款自己的交換芯片模擬器？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>工欲善其事，必先利其器。在芯片設計流程中，某種類型的芯片是否有模擬器，對該類芯片的架構設計至關重要。這其中，最具代表性的就是CPU的模擬器如開源的gem5等。模擬器的核心就是用C/C++等軟件語言去描述芯片的工作流程，這裡需要解決的首要問題便是如何採用“串行”執行的軟件語言去描述“並行”執行的芯片中各個模塊的行為。同時，如何做到在保證效率的前提下還能最大程度的仿真芯片的真實行為，是其中最核心的問題。如果描述的精度是時間觸發的級別（如時鐘），則跟用VHDL和Verilog寫出來的沒有太大區別，複雜且仿真效率低下；但如果採用事件觸發的思想，則常常又過於粗糙無法真實的反應硬件的運行機制。CPU的模擬器、網絡仿真工具opnet和NS2等是如何設計出來的，其核心思想是什麼，能否自己開發一種自己設計的芯片的一種模擬器？本文將為你一一解答。</p></blockquote><p class=ql-align-justify></p><p class=ql-align-justify>長期以來，在設計芯片時經常遇到這樣的困惑，採用傳統流程設計某種類型的芯片時週期很長，某些模塊的特點至少等到進行FPGA驗證階段才能分析其性能，如果不合適，還需要推翻原來的架構重新設計，給設計流程和設計複雜度帶來很大的困擾。為了在芯片真正開始寫代碼設計之前就把上述問題解決掉，芯片模擬器的思想應運而生了。</p><p><strong>gem5與計算機架構仿真器</strong></p><p class=ql-align-justify>GEM5是一款模塊化的離散事件驅動全系統模擬器，它結合了M5(多處理器模擬器)和GEMS（存儲層次模擬器）中最優秀的部分，是一款高度可配置、集成多種ISA和多種CPU模型的體系結構模擬器。GEM5已經能夠支持多種商用ISA，包括X86、ARM、ALPHA、MIPS、Power、SPARC等，<strong>並且能夠在X86、ARM、ALPHA上加載LINUX操作系統。是一種名副其實的全系統計算機架構仿真工具。</strong></p><p class=ql-align-justify>筆者所在課題組也曾經研究過一段時間gem5，在上面跑起來了linux操作系統。只是速度比真實芯片上跑起來的有點慢而已。 網上有很多相關的學習筆記，比如：一個從剛入大學就勵志做CPU設計到畢業後如願以償的故事！</p><p class=ql-align-justify>讓我們看一下gem5介紹框圖。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/219773ca91044af0974b7db00ac40871><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify></p><p class=ql-align-justify>事實上，計算機架構仿真器有很多種，有些不是完整的系統仿真器。全系統仿真器包括 Simics, Simflex, GEM5, Bochs, MARSSX86, PTLsim。 (QEMU, GEMS以及其它項目)。其中最具代表性的有Simflex, GEM5, Bochs, MARSSX86等。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ac2162a78b44e64951d81a3feb8fb55><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>更加全面系統介紹計算機架構仿真器的頁面請訪問：</p><p class=ql-align-justify>http://pages.cs.wisc.edu/~arch/www/tools.html。</p><p class=ql-align-justify>這裡有各種仿真器官網的鏈接及相應的工具下載鏈接。可惜很少看到有中國人開發的仿真器。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/69df0cde14194c32a795c33208196fe2><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>Tensilica公司與ASIP</strong></p><p>個人認為，Tensilica公司是一家真正將計算機架構仿真器商用化的公司。或許很多同學沒有聽說過這個公司。其實，這家公司主要做定製指令集處理器（ASIP）的一家公司。ASIP的理念是：專業的事情應該由專業的指令集來完成！舉個例子，通用ARM處理器功能幾乎無所不能，可以播放視頻，可以處理網絡數據包等業務，但什麼都能做的反面就意味著可能什麼都做的不是最好的！Tensilica的思路是，分析通用處理器在執行某些具體任務如播放視頻的指令執行情況，從其中選出最經常被用到的幾十條或者幾百條通用指令集的組合，<strong>將這些最經常被用到的指令集組合實現的功能採用專門的一條新指令來替換掉</strong>！當然，這條新的指令就意味著處理器本身必須在硬件上去支持這一條指令去完成的所有功能。有了新的指令，當然處理器在進行視頻播放時效率就會有非常顯著的提升。這個新的被優化過的指令集就是播放視頻而定製的專用指令集，這就是ASIP的思想。</p><p>在這個理念下，DSP就是一種被優化了數值計算功能的ASIP，GPU也是一種被優化了視頻或圖像處理的ASIP，而寒武紀的AI處理器也是一種被優化了機器學習功能的ASIP，而所有的網絡處理器也是被優化了網絡數據包處理功能的ASIP......</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/846393676c4e4b6fa07e733cb1e10a8e><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>筆者曾在研究生階段申請了Tensilica公司大學計劃的LICENSE，也曾嘗試過在這個新的架構仿真器平臺下對JPEG等編解碼功能的指令集優化，據介紹，可以在這個平臺下一個小時之內就能定製一款ASIP的處理器。並且，在新的指令集下可以直接運行嵌入式的各種操作系統，綜合驗證軟硬件是否能協同工作。這種理念在十幾年前曾引起了不小的轟動，被認為是一種能擊倒ARM處理器的一種先進的SoC設計理念，可惜，當時的Xtensa等處理器由於價格昂貴等因素，沒有能迅速的推廣開。以至於到2013年的時候，被Cadence公司以3.8億美金收購。</p><p>有人認為，被收購的原因是大勢所趨。因為一組數據的對比，大約2003年，網絡電信專用設備硬件和軟件的投資比80:20的樣子，而2008年基本就已經逆轉成20:80的樣子。添加指令，是犧牲軟件的兼容性來增加硬件性能。因此當軟硬件投資比例發生逆轉的時候，過去的一些好技術，就不再有市場。這解釋了intel幹倒了一堆高性能的CPU，也解釋了ARM的崛起，也解釋了Tesillica不能獨立運營，只能被收購。</p><p>還有人認為被收購的原因是太過於對工具的依賴。針對某一類應用設計一套指令集，相對應的是一種處理器體系結構。但是要想真正從某一類應用出發設計出一個處理器，那困難大了去了，你先得抽象出一般共性的指令集，然後選擇合適的體系結構，根據指令集去調整優化這個結構，最後指令集和體系結構逐步收斂。期間還要考慮一整套處理器工具鏈的設計和實現。就像國內龍芯和最近呼聲很高的RISCV處理器一樣，最後發現，最重要的不是芯片的設計，而是針對芯片的編譯器的設計。從事CPU芯片設計的同學們都知道那本經典的《計算機體系架構：量化分析方法》書籍，此書可以說是計算機界的奇書，沒有之一，三十年來出了四版。兩位作者都是大仙，一個是斯坦福大學校長，另一個是是RISC的發明人，看這本書，讓人清楚的感受到處理器設計的門檻之高，涉及技術領域之廣。而Tensilica公司的Xtensa處理器出現後，一下子把處理器的設計門檻降低了！你可以針對你的目標應用，對這個處理器原型進行修修補補，尤其是他們提供了一個強大的軟件工具，你只需要用一種高級語言描述你的處理器，就會自動產生處理器相關的工具鏈和最終的RTL代碼/網表。整個過程比重新開始一個新指令集/體系結構要容易的多。也有人認為這裡面蘊含著一種設計哲學：要想從用戶需求側設計一種複雜的<strong>系統</strong>，相對簡單的思路是選擇一種熟悉的、通用的系統原型，進行修修補補，迭代收斂完成最終的設計。</p><p>有關Tensilica的更詳細的技術細節，可以參考chris rowen博士的《複雜SoC設計》一書。</p><p><strong>離散事件模型</strong></p><p>言歸正傳。接下來介紹一種上面牛叉的各種芯片模擬器平臺的原始設計思想：離散事件模型！</p><p>幾年前，因為筆者所在的團隊常做各種定製的網絡與交換的FPGA和芯片，所以就想著，是否能夠像設計CPU那樣開發出一套網絡與交換專用的模擬器。當然，網絡分析的模擬器也有很多常用的工具，比如OPNET、NS3等工具，但這些太偏系統，無法模擬出一款專用的交換芯片內部模塊的功能，最重要的是，這是別人做的工具，用起來實在不順手。<strong>大學的使命就是做研究，研究這些模擬器的核心思想到底是什麼，我們能否開發出自己的芯片模擬器？這才是我們作為一個高校科研工作者的使命和擔當。</strong>於是才有了上面那些資料的查找和理解過程。</p><p>我們的目標是，通過模擬器可以對各種交換功能進行裁剪和定製，滿足各種接口個數和接口速率（從百兆千兆萬兆到25G、40G到100G和400G）的需求，並且，通過模擬器還可以判斷邏輯資源和存儲資源的需求，從而確定FPGA的選型，還可以給出數據包的時延、抖動以及在各種網絡數據源模型下的性能分析......</p><p>硬件上實現一個複雜的交換單元的設計方案，所需要的開發成本十分高昂，實現週期長。而且硬件實現的結果如果不符合交換單元的需求，那麼又需要修改硬件實現方案，又需要經過漫長的時間，這樣大大增加了交換單元的開發時間。如果能夠在硬件實現之前，能夠確保設計方案的性能滿足需求，則能減少硬件修改的次數，從而縮短開發週期。而軟件仿真能夠衡量設計方案的性能好壞，在發現設計方案問題的時候可以及時對設計方案進行修改，然後繼續進行仿真測試性能，這樣為硬件實現提供了良好的方案，避免重複繁瑣的硬件修改過程。</p><p class=ql-align-justify>仿真平臺能夠把一些比較成熟的仿真實現方法接口化和模塊化，讓軟件仿真開發者可以直接調用已有的，減少了不必要的重複繁瑣的仿真設計工作，這樣有助於縮短軟件仿真開發週期，從而降低了實現一款交換單元的時間成本。這樣的仿真平臺能讓平臺的開發者更關注於平臺底層功能的開發，而平臺使用者即仿真開發者更注重具體交換單元的仿真方案的設計和實現。</p><p class=ql-align-justify>交換單元軟件仿真平臺的開發人員主要設計和實現仿真平臺底層，並且設計各種API函數和模塊供使用者調用。平臺的使用者則針對具體交換單元的設計方案，設計仿真方案，然後調用平臺接口實現自己的功能邏輯，而平臺底層負責運行邏輯。</p><p class=ql-align-justify>好了，不囉嗦了。下面看一個圖。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/54d079b3f7764e359ec8f6316a471cd0><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify></p><p class=ql-align-justify>上圖就是一個最典型的離散時間模型的實現方式，二維事件鏈表。用事件隊列來表示所發生各種事件的先後順序，以及在不同的事件發生後會觸發新的事件的發生，通過入隊和出隊操作來模擬事件的發生和結束。整個模型採用事件觸發的機制。當然，描述芯片內部行為，還需要維護一個時間軸，所有的事件都有專屬的執行時間的概念。在這個簡單模型下，一個數據幀的到達可以用數個事件來描述（幀長、耗費的時間等）。其實，大家應該都做過類似的程序設計，比如經典的銀行窗口服務系統等就是最簡單的一個離散事件。</p><p class=ql-align-justify>其實，離散事件模型不僅僅可以用來搭建芯片的仿真器（變時鐘驅動為事件驅動），還可以做各種通信協議的仿真平臺，甚至是其它所有你可以抽象為離散事件的場景。</p><p class=ql-align-justify><strong>事件驅動仿真器關鍵技術</strong></p><p class=ql-align-justify>以下內容是課題組學生總結的一些體會和心得，通過這些總結就能夠看出初次寫一個模擬器需要注意的內容。</p><p class=ql-align-justify>1、什麼是事件</p><p class=ql-align-justify>事件是什麼，事件是一種軟件層面的抽象，一定要理解軟件中的抽象。事件是對將要執行的動作的一種抽象描述，一個事件最主要的就是啥事、啥時候、誰啊、幹啥啊。在實際的硬件中，大多數的動作都是中斷觸發的，包括定時器中斷，我們都可以說有個事件要執行。在MFC框架中，也有事件的概念，一條消息、什麼時候的消息、給誰的消息、怎麼處理這個消息。總之當我們將上述元素組合在一起時，將能夠精確地描述一個實際操作。例如，我要發送數據包，我在***時刻發送，我這麼這麼發送。再例如，我要規劃信道，我在***時刻規劃，我這麼這麼規劃。原來上面說的一大堆模塊都可以抽象成為事件的概念，在不同的時刻執行不同的例如，生成數據、發送數據、接收數據的操作。我不敢說所有軟件都是基於事件的，但我們的仿真框架就是基於事件的。</p><p class=ql-align-justify>2、需要調度器嗎</p><p class=ql-align-justify>事件有了，然後呢？怎麼安排這些事件在不同的時刻去執行呢？我的第一個思路，把這些事件寫成數組，一個挨著一個執行，因為我們的協議是TDD的嘛，有時間軸。這個方法貌似可行。。。不對有問題，同一時刻有多個事件怎麼辦？這個數組不夠大怎麼辦？隨著事件的執行，很多空間變得不再需要怎麼辦？我可能要添加新的事件怎麼辦？我腦殘添加錯了想刪除事件怎麼辦？好了好了別問了，我用鏈表不就行了。。。（實現的可能千千萬）</p><p class=ql-align-justify>經過努力，現在所有的事件以一種合理的方式存儲著，而且你可以隨時添加新的事件，在發現自己2B以後可以刪除事件。我們貌似有了一張動態的表格，隨著時間的推移已經執行的事件在表格中擦除了，但是同時也會有新的需要執行的事件寫入了這張表格。</p><p class=ql-align-justify>而調度器的工作就是每次提取第一個將要執行的事件並執行相關處理（FIFO，最簡單的調度器，也最符合仿真場景）。Windows怎麼做的？GetMessage、TranslateMessage、DispatchMessage大循環。NS2怎麼做的deque_event、dispatch_event大循環。</p><p class=ql-align-justify>這裡由於windows是實際系統，所以他不知道有什麼message，這個message是由於用戶交互操作產生的，是不可知的，而且系統的時鐘是連續流逝的。NS2中，在一定程度上事件是提前可知的，而且系統的時鐘可以不連續的流逝。下面我們就說說時間軸和離散的問題，來完善這個調度器的說明。</p><p class=ql-align-justify>3、時間軸和離散事件驅動</p><p class=ql-align-justify>我們在測量協議性能的時候，有一個性能指標叫做時延，數據包從到達系統，然後離開系統所經過的時間。實際硬件中，系統應該會維護一個時鐘，這樣對每個包在出隊入隊時分別讀取這個時間就可以知道包的時延。那麼在仿真中如何做到？</p><p class=ql-align-justify>沒錯我們也需要一個時間軸，在數據包入隊事件中為每個包打上標記，在數據包發送並接收事件處理時讀取時間軸時間，以獲得包的時延。問題是我們怎麼樣提供一個時間軸？</p><p class=ql-align-justify>Windows下可以獲取系統時間，能拿這個當做我們仿真的時間軸對嗎？You are wrong！記得我們說過的仿真可以屏蔽硬件特性嗎？如果我們這樣做會有什麼樣的結果呢？我有一臺i7-4770k處理器的臺式機，一個數據包從入隊到出隊歷時2.5ms；你有一臺奔騰III處理器的臺式機，同樣的操作歷時5ms。哇，你又引入了硬件特性，更何況windows能提供的時間精度是什麼樣的我們都不知道。</p><p class=ql-align-justify>我們該怎麼辦？別給我說windows都做不到，臣妾也做不到啊~~~~麵包會有，辦法也會有的。辦法就是我們自己提供一個時間軸，時間的流逝由我們自己控制，流逝的精度任意設定，這樣就完全屏蔽了不同硬件帶來的不同結果。</p><p class=ql-align-justify>我覺得我又說了個廢話，方法具體是啥呢？第一個思路，設計時間流逝精度是1us，現在時刻now_time，我查看事件表格裡的第一個事件的時刻是不是等於now_time，若是則執行；若不是則now_time+1，時間流逝1us。這裡為了屏蔽硬件特性，在這個操作沒有執行結束時時間軸是不會向前移動的，因為實際硬件中高速率cpu可能0.5us就執行完畢，而低速率cpu可能需要2us。這裡無論這個操作在實際硬件中需要多久，我們都假設他在1us內執行結束就屏蔽了硬件。</p><p class=ql-align-justify>然後，我又發現了問題，這樣做確實可行，但是我需要輪訓查詢，輪訓效率是相對較低的。而且，若1us有個事件，1000us有個事件，我需要查詢1000次，而且全是無用功，怎麼辦？離散事件驅動來幫助你。。。</p><p class=ql-align-justify>每次取出一個事件，事件中標記此事件的發生時間，我們只需要將事件的發生時刻賦值給now_time，就可以模擬時間流逝到這個事件的發生時刻。還是上述例子，now_time為1，取出一個事件，發現其發生時刻為1000，則設定now_time為1000，並執行相關操作。沒有了查詢，而且跳過了沒有任何事件的1000個時間單位，效率大大提升。這裡時間軸沒有一個一個時間單元的流逝，而是根據事件的發生時刻，從1跳到1000，再跳到1002.。。。。時間點是離散的，事件也沒有在時間軸上均勻分佈，這就叫離散事件驅動，基於此原理的調度器就是離散事件調度器，也就是我們仿真框架使用的模型。</p><p class=ql-align-justify>4、事件單元</p><p class=ql-align-justify>至此，我們應該對框架有個大概的認識：事件就是協議中的各種操作，他們被事先安排在一個合理的結構中，調度器每次從這個結構中取出第一個待執行的事件執行，完畢後重覆上述步驟，完成deque_event、dispatch_event循環。這裡，大循環不是問題，問題是第一事件應該有哪些元素，第二這個所謂存儲事件的結構是啥樣的，我們一個個回答。</p><p class=ql-align-justify>事件應由哪些元素組成呢？回想一下windows程序中的消息，它包括消息所屬的窗口（誰的消息），消息標識符（消息的名字或者類型），消息投遞時間（消失的產生時間），消息的附加信息。回頭想想之前說的事件中的元素，現在已經擁有了誰啊（消息所屬）、啥事兒（消息標識符）、啥時候（消息投遞時間），但是沒有看到幹啥啊，windows裡的結構不完整啊，這是個bug吧。再翻開孫鑫的書，每個消息有指定所屬的窗口，每個窗口結構有一個函數指針，指向此窗口對所有消息的處理函數，函數中根據消息的類型不同，利用switch進行語句分支，達到處理不同消息的目的。</p><p class=ql-align-justify>貌似問題解決了，我們可以為每個模塊設定類似上述結構（事件類型、事件執行者、事件發生時間），然後每個模塊根據判定事件類型的不同選擇不同的程序分支進行處理。具體些，調度器調出一個事件，首先判定事件執行者，程序調轉到相關執行者代碼段，再判定事件類型，程序跳轉至相應代碼段，所有操作執行結束，返回調度器，重複上述。思路沒有大的問題，程序會有兩個switch，一個判定執行者，一個判定事件類型。但是我們可以想象隨著模塊的增多、事件類型的增多，這兩個switch會不斷增大，以致後來我們自己徜徉在我們的代碼裡卻找不到北。</p><p class=ql-align-justify>巨硬搞錯了吧，設計這麼糟糕的框架。別忘了巨硬還有個框架叫MFC，它裡面使用了另外一套機制來解決代碼越來越長的問題---消息映射機制，光從這個名字就知道這是啥技術。一條消息對應一個消息處理函數，而不像原來所有消息對應到一個入口函數，在內部實現消息的不同處理。這樣第一我們能迅速的找到處理此消息的代碼，第二我們程序猿不用為了滿足產品狗不斷的需求，而讓那唯一的函數變得越來越大、越來越長~~~~（這裡微軟是怎麼映射的我們就不探討了，那是具體實現的問題了）</p><p class=ql-align-justify>說了這麼一大堆windows的東西，和我們有何關係呢？如前所述，我們的事件就類似windows中的消息，有差不多相同的元素，再加上事件到事件處理函數的映射關係，我們的框架貌似就要完成了。不過先別急，我們再看看NS2的代碼。</p><p class=ql-align-justify>NS2更懶，消息映射了我還要查消息映射表，老子決定不查了，老子要紋身，紋上我要怎麼處理。然後NS2中每個事件都有一個元素，叫做事件處理函數指針的東西。</p><p class=ql-align-justify>好吧，齊活。事件包括事件類型和名稱（名稱也許只有調試的時候有用），事件執行者ID（協議仿真中總要分不同的結點），事件發生時間（別忘了我們還有張事件表格，事件在表格中是有先後順序的），事件執行函數指針（瞬間我就找到了處理我的代碼，真是極好的）。</p><p class=ql-align-justify>哎呀師兄，這個函數指針我理解不了。要觸類旁通。再看看孫鑫的書，看看windows窗口程序的函數指針，它有四個參數，前兩個參數--窗口句柄、消息類型，為了之前所說的兩個switch用的，看來我們的結構是用不上了，因為我們不需要映射。後兩個參數--消息帶來的兩個參數，這是幹嘛的。廢話啊，程序是完成交互處理的，當然要有參數了，不然函數不就不能完成多樣性的輸出了嘛。</p><p class=ql-align-justify>對啊，我們的事件執行函數指針總要有個類型吧，指明這類函數要怎麼樣的輸入參數，輸出怎麼樣的值。說得對，但問題是執行函數千奇百怪，參數個數不盡相同，怎麼可能設計出適合所有函數的指針呢？</p><p class=ql-align-justify>哎呀呀，要你這麼說linux中的驅動程序那麼高級的抽象是怎麼做出來的。辦法有，而且很簡單，使用void*指針作為函數的輸入參數（void fun(void* pdata)）。當我們需要一個輸入參數時，一個viod*指針就夠了；兩個參數怎麼辦，傳輸形參前先將他們封裝到一個結構體內，在函數內部再取出各個域。這個辦法，你有一百個參數都能傳進去。</p><p class=ql-align-justify>方法很好，不過我們能不能簡化一下處理呢？一個函數完成一個功能，需要處理輸入得到輸出，那麼這個函數類型可以簡化為void fun(void *src_data,void *des_data)，這樣如果函數的參數不是很多的話，我們就不用設計那些封裝參數的結構體了。送佛送到西，再來一個void fun(void *src_data,void *des_data, void *add_data)，我們的函數都採用這樣的形式吧，源參數、目的參數和附加參數，源參數主要承載函數獲取數據的來源，目的參數負責指明結果寫到哪裡，附加參數你就發揮想象吧，什麼都可以。</p><p class=ql-align-justify>哇，問題似乎是得到了解決，事件包括上述的那些元素，其中包括一個這樣一個函數指針---void (*pfun)(void*src_data, void *des_data, void *add_data)。事件處理循環中，取出事件，然後執行這個指針指向的函數。</p><p class=ql-align-justify>代碼寫著寫著發現問題了，執行這個指針指向的函數，他需要參數啊，而且雖說所有事件執行函數的參數個數一致，但是參數的名字不一致啊，怎麼可能寫出一條語句去執行所有的事件執行函數呢？看看NS2咋搞的，很遺憾NS2沒有利用我們設計的這套機制，難道我們要推倒重建？Nononono。。。。</p><p class=ql-align-justify>再看一下NS2的事件執行循環函數：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e1575c9bfea745108c833a95276d3082><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>注意紅色劃線部分，先取出一個事件p，然後將p傳遞給dispatch函數，然後在dispatch內部：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=從gem5到ASIP，如何打造一款自己的交換芯片模擬器？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca85d60d03094ec499c120d71a374aed><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>調用事件 p 的執行函數指針，並將事件 p 本身作為參數傳遞給事件執行函數。</p><p class=ql-align-justify>原來是這樣啊，我們可以將所有的參數封裝進事件，作為事件元素的一部分，然後對於事件執行函數我們設計 void (*pfun)(Event *e) 的指針，每次將事件本身傳遞給執行函數，並在函數內部解析出需要的各種參數。</p><p class=ql-align-justify>真是個浩大的工程，用了三分之一的篇幅終於將事件的所有重要元素搞出來了。事件包括：事件的發生時間、事件的類型、事件的所屬對象、事件的執行函數指針、事件執行函數的源參數指針、事件執行函數的目的參數指針、事件執行函數的附加參數指針（針對不同事件，不是所有的域都要使用）。</p><p class=ql-align-justify>那麼當我們實例化一個事件時，這個結構就叫做一個事件單元，代表著一個將要執行的動作的所有要素。</p><p class=ql-align-justify>5、事件存儲單元</p><p class=ql-align-justify>有了事件單元后，存進一個怎麼樣的結構就是個問題。這裡僅僅講解存儲的思路，實現不做具體分析。我們有兩個問題，第一同一時間點的事件如何放置，第二不同時間點的事件如何放置。</p><p class=ql-align-justify>第一個問題，最簡單的方法就是隊列，同一時刻的事件按照事件的先後順序（也有可能事件間沒有先後順序，但總要有個隊列）。</p><p class=ql-align-justify>第二個問題，不同的時刻也要能夠很簡單的索引到，因為當插入新事件時，一定是向當前時刻之後的某個時刻插入。這裡我們可以再次使用鏈表，或者hash表，這都是實現的問題了。</p><p class=ql-align-justify>至此，我們設計出了一個事件單元的結構，以及為了方便索引至任意時刻的任意事件單元的存儲結構。而且，通過每次提取這個存儲結構中的第一個事件並執行，我們的框架中最主要的部分就完成了，剩下的工作就是設計不同的事件及其相關操作函數。</p><p class=ql-align-justify><strong>EDA相關與芯片仿真器</strong></p><p class=ql-align-justify>長期以來，國內的EDA相關工具都嚴重依賴於國外。正是因為國內從事EDA工具開發的公司在Synopsys、Cadence、Mentor面前實力過於懸殊，國內IC設計公司幾乎100%採用國外EDA工具。而且在相當長的一段時間裡，看不到縮小和Synopsys、Cadence、Mentor技術差距的可能性。但筆者今天所說的內容，不屬於常見的芯片設計EDA工具範疇，但卻關乎國產芯片能否做大做強的關鍵。今年9月，一家國產eda公司獲得國家集成電路產業投資基金投資，從2017年底至今，該公司已獲得累計數億元投資，這將有助於該公司提升自身技術水平，填補中國EDA工具上的空白。不過，由於中國在EDA工具上與國外三大廠差距過大，追趕之路任重道遠。</p><p class=ql-align-justify>我們也希望國內也能夠出現類似於Cadence和Synopsys 這樣的巨無霸，不是隻提供芯片設計專用的EDA工具，也能夠出售各種成熟的IP和仿真器平臺。</p><p class=ql-align-justify>全文完。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>gem5</a></li><li><a>ASIP</a></li><li><a>交換</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ef4a8fd.html alt=「網工進階」路由交換：鏈路聚合的配置，你都會嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f5b7228828484a249973d030a8ae92a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ef4a8fd.html title=「網工進階」路由交換：鏈路聚合的配置，你都會嗎>「網工進階」路由交換：鏈路聚合的配置，你都會嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35ebbbc8.html alt=交換機鏈路帶寬不夠用怎麼辦？可以通過鏈路捆綁增加鏈路帶寬 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8cfd610c006140cebf4355d60e84b06e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35ebbbc8.html title=交換機鏈路帶寬不夠用怎麼辦？可以通過鏈路捆綁增加鏈路帶寬>交換機鏈路帶寬不夠用怎麼辦？可以通過鏈路捆綁增加鏈路帶寬</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cd32872.html alt=交換機鏈路聚合最常用場景分析，記住一張表格即可 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/93898ffc9d7b4672b064a870525bab57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cd32872.html title=交換機鏈路聚合最常用場景分析，記住一張表格即可>交換機鏈路聚合最常用場景分析，記住一張表格即可</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/df522c73.html alt=交換機鏈路聚合配置詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/df522c73.html title=交換機鏈路聚合配置詳解>交換機鏈路聚合配置詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb9466d0.html alt=交換機小課堂｜劃分VLAN有什麼作用？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b5d0f7051d87478488a0f658b689ce5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb9466d0.html title=交換機小課堂｜劃分VLAN有什麼作用？>交換機小課堂｜劃分VLAN有什麼作用？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/611f4508.html alt=BIM模型數據主要有哪些交換方式與方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8b3a0009c04f47dba125fac42117633d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/611f4508.html title=BIM模型數據主要有哪些交換方式與方法>BIM模型數據主要有哪些交換方式與方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d9900a2.html alt=Flink中的數據抽象及數據交換過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/1b7a1014-7ea5-421b-808e-c41398f5e4aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d9900a2.html title=Flink中的數據抽象及數據交換過程>Flink中的數據抽象及數據交換過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a44e688d.html alt=共建安全高效的證通數據交換存儲平臺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6e00e2a126624cd3a04003e09f129836 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a44e688d.html title=共建安全高效的證通數據交換存儲平臺>共建安全高效的證通數據交換存儲平臺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a8ee1e1.html alt=加大數據交換，服務社會治理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52356fef840348268d722f9e09041d09 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a8ee1e1.html title=加大數據交換，服務社會治理>加大數據交換，服務社會治理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aabf6c20.html alt=大容量數據交換，該選擇什麼移動存儲設備？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a0645b75449e4f86b44ec2301e660ac4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aabf6c20.html title=大容量數據交換，該選擇什麼移動存儲設備？>大容量數據交換，該選擇什麼移動存儲設備？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4abcc1ec.html alt=完善和高效的數據交換管理平臺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/95bd84cca48a4510bdf677846e255dda style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4abcc1ec.html title=完善和高效的數據交換管理平臺>完善和高效的數據交換管理平臺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/543694ba.html alt=一般人不知道的線程間數據交換Exchanger class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df26ce3a590f4daba6b29648f36e3ae7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/543694ba.html title=一般人不知道的線程間數據交換Exchanger>一般人不知道的線程間數據交換Exchanger</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/781bd8ae.html alt="成都成華：搭建數據交換中心 推進移動辦公辦案平臺建設_正義網" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/781bd8ae.html title="成都成華：搭建數據交換中心 推進移動辦公辦案平臺建設_正義網">成都成華：搭建數據交換中心 推進移動辦公辦案平臺建設_正義網</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89963e6e.html alt=數據安全交換協議來了，或將推動AI大步邁向3.0時代 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/SErvipbBeWotcr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89963e6e.html title=數據安全交換協議來了，或將推動AI大步邁向3.0時代>數據安全交換協議來了，或將推動AI大步邁向3.0時代</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75154d57.html alt=試驗數據交換共享技術研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1f294f46e217463ca5ba719dfd99dcf3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75154d57.html title=試驗數據交換共享技術研究>試驗數據交換共享技術研究</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>