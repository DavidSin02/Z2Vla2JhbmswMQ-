<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>彙編乾貨第三章 | 极客快訊</title><meta property="og:title" content="彙編乾貨第三章 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/106cd543a805444295836b37ed89a1f4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5273778.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><meta property="article:published_time" content="2020-10-29T21:04:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:04+08:00"><meta name=Keywords content><meta name=description content="彙編乾貨第三章"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5273778.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>彙編乾貨第三章</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/106cd543a805444295836b37ed89a1f4><p class=pgc-img-caption></p></div><p>是時候關注我們一波了&lt;微信公眾號滲透雲筆記></p><p>包含多個段的程序</p><p>前面說道，如果要使用安全的內存空間，0:200~0:2FF是相對安全得內存空間，可是這段空間只有256字節，如果需要的空間大於256字節該怎麼辦呢？</p><p>在操作系統允許的情況下，程序可以取得任意容量的空間。</p><p>取得空間的方法有兩種。</p><ul><li>加載程序時為程序分配</li><li>執行過程中向系統申請（這裡不討論）</li></ul><p>若要一個程序在加載時取得所需的空間，則必須在源程序做出說明。</p><p>上面是從內存空間獲取的角度上，談定義段的問題。為了可讀性、功能設計，一般一額定義不同的段來存放。</p><p>關於段的問題，我們將以這樣的順序討論多個段的問題：</p><ul><li>在一個段中存放數據、代碼、棧;</li><li>將數據、代碼、棧放入不同的段中。</li></ul><p>在代碼段中使用數據</p><p>我們可以在程序中，定義我們希望處理的數據，數據作為程序的一部分一同被編譯、鏈接寫到可執行文件中。</p><p>考慮這樣一個問題，編程計算8個數據的和，結果存放在AX寄存器中，下面是用我們前面知識寫出的代碼。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/91b7496c0bf34edca81744f4ac18dadf><p class=pgc-img-caption></p></div><p>這裡出現了一個新的指令dw，dw即“define word”，在這裡，定義了8個字型數據，佔用16字節的內存空間。</p><p>使用Debug調試程序，不運行，發現一個問題，程序所在的內存區為075C:0（DS=075C）,前256字節存放著PSP，程序的存放位置應為076C:0，使用U指令查看確發現有點不對。</p><p>實際上，看到其實是有dw定義的數據，從第16字節開始才是彙編指令對應的機器碼。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/52418377711d4fd6b8e96eb40610ade8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f8c22945a9a4dd8a26ade19142b5f41><p class=pgc-img-caption></p></div><p>怎樣執行程序中的指令呢？在Debug中，可以手動修改IP寄存器的值，從而使CS:IP指向程序的另一條指令。</p><p>這樣一來，在系統運行時就會出現問題，程序的入口不是我們希望執行的指令。</p><p>藉助偽指令可以通知編譯器程序的入口。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddf9af725c244fb7901be3073db389db><p class=pgc-img-caption></p></div><p>有了這個指令，可以仿照這個模板寫出更多的程序，start上面安排數據，start和end start之間安排代碼。</p><p>在代碼段中使用棧</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/52f953cf7df04e06a0cd4a1c26fe3730><p class=pgc-img-caption></p></div><p>這裡的檢測點沒做出來，看視頻才想通的，後來發現這個題目第一眼沒看懂。</p><p>檢測點考察dw定義的數據在內存空間的位置，理解了這一點，題目就可以做出來了。</p><p>註釋未知的指令，在debug模式中運行可以直觀的感受到到這一點。</p><p>將數據、代碼、棧放入不同的段</p><p>前面的內容中，我們將數據、棧和代碼都放到了一個段裡面，編程的時候需要注意何處是數據，何處是棧，何處是代碼。顯然這樣有問題：</p><ul><li>程序混亂</li><li>8086的段空間限制只有64KB</li></ul><p>下面的程序用不同的段實現了上面的功能</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/65b1fe3be8c5421c935b4c26ef869c12><p class=pgc-img-caption></p></div><ul><li>對於不同的段，使用不同的段名聯繫不同的段寄存器。</li><li>注意紅線的部分，段名相當於一個標號，代表了段地址，8086CPU不允許將一個數值送入段寄存器，因此使用其它寄存器中轉</li><li>“代碼段”、“數據段”、“棧段”完全是我們的安排</li><li>CPU如何處理定義的段的內容，取決與程序中具體的彙編指令。</li><li class=ql-indent-1>段名只是為了閱讀性</li><li class=ql-indent-1>cs:code等代碼將段名和寄存器聯繫起來</li><li class=ql-indent-1>end start指明瞭程序的入口，CS:IP指向這個入口，從而執行程序的第一條指令</li></ul><p>編寫、調試具有多個段的程序</p><p>這裡是兩個檢測點，為了理解不同段在內存空間中的排列，一個段在內存空間中最小單位為16字節。</p><p>限於篇幅原因，我這裡介紹比較最後的一個實驗。</p><p>程序如下，編寫code段的代碼，用push指令將a段中的前8個字型數據逆序存儲在b段中。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e0da7f9180be4fc68891f1239372a5ee><p class=pgc-img-caption></p></div><p>寫出程序很容易，不過這不是我要說的重點。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1c7748fa7e6f4afdb0b54258b76138e9><p class=pgc-img-caption></p></div><p>程序運行完之後，查看內存空間，注意我這裡查看的DS。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7decc55e980d4e20882cdaaf4912fb7f><p class=pgc-img-caption></p></div><p>從數據對應關係不難判斷，76C:00~76C:1F是我們定義的數據段， 076C:20~76C:2E是我們定義的棧段，76C:30之後是代碼段。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57119f4d8599478ca3eaa553f20cf044><p class=pgc-img-caption></p></div><p>查看對應的寄存器，也驗證了這一點，</p><p>$076C \times 10H+0=76C0H=76C \times 10H+0$</p><p>$076C \times 10H+20=76E0H=76E \times 10H+0$</p><p>$076C \times10H+30=76F0H=76F \times 10H+0$</p><p>這裡主要涉及到了一些段編譯的規則，編譯的規則影響了內存的分配。我們在使用SSD格式化的時候，有一個選項為4K對齊，4K對齊是為了讓操作系統的最小分配單元和閃存的一個頁對應，提高讀寫效率，實際使用過程中，即使文件沒有那麼大，實際佔用的均為4KB的倍數，在這一點上和編譯規則有些相似。</p><p>更靈活的定位內存地址的方法</p><p>前面，我們用[0]、[bx]的方法，定位內存單元的地址。本章介紹更為靈活的定位內存地址和相關的編程方法。</p><p>and和or指令</p><pre>12345678;and指令：邏輯與指令，按位進行與運算mov al,00001111Band al,11110000B;執行後AL=00000000B 相應位設為0;or指令：理解與指令，按位進行或運算mov al,00001111Bor al,11110000B;執行後 AL=11111111B 相應位設為1</pre><p>以字符形式給出的數據</p><p>計算機中所有的信息都是二進制，而人能理解的信息是具有約定意義的字符。將字符存儲在計算機中，就要對其進行編碼。計算機存儲的信息展示給我們看時，就要對其進行解碼。</p><p>ASCII是基於拉丁字母的一套編碼系統。例如，文件編輯過程中，按一下按鍵的“a”鍵，計算機用ASII碼規則編碼為61H存儲在內存中;文件編輯器從內存中取出61H，送入顯卡上的顯存中；顯卡用ASII碼的規則解釋顯存的內容，顯卡驅動顯示器，我們在顯示器看到了字符“a”。</p><p>我們可以在彙編程序中，用‘……‘的方式指明數據是以字符的形式給出，編譯器將轉化為相對應的ASCII碼。</p><p>大小寫轉換的問題</p><p>在codesg中填寫代碼（我這裡寫好了），將datasg中的第一個字符串轉化為大寫，第二個字符轉化為小寫。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/67ca1944f2b54a1b9fe531f42021e78a><p class=pgc-img-caption></p></div><p>查看字母的ASCII表。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f644a9b423a4dc39e5243b724b07204><p class=pgc-img-caption></p></div><p>可以發現，大寫字母到小寫字母在於寄存器中第5個字符的不同（我沒說錯，從右往左數，從0到7），那麼這道題的關鍵在於將第5個字符置0的轉換了，寫出上面的代碼就很簡單了。</p><p>[bx+idata]</p><p>前面使用[bx]的方式來指明一個內存單元，還可以使用[bx+idata]來表示內存單元，他的偏移地址為[bx]+idata。</p><p>有了這個特性，前面我們做過一道將a段和b段的內容相加到c段中的題目，可以將代碼優化。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/528feae7dc7744418f0f1eb804d7646c><p class=pgc-img-caption></p></div><p>可以看出靈活的內存訪問方式，減少了指令，加快的程序運行速度。</p><p>SI+DI</p><p>SI和DI是8086CPU中和BX功能相近的寄存器，SI和DI不能分成兩個8為寄存器來使用</p><p>[bx+si]和[bx+di]</p><p>在前面，我們用[bx]和[bx+idata]的方式來指明一個內存單元，還可以使用更為靈活的方式：[bx+si]和[bx+di]</p><p>[bx+si]表示一個內存單元，它的偏移地址為(bx)+(si)（即bx中的數值加上si的數值）</p><p>[bx+si+idata]和[bx+di+idata]</p><p>[bx+si+idata]表示一個內存單元，偏移地址為(bx)+(si)+(idata)。</p><p>不同的尋址方式的應用</p><ul><li>[idata]用一個常量表示內存地址，可直接定位一個內存單元</li><li>[bx]用一個變量表示內存地址，可間接定位一個內存單元</li><li>[bx+idata]用一個變量和常量表示內存地址，可在一個起始位置的基礎上用變量間接定位一個內存單元</li><li>[bx+si]用兩個變量表示地址</li><li>[bx+si+idata]用兩個變量和一個常量便是地址。</li></ul><p>如下圖，將datasg段中的每個單詞改為大寫字母</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfd9bfcc22f04cba97793dccebd3bc0e><p class=pgc-img-caption></p></div><p>db指令和dw指令類似，不過他定義的是字節型數據</p><p>總共數據有4行，每行有3個字母需要更改，也就是$4\times3$此二重循環，有限的循環可以使用loop指令，這裡需要存儲兩個循環次數，經過艱苦的思考（並沒有，我想不出來，看書上思路了），可以使用空寄存器DX暫存，循環完成後又拿回（下圖左）。</p><p>程序中進場需要進行數據的暫存，寄存器的數量有限，如果不適用寄存器，只能使用內存了，我們開闢了新的一塊內存，先存放在內存中，需要的時候在從內存單元中恢復（下圖中）。</p><p>我們使用內存來暫存數據，這是比較聰明的選擇，但是值得推敲的是，我們用怎樣的結構來保存這些數據，從而使程序更為清晰。</p><p>一般來說，在需要暫存數據的時候，都應該使用棧。</p><p>我們使用棧暫存數據，採用相關的指令將數據入棧，需要時在出棧（下圖右）。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e09ded2a8a4b499fa1b1662b10cd6940><p class=pgc-img-caption></p></div><p>為什麼要用[bx+si+data]的形式來表示？</p><ul><li>為了可閱讀性，理解數據的起始，體現了偏移的思想</li></ul><p>程序如何改進？</p><ul><li>更多的數據入棧，比如上面的BX進行入棧</li></ul><p>數據處理的兩個基本問題</p><ul><li>處理的數據在什麼地方</li><li>要處理的數據有多長</li></ul><p>reg和sreg</p><p>定義描述性的符號reg和sreg，reg表示一個寄存器，sreg表示一個段寄存器。</p><p>reg：x、bx、cx、dx、ah、al、bh、bl、cx、bl、dh、dl、sp、bp、si、di;</p><p>sreg：ds、ss、cs、es</p><p>bx、si、di和bp</p><ul><li>8086CPU中，只有這4個寄存器可以用在[…]中進行內存單元尋址</li><li>在[…]可以單個出現，或只能以4中組合出現：bx和si、bx和di、bp和si、bp和di.</li><li>指令沒有顯性給出段地址，段地址就默認在SS中。</li></ul><p>處理的數據在什麼地方</p><p>機器指令不關心數據的值多少，而關心指令執行前一刻，它將要處理的數據所在的位置。指令執行前，處理的數據可以在3個地方：CPU內部、內存、端口（後面介紹）</p><p>彙編語言中數據的表達</p><ul><li>立即數：直接在包含在機器指令中的數據（執行前在CPU的指令緩衝器中），稱為立即數（idata)</li><li>寄存器：數據在寄存器中，給出寄存器名使用</li><li>段地址（SA）和偏移地址（EA）：段地址默認在DS中，若BP做為有效地址的一部分，段地址默認在SS中，可以顯性給出段寄存器</li></ul><p>尋址方式</p><p>數據存放在內存中的時候，可是用多種方式給定這個內存單元的偏移地址，這種定位內存單元的方法一般被稱為尋址方式。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4455638b3f045e0be2d0cbbe1b59962><p class=pgc-img-caption></p></div><p>指令的數據有多長</p><p>8086CPU中，可以處理兩種尺寸的數據，byte和word。所以在機器指令中要指明，指令進行的是字操作還是字節操作。</p><ul><li>通過寄存器指明要處理的數據的尺寸，mov ax,1與mov al,1</li><li>沒有寄存器時，用操作符指明：X ptr指明內存單元長度，X可以為word或byte</li></ul><p>順便說一下，[bx].10h[si]=[bx+16+si]。</p><p>div指令</p><p>div是觸發指令</p><ul><li>除數：有8位和16位兩種，在一個reg或內存單元中</li><li>被除數：默認放在AX或DX和AX中</li><li class=ql-indent-1>如果除數為8位，則被除數則為16位，默認在AX中存放</li><li class=ql-indent-1>如果除數為16位，被除數為32位,在DX和AX中存放，DX存放高16位，AX存放低16位</li><li>結果</li><li class=ql-indent-1>如果除數為8位，AL存儲除法操作的商，AH存儲除法操作的餘數</li><li class=ql-indent-1>如果除數為16位，AX存儲除法操作的商，DX存儲除法操作的餘數</li></ul><p>單純看這段話容易看懵，在debug模式中試驗下。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e8727dbdb9734357bd65493f4747bc64><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0b061135183429e92f3b725ec95c0d2><p class=pgc-img-caption></p></div><p>說明，這裡演示的是$\frac{16}{3}=5\cdots\cdots1 $,其中16的部分在指令中我使用的是十六進制”10H“。</p><p>偽指令dd</p><p>前面使用db和dw定義字節型數據和字型數據。dd用來定義dword(double word，雙字)型數據</p><p>偽指令dup</p><p>dup是一個操作符，同db、dw、dd等一樣，也是由編譯器識別處理的符號。配合db、dw、dd等數據定義偽指令使用，用來進行數據的重複。</p><p>使用的格式如下</p><pre>123db 重複的次數 dup （重複的字節型數據）dw 重複的次數 dup （重複的字型數據）dd 重複的次數 dup （重複的雙字型數據）</pre><p>實驗七</p><p>這裡基本將所有的知識都運用起來了，筆者自己做的時候感覺自己好渣，想不出來。還是需要進行分析，理解數據從哪裡來，到哪裡去，中間做了什麼。</p><p>題目是將data中的年、收入、計算的人均收入寫到table段中。直接給代碼。</p><div class=pgc-img><img alt=彙編乾貨第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f5fb81517a814614ba67a047b6ca5866><p class=pgc-img-caption></p></div><ul><li>年份的傳遞，可以使用寄存器，使用棧明顯是更好的選擇</li><li>使用相應的寄存器存儲偏移量，可以使用[bx+idata]訪問數據節省寄存器</li><li>除法運算中被除數為雙字，使用AX、DX分別存儲低16位和高16位，將AX中的商傳遞到Table段</li></ul><p>實驗的反思</p><p>這個實驗的段名彷彿在暗示什麼，回顧我們做了什麼，我們將零散的數據結構化，使數據閱讀性提升，使用偏移地址訪問非常遍歷。換句話說，如果編寫程序時，將數據結構化，程序效率也將提升。程序的效率與數據組織的合理不合理有關，有一門課程叫數據結構，講的就是這麼個問題。</p><p>本質上可以歸納為對數據的組織，而下一章轉移指令的原理，本質上是對代碼的組織。</p><p>總結</p><p>前兩章的介紹都是為了理解數據在內存中如何排列，後一章理解數據在處理過程中的細節。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編乾貨</a></li><li><a>第三章</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/918bb543.html alt=還沒想好名字（第三章） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/918bb543.html title=還沒想好名字（第三章）>還沒想好名字（第三章）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c7c678a.html alt=《道路工程》第三章第四節第五節知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c7c678a.html title=《道路工程》第三章第四節第五節知識點>《道路工程》第三章第四節第五節知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd529d1.html alt="第三章 踩蹺法的常用套路" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd529d1.html title="第三章 踩蹺法的常用套路">第三章 踩蹺法的常用套路</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/78d3c63.html alt="《唐末宣宗之死》第三章 善心囑託" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1f1fa67fafe41f1bebd37acef2e27a8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/78d3c63.html title="《唐末宣宗之死》第三章 善心囑託">《唐末宣宗之死》第三章 善心囑託</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>