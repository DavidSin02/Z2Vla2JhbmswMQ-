<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>前端使用FileReader 讀取本地文件和校驗文件唯一 | 极客快訊</title><meta property="og:title" content="前端使用FileReader 讀取本地文件和校驗文件唯一 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/cdcad911-f12b-41e5-b6d2-5105f6e8f79e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53962e7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53962e7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/53962e7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53962e7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53962e7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/53962e7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/53962e7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53962e7.html><meta property="article:published_time" content="2020-10-29T21:08:25+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:25+08:00"><meta name=Keywords content><meta name=description content="前端使用FileReader 讀取本地文件和校驗文件唯一"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/53962e7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>前端使用FileReader 讀取本地文件和校驗文件唯一</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/cdcad911-f12b-41e5-b6d2-5105f6e8f79e><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>故事背景</h1><p>昨天下午被問到一個問題：oss 對象存儲裡邊由於有些圖片被共享，導致上傳了很多的重複的圖片或者文件，有沒有辦法在上傳之前判斷一下這個文件是否被上傳過，如果上傳過直接去後端拿存儲的地址行不行。</p><p>當時被問到的時候，第一反應是根據file的文件類型名稱和大小生成一個MD5，後來被否決了，假如文件改了名字的話，這個文件還是會被上傳上去</p><p>然後通過一天的調研，學習了這個之前沒有用過的FileReader對象，順便被他的其他方法給吸引住了，今天這裡分享一下</p><p><br></p><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/0418e13d-8859-45af-9d79-53590303db54><p class=pgc-img-caption></p></div><p><br></p><p class=pgc-end-literature>轉載鏈接：https://segmentfault.com/a/1190000022113605</p><h1 class=pgc-h-arrow-right>是什麼FileReader</h1><blockquote><p><strong>FileReader</strong> 對象允許Web應用程序異步讀取存儲在用戶計算機上的文件（或原始數據緩衝區）的內容，使用File或Blob</p><p><strong>Blob</strong> 對象表示一個不可變、原始數據的類文件對象。Blob 表示的不一定是JavaScript原生格式的數據。</p><p><strong>File</strong> 接口基於Blob，繼承了 blob 的功能並將其擴展使其支持用戶系統上的文件。") 對象指定要讀取的文件或數據。</p><p>其中File對象可以是來自用戶在一個 <strong>input</strong> 元素用於為基於Web的表單創建交互式控件，以便接受來自用戶的數據; 可以使用各種類型的輸入數據和控件小部件，具體取決於設備和user agent元素上選擇文件後返回的FileList對象,也可以來自拖放操作生成的DataTransfer對象,還可以是來自在一個HTMLCanvasElement上執行mozGetAsFile()方法後返回結果。(MDN)</p></blockquote><p>說白了就是<strong>FileReader</strong>對象可以對內存中的數據進行操作</p><p>然後需要知道一個重點就是</p><h1 class=pgc-h-arrow-right>FileReader僅用於以安全的方式從用戶（遠程）系統讀取文件內容 它不能用於從文件系統中按路徑名簡單地讀取文件。</h1><p>也就是說他是不可以直接用本地的路徑去讀取文件的，可以請求後端的資源，來讀取對應的文件，或者前端以一個比較安全的方式讀取文件，常見的比如說input的文件上傳</p><h1 class=pgc-h-arrow-right>FileReader 的屬性</h1><p>打印一下 如圖</p><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/22194ef3c5324873924de54ee71887b0><p class=pgc-img-caption></p></div><pre><code>EMPTY: 0LOADING: 1DONE: 2</code></pre><p>這三個是對象實例的狀態，分別是未讀取文件，正在讀取和讀取完畢</p><pre><code>    readyState: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    result: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    error: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]</code></pre><p>然後這三個屬性</p><ul><li>readyState，這個是獲取當前對象實例的狀態</li><li>result，這個是讀取文件成功之後的返回值，具體的返回值是根據，你調用的對象實例的方法而返回的，下邊我會講一下FileReader的方法的具體使用</li><li>error，顯而易見，報錯的時候的信息</li></ul><pre><code>    onloadstart: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    onprogress: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    onload: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    onabort: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    onerror: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    onloadend: [Exception: TypeError: Illegal invocation at FileReader.invokeGetter (&lt;anonymous&gt;:1:142)]    </code></pre><ul><li>onloadstart 讀取開始時觸發，這裡可以做一些常用的處理 比如加載loading什麼的</li><li>onprogress 這個事件就比較讓人喜歡了，這個方法會在文件被讀取的過程中被觸發，每大概11927552字節左右會被觸發一次，這個裡邊會反給一個ProgressEvent 對象，這個對象裡邊有本次讀取文件的最大字節數和已經讀取完畢的字節數，可以用來做進度條什麼的</li><li>onload 這個事件是文件讀取成功的時候觸發 ，在這裡裡邊可以使用上邊說道的實例上邊的result屬性，查看你操作的函數的對應的內容</li><li>onabort 讀取文件被終端的時候觸發，與之對應的有一箇中斷讀取的方法</li><li>onerror 讀取文件失敗的時候觸發</li><li>onloadend 讀取文件 不管失敗還是成功都會觸發這個方法，這個方法的執行時機在onload方法之後</li></ul><h1 class=pgc-h-arrow-right>FileReader 的方法</h1><ul><li>readAsDataURL ， 這個方法會返回一個你得到的這個對象的一個base64的地址，但是這個地址，你會發現你的文件越大，這個地址就越長，其實這個地址是一個Base64編碼的文件數據字符串</li></ul><p>然後之前說了FileReader所有的操作都是異步的，所以你並不能像下邊這樣獲取返回值</p><pre><code>        let fileReader = new FileReader()        let url = fileReader.readAsDataURL(file.file)        console.log(url)</code></pre><p>這樣是打印不出來的，你需要在他自身的處理事件上邊回調獲取</p><pre><code>        let fileReader = new FileReader()        fileReader.readAsDataURL(file.file)        fileReader.onload=()=&gt;{            console.log(fileReader.result)        }</code></pre><p>回調結果在對象實例的result屬性上邊，上邊有說過</p><ul><li>readAsBinaryString 開始讀取指定的Blob中的內容。一旦完成，result屬性中將包含所讀取文件的原始二進制數據。</li></ul><p>這個方法獲取的結果是原始二進制數據，不能直接使用，還需要做一些轉換或者使用標籤什麼得才能用，打印出來大概是這樣的</p><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cfdeb65dc3d04aafb77e3097eeced273><p class=pgc-img-caption></p></div><ul><li>abort 這個是中斷文件的讀取，比如你覺得這個讀取的事件有點長，再或者在某個特定情況下你希望他停下來，那麼這個時候可以使用這個方法中斷他，並且使用這個方法之後fileReader對象的狀態是DONE 也就是說可以在onload裡邊去獲取已經讀取的數據</li></ul><h1 class=pgc-h-arrow-right>readAsArrayBuffer</h1><ul><li>最後這兩個是我今天用到的方法readAsArrayBuffer 開始讀取指定的Blob中的內容, 一旦完成, result 屬性中保存的將是被讀取文件的 ArrayBuffer數據對象.這個ArrayBuffer上邊有mdn的傳送門可以看下，或者看一下阮一峰老師的es6最下邊的講解，他是一個字節數組，用來表示通用的、固定長度的原始二進制數據緩衝區他不能直接被操作，你可以用對應的<strong>TypedArray</strong>接口或者<strong>DataView</strong>的接口來操作他，這是一個對二進制字節數據操作的底層接口，我這裡使用了TypeArray</li><li>TypeArray的常用構造函數<strong>Int8Array</strong>：8 位有符號整數，長度 1 個字節。<strong>Uint8Array</strong>：8 位無符號整數，長度 1 個字節。<strong>Uint8ClampedArray</strong>：8 位無符號整數，長度 1 個字節，溢出處理不同。<strong>Int16Array</strong>：16 位有符號整數，長度 2 個字節。<strong>Uint16Array</strong>：16 位無符號整數，長度 2 個字節。<strong>Int32Array</strong>：32 位有符號整數，長度 4 個字節。<strong>Uint32Array</strong>：32 位無符號整數，長度 4 個字節。<strong>Float32Array</strong>：32 位浮點數，長度 4 個字節。<strong>Float64Array</strong>：64 位浮點數，長度 8 個字節。</li></ul><p>好，看到這裡，之前沒有接觸過的同學是不是腦瓜子嗡嗡的。。沒關係 我昨天我也嗡嗡的。。。</p><p><strong>簡單扼要的說一下就是說，上邊列出來的這九個構造函數，都會根據你傳進去的參數，生成一個對應的數組，然後這些數組統稱為TypeArray視圖，這個數組包含了所有的數組的方法和屬性，你可以像數組一樣去操作他們，一會我會在下邊打印一下他們的結果，看一下就知道了</strong></p><ul><li>然後上邊說的DataView，簡單說一下這個DataView是和<strong>TypedArray</strong> 配套使用的，因為DataView的參數是接受一個TypedArray對象,具體方法如下</li><li>讀取<strong>getInt8</strong>：讀取 1 個字節，返回一個 8 位整數。<strong>getUint8</strong>：讀取 1 個字節，返回一個無符號的 8 位整數。<strong>getInt16</strong>：讀取 2 個字節，返回一個 16 位整數。<strong>getUint16</strong>：讀取 2 個字節，返回一個無符號的 16 位整數。<strong>getInt32</strong>：讀取 4 個字節，返回一個 32 位整數。<strong>getUint32</strong>：讀取 4 個字節，返回一個無符號的 32 位整數。<strong>getFloat32</strong>：讀取 4 個字節，返回一個 32 位浮點數。<strong>getFloat64</strong>：讀取 8 個字節，返回一個 64 位浮點數。</li><li>寫入<strong>setInt8</strong>：寫入 1 個字節的 8 位整數。<strong>setUint8</strong>：寫入 1 個字節的 8 位無符號整數。<strong>setInt16</strong>：寫入 2 個字節的 16 位整數。<strong>setUint16</strong>：寫入 2 個字節的 16 位無符號整數。<strong>setInt32</strong>：寫入 4 個字節的 32 位整數。<strong>setUint32</strong>：寫入 4 個字節的 32 位無符號整數。<strong>setFloat32</strong>：寫入 4 個字節的 32 位浮點數。<strong>setFloat64</strong>：寫入 8 個字節的 64 位浮點數。</li></ul><h1 class=pgc-h-arrow-right>readAsText</h1><p>這個是之前的時候搞得一個讀取文件的方法，裡邊用到了FileReader的readAsText方法，不多說廢話了，直接附上代碼和效果圖</p><pre><code>export default function readFile(model) {    return new Promise((resolve) =&gt; {        // 谷歌        if (window.FileReader) {            // 獲取文件流            let file = model.currentTarget ? model.currentTarget.files[0] : model;            // 創建FileReader實例            let reader = new FileReader();            // 讀文件            reader.readAsText(file);            reader.onload = () =&gt; {                resolve(reader.result)            }        }        //支持IE 7 8 9 10        else if (typeof window.ActiveXObject != 'undefined') {            let xmlDoc;            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");            xmlDoc.async = false;            resolve(xmlDoc.load(model))        }        //支持FF        else if (document.implementation &amp;&amp; document.implementation.createDocument) {            let xmlDoc;            xmlDoc = document.implementation.createDocument("", "", null);            xmlDoc.async = false;            resolve(xmlDoc.load(model))        }    })}   //安裝依賴npm i zjsmethods -S~~~~// 頁面引入並使用 import { _readFile } from "zjsmethods"_readFile(file).then(res=&gt;{    console.log(res)})</code></pre><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5a1c22aae8ad4f3f85168268af4fe75e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>readAsArrayBuffer校驗文件唯一</h1><p>上邊說了那麼一大堆，終於要進入正題了哈，直接看第一版代碼</p><pre><code>    const reader = new FileReader();    reader.readAsArrayBuffer(file.file);    reader.onload = () =&gt; {           let u8Arr =  new Uint8Array(reader.result)           console.log(u8Arr)           console.log(md5(u8Arr))    }    </code></pre><p>ok 沒得問題，結果如下</p><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/42d8764a43b34caab4c13696e6689a78><p class=pgc-img-caption></p></div><p>正在我覺得如此簡單的時候，意外發生了，在我用比較小的文件的時候，只有1M 左右，但是當我上傳了一個視頻做測試的時候大概有兩個G，瀏覽器崩潰了。。崩潰了。。了</p><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/42e4ba8210094a22b9968d26dbe44f6a><p class=pgc-img-caption></p></div><p>然後我展開了 之前比較小文件的字節數組，大概有這麼大</p><div class=pgc-img><img alt="前端使用FileReader 讀取本地文件和校驗文件唯一" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e1441ca04484736b2397fad1326fe09><p class=pgc-img-caption></p></div><p>原因是readAsArrayBuffer在讀取文件的時候會先把整個文件加載到內存中，那麼如果文件太大，內存就不夠用了，瀏覽器進程就會崩潰。</p><p>既然整個加載不行，那麼我們選擇把一個文件分段加載，後來我覺得10M一段比較穩妥，於是改成了當文件小於10M的時候平均分成10段，如果大於10M ，那麼每10M 分成一段 直到分完為止，同樣為了避免加密的時候數據太多造成卡頓，在生成標識的時候放棄用整個數組生成標識，採取固定規則的最大10M 數據生成標識</p><pre><code>    async vaildArrayBuffer(){        const reader = new FileReader();        while(this.whileNumber--){            this.start = this.end            this.end = this.end+this.whileMax            let { start,end,sliceEnd,file}=this                reader.readAsArrayBuffer(file.slice(start,end));                reader.onload = () =&gt; {                        new Uint8Array(reader.result)                            .slice(0, sliceEnd)                            .join('')                }        }    }</code></pre><p>這個時候又出了一個小插曲，在調用的時候reader被提示，正在進行文件讀取，也是就一個reader在做讀取文件操作的時候不能同事讀取兩個，於是乎剛開始的時候我高估了讀取的速度放在了回調裡邊讀取文件，代價就是我在電腦前面眼巴巴的看了控制檯大概5分鐘，後來改成了promise包裹，最後整理出的代碼如下</p><pre><code>/* * @Date: 2020-03-22 16:36:37 * @information: 最後更新時間 */import md5 from 'md5'export default class vaileFile{    constructor(file){        this.file = file        // 每次截取多少二進制        this.whileMax = Math.floor(file.size / 10 &gt; 10240 * 1024 ?  10240 * 1024 : file.size / 10);        // 循環截取多少次        this.whileNumber = file.size &lt;= 10240 * 1024 ? 10 : Math.ceil(file.size/this.whileMax)        // 二進制的截取長度，超出10M後 每10M 截取一部分，最多10M        this.sliceEnd = Math.floor(1024 * 10240 / file.size * 100 / this.whileNumber * this.whileMax)        this.sliceEnd = this.whileNumber&gt;10?this.sliceEnd:10240 * 1024         // 轉換二進制的長度        this.start = 0         this.end = 0;    }    /**     * @Author: 周靖鬆     * @Date: 2020-03-22 15:53:07     * @information: 校驗文件唯一     */    async vaildArrayBuffer(){            let promiseArr = []            while(this.whileNumber--){                this.start = this.end                this.end = this.end+this.whileMax                let { start,end,sliceEnd,file}=this                let promiseArrayBuffer = new Promise((resolve,reject)=&gt;{                    const reader = new FileReader();                    reader.readAsArrayBuffer(file.slice(start,end));                    reader.onload = () =&gt; {                        resolve(                            new Uint8Array(reader.result)                                .slice(0, sliceEnd)                                .join('')                        )                    }                })                promiseArr.push(promiseArrayBuffer)            }            return md5((await Promise.all(promiseArr)).join(''))        }    }</code></pre><p>大功告成，上傳的文件後會生成一個md5 ，複製文件，文件改名字，都可以識別是之前的文件</p><p>然後寫一個README.md 說明一下使用方法</p><pre><code>### _vaileFile ，//使用文件二進制校驗文件唯一性    當有業務需要上傳oss 對象存儲的時候，為了避免同一個文件（視頻，音頻，圖片，壓縮包等），有可能其他人複製或者改名字等等，造成文件重複上傳，大量佔用空間，寫了一個校驗文件的方法    //安裝依賴    npm i zjsmethods -S        //引入這個類    import { _vaileFile } from 'zjsmethods'    //  然後在你需要判斷oss 是否有該文件的時候    new _vaileFile('file對象').vaildArrayBuffer().then(res=&gt;{        console.log(res)        // 繼續上傳 或者 向後端請求已經存在的文件url    })    // new 這個類之後 有一個vaildArrayBuffer 方法 他返回一個promise ,裡邊返回值是一個md5的字符串，這個是這個文件的唯一標識</code></pre><p>喜歡的點個贊吧，有不足之處歡迎斧正</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>文件</a></li><li><a>FileReader</a></li><li><a>讀取</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/438a5238.html alt=環境管理體系程序文件-文件控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/aaa460951e4e4b358966a6652c1d361f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/438a5238.html title=環境管理體系程序文件-文件控制程序>環境管理體系程序文件-文件控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0ffb976.html alt=不合格、糾正措施程序文件（ISO9001程序文件範本） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0ffb976.html title=不合格、糾正措施程序文件（ISO9001程序文件範本）>不合格、糾正措施程序文件（ISO9001程序文件範本）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16c259de.html alt=什麼是程序文件？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16c259de.html title=什麼是程序文件？>什麼是程序文件？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8c41b36.html alt=今天聊聊程序的文件的概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8c41b36.html title=今天聊聊程序的文件的概念>今天聊聊程序的文件的概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd79f8d.html alt=程序文件-ISO9001 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2e673ba29f5545fd8aea4073e1c638c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd79f8d.html title=程序文件-ISO9001>程序文件-ISO9001</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4526bc23.html alt=程序文件沒有用？管理全靠你盯著？也許是你對程序文件有誤解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f214b9-177d-4e1e-8ccd-1c3fe7c07fe5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4526bc23.html title=程序文件沒有用？管理全靠你盯著？也許是你對程序文件有誤解>程序文件沒有用？管理全靠你盯著？也許是你對程序文件有誤解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c81e50df.html alt=程序文件流程圖 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3a0300041dc3570ffec5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c81e50df.html title=程序文件流程圖>程序文件流程圖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48fac9bc.html alt=管理體系程序文件之文件控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48fac9bc.html title=管理體系程序文件之文件控制程序>管理體系程序文件之文件控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ffde15b2.html alt=質量管理體系程序文件--文件控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c4afea2228a24b0e81d79d622e633652 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ffde15b2.html title=質量管理體系程序文件--文件控制程序>質量管理體系程序文件--文件控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e68a385b.html alt=如何挑選合適的文件櫃？跟美格利生一起來看看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e0a2460d3344937bd8219a679ee2353 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e68a385b.html title=如何挑選合適的文件櫃？跟美格利生一起來看看>如何挑選合適的文件櫃？跟美格利生一起來看看</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02c33c9e.html alt=文件櫃定製有哪些方面需注意呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/966ef4ec8b7749b080bb564832a55c13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02c33c9e.html title=文件櫃定製有哪些方面需注意呢>文件櫃定製有哪些方面需注意呢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/64e0caa9.html alt=文件櫃的主要用途都有哪些呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/92909af8e5014e79bfa05c7a05cafcfa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/64e0caa9.html title=文件櫃的主要用途都有哪些呢>文件櫃的主要用途都有哪些呢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4c8c7f6.html alt=選擇哪種文件櫃儲存文件好呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b59db2e366841b6b757a77467e16b50 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4c8c7f6.html title=選擇哪種文件櫃儲存文件好呢>選擇哪種文件櫃儲存文件好呢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9621c7b8.html alt=都有哪些材質的文件櫃？各有什麼特點？這篇文章助你選對文件櫃 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/473ff5d12cb54f328e1d64db1d28fb33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9621c7b8.html title=都有哪些材質的文件櫃？各有什麼特點？這篇文章助你選對文件櫃>都有哪些材質的文件櫃？各有什麼特點？這篇文章助你選對文件櫃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10f6efe5.html alt=鋼製文件櫃的價格是多少呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4f025bc54b77411ab5582ba4f9fc70f2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10f6efe5.html title=鋼製文件櫃的價格是多少呢？>鋼製文件櫃的價格是多少呢？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>