<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性 | 极客快訊</title><meta property="og:title" content="設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1536400464147264a5443a5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/547fec10.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/547fec10.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/547fec10.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/547fec10.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/547fec10.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/547fec10.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/547fec10.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/547fec10.html><meta property="article:published_time" content="2020-11-14T21:01:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:42+08:00"><meta name=Keywords content><meta name=description content="設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/547fec10.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>互聯網發展的如此之好，以至於很多人把它當作像太平洋一般的自然資源，而非人造事物。上一次出現造成這種錯覺的規模技術是什麼時候？ —Alan Kay, in interview with Dr Dobb’s Journal (2012)</p><p>現在很多應用是數據密集型的，與計算密集型應用不同，這些應用的限制因素很少是因為CPU能力，而通常是數據體量、數據複雜度以及數據變化速度。</p><p>數據密集型應用通常由提供通用功能的標準組件（standard building blocks）構建。例如，很多應用需要：</p><ul><li>存儲數據以方便本應用及其他應用後續查找數據（數據庫）</li><li>記錄複雜操作的結果以加速讀（緩存）</li><li>允許用戶按照關鍵詞查詢或者以多種方式進行篩選（查詢索引）</li><li>定期將大量累積數據碎片化（批處理）</li><li>如果這些聽起來令人痛苦，那是因為數據系統是如此成功的一種抽象：我們一直在使用它卻很少思考它。當構建應用的時候，大部分工程師不會試圖去自己寫一個全新的數據存儲引擎，因為數據庫可以很好的完成工作。</li><li>但是實際上事情並沒有這麼簡單，因為不同的應用滿足不同的需求，各種數據庫系統有不同的特徵。緩存的方式是多種多樣的，創建查詢索引的方法是多種多樣的，諸如此類。在構建應用的時候，我們任然需要去決策哪些工具，哪些策略對於我們現在所處理的工作是最適合的。而且當單一工具無法完成我們的工作的時候，組合運用多種工具也並非易事。</li><li>在本節，我們以想要達到的目標開始進行探索：可靠，可擴展，可維護數據系統。我們將會澄清這些概念的意義，整理理解這些概念的方法，為後面的章節打下基礎。在後面的章節中將會層層展開，看一下在構建數據密集型應用的時候，哪些因素是需要考慮的。</li></ul><h2>關於數據系統</h2><p>我們通常認為數據庫、消息隊列、緩存等是非常不同的幾種工具。儘管一個數據庫和一個消息隊列一列非常重要的相似點，兩者都存儲一段時間的數據，但是他們擁有截然不同的訪問模式，這意味著不同的性能特徵和截然不同的應用場景。</p><p>那麼為什麼我們還把他們放在同一種概念中進行考察呢，比如說數據庫系統？</p><p>近些年出現了很多新的數據存儲和運算工具。它們針對一些特殊的一定用場景進行了優化，我們也很難將它們整齊地歸納到傳統的類別中。比如有些數據存儲工具經常被當作消息隊列使用（Redis），也有些消息隊列具有數據庫持久化能力（Kafka）。不同種類之間的界限正在逐漸變得模糊化。</p><p>其次，越來越多應用需要滿足各種維度的需求，單一的工具已經無法滿足它們的數據計算和存儲需要，所以，應用中的任務會被分解成為各個task分發到對應的單一工具中執行解決，這些工具通過應用編號彼此鏈接。</p><p>比如，如果一個應用擁有一個它管理的緩存層（用Memcached或者其他工具實現），或者有一個全文本檢索服務（比如Elasticsearch或者Solr）部署在應用的主存儲中，那麼通常來講，應用編碼（application code）的責任就是去保證緩存和索引與主存儲是同步的。圖1-1展示了這種關係的示意圖（在後續的章節中會詳細講述）。</p><div class=pgc-img><img alt="設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1536400464147264a5443a5><p class=pgc-img-caption></p></div><p>圖1-1. 一種包含多種總監的可用數據系統架構</p><p>當你組合各種工具去構建一種服務時，服務接口或者應用程序接口（API）通常隱藏在客戶端的實現細節中。現在你本質上是基於通用的更小組件構建了一個全新的，具有特定用途的數據系統。你的複合數據系統可能能夠提供特性的保證，比如說能夠在數據寫入過程中能夠有效清理或者升級緩存，以保證外界客戶端能夠讀取到一致性的結果。那麼你現在就不再僅僅是一個應用開發者，也是一個數據系統設計者。</p><p>如果你正在設計一個數據系統或者一種數據服務，那麼你將面臨很多小問題的來臨。你如何在正常或者內在錯誤發生情況下保證數據的正確性和完整性，如何為客戶端持續提供良好的性能，面對負載的增加你該採取怎樣的擴展策略，在服務端一個好的API是如何定義的？</p><p>有很多因素會影響數據系統覺得設計，包括相關人員的技術能力和相關經驗，遺留系統覺得依賴性，交付的時間週期，你所在組織對於各種各樣風險的承受能力，監督約束條件等等。這些因素變動不居，非常依賴於具體情勢。</p><p>在本書中，我們主要關注在大多數軟件系中都非常重要的三個因子。</p><p>可靠性</p><p>系統應該持續正確工作（以期望覺得性能水平正確執行功能），即使在災難中（硬件或者軟件錯誤，甚至是認為錯誤）也能保持如此。</p><pre>可擴展性 應該能夠合理地處理系統的增長（數據量級，交互量級和複雜度）。</pre><p>可維護性</p><pre> 隨著應用運行時間的增長，不同的人群會在系統上工作（工程師和操作員，兩者均能夠保持當前的操作並將系統應用於新的應用場景），系統要能夠保證他們工作的有效性。</pre><p>這些概念在並沒有明確其含義的情況下已經廣為傳播。我們將會在接下來的章節中，以工程師的視角來探索可靠性，可擴展性和可維護性的意義。然後，我們會能夠實現這些目標的不同技術，架構和算法進行說明。</p><h2>可靠性</h2><p>每個人對於可靠和不可靠都有自己主觀的認知。在軟件領域，可靠通常包括：</p><ul><li>應用以用戶期望的方式運行</li><li>應用能夠容忍用戶犯錯誤或者以錯誤的方式使用軟件</li><li>在期望的數據量級和負載下，應用能夠在需要的場景中擁有足夠好的性能表現</li><li>系統能夠阻止未獲認證的訪問和攻擊</li><li>如果這些加在一起意味著正確工作的話，那麼我們可以大致將可靠性理解為“持續正確工作，即使情勢不佳”。</li><li>“情勢不佳”就是我們通常所說的錯誤，能夠預知錯誤並且能夠處理錯誤的系統我們稱之為容錯的（fault-tolerant）或者有彈性的（resilient）。以上的描述會引起一些誤解：它意味著我們可以創造系統能夠容忍的任何錯誤，這在實際上是不可能的。如果整個地球被黑洞吞噬了，對這種錯誤的容忍性需要將主機部署在太空，那麼首先你要足夠幸運能夠獲得項目的預算。所以將容忍性侷限在特定類型錯誤上進行討論才是有意義的。</li><li>需要說明的是，錯誤（fault）並不等同於失敗（failure）。錯誤通常意味著系統的某些組件偏離了它正常的運行軌道，而失敗則意味著系統停止對用戶提供他們期望的服務。將錯誤降低到0是不可能的，所以最好設計容錯機制組織錯誤導致失敗。本書講了幾種基於不可靠組件構建可靠系統的技術。</li><li>與常識相反，在這樣的容錯系統中，通過故意觸發提高錯誤率是有意義的，比如在沒有警告的情況下隨機殺掉系統的進程。許多致命的bug都是因為錯誤的處理機制導致的。通過故意觸發錯誤，你可以確保容錯機制被不斷的訓練和測試，這有助於提高你對錯誤自然發生時應用正確處理能力的自信心。Netflix Chaos Monkey正是採取這種方法的事蹟案例。</li><li>儘管相比阻止錯誤發生，我們更經常採用提高容錯能力的方法，但是在有些情況下，阻止比治癒更好（因為有些情況下根本沒有治癒這一說）。在關於安全的領域內，阻止明顯是更好的方法，比如說，如果一個attacker 侵入了一個系統並且獲得了敏感數據，這個事情便是不可挽回的。但是如下面章節所講，本書提及的大多數是可以治癒的錯誤。</li></ul><h4>硬件錯誤</h4><p>當提到系統失敗原因的時候，首先浮出腦海的便是硬件錯誤。硬盤奔潰，內存錯誤，電源損壞，網線錯拔等。凡是接觸過大型數據中心的工作人員會告訴你，只要是你擁有大量的設備，這些問題幾乎每時每刻都在發生。</p><p>據報道，硬盤的平均出故障時間（MTTF）大約是10到50年。所以如果有一存儲集群擁有10000塊硬盤，那麼我們可以推測這個集群平均每天會有一塊硬盤掛掉。</p><p>對於硬件錯誤，首先想到的策略是對硬件組件做冗餘備份，從而降低硬件錯誤造成系統失敗的可能性。硬盤可以做RAID配置，服務器可以做雙電源和熱插拔CPU，數據中心可能有用於做備用電源的電池和柴油發動機。當一個組件掛掉，備用組件可以替代它繼續工作。這種方法不能完全阻止硬件問題導致系統失敗，但是容易理解而且通常可以保持一臺設備運行數年而不宕機。</p><p>直到現在，硬件組件備份在大多數應用中都是有效且意義重大的，因為它使得單機奔潰的可能性極小。只要您能夠相當快地將備份恢復到一臺新機器上，在大多數應用程序中，故障發生的停機時間都不是災難性的。因此，只有那些高可用性要求較高的應用才需要做多機器冗餘備份。</p><p>但是，隨著數據量級和計算能力要求的提高，越來越多的應用已經開始用大量的機器，這顯而易見也就增加了硬件錯誤出現的機率。此外，在一些像Amazon Web Services (AWS) 一樣的雲平臺，沒有任何的警示的情況下一臺雲主機就不可用了的情況是非常常見的，因為平臺首先考慮的是靈活性和伸縮性，而非單臺機器的可靠性。</p><p>因此有一種向可以容忍機器丟失的系統的轉變，這種系統通過使用軟件容錯技術或者在硬件備份的基礎上使用軟件容錯技術來實現。這種系統也具有明顯的有時：單機系統在重啟（如打安全補丁）的時候需要計劃停機，但是在可以容忍機器錯誤的系統可以每次為一臺設備打補丁，從而不用將整個系統停機（見第四節）。</p><h4>軟件錯誤</h4><p>我們通常認為硬件錯誤是隨機的，設備與設備之間也是相互獨立的：一臺設備硬盤問題並不意味著其他設備的硬盤也出現問題。他們之間也有可能存在微弱的聯繫（比如因為機架溫度等常見原因），但是大規模硬件組件同時掛掉也是不大可能的。</p><p>另一種錯誤是系統內在的系統性錯誤。這種錯誤更難預測，因為它們是跨節點的，它們也比硬件錯誤導致更多的系統失敗。實例包括：</p><ul><li>當給定一個特定的異常輸入時，一個軟件bug會導致每個應用服務實例奔潰。比如在2012年6月30日，linux內核將時鐘額外增加一閏秒導致很多應用同時掛起。</li><li>一個跑飛的程序用盡了共享資源——CPU時間，內存，硬盤空間或者帶寬。</li><li>系統依賴的服務變慢，無響應或者返回異常結果。</li><li>級聯錯誤，某一個組件的小錯誤引發另一個組件的錯誤，進而觸發更多的錯誤。</li><li>能夠導致這些軟件錯誤的bug通常會存活很長時間直到被異常場景觸發。在這些場景下，軟件試圖對環境做出某種猜測——正常情況下猜測應該時正確的，但是因為某些原因，它猜錯了。</li><li>軟件的系統性錯誤並沒有快速的解決辦法。很多小技巧可能能夠提供幫助：深思熟慮系統做出的各種假設和組件間的相互作用；嚴格進行軟件測試；進程隔離；允許進程奔潰和重啟；測量、檢測和分析生產過程中的系統行為。如果一個系統要提供一些保證（比如，在消息隊列中，入隊和出隊的數據量應該是一致的），那麼它應該能夠在運行過程中做到自我監測，當發現異常時能夠發出警告。</li></ul><h4>人為錯誤</h4><p>人類設計和構建了軟件系統，同時人類也是保持系統持續運行的操作者。但是人類從來都不是十分靠譜的，例如據統計，人為配置錯誤是導致斷電事故的主要原因，而硬件錯誤（服務器或者網絡）只佔了斷電事故原因的10-25%。</p><p>儘管人類是不可靠的，我們可以採取以下手段來保證系統的可靠性。</p><ul><li>以最小化錯誤出現概率的方法設計系統。例如，良好的抽象，API和管理接口降低做正確事情的難度而提高做錯誤事情的難度。但是如果接口限制過多，人們會刻意避免使用它而對它的優點視而不見，所以如何在易用性和保證正確性之間取得平衡也並非易事。</li><li>將人們容易犯錯的環境和容易導致失敗的環境解耦。可以為人們提供擁有系統完整特性的非生產沙箱環境，人們可以在沙箱環境中安全地進行開發和測試，使用真實的數據卻不影響真實的用戶。</li><li>從單元測試到全系統集成測試和手工測試，在所有的層級全方位測試。自動化測試被廣泛使用，很好理解，對於在正常操作中很少出現的邊界案例尤其具有價值。</li><li>允許從人為錯誤中快速而容易地恢復，以儘量減少失敗的影響。例如，快速地回滾配置更改，逐步推出新代碼（這樣，任何意外的bug都會隻影響到一小部分用戶），並提供重新計算數據的工具（以防舊的計算結果是不正確的）。</li><li>建立詳細和清晰的監視，例如性能指標和錯誤率。在其他工程學科中，這被稱為遙測技術。（一旦火箭離開地面，遙測技術對於追蹤正在發生的事情和理解失敗是至關重要的。）監控可以向我們顯示早期預警信號，並允許我們檢查是否有任何假設或約束被違反了。當出現問題時，度量標準對於診斷問題是非常有價值的。</li><li>進行良好的管理實踐和培訓——這是一個複雜而重要的方面，超出了本書的範圍。</li></ul><h4>可靠性的重要性</h4><p>可靠性不僅適用於核電站和空中交通控制軟件——普通的應用程序也應該可靠地工作。業務應用程序中的bug會導致生產力的損失（如果信息被錯誤地報告，則會帶來法律風險），而電子商務網站的中斷可能會造成收入損失和聲譽受損，成本巨大。</p><p>即使在“非關鍵”應用程序中，我們也有責任保證應用是可靠的。想象以下，一個家長在你的照片應用程序中存儲了他們孩子的所有照片和視頻。如果那個數據庫突然損壞了，他們會有什麼感覺？他們知道如何從備份中恢復它嗎？</p><p>有些情況下,我們可能會選擇犧牲可靠性以減少開發成本(例如,為未知市場開發一個原型產品)或運營成本(例如,一個利潤率非常小的服務)，但是我們應該對於這種偷工減料的做法保持謹慎和警醒。</p><h2>可擴展性</h2><p>即使系統今天可靠地運行，也並不代表未來它會一直穩定運行。系統退化的一個比較常見的原因便是負載變重：也許併發用戶量從10000增長到100000，或者從一百萬增長到一千萬，也許程序處理的數據量猛增。</p><p>我們用擴展性來描述一個系統處理遞增負載的能力。但是，不得不提的是擴展性並不是一種單維的指標，X可擴展或者Y可擴展的說法是沒有意義的。擴展性意味著我們對以下問題進行思考，如果系統以一種特定的方式增長，我們應該如何應對這種增長，或者，我們應該如何增加計算資源去應對額外的負載。</p><h4>關於負載</h4><p>首先，我們應該量化系統負載的現狀，只有這樣討論負載增長才有意義（如果我們的負載翻倍會發生什麼？）。負載可以使用集中負載參數(load parameters)來進行量化。最優負載參數取決於系統的架構：它可能WEB服務器每秒的請求數、數據庫中的讀寫比率、聊天室中同時活躍用戶量、緩存命中率或其他東西。也許平均值對你來說是最關注的參數，業務少量的邊界值對你來說又至關重要。</p><p>為了更加具體的描述這些概念，我們拿Twitter為例，使用2012年11月發佈的數據。Twitter包含兩個主要業務：</p><ul><li>發佈tweet消息</li><li>用戶可以向其追隨者發佈一條新消息（平均4.6 k請求/秒，峰值超過12 k請求/秒）。</li><li>訪問時間線主頁</li><li>用戶可以查看他們關注的人所發佈的推文（300 k請求/秒）。</li></ul><p>每秒12000個簡易寫操作（發佈tweet的峰值速率）是相當容易的。然而，Twitter的規模挑戰並不主要是由於推文的數量，而是由於粉絲的數量——每個用戶都有很多粉絲，這些用戶同時又是很多人的粉絲。事先這兩種操作大致有兩種方式：</p><p>1、發佈tweet的時候將消息錯處到一個全局的tweet集合中。當一個用戶請求訪問時間線主頁時，遍歷所有他關注的人並且找到他們每個人發佈的所有tweets，對這些tweet進行合併（按照時間進行排序）。在如圖1-2所示的關係數據庫中，你可以編寫如下的一個查詢：</p><pre>SELECT tweets.*, users.* FROM tweets JOIN users ON tweets.sender_id = users.id JOIN follows ON follows.followee_id = users.id WHERE follows.follower_id = current_user</pre><p>2、為每個用戶的時間線主頁保存緩存，就好像是每個tweeter用戶都擁有一個郵箱（如圖一1-3）。當一個用戶發佈一個tweet的時候，遍歷所有關注這個用戶的人，並且將新發布的tweet放入關注者的緩存中。這樣的話，瀏覽時間線主頁的成本就會降低，因為結果在瀏覽之前就已經計算好了。</p><div class=pgc-img><img alt="設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153640046434467b5891b00><p class=pgc-img-caption></p></div><p>圖1-2：實現主頁存儲的簡易表結構</p><div class=pgc-img><img alt="設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1536400464086de55fbc4bc><p class=pgc-img-caption></p></div><p>圖1-3：通過消息隊列將tweet推送給粉絲</p><p>Twitter的第一個版本採用方法1，但是系統難以跟上時間線主頁查詢的負載，所以公司轉向了方法2。這樣做的效果更好，因為發佈tweet的平均速率比主頁讀取速度要低兩個數量級，在這種情況下，應該將更多的操作放到寫操作中而簡化讀操作。</p><p>但是第二種方法的弊端是，當發佈一條tweet的時候需要太多的額外工作量。平均情況下，一條tweet會被送往75個粉絲那裡，所以4.6k/s的tweet緩存寫入量被擴大為345k/s的寫入量。而且，這種平均值也隱藏了一個事實，即每個用戶的追隨者數量差別很大，有些用戶甚至擁有300萬粉絲。這就意味著一條tweet發佈有可能會導致300萬次寫操作。在規定的時間內（tweeter嘗試在5s內將tweet傳送給粉絲）完成這項工作挑戰巨大。</p><p>在Twitter的例子中，一個用戶的粉絲分佈情況是可擴展性關鍵的負載參數（可能根據用戶的推文頻率來衡量），因為它決定了粉絲量負載。你的應用程序可能擁有截然不同的特性，但是同樣可以應用類似的原理堆負載進行推理。</p><p>Twitter實例的最後一個發展是：既然方法2得到了有效實施，Twitter正在促進兩種方法的融合。在發佈推文時，大多數用戶的推文仍然會傳遞到粉絲的時間線主頁，但是如果一個用戶擁有龐大的粉絲群（例如名人），則不會對他的消息採取這種策略。用戶關注的任何名人的推文都是單獨獲取的，在該用戶獲取名人推文的時候，推文會如方法1一樣和該用戶的時間軸主頁進行合併。這種混合方法能夠提供持續良好的性能。在我們討論了更多基礎技術之後，我們將在第12章重新討論這個例子。</p><h4>關於性能</h4><p>一旦你能夠量化負載，就可以研究負載增大對系統的影響。你可以從兩方面看待這個問題。</p><ul><li>保持系統資源不變（CPU,內存，網絡帶寬等）的前提下增加一個負載參數，看系統性能會如何發生變化。</li><li>當一個負載參數增加後，應該如何系統資源才能保證性能不受影響。</li><li>這兩個方面都需要考察性能數據，那麼我們首先來簡單描述一下系統性能。</li><li>在像Hadoop這樣的批處理系統中，我們通常關注吞吐量（throughput），也就是每秒可以處理記錄數或者固定數據集所需的處理時間。而在線系統更加看重的相應時間，也就是客戶端發送請求和得到迴應之間的時間差。</li></ul><pre>延遲和響應時間通常是同義的，但是它們並不相同。響應時間是從客戶端來看的：除了處理請求的實際時間（服務時間）之外，它還包括網絡延遲和排隊延遲。延遲是請求等待處理的持續時間，在等待的時候並沒有進行請求處理。</pre><p>即使一次次發送同樣的請求，每次請求的響應時間也會有微弱的差異。實際上，一個處理大量請求的系統中，響應時間有很大的差別。所以我們不能把響應時間當做是單一的數值，而要看做可度量的值的分佈。</p><p>在圖1-4中，每一個灰色的柱子代表一個服務的響應，柱子的高度代表相應時間的長短。圖中大部分的請求響應很快，但是也存在一些響應較慢的離群值。也許請求緩慢是因為他們本質上所需的時間就長，比如說因為他們需要處理更多的數據。但是即使在一個你認為響應時間應該一致的環境下，響應時間依然會有差異：當後臺進程切換的時候回引入隨機附加延遲，網絡數據包和TCP傳輸成本，垃圾回收引起的暫停，一個頁面錯誤引起的磁盤讀操作，服務器機架的機械振動等，或許還有更多其他的原因。</p><div class=pgc-img><img alt="設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153640046417933a231997b><p class=pgc-img-caption></p></div><p>圖1-4：100個服務請求的響應時間實例</p><p>服務的平均響應時間經常被提及（嚴格地說，“平均值”這個詞並不指代任何特定的公式，但在實踐中，它通常被理解為算術平均數：n個值之和除以n）。但是，如果你想知道服務的“典型”響應時間，那麼平均值並不是一個很好的度量標準，因為它並不能告訴你有多少用戶經歷了這種延遲。</p><p>用分位數來描述會更好一些。如果你講響應時間按照從快到慢進行排序，那麼中間的數值就是中位數：例如，如果中位響應時間是200ms，那麼就意味著一半的響應時間少於200ms，一半的響應時間高於200ms。</p><p>如果你想知道用戶“典型”的等待時間，中位數是一個很好的參考標準：一半的用戶需要等待比中位數更短的時間，其他的一半則需要等待比中位數更長的時間。中位數也稱作50分位，簡稱p50。需要注意的是，中位數指的是單個請求，如果用戶提出了多個請求（在會話過程中，或者一個頁面包含了多個資源），那麼這些請求中至少有一個有很大概率會慢於中位數。</p><p>為了描述哪些離散點到底有多糟糕，你可以查看更高的分位數：通常用95分位，99分位或者99.9分位（簡稱p95,p99和p999）。它們分別表示95%，99%和99.9%的響應時間快於的數值。比如說，95分位數對應的響應時間是1.5s，那麼就意味著100個請求中有95個請求響應時間快於1.5s，5個請求耗費了1.5s或者更多。這些概念在圖1-4中也有體現。</p><p>尾部延遲，也就是高分位數對應的相應時間是很重要的，因為它們直接影響用戶對服務的體驗。例如，Amazon以99.9分位數來描述內部服務的響應時間需求，即使它隻影響1,000個請求中的1個。這是因為那些擁有最慢請求的客戶通常是賬戶中數據量最大的用戶，即購買了很多次東西的用戶，也就是說，他們是最有價值的客戶。通過提高他們瀏覽網頁的速度來獲得他們的滿意是非常重要的，亞馬遜還發現，響應時間每增加100 ms，銷售額就會減少1%，另有報道稱，1秒的放緩會導致客戶滿意度指標降低16%。</p><p>另一方面，優化99.99分位數（10000個請求中最慢的那一個）對於亞馬遜來說確實成本太高了，而且也並不能帶來太高的經濟收益。降低高分位數對應的響應時間非常困難，因為它很容易被超出你控制範圍之外的隨機事件所影響，而且收益也不高。</p><p>比如說，百分位數通常用於服務水平目標（SLOs）和服務水平協議（SLAs），這些約定定義了服務的預期性能和可用性。一個SLA可能意味著，如果一個服務平均響應時間低於200ms，99分位數低於1s就認為這個服務是好的（如果響應時間較長，則可能意味著這個服務是差的），那麼一個服務至少在99.9%的時間內是好的。這些參數為客戶端用戶設定了期望，當SLA並沒有滿足他們的期望時，他們便可以提出退款。</p><p>在高百分位的長響應時間中，排隊延遲通常佔了很大的一部分。如果一個服務只可以併發處理少量的事情（比如說因為CPU核數的限制），它只需要少量的緩慢請求來支撐起後續請求的處理，這種效果有事被稱為“線頭阻塞”（head-of-line blocking）。即使後續請求在服務器上快速得以處理，由於要等待線頭響應完成，客戶端看到的也只是一個緩慢的總體響應時間。由於這種現象的存在，在客戶端測量響應時間是非常重要的。</p><p>當為了測試系統的可伸縮性而人為生成負載時，生成負載的客戶端不需考慮響應時間而只管不停的發送請求即可。如果客戶端等待一個請求相應完成後再發送另外一個請求的話，就會得到比實際情況更短的請求響應時間，這會扭曲測量的結果。</p><pre> 分位數實戰  高分位數在後端服務中尤為重要，作為服務單終端用戶請求的一部分，這些服務會被多次調用。即使併發調用，客戶仍然需要等待併發請求中響應最慢的那一個完成。只要存在一個緩慢調用就會讓終端用戶的請求變慢。如圖1-5所示，如果終端用戶發出多個後臺調用，即使只有一小部分調用較慢，也有很大的機率造成慢調用，因此更大比例的終端用戶獲得慢調用響應（通常稱為尾部延遲放大）。 如果你想要將響應時間分位數添加到服務的監測儀表板中，你需要持續有效地計算這些分位數。例如，你可能想要做一個滾動窗口滾動顯示最近10分鐘的請求響應時間。每一分鐘你都需要計算窗口中響應時間的中位數和其他的分位數並繪製在儀表盤上。 比較低級的實現方法是在時間窗口中保存所有請求的響應時間列表，並每分鐘對該列表進行排序。如果覺得這種方法效率太低，有一些算法可以在最小的CPU和內存成本下計算出分位數的近似值，比如 forward decay [25]，t-digest[26]，或者HdrHistogram[27]。需要注意的是，百分位平均化，如減小時間分辨率或將不同機器的數據組合在一起，在數學上是沒有意義的——聚合響應時間數據的正確方法是添加直方圖[28]。 </pre><div class=pgc-img><img alt="設計數據密集型應用 第一部分第一節 可靠性，可擴展性和可維護性" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15364004641357d609c69ec><p class=pgc-img-caption></p></div><p>圖1-5：當有多個後臺服務響應一個請求時，只要一個後臺服務響應較慢就會讓終端用戶的請求變慢</p><h4>處理負載的方法</h4><p>既然我們已經討論了描述負載和度量性能的參數，現在我們可以認真地討論可擴展性了：當負載參數增加時如何保持良好的性能。</p><p>一種能夠良好應對某一等級負載的架構很難應對10倍的負載。如果你正在開發一個快速增長的服務，那麼在每一次負載增加一個量級的時候你可能要重新考慮你的架構，或者更頻繁地考慮它。</p><p>人們經常談論在縱向擴展（垂直擴展，移動到更強大的機器）和橫向擴展（水平擴展，在多個較小的機器上分配負載）進行取捨。在多臺機器上分配負載也稱為無共享（shared-nothing）體系結構。單機系統往往容易管理，但是高端的機器往往又比較昂貴，所以一個負載較重的系統往往不可避免地要進行橫向擴展。實際上，一個好的結構通常會將兩者有效地結合起來：例如，使用幾個高性能的機器仍然比大量的小型虛擬機更簡單、成本更低。</p><p>有一些系統是彈性的，也就是說當檢測到負載增加時系統能夠自動增加計算資源，而另外一些系統需要手動實現可擴展性（人為地分析系統負載能力併為集群增加更多的機器）。如果負載變化很難預測，彈性系統會更加實用，但是手動進行系統擴展更加簡單，操作彩蛋也會更少（見“分區再平衡”）。</p><p>雖然跨機器分發無狀態服務相當簡單，但是有狀態數據系統從單機部署遷入到分佈式部署可能會帶來許多額外的複雜性。因此，至今常見的做法是將數據庫保存在單個節點上（縱向擴展），直到擴展成本或者高可用性要求迫使不得不進行分佈式部署。</p><p>隨著分佈式系統工具和抽象化的進步，這種常見的做法可能會有所改變，至少對有些類別的應用來說如此。可以預見，未來即使在不需要處理大規模數據或流量的場景下，分佈式數據系統也會成為默認的部署配置。在本書的餘下內容中，我們會對幾種分佈式系統進行研究，並在它們的可擴展性、易用性和可維護性方面進行討論。</p><p>並沒有一種通用的，萬能的可擴展性框架（俗稱萬能膠水），那些大規模運行的系統，框架往往是針對應用而深度定製的。架構面臨的問題可能包括數據讀的量級，數據寫的量級，數據存儲量級，數據複雜度，響應性能要求，訪問模式等，或者將這些問題加起來再加上其他的更多問題。</p><p>例如，一個被設計用來每秒處理100000條請求，每個請求1kb的系統與每分鐘處理3個請求，每個請求2GB的系統是截然不同的，即使兩個系統擁有相同的數據吞吐量。</p><p>對於特定的應用程序來說，一個強擴展性系統是圍繞著常見操作和罕見操作的假設創建的（也就是負載參數）。如果這些假設是錯誤的，所有為擴展性所做的努力全部都會付之東流，甚至會適得其反。在早期的創業公司或未經驗證的產品中，通常更重要的是能夠快速地迭代產品特性，而不是基於對未來負載的假設進行擴展（過度設計）。</p><p>雖然是特定於目標應用的，但可擴展架構通常由通用模塊構建，採用常見的排列模式。在這本書中我們隊這些模塊和模式進行了討論。</p><h2>可維護性</h2><p>眾所周知，軟件成本不僅包括最初的開發成本，還包括運維成本——解決bug，保證系統的可操作性，定位失敗原因，平臺移植，適配新的應用場景，償還技術負債和添加新特性。</p><p>但不幸的是，許多軟件從業人員不喜歡維護所謂的遺留系統——修復別人的bug，在過時的平臺上工作或者被逼迫做自己不願意做的事情。每個遺留系統都有自己讓人不爽的地方，所以很難給出通用的處理建議。</p><p>但是我們應該以最小化運維痛苦的方法設計軟件，並且避免自己創建遺留系統。最後，我們需要格外留意軟件系統的三個設計原則：</p><p>可操作性</p><pre>讓操作團隊更容易保持系統的穩定運行。</pre><p>簡易性</p><pre>讓新的開發者易於理解系統，儘可能的降低系統的複雜度（需要注意的是，這並不同於用戶界面的簡易性）。</pre><p>可演化性</p><pre>讓開發者未來容易改進系統，當需求變動時系統能夠適應未知場景。又稱為可擴展性，可修改性或者可塑性。</pre><p>就像以前的可靠性和可伸縮性一樣，並沒有簡單的方案可以達到這些目標。但是，我們將嘗試思考具有可操作性、簡單性和可演化性的系統。</p><h4>可操作性：讓操作變得容易</h4><p>有人曾說“好的操作通常可以繞過壞（或不完整）軟件的限制，但是好的軟件不能在糟糕的操作中可靠地運行”。雖然操作的某些方面可以而且應該是自動化的，但是對於人來說，構建自動化並保證它正確的運行是非常重要的。</p><p>操作團隊對於保持系統穩定運行至關重要。一個好的操作團隊需要對以下事情（或者更多）負責：</p><ul><li>監測系統的健康狀況，當系統狀態變差時快速地重構服務。</li><li>跟蹤問題原因，比如系統失敗或者性能下降。</li><li>保持軟件平臺升級，包括安全補丁。</li><li>密切關注不同系統之間的交互影響，這樣就可以在造成危害之前扼殺一個有問題的修改。</li><li>對未來問題進行預測並在發生之前就消滅它們（比如容量規劃）。</li><li>構建用於部署、配置管理等功能的優秀實踐和工具。</li><li>執行復雜的運維任務，例如將應用程序從一個平臺移植到另一個平臺。</li><li>當配置修改時保證系統的安全性。</li><li>設定操作規範化流程，並幫助保持生產環境的穩定。</li><li>維持組織對系統的瞭解，即使有人員變更。</li><li>好的操作性意味著讓日常事務變得簡單，讓操作團隊專注於更有價值的活動。數據系統可以做各種各樣的事情簡化日常任務，包括：</li><li>通過良好的監測，將系統運行是行為和內部機制可視化。</li><li>為自動化和標準工具集成提供良好的支持。</li><li>避免對單機的依賴（允許系統在作為一個整體運行時關機）。</li><li>提供良好的文檔和易於理解的操作指南（如果我做了X，Y就會發生）。</li><li>提供良好的默認行為，但是同時給與管理員在必要時修改默認行為的權限。</li><li>最好有自愈機制，但同時給與管理員在必要時控制系統狀態的權限。</li><li>引導操作流程，減少彩蛋。</li></ul><h4>簡易性：管理複雜度</h4><p>小軟件的代碼可以清爽簡潔，但是隨著工程變大，代碼通常會變得複雜而難以理解。這種複雜度降低了每個開發者的效率，從而進一步增加維護成本。一個陷入複雜度泥潭的軟件工程有時被稱作“大泥團”（big ball of mud）。</p><p>複雜性有各種各樣的可能的徵兆：狀態空間爆炸，模塊之間緊耦合，複雜的依賴關係，不一致的命名和術語，旨在解決性能問題的黑客攻擊，在其他地方解決問題的外掛等。這個話題已經被很多人廣泛討論了[31,32,33]。</p><p>當複雜性使維護變得困難時，預算和時間表就變得不再明朗。複雜度高的軟件，在進行修改時引入bug的風險也更大：當系統變得更加難以理解和推理，我們往往就會忽略隱藏的假設、意外的結果和意外的交互。相反，減少複雜性則極大地提高了軟件的可維護性，因此簡易性應當是我們構建的系統的一個關鍵目標。</p><p>讓系統變得簡單並不一定意味著要削弱系統的功能，它也可能意味著消除系統的偶然性複雜度。Moseley和Marks將那些不是來自於要解決問題本身的複雜性，而僅來自於軟件實現的複雜性的複雜度稱為偶然性複雜度。</p><p>抽象化是消除偶然性複雜度最好用的工具之一。一個好的抽象能夠隱藏清晰易懂表象下大量的實現細節。好的抽象同樣可以大規模運用在其他的應用程序上。這種抽象概念的複用不僅比重複實現簡易功能更加有效，而且能夠引導開發出更高質量的軟件，抽象組件的質量改進也會讓所有使用它的應用程序受益。</p><p>例如，高等級的編程語言是抽象的，它會隱藏機器核心，CPU註冊和系統調用信息。SQL是一種抽象，它隱藏了複雜的磁盤和內存中的數據結構、來自其他客戶機的併發請求，以及崩潰後的不一致性。當然，當使用高等級語言編程的時候，我們使用的依舊是機器編碼，但是我們不是直接使用，因為編程語言的抽象允許我們不用去考慮這些。</p><p>但是，找到好的抽象是非常困難的，在分佈式系統中，儘管有很多好的算法，但是我們並不知道如何將他們封裝到一種抽象中用來將系統的複雜度保持在可控的範圍內。</p><p>在這本書中，我們持續關注良好的抽象，以幫助我們能夠將大系統的組成部分提取到定義良好、可複用的組件中。</p><h4>可演化性：讓改變變得容易</h4><p>你的系統需求永遠不變幾乎是絕不可能的。它更可能處於不斷變化的狀態：你找到新的事實，出現未曾預料到的用例，業務優先級改變，用戶請求新的功能，新平臺取代舊平臺，法律法規要求的改變，系統的增長迫使架構調整等等。</p><p>在組織流程上，敏捷工作法提供了適應變化的框架。敏捷社區同時開發了技術工具和模式去幫助開發者在多邊的環境中開發軟件，比如測試驅動開發（TDD）和重構。</p><p>大多數關於這些敏捷技術的討論都侷限在一個相當小、局部的規模上（在同一個應用程序內有幾個源代碼文件）。在本書中，我們尋求在更大的數據系統上提高敏捷性的方法，也許這些系統由幾種不同的應用程序或者不同功能的服務構成。例如，你將如何重構Twitter的架構，將實現主頁時間線的方法從第一種方法轉換為成第二種方法。</p><p>你可以輕鬆地修改一個數據系統，並使其適應不斷變化的需求，這與系統的簡易性和抽象密切相關：簡單易懂的系統通常比複雜系統更容易去調整。但是由於這是一個非常重要的想法，我們將使用一個其他的詞彙來指代數據系統級別的敏捷性：可演化性[34]。</p><h2>小結</h2><p>本節，我們探索了一些研究數據密集型應用的基本方法。這些原則將會貫穿本書剩餘部分，我們將在剩餘章節中深入研究這些方法的技術細節。</p><p>一個實用的應用需要迎合各種各樣的需求。包括一些功能性需求（它需要做什麼，例如允許以各種方式存儲、檢索、搜索和處理數據），以及一些非功能需求（注入安全性，可靠性，遵從性，可擴展性，兼容性和可維護性等一般屬性）。在本節中，我們詳細討論了可靠性，可擴展性和可維護性。</p><p>可靠性意味著讓系統正確地運行，即使當錯誤發生的時候也能如此。錯誤可能是硬件上的（典型隨機和不相關的），軟件上的（系統性，難以處理的bug），人為性的（人類總是不可避免的反覆犯錯）。容錯技術可以做到向終端用戶隱藏錯誤類型。</p><p>可擴展性意味著，即使負載增加的情況下，也能夠保持系統性能良好。為了方便對可擴展性進行討論，我們首先需要能夠描述負載和量化性能。我們以Twitter的主頁時間線為例簡要描述了負載，並且用響應時間分位數作為量化性能的參數。在可擴展性系統中，你可以增加處理能力以在高負載的情況下保證可靠性。</p><p>可維護性有很多方面，但是本質上來說，它著力於讓那些與系統相依為命的開發者和操作團隊過得更好。好的抽象有助於降低福再度，讓系統更容易去修改和適應新的用例。良好的可操作性意味著良好地可視化系統健康狀況，並有效地管理它。</p><p>不幸的是，並沒有簡單的方法可以保證系統的可靠性，可擴展性或者可維護性。但是有些模式和技術可以適用在不同種類的應用上。在接下來的章節中我們會看一下一些數據系統的實例，並且分析如何讓它們達到這些目標。</p><p>稍後，在第三部分，我們將研究向圖1-1系統那樣由幾個組件一起工作的系統模式。</p><p>參考文獻：</p><p>[1] Michael Stonebraker and Uğur Çetintemel: “‘One Size Fits All’: An Idea Whose Time Has Come and Gone,” at 21st International Conference on Data Engineering (ICDE), April 2005.</p><p>[2] Walter L. Heimerdinger and Charles B. Weinstock: “A Conceptual Framework for System Fault Tolerance,” Technical Report CMU/SEI-92-TR-033, Software Engineering Institute, Carnegie Mellon University, October 1992.</p><p>[3] Ding Yuan, Yu Luo, Xin Zhuang, et al.: “Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems,” at 11th USENIX Symposium on Operating Systems Design and Implementation (OSDI), October 2014.</p><p>[4] Yury Izrailevsky and Ariel Tseitlin: “The Netflix Simian Army,” techblog.netflix.com, July 19, 2011.</p><p>[5] Daniel Ford, François Labelle, Florentina I. Popovici, et al.: “Availability in Globally Distributed Storage Systems,” at 9th USENIX Symposium on Operating Systems Design and Implementation (OSDI), October 2010.</p><p>[6] Brian Beach: “Hard Drive Reliability Update – Sep 2014,” backblaze.com, September 23, 2014.</p><p>[7] Laurie Voss: “AWS: The Good, the Bad and the Ugly,” blog.awe.sm, December 18, 2012.</p><p>[8] Haryadi S. Gunawi, Mingzhe Hao, Tanakorn Leesatapornwongsa, et al.: “What Bugs Live in the Cloud?,” at 5th ACM Symposium on Cloud Computing (SoCC), November 2014. doi:10.1145/2670979.2670986</p><p>[9] Nelson Minar: “Leap Second Crashes Half the Internet,” somebits.com, July 3, 2012.</p><p>[10] Amazon Web Services: “Summary of the Amazon EC2 and Amazon RDS Service Disruption in the US East Region,” aws.amazon.com, April 29, 2011.</p><p>[11] Richard I. Cook: “How Complex Systems Fail,” Cognitive Technologies Laboratory, April 2000.</p><p>[12] Jay Kreps: “Getting Real About Distributed System Reliability,” blog.empathybox.com, March 19, 2012.</p><p>[13] David Oppenheimer, Archana Ganapathi, and David A. Patterson: “Why Do Internet Services Fail, and What Can Be Done About It?,” at 4th USENIX Symposium on Internet Technologies and Systems (USITS), March 2003.</p><p>[14] Nathan Marz: “Principles of Software Engineering, Part 1,” nathanmarz.com, April 2, 2013.</p><p>[15] Michael Jurewitz: “The Human Impact of Bugs,” jury.me, March 15, 2013.</p><p>[16] Raffi Krikorian: “Timelines at Scale,” at QCon San Francisco, November 2012. [17] Martin Fowler: Patterns of Enterprise Application Architecture. Addison Wesley, 2002. ISBN: 978-0-321-12742-6</p><p>[18] Kelly Sommers: “After all that run around, what caused 500ms disk latency even when we replaced physical server?” twitter.com, November 13, 2014.</p><p>[19] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, et al.: “Dynamo: Amazon’s Highly Available Key-Value Store,” at 21st ACM Symposium on Operating Systems Principles (SOSP), October 2007.</p><p>[20] Greg Linden: “Make Data Useful,” slides from presentation at Stanford University Data Mining class (CS345), December 2006.</p><p>[21] Tammy Everts: “The Real Cost of Slow Time vs Downtime,” webperformancetoday.com, November 12, 2014.</p><p>[22] Jake Brutlag: “Speed Matters for Google Web Search,” googleresearch.blogspot.co.uk, June 22, 2009.</p><p>[23] Tyler Treat: “Everything You Know About Latency Is Wrong,” bravenewgeek.com, December 12, 2015.</p><p>24 | Chapter 1: Reliable, Scalable, and Maintainable Applications</p><p>[24] Jeffrey Dean and Luiz André Barroso: “The Tail at Scale,” Communications of the ACM, volume 56, number 2, pages 74–80, February 2013. doi: 10.1145/2408776.2408794</p><p>[25] Graham Cormode, Vladislav Shkapenyuk, Divesh Srivastava, and Bojian Xu: “Forward Decay: A Practical Time Decay Model for Streaming Systems,” at 25th IEEE International Conference on Data Engineering (ICDE), March 2009.</p><p>[26] Ted Dunning and Otmar Ertl: “Computing Extremely Accurate Quantiles Using t-Digests,” github.com, March 2014.</p><p>[27] Gil Tene: “HdrHistogram,” hdrhistogram.org.</p><p>[28] Baron Schwartz: “Why Percentiles Don’t Work the Way You Think,” vividcortex.com, December 7, 2015.</p><p>[29] James Hamilton: “On Designing and Deploying Internet-Scale Services,” at 21st Large Installation System Administration Conference (LISA), November 2007. [30] Brian Foote and Joseph Yoder: “Big Ball of Mud,” at 4th Conference on Pattern Languages of Programs (PLoP), September 1997.</p><p>[31] Frederick P Brooks: “No Silver Bullet – Essence and Accident in Software Engineering,” in The Mythical Man-Month, Anniversary edition, Addison-Wesley, 1995. ISBN: 978-0-201-83595-3</p><p>[32] Ben Moseley and Peter Marks: “Out of the Tar Pit,” at BCS Software Practice Advancement (SPA), 2006.</p><p>[33] Rich Hickey: “Simple Made Easy,” at Strange Loop, September 2011.</p><p>[34] Hongyu Pei Breivold, Ivica Crnkovic, and Peter J. Eriksson: “Analyzing Software Evolvability,” at 32nd Annual IEEE International Computer Software and Applications Conference (COMPSAC), July 2008. doi:10.1109/COMPSAC.2008.50</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>展性</a></li><li><a>設計</a></li><li><a>數據</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/51f533f3.html alt=「技術探祕」5層可靠性設計，保障數據永遠在線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c5a4ed7e8e1b483a9cc7aa5ecf153ba4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51f533f3.html title=「技術探祕」5層可靠性設計，保障數據永遠在線>「技術探祕」5層可靠性設計，保障數據永遠在線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9a1539c.html alt=聊聊軟件設計的可測試性、可維護性、可擴展性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9a1539c.html title=聊聊軟件設計的可測試性、可維護性、可擴展性>聊聊軟件設計的可測試性、可維護性、可擴展性</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/5f54aef5.html alt=擔心設計數據意外刪除無法還原？快來這樣備份 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8e66516c4b3f4bd591e76dfea9ce9a42 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/5f54aef5.html title=擔心設計數據意外刪除無法還原？快來這樣備份>擔心設計數據意外刪除無法還原？快來這樣備份</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1ea89d.html alt=數據可視化設計過程：面向初學者的循序漸進指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S675yEr91tYEF1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1ea89d.html title=數據可視化設計過程：面向初學者的循序漸進指南>數據可視化設計過程：面向初學者的循序漸進指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4855d18.html alt=系統設計：性能指標、伸縮性、擴展性、可用性、安全性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c755c4f781e74f4dbc067a54f84040c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4855d18.html title=系統設計：性能指標、伸縮性、擴展性、可用性、安全性>系統設計：性能指標、伸縮性、擴展性、可用性、安全性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed02fb1.html alt=Dashboard設計思考，數據有效傳達信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R7vwwuPG4zfI8A style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed02fb1.html title=Dashboard設計思考，數據有效傳達信息>Dashboard設計思考，數據有效傳達信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html alt=鋼構人福利——鋼結構設計經典問題解讀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a72bd60ea48d471b8ce03ebf0ce15869 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html title=鋼構人福利——鋼結構設計經典問題解讀>鋼構人福利——鋼結構設計經典問題解讀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html alt=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153569494612546362474a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html title=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先>鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html alt=38個鋼結構設計問題，都很常見 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f1181ce8-cf01-4194-b9c2-362f43894ddb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html title=38個鋼結構設計問題，都很常見>38個鋼結構設計問題，都很常見</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html alt=步步解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d88dd927b4f2474fbe4ea261c2397ba8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html title=步步解析橋樑設計計算，不可錯過的一篇乾貨>步步解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html alt=結構設計、校對、審核三字經，速速收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html title=結構設計、校對、審核三字經，速速收藏>結構設計、校對、審核三字經，速速收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html alt=解析橋樑設計計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa4d0bcf2a204a2fac9b37978b1b0713 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html title=解析橋樑設計計算>解析橋樑設計計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html alt=解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af9ca7f120da4e23b0ca589375e05dd2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html title=解析橋樑設計計算，不可錯過的一篇乾貨>解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html alt=設計師解析橋樑設計計算，錯過了就沒有機會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e01645937bda4ae7a7f148666ff89117 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html title=設計師解析橋樑設計計算，錯過了就沒有機會>設計師解析橋樑設計計算，錯過了就沒有機會</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>