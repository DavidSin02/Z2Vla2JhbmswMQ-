<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 | 极客快訊</title><meta property="og:title" content="鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4331d0b354d4405b91ff022ac65cd4bc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5487254a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5487254a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4331d0b354d4405b91ff022ac65cd4bc><p class=pgc-img-caption></p></div><p><strong>|</strong>導語：非常幸運的是，從4月份至今，我能夠全身心投入到騰訊新聞的單元測試專項任務中，從無知懵懂，到不斷深入理解的過程，與開發同學互幫互助，受益匪淺。 在此過程中，得到了質量總監、新聞總監和喬幫主的傾囊指導，真心感謝！！ 我希望把所有心得，總結成一篇較為全面的文章，分享給其他團隊。 時刻牢記：</p><ol><li>不要濫用mock</li><li>基於意圖。</li></ol><p>在我們談到單元測試，大都清楚是測試函數符合預期，國外很多大公司都將單測執行的很好，國內成功的案例則相對有限。在本文中，筆者將在騰訊新聞項目中親身經歷單測從無到有的實踐過程梳理為可讀可參考的經驗分享出來。在實踐的過程我發現，單測可以推動產品質量轉為優秀，推動實行它的過程更需要對它有真實的認識以及一套方法論。</p><h1>一. 為單元測試"正名"</h1><p>我曾經認為，單元測試面向的是一個函數。任何走出一個函數的測試，都不是單元測試。</p><p>其實，對"單元"的定義取決於自己。如果你正在使用函數式編程，一個單元最有可能指的是一個函數。你的單元測試將使用不同的參數調用這個函數，並斷言它返回了期待的結果；在面嚮對象語言裡，下至一個方法，上至一個類都可以是一個單元（從一個單一的方法到一整個的類都可以是一個單元）。<strong>意圖</strong>很重要（"意圖"二字是本文中第一次提到，它很重要）</p><p>我們有單元測試、增量測試、集成測試、迴歸測試、冒煙測試等等，名字非常多。谷歌看到這種"百家爭鳴"的現象，創立了自己的命名方式，只分為<strong>小型測試</strong>、<strong>中型測試</strong>和<strong>大型測試</strong>。</p><p>· 小型測試，針對單個函數的測試，關注其內部邏輯，mock所有需要的服務。小型測試帶來優秀的代碼質量、良好的異常處理、優雅的錯誤報告</p><p>· 中型測試，驗證兩個或多個制定的模塊應用之間的交互</p><p>· 大型測試，也被稱為"系統測試"或"端到端測試"。大型測試在一個較高層次上運行，驗證系統作為一個整體是如何工作的。、</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f88b0cd2ffa4466b58d8b12893160e4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2a1673a6d174df4b8cd6f05fd182ddd><p class=pgc-img-caption></p></div><p>結論：我們的單元測試，既可以針對一個函數寫case，也可以按照函數的調用關係串起來寫case。</p><h1>二. 金字塔模型</h1><p>在金字塔模型之前，流行的是冰淇淋模型。包含了大量的手工測試、端到端的自動化測試及少量的單元測試。造成的後果是，隨著產品壯大，手工迴歸測試時間越來越長，質量很難把控；自動化case頻頻失敗，每一個失敗對應著一個長長的函數調用，到底哪裡出了問題？單元測試少的可憐，基本沒作用。</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ded9ab1719a478d9eac72dfc60f6037><p class=pgc-img-caption></p></div><p>Mike Cohn 在他的著作《Succeeding with Agile》一書中提出了<strong>"測試金字塔"</strong>這個概念。這個比喻非常形象，它讓你一眼就知道測試是需要分層的。它還告訴你每一層需要寫多少測試。</p><p>測試金字塔本身是一條很好的經驗法則，我們最好記住Cohn在金字塔模型中提到的兩件事：</p><ul><li>編寫不同粒度的測試</li><li>層次越高，你寫的測試應該越少</li></ul><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eca77090e4d4aebb814dbb443838410><p class=pgc-img-caption></p></div><p>同時，我們對金字塔的理解絕不能止步於此，要進一步理解：</p><p>我把金字塔模型理解為——<strong>冰激凌融化了</strong>。就是指，最頂部的"手工測試"理論上全部要自動化，向下融化，優先全部考慮融化成單元測試，單元測試覆蓋不了的 放在中間層（分層測試），再覆蓋不了的才會放到UI層。因此，UI層的case，能沒有就不要有，跑的慢還不穩定。按照喬幫主的說法，我不分單元測試還是分層測試，統一都叫自動化測試，那就應該把所有的自動化case看做一個整體，case不要冗餘，單元測試能覆蓋，就要把這個case從分層或ui中去掉。</p><p>越是底層的測試，牽扯到相關內容越少，而高層測試則涉及面更廣。比如單元測試，它的關注點只有一個單元，而沒有其它任何東西。所以，只要一個單元寫好了，測試就是可以通過的；而集成測試則要把好幾個單元組裝到一起才能測試，測試通過的前提條件是，所有這些單元都寫好了，這個週期就明顯比單元測試要長；系統測試則要把整個系統的各個模塊都連在一起，各種數據都準備好，才可能通過。</p><p>另外，因為涉及到的模塊過多，任何一個模塊做了調整，都有可能破壞高層測試，所以，高層測試通常是相對比較脆弱的，在實際的工作中，有些高層測試會牽扯到外部系統，這樣一來，複雜度又在不斷地提升。</p><h1><strong>三. 為什麼做單測</strong></h1><p>這個問題我們規避不掉。新聞是這次研發模式改革的主力軍之一，所以自上而下的推動讓這個問題不那麼棘手：做了就是做了。不做，卻又有那麼多的理由：</p><p>（蒐集到的吐槽真實聲音）</p><p>· <em>單元測試浪費了太多的時間</em></p><p>· <em>單元測試僅僅是證明這些代碼做了什麼</em></p><p>· <em>我是很棒的程序員，我是不是可以不進行單元測試？</em></p><p>· <em>後面的集成測試將會抓住所有的bug</em></p><p>· <em>單元測試的成本效率不高我把測試都寫了，那麼測試人員做什麼呢？</em></p><p>· <em>公司請我來是寫代碼，而不是寫測試</em></p><p>· <em>測試代碼的正確性，並不是我的工作</em></p><p>我覺得我們總監指導的很到位：改革，一是工作方式的改革，更難的是思想上的改革。</p><h1><strong>單元測試的意義</strong></h1><p>新聞的總監dot老師是至始至終推進單測的好領導，他講述了螺絲釘與飛機的故事：</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b5be4a22ca12410dae12bd951acf54d4><p class=pgc-img-caption></p></div><ul><li>單元測試對我們的產品質量是非常重要的。</li><li>單元測試是所有測試中最底層的一類測試，是第一個環節，也是最重要的一個環節，是<strong>唯一一次有保證能夠代碼覆蓋率達到100%的測試</strong>，是整個軟件測試過程的基礎和前提，單元測試防止了開發的後期因bug過多而失控，單元測試的性價比是最好的。</li><li>據統計，大約有80%的錯誤是在軟件設計階段引入的，並且修正一個軟件錯誤所需的費用將隨著軟件生命期的進展而上升。錯誤發現的越晚，修復它的費用就越高，而且呈指數增長的趨勢。作為編碼人員，也是單元測試的主要執行者，是唯一能夠做到生產出無缺陷程序這一點的人，其他任何人都無法做到這一點</li><li>代碼規範、優化，可測試性的代碼</li><li>放心重構</li><li>自動化執行three-thousand times</li></ul><p>下面這張圖，來自微軟的統計數據：bug在單元測試階段被發現，平均耗時3.25小時，如果漏到系統測試階段，要花費11.5小時。</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9bd4b79c969443deb3189296603afbae><p class=pgc-img-caption></p></div><p>下面這張圖，旨在說明兩個問題：85%的缺陷都在代碼設計階段產生，而發現bug的階段越靠後，耗費成本就越高，指數級別的增高。所以，在早期的單元測試就能發現bug，省時省力，一勞永逸，何樂而不為呢</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f185b9b0fc749939ea1de3641857796><p class=pgc-img-caption></p></div><h1><strong>單元測試特別耗時？</strong></h1><p><strong>不能一刀切，不能只盯著單測階段的耗時</strong>。</p><p>我採訪了新聞客戶端、後臺的開發，首先肯定的是，單測會增加開發量、增加開發時長；</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fdbb094233a74d4d94821d156a91ad49><p class=pgc-img-caption></p></div><p>在《單元測試的藝術》這本書提到一個案例：找了開發能力相近的兩個團隊，同時開發相近的需求。進行單測的團隊在編碼階段時長增長了一倍，從7天到14天，但是，這個團隊在集成測試階段的表現非常順暢，bug量小，定位bug迅速等。最終的效果，整體交付時間和缺陷數，均是單測團隊最少。</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/91142ef80f46493d85e436fc0d51aef3><p class=pgc-img-caption></p></div><p>單測，存在即合理。一方面，需要把單測放在整個迭代週期來觀測其效果；一方面，寫單測也是技術活，<strong>寫得好的同學</strong>，時間少代碼質量高（也即，不是說寫了單測，就能寫好單測）</p><h1>誰來寫單測呢？</h1><ul><li>開發同學寫單測</li><li>測試同學具有寫單測的能力。重點在於開發腳手架、分層測試/端到端測試</li></ul><h1>增量還是存量</h1><ul><li>單測case針對增量代碼</li><li>當存量代碼出現大規模重構，後者質量暴露出極大風險時，都是推動補全單測的好時機</li></ul><h1>四. 單元測試的階段</h1><p>1. 廣義的單元測試，我們指這三部分的有機組合：</p><ul><li>code review</li><li>靜態代碼掃描</li><li>單元測試用例編寫</li></ul><p>2. 結合新聞的實踐，我把單測成長的過程分為4個目標，分別為：</p><ul><li>會寫，全員可寫</li><li>寫的好，同時關注可測性問題，試點解決</li><li>識別可測性問題，熟練使用重構方法進行重構；識別代碼架構設計問題；case與業務代碼同步編寫</li><li>TDD。但這個目標是期望，不能作為必須實現的目標。</li></ul><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bfcdb302154494f803cf9aa3aefc004><p class=pgc-img-caption></p></div><p>截至發稿當天，新聞處於第三階段，即，每個迭代均能產出高質量的case，人數覆蓋和需求覆蓋均較高；關注重點在於可測性，時刻注重重構。</p><h1>五. 單元測試的指標</h1><p>還挺尷尬的，不太有直接的指標去衡量單測的效果。我們也經常被問到，"怎麼證明你們新聞單測的作用呀？"</p><ul><li>bug類指標（間接指標）：連續迭代的bug總數趨勢、迭代內新建bug的趨勢、千行bug率</li><li>單測的需求覆蓋度（50%以上），參與人員覆蓋度（80%以上）</li><li>單測case總數趨勢，代碼行增量趨勢</li><li>增量代碼的行覆蓋率（接入層80%，客戶端30%）</li><li>單函數圈複雜度（低於40），單函數代碼行數（低於80），掃描告警數</li></ul><p>在迭代需求持續高吞吐量的前提下，以新聞iOS的數據為例：</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8392a0ec7af942f9870e247a69cca484><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4381c8be6e964433b7be2c0eee9663aa><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/157717b6709c4142aaa496fb5d41d1ee><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/50c8a3d30ef44b369221bed576ca1c15><p class=pgc-img-caption></p></div><h1>六. go單元測試框架選型</h1><p>基本選型：testify + gomonkey</p><p>附加：httptest + sqlmock</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b424f96c0b8146b7a35d328a8684c17a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/993130c9b0dc4a8fb520bec9680a3863><p class=pgc-img-caption></p></div><h1>前提</h1><ul><li>測試文件，以_test.go結尾，與被測文件放於相同目錄</li><li>測試函數，函數名以Test開頭，並且隨後的第一個字符必須為大寫字母或下劃線，如：TestParseReq_CorrectNum_TableDriven</li><li>測試函數，參數為t *testing.T；對於bench測試，參數為b *testing.B</li><li>運行命令行，我的文章有深入講解：</li></ul><h1>testify常規用法</h1><p>testify基於gotesting編寫，所以語法上、執行命令行與go test完全兼容</p><ul><li>支持大量高效的api，比如：</li></ul><p>assert.Equal：常規對比，是把兩者分別換成[]byte去嚴格比對</p><p>assert.Nil：判斷對象為nil時，有時對err判空時也用</p><p>assert.Error：判斷err的具體類型和內容</p><p>assert.JSONEq：這個比較有用，對比map時；或者對比struct的時候，也會先轉為map，在用這個api去做對比，如下面這個例子，我封裝了建議的方法去將struct轉換為string(json)：</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/59a8742a214846ce9f49ba3d32398bff><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0b5039bd234643c19652a25b4ce9be95><p class=pgc-img-caption></p></div><ul><li>支持suite，用例集管理</li><li>運行時，可以指定用例集執行</li></ul><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/32e27aa7c9f44fa99448c5f06233ffcd><p class=pgc-img-caption></p></div><ul><li>自帶mock工具，但只支持接口方法的mock，而且用法相對複雜</li><li>table-driven</li></ul><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/07865253e3844b7ca36ab6b8e7679400><p class=pgc-img-caption></p></div><h1>gomonkey用法（加粗字體表示常用）</h1><p>https://github.com/agiledragon/gomonkey</p><p>https://studygolang.com/articles/15034</p><ul><li><strong>支持為一個函數打一個樁</strong></li><li><strong>支持為一個成員方法打一個樁</strong></li><li>支持為一個全局變量打一個樁</li><li>支持為一個函數變量打一個樁</li><li><strong>支持為一個函數打一個特定的樁序列</strong></li><li><strong>支持為一個成員方法打一個特定的樁序列</strong></li><li>支持為一個函數變量打一個特定的樁序列</li><li>table-driven的方式定義一系列stub</li></ul><p>注意，對內聯函數的Stub，go test命令行一定要加上參數才可生效。見官方文檔。所以，我的命令行默認加上-gcflags=all=-l就行了。</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8634c1c88b19495c830401a99a5d24db><p class=pgc-img-caption></p></div><p>我設置了一些goland的代碼模板，放在附件中。</p><p>ApplyFunc是對外部函數Stub（非類方法）</p><pre>/* 用法：gomonkey.ApplyFunc(被stub函數名, 被stub函數簽名) 函數返回值*例子：patches := gomonkey.ApplyFunc(fake.Exec, func(_ string, _ ...string) (string, error) {return outputExpect, nil})*/patches := gomonkey.ApplyFunc(lcache.GetCache, func(_ string) (interface{}, bool) {return getCommentsResp()})defer patches.Reset()</pre><p>ApplyMethod是對類函數Stub。但這裡注意，要被stub的方式是私有方法，gomonkey通過反射是找不到的，有兩種解決方法：</p><p>1）使用增強版的gomonkey；</p><p>2）不Stub它，而是選擇走進這個函數，這個話題在後面專題談mock的時候說。</p><pre>/* 用法：gomonkey.ApplyMethod(反射類名, 被stub函數簽名) 函數返回值*例子：var s *fake.Slicepatches := ApplyMethod(reflect.TypeOf(s), "Add", func(_ *fake.Slice, _ int) error {return nil})*/var ac *auth.AuthCheckpatches := gomonkey.ApplyMethod(reflect.TypeOf(ac), "PrepareWithHttp", func(_ *auth.AuthCheck, _ *http.Request, _ ...auth.AuthOption) error {return fmt.Errorf("prepare with nil object")})defer patches.Reset()</pre><p>ApplyMethodSeq是對同一個Stub的函數返回不同的結果</p><pre>/* 用法：gomonkey.ApplyMethodSeq(類的反射，"被stub函數名", 返回結構體)；Params{info1},中括號內為被stub函數的返回值列表；Times為生效次數*例子：e := &amp;fake.Etcd{}info1 := "hello cpp"info2 := "hello golang"info3 := "hello gomonkey"outputs := []OutputCell{{Values: Params{info1, nil}},{Values: Params{info2, nil}},{Values: Params{info3, nil}},}patches := ApplyMethodSeq(reflect.TypeOf(e), "Retrieve", outputs)defer patches.Reset()*/conn := &amp;redis.RedisConn{}patch1 := gomonkey.ApplyFunc(redis.NewRedisHTTP, func(serviceName string, _ string) *redis.RedisConn {conn := &amp;redis.RedisConn{redis.RedisConfig{},&amp;redis.RedisHelper{},}return conn})defer patch1.Reset()// mock redis data. 返回空和不為空的情況outputCell := []gomonkey.OutputCell{{Values: gomonkey.Params{"12", nil}, Times: 1},{Values: gomonkey.Params{"", nil}, Times: 1},}patchs := gomonkey.ApplyMethodSeq(reflect.TypeOf(conn.RedisHelper), "Get", outputCell)defer patchs.Reset()</pre><p>先舉這幾個例子，詳細的可以在上面的鏈接文章中全面得到。</p><p>這裡補充一點，對類方法進行stub，<strong>必須要找到該方法對應的真實的類（結構體）</strong>，舉個例子：</p><pre>//被測函數中有如下一段，其中的Get方法我們想stub掉，只要找到Get方法對應的類就好了readCountStr, _ := conn.Get(redisKey)if len(readCountStr) == 0 {return 0, nil}</pre><pre>//定位conn，是RedisConn類型的structtype RedisConn struct {RedisConfig*RedisHelper}//所以第一次，我用gomonkey.AppleyMethod時這麼寫：patches := gomonkey.ApplyMethod(reflect.TypeOf(*RedisConn),"Get", func(_ *redis.RedisHelper,_ string, _ []string) ([]string, error){return info,err_notNil})defer patches.Reset()//運行時報了空指針panic，提示RedisConn沒有Get方法 </pre><pre>//繼續追，原來Get是*RedisHelper的方法，組合到了RedisConn結構體中，共用方法。但我們使用gomonkey時，需要指向真正定義它的類func (this *RedisHelper) Get(key string) (string, error) {return redigo.String(this.Do("GET", key))</pre><pre>//最終這麼寫:patches := gomonkey.ApplyMethod(reflect.TypeOf(giftData.rankRedisRD.RedisHelper),"Get", func(_ *redis.RedisHelper,_ string, _ []string) ([]string, error){return info,err_notNil})defer patches.Reset()</pre><h1>七. 必須說一說mock了</h1><h1>test doubles</h1><p>在《xUnit Test Patterns》一書中，作者首次提出test doubles（測試替身）的概念。我們常掛在嘴邊的mock只是其中一種，而且是最容易與Stub（打樁）混淆的一種。在上一節中對gomonkey的介紹，你可以注意到了，我沒有使用mock，全部是Stub。是的，gomonkey不是mock工具，只是一個高級打樁的工具，適配了我們大部分的使用場景。</p><p>測試替身，共有五種：可以參考這篇翻譯</p><ul><li>Dummy Object：</li></ul><p>用於傳遞給調用者但是永遠不會被真實使用的對象，通常它們只是用來填滿參數列表</p><ul><li>Test Stub</li></ul><p>Stubs通常用於在測試中提供封裝好的響應，譬如有時候編程設定的並不會對所有的調用都進行響應。Stubs也會記錄下調用的記錄，譬如一個email gateway就是一個很好的例子，它可以用來記錄所有發送的信息或者它發送的信息的數目。簡而言之，Stubs一般是對一個真實對象的封裝</p><ul><li>Test Spy</li></ul><p>Test Spy像一個間諜，安插在了SUT內部，專門負責將SUT內部的間接輸出(indirect outputs)傳到外部。它的特點是將內部的間接輸出返回給測試案例，由測試案例進行驗證，Test Spy只負責獲取內部情報，並把情報發出去，不負責驗證情報的正確性</p><ul><li>Mock Object</li></ul><p>針對設定好的調用方法與需要響應的參數封裝出合適的對象</p><ul><li>Fake Object</li></ul><p>Fake對象常常與類的實現一起起作用，但是只是為了讓其他程序能夠正常運行，譬如內存數據庫就是一個很好的例子。</p><h1>stub與mock</h1><p>打樁和mock應該是最容易混淆的，而且習慣上我們統一用mock去形容模擬返回的能力，習慣成自然，也就把mock常掛在嘴邊了。</p><p>就我的理解，stub可以理解為mock的子集，mock更強大一些：</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f4bd150027e443488017ee6ed4f8d55a><p class=pgc-img-caption></p></div><ul><li>mock可以驗證實現過程，驗證某個函數是否被執行，被執行幾次</li><li>mock可以依條件生效，比如傳入特定參數，才會使mock效果生效</li><li>mock可以指定返回結果</li><li>當mock指定任何參數都返回固定的結果時，它等於stub</li></ul><p>只不過，go的mock工具gomock只基於接口生效，不適合新聞、企鵝號項目，而gomonkey的stub覆蓋了大部分的使用場景。</p><h1>八. 不要濫用mock</h1><p>我把這一部分單獨放一章節，表現出它重要的意義。需要讀懂肖鵬的《mock七宗罪》，在gitchat上。</p><h1>兩個門派</h1><p>約從2004-2005年間，江湖上形成兩大門派：經典測試驅動開發派 和 mockist（mock極端派）。</p><p>先說mockist。他主張將被測函數 <strong>所有</strong> 調用的外面函數，全部mock。也即，只關注被測函數自己的一行行代碼，只要調用其他函數，全都mock掉，用假數據來測試。</p><p>再說經典測試驅動開發派，他們主張不要濫用mock，能不mock就不mock，被測單元也不一定是具體的一個函數，可能是多個函數，串起來。<strong>必要的時候再mock</strong>。</p><p>兩個門派相爭多年，理論各有利弊，至今仍然共存。存在即合理。比如mockist，使用了過多的mock，無法覆蓋函數接口，這部分又是很容易出錯的；經典派，串的太多，又被質疑是集成測試。</p><p>對於我們實際應用，<strong>不必強制遵從某一派，結合即可</strong>，需要的時候mock，儘量少mock，不用糾結。</p><h1>什麼時候適合mock</h1><p>如果一個對象具有以下特徵，比較適合使用mock對象：</p><ul><li>該對象提供非確定的結果（比如當前的時間或者當前的溫度）</li><li>對象的某些狀態難以創建或者重現（比如網絡錯誤或者文件讀寫錯誤）</li><li>對象方法上的執行太慢（比如在測試開始之前初始化數據庫）</li><li>該對象還不存在或者其行為可能發生變化（比如測試驅動開發中驅動創建新的類）</li><li>該對象必須包含一些專門為測試準備的數據或者方法（後者不適用於靜態類型的語言，流行的Mock框架不能為對象添加新的方法。Stub是可以的。）</li></ul><p><strong>因此，不要濫用mock（stub），當被測方法中調用其他方法函數，第一反應應該走進去串起來，而不是從根部就mock掉了。</strong></p><h1>九. 用例設計法</h1><p>喬幫主介紹了一篇文章：像機器一樣思考</p><p>文章講述思考程序設計的根本思路——考慮輸入輸出。我們設計case，想要得到最全面的設計，根本是考慮全輸入全輸出的組合，當然，一方面，這麼做耗時太大，很多時候是不可執行的；一方面，這不是想要的結果，要考慮投入產出比。這時，需要理論與實踐相結合，理論指導實踐，實踐精細理論。</p><h1>先說理論</h1><p>1. 還是從上篇文章說起，考慮輸入、輸出，就要先知道哪些屬於輸入輸出：</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92a8de5d507d41edba52bae28f8b5511><p class=pgc-img-caption></p></div><p>2. 白盒&黑盒設計</p><p>白盒法：</p><ul><li>邏輯覆蓋（語句、分支、條件、條件組合等）</li><li>路徑（全路徑、最小線性無關路徑）</li><li>循環：結合5種場景（跳過循環、循環一次，循環最大次，循環m次命中、循環m次未命中）</li></ul><p>黑盒法：</p><p>等價類：正確的，錯誤的（合法的，非法的）</p><p>邊界法：[1，10] ==> 0，1，2，9，10，11（是等價類的有效補充）</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ecfd4de22364bf088605483ce0caa0d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec3a65a854884a36b1359b80fd449d3e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ec53ecd22f2a42e0b1eef66a08000e1b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fbc4ebd4c25b4a2fbecb16b19b2bb3f5><p class=pgc-img-caption></p></div><p>3. 結合應用</p><p>全輸入輸出，實施難度較大，轉而我們思考到業內大神們設計出白盒黑盒設計法，通過仔細思考，可以判斷出是對全輸入全輸出的方法論體現。</p><p>因此，白盒&黑盒用例設計法，每一種我都親自實踐，理解其優缺點，從設計覆蓋角度，條件組合>最小線性無關路徑>條件>分支>語句。</p><p>下面這張圖，是我早期思考用例設計時的一次實踐，現在回憶起來，它過度設計了。</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/73e5aaee12f64a7094294e6eac448699><p class=pgc-img-caption></p></div><p>但實際中，我們擔心"過度設計"，也還無法給出答案"用什麼方法設計保證萬無一失"。</p><ul><li>過度設計，也會使case脆弱</li><li>在有限的時間內，我們尋求收益較大化</li></ul><p>1. 小函數&重要（計算，對象處理）：儘量設計全面</p><p>2. 邏輯較重，代碼行數較多：分支、語句覆蓋 + 循環 + 典型的邊界處理（我們看個例子：GetUserGiftList）</p><p>3. 引出"基於實現"與"<strong>基於意圖</strong>"的設計：過多去Stub被測函數內部的調用，就越接近"基於實現"（第二次提到"基於意圖"）</p><h1>十. 基於意圖與基於實現</h1><p>這個話題是非常重要的。</p><p><strong>基於意圖</strong>：思考函數最終想做什麼，把被測函數當做黑盒，考慮其輸出輸出，而不要關注其中間是怎樣實現的，究竟生成了什麼臨時變量，循環了幾次，有什麼判斷等。</p><p><strong>基於實現</strong>：輸入輸出我也考慮，中間怎麼實現的我也考慮。mock就是一個好例子，比如我們寫一個case，我們會用mock去驗證函數內是否調用了哪個外部方法、調用了幾次，語句的執行順序是怎樣的。程序的變動比需求還快，重構隨時都有，稍有一變，case大批量失敗，這也是《mock七宗罪》中提到的一種情況。</p><p><strong>我們要的是基於意圖，遠離基於實現</strong>。</p><p>dot老師和喬幫主給我們上了課程，結合實戰經驗，我總結如下：</p><p>1. "要麼寫好，要麼不寫"。case也是代碼，也需要維護，也有工作量，所以要寫的到位，而不是寫得多。寫了一堆沒用的，你還得維護，不如刪了。</p><p>2. 拿到一個函數，先問問自己，這個函數要實現什麼功能，最終輸出是什麼；然後，問自己，這個函數的風險在哪裡，哪部分邏輯不太自信，最容易出錯（計算、複雜的判斷、某異常分支的命中等）。這些才是我們case要覆蓋的點。</p><p>3. 內聯函數、直接get/set，沒幾行沒什麼邏輯的，只要你判斷沒什麼風險，就不用寫case。</p><p>4. 確定了要寫的case，再用分支條件組合、邊界等核心方面設計出具體用例，實施編寫。</p><p>我們看一個具體的case：</p><p>1. 拿到這個函數，作為<strong>測試同學的我</strong>先向開發瞭解該函數的意圖：對符合格式、符合時間的用戶禮物進行加和</p><p>2. 讀代碼，瞭解了代碼流程、幾個異常分支，先做了code review</p><p>3. 根據必要的異常分支，設計case覆蓋</p><p>4. 對正常的業務流程，是按照開發講述的函數意圖，進行設計，case如下：</p><p>被測函數：</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c8720535d254342917b1e2da054d3cf><p class=pgc-img-caption></p></div><p>正常路徑的單測case</p><pre>func TestNum_CorrectRet(t *testing.T) {giftRecord := map[string]string{"1:1000": "10","1:2001": "100","1:999": "20","2": "200","a": "30","2:1001": "20","2:999": "200",}expectRet := map[int]int{1: 110,2: 20,}var s *redis.xxxpatches := gomonkey.ApplyMethod(reflect.TypeOf(s), "Getxxx", func(_ *redis.xxx, _ string)(map[string]string, error) {return giftRecord, nil})defer patches.Reset()p := &amp;StarData{xxx }userStarNum, err := p.GetNum(10000)assert.Nil(t, err)assert.JSONEq(t, Calorie.StructToString(expectRet), Calorie.StructToString(userStarNum))}</pre><p><strong>有同學會問到</strong>：但是你最終還是看的代碼呀？看到代碼的正確邏輯是怎麼處理的，再去設計的case和構造數據吧？而且你不看代碼，怎麼知道有哪些異常分支要覆蓋呢？</p><p>答：</p><p>1. 我現在作為測試同學寫開發同學的case，確實需要知道有哪些異常分支要處理， 但不侷限於代碼中的幾種，還應該包括我理解到的異常分支，都要體現在case中。我們的case絕不是為了證明代碼是怎麼實現的！通過單測，我們經常能夠發現bug。但是將來是開發來寫單測的，他自己設計的函數肯定知道要覆蓋哪些異常分支。</p><p>2. 嗯，我需要看代碼的正常流程是怎樣的，但不代表著把代碼扒下來以設計出case。case實際上是通過與開發的溝通後，瞭解輸入數據的結構，輸出的格式，數據校驗和計算的過程，去設計輸入輸出的。</p><h1>十一. 用例編寫的策略</h1><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0a34a8e2cf5b4059b4dcfa0fc4a69ee0><p class=pgc-img-caption></p></div><p>對於怎麼個順序去寫單測，我們重點實踐了一番，基本上也就三種情況吧：</p><ul><li>獨立原子：mockist，被我們推翻了。當然，最底部的函數可能沒有外部依賴，那單測它就夠了。</li><li>自上而下（紅線）：從入口函數往下測。實踐的過程中，我發現很難執行，因為我從入口處就要想好每一次調用都需要返回哪些數據及格式，串起來一個case已經非常不易。</li><li>自下而上(黃線)：我們發現，入口函數，往往沒什麼邏輯，調用另一個函數然後拿到響應返回。所以入口函數，也許不用寫？我們繼續往下看，每一次調用的函數都看，也調出了以往的線上線下bug，我們發現出現問題的代碼部分往往是調用鏈的底端，尤其是涉及計算、複雜分支循環等。而且，底端的函數往往可測性較好。</li></ul><p>因此，考慮兩方面，<strong>我們選擇自下而上設計來選擇函數編寫case</strong>：</p><p>1. 底部的函數可測性通常很好</p><p>2. 核心邏輯比較多，尤其涉及計算、拼接，分支的。</p><h1>十二. 可測性問題的解決——重構</h1><p>導致無法寫單測的重要原因是，代碼可測性不好。如果一個函數八九十行、二三百行，基本就是不可測的，或者說"不好測的"。因為裡面邏輯太多了，從第一行到最後一行都經歷了什麼，各種函數調用外部依賴，各種if/for，各種異常分支處理，寫一個case的代碼行數可能是原函數的幾倍。</p><p>因此，推動單測走下去，重構提升可測性是必須環節。而且，通過重構，代碼結構間接清晰了，更可讀可維護，更容易發現和定位問題。</p><p>常見的問題：重複代碼、魔法數字、箭頭式的代碼等</p><p>推薦的理論書籍是《重構：改善既有代碼的設計》第二版、《clean code》</p><p>我輸出了一篇關於重構的文章。</p><p>使用codecc（騰訊代碼檢查中心）的圈複雜度、函數長度來評估代碼結構質量，我們與開發一起學習，一起實踐，不斷有成果輸出。</p><p>對於箭頭式的代碼，可考慮如下步驟：</p><p>1. 多使用衛語句，先判斷異常，異常return</p><p>2. 將判斷語句抽離</p><p>3. 將核心部分抽離為函數</p><h1>十三. 用例維護，可讀性、可維護性、可信賴性</h1><h1>用例設計要素</h1><ul><li>將內部邏輯與外部請求分開測試</li><li>對服務邊界（interface）的輸入和輸出進行嚴格驗證</li><li>用斷言來代替原生的報錯函數</li><li>避免隨機結果</li><li>儘量避免斷言時間的結果</li><li>適時使用setup和teardown</li><li>測試用例之間相互隔離，不要相互影響</li><li>原子性，所有的測試只有兩種結果：成功和失敗</li><li>避免測試中的邏輯，即不該包含if、switch、for、while等</li><li>不要保護起來，try…catch…</li><li>每個用例只測試一個關注點</li><li>少用sleep，延緩測試時長的行為都是不健康的</li><li>3A策略：arrange，action，assert</li></ul><h1>用例可讀性</h1><ul><li>標題要明確表明意圖，如Test+被測函數名+condition+result。case失敗後，通過名字就知道哪個場景失敗，而不用一行行再讀代碼。將來維護這個測試代碼的，可能是其他人，我們需要讓別人容易讀懂</li><li>測試代碼的內容要清晰，3A原則：arrange，action，assert 分成三部分。數據準備部分arrange如果代碼行較多，考慮抽離出去。</li><li>斷言的意圖明顯，可以考慮將魔法數字變為變量，命名通俗易通</li><li>一個case，不要做過多的assert，要專一</li><li>和業務代碼的要求一致，都要可讀</li></ul><h1>用例可維護性</h1><ul><li>重複：文本字符串重複、結構重複、語義重複</li><li>拒絕硬編碼</li><li>基於意圖的設計。不要因為業務代碼重構一次，就導致一批case失敗</li><li>注意代碼的各種壞味道，可參見《重構》第二版</li></ul><h1>用例可信賴性</h1><p>單元測試，小而且運行快，它不是為了發現本次的bug，更是為了放在流水線上 努力發現每一次MR是否產生了bug。單測運行失敗，唯一的原因只應該是出現bug，而不是因為外部依賴不穩定、基於實現的涉及等，長期的失敗將失去單元測試的警示作用，"狼來了"的故事是慘痛的教訓。</p><ul><li>非被測程序缺陷，隨機失敗的case</li><li>永不失敗的case</li><li>沒有assert的case</li><li>名不副實的case</li></ul><h1>十四. 新聞單元測試的推動過程</h1><p>我們提到，對單元測試的實踐分為4個階段，每階段均有目標。</p><h1>第一階段 會寫，全員寫，不要求寫好</h1><ul><li>由上而下的推動，從總監到組長，極力支持，毫無猶豫，使組員情緒高漲</li><li>快速確定單測框架，熟練使用</li><li>結合開發需求，輸出各場景下 單測框架的使用方法，包括assert、mock，table-driven等</li><li>封裝http2WebContext，方便生成context對象</li><li>多次培訓，講解單測理論及框架使用</li><li>各團隊（終端、接入層）指定單測接口人，由他先嚐螃蟹。他是最熟悉框架使用，在前期寫最多case的人</li><li>在磨合好單測框架的集成使用後，啟動會，部分同學先試點使用，確保連續兩個迭代，這幾個同學都有case輸出</li><li>每個迭代總結數據中，加入單測相關數據：組長和總監非常關注單測數據信息，針對性鼓勵提升case數量和代碼行數</li></ul><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92bcb784395341bda1888cbff5fd6024><p class=pgc-img-caption></p></div><h1>第二階段 寫好，有效，全員寫</h1><ul><li>測試同學探索出mock的正確使用方法、用例設計的正確思路，分享給團隊，經過探討達成一致</li><li>結對編程，每迭代結對2-3個開發，共同寫case，互相提升。</li></ul><p>這裡的結對是靈活的：有的開發，只需用半天的時間給他講框架使用，同他練習，他就可以上手了不需要再擔心；有的開發，會分給測試同學需求，測試同學寫完case後，開發review學習，並嘗試寫出自己的第一個case；有的開發，一開始可能不太接受，以需求不適合單測為理由，觀察了一段時間，他發現其他人都寫了，也沒那麼難，對團隊也有利，他甚至會主動找到測試同學教他寫case。</p><ul><li>測試同學對開發提交的case進行review，跟進開發修改後重新MR</li><li>連續兩個迭代，邀請dot老師、喬幫主進行case review，效果非常好</li><li>對迭代的單測數據分析，關注需求覆蓋度、人員覆蓋度，case增量</li><li>組長持續鼓勵支持單測</li><li>每迭代的需求增加"單元測試"字段，由組長評估後置位。不帶單測的MR不予通過，單測也要被review</li></ul><h1>第三階段 可測性提升</h1><ul><li>測試和開發共同學習《重構》第二版，每週有分享會</li><li>某些骨幹同學優先重構自己的代碼</li><li>測試同學嚴格要求，先保證有單測，然後小步重構，每一步均有單測保障</li><li>通過流水線的codecc掃描，圈複雜度和函數長度必須達標，不可人工干預其通過</li></ul><h1>第四階段 TDD</h1><ul><li>先不保證開發同學做到TDD，門檻還是挺高的，而且需要在線下熟練之後再運用到業務開發中</li><li>逐步推動開發將業務代碼和測試代碼同步編寫，而不是完成業務代碼後再補case</li><li>測試同學練成TDD</li></ul><h1>十五. 流水線</h1><p>單測要放在流水線上跑，客戶端和後臺都配好了流水線，保證每次push和MR都運行一次，發報告。</p><p>對於go的單測，新聞接入層各模塊是通過MakeFile來編譯，因為要導入一些環境變量，所以我將go test集成在MakeFile中，執行make test即可運行該模塊下所有的測試用例。</p><pre>GO = goCGO_LDFLAGS = xxxCGO_LDFLAGS += xxxCGO_LDFLAGS += xxxCGO_LDFLAGS += xxxTARGET =aaaexport CGO_LDFLAGSall:$(TARGET)$(TARGET): main.go$(GO) build -o $@ $^test:CFLAGS=-gexport CFLAGS$(GO) test $(M) -v -gcflags=all=-l -coverpkg=./... -coverprofile=test.out ./...clean:rm -f $(TARGET) </pre><p>注：上述做法，只能生成被測試的代碼文件的覆蓋率，無法拿到未被測試覆蓋率情況。可以在根目錄建一個空的測試文件，就能解決這個問題，拿到全量代碼覆蓋率。</p><pre>//main_test.gopackage mainimport ("fmt""testing")func TestNothing(t *testing.T) {fmt.Println("ok")}</pre><p>流水線加上流程</p><div class=pgc-img><img alt=鵝廠開發談單元測試：牢記這兩點，從此遠離無效的單元測試 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2408343b98b74211ba58981b9595df0a><p class=pgc-img-caption></p></div><pre># cd ${WORKSPACE} 可進入當前工作空間目錄export GOPATH=${WORKSPACE}/xxxpwdecho "====================work space"echo ${WORKSPACE}cd ${GOPATH}/srcfor file in `ls`:doif [ -d $file ]thenif [[ "$file" == "a" ]] || [[ "$file" == "b" ]] || [[ "$file" == "c" ]] || [[ "$file" == "d" ]]thenecho $fileecho ${GOPATH}"/src/"$filecp -r ${GOPATH}/src/tools/qatesting/main_test.go ${GOPATH}/src/$file"/."cd ${GOPATH}/src/$filemake testcd ..fifidone</pre><h1>附錄. 資料</h1><ul><li>《測試驅動開發》</li><li>《單元測試的藝術》</li><li>《有效的單元測試》</li><li>《重構，改善既有代碼的設計》</li><li>《修改代碼的藝術》</li><li>《測試驅動開發的三項修煉》</li><li>《xUnit Test Patterns》</li><li>mock七宗罪</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>單元</a></li><li><a>測試</a></li><li><a>鵝廠</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/81163a9.html alt=一年級數學第8單元測試，滿分少，最難的進位加法來了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fdd450113239499cb36d9f1f12d75838 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/81163a9.html title=一年級數學第8單元測試，滿分少，最難的進位加法來了>一年級數學第8單元測試，滿分少，最難的進位加法來了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/85e4fda.html alt=二年級數學第2單元測試，運算量大，1小時答不完 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/be848e7f126b441ab3143ded0000ab10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/85e4fda.html title=二年級數學第2單元測試，運算量大，1小時答不完>二年級數學第2單元測試，運算量大，1小時答不完</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/99ee6ab.html alt=一年級上學期二單元測試 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/99ee6ab.html title=一年級上學期二單元測試>一年級上學期二單元測試</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c36f4ae6.html alt=手推公式：LSTM單元梯度的詳細的數學推導 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68dcd30ac0c0469a9bb85ea2bc9f3e8c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c36f4ae6.html title=手推公式：LSTM單元梯度的詳細的數學推導>手推公式：LSTM單元梯度的詳細的數學推導</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d1c2a0c.html alt=塑料扯斷伸長率的概念及測試要點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/6fe0ba07-c929-4046-9216-7f6d5eaa1716 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d1c2a0c.html title=塑料扯斷伸長率的概念及測試要點>塑料扯斷伸長率的概念及測試要點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html alt=時間繼電器測試儀的使用方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1205bf787f1f4de6a5f1e73e7737887b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html title=時間繼電器測試儀的使用方法>時間繼電器測試儀的使用方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bee6be40.html alt=河北省邯鄲市計量測試所大力實施專業技能提升行動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bee6be40.html title=河北省邯鄲市計量測試所大力實施專業技能提升行動>河北省邯鄲市計量測試所大力實施專業技能提升行動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd4ac23e.html alt=輪轂軸承單元的預載範圍縮小 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f13f9a1f6cc4488dbd353044370023b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd4ac23e.html title=輪轂軸承單元的預載範圍縮小>輪轂軸承單元的預載範圍縮小</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9b084990.html alt=介質損耗測試儀的操作方法與注意事項 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/1a746168-e5df-4643-9117-3f1fb4faf100 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9b084990.html title=介質損耗測試儀的操作方法與注意事項>介質損耗測試儀的操作方法與注意事項</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d38b572e.html alt=有關於射頻測試設備：電纜/天線分析儀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0e79c2e668d84f09be994180e66f90c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d38b572e.html title=有關於射頻測試設備：電纜/天線分析儀>有關於射頻測試設備：電纜/天線分析儀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0f90fbd.html alt=透氣性、透氣度測試知多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/45ac8fb9-3365-4327-901d-b21b7cd9cbbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0f90fbd.html title=透氣性、透氣度測試知多少？>透氣性、透氣度測試知多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26e2bf51.html alt=振動測試中需要了解的27個常識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/523bd012e455466f857587d9314c3084 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26e2bf51.html title=振動測試中需要了解的27個常識>振動測試中需要了解的27個常識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72951256.html alt=現場密度測試方法——灌砂法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e780002be67a3fa5bad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72951256.html title=現場密度測試方法——灌砂法>現場密度測試方法——灌砂法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html alt=測試開發專題：spring-boot統一異常捕獲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/135918e30e2f4a2ea248b539eb383688 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html title=測試開發專題：spring-boot統一異常捕獲>測試開發專題：spring-boot統一異常捕獲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/01e5dc8b.html alt=汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1527412810099aa43fbd71b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/01e5dc8b.html title=汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險>汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>