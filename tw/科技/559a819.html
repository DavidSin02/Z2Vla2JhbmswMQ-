<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從面向對象的設計模式看軟件設計 | 极客快訊</title><meta property="og:title" content="從面向對象的設計模式看軟件設計 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/967b7bdd49df46e182dcdf48e30539a4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/559a819.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/559a819.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/559a819.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/559a819.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/559a819.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/559a819.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/559a819.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/559a819.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="從面向對象的設計模式看軟件設計"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/559a819.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從面向對象的設計模式看軟件設計</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote>來源：https://coolshell.cn/articles/8961.html</blockquote><p class=ql-align-justify><strong>什麼是模式</strong></p><p class=ql-align-justify>在正式說明GoF的那23個經典的設計模式其實和OO關係不大並和Unix的設計思想很相似的這個觀點之前，讓我先來說說什麼是模式？設計模式的英文是Design Pattern，模式是Pattern的漢譯。所謂Pattern就是一種規則，或是一種模型，或是一種習慣。Pattern這個東西到處都是，並不只有技術圏子裡才有。比如：</p><ul><li class=ql-align-justify>文章有文章的Pattern。如新聞有新聞的Pattern（第一段話簡述了整個新聞），詩歌總是抒情的，論文總是死板的，講稿總是高談的，漫畫總是幽默的，……</li><li class=ql-align-justify>小說有小說的Pattern。比如，</li><li class="ql-align-justify ql-indent-1">武俠小說必然要整個武林大會，整幾個NB的武功和大師，分個正派和反派，還有一個或數個驚天陰謀，壞人總是要在一開始佔盡優勢，好人總是要力挽狂瀾……</li><li class="ql-align-justify ql-indent-1">言情小說總是要有第三者，總是要有負心人，裡面的女子總是要哭得死去活來，但又痴心不改，……</li><li class=ql-align-justify>新聞聯播的模式是：頭10分鐘領導很忙，中間10分鐘人民很幸福，後10分鐘國外很亂。中國政府官方宣傳稿也模式也很明顯，各種讚美，口號，勝利，總是要堅持個什麼，團結個什麼，邁向個什麼，某某精神，某某思想，群眾情緒穩定，不明真相，等等……</li><li class=ql-align-justify>春節的模式是，回家，吃餃子，放個鞭炮，給壓歲錢，同學聚會…… 同學聚會的模式基本上都是在飯桌上回憶一下校園時光，比較一下各自的當前處境，調戲一下女同學……</li><li class=ql-align-justify>…… ……</li></ul><p class=ql-align-justify>這就是Pattern，只要你細心觀察，你會發現這世間有很多很多的Pattern。</p><p class=ql-align-justify><strong>GoF的23個設計模式</strong></p><p class=ql-align-justify>《設計模式》這本書中，GoF這四個人總結了23個經典的面向對象的設計模式，某中有5個創建模式，7個結構模式，11個行為模式。<strong>很多人都會覺得這是面向對象的設計模式，很多人也覺得非面向對象不能用這些模式。我覺得這是一種教條主義。</strong>就像《那些流行的編程方法》中的“設計模式驅動型編程”一樣，就像《如此理解面向對象》一樣的那麼的滑稽。</p><p class=ql-align-justify>好了，回到我的論點——“<strong>GoF的這23個設計模式和OO關係不大，並且和Unix的設計思想基本一致，只不過GoF用OO實現了它們</strong>”，就像我上面說過的那些生活中的Pattern一樣，只要你仔細思考，你會發現這23個設計模式在我們的生活和社會中也能有他們的身影。而且也一樣可以用OO的方式實現之。</p><p class=ql-align-justify>讓我們來看看這23個經典的設計模式中的幾個常用的模式：</p><p class=ql-align-justify><strong>Factory 模式</strong>，這個模式可能是是個人都知道的模式。這個模式在現實社會中就像各種工廠一樣，工廠跨界的不多，基本上都是在生產同一類的產品，有的生產汽車，有的生產電視，有的生產衣服，有的生產衛生紙……基本上來說，一個生產線上只有做同一類的東西。這和Factory模式很相似。編程中，像內存池，線程池，連接池等池化技術都是這個模式，當然，Factory給你的一個對象，而不單單只是資源，factory創建出來的對象都有同樣的接口可以被多態調用。<strong>這其實和Unix把所有的硬件都factory成文件一樣，並提供了read/write等文件操作來讓你操作任意設備的I/O</strong>。</p><p class=ql-align-justify><strong>Abstract Factor</strong>y：抽象工廠這個模式是創建一組有同一主題的不同的類。這個模式在現實社會當中也有很多例子，比如：</p><ul><li class=ql-align-justify>移動公司的合約機計劃，88套餐（通話100分鐘，短信100條，彩信，20條，上網200M），128套餐（通話200分鐘，短信150條，彩信50條，上網500M）……</li><li class=ql-align-justify>家裡的裝修，總是要有廚衛，有門，有燈，有沙發，有茶几，有床，有衣櫃，有電視，有冰箱，有洗衣機……，這些都是必需的，只是每個家庭裡的具體裝修不一樣。</li><li class=ql-align-justify>Diablo遊戲中的Normal，Hard，Nightmare，Hell模式，這些模式的怪和場景和故事情況都差不多，就是每個場景的怪物和裝備的屬性不一樣。或是WarCraft中的地圖就是一個Abstract Factory模式(注：Warcraft的地圖什麼都能幹)。這和學校中的小學，初中，高中，大學差不多，都是一樣的學習環境，一樣的教學方式，一樣的教室，都要期中考和期末考，都有班長和科代表，就是學的東西的難度不一樣，但基本上都是語文，英語，數，理，化，還有永遠都有的政治課。學校就是一個抽象工廠。</li></ul><p class=ql-align-justify>這就是抽象工廠的業務模型（或是：Business Pattern），你覺得是不是不一定非要用OO來實現這樣的模式？（我們思考一下，我們會不會被先入為主了，覺得不會OO都不知道怎麼實現了），不用OO，用相同格式但內容不同的配置文件是不是也能實現？在Unix下<strong>，抽象工廠這個模式在Unix下就像是/etc/rcX.d下的那些東西，1代表命令行單用戶，2，代表命令行多用戶，3代表命令行多用戶完整模式啟動，5代表圖形界面啟動，0代表關機，6代表重啟，你要切換的話，init &lt;X>就行了</strong>。</p><p class=ql-align-justify><strong>Prototype模式</strong>，原型模式，複製一個類的實現。這個模式在現實中的例子也有很多：傳真，複印，都是這個模式。<strong>Unix進程和Github項目的Fork就是一種。進程fork明顯不是OO的模型</strong>（參看：關於Fork的一道面試題）。用非OO的方法同樣可以實現這個模式。</p><p class=ql-align-justify><strong>Singleton模式</strong>，單例模式。生活中，公司只有一個CEO，法律限制你只能有一個老婆，你只能有一個身份證號，一個TCP端口只能被一個進程使用，等等。軟件開發方面，並不一定只有OO才能做到，你可以用一個全局變量，一箇中心服務器，甚至可以使用行政手段來約束開發中不會出現多個實例。<strong>Unix下實現單例進程的一個最常用的實踐是在進程啟動的時候用“(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)”模式打開一個“鎖文件”</strong>。</p><p class=ql-align-justify><strong>Adapter模式</strong>，適配器模式。可以兼容歐洲美國中國的插頭或插座，萬能讀卡器，可以播放各種格式多媒體文件的插放器，可以解析FTP/HTTP/HTTPS/等網絡協議的瀏覽器，可以兼容各大銀行的銀聯接口、支付寶、Paypal、VISA等銀行接口，可以適配各種後端的解釋器的Nginx或Apache，等等。用非OO的編程方式就是重新包裝成一個標準接口。<strong>這個模式很像Unix下的/dev下的那些文件，操作系統把系統設備適配成文件，於是你就可以使用read/write來進行讀寫了</strong>。</p><p class=ql-align-justify><strong>Bridge模式</strong>，橋接模式。這個模式用的更多，比如一個燈具可以接各種燈泡或燈管，一個電鑽可以換上不同的鑽頭來適應不同的材料，一輛汽車可以隨時更換不同的輪胎來適應不同的路面，你的桌面可以隨時更換一個圖片來適應你的心情，你的單反相機可以更換不同的鏡頭來拍不同的照片…… 橋接模式說白了就是組件化，模塊化，可以自由拼裝。在OO中，其主要是通過讓業務類組合一個標準接口來完成，這在非OO的程序設計中用得實在是太多了，主要是通過回調函數或是標準接口來實現。這個也是Unix設計哲學中的主要思想。<strong>在Unix中，文件的權限使用的就是Bridge模式，標準接口是用戶，用戶組和其它，rwx三個模式，然後用 chmod/chown改一改，這文件就有不同的屬主和屬性了</strong>。</p><p class=ql-align-justify><strong>Decorator模式</strong>，裝飾模式。這個模式在生活中太多了，你給你的手機或電腦貼個什麼，掛個什麼，吃東西的時候加點什麼佐料，多點肉還是多個蛋，一個Unix/Linux命令的各種參數是對這個命令的修飾，等等。<strong>我覺得這個模式在Unix中最經常的體現就是通過管道把命令連接起來來完成一個功能</strong>，比如：ps -elf 是列進程的，用管道 grep hchen就可以達到過濾的目的，grep的邏輯沒有侵入ps中，grep 修飾了 ps，但是其組合起來完成了一個特定的功能。可見，這和OO沒有什麼關係。</p><p class=ql-align-justify><strong>Facade模式，</strong>這個模式我們每個人從會編程的時候就在無意識地用這個模式了。這個模式就是把一大堆類拼裝起來，並統一往外提供提口。在現實生活中這樣的例子太多了，比如：旅行社把機票，酒店，景點，導遊，司機，進店打了一個包叫旅行；IBM把主機，存儲，OS，J2EE，DB，網絡，流程打了個包叫企業級解決方案。Unix中最典型的一個例子就是用Shell腳本組合各種命令來創造一個新的功能，這是的Shell中的各種命令通過標準I/O這個接口進行組合交互。</p><p class=ql-align-justify><strong>Proxy模式</strong>，代理模式。我們租個房，買個機票，打個官司，都少不了代理，人大代表代理了老百姓去行使政治權力。我們去飯館裡吃飯也是一種代理模式，因為我們只管吃就好了，洗菜做飯洗碗的工作都被Proxy幫你幹了，於是你就省事多了。操作系統就是硬件的代理，CDN就是網站的代理，……使用代理你可以讓事情變理更簡單，也可以在代理層加入一些權限檢查，這樣可以讓業務模塊更關注業務，而把一些非業務的事情剝離出來交給代理以完成解耦。可見這個模式和OO沒啥關係。<strong>Unix下這個模式最佳體現就是Shell，它代理了系統調用並提供UI</strong>。還有很多命令會幫你把/proc目錄下的那些文件內容整理和顯示出來。</p><p class=ql-align-justify><strong>Chain of Responsibility模式</strong>，劫匪來搶銀行，保安搞不定，就交給110，110搞不定就交給武警。有什麼事件發生時的響應的Escalation Path，辦公中的逐級審批。這個模式用一個函數指針數組或是棧結構就可以實現了。這個思想很像編程中的異常處理機制，一層一層地往上傳遞異常直到異常被捕捉。<strong>在Unix下，一個最簡單的例子就是用 && 或 || 來把命令拼起來，如：cmd1 && cmd2 或 cmd3 || cmd4 ， 如果cmd1失敗了，cmd2就不會執行，如果cmd3失敗了，cmd4才會執行。</strong>如： cd lib && rm -rf .o 或 ping -c1 coolshell.cn && ssh haoel@coolshell.cn</p><p class=ql-align-justify><strong>Command模式</strong>，這恐怕是軟件裡最多的模式了，比如：編譯器裡的Undo/Redo，宏錄製。還有數據庫的事務處理，線程池，設置嚮導，包括程序並行執行的指令集等等。這個模式主要是把一個對象的行為封裝成一個一個的有相同接口的command，然後交給一個統一的命令執行器執行或管理這些命令。<strong>這個模式和我們的Unix/Linux機器啟動時在/etc/init.d下的那些S和K開頭的腳本很像，把各種daemon的啟動和退出行為封裝成一個腳本其支持reload/start/stop/status這樣的命令，然後把他們按一定的規範做符號鏈接到/etc/init.d目錄下，這樣操作系統就會接管這些daemon的啟動和退出</strong>。</p><p class=ql-align-justify><strong>Observer模式</strong>，觀察者模式，這個模式也叫pub-sub模式，很像我們用手機訂閱手機報，微博的follow的信息流也是這樣的一個模式。MVC中的C會sub V中的事件，用非OO的方式其實也是一個回調函數的事。在很多異步系統中，你需要知道最終的調用有沒有成功，比如說調用支付寶的支付接口，你需要向支付寶註冊一個回調的接口，以便支付寶回調你。<strong>Linux下的一些系統調用如epoll/aio/inotify/signal都是這種思路</strong>。</p><p class=ql-align-justify><strong>Strategy 模式</strong>，策略模式，這個模式和Bridge模式很像，只不過Bridge是結構模式，其主要是用於對象的構造；而Strategy是行為模式，主要是用於對象的行為。策略模式很像瀏覽器裡的各種插件，只要你裝了某個插件，你就有某個功能。你可以安裝多個插件來讓你的瀏覽器有更多的功能（書本上的這個模式是你只能選用一個算法，當然，我們不用那麼教條）。<strong>就像《你可能不知道的Shell》中的那個設置設置$EDITOR變量後可以按ctrl+x e啟動編譯器，或是用set -o vi或set -o emacs 來讓自己的shell像vi或 emacs 一樣，或是像find -exec或xargs一樣的拼裝命令</strong>。</p><p class=ql-align-justify><strong>Bridge 和 Strategy是OO設計模式裡的“Favor Composition Over Inheritance” 的典範，其實現了接口與實現分離的</strong>。Unix中的Shell就是一種，你可隨意地更換不同的Shell。還有Emacs中的LISP驅動C，C實現了引擎，交給LISP實現邏輯。把程序分為前端和後端，通過socket專用應用協議進行通訊，前端實現策略，後端實現機制。再看看makefile把編譯器和源代碼的解耦，命令行輸出這個接口可以把一個複雜的功能解耦並抽像成各種各樣小而美的小功能命令，等等這樣的例子，你會發現，還有大量的編程框架都會多少採用這樣的思想，可以讓你的軟件像更換汽車零件一樣方便。我在用Unix的設計思想來應對變更的需求中說過燈具廠，燈泡廠，和開關廠的例子。</p><p class=ql-align-justify><strong>後記</strong></p><p class=ql-align-justify>因為寫作倉促，上面的那些東西，可能會你讓你覺得有些牽強，那麼抱歉了，你可以幫我看看在生活中和 Unix裡有沒有更帥的例子。</p><p class=ql-align-justify>不過，我們會發現上面OO搞出來的那麼多模式在Unix下看來好像沒有那麼複雜，而且Unix下看起來並沒有那麼多模式，而且Unix中的設計模式無非就是這麼幾個關鍵詞：<strong>單一，簡潔，模塊，拼裝</strong>。我們再來看看OO設計的兩大準則：<strong>1）鍾情於組合而不是繼承，2）依賴於接口而不是實現</strong>。還有S.O.L.I.D原則也一樣（如果你仔細觀察，你會發現SOLID原則在Unix下也是完美地體現）。你看，Unix和OO設計模式是不是完美的統一嗎？</p><p class=ql-align-justify>我有種強烈的感覺——<strong>Unix對這些所謂的OO的設計模式實現得更好</strong>。因為Unix就一條設計模式！再次推薦《<em>The Art of Unix Programming</em>》</p><div class=pgc-img><img alt=從面向對象的設計模式看軟件設計 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/967b7bdd49df46e182dcdf48e30539a4><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>餐後甜點</strong></p><p class=ql-align-justify>我上面提到了《<em>The Art of Unix Programming</em>》，所以我有必要再談談這本書中我中毒最深的一章《模塊性：保持清晰和簡潔》中所談到的膠合層。</p><p class=ql-align-justify>膠合層這一節中說了，我們開發軟件一般要麼Top-Down，要麼Bottom-Up，這兩種方法都有好有不好。頂層一般是應用邏輯層，底層一般是原語層（我理解為技術沉澱層，或是技術基礎層）。自頂向下的開發，你可能會因為開發到底層後發現底層可沉澱的東西越來越不爽（因為被可能被很多業務邏輯所侵入），如果自底向上的開發，你可能越到上層你越發現很多你下面乾的基礎上工作有很多用不上（比如干多了）。所以，最好的方式是同時進行，一會頂層，一會底層，來來回回的開發——說白了就是在開發中不斷的重構，邊開發邊理解邊沉澱。</p><p class=ql-align-justify>無論怎麼樣，你會發現需要一層膠合層來膠合業務邏輯層和底層原語層（軟件開發中的業務層和技術層的膠合），Unix的設計哲學認為，這層膠合層應該儘量地薄，膠合層越多，我們就只能在其中苦苦掙扎。</p><p class=ql-align-justify>其實，<strong>膠合層原則就是分離原則上更為上層地體現，策略（業務邏輯）和機制（基礎技術或原語）的清楚的分離。你可以看到，OO和Unix都是在做這樣的分離。但是需要注意到的時，OO用抽象接口來做這個分離——很多OO的模式中，抽象層太多了，導致膠合層太過於複雜了，也就是說，OO鼓勵了——“厚重地膠合和複雜層次”，反而增加了程序的複雜度（這種情況在惡化中）。而Unix採用的是薄的膠合層，薄地相當的優雅</strong>。（通過這段話的描述，我相信你會明白了《如此理解面向對象編程》中的個例子——為什麼用OO來實現會比用非OO來實現更為地噁心——那就是因為OO膠合層太複雜了）</p><p class=ql-align-justify><strong>OO的最大的問題就——接口複雜度太高，膠合層太多！</strong>（注：Unix編程藝術這本書裡說了軟件有三個複雜度：代碼量、接口、實現，這三個東西構成了我們的軟件複雜度）</p><p class=ql-align-justify><strong>再送一個果盤</strong></p><p class=ql-align-justify>大家一定記得《SteveY對Amazon和Google平臺的長篇大論》中Amazon中那個令人非常向往的SOA式的架構。因為以前在Amazon，有些話不好說。現在可以說了，我在Amazon裡，我個人對這個服務化的架構相當的不待見，太複雜，複雜以亂七八糟，方向是好的，想法也是好的，但是這東西和OO一樣，造成大量的接口複雜度，今天的Amazon，完全沒人知道各個服務是怎麼個調用的，一團亂麻（其內部並不像你看到的AWS那麼的美妙。注：AWS是非常不錯的，是相當好的設計）。</p><p class=ql-align-justify><strong>那麼我們怎麼來解決SOA的接口複雜度問題？其實，Unix早就給出了答案——數據驅動編程</strong>（詳見：《Unix編程藝術》的第9.1章），在我離開Amazon的時候，美國總部的Principle SDE們在吐槽今天Amazon的SOA架構，更好的架構應該是數據驅動式的。（今天還在Amazon的同學可以上內網boardcast上看看相關的Principle Talk視頻）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>設計</a></li><li><a>對象</a></li><li><a>看軟件</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html alt=面向對象設計原則之開閉原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ff63803ae3d4638b01095d32682fa70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html title=面向對象設計原則之開閉原則>面向對象設計原則之開閉原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html alt=面向對象設計的七大原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd44e43836e64ae3b2c4d6e9ffa9f033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html title=面向對象設計的七大原則>面向對象設計的七大原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html alt=面向對象設計之依賴倒置原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html title=面向對象設計之依賴倒置原則>面向對象設計之依賴倒置原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html alt=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/93686fc2-2a36-4161-8664-03ae59f6e71e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html title=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺>面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html alt=C++面向對象設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c001c4074d3f4c658dfea942671f0ea6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html title=C++面向對象設計>C++面向對象設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html alt=Python面向對象設計和麵向對象編程解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html title=Python面向對象設計和麵向對象編程解析>Python面向對象設計和麵向對象編程解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html alt=什麼是“面向對象”程序設計-以Python為例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/12f1d2422ce145819ebe4973dcfa2b89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html title=什麼是“面向對象”程序設計-以Python為例>什麼是“面向對象”程序設計-以Python為例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3924ddd.html alt=軟考自查：面向對象設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8fc841fb0334a72ba00b8186b247534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3924ddd.html title=軟考自查：面向對象設計>軟考自查：面向對象設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c10ee1cd.html alt=關於面向對象程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c10ee1cd.html title=關於面向對象程序設計>關於面向對象程序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html alt=面向對象編程設計的類與對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/86e56bdd947940c4b06129e01f19706a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html title=面向對象編程設計的類與對象>面向對象編程設計的類與對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0663a3e1.html alt=面向對象設計的工作步驟一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/900239b473b34a7bb4a3a15a93f05bdc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0663a3e1.html title=面向對象設計的工作步驟一>面向對象設計的工作步驟一</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/864c3f59.html alt=C++面向對象程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b42379075324d628f329f2d6e793e4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/864c3f59.html title=C++面向對象程序設計>C++面向對象程序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html alt=Java程序設計-面向對象思路（筆記） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9fcc6e3cac554acc8790d6b14e6aceaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html title=Java程序設計-面向對象思路（筆記）>Java程序設計-面向對象思路（筆記）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/051b30a8.html alt=一種基於面向對象思想的c程序設計方法及系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/47a4c40dab944a948cd9a3c6d3fc26ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/051b30a8.html title=一種基於面向對象思想的c程序設計方法及系統>一種基於面向對象思想的c程序設計方法及系統</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>