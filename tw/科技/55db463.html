<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入瞭解一些Android動畫 | 极客快訊</title><meta property="og:title" content="深入瞭解一些Android動畫 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ee4f15e064504e11869881b7ee7dbd0d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55db463.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><meta property="article:published_time" content="2020-10-29T20:50:38+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:38+08:00"><meta name=Keywords content><meta name=description content="深入瞭解一些Android動畫"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/55db463.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入瞭解一些Android動畫</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、PropertyValuesHolder</h1><p>閱讀本文需要上一本Android屬性動畫的基礎，這樣才可以明白接下來要講什麼。</p><h2 class=pgc-h-arrow-right>1.理解和使用</h2><p>PropertyValuesHolder 是ObjectAnimation類似的一個方法，只是少了一個target，就是要執行的控件。看看正常的使用方法：會同時執行全部的Holder</p><pre><code>public void  doPropertyValuesHolder(){        //定義一個旋轉Holder        PropertyValuesHolder rotationHolder=                PropertyValuesHolder.ofFloat(                        "rotation",                        60f,40f,100f,-60f,40f,88f,77f);        //定義一個透明Holder        PropertyValuesHolder alphaHolder=                PropertyValuesHolder.ofFloat(                        "alpha",                        0.01f,0.5f,1.0f,0.8f,0.2f,0.0f);        //加載進ObjectAnimator        ObjectAnimator objectAnimator=ObjectAnimator.ofPropertyValuesHolder(ballImageView,rotationHolder,alphaHolder);        objectAnimator.setDuration(3000);        objectAnimator.start();    }</code></pre><h2 class=pgc-h-arrow-right>2.方法和參數</h2><p>可以看看這個方法的參數：</p><pre><code>ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values)</code></pre><pre><code>PropertyValuesHolder ofFloat(String propertyName, float... values)</code></pre><p>Object target 是要顯示動畫的控件</p><p>PropertyValuesHolder... values 裝載多個PropertyValuesHolder</p><p>String propertyName 代表要反射的參數，跟ObjectAnimation的參數是一樣的</p><p>float... values 代表是可變長參數 這樣的方法還有以下圖片這些：</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee4f15e064504e11869881b7ee7dbd0d><p class=pgc-img-caption></p></div><p>其中ofObject()方法 ，也是跟ObjectAnimation的相似，也是要自定義TypeEvaluator。</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c20d7deef644470a8e143dd181aceb86><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>二、Keyframe</h1><h2 class=pgc-h-arrow-right>1.理解和使用</h2><p>看名字，就是理解為關鍵幀的意思，在動畫中，在某幀做一些操作，從而實現對比效果比較明顯的效果。 關鍵幀表示是某個物體在哪個時間點應該在哪個位置上。 具體使用：</p><pre><code> public void  doPropertyValuesHolderKeyFrame(){        //頭keyframe1，從進度0.6開始，在進度60%的時候，數值是0.1f        Keyframe keyframe1=Keyframe.ofFloat(0.6f,0.1f);        //中間keyframe2        Keyframe keyframe2=Keyframe.ofFloat(0.1f,0.8f);        //尾部keyframe3，以50%進度作為結束，這時候的數值為0.2f        Keyframe keyframe3=Keyframe.ofFloat(0.5f,0.2f);        //裝載到Holder中，並設置要反射的方法，這是反射的是setAlpha()方法，控制透明度        PropertyValuesHolder alphaHolder=PropertyValuesHolder.ofKeyframe("alpha",keyframe1,keyframe2,keyframe3);        //把裝載到Holder中裝載到ObjectAnimator或者ValueAnimation        ObjectAnimator objectAnimator=ObjectAnimator.ofPropertyValuesHolder(ballImageView,alphaHolder);        objectAnimator.setDuration(3000);        objectAnimator.start();    }</code></pre><h2 class=pgc-h-arrow-right>2.方法和參數</h2><pre><code>Keyframe ofFloat(float fraction, float value)</code></pre><p>float fraction 表示進度</p><p>float value 表示在這個進度下的數值</p><pre><code> PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</code></pre><p>String propertyName 要反射的set方法</p><p>Keyframe... values 傳入Keyframe</p><p>Keyframe的方法，也是和其他的類似的。</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a376cc480be040d29b655e1d4071d467><p class=pgc-img-caption></p></div><p>Keyframe的set方法，設置進度，插值器，數值。 沒有設置插值器的時候，默認是線性插值器</p><pre><code> keyframe1.setInterpolator(new LinearInterpolator()); //默認線性插值器</code></pre><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fbb2b7bfe53e4c13a2d95d25f1d731d6><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>3.幀的操作</h2><p>直接寫結論：</p><ul><li>如果去掉0幀，則以第一個關鍵幀為起始位置</li><li>如果去掉結束幀（進度為1），則以最後一個關鍵幀為結束位置</li><li>使用keyframe來構建動畫，至少需要2幀</li></ul><h1 class=pgc-h-arrow-right>三、ViewPropertyAnimator</h1><h2 class=pgc-h-arrow-right>1.理解和使用</h2><p>可以通過串行的形式，快速定義動畫，省去一些定義，在每次界面繪製的時候，啟動動畫，比其他的更節省消耗。 比如：</p><pre><code> ballImageView.animate().alpha(0.5f).rotation(360f).scaleX(1.5f).translationX(100f);</code></pre><h2 class=pgc-h-arrow-right>2.參數和方法</h2><p>可以看到這些方法的返回值，基本都是ViewPropertyAnimator</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/33e72dc69af4456daf9d5ae696ba8931><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9c20521105694cf6bcc01577ec0a3091><p class=pgc-img-caption></p></div><p>再引用一張表格：</p><p>函數 含義 alpha(float value) 設置透明度 scaleY(float value) 設置 Y軸方向的縮放大小 scaleX(float value) 設置X軸方向的縮放大小 translationY(float value) 設置Y軸方向的移動值 translationX(float value) 設置X軸方向的移動值 rotation(float value) 設置繞Z軸旋轉度數 rotationX(float value) 設置繞x軸旋轉度數 rotationY(float value) 設置繞 Y 軸旋轉度數 x(float value) 相對於父容器的左上角座標在 X軸方向的最終位置 y(float value) 相對於父容器的左上角座標在Y軸方向的最終位置 alphaBy(float value) 設置透明度增量 rotationBy(float value) 設置繞Z軸旋轉增量 rotationXBy(float value) 設置繞 X 油旋轉增量 rotationYBy(float value) 設置統Y軸旋轉增量 translationXBy(float value) 設置X軸方向的移動值增量 translationYBy(float value) 設置Y軸方向的移動值增量 scaleXBy(float value) 設置X軸方向的縮放大小增量 scaleYBy(float value) 設置 Y軸方向的縮放大小增量 xBy(float value) 相對於父容器的左上角座標在 X軸方向的位置增量 yBy(float value) 相對於父容器的左上角座標在 Y軸方向的位置增量 setlnterpolator(Timelnterpolator interpolator) 設置插值器 setStartDelay(long startDelay) 設置開始延時 setDuration(long duration) 設置動畫時長</p><h1 class=pgc-h-arrow-right>四、animateLayoutChanges</h1><p>android:animateLayoutChanges="true" 在Layout加入控件，或者移除控件的時候，添加動畫，但是隻能使用默認動畫。</p><pre><code> &lt;LinearLayout            android:animateLayoutChanges="true"            android:layout_width="match_parent"            android:layout_height="match_parent"            android:orientation="vertical"/&gt;</code></pre><h1 class=pgc-h-arrow-right>五、LayoutTransition</h1><p>LayoutTransition可以控制ViewGroup的動畫，可以使用自定義的動畫。 具體使用：</p><pre><code> public void doLayoutTransition(){        LinearLayout linearLayout=new LinearLayout(this);        //1.創建實例        LayoutTransition transition=new LayoutTransition();        //2.創建動畫        ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(null,"rotation",0f,90f,0f);        //3.動畫出現形式進行設置        transition.setAnimator(LayoutTransition.DISAPPEARING,objectAnimator);        //4.將LayoutTransition設置到ViewGroup中        linearLayout.setLayoutTransition(transition);          //5.開源動畫庫 NineOldAndroids    }</code></pre><p>setAnimator(int transitionType, Animator animator)</p><p>這個方法中，transitionType有五個選項</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/376a1c51788048f99470d2f1c2801260><p class=pgc-img-caption></p></div><p>CHANGE_APPEARING 由於容器中要顯示一個新的元素，其他需要變化的元素所應用的動畫（問題多，不常用）</p><p>_CHANGE_DISAPPEARING_ 當個容器中某個元素要消失時，其他需要變化的元素所應用的動畫（問題多，不常用）</p><p>_CHANGING_ 容器中正在更改的元素的動畫變化</p><p>_APPEARING_ 元素在容器中出現時所定義的動畫</p><p>_DISAPPEARING_ 元素在容器中消失時所定義的動畫</p><h1 class=pgc-h-arrow-right>六、PathMeasure</h1><p>PathMeasure類似一個計算器，可以計算出目標path的座標，長度等</p><h2 class=pgc-h-arrow-right>1.初始化</h2><pre><code>  public void doPathMeasure(){        Path path=new Path();        //初始化方法1        PathMeasure pathMeasure1=new PathMeasure();        pathMeasure1.setPath(path,true);        //初始化方法2        PathMeasure pathMeasure2=new PathMeasure(path,false);    }</code></pre><p>setPath(Path path, boolean forceClosed) path 就是代表要計算的目標Path。 forceClosed 是否閉合，true會計算閉合狀態下的Path，false會按照Path原來情況來計算。</p><h2 class=pgc-h-arrow-right>2.函數調用</h2><p>自定義一個view</p><pre><code>public class PathView extends View {    Path mPath;    Paint mPaint;    PathMeasure mPathMeasure;    public PathView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        mPath=new Path();        mPaint=new Paint();        mPathMeasure=new PathMeasure();    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        canvas.translate(250,250); //畫布移動        mPaint.setColor(Color.BLUE); //畫筆顏色        mPaint.setStrokeWidth(5); //畫筆粗細        mPaint.setStyle(Paint.Style.STROKE); //畫筆風格        mPath.moveTo(0,0);        mPath.lineTo(0,100);        mPath.lineTo(100,100);        mPath.lineTo(100,0);        mPathMeasure.setPath(mPath,true);        Log.v("showLog",                "getLength()=="+mPathMeasure.getLength()                        +"  isClosed()=="+ mPathMeasure.isClosed()); //結果400.0  true        mPathMeasure.setPath(mPath,false);        Log.v("showLog",                "getLength()=="+mPathMeasure.getLength()                        +"  isClosed()=="+ mPathMeasure.isClosed()); //結果300.0  false        canvas.drawPath(mPath,mPaint); //繪製路徑    }}</code></pre><p>繪製效果：</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cdb95babbae8487ca5b6ebaa22dd5983><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.1 PathMeasure.getLength()</h3><p>PathMeasure.getLength() 函數用於測量路徑的長度</p><h3 class=pgc-h-arrow-right>2.2 PathMeasure.isClosed()</h3><p>PathMeasure.isClosed() 函數用於返回是否測量閉合狀態</p><h3 class=pgc-h-arrow-right>2.3 PathMeasure.nextContour()</h3><pre><code>           mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);        canvas.drawPath(mPath, mPaint);        mPath.addRect(-100, -100, 100, 100, Path.Direction.CW);        canvas.drawPath(mPath, mPaint);        mPath.addRect(-120, -120, 120, 120, Path.Direction.CW);        canvas.drawPath(mPath, mPaint);        mPathMeasure.setPath(mPath, false);        do {            float len = mPathMeasure.getLength();            Log.v("showLog", "len=" + len);        } while (mPathMeasure.nextContour());</code></pre><p>效果：</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fd3d920653774afbbfd834f878cb2857><p class=pgc-img-caption></p></div><p>打印結果：</p><pre><code>len=400.0len=800.0len=960.0</code></pre><p>PathMeasure.nextContour()得到的順序與添加的Path的順序相同</p><p>PathMeasure.getLength()只是得到當前path的長度，不是全部的長度</p><h3 class=pgc-h-arrow-right>2.3 getSegment()</h3><p>使用getSegment函數需要禁用硬件加速 在構造方法中加入 setLayerType(LAYER_TYPE_SOFTWARE,null);</p><pre><code>         mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);        mPathMeasure.setPath(mPath,false); //計算的path        mPathMeasure.getSegment(0,150,mDstPath,true); //截取並添加到mDstPath，是添加，不是其他        canvas.drawPath(mPath, mPaint); //繪製原來的path        canvas.translate(200,0); //畫布移動        mPaint.setColor(Color.RED);        canvas.drawPath(mDstPath, mPaint); //繪製添加後的mDstPath</code></pre><pre><code> boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</code></pre><p>startDpath開始截取的點，截取的起始點，是以左上角的點開始的</p><p>stopD截取停止的點</p><p>dst截取後添加到的path</p><p>startWithMoveTo是否保存原狀，true保存原樣，false則會連接初始點和終點，和原來的不一定相同形狀 以上代碼的效果: 截圖的方向，與原來的path的生成方向有關</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/852d4797db5c4b068f32a4f353728fdd><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.4 動態畫圓的例子</h3><p>代碼：</p><pre><code>public class PathView extends View {    Path mPath, mDstPath;    Paint mPaint;    PathMeasure mPathMeasure;    float mCurAnimValue;    public PathView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        setLayerType(LAYER_TYPE_SOFTWARE, null);        mPath = new Path();        mDstPath = new Path();        mPaint = new Paint();        mPathMeasure = new PathMeasure();        mPaint.setColor(Color.BLUE); //畫筆顏色        mPaint.setStrokeWidth(5); //畫筆粗細        mPaint.setStyle(Paint.Style.STROKE); //畫筆風格        mPath.addCircle(100, 100, 50, Path.Direction.CW); //一個完整的圓        mPathMeasure.setPath(mPath, true); //要計算的path        ValueAnimator animator = ValueAnimator.ofFloat(0, 1); //進度 0~1        animator.setRepeatCount(ValueAnimator.INFINITE); //無限循環        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                mCurAnimValue = (Float) animation.getAnimatedValue(); //得到當前的進度                invalidate();//重繪，重新執行onDraw()方法            }        });        animator.setDuration(5000);        animator.start();    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        canvas.translate(100, 100); //畫布移動        float stop=mPathMeasure.getLength()*mCurAnimValue; //一個進度確定一個截取點        mDstPath.reset();        mPathMeasure.getSegment(0,stop,mDstPath,true); //一點點添加        canvas.drawPath(mDstPath,mPaint); //每次有進度更新，就繪製一小段截取    }}</code></pre><p>效果：</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/91192788a7424bd79bb6e3985019444a><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.5 getPosTan()</h3><p>先看看函數的定義：</p><pre><code>boolean getPosTan(float distance, float pos[], float tan[]) </code></pre><p>float distance 距離path的其實長度</p><p>float pos[] 該點的座標值。x和y pos[0]=x，pos[1]=y</p><p>float tan[] 該點的正切值。x和y pos[0]=x，pos[1]=y tan&lt;a=y/x</p><h3 class=pgc-h-arrow-right>2.6 箭頭畫圓的例子</h3><p>代碼：</p><pre><code>public class PathView extends View {    Path mPath, mDstPath;    Paint mPaint;    PathMeasure mPathMeasure;    float mCurAnimValue;    Bitmap mArrowBmp;    float[] mPos;    float[] mTan;    int mCenterX,mCenterY;    float mRadius;    public PathView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        setLayerType(LAYER_TYPE_SOFTWARE, null);        mPath = new Path();        mDstPath = new Path();        mPaint = new Paint();        mPathMeasure = new PathMeasure();        mPos=new float[2];        mTan=new float[2];        //加載箭頭圖片        mArrowBmp= BitmapFactory.decodeResource(getResources(), R.drawable.arrow);        mPaint.setColor(Color.BLUE); //畫筆顏色        mPaint.setStrokeWidth(5); //畫筆粗細        mPaint.setStyle(Paint.Style.STROKE); //畫筆風格        mPath.addCircle(540, 972, 486, Path.Direction.CW); //一個完整的圓        mPathMeasure.setPath(mPath, true); //要計算的path        ValueAnimator animator = ValueAnimator.ofFloat(0, 1); //進度 0~1        animator.setRepeatCount(ValueAnimator.INFINITE); //無限循環        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                mCurAnimValue = (Float) animation.getAnimatedValue(); //得到當前的進度                invalidate();//重繪，重新執行onDraw()方法            }        });        animator.setDuration(5000);        animator.start();    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        /*         * 得到h,w的最小的那個值;         * &gt;&gt; 1 移位 跟 /2 相同;         * 乘以0.9f,表示佔佈局的90%         * */        mRadius = (Math.min(h, w) &gt;&gt; 1) * 0.9f;        // 中心座標        mCenterX = w / 2;        mCenterY = h / 2;        Log.v("showLog",mCenterX+"  "+mCenterY+"  "+mRadius);        postInvalidate();        super.onSizeChanged(w, h, oldw, oldh);    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        float stop=mPathMeasure.getLength()*mCurAnimValue; //一個進度確定一個截取點        mDstPath.reset();        mPathMeasure.getSegment(0,stop,mDstPath,true); //一點點添加        canvas.drawPath(mDstPath,mPaint); //每次有進度更新，就繪製一小段截取        mPathMeasure.getPosTan(stop,mPos,mTan); //獲得每點的正切值和座標        /**         *    Math.atan2(mTan[1],mTan[0])獲得tan的弧度值         *    *180.0/Math.PI將轉化為角度值         * */        float degrees=(float)(Math.atan2(mTan[1],mTan[0])*180.0/Math.PI);        Matrix matrix=new Matrix();        /**         * 將圖片圍繞中心點旋轉指定角度         * postRotate(float degrees, float px, float py)         * degrees是角度  （px,py）是圖片中心點         * */        matrix.postRotate(degrees,mArrowBmp.getWidth()/2,mArrowBmp.getHeight()/2);        /**         * 將圖片從默認的（0，0）點移動到路徑的最前端         * */        matrix.postTranslate(mPos[0]-mArrowBmp.getWidth()/2,mPos[1]-mArrowBmp.getHeight()/2);        //繪製圖片        canvas.drawBitmap(mArrowBmp,matrix,mPaint);    }}</code></pre><p>效果：</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5504f7ffdf344e98b5ba748f9cc7eed3><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.7 getMatrix()</h3><p>參數類型：</p><pre><code>boolean getMatrix(float distance, Matrix matrix, int flags)</code></pre><p>使用方法：</p><pre><code>          //計算方位角        Matrix matrix = new Matrix();        //獲取位置信息        mPathMeasure.getMatrix(stop,matrix,PathMeasure.POSITION_MATRIX_FLAG);        //獲取切邊信息        mPathMeasure.getMatrix(stop,matrix,PathMeasure.TANGENT_MATRIX_FLAG); </code></pre><h3 class=pgc-h-arrow-right>2.8 支付成功例子</h3><pre><code>public class TickView extends View {    Path mPath, mDstPath;    Paint mPaint;    PathMeasure mPathMeasure;    float mCurAnimValue;    int mCenterX, mCenterY;    float mRadius;    public TickView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        setLayerType(LAYER_TYPE_SOFTWARE, null);        mPath = new Path();        mDstPath = new Path();        mPaint = new Paint();        mPathMeasure = new PathMeasure();        mPaint.setColor(Color.BLUE); //畫筆顏色        mPaint.setStrokeWidth(5); //畫筆粗細        mPaint.setStyle(Paint.Style.STROKE); //畫筆風格        mCenterX = 540;        mCenterY = 972;        mRadius = 486 / 2;        /**         * 圓         * */        mPath.addCircle(mCenterX, mCenterY, mRadius, Path.Direction.CW);        /**         * 對勾         * */        mPath.moveTo(mCenterX - mRadius / 2, mCenterY);        mPath.lineTo(mCenterX, mCenterY + mRadius / 2);        mPath.lineTo(mCenterX + mRadius / 2, mCenterY - mRadius / 3);        mPathMeasure.setPath(mPath, false); //要計算的path        ValueAnimator animator = ValueAnimator.ofFloat(0, 2); //進度 0~1 是圓，1~2是對勾        animator.setRepeatCount(ValueAnimator.RESTART);        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                mCurAnimValue = (Float) animation.getAnimatedValue(); //得到當前的進度                invalidate();//重繪，重新執行onDraw()方法            }        });        animator.setDuration(5000);        animator.start();    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        /*         * 得到h,w的最小的那個值;         * &gt;&gt; 1 移位 跟 /2 相同;         * 乘以0.9f,表示佔佈局的90%         * */        mRadius = (Math.min(h, w) &gt;&gt; 1) * 0.9f;        // 中心座標        mCenterX = w / 2;        mCenterY = h / 2;        Log.v("showLog", mCenterX + "  " + mCenterY + "  " + mRadius);        postInvalidate();        super.onSizeChanged(w, h, oldw, oldh);    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        if (mCurAnimValue &lt; 1) {            float stop = mPathMeasure.getLength() * mCurAnimValue;            mPathMeasure.getSegment(0, stop, mDstPath, true);        } else if (mCurAnimValue == 1) {            mPathMeasure.getSegment(0, mPathMeasure.getLength(), mDstPath, true);            mPathMeasure.nextContour();        } else {            float stop = mPathMeasure.getLength() * (mCurAnimValue - 1);            mPathMeasure.getSegment(0, stop, mDstPath, true);        }        canvas.drawPath(mDstPath, mPaint);    }}</code></pre><p>效果：</p><div class=pgc-img><img alt=深入瞭解一些Android動畫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/930b90db257c42069501f2e75f43e805><p class=pgc-img-caption></p></div><p>編程中我們會遇到多少挫折？表放棄，沙漠盡頭必是綠洲。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>瞭解</a></li><li><a>Android</a></li><li><a>動畫</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html alt=兩分鐘瞭解低損耗電纜結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9af84f52bbed4ee39f3825e0f43e619b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html title=兩分鐘瞭解低損耗電纜結構>兩分鐘瞭解低損耗電纜結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48a98575.html alt=《獅子王》：引入VR虛擬製作技術的真人動畫電影 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RWRwBuj8EnLKpd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48a98575.html title=《獅子王》：引入VR虛擬製作技術的真人動畫電影>《獅子王》：引入VR虛擬製作技術的真人動畫電影</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html alt=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/decf8edb02a34404b92b86681378575f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html title=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html alt=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcdae811e636496d948cf5a745f470fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html title=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html alt=「瞭解」房屋的層高和淨高怎麼算？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1526054178152a496189726 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html title=「瞭解」房屋的層高和淨高怎麼算？>「瞭解」房屋的層高和淨高怎麼算？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2db74f7c.html alt=瞭解鍋爐循環泵與換熱站循環泵的佈置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533630871099dca28f1fe7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2db74f7c.html title=瞭解鍋爐循環泵與換熱站循環泵的佈置>瞭解鍋爐循環泵與換熱站循環泵的佈置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html alt=做跨境電商站外推廣，你必須瞭解的Facebook像素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2df772dcb2d747f8b55ff9e4610cbcad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html title=做跨境電商站外推廣，你必須瞭解的Facebook像素>做跨境電商站外推廣，你必須瞭解的Facebook像素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed10eec0.html alt=瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/79d0cee860504ee48c8e419052ceab23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed10eec0.html title=瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？>瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html alt=瞭解生成對抗網絡（GAN） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/634604de44ad4d17931ccc0bcf3e46ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html title=瞭解生成對抗網絡（GAN）>瞭解生成對抗網絡（GAN）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2f3b02a.html alt=牆繪知識來了，帶你一分鐘瞭解丙烯顏料 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f33c910d91a847bdb6baabc3ab01e0cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2f3b02a.html title=牆繪知識來了，帶你一分鐘瞭解丙烯顏料>牆繪知識來了，帶你一分鐘瞭解丙烯顏料</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6114a4bb.html alt=格鬥周：帶你瞭解各類格鬥術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/46b75604edfa491990901ac982573db9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6114a4bb.html title=格鬥周：帶你瞭解各類格鬥術>格鬥周：帶你瞭解各類格鬥術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/444cae24.html alt=瞭解房屋建築圈樑 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/154043230417821ced6ef46 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/444cae24.html title=瞭解房屋建築圈樑>瞭解房屋建築圈樑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57257e28.html alt=你對鋼製文件櫃瞭解多少呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad059f36d954de2b5517d99057887f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57257e28.html title=你對鋼製文件櫃瞭解多少呢>你對鋼製文件櫃瞭解多少呢</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>