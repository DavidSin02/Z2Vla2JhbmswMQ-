<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++堆與棧詳解 | 极客快訊</title><meta property="og:title" content="C++堆與棧詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/25545ad985a24c7e944f3e7978f6d660"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55f48b84.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55f48b84.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55f48b84.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55f48b84.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55f48b84.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55f48b84.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55f48b84.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55f48b84.html><meta property="article:published_time" content="2020-10-29T21:10:52+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:52+08:00"><meta name=Keywords content><meta name=description content="C++堆與棧詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/55f48b84.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++堆與棧詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>大多數操作系統會將內存空間分為內核空間和用戶空間，而每個進程的內存空間又有如下的“默認”區域。</p><p>1、棧：棧用於維護函數調用的上下文，離開棧函數調用就會無法實現。棧通常在用戶空間的最高地址處分配，通常有數兆字節。</p><p>2、堆:堆用來容納應用程序動態分配的內存區域，我們使用malloc 或者new分配內存時，得到的內存來自堆裡。堆通常存於棧的下方（低地址方向），堆一般比棧大很多，可以有幾十至數百兆字節的容量。</p><p>3、可執行文件鏡像：可執行文件由裝載器在裝載時將可執行文件讀取到內存或者映射到內存。</p><p>4、保留區：保留區並不是一個單一的內存區域，而是對內存中受保護而禁止訪問的內存區域的總稱，例如，大多說操作系統中，極小的地址通常都是不允許訪問的，如NULL。（順便提一下，我們編程的時候經常會遇到‘段錯誤（segment fault）’或者‘非法操作，該內存地址不能read/write’的錯誤信息，其中一個原因就是我們初始化了一個指針為NULL但是沒有給它賦合理的值就開始使用它。）</p><p>linux 進程內存空間佈局如下圖：</p><p><strong>01 棧</strong></p><p>一個棧的實例：</p><p>在經典的操作系統中，棧總是向下增長的，棧頂由稱為esp的寄存器進行定位，壓棧的操作使棧頂的地址減小，彈出的操作使棧頂地址增大。棧保存了一個函數調用所需的維護信息，常常被稱為堆棧幀或者活動記錄。堆棧幀一般包括如下幾個方面：</p><p>函數的返回地址和參數。</p><p>臨時變量：包括函數的非靜態局部變量以及編譯器自動生成的其他臨時變量。</p><p>保存的上下文：包括在函數調用前後需要保持不變的寄存器。</p><p>一個函數調用函數的活動記錄</p><p>一個函數的活動記錄用ebp和esp這兩個寄存器劃定範圍。esp寄存器始終指向棧的頂部，ebp寄存器指向了函數活動記錄的一個固定位置，ebp寄存器又被稱為幀指針。函數調用時棧的操作如下：</p><p>把所有的或者一部分參數壓入棧中，如果有其他參數沒有入棧，那麼使用某些特定的寄存器傳遞。</p><p>把當前指令的下一條指令的地址壓入棧中。</p><p>跳轉到函數體執行。</p><p>push ebp：把ebp壓入棧中（稱為old ebp）。為了在函數返回的時候便於恢復以前的ebp值。</p><p>mov ebp , esp: ebp = esp (這時ebp指向棧頂，而此時棧頂就是old ebp)。</p><p>【可選】sub esp,XXX :在棧上分配XXX字節的臨時空間。</p><p>【可選】push XXX:如果有必要，保存名為XXX的寄存器（可重複多個，由於編譯器可能要求某些寄存器在調用前後保持不變，那麼函數就在調用開始將這些寄存器的值壓入棧中，在結束後取出）。</p><p>函數調用結束時</p><p>【可選】pop XXX:如果有必要，恢復保存過的寄存器（可重複多個）。</p><p>mov esp， ebp：恢復ESP同時回收局部變量空間。</p><p>pop ebp： 從棧中恢復保存的ebp的值。</p><p>ret ：從棧中取得返回地址，並跳轉到該位置。</p><p>函數返回值傳遞</p><p>函數的返回值是通過eax寄存器返回的，但是eax寄存器只有4字節，如果返回值在5-8字節範圍內，幾乎所有的調用慣例都是採用eax和edx聯合返回的，eax存儲返回值的低4字節，其他的字節在edx中存儲。但是大於8字節的返回值那？</p><p>先上代碼：</p><blockquote><p>typedef struct big_thing</p><p>{</p><p>char buf[128];</p><p>}big_thing;</p><p>big_thing return_test()</p><p>{</p><p>big_thing b;</p><p>b.buf[0] = 0;</p><p>return b;</p><p>}</p><p>int main()</p><p>{</p><p>big_thing n = return_test();</p><p>}</p></blockquote><div class=pgc-img><img alt=C++堆與棧詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/25545ad985a24c7e944f3e7978f6d660><p class=pgc-img-caption></p></div><blockquote></blockquote><p>在調用return_test函數時，進行了如下操作：</p><p>首先main函數在棧上額外開闢了一片空間，並將這塊空間的一部分作為傳遞返回值的臨時對象，這裡稱為temp。</p><p>將temp對象的地址作為隱藏參數傳遞給return_test函數。</p><p>return_test函數將數據拷貝給temp對象，並將temp對象的地址用eax傳出。</p><p>return_test 返回之後，main函數將eax指向的temp對象的內容拷貝給n。</p><p>也就是如下偽代碼：</p><blockquote><p>void return_test(void *temp)</p><p>{</p><p>big_thing b;</p><p>b.buf[0] = 0;</p><p>memcpy(temp, &b, sizeof(big_thing));</p><p>eax = temp;</p><p>}</p><p>int main()</p><p>{</p><p>big_thing n;</p><p>big_thing temp;</p><p>return_test(&temp);</p><p>memcpy(&, eax, sizeof(big_thing));</p><p>}</p></blockquote><div class=pgc-img><img alt=C++堆與棧詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8c57c8831be4fa4a2d43c72e340ffe0><p class=pgc-img-caption></p></div><blockquote></blockquote><p>所以我們在編程時儘量不要返回大於4字節的數據，避免兩次拷貝，減小開銷。</p><p><strong>02 堆</strong></p><p>棧上的數據在函數返回時就會被釋放掉，所以無法將數據傳至函數外部，而全局變量沒有辦法動態地產生，只能在編譯的時候定義，在這種情況下，堆是唯一地選擇。malloc是C語言申請堆空間的函數，但是它是怎麼實現的那？</p><p>其實可以直接讓操作系統的內核來管理進程的內存，但是每次申請內存都要經過系統調用，如果操作頻繁會導致效率很低，程序性能降低。比較好的做法是程序向操作系統申請一塊適當的堆空間，然後由程序的運行庫根據算法管理堆空間的分配，當堆空間不夠的時候再向操作系統申請堆空間。linux下提供兩種堆空間分配方式：一個是brk（）系統調用，另外一個是mmap（）。</p><blockquote><p>int brk (void *end_data_segment)</p></blockquote><div class=pgc-img><img alt=C++堆與棧詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9fa25bd21474abdafd1c1278f5a728a><p class=pgc-img-caption></p></div><blockquote></blockquote><p>brk()的作用實際上就是設置進程數據段的結束地址，她可以擴大或者縮小數據段。</p><blockquote><p>void mmap（void *start, size_t length, int port, int flags, int fd, off_t offset）</p></blockquote><div class=pgc-img><img alt=C++堆與棧詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/06afbaf992f34b7bb8b2e8db0dc426a1><p class=pgc-img-caption></p></div><blockquote></blockquote><p>mmap的前兩個參數分別指定需要申請的空間的起始地址和長度，如果其實地址設為0，那麼操作系統會挑選合適的起始地址。port/flags這兩個參數用於設置申請的空間的權限（可讀，可寫，可執行）以及映射類型（文件類型，匿名空間等），最後兩個參數用於文件映射是指定文件的描述符和文件偏移。用mmap實現的malloc函數：</p><blockquote><p>void *malloc(size_t nbytes)</p><p>{</p><p>void *ret = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0 , 0);</p><p>if (ret == MAP_FAILED)</p><p>return 0;</p><p>return ret;</p><p>}</p></blockquote><div class=pgc-img><img alt=C++堆與棧詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf21b6f1cd1e4fa8b1020739af2a54dd><p class=pgc-img-caption></p></div><blockquote></blockquote><p>mmap（）的作用是向操作系統申請一段虛擬空間，當這塊虛擬空間可以映射到某個文件（也就是這個系統調用的最初的作用），當他不將地址空間映射到某個文件時，我們又稱這塊空間為匿名空間。</p><p>glibc的malloc 函數是這樣處理用戶的空間請求的：對於小於128KB的請求來說，它會在現有的堆空間裡面，按照堆分配算法為它分配一塊空間返回，對於大於128KB的請求來說，它會使用mmap（）函數為它分配一塊匿名空間，然後再這個匿名空間中為用戶分配空間。（所以問一個很常見的問題，malloc申請的內存，進程結束以後還會不會存在？ 答案是不存在）</p><p>堆分配算法</p><p>1、空閒鏈表法</p><p>空閒鏈表的方法是把堆中各個空閒的快按照鏈表的方式連接起來，當用戶請求一塊空間時，可以遍歷整個列表，直到找到合適大小的快並且將它拆分，當用戶釋放空間時將它合併到空閒鏈表中。</p><p>2、位圖</p><p>核心思想就是將整個堆劃分為大量的塊，每個塊大小相同。當用戶請求內存的時候總是分配整個塊的空間給用戶。第一個塊我們稱為已分配區域的頭，其餘的稱為已分配區域的主體。而我們可以使用一個整數數組來記錄塊的使用情況，由於每個塊只有頭/主體/空閒三種狀態，因此僅僅需要兩位即可表示一個塊，因此稱為位圖。</p><p>優點：速度快，穩定性好，容易管理。</p><p>缺點：容易產生碎片，浪費空間。</p><p><strong>3 對象池</strong></p><p>如果實際上在一些場合，被分配對象的大小是固定的幾個值，我們可以採用對象池的方法。對象池思想就是，如果每一次分配的空間大小都一樣，那麼就可以按照這個每次請求分配的大小作為一個單位，把整個堆空間劃分為大量的小塊，每次請求只要找到一個空閒的小塊就可以了。</p><p>實際上很多應用中，堆的分配算法往往是採取多種算法複合而成的，對於glibc來說，小於64字節的採用對象池的方法，對於大於512字節的採用最佳適配算法，對於64字節和512字節之間的採取最佳折中策略；對於大於128kb的申請，它會直接使用mmap向操作系統申請空間。</p><p>原文：https://blog.csdn.net/u014608280/article/details/82218079</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>C++</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html alt=詳解13項鋼筋安裝質量標準及通病防治 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fd3ff534941a487884c7a67361337cfb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html title=詳解13項鋼筋安裝質量標準及通病防治>詳解13項鋼筋安裝質量標準及通病防治</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html alt=史上最全電路圖詳解！老電工都收藏了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533138404073909636bf43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html title=史上最全電路圖詳解！老電工都收藏了！>史上最全電路圖詳解！老電工都收藏了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html alt=每一滴油力爭做到不浪費，詳解各種燃油噴射方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3ed00001d75ac552f05c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html title=每一滴油力爭做到不浪費，詳解各種燃油噴射方式>每一滴油力爭做到不浪費，詳解各種燃油噴射方式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>