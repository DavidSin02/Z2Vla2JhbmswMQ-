<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>老大吩咐的可重入分佈式鎖，終於完美的實現了 | 极客快訊</title><meta property="og:title" content="老大吩咐的可重入分佈式鎖，終於完美的實現了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/c6023f6931ac4b409b0fa5ed962428a0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56656970.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="老大吩咐的可重入分佈式鎖，終於完美的實現了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/56656970.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>老大吩咐的可重入分佈式鎖，終於完美的實現了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>重做永遠比改造簡單</p><p>最近在做一個項目，將一個其他公司的實現系統（下文稱作舊系統），完整的整合到自己公司的系統（下文稱作新系統）中，這其中需要將對方實現的功能完整在自己系統也實現一遍。</p><p>舊系統還有一批存量商戶，為了不影響存量商戶的體驗，新系統提供的對外接口，還必須得跟以前一致。最後系統完整切換之後，功能只運行在新系統中，這就要求舊系統的數據還需要完整的遷移到新系統中。</p><p>當然這些在做這個項目之前就有預期，想過這個過程很難，但是沒想到有那麼難。原本感覺排期大半年，時間還是挺寬裕，現在感覺就是大坑，還不得不在坑裡一點點去填。</p><div class=pgc-img><img alt=老大吩咐的可重入分佈式鎖，終於完美的實現了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6023f6931ac4b409b0fa5ed962428a0><p class=pgc-img-caption></p></div><p>哎，說多都是淚，不吐槽了，等到下次做完再給大家覆盤下真正心得體會。</p><p>回到正文，上篇文章<strong>Redis 分佈式鎖</strong>，咱們基於 Redis 實現一個分佈式鎖。這個分佈式鎖基本功能沒什麼問題，但是缺少可重入的特性，所以這篇文章小黑哥就帶大家來實現一下可重入的分佈式鎖。</p><p>本篇文章將會涉及以下內容：</p><ul><li>可重入</li><li>基於 ThreadLocal 實現方案</li><li>基於 Redis Hash 實現方案</li></ul><h2 class=pgc-h-arrow-right>可重入</h2><p>說到可重入鎖，首先我們來看看一段來自 <strong>wiki</strong> 上可重入的解釋：</p><blockquote><p>“</p><p>若一個程序或子程序可以“在任意時刻被中斷然後操作系統調度執行另外一段代碼，這段代碼又調用了該子程序不會出錯”，則稱其為<strong>可重入</strong>（reentrant或re-entrant）的。即當該子程序正在運行時，執行線程可以再次進入並執行它，仍然獲得符合設計時預期的結果。與多線程併發執行的線程安全不同，可重入強調對單個線程執行時重新進入同一個子程序仍然是安全的。</p></blockquote><p>當一個線程執行一段代碼成功獲取鎖之後，繼續執行時，又遇到加鎖的代碼，可重入性就就保證線程能繼續執行，而不可重入就是需要等待鎖釋放之後，再次獲取鎖成功，才能繼續往下執行。</p><p>用一段 Java 代碼解釋可重入：</p><pre><code>public synchronized void a() {    b();}public synchronized void b() {    // pass}</code></pre><p>假設 X 線程在 a 方法獲取鎖之後，繼續執行 b 方法，如果此時<strong>不可重入</strong>，線程就必須等待鎖釋放，再次爭搶鎖。</p><p>鎖明明是被 X 線程擁有，卻還需要等待自己釋放鎖，然後再去搶鎖，這看起來就很奇怪，我釋放我自己~</p><div class=pgc-img><img alt=老大吩咐的可重入分佈式鎖，終於完美的實現了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/978d3c7e06f44f84824be000d01abbc5><p class=pgc-img-caption></p></div><p>我打我自己</p><p>可重入性就可以解決這個尷尬的問題，當線程擁有鎖之後，往後再遇到加鎖方法，直接將加鎖次數加 1，然後再執行方法邏輯。退出加鎖方法之後，加鎖次數再減 1，當加鎖次數為 0 時，鎖才被真正的釋放。</p><p>可以看到可重入鎖最大特性就是計數，計算加鎖的次數。所以當可重入鎖需要在分佈式環境實現時，我們也就需要統計加鎖次數。</p><p>分佈式可重入鎖實現方式有兩種：</p><ul><li>基於 ThreadLocal 實現方案</li><li>基於 Redis Hash 實現方案</li></ul><p>首先我們看下基於 ThreadLocal 實現方案。</p><h2 class=pgc-h-arrow-right>基於 ThreadLocal 實現方案</h2><h3 class=pgc-h-arrow-right>實現方式</h3><p>Java 中 ThreadLocal可以使每個線程擁有自己的實例副本，我們可以利用這個特性對線程重入次數進行技術。</p><p>下面我們定義一個ThreadLocal的全局變量 LOCKS，內存存儲 Map 實例變量。</p><pre><code>private static ThreadLocal&lt;Map&lt;String, Integer&gt;&gt; LOCKS = ThreadLocal.withInitial(HashMap::new);</code></pre><p>每個線程都可以通過 ThreadLocal獲取自己的 Map實例，Map 中 key 存儲鎖的名稱，而 value存儲鎖的重入次數。</p><p><strong>加鎖的代碼如下：</strong></p><pre><code>/** * 可重入鎖 * * @param lockName  鎖名字,代表需要爭臨界資源 * @param request   唯一標識，可以使用 uuid，根據該值判斷是否可以重入 * @param leaseTime 鎖釋放時間 * @param unit      鎖釋放時間單位 * @return */public Boolean tryLock(String lockName, String request, long leaseTime, TimeUnit unit) {    Map&lt;String, Integer&gt; counts = LOCKS.get();    if (counts.containsKey(lockName)) {        counts.put(lockName, counts.get(lockName) + 1);        return true;    } else {        if (redisLock.tryLock(lockName, request, leaseTime, unit)) {            counts.put(lockName, 1);            return true;        }    }    return false;}</code></pre><blockquote><p>“</p><p>ps: redisLock#tryLock 為上一篇文章實現的分佈鎖。</p><p>由於公號外鏈無法直接跳轉，關注『<strong>程序通事</strong>』，回覆<strong>分佈式鎖</strong>獲取源代碼。</p></blockquote><p>加鎖方法首先判斷當前線程是否已經已經擁有該鎖，若已經擁有，直接對鎖的重入次數加 1。</p><p>若還沒擁有該鎖，則嘗試去 <strong>Redis</strong> 加鎖，加鎖成功之後，再對重入次數加 1 。</p><p><strong>釋放鎖的代碼如下：</strong></p><pre><code>/** * 解鎖需要判斷不同線程池 * * @param lockName * @param request */public void unlock(String lockName, String request) {    Map&lt;String, Integer&gt; counts = LOCKS.get();    if (counts.getOrDefault(lockName, 0) &lt;= 1) {        counts.remove(lockName);        Boolean result = redisLock.unlock(lockName, request);        if (!result) {            throw new IllegalMonitorStateException("attempt to unlock lock, not locked by lockName:+" + lockName + " with request: "                    + request);        }    } else {        counts.put(lockName, counts.get(lockName) - 1);    }}</code></pre><p>釋放鎖的時首先判斷重入次數，若大於 1，則代表該鎖是被該線程擁有，所以直接將鎖重入次數減 1 即可。</p><p>若當前可重入次數小於等於 1，首先移除 Map中鎖對應的 key，然後再到 Redis 釋放鎖。</p><p>這裡需要注意的是，當鎖未被該線程擁有，直接解鎖，可重入次數也是小於等於 1 ，這次可能無法直接解鎖成功。</p><blockquote><p>“</p><p>ThreadLocal 使用過程要記得及時清理內部存儲實例變量，防止發生內存洩漏，上下文數據串用等問題。</p><p>下次咱來聊聊最近使用 ThreadLocal 寫的 Bug。</p></blockquote><h3 class=pgc-h-arrow-right>相關問題</h3><p>使用 ThreadLocal 這種本地記錄重入次數，雖然真的簡單高效，但是也存在一些問題。</p><p><strong>過期時間問題</strong></p><p>上述加鎖的代碼可以看到，重入加鎖時，僅僅對本地計數加 1 而已。這樣可能就會導致一種情況，由於業務執行過長，Redis 已經過期釋放鎖。</p><p>而再次重入加鎖時，由於本地還存在數據，認為鎖還在被持有，這就不符合實際情況。</p><p>如果要在本地增加過期時間，還需要考慮本地與 Redis 過期時間一致性的，代碼就會變得很複雜。</p><p><strong>不同線程/進程可重入問題</strong></p><p>狹義上可重入性應該只是對於<strong>同一線程</strong>的可重入，但是實際業務可能需要不同的應用線程之間可以重入同把鎖。</p><p>而 ThreadLocal的方案僅僅只能滿足同一線程重入，無法解決不同線程/進程之間重入問題。</p><p>不同線程/進程重入問題就需要使用下述方案 Redis Hash 方案解決。</p><h2 class=pgc-h-arrow-right>基於 Redis Hash 可重入鎖</h2><h3 class=pgc-h-arrow-right>實現方式</h3><p>ThreadLocal 的方案中我們使用了 Map 記載鎖的可重入次數，而 Redis 也同樣提供了 Hash （哈希表）這種可以存儲鍵值對數據結構。所以我們可以使用 Redis Hash 存儲的鎖的重入次數，然後利用 lua 腳本判斷邏輯。</p><p>加鎖的 lua 腳本如下：</p><pre><code>---- 1 代表 true---- 0 代表 falseif (redis.call('exists', KEYS[1]) == 0) then    redis.call('hincrby', KEYS[1], ARGV[2], 1);    redis.call('pexpire', KEYS[1], ARGV[1]);    return 1;end ;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then    redis.call('hincrby', KEYS[1], ARGV[2], 1);    redis.call('pexpire', KEYS[1], ARGV[1]);    return 1;end ;return 0;</code></pre><blockquote><p>“</p><p>如果 KEYS:[lock],ARGV[1000,uuid]</p></blockquote><p>不熟悉 lua 語言同學也不要怕，上述邏輯還是比較簡單的。</p><p>加鎖代碼首先使用 Redis exists 命令判斷當前 lock 這個鎖是否存在。</p><p>如果鎖不存在的話，直接使用 hincrby創建一個鍵為 lock hash 表，並且為 Hash 表中鍵為 uuid 初始化為 0，然後再次加 1，最後再設置過期時間。</p><p>如果當前鎖存在，則使用 hexists判斷當前 lock 對應的 hash 表中是否存在 uuid 這個鍵，如果存在,再次使用 hincrby 加 1，最後再次設置過期時間。</p><p>最後如果上述兩個邏輯都不符合，直接返回。</p><p>加鎖代碼如下:</p><pre><code>// 初始化代碼String lockLuaScript = IOUtils.toString(ResourceUtils.getURL("classpath:lock.lua").openStream(), Charsets.UTF_8);lockScript = new DefaultRedisScript&lt;&gt;(lockLuaScript, Boolean.class);/** * 可重入鎖 * * @param lockName  鎖名字,代表需要爭臨界資源 * @param request   唯一標識，可以使用 uuid，根據該值判斷是否可以重入 * @param leaseTime 鎖釋放時間 * @param unit      鎖釋放時間單位 * @return */public Boolean tryLock(String lockName, String request, long leaseTime, TimeUnit unit) {    long internalLockLeaseTime = unit.toMillis(leaseTime);    return stringRedisTemplate.execute(lockScript, Lists.newArrayList(lockName), String.valueOf(internalLockLeaseTime), request);}</code></pre><blockquote><p>“</p><p>Spring-Boot 2.2.7.RELEASE</p></blockquote><p>只要搞懂 Lua 腳本加鎖邏輯，Java 代碼實現還是挺簡單的，直接使用 SpringBoot 提供的 StringRedisTemplate 即可。</p><p>解鎖的 Lua 腳本如下：</p><pre><code>-- 判斷 hash set 可重入 key 的值是否等於 0-- 如果為 0 代表 該可重入 key 不存在if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then    return nil;end ;-- 計算當前可重入次數local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1);-- 小於等於 0 代表可以解鎖if (counter &gt; 0) then    return 0;else    redis.call('del', KEYS[1]);    return 1;end ;return nil;</code></pre><p>首先使用 hexists 判斷 Redis Hash 表是否存給定的域。</p><p>如果 lock 對應 Hash 表不存在，或者 Hash 表不存在 uuid 這個 key，直接返回 nil。</p><p>若存在的情況下，代表當前鎖被其持有，首先使用 hincrby使可重入次數減 1 ，然後判斷計算之後可重入次數，若小於等於 0，則使用 del 刪除這把鎖。</p><p>解鎖的 Java 代碼如下：</p><pre><code>// 初始化代碼：String unlockLuaScript = IOUtils.toString(ResourceUtils.getURL("classpath:unlock.lua").openStream(), Charsets.UTF_8);unlockScript = new DefaultRedisScript&lt;&gt;(unlockLuaScript, Long.class);/** * 解鎖 * 若可重入 key 次數大於 1，將可重入 key 次數減 1 &lt;br&gt; * 解鎖 lua 腳本返回含義：&lt;br&gt; * 1:代表解鎖成功 &lt;br&gt; * 0:代表鎖未釋放，可重入次數減 1 &lt;br&gt; * nil：代表其他線程嘗試解鎖 &lt;br&gt; * &lt;p&gt; * 如果使用 DefaultRedisScript&lt;Boolean&gt;，由於 Spring-data-redis eval 類型轉化，&lt;br&gt; * 當 Redis 返回  Nil bulk, 默認將會轉化為 false，將會影響解鎖語義，所以下述使用：&lt;br&gt; * DefaultRedisScript&lt;Long&gt; * &lt;p&gt; * 具體轉化代碼請查看：&lt;br&gt; * JedisScriptReturnConverter&lt;br&gt; * * @param lockName 鎖名稱 * @param request  唯一標識，可以使用 uuid * @throws IllegalMonitorStateException 解鎖之前，請先加鎖。若為加鎖，解鎖將會拋出該錯誤 */public void unlock(String lockName, String request) {    Long result = stringRedisTemplate.execute(unlockScript, Lists.newArrayList(lockName), request);    // 如果未返回值，代表其他線程嘗試解鎖    if (result == null) {        throw new IllegalMonitorStateException("attempt to unlock lock, not locked by lockName:+" + lockName + " with request: "                + request);    }}</code></pre><p>解鎖代碼執行方式與加鎖類似，只不過解鎖的執行結果返回類型使用 Long。這裡之所以沒有跟加鎖一樣使用 Boolean ,這是因為解鎖 lua 腳本中，三個返回值含義如下：</p><ul><li>1 代表解鎖成功，鎖被釋放</li><li>0 代表可重入次數被減 1</li><li>null 代表其他線程嘗試解鎖，解鎖失敗</li></ul><p>如果返回值使用 Boolean，<strong>Spring-data-redis</strong> 進行類型轉換時將會把 null 轉為 false，這就會影響我們邏輯判斷，所以返回類型只好使用 Long。</p><p>以下代碼來自 JedisScriptReturnConverter：</p><div class=pgc-img><img alt=老大吩咐的可重入分佈式鎖，終於完美的實現了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/99d27b39cdd04f65907b9fb5feaef797><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>相關問題</h3><p><strong>spring-data-redis 低版本問題</strong></p><p>如果 Spring-Boot 使用 Jedis 作為連接客戶端,並且使用Redis Cluster 集群模式，需要使用 <strong>2.1.9</strong> 以上版本的<strong>spring-boot-starter-data-redis</strong>,不然執行過程中將會拋出：</p><pre><code>org.springframework.dao.InvalidDataAccessApiUsageException: EvalSha is not supported in cluster environment.</code></pre><p>如果當前應用無法升級 spring-data-redis也沒關係，可以使用如下方式，直接使用原生 Jedis 連接執行 lua 腳本。</p><p>以加鎖代碼為例：</p><pre><code>public boolean tryLock(String lockName, String reentrantKey, long leaseTime, TimeUnit unit) {    long internalLockLeaseTime = unit.toMillis(leaseTime);    Boolean result = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; {        Object innerResult = eval(connection.getNativeConnection(), lockScript, Lists.newArrayList(lockName), Lists.newArrayList(String.valueOf(internalLockLeaseTime), reentrantKey));        return convert(innerResult);    });    return result;}private Object eval(Object nativeConnection, RedisScript redisScript, final List&lt;String&gt; keys, final List&lt;String&gt; args) {    Object innerResult = null;    // 集群模式和單點模式雖然執行腳本的方法一樣，但是沒有共同的接口，所以只能分開執行    // 集群    if (nativeConnection instanceof JedisCluster) {        innerResult = evalByCluster((JedisCluster) nativeConnection, redisScript, keys, args);    }    // 單點    else if (nativeConnection instanceof Jedis) {        innerResult = evalBySingle((Jedis) nativeConnection, redisScript, keys, args);    }    return innerResult;}</code></pre><p><strong>數據類型轉化問題</strong></p><p>如果使用 Jedis 原生連接執行 Lua 腳本，那麼可能又會碰到數據類型的轉換坑。</p><div class=pgc-img><img alt=老大吩咐的可重入分佈式鎖，終於完美的實現了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/681839946566422e82de2718aeaebb9a><p class=pgc-img-caption></p></div><p>可以看到 Jedis#eval返回 Object，我們需要具體根據 Lua 腳本的返回值的，再進行相關轉化。這其中就涉及到 Lua 數據類型轉化為 Redis 數據類型。</p><p>下面主要我們來講下 Lua 數據轉化 Redis 的規則中幾條比較容易踩坑：</p><p>1、Lua number 與 Redis 數據類型轉換</p><p>Lua 中 number 類型是一個雙精度的浮點數，但是 Redis 只支持整數類型，所以這個轉化過程將會丟棄小數位。</p><div class=pgc-img><img alt=老大吩咐的可重入分佈式鎖，終於完美的實現了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99610da571ac4751b1ac07ab57f6e265><p class=pgc-img-caption></p></div><p>2、Lua boolean 與 Redis 類型轉換</p><p>這個轉化比較容易踩坑，Redis 中是不存在 boolean 類型，所以當Lua 中 true 將會轉為 Redis 整數 1。而 Lua 中 false 並不是轉化整數，而是轉化 <strong>null</strong> 返回給客戶端。</p><div class=pgc-img><img alt=老大吩咐的可重入分佈式鎖，終於完美的實現了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae744ace602847bf9d1f5667a3fc2aca><p class=pgc-img-caption></p></div><p>3、Lua nil 與 Redis 類型轉換</p><p>Lua nil 可以當做是一個空值，可以等同於 Java 中的 <strong>null</strong>。在 Lua 中如果 nil 出現在條件表達式，將會當做 false 處理。</p><p>所以 Lua nil 也將會 <strong>null</strong> 返回給客戶端。</p><p>其他轉化規則比較簡單，詳情參考:</p><p><strong>http://doc.redisfans.com/script/eval.html</strong></p><h2 class=pgc-h-arrow-right>總結</h2><p>可重入分佈式鎖關鍵在於對於鎖重入的計數，這篇文章主要給出兩種解決方案，一種基於 ThreadLocal 實現方案，這種方案實現簡單，運行也比較高效。但是若要處理鎖過期的問題，代碼實現就比較複雜。</p><p>另外一種採用 Redis Hash 數據結構實現方案，解決了 ThreadLocal 的缺陷，但是代碼實現難度稍大，需要熟悉 Lua 腳本，以及Redis 一些命令。另外使用 <strong>spring-data-redis</strong> 等操作 Redis 時不經意間就會遇到各種問題。</p><h2 class=pgc-h-arrow-right>幫助</h2><p><strong>https://www.sofastack.tech/blog/sofa-jraft-rheakv-distributedlock/</strong></p><p><strong>https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html</strong></p><h2 class=pgc-h-arrow-right>最後說兩句（求關注）</h2><p>看完文章，哥哥姐姐們點個<strong>在看</strong>吧，周更真的超累，不知覺又寫了兩天，拒絕白嫖，來點正反饋唄~。</p><p>最後感謝各位的閱讀，才疏學淺，難免存在紕漏，如果你發現錯誤的地方，可以留言指出。如果看完文章還有其他不懂的地方，歡迎加我，互相學習，一起成長~</p><p>最後謝謝大家支持~</p><p>最最後，重要的事再說一篇~</p><p>快來關注我呀~ 快來關注我呀~ 快來關注我呀~</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>式鎖</a></li><li><a>終於</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ab3719e.html alt=終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3553afe761fd4eea86e31ba84eb1ffeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ab3719e.html title=終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了>終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html alt="廣西鐵路出海大通道 全面實現電氣化運營" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html title="廣西鐵路出海大通道 全面實現電氣化運營">廣西鐵路出海大通道 全面實現電氣化運營</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c67451a1.html alt=看了這臺美國和麵機，終於知道為什麼外國人每天的早餐都那麼豐盛 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39ba000437f591377966 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c67451a1.html title=看了這臺美國和麵機，終於知道為什麼外國人每天的早餐都那麼豐盛>看了這臺美國和麵機，終於知道為什麼外國人每天的早餐都那麼豐盛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7c3d9f70.html alt=新穎的混合材料或有助於實現高效的下一代顯示器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/47050004da4f36dcec1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7c3d9f70.html title=新穎的混合材料或有助於實現高效的下一代顯示器>新穎的混合材料或有助於實現高效的下一代顯示器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d93e49d.html alt=教程：採用梯度下降算法實現線性迴歸！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1537162000876f4501fb1c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d93e49d.html title=教程：採用梯度下降算法實現線性迴歸！>教程：採用梯度下降算法實現線性迴歸！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8e17d90.html alt=重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RtbWBYL9koJMmN style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8e17d90.html title=重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別>重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1b218e68.html alt=圖像拼接算法及實現（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534489824878547eee8fc2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1b218e68.html title=圖像拼接算法及實現（一）>圖像拼接算法及實現（一）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>