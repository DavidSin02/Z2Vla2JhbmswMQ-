<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「排序」歸併排序和逆序數問題探究 | 极客快訊</title><meta property="og:title" content="「排序」歸併排序和逆序數問題探究 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/376607cc-e1f3-48f0-85d8-4a952ed4df5e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56f773f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><meta property="article:published_time" content="2020-10-29T20:52:58+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:58+08:00"><meta name=Keywords content><meta name=description content="「排序」歸併排序和逆序數問題探究"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/56f773f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「排序」歸併排序和逆序數問題探究</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>微信公眾號：bigsai</p><p>頭條號：一直碼農一直爽</p></blockquote><h2 class=pgc-h-arrow-right>前言</h2><p><br></p><div class=pgc-img><img alt=「排序」歸併排序和逆序數問題探究 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/376607cc-e1f3-48f0-85d8-4a952ed4df5e><p class=pgc-img-caption></p></div><p><br></p><p>在排序中，我們可能大部分更熟悉冒泡排序、快排之類。對歸併排序可能比較陌生。然而事實上歸併排序也是一種穩定的排序，時間複雜度為O(nlogn).</p><p>歸併排序是基於分治進行歸併的，有<strong>二路歸併</strong>和多路歸併.我們這裡只講二路歸併並且日常用的基本是二路歸併。並且<strong>歸併排序的實現方式</strong>有遞歸形式和非遞歸形式。要注意其中的區分(思想上沒有大的區別，只是劃分上會有區分後面會對比)。</p><p>並且歸併排序很重要的一個應用是求序列中的逆序數個數。當然<strong>逆序數也可以用樹狀數組</strong>完成，這裡就不介紹了。</p><h2 class=pgc-h-arrow-right>歸併排序(merge sort)</h2><p>歸併和快排都是<strong>基於分治算法</strong>的。分治算法其實應用挺多的，很多分治會用到遞歸，也有很多遞歸實現的算法是分治，但事實上<strong>分治和遞歸是兩把事</strong>。分治就是分而治之。因為面對排序，如果不採用合理策略。每多一個數就會對整個整體帶來巨大的影響。而分治就是將整個問題可以分解成相似的子問題。子問題的解決要遠遠高效於整個問題的解決，並且子問題的合併並不佔用太大資源。</p><p>至於歸併的思想是這樣的：</p><ul><li>第一次：整串先進行劃分成1個一個單獨，第一次是一一(12 34 56---)歸併成若干對，分成若干2個區間.歸併完(xx xx xx xx----)這樣局部有序的序列。</li><li>第二次就是兩兩歸併成若干四個(1234 5678 ----)<strong>每個小局部是有序的</strong>。</li><li>就這樣一直到最後這個串串只剩一個，然而這個耗費的總次數logn。每次操作的時間複雜的又是O(n)。所以總共的時間複雜度為O(nlogn).</li></ul><p>對於分治過程你可能瞭解了，但是這個兩兩merge的過程其實是很重要的。首先我們直到的兩個序列都是有序的。其實思想也很簡單，假設兩個串串為 3 5 7 8和2 6 9 10進行歸併操作。我們需要藉助一個額外的數組team[8]將兩個串串有序存進去就行。而流程是這樣的：</p><div class=pgc-img><img alt=「排序」歸併排序和逆序數問題探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03da2929f86d449cbd7d02c70dbd5f24><p class=pgc-img-caption></p></div><p><br></p><p><strong>非遞歸的歸併</strong>正常歸併的代碼實現都是藉助遞歸的。但是也有不借助遞歸的。大部分<strong>課本或者考試</strong>如果讓你列歸併的序列，那麼<strong>默認就是非遞歸</strong>的，比如一個序列9,2,6,3,8,1,7,4,10,5序列的劃分也是這樣的。</p><pre><code>第一次結束： {2,9}{3,6}{1,8}{4,7}{5,10}第二次結束：{2,3,6,9}{1,4,7,8}{5,10}第三次結束：{1,2,3,4,6,7,8,9}{5,10}第四次結束：{1,2,3,4,5,6,7,8,9,10}</code></pre><p><strong>遞歸的歸併</strong>在代碼實現上的歸併可能大部分都是遞歸的歸併。並且遞歸和分治整在一起真的是很容易理解。遞歸可以將問題分解成子問題，而這恰恰是分治所需要的手段。而遞歸的<strong>一來一回</strong>過程的來(分治)回(歸併)，一切都剛剛好。</p><p>而遞歸的思想和上面非遞歸肯定不同的，你可以想想非遞歸：我要考慮當前幾個進行歸併，每個開始的頭座標該怎麼表示，還要考慮是否越界等等問題哈，<strong>寫起來略麻煩</strong>。</p><p>而非遞歸它的過程就是局部—>整體的過程，而遞歸是整體—>局部—>整體的過程。而遞歸實現的歸併的思想：</p><pre><code> void mergesort(int[] array, int left, int right) {       int mid=(left+right)/2;//找到中間節點      if(left&lt;right)//如果不是一個節點就往下遞歸分治        {    mergesort(array, left, mid);//左區間(包過mid)進行歸併排序          mergesort(array, mid+1, right);//右區間進行歸併排序              merge(array, left,mid, right);//左右已經有序了，進行合併          } }</code></pre><p>同樣是9,2,6,3,8,1,7,4,10,5這麼一串序列，它的遞歸實現的順序是這樣的(可能部分有點問題，但是還是有助於理解的)：</p><div class=pgc-img><img alt=「排序」歸併排序和逆序數問題探究 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/74e34b46c9ec4a16a387b191a2720a5e><p class=pgc-img-caption></p></div><p><br></p><p>所以實現一個歸併排序的代碼為：</p><pre><code>private static void mergesort(int[] array, int left, int right) {      int mid=(left+right)/2;       if(left&lt;right)        {           mergesort(array, left, mid);           mergesort(array, mid+1, right);         merge(array, left,mid, right);       }    }   private static void merge(int[] array, int l, int mid, int r) {    int lindex=l;int rindex=mid+1;          int team[]=new int[r-l+1];        int teamindex=0;       while (lindex&lt;=mid&amp;&amp;rindex&lt;=r) {//先左右比較合併          if(array[lindex]&lt;=array[rindex])            {           team[teamindex++]=array[lindex++];           }               else {                                 team[teamindex++]=array[rindex++];           }        }          while(lindex&lt;=mid)//當一個越界後剩餘按序列添加即可        {               team[teamindex++]=array[lindex++];         }        while(rindex&lt;=r)          {               team[teamindex++]=array[rindex++];     }         for(int i=0;i&lt;teamindex;i++)       {            array[l+i]=team[i];       }  }</code></pre><h2 class=pgc-h-arrow-right>逆序數</h2><p>首先得了解什麼是逆序數：</p><blockquote><p>在數組中的兩個數字，如果前面一個數字大於後面的數字，則這兩個數字組成一個逆序對</p></blockquote><p>也就是比如3 2 1.看3 ，有2 1在後面，看2 有1在後面有3個逆序數。而比如1 2 3的逆序數為0.</p><p>在數組中，暴力確實可以求出逆序數，但是暴力之法太複雜，不可取！<strong>而有什麼好的方法能解決這個問題呢？</strong> 當前序列我可能不知道有多少序列。<strong>但是我們直到如果這個序列如果有序那麼逆序數就為0</strong>.</p><p>在看個序列 abcd 3 2 1 efg編程abcd 1 2 3 efg整個序列逆序數減少3個。因為如果不管abcd還是efg和123三個數相對位置沒有變。所以我們是可以通過某種方法確定逆序數對的。</p><p>我們就希望能不能有個過程，動態改變如果逆序數發生變化能夠記錄下來？！比如動那麼一下能夠知道有沒有改變的。並且這個動不能瞎動，<strong>最好是局部的，有序的動</strong>。歸併排序就是很適合的一個結構。因為肯定<strong>要選個小於O(n^2^)的複雜度算法</strong>，而歸併排序滿足，<strong>並且每次只和鄰居進行歸併，歸併後該部分有序。</strong></p><p>縱觀歸併的每個單過程例如兩個有序序列：假設序列2 3 6 8 9和序列1 4 7 10 50這個相鄰區域進行歸併。</p><div class=pgc-img><img alt=「排序」歸併排序和逆序數問題探究 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f88ee4a64a72486d9bc65e0fa9e81bf4><p class=pgc-img-caption></p></div><p>在這裡插入圖片描述</p><p>而縱觀整個歸併排序。<strong>變化過程只需要注意一些相對變化即可也就是把每個歸併的過程逆序數發生變化進行累加，那麼最終有序的那個序列為止得到的就是整個序列的逆序數！</strong></p><div class=pgc-img><img alt=「排序」歸併排序和逆序數問題探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee5366f7338b480dac1a29e03ab6a25e><p class=pgc-img-caption></p></div><p>至於規律，<strong>你可以發現每次歸併過程中，當且僅當右側的數提前放到左側，而左側還未放置的個數就是該元素減少的逆序個數！</strong> 這個需要消化一下，而在代碼實現中，需要這樣進行即可！</p><pre><code>int value;-----------------private static void merge(int[] array, int l, int mid, int r) {		int lindex=l;int rindex=mid+1;		int team[]=new int[r-l+1];		int teamindex=0;		while (lindex&lt;=mid&amp;&amp;rindex&lt;=r) {			if(array[lindex]&lt;=array[rindex])			{				team[teamindex++]=array[lindex++];			}			else {								team[teamindex++]=array[rindex++];				value+=mid-lindex+1;//加上左側還剩餘的			}		}		while(lindex&lt;=mid)	      {	    	  team[teamindex++]=array[lindex++];	    	  	      }		while(rindex&lt;=r)	      {	    	  team[teamindex++]=array[rindex++];	      }			for(int i=0;i&lt;teamindex;i++)		{			array[l+i]=team[i];		}			}</code></pre><h2 class=pgc-h-arrow-right>結語</h2><p>至於<strong>歸併排序和逆序數</strong>就講這麼多了！個人感覺已經盡力講了，如果有錯誤或者不好的地方還請各位指正。如果感覺可以，還請點贊，關注一波哈。</p><p>歡迎關注公眾號：<strong>bigsai</strong></p><p>頭條號：<strong>一直碼農一直爽</strong></p><p>長期奮戰輸出！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>排序</a></li><li><a>逆序</a></li><li><a>數問題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0b1d824.html alt=？？？數組中的逆序對（歸併排序思想） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/682efe151ca8402b9f8ee2ac0c95286f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0b1d824.html title=？？？數組中的逆序對（歸併排序思想）>？？？數組中的逆序對（歸併排序思想）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c692a239.html alt=強連通分量與拓撲排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/70f8cf4acc804054acc4c73649b83179 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c692a239.html title=強連通分量與拓撲排序>強連通分量與拓撲排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10310f41.html alt=「乾貨」常用排序算法總結，必收藏系列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8acebd059bd4f4bba84851e32fa7ce7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10310f41.html title=「乾貨」常用排序算法總結，必收藏系列>「乾貨」常用排序算法總結，必收藏系列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5d0a0be.html alt=五種常用且高效的排序算法性能總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534143270780b452d84457 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5d0a0be.html title=五種常用且高效的排序算法性能總結>五種常用且高效的排序算法性能總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/977abfb9.html alt="冒泡排序、快速排序、歸併排序、基數排序 | 排序算法（二）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7179768ce3434cdba1850438f76df374 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/977abfb9.html title="冒泡排序、快速排序、歸併排序、基數排序 | 排序算法（二）">冒泡排序、快速排序、歸併排序、基數排序 | 排序算法（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html alt=深入淺出排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c898a3bab26542c2965d2bc5bebf9bd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html title=深入淺出排序算法>深入淺出排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html alt=程序員那些必須掌握的排序算法(上) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c32d187d725f4bd59225a5d09a38cb37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html title=程序員那些必須掌握的排序算法(上)>程序員那些必須掌握的排序算法(上)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html alt="算法 － 七大排序算法詳細介紹" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html title="算法 － 七大排序算法詳細介紹">算法 － 七大排序算法詳細介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html alt=算法之旅｜快速排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3b0e0000a716d98c3cba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html title=算法之旅｜快速排序法>算法之旅｜快速排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1e77b20f.html alt=常見的排序算法簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1e77b20f.html title=常見的排序算法簡介>常見的排序算法簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a35a8e8a.html alt=排序算法（1）——O(n^2) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/593b00001b3fdbe6409a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a35a8e8a.html title=排序算法（1）——O(n^2)>排序算法（1）——O(n^2)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/367001e2.html alt=算法之旅｜選擇排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3214000370c00fc3211e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/367001e2.html title=算法之旅｜選擇排序法>算法之旅｜選擇排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/d712d725.html alt=算法實現——拓撲排序的原理及實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/68d7916f4828401f95d9261fe25237ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/d712d725.html title=算法實現——拓撲排序的原理及實現>算法實現——拓撲排序的原理及實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51f1b140.html alt=需求方法論（2）：需求的分析、驗證與排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RpW5fJwDu0piuM style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51f1b140.html title=需求方法論（2）：需求的分析、驗證與排序>需求方法論（2）：需求的分析、驗證與排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/ae3a331.html alt=警告！有公式的單元格不要直接參與排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b833144462584c86985fe9869f5e9b3d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/ae3a331.html title=警告！有公式的單元格不要直接參與排序>警告！有公式的單元格不要直接參與排序</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>