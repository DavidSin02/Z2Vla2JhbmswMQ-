<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>淺談程序的內存佈局 | 极客快訊</title><meta property="og:title" content="淺談程序的內存佈局 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/Rgk77B2FkX8g3W"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5823f06f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5823f06f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5823f06f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5823f06f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5823f06f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5823f06f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5823f06f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5823f06f.html><meta property="article:published_time" content="2020-10-29T21:10:52+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:52+08:00"><meta name=Keywords content><meta name=description content="淺談程序的內存佈局"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5823f06f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>淺談程序的內存佈局</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rgk77B2FkX8g3W><p>作者 | herongwei</p><p>責編 | 屠敏</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p><strong>前言</strong></p><p>1、什麼是 User space 與 Kernel space？</p><p>2、什麼是棧區？</p><p>3、什麼是堆區？</p><p>4、malloc 算法是如何實現的？</p><p>5、Linux 系統下，有幾種堆空間分配方式？</p><p>6、Linux 下一個進程地址空間佈局是怎樣的？</p><p>上面幾個問題，你心裡有答案嗎？如果沒有，跟我一起來探究一下吧。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p><strong>User space 與 Kernel space</strong></p><p>現代的應用程序都運行在一個內存空間裡，在 32 位系統中，這個內存空間擁有 4GB （2 的 32 次方）的尋址能力。</p><p>儘管現在大部分計算機的內存空間配置越來越高，但實際上內存仍然在不同的地址區間有著不同的地位，例如，大多數操作系統都會將 4GB 的內存空間一部分挪給內核使用，應用程序無法直接訪問這一段內存，這一部分內存地址被稱為內核空間。</p><p>Windows 在默認的情況下會將高地址的 2GB 空間分配給內核（也可以配置 1GB）。</p><p>Linux 默認情況下將高地址的 1GB 空間分配給內核。</p><p>用戶使用的剩下的 2GB 或 3GB 的內存空間稱為用戶空間。</p><p><strong>為什麼要區分內核空間和用戶空間？</strong></p><p>大致有三點因素：</p><p>第一點：操作系統的數據都是存放於系統空間的，用戶進程的數據是存放於用戶空間的；</p><p>第二點：分開來存放，就讓系統的數據和用戶的數據互不干擾，保證系統的穩定性，並且管理上很方便；</p><p>第三點：也是重要的一點，將用戶的數據和系統的數據隔離開，就可以對兩部分的數據的訪問進行控制。這樣就可以確保用戶程序不能隨便操作系統的數據，這樣防止用戶程序誤操作或者是惡意破壞系統。</p><p>下面這一張圖，比較形象的解釋了 User space 與 Kernel space 的區別。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RqozNnT8o75FNK><p>第一點：操作系統的數據都是存放於系統空間的，用戶進程的數據是存放於用戶空間的；</p><p>簡單說，Kernel space 是 Linux 內核的運行空間，User space 是用戶程序的運行空間。為了安全，它們是隔離的，即使用戶的程序崩潰了，內核也不受影響。</p><p>Kernel space 可以執行任意命令，調用系統的一切資源；</p><p>相對來說，User space 執行的是較為簡單的運算，執行的運算不影響其他程序的執行，並且不能直接調用系統資源，必須通過系統接口（又稱 system call），才能向內核發出指令。</p><p>這裡補充下知乎網友@風雲評論：</p><p>其實，在用戶空間，幾乎所有內核資源在用戶空間都是可以訪問的（必須有相應的權限），即使是操作系統內核的大腦（調度程序）。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p><strong>Linux 進程地址空間佈局</strong></p><p>在用戶空間裡，也有許多地址區間有特權的地位，一般來講，應用程序使用的內存空間裡有如下“默認”的區域。</p><p><strong>棧區： </strong>棧用於維護函數調用的上下文，離開了棧，函數調用就無法實現，棧通常在用戶空間的最高地址處分配，通常有數兆字節的大小。</p><p><strong>堆區： </strong>堆是用來容納應用程序動態分配的內存區域，當程序使用 malloc 或者 new 分配內存的時候，得到的內存會來自堆裡。</p><p>堆通常存在棧的下方（低地址方向），在某些時候，堆也可能沒有固定統一的存儲區域。堆一般比棧大很多，可以有幾十至數百兆字節的容量。</p><p><strong>可執行文件映像：</strong>存儲著可執行文件在內存裡的映像，由裝載器在裝載時將可執行文件的內存讀取或映射到這裡。</p><p><strong>保留區：</strong>保留區並不是一個單一的內存區域，而是對內存中受到保護而禁止訪問的內存區域的總稱：例如大多數操作系統中，極小的地址通常都是不允許訪問的，如 ，C 語言將無效指針賦值為 0 也是這個考慮。</p><p><strong>動態鏈接庫映射區： </strong>這個區域用於映射裝載的動態鏈接庫。在 Linux 下，如果可執行文件依賴其它共享庫，那麼系統就會為它在從 0x40000000 開始的地址分配相應的空間，並將共享庫載入該空間。</p><p>剩下的還有以下幾部份組成：</p><p>（1）代碼段</p><p>（2）初始化數據段（數據段）</p><p>（3）未初始化數據段（BSS 段）</p><p>下圖是 Linux 下一個進程裡典型的內存佈局</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RqozNoB1k7BZry><p>圖中的箭頭，標明瞭幾個大小可變的尺寸增長的方向，在這裡，可以清晰地看出：</p><p>棧是由高地址向低地址增長。</p><p>堆是由低地址向高地址增長。</p><p>當棧或堆現有的大小不夠用的時候，它將按照圖中的增長方向擴大自身的尺寸，直到預留的空間被用完為止。</p><p>在講堆和棧之前，我們先來看一下代碼段，初始化數據段和未初始化數據段。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7YR5xGDl><p><strong>代碼段</strong></p><p>代碼段中存放可執行的指令，在內存中，為了保證不會因為堆棧溢出被覆蓋，將其放在了堆棧段下面（從上圖可以看出）。</p><p>通常來講代碼段是共享的，這樣多次反覆執行的指令只需要在內存中駐留一個副本即可，比如 C 編譯器，文本編輯器等。</p><p>代碼段一般是隻讀的，這樣程序執行時不能隨意更改指令，也是為了進行隔離保護。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7uHXU5GZc><p><strong>初始化數據段</strong></p><p>初始化數據段有時就稱之為數據段。數據段是一個程序虛擬地址空間的一部分，包括一全局變量和靜態變量，這些變量在編程時就已經被初始化。數據段是可以修改的，不然程序運行時變量就無法改變了，這一點和代碼段不同。</p><p>數據段可以細分為初始化只讀區和初始化讀寫區。這一點和編程中的一些特殊變量吻合。比如全局變量 int global n = 1就被放在了初始化讀寫區，因為 global 是可以修改的。而 const int m = 2 就會被放在只讀區，很明顯，m 是不能修改的。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTLSNam5ZxLDlM><p><strong>棧</strong></p><p>棧 (stack) 是現代計算機程序裡最為重要的概念之一，幾乎每一個程序都使用了棧，沒有棧就沒有函數，沒有局部變量，也就沒有我們如今能夠看見的所有的計算機語言。</p><p>在解釋為什麼棧會如此重要之前，讓我們來先了解一下傳統的棧的定義：</p><p>在經典的計算機科學中，棧被定義為一個特殊的容器，用戶可以將數據壓入棧中（入棧,push），也可以將已經壓入棧中的數據彈出(出棧, pop)。</p><p>但棧這個容器必須遵守一條規則：<strong>先入棧的數據後出棧(First In Last Out, FIFO)，多多少少像疊成一疊的書：先疊上去的書在最下面：因此要最後才能取出。</strong></p><p>在計算機系統中，棧則是一個具有以上屬性的動態內存區域，程序可以將數據壓入棧中，也可以將數據從棧頂彈出，壓棧操作使得棧增大,而彈出操作使棧減小。</p><p>在經典的操作系統裡，棧總是向下增長的。</p><p>在 i386 下，棧頂由稱為 esp 的寄存器進行定位。壓棧的操作使棧頂的地址減小，彈出的操作使棧頂地址增大。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RqozOap2RplDgY><p>這裡棧底的地址是 0xbffff，而 esp 寄存器標明瞭棧頂，地址為 0xbifff4。</p><p><strong>在棧上壓入數據會導致 esp 減小，彈出數據使得 esp 增大。</strong></p><p>棧在程序運行中具有舉足輕重的地位。最重要的，棧保存了一個函數調用所需要的維護信息，這常常被稱為堆棧幀(Stack Frame)或活動記錄(Activate Record)，堆棧幀一般包括如下幾方面內容：</p><p>1、函數的返回地址和參數。</p><p>2、臨時變量:包括函數的非靜態局部變量以及編譯器自動生成的其他臨時變量。</p><p>3、保存的上下文:包括在函數調用前後需要保持不變的寄存器。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTRIuPNI7JPB03><p><strong>堆</strong></p><p>相對於棧，堆這片內存面臨著一個稍微複雜的行為模式：在任意時刻，程序可能發出請求，要麼申請一段內存，要麼釋放一段已經申請過的內存，而且申請的大小從幾個字節到數 GB 都是有可能的。</p><p>我們不能假設程序會一次申請多少堆空間，因此，這時候堆的作用就凸顯出來了，同樣，相比較與棧，堆的管理顯得較為複雜。</p><p>光有棧，對於面向過程的程序設計還遠遠不夠，因為棧上的數據在函數返回的時候就會被釋放掉，所以無法將數據傳遞至函數外部。而全局變量沒有辦法動態地產生，只能在編譯的時候定義，有很多情況下缺乏表現力，在這種情況下，堆（Heap）是一種唯一的選擇。</p><p>堆是一塊巨大的內存空間，常常佔據整個虛擬空間的絕大部分，在這片空間裡，程序可以請求一塊連續的內存，並自由地使用，這塊內存在程序主動放棄之前都活一直保持有效，下面是一個申請堆空間最簡單的例子：</p><pre><code>int main<br>{<br>char* p = (char*) malloc(233);<br>free(p);<br>return 0;<br>}</code></pre><p>在代碼中，第 3 行用 malloc 申請了 233 個字節的空間之後，程序可以自由地使用這 233個字節，直到程序用 free 函數釋放它。</p><p><strong>那麼 malloc 到底是怎麼實現的呢？</strong></p><p>有一種做法是，把進程的內存管理交給操作系統內核去做，既然內核管理著進程的地址空間，那麼如果它提供一個系統調用，可以讓程序使用這個系統調用申請內存，不就可以了嗎？</p><p>當然這是一種理論上可行的做法，但實際上這樣做的性能比較差，原因在於每次程序申請或者釋放堆空間都需要進行系統調用。</p><p>我們知道系統調用的性能開銷是很大的，當程序對堆的操作比較頻繁時，這樣做的結果是會嚴重影響程序的性能的。</p><p>比較好的做法就是：<strong>程序向操作系統申請一塊適當大小的堆空間，然後由程序自己管理這塊空間，而具體來講，管理著堆空間分配的往往是程序的運行</strong>庫。</p><p>運行庫相當於是向操作系統 “批發” 了一塊較大的堆空間，然後 “零售” 給程序用。</p><p>當全部“售完”或程序有大量的內存需求時，再根據實際需求向操作系統“進貨”。</p><p>當然運行庫在向程序零售堆空間時，必須管理它批發來的堆空間，不能把同一塊地址出售兩次，導致地址的衝突。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTRIuPaahjHjS><p><strong>Linux 進程堆管理</strong></p><p>由第一節可知，進程的地址空間中，除了可執行文件，共享庫和棧之外，剩餘的未分配的空間都可以用來作為堆空間。</p><p>Linux 系統下，提供兩種堆空間分配方式：</p><p><strong>brk 統調用和 mmap 系統調用。</strong></p><p>這兩種方式分配的都是虛擬內存，沒有分配物理內存。在第一次訪問已分配的虛擬地址空間的時候，發生缺頁中斷，操作系統負責分配物理內存，然後建立虛擬內存和物理內存之間的映射關係。</p><p>在標準 C 庫中，提供了malloc/free 函數分配釋放內存，這兩個函數底層是由 brk，mmap，munmap 這些系統調用實現的。</p><p><strong>brk 系統調用</strong></p><p>C 語言形式聲明：int brk {void* end_data_segment;}</p><p>brk 的作用實際上就是設置進程數據段的結束地址，即它可以擴大或者縮小數據段（Linux 下數據段和 BBS 合併在一起統稱數據段）。</p><p>如果我們將數據段的結束地址向高地址移動，那麼擴大的那部分空間就可以被我們使用，把這塊空間拿過來使用作為堆空間是最常見的做法。</p><p><strong>mmap 系統調用</strong></p><p>和 Windows 系統下的 VirtualAlloc 很相似，它的作用就是向操作系統申請一段虛擬地址空間，（堆和棧中間，稱為文件映射區域的地方）這塊虛擬地址空間可以映射到某個文件。</p><p>glibc 的 malloc 函數是這樣處理用戶的空間請求的：對於小於 128KB 的請求來說，它會在現有的堆空間裡面，按照堆分配算法為它分配一塊空間並返回；對於大於128KB 的請求來說，它會使用 mmap 函數為它分配一塊匿名空間，然後在這個匿名空間中為用戶分配空間。</p><p>聲明如下：</p><pre><code>void* mmap{<br>void* start;<br>size_t length;<br>int prot;<br>int flags;<br>int fd;<br>off_t offset;<br>}<br></code></pre><p>mmap 前兩個參數分別用於指定需要申請的空間的起始地址和長度，如果起始地址設置 0，那麼 Linux 系統會自動挑選合適的起始地址。</p><p>prot/flags 參數：用於設置申請的空間的權限（可讀，可寫，可執行）以及映射類型（文件映射，匿名空間等）。</p><p>最後兩個參數用於文件映射時指定的文件描述符和文件偏移的。</p><p>瞭解了 Linux 系統對於堆的管理之後，我們可以思考這麼一個問題：</p><p><strong>malloc 到底一次能夠申請的最大空間是多少？</strong></p><p>為了回答這個問題，就不得不再回頭仔細研究一下之前的圖一。我們可以看到在有共享庫的情況下，留給堆可以用的空間還有兩處。</p><p>第一處就是從 BSS 段結束到 0x40 000 000 即大約 1GB 不到的空間；</p><p>第二處是從共享庫到棧的這塊空間，大約是 2GB 不到。這兩塊空間大小都取決於棧、共享庫的大小和數量。</p><p>於是可以估算到 malloc 最大的申請空間大約是 2GB 不到。（Linux 內核 2.4 版本）。</p><p>當然還有其它諸多因素會影響 malloc 的最大空間大小，比如系統的資源限制（ulimit），物理內存和交換空間的總和等。</p><p>mmap 申請匿名空間時，系統會為它在內存或交換空間中預留地址，但是申請的空間大小不能超過空閒內存+空閒交換空間的總和。</p><p><strong>堆分配算法</strong></p><p><strong>1、空閒鏈表法（即調用 malloc 分配）</strong></p><p>就是把堆中各個空閒的塊按照鏈表的方式連接起來，當用戶請求一塊空間的時候，可以遍歷整個列表，直到找到合適大小的塊並且將它拆分；當用戶釋放空間的時候將它合併到空閒鏈表中。</p><p>空閒鏈表是這樣一種結構，在堆裡的每一個空閒空間的開頭(或結尾)有一個頭 (header)，頭結構裡記錄了上一個 (prev) 和下一個 (next) 空閒塊的地址，也就是說，所有的空閒塊形成了一個鏈表。如圖所示。</p><img alt=淺談程序的內存佈局 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RqozObiFriVbaC><p>具體實現方案：</p><ul><li><p>malloc 函數的實質是它有一個將可用的內存塊連接為一個長長的列表的所謂空閒鏈表。</p></li><li><p>調用 malloc函數時，它沿著連接表尋找一個大到足以滿足用戶請求所需要的內存塊。然後，將該內存塊一分為二（一塊的大小與用戶申請的大小相等，另一塊的大小就是剩下來的字節）。接下來，將分配給用戶的那塊內存存儲區域傳給用戶，並將剩下的那塊（如果有的話）返回到連接表上。</p></li><li><p>調用 free 函數時，它將用戶釋放的內存塊連接到空閒鏈表上。</p></li><li><p>到最後，空閒鏈會被切成很多的小內存片段，如果這時用戶申請一個大的內存片段， 那麼空閒鏈表上可能沒有可以滿足用戶要求的片段了。於是，malloc 函數請求延時，並開始在空閒鏈表上檢查各內存片段，對它們進行內存整理，將相鄰的小空閒塊合併成較大的內存塊。</p></li></ul><p><strong>2、位圖法</strong></p><p>針對空閒鏈表的弊端，另一種分配方式顯得更加穩健。這種方式稱為位圍(Bitmap)，其核心思想是將整個堆劃分為大量的塊(block)，每個塊的大小相同。</p><p>當用戶請求內存的時候，總是分配整數個塊的空間給用戶，第一個塊我們稱為已分配區域的頭(Head)，其餘的稱為己分配區域的主體(Body)，而我們可以使用一個整數數組來記錄塊的使用情況，由於每個塊只有頭/主體/空閒三種狀態，因此僅僅需要兩位即可表示一個塊，因此稱為位圖。</p><p><strong>3、對象池</strong></p><p>還有一種方法是對象池，也是把堆空間分成了大小相等的一些塊，它是認為某些場合每次分配的空間都相等，所以每次就直接返回一個塊的大小，它的管理方法可以是鏈表也可以是位圖。因為不用每次查找合適的大小的內存返回，所以效率很高。</p><p>實際上很多現實應用中，堆的分配算法往往是採取多種算法複合而成的。</p><p>比如對於glibc來說，它對於小於64字節的空間申請是採用類似於對象池的方法。</p><p>而對於大於512字節的空間申請採用的是最佳適配算法；</p><p>對於大於64字節而小於512字節的，它會根據情況採取上述方法中的最佳折中策略；</p><p>對於大於128KB的申請，它會使用mmap機制直接向操作系統申請空間。</p><p><strong>參考資料：</strong></p><ul><li><p>《程序員的自我修養》</p></li><li><p>http://www.ruanyifeng.com/blog/2016/12/user_space_vs_kernel_space.html</p></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>淺談</a></li><li><a>內存</a></li><li><a>程序</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ec734b.html alt=淺談Linux內存管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4443462f6dbd4ae5a5257ef9f329d755 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ec734b.html title=淺談Linux內存管理>淺談Linux內存管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c705a95.html alt=淺談無人機傾斜攝影測量技術標準 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/433b0001f1761786a418 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c705a95.html title=淺談無人機傾斜攝影測量技術標準>淺談無人機傾斜攝影測量技術標準</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32b07cdf.html alt=淺談虛擬現實技術在實際中的應用是什麼？你的看法是？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/320e000488d3da066723 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32b07cdf.html title=淺談虛擬現實技術在實際中的應用是什麼？你的看法是？>淺談虛擬現實技術在實際中的應用是什麼？你的看法是？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/218a90a9.html alt=淺談廣西沿海鐵路公司，到底寧局好還是沿海好？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153102100759992f2d934f2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/218a90a9.html title=淺談廣西沿海鐵路公司，到底寧局好還是沿海好？>淺談廣西沿海鐵路公司，到底寧局好還是沿海好？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0bbe5cba.html alt=淺談廣西高鐵里程，曾經以1700多公里奪冠，創下了輝煌史！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dbb04b7e14834fdda0eedea1205e664a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0bbe5cba.html title=淺談廣西高鐵里程，曾經以1700多公里奪冠，創下了輝煌史！>淺談廣西高鐵里程，曾經以1700多公里奪冠，創下了輝煌史！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96594f0.html alt=淺談通信基本概念，收藏了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e1bea466fcaa45bbbe91877c2c083ebe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96594f0.html title=淺談通信基本概念，收藏了>淺談通信基本概念，收藏了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8e8a950.html alt=實車事故車案例——淺談事故車 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4ac90de03c0549cb85a7d0a5c997753b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8e8a950.html title=實車事故車案例——淺談事故車>實車事故車案例——淺談事故車</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f93af1ed.html alt=持股拿不住怎麼辦？淺談交易中的“回撤賣出法” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a9d04a4312547a1bec87c3a946a63de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f93af1ed.html title=持股拿不住怎麼辦？淺談交易中的“回撤賣出法”>持股拿不住怎麼辦？淺談交易中的“回撤賣出法”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/87ec6d9d.html alt=管理評審程序（IAO9001程序文件範本） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/87ec6d9d.html title=管理評審程序（IAO9001程序文件範本）>管理評審程序（IAO9001程序文件範本）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fd25820.html alt=質量管理體系程序文件-FMEA程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fd25820.html title=質量管理體系程序文件-FMEA程序>質量管理體系程序文件-FMEA程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0ffb976.html alt=不合格、糾正措施程序文件（ISO9001程序文件範本） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0ffb976.html title=不合格、糾正措施程序文件（ISO9001程序文件範本）>不合格、糾正措施程序文件（ISO9001程序文件範本）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16c259de.html alt=什麼是程序文件？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16c259de.html title=什麼是程序文件？>什麼是程序文件？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8c41b36.html alt=今天聊聊程序的文件的概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8c41b36.html title=今天聊聊程序的文件的概念>今天聊聊程序的文件的概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd79f8d.html alt=程序文件-ISO9001 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2e673ba29f5545fd8aea4073e1c638c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd79f8d.html title=程序文件-ISO9001>程序文件-ISO9001</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e56d2fb8.html alt=程序文件主要包括哪些內容？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e56d2fb8.html title=程序文件主要包括哪些內容？>程序文件主要包括哪些內容？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>