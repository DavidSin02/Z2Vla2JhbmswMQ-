<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面向對象設計的原則一二 | 极客快訊</title><meta property="og:title" content="面向對象設計的原則一二 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/3f695e811db847a991662fc4eefa151f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5862f7a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5862f7a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5862f7a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5862f7a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5862f7a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5862f7a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5862f7a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5862f7a.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="面向對象設計的原則一二"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5862f7a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面向對象設計的原則一二</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>前言</p><p>在面向對象的軟件設計中，只有儘量降低各個模塊之間的耦合度，才能提高代碼的複用率，系統的可維護性、可擴展性才能提高。面向對象的軟件設計中，有23種經典的設計模式，是一套前人代碼設計經驗的總結，如果把設計模式比作武功招式，那麼設計原則就好比是內功心法。常用的設計原則有七個，下文將具體介紹。</p><h2 class=pgc-h-arrow-right>設計原則簡介</h2><ul><li>單一職責原則：專注降低類的複雜度，實現類要職責單一；</li><li>開放關閉原則：所有面向對象原則的核心，設計要對擴展開發，對修改關閉；</li><li>裡式替換原則：實現開放關閉原則的重要方式之一，設計不要破壞繼承關係；</li><li>依賴倒置原則：系統抽象化的具體實現，要求面向接口編程，是面向對象設計的主要實現機制之一；</li><li>接口隔離原則：要求接口的方法儘量少，接口儘量細化；</li><li>迪米特法則：降低系統的耦合度，使一個模塊的修改儘量少的影響其他模塊，擴展會相對容易；</li><li>組合複用原則：在軟件設計中，儘量使用組合/聚合而不是繼承達到代碼複用的目的。</li></ul><p>這些設計原則並不說我們一定要遵循他們來進行設計，而是根據我們的實際情況去怎麼去選擇使用他們，來讓我們的程序做的更加的完善。</p><h2 class=pgc-h-arrow-right>單一職責原則</h2><p>解釋：</p><p>就一個類而言，應該僅有一個引起它變化的原因，通俗的說，就是一個類只負責一項職責。</p><p>此原則的核心就是解耦和增強內聚性</p><p>那麼為什麼要使用單一職責原則：</p><p>如果一個類承擔的職責過多，就等於把這些職責耦合在一起，一個職責的變化可能會削弱或者抑制這個類完成其他職責的能力。這種耦合會導致脆弱的設計。</p><p>這也是他的優點，我們總結一下</p><p>優點：</p><p>（1）降低類的複雜度；</p><p>（2）提高類的可讀性，提高系統的可維護性；</p><p>（3）降低變更引起的風險（降低對其他功能的影響）。</p><p>我們來舉一些簡單的例子來說明一下這個單一職責原則</p><p>實例：</p><pre><code>    //我們用動物生活來做測試    class Animal{        public void breathe(String animal){            System.out.println(animal+"生活在陸地上");        }    }    public class Client{        public static void main(String[] args){            Animal animal = new Animal();            animal.breathe("羊");            animal.breathe("牛");            animal.breathe("豬");        }    }    運行結果 羊生活在陸地上 牛生活在陸地上 豬生活在陸地上</code></pre><p>但是問題來了，動物並不是都生活在陸地上的，魚就是生活在水中的，修改時如果遵循單一職責原則，需要將Animal類細分為陸生動物類Terrestrial，水生動物Aquatic，代碼如下：</p><pre><code>class Terrestrial{    public void breathe(String animal){        System.out.println(animal+"生活在陸地上");    }}class Aquatic{    public void breathe(String animal){        System.out.println(animal+"生活在水裡");    }}    public class Client{        public static void main(String[] args){            Terrestrial terrestrial = new Terrestrial();            terrestrial.breathe("羊");            terrestrial.breathe("牛");            terrestrial.breathe("豬");                Aquatic aquatic = new Aquatic();            aquatic.breathe("魚");        }運行結果：羊生活在陸地上牛生活在陸地上豬生活在陸地上魚生活在水裡</code></pre><p>但是問題來了如果這樣修改花銷是很大的，除了將原來的類分解之外，還需要修改客戶端。而直接修改類Animal來達成目的雖然違背了單一職責原則，但花銷卻小的多，代碼如下：</p><pre><code>class Animal{    public void breathe(String animal){        if("魚".equals(animal)){            System.out.println(animal+"生活在水中");        }else{            System.out.println(animal+"生活在陸地上");        }    }}public class Client{    public static void main(String[] args){        Animal animal = new Animal();        animal.breathe("羊");        animal.breathe("牛");        animal.breathe("豬");        animal.breathe("魚");    }</code></pre><p>可以看到，這種修改方式要簡單的多。但是卻存在著隱患：有一天需要將魚分為生活在淡水中的魚和生活在海水的魚，則又需要修改Animal類的breathe方法，而對原有代碼的修改會對調用“豬”“牛”“羊”等相關功能帶來風險，也許某一天你會發現程序運行的結果變為“牛生活在水中”了。</p><p>這種修改方式直接在代碼級別上違背了單一職責原則，雖然修改起來最簡單，但隱患卻是最大的。還有一種修改方式：</p><pre><code>class Animal{    public void breathe(String animal){        System.out.println(animal+"生活在陸地上");    }    public void breathe2(String animal){        System.out.println(animal+"生活在水中");    }}public class Client{    public static void main(String[] args){        Animal animal = new Animal();        animal.breathe("牛");        animal.breathe("羊");        animal.breathe("豬");        animal.breathe2("魚");    }}</code></pre><p>可以看到，這種修改方式沒有改動原來的方法，而是在類中新加了一個方法，這樣雖然也違背了單一職責原則，但在方法級別上卻是符合單一職責原則的，因為它並沒有動原來方法的代碼。</p><p>這三種方式各有優缺點，那麼在實際編程中，採用哪一中呢？其實這真的比較難說，需要根據實際情況來確定。我的原則是：只有邏輯足夠簡單，才可以在代碼級別上違反單一職責原則；只有類中方法數量足夠少，才可以在方法級別上違反單一職責原則；</p><p>例如本文所舉的這個例子，它太簡單了，它只有一個方法，所以，無論是在代碼級別上違反單一職責原則，還是在方法級別上違反，都不會造成太大的影響。 實際應用中的類都要複雜的多，一旦發生職責擴散而需要修改類時，除非這個類本身非常簡單，否則還是遵循單一職責原則的好。</p><p>以上就是我所說的單一職責原則了，很多書中介紹的說它並不屬於面向對象設計原則中的一種，但是我認為它是，所以我就把他解釋出來了。</p><h2 class=pgc-h-arrow-right>開放關閉原則</h2><p>開放關閉原則又稱為開放封閉原則。</p><p>定義：</p><p>一個軟件實體應該對擴展開放，對修改關閉，這個原則也是說，在設計一個模塊的時候，應當使這個模塊可以在不被修改的前提下被擴展，換句話說，應當可以在不必修改源碼的情況下改變這個模塊的行為。</p><p>這句話其實剛開始看上去是有些矛盾的，接下來在我後邊文章解釋裡面，我會把他解釋清楚一點。</p><p>我們先用個比較好玩的例子來說一下。</p><p>西遊記大家都看過，玉帝招安孫悟空的時候的橋段，大家還有沒有印象？</p><p>當年大腦天宮的時候美猴王對玉皇大帝做了個挑戰，美猴王說：皇帝輪流做，明年到我家，只叫他搬出去，將天宮讓給我，對於這個挑戰，太白金星給玉皇大帝提了個意見，我們把它招上來，給他個小官做，他不就不鬧事了？</p><p>換一句話說，不用興師動眾的，不破壞天庭的規矩這就是閉，但是收他為官，便是開，招安的方法便是符合開閉原則的，給他個‘弼馬溫’的官，便可以讓這個系統正常不受威脅，是吧，何樂而不為？ 我給大家畫個圖。</p><div class=pgc-img><img alt=面向對象設計的原則一二 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f695e811db847a991662fc4eefa151f><p class=pgc-img-caption></p></div><p>招安的方法的關鍵就是不允許更改現有的天庭秩序，但是允許將妖猴納入現有的秩序中，從而擴展了這個秩序，用面向對象的語言來說：不允許更改的是系統的抽象層，而允許擴展的是系統的實現層。</p><p>我們寫一些簡單的代碼來進行一個完整的展示來進行一下理解。</p><p>實例：</p><pre><code>    //書店賣書    interface Books{        //書籍名稱        public Sting getName();        //書籍價格        public int getPrice();        //書籍作者        public String getAuthor();    }    public class NovelBook implements Books {    private String name;    private int price;    private String author;    public NovelBook(String name, int price, String author) {        this.name = name;        this.price = price;        this.author = author;    }    @Override    public String getName() {        return name;    }    @Override    public int getPrice() {        return price;    }    @Override    public String getAuthor() {        return author;    }}</code></pre><p>以上的代碼是數據的實現類和書籍的類別；</p><p>下面我們將要開始對書籍進行一個售賣活動：</p><pre><code>public class BookStore {    private final static ArrayList&lt;Books&gt; sBookList = new ArrayList&lt;Books&gt;();    static {        sBookList.add(new NovelBook("天龍八部", 4400, "金庸"));        sBookList.add(new NovelBook("射鵰英雄傳", 7600, "金庸"));        sBookList.add(new NovelBook("鋼鐵是怎麼煉成的", 7500, "保爾·柯查金"));        sBookList.add(new NovelBook("紅樓夢", 3300, "曹雪芹"));    }    public static void main(String[] args) throws IOException {        NumberFormat format = NumberFormat.getCurrencyInstance();        format.setMaximumFractionDigits(2);       System.out.println("----書店賣出去的書籍記錄如下---");        for (Books book : sBookList) {            System.out.println("書籍名稱:" + book.getName()                    + "\t書籍作者:" + book.getAuthor()                    + "\t書籍價格:" + format.format(book.getPrice() / 100.00) + "元");        }    }}</code></pre><p>運行結果如下：</p><pre><code>D:\develop\JDK8\jdk1.8.0_181\bin\java.exe "-javaagent:D:\develop\IDEA\IntelliJ IDEA 2018.2.4\lib\idea_rt.jar=62787:D:\develop\IDEA\IntelliJ IDEA 2018.2.4\bin" -Dfile.encoding=UTF-8 -classpath D:\develop\JDK8\jdk1.8.0_181\jre\lib\charsets.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\deploy.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\dnsns.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\jaccess.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\localedata.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\nashorn.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\sunec.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\ext\zipfs.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\javaws.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\jce.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\jfr.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\jfxswt.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\jsse.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\management-agent.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\plugin.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\resources.jar;D:\develop\JDK8\jdk1.8.0_181\jre\lib\rt.jar;D:\develop\IDEA_Workspace\CloudCode\out\production\PattemMoudle com.yldyyn.test.BookStore----書店賣出去的書籍記錄如下---書籍名稱:天龍八部	書籍作者:金庸	書籍價格:￥44.00元書籍名稱:射鵰英雄傳	書籍作者:金庸	書籍價格:￥76.00元書籍名稱:鋼鐵是怎麼煉成的	書籍作者:保爾·柯查金	書籍價格:￥75.00元書籍名稱:紅樓夢	書籍作者:曹雪芹	書籍價格:￥33.00元Process finished with exit code 0</code></pre><p>但是如果說現在書店賣書的時候要求打折出售，40以上的我們要7折售賣，40一下的我們打8折。</p><p>方法有三種，第一個辦法：修改接口。在Books上新增加一個方法getOnSalePrice()，專門進行打折，所有實現類實現這個方法。 但是這樣修改的後果就是實現類NovelBook要修改,BookStore中的main方法也修改，同時Books作為接口應該是穩定且可靠的，不應該經常發生變化，否則接口做為契約的作用就失去了效能，其他不想打折的書籍也會因為實現了書籍的接口必須打折，因此該方案被否定。</p><p>第二個辦法：修改實現類。修改NovelBook 類中的方法，直接在getPrice()中實現打折處理，這個應該是大家在項目中經常使用的就是這樣辦法，通過class文件替換的方式可以完成部分業務（或是缺陷修復）變化，但是該方法還是有缺陷的，例如採購書籍人員也是要看價格的，由於該方法已經實現了打折處理價格，因此採購人員看到的也是打折後的價格，這就產生了信息的矇蔽效果，導致信息不對稱而出現決策失誤的情況。該方案也不是一個最優的方案。</p><p>第三個辦法，通過擴展實現變化增加一個子類 OffNovelBook，覆寫getPrice方法，高層次的模塊（也就是static靜態模塊區）通過OffNovelBook類產生新的對象，完成對業務變化開發任務。好辦法，風險也小。</p><pre><code>public class OnSaleBook extends NovelBook {    public OnSaleBook(String name, int price, String author) {        super(name, price, author);    }    @Override    public String getName() {        return super.getName();    }    @Override    public int getPrice() {        int OnsalePrice = super.getPrice();        int salePrce = 0;        if (OnsalePrice &gt;4000){            salePrce = OnsalePrice * 70/100;        }else{            salePrce = OnsalePrice * 80/100;        }        return  salePrce;    }    @Override    public String getAuthor() {        return super.getAuthor();    }}</code></pre><p>上面的代碼是擴展出來的一個類，而不是在原來的類中進行的修改。</p><pre><code>public class BookStore {    private final static ArrayList&lt;Books&gt; sBookList = new ArrayList&lt;Books&gt;();    static {        sBookList.add(new OnSaleBook("天龍八部", 4400, "金庸"));        sBookList.add(new OnSaleBook("射鵰英雄傳", 7600, "金庸"));        sBookList.add(new OnSaleBook("鋼鐵是怎麼煉成的", 7500, "保爾·柯查金"));        sBookList.add(new OnSaleBook("紅樓夢", 3300, "曹雪芹"));    }    public static void main(String[] args) throws IOException {        NumberFormat format = NumberFormat.getCurrencyInstance();        format.setMaximumFractionDigits(2);       System.out.println("----書店賣出去的書籍記錄如下---");        for (Books book : sBookList) {            System.out.println("書籍名稱:" + book.getName()                    + "\t書籍作者:" + book.getAuthor()                    + "\t書籍價格:" + format.format(book.getPrice() / 100.00) + "元");        }    }}</code></pre><p>結果展示：</p><pre><code>----書店賣出去的書籍記錄如下---書籍名稱:天龍八部	書籍作者:金庸	書籍價格:￥30.80元書籍名稱:射鵰英雄傳	書籍作者:金庸	書籍價格:￥53.20元書籍名稱:鋼鐵是怎麼煉成的	書籍作者:保爾·柯查金	書籍價格:￥52.50元書籍名稱:紅樓夢	書籍作者:曹雪芹	書籍價格:￥26.40元Process finished with exit code 0</code></pre><p>在開閉原則中，抽象化是一個關鍵，解決問題的關鍵在於抽象化，在JAVA語言這種面向對象的語言中，可以給系統定義出一個一勞永逸的，不再更改的抽象化的設計，此設計允許擁有無窮無盡的實現層被實現。</p><p>在JAVA語言中，可以給出一個或者多個抽象的JAVA類或者是JAVA接口，規定所有的具體類必須提供方法特徵作為系統設計的抽象層，這個抽象層會遇見所有的可能出現的擴展，因此，在任何擴展情況下都不回去改變，這就讓系統的抽象層不需要修改，從而滿足開閉原則的第二條，對修改進行閉合。</p><p>同時，從抽象層裡面導出一個或者多個新的具體類可以改變系統的行為，這樣就滿足了開閉原則的第一條。</p><p>儘管很多時候我們無法百分百的做到開閉原則，但是如果向著這個方向去努力，就能夠有部分的成功，這也是可以改善系統的結構的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>對象</a></li><li><a>設計</a></li><li><a>原則</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html alt=面向對象設計原則之開閉原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ff63803ae3d4638b01095d32682fa70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html title=面向對象設計原則之開閉原則>面向對象設計原則之開閉原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html alt=面向對象設計的七大原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd44e43836e64ae3b2c4d6e9ffa9f033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html title=面向對象設計的七大原則>面向對象設計的七大原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html alt=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/93686fc2-2a36-4161-8664-03ae59f6e71e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html title=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺>面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/830b660.html alt=面向對象的程序設計原則之SOLID原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1391fe67dc134aae92fef59ec541c40e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/830b660.html title=面向對象的程序設計原則之SOLID原則>面向對象的程序設計原則之SOLID原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb60e0b.html alt="面向對象的設計原則-'里氏替換原則'" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb60e0b.html title="面向對象的設計原則-'里氏替換原則'">面向對象的設計原則-'里氏替換原則'</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ff8b90.html alt=不懂對象設計原則，都不好意思自稱php大師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ff8b90.html title=不懂對象設計原則，都不好意思自稱php大師>不懂對象設計原則，都不好意思自稱php大師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0ef77f.html alt=面向對象設計原則（OOP） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1537670193470d0e7533729 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0ef77f.html title=面向對象設計原則（OOP）>面向對象設計原則（OOP）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb36434b.html alt=可靠性設計原則1000條---菜鳥走向大神必經之路 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb36434b.html title=可靠性設計原則1000條---菜鳥走向大神必經之路>可靠性設計原則1000條---菜鳥走向大神必經之路</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f7121626.html alt=可靠性設計原則1000條（完整版，建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f7121626.html title=可靠性設計原則1000條（完整版，建議收藏）>可靠性設計原則1000條（完整版，建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a11c588.html alt="PCB設計基本流程 & 佈局佈線基本原則和常識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7d8f835b7a3a4991b521f59f78f48d65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a11c588.html title="PCB設計基本流程 & 佈局佈線基本原則和常識">PCB設計基本流程 & 佈局佈線基本原則和常識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a849f9c9.html alt=燃氣管道佈置設計原則、基本要求與補償器的選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153013884a3441cdaf954d0f1510fc51 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a849f9c9.html title=燃氣管道佈置設計原則、基本要求與補償器的選擇>燃氣管道佈置設計原則、基本要求與補償器的選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d7ca019.html alt=管道佈置設計原則、基本要求與補償器的選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ba20020083df4c82a21b87b502ae0a0e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d7ca019.html title=管道佈置設計原則、基本要求與補償器的選擇>管道佈置設計原則、基本要求與補償器的選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a540ed0e.html alt=建築立面設計原則+處理手法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5dd8595ef4064bc5b4b0eee602fbaef5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a540ed0e.html title=建築立面設計原則+處理手法>建築立面設計原則+處理手法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html alt=面向對象設計之依賴倒置原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html title=面向對象設計之依賴倒置原則>面向對象設計之依賴倒置原則</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>