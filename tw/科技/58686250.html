<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>全網最全 | MySQL EXPLAIN 完全解讀 | 极客快訊</title><meta property="og:title" content="全網最全 | MySQL EXPLAIN 完全解讀 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/88fc822de5fe4201b969f177fb3ab93a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/58686250.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/58686250.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/58686250.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/58686250.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/58686250.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/58686250.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/58686250.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/58686250.html><meta property="article:published_time" content="2020-11-14T21:00:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:22+08:00"><meta name=Keywords content><meta name=description content="全網最全 | MySQL EXPLAIN 完全解讀"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/58686250.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>全網最全 | MySQL EXPLAIN 完全解讀</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>EXPLAIN作為MySQL的性能分析神器，讀懂其結果是很有必要的，然而我在各種搜索引擎上竟然找不到特別完整的解讀。都是隻有重點，沒有細節（例如type的取值不全、Extra缺乏完整的介紹等）。</p><p>所以，我肝了將近一個星期，整理了一下。這應該是全網最全面、最細緻的EXPLAIN解讀文章了，下面是全文。</p><p>文章比較長，建議收藏。</p><blockquote><p><strong>TIPS</strong></p><p>本文基於MySQL 8.0編寫，理論支持MySQL 5.0及更高版本。</p></blockquote><h2 class=pgc-h-arrow-right>EXPLAIN使用</h2><p>explain可用來分析SQL的執行計劃。格式如下：</p><pre><code>{EXPLAIN | DESCRIBE | DESC}    tbl_name [col_name | wild]{EXPLAIN | DESCRIBE | DESC}    [explain_type]    {explainable_stmt | FOR CONNECTION connection_id}{EXPLAIN | DESCRIBE | DESC} ANALYZE select_statement    explain_type: {    FORMAT = format_name}format_name: {    TRADITIONAL  | JSON  | TREE}explainable_stmt: {    SELECT statement  | TABLE statement  | DELETE statement  | INSERT statement  | REPLACE statement  | UPDATE statement}</code></pre><p>示例：</p><pre><code>EXPLAIN format = TRADITIONAL json SELECT tt.TicketNumber, tt.TimeIn,               tt.ProjectReference, tt.EstimatedShipDate,               tt.ActualShipDate, tt.ClientID,               tt.ServiceCodes, tt.RepetitiveID,               tt.CurrentProcess, tt.CurrentDPPerson,               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,               et_1.COUNTRY, do.CUSTNAME        FROM tt, et, et AS et_1, do        WHERE tt.SubmitTime IS NULL          AND tt.ActualPC = et.EMPLOYID          AND tt.AssignedPC = et_1.EMPLOYID          AND tt.ClientID = do.CUSTNMBR;</code></pre><p>結果輸出展示：</p><p><br></p><div class=pgc-img><img alt="全網最全 | MySQL EXPLAIN 完全解讀" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/88fc822de5fe4201b969f177fb3ab93a><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right>結果解讀</h2><h3 class=pgc-h-arrow-right>id</h3><p>該語句的唯一標識。如果explain的結果包括多個id值，則數字越大越先執行；而對於相同id的行，則表示從上往下依次執行。</p><h3 class=pgc-h-arrow-right>select_type</h3><p>查詢類型，有如下幾種取值：</p><p><strong>查詢類型作用</strong></p><p><br></p><div class=pgc-img><img alt="全網最全 | MySQL EXPLAIN 完全解讀" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/83cd2b7abec847949c14029e28bbcb93><p class=pgc-img-caption></p></div><p><br></p><h3 class=pgc-h-arrow-right>table</h3><p>表示當前這一行正在訪問哪張表，如果SQL定義了別名，則展示表的別名</p><h3 class=pgc-h-arrow-right>partitions</h3><p>當前查詢匹配記錄的分區。對於未分區的表，返回null</p><h3 class=pgc-h-arrow-right>type</h3><p>連接類型，有如下幾種取值，<strong>性能從好到壞排序</strong> 如下：</p><p>1 system：該表只有一行（相當於系統表），system是const類型的特例</p><p>2 const：針對主鍵或唯一索引的等值查詢掃描, 最多隻返回一行數據. const 查詢速度非常快, 因為它僅僅讀取一次即可</p><p>3 eq_ref：當使用了索引的全部組成部分，並且索引是PRIMARY KEY或UNIQUE NOT NULL 才會使用該類型，性能僅次於system及const。</p><pre><code>-- 多表關聯查詢，單行匹配SELECT * FROM ref_table,other_table  WHERE ref_table.key_column=other_table.column;-- 多表關聯查詢，聯合索引，多行匹配SELECT * FROM ref_table,other_table  WHERE ref_table.key_column_part1=other_table.column  AND ref_table.key_column_part2=1;</code></pre><p>4 ref：當滿足索引的最左前綴規則，或者索引不是主鍵也不是唯一索引時才會發生。如果使用的索引只會匹配到少量的行，性能也是不錯的。</p><pre><code>-- 根據索引（非主鍵，非唯一索引），匹配到多行SELECT * FROM ref_table WHERE key_column=expr;-- 多表關聯查詢，單個索引，多行匹配SELECT * FROM ref_table,other_table  WHERE ref_table.key_column=other_table.column;-- 多表關聯查詢，聯合索引，多行匹配SELECT * FROM ref_table,other_table  WHERE ref_table.key_column_part1=other_table.column  AND ref_table.key_column_part2=1;</code></pre><blockquote><p><strong>TIPS</strong></p><p>最左前綴原則，指的是索引按照最左優先的方式匹配索引。比如創建了一個組合索引(column1, column2, column3)，那麼，如果查詢條件是：</p><p>WHERE column1 = 1、WHERE column1= 1 AND column2 = 2、WHERE column1= 1 AND column2 = 2 AND column3 = 3 都可以使用該索引；WHERE column1 = 2、WHERE column1 = 1 AND column3 = 3就無法匹配該索引。</p></blockquote><p>5 fulltext：全文索引</p><p>6 ref_or_null：該類型類似於ref，但是MySQL會額外搜索哪些行包含了NULL。這種類型常見於解析子查詢</p><pre><code>SELECT * FROM ref_table  WHERE key_column=expr OR key_column IS NULL;</code></pre><p>7 index_merge：此類型表示使用了索引合併優化，表示一個查詢裡面用到了多個索引</p><p>8 unique_subquery：該類型和eq_ref類似，但是使用了IN查詢，且子查詢是主鍵或者唯一索引。例如：</p><pre><code>value IN (SELECT primary_key FROM single_table WHERE some_expr)</code></pre><p>9 index_subquery：和unique_subquery類似，只是子查詢使用的是非唯一索引</p><pre><code>value IN (SELECT key_column FROM single_table WHERE some_expr)</code></pre><p>10 range：範圍掃描，表示檢索了指定範圍的行，主要用於有限制的索引掃描。比較常見的範圍掃描是帶有BETWEEN子句或WHERE子句裡有>、>=、&lt;、&lt;=、IS NULL、&lt;=>、BETWEEN、LIKE、IN()等操作符。</p><pre><code>SELECT * FROM tbl_name  WHERE key_column BETWEEN 10 and 20;SELECT * FROM tbl_name  WHERE key_column IN (10,20,30);</code></pre><p>11 index：全索引掃描，和ALL類似，只不過index是全盤掃描了索引的數據。當查詢僅使用索引中的一部分列時，可使用此類型。有兩種場景會觸發：</p><ul><li>如果索引是查詢的覆蓋索引，並且索引查詢的數據就可以滿足查詢中所需的所有數據，則只掃描索引樹。此時，explain的Extra 列的結果是Using index。index通常比ALL快，因為索引的大小通常小於表數據。</li><li>按索引的順序來查找數據行，執行了全表掃描。此時，explain的Extra列的結果不會出現Uses index。</li><li>ALL：全表掃描，性能最差。</li></ul><h3 class=pgc-h-arrow-right>possible_keys</h3><p>展示當前查詢可以使用哪些索引，這一列的數據是在優化過程的早期創建的，因此有些索引可能對於後續優化過程是沒用的。</p><h3 class=pgc-h-arrow-right>key</h3><p>表示MySQL實際選擇的索引</p><h3 class=pgc-h-arrow-right>key_len</h3><p>索引使用的字節數。由於存儲格式，當字段允許為NULL時，key_len比不允許為空時大1字節。</p><p>key_len計算公式： https://www.cnblogs.com/gomysql/p/4004244.html</p><h3 class=pgc-h-arrow-right>ref</h3><p>表示將哪個字段或常量和key列所使用的字段進行比較。</p><p>如果ref是一個函數，則使用的值是函數的結果。要想查看是哪個函數，可在EXPLAIN語句之後緊跟一個SHOW WARNING語句。</p><h3 class=pgc-h-arrow-right>rows</h3><p>MySQL估算會掃描的行數，數值越小越好。</p><h3 class=pgc-h-arrow-right>filtered</h3><p>表示符合查詢條件的數據百分比，最大100。用rows × filtered可獲得和下一張表連接的行數。例如rows = 1000，filtered = 50%，則和下一張表連接的行數是500。</p><blockquote><p><strong>TIPS</strong></p><p>在MySQL 5.7之前，想要顯示此字段需使用explain extended命令；</p><p>MySQL.5.7及更高版本，explain默認就會展示filtered</p></blockquote><h3 class=pgc-h-arrow-right>Extra</h3><p>展示有關本次查詢的附加信息，取值如下：</p><p>1 Child of 'table' pushed join@1</p><p>此值只會在NDB Cluster下出現。</p><p>2 const row not found</p><p>例如查詢語句SELECT ... FROM tbl_name，而表是空的</p><p>3 Deleting all rows</p><p>對於DELETE語句，某些引擎（例如MyISAM）支持以一種簡單而快速的方式刪除所有的數據，如果使用了這種優化，則顯示此值</p><p>4 Distinct</p><p>查找distinct值，當找到第一個匹配的行後，將停止為當前行組合搜索更多行</p><p>5 FirstMatch(tbl_name)</p><p>當前使用了半連接FirstMatch策略，詳見 https://mariadb.com/kb/en/firstmatch-strategy/ ，翻譯 https://www.cnblogs.com/abclife/p/10895624.html</p><p>6 Full scan on NULL key</p><p>子查詢中的一種優化方式，在無法通過索引訪問null值的時候使用</p><p>7 Impossible HAVING</p><p>HAVING子句始終為false，不會命中任何行</p><p>8 Impossible WHERE</p><p>WHERE子句始終為false，不會命中任何行</p><p>9 Impossible WHERE noticed after reading const tables</p><p>MySQL已經讀取了所有const（或system）表，並發現WHERE子句始終為false</p><p>10 LooseScan(m..n)</p><p>當前使用了半連接LooseScan策略，詳見 https://mariadb.com/kb/en/loosescan-strategy/ ，翻譯 http://www.javacoder.cn/?p=39</p><p>11 No matching min/max row</p><p>沒有任何能滿足例如 SELECT MIN(...) FROM ... WHERE condition 中的condition的行</p><p>12 no matching row in const table</p><p>對於關聯查詢，存在一個空表，或者沒有行能夠滿足唯一索引條件</p><p>13 No matching rows after partition pruning</p><p>對於DELETE或UPDATE語句，優化器在partition pruning（分區修剪）之後，找不到要delete或update的內容</p><p>14 No tables used</p><p>當此查詢沒有FROM子句或擁有FROM DUAL子句時出現。例如：explain select 1</p><p>15 Not exists</p><p>MySQL能對LEFT JOIN優化，在找到符合LEFT JOIN的行後，不會為上一行組合中檢查此表中的更多行。例如：</p><pre><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id  WHERE t2.id IS NULL;</code></pre><p>假設t2.id定義成了NOT NULL ，此時，MySQL會掃描t1，並使用t1.id的值查找t2中的行。 如果MySQL在t2中找到一個匹配的行，它會知道t2.id永遠不會為NULL，並且不會掃描t2中具有相同id值的其餘行。也就是說，對於t1中的每一行，MySQL只需要在t2中只執行一次查找，而不考慮在t2中實際匹配的行數。</p><p>在MySQL 8.0.17及更高版本中，如果出現此提示，還可表示形如 NOT IN (subquery) 或 NOT EXISTS (subquery) 的WHERE條件已經在內部轉換為反連接。這將刪除子查詢並將其表放入最頂層的查詢計劃中，從而改進查詢的開銷。通過合併半連接和反聯接，優化器可以更加自由地對執行計劃中的表重新排序，在某些情況下，可讓查詢提速。你可以通過在EXPLAIN語句後緊跟一個SHOW WARNING語句，並分析結果中的Message列，從而查看何時對該查詢執行了反聯接轉換。</p><blockquote><p><strong>Note</strong></p><p>兩表關聯只返回主表的數據，並且只返回主表與子表沒關聯上的數據，這種連接就叫反連接</p></blockquote><p>16 Plan isn't ready yet</p><p>使用了EXPLAIN FOR CONNECTION，當優化器尚未完成為在指定連接中為執行的語句創建執行計劃時， 就會出現此值。</p><p>17 Range checked for each record (index map: N)</p><p>MySQL沒有找到合適的索引去使用，但是去檢查是否可以使用range或index_merge來檢索行時，會出現此提示。index map N索引的編號從1開始，按照與表的SHOW INDEX所示相同的順序。 索引映射值N是指示哪些索引是候選的位掩碼值。 例如0x19（二進制11001）的值意味著將考慮索引1、4和5。</p><p>示例：下面例子中，name是varchar類型，但是條件給出整數型，涉及到隱式轉換。圖中t2也沒有用到索引，是因為查詢之前我將t2中name字段排序規則改為utf8_bin導致的鏈接字段排序規則不匹配。</p><pre><code>explain select a.* from t1 a left  join t2 bon t1.name = t2.namewhere t2.name = 2;</code></pre><p>結果：</p><p><br></p><div class=pgc-img><img alt="全網最全 | MySQL EXPLAIN 完全解讀" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0053a47ed7b1467ca6226de30a180d95><p class=pgc-img-caption></p></div><p>18 Recursive</p><p>出現了遞歸查詢。詳見 “WITH (Common Table Expressions)”</p><p>19 Rematerialize</p><p>用得很少，使用類似如下SQL時，會展示Rematerialize</p><pre><code>SELECT  ...FROM  t,  LATERAL (derived table that refers to t) AS dt...</code></pre><p>20 Scanned N databases</p><p>表示在處理INFORMATION_SCHEMA表的查詢時，掃描了幾個目錄，N的取值可以是0，1或者all。詳見 “Optimizing INFORMATION_SCHEMA Queries”</p><p>21 Select tables optimized away</p><p>優化器確定：①最多返回1行；②要產生該行的數據，要讀取一組確定的行，時會出現此提示。一般在用某些聚合函數訪問存在索引的某個字段時，優化器會通過索引直接一次定位到所需要的數據行完成整個查詢時展示，例如下面這條SQL。</p><pre><code>explainselect min(id)from t1;</code></pre><p>22 Skip_open_table， Open_frm_only， Open_full_table</p><p>這些值表示適用於INFORMATION_SCHEMA表查詢的文件打開優化；</p><p>23 Skip_open_table：無需打開表文件，信息已經通過掃描數據字典獲得</p><p>24 Open_frm_only：僅需要讀取數據字典以獲取表信息</p><p>25 Open_full_table：未優化的信息查找。表信息必須從數據字典以及表文件中讀取</p><p>26 Start temporary, End temporary</p><p>表示臨時表使用Duplicate Weedout策略，詳見 https://mariadb.com/kb/en/duplicateweedout-strategy/ ，翻譯 https://www.cnblogs.com/abclife/p/10895531.html</p><p>27 unique row not found</p><p>對於形如 SELECT ... FROM tbl_name 的查詢，但沒有行能夠滿足唯一索引或主鍵查詢的條件</p><p><strong>28 Using filesort</strong></p><p>當Query 中包含 ORDER BY 操作，而且無法利用索引完成排序操作的時候，MySQL Query Optimizer 不得不選擇相應的排序算法來實現。數據較少時從內存排序，否則從磁盤排序。Explain不會顯示的告訴客戶端用哪種排序。官方解釋：“MySQL需要額外的一次傳遞，以找出如何按排序順序檢索行。通過根據聯接類型瀏覽所有行併為所有匹配WHERE子句的行保存排序關鍵字和行的指針來完成排序。然後關鍵字被排序，並按排序順序檢索行”</p><p>29 Using index</p><p>僅使用索引樹中的信息從表中檢索列信息，而不必進行其他查找以讀取實際行。當查詢僅使用屬於單個索引的列時，可以使用此策略。例如：</p><pre><code>explain SELECT id FROM t</code></pre><p>30 Using index condition</p><p>表示先按條件過濾索引，過濾完索引後找到所有符合索引條件的數據行，隨後用 WHERE 子句中的其他條件去過濾這些數據行。通過這種方式，除非有必要，否則索引信息將可以延遲“下推”讀取整個行的數據。詳見 “Index Condition Pushdown Optimization” 。例如：</p><blockquote><p><strong>TIPS</strong></p><p>MySQL分成了Server層和引擎層，下推指的是將請求交給引擎層處理。</p><p>理解這個功能，可創建所以INDEX (zipcode, lastname, firstname)，並分別用如下指令，</p><p>SET optimizer_switch = 'index_condition_pushdown=off'; SET optimizer_switch = 'index_condition_pushdown=on';</p><p>開或者關閉索引條件下推，並對比：</p><p>explain SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';</p><p>的執行結果。</p><p>index condition pushdown從MySQL 5.6開始支持，是MySQL針對特定場景的優化機制，感興趣的可以看下 https://blog.51cto.com/lee90/2060449</p></blockquote><p>31 Using index for group-by</p><p>數據訪問和 Using index 一樣，所需數據只須要讀取索引，當Query 中使用GROUP BY或DISTINCT 子句時，如果分組字段也在索引中，Extra中的信息就會是 Using index for group-by。詳見 “GROUP BY Optimization”</p><pre><code>-- name字段有索引explain SELECT name FROM t1 group by name</code></pre><p>32 Using index for skip scan</p><p>表示使用了Skip Scan。詳見 Skip Scan Range Access Method</p><p>33 Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access)</p><p>使用Block Nested Loop或Batched Key Access算法提高join的性能。詳見 https://www.cnblogs.com/chenpingzhao/p/6720531.html</p><p>34 Using MRR</p><p>使用了Multi-Range Read優化策略。詳見 “Multi-Range Read Optimization”</p><p>35 Using sort_union(...), Using union(...), Using intersect(...)</p><p>這些指示索引掃描如何合併為index_merge連接類型。詳見 “Index Merge Optimization” 。</p><p><strong>36 Using temporary</strong></p><p>為了解決該查詢，MySQL需要創建一個臨時表來保存結果。如果查詢包含不同列的GROUP BY和 ORDER BY子句，通常會發生這種情況。</p><pre><code>-- name無索引explain SELECT name FROM t1 group by name</code></pre><p>37 Using where</p><p>如果我們不是讀取表的所有數據，或者不是僅僅通過索引就可以獲取所有需要的數據，則會出現using where信息</p><pre><code>explain SELECT * FROM t1 where id &gt; 5</code></pre><p>38 Using where with pushed condition</p><p>僅用於NDB</p><p>39 Zero limit</p><p>該查詢有一個limit 0子句，不能選擇任何行</p><pre><code>explain SELECT name FROM resource_template limit 0</code></pre><h2 class=pgc-h-arrow-right>擴展的EXPLAIN</h2><p>EXPLAIN可產生額外的擴展信息，可通過在EXPLAIN語句後緊跟一條SHOW WARNING語句查看擴展信息。</p><blockquote><p><strong>TIPS</strong></p><p>在MySQL 8.0.12及更高版本，擴展信息可用於SELECT、DELETE、INSERT、REPLACE、UPDATE語句；在MySQL 8.0.12之前，擴展信息僅適用於SELECT語句；在MySQL 5.6及更低版本，需使用EXPLAIN EXTENDED xxx語句；而從MySQL 5.7開始，無需添加EXTENDED關鍵詞。</p></blockquote><p>使用示例：</p><pre><code>mysql&gt; EXPLAIN       SELECT t1.a, t1.a IN (SELECT t2.a FROM t2) FROM t1\G*************************** 1. row ***************************           id: 1  select_type: PRIMARY        table: t1         type: indexpossible_keys: NULL          key: PRIMARY      key_len: 4          ref: NULL         rows: 4     filtered: 100.00        Extra: Using index*************************** 2. row ***************************           id: 2  select_type: SUBQUERY        table: t2         type: indexpossible_keys: a          key: a      key_len: 5          ref: NULL         rows: 3     filtered: 100.00        Extra: Using index2 rows in set, 1 warning (0.00 sec)mysql&gt; SHOW WARNINGS\G*************************** 1. row ***************************  Level: Note   Code: 1003Message: /* select#1 */ select `test`.`t1`.`a` AS `a`,         &lt;in_optimizer&gt;(`test`.`t1`.`a`,`test`.`t1`.`a` in         ( &lt;materialize&gt; (/* select#2 */ select `test`.`t2`.`a`         from `test`.`t2` where 1 having 1 ),         &lt;primary_index_lookup&gt;(`test`.`t1`.`a` in         &lt;temporary table&gt; on &lt;auto_key&gt;         where ((`test`.`t1`.`a` = `materialized-subquery`.`a`))))) AS `t1.a         IN (SELECT t2.a FROM t2)` from `test`.`t1`1 row in set (0.00 sec)</code></pre><p>由於SHOW WARNING的結果並不一定是一個有效SQL，也不一定能夠執行（因為裡面包含了很多特殊標記）。特殊標記取值如下：</p><p>1 &lt;auto_key></p><p>自動生成的臨時表key</p><p>2 &lt;cache>(expr)</p><p>表達式（例如標量子查詢）執行了一次，並且將值保存在了內存中以備以後使用。對於包括多個值的結果，可能會創建臨時表，你將會看到 &lt;temporary table> 的字樣</p><p>3 &lt;exists>(query fragment)</p><p>子查詢被轉換為 EXISTS</p><p>4 &lt;in_optimizer>(query fragment)</p><p>這是一個內部優化器對象，對用戶沒有任何意義</p><p>5 &lt;index_lookup>(query fragment)</p><p>使用索引查找來處理查詢片段，從而找到合格的行</p><p>6 &lt;if>(condition, expr1, expr2)</p><p>如果條件是true，則取expr1，否則取expr2</p><p>7 &lt;is_not_null_test>(expr)</p><p>驗證表達式不為NULL的測試</p><p>8 &lt;materialize>(query fragment)</p><p>使用子查詢實現</p><p>9 materialized-subquery.col_name</p><p>在內部物化臨時表中對col_name的引用，以保存子查詢的結果</p><p>10 &lt;primary_index_lookup>(query fragment)</p><p>使用主鍵來處理查詢片段，從而找到合格的行</p><p>11 &lt;ref_null_helper>(expr)</p><p>這是一個內部優化器對象，對用戶沒有任何意義</p><p>12 /* select#N */ select_stmt</p><p>SELECT與非擴展的EXPLAIN輸出中id=N的那行關聯</p><p>13 outer_tables semi join (inner_tables)</p><p>半連接操作。inner_tables展示未拉出的表。詳見 “Optimizing Subqueries, Derived Tables, and View References with Semijoin Transformations”</p><p>14 &lt;temporary table></p><p>表示創建了內部臨時表而緩存中間結果</p><p>當某些表是const或system類型時，這些表中的列所涉及的表達式將由優化器儘早評估，並且不屬於所顯示語句的一部分。但是，當使用FORMAT=JSON時，某些const表的訪問將顯示為ref。</p><h2 class=pgc-h-arrow-right>估計查詢性能</h2><p>多數情況下，你可以通過計算磁盤的搜索次數來估算查詢性能。對於比較小的表，通常可以在一次磁盤搜索中找到行（因為索引可能已經被緩存了），而對於更大的表，你可以使用B-tree索引進行估算：你需要進行多少次查找才能找到行：log(row_count) / log(index_block_length / 3 * 2 / (index_length + data_pointer_length)) + 1</p><p>在MySQL中，index_block_length通常是1024字節，數據指針一般是4字節。比方說，有一個500,000的表，key是3字節，那麼根據計算公式 log(500,000)/log(1024/3*2/(3+4)) + 1 = 4 次搜索。</p><p>該索引將需要500,000 * 7 * 3/2 = 5.2MB的存儲空間（假設典型的索引緩存的填充率是2/3），因此你可以在內存中存放更多索引，可能只要一到兩個調用就可以找到想要的行了。</p><p>但是，對於寫操作，你需要四個搜索請求來查找在何處放置新的索引值，然後通常需要2次搜索來更新索引並寫入行。</p><p>前面的討論並不意味著你的應用性能會因為log N而緩慢下降。只要內容被OS或MySQL服務器緩存，隨著表的變大，只會稍微變慢。在數據量變得太大而無法緩存後，將會變慢很多，直到你的應用程序受到磁盤搜索約束（按照log N增長）。為了避免這種情況，可以根據數據的增長而增加key的。對於MyISAM表，key的緩存大小由名為key_buffer_size的系統變量控制，詳見 Section 5.1.1, “Configuring the Server”</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>全網</a></li><li><a>MySQL</a></li><li><a>EXPLAIN</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html alt="圖解MySQL | 「原理解析」 MySQL組提交(group commit)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e5444e9094614d6b88bd3fc8ac0524fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html title="圖解MySQL | 「原理解析」 MySQL組提交(group commit)">圖解MySQL | 「原理解析」 MySQL組提交(group commit)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html alt=MySQL系列-第14篇：事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html title=MySQL系列-第14篇：事務詳解>MySQL系列-第14篇：事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html alt=MySQL進階之InnoDB事務原子性實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e1d208ac-c0ed-4238-bce5-e4b3760228c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html title=MySQL進階之InnoDB事務原子性實現原理>MySQL進階之InnoDB事務原子性實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html alt=全網流行的像素風插畫怎麼做？看這篇教程就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c6a523bb05004ed59ac7080c46f41e10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html title=全網流行的像素風插畫怎麼做？看這篇教程就夠了>全網流行的像素風插畫怎麼做？看這篇教程就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html alt="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html title="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務">技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html alt=深入學習MySQL事務：ACID特性的實現原理「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cdc702d66d6943499997d11e931425eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html title=深入學習MySQL事務：ACID特性的實現原理「轉」>深入學習MySQL事務：ACID特性的實現原理「轉」</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>