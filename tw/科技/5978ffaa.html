<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Google官方MVP+Dagger2架構詳解 | 极客快訊</title><meta property="og:title" content="Google官方MVP+Dagger2架構詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d46de2bbbe8a4c669aab49adf79e1104"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5978ffaa.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5978ffaa.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5978ffaa.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5978ffaa.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5978ffaa.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5978ffaa.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5978ffaa.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5978ffaa.html><meta property="article:published_time" content="2020-10-29T21:12:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:37+08:00"><meta name=Keywords content><meta name=description content="Google官方MVP+Dagger2架構詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5978ffaa.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Google官方MVP+Dagger2架構詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1 前言</h1><p>前段時間分享了一篇文章：<strong>google官方架構MVP解析與實戰</strong> ，針對這是對google官方示例架構（googlesamples/<strong>android-architecture</strong>）的一個分支todo-mvp/ 的項目解析與實際運用</p><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d46de2bbbe8a4c669aab49adf79e1104><p class=pgc-img-caption></p></div><p>google官方示例架構項目</p><p><br></p><p>在我的前一篇文章分享的時候，當時todo-mvp-dagger/ 這個分支也還沒有開發完畢。最近的項目中也在用到Dagger2 作為依賴注入，所以通過這個項目一起來學習下，mvp+Dagger2 的實現吧。</p><h1 class=pgc-h-arrow-right>2 Dagger2基礎</h1><blockquote><p>以下Dagger2基礎部分主要是對參考資料裡面的幾篇外文鏈接的知識點的整合，所以翻譯的語句可能有些生硬，在適當的地方會出現英文原文。 原文章鏈接（70%來自於下面的原文，做出了適當修改）： Dependency Injection with Dagger 2</p></blockquote><h3 class=pgc-h-arrow-right>2.1 什麼是Dagger2</h3><p>面向對象編程經常需要處理各種依賴關係。安卓開發也不例外，比如說網絡訪問中使用Retrofit，Gson，本地存儲中使用shared preference。無一例外，我們都都需要在使用它們的地方進行實例對象構建，對象之間可能還存在著各種各樣的依賴關係。</p><p>依賴注入（Dependency Injection，簡稱DI）是用於削減計算機程序的耦合問題的一個法則。對象在被創建的時候，由一個調控系統內所有對象的外界實體將其所依賴的對象的引用傳遞給它。也可以說，依賴被注入到對象中。</p><p>在J2EE後臺開發中，當前比較知名的依賴注入框架有：Pico Container、Avalon 、Spring、JBoss、HiveMind、EJB等。</p><p>Dagger2 （A fast dependency injector for Android and Java. http://google.github.io/dagger）正是一個安卓和Java的依賴注入框架，使用代碼自動生成創建依賴關係需要的代碼。減少很多模板化的代碼，更易於測試，降低耦合，創建可複用可互換的模塊。</p><h3 class=pgc-h-arrow-right>2.2 Dagger2的優點</h3><ul><li><strong>全局對象實例的簡單訪問方式</strong><br>和ButterKnife 庫定義了view，事件處理以及資源的引用一樣，Dagger2 提供全局對象引用的簡易訪問方式。聲明瞭單例的實例都可以使用@inject進行訪問。比如下面的MyTwitterApiClient 和SharedPreferences 的實例：</li></ul><pre><code>public class MainActivity extends Activity {   @Inject MyTwitterApiClient mTwitterApiClient;   @Inject SharedPreferences sharedPreferences;   public void onCreate(Bundle savedInstance) {       // assign singleton instances to fields       InjectorClass.inject(this);   } </code></pre><ul><li><strong>複雜的依賴關係只需要簡單的配置</strong><br>Dagger2 會通過依賴關係並且生成易懂易分析的代碼。以前通過手寫的大量模板代碼中的對象引用將會由它給你創建並傳遞到相應對象中。因此你可以更多的關注模塊中構建的內容而不是模塊中的對象實例的創建順序。</li><li><strong>讓單元測試和集成測試更加方便</strong><br>因為依賴關係已經為我們獨立出來，所以我們可以輕鬆的抽取出不同的模塊進行測試。依賴的注入和配置獨立於組件之外。因為對象是在一個獨立、不耦合的地方初始化，所以當注入抽象方法的時候，我們只需要修改對象的實現方法，而不用大改代碼庫。依賴可以注入到一個組件中：我們可以注入這些依賴的模擬實現，這樣使得測試更加簡單。</li><li><strong>作用域實例（Scoped instances）</strong><br>我們不僅可以輕鬆的管理全局實例對象，也可以使用Dagger2中的scope定義不同的作用域。（比如根據user session，activity的生命週期）</li></ul><h3 class=pgc-h-arrow-right>2.3 Dagger2的引用</h3><ul><li>在整個項目的build.gradle中加入：</li></ul><pre><code> dependencies {     // other classpath definitions here     classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' }</code></pre><ul><li>在app/build.gradle中分別加入：</li></ul><pre><code>// add after applying plugin: 'com.android.application'  apply plugin: 'com.neenbedankt.android-apt'</code></pre><pre><code>dependencies {    // apt command comes from the android-apt plugin    apt 'com.google.dagger:dagger-compiler:2.2'    compile 'com.google.dagger:dagger:2.2'    provided 'javax.annotation:jsr250-api:1.0'}</code></pre><blockquote><p>需要注意的是provided代表編譯時需要的依賴，Dagger的編譯器生成依賴關係的代碼，並在編譯時添加到IDE 的class path中，只參與編譯，並不會打包到最終的apk中。apt是由android-apt插件提供，它並不會添加這些類到class path中，這些類只用於註解解析，編寫代碼的時候應當避免使用這些類。</p></blockquote><h3 class=pgc-h-arrow-right>2.4 Dagger2的使用，依賴注入流程</h3><p>Dagger2 中使用了很多註解，接下來一步一步的分析Dagger2的使用，先來一張表和一張圖把Dagger2中的註解講解一下。如果有點不清晰，請接著往下看，然後再回來看一遍。</p><p>註解 用法 @Module Modules類裡面的方法專門提供依賴，所以我們定義一個類，用@Module註解，這樣Dagger在構造類的實例的時候，就知道從哪裡去找到需要的 依賴。modules的一個重要特徵是它們設計為分區並組合在一起（比如說，在我們的app中可以有多個組成在一起的modules) @Provide 在modules中，我們定義的方法是用這個註解，以此來告訴Dagger我們想要構造對象並提供這些依賴。 @Singleton 當前提供的對象將是單例模式 ,一般配合@Provides一起出現 @Component 用於接口，這個接口被Dagger2用於生成用於模塊注入的代碼 @Inject 在需要依賴的地方使用這個註解。（你用它告訴Dagger這個 構造方法，成員變量或者函數方法需要依賴注入。這樣，Dagger就會構造一個這個類的實例並滿足他們的依賴。） @Scope Scopes可是非常的有用，Dagger2可以通過自定義註解限定註解作用域。</p><p><strong>沒看懂？接著往下看</strong></p><p>看看Dagger2 的流程：</p><p><br></p><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/90971247a2bc4fb890359232d7e66547><p class=pgc-img-caption></p></div><p>Dagger2 流程</p><p>首先看看下面這段代碼，我們需要使用Okhttp，Retrofit和Gson做一個Twitter 客戶端的網絡訪問，如果我們需要在onCreate中加載，我們可能會這樣初始化。</p><pre><code>public class MainActivity extends Activity {OkHttpClient client = new OkHttpClient();// Enable caching for OkHttpint cacheSize = 10 * 1024 * 1024; // 10 MiBCache cache = new Cache(getApplication().getCacheDir(), cacheSize);client.setCache(cache);// Used for caching authentication tokensSharedPreferences sharedPrefeences = PreferenceManager.getDefaultSharedPreferences(this);// Instantiate GsonGson gson = new GsonBuilder().create();GsonConverterFactory converterFactory = GsonConverterFactory.create(Gson);// Build RetrofitRetrofit retrofit = new Retrofit.Builder()                                .baseUrl("https://api.github.com")                                .addConverterFactory(converterFactory)                                .client(client)  // custom client                                .build();public void onCreate(Bundle savedInstance) {    retrofit.xxx();    sharedPrefeences.xxx();    gson.xxx() } } </code></pre><p><strong>如果我們使用Dagger2完成上述過程呢？</strong></p><p>首先我們要創建幾個Dagger模塊（Module），我們的第一個Dagger模塊（Module）AppModule.java(使用@Module進行類註解)，將會提供Application 的context引用。我們使用@Provides註解告訴Dagger providesApplication()這個方法是Application的實例的提供者。使用@Singleton註解告訴Dagger整個生命週期中只會被初始化一次。</p><pre><code>@Modulepublic class AppModule {    Application mApplication;    public AppModule(Application application) {        mApplication = application;    }    @Provides    @Singleton    Application providesApplication() {        return mApplication;    }}</code></pre><p>和上面類似構建第二個模塊（Module），下面這段代碼我們進行了Gson，Cache，OkHttpClient以及Retrofit 的實例化，這些方法的返回類型都會在定義到<strong>依賴關係（依賴表 dependency graph）</strong>中。在這裡我們需要關注的是三個註解的@Module,@Provides,@Singleton的定義位置。</p><pre><code>@Modulepublic class NetModule {    String mBaseUrl;    // Constructor needs one parameter to instantiate.      public NetModule(String baseUrl) {        this.mBaseUrl = baseUrl;    }    // Dagger will only look for methods annotated with @Provides    @Provides    @Singleton    // Application reference must come from AppModule.class    SharedPreferences providesSharedPreferences(Application application) {        return PreferenceManager.getDefaultSharedPreferences(application);    }    @Provides    @Singleton    Cache provideOkHttpCache(Application application) {         int cacheSize = 10 * 1024 * 1024; // 10 MiB        Cache cache = new Cache(application.getCacheDir(), cacheSize);        return cache;    }   @Provides    @Singleton   Gson provideGson() {         GsonBuilder gsonBuilder = new GsonBuilder();       gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);       return gsonBuilder.create();   }   @Provides   @Singleton   OkHttpClient provideOkHttpClient(Cache cache) {      OkHttpClient client = new OkHttpClient();      client.setCache(cache);      return client;   }   @Provides   @Singleton   Retrofit provideRetrofit(Gson gson, OkHttpClient okHttpClient) {      Retrofit retrofit = new Retrofit.Builder()                .addConverterFactory(GsonConverterFactory.create(gson))                .baseUrl(mBaseUrl)                .client(okHttpClient)                .build();        return retrofit;    }}</code></pre><p>可以看到我們通過@Module標註類，@Provide和@Singleton標註方法完成了這些對象實例的創建。那麼我們怎麼獲取這些對象實例呢？</p><p>Dagger2通過@inject註解提供了實例的獲取,通過調用@inject會讓Dagger2 在<strong>依賴關係（依賴表 dependency graph）</strong>中找到對應的實例對象並賦值給該字段。比如下面的例子就會返回MyTwitterApiClient,SharedPreferences的實例對象。</p><pre><code>public class MainActivity extends Activity {   @Inject MyTwitterApiClient mTwitterApiClient;   @Inject SharedPreferences sharedPreferences;  public void onCreate(Bundle savedInstance) {       // assign singleton instances to fields       InjectorClass.inject(this);   } </code></pre><p>上面的Module類都會需要一個context，有的時候是Activity context，有的時候是Application context，所以上面完成了提供 和使用實例 。</p><p>可以看到上面通過InjectorClass.inject(this)把當前activity對象注入到InjectorClass，那麼InjectorClass是什麼呢?正是這個關聯過程。</p><p>在Dagger2 中 ，注入類（injector class）被稱作組件（Component），我們通過inject方法傳遞activity，service或者fragment對象到注入類component中。比如下面這個類。我們通過@Component註解當前類，並且把之前的兩個模塊AppModule.class, NetModule.class也添加到component中。（<strong>Components從根本上來說就是一個注入器，也可以說是@Inject和@Module的橋樑。</strong>）</p><pre><code>@Singleton@Component(modules={AppModule.class, NetModule.class})public interface NetComponent {   void inject(MainActivity activity);   // void inject(MyFragment fragment);   // void inject(MyService service);}</code></pre><p>到這裡我們就把Dagger2 的大致流程梳理了一遍。</p><blockquote><p>提供（@Module）&lt;->關聯（@Component）&lt;->使用（@Inject）</p></blockquote><blockquote><p>依賴注入，這讓我想起了小時候最怕的打針。就好像打針過程一樣，我們有了藥物（提供的實例），你的身體生病了需要藥物（使用這個實例），我們需要注射器把藥物注入你的身體裡面。（關聯這個實例） 那麼你就會好奇這個註解類是怎麼完成整個注入的呢？(也就是說這個關聯過程)</p></blockquote><p>Dagger2中很重要的一點就是它會為@Component註解的類生成代碼。它會在類的前面添加上Dagger前綴（比如上面的類就會生成DaggerNetComponent .java）,也就是這個類負責初始化<strong>依賴關係（依賴表 dependency graph）</strong>中的實例，併為註解了@Inject 的字段執行注入操作。接著往下看。</p><h3 class=pgc-h-arrow-right>2.5 初始化組件（Instantiating the component）</h3><p>初始化組件操作應當在Application中進行操作，因為這些實例在整個application生命週期中只會被實例化一次。</p><pre><code>public class MyApp extends Application {    private NetComponent mNetComponent;    @Override    public void onCreate() {        super.onCreate();        // Dagger%COMPONENT_NAME%        mNetComponent = DaggerNetComponent.builder()                // list of modules that are part of this component need to be created here too                .appModule(new AppModule(this)) // This also corresponds to the name of your module: %component_name%Module                .netModule(new NetModule("https://api.github.com"))                .build();        // If a Dagger 2 component does not have any constructor arguments for any of its modules,        // then we can use .create() as a shortcut instead:        //  mAppComponent = com.codepath.dagger.components.DaggerNetComponent.create();    }    public NetComponent getNetComponent() {       return mNetComponent;    }}</code></pre><p>可以看到的是我們直接使用NetComponent生成的類DaggerNetComponent並且生成的方法appModule和netModule完成了兩個對應module的初始化。</p><blockquote><p>因為這裡我們繼承了Application並作出了修改，所以需要在AndroidManifest.xml中作出修改如下。</p></blockquote><pre><code>&lt;application      android:allowBackup="true"      android:name=".MyApp"&gt;</code></pre><p>在activity中，我們需要獲取component並且調用inject()方法。注意需要將獲取的Application強制轉換為MyApp。這也完成了上面InjectorClass.inject(this);代碼的替換。</p><pre><code>public class MyActivity extends Activity {  @Inject OkHttpClient mOkHttpClient;  @Inject SharedPreferences sharedPreferences;  public void onCreate(Bundle savedInstance) {        // assign singleton instances to fields        // We need to cast to `MyApp` in order to get the right method        ((MyApp) getApplication()).getNetComponent().inject(this);    } </code></pre><blockquote><p>到這裡就完成了整個Dagger2的依賴注入流程.</p></blockquote><h4 class=pgc-h-arrow-right>Dagger2的使用還有一些注意點。下面進行講解。包括下面的限定類型，作用域，組建依賴，以及子組件。</h4><h3 class=pgc-h-arrow-right>2.6 限定類型（Qualified types）</h3><p><br></p><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e9ed79a0b06f46069aa3dd5d95f83081><p class=pgc-img-caption></p></div><p>Dagger 修飾符</p><p><br>如果對於不同的對象有同樣的返回類型，我們可以使用@Named修飾符註解。你需要在提供單例的地方(@Provides註解)和注入的地方（@Inject註解）都使用@Named註解。<br>比如，對於同樣的返回OkHttpClient ，這裡提供不同的方法，和java中多態一樣，只不過這裡需要額外通過@Named註解來標註：</p><p><br></p><pre><code>@Provides @Named("cached")@SingletonOkHttpClient provideOkHttpClient(Cache cache) {    OkHttpClient client = new OkHttpClient();    client.setCache(cache);    return client;}@Provides @Named("non_cached") @SingletonOkHttpClient provideOkHttpClient() {    OkHttpClient client = new OkHttpClient();    return client;}</code></pre><pre><code>@Inject @Named("cached") OkHttpClient client;@Inject @Named("non_cached") OkHttpClient client2;</code></pre><p>如下，@Named是在Dagger中預先定義好的修飾符，你也可以創建自己的修飾符註解。關於自定義註解，我之前的一篇文章【譯】從java註解分析ButterKnife工作流程有所提及。</p><pre><code>@Qualifier@Documented@Retention(RUNTIME)public @interface DefaultPreferences {}</code></pre><h3 class=pgc-h-arrow-right>2.7 作用域（Scopes）</h3><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/110d321a3ccd446d91328d25f57018a1><p class=pgc-img-caption></p></div><p>dagger 作用域</p><p>Scopes可是非常的有用，Dagger2可以通過自定義註解限定註解作用域。@Singleton是被Dagger預先定義的作用域註解（ scope annotation ）。沒有指定作用域的@Provides方法將會在每次注入的時候都創建新的對象。同樣的，你也可以定義自己的Scope註解。</p><pre><code>@Scope@Documented@Retention(value=RUNTIME)public @interface MyActivityScope</code></pre><blockquote><p>你可以在官方文檔中找到這樣一段文字</p></blockquote><pre><code>/** * In Dagger, an unscoped component cannot depend on a scoped component. As * {@link edu.com.app.injection.component.ApplicationComponent} is a scoped component ({@code @Singleton}, we create a custom * scope to be used by all fragment components. Additionally, a component with a specific scope * cannot have a sub component with the same scope. */</code></pre><p>也就是說一個沒有scope的組件component不可以以來一個有scope的組件component。子組件和父組件的scope不能相同。我們通常的ApplicationComponent都會使用Singleton註解，也就會是說我們如果自定義component必須有自己的scope。在下面組件依賴中會再次提及。</p><h3 class=pgc-h-arrow-right>2.8 組件依賴（Component Dependencies）</h3><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/41f2ae070e8540b0b0e9095742cb2a17><p class=pgc-img-caption></p></div><p>dagger 依賴</p><p><br></p><p>上面的例子我們創建了application的全局單例.如果我們想在內存中總是擁有多個組件（例如在activity和fragment生命週期，用戶登錄註冊創建的component），我們可以使用組件依賴（Component Dependencies），使用組件依賴有下面幾個考慮點：</p><ul><li>兩個依賴的組件不能共享作用域，比如兩個組件不能共享@Singleton作用域。這個限制產生的原因看這裡。依賴的組件需要定義自己的作用域。</li><li>儘管Dagger2 有創建作用域實例的能力，你也需要創建和刪除引用來滿足行為的一致性。Dagger2 不會知道任何底層的實現。可以看看Stack Overflow 的這個 討論</li><li>當創建依賴組件的時候，父組件需要顯示的暴露對象給子組件。比如子組件需要知道Retrofit 對象，也就需要顯示的暴露出來。</li></ul><pre><code>@Singleton@Component(modules={AppModule.class, NetModule.class})public interface NetComponent {//依賴於當前component的component會得到Retrofit實例，這裡的方法名不固定    Retrofit retrofit();}</code></pre><p>這裡參考我自己項目的ActivityComponent，依賴於ApplicationComponent，所以這裡我們會自定義ScopePerActivity。也可以看到的是@ActivityContext會在component和module中得到使用。參考下面三段代碼。</p><pre><code>@PerActivity@Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)public interface ActivityComponent {    void inject(MainActivity mainActivity);  //......    void inject(SettingsFragment settingsFragment);}</code></pre><pre><code>@Documented@Scope@Retention(RetentionPolicy.RUNTIME)public @interface PerActivity {}</code></pre><pre><code>@Modulepublic class ActivityModule {    private Activity mActivity;    public ActivityModule(Activity activity) {        mActivity = activity;    }    @Provides    Activity provideActivity() {        return mActivity;    }    @Provides    @ActivityContext    Context providesContext() {        return mActivity;    }}</code></pre><h3 class=pgc-h-arrow-right>2.9 子組件（Subcomponents）</h3><p><br></p><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/245b1dd07c014b649cd028e0a9d557fd><p class=pgc-img-caption></p></div><p>dagger 子組件</p><p><br>除了依賴關係，也可以使用子組件進行<strong>對象關係（對象表/圖 object graph）</strong>繼承。和組件之間添加依賴關係一樣，子組件也有自己的生命週期，也會在所有對其應用不在的時候被垃圾回收，也有同樣的作用域限制。區別於組件依賴的不同點主要是：</p><p><br></p><ul><li>需要在父組件的接口中聲明（在接口中定義的方法對於生成的對象是可訪問的。）。</li><li>能夠獲取父組件的所有元素（不僅僅是在接口中聲明的元素）。<br>比如下面這段代碼：</li></ul><pre><code>@Modulepublic class MyActivityModule {    private final MyActivity activity;    public MyActivityModule(MyActivity activity) { this.activity = activity; }    @Provides @MyActivityScope @Named("my_list")    public ArrayAdapter providesMyListAdapter() {        return new ArrayAdapter&lt;String&gt;(activity, android.R.layout.my_list);    }    ...}@MyActivityScope@Subcomponent(modules={ MyActivityModule.class })public interface MyActivitySubComponent {    @Named("my_list") ArrayAdapter myListAdapter();}@Singleton@Component(modules={ ... })public interface MyApplicationComponent {    MyActivitySubComponent newMyActivitySubcomponent(MyActivityModule activityModule);}</code></pre><p>在上面的例子中，子組件的實例在每次我們調用newMyActivitySubcomponent()的時候都會被創建。使用子模塊去注入一個activity：</p><pre><code>public class MyActivity extends Activity {  @Inject ArrayAdapter arrayAdapter;  public void onCreate(Bundle savedInstance) {        // assign singleton instances to fields        // We need to cast to `MyApp` in order to get the right method        ((MyApp) getApplication()).getApplicationComponent())            .newMyActivitySubcomponent(new MyActivityModule(this))            .inject(this);    } }</code></pre><blockquote><p>最後再來梳理一下Dagger2 中的一些注意點：</p></blockquote><ul><li>Components從根本上來說就是一個注入器，也可以說是@Inject和@Module的橋樑。 Components可以提供所有定義了的類型的實例，比如：我們必須用@Component註解一個接口然後列出所有的@Modules組成該組件，如 果缺失了任何一塊都會在編譯的時候報錯。@Component接口定義了對象提供者（module）和對象之間的聯繫，也表述了一種依賴關係。</li><li>由於Dagger2使用生成的代碼去訪問字段，所以字段使用了Dagger2 是不允許標註為private的。</li><li>Dagger2 基於JSR 330（為了最大程度的提高代碼的複用性、測試性和維護性，java的依賴注入為注入類中的使用定義了一整套註解（和接口）標準。Dagger1和Dagger2（還有Guice）都是基於這套標準，給程序帶來了穩定性和標準的依賴注入方法。）</li><li>使用@inject註解表示依賴關係可以用於三個地方。構造函數，字段或者方法中）。</li><li>Dagger2會在編譯時通過apt生成代碼進行注入。</li></ul><p>以後的開發中，那麼多需要使用實例的地方，只需要簡簡單單地來一個@inject，而不需要關心是如何注入的。Dagger2讓你愛不釋手。 那麼接下來我們分析官方架構Dagger2 又是怎麼使用的吧？</p><hr><h1 class=pgc-h-arrow-right>3 google官方MVP架構回顧</h1><p><br></p><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d9ff10e0e7f45818079dde365a89bbc><p class=pgc-img-caption></p></div><p><br>上一篇文章<strong>google官方架構MVP解析與實戰</strong> 中，我們分析到整個項目是按照功能模塊進行劃分（addedittask，statistics，taskdetail，tasks四個模塊）並且將數據和工具類分別提取到data和util包中。我們對taskdetial模塊進行了分析。這裡提取上一篇文章中的結論</p><p><br></p><blockquote><p><strong>3.1</strong> 官方MVP實例，通過協議類XXXContract來對View和Presenter的接口進行內部繼承。是對BaseView和BasePresenter的進一步封裝，所以我們實現的View和Presenter也只需要繼承XXXContract中的對應內部接口就行。這也是一個非常不錯的方式管理MVP中的view和presenter。(侷限在於XXXContract 以接口的形式進行提供，所以它的內部類view和presenter都不能做一些公共初始化操作，只能以接口形式提供給子類實現。)</p><p><br></p></blockquote><blockquote><p><strong>3.2</strong> activity的作用主要是創建MVP中View（這裡是相應的fragment），以及創建presenter，並把view和presenter綁定。（在實際開發中可以靈活運用，activity，fragment以及自定義view都可以作為MVP中的view使用。）</p><p><br></p></blockquote><blockquote><p><strong>3.3</strong> 在presenter的實現類的構造函數中，通過view的setPresenter，讓view獲得了presenter實例。這樣view中就可以對Presenter中的方法進行操作了。</p><p><br></p></blockquote><blockquote><p><strong>3.4</strong> 在presenter的實現類中，可以對Model數據(這裡的TaskRespository)進行操作。實例中，數據的獲取、存儲、數據狀態變化都是model層的任務，presenter會根據需要調用該層的數據處理邏輯並在需要時將回調傳入。這樣model、presenter、view都只處理各自的任務，此種實現確實是單一職責最好的詮釋。</p><p><br></p></blockquote><hr><h1 class=pgc-h-arrow-right>4 Google官方架構MVP+Dagger2架構詳解</h1><h3 class=pgc-h-arrow-right>4.1 對比</h3><p>這裡我們接著MVP項目講解MVP+Dagger2項目，也是對taskdetial模塊做出分析。</p><p><br></p><div class=pgc-img><img alt=Google官方MVP+Dagger2架構詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe544df3ddd04fc2a4f17e16709deaed><p class=pgc-img-caption></p></div><p>通過上圖我們可以看到，這裡添加了四個個類文件，分別是全局的ApplicationModule和ToDoApplication。以及對應XXX模塊中的XXXComponent和XXXPresenterModule。其他模塊也類似。</p><h3 class=pgc-h-arrow-right>4.2 分析</h3><ul><li>首先看看ToDoApplication,提供了TasksRepositoryComponent的初始化。</li></ul><pre><code>public class ToDoApplication extends Application {    private TasksRepositoryComponent mRepositoryComponent;    @Override    public void onCreate() {        super.onCreate();        mRepositoryComponent = DaggerTasksRepositoryComponent.builder()                .applicationModule(new ApplicationModule((getApplicationContext())))                .tasksRepositoryModule(new TasksRepositoryModule()).build();    }    public TasksRepositoryComponent getTasksRepositoryComponent() {        return mRepositoryComponent;    }}</code></pre><p>DaggerTasksRepositoryComponent 是由Dagger2生成的代碼。我們通過它來初始化TasksRepositoryComponent。並且可以看到的是ApplicationModule和TasksRepositoryModule也在這裡進行了一次性初始化。TasksRepository需要說明的是整個數據model層的核心。</p><ul><li>來看看ApplicationModule</li></ul><pre><code>@Modulepublic final class ApplicationModule {    private final Context mContext;    ApplicationModule(Context context) {        mContext = context;    }    @Provides    Context provideContext() {        return mContext;    }}</code></pre><p>可以看到的是這裡需要的是一個application context 的實例，也就是我們在上面ToDoApplication的onCreate中初始化的時候傳入的getApplicationContext()。它最終會提供一個通過provideContext()方法提供一個Context實例。</p><ul><li>來看看TasksRepositoryModule</li></ul><pre><code>@Modulepublic class TasksRepositoryModule {    @Singleton    @Provides    @Local    TasksDataSource provideTasksLocalDataSource(Context context) {        return new TasksLocalDataSource(context);    }    @Singleton    @Provides    @Remote    TasksDataSource provideTasksRemoteDataSource() {        return new FakeTasksRemoteDataSource();    }}</code></pre><p>這是用於mock測試的一個類，裡面的兩個方法分別表示本地數據和遠程數據，最終返回的都是TasksDataSource。mock測試就是在測試過程中，對於某些不容易構造或者不容易獲取的對象，用一個虛擬的對象來創建以便測試的測試方法。這裡對於數據對象直接在這裡進行初始化，而不是在所有的用到該數據的地方new一遍。這也就體現了Dagger2的引入對測試是一個極大的便利。</p><ul><li>現在回到整個應用的核心TasksRepositoryComponent,也就是在ToDoApplication中初始化的核心類。</li></ul><pre><code>@Singleton@Component(modules = {TasksRepositoryModule.class, ApplicationModule.class})public interface TasksRepositoryComponent {    TasksRepository getTasksRepository();}</code></pre><p>可以看到這裡Dagger2允許我們為Component使用@Singleton來保持單例模式，但是我們在ToDoApplication也再次進行了單例創建，這是必要的一步。同時這裡定義的TasksRepositoryModule.class和ApplicationModule.class 也是在ToDoApplication進行初始化創建的。 都說Component就是一個注入器，也可以說是@Inject和@Module的橋樑。 那麼鏈接了@Module，我們看看是如何鏈接@Inject的吧？</p><ul><li>現在進入對應模塊taskdetail模塊，首先看看TaskDetailComponent.</li></ul><pre><code>@FragmentScoped@Component(dependencies = TasksRepositoryComponent.class, modules = TaskDetailPresenterModule.class)public interface TaskDetailComponent {        void inject(TaskDetailActivity taskDetailActivity);}</code></pre><pre><code>@Documented@Scope@Retention(RetentionPolicy.RUNTIME)public @interface FragmentScoped {}</code></pre><p>這也就是我們提供注入inject方法的地方。從註解中可以看到依賴於TasksRepositoryComponent.class所以其中的TaskRespository對於當前component是可用的。</p><blockquote><p>需要注意的是在Dagger中，一個沒有作用域（unscoped ）的組件不可以依賴有作用域的組件。比如這裡的TasksRepositoryComponent作用域為@Singleton。所以我們在這裡自定義了一個由所有fragment使用的FragmentScoped。另外，組件有確定作用域，那麼依賴它的組件不能有相同的作用域。</p></blockquote><ul><li>接下來看看TaskDetailComponent中定義的模塊TaskDetailPresenterModule.class</li></ul><pre><code>@Modulepublic class TaskDetailPresenterModule {    private final TaskDetailContract.View mView;    private final String mTaskId;    public TaskDetailPresenterModule(TaskDetailContract.View view, String taskId) {        mView = view;        mTaskId = taskId;    }    @Provides    TaskDetailContract.View provideTaskDetailContractView() {        return mView;    }    @Provides    String provideTaskId() {        return mTaskId;    }}</code></pre><p>主要是提供MVP中相應模塊的View的返回，這在上面一節中提到過，所以可以看到返回類型是TaskDetailContract.View 。也是在這裡完成MVP模式中重要的一環，也就是Presenter和View的實例的獲取，不然Presenter怎麼告訴View怎麼更新View呢！</p><ul><li>接下來看看Presenter的創建。在上一節中我們就知道了Presenter由TaskDetailActivity進行創建。實際上的MVP中的View是TaskDetailFragment。因為這裡是通過view.setPresenter方式完成presenter和view的鏈接。所以這裡不再贅述View中的細節。</li></ul><pre><code>public class TaskDetailActivity extends AppCompatActivity {    @Inject TaskDetailPresenter mTaskDetailPresenter;    @Override    protected void onCreate(Bundle savedInstanceState) {       ......        if (taskDetailFragment == null) {            taskDetailFragment = TaskDetailFragment.newInstance(taskId);            ActivityUtils.addFragmentToActivity(getSupportFragmentManager(),                    taskDetailFragment, R.id.contentFrame);        }        // Create the presenter        DaggerTaskDetailComponent.builder()                .taskDetailPresenterModule(new TaskDetailPresenterModule(taskDetailFragment, taskId))                .tasksRepositoryComponent(((ToDoApplication) getApplication())                .getTasksRepositoryComponent()).build()                .inject(this);    }......}</code></pre><ul><li>看看TaskDetailPresenter</li></ul><pre><code>final class TaskDetailPresenter implements TaskDetailContract.Presenter {    private TasksRepository mTasksRepository;//Model    private TaskDetailContract.View mTaskDetailView;//View    /**     * Dagger strictly enforces that arguments not marked with {@code @Nullable} are not injected     * with {@code @Nullable} values.     */    @Nullable String mTaskId;    /**     * Dagger strictly enforces that arguments not marked with {@code @Nullable} are not injected     * with {@code @Nullable} values.     */    @Inject    TaskDetailPresenter(@Nullable String taskId,            TasksRepository tasksRepository,            TaskDetailContract.View taskDetailView) {        mTasksRepository = tasksRepository;        mTaskDetailView = taskDetailView;        mTaskId = taskId;    }    /**     * Method injection is used here to safely reference {@code this} after the object is created.     * For more information, see Java Concurrency in Practice.     */    @Inject    void setupListeners() {        mTaskDetailView.setPresenter(this);    }...Presenter中的操作...}</code></pre><p>除了Presenter中的操作，這裡主要就是有一個@inject標註的方法，構造函數，還有字段。到這裡也就完成了MVP中Dagger2 的使用 。還在等什麼？趕快將它用到你的項目中吧！</p><hr><h1 class=pgc-h-arrow-right>5 Dagger2添加步驟：</h1><p>這裡再次總結一下Dagger2添加步驟。</p><ul><li>step 1：添加android-apt, dagger 2, dagger2-compiler以及javax annotation到build.gradle.(注意他們不都是compile的形式)</li><li>step 2：添加模塊（module）,ApplicationModule將會注入Application Context 到需要的類中。</li><li>step 3：添加組件Component, Dagger2 將會為你創建的所有component生成代碼。使用文件名Dagger（Component）的形式。Component可以擁有多個module。（比如DaggerTaskDetailComponent擁有TaskDetailPresenterModule模塊）</li><li>step 4: 繼承android.app.Application類，並且在AndroidManifest.xml中聲明使用的application類。在它的onCreate()方法中構建主要組件（main component）</li></ul><pre><code>       mRepositoryComponent = DaggerTasksRepositoryComponent.builder()                .applicationModule(new ApplicationModule((getApplicationContext())))                .tasksRepositoryModule(new TasksRepositoryModule()).build();</code></pre><ul><li>step 5: 添加註入方法（inject）到Component 接口中，你需要為每一個參與到依賴注入的類添加inject()方法。(注意在dagger2中：為父類注入的依賴並不會為子類注入依賴關係，為子類注入的依賴關係則可以為父類注入依賴關係)參考上面的TaskDetailPresenter方法。</li><li>step 6: 注入依賴，用inject，替換你新建對象實例的地方。把這些新建實例的地方移到Modules中並且添加@Provides標註。可以參考上面的 ApplicationModule.java,在使用@Inject，請確保調用Component.inject()方法。可以參考上面的TaskDetailActivity.</li><li>step 7: (可選，推薦)將getApplicationComponent()移到父類中（一般是指BaseActivity）</li></ul><p>實踐出真知，還是希望你可以親手寫寫，然後再回過頭來看這篇文章。</p><p><br>關注小編不迷路，後續還會更新更多精彩內容哦</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Google</a></li><li><a>MVP</a></li><li><a>Dagger2</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/48af3dac.html alt="Google Docs可在文本編輯模式下實時統計已輸入字數了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RbeYEyZD0kyYtf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48af3dac.html title="Google Docs可在文本編輯模式下實時統計已輸入字數了">Google Docs可在文本編輯模式下實時統計已輸入字數了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c208a1c5.html alt="Google Assistant的“快照”新增生日提醒和菜譜推薦等功能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S8ukJ4W3GGfnNM style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c208a1c5.html title="Google Assistant的“快照”新增生日提醒和菜譜推薦等功能">Google Assistant的“快照”新增生日提醒和菜譜推薦等功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aae99eac.html alt=“吃雞”玩家晒出MVP戰績“孤獨求敗”？抱歉，已被反饋給光子 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f02e4573584a42278fe0d0f655327c26 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aae99eac.html title=“吃雞”玩家晒出MVP戰績“孤獨求敗”？抱歉，已被反饋給光子>“吃雞”玩家晒出MVP戰績“孤獨求敗”？抱歉，已被反饋給光子</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8ab9576.html alt=Google正在將Android手機變成地震儀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/39fd28d956754ee5832878a2fa038408 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8ab9576.html title=Google正在將Android手機變成地震儀>Google正在將Android手機變成地震儀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6272038d.html alt="如何在Google Ads中設置結構化代碼段擴展" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/140621b1d9d64cac8c095003de160fdf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6272038d.html title="如何在Google Ads中設置結構化代碼段擴展">如何在Google Ads中設置結構化代碼段擴展</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/07d6738b.html alt=Google代碼審查者指南(五)：如何撰寫CR評論 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/07d6738b.html title=Google代碼審查者指南(五)：如何撰寫CR評論>Google代碼審查者指南(五)：如何撰寫CR評論</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/690031e4.html alt=Google代碼審查者指南(六)：處理CR拖延 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/690031e4.html title=Google代碼審查者指南(六)：處理CR拖延>Google代碼審查者指南(六)：處理CR拖延</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/04760a1c.html alt=「世界盃點將·字母哥」新科MVP要當眾星之首 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/214a89ca7e9d422786ed16e46e77be52 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/04760a1c.html title=「世界盃點將·字母哥」新科MVP要當眾星之首>「世界盃點將·字母哥」新科MVP要當眾星之首</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/a6e0fdf4.html alt="對話尼基·帕瑪：在Google Brain工作是一種怎樣的體驗？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3042df995c564a71a2f8397aef525d7a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/a6e0fdf4.html title="對話尼基·帕瑪：在Google Brain工作是一種怎樣的體驗？">對話尼基·帕瑪：在Google Brain工作是一種怎樣的體驗？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/93db9060.html alt=物流聯盟版“王者榮耀”，MVP花落誰家？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15308696479286228322a89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/93db9060.html title=物流聯盟版“王者榮耀”，MVP花落誰家？>物流聯盟版“王者榮耀”，MVP花落誰家？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/623dc459.html alt=如何進行MVP驗證？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/93a7820379584b5dbf55387bfd601ca2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/623dc459.html title=如何進行MVP驗證？>如何進行MVP驗證？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a7a452fc.html alt=App如何構建和驗證MVP（最小可行性產品）？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e395d61ec2ee4c2db11babf4f8430550 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a7a452fc.html title=App如何構建和驗證MVP（最小可行性產品）？>App如何構建和驗證MVP（最小可行性產品）？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ba74998.html alt=使用MVP策略快速驗證我們的產品在市場是否有需求 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c56abd6b15074515869402cf45843565 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ba74998.html title=使用MVP策略快速驗證我們的產品在市場是否有需求>使用MVP策略快速驗證我們的產品在市場是否有需求</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd2c2742.html alt="Google推出更加真實的文本到語音服務由DeepMind AI提供支持" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd2c2742.html title="Google推出更加真實的文本到語音服務由DeepMind AI提供支持">Google推出更加真實的文本到語音服務由DeepMind AI提供支持</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dce5711.html alt=Google協作平臺中出現惡意軟件，用於竊取他人敏感信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/face24f89f3143b99b382ec72374da6f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dce5711.html title=Google協作平臺中出現惡意軟件，用於竊取他人敏感信息>Google協作平臺中出現惡意軟件，用於竊取他人敏感信息</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>