<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「最完整系列」JAVA-容器篇-HashMap面試最詳解 | 极客快訊</title><meta property="og:title" content="「最完整系列」JAVA-容器篇-HashMap面試最詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/71d7c60ccb9e4e57acda3ded903a1fd5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5a4f8a1a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5a4f8a1a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5a4f8a1a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5a4f8a1a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5a4f8a1a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5a4f8a1a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5a4f8a1a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5a4f8a1a.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="「最完整系列」JAVA-容器篇-HashMap面試最詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「最完整系列」JAVA-容器篇-HashMap面試最詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p>在講技術前有必要講一下這篇文章的由來。寫java的朋友，無論是客戶端還是服務端，HashMap基本上都最常用的java容器了，正因為最常用，所以我們需要去了解的更深，對代碼優化和規範都有好處。網上關於 hashmap 的講解也鋪天蓋地多的是，那為什麼我還要寫一篇這個呢。原因主要在於你可以看網上任何的一篇講 hashmap 的文章，遠遠沒有這篇文章帶給你的清晰和完整，甚至可以讓你靠近人家在開發 hashmap 時用到的思維模式。</p><blockquote><p>說明：以下彙總下jdk1.8以及之後版本中的 HashMap 實現。</p></blockquote><h1 class=pgc-h-arrow-right>簡介</h1><p>首先用一句話說明 HashMap 的結構：</p><p>數組+鏈表，即數組中存放的是指向鏈表的指針，當鏈表中數據大於閾值（默認為8），用紅黑樹代替鏈表。</p><p><br></p><div class=pgc-img><img alt=「最完整系列」JAVA-容器篇-HashMap面試最詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/71d7c60ccb9e4e57acda3ded903a1fd5><p class=pgc-img-caption></p></div><p><br></p><p>上面出現了3個結構：數組、鏈表和紅黑樹。那麼下面依次說明各個結構在 HashMap 中的具體應用。</p><h1 class=pgc-h-arrow-right>數組</h1><p>HashMap 中的數組也被叫做哈希桶，本質上是一個 Node 類型的數組。</p><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        ...}</code></pre><p>可以看到 Node 中存放著 key，value 以及一個 hash 值。這個 hash 值的作用就是為了確定指定的 key 存放在數組中的哪個桶，它的具體實現：</p><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>從這個 hash 函數中我們可以看到2點：</p><ol start=1><li>key 允許為null，為 null 時存放在數組的第一個桶（下標為0）中。</li><li>用到了 key 對象的 hashCode 方法獲取對象的 hash 值，然後運用了一些位運算計算下標。</li></ol><p>java 中 int 4個字節，h>>>16 相當於獲取 h 的高位部分，之後的位運算是將 key 的 hashCode 與其高位異或操作，相當於將高位和低位綜合一下，為了減少 hash 碰撞的記錄。最終這個擾動函數計算出來的 hash 值會跟數組長度進行求餘操作來獲取 key 存放的桶下標：</p><pre><code>// &amp; 可以用來取餘，i 就是計算出的數組的下標i = (n-1) &amp; hash</code></pre><blockquote><p>為什麼需要將高低位異或？因為hashCode()是int類型，取值範圍是40多億，只要哈希函數映射的比較均勻鬆散，碰撞機率是很小的。但是由於HashMap的哈希桶的長度遠比hash取值範圍小，默認是16，所以當對hash值以桶的長度取餘，以找到存放該key的桶的下標時，由於取餘是通過與操作完成的，會忽略hash值的高位。因此只有hashCode()的低位參加運算，發生不同的hash值，但是得到的index相同的情況的機率會大大增加。</p></blockquote><h1 class=pgc-h-arrow-right>鏈表</h1><p>hash 函數總是有可能會存在衝突的，當兩個不同的 key 計算的 hash 值相等時，此時它們對應數組的下標也就相等了。因此我們就需要將數組中的元素以鏈表的方式串聯起來，這就是 Node 結構存在一個指向下一個節點的 next 字段的原因。其中新建的 Node 會插入到鏈表的尾部。</p><pre><code>// 取一段 put 方法中插入到鏈表尾的代碼Node&lt;K,V&gt; e; K k;for (int binCount = 0; ; ++binCount) {    if ((e = p.next) == null) {        // 到達鏈表尾部        p.next = newNode(hash, key, value, null);        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st            treeifyBin(tab, hash);        break;    }    if (e.hash == hash &amp;&amp;        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))        break;    p = e;}</code></pre><blockquote><p>思考一下為什麼要插入到鏈表尾部，而不是頭插法（插入到頭部）呢？ 讓我們來算下時間複雜度，尾插法需要遍歷整個鏈表，時間複雜度為O(N)，頭插法只需要將數組下標中值存放成新 Node，然後將新 Node 的 next 指向舊的頭，複雜度為O(1)，明明頭插更快啊，為什麼會變成尾插呢？答案請看擴容章節。</p></blockquote><h1 class=pgc-h-arrow-right>紅黑樹</h1><p>上面的代碼中我們還能看到一個常量 TREEIFY_THRESHOLD，它指代的是鏈表的最大長度，超過這個長度後鏈表需要被轉化為紅黑樹，默認這個變量為 8。</p><pre><code>static final int TREEIFY_THRESHOLD = 8;</code></pre><blockquote><p>什麼是紅黑樹？請看我之後的數據結構篇。</p></blockquote><p>為什麼要把長的鏈表轉換成紅黑樹呢，因為你們可以看到上面的插入操作在查找的過程中用了一個 for 循環找到尾部，時間複雜度是O(n)，而紅黑樹可以讓搜索的複雜度降到O(logn)，對於數據量大的情況，效率下降的比鏈表慢。</p><p>下面是鏈表轉換為紅黑樹的過程：</p><pre><code>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            // 將鏈表 Node 替換成 TreeNode            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            hd.treeify(tab);    }}</code></pre><h1 class=pgc-h-arrow-right>擴容</h1><p>當我們不斷的往hash桶放數據，整個桶會變得越來越臃腫，操作效率大幅降低，這時候我們需要去給 hashmap 擴容。</p><p>假定 hashmap 的容量是 capacity，目前存放著 size 個元素，當 size > threshold 時，hashmap 需要擴容，threshold = capacity * load factor。load factor 是負載因子，默認是 0.75。</p><pre><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;// 很多地方通過如下判斷進入 resize 流程if(size &gt; threshold) resize();</code></pre><p>關於容量，大家都知道 hashmap 的默認容量是 16。你有想過為什麼是16嗎？這其實還是要回過頭看到我們計算數組下標的代碼 (n-1) & hash， n 指代容量，只要n是2的冪，那麼 n-1肯定是一個二進制值全為1的數字.例如 n = 16，那麼 15 的二進制就是 1111，1111 與其他數 & 操作後的值就是後4位本身的值，所以達到最終目的，均勻的 hash（你可以對比下用 5，7等數跟別的數 & 的結果，碰撞機率明顯上升）。而 16 恰巧是那個合適的默認值，不大不小。這個道理跟負載因子是 0.75一樣，為啥是 0.75 呢，也是折中過後取的值，如果因子為1，那麼允許不擴容的大小就越大，hash 碰撞發生機率高，如果小了，動不動就擴容也不行，內存消耗大了（我猜測 0.75 應該是專家實驗統計出來的結果）。</p><p>hashmap 中還存在一個最大容量的常量，值是 2^30 次方，當容量到了這個級別就不會在擴容了。正常情況下，擴容時會先創建一個長度為原來2倍的數組，然後經過rehash 把原先的Node放進新數組中。</p><p>下面看下 resize 的具體過程：</p><pre><code>final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {            // 達到最大容量後不再擴容            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        // 如果之前的容量是0，初始化為默認的容量        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                    (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({"rawtypes","unchecked"})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    // rehash到新的數組                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><p>大家可以看到 rehash 的部分也是尾插的形式重新生成鏈表，由此它保證了 Node 的順序依然是之前鏈表的順序，如果是頭插呢，順序就變了。順序變了會產生什麼樣的問題呢：可能會導致 resize 死循環。</p><pre><code>尾插法:原鏈表 1-&gt;2-&gt;3-&gt;4rehash後鏈表可能是      1-&gt;2-&gt;3    4頭插法:原鏈表     1-&gt;2-&gt;3-&gt;4rehash後鏈表可能是     3-&gt;2-&gt;1    4   </code></pre><p><strong>頭插法中死循環是怎麼發生的？</strong></p><p>假設現在是頭插法有2個線程，線程A resize 執行遍歷到了1，然後線程B執行，執行完了整個 resize，鏈表變成了 3->2->1。然後線程A回來繼續執行，那麼它在rehash 1後繼續rehash 2，這時候發現2的next是1，這就形成了一個環，所以會一直循環下去直到資源耗盡。而尾插法很好的避免的這個問題，所以即使犧牲了一點點搜索的性能（也沒有差很多），解決了這個多線程的問題。</p><p>由此你也能看到，hashmap 是線程不安全的。想要用線程安全的 hashmap 就用 ConcurrentHashMap，它給很多操作都加了同步鎖，具體細節之後請關注多線程篇。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JAVA</a></li><li><a>HashMap</a></li><li><a>面試</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html alt=HashMap面試專題：常問六題深入解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/75bf5de0-37fd-469c-b6b3-8067c551568a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html title=HashMap面試專題：常問六題深入解析>HashMap面試專題：常問六題深入解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html alt=一個HashMap能跟面試官扯上半個小時 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3c09bf1ad1b54adaab3db4be30c10c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html title=一個HashMap能跟面試官扯上半個小時>一個HashMap能跟面試官扯上半個小時</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html alt=面試必備：HashMap源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html title=面試必備：HashMap源碼解析>面試必備：HashMap源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html alt=HashMap？面試？我是誰？我在哪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8aa437a2fb3143e7a345a46a36d2c81e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html title=HashMap？面試？我是誰？我在哪>HashMap？面試？我是誰？我在哪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html alt=面試必問的HashMap，你真的瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/19a8d23522b640b4a8d8a927514eca33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html title=面試必問的HashMap，你真的瞭解嗎？>面試必問的HashMap，你真的瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd64aed.html alt=互聯網JAVA面試常問問題-帶你走入AQS同步器源碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b0ad8c979566419b9e645660d41304d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd64aed.html title=互聯網JAVA面試常問問題-帶你走入AQS同步器源碼>互聯網JAVA面試常問問題-帶你走入AQS同步器源碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html alt=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15310942260931dda577a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html title=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點>JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>