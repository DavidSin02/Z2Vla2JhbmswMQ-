<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？ | 极客快訊</title><meta property="og:title" content="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/RiGWAV4Aw9MAi3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5aa9b023.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5aa9b023.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5aa9b023.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5aa9b023.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5aa9b023.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5aa9b023.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5aa9b023.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5aa9b023.html><meta property="article:published_time" content="2020-10-29T21:09:45+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:45+08:00"><meta name=Keywords content><meta name=description content="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5aa9b023.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RiGWAV4Aw9MAi3><p>作者 | 海星</p><p>來源 | JavaKeeper（ID：JavaKeeper）</p><p><strong>Keeper導讀</strong>：前幾天起身去“外邊”看了看，阿里健康的一個面試官一直在問我這個問題，回答的一般，用了兩天時間整理，希望大家也能真正理解了。</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p><strong>前言</strong></p><p>循環依賴問題，算是一道爛大街的面試題了，解毒之前，我們先來回顧兩個知識點：</p><p>初學 Spring 的時候，我們就知道 IOC，控制反轉麼，它將原本在程序中手動創建對象的控制權，交由 Spring 框架來管理，不需要我們手動去各種 new XXX。</p><p>儘管是 Spring 管理，不也得創建對象嗎， Java 對象的創建步驟很多，可以 new XXX、序列化、clone 等等， 只是 Spring 是通過反射 + 工廠的方式創建對象並放在容器的，創建好的對象我們一般還會對對象屬性進行賦值，才去使用，可以理解是分了兩個步驟。</p><p>好了，對這兩個步驟有個印象就行，接著我們進入循環依賴，先說下循環依賴的概念。</p><p>所謂的循環依賴是指，A 依賴 B，B 又依賴 A，它們之間形成了循環依賴。或者是 A 依賴 B，B 依賴 C，C 又依賴 A，形成了循環依賴。更或者是自己依賴自己。它們之間的依賴關係如下：</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9o5jNS6sXa4uU><p>這裡以兩個類直接相互依賴為例，他們的實現代碼可能如下：</p><pre><div><pre><p>public class BeanB {</p><p>private BeanA beanA;</p><p>public void <strong class=highlight-text toutiao-origin=span>setBeanA</strong>(BeanA beanA) {</p><p>this.beanA = beanA;</p><p>}</p><p>}</p><p>public class BeanA {</p><p>private BeanB beanB;</p><p>public void <strong class=highlight-text toutiao-origin=span>setBeanB</strong>(BeanB beanB) {</p><p>this.beanB = beanB;</p><p>}</p><p>}</p></pre></div></pre><p>配置信息如下（用註解方式注入同理，只是為了方便理解，用了配置文件）：</p><pre><div><pre><p>&lt;bean id="beanA" class="priv.starfish.BeanA"&gt;</p><p>&lt;property name="beanB" ref="beanB"/&gt;</p><p>&lt;/bean&gt;</p><p>&lt;bean id="beanB" class="priv.starfish.BeanB"&gt;</p><p>&lt;property name="beanA" ref="beanA"/&gt;</p><p>&lt;/bean&gt;</p></pre></div></pre><p>Spring 啟動後，讀取如上的配置文件，會按順序先實例化 A，但是創建的時候又發現它依賴了 B，接著就去實例化 B ，同樣又發現它依賴了 A ，這尼瑪咋整？無限循環呀。</p><p>Spring “肯定”不會讓這種事情發生的，如前言我們說的 Spring 實例化對象分兩步，第一步會先創建一個原始對象，只是沒有設置屬性，可以理解為"半成品"—— 官方叫 A 對象的早期引用（EarlyBeanReference），所以當實例化 B 的時候發現依賴了 A， B 就會把這個“半成品”設置進去先完成實例化，既然 B 完成了實例化，所以 A 就可以獲得 B 的引用，也完成實例化了，這其實就是 Spring 解決循環依賴的思想。</p><p>不理解沒關係，先有個大概的印象，然後我們從源碼來看下 Spring 具體是怎麼解決的。</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p></p><h1 toutiao-origin=h2>源碼解毒</h1><blockquote><p>代碼版本：5.0.16.RELEASE</p></blockquote><p>在 Spring IOC 容器讀取 Bean 配置創建 Bean 實例之前, 必須對它進行實例化。只有在容器實例化後，才可以從 IOC 容器裡獲取 Bean 實例並用，循環依賴問題也就是發生在實例化 Bean 的過程中的，所以我們先回顧下獲取 Bean 的過程。</p><p></p><h2 toutiao-origin=h3><strong>獲取 Bean 流程</strong></h2><p>Spring IOC 容器中獲取 bean 實例的簡化版流程如下（排除了各種包裝和檢查的過程）</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9o5jNsDOKJHqz><p>大概的流程順序（可以結合著源碼看下，我就不貼了）：</p><ol><li><p>流程從 getBean 方法開始，getBean 是個空殼方法，所有邏輯直接到 doGetBean 方法中。</p></li><li><p>transformedBeanName 將 name 轉換為真正的 beanName（name 可能是 FactoryBean 以 & 字符開頭或者有別名的情況，所以需要轉化下）。</p></li><li><p>然後通過 getSingleton(beanName) 方法嘗試從緩存中查找是不是有該實例 sharedInstance（單例在 Spring 的同一容器只會被創建一次，後續再獲取 bean，就直接從緩存獲取即可）。</p></li><li><p>如果有的話，sharedInstance 可能是完全實例化好的 bean，也可能是一個原始的 bean，所以再經 getObjectForBeanInstance 處理即可返回。</p></li><li><p>當然 sharedInstance 也可能是 ，這時候就會執行創建 bean 的邏輯，將結果返回。</p></li></ol><p>第三步的時候我們提到了一個緩存的概念，這個就是 Spring 為了解決單例的循環依賴問題而設計的三級緩存：</p><pre><div><pre><p>/** Cache of singleton objects: bean name --&gt; bean instance */</p><p>private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</p><p>/** Cache of singleton factories: bean name --&gt; ObjectFactory */</p><p>private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</p><p>/** Cache of early singleton objects: bean name --&gt; bean instance */</p><p>private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</p></pre></div></pre><p>這三級緩存的作用分別是：</p><ul><li><p>singletonObjects：完成初始化的單例對象的 cache，這裡的 bean 經歷過 實例化->屬性填充->初始化 以及各種後置處理（一級緩存）。</p></li><li><p>earlySingletonObjects：存放原始的 bean 對象（完成實例化但是尚未填充屬性和初始化），僅僅能作為指針提前曝光，被其他 bean 所引用，用於解決循環依賴的 （二級緩存）。</p></li><li><p>singletonFactories：在 bean 實例化完之後，屬性填充以及初始化之前，如果允許提前曝光，Spring 會將實例化後的 bean 提前曝光，也就是把該 bean 轉換成 beanFactory 並加入到 singletonFactories（三級緩存）。</p></li></ul><p>我們首先從緩存中試著獲取 bean，就是從這三級緩存中查找：</p><pre><div><pre><p>protected Object getSingleton(String beanName, boolean allowEarlyReference) {</p><p>// 從 singletonObjects 獲取實例，singletonObjects 中的實例都是準備好的 bean 實例，可以直接使用</p><p>Object singletonObject = this.singletonObjects.get(beanName);</p><p>//isSingletonCurrentlyInCreation 判斷當前單例bean是否正在創建中</p><p>if (singletonObject ==  &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</p><p>synchronized (this.singletonObjects) {</p><p>// 一級緩存沒有，就去二級緩存找</p><p>singletonObject = this.earlySingletonObjects.get(beanName);</p><p>if (singletonObject ==  &amp;&amp; allowEarlyReference) {</p><p>// 二級緩存也沒有，就去三級緩存找</p><p>ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</p><p>if (singletonFactory != ) {</p><p>// 三級緩存有的話，就把他移動到二級緩存,.getObject 後續會講到</p><p>singletonObject = singletonFactory.getObject;</p><p>this.earlySingletonObjects.put(beanName, singletonObject);</p><p>this.singletonFactories.remove(beanName);</p><p>}</p><p>}</p><p>}</p><p>}</p><p>return singletonObject;</p><p>}</p></pre></div></pre><p>如果緩存沒有的話，我們就要創建了，接著我們以單例對象為例，再看下創建 bean 的邏輯（大括號表示內部類調用方法）：</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9o5jOVA7vGz4K><p>1、創建 bean 從以下代碼開始，一個匿名內部類方法參數（總覺得 Lambda 的方式可讀性不如內部類好理解）。</p><pre><div><pre><p>if (mbd.isSingleton) {</p><p>sharedInstance = getSingleton(beanName,  -&gt; {</p><p>try {</p><p>return createBean(beanName, mbd, args);</p><p>}</p><p>catch (BeansException ex) {</p><p>destroySingleton(beanName);</p><p>throw ex;</p><p>}</p><p>});</p><p>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</p><p>}</p></pre></div></pre><p>getSingleton 方法內部主要有兩個方法：</p><pre><div><pre><p>public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {</p><p>// 創建 singletonObject</p><p>singletonObject = singletonFactory.getObject;</p><p>// 將 singletonObject 放入緩存</p><p>addSingleton(beanName, singletonObject);</p><p>}</p></pre></div></pre><p>2、getObject 匿名內部類的實現真正調用的又是 createBean(beanName, mbd, args)。</p><p>3、往裡走，主要的實現邏輯在 doCreateBean方法，先通過 createBeanInstance 創建一個原始 bean 對象。</p><p>4、接著 addSingletonFactory 添加 bean 工廠對象到 singletonFactories 緩存（三級緩存）。</p><p>5、通過 populateBean 方法向原始 bean 對象中填充屬性，並解析依賴，假設這時候創建 A 之後填充屬性時發現依賴 B，然後創建依賴對象 B 的時候又發現依賴 A，還是同樣的流程，又去 getBean(A)，這個時候三級緩存已經有了 beanA 的“半成品”，這時就可以把 A 對象的原始引用注入 B 對象（並將其移動到二級緩存）來解決循環依賴問題。這時候 getObject 方法就算執行結束了，返回完全實例化的 bean。</p><p>6、最後調用 addSingleton 把完全實例化好的 bean 對象放入 singletonObjects 緩存（一級緩存）中，打完收工。</p><p></p><h2 toutiao-origin=h3><strong>Spring 解決循環依賴</strong></h2><p>建議搭配著“源碼”看下邊的邏輯圖，更好下飯。</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9o5jPO8NyCje3><p>流程其實上邊都已經說過了，結合著上圖我們再看下具體細節，用大白話再捋一捋：</p><ol><li><p>Spring 創建 bean 主要分為兩個步驟，創建原始 bean 對象，接著去填充對象屬性和初始化。</p></li><li><p>每次創建 bean 之前，我們都會從緩存中查下有沒有該 bean，因為是單例，只能有一個。</p></li><li><p>當我們創建 beanA 的原始對象後，並把它放到三級緩存中，接下來就該填充對象屬性了，這時候發現依賴了 beanB，接著就又去創建 beanB，同樣的流程，創建完 beanB 填充屬性時又發現它依賴了 beanA，又是同樣的流程，不同的是，這時候可以在三級緩存中查到剛放進去的原始對象 beanA，所以不需要繼續創建，用它注入 beanB，完成 beanB 的創建。</p></li><li><p>既然 beanB 創建好了，所以 beanA 就可以完成填充屬性的步驟了，接著執行剩下的邏輯，閉環完成。</p></li></ol><p>這就是單例模式下 Spring 解決循環依賴的流程了。</p><p>但是這個地方，不管是誰看源碼都會有個小疑惑，為什麼需要三級緩存呢，我趕腳二級他也夠了呀？</p><p>革命尚未成功，同志仍需努力！</p><p>跟源碼的時候，發現在創建 beanB 需要引用 beanA 這個“半成品”的時候，就會觸發"前期引用"，即如下代碼：</p><pre><div><pre><p>ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</p><p>if (singletonFactory != ) {</p><p>// 三級緩存有的話，就把他移動到二級緩存</p><p>singletonObject = singletonFactory.getObject;</p><p>this.earlySingletonObjects.put(beanName, singletonObject);</p><p>this.singletonFactories.remove(beanName);</p><p>}</p></pre></div></pre><p>singletonFactory.getObject 是一個接口方法，這裡具體的實現方法在：</p><pre><div><pre><p>protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {</p><p>Object exposedObject = bean;</p><p>if (!mbd.isSynthetic &amp;&amp; hasInstantiationAwareBeanPostProcessors) {</p><p>for (BeanPostProcessor bp : getBeanPostProcessors) {</p><p>if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {</p><p>SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</p><p>// 這麼一大段就這句話是核心，也就是當bean要進行提前曝光時，</p><p>// 給一個機會，通過重寫後置處理器的getEarlyBeanReference方法，來自定義操作bean</p><p>// 值得注意的是，如果提前曝光了，但是沒有被提前引用，則該後置處理器並不生效!!!</p><p>// 這也正式三級緩存存在的意義，否則二級緩存就可以解決循環依賴的問題</p><p>exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</p><p>}</p><p>}</p><p>}</p><p>return exposedObject;</p><p>}</p></pre></div></pre><p>這個方法就是 Spring 為什麼使用三級緩存，而不是二級緩存的原因，它的目的是為了後置處理，如果沒有 AOP 後置處理，就不會走進 if 語句，直接返回了 exposedObject ，相當於啥都沒幹，二級緩存就夠用了。</p><p>所以又得出結論，這個三級緩存應該和 AOP 有關係，繼續。</p><p>在 Spring 的源碼中getEarlyBeanReference 是 SmartInstantiationAwareBeanPostProcessor 接口的默認方法，真正實現這個方法的只有**AbstractAutoProxyCreator** 這個類，用於提前曝光的 AOP 代理。</p><pre><div><pre><p>@Override</p><p>public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {</p><p>Object cacheKey = getCacheKey(bean.getClass, beanName);</p><p>this.earlyProxyReferences.put(cacheKey, bean);</p><p>// 對bean進行提前Spring AOP代理</p><p>return wrapIfNecessary(bean, beanName, cacheKey);</p><p>}</p></pre></div></pre><p>這麼說有點幹，來個小 demo 吧，我們都知道 Spring AOP、事務等都是通過代理對象來實現的，而事務的代理對象是由自動代理創建器來自動完成的。也就是說 Spring 最終給我們放進容器裡面的是一個代理對象，而非原始對象，假設我們有如下一段業務代碼：</p><pre><div><pre><p>@Service</p><p>public class HelloServiceImpl implements HelloService {</p><p>@Autowired</p><p>private HelloService helloService;</p><p>@Override</p><p>@Transactional</p><p>public Object hello {</p><p>return "Hello JavaKeeper";</p><p>}</p><p>}</p></pre></div></pre><p>此 Service 類使用到了事務，所以最終會生成一個 JDK 動態代理對象 Proxy。剛好它又存在自己引用自己的循環依賴，完美符合我們的場景需求。</p><p>我們再自定義一個後置處理，來看下效果：</p><pre><div><pre><p>@Component</p><p>public class HelloProcessor implements SmartInstantiationAwareBeanPostProcessor {</p><p>@Override</p><p>public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {</p><p>System.out.println("提前曝光了："+beanName);</p><p>return bean;</p><p>}</p><p>}</p></pre></div></pre><p>可以看到，調用方法棧中有我們自己實現的 HelloProcessor，說明這個 bean 會通過 AOP 代理處理。</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9o5nd9DDx4KUe><p>再從源碼看下這個自己循環自己的 bean 的創建流程：</p><pre><div><pre><p>protected Object doCreateBean( ... ){</p><p>...</p><p>boolean earlySingletonExposure = (mbd.isSingleton &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</p><p>// 需要提前暴露（支持循環依賴），就註冊一個ObjectFactory到三級緩存</p><p>if (earlySingletonExposure) { </p><p>// 添加 bean 工廠對象到 singletonFactories 緩存中，並獲取原始對象的早期引用</p><p>//匿名內部方法 getEarlyBeanReference 就是後置處理器 </p><p>// SmartInstantiationAwareBeanPostProcessor 的一個方法，</p><p>// 它的功效為：保證自己被循環依賴的時候，即使被別的Bean @Autowire進去的也是代理對象</p><p>addSingletonFactory(beanName,  -&gt; getEarlyBeanReference(beanName, mbd, bean));</p><p>}</p><p>// 此處注意：如果此處自己被循環依賴了 那它會走上面的getEarlyBeanReference，從而創建一個代理對象從 三級緩存轉移到二級緩存裡</p><p>// 注意此時候對象還在二級緩存裡，並沒有在一級緩存。並且此時後續的這兩步操作還是用的 exposedObject，它仍舊是原始對象~~~</p><p>populateBean(beanName, mbd, instanceWrapper);</p><p>exposedObject = initializeBean(beanName, exposedObject, mbd);</p><p>// 因為事務的AOP自動代理創建器在getEarlyBeanReference 創建代理後，initializeBean 就不會再重複創建了，二選一的）</p><p>// 所以經過這兩大步後，exposedObject 還是原始對象，通過 getEarlyBeanReference 創建的代理對象還在三級緩存呢</p><p>...</p><p>// 循環依賴校驗</p><p>if (earlySingletonExposure) {</p><p>// 注意此處第二個參數傳的false，表示不去三級緩存裡再去調用一次getObject方法了~~~，此時代理對象還在二級緩存，所以這裡拿出來的就是個 代理對象</p><p>// 最後賦值給exposedObject 然後return出去，進而最終被addSingleton添加進一級緩存裡面去 </p><p>// 這樣就保證了我們容器裡 最終實際上是代理對象，而非原始對象~~~~~</p><p>Object earlySingletonReference = getSingleton(beanName, false);</p><p>if (earlySingletonReference != ) {</p><p>if (exposedObject == bean) { </p><p>exposedObject = earlySingletonReference;</p><p>}</p><p>}</p><p>...</p><p>}</p><p>}</p></pre></div></pre><p></p><h2 toutiao-origin=h4>自我解惑：</h2><p>問：還是不太懂，為什麼這麼設計呢，即使有代理，在二級緩存代理也可以吧 | 為什麼要使用三級緩存呢？</p><p>我們再來看下相關代碼，假設我們現在是二級緩存架構，創建 A 的時候，我們不知道有沒有循環依賴，所以放入二級緩存提前暴露，接著創建 B，也是放入二級緩存，這時候發現又循環依賴了 A，就去二級緩存找，是有，但是如果此時還有 AOP 代理呢，我們要的是代理對象可不是原始對象，這怎麼辦，只能改邏輯，在第一步的時候，不管3721，所有 Bean 統統去完成 AOP 代理，如果是這樣的話，就不需要三級緩存了，但是這樣不僅沒有必要，而且違背了 Spring 在結合 AOP 跟 Bean 的生命週期的設計。</p><p>所以 Spring “多此一舉”的將實例先封裝到 ObjectFactory 中（三級緩存），主要關鍵點在 getObject 方法並非直接返回實例，而是對實例又使用 SmartInstantiationAwareBeanPostProcessor 的 getEarlyBeanReference 方法對 bean 進行處理，也就是說，當 Spring 中存在該後置處理器，所有的單例 bean 在實例化後都會被進行提前曝光到三級緩存中，但是並不是所有的 bean 都存在循環依賴，也就是三級緩存到二級緩存的步驟不一定都會被執行，有可能曝光後直接創建完成，沒被提前引用過，就直接被加入到一級緩存中。因此可以確保只有提前曝光且被引用的 bean 才會進行該後置處理。</p><pre><div><pre><p>protected Object getSingleton(String beanName, boolean allowEarlyReference) {</p><p>Object singletonObject = this.singletonObjects.get(beanName);</p><p>if (singletonObject ==  &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {</p><p>synchronized (this.singletonObjects) {</p><p>singletonObject = this.earlySingletonObjects.get(beanName);</p><p>if (singletonObject ==  &amp;&amp; allowEarlyReference) {</p><p>// 三級緩存獲取，key=beanName value=objectFactory，objectFactory中存儲 //getObject方法用於獲取提前曝光的實例</p><p>ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</p><p>if (singletonFactory != ) {</p><p>// 三級緩存有的話，就把他移動到二級緩存</p><p>singletonObject = singletonFactory.getObject;</p><p>this.earlySingletonObjects.put(beanName, singletonObject);</p><p>this.singletonFactories.remove(beanName);</p><p>}</p><p>}</p><p>}</p><p>}</p><p>return singletonObject;</p><p>}</p><p>boolean earlySingletonExposure = (mbd.isSingleton &amp;&amp; this.allowCircularReferences &amp;&amp;</p><p>isSingletonCurrentlyInCreation(beanName));</p><p>if (earlySingletonExposure) {</p><p>if (logger.isDebugEnabled) {</p><p>logger.debug("Eagerly caching bean '" + beanName +</p><p>"' to allow for resolving potential circular references");</p><p>}</p><p>// 添加 bean 工廠對象到 singletonFactories 緩存中，並獲取原始對象的早期引用</p><p>//匿名內部方法 getEarlyBeanReference 就是後置處理器</p><p>// SmartInstantiationAwareBeanPostProcessor 的一個方法，</p><p>// 它的功效為：保證自己被循環依賴的時候，即使被別的Bean @Autowire進去的也是代理對象~~~~ AOP自動代理創建器此方法裡會創建的代理對象~~~</p><p>addSingletonFactory(beanName,  -&gt; getEarlyBeanReference(beanName, mbd, bean));</p><p>}</p></pre></div></pre><p>再問：AOP 代理對象提前放入了三級緩存，沒有經過屬性填充和初始化，這個代理又是如何保證依賴屬性的注入的呢？</p><p>這個又涉及到了 Spring 中動態代理的實現，不管是cglib代理還是jdk動態代理生成的代理類，代理時，會將目標對象 target 保存在最後生成的代理 $proxy 中，當調用 $proxy 方法時會回調 h.invoke，而 h.invoke 又會回調目標對象 target 的原始方法。所有，其實在 AOP 動態代理時，原始 bean 已經被保存在 提前曝光代理中了，之後 原始 bean 繼續完成屬性填充和初始化操作。因為 AOP 代理$proxy中保存著 traget 也就是是 原始bean 的引用，因此後續 原始bean 的完善，也就相當於Spring AOP中的 target 的完善，這樣就保證了 AOP 的屬性填充與初始化了！</p><p></p><h2 toutiao-origin=h3>非單例循環依賴</h2><p>看完了單例模式的循環依賴，我們再看下非單例的情況，假設我們的配置文件是這樣的：</p><pre><div><pre><p>&lt;bean id="beanA" class="priv.starfish.BeanA" scope="prototype"&gt;</p><p>&lt;property name="beanB" ref="beanB"/&gt;</p><p>&lt;/bean&gt;</p><p>&lt;bean id="beanB" class="priv.starfish.BeanB" scope="prototype"&gt;</p><p>&lt;property name="beanA" ref="beanA"/&gt;</p><p>&lt;/bean&gt;</p></pre></div></pre><p>啟動 Spring，結果如下：</p><pre><div><pre><p>Error creating bean with name 'beanA' defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean 'beanB' while setting bean property 'beanB';</p><p>Error creating bean with name 'beanB' defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean 'beanA' while setting bean property 'beanA';</p><p>Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'beanA': Requested bean is currently in creation: Is there an unresolvable circular reference?</p></pre></div></pre><p>對於 prototype 作用域的 bean，Spring 容器無法完成依賴注入，因為 Spring 容器不進行緩存 prototype 作用域的 bean ，因此無法提前暴露一個創建中的bean 。</p><p>原因也挺好理解的，原型模式每次請求都會創建一個實例對象，即使加了緩存，循環引用太多的話，就比較麻煩了就，所以 Spring 不支持這種方式，直接拋出異常：</p><pre><div><pre><p>if (isPrototypeCurrentlyInCreation(beanName)) {</p><p>throw new BeanCurrentlyInCreationException(beanName);</p><p>}</p></pre></div></pre><p></p><h2 toutiao-origin=h3>構造器循環依賴</h2><p>上文我們講的是通過 Setter 方法注入的單例 bean 的循環依賴問題，用 Spring 的小夥伴也都知道，依賴注入的方式還有構造器注入、工廠方法注入的方式（很少使用），那如果構造器注入方式也有循環依賴，可以搞不？</p><p>我們再改下代碼和配置文件。</p><pre><div><pre><p>public class BeanA {</p><p>private BeanB beanB;</p><p>public <strong class=highlight-text toutiao-origin=span>BeanA</strong>(BeanB beanB) {</p><p>this.beanB = beanB;</p><p>}</p><p>}</p><p>public class BeanB {</p><p>private BeanA beanA;</p><p>public <strong class=highlight-text toutiao-origin=span>BeanB</strong>(BeanA beanA) {</p><p>this.beanA = beanA;</p><p>}</p><p>}</p></pre></div></pre><pre><div><pre><p>&lt;bean id="beanA" class="priv.starfish.BeanA"&gt;</p><p>&lt;constructor-arg ref="beanB"/&gt;</p><p>&lt;/bean&gt;</p><p>&lt;bean id="beanB" class="priv.starfish.BeanB"&gt;</p><p>&lt;constructor-arg ref="beanA"/&gt;</p><p>&lt;/bean&gt;</p></pre></div></pre><p>執行結果，又是異常</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9o5ndtA3mcWV8><p>看看官方給出的說法：</p><blockquote><p>Circular dependencies</p><p>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.</p><p>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a BeanCurrentlyInCreationException.</p><p>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.</p><p>Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken-and-egg scenario).</p></blockquote><p>大概意思是：</p><p>如果您主要使用構造器注入，循環依賴場景是無法解決的。建議你用 setter 注入方式代替構造器注入</p><p>其實也不是說只要是構造器注入就會有循環依賴問題，Spring 在創建 Bean 的時候默認是按照自然排序來進行創建的，我們暫且把先創建的 bean 叫主 bean，上文的 A 即主 bean，只要主 bean 注入依賴 bean 的方式是 setter 方式，依賴 bean 的注入方式無所謂，都可以解決，反之亦然</p><p>所以上文我們 AB 循環依賴問題，只要 A 的注入方式是 setter ，就不會有循環依賴問題。</p><p>面試官問：為什麼呢？</p><p>Spring 解決循環依賴依靠的是 Bean 的“中間態”這個概念，而這個中間態指的是已經實例化，但還沒初始化的狀態。實例化的過程又是通過構造器創建的，如果 A 還沒創建好出來，怎麼可能提前曝光，所以構造器的循環依賴無法解決，我一直認為應該先有雞才能有蛋。</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p></p><h1 toutiao-origin=h2>小總結 | 面試這麼答</h1><p></p><h2 toutiao-origin=h4>B 中提前注入了一個沒有經過初始化的 A 類型對象不會有問題嗎？</h2><p>雖然在創建 B 時會提前給 B 注入了一個還未初始化的 A 對象，但是在創建 A 的流程中一直使用的是注入到 B 中的 A 對象的引用，之後會根據這個引用對 A 進行初始化，所以這是沒有問題的。</p><p></p><h2 toutiao-origin=h4>Spring 是如何解決的循環依賴？</h2><p>Spring 為了解決單例的循環依賴問題，使用了三級緩存。其中一級緩存為單例池（singletonObjects），二級緩存為提前曝光對象（earlySingletonObjects），三級緩存為提前曝光對象工廠（singletonFactories）。</p><p>假設A、B循環引用，實例化 A 的時候就將其放入三級緩存中，接著填充屬性的時候，發現依賴了 B，同樣的流程也是實例化後放入三級緩存，接著去填充屬性時又發現自己依賴 A，這時候從緩存中查找到早期暴露的 A，沒有 AOP 代理的話，直接將 A 的原始對象注入 B，完成 B 的初始化後，進行屬性填充和初始化，這時候 B 完成後，就去完成剩下的 A 的步驟，如果有 AOP 代理，就進行 AOP 處理獲取代理後的對象 A，注入 B，走剩下的流程。</p><p></p><h2 toutiao-origin=h4>為什麼要使用三級緩存呢？二級緩存能解決循環依賴嗎？</h2><p>如果沒有 AOP 代理，二級緩存可以解決問題，但是有 AOP 代理的情況下，只用二級緩存就意味著所有 Bean 在實例化後就要完成 AOP 代理，這樣違背了 Spring 設計的原則，Spring 在設計之初就是通過 AnnotationAwareAspectJAutoProxyCreator 這個後置處理器來在 Bean 生命週期的最後一步來完成 AOP 代理，而不是在實例化後就立馬進行 AOP 代理。</p><p></p><h2 toutiao-origin=h3>參考與感謝：</h2><p>《Spring 源碼深度解析》- 郝佳著</p><p>https://developer.aliyun.com/article/766880</p><p>http://www.tianxiaobo.com/2018/06/08/Spring-IOC-容器源碼分析-循環依賴的解決辦法</p><p>https://cloud.tencent.com/developer/article/1497692</p><p>https://blog.csdn.net/chaitoudaren/article/details/105060882</p><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R69FpRH4d90a7d><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9fvQrwFxdO6Si><pre><div><div><div><div><div><div><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpbJ0CLyq7></div></div><p><strong toutiao-origin=span>點分享</strong></p></div><div><div><div><div><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S3Y8EjO3S3jH6O></div></div></div><div><div><div><img alt="爛了大街的 Spring 循環依賴問題，你以為自己就真會了嗎？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpwDUoK9Jv></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>爛了</a></li><li><a>Spring</a></li><li><a>循環</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/32c82df2.html alt=熱水鍋爐房循環水泵選型建議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32c82df2.html title=熱水鍋爐房循環水泵選型建議>熱水鍋爐房循環水泵選型建議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html alt=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/433259b5-1936-4cee-ab74-70aef36536ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html title=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理>（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48532629.html alt=循環⽔養殖指標-溶解氧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/56d1472f673a48fcb736dca88bf7b39c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48532629.html title=循環⽔養殖指標-溶解氧>循環⽔養殖指標-溶解氧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d9a5540.html alt=循環流化床鍋爐耐磨耐火材料都有哪些？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/85eb71ea22e548ff81c68a4c0216f09a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d9a5540.html title=循環流化床鍋爐耐磨耐火材料都有哪些？>循環流化床鍋爐耐磨耐火材料都有哪些？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f833cb1e.html alt="技術 | 淺談循環流化床鍋爐大修時的防磨處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f833cb1e.html title="技術 | 淺談循環流化床鍋爐大修時的防磨處理">技術 | 淺談循環流化床鍋爐大修時的防磨處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/80eda0c9.html alt=工業循環冷卻水處理（三） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a8094522823a4a4fab20b39b9c4a062c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/80eda0c9.html title=工業循環冷卻水處理（三）>工業循環冷卻水處理（三）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/41882779.html alt=什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e06e4d3087d4032ab0d9dfb3d7d2e89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/41882779.html title=什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司>什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7061034.html alt=循環流化床鍋爐1000問（四）優化試驗篇1循環流化床鍋爐冷態試驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3cfade6d49b044d199d262c3b6d40f1a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7061034.html title=循環流化床鍋爐1000問（四）優化試驗篇1循環流化床鍋爐冷態試驗>循環流化床鍋爐1000問（四）優化試驗篇1循環流化床鍋爐冷態試驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90f40400.html alt="挪威小鎮改造方案：景觀循環the landscape loop" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/435200015e999fea9af2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90f40400.html title="挪威小鎮改造方案：景觀循環the landscape loop">挪威小鎮改造方案：景觀循環the landscape loop</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a83bdbe.html alt=燃料電池氫氣循環設計方案探討 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c98d4743f6e749ff993165fcb3fe7ed8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a83bdbe.html title=燃料電池氫氣循環設計方案探討>燃料電池氫氣循環設計方案探討</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>