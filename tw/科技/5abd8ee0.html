<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經 | 极客快訊</title><meta property="og:title" content="四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/af6b4034b7db48f0907aff6d641e490c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5abd8ee0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>導讀</h1><p>前面文章<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6876269894007161348/?group_id=6876269894007161348?group_id=6876269894007161348" rel="noopener noreferrer" target=_blank>一、深入理解-Java集合初篇</a> 中我們對Java的集合體系進行一個簡單的分析介紹，上兩篇文章<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877007182232027655/?group_id=6877007182232027655?group_id=6877007182232027655" rel="noopener noreferrer" target=_blank>二、Jdk1.7和1.8中HashMap數據結構及源碼分析</a> 、<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877050052326457860/?group_id=6877050052326457860?group_id=6877050052326457860" rel="noopener noreferrer" target=_blank>二、JDK1.7和1.8HashMap數據結構及源碼分析-續</a> 中我們分別對JDK1.7和JDK1.8中HashMap的數據結構、主要聲明變量、構造函數、HashMap的put操作方法做了深入的講解和源碼分析。<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877362834460639757/?group_id=6877362834460639757?group_id=6877362834460639757" rel="noopener noreferrer" target=_blank>三、深入理解Java中的HashMap「網易面試快答」</a> 文章中主要針對面試中常見的文件進行簡單解答。</p><p><strong>本篇文章我們將要對JDK1.7中HashMap的哈希衝突及減少哈希衝突的解決方案做詳細的介紹，並通過源碼加深大家的理解。</strong></p><p><br></p><p><strong class=highlight-text>如果大家在面試中針對Java集合或者Java中的HashMap大家還有什麼疑問或者其他問題，可以評論區告訴我。</strong></p><h1 class=pgc-h-arrow-right>簡單介紹</h1><p>JDK1.7---》哈希表，鏈表</p><p>JDK1.8---》哈希表，鏈表，紅黑樹--- JDK1.8之後，當鏈表長度超過8使用紅黑樹。</p><p><strong class=highlight-text>非線程安全</strong></p><p><strong class=highlight-text>0.75的負載因子，擴容必須為原來的兩倍。</strong></p><p><strong class=highlight-text>默認大小為16，傳入的初始大小必須為2的冪次方的值，如果不為也會變為2的冪次方的值。</strong></p><p>根據HashCode存儲數據。</p><h1 class=pgc-h-arrow-right>JDK1.7的哈希衝突解決方案</h1><h1 class=pgc-h-arrow-right>1.配置threshold：jdk.map.althashing.threshold（閥值-門檻）</h1><p><strong>配置改變hash衝突的門檻</strong></p><p><strong>源碼：</strong></p><pre><code>/** * The default threshold of map capacity above which alternative hashing is * used for String keys. Alternative hashing reduces the incidence of * collisions due to weak hash code calculation for String keys. * &lt;p/&gt; * This value may be overridden by defining the system property * {@code jdk.map.althashing.threshold}. A property value of {@code 1} * forces alternative hashing to be used at all times whereas * {@code -1} value ensures that alternative hashing is never used. */static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</code></pre><p><strong></strong></p><p>-Djdk.map.althashing.threshold = -1: 表示不做優化（不配置這個值作用一樣）<br>-Djdk.map.althashing.threshold &lt; 0: 報錯</p><p>-Djdk.map.althashing.threshold = 1: 表示總是啟用隨機HashSeed<br>-Djdk.map.althashing.threshold >= 0 : 表示hashMap內部的數組長度超過該值了就使用隨機HashSeed，降低碰撞</p><p><strong class=highlight-text>如果 配置該值為-1，表示不做hash衝突的優化；</strong></p><p><strong class=highlight-text>如果 配置該值小於0，則報錯；</strong></p><p><strong class=highlight-text>如果 配置該值為1 則表示總是使用一個隨機值（哈希因子hashseed）對hash衝突.</strong></p><p><strong class=highlight-text>如果 配置該值大於等於0 表示當HashMap中數組長度超過該值的時候就使用隨機值（哈希因子hashseed）來降低哈希衝突的可能性。</strong></p><p></p><h1 class=pgc-h-arrow-right>2使用一個私有的靜態內部類Holder加載虛擬機引導之後才被初始化的值。</h1><p>使用私有的靜態內部類Holder加載上一步配置的Jdk.map.althashing.threshold。</p><p><strong>源碼：</strong></p><pre><code>/** * The default threshold of map capacity above which alternative hashing is * used for String keys. Alternative hashing reduces the incidence of * collisions due to weak hash code calculation for String keys. * &lt;p/&gt; * This value may be overridden by defining the system property * {@code jdk.map.althashing.threshold}. A property value of {@code 1} * forces alternative hashing to be used at all times whereas * {@code -1} value ensures that alternative hashing is never used. */static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;/** * holds values which can't be initialized until after VM is booted. */private static class Holder {    /**     * Table capacity above which to switch to use alternative hashing.     */    static final int ALTERNATIVE_HASHING_THRESHOLD;    static {        String altThreshold = java.security.AccessController.doPrivileged(            new sun.security.action.GetPropertyAction(                "jdk.map.althashing.threshold"));        int threshold;        try {            threshold = (null != altThreshold)                    ? Integer.parseInt(altThreshold)                    : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;            // disable alternative hashing if -1            if (threshold == -1) {                threshold = Integer.MAX_VALUE;            }            if (threshold &lt; 0) {                throw new IllegalArgumentException("value must be positive integer.");            }        } catch(IllegalArgumentException failed) {            throw new Error("Illegal value for 'jdk.map.althashing.threshold'", failed);        }        ALTERNATIVE_HASHING_THRESHOLD = threshold;    }}/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. If 0 then * alternative hashing is disabled. */transient int hashSeed = 0;</code></pre><p><strong>源碼解讀：</strong></p><p>1、static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</p><p>如果在上一步中沒有配置“jdk.map.althashing.threshold”,則使用該值表示是否對HashMap中的哈希衝突做干擾。該值的默認值是Integer的最大值。表示只有當HashMap中數組容量達到Integer的最大值時候才會做哈希衝突的干擾。設置這個值這麼大，其實就是不做哈希衝突干擾。</p><p>2、在私有的靜態內部類Holder中做判斷判斷。</p><p>①加載（jdk.map.althashing.threshold）配置的altThreshold;</p><pre><code>String altThreshold = java.security.AccessController.doPrivileged(    new sun.security.action.GetPropertyAction(        "jdk.map.althashing.threshold"));</code></pre><p>②如果從配置中加載到的altThreshold不為空，則把threshold賦值為加載到的altThreshold;</p><p>如果沒有配置該altThreshold則使用默認的ALTERNATIVE_HASHING_THRESHOLD_DEFAULT，即Integer.MAX_VALUE;</p><pre><code>threshold = (null != altThreshold)        ? Integer.parseInt(altThreshold)        : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</code></pre><p>③如果在JDK中配置的jdk.map.althashing.threshold為默認值-1，則把threshold設置為Integer.MAX_VALUE;</p><pre><code>// disable alternative hashing if -1if (threshold == -1) {    threshold = Integer.MAX_VALUE;}</code></pre><p>④．如果在JDK中配置的jdk.map.althashing.threshold值小於0，則報錯，表示該值不是一個有效值。</p><pre><code>if (threshold &lt; 0) {    throw new IllegalArgumentException("value must be positive integer.");}</code></pre><p>⑤．把經過計算的threshold的值賦值給“ALTERNATIVE_HASHING_THRESHOLD”.</p><p><strong class=highlight-text>也就是說最終是否對哈希衝突做干擾，或者在什麼情況進行干擾是存儲在“ALTERNATIVE_HASHING_THRESHOLD”中的。</strong></p><pre><code>ALTERNATIVE_HASHING_THRESHOLD = threshold;</code></pre><p>⑥．解決哈希衝突的干擾因子。根據上一步中計算的配置“ALTERNATIVE_HASHING_THRESHOLD”判斷是否啟用該干擾因子。</p><pre><code>/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. If 0 then * alternative hashing is disabled. */transient int hashSeed = 0;</code></pre><p><strong>從代碼看出jdk.map.althashing.threshold這個變量設置的值最終會存放在靜態常量ALTERNATIVE_HASHING_THRESHOLD</strong></p><h1 class=pgc-h-arrow-right>3.根據初始化的HashMap容量大小，決定干擾因子的值。</h1><p><strong>源碼：</strong></p><pre><code>/**初始化哈希干擾的掩碼值，我們把它的設置延遲到了真正使用它的時候。 * Initialize the hashing mask value. We defer initialization until we * really need it. */final boolean initHashSeedAsNeeded(int capacity) {   /**判斷是否開啟了hash干擾。如果hashseed 等於 0，則currentAltHashing = false;如果hashseed 不等於 0 ，則currentAltHashing = true;**/     boolean currentAltHashing = hashSeed != 0;/** 判斷是否使用為干擾1.如果當前HashMap數組容量的大小等於jdk配置    中“jdk.map.althashing.threshold”的值時候，    且VM .isbooted 為true 時候，userAltHashing 為true;2.如果當前HashMap數組容量的小於jdk配置    中“jdk.map.althashing.threshold”的值時候，    且VM .isbooted 為true 時候，userAltHashing 為false;3. 如果當前HashMap數組容量的大小等於jdk配置    中“jdk.map.althashing.threshold”的值時候，    且VM .isbooted 為false 時候，userAltHashing 為false;4. 如果當前HashMap數組容量的小於jdk配置    中“jdk.map.althashing.threshold”的值時候，    且VM .isbooted 為false 時候，userAltHashing 為false;**/    boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp;            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);/** 對以上的兩個值進行“異或”處理異或的結果為 兩個值相同為0，兩個值不同為1.也就是說 currentAltHashing 為true時且useAltHashing也為true時，或者 currentAltHashing 為false時且useAltHashing也為false時switching的結果為 true.其他情況時候，switching為false.**/    boolean switching = currentAltHashing ^ useAltHashing;    if (switching) {/**如果switching為true ，設置hashSeed(干擾因子)的值。如果useAltHashing的值為true，則隨機一個干擾值給HashSeed。否則賦值為0.**/         hashSeed = useAltHashing            ? sun.misc.Hashing.randomHashSeed(this)            : 0;    }//返回是否啟用干擾因子    return switching;}</code></pre><p><strong>源碼解讀：</strong></p><p><strong class=highlight-text>當hashMap擴大容量時，都是調用該方法。從代碼可以看出，當數組容量超過，我們設定的值ALTERNATIVE_HASHING_THRESHOLD且是vm booted，同時 hashSeed==0的時候，hashSeed的值就是用隨機量，而不是固定的等於0。這樣就能降低碰撞，就能降低演化成鏈表概率。</strong></p><p><strong>代碼具體過程：</strong></p><pre><code>當 hashSeed==0 則 currentAltHashing=false當 capacity &lt; Holder.ALTERNATIVE_HASHING_THRESHOLD 則currentAltHashing =false結果:switching=false 當 hashSeed==0 則 currentAltHashing=false當 capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD  則 currentAltHashing =true結果:switching=true  當 hashSeed !=0 則 currentAltHashing=true當 capacity &lt; Holder.ALTERNATIVE_HASHING_THRESHOLD  則 currentAltHashing =false結果:當 switching=true 當 hashSeed !=0 則 currentAltHashing=true當 capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD  則 currentAltHashing =true結果:switching=false</code></pre><p>回頭再看代碼，發現很巧妙</p><p>結論：</p><p>①.如果不配置“jdk.map.althashing.threshold”,則HashMap中的私有靜態內部類中的’ALTERNATIVE_HASHING_THRESHOLD‘的值為Integer.MAX_VALUE，且HashSeed默認值為0，則switching的值永遠為false，也就永遠不會改變干擾因子（HashSeed）的值。</p><p>②．如果配置了“jdk.map.althashing.threshold”,則會根據當前HashMap中的數組容量動態的變更HashSeed的值，以便於引入HashSeed降低哈希衝突。</p><p>-Djdk.map.althashing.threshold=-1:表示不做優化（不配置這個值作用一樣）<br>-Djdk.map.althashing.threshold&lt;0:報錯</p><p>-Djdk.map.althashing.threshold=1:表示總是啟用隨機HashSeed<br>-Djdk.map.althashing.threshold>=0:便是hashMap內部的數組長度超過該值了就使用隨機HashSeed，降低碰撞</p><h1 class=pgc-h-arrow-right>4.獲取key的Hash值，位干擾。</h1><p><strong>源碼：</strong></p><pre><code>/** * Retrieve object hash code and applies a supplemental hash function to the * result hash, which defends against poor quality hash functions.  This is * critical because HashMap uses power-of-two length hash tables, that * otherwise encounter collisions for hashCodes that do not differ * in lower bits. Note: Null keys always map to hash 0, thus index 0. */final int hash(Object k) {/** 獲取哈希干擾因子，該因子會跟根據HashMap的容量進行變更變更情況根據上一步的“final boolean initHashSeedAsNeeded(int capacity)”方法動態變更**/     int h = hashSeed;//如果為干擾因子不為0，且傳入的key類型為String,則使用特定的算法（sun.misc.Hashing.stringHash32((String) k)）對該key進行hash計算。並返回    if (0 != h &amp;&amp; k instanceof String) {        return sun.misc.Hashing.stringHash32((String) k);    }//如果哈希干擾因子為0 或者 k的類型不為String則使用異或操作變更key的hashcode    h ^= k.hashCode();//為了減少Hash衝突出現次數進行必要的位干擾，默認負載因子是8.    // This function ensures that hashCodes that differ only by    // constant multiples at each bit position have a bounded    // number of collisions (approximately 8 at default load factor).    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}</code></pre><p><strong>源碼解讀：</strong></p><p>可以看出生成的hash值和hashSeed 這個值有著緊密的關係，但是這個值默認是0。也就是說不管HashMap存多少數據，hashSeed 都是不會變的，可以看出隨著hashMap 的容量增大，hash碰撞的概率增大的可能性也就增大。如果hash值，碰撞很高的話，那麼hashMap逐漸演化成鏈表，性能就急劇下降。</p><p>在hash(Object k)中有這麼一段位運算的代碼：</p><pre><code>h ^= k.hashCode();h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</code></pre><p>看起來既簡單又深奧的樣子，讓我們來看看這段代碼隱藏的東西吧。</p><p>k.hashCode()函數調用的是key鍵值類型自帶的哈希函數，由於不同的對象其hashCode()有可能相同，所以需對hashCode()再次哈希，以降低相同率。</p><p>接下來的一串與運算和異或運算，稱之為“擾動函數”，擾動的核心思想在於使計算出來的值在保留原有相關特性的基礎上，增加其值的不確定性，從而降低衝突的概率。不同的版本實現的方式不一樣，但其根本思想是一致的。<br>這裡的具體實現方式是如何保證的呢？筆者功力淺薄，暫時還沒有答案，如果有朋友知道的話可以交流。但是，“擾動函數”的核心思想一定要明白。</p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/af6b4034b7db48f0907aff6d641e490c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>往期文章鏈接</h1><p><strong>Java集合</strong></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6876269894007161348/?group_id=6876269894007161348?group_id=6876269894007161348" rel="noopener noreferrer" target=_blank>一、深入理解-Java集合初篇</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877007182232027655/?group_id=6877007182232027655?group_id=6877007182232027655" rel="noopener noreferrer" target=_blank>二、Jdk1.7和1.8中HashMap數據結構及源碼分析</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877050052326457860/?group_id=6877050052326457860?group_id=6877050052326457860" rel="noopener noreferrer" target=_blank>二、JDK1.7和1.8HashMap數據結構及源碼分析-續</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877362834460639757/?group_id=6877362834460639757?group_id=6877362834460639757" rel="noopener noreferrer" target=_blank>三、深入理解Java中的HashMap「網易面試快答」</a></p><p><br></p><p><strong>Java-IO體系</strong></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6873764446930633230/?group_id=6873764446930633230" rel="noopener noreferrer" target=_blank>一、JAVA IO/NIO體系介紹</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6873765094426313219/?group_id=6873765094426313219" rel="noopener noreferrer" target=_blank>二、網絡IO原理-創建ServerSocket-徹底弄懂IO</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6873765826462220814/?group_id=6873765826462220814" rel="noopener noreferrer" target=_blank>三、JAVA中ServerSocket調用Linux系統內核</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6874772531308724750/?group_id=6874772531308724750" rel="noopener noreferrer" target=_blank>四、「大廠職員教你」IO進化過程之BIO</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6874782223262810635/?group_id=6874782223262810635" rel="noopener noreferrer" target=_blank>五、「大廠職員教你」Java-IO進化過程之NIO</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6875153531486077448/?group_id=6875153531486077448" rel="noopener noreferrer" target=_blank>六、Selector實現Netty中Reactor單線程模型</a></p><p><br><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6875498967183032840/?group_id=6875498967183032840" rel="noopener noreferrer" target=_blank>七、Selector實現Netty中Reactor主從模型</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6875960048917414407/?group_id=6875960048917414407" rel="noopener noreferrer" target=_blank>八、Netty入門服務端代碼</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877376837149065741/?group_id=6877376837149065741" rel="noopener noreferrer" target=_blank>九、IO進化過程之EVENT（EPOLL-事件驅動異步模型）</a></p><p>如需瞭解更多更詳細內容也可關注本人CSDN博客：<strong>不吃_花椒</strong></p><h1 class=pgc-h-arrow-right>Java集合還需要學習的內容</h1><p><br></p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/525daadbc273400c9608cc01da77bed7><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4c1effd30384d50974b96b130200436><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/21837c954b8b448fab8a03b1a0bbe55c><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JDK1.7</a></li><li><a>HashMap</a></li><li><a>哈希</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html alt=C++哈希表是如何解決衝突的? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ac4410086e640ea82846bde1dd72c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html title=C++哈希表是如何解決衝突的?>C++哈希表是如何解決衝突的?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html alt=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/54d45b20ef6a4a3f960411db61474538 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html title=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到>java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c835605d.html alt=互聯網公司面試經，你不得不知道的哈希 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/80891c3b3b5d4f04b84078744a653aeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c835605d.html title=互聯網公司面試經，你不得不知道的哈希>互聯網公司面試經，你不得不知道的哈希</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/01b66ad2.html alt="漫畫 | 什麼是散列表（哈希表）？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e8a38bd3470c4c06befa051c4adbf665 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/01b66ad2.html title="漫畫 | 什麼是散列表（哈希表）？">漫畫 | 什麼是散列表（哈希表）？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b312402f.html alt=程序員面試中常見的哈希表，到底是什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35e957fe50484e03a497b640373bc5ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b312402f.html title=程序員面試中常見的哈希表，到底是什麼？>程序員面試中常見的哈希表，到底是什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/92675aff.html alt=關於哈希表，你該瞭解這些 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d18861a74ac4577abd03b0064a1016b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92675aff.html title=關於哈希表，你該瞭解這些>關於哈希表，你該瞭解這些</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/21474a0e.html alt=一張圖搞定對哈希表的理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a49c66caf9044e7b086f48696b04283 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/21474a0e.html title=一張圖搞定對哈希表的理解>一張圖搞定對哈希表的理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html alt="為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6cbd09e4427c44c082e15ec40e24b6f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html title="為什麼 HashMap 的加載因子是0.75？">為什麼 HashMap 的加載因子是0.75？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>