<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 | 极客快訊</title><meta property="og:title" content="全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/ecdce8a25bde4964bbfb879fdb8f6e5f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5bf32589.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5bf32589.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5bf32589.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5bf32589.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5bf32589.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5bf32589.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5bf32589.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5bf32589.html><meta property="article:published_time" content="2020-11-14T21:04:16+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:16+08:00"><meta name=Keywords content><meta name=description content="全網分析HTTP協議最全的一篇文章，程序員趕緊收藏"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5bf32589.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>全網分析HTTP協議最全的一篇文章，程序員趕緊收藏</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>專注於Java領域優質技術，歡迎關注</p></blockquote><p>作者：滌生_Woo</p><p>本篇文章篇幅比較長，先來個思維導圖預覽一下。</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ecdce8a25bde4964bbfb879fdb8f6e5f><p class=pgc-img-caption>一張圖帶你看完本篇文章</p></div><h1><strong>一、概述</strong></h1><p><strong>1.計算機網絡體系結構分層</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8e81c5252793448db82e3a40523244d4><p class=pgc-img-caption>計算機網絡體系結構分層</p></div><p><strong>2.TCP/IP 通信傳輸流</strong></p><p>利用 TCP/IP 協議族進行網絡通信時，會通過分層順序與對方進行通信。發送端從應用層往下走，接收端則從鏈路層往上走。如下：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2aab1253fc8a48a19191347dc0b9ec18><p class=pgc-img-caption>TCP/IP 通信傳輸流</p></div><ul><li>首先作為發送端的客戶端在應用層（HTTP 協議）發出一個想看某個 Web 頁面的 HTTP 請求。</li><li>接著，為了傳輸方便，在傳輸層（TCP 協議）把從應用層處收到的數據（HTTP 請求報文）進行分割，並在各個報文上打上標記序號及端口號後轉發給網絡層。</li><li>在網絡層（IP 協議），增加作為通信目的地的 MAC 地址後轉發給鏈路層。這樣一來，發往網絡的通信請求就準備齊全了。</li><li>接收端的服務器在鏈路層接收到數據，按序往上層發送，一直到應用層。當傳輸到應用層，才能算真正接收到由客戶端發送過來的 HTTP請求。</li></ul><p>如下圖所示：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7410425444574b90895fb0039bbe96c1><p class=pgc-img-caption>HTTP 請求</p></div><p>在網絡體系結構中，包含了眾多的網絡協議，這篇文章主要圍繞 HTTP 協議（HTTP/1.1版本）展開。</p><pre>HTTP協議（HyperText Transfer Protocol，超文本傳輸協議）是用於從WWW服務器傳輸超文本到本地瀏覽器的傳輸協議。它可以使瀏覽器更加高效，使網絡傳輸減少。它不僅保證計算機正確快速地傳輸超文本文檔，還確定傳輸文檔中的哪一部分，以及哪部分內容首先顯示(如文本先於圖形)等。 HTTP是客戶端瀏覽器或其他程序與Web服務器之間的應用層通信協議。在Internet上的Web服務器上存放的都是超文本信息，客戶機需要通過HTTP協議傳輸所要訪問的超文本信息。HTTP包含命令和傳輸信息，不僅可用於Web訪問，也可以用於其他因特網/內聯網應用系統之間的通信，從而實現各類應用資源超媒體訪問的集成。 我們在瀏覽器的地址欄裡輸入的網站地址叫做URL (Uniform Resource Locator，統一資源定位符)。就像每家每戶都有一個門牌地址一樣，每個網頁也都有一個Internet地址。當你在瀏覽器的地址框中輸入一個URL或是單擊一個超級鏈接時，URL就確定了要瀏覽的地址。瀏覽器通過超文本傳輸協議(HTTP)，將Web服務器上站點的網頁代碼提取出來，並翻譯成漂亮的網頁。</pre><h1><strong>二、HTTP 工作過程</strong></h1><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe28de314ff04bf4aff165858d115c51><p class=pgc-img-caption>HTTP請求響應模型</p></div><p>HTTP通信機制是在一次完整的 HTTP 通信過程中，客戶端與服務器之間將完成下列7個步驟：</p><p><strong>1 建立 TCP 連接</strong></p><p>在HTTP工作開始之前，客戶端首先要通過網絡與服務器建立連接，該連接是通過 TCP 來完成的，該協議與 IP 協議共同構建 Internet，即著名的 TCP/IP 協議族，因此 Internet 又被稱作是 TCP/IP 網絡。HTTP 是比 TCP 更高層次的應用層協議，根據規則，只有低層協議建立之後，才能進行高層協議的連接，因此，首先要建立 TCP 連接，一般 TCP 連接的端口號是80；</p><p><strong>2 客戶端向服務器發送請求命令</strong></p><p>一旦建立了TCP連接，客戶端就會向服務器發送請求命令；</p><p>例如：GET/sample/hello.jsp HTTP/1.1</p><p><strong>3 客戶端發送請求頭信息</strong></p><p>客戶端發送其請求命令之後，還要以頭信息的形式向服務器發送一些別的信息，之後客戶端發送了一空白行來通知服務器，它已經結束了該頭信息的發送；</p><p><strong>4 服務器應答</strong></p><p>客戶端向服務器發出請求後，服務器會客戶端返回響應；</p><p>例如： HTTP/1.1 200 OK</p><p>響應的第一部分是協議的版本號和響應狀態碼</p><p><strong>5 服務器返回響應頭信息</strong></p><p>正如客戶端會隨同請求發送關於自身的信息一樣，服務器也會隨同響應向用戶發送關於它自己的數據及被請求的文檔；</p><p><strong>6 服務器向客戶端發送數據</strong></p><p>服務器向客戶端發送頭信息後，它會發送一個空白行來表示頭信息的發送到此為結束，接著，它就以 Content-Type 響應頭信息所描述的格式發送用戶所請求的實際數據；</p><p><strong>7 服務器關閉 TCP 連接</strong></p><p>一般情況下，一旦服務器向客戶端返回了請求數據，它就要關閉 TCP 連接，然後如果客戶端或者服務器在其頭信息加入了這行代碼 Connection:keep-alive ，TCP 連接在發送後將仍然保持打開狀態，於是，客戶端可以繼續通過相同的連接發送請求。保持連接節省了為每個請求建立新連接所需的時間，還節約了網絡帶寬。</p><h1><strong>三、HTTP 協議基礎</strong></h1><p><strong>1.通過請求和響應的交換達成通信</strong></p><p>應用 HTTP 協議時，必定是一端擔任客戶端角色，另一端擔任服務器端角色。僅從一條通信線路來說，服務器端和客服端的角色是確定的。HTTP 協議規定，請求從客戶端發出，最後服務器端響應該請求並返回。<strong>換句話說，肯定是先從客戶端開始建立通信的，服務器端在沒有接收到請求之前不會發送響應。</strong></p><p><strong>2.HTTP 是不保存狀態的協議</strong></p><p>HTTP 是一種無狀態協議。協議自身不對請求和響應之間的通信狀態進行保存。也就是說在 HTTP 這個級別，協議對於發送過的請求或響應都不做持久化處理。這是為了更快地處理大量事務，確保協議的可伸縮性，而特意把 HTTP 協議設計成如此簡單的。</p><p>可是隨著 Web 的不斷髮展，我們的很多業務都需要對通信狀態進行保存。於是我們引入了 Cookie 技術。有了 Cookie 再用 HTTP 協議通信，就可以管理狀態了。</p><p><strong>3.使用 Cookie 的狀態管理</strong></p><p>Cookie 技術通過在請求和響應報文中寫入 Cookie 信息來控制客戶端的狀態。Cookie 會根據從服務器端發送的響應報文內的一個叫做 Set-Cookie 的首部字段信息，通知客戶端保存Cookie。當下次客戶端再往該服務器發送請求時，客戶端會自動在請求報文中加入 Cookie 值後發送出去。服務器端發現客戶端發送過來的 Cookie 後，會去檢查究竟是從哪一個客戶端發來的連接請求，然後對比服務器上的記錄，最後得到之前的狀態信息。</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ea444bb8712a4d418140c4b648a30ce2><p class=pgc-img-caption>Cookie 的流程</p></div><p><strong>4.請求 URI 定位資源</strong></p><p>HTTP 協議使用 URI 定位互聯網上的資源。正是因為 URI 的特定功能，在互聯網上任意位置的資源都能訪問到。</p><p><strong>5.告知服務器意圖的 HTTP 方法（HTTP/1.1）</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5e1873a6e9574a599012468afb9ef977><p class=pgc-img-caption>HTTP 方法</p></div><p><strong>6.持久連接</strong></p><p>HTTP 協議的初始版本中，每進行一個 HTTP 通信都要斷開一次 TCP 連接。比如使用瀏覽器瀏覽一個包含多張圖片的 HTML 頁面時，在發送請求訪問 HTML 頁面資源的同時，也會請求該 HTML 頁面裡包含的其他資源。因此，每次的請求都會造成無畏的 TCP 連接建立和斷開，增加通信量的開銷。</p><p>為了解決上述 TCP 連接的問題，HTTP/1.1 和部分 HTTP/1.0 想出了持久連接的方法。<strong>其特點是，只要任意一端沒有明確提出斷開連接，則保持 TCP 連接狀態。旨在建立一次 TCP 連接後進行多次請求和響應的交互。</strong>在 HTTP/1.1 中，所有的連接默認都是持久連接。</p><p><strong>7.管線化</strong></p><p>持久連接使得多數請求以管線化方式發送成為可能。以前發送請求後需等待並接收到響應，才能發送下一個請求。管線化技術出現後，不用等待亦可發送下一個請求。這樣就能做到同時並行發送多個請求，而不需要一個接一個地等待響應了。</p><p>比如，當請求一個包含多張圖片的 HTML 頁面時，與挨個連接相比，用持久連接可以讓請求更快結束。而管線化技術要比持久連接速度更快。請求數越多，時間差就越明顯。</p><h1><strong>四、HTTP 協議報文結構</strong></h1><p><strong>1.HTTP 報文</strong></p><p>用於 HTTP 協議交互的信息被稱為 HTTP 報文。請求端（客戶端）的 HTTP 報文叫做請求報文；響應端（服務器端）的叫做響應報文。HTTP 報文本身是由多行（用 CR+LF 作換行符）數據構成的字符串文本。</p><p><strong>2.HTTP 報文結構</strong></p><p>HTTP 報文大致可分為報文首部和報文主體兩部分。兩者由最初出現的空行（CR+LF）來劃分。通常，並不一定有報文主體。如下：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/21587b8589884ebc8db764f7859d4763><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9f69bcb9a27c40b2a6566d144b66cc0a><p class=pgc-img-caption>HTTP 報文結構</p></div><p><strong>2.1請求報文結構</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d8a1f9504f14a4e9c4e2eb87a2f5288><p class=pgc-img-caption>請求報文結構</p></div><p>請求報文的首部內容由以下數據組成：</p><ul><li><strong>請求行</strong> —— 包含用於請求的方法、請求 URI 和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示請求的各種條件和屬性的各類首部。（通用首部、請求首部、實體首部以及RFC裡未定義的首部如 Cookie 等）</li></ul><p>請求報文的示例，如下：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7109640dac34c1e9a6bd620f135ec58><p class=pgc-img-caption>請求報文示例</p></div><p><strong>2.2響應報文結構</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/615c8f0dc2a24f9fbce783fdbd18c9c9><p class=pgc-img-caption>響應報文結構</p></div><p>響應報文的首部內容由以下數據組成：</p><ul><li><strong>狀態行</strong> —— 包含表明響應結果的狀態碼、原因短語和 HTTP 版本。</li><li><strong>首部字段</strong> —— 包含表示請求的各種條件和屬性的各類首部。（通用首部、響應首部、實體首部以及RFC裡未定義的首部如 Cookie 等）</li></ul><p>響應報文的示例，如下：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/80eaef8d0c704b8aaedb8a203581c0fb><p class=pgc-img-caption>響應報文示例</p></div><h1><strong>五、HTTP 報文首部之請求行、狀態行</strong></h1><p><strong>1.請求行</strong></p><p>舉個栗子，下面是一個 HTTP 請求的報文：</p><pre>GET /index.htm HTTP/1.1Host: sample.com</pre><p>其中，下面的這行就是請求行，</p><pre>GET /index.htm HTTP/1.1</pre><ul><li>開頭的 GET 表示請求訪問服務器的類型，稱為方法；</li><li>隨後的字符串 /index.htm 指明瞭請求訪問的資源對象，也叫做請求 URI；</li><li>最後的 HTTP/1.1，即 HTTP 的版本號，用來提示客戶端使用的 HTTP 協議功能。</li></ul><p>綜合來看，大意是請求訪問某臺 HTTP 服務器上的 /index.htm 頁面資源。</p><p><strong>2.狀態行</strong></p><p>同樣舉個栗子，下面是一個 HTTP 響應的報文：</p><pre>HTTP/1.1 200 OKDate: Mon, 10 Jul 2017 15:50:06 GMTContent-Length: 256Content-Type: text/html &lt;html&gt;...</pre><p>其中，下面的這行就是狀態行，</p><pre>HTTP/1.1 200 OK</pre><ul><li>開頭的 HTTP/1.1 表示服務器對應的 HTTP 版本；</li><li>緊挨著的 200 OK 表示請求的處理結果的狀態碼和原因短語。</li></ul><h1><strong>六、HTTP 報文首部之首部字段（重點分析）</strong></h1><p><strong>1.首部字段概述</strong></p><p>先來回顧一下首部字段在報文的位置，HTTP 報文包含報文首部和報文主體，報文首部包含請求行（或狀態行）和首部字段。</p><p>在報文眾多的字段當中，HTTP 首部字段包含的信息最為豐富。首部字段同時存在於請求和響應報文內，並涵蓋 HTTP 報文相關的內容信息。使用首部字段是為了給客服端和服務器端提供報文主體大小、所使用的語言、認證信息等內容。</p><p><strong>2.首部字段結構</strong></p><ul><li>HTTP 首部字段是由首部字段名和字段值構成的，中間用冒號“：”分隔。</li><li>另外，字段值對應單個 HTTP 首部字段可以有多個值。</li><li>當 HTTP 報文首部中出現了兩個或以上具有相同首部字段名的首部字段時，這種情況在規範內尚未明確，根據瀏覽器內部處理邏輯的不同，優先處理的順序可能不同，結果可能並不一致。</li></ul><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e090c859da5b4a2cbfb9b7acde6bb34e><p class=pgc-img-caption></p></div><p><strong>3.首部字段類型</strong></p><p>首部字段根據實際用途被分為以下4種類型：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc9ff10c796c432ba915d972192d306c><p class=pgc-img-caption></p></div><p><strong>4.通用首部字段（HTTP/1.1）</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/89f4b94cd8764df98ca0811bcb8d94cf><p class=pgc-img-caption></p></div><p><strong>4.1 Cache-Control</strong></p><p>通過指定首部字段 Cache-Control 的指令，就能操作緩存的工作機制。</p><p><strong>4.1.1 可用的指令一覽</strong></p><p>可用的指令按請求和響應分類如下：</p><p><strong>緩存請求指令</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/56546169f3d6460b9fa69a45cc982642><p class=pgc-img-caption></p></div><p><strong>緩存響應指令</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/173ef5b30b6343df84edb9a145728840><p class=pgc-img-caption></p></div><p><strong>4.1.2 表示能否緩存的指令</strong></p><p><strong>public 指令</strong></p><pre> Cache-Control: public</pre><p>當指定使用 public 指令時，則明確表明其他用戶也可利用緩存。</p><p><strong>private 指令</strong></p><pre> Cache-Control: private</pre><p>當指定 private 指令後，響應只以特定的用戶作為對象，這與 public 指令的行為相反。緩存服務器會對該特定用戶提供資源緩存的服務，對於其他用戶發送過來的請求，代理服務器則不會返回緩存。</p><p><strong>no-cache 指令</strong></p><pre> Cache-Control: no-cache</pre><ul><li>使用 no-cache 指令是為了防止從緩存中返回過期的資源。</li><li>客戶端發送的請求中如果包含 no-cache 指令，則表示客戶端將不會接收緩存過的響應。於是，“中間”的緩存服務器必須把客戶端請求轉發給源服務器。</li><li>如果服務器中返回的響應包含 no-cache 指令，那麼緩存服務器不能對資源進行緩存。源服務器以後也將不再對緩存服務器請求中提出的資源有效性進行確認，且禁止其對響應資源進行緩存操作。</li></ul><pre>Cache-Control: no-cache=Location</pre><p>由服務器返回的響應中，若報文首部字段 Cache-Control 中對 no-cache 字段名具體指定參數值，那麼客戶端在接收到這個被指定參數值的首部字段對應的響應報文後，就不能使用緩存。換言之，無參數值的首部字段可以使用緩存。只能在響應指令中指定該參數。</p><p><strong>no-store 指令</strong></p><pre> Cache-Control: no-store</pre><p>當使用 no-store 指令時，暗示請求（和對應的響應）或響應中包含機密信息。因此，該指令規定緩存不能在本地存儲請求或響應的任一部分。</p><p>注意：no-cache 指令代表不緩存過期的指令，緩存會向源服務器進行有效期確認後處理資源；no-store 指令才是真正的不進行緩存。</p><p><strong>4.1.3 指定緩存期限和認證的指令</strong></p><p><strong>s-maxage 指令</strong></p><pre> Cache-Control: s-maxage=604800（單位：秒）</pre><ul><li>s-maxage 指令的功能和 max-age 指令的相同，它們的不同點是 s-maxage 指令只適用於供多位用戶使用的公共緩存服務器（一般指代理）。也就是說，對於向同一用戶重複返回響應的服務器來說，這個指令沒有任何作用。</li><li>另外，當使用 s-maxage 指令後，則直接忽略對 Expires 首部字段及 max-age 指令的處理。</li></ul><p><strong>max-age 指令</strong></p><pre> Cache-Control: max-age=604800（單位：秒）</pre><ul><li>當客戶端發送的請求中包含 max-age 指令時，如果判定緩存資源的緩存時間數值比指定的時間更小，那麼客戶端就接收緩存的資源。另外，當指定 max-age 的值為0，那麼緩存服務器通常需要將請求轉發給源服務器。</li><li>當服務器返回的響應中包含 max-age 指令時，緩存服務器將不對資源的有效性再作確認，而 max-age 數值代表資源保存為緩存的最長時間。</li><li>應用 HTTP/1.1 版本的緩存服務器遇到同時存在 Expires 首部字段的情況時，會優先處理 max-age 指令，並忽略掉 Expires 首部字段；而 HTTP/1.0 版本的緩存服務器則相反。</li></ul><p><strong>min-fresh 指令</strong></p><pre> Cache-Control: min-fresh=60（單位：秒）</pre><p>min-fresh 指令要求緩存服務器返回至少還未過指定時間的緩存資源。</p><p><strong>max-stale 指令</strong></p><p>Cache-Control: max-stale=3600（單位：秒）</p><ul><li>使用 max-stale 可指示緩存資源，即使過期也照常接收。</li><li>如果指令未指定參數值，那麼無論經過多久，客戶端都會接收響應；如果指定了具體參數值，那麼即使過期，只要仍處於 max-stale 指定的時間內，仍舊會被客戶端接收。</li></ul><p><strong>only-if-cached 指令</strong></p><pre> Cache-Control: only-if-cached</pre><p>表示客戶端僅在緩存服務器本地緩存目標資源的情況下才會要求其返回。換言之，該指令要求緩存服務器不重新加載響應，也不會再次確認資源的有效性。</p><p><strong>must-revalidate 指令</strong></p><pre> Cache-Control: must-revalidate</pre><p>使用 must-revalidate 指令，代理會向源服務器再次驗證即將返回的響應緩存目前是否仍有效。另外，使用 must-revalidate 指令會忽略請求的 max-stale 指令。</p><p><strong>proxy-revalidate 指令</strong></p><pre> Cache-Control: proxy-revalidate</pre><p>proxy-revalidate 指令要求所有的緩存服務器在接收到客戶端帶有該指令的請求返回響應之前，必須再次驗證緩存的有效性。</p><p><strong>no-transform 指令</strong></p><pre> Cache-Control: no-transform</pre><p>使用 no-transform 指令規定無論是在請求還是響應中，緩存都不能改變實體主體的媒體類型。這樣做可防止緩存或代理壓縮圖片等類似操作。</p><p><strong>4.1.4 Cache-Control 擴展</strong></p><pre>Cache-Control: private, community="UCI"</pre><p>通過 cache-extension 標記（token），可以擴展 Cache-Control 首部字段內的指令。上述 community 指令即擴展的指令，如果緩存服務器不能理解這個新指令，就會直接忽略掉。</p><p><strong>4.2 Connection</strong></p><p>Connection 首部字段具備以下兩個作用：</p><p><strong>控制不再轉發的首部字段</strong></p><pre> Connection: Upgrade</pre><p>在客戶端發送請求和服務器返回響應中，使用 Connection 首部字段，可控制不再轉發給代理的首部字段，即刪除後再轉發（即Hop-by-hop首部）。</p><p><strong>管理持久連接</strong></p><pre> Connection: close</pre><p>HTTP/1.1 版本的默認連接都是持久連接。當服務器端想明確斷開連接時，則指定 Connection 首部字段的值為 close。</p><pre> Connection: Keep-Alive</pre><p>HTTP/1.1 之前的 HTTP 版本的默認連接都是非持久連接。為此，如果想在舊版本的 HTTP 協議上維持持續連接，則需要指定 Connection 首部字段的值為 Keep-Alive。</p><p><strong>4.3 Date</strong></p><p>表明創建 HTTP 報文的日期和時間。</p><pre> Date: Mon, 10 Jul 2017 15:50:06 GMT</pre><p>HTTP/1.1 協議使用在 RFC1123 中規定的日期時間的格式。</p><p><strong>4.4 Pragma</strong></p><p>Pragma 首部字段是 HTTP/1.1 版本之前的歷史遺留字段，僅作為與 HTTP/1.0 的向後兼容而定義。</p><pre> Pragma: no-cache</pre><ul><li>該首部字段屬於通用首部字段，但只用在客戶端發送的請求中，要求所有的中間服務器不返回緩存的資源。</li><li>所有的中間服務器如果都能以 HTTP/1.1 為基準，那直接採用 Cache-Control: no-cache 指定緩存的處理方式最為理想。但是要整體掌握所有中間服務器使用的 HTTP 協議版本卻是不現實的，所以，發送的請求會同時包含下面兩個首部字段：</li></ul><pre>Cache-Control: no-cachePragma: no-cache</pre><p><strong>4.5 Trailer</strong></p><pre>Trailer: Expires</pre><p>首部字段 Trailer 會事先說明在報文主體後記錄了哪些首部字段。可應用在 HTTP/1.1 版本分塊傳輸編碼時。</p><p><strong>4.6 Transfer-Encoding</strong></p><pre>Transfer-Encoding: chunked</pre><ul><li>規定了傳輸報文主體時採用的編碼方式。</li><li>HTTP/1.1 的傳輸編碼方式僅對分塊傳輸編碼有效。</li></ul><p><strong>4.7 Upgrade</strong></p><pre>Upgrade: TSL/1.0</pre><p>用於檢測 HTTP 協議及其他協議是否可使用更高的版本進行通信，其參數值可以用來指定一個完全不同的通信協議。</p><p><strong>4.8 Via</strong></p><pre>Via: 1.1 a1.sample.com(Squid/2.7)</pre><ul><li>為了追蹤客戶端和服務器端之間的請求和響應報文的傳輸路徑。</li><li>報文經過代理或網關時，會現在首部字段 Via 中附加該服務器的信息，然後再進行轉發。</li><li>首部字段 Via 不僅用於追蹤報文的轉發，還可避免請求迴環的發生。</li></ul><p><strong>4.9 Warning</strong></p><p>該首部字段通常會告知用戶一些與緩存相關的問題的警告。</p><p>Warning 首部字段的格式如下：</p><p>Warning：[警告碼][警告的主機:端口號] "[警告內容]"([日期時間])</p><p>最後的日期時間可省略。</p><p>HTTP/1.1 中定義了7種警告，警告碼對應的警告內容僅推薦參考，另外，警告碼具備擴展性，今後有可能追加新的警告碼。</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b41dffd7084406da101a79668932a93><p class=pgc-img-caption></p></div><p><strong>5. 請求首部字段（HTTP/1.1）</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/742bcf6c124448e0b4cea679d3db5fed><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/05723f26ea414ab5b2ae006d82fdc56e><p class=pgc-img-caption></p></div><p><strong>5.1 Accept</strong></p><pre>Accept: text/html, application/xhtml+xml, application/xml; q=0.5</pre><ul><li>Accept 首部字段可通知服務器，用戶代理能夠處理的媒體類型及媒體類型的相對優先級。可使用 type/subtype 這種形式，一次指定多種媒體類型。</li><li>若想要給顯示的媒體類型增加優先級，則使用 q=[數值] 來表示權重值，用分號（;）進行分隔。權重值的範圍 0~1（可精確到小數點後三位），且 1 為最大值。不指定權重值時，默認為 1。</li></ul><p><strong>5.2 Accept-Charset</strong></p><pre>Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</pre><p>Accept-Charset 首部字段可用來通知服務器用戶代理支持的字符集及字符集的相對優先順序。另外，可一次性指定多種字符集。同樣使用 q=[數值] 來表示相對優先級。</p><p><strong>5.3 Accept-Encoding</strong></p><pre>Accept-Encoding: gzip, deflate</pre><p>Accept-Encoding 首部字段用來告知服務器用戶代理支持的內容編碼及內容編碼的優先順序，並可一次性指定多種內容編碼。同樣使用 q=[數值] 來表示相對優先級。也可使用星號（*）作為通配符，指定任意的編碼格式。</p><p><strong>5.4 Accept-Language</strong></p><pre>Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3</pre><p>告知服務器用戶代理能夠處理的自然語言集（指中文或英文等），以及自然語言集的相對優先級，可一次性指定多種自然語言集。同樣使用 q=[數值] 來表示相對優先級。</p><p><strong>5.5 Authorization</strong></p><pre>Authorization: Basic ldfKDHKfkDdasSAEdasd==</pre><p>告知服務器用戶代理的認證信息（證書值）。通常，想要通過服務器認證的用戶代理會在接收到返回的 401 狀態碼響應後，把首部字段 Authorization 加入請求中。共用緩存在接收到含有 Authorization 首部字段的請求時的操作處理會略有差異。</p><p><strong>5.6 Expect</strong></p><pre>Expect: 100-continue</pre><p>告知服務器客戶端期望出現的某種特定行為。</p><p><strong>5.7 From</strong></p><pre>From: Deeson_Woo@163.com</pre><p>告知服務器使用用戶代理的電子郵件地址。</p><p><strong>5.8 Host</strong></p><pre>Host: www.jianshu.com</pre><ul><li>告知服務器，請求的資源所處的互聯網主機和端口號。</li><li><strong>Host 首部字段是 HTTP/1.1 規範內唯一一個必須被包含在請求內的首部字段。</strong></li><li>若服務器未設定主機名，那直接發送一個空值即可 Host: 。</li></ul><p><strong>5.9 If-Match</strong></p><p>形如 If-xxx 這種樣式的請求首部字段，都可稱為條件請求。服務器接收到附帶條件的請求後，只有判斷指定條件為真時，才會執行請求。</p><pre>If-Match: "123456"</pre><ul><li>首部字段 If-Match，屬附帶條件之一，它會告知服務器匹配資源所用的實體標記（ETag）值。這時的服務器無法使用弱 ETag 值。</li><li>服務器會比對 If-Match 的字段值和資源的 ETag 值，僅當兩者一致時，才會執行請求。反之，則返回狀態碼 412 Precondition Failed 的響應。</li><li>還可以使用星號（*）指定 If-Match 的字段值。針對這種情況，服務器將會忽略 ETag 的值，只要資源存在就處理請求。</li></ul><p><strong>5.10 If-Modified-Since</strong></p><pre>If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT</pre><ul><li>首部字段 If-Modified-Since，屬附帶條件之一，用於確認代理或客戶端擁有的本地資源的有效性。</li><li>它會告知服務器若 If-Modified-Since 字段值早於資源的更新時間，則希望能處理該請求。而在指定 If-Modified-Since 字段值的日期時間之後，如果請求的資源都沒有過更新，則返回狀態碼 304 Not Modified 的響應。</li></ul><p><strong>5.11 If-None-Match</strong></p><pre>If-None-Match: "123456"</pre><p>首部字段 If-None-Match 屬於附帶條件之一。它和首部字段 If-Match 作用相反。用於指定 If-None-Match 字段值的實體標記（ETag）值與請求資源的 ETag 不一致時，它就告知服務器處理該請求。</p><p><strong>5.12 If-Range</strong></p><pre>If-Range: "123456"</pre><ul><li>首部字段 If-Range 屬於附帶條件之一。它告知服務器若指定的 If-Range 字段值（ETag 值或者時間）和請求資源的 ETag 值或時間相一致時，則作為範圍請求處理。反之，則返回全體資源。</li><li>下面我們思考一下不使用首部字段 If-Range 發送請求的情況。服務器端的資源如果更新，那客戶端持有資源中的一部分也會隨之無效，當然，範圍請求作為前提是無效的。這時，服務器會暫且以狀態碼 412 Precondition Failed 作為響應返回，其目的是催促客戶端再次發送請求。這樣一來，與使用首部字段 If-Range 比起來，就需要花費兩倍的功夫。</li></ul><p><strong>5.13 If-Unmodified-Since</strong></p><pre>If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT</pre><p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服務器，指定的請求資源只有在字段值內指定的日期時間之後，未發生更新的情況下，才能處理請求。如果在指定日期時間後發生了更新，則以狀態碼 412 Precondition Failed 作為響應返回。</p><p><strong>5.14 Max-Forwards</strong></p><pre>Max-Forwards: 10</pre><p>通過 TRACE 方法或 OPTIONS 方法，發送包含首部字段 Max-Forwards 的請求時，該字段以十進制整數形式指定可經過的服務器最大數目。服務器在往下一個服務器轉發請求之前，Max-Forwards 的值減 1 後重新賦值。當服務器接收到 Max-Forwards 值為 0 的請求時，則不再進行轉發，而是直接返回響應。</p><p><strong>5.15 Proxy-Authorization</strong></p><pre>Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</pre><ul><li>接收到從代理服務器發來的認證質詢時，客戶端會發送包含首部字段 Proxy-Authorization 的請求，以告知服務器認證所需要的信息。</li><li>這個行為是與客戶端和服務器之間的 HTTP 訪問認證相類似的，不同之處在於，認證行為發生在客戶端與代理之間。</li></ul><p><strong>5.16 Range</strong></p><pre>Range: bytes=5001-10000</pre><ul><li>對於只需獲取部分資源的範圍請求，包含首部字段 Range 即可告知服務器資源的指定範圍。</li><li>接收到附帶 Range 首部字段請求的服務器，會在處理請求之後返回狀態碼為 206 Partial Content 的響應。無法處理該範圍請求時，則會返回狀態碼 200 OK 的響應及全部資源。</li></ul><p><strong>5.17 Referer</strong></p><pre>Referer: http://www.sample.com/index.html</pre><p>首部字段 Referer 會告知服務器請求的原始資源的 URI。</p><p><strong>5.18 TE</strong></p><pre>TE: gzip, deflate; q=0.5</pre><ul><li>首部字段 TE 會告知服務器客戶端能夠處理響應的傳輸編碼方式及相對優先級。它和首部字段 Accept-Encoding 的功能很相像，但是用於傳輸編碼。</li><li>首部字段 TE 除指定傳輸編碼之外，還可以指定伴隨 trailer 字段的分塊傳輸編碼的方式。應用後者時，只需把 trailers 賦值給該字段值。TE: trailers</li></ul><p><strong>5.19 User-Agent</strong></p><pre>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101</pre><ul><li>首部字段 User-Agent 會將創建請求的瀏覽器和用戶代理名稱等信息傳達給服務器。</li><li>由網絡爬蟲發起請求時，有可能會在字段內添加爬蟲作者的電子郵件地址。此外，如果請求經過代理，那麼中間也很可能被添加上代理服務器的名稱。</li></ul><h1><strong>6. 響應首部字段（HTTP/1.1）</strong></h1><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/158626df9f72464baf9666430d377731><p class=pgc-img-caption></p></div><p><strong>6.1 Accept-Ranges</strong></p><pre>Accept-Ranges: bytes</pre><ul><li>首部字段 Accept-Ranges 是用來告知客戶端服務器是否能處理範圍請求，以指定獲取服務器端某個部分的資源。</li><li>可指定的字段值有兩種，可處理範圍請求時指定其為 bytes，反之則指定其為 none。</li></ul><p><strong>6.2 Age</strong></p><pre>Age: 1200</pre><ul><li>首部字段 Age 能告知客戶端，源服務器在多久前創建了響應。字段值的單位為秒。</li><li>若創建該響應的服務器是緩存服務器，Age 值是指緩存後的響應再次發起認證到認證完成的時間值。代理創建響應時必須加上首部字段 Age。</li></ul><p><strong>6.3 ETag</strong></p><pre>ETag: "usagi-1234"</pre><ul><li>首部字段 ETag 能告知客戶端實體標識。它是一種可將資源以字符串形式做唯一性標識的方式。服務器會為每份資源分配對應的 ETag 值。</li><li>另外，當資源更新時，ETag 值也需要更新。生成 ETag 值時，並沒有統一的算法規則，而僅僅是由服務器來分配。</li><li>ETag 中有強 ETag 值和弱 ETag 值之分。強 ETag 值，不論實體發生多麼細微的變化都會改變其值；弱 ETag 值只用於提示資源是否相同。只有資源發生了根本改變，產生差異時才會改變 ETag 值。這時，會在字段值最開始處附加 W/： ETag: W/"usagi-1234"。</li></ul><p><strong>6.4 Location</strong></p><pre>Location: http://www.sample.com/sample.html</pre><ul><li>使用首部字段 Location 可以將響應接收方引導至某個與請求 URI 位置不同的資源。</li><li>基本上，該字段會配合 3xx ：Redirection 的響應，提供重定向的 URI。</li><li>幾乎所有的瀏覽器在接收到包含首部字段 Location 的響應後，都會強制性地嘗試對已提示的重定向資源的訪問。</li></ul><p><strong>6.5 Proxy-Authenticate</strong></p><pre>Proxy-Authenticate: Basic realm="Usagidesign Auth"</pre><ul><li>首部字段 Proxy-Authenticate 會把由代理服務器所要求的認證信息發送給客戶端。</li><li>它與客戶端和服務器之間的 HTTP 訪問認證的行為相似，不同之處在於其認證行為是在客戶端與代理之間進行的。</li></ul><p><strong>6.6 Retry-After</strong></p><pre>Retry-After: 180</pre><ul><li>首部字段 Retry-After 告知客戶端應該在多久之後再次發送請求。主要配合狀態碼 503 Service Unavailable 響應，或 3xx Redirect 響應一起使用。</li><li>字段值可以指定為具體的日期時間（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是創建響應後的秒數。</li></ul><p><strong>6.7 Server</strong></p><pre>Server: Apache/2.2.6 (Unix) PHP/5.2.5</pre><p>首部字段 Server 告知客戶端當前服務器上安裝的 HTTP 服務器應用程序的信息。不單單會標出服務器上的軟件應用名稱，還有可能包括版本號和安裝時啟用的可選項。</p><p><strong>6.8 Vary</strong></p><pre>Vary: Accept-Language</pre><ul><li>首部字段 Vary 可對緩存進行控制。源服務器會向代理服務器傳達關於本地緩存使用方法的命令。</li><li>從代理服務器接收到源服務器返回包含 Vary 指定項的響應之後，若再要進行緩存，僅對請求中含有相同 Vary 指定首部字段的請求返回緩存。即使對相同資源發起請求，但由於 Vary 指定的首部字段不相同，因此必須要從源服務器重新獲取資源。</li></ul><p><strong>6.9 WWW-Authenticate</strong></p><pre>WWW-Authenticate: Basic realm="Usagidesign Auth"</pre><p>首部字段 WWW-Authenticate 用於 HTTP 訪問認證。它會告知客戶端適用於訪問請求 URI 所指定資源的認證方案（Basic 或是 Digest）和帶參數提示的質詢（challenge）。</p><p><strong>7. 實體首部字段（HTTP/1.1）</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5585e89bff224ceba703eb1ac8f8d508><p class=pgc-img-caption></p></div><p><strong>7.1 Allow</strong></p><pre>Allow: GET, HEAD</pre><ul><li>首部字段 Allow 用於通知客戶端能夠支持 Request-URI 指定資源的所有 HTTP 方法。</li><li>當服務器接收到不支持的 HTTP 方法時，會以狀態碼 405 Method Not Allowed 作為響應返回。與此同時，還會把所有能支持的 HTTP 方法寫入首部字段 Allow 後返回。</li></ul><p><strong>7.2 Content-Encoding</strong></p><pre>Content-Encoding: gzip</pre><ul><li>首部字段 Content-Encoding 會告知客戶端服務器對實體的主體部分選用的內容編碼方式。內容編碼是指在不丟失實體信息的前提下所進行的壓縮。</li><li>主要採用這 4 種內容編碼的方式（gzip、compress、deflate、identity）。</li></ul><p><strong>7.3 Content-Language</strong></p><pre>Content-Language: zh-CN</pre><p>首部字段 Content-Language 會告知客戶端，實體主體使用的自然語言（指中文或英文等語言）。</p><p><strong>7.4 Content-Length</strong></p><pre>Content-Length: 15000</pre><p>首部字段 Content-Length 表明了實體主體部分的大小（單位是字節）。對實體主體進行內容編碼傳輸時，不能再使用 Content-Length首部字段。</p><p><strong>7.5 Content-Location</strong></p><pre>Content-Location: http://www.sample.com/index.html</pre><p>首部字段 Content-Location 給出與報文主體部分相對應的 URI。和首部字段 Location 不同，Content-Location 表示的是報文主體返回資源對應的 URI。</p><p><strong>7.6 Content-MD5</strong></p><pre>Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</pre><p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在於檢查報文主體在傳輸過程中是否保持完整，以及確認傳輸到達。</p><p><strong>7.7 Content-Range</strong></p><pre>Content-Range: bytes 5001-10000/10000</pre><p>針對範圍請求，返回響應時使用的首部字段 Content-Range，能告知客戶端作為響應返回的實體的哪個部分符合範圍請求。字段值以字節為單位，表示當前發送部分及整個實體大小。</p><p><strong>7.8 Content-Type</strong></p><pre>Content-Type: text/html; charset=UTF-8</pre><p>首部字段 Content-Type 說明了實體主體內對象的媒體類型。和首部字段 Accept 一樣，字段值用 type/subtype 形式賦值。參數 charset 使用 iso-8859-1 或 euc-jp 等字符集進行賦值。</p><p><strong>7.9 Expires</strong></p><pre>Expires: Mon, 10 Jul 2017 15:50:06 GMT</pre><ul><li>首部字段 Expires 會將資源失效的日期告知客戶端。</li><li>緩存服務器在接收到含有首部字段 Expires 的響應後，會以緩存來應答請求，在 Expires 字段值指定的時間之前，響應的副本會一直被保存。當超過指定的時間後，緩存服務器在請求發送過來時，會轉向源服務器請求資源。</li><li>源服務器不希望緩存服務器對資源緩存時，最好在 Expires 字段內寫入與首部字段 Date 相同的時間值。</li></ul><p><strong>7.10 Last-Modified</strong></p><pre>Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT</pre><p>首部字段 Last-Modified 指明資源最終修改的時間。一般來說，這個值就是 Request-URI 指定資源被修改的時間。但類似使用 CGI 腳本進行動態數據處理時，該值有可能會變成數據最終修改時的時間。</p><p><strong>8. 為 Cookie 服務的首部字段</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a18f21b9cf894d3d8d7a9d64d7603949><p class=pgc-img-caption></p></div><p><strong>8.1 Set-Cookie</strong></p><pre>Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;</pre><p>下面的表格列舉了 Set-Cookie 的字段值。</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/11dee7b5ab1f4b8b8f22af48e28d6b3b><p class=pgc-img-caption></p></div><p><strong>8.1.1 expires 屬性</strong></p><ul><li>Cookie 的 expires 屬性指定瀏覽器可發送 Cookie 的有效期。</li><li>當省略 expires 屬性時，其有效期僅限於維持瀏覽器會話（Session）時間段內。這通常限於瀏覽器應用程序被關閉之前。</li><li>另外，一旦 Cookie 從服務器端發送至客戶端，服務器端就不存在可以顯式刪除 Cookie 的方法。但可通過覆蓋已過期的 Cookie，實現對客戶端 Cookie 的實質性刪除操作。</li></ul><p><strong>8.1.2 path 屬性</strong></p><p>Cookie 的 path 屬性可用於限制指定 Cookie 的發送範圍的文件目錄。</p><p><strong>8.1.3 domain 屬性</strong></p><ul><li>通過 Cookie 的 domain 屬性指定的域名可做到與結尾匹配一致。比如，當指定 example.com 後，除example.com 以外，www.example.com 或 www2.example.com 等都可以發送 Cookie。</li><li>因此，除了針對具體指定的多個域名發送 Cookie 之 外，不指定 domain 屬性顯得更安全。</li></ul><p><strong>8.1.4 secure 屬性</strong></p><p>Cookie 的 secure 屬性用於限制 Web 頁面僅在 HTTPS 安全連接時，才可以發送 Cookie。</p><p><strong>8.1.5 HttpOnly 屬性</strong></p><ul><li>Cookie 的 HttpOnly 屬性是 Cookie 的擴展功能，它使 JavaScript 腳本無法獲得 Cookie。其主要目的為防止跨站腳本攻擊（Cross-site scripting，XSS）對 Cookie 的信息竊取。</li><li>通過上述設置，通常從 Web 頁面內還可以對 Cookie 進行讀取操作。但使用 JavaScript 的 document.cookie 就無法讀取附加 HttpOnly 屬性後的 Cookie 的內容了。因此，也就無法在 XSS 中利用 JavaScript 劫持 Cookie 了。</li></ul><p><strong>8.2 Cookie</strong></p><pre>Cookie: status=enable</pre><p>首部字段 Cookie 會告知服務器，當客戶端想獲得 HTTP 狀態管理支持時，就會在請求中包含從服務器接收到的 Cookie。接收到多個 Cookie 時，同樣可以以多個 Cookie 形式發送。</p><p><strong>9. 其他首部字段</strong></p><p>HTTP 首部字段是可以自行擴展的。所以在 Web 服務器和瀏覽器的應用上，會出現各種非標準的首部字段。</p><p>以下是最為常用的首部字段。</p><p><strong>9.1 X-Frame-Options</strong></p><pre>X-Frame-Options: DENY</pre><p>首部字段 X-Frame-Options 屬於 HTTP 響應首部，用於控制網站內容在其他 Web 網站的 Frame 標籤內的顯示問題。其主要目的是為了防止點擊劫持（clickjacking）攻擊。首部字段 X-Frame-Options 有以下兩個可指定的字段值：</p><ul><li>DENY：拒絕</li><li>SAMEORIGIN：僅同源域名下的頁面（Top-level-browsing-context）匹配時許可。（比如，當指定 http://sample.com/sample.html 頁面為 SAMEORIGIN 時，那麼 sample.com 上所有頁面的 frame 都被允許可加載該頁面，而 example.com 等其他域名的頁面就不行了）</li></ul><p><strong>9.2 X-XSS-Protection</strong></p><pre>X-XSS-Protection: 1</pre><p>首部字段 X-XSS-Protection 屬於 HTTP 響應首部，它是針對跨站腳本攻擊（XSS）的一種對策，用於控制瀏覽器 XSS 防護機制的開關。首部字段 X-XSS-Protection 可指定的字段值如下:</p><ul><li>0 ：將 XSS 過濾設置成無效狀態</li><li>1 ：將 XSS 過濾設置成有效狀態</li></ul><p><strong>9.3 DNT</strong></p><pre>DNT: 1</pre><p>首部字段 DNT 屬於 HTTP 請求首部，其中 DNT 是 Do Not Track 的簡稱，意為拒絕個人信息被收集，是表示拒絕被精準廣告追蹤的一種方法。首部字段 DNT 可指定的字段值如下：</p><ul><li>0 ：同意被追蹤</li><li>1 ：拒絕被追蹤</li></ul><p>由於首部字段 DNT 的功能具備有效性，所以 Web 服務器需要對 DNT做對應的支持。</p><p><strong>9.4 P3P</strong></p><pre>P3P: CP="CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND</pre><p>首部字段 P3P 屬於 HTTP 響應首部，通過利用 P3P（The Platform for Privacy Preferences，在線隱私偏好平臺）技術，可以讓 Web 網站上的個人隱私變成一種僅供程序可理解的形式，以達到保護用戶隱私的目的。</p><p>要進行 P3P 的設定，需按以下操作步驟進行：</p><ul><li>步驟 1：創建 P3P 隱私</li><li>步驟 2：創建 P3P 隱私對照文件後，保存命名在 /w3c/p3p.xml</li><li>步驟 3：從 P3P 隱私中新建 Compact policies 後，輸出到 HTTP 響應中</li></ul><h1><strong>七、HTTP 響應狀態碼（重點分析）</strong></h1><p><strong>1. 狀態碼概述</strong></p><ul><li>HTTP 狀態碼負責表示客戶端 HTTP 請求的返回結果、標記服務器端的處理是否正常、通知出現的錯誤等工作。</li><li>HTTP 狀態碼如 200 OK ，以 3 位數字和原因短語組成。數字中的第一位指定了響應類別，後兩位無分類。</li><li>不少返回的響應狀態碼都是錯誤的，但是用戶可能察覺不到這點。比如 Web 應用程序內部發生錯誤，狀態碼依然返回 200 OK。</li></ul><p><strong>2. 狀態碼類別</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9970d1363dc0471eba845e50e7b4b8ed><p class=pgc-img-caption></p></div><p>我們可以自行改變 RFC2616 中定義的狀態碼或者服務器端自行創建狀態碼，只要遵守狀態碼的類別定義就可以了。</p><p><strong>3. 常用狀態碼解析</strong></p><p>HTTP 狀態碼種類繁多，數量達幾十種。其中最常用的有以下 14 種，一起來看看。</p><p><strong>3.1 200 OK</strong></p><p>表示從客戶端發來的請求在服務器端被正常處理了。</p><p><strong>3.2 204 No Content</strong></p><ul><li>代表服務器接收的請求已成功處理，但在返回的響應報文中不含實體的主體部分。另外，也不允許返回任何實體的主體。</li><li>一般在只需要從客戶端向服務器端發送消息，而服務器端不需要向客戶端發送新消息內容的情況下使用。</li></ul><p><strong>3.3 206 Partial Content</strong></p><p>表示客戶端進行了範圍請求，而服務器成功執行了這部分的 GET 請求。響應報文中包含由 Content-Range 首部字段指定範圍的實體內容。</p><p><strong>3.4 301 Moved Permanently</strong></p><p>永久性重定向。表示請求的資源已被分配了新的 URI。以後應使用資源現在所指的 URI。也就是說，如果已經把資源對應的 URI 保存為書籤了，這時應該按 Location 首部字段提示的 URI 重新保存。</p><p><strong>3.5 302 Found</strong></p><ul><li>臨時性重定向。表示請求的資源已被分配了新的 URI，希望用戶（本次）能使用新的 URI 訪問。</li><li>和 301 Moved Permanently 狀態碼相似，但 302 Found 狀態碼代表資源不是被永久移動，只是臨時性質的。換句話說，已移動的資源對應的 URI 將來還有可能發生改變。</li></ul><p><strong>3.6 303 See Other</strong></p><ul><li>表示由於請求的資源存在著另一個 URI，應使用 GET 方法定向獲取請求的資源。</li><li>303 See Other 和 302 Found 狀態碼有著相同的功能，但 303 See Other 狀態碼明確表示客戶端應採用 GET 方法獲取資源，這點與 302 Found 狀態碼有區別。</li></ul><p><strong>3.7 304 Not Modified</strong></p><ul><li>表示客戶端發送附帶條件的請求時，服務器端允許請求訪問的資源，但未滿足條件的情況。</li><li>304 Not Modified 狀態碼返回時，不包含任何響應的主體部分。</li><li>304 Not Modified 雖然被劃分到 3xx 類別中，但和重定向沒有關係。</li></ul><p><strong>3.8 307 Temporary Redirect</strong></p><p>臨時重定向。該狀態碼與 302 Found 有著相同的含義。</p><p><strong>3.9 400 Bad Request</strong></p><ul><li>表示請求報文中存在語法錯誤。當錯誤發生時，需修改請求的內容後再次發送請求。</li><li>另外，瀏覽器會像 200 OK 一樣對待該狀態碼。</li></ul><p><strong>3.10 401 Unauthorized</strong></p><ul><li>表示發送的請求需要有通過 HTTP 認證（BASIC 認證、DIGEST 認證）的認證信息。</li><li>另外，若之前已進行過 1 次請求，則表示用戶認證失敗。</li><li>返回含有 401 Unauthorized 的響應必須包含一個適用於被請求資源的 WWW-Authenticate 首部用以質詢（challenge）用戶信息。</li></ul><p><strong>3.11 403 Forbidden</strong></p><p>表明對請求資源的訪問被服務器拒絕了。服務器端沒有必要給出詳細的拒絕理由，當然也可以在響應報文的實體主體部分對原因進行描述。</p><p><strong>3.12 404 Not Found</strong></p><p>表明服務器上無法找到請求的資源。除此之外，也可以在服務器端拒絕請求且不想說明理由的時候使用。</p><p><strong>3.13 500 Internal Server Error</strong></p><p>表明服務器端在執行請求時發生了錯誤。也可能是 Web 應用存在的 bug 或某些臨時的故障。</p><p><strong>3.14 503 Service Unavailable</strong></p><p>表明服務器暫時處於超負載或正在進行停機維護，現在無法處理請求。如果事先得知解除以上狀況需要的時間，最好寫入 Retry-After 首部字段再返回給客戶端。</p><h1><strong>八、HTTP 報文實體</strong></h1><p><strong>1. HTTP 報文實體概述</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0ee12507273d48c988d6e7a1c60373a0><p class=pgc-img-caption>HTTP 報文結構</p></div><p>大家請仔細看看上面示例中，各個組成部分對應的內容。</p><p>接著，我們來看看報文和實體的概念。如果把 HTTP 報文想象成因特網貨運系統中的箱子，那麼 HTTP 實體就是報文中實際的貨物。</p><ul><li>報文：是網絡中交換和傳輸的數據單元，即站點一次性要發送的數據塊。報文包含了將要發送的完整的數據信息，其長短很不一致，長度不限且可變。</li><li>實體：作為請求或響應的有效載荷數據（補充項）被傳輸，其內容由實體首部和實體主體組成。（實體首部相關內容在上面第六點中已有闡述。）</li></ul><p>我們可以看到，上面示例右圖中深紅色框的內容就是報文的實體部分，而藍色框的兩部分內容分別就是實體首部和實體主體。而左圖中粉紅框內容就是報文主體。</p><p><strong>通常，報文主體等於實體主體。只有當傳輸中進行編碼操作時，實體主體的內容發生變化，才導致它和報文主體產生差異。</strong></p><p><strong>2. 內容編碼</strong></p><ul><li>HTTP 應用程序有時在發送之前需要對內容進行編碼。例如，在把很大的 HTML 文檔發送給通過慢速連接上來的客戶端之前，服務器可能會對其進行壓縮，這樣有助於減少傳輸實體的時間。服務器還可以把內容攪亂或加密，以此來防止未授權的第三方看到文檔的內容。</li><li>這種類型的編碼是在發送方應用到內容之上的。當內容經過內容編碼後，編好碼的數據就放在實體主體中，像往常一樣發送給接收方。</li></ul><p>內容編碼類型：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4752af59f15d4382adee7e9368ab9243><p class=pgc-img-caption></p></div><p><strong>3. 傳輸編碼</strong></p><p>內容編碼是對報文的主體進行的可逆變換，是和內容的具體格式細節緊密相關的。</p><p>傳輸編碼也是作用在實體主體上的可逆變換，但使用它們是由於架構方面的原因，同內容的格式無關。使用傳輸編碼是為了改變報文中的數據在網絡上傳輸的方式。</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7721aa0942a34f9e9ed7cb9543164352><p class=pgc-img-caption>內容編碼和傳輸編碼的對比</p></div><p><strong>4. 分塊編碼</strong></p><p>分塊編碼把報文分割成若干已知大小的塊。塊之間是緊挨著發送的，這樣就不需要在發送之前知道整個報文的大小了。分塊編碼是一種傳輸編碼，是報文的屬性。</p><p><strong>分塊編碼與持久連接</strong></p><p>若客戶端與服務器端之間不是持久連接，客戶端就不需要知道它在讀取的主體的長度，而只需要讀取到服務器關閉主體連接為止。</p><p>當使用持久連接時，在服務器寫主體之前，必須知道它的大小並在 Content-Length 首部中發送。如果服務器動態創建內容，就可能在發送之前無法知道主體的長度。</p><p>分塊編碼為這種困難提供瞭解決方案，只要允許服務器把主體分塊發送，說明每塊的大小就可以了。因為主體是動態創建的，服務器可以緩衝它的一部分，發送其大小和相應的塊，然後在主體發送完之前重複這個過程。服務器可以用大小為 0 的塊作為主體結束的信號，這樣就可以繼續保持連接，為下一個響應做準備。</p><p>來看看一個分塊編碼的報文示例：</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/89d26fe646e24eaeb320f877e6b44d32><p class=pgc-img-caption>分塊編碼的報文</p></div><p><strong>5.多部分媒體類型</strong></p><p>MIME 中的 multipart（多部分）電子郵件報文中包含多個報文，它們合在一起作為單一的複雜報文發送。每一部分都是獨立的，有各自的描述其內容的集，不同部分之間用分界字符串連接在一起。</p><p>相應得，HTTP 協議中也採納了多部分對象集合，發送的一份報文主體內可包含多種類型實體。</p><p>多部分對象集合包含的對象如下：</p><ul><li>multipart/form-data：在 Web 表單文件上傳時使用。</li><li>multipart/byteranges：狀態碼 206 Partial Content 響應報文包含了多個範圍的內容時使用。</li></ul><p><strong>6. 範圍請求</strong></p><p>假設你正在下載一個很大的文件，已經下了四分之三，忽然網絡中斷了，那下載就必須重頭再來一遍。為了解決這個問題，需要一種可恢復的機制，即能從之前下載中斷處恢復下載。要實現該功能，這就要用到範圍請求。</p><p>有了範圍請求， HTTP 客戶端可以通過請求曾獲取失敗的實體的一個範圍（或者說一部分），來恢復下載該實體。當然這有一個前提，那就是從客戶端上一次請求該實體到這一次發出範圍請求的時間段內，該對象沒有改變過。例如：</p><pre>GET /bigfile.html HTTP/1.1Host: www.sample.comRange: bytes=20224-···</pre><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e8fa12af502745228a36b0e0c82400f3><p class=pgc-img-caption>實體範圍請求示例</p></div><p>上面示例中，客戶端請求的是文檔開頭20224字節之後的部分。</p><h1><strong>九、與 HTTP 協作的 Web 服務器</strong></h1><p>HTTP 通信時，除客戶端和服務器外，還有一些用於協助通信的應用程序。如下列出比較重要的幾個：<strong>代理、緩存、網關、隧道、Agent 代理</strong>。</p><p>1.代理</p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4716c5b3330846898404e847ca148b52><p class=pgc-img-caption>代理</p></div><p>HTTP 代理服務器是 Web 安全、應用集成以及性能優化的重要組成模塊。代理位於客戶端和服務器端之間，接收客戶端所有的 HTTP 請求，並將這些請求轉發給服務器（可能會對請求進行修改之後再進行轉發）。對用戶來說，這些應用程序就是一個代理，代表用戶訪問服務器。</p><p>出於安全考慮，通常會將代理作為轉發所有 Web 流量的可信任中間節點使用。代理還可以對請求和響應進行過濾，安全上網或綠色上網。</p><p><strong>2. 緩存</strong></p><p><strong>瀏覽器第一次請求：</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cba011e82dab4a7192903eaad85feafe><p class=pgc-img-caption>瀏覽器第一次請求</p></div><p><strong>瀏覽器再次請求：</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6cff7cdd110c43599ab78fd8634c2b8b><p class=pgc-img-caption>瀏覽器再次請求</p></div><p>Web 緩存或代理緩存是一種特殊的 HTTP 代理服務器，可以將經過代理傳輸的常用文檔複製保存起來。下一個請求同一文檔的客戶端就可以享受緩存的私有副本所提供的服務了。客戶端從附近的緩存下載文檔會比從遠程 Web 服務器下載快得多。</p><p><strong>3. 網關</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/91c7c77b70084c328d4c15875d761353><p class=pgc-img-caption>HTTP / FTP 網關</p></div><p>網關是一種特殊的服務器，作為其他服務器的中間實體使用。通常用於將 HTTP 流量轉換成其他的協議。網關接收請求時就好像自己是資源的源服務器一樣。客戶端可能並不知道自己正在跟一個網關進行通信。</p><p><strong>4. 隧道</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24ee291e0c8643a6b6aaa2355345758c><p class=pgc-img-caption>HTTP/SSL 隧道</p></div><p>隧道是會在建立起來之後，就會在兩條連接之間對原始數據進行盲轉發的 HTTP 應用程序。HTTP 隧道通常用來在一條或多條 HTTP 連接上轉發非 HTTP 數據，轉發時不會窺探數據。</p><p>HTTP 隧道的一種常見用途就是通過 HTTP 連接承載加密的安全套接字層（SSL）流量，這樣 SSL 流量就可以穿過只允許 Web 流量通過的防火牆了。</p><p><strong>5. Agent 代理</strong></p><div class=pgc-img><img alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c36ec4c296654a0ea461389fe91b6717><p class=pgc-img-caption>自動搜索引擎“網絡蜘蛛”</p></div><p>Agent 代理是代表用戶發起 HTTP 請求的客戶端應用程序。所有發佈 Web 請求的應用程序都是 HTTP Agent 代理。</p><blockquote><p>來源：簡書 鏈接：https://www.jianshu.com/p/6e9e4156ece3</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>全網</a></li><li><a>HTTP</a></li><li><a>協議</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d5a515e.html alt=理解HTTP協議－HTTP協議詳解總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1f9dd54a51c344d9be602aa94f72056e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d5a515e.html title=理解HTTP協議－HTTP協議詳解總結>理解HTTP協議－HTTP協議詳解總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ee43750.html alt=HTTP/HTTPS協議簡介：一文看懂超文本傳輸協議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1076e9a8188e459592706c563a3ee086 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ee43750.html title=HTTP/HTTPS協議簡介：一文看懂超文本傳輸協議>HTTP/HTTPS協議簡介：一文看懂超文本傳輸協議</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/1a8eee9e.html alt=企業都需要的保密協議（全網最全） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/452fe447-f2d0-4f14-a666-3fcd9c99056c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/1a8eee9e.html title=企業都需要的保密協議（全網最全）>企業都需要的保密協議（全網最全）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2e5fc9a.html alt=TCP、HTTP協議以及TCP工作方式和HTTP請求完整過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5e2a3e9642b44ff69966b210d29e5a15 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2e5fc9a.html title=TCP、HTTP協議以及TCP工作方式和HTTP請求完整過程>TCP、HTTP協議以及TCP工作方式和HTTP請求完整過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35d94cf.html alt="如何理解HTTP協議的 “無連接，無狀態” 特點？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35d94cf.html title="如何理解HTTP協議的 “無連接，無狀態” 特點？">如何理解HTTP協議的 “無連接，無狀態” 特點？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html alt=全網流行的像素風插畫怎麼做？看這篇教程就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c6a523bb05004ed59ac7080c46f41e10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html title=全網流行的像素風插畫怎麼做？看這篇教程就夠了>全網流行的像素風插畫怎麼做？看這篇教程就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a286add.html alt=KNX-EIB通信協議的基本原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0eb231dd55b34ebcbbd7ac0328fd48a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a286add.html title=KNX-EIB通信協議的基本原理>KNX-EIB通信協議的基本原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/decdc747.html alt=PPP協議（點對點協議）詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/888a1b78159844579e62e13ed788ff33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/decdc747.html title=PPP協議（點對點協議）詳解>PPP協議（點對點協議）詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69d23a45.html alt=工業控制常用的接口協議大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2fb460305abe4cbaa0210943132dca15 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69d23a45.html title=工業控制常用的接口協議大全>工業控制常用的接口協議大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ea884f1.html alt=達成執行和解協議，執行處於一種暫停狀態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5f266a9654cd4baea7b6bfe99f1e6fad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ea884f1.html title=達成執行和解協議，執行處於一種暫停狀態>達成執行和解協議，執行處於一種暫停狀態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d65aa7b.html alt=全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/76ac70f31cde4c3f8b3f073b28660a91 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d65aa7b.html title=全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？>全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/abb4a186.html alt="這應該是全網講解JAVA 異常處理最全的文章了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b29b2b140f7e4922b0f2ecdff264f228 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/abb4a186.html title="這應該是全網講解JAVA 異常處理最全的文章了">這應該是全網講解JAVA 異常處理最全的文章了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f8ef1f4.html alt="一文帶你看網絡協議之因特網中的轉發和編址！| 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S0IOdi2GF5Q4RI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f8ef1f4.html title="一文帶你看網絡協議之因特網中的轉發和編址！| 原力計劃">一文帶你看網絡協議之因特網中的轉發和編址！| 原力計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90f48362.html alt=帶你看網絡協議之因特網中的轉發和編址 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a00aa25e7b3c40dc9f1dfedcc73b804b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90f48362.html title=帶你看網絡協議之因特網中的轉發和編址>帶你看網絡協議之因特網中的轉發和編址</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f152d00e.html alt=網絡七層協議的通俗理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RGV9JjQ82nsqfC style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f152d00e.html title=網絡七層協議的通俗理解>網絡七層協議的通俗理解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>