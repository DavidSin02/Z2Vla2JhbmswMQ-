<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何幫助實際程序員編寫正確的程序？ | 极客快訊</title><meta property="og:title" content="如何幫助實際程序員編寫正確的程序？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/20f727dcf68945e783561b6ad1ee89d4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c21fa62.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c21fa62.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5c21fa62.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c21fa62.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c21fa62.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5c21fa62.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5c21fa62.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c21fa62.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="如何幫助實際程序員編寫正確的程序？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5c21fa62.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何幫助實際程序員編寫正確的程序？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>20世紀60年代末，人們就在討論驗證其他程序正確性的那些驗證程序的前景了。不幸的是，到今天這幾十年間，除了屈指可數的幾個例外，自動驗證系統依然還是紙上談兵。儘管以前的預期落空了，對程序驗證所進行的研究還是給我們提供了很有價值的東西——對計算機編程的基本理解，這比一個吞入程序，然後閃現“好”或“壞”的黑匣子要好得多。</p><p>本章的目的是闡述這些基本理解如何幫助實際程序員編寫正確的程序。一位讀者將大多數程序員習以為常的方法形象地歸納為“編寫代碼，然後丟給另一個部門，由QA（質量保證）或QT（質量測試）來處理錯誤”。本章描述一種不同的方法。在開始討論之前，我們必須正確地認識到：編程技巧僅僅是編寫正確程序的很小一部分，大部分內容還是前面三章討論過的主題：問題定義、算法設計以及數據結構選擇。如果這些步驟都完成得很好，那麼編寫正確的程序通常是很容易的。</p><h2 class=pgc-h-arrow-right>4.1　二分搜索的挑戰</h2><p>即使有了最好的程序設計，程序員也常常要編寫巧妙的代碼。本章討論一個需要特別仔細地編寫代碼的問題：二分搜索。在回顧這個問題並簡介其算法之後，我們將使用驗證原則來編寫程序。</p><p>我們首次遇到這個問題是在2.2節。我們需要確定排序後的數組</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/20f727dcf68945e783561b6ad1ee89d4><p class=pgc-img-caption></p></div><p>中是否包含目標元素t。[1]準確地說，已知</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/97c0b4483461420fbed9112ce6270d01><p class=pgc-img-caption></p></div><p>且</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c4f8a122b5ba43c38ee62f443b72a279><p class=pgc-img-caption></p></div><p>，當n=0時數組為空。t與x中元素的數據類型相同。無論是整型、浮點型還是字符串型，偽代碼都必須同樣地正確運行。答案存儲在整數p中（記錄位置）：當p為-1時，目標t不在數組</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/20f727dcf68945e783561b6ad1ee89d4><p class=pgc-img-caption></p></div><p>中；否則</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5baf0d52270f46d48bf11a3c0c005a43><p class=pgc-img-caption></p></div><p>，且</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f4b537980a6c47eeb3087241e6887432><p class=pgc-img-caption></p></div><p>。</p><p>二分搜索通過持續跟蹤數組中包含元素t的範圍（如果t存在於數組的話）來解決問題。一開始，這個範圍是整個數組；然後通過將t與數組的中間項進行比較並拋棄一半的範圍來縮小範圍。該過程持續進行，直到在數組中找到t或確定包含t的範圍為空時為止。在有n個元素的表中，二分搜索大約需要執行</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2d242d1908d74bb19b88ca53585cf016><p class=pgc-img-caption></p></div><p>次比較操作。</p><p>多數程序員都認為有了上述描述在手，編寫代碼是輕而易舉的事。但是他們錯了。相信這一點的唯一辦法就是馬上放下書，然後自己編寫這段程序。試試看。</p><p>我在給專業程序員上課時佈置過該問題。學生們有數小時的時間將上面的描述轉換成程序。可以使用任何一種編程語言，高級偽代碼也可以。規定的時間到了的時候，幾乎所有的程序員都報告說自己完成了該任務的正確代碼。然後，我們用30分鐘時間來檢查這些程序員已經用測試實例檢驗過了的代碼。在幾個課堂裡對一百多名程序員的檢查結果大同小異：90%的程序員都在他們的程序中發現了錯誤（並且我不相信那些沒有發現錯誤的程序就一定是正確的）。</p><p>我很驚詫：提供充足的時間，竟然僅有約10%的專業程序員能夠將這個小程序編寫正確。但是他們不是唯一一批發現這個任務困難的人：Knuth在其The Art of Computer Programming, Volume 3: Sorting and Searching的6.2.1節的歷史部分中指出，雖然第一篇二分搜索論文在1946年就發表了，但是第一個沒有錯誤的二分搜索程序卻直到1962年才出現。</p><h2 class=pgc-h-arrow-right>4.2　編寫程序</h2><p>二分搜索的關鍵思想是如果t在</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/20f727dcf68945e783561b6ad1ee89d4><p class=pgc-img-caption></p></div><p>中，那麼它就一定存在於x的某個特定範圍之內。這裡使用mustbe(range)來表示：如果t在數組中，那麼它一定在range中。使用這個定義可以將上面描述的二分搜索轉換成下面的程序框架：</p><pre><code>initialize range to 0..n-1loop     { invariant: mustbe(range) }    if range is empty,         break and report that t is not in the array    compute m, the middle of the range    use m as a probe to shrink the range         if t is found during the shrinking process,         break and report its position</code></pre><p>該程序的最重要部分是大括號內的循環不變式（loop invariant）。之所以把這種關於程序狀態的斷言（assertion）稱為不變式（invariant），是因為在每次循環迭代之前和之後，該斷言都為真。這個名稱將前面已有的直觀概念形式化了。</p><p>現在進一步完善程序，並確保所有的操作都遵循該不變式。我們面對的第一個問題就是範圍（range）的表示方式：這裡使用兩個下標l和u（對應下限lower和上限upper）來表示範圍l..u。（9.3節的二分搜索函數使用起始位置和長度來表示範圍）。邏輯函數mustbe(l, u)是說：如果t在數組中，t就一定在（閉區間）範圍x[l..u]之內。</p><p>下一步的工作是初始化。l和u應該為何值，才能使mustbe(l, u)為真？顯而易見的選擇是0和n-1：mustbe(0, n-1)是說如果t在x中，那麼t就一定在x[0..n-1]中；而這恰好就是我們在程序一開始就知道的事實。於是，初始化由賦值語句l=0和u=n-1組成。</p><p>下一步的任務是檢查空範圍並計算新的中間點m。當l > u時範圍l..u為空，在這種情況下，將特殊值-1賦給p並終止循環，程序如下：</p><pre><code>if l &gt; u    p = -1; break</code></pre><p>break語句終止了外層的loop。下面的語句計算範圍的中間點m：</p><pre><code>m = (l + u) / 2</code></pre><p>“/”運算符實現整數除法：6/2等於3，7/2也等於3。至此，擴展的程序如下：</p><pre><code>l = 0; u = n-1loop    { invariant; mustbe(l, u) }    if l &gt; u        p=-1; break    m = (l + u) / 2    use m as a probe to shrink the range l..u         if t is found during the shrinking process,         break and note its position</code></pre><p>為了完善循環體中的後三行，需要比較t和x[m]，並採取合適的操作來保持不變式成立。因此代碼的一般形式為：</p><pre><code>case     x[m] &lt;  t:  action a    x[m] == t:  action b    x[m] &gt;  t:  action c</code></pre><p>對於操作b，由於t在位置m，所以將p設為m並終止循環。由於另外兩種情況是對稱的，這裡集中討論第一種情況並認為對最後一種情況的討論可以根據對稱性得到（這也是在下一節中我們必須精確驗證代碼正確性的一部分原因）。</p><p>如果x[m]&lt;t,那麼x[0]</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46302e42690548b08f8ec57d94869ef7><p class=pgc-img-caption></p></div><p>x[1]</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46302e42690548b08f8ec57d94869ef7><p class=pgc-img-caption></p></div><p>…</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46302e42690548b08f8ec57d94869ef7><p class=pgc-img-caption></p></div><p>x[m]&lt;t。因此，t不可能存在於x[0..m]中的任何位置。將該結論與已知條件“t不在x[l..u]之外”相結合，可知t一定在x[m+1..u]之內，記為mustbe(m+1, u)。然後，通過將l設為m+1可以再次確立不變式mustbe(l, u)。將這些情況放入前面的代碼框架中，就獲得了最終的函數。</p><pre><code>l = 0; u = n-1loop     { mustbe(l, u) }     if l &gt; u        p = -1; break     m = (l + u) / 2     case           x[m] &lt;  t:   l = m+1          x[m] == t:   P = m; break          x[m] &gt;  t:   u = m-1</code></pre><p>這是一個簡短的程序：只有9行代碼和一個不變式斷言。程序驗證的基本技術（精確定義不變式並在編寫每一行代碼時隨時保持不變式的成立）在我們將算法框架轉化成偽代碼時起到了很大的作用。該過程使我們對程序的正確性樹立了一些信心。但是這並不意味著該程序就一定是正確的。在繼續往下閱讀之前，請花幾分鐘時間確定該代碼的功能是否與所描述的一致。</p><h2 class=pgc-h-arrow-right>4.3　理解程序</h2><p>當面對複雜的編程問題的時候，我總是試圖得到如同上面那樣詳細的程序代碼，然後使用驗證方法來增強自己對程序正確性的信心。本書中的第9章、第11章和第14章也將在這個層面上使用驗證技術。</p><p>本節我們將在近乎吹毛求疵的細節層面上研究對二分搜索程序所進行的驗證分析，實踐中我很少做這麼多正式的分析。下一頁的程序大量使用斷言進行註釋，從而形式化了最初編寫代碼時所用的直觀概念。</p><p>代碼的開發是自上而下進行的（從一般思想開始，將其完善為獨立的代碼行），該正確性分析則是自下而上進行的：從每個獨立的代碼行開始，檢查它們是如何協同運作並解決問題的。</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e601d57301f84c32a2d475b8b7b640fc><p class=pgc-img-caption></p></div><p>我們從第1行至第3行開始討論。mustbe的定義如下：如果t在數組中，那麼它一定在x[0..n-1]中。由此可知，第1行的斷言mustbe(0, n-1)為真。於是，根據第2行的賦值語句l=0和u=n-1可以得到第3行的斷言：mustbe(l, u)。</p><p>下面討論困難的部分：第4行至第27行的循環。關於其正確性的討論分為3個部分，每部分都與循環不變式密切相關。</p><ul><li>初始化。循環初次執行的時候不變式為真。</li><li>保持。如果在某次迭代開始的時候以及循環體執行的時候，不變式都為真，那麼，循環體執行完畢的時候不變式依然為真。</li><li>終止。循環能夠終止，並且可以得到期望的結果（在本例中，期望的結果是p得到正確的值）。為說明這一點需要用到不變式所確立的事實。</li></ul><p>對於初始化，我們注意到第3行的斷言與第5行的相同。為確立其他兩條性質，對第5行至第27行進行分析。討論第9行和第21行（break語句）時，將確立終止性質。如果持續下去，直至第27行，就可以得到保持性質，因為這又與第5行相同。</p><pre><code>1． { mustbe(0, n-1) }2． l = 0; u= n-13． { mustbe(l, u) }4． loop5．      { mustbe(l, u) }6．      if l &gt; u7．            { l &gt; u &amp;&amp; mustbe(l, u) }8．            { t is not in the array }9．            p = -1; break10．     { mustbe(l, u) &amp;&amp; l &lt;= u }11．     m = (l + u) / 212．     { mustbe(l, u) &amp;&amp; l &lt;= m &lt;= u }13．     case14．          x[m] &lt; t:15．                    { mustbe(l, u) &amp;&amp; cantbe(0, m) }16．                    { mustbe(m+l, u) }17．                    l = m+118．                    { mustbe(l, u) }19．          x[m] == t:20．                    { x[m] == t }21．                    p = m; break22．          x[m] &gt; t:23．                    { mustbe(l, u) &amp;&amp; cantbe(m, n-1) }24．                    { mustbe(l, m-1) }25．                    u = m-126．                    { mustbe(l, u) }27．      { mustbe(l, u) }</code></pre><p>第6行的成功測試將得到第7行的斷言：如果t在數組中，那麼它就必定在位置l和u之間，且l > u。這些事實就意味著第8行的斷言成立：t不在數組中。於是在第9行設定p為-1後，就可以正確地終止循環。</p><p>如果第6行的測試失敗，就進入到第10行。不變式依然為真（我們沒有對其做任何改動），並且由於測試失敗，可得l</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46302e42690548b08f8ec57d94869ef7><p class=pgc-img-caption></p></div><p>u。第11行將m設為l和u的平均值，向下取整為最接近的整數。由於平均值總是位於兩個值之間並且取整不會使之小於l，所以得到第12行的斷言。</p><p>從第13行至第27行的case語句考慮到了所有3種可能。最容易分析的一個分支是位於第19行的第二個分支。由第20行的斷言，我們將p設定為m並終止循環是正確的。這是第二處終止循環的地方（一共兩處），由於兩次對循環的終止都是正確的，於是我們確立了循環終止的正確性。</p><p>下面討論case語句中的兩個對稱分支。由於在編寫代碼的時候，我們把精力集中在第一個分支上，現在我們將注意力轉移到第22行～第26行。考慮第23行的斷言。第一個子句是不變式，循環並沒有對其進行改變。由於t &lt; x[m]</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46302e42690548b08f8ec57d94869ef7><p class=pgc-img-caption></p></div><p>x[m+1]</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46302e42690548b08f8ec57d94869ef7><p class=pgc-img-caption></p></div><p>…</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46302e42690548b08f8ec57d94869ef7><p class=pgc-img-caption></p></div><p>x[n-1]，第二個子句亦為真，於是我們可以知道t不在數組中任何高於m-1的位置，使用簡短記法表示為cantbe(m, n-1)。邏輯告訴我們，如果t一定在l和u之間，而且不等於或高於m，那麼t就一定在l和m-1之間（前提是t在x中），於是得到第24行。第24行為真時執行第25行可得第26行為真——這是賦值的定義。case語句的這個分支也就再次確立了第27行的不變式。</p><p>第14行至第18行的討論具有完全相同的形式，至此，我們完成了對case語句所有三個分支的分析。一個正確地終止了循環，其他兩個則保持了不變式。</p><p>該代碼分析表明，如果循環能夠終止，那麼就可以得到正確的p值。但是，程序中仍有可能包含死循環；事實上，這正是那些專業程序員編寫該程序時所犯的最常見的錯誤。</p><p>我們的停機證明從另一個角度對範圍l..u進行了考慮。初始範圍為某一有限大小（n），第6行至第9行確保當範圍中的元素少於一個時終止循環。因此，要證明終止，我們必須證明在循環的每次迭代後範圍都縮小了。第12行告訴我們，m總處於當前範圍內。case語句中不終止循環的兩個分支（第14行和第22行）都排除了範圍中位置m處的值，由此將範圍大小至少縮小1。因此，程序必會終止。</p><p>有了這些背景分析，我對我們進一步討論這個函數更有信心了。下一章涵蓋了以下主題：用C來實現該函數，然後進行測試以確保程序正確而且高效。</p><h2 class=pgc-h-arrow-right>4.4　原理</h2><p>本章的練習展示了程序驗證的諸多優勢：問題很重要，需要認真地編寫代碼；程序的開發需要遵循驗證思想；可以使用一般性的工具進行程序的正確性分析。該練習的主要缺點在於其細節層面：在實踐中不需要這麼正式。幸運的是，這些細節闡述了許多一般性的原理，包括以下原理。</p><p>斷言。輸入、程序變量和輸出之間的關係勾勒出了程序的“狀態”，斷言使得程序員可以準確闡述這些關係。這些斷言在程序生命週期中的角色在下一節中論述。</p><p>順序控制結構。控制程序的最簡單的結構莫過於採用“執行這條語句然後執行下一條語句”的形式。可以通過在語句之間添加斷言並分別分析程序執行的每一步來理解這樣的結構。</p><p>選擇控制結構。這些結構包括不同形式的if和case語句；在程序運行過程中，多個分支中的一個被選擇執行。我們通過分別分析每一個分支說明了該結構的正確性。一定會選擇某個分支的事實允許我們使用斷言來證明。例如，如果執行了語句if i >j，那麼我們就可以斷言i >j並且使用這個事實來推導出下一個相關的斷言。</p><p>迭代控制結構。要證明循環的正確性就必須為其確立3個性質：</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2e1063288b754acc9022702bc49d0318><p class=pgc-img-caption></p></div><p>我們首先討論由初始化確立的循環不變式，然後證明每次迭代都保持該不變式為真。由數學歸納法可知這兩步就證明了在循環的每次迭代之前和之後該不變式都為真。第三步是證明無論循環在何時終止執行，所得到的結果都是正確的。綜合這些步驟可知：只要循環能停止運行，那麼其結果就是正確的。因此我們還必須用其他方法證明循環一定能終止（二分搜索的停機證明所使用的方法是比較常見的）。</p><p>函數。要驗證一個函數，首先需要使用兩個斷言來陳述其目的。前置條件（precon- dition）是在調用該函數之前就應該成立的狀態，後置條件（postcondition）的正確性由函數在終止執行時保證。如此可以得到C語言二分搜索函數如下：</p><pre><code>int bsearch(int t, int x[], int n) /* precondition: x[0] &lt;= x[1] &lt;= ... &lt;= x[n-1]   postcondition:         result == -1    =&gt; t not present in x         0 &lt;= result &lt; n =&gt; x[result] == t*/</code></pre><p>這些條件與其說是事實陳述不如說是一個契約：如果在前置條件滿足的情況下調用函數，那麼函數的執行將確立後置條件。一旦證明函數體具有該性質，在以後的應用中就可以直接使用前置條件和後置條件之間的關係而不再需要考慮其實現。該方法在軟件開發中通常稱為“契約編程”。</p><h2 class=pgc-h-arrow-right>4.5　程序驗證的角色</h2><p>當一個程序員想要讓別人相信某段代碼正確的時候，首選的工具通常就是使用測試用例：運行程序並手動輸入數據。這是很有效的：適用於檢測程序的錯誤、易於使用並且很容易理解。然而，程序員明顯對程序有更深的理解——如果他們做不到這一點的話，就不可能編寫出第一手程序。程序驗證的一個主要好處就是為程序員提供一種語言，用來表達他們對程序的理解。</p><p>本書的後續部分（特別是第9章、第11章和第14章）將會使用驗證技術進行復雜程序的開發。在編寫每一行代碼的時候都使用驗證語言來解釋，這對概括每個循環的不變式特別有用。程序文本中重要的解釋以斷言的形式結束；而確定在實際軟件中應包含哪些斷言則是一門藝術，只能在實踐中學習。</p><p>驗證語言常用於程序代碼初次編寫完成以後，在進行初次模擬的時候開始使用。測試過程中，違反斷言語句的那些情況指明瞭程序的錯誤所在，而對相應情況形式的分析則指出了在不引入新錯誤的情況下如何修正程序中的錯誤。調試過程中，需要同時修正錯誤代碼和錯誤的斷言：總是保持對代碼的正確理解，不要理會那種“只要能讓程序工作，怎麼改都行”的催促。第5章將介紹程序驗證在程序的測試和調試過程中所扮演的幾種重要角色。斷言在程序維護過程中至關重要：當你拿到一段你從未見過而且多年來也沒有其他人見過的代碼時，有關該程序狀態的斷言對於理解程序是很有幫助的。</p><p>這些僅是編寫正確程序的很小一部分技術。編寫簡單的代碼通常是得到正確程序的關鍵。另一方面，幾個熟悉這些驗證技術的專業程序員曾經對我講述了一段在我自己編程時也常遇到的經歷：當他們編寫程序的時候，“困難”的部分第一次就可以正確運行，而那些“容易”的部分往往會出毛病。當開始編寫困難的部分時，他們會坐下來仔細編程併成功地使用強大的正規技術。在編寫容易的部分時，他們又返回到自己的編程老路上來了，結果當然是舊病復發了。在親身經歷之前，我也並不相信會有這種現象，這種尷尬的現象是經常使用驗證技術的良好動力。</p><p>本文摘自：《編程珠璣》第2版。[美] 喬恩·本特利（Jon Bentley） 著，黃倩，錢麗豔 譯。</p><div class=pgc-img><img alt=如何幫助實際程序員編寫正確的程序？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/97ed8ebb0e694bd9aec7bfe186f75b73><p class=pgc-img-caption></p></div><ul><li>經典算法和數據結構習題精粹，計算機科學領域20餘年暢銷不衰的不朽經典</li><li>程序員案頭常備，融深邃思想、實戰技術與趣味軼事於一爐的奇書</li><li>帶你真正領略計算機科學之美</li></ul><p>多年以來，當讓程序員推選喜愛的計算機圖書時，《編程珠璣》總是位於前列。正如自然界裡珍珠出自細沙對牡蠣的磨礪，計算機科學大師喬恩·本特利以其獨有的洞察力和創造力，從磨礪程序員的實際問題中凝結出一篇篇編程“珠璣”，成為世界計算機界名刊《ACM通訊》歷史上*受歡迎的專欄，*終結集為兩部計算機科學經典名著，影響和激勵著一代又一代程序員和計算機科學工作者。本書為第一卷，主要討論計算機科學中*本質的問題：如何正確選擇和高效地實現算法。<br>在書中，作者選取許多具有典型意義的複雜編程和算法問題，生動描繪了歷史上大師們在探索解決方案中發生的軼事、走過的彎路和不斷精益求精的歷程，引導讀者像真正的程序員和軟件工程師那樣富於創新性地思考，並透徹闡述和總結了許多獨特而精妙的設計原則、思考和解決問題的方法以及實用程序設計技巧。解決方案的代碼均以C/C++語言編寫，不僅有趣，而且有很大的實戰示範意義。每章後所附習題極具挑戰性和啟發性，書末給出了簡潔的解答。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>程序</a></li><li><a>幫助</a></li><li><a>實際</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f11d7679.html alt=耳朵除了聽聲音，還可以幫助警察破案哦！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/38e98d2bf14d4fef9a0071fd57db3b19 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f11d7679.html title=耳朵除了聽聲音，還可以幫助警察破案哦！>耳朵除了聽聲音，還可以幫助警察破案哦！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fd22dc3.html alt=“層高”與“淨高”實際上並不是一回事，兩者所表達的含義也不同 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e0554c3a320343c9ac4d21554ff065ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fd22dc3.html title=“層高”與“淨高”實際上並不是一回事，兩者所表達的含義也不同>“層高”與“淨高”實際上並不是一回事，兩者所表達的含義也不同</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6dbc7107.html alt=iPhone1200萬像素落後安卓近十倍，實際拍照卻贏很大？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c39cd90b9add48b393074ca84f3238ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6dbc7107.html title=iPhone1200萬像素落後安卓近十倍，實際拍照卻贏很大？>iPhone1200萬像素落後安卓近十倍，實際拍照卻贏很大？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86f7cce2.html alt=礦山巷道貫通後的實際偏差如何測定？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c75908ccd2c449728a3f0b89153b0af6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86f7cce2.html title=礦山巷道貫通後的實際偏差如何測定？>礦山巷道貫通後的實際偏差如何測定？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/87ec6d9d.html alt=管理評審程序（IAO9001程序文件範本） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/87ec6d9d.html title=管理評審程序（IAO9001程序文件範本）>管理評審程序（IAO9001程序文件範本）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fd25820.html alt=質量管理體系程序文件-FMEA程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fd25820.html title=質量管理體系程序文件-FMEA程序>質量管理體系程序文件-FMEA程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0ffb976.html alt=不合格、糾正措施程序文件（ISO9001程序文件範本） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0ffb976.html title=不合格、糾正措施程序文件（ISO9001程序文件範本）>不合格、糾正措施程序文件（ISO9001程序文件範本）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16c259de.html alt=什麼是程序文件？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16c259de.html title=什麼是程序文件？>什麼是程序文件？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8c41b36.html alt=今天聊聊程序的文件的概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8c41b36.html title=今天聊聊程序的文件的概念>今天聊聊程序的文件的概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd79f8d.html alt=程序文件-ISO9001 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2e673ba29f5545fd8aea4073e1c638c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd79f8d.html title=程序文件-ISO9001>程序文件-ISO9001</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e56d2fb8.html alt=程序文件主要包括哪些內容？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e56d2fb8.html title=程序文件主要包括哪些內容？>程序文件主要包括哪些內容？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4526bc23.html alt=程序文件沒有用？管理全靠你盯著？也許是你對程序文件有誤解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f214b9-177d-4e1e-8ccd-1c3fe7c07fe5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4526bc23.html title=程序文件沒有用？管理全靠你盯著？也許是你對程序文件有誤解>程序文件沒有用？管理全靠你盯著？也許是你對程序文件有誤解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c81e50df.html alt=程序文件流程圖 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3a0300041dc3570ffec5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c81e50df.html title=程序文件流程圖>程序文件流程圖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/300f6ba5.html alt=程序文件的管理主要有哪些方面的內容？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/300f6ba5.html title=程序文件的管理主要有哪些方面的內容？>程序文件的管理主要有哪些方面的內容？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5ad5161d.html alt=食品企業程序文件範本 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/6cb0d535ec904fa2ac5d54a06cea18b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5ad5161d.html title=食品企業程序文件範本>食品企業程序文件範本</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>