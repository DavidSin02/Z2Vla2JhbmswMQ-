<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>UE手遊研發中，如何做好Android內存優化？ | 极客快訊</title><meta property="og:title" content="UE手遊研發中，如何做好Android內存優化？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/bdf26c52e1004f91b54c615e2b291a2d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c4c767.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c4c767.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5c4c767.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c4c767.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c4c767.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5c4c767.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5c4c767.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5c4c767.html><meta property="article:published_time" content="2020-10-29T20:59:05+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:05+08:00"><meta name=Keywords content><meta name=description content="UE手遊研發中，如何做好Android內存優化？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5c4c767.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>UE手遊研發中，如何做好Android內存優化？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bdf26c52e1004f91b54c615e2b291a2d><p class=pgc-img-caption></p></div><p><br></p><p><strong>編者按</strong> 在大多數人的印象裡，用UE引擎製作出來的遊戲實際佔用內存會比較高。<strong>騰訊遊戲學院專家Leonn</strong>，將和大家分享基於UE的手遊開發中，Android內存分佈和優化。</p><p><br></p><p><strong>文 | Leonn</strong></p><p><br></p><p>在基於UE的手遊開發中，經常會發現Android系統的實際內存佔用要比我們預估的高很多，優化內存的佔用就要先明確究竟每1k實際的內存佔用分佈在哪裡及如何運用工具有效的獲取真實的內存組成，本文將結合項目經驗詳細介紹這個部分，並據此分別介紹一些常用的瓶頸和優化。最終了解你的Android程序中的每1k內存。</p><p><br></p><h1 class=pgc-h-arrow-right>Android程序內存分配原理</h1><p><br></p><p><strong>Android內存管理基礎</strong></p><p><br></p><p>Android內存的管理核心是<strong>paging</strong>和<strong>memory-mapping（mmap）</strong>。</p><p><br></p><p><strong>Paging</strong></p><p><br></p><p>Android系統中使用虛擬內存地址來索引內存，虛擬內存被劃分為固定大小的page頁，典型的頁大小為4K。內存分配最開始都是在虛擬內存上分配，當需要訪問這段內存的時候，如果發現它沒有存在於物理內存上（即MMU不能找到這個虛地址va對應的物理地址pa），即發生了缺頁（page fault），缺頁有幾種可能：</p><p><br></p><ul><li>Bug，程序訪問了它不應該訪問的虛地址空間，Android系統會觸發訪問不合法，kill掉進程。</li><li>Va是合法的，但是這塊va對應的pa還從來沒有被分配出來過（例如你mmap的一段內存空間，但是從來沒用過，這是第一次在這塊內存上寫入），這叫做lazy-allocation，這時系統會真正分配一段物理內存給你用，然後在頁表上對應好這段pa和va。注意第一次寫入這裡才算真正佔用了物理內存，mmap的分配並不算。</li><li>Va是合法的，但是這va對應的pa內容當前並沒有在物理內存上，而是被swap到一個backup的file上，這時系統會給這個page在pa上分配物理內存，然後將這塊內容從文件讀回到物理內存上（swap-in）。</li></ul><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be76d9c7471f4eacbc749f4fe6f6d68b><p class=pgc-img-caption></p></div><p><br></p><p><strong>Swap和zram</strong></p><p><br></p><p>典型的linux系統的虛擬內存都有swap操作，即一段物理內存在一段時間不用的時候，為了節省物理內存將他們備份到它的backup file上，一段時間後缺頁時再換回。</p><p><br></p><p>但是在Android上大多數情況是沒有這套swap機制的，因為對於移動端的IO代價太大，所以大多數情況被映射到pa的page是不能被swap的。只有一種情況除外，即如果這段虛擬地址段具有backup file，並且當他被swap-in到pa後是隻讀的，那麼它是有機會被swap-out回disk的，因為swap這種內存的代價很小，他們不會在物理內存上被更改，通常這類情況包括那些代碼文件的mmap（如dex so等）。</p><p><br></p><p>此外Android上還使用了一種特殊的ZRAM機制來壓縮一些物理內存上的page，但是並不把他們swap-out到disk上，而是仍然在ram中，這是一段被壓縮了的page，系統會選擇壓縮一些page存儲在內存中以騰出一些物理內存的佔用。</p><p><br></p><p><strong>MMAP</strong></p><p><br></p><p>Linux上一個重要的特性是memory mapping。如上面所述，va和pa之間通過mmu建立了一個對應關係，通過page fault來觸發pa的分配，此外va還會對應一個backup file，作為swap-in/out時的備份存儲。這個va和backup file之間的對應關係就叫做memory mapping，我們可以利用這個機制做文件讀取。</p><p><br></p><p>Memory mapping的調用函數是mmap，它的原型是</p><p><br></p><p>void* mmap(void *addr, size_t length, int prot, int flags, int fd, size_t offset)</p><p>void munmap(void *addr, size_t length)</p><p><br></p><p>addr為預映射的虛擬內存地址起始（傳null則讓系統給你分配）。</p><p><br></p><p>length為大小。</p><p><br></p><p>offset為偏移。</p><p><br></p><p>prot為這段地址區域的保護方式:</p><p>-PROT_EXEC（可被執行）</p><p>-PROT_READ(可讀)</p><p>-PROT_WRITE(可寫)</p><p>-PROT_NONE（不能存取）</p><p><br></p><p>flags代表為這段區域的各種特性:</p><p>-MAP_FIXED:如果傳入是start地址不能成功建立映射，則放棄映射</p><p>-MAP_SHARED：對映射區域的寫入會複製回它的backup文件，而且允許其他進程共享對該文件的映射</p><p>-MAP_PRIVATE:對映射區域的寫入會產生一個backup文件的複製，且這個區域的修改都不會再寫回backup文件（shared和private必須二選一）</p><p>-MAP_ANONYMOUS:匿名映射，忽略文件fd參數，且映射區域不能和其他進程共享</p><p>-MAP_DENYWRITE:只能寫入映射的內存，不能直接寫入文件</p><p>-MAP_LOCKED:鎖定映射區域、，說明該段不能被swap</p><p></p><p>它有兩種用法：</p><p><br></p><p>第一種是映射文件到內存做讀取， 這時提供一個文件句柄，然後將文件內容映射到一段虛擬內存地址空間，這樣就做到了通過訪問虛擬地址空間--造成缺頁—swapin backup file的方式來根據需要讀取文件。它相比傳統的文件讀取效率更高。</p><p><br></p><p>第二種是創建一個匿名映射，匿名映射沒有backupfile，只是單純分配一塊虛擬內存空間，這其實是Android上調用new一個對象做的事情，我們new一塊int的數組，事實上在new後很可能是通過mmap分配了一塊虛擬內存空間，而只有當第一次寫入的時候才觸發缺頁而佔用真正的物理內存，所以統計Android的物理內存佔用不是看new了多少，或者文件映射了多少，而是實際上虛擬內存缺頁了多少。</p><p><br></p><p><strong>MMAP和new malloc</strong></p><p><br></p><p>我們知道我們可以用new創建對象，new裡面就是用的malloc/calloc等分配內存空間，那麼malloc和mmap之間是什麼關係呢。首先new 和malloc是c++/c語言層面的事情，實際在類linux的操作系統層面，給用戶提供的申請內存的函數只有brk/sbrk和mmap函數。</p><p><br></p><p>如下圖典型32位系統中一個進程的虛擬地址空間分佈狀態，sbrk的作用就是擴展heap部分的上界，可以傳入一個分配的大小，並返回新的brk地址。</p><p><br></p><p>Malloc函數當申請小內存時使用sbrk來分配內存，大內存則使用mmap申請，如果是這種情況，這時的malloc並沒有申請物理內存的佔用 。但實際上大部分malloc的實現都會在操作系統內再維護一個內存池，它會預先申請一塊較大的連續內存複用，最終都是走的mmap。</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f1706afca8c24dc0a20035812ee9a6d9><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>Android程序的內存構成</h1><p><br></p><p>有了前面的Android的內存管理的基礎知識，這裡談下Android進程的內存組成。</p><p><br></p><p><strong>從adb meminfo說起</strong></p><p><br></p><p>當我們運行adb shell dumpsys meminfo xxx.xxx.xxx的時候將得到一份最簡單的Android程序內存報告，這裡面的pss+swap的總量也是我們Android內存統計的金標準。</p><p><br></p><p>一個典型的adb 內容如下：</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/20089e47fa2643878d39db29c8a503ac><p class=pgc-img-caption></p></div><p><br></p><p>這裡面可以看到pss privatedirty privateclean swapped diry 這幾個重要的指標。</p><p><br></p><p>這裡能看到的所有值都是物理內存大小，即缺頁的那些虛擬內存的大小，而不是真正虛擬內存的大小，注意這裡看到的所有內存大小都是真真實實佔著你的物理內存的（比如我隨便new 1個int[1024],在你對這塊內存寫入之前它都不會佔用物理內存並體現在這裡。）</p><p><br></p><p>PSS是指proportional set size，是指你的進程實際佔用的物理內存大小，但是Android內存涉及到在系統中同其他進程共享一部分庫（可能是so，可能是字體文件等的mmap），所以這裡面會考慮這個因素計算你的進程平攤的這部分共享庫的大小，這裡的p就意味著統計了這個平攤後的物理內存。這是衡量進程佔用內存的最真實指標。</p><p><br></p><p>Private Dirty和Private Clean則是完全該進程自己（而不包括和別人共享部分）佔用的物理內存，clean是指那部分可能被swap的內存部分（即前面說到的擁有backup文件，mmap之後一直保持只讀狀態，他們具有被swap out的可能，比如你的so庫文件。），而dirty部分就是除clean之外那些不能被swap的內存。Private Dirty通常是你的進程內存最需要優化的地方，因為他們是大頭。</p><p><br></p><p>Swapped Dirty指的並不是被swap-out出去的內存，而是Android系統中zram機制壓縮掉的部分Private Dirty部分的不常用物理內存，這個重要度等同於Private Dirty，因為哪些Private Dirty會被壓縮不能被控制，所以這部分多通常也是Private Dirty 的。</p><p><br></p><p>因為PSS中已經包含了Private Dirty和Private Clean，但是沒包含swapped dity，所以最終衡量你的進程對物理內存的佔用應該是取PSS+Swapped Dirty。</p><p></p><p>下面則是按照各種category分別統計的內存值，仍然很有意義。</p><p><br></p><p>Native Heap：這是C/C++層直接通過malloc分配的內存，在UE的框架中你幾乎不會在UE代碼中分配到這部分內存，因為UE的所有malloc都統一走了UE的內存管理機制FMalloc，而Fmalloc的底層使用的mmap。所以當你看到Native Heap存在數值較大，一般只有幾個大的可能：除UE之外引入的其他第三方庫，以及一個很大的大頭gles的driver在client內存一側的分配。這部分的內存通常普遍較大，且剖析比較複雜，在非root的Android機幾乎很難用正常的方法hook到，是很多UE手遊內存分析人員的盲區，這部分profile我們後面詳細講。</p><p><br></p><p>Dalvik Heap/other：這是Android的java虛擬機分配的內存，也就是java部分分配的，UE基本不直接寫java層代碼，所以大的話多數是接入的第三方SDK分配的，這部分可以很容易的用android studio的memory profiler看到分配堆棧。</p><p><br></p><p>Stack：很好理解棧分配內存。</p><p><br></p><p>Ashmem：進程的匿名共享內存 Anonymous Shared Memory ，通常不會很大，和操作系統有關係。</p><p><br></p><p>GFX dev：通俗來說是你的顯存，Android 顯存和內存在同樣的物理設備上，所以統計的總內存是包括顯存的，至於adb如何知道哪些是顯存，是因為gles和egl的so庫在分配顯存的時候也是使用的帶backup文件的mmap，adb只是簡單的統計了所有gles和egl的mmap將其視為顯存，這部分通常就是在gpu上的資源，gpu上的資源由很多種，佔大頭的就是texture，buffer，shader programe，這個是所有遊戲的大頭，後面也會詳細講這部分的profile。</p><p><br></p><p>Other Dev：除顯卡外所有其他硬件設備的mmap後的物理內存，可能包括聲卡等，通常不多。</p><p><br></p><p>.so mmap:這個就是so庫本身文件mmap佔用的物理內存，我們隨著遊戲進度會逐漸的讀取我們的so文件，造成和缺頁的部分就是在物理內存產生佔用，這部分大就是so庫太大了，但是這部分因為有很多是readonly的mmap，所以有更大的機會被swap-out出去。</p><p><br></p><p>.apk .dex oat .art mmap:這些都是Android 程序文件本身被mmap佔用的內存，和so的性質差不多。</p><p><br></p><p>Other mmap：是所有除了上面的之外其他的所有非匿名方式的mmap，想要知道是什麼可以通過下面要講的命令查看。</p><p><br></p><p>Unkonwn:在UE程序中這部分通常是最大的一塊，在meminf中它指所有的匿名mmap,因為是匿名的，所以meminf不知道是什麼，就統計在unkown中，用匿名映射做的mmap基本就是mmap方式的內存分配，在UE中UE自己的Fmalloc系統使用的就完全是mmap方式的內存分配（改成ansi方式除外），所以這裡的unkown內存基本等同於UE的fmalloc的內存，就是你的ue程序分配的內存。看，通過UE的fmalloc的內存其實只佔整個Android進程內存的一部分而已，我們通過UE的llm_full等跟蹤到的內存其實只是這個unkown內存的部分。</p><p><br></p><p><strong>RSS 和 VSS</strong></p><p><br></p><p>上面說的是PSS的統計，其實還有兩個口徑的內存統計，RSS和vss。</p><p><br></p><p>通過adb shell top可以查看所有進程的rss vss信息。</p><p><br></p><p>RSS即resident set size，它表示該進程本身除了和別的進程共享部分實際佔用的物理內存，即比pss小一些。</p><p><br></p><p>VSS則是值改進程分配的虛擬空間大小，這個值通常意義不大，因為理論上你的虛擬空間可以分配的很大，比如你要mmap很多的文件，但是並不代表你要同時訪問這些文件在物理內存上。</p><p><br></p><p><strong>瞭解Android的每1k內存 -- 查看進程完整的虛擬內存空間映射情況</strong></p><p><br></p><p>到這裡為止我們知道了使用簡單的adb指令查看Android的內存組成，那麼adb meminfo又是根據什麼統計出來了呢，其實可以去查看adb meminfo的代碼實現，它基於了更詳細的虛擬內存映射信息。</p><p><br></p><p>通過指令adb run-as xxx.xxx.xxx cat /proc/pid/smaps 可以查看到當前整個進程的虛擬內存映射情況，即每1k物理內存是在哪裡發生的。如下表是其中的一部分：</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/791d7005cb874b2585a36d5dae255fb0><p class=pgc-img-caption></p></div><p><br></p><p>這裡面詳細記錄了你的進程的每一塊虛擬地址空間的分配情況，如圖中的第一個block中，說的是12c0000-12ebc000這塊連續的虛地址空間，它的大小是2800K（虛擬地址大小），它也映射的物理內存RSs和pss都是2732kb，後面的ashemen說明它是一個匿名共享內存，最終會被統計到adb meminfo的ashm中 。</p><p><br></p><p>這個文件很大，很詳細，我們還可以得到一個更簡要的信息，通過命令</p><p>adb shell run-as xxx.xxx.xxx pmap pid –x 可以得到規整成下面的一個表：</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c36cc4dc16834d4cad8089b8fae03d6c><p class=pgc-img-caption></p></div><p><br></p><p>這個表更容易看，分別列出來虛擬內存其實地址，大小，映射的pss物理內存大小，內存屬性，以後後面的mapping的來源。</p><p><br></p><p>從mapping的來源我們可以簡單推測這個內存的創建來源。例如有這麼些可能：</p><p><br></p><p>如果看到dalvik-main，那它一般是java 虛擬機的native 分配，這個最終會被統計到meminf的dalvik裡。</p><p><br></p><p>Anon：這個就是匿名mmap映射，最終會被統計到meminf的unkown裡，這個在UE中就是所有的Fmalloc。</p><p><br></p><p>Anon：libc_malloc 這個是通過malloc方法進入的mmap，即你所有的new ，malloc調用，在UE裡面這個基本就是第三方庫的malloc分配，當然還有一個大頭是gles 的driver的malloc分配。</p><p><br></p><p>Kgsl-3d則是gles對顯存硬件的虛擬內存映射，換句話說就是顯存，meminf正是統計這個標籤來獲取gfx的大小。</p><p><br></p><p>在後半段還會看到**.SO，這個不是說這個so分配了多少，而是這個so文件本身在虛擬內存映射後缺頁的物理內存大小，即so文件被當前讀入到內存上的大小，這個會動態改變，因為程序對so的訪問也是動態的。</p><p><br></p><p>還有***.ttf,這個就是對ttf字體文件的讀取，同so的讀取一樣。</p><p><br></p><p>可以看到，其實adb meminf也是靠這個pmap映射算出來前面那份報表。</p><p><br></p><p>根據這個映射清單，我們基本可以先大致一眼瞄出程序的主要內存佔用在哪。作為UE手遊，通常你要關注的是：</p><p>Nativeheap（主要是gl的driver和第三方庫，會很大，你的圖形資源是否太多）</p><p>GFX（顯存，貼圖，buffer，shader，你的圖形資源是否太多）</p><p>Unkown(UE中的fmalloc)</p><p>So mmap（So庫是否太大）</p><p></p><p>當然從這裡還是不能給出一些指導意見，所以我們需要再詳細分解這些內存的使用，因為我們基於了UE4引擎，所以我們還有更多的手段。</p><p><br></p><h1 class=pgc-h-arrow-right>UE程序的完整內存組成</h1><p><br></p><p>因為在UE引擎內部的內存分配和釋放望去可以在引擎層hook住，所以UE引擎範圍內的內存使用我們是可以詳細的追蹤細化的。在引擎層我們能hook住的內存分配主要來自兩塊：</p><p><br></p><p>1）通過FMalloc對內存的分配。因為UE用fmalloc承接了所有new/delete，所以通過在fmalloc這層去hook，可以抓住這些分配。另外malloc底層又通過mmap去分配，等於通過追蹤UE的fmalloc可以追蹤整個Android內存的Unkonw部分，即匿名mmap映射部分。</p><p><br></p><p>2）通過對graphic api的調用而觸發一些gpu資源的創建。例如通過一個glcreatexxx可以創建某個顯卡資源，整個過程會產生driver的開銷即gpu上顯存的開銷，在很多平臺我們不太可能準確的查詢到這裡面多分配了多少內存，但是至少可以根據資源估計出在顯卡上的顯存開銷。這個顯存的開銷就對應了gfx部分。</p><p><br></p><p>所以在UE的引擎內部我們有可能容易的細化上面說的Unkonw和GFX部分。而UE引擎為我們提供了這個機制，即LLM（Low Level Memory Checker）。</p><p></p><p>3.1LLM</p><p><br></p><p>LLM通過插入各種tag來將所有待統計的內存劃歸到某個tag下。通過維護一個tag的堆棧，將fmalloc到的內存統計到當前棧頂的tag下。Llm在最底層hook了fmalloc的每一個統計，如果沒有任何tag在當前棧中，那麼所有內存計入在untagged這個tag下，如果我們在代碼中插入一個基於scoped的tag，就可以把這個scope下的內存計入你的tag下。通過LLm我們不會遺漏任何Fmalloc分配的內存。</p><p><br></p><p>此外程序剛初始化的時候，LLM會記錄一個內存，被它估計為可執行程序本身的內存，記在Program這個tag下。而rhi每個對於gpu資源的創建也會被LLM記錄在額外的texture，buffer等標籤下，他們不是fmalloc內存的一部分，是對GPU的內存佔用的估算。</p><p></p><p><strong>LLM的類型</strong></p><p><br></p><p>LLM主要分兩種，即兩種統計口徑，分別為default和platform，他們是兩個維度的統計。</p><p><br></p><p>LLM基於代碼中定義LLMTag來為每個內存打標籤，一個tag要至少包含類型名，組名，可以通過查看LLM_ENUM_GENERIC_TAGS這個宏來看所有的tag。</p><p><br></p><p>一個tag要麼屬於default的統計範疇，要麼屬於platform的統計範疇，這個可以通過查看DECLARE_LLM_MEMOPRY_STAT這部分代碼來判斷屬於哪個口徑。</p><p><br></p><p>default和platform的tag會同時設置，也就是說default和platform會同時統計每個內存的使用，每個內存都會被default和platform的某個tag同時抓到。</p><p></p><p><strong>default-統計和平臺無關的內存</strong>（即無論到哪個平臺上，default的內存都是差不多的）</p><p><br></p><p>通過stat LLM和stat llmfull 可以看到詳細的統計。前者是按大組去統計的，後者是細分的。主要的統計項目包括：</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1582ff9db622429b9fa22fb192e0bdc1><p class=pgc-img-caption></p></div><p><br></p><p><strong>platform-統計和平臺相關的</strong></p><p><br></p><p>通過stat llmplatform可以看到詳細的統計，主要項目包括</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/949a8f3fc22745bf827a077dadd32bd1><p class=pgc-img-caption></p></div><p><br></p><p>可以看到上面一些tag是存在交叉的，例如platform口徑下的fmalloc實際上包含了default下面的很多tag的和。</p><p><br></p><p>之所有有這樣兩個口徑是方便我們從不同維度理解內存的組成，platform的維度和機型平臺相關，default則和平臺無關。當然無論哪個維度，加起來的總和是一樣的。</p><p></p><p><strong>怎樣打開並使用LLM？</strong></p><p><br></p><p>1）默認dev debug 包才開啟，如果在test包開啟，則需要設置宏ALLOW_LOW_LEVEL_MEM_TRACKER_IN_TEST= 1</p><p>2）需要連接調試器啟動，例如xcode或者android studio</p><p>3）加上啟動參數 -LLM</p><p>4）如果啟動參數帶上 -LLMCSV 則會定期將結果自動保存在磁盤為csv文件。</p><p>5）帶上啟動參數 -LLMCSV可以寫到csv裡面</p><p></p><p>運行時，輸入指令stat LLMFULL 和stat LLMPLATFORM 分別看到default和platform兩種統計口徑的結果</p><p></p><p>3.2 構建你的UE程序的Android內存清單</p><p><br></p><p>在對一個基於UE程序的Android進行內存剖析的時候，第一件事情一定是生成一個報告，這個報告可以說明總的pss的每一k分別分佈在哪裡，這才是解決一切問題的前提，不然都是盲猜。</p><p><br></p><p>在這裡我們需要試圖整理出一個完整的UE程序的內存清單。</p><p><br></p><p>從最前面我們知道Android內存從meminfo上來看可以分為</p><p>Nativeheap</p><p>Davik</p><p>Gfx</p><p>.so/.dex/.oart map…</p><p>Unkonw</p><p><br></p><p>而UE的fmalloc採用匿名映射，基本代表unkonwn的部分，而且UE還估計了tex buffer的顯存，可以認為代表了大部分的gfx。而LLm肢解了fmalloc和顯存這部分。</p><p><br></p><p>所以可以認為用llm我們首先就分解開了gfx的大部分和unkonw的全部。</p><p><br></p><p>那麼然後是其他的幾個部分，需要我們自己做點工作了。</p><p></p><p><strong>NativeHeap部分</strong></p><p><br></p><p>這部分是所有通過malloc分配的內存。UE內部的任何內存分配都不在這裡，那麼這裡主要是什麼？主要是其他任何第三方so通過malloc獲取的內存，事實上UE內部也可能存在某些插件不走統計的fmalloc而是直接malloc系統內存，那麼也會進入這裡。這其中最大大頭的一個so通常就是那個叫做libgles***.so所分配的，它代表顯卡driver在driver層分配的內存（注意不是顯存）。</p><p><br></p><p>這部分內存通常很大，怎麼分析。我們需要把這部分內存的分配hook到。</p><p><br></p><p>如果是root的版本（或者是非root但是Android10以上版本）你可以參考這個文檔https://source.android.com/devices/tech/debug/native-memory上的一些方法，包括其中介紹的malloc debug，perfetto等方法，強烈推薦的是Android-10以上可以用的perfetto，如果是任意一臺一些低端機，那麼就只能採用一些hack的方法。我推薦一個開源的項目xhook https://github.com/iqiyi/xHook，是通過 PLT (Procedure Linkage Table) 的技術hook住任意函數的調用，當然就包括malloc。</p><p><br></p><p>在筆者的項目中集成了這個xhook，然後我hook住所有so的malloc，relloc，calloc，free。就可以拿到每個so的native heap的分配，他們的和就等於這個nativeheap的值。</p><p><br></p><p>一個典型的UE手遊的nativeheap的分解值可能是這樣的：</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/441ec203e22649a7ab3bcc2d538c02f1><p class=pgc-img-caption></p></div><p><br></p><p>不出意外gles相關的so會是絕對大頭，它是顯卡的driver部分（我們後面分析顯存的時候在細講），另外我們看UE4本身也會有走非fmalloc的代碼，是其中的某些plugin。</p><p></p><p>除了可以通過這種方法拿到每個so佔用的nativeheap，還可以自己寫些代碼拿到具體這個so的nativeheap分佈在了那裡。例如我想分析gles的driver佔用的這125M內存是從哪來的，有的人說gles的driver是顯卡driver決定的，我們無法介入，確實這裡是一個黑盒，但是所有的driver內存分配究竟還是你的每一個gl api調用而產生的，通過在你的每個glapi調用前後打tag，你還是應該能夠統計到這些內存究竟同什麼樣的api調用相關，你就知道該優化什麼。</p><p><br></p><p>例如筆者在項目中在所有的gl api前後打一些tag，來分段統計這個hook到的gles的nativeheap，可以非常精確的拿到幾個大戶對driver的內存分配情況，例如tex，buffer，shader的創建。此外我們甚至還可以結合具體邏輯再細分tag，拿到具體哪些類型的buffer更佔顯卡driver等等。</p><p><br></p><p><strong>GFX和顯存相關部分</strong></p><p><br></p><p>顯存通常是一個UE程序的絕對大頭。在Android程序中，顯示相關資源需要的內存包括：</p><p><br></p><p>A CPU遊戲引擎測需要對應的結構</p><p>B Meminfo上GFX部分的顯存</p><p>C Meminfo上面的GL Mtrack</p><p>D Meminfo上面的EGL Mtrack</p><p>E 顯卡driver分配的</p><p></p><p>其中A包括為了創建貼圖，buffer等在cpu這邊的結構體，原始數據等，已經被LLM統計了，他是內存的部分，相對好追蹤，就不討論。</p><p><br></p><p>B出現在adb meminfo上，是我們常規意義上稱為的顯卡訪問的存儲資源，顯存。它的統計方法是統計pmap中顯存mmap映射文件（adreno上是kgsl-3D0這個文件）的pss部分。</p><p><br></p><p>C 這一項只有較新的設備有，因為Android上顯存的管理和內存不一樣，不是採用虛擬內存映射，缺頁後再調入物理內存，而是虛存vs有多大，就直接為其分配多大的物理內存。所以很多老的系統只統計B而計算出的總PSS其實是要比真實物理內存佔用要小的。而GL Mtracker這個項正是統計了那些pss映射為0的部分的vss大小。所以這個加上B才是真實的顯存大小 ，如果你的Android系統不統計C，那麼可以自己去pmap裡面累加。</p><p><br></p><p>D 這是EGL分配的硬件資源，因為一些顯示資源不是gl分配的，例如backbuffer是系統從窗口系統中分配的，這屬於egl的分配範疇。一些老的系統沒有統計這個。</p><p><br></p><p>E opengl是一個client-server架構，server指的是顯卡那部分，client指的就是CPU這側的dirver部分，很多顯示資源不只需要在server部分對應顯存分配，同樣需要消耗大量的client部分的driver內存。例如去創建一個新的glbuffer，不管這個buffer實際上有多大，筆者在一些adreno機器上測試它在driver這塊都需要分配固定的4096+284k的內存，因為driver內部要維持一個渲染狀態和結構。例如去map一個glbuffer，那麼driver這邊通常是需要malloc一個這個glbuffer大小的buffer出來，用來接受你對map結果的寫入，driver在合適的時機再同步給server那邊的glbuffer。所以gl的driver部分的內存是不可忽視的一大塊，它就是我們前面將的那一節的nativeheap的gles的部分。</p><p><br></p><p>很多老的機器系統因為不統計C和D，會導致pss看起來比實際小很多。</p><p></p><p>A在llm中有，E在nativeheap中獲取，這裡面我們還不能拿到準確組成的是BCD，即真正顯存上的那一部分，但是如果我們看gl文檔，gl資源的組成主要就包括以下幾種：texture，buffer，shader和program，sampler，queryobject。而大頭主要就是texture，buffer，shader和program。所以我們可以推測。事實上在UE裡面已經對texture和buffer進行的推測。</p><p><br></p><p>在gl每次創建tex和buffer的最底層，UE都加了一個hook，根據當前tex和buffer的屬性推測了程序實際使用的tex和buffer大小，我們通過指令stat rhi，可以看到UE推測的各種類型的tex和buffer內存。那麼bcd三項的和減去UE推測的tex和buffer，就只剩下shader和program的內存了。</p><p></p><p>這裡我們對顯存可以拿到完整的清單。當然對於bcd三項我們還有其他方法，例如截幀軟件可以截取當前所有存活於顯卡的渲染資源，包括看到所有的tex，buffer，shader，也可以用來輔助定位哪些顯示資源佔了更多。</p><p><br></p><p><strong>.so/.dex/.oart map…</strong></p><p><br></p><p>這部分是程序代碼文件本身的mmap部分，在遊戲過程中，隨著隨遊戲代碼文件的讀入，而導致缺頁分配物理內存，如果項目這個很大，要考慮對so文件瘦身。</p><p><br></p><p><strong>Dalvik</strong></p><p><br></p><p>這是java虛擬機部分分配的內存，因為我們幾乎不會寫java代碼，所以基本不大，另外也可以輕易的用android studio的profilor分析到這部分內存的產生。</p><p><br></p><p><strong>你的內存組成清單</strong></p><p><br></p><p>下面我們就可以專業的拿出一個完整的UE程序在Android上的內存組成清單，它應該看起來包括這些主要內容。</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a083bc6d5b5f42f3888c00e02c65eca0><p class=pgc-img-caption></p></div><p><br></p><p>在正常情況下這裡面的子項加起來應該基本等於total部分，如果有明顯出入，就要再具體分析出入在哪裡了。</p><p><br></p><p>當我們拿出了這樣的一個清單，一個UE程序在Android上的內存瓶頸會非常清晰，然後下一步就是去優化這些瓶頸了。</p><p><br></p><h1 class=pgc-h-arrow-right>UE程序常見的內存瓶頸和優化</h1><p><br></p><p>這裡會對應上面一節給出的內存組成清單，來簡要說下可能會成為瓶頸的地方及其常用優化方法。</p><p><br></p><p><strong>4.1貼圖的顯存</strong></p><p><br></p><p>最有效的方法是砍美術！是的，如果程序的佔用顯存過大，多少都涉及到過量的美術資源。</p><p><br></p><p>當然除了砍美術之外，還包括合適的貼圖壓縮格式和質量，貼圖的合併減少貼圖的張數。我們經常以貼圖的尺寸，格式來估計貼圖佔用的顯存大小，但是實際上這是個理想情況，實際上在很多硬件上，最終一個貼圖對顯存的佔用還要受很多因素，例如，內存的對齊。筆者曾經在一個snapdragon660的機器上實測過幾種不同格式分辨率貼圖的實際對顯存pss的佔用。</p><p><br></p><div class=pgc-img><img alt=UE手遊研發中，如何做好Android內存優化？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9e40f38a2e8842d58eb9d296d2575404><p class=pgc-img-caption></p></div><p><br></p><p>大多數情況實際的pss都要比UE估計的更多。這裡面似乎存在這樣幾個規則：</p><p><br></p><p>對於astc6*6 4*4,顯存的實際分配情況比預估多，猜測至少對於adreno存在astc圖像按照16個block對其的情況（因為如果按照16個block對齊計算則同實際pss值一致）</p><p><br></p><p>16block對其的情況存在一些基礎開銷：</p><p><br></p><p>astc8*8最適合128 倍數的貼圖。<br>astc6*6最適合96倍數的貼圖。<br>astc4*4最適合64倍數的貼圖。</p><p><br></p><p>所以我們要儘量選用和你壓縮質量最匹配的分辨率，並且因為每張帶mip的28k的基礎開銷，能合併貼圖儘量合併是能減少內存大小的。</p><p><br></p><p>當然為了更貼合實際使用情況，可以修改UE的估算公式。</p><p><br></p><p>此外合理的加載，gc，緩存，texturestreaming的使用都是貼圖的優化策略。</p><p><br></p><p><strong>4.2 Buffer的顯存</strong></p><p><br></p><p>和貼圖一樣，要先考慮過量的美術資源使用，除此，還要考慮到：</p><p>是否引入了沒使用的attributer，如uv2，color。</p><p>是否用了過多的instance合批造成的instance buffer等。</p><p>此外statimesh的streaming也可以考慮打開。</p><p><br></p><p><strong>4.3 Shader和program的顯存/內存</strong></p><p><br></p><p>shader變體是UE的一個老大難問題，在大型項目中，幾乎都存在變體爆炸的問題，事實上筆者的項目在shader這塊曾經累計摳出來過不下200M的內存。這裡面可能需要考慮的策略包括：</p><p><br></p><p>儘可能減少母材質，減少對母材質管線屬性的的overrider（例如overide它的blendmode就等於新出一個ps）。</p><p>減少材質可使用的vertexfactory。</p><p>減少顯示的定義更多的materialshaderd模板類型。</p><p>在materialshader的shoulcompile裡面做更多更細緻的裁剪，去掉不可能的組合。</p><p>只加載當前qulitylevel的材質。</p><p><br></p><p>除了減少變體外，UE中默認永遠不會清理已經編譯的shader和programe，這會導致你的程序越跑這部分內存越高，到達一個峰值，可以考慮使用LRU動態卸載一些不用的programe，考慮在shader被編譯到programe後及時卸載，尤其是使用binarycache的情況下，其實根本是不需要編譯glshader的，programe完全從binary生成。</p><p><br></p><p>另外包括推遲shader和programe的編譯階段，UE默認在initrhi階段就編譯glshader了，但其實很多情況這個shader根本從來沒被用來attach glprogram。</p><p><br></p><p>由於UE內部完全沒有考慮對glshader的卸載，所以這塊需要自己改造一下。</p><p><br></p><p><strong>4.4 Gles的driver</strong></p><p><br></p><p>如果跟蹤gles的native的分配情況，會發現這裡面的大頭還是tex，buffer和shader的相關操作。一些較常見的問題包括：</p><p><br></p><p>創建任何一個glbuffer，在很多機器上都存在一個4k左右的基礎開銷，無論這個buffer多大，而如果你的遊戲使用了大量的buffer，尤其是你用了大量的ubo，你會發現你的ubo真正的顯存加起來可能只有幾k，但是在driver層用於管理他們的結構內存已經高達幾十M！所以一定不要使用大量散裝的ubo，你應該嘗試使用UE的emulated ubo，或者自己合併全局的ub，並用double buffer去管理cpu和gpu的訪問衝突。</p><p><br></p><p>另外包括長期的mapbuffer也會在driver分配內存。</p><p><br></p><p>此外也可以嘗試UE中分開存放的頂點的attribufer buffer，但是pos buffer因為tbdr的問題還是儘量單獨存放。</p><p><br></p><p><strong>4.5 Uobject</strong></p><p><br></p><p>減少數量和減少屬性。通過將場景中的物件整合成hism後發佈，是可以大大減少uobject的總量的，此外通過objlist dump出每個類型的uobject的數量和內存後，針對性的刪掉它們中沒用的成員變量。</p><p><br></p><p><strong>4.6 Malloc unused</strong></p><p><br></p><p>這是一個躲不掉的內存開銷，因為UE的bin式的內存管理會將所有的內存分配按照固定大小對其從整個page中分配。這個過程至少就存在這樣兩種浪費：一個是內存的對其浪費，一個是頁的空白浪費。避免這個問題，有幾種思路：</p><p><br></p><p>總的內存分配減少，這部分內存就自然成比例減少。</p><p><br></p><p>做好內存對齊，找到那些對其不良的部分，我們可以hook malloc的底層，發現這樣的地方。</p><p><br></p><p>減少內存分配的次數，頻繁程度，尤其是短期內的大量分配，它會容易分配大量page，雖然後面內存被釋放，但是dirty page已然被撐大而不能有效回縮，造成大量的unused 內存。這裡面的重災區又常見在tarray的頻繁resize，可以hook一下所有因tarray的reize導致的內存分配去優化它。如果是renderthread，通常可以用fmemstack，sceneallocater的array來避免頻繁的直接內存分配，至於rhithread也有類似於rhicmdlist.alloc這種優化的內存分配方式。</p><p><br></p><p><strong>4.7 Lua</strong></p><p><br></p><p>包括合理的設置lua的gc參數，gc的步長，閾值等，防止lua到了較高內存才執行gc。此外如果是大量的配置表導致的lua內存則要考慮用其他方式代替，如sqlite。</p><p><br></p><p><strong>4.8 代碼的so map</strong></p><p><br></p><p>除了減少我們的代碼量之外，還要strip掉so的符號，以及不去編譯一些用不到的UE特性，plugin等。</p><p><br></p><p><strong>4.9 Assetregistry</strong></p><p><br></p><p>如果資源量太多，會發現assetregistry，包括fname等都會佔用較高的內存，除了我們儘量減少cook清單外，還可以考慮關閉assetregistry，不會對遊戲性能造成什麼影響。</p><p></p><p>寫到這裡文章已經超過1萬字了，出於篇幅的限制（事實上是真的寫累了..），這裡就只列舉了一些可能是較大瓶頸的內存問題，當然每個項目都有每個項目特有的問題，就需要case by case了。但是最重要的前提是隻要我們建立了合理正確的內存分析策略得到完整的內存分佈清單，那麼問題就會很容易暴露和定位，解決問題才會成為可能。</p><p><br></p><p>總之，工慾善其事必先利其器，發現問題->分析問題->解決問題的最前面應該是找到發現問題的方法論並製作發現問題的工具，而這正是本文想著重講述的。</p><p><br></p><p><strong>關於騰訊遊戲學院專家團</strong></p><p>如果你的遊戲也富有想法充滿創意，如果你的團隊現在也遇到了一些開發瓶頸，那麼歡迎你來聯繫我們。騰訊遊戲學院聚集了騰訊及行業內策劃、美術、程序等領域的遊戲專家，我們將為全世界的創意遊戲團隊提供專業的技術指導和遊戲調優建議，解決團隊在開發過程中遇到的一系列問題。</p><p><br></p><p><strong>申請專家資源請前往：</strong></p><p>https://gwb.tencent.com/cn/tutor</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>UE</a></li><li><a>手遊</a></li><li><a>研發</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/cd6334f.html alt=史上研發最久的回合手遊？騰訊這款妖尾ip的遊戲終於來了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/2fb16a59111946808b5ee9dd8488a047 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/cd6334f.html title=史上研發最久的回合手遊？騰訊這款妖尾ip的遊戲終於來了！>史上研發最久的回合手遊？騰訊這款妖尾ip的遊戲終於來了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059eb0e0.html alt=西華大學研發的軌道交通應急通訊公鐵兩用保障車進入試應用階段 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e2c88a4a2e0f4204a26bec2b8ec45fc1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059eb0e0.html title=西華大學研發的軌道交通應急通訊公鐵兩用保障車進入試應用階段>西華大學研發的軌道交通應急通訊公鐵兩用保障車進入試應用階段</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebc86c59.html alt="Nature Communications｜合肥工大等研發自修復可拉伸彈性導體新材料" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531328023682f62dd2efab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebc86c59.html title="Nature Communications｜合肥工大等研發自修復可拉伸彈性導體新材料">Nature Communications｜合肥工大等研發自修復可拉伸彈性導體新材料</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/77301633.html alt=哈佛研發可水洗，超靈敏且有彈性的智能紡織品應變測量傳感器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dc417c505f144603ba1cf5e4f3f6357d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/77301633.html title=哈佛研發可水洗，超靈敏且有彈性的智能紡織品應變測量傳感器>哈佛研發可水洗，超靈敏且有彈性的智能紡織品應變測量傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f8fc13d.html alt="頂點軟件：公司的研發團隊陣容強大 已推出證券軟件產品新品" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f8fc13d.html title="頂點軟件：公司的研發團隊陣容強大 已推出證券軟件產品新品">頂點軟件：公司的研發團隊陣容強大 已推出證券軟件產品新品</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae20f785.html alt="華工研發新型塑料袋 遇水即溶無汙染" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/R6Aaarr1EhocLf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae20f785.html title="華工研發新型塑料袋 遇水即溶無汙染">華工研發新型塑料袋 遇水即溶無汙染</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1990951d.html alt=藥物研發新革命-核磁共振技術加速先導化合物發現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad74ce90265642a9b7c1aa31443033f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1990951d.html title=藥物研發新革命-核磁共振技術加速先導化合物發現>藥物研發新革命-核磁共振技術加速先導化合物發現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5bdbdb5b.html alt=國際新研發：復材電力電纜為風力發電提供更多動力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c18ad572782b4bc88d63d9acab3e6f4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5bdbdb5b.html title=國際新研發：復材電力電纜為風力發電提供更多動力>國際新研發：復材電力電纜為風力發電提供更多動力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82e8e9a8.html alt=西門子宣佈研發下一代HL級燃氣輪機技術，發電效率65% class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/31f500030bd3feec71c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82e8e9a8.html title=西門子宣佈研發下一代HL級燃氣輪機技術，發電效率65%>西門子宣佈研發下一代HL級燃氣輪機技術，發電效率65%</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aab19b91.html alt=昆鋼自主研發設計的全國產化EB爐建成試車 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aab19b91.html title=昆鋼自主研發設計的全國產化EB爐建成試車>昆鋼自主研發設計的全國產化EB爐建成試車</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e263607.html alt=福耀等研發新型汽車玻璃：集成北斗高精度定位與通信多模智能天線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e92497aea3c34102bcf1014009a3aca5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e263607.html title=福耀等研發新型汽車玻璃：集成北斗高精度定位與通信多模智能天線>福耀等研發新型汽車玻璃：集成北斗高精度定位與通信多模智能天線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8d3b396.html alt="高速三支隊烏海大隊交警“跨界”工匠 自主研發便攜式安全防護裝備" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7f022541ceba4d2fb2f65f42d7660175 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8d3b396.html title="高速三支隊烏海大隊交警“跨界”工匠 自主研發便攜式安全防護裝備">高速三支隊烏海大隊交警“跨界”工匠 自主研發便攜式安全防護裝備</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d630851.html alt=國產新能源再做突破！比亞迪研發超級鐵鋰電池，續航有望破600Km class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4bb931abba3041038835c5799a4a82d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d630851.html title=國產新能源再做突破！比亞迪研發超級鐵鋰電池，續航有望破600Km>國產新能源再做突破！比亞迪研發超級鐵鋰電池，續航有望破600Km</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/019af8c4.html alt=穩定性、成本效益比更佳，印度研發世界第一個鐵離子電池 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/819e4fe56dc04b28a95151d7afef42af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/019af8c4.html title=穩定性、成本效益比更佳，印度研發世界第一個鐵離子電池>穩定性、成本效益比更佳，印度研發世界第一個鐵離子電池</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a24bd0b.html alt=生活垃圾如何分類傻傻分不清？麻省理工研發了自動分類回收機器人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/43f5fe8de9e24cd5afd0796c26ca46d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a24bd0b.html title=生活垃圾如何分類傻傻分不清？麻省理工研發了自動分類回收機器人>生活垃圾如何分類傻傻分不清？麻省理工研發了自動分類回收機器人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>