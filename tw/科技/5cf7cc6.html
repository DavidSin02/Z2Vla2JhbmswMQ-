<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux系統調用詳解（實現機制分析） | 极客快訊</title><meta property="og:title" content="Linux系統調用詳解（實現機制分析） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/89bc567a63c84695b0fbe8982764bbdb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><meta property="article:published_time" content="2020-10-29T21:04:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:55+08:00"><meta name=Keywords content><meta name=description content="Linux系統調用詳解（實現機制分析）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5cf7cc6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux系統調用詳解（實現機制分析）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用概述</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">計算機系統的各種硬件資源是有限的，在現代多任務操作系統上同時運行的多個進程都需要訪問這些資源，為了更好的管理這些資源進程是不允許直接操作的，所有對這些資源的訪問都必須有操作系統控制。也就是說操作系統是使用這些資源的唯一入口，而這個入口就是操作系統提供的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統調用（System Call）</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。在linux中系統調用是用戶空間訪問內核的唯一手段，除異常和陷入外，他們是內核唯一的合法入口。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般情況下應用程序通過應用編程接口API，而不是直接通過系統調用來編程。在Unix世界，最流行的API是基於POSIX標準的。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">操作系統一般是通過中斷從用戶態切換到內核態。中斷就是一個硬件或軟件請求，要求CPU暫停當前的工作，去處理更重要的事情。比如，在x86機器上可以通過int指令進行軟件中斷，而在磁盤完成讀寫操作後會向CPU發起硬件中斷。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">中斷有兩個重要的屬性，中斷</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">號</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和中斷處理程序。中斷號用來標識不同的中斷，不同的中斷具有不同的中斷處理程序。在操作系統內核中維護著一箇中斷向量表（Interrupt Vector Table），這個數組存儲了所有中斷處理程序的地址，而中斷號就是相應中斷在中斷向量表中的偏移量。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般地，系統調用都是通過軟件中斷實現的，x86系統上的軟件中斷由int $0x80指令產生，而128號異常處理程序就是系統調用處理程序system_call()，它與硬件體系有關，在entry.S中用匯編寫。接下來就來看一下Linux下系統調用具體的實現過程。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">為什麼需要系統調用</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">linux內核中設置了一組用於實現系統功能的子程序，稱為系統調用。系統調用和普通庫函數調用非常相似，只是系統調用由操作系統核心提供，運行於</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">內核態</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，而普通的函數調用由函數庫或用戶自己提供，運行於</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">用戶態</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般的，進程是不能訪問內核的。它不能訪問內核所佔內存空間也不能調用內核函數。CPU硬件決定了這些（這就是為什麼它被稱作</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">“保護模式”</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">）。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">為了和用戶空間上運行的進程進行交互，內核提供了一組接口。透過該接口，應用程序可以訪問硬件設備和其他操作系統資源。這組接口在應用程序和內核之間扮演了使者的角色，應用程序發送各種請求，而內核負責滿足這些請求(或者讓應用程序暫時擱置)。實際上提供這組接口主要是為了保證系統穩定可靠，避免應用程序肆意妄行，惹出大麻煩。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統調用在用戶空間進程和硬件設備之間添加了一箇中間層。該層主要作用有三個：</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1、它為用戶空間提供了一種統一的硬件的抽象接口。比如當需要讀些文件的時候，應用程序就可以不去管磁盤類型和介質，甚至不用去管文件所在的文件系統到底是哪種類型。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2、系統調用保證了系統的穩定和安全。作為硬件設備和應用程序之間的中間人，內核可以基於權限和其他一些規則對需要進行的訪問進行裁決。舉例來說，這樣可以避免應用程序不正確地使用硬件設備，竊取其他進程的資源，或做出其他什麼危害系統的事情。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">3、每個進程都運行在虛擬系統中，而在用戶空間和系統的其餘部分提供這樣一層公共接口，也是出於這種考慮。如果應用程序可以隨意訪問硬件而內核又對此一無所知的話，幾乎就沒法實現多任務和虛擬內存，當然也不可能實現良好的穩定性和安全性。在Linux中，系統調用是用戶空間訪問內核的</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">惟一</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">手段；除異常和中斷外，它們是內核惟一的合法入口。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">API/POSIX/C庫的區別與聯繫</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般情況下，應用程序通過應用編程接口(API)而不是直接通過系統調用來編程。這點很重要，因為應用程序使用的這種編程接口實際上並不需要和內核提供的系統調用一一對應。</span></p><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">一個API定義了一組應用程序使用的編程接口。它們可以實現成一個系統調用，也可以通過調用多個系統調用來實現，而完全不使用任何系統調用也不存在問題。實際上，API可以在各種不同的操作系統上實現，給應用程序提供完全相同的接口，而它們本身在這些系統上的實現卻可能迥異。</span></span></p></blockquote><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在Unix世界中，最流行的應用編程接口是基於POSIX標準的，其目標是提供一套大體上基於Unix的可移植操作系統標準。POSIX是說明API和系統調用之間關係的一個極好例子。在大多數Unix系統上，根據POSIX而定義的API函數和系統調用之間有著直接關係。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Linux的系統調用像大多數Unix系統一樣，作為C庫的一部分提供如下圖所示。C庫實現了 Unix系統的主要API，包括標準C庫函數和系統調用。所有的C程序都可以使用C庫，而由於C語言本身的特點，其他語言也可以很方便地把它們封裝起來使用。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">從程序員的角度看，系統調用無關緊要，他們只需要跟API打交道就可以了。相反，內核只跟系統調用打交道；庫函數及應用程序是怎麼使用系統調用不是內核所關心的。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">關於Unix的界面設計有一句通用的格言“提供機制而不是策略”。換句話說，Unix的系統調用抽象出了用於完成某種確定目的的函數。</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">至幹</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這些函數怎麼用完全不需要內核去關心。區別對待機制(mechanism)和策略(policy)是Unix設計中的一大亮點。大部分的編程問題都可以被切割成兩個部分:“需要提供什麼功能”(機制)和“怎樣實現這些功能”(策略)。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">區別</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">api是函數的定義，規定了這個函數的功能，跟內核無直接關係。而系統調用是通過中斷向內核發請求，實現內核提供的某些服務。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">聯繫</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一個api可能會需要一個或多個系統調用來完成特定功能。通俗點說就是如果這個api需要跟內核打交道就需要系統調用，否則不需要。<br>程序員調用的是API（API函數），然後通過與系統調用共同完成函數的功能。<br>因此，API是一個提供給應用程序的接口，一組函數，是與程序員進行直接交互的。<br>系統調用則不與程序員進行交互的，它根據API函數，通過一個軟中斷機制向內核提交請求，以獲取內核服務的接口。<br>並不是所有的API函數都一一對應一個系統調用，有時，一個API函數會需要幾個系統調用來共同完成函數的功能，甚至還有一些API函數不需要調用相應的系統調用（因此它所完成的不是內核提供的服務）</span></p><p style=text-align:start><strong>需要C/C++ Linux高級服務器架構師學習資料後臺私信“資料”（包括C/C++，Linux，golang技術，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒體，CDN，P2P，K8S，Docker，TCP/IP，協程，DPDK，ffmpeg等）</strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/89bc567a63c84695b0fbe8982764bbdb><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用的實現原理</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">基本機制</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">前文已經提到了Linux下的系統調用是通過0x80實現的，但是我們知道操作系統會有多個系統調用（Linux下有319個系統調用），而對於同一個中斷號是如何處理多個不同的系統調用的？最簡單的方式是對於不同的系統調用採用不同的中斷號，但是中斷號明顯是一種稀缺資源，Linux顯然不會這麼做；還有一個問題就是系統調用是需要提供參數，並且具有返回值的，這些參數又是怎麼傳遞的？也就是說，對於系統調用我們要搞清楚兩點：</span></p><ol start=1><li>1.系統調用的函數名稱轉換。</li><li>2.系統調用的參數傳遞。</li></ol><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">首先看第一個問題。實際上，Linux中每個系統調用都有相應的系統調用號作為唯一的標識，內核維護一張系統調用表，sys_call_table，表中的元素是系統調用函數的起始地址，而系統調用號就是系統調用在調用表的偏移量。在x86上，系統調用號是通過eax寄存器傳遞給內核的。比如fork（）的實現：</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">用戶空間的程序無法直接執行內核代碼。它們不能直接調用內核空間中的函數，因為內核駐留在受保護的地址空間上。如果進程可以直接在內核的地址空間上讀寫的話，系統安全就會失去控制。所以，應用程序應該以某種方式通知系統，告訴內核自己需要執行一個系統調用，希望系統切換到內核態，這樣內核就可以代表應用程序來執行該系統調用了。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通知內核的機制是靠軟件中斷實現的。首先，用戶程序為系統調用設置參數。其中一個參數是系統調用編號。參數設置完成後，程序執行“系統調用”指令。x86系統上的軟中斷由int產生。這個指令會導致一個異常：產生一個事件，這個事件會致使處理器切換到內核態並跳轉到一個新的地址，並開始執行那裡的異常處理程序。此時的異常處理程序實際上就是系統調用處理程序。它與硬件體系結構緊密相關。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">新地址的指令會保存程序的狀態，計算出應該調用哪個系統調用，調用內核中實現</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">那個</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統調用的函數，恢復用戶程序狀態，然後將控制權返還給用戶程序。系統調用是設備驅動程序中定義的函數最終被調用的一種方式。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">從系統分析的角度，linux的系統調用涉及4個方面的問題。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">響應函數</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_xxx</span></span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">響應函數名以“sys_”開頭，後跟該系統調用的名字。</span></p><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">例如</span></span></p><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">系統調用</span></span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">fork()</span></span>的響應函數是<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_fork()</span></span>(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">Kernel/fork.c</span></span>),</p><p><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">exit()</span></span>的響應函數是<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_exit()</span></span>(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">kernel/fork.</span></span>)。</p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用表與系統調用號-=>數組與下標</span></h1><hr><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">文件</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">include/asm/unisted.h</span></span>為每個系統調用規定了唯一的編號。</p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/118c01f3d890476f8fe254c21f8f0cad><p class=pgc-img-caption></p></div><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">在我們系統中/usr/include/asm/unistd_32.h，可以通過find / -name unistd_32.h -print查找）<br>而內核中的頭文件路徑不同的內核版本以及不同的發行版，文件的存儲結構可能有所區別</span></span></p></blockquote><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/59cc1fbf068b4912a5bb2241de256fd6><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5d2530cd229a416f973080c77ee3d8fa><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9ee6627baf804e72b59192004c49016d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71e628fdd8084f2a8035ea867abe8b13><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">假設用name表示系統調用的名稱，那麼系統調用號與系統調用</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">響應</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">函數的關係是：以系統調用號</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_NR_name</span></span>作為下標，可找出系統調用表<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/entry.S</span></span>)中對應表項的內容，它正好是該系統調用的響應函數<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_name</span></span>的入口地址。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統調用表</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>記錄了各<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_name</span></span>函數在表中的位置，共190項。有了這張表，就很容易根據特定系統調用</p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5fc645c423da4a06877c5a24443a7d06><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在表中的偏移量，找到對應的系統調用</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">響應</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">函數的入口地址。系統調用表共256項，餘下的項是可供用戶自己添加的系統調用空間。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在Linux中，每個系統調用被賦予一個系統調用號。這樣，通過這個獨一無二的號就可以關聯繫統調用。當用戶空間的進程執行一個系統調用的時候，這個系統調用號就被用來指明到底是要執行哪個系統調用。進程不會提及系統調用的名稱。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統調用號相當關鍵，一旦分配就不能再有任何變更，否則編譯好的應用程序就會崩潰。Linux有一個“未實現”系統調用</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_ni_syscall()</span></span>，它除了返回一<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ENOSYS</span></span>外不做任何其他工作，這個錯誤號就是專門針對無效的系統調用而設的。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">因為所有的系統調用陷入內核的方式都一樣，所以僅僅是陷入內核空間是不夠的。因此必須把系統調用號一併傳給內核。在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">x86</span></span>上，系統調用號是通過<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">eax</span></span>寄存器傳遞給內核的。在陷人內核之前，用戶空間就把相應系統調用所對應的號放入<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">eax</span></span>中了。這樣系統調用處理程序一旦運行，就可以從<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">eax</span></span>中得到數據。其他體系結構上的實現也都類似。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">內核記錄了系統調用表中的所有已註冊過的系統調用的列表，存儲在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>中。它與體系結構有關，一般在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">entry.s</span></span>中定義。這個表中為每一個有效的系統調用指定了惟一的系統調用號。<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>是一張由指向實現各種系統調用的內核函數的函數指針組成的表：<br><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system_call()</span></span>函數通過將給定的系統調用號與<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">NR_syscalls</span></span>做比較來檢查其有效性。如果它大於或者等於<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">NR syscalls</span></span>,該函數就返回一<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ENOSYS</span></span>。否則，就執行相應的系統調用。</p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed6cc376c01c44faadabf8a3890bb288><p class=pgc-img-caption></p></div><pre><code> call *sys_ call-table(，%eax, 4)1</code></pre><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">由於系統調用表中的表項是以32位(4字節)類型存放的，所以內核需要將給定的系統調用號乘以4，然後用所得的結果在該表中查詢其位置</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">進程的系統調用命令轉換為INT 0x80中斷的過程</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">宏定義</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscallN()</span></span>見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">include/asm/unisted.h</span></span>)用於系統調用的格式轉換和參數的傳遞。N取0~5之間的整數。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">參數個數為N的系統調用由_syscallN()負責格式轉換和參數傳遞。系統調用</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">號</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">放入EAX寄存器，啟動INT 0x80後，規定返回值送EAX寄存器。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用功能模塊的初始化</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對系統調用的初始化也就是對</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">INT 0x80</span></span>的初始化。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統啟動時，彙編子程序</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">setup_idt</span></span>(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/head.S</span></span>)準備了1張256項的idt表，由<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">start_kernel()</span></span>(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">init/main.c),trap_init()</span></span>(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/traps.c</span></span>)調用的C語言宏定義<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">set_system_gate(0x80,&system_call)</span></span>(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">include/asm/system.h</span></span>)設置<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">0x80</span></span>號軟中斷的服務程序為 system_call(見<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/entry.S</span></span>), <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system.call</span></span>就是所有系統調用的總入口。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">內核如何為各種系統調用服務</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">當進程需要進行系統調用時，必須以C語言函數的形式寫一句系統調用命令。該命令如果已在某個頭文件中由相應的</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscallN()</span></span>展開，則用戶程序必須包含該文件。當進程執行到用戶程序的系統調用命令時，實際上執行了由宏命令_syscallN()展開的函數。系統調用的參數 由各通用寄存器傳遞，然後執行INT 0x80，以內核態進入入口地址<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system_call</span></span>。</p><h1 class=pgc-h-arrow-right><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ret_from_sys_call</span></span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ret_from_sys_call</span></span>入口的彙編程序段在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">linux</span></span>進程管理中起到了十分重要的作用。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">所有系統調用結束前以及大部分</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">中斷</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">服務返回前，都會跳轉至此處入口地址。 該段程序不僅僅為系統調用服務，它還處理中斷嵌套、CPU調度、信號等事務。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">內核如何為系統調用的參數傳遞參數</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">參數傳遞</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">除了系統調用號以外，大部分系統調用都還需要一些外部的參數</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">輸人</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。所以，在發生異常的時候，應該把這些參數從用戶空間傳給內核。最簡單的辦法就是像傳遞系統調用號一樣把這些參數也存放在寄存器裡。在x86系統上，</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ebx</span></span>, <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ecx</span></span>, <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">edx</span></span>, <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">esi</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">edi</span></span>按照順序存放前五個參數。需要六個或六個以上參數的情況不多見，此時，應該用一個單獨的寄存器存放指向所有這些參數在用戶空間地址的指針。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">給用戶空間的返回值也通過寄存器傳遞。在x86系統上，它存放在eax寄存器中。接下來許多關於系統調用處理程序的描述都是針對x86版本的。但不用擔心，所有體系結構的實現都很類似。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">參數驗證</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統調用必須仔細檢查它們所有的參數是否合法有效。舉例來說，與文件I/O相關的系統調用必須檢查文件描述符是否有效。與進程相關的函數必須檢查提供的PID是否有效。必須檢查每個參數，保證它們不但合法有效，而且正確。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最重要的一種檢查就是檢查用戶提供的指針是否有效。試想，如果一個進程可以給內核傳遞指針而又無須被檢查，那麼它就可以給出一個它根本就沒有訪問權限的指針，哄騙內核去為它拷貝本不允許它訪問的數據，如原本屬於其他進程的數據。在接收一個用戶空間的指針之前，內核必須保證：</span></p><ul><li><span style="color:#4d4d4d;--tt-darkmode-color: #999999">指針指向的內存區域屬於用戶空間。進程決不能哄騙內核去讀內核空間的數據。</span></li><li><span style="color:#4d4d4d;--tt-darkmode-color: #999999">指針指向的內存區域在進程的地址空間裡。進程決不能哄騙內核去讀其他進程的數據。</span></li><li><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果是讀，該內存應被標記為可讀。如果是寫，該內存應被標記為可寫。進程決不能繞過內存訪問限制。</span></li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">內核提供了兩個方法來完成必須的檢查和內核空間與用戶空間之間數據的來回拷貝。注意，內核無論何時都不能輕率地接受來自用戶空間的指針!這兩個方法中必須有一個被調用。為了向用戶空間寫入數據，內核提供了</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_to_user()</span></span>，它需要三個參數。第一個參數是進程空間中的目的內存地址。第二個是內核空間內的源地址。最後一個參數是需要拷貝的數據長度(字節數)。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">為了從用戶空間讀取數據，內核提供了</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_from_ user()</span></span>，它和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy-to-User()</span></span>相似。該函數把第二個參數指定的位置上的數據拷貝到第一個參數指定的位置上，拷貝的數據長度由第三個參數決定。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果執行失敗，這兩個函數返回的都是沒能完成拷貝的數據的字節數。如果成功，返回0。當出現上述錯誤時，系統調用返回標準-EFAULT。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_to_user()</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_from_user()</span></span>都有可能引起阻塞。當包含用戶數據的頁被換出到硬盤上而不是在物理內存上的時候，這種情況就會發生。此時，進程就會休眠，直到缺頁處理程序將該頁從硬盤重新換回物理內存。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用的返回值</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系統調用(在Linux中常稱作syscalls)通常通過函數進行調用。它們通常都需要定義一個或幾個參數(輸入)而且可能產生一些副作用，例如寫某個文件或向給定的指針拷貝數據等等。為防止和正常的返回值混淆，系統調用並不直接返回錯誤碼，而是將錯誤碼放入一個名為errno的全局變量中。通常用一個負的返回值來表明錯誤。返回一個0值通常表明成功。如果一個系統調用失敗，你可以讀出errno的值來確定問題所在。通過調用perror()庫函數，可以把該變量翻譯成用戶可以理解的錯誤字符串。</span></p><p style=text-align:start><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>不同數值所代表的錯誤消息定義在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno.h</span></span>中，你也可以通過命令”man 3 errno”來察看它們。需要注意的是，<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>的值只在函數發生錯誤時設置，如果函數不發生錯誤，<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>的值就無定義，並不會被置為0。另外，在處理<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>前最好先把它的值存入另一個變量，因為在錯誤處理過程中，即使像<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">printf()</span></span>這樣的函數出錯時也會改變<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>的值。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">當然，系統調用最終具有一種明確的操作。舉例來說，如getpid()系統調用，根據定義它會返回當前進程的PID。內核中它的實現非常簡單:</span></p><pre><code>asmlinkage long sys_ getpid(void){    return current-&gt; tgid;}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">上述的系統調用盡管非常簡單，但我們還是可以從中發現兩個特別之處。首先，注意函數聲明中的asmlinkage限定詞，這是一個小</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">戲法</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，用於通知編譯器僅從棧中提取該函數的參數。所有的系統調用都需要這個限定詞。其次，注意系統調用get_pid()在內核中被定義成sys_ getpid。這是Linux中所有系統調用都應該遵守的命名規則。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">訪問系統調用</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用上下文</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">內核在執行系統調用的時候處於進程上下文。</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">current</span></span>指針指向當前任務，即引發系統調用的那個進程。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在進程上下文中，內核可以休眠並且可以被搶佔。這兩點都很重要。首先，能夠休眠說明系統調用可以使用內核提供的絕大部分功能。休眠的能力會給內核編程帶來極大便利。在進程上下文中能夠被搶佔，其實表明，像用戶空間內的進程一樣，當前的進程同樣可以被其他進程搶佔。因為新的進程可以使用相同的系統調用，所以必須小心，保證該系統調用是可重人的。當然，這也是在對稱多處理中必須同樣關心的問題。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">當系統調用返回的時候，控制權仍然在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system_call()</span></span>中，它最終會負責切換到用戶空間並讓用戶進程繼續執行下去。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用訪問示例</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">操作系統使用系統調用表將系統調用編號翻譯為特定的系統調用。系統調用表包含有實現每個系統調用的函數的地址。例如，</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">read()</span></span> 系統調用函數名為<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read</span></span>。<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">read()</span></span>系統調用編號是 3，所以<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span> 位於系統調用表的第四個條目中（因為系統調用起始編號為0）。從地址 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table + (3 * word_size)</span></span> 讀取數據，得到<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span>的地址。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">找到正確的系統調用地址後，它將控制權轉交給那個系統調用。我們來看定義</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span>的位置，即<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">fs/read_write.c</span></span>文件。這個函數會找到關聯到 fd 編號（傳遞給 read() 函數的）的文件結構體。那個結構體包含指向用來讀取特定類型文件數據的函數的指針。進行一些檢查後，它調用與文件相關的 read() 函數，來真正從文件中讀取數據並返回。與文件相關的函數是在其他地方定義的 —— 比如套接字代碼、文件系統代碼，或者設備驅動程序代碼。這是特定內核子系統最終與內核其他部分協作的一個方面。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">讀取函數結束後，從</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span>返回，它將控制權切換給 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ret_from_sys</span></span>。它會去檢查那些在切換回用戶空間之前需要完成的任務。如果沒有需要做的事情，那麼就恢復用戶進程的狀態，並將控制權交還給用戶程序。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">從用戶空間直接訪問系統調用</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通常，系統調用靠C庫支持。用戶程序通過包含標準頭文件並和C庫鏈接，就可以使用系統調用(或者調用庫函數，再由庫函數實際調用)。但如果你僅僅寫出系統調用，glibc庫恐怕並不提供支持。值得慶幸的是，Linux本身提供了一組宏，用於直接對系統調用進行訪問。它會設置好寄存器並調用陷人指令。這些宏是</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscalln()</span></span>，其中n的範圍從0到6。代表需要傳遞給系統調用的參數個數，這是由於該宏必須瞭解到底有多少參數按照什麼次序壓入寄存器。舉個例子，open()系統調用的定義是:</p><pre><code>long open(const char *filename, int flags, int mode)</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">而不靠庫支持，直接調用此係統調用的宏的形式為:</span></p><pre><code>#define NR_ open 5syscall3(long, open, const char*，filename, int, flags, int, mode)</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這樣，應用程序就可以直接使用</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">open()</span></span><br>對於每個宏來說，都有2+ n個參數。<br>第一個參數對應著系統調用的返回值類型。<br>第二個參數是系統調用的名稱。再以後是按照系統調用參數的順序排列的每個參數的類型和名稱。<br><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_NR_ open</span></span>在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">&lt;asm/unistd.h></span></span>中定義，是系統調用號。該宏會被擴展成為內嵌彙編的C函數。由彙編語言執行前一節所討論的步驟，將系統調用號和參數壓入寄存器並觸發軟中斷來陷入內核。調用<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">open()</span></span>系統調用直接把上面的宏放置在應用程序中就可以了。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">讓我們寫一個宏來使用前面編寫的foo()系統調用，然後再寫出測試代碼炫耀一下我們所做的努力。</span></p><pre><code>#define NR foo 283_sysca110(long, foo)int main(){long stack size;stack_ size=foo();printf("The kernel stacksize is 81d/n"，stack_ size);return;}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">添加系統調用</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">通過修改內核源代碼添加系統調用</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">linux-2.6.*</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通過以上分析linux系統調用的過程，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">將自己的系統調用加到內核中就是一件容易的事情。下面介紹一個實際的系統調用，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">並把它加到內核中去。要增加的系統調用是：inttestsyscall()，其功能是在控制終端屏幕上顯示hello world，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">執行成功後返回0。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">編寫int testsyscall()系統調用–響應函數</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">編寫一個系統調用意味著要給內核增加1個函數，將新函數放入文件kernel/sys.c中。新函數代碼如下：</span></p><pre><code>asmlingkage sys_testsyscall(){     print("hello world\n");        return 0; }</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">添加系統調用號</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">編寫了新的系統調用過程後，下一項任務是使內核的其餘部分知道這一程序的存在，然後重建包含新的系統調用的內核。為了把新的函數連接到已有的內核中去， 需要編輯2個文件：</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1).inculde/asm/unistd.h在這個文件中加入</span></p><pre><code>#define_NR_testsyscall 191</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統調用表中添加對應項</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2).are/i386/kernel/entry.s這個文件用來對指針數組初始化，在這個文件中增加一行：</span></p><pre><code> .long SYMBOL_NAME(_sys_tsetsycall)</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">將</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">.rept NR_syscalls-190</span></span>改為<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">NR_SYSCALLS-191</span></span>,然後重新編譯和運行新內核。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">使用新的系統調用</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在保證的C語言庫中沒有新的系統調用的程序段，必須自己建立其代碼如下</span></p><pre><code>#inculde_syscall0(int,testsyscall)main(){    tsetsyscall();}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在這裡使用了</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscall0</span></span>宏指令，宏指令本身在程序中將擴展成名為<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">syscall()</span></span>的函數，它在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">main()</span></span>函數內部加以調用。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">testsyscall()</span></span>函數中， 預處理程序產生所有必要的機器指令代碼，包括用系統調用參數值加載相應的<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">cpu</span></span>寄存器， 然後執行<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">int 0x80</span></span>中斷指令。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">linux-3.*</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在linux-3.8.4/kernel/sys.c 文件末尾添加新的系統調用函數如：</span></p><pre><code>asmlinkage int sys_mycall(int number){        printk("這是我添加的第一個系統調用");        return number; }</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/x86/syscall_32.tbl</span></span>下找到<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">unused 223</span></span>號調用然後替換如：</p><pre><code>223 i386 mycall sys_mycall</code></pre><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">如果是64位系統，在</span></span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/x86/syscalls/syscall_64.tbl</span></span>下找到<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">313</span></span>號系統調用，然後在其下面加上<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">314</span></span>號自己的中斷如：<br>`314 common mycall sys_mycall</p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">利用內核模塊添加系統調用</span></h1><hr><p>模塊是內核的一部分，但是並沒有被編譯到內核裡面去。它們被分別編譯並連接成一組目標文件， 這些文件能被插入到正在運行的內核，或者從正在運行的內核中移走。內核模塊至少必須有2個函數：<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">init_module</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">cleanup_module</span></span>。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第一個函數是在把模塊插入內核時調用的;</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第二個函數則在刪除該模塊時調用。由於內核模塊是內核的一部分，所以能訪問所有內核資源。根據對linux系統調用機制的分析，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果要增加系統調用，可以編寫自己的函數來實現，然後在sys_call_table表中增加一項，使該項中的指針指向自己編寫的函數，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">就可以實現系統調用。下面用該方法實現在控制終端上打印“hello world” 的系統調用testsyscall()。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">編寫系統調用內核模塊</span></h1><hr><pre><code>#inculde(linux/kernel.h)#inculde(linux/module.h)#inculde(linux/modversions.h)#inculde(linux/sched.h) #inculde(asm/uaccess.h)#define_NR_testsyscall 191extern viod *sys_call+table[];asmlinkage int testsyscall(){     printf("hello world\n");    return 0;}int init_module(){     sys_call_table[_NR_tsetsyscall]=testsyscall;    printf("system call testsyscall() loaded success\n");    return 0;}void cleanup_module(){}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">使用新的系統調用</span></h1><pre><code>#define_NR_testsyscall 191_syscall0(int,testsyscall)main(){    testsyscall();}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">內核Linux系統調用的列表</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以下是Linux系統調用的一個列表，包含了大部分常用系統調用和由系統調用派生出的的函數。</span></p><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">進程控制</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2b918ff71dcc4802a2f95b99410e7cfe><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">文件系統控制</span></h1><hr><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">文件讀寫操作</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e48933b57a94945918b332e448f99c5><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">文件系統操作</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5f66ec6f76d142b08f91eb6f928d79c9><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系統控制</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/21f54a6904da4b4fac5afff2dec5cd1f><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">內存管理</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1f4c3d6a9494487ea548e116af35e96a><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">網絡管理</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/437cc925bf2c4e8285fb73d6f1c7babf><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">socket控制</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/88ef63bdf49c41ab82af6fa6f4cad79a><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">用戶管理</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3abe8c1de0b4d6c8d21b340cd1c84ed><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">進程間通信</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bfc68fded2a34ad7b61528317cec0fc9><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">信號</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8551fa049fe745338ebf72838a71e7d9><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">消息</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/adc0c57b9d0a41ab87dfe6fe7d2e2cd0><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">管道</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/079c2fe70c4c4d528437f9301576aad3><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">信號量</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfc9e4d0d1af4865a87caa8b1a5cade7><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">共享內存</span></strong></p><div class=pgc-img><img alt=Linux系統調用詳解（實現機制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/51bb56add68b4e06b13d8a585a78749e><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>系統</a></li><li><a>調用</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html alt=Linux系統常用命令大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html title=Linux系統常用命令大全>Linux系統常用命令大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d39b51ac.html alt=Linux操作系統存儲子系統核心技術之硬盤與RAID class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/12a0a3d09fd54be3b2087a5d45b798b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d39b51ac.html title=Linux操作系統存儲子系統核心技術之硬盤與RAID>Linux操作系統存儲子系統核心技術之硬盤與RAID</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/59993286.html alt="Linux 文件系統介紹" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/50a30000b2bb9135b878 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/59993286.html title="Linux 文件系統介紹">Linux 文件系統介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8024f20c.html alt="Linux 文件系統剖析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7ea491ff1de847568632e723367af267 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8024f20c.html title="Linux 文件系統剖析">Linux 文件系統剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13a20156.html alt=Linux文件系統101 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/184733a1b935442eaf00466d218e78af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13a20156.html title=Linux文件系統101>Linux文件系統101</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d5836cb.html alt=Linux文件系統介紹：Ext、XFS、Btrfs等，選擇適合自己的文件系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/988b5ddedbeb42e8ae01b11a525ff754 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d5836cb.html title=Linux文件系統介紹：Ext、XFS、Btrfs等，選擇適合自己的文件系統>Linux文件系統介紹：Ext、XFS、Btrfs等，選擇適合自己的文件系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/198ca4e7.html alt=Linux文件系統概念解釋 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153dc1ea3f434fef9762d98d4d308380 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/198ca4e7.html title=Linux文件系統概念解釋>Linux文件系統概念解釋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/11002b4c.html alt=Linux文件系統目錄標準介紹（FHS） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5fcf0579209e4a4794121746fe9b8ddc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/11002b4c.html title=Linux文件系統目錄標準介紹（FHS）>Linux文件系統目錄標準介紹（FHS）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b2909f2b.html alt=Linux文件系統與目錄結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b2909f2b.html title=Linux文件系統與目錄結構>Linux文件系統與目錄結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10be8693.html alt=一篇文章講清Linux操作系統的目錄結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/64f85cc0fcc548d99f56bd2567c34511 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10be8693.html title=一篇文章講清Linux操作系統的目錄結構>一篇文章講清Linux操作系統的目錄結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4717b88a.html alt=嵌入式開發之Linux系統中文件和目錄相關命令 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1d8b5c2d75ba4ed5a0cc99267cb18c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4717b88a.html title=嵌入式開發之Linux系統中文件和目錄相關命令>嵌入式開發之Linux系統中文件和目錄相關命令</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd75dea8.html alt="系統瞭解 Linux 文件系統" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3b15000077fa0e231516 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd75dea8.html title="系統瞭解 Linux 文件系統">系統瞭解 Linux 文件系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1b6548ae.html alt=詳解Linux系統架構--內核（內存、進程、設備、文件系統和網絡） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/69fc12e26bdd4ebf942d997de47a1396 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1b6548ae.html title=詳解Linux系統架構--內核（內存、進程、設備、文件系統和網絡）>詳解Linux系統架構--內核（內存、進程、設備、文件系統和網絡）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7ea2e49.html alt=Linux文件系統是怎麼工作的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/dc7369f3a6f547b4a03c383142a7af8c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7ea2e49.html title=Linux文件系統是怎麼工作的？>Linux文件系統是怎麼工作的？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>