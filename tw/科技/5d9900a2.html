<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Flink中的數據抽象及數據交換過程 | 极客快訊</title><meta property="og:title" content="Flink中的數據抽象及數據交換過程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/1b7a1014-7ea5-421b-808e-c41398f5e4aa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><meta property="article:published_time" content="2020-11-14T21:00:07+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:07+08:00"><meta name=Keywords content><meta name=description content="Flink中的數據抽象及數據交換過程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5d9900a2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Flink中的數據抽象及數據交換過程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Flink中的數據抽象及數據交換過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/1b7a1014-7ea5-421b-808e-c41398f5e4aa><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>Flink的數據抽象</h1><p><strong>MemorySegment</strong></p><p>Flink作為一個高效的流框架，為了避免JVM的固有缺陷（java對象存儲密度低，FGC影響吞吐和響應等），必然走上自主管理內存的道路。</p><p>這個MemorySegment就是Flink的內存抽象。默認情況下，一個MemorySegment可以被看做是一個32kb大的內存塊的抽象。這塊內存既可以是JVM裡的一個byte[]，也可以是堆外內存（DirectByteBuffer）。</p><p>如果說byte[]數組和direct memory是最底層的存儲，那麼memorysegment就是在其上覆蓋的一層統一抽象。它定義了一系列抽象方法，用於控制和底層內存的交互，如：</p><pre><code>public abstract class MemorySegment {    public abstract byte get(int index);        public abstract void put(int index, byte b);        public int size() ;        public abstract ByteBuffer wrap(int offset, int length);        ......}</code></pre><p>我們可以看到，它在提供了諸多直接操作內存的方法外，還提供了一個wrap()方法，將自己包裝成一個ByteBuffer，我們待會兒講這個ByteBuffer。</p><p>Flink為MemorySegment提供了兩個實現類：HeapMemorySegment和HybridMemorySegment。他們的區別在於前者只能分配堆內存，而後者能用來分配堆內和堆外內存。事實上，Flink框架裡，只使用了後者。這是為什麼呢？</p><p>如果HybridMemorySegment只能用於分配堆外內存的話，似乎更合常理。但是在JVM的世界中，如果一個方法是一個虛方法，那麼每次調用時，JVM都要花時間去確定調用的到底是哪個子類實現的該虛方法（方法重寫機制，不明白的去看JVM的invokeVirtual指令），也就意味著每次都要去翻方法表；而如果該方法雖然是個虛方法，但實際上整個JVM裡只有一個實現（就是說只加載了一個子類進來），那麼JVM會很聰明的把它去虛化處理，這樣就不用每次調用方法時去找方法表了，能夠大大提升性能。但是隻分配堆內或者堆外內存不能滿足我們的需要，所以就出現了HybridMemorySegment同時可以分配兩種內存的設計。</p><p>我們可以看看HybridMemorySegment的構造代碼：</p><pre><code>HybridMemorySegment(ByteBuffer buffer, Object owner) {        super(checkBufferAndGetAddress(buffer), buffer.capacity(), owner);        this.offHeapBuffer = buffer;    }            HybridMemorySegment(byte[] buffer, Object owner) {        super(buffer, owner);        this.offHeapBuffer = null;    }</code></pre><p>其中，第一個構造函數的checkBufferAndGetAddress()方法能夠得到direct buffer的內存地址，因此可以操作堆外內存。</p><h1 class=pgc-h-arrow-right>ByteBuffer與NetworkBufferPool</h1><p>在MemorySegment這個抽象之上，Flink在數據從operator內的數據對象在向TaskManager上轉移，預備被髮給下個節點的過程中，使用的抽象或者說內存對象是Buffer。</p><p>注意，這個Buffer是個flink接口，不是java.nio提供的那個Buffer抽象類。Flink在這一層面同時使用了這兩個同名概念，用來存儲對象，直接看代碼時到處都是各種xxxBuffer很容易混淆：</p><ul class=list-paddingleft-2><li>java提供的那個Buffer抽象類在這一層主要用於構建HeapByteBuffer，這個主要是當數據從jvm裡的一個對象被序列化成字節數組時用的；</li><li>Flink的這個Buffer接口主要是一種flink層面用於傳輸數據和事件的統一抽象，其實現類是NetworkBuffer，是對MemorySegment的包裝。Flink在各個TaskManager之間傳遞數據時，使用的是這一層的抽象。因為Buffer的底層是MemorySegment，這可能不是JVM所管理的，所以為了知道什麼時候一個Buffer用完了可以回收，Flink引入了引用計數的概念，當確認這個buffer沒有人引用，就可以回收這一片MemorySegment用於別的地方了（JVM的垃圾回收為啥不用引用計數？讀者思考一下）：</li></ul><pre><code>public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {    private volatile int refCnt = 1;        ......}</code></pre><p>為了方便管理NetworkBuffer，Flink提供了BufferPoolFactory，並且提供了唯一實現NetworkBufferPool，這是個工廠模式的應用。</p><p>NetworkBufferPool在每個TaskManager上只有一個，負責所有子task的內存管理。其實例化時就會嘗試獲取所有可由它管理的內存（對於堆內存來說，直接獲取所有內存並放入老年代，並令用戶對象只在新生代存活，可以極大程度的減少Full GC），我們看看其構造方法：</p><pre><code>public NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize) {        ......                try {            this.availableMemorySegments = new ArrayBlockingQueue&lt;&gt;(numberOfSegmentsToAllocate);        }        catch (OutOfMemoryError err) {            throw new OutOfMemoryError("Could not allocate buffer queue of length "                    + numberOfSegmentsToAllocate + " - " + err.getMessage());        }        try {            for (int i = 0; i &lt; numberOfSegmentsToAllocate; i++) {                ByteBuffer memory = ByteBuffer.allocateDirect(segmentSize);                availableMemorySegments.add(MemorySegmentFactory.wrapPooledOffHeapMemory(memory, null));            }        }        ......                long allocatedMb = (sizeInLong * availableMemorySegments.size()) &gt;&gt; 20;        LOG.info("Allocated {} MB for network buffer pool (number of memory segments: {}, bytes per segment: {}).",                allocatedMb, availableMemorySegments.size(), segmentSize);    }</code></pre><p>由於NetworkBufferPool只是個工廠，實際的內存池是LocalBufferPool。每個TaskManager都只有一個NetworkBufferPool工廠，但是上面運行的每個task都要有一個和其他task隔離的LocalBufferPool池，這從邏輯上很好理解。另外，NetworkBufferPool會計算自己所擁有的所有內存分片數，在分配新的內存池時對每個內存池應該佔有的內存分片數重分配，步驟是：</p><ul class=list-paddingleft-2><li>首先，從整個工廠管理的內存片中拿出所有的內存池所需要的最少Buffer數目總和如果正好分配完，就結束</li><li>其次，把所有的剩下的沒分配的內存片，按照每個LocalBufferPool內存池的剩餘想要容量大小進行按比例分配</li><li>剩餘想要容量大小是這麼個東西：如果該內存池至少需要3個buffer，最大需要10個buffer，那麼它的剩餘想要容量就是7實現代碼如下：</li></ul><pre><code>private void redistributeBuffers() throws IOException {        assert Thread.holdsLock(factoryLock);        // All buffers, which are not among the required ones        final int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;        if (numAvailableMemorySegment == 0) {            // in this case, we need to redistribute buffers so that every pool gets its minimum            for (LocalBufferPool bufferPool : allBufferPools) {                bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());            }            return;        }        long totalCapacity = 0; // long to avoid int overflow        for (LocalBufferPool bufferPool : allBufferPools) {            int excessMax = bufferPool.getMaxNumberOfMemorySegments() -                bufferPool.getNumberOfRequiredMemorySegments();            totalCapacity += Math.min(numAvailableMemorySegment, excessMax);        }        // no capacity to receive additional buffers?        if (totalCapacity == 0) {            return; // necessary to avoid div by zero when nothing to re-distribute        }        final int memorySegmentsToDistribute = MathUtils.checkedDownCast(                Math.min(numAvailableMemorySegment, totalCapacity));        long totalPartsUsed = 0; // of totalCapacity        int numDistributedMemorySegment = 0;        for (LocalBufferPool bufferPool : allBufferPools) {            int excessMax = bufferPool.getMaxNumberOfMemorySegments() -                bufferPool.getNumberOfRequiredMemorySegments();            // shortcut            if (excessMax == 0) {                continue;            }            totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);            final int mySize = MathUtils.checkedDownCast(                    memorySegmentsToDistribute * totalPartsUsed / totalCapacity - numDistributedMemorySegment);            numDistributedMemorySegment += mySize;            bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);        }        assert (totalPartsUsed == totalCapacity);        assert (numDistributedMemorySegment == memorySegmentsToDistribute);    }</code></pre><p>接下來說說這個LocalBufferPool內存池。<br>LocalBufferPool的邏輯想想無非是增刪改查，值得說的是其fields：</p><pre><code>/** 該內存池需要的最少內存片數目*/    private final int numberOfRequiredMemorySegments;    /**     * 當前已經獲得的內存片中，還沒有寫入數據的空白內存片     */    private final ArrayDeque&lt;MemorySegment&gt; availableMemorySegments = new ArrayDeque&lt;MemorySegment&gt;();    /**     * 註冊的所有監控buffer可用性的監聽器     */    private final ArrayDeque&lt;BufferListener&gt; registeredListeners = new ArrayDeque&lt;&gt;();    /** 能給內存池分配的最大分片數*/    private final int maxNumberOfMemorySegments;    /** 當前內存池大小 */    private int currentPoolSize;    /**     * 所有經由NetworkBufferPool分配的，被本內存池引用到的（非直接獲得的）分片數     */    private int numberOfRequestedMemorySegments;</code></pre><p>承接NetworkBufferPool的重分配方法，我們來看看LocalBufferPool的setNumBuffers()方法，代碼很短，邏輯也相當簡單，就不展開說了：</p><pre><code>public void setNumBuffers(int numBuffers) throws IOException {        synchronized (availableMemorySegments) {            checkArgument(numBuffers &gt;= numberOfRequiredMemorySegments,                    "Buffer pool needs at least %s buffers, but tried to set to %s",                    numberOfRequiredMemorySegments, numBuffers);            if (numBuffers &gt; maxNumberOfMemorySegments) {                currentPoolSize = maxNumberOfMemorySegments;            } else {                currentPoolSize = numBuffers;            }            returnExcessMemorySegments();            // If there is a registered owner and we have still requested more buffers than our            // size, trigger a recycle via the owner.            if (owner != null &amp;&amp; numberOfRequestedMemorySegments &gt; currentPoolSize) {                owner.releaseMemory(numberOfRequestedMemorySegments - numBuffers);            }        }    }</code></pre><h1 class=pgc-h-arrow-right><strong>RecordWriter與Record</strong></h1><p>我們接著往高層抽象走，剛剛提到了最底層內存抽象是MemorySegment，用於數據傳輸的是Buffer，那麼，承上啟下對接從Java對象轉為Buffer的中間對象是什麼呢？是StreamRecord。</p><p>從StreamRecord&lt;T>這個類名字就可以看出來，這個類就是個wrap，裡面保存了原始的Java對象。另外，StreamRecord還保存了一個timestamp。</p><p>那麼這個對象是怎麼變成LocalBufferPool內存池裡的一個大號字節數組的呢？藉助了StreamWriter這個類。</p><p>我們直接來看把數據序列化交出去的方法：</p><pre><code>private void sendToTarget(T record, int targetChannel) throws IOException, InterruptedException {        RecordSerializer&lt;T&gt; serializer = serializers[targetChannel];        SerializationResult result = serializer.addRecord(record);        while (result.isFullBuffer()) {            if (tryFinishCurrentBufferBuilder(targetChannel, serializer)) {                // If this was a full record, we are done. Not breaking                // out of the loop at this point will lead to another                // buffer request before breaking out (that would not be                // a problem per se, but it can lead to stalls in the                // pipeline).                if (result.isFullRecord()) {                    break;                }            }            BufferBuilder bufferBuilder = requestNewBufferBuilder(targetChannel);            result = serializer.continueWritingWithNextBufferBuilder(bufferBuilder);        }        checkState(!serializer.hasSerializedData(), "All data should be written at once");                                if (flushAlways) {            targetPartition.flush(targetChannel);        }    }</code></pre><p>先說最後一行，如果配置為flushAlways，那麼會立刻把元素髮送出去，但是這樣吞吐量會下降；Flink的默認設置其實也不是一個元素一個元素的發送，是單獨起了一個線程，每隔固定時間flush一次所有channel，較真起來也算是mini batch了。再說序列化那一句:SerializationResult result = serializer.addRecord(record);。在這行代碼中，Flink把對象調用該對象所屬的序列化器序列化為字節數組。</p><h1 class=pgc-h-arrow-right>數據流轉過程</h1><p>上一節講了各層數據的抽象，這一節講講數據在各個task之間exchange的過程。</p><h1 class=pgc-h-arrow-right>整體過程</h1><p>看這張圖：</p><div class=pgc-img><img alt=Flink中的數據抽象及數據交換過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/867ece4553124fdfb6151b38bb0dbc77><p class=pgc-img-caption></p></div><p>1.第一步必然是準備一個ResultPartition；2.通知JobMaster；3.JobMaster通知下游節點；如果下游節點尚未部署，則部署之；4.下游節點向上遊請求數據5.開始傳輸數據</p><h1 class=pgc-h-arrow-right>數據跨task傳遞</h1><p>本節講一下算子之間具體的數據傳輸過程。也先上一張圖：</p><div class=pgc-img><img alt=Flink中的數據抽象及數據交換過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b5f2986097a4c7b929313895f2cae05><p class=pgc-img-caption></p></div><p>數據在task之間傳遞有如下幾步：</p><p>1.數據在本operator處理完後，交給RecordWriter。每條記錄都要選擇一個下游節點，所以要經過ChannelSelector。2.每個channel都有一個serializer（我認為這應該是為了避免多線程寫的麻煩），把這條Record序列化為ByteBuffer3.接下來數據被寫入ResultPartition下的各個subPartition裡，此時該數據已經存入DirectBuffer（MemorySegment）4.單獨的線程控制數據的flush速度，一旦觸發flush，則通過Netty的nio通道向對端寫入5.對端的netty client接收到數據，decode出來，把數據拷貝到buffer裡，然後通知InputChannel6.有可用的數據時，下游算子從阻塞醒來，從InputChannel取出buffer，再解序列化成record，交給算子執行用戶代碼數據在不同機器的算子之間傳遞的步驟就是以上這些。</p><p>瞭解了步驟之後，再來看一下部分關鍵代碼：首先是把數據交給recordwriter。</p><pre><code>//RecordWriterOutput.java    @Override    public void collect(StreamRecord&lt;OUT&gt; record) {        if (this.outputTag != null) {            // we are only responsible for emitting to the main input            return;        }        //這裡可以看到把記錄交給了recordwriter        pushToRecordWriter(record);    }</code></pre><p>然後recordwriter把數據發送到對應的通道。</p><pre><code>//RecordWriter.java    public void emit(T record) throws IOException, InterruptedException {        //channelselector登場了        for (int targetChannel : channelSelector.selectChannels(record, numChannels)) {            sendToTarget(record, targetChannel);        }    }            private void sendToTarget(T record, int targetChannel) throws IOException, InterruptedException {                //選擇序列化器並序列化數據        RecordSerializer&lt;T&gt; serializer = serializers[targetChannel];        SerializationResult result = serializer.addRecord(record);        while (result.isFullBuffer()) {            if (tryFinishCurrentBufferBuilder(targetChannel, serializer)) {                // If this was a full record, we are done. Not breaking                // out of the loop at this point will lead to another                // buffer request before breaking out (that would not be                // a problem per se, but it can lead to stalls in the                // pipeline).                if (result.isFullRecord()) {                    break;                }            }            BufferBuilder bufferBuilder = requestNewBufferBuilder(targetChannel);            //寫入channel            result = serializer.continueWritingWithNextBufferBuilder(bufferBuilder);        }        checkState(!serializer.hasSerializedData(), "All data should be written at once");        if (flushAlways) {            targetPartition.flush(targetChannel);        }    }</code></pre><p>接下來是把數據推給底層設施（netty）的過程：</p><pre><code>//ResultPartition.java    @Override    public void flushAll() {        for (ResultSubpartition subpartition : subpartitions) {            subpartition.flush();        }    }            //PartitionRequestQueue.java        void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {        //這裡交給了netty server線程去推        ctx.executor().execute(new Runnable() {            @Override            public void run() {                ctx.pipeline().fireUserEventTriggered(reader);            }        });    }</code></pre><p>netty相關的部分：</p><pre><code>//AbstractChannelHandlerContext.java    public ChannelHandlerContext fireUserEventTriggered(final Object event) {        if (event == null) {            throw new NullPointerException("event");        } else {            final AbstractChannelHandlerContext next = this.findContextInbound();            EventExecutor executor = next.executor();            if (executor.inEventLoop()) {                next.invokeUserEventTriggered(event);            } else {                executor.execute(new OneTimeTask() {                    public void run() {                        next.invokeUserEventTriggered(event);                    }                });            }            return this;        }    }</code></pre><p>最後真實的寫入：</p><pre><code>//PartittionRequesetQueue.java    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {        if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {            return;        }        // Queue an available reader for consumption. If the queue is empty,        // we try trigger the actual write. Otherwise this will be handled by        // the writeAndFlushNextMessageIfPossible calls.        boolean triggerWrite = availableReaders.isEmpty();        registerAvailableReader(reader);        if (triggerWrite) {            writeAndFlushNextMessageIfPossible(ctx.channel());        }    }        private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {                ......                next = reader.getNextBuffer();                if (next == null) {                    if (!reader.isReleased()) {                        continue;                    }                    markAsReleased(reader.getReceiverId());                    Throwable cause = reader.getFailureCause();                    if (cause != null) {                        ErrorResponse msg = new ErrorResponse(                            new ProducerFailedException(cause),                            reader.getReceiverId());                        ctx.writeAndFlush(msg);                    }                } else {                    // This channel was now removed from the available reader queue.                    // We re-add it into the queue if it is still available                    if (next.moreAvailable()) {                        registerAvailableReader(reader);                    }                    BufferResponse msg = new BufferResponse(                        next.buffer(),                        reader.getSequenceNumber(),                        reader.getReceiverId(),                        next.buffersInBacklog());                    if (isEndOfPartitionEvent(next.buffer())) {                        reader.notifySubpartitionConsumed();                        reader.releaseAllResources();                        markAsReleased(reader.getReceiverId());                    }                    // Write and flush and wait until this is done before                    // trying to continue with the next buffer.                    channel.writeAndFlush(msg).addListener(writeListener);                    return;                }                ......            }</code></pre><p>上面這段代碼裡第二個方法中調用的writeAndFlush(msg)就是真正往netty的nio通道里寫入的地方了。在這裡，寫入的是一個RemoteInputChannel，對應的就是下游節點的InputGate的channels。</p><p>有寫就有讀，nio通道的另一端需要讀入buffer，代碼如下：</p><pre><code>//CreditBasedPartitionRequestClientHandler.java    private void decodeMsg(Object msg) throws Throwable {        final Class&lt;?&gt; msgClazz = msg.getClass();        // ---- Buffer --------------------------------------------------------        if (msgClazz == NettyMessage.BufferResponse.class) {            NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;            RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);            if (inputChannel == null) {                bufferOrEvent.releaseBuffer();                cancelRequestFor(bufferOrEvent.receiverId);                return;            }            decodeBufferOrEvent(inputChannel, bufferOrEvent);        }                ......            }</code></pre><p>插一句，Flink其實做阻塞和獲取數據的方式非常自然，利用了生產者和消費者模型，當獲取不到數據時，消費者自然阻塞；當數據被加入隊列，消費者被notify。Flink的背壓機制也是藉此實現。</p><p>然後在這裡又反序列化成StreamRecord：</p><pre><code>//StreamElementSerializer.java    public StreamElement deserialize(DataInputView source) throws IOException {        int tag = source.readByte();        if (tag == TAG_REC_WITH_TIMESTAMP) {            long timestamp = source.readLong();            return new StreamRecord&lt;T&gt;(typeSerializer.deserialize(source), timestamp);        }        else if (tag == TAG_REC_WITHOUT_TIMESTAMP) {            return new StreamRecord&lt;T&gt;(typeSerializer.deserialize(source));        }        else if (tag == TAG_WATERMARK) {            return new Watermark(source.readLong());        }        else if (tag == TAG_STREAM_STATUS) {            return new StreamStatus(source.readInt());        }        else if (tag == TAG_LATENCY_MARKER) {            return new LatencyMarker(source.readLong(), new OperatorID(source.readLong(), source.readLong()), source.readInt());        }        else {            throw new IOException("Corrupt stream, found tag: " + tag);        }    }</code></pre><p>然後再次在StreamInputProcessor.processInput()循環中得到處理。</p><p>至此，數據在跨jvm的節點之間的流轉過程就講完了。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>Flink</a></li><li><a>交換</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/611f4508.html alt=BIM模型數據主要有哪些交換方式與方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8b3a0009c04f47dba125fac42117633d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/611f4508.html title=BIM模型數據主要有哪些交換方式與方法>BIM模型數據主要有哪些交換方式與方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a44e688d.html alt=共建安全高效的證通數據交換存儲平臺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6e00e2a126624cd3a04003e09f129836 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a44e688d.html title=共建安全高效的證通數據交換存儲平臺>共建安全高效的證通數據交換存儲平臺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a8ee1e1.html alt=加大數據交換，服務社會治理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52356fef840348268d722f9e09041d09 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a8ee1e1.html title=加大數據交換，服務社會治理>加大數據交換，服務社會治理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aabf6c20.html alt=大容量數據交換，該選擇什麼移動存儲設備？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a0645b75449e4f86b44ec2301e660ac4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aabf6c20.html title=大容量數據交換，該選擇什麼移動存儲設備？>大容量數據交換，該選擇什麼移動存儲設備？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4abcc1ec.html alt=完善和高效的數據交換管理平臺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/95bd84cca48a4510bdf677846e255dda style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4abcc1ec.html title=完善和高效的數據交換管理平臺>完善和高效的數據交換管理平臺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/543694ba.html alt=一般人不知道的線程間數據交換Exchanger class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df26ce3a590f4daba6b29648f36e3ae7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/543694ba.html title=一般人不知道的線程間數據交換Exchanger>一般人不知道的線程間數據交換Exchanger</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/781bd8ae.html alt="成都成華：搭建數據交換中心 推進移動辦公辦案平臺建設_正義網" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/781bd8ae.html title="成都成華：搭建數據交換中心 推進移動辦公辦案平臺建設_正義網">成都成華：搭建數據交換中心 推進移動辦公辦案平臺建設_正義網</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89963e6e.html alt=數據安全交換協議來了，或將推動AI大步邁向3.0時代 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/SErvipbBeWotcr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89963e6e.html title=數據安全交換協議來了，或將推動AI大步邁向3.0時代>數據安全交換協議來了，或將推動AI大步邁向3.0時代</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75154d57.html alt=試驗數據交換共享技術研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1f294f46e217463ca5ba719dfd99dcf3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75154d57.html title=試驗數據交換共享技術研究>試驗數據交換共享技術研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/259011ee.html alt=跨網數據交換的5種方式介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/46b9311b886d482780b49bd6285a6eee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/259011ee.html title=跨網數據交換的5種方式介紹>跨網數據交換的5種方式介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/b7000f2a.html alt=數據中心網絡交換設備架構之戰 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15209294584692e19f49375 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/b7000f2a.html title=數據中心網絡交換設備架構之戰>數據中心網絡交換設備架構之戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3fdedd1.html alt="'數據共享'和'數據交換'，這兩種服務平臺在推廣仍有下方面困難" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/21d8c0770c0944d495e1516d8bcb6c70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3fdedd1.html title="'數據共享'和'數據交換'，這兩種服務平臺在推廣仍有下方面困難">'數據共享'和'數據交換'，這兩種服務平臺在推廣仍有下方面困難</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/28c16cf.html alt=中巴海關數據交換已啟動，低價報關將受嚴懲！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RDa53wtC87XbSB style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/28c16cf.html title=中巴海關數據交換已啟動，低價報關將受嚴懲！>中巴海關數據交換已啟動，低價報關將受嚴懲！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d19a57.html alt="如何使用 Protobuf 做數據交換" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1f3e86b7f46045efaa41d194ae4b0638 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d19a57.html title="如何使用 Protobuf 做數據交換">如何使用 Protobuf 做數據交換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1209c08.html alt=如何有效的進行數據交換管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/fbb3bc2be1e04318bc25ab6d95ff4d03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1209c08.html title=如何有效的進行數據交換管理>如何有效的進行數據交換管理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>