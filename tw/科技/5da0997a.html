<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入分析 Java Web 中的中文編碼問題 | 极客快訊</title><meta property="og:title" content="深入分析 Java Web 中的中文編碼問題 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/154071479216321347e0b7f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0997a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0997a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0997a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0997a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0997a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0997a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0997a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0997a.html><meta property="article:published_time" content="2020-10-29T21:09:08+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:08+08:00"><meta name=Keywords content><meta name=description content="深入分析 Java Web 中的中文編碼問題"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5da0997a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入分析 Java Web 中的中文編碼問題</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>開始，背景：</p><blockquote><p>編碼問題一直困擾著程序開發人員，尤其是在 Java 中更加明顯，因為 Java 是跨平臺的語言，在不同平臺的編碼之間的切換較多。接下來將介紹 Java 編碼問題出現的根本原因；在 Java 中經常遇到的幾種編碼格式的區別；在 Java 中經常需要編碼的場景；出現中文問題的原因分析；在開發 Java Web 中可能存在編碼的幾個地方；一個 HTTP 請求怎麼控制編碼格式；如何避免出現中文編碼問題等。</p></blockquote><p>深入分析 Java Web 中的中文編碼問題</p><p>1幾種常見的編碼格式</p><p>1 為什麼要編碼</p><p>2 如何翻譯</p><p>2在 Java 中需要編碼的場景</p><p>1 在 IO 操作中存在的編碼</p><p>2 在內存操作中的編碼</p><p>3在 Java 中如何編解碼</p><p>幾種編碼格式的比較</p><p>4在 Java Web 中涉及的編解碼</p><p>1 URL 的編解碼</p><p>2 HTTP Header 的編解碼</p><p>3 POST 表單的編解碼</p><p>4 HTTP BODY 的編解碼</p><p>5 其它需要編碼的地方</p><p>5常見問題分析</p><p>1 中文變成了看不懂的字符</p><p>2 一個漢字變成一個問號</p><p>3 一個漢字變成兩個問號</p><p>4 一種不正常的正確編碼</p><p>6總結</p><hr><p><strong>1、幾種常見的編碼格式</strong></p><p>1.1 為什麼要編碼</p><p>在計算機中存儲信息的最小單元是 1 個字節，即 8 個 bit， 所以能表示的字符範圍是 0 ~ 255 個。</p><p>要表示的符號太多，無法用 1 個字節來完全表示。</p><p>1.2 如何翻譯</p><p>計算機中提供多種翻譯方式，常見的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16等。這些都規定了轉化的規則，按照這個規則就可以讓計算機正確的表示我們的字符。下面介紹這幾種編碼格式：</p><p>ASCII 碼</p><p>總共有 128 個，用 1 個字節的低 7 位表示， 0 ~ 31 是控制字符如換行、回車、刪除等，32 ~ 126 是打印字符，可以通過鍵盤輸入並且能夠顯示出來。</p><p>ISO-8859-1</p><p>128 個字符顯然是不夠用的，所以 ISO 組織在 ASCII 的基礎上擴展，他們是 ISO-8859-1 至 ISO-8859-15，前者涵蓋大多數字符，應用最廣。ISO-8859-1 仍是單字節編碼，它總歸能表示 256 個字符。</p><p>GB2312</p><p>它是雙字節編碼，總的編碼範圍是 A1 ~ F7，其中 A1 ~ A9 是符號區，總共包含 682 個符號；B0 ~ F7 是漢字區，包含 6763 個漢字。</p><p>GBk</p><p>GBK 為《漢字內碼擴展規範》，為 GB2312 的擴展，它的編碼範圍是 8140 ~ FEFE（去掉XX7F），總共有 23940 個碼位，能表示 21003 個漢字，和 GB2312的編碼兼容，不會有亂碼。</p><p>UTF-16</p><p>它具體定義了 Unicode 字符在計算機中的存取方法。UTF-16 用兩個字節來表示 Unicode 的轉化格式，它採用定長的表示方法，即不論什麼字符用兩個字節表示。兩個字節是 16 個 bit，所以叫 UTF-16。它表示字符非常方便，沒兩個字節表示一個字符，這就大大簡化了字符串操作。</p><p>UTF-8</p><p>雖說 UTF-16 統一採用兩個字節表示一個字符很簡單方便，但是很大一部分字符用一個字節就可以表示，如果用兩個字節表示，存儲空間放大了一倍，在網絡帶寬有限的情況下會增加網絡傳輸的流量。UTF-8 採用了一種變長技術，每個編碼區域有不同的字碼長度不同類型的字符可以由 1 ~ 6 個字節組成。</p><p>UTF-8 有以下編碼規則：</p><p>如果是 1 個字節，最高位（第 8 位）為 0，則表示這是一個 ASCII 字符（00 ~ 7F）</p><p>如果是 1 個字節，以 11 開頭，則連續的 1 的個數暗示這個字符的字節數</p><p>如果是 1 個字節，以 10 開頭，表示它不是首字節，則需要向前查找才能得到當前字符的首字節</p><p><strong>2、在 Java 中需要編碼的場景</strong></p><p>2.1 在 I/O 操作中存在的編碼</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/154071479216321347e0b7f><p class=pgc-img-caption></p></div><p>如上圖：Reader 類是在 Java 的 I/O 中讀取符的父類，而 InputStream 類是讀字節的父類， InputStreamReader 類就是關聯字節到字符的橋樑，它負責在 I/O 過程中處理讀取字節到字符的轉換，而對具體字節到字符的解碼實現，它又委託 StreamDecoder 去做，在 StreamDecoder 解碼過程中必須由用戶指定 Charset 編碼格式。值得注意的是，如果你沒有指定 Charset，則將使用本地環境中默認的字符集，如在中文環境中將使用 GBK 編碼。</p><p>如下面一段代碼，實現了文件的讀寫功能：</p><blockquote><p>String file = "c:/stream.txt";</p><p>String charset = "UTF-8";</p><p>// 寫字符換轉成字節流</p><p>FileOutputStream outputStream = new FileOutputStream(file);</p><p>OutputStreamWriter writer = new OutputStreamWriter(</p><p>outputStream, charset);</p><p>try {</p><p>writer.write("這是要保存的中文字符");</p><p>} finally {</p><p>writer.close();</p><p>}</p><p>// 讀取字節轉換成字符</p><p>FileInputStream inputStream = new FileInputStream(file);</p><p>InputStreamReader reader = new InputStreamReader(</p><p>inputStream, charset);</p><p>StringBuffer buffer = new StringBuffer();</p><p>char[] buf = new char[64];</p><p>int count = 0;</p><p>try {</p><p>while ((count = reader.read(buf)) != -1) {</p><p>buffer.append(buffer, 0, count);</p><p>}</p><p>} finally {</p><p>reader.close();</p><p>}</p></blockquote><p>在我們的應用程序中涉及 I/O 操作時，只要注意指定統一的編解碼 Charset 字符集，一般不會出現亂碼問題。</p><p>2.2 在內存操作中的編碼</p><p>在內存中進行從字符到字節的數據類型轉換。</p><p>1、String 類提供字符串轉換到字節的方法，也支持將字節轉換成字符串的構造函數。</p><blockquote><p>String s = "字符串"；</p><p>byte[] b = s.getBytes("UTF-8");</p><p>String n = new String(b, "UTF-8");</p></blockquote><p>2、Charset 提供 encode 與 decode，分別對應 char[] 到 byte[] 的編碼 和 byte[] 到 char[] 的解碼。</p><blockquote><p>Charset charset = Charset.forName("UTF-8");</p><p>ByteBuffer byteBuffer = charset.encode(string);</p><p>CharBuffer charBuffer = charset.decode(byteBuffer);</p></blockquote><p><strong>3、在 Java 中如何編解碼</strong></p><p>Java 編碼類圖</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15407148654382ab9bf773c><p class=pgc-img-caption></p></div><p>首先根據指定的 charsetName 通過 Charset.forName(charsetName) 設置 Charset 類，然後根據 Charset 創建 CharsetEncoder 對象，再調用 CharsetEncoder.encode 對字符串進行編碼，不同的編碼類型都會對應到一個類中，實際的編碼過程是在這些類中完成的。下面是 String. getBytes(charsetName) 編碼過程的時序圖</p><p>Java 編碼時序圖</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/154071488119864bee873d4><p class=pgc-img-caption></p></div><p>從上圖可以看出根據 charsetName 找到 Charset 類，然後根據這個字符集編碼生成 CharsetEncoder，這個類是所有字符編碼的父類，針對不同的字符編碼集在其子類中定義瞭如何實現編碼，有了 CharsetEncoder 對象後就可以調用 encode 方法去實現編碼了。這個是 String.getBytes 編碼方法，其它的如 StreamEncoder 中也是類似的方式。</p><p>經常會出現中文變成“？”很可能就是錯誤的使用了 ISO-8859-1 這個編碼導致的。中文字符經過 ISO-8859-1 編碼會丟失信息，通常我們稱之為“黑洞”，它會把不認識的字符吸收掉。由於現在大部分基礎的 Java 框架或系統默認的字符集編碼都是 ISO-8859-1，所以很容易出現亂碼問題，後面將會分析不同的亂碼形式是怎麼出現的。</p><p><strong>幾種編碼格式的比較</strong></p><p>對中文字符後面四種編碼格式都能處理，GB2312 與 GBK 編碼規則類似，但是 GBK 範圍更大，它能處理所有漢字字符，所以 GB2312 與 GBK 比較應該選擇 GBK。UTF-16 與 UTF-8 都是處理 Unicode 編碼，它們的編碼規則不太相同，相對來說 UTF-16 編碼效率最高，字符到字節相互轉換更簡單，進行字符串操作也更好。它適合在本地磁盤和內存之間使用，可以進行字符和字節之間快速切換，如 Java 的內存編碼就是採用 UTF-16 編碼。但是它不適合在網絡之間傳輸，因為網絡傳輸容易損壞字節流，一旦字節流損壞將很難恢復，想比較而言 UTF-8 更適合網絡傳輸，對 ASCII 字符采用單字節存儲，另外單個字符損壞也不會影響後面其它字符，在編碼效率上介於 GBK 和 UTF-16 之間，所以 UTF-8 在編碼效率上和編碼安全性上做了平衡，是理想的中文編碼方式。</p><p><strong>4、在 Java Web 中涉及的編解碼</strong></p><p>對於使用中文來說，有 I/O 的地方就會涉及到編碼，前面已經提到了 I/O 操作會引起編碼，而大部分 I/O 引起的亂碼都是網絡 I/O，因為現在幾乎所有的應用程序都涉及到網絡操作，而數據經過網絡傳輸都是以字節為單位的，所以所有的數據都必須能夠被序列化為字節。在 Java 中數據被序列化必須繼承 Serializable 接口。</p><p>一段文本它的實際大小應該怎麼計算，我曾經碰到過一個問題：就是要想辦法壓縮 Cookie 大小，減少網絡傳輸量，當時有選擇不同的壓縮算法，發現壓縮後字符數是減少了，但是並沒有減少字節數。所謂的壓縮只是將多個單字節字符通過編碼轉變成一個多字節字符。減少的是 String.length()，而並沒有減少最終的字節數。例如將“ab”兩個字符通過某種編碼轉變成一個奇怪的字符，雖然字符數從兩個變成一個，但是如果採用 UTF-8 編碼這個奇怪的字符最後經過編碼可能又會變成三個或更多的字節。同樣的道理比如整型數字 1234567 如果當成字符來存儲，採用 UTF-8 來編碼佔用 7 個 byte，採用 UTF-16 編碼將會佔用 14 個 byte，但是把它當成 int 型數字來存儲只需要 4 個 byte 來存儲。所以看一段文本的大小，看字符本身的長度是沒有意義的，即使是一樣的字符采用不同的編碼最終存儲的大小也會不同，所以從字符到字節一定要看編碼類型。</p><p>我們能夠看到的漢字都是以字符形式出現的，例如在 Java 中“淘寶”兩個字符，它在計算機中的數值 10 進制是 28120 和 23453，16 進制是 6bd8 和 5d9d，也就是這兩個字符是由這兩個數字唯一表示的。Java 中一個 char 是 16 個 bit 相當於兩個字節，所以兩個漢字用 char 表示在內存中佔用相當於四個字節的空間。</p><p>這兩個問題搞清楚後，我們看一下 Java Web 中那些地方可能會存在編碼轉換？</p><p>用戶從瀏覽器端發起一個 HTTP 請求，需要存在編碼的地方是 URL、Cookie、Parameter。服務器端接受到 HTTP 請求後要解析 HTTP 協議，其中 URI、Cookie 和 POST 表單參數需要解碼，服務器端可能還需要讀取數據庫中的數據，本地或網絡中其它地方的文本文件，這些數據都可能存在編碼問題，當 Servlet 處理完所有請求的數據後，需要將這些數據再編碼通過 Socket 發送到用戶請求的瀏覽器裡，再經過瀏覽器解碼成為文本。這些過程如下圖所示：</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15407149308096e991d8431><p class=pgc-img-caption></p></div><p>一次 HTTP 請求的編碼示例</p><p><strong>4.1 URL 的編解碼</strong></p><p>用戶提交一個 URL，這個 URL 中可能存在中文，因此需要編碼，如何對這個 URL 進行編碼？根據什麼規則來編碼？有如何來解碼？如下圖一個 URL：</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540714945754801396001c><p class=pgc-img-caption></p></div><p>-上圖中以 Tomcat 作為 Servlet Engine 為例，它們分別對應到下面這些配置文件中：</p><p>Port 對應在 Tomcat 的 中配置，而 Context Path 在 中配置，Servlet Path 在 Web 應用的 web.xml 中的</p><blockquote><p>&lt;servlet-mapping></p><p>&lt;servlet-name>junshanExample&lt;/servlet-name></p><p>&lt;url-pattern>/servlets/servlet/*&lt;/url-pattern></p><p>&lt;/servlet-mapping></p></blockquote><p>中配置，PathInfo 是我們請求的具體的 Servlet，QueryString 是要傳遞的參數，注意這裡是在瀏覽器裡直接輸入 URL 所以是通過 Get 方法請求的，如果是 POST 方法請求的話，QueryString 將通過表單方式提交到服務器端。</p><p>上圖中 PathInfo 和 QueryString 出現了中文，當我們在瀏覽器中直接輸入這個 URL 時，在瀏覽器端和服務端會如何編碼和解析這個 URL 呢？為了驗證瀏覽器是怎麼編碼 URL 的我選擇的是360極速瀏覽器並通過 Postman 插件觀察我們請求的 URL 的實際的內容，以下是 URL：</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1540714982652ee0589b1c2><p class=pgc-img-caption></p></div><p>君山的編碼結果是：e5 90 9b e5 b1 b1，和《深入分析 Java Web 技術內幕》中的結果不一樣，這是因為我使用的瀏覽器和插件和原作者是有區別的，那麼這些瀏覽器之間的默認編碼是不一樣的，原文中的結果是：</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15407150105438a82cf5c66><p class=pgc-img-caption></p></div><p>君山的編碼結果分別是：e5 90 9b e5 b1 b1，be fd c9 bd，查閱上一屆的編碼可知，PathInfo 是 UTF-8 編碼而 QueryString 是經過 GBK 編碼，至於為什麼會有“%”？查閱 URL 的編碼規範 RFC3986 可知瀏覽器編碼 URL 是將非 ASCII 字符按照某種編碼格式編碼成 16 進制數字然後將每個 16 進製表示的字節前加上“%”，所以最終的 URL 就成了上圖的格式了。</p><p>從上面測試結果可知瀏覽器對 PathInfo 和 QueryString 的編碼是不一樣的，不同瀏覽器對 PathInfo 也可能不一樣，這就對服務器的解碼造成很大的困難，下面我們以 Tomcat 為例看一下，Tomcat 接受到這個 URL 是如何解碼的。</p><p>解析請求的 URL 是在 org.apache.coyote.HTTP11.InternalInputBuffer 的 parseRequestLine 方法中，這個方法把傳過來的 URL 的 byte[] 設置到 org.apache.coyote.Request 的相應的屬性中。這裡的 URL 仍然是 byte 格式，轉成 char 是在 org.apache.catalina.connector.CoyoteAdapter 的 convertURI 方法中完成的：</p><blockquote><p>protected void convertURI(MessageBytes uri, Request request)</p><p>throws Exception {</p><p>ByteChunk bc = uri.getByteChunk();</p><p>int length = bc.getLength();</p><p>CharChunk cc = uri.getCharChunk();</p><p>cc.allocate(length, -1);</p><p>String enc = connector.getURIEncoding();</p><p>if (enc != null) {</p><p>B2CConverter conv = request.getURIConverter();</p><p>try {</p><p>if (conv == null) {</p><p>conv = new B2CConverter(enc);</p><p>request.setURIConverter(conv);</p><p>}</p><p>} catch (IOException e) {...}</p><p>if (conv != null) {</p><p>try {</p><p>conv.convert(bc, cc, cc.getBuffer().length -</p><p>cc.getEnd());</p><p>uri.setChars(cc.getBuffer(), cc.getStart(),</p><p>cc.getLength());</p><p>return;</p><p>} catch (IOException e) {...}</p><p>}</p><p>}</p><p>// Default encoding: fast conversion</p><p>byte[] bbuf = bc.getBuffer();</p><p>char[] cbuf = cc.getBuffer();</p><p>int start = bc.getStart();</p><p>for (int i = 0; i &lt; length; i++) {</p><p>cbuf[i] = (char) (bbuf[i + start] & 0xff);</p><p>}</p><p>uri.setChars(cbuf, 0, length);</p><p>}</p></blockquote><p>從上面的代碼中可以知道對 URL 的 URI 部分進行解碼的字符集是在 connector 的 中定義的，如果沒有定義，那麼將以默認編碼 ISO-8859-1 解析。所以如果有中文 URL 時最好把 URIEncoding 設置成 UTF-8 編碼。</p><p>QueryString 又如何解析？ GET 方式 HTTP 請求的 QueryString 與 POST 方式 HTTP 請求的表單參數都是作為 Parameters 保存，都是通過 request.getParameter 獲取參數值。對它們的解碼是在 request.getParameter 方法第一次被調用時進行的。request.getParameter 方法被調用時將會調用 org.apache.catalina.connector.Request 的 parseParameters 方法。這個方法將會對 GET 和 POST 方式傳遞的參數進行解碼，但是它們的解碼字符集有可能不一樣。POST 表單的解碼將在後面介紹，QueryString 的解碼字符集是在哪定義的呢？它本身是通過 HTTP 的 Header 傳到服務端的，並且也在 URL 中，是否和 URI 的解碼字符集一樣呢？從前面瀏覽器對 PathInfo 和 QueryString 的編碼採取不同的編碼格式不同可以猜測到解碼字符集肯定也不會是一致的。的確是這樣 QueryString 的解碼字符集要麼是 Header 中 ContentType 中定義的 Charset 要麼就是默認的 ISO-8859-1，要使用 ContentType 中定義的編碼就要設置 connector 的 中的 useBodyEncodingForURI 設置為 true。這個配置項的名字有點讓人產生混淆，它並不是對整個 URI 都採用 BodyEncoding 進行解碼而僅僅是對 QueryString 使用 BodyEncoding 解碼，這一點還要特別注意。</p><p>從上面的 URL 編碼和解碼過程來看，比較複雜，而且編碼和解碼並不是我們在應用程序中能完全控制的，所以在我們的應用程序中應該儘量避免在 URL 中使用非 ASCII 字符，不然很可能會碰到亂碼問題，當然在我們的服務器端最好設置 中的 URIEncoding 和 useBodyEncodingForURI 兩個參數。</p><p>4.2 HTTP Header 的編解碼</p><p>當客戶端發起一個 HTTP 請求除了上面的 URL 外還可能會在 Header 中傳遞其它參數如 Cookie、redirectPath 等，這些用戶設置的值很可能也會存在編碼問題，Tomcat 對它們又是怎麼解碼的呢？</p><p>對 Header 中的項進行解碼也是在調用 request.getHeader 是進行的，如果請求的 Header 項沒有解碼則調用 MessageBytes 的 toString 方法，這個方法將從 byte 到 char 的轉化使用的默認編碼也是 ISO-8859-1，而我們也不能設置 Header 的其它解碼格式，所以如果你設置 Header 中有非 ASCII 字符解碼肯定會有亂碼。</p><p>我們在添加 Header 時也是同樣的道理，不要在 Header 中傳遞非 ASCII 字符，如果一定要傳遞的話，我們可以先將這些字符用 org.apache.catalina.util.URLEncoder 編碼然後再添加到 Header 中，這樣在瀏覽器到服務器的傳遞過程中就不會丟失信息了，如果我們要訪問這些項時再按照相應的字符集解碼就好了。</p><p>4.3 POST 表單的編解碼</p><p>在前面提到了 POST 表單提交的參數的解碼是在第一次調用 request.getParameter 發生的，POST 表單參數傳遞方式與 QueryString 不同，它是通過 HTTP 的 BODY 傳遞到服務端的。當我們在頁面上點擊 submit 按鈕時瀏覽器首先將根據 ContentType 的 Charset 編碼格式對錶單填的參數進行編碼然後提交到服務器端，在服務器端同樣也是用 ContentType 中字符集進行解碼。所以通過 POST 表單提交的參數一般不會出現問題，而且這個字符集編碼是我們自己設置的，可以通過 request.setCharacterEncoding(charset) 來設置。</p><p>另外針對 multipart/form-data 類型的參數，也就是上傳的文件編碼同樣也是使用 ContentType 定義的字符集編碼，值得注意的地方是上傳文件是用字節流的方式傳輸到服務器的本地臨時目錄，這個過程並沒有涉及到字符編碼，而真正編碼是在將文件內容添加到 parameters 中，如果用這個編碼不能編碼時將會用默認編碼 ISO-8859-1 來編碼。</p><p>4.4 HTTP BODY 的編解碼</p><p>當用戶請求的資源已經成功獲取後，這些內容將通過 Response 返回給客戶端瀏覽器，這個過程先要經過編碼再到瀏覽器進行解碼。這個過程的編解碼字符集可以通過 response.setCharacterEncoding 來設置，它將會覆蓋 request.getCharacterEncoding 的值，並且通過 Header 的 Content-Type 返回客戶端，瀏覽器接受到返回的 socket 流時將通過 Content-Type 的 charset 來解碼，如果返回的 HTTP Header 中 Content-Type 沒有設置 charset，那麼瀏覽器將根據 Html 的 中的 charset 來解碼。如果也沒有定義的話，那麼瀏覽器將使用默認的編碼來解碼。</p><p>4.5 其它需要編碼的地方</p><p>除了 URL 和參數編碼問題外，在服務端還有很多地方可能存在編碼，如可能需要讀取 xml、velocity 模版引擎、JSP 或者從數據庫讀取數據等。</p><p>xml 文件可以通過設置頭來制定編碼格式</p><blockquote><p>&lt;?xml version="1.0" encoding="UTF-8"?></p></blockquote><p>Velocity 模版設置編碼格式：</p><blockquote><p>services.VelocityService.input.encoding=UTF-8</p></blockquote><p>JSP 設置編碼格式：</p><blockquote><p>&lt;%@page contentType="text/html; charset=UTF-8"%></p></blockquote><p>訪問數據庫都是通過客戶端 JDBC 驅動來完成，用 JDBC 來存取數據要和數據的內置編碼保持一致，可以通過設置 JDBC URL 來制定如 MySQL：url=”jdbc:mysql://localhost:3306/DB?useUnicode=true&characterEncoding=GBK”。</p><p><strong>5、常見問題分析</strong></p><p>下面看一下，當我們碰到一些亂碼時，應該怎麼處理這些問題？出現亂碼問題唯一的原因都是在 char 到 byte 或 byte 到 char 轉換中編碼和解碼的字符集不一致導致的，由於往往一次操作涉及到多次編解碼，所以出現亂碼時很難查找到底是哪個環節出現了問題，下面就幾種常見的現象進行分析。</p><p><strong>5.1 中文變成了看不懂的字符</strong></p><p>例如，字符串“淘！我喜歡！”變成了“Ì Ô £ ¡Î Ò Ï²»¶ £ ¡”編碼過程如下圖所示：</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1540715103507e174b47ae4><p class=pgc-img-caption></p></div><p><strong>字符串在解碼時所用的字符集與編碼字符集不一致</strong>導致漢字變成了看不懂的亂碼，而且是<strong>一個漢字字符變成兩個亂碼字符</strong>。</p><p><strong>5.2 一個漢字變成一個問號</strong></p><p>例如，字符串“淘！我喜歡！”變成了“？？？？？？”編碼過程如下圖所示:</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540715117484400c0110ce><p class=pgc-img-caption></p></div><p>將中文和中文符號經過不支持中文的 ISO-8859-1 編碼後，所有字符變成了“？”，這是因為用 ISO-8859-1 進行編解碼時遇到不在碼值範圍內的字符時統一用 3f 表示，這也就是通常所說的“黑洞”，所有 ISO-8859-1 不認識的字符都變成了“？”。</p><p>5.3 一個漢字變成兩個問號</p><p>例如，字符串“淘！我喜歡！”變成了“？？？？？？？？？？？？”編碼過程如下圖所示:</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540715133588a0652da55d><p class=pgc-img-caption></p></div><p>這種情況比較複雜，中文經過多次編碼，但是其中有一次編碼或者解碼不對仍然會出現中文字符變成“？”現象，出現這種情況要仔細查看中間的編碼環節，找出出現編碼錯誤的地方。</p><p>5.4 一種不正常的正確編碼</p><p>還有一種情況是在我們通過 request.getParameter 獲取參數值時，當我們直接調用</p><p>String value = request.getParameter(name); 會出現亂碼，但是如果用下面的方式</p><p>String value = String(request.getParameter(name).getBytes(" ISO-8859-1"), "GBK");</p><p>解析時取得的 value 會是正確的漢字字符，這種情況是怎麼造成的呢？</p><p>看下如所示：</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540715148704d397d7b83c><p class=pgc-img-caption></p></div><p>這種情況是這樣的，ISO-8859-1 字符集的編碼範圍是 0000-00FF，正好和一個字節的編碼範圍相對應。這種特性保證了使用 ISO-8859-1 進行編碼和解碼可以保持編碼數值“不變”。雖然中文字符在經過網絡傳輸時，被錯誤地“拆”成了兩個歐洲字符，但由於輸出時也是用 ISO-8859-1，結果被“拆”開的中文字的兩半又被合併在一起，從而又剛好組成了一個正確的漢字。雖然最終能取得正確的漢字，但是還是不建議用這種不正常的方式取得參數值，因為這中間增加了一次額外的編碼與解碼，這種情況出現亂碼時因為 Tomcat 的配置文件中 useBodyEncodingForURI 配置項沒有設置為”true”，從而造成第一次解析式用 ISO-8859-1 來解析才造成亂碼的。</p><p><strong>6、總結</strong></p><p>本文首先總結了幾種常見編碼格式的區別，然後介紹了支持中文的幾種編碼格式，並比較了它們的使用場景。接著介紹了 Java 那些地方會涉及到編碼問題，已經 Java 中如何對編碼的支持。並以網絡 I/O 為例重點介紹了 HTTP 請求中的存在編碼的地方，以及 Tomcat 對 HTTP 協議的解析，最後分析了我們平常遇到的亂碼問題出現的原因。</p><p>綜上所述，要解決中文問題，首先要搞清楚哪些地方會引起字符到字節的編碼以及字節到字符的解碼，最常見的地方就是讀取會存儲數據到磁盤，或者數據要經過網絡傳輸。然後針對這些地方搞清楚操作這些數據的框架的或系統是如何控制編碼的，正確設置編碼格式，避免使用軟件默認的或者是操作系統平臺默認的編碼格式。</p><div class=pgc-img><img alt="深入分析 Java Web 中的中文編碼問題" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15407151947037e2dd79788><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>Web</a></li><li><a>編碼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7b26a08.html alt="Java 字符編碼" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/689930fcab234b1fa89acd0868efc912 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7b26a08.html title="Java 字符編碼">Java 字符編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/20dcfe0c.html alt=Java--字符編碼和字符集詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/20dcfe0c.html title=Java--字符編碼和字符集詳解>Java--字符編碼和字符集詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af0de2ce.html alt="Java Web 模板代碼生成器的設計與實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b963f9c3758447ad9436b6c3928a66ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af0de2ce.html title="Java Web 模板代碼生成器的設計與實現">Java Web 模板代碼生成器的設計與實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5cf25be3.html alt="'輕'量級 Java Web 服務框架漫談" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cd5fb752127d465f81782a9d2cc9f4cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5cf25be3.html title="'輕'量級 Java Web 服務框架漫談">'輕'量級 Java Web 服務框架漫談</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b3be53a.html alt="2019最新Java Web J2EE下的兩大框架SSH和SSM對比" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a799f550bec94acd95f960c34deaaacc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b3be53a.html title="2019最新Java Web J2EE下的兩大框架SSH和SSM對比">2019最新Java Web J2EE下的兩大框架SSH和SSM對比</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f5733e7.html alt="Java IO4：字符編碼，來來來，繼續" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b393785e9fc14c139e7277da465fd2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f5733e7.html title="Java IO4：字符編碼，來來來，繼續">Java IO4：字符編碼，來來來，繼續</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8fe637e.html alt="我的Java Web之路14 - Eclipse的大綱（Outline）視圖" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/53777bf08cef43e99ccca3282ad179cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8fe637e.html title="我的Java Web之路14 - Eclipse的大綱（Outline）視圖">我的Java Web之路14 - Eclipse的大綱（Outline）視圖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a2871b0c.html alt="可用於企業的 7 個最佳開源 Web 服務器！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1531874286737ba179830a5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a2871b0c.html title="可用於企業的 7 個最佳開源 Web 服務器！">可用於企業的 7 個最佳開源 Web 服務器！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02402c9e.html alt=「乾貨」藍牙耳機編碼（SBC、AAC、aptX）都有啥區別？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/feb0ab00-bb82-4c38-9e77-e3570f56137d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02402c9e.html title=「乾貨」藍牙耳機編碼（SBC、AAC、aptX）都有啥區別？>「乾貨」藍牙耳機編碼（SBC、AAC、aptX）都有啥區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4e49d1f3.html alt=信息編碼：數字和文字是如何誕生的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1f3d0677443e48bfbb2435b71f6da199 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4e49d1f3.html title=信息編碼：數字和文字是如何誕生的？>信息編碼：數字和文字是如何誕生的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3070f16.html alt=買這個編碼格式的藍牙設備，又便宜又好用！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/8d5cc4a5-5d5b-4a34-adbd-cb74f8d4db2b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3070f16.html title=買這個編碼格式的藍牙設備，又便宜又好用！>買這個編碼格式的藍牙設備，又便宜又好用！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8775ee99.html alt=音頻壓縮編碼的基本原理詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1d62465bab4542babd5647386c272c82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8775ee99.html title=音頻壓縮編碼的基本原理詳解>音頻壓縮編碼的基本原理詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/53140375.html alt=信息編碼與數字化 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8bea8e2d5bad49659ffd74924fc6f08b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/53140375.html title=信息編碼與數字化>信息編碼與數字化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed5abbe2.html alt=很多程序員編碼時都戴耳機？他們在聽什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0710e96976d448dc8a7fde6c55312565 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed5abbe2.html title=很多程序員編碼時都戴耳機？他們在聽什麼？>很多程序員編碼時都戴耳機？他們在聽什麼？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>