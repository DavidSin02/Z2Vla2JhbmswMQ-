<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗 | 极客快訊</title><meta property="og:title" content="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><meta property="article:published_time" content="2020-11-14T21:04:16+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:16+08:00"><meta name=Keywords content><meta name=description content="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5da0d73c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1）實驗平臺：正點原子開拓者FPGA 開發板</p><p style=text-align:start>2）摘自《開拓者FPGA開發指南》關注官方微信號公眾號，獲取更多資料：正點原子</p><p style=text-align:start>3）全套實驗源碼+手冊+視頻下載地址：http://www.openedv.com/thread-13912-1-1.html</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f><p class=pgc-img-caption></p></div><p><strong>第三十二章 音頻環回實驗</strong></p><p>WM8978是一個低功耗、高質量的立體聲多媒體數字信號編譯碼器，它結合了一個高質量的</p><p>立體聲音頻DAC和ADC，帶有靈活的音頻線輸入、麥克風輸入和音頻輸出處理。其主要應用於便</p><p>攜式應用，可以應用到可攜式數碼攝像機或數碼相機等設備。本章我們將使用FPGA開發板上的</p><p>WM8978器件實現音頻環回的功能。</p><p>本章包括以下幾個部分：</p><p>32.1 WM8978簡介</p><p>32.2 實驗任務</p><p>32.3 硬件設計</p><p>32.4 程序設計</p><p>32.5 下載驗證</p><p><strong>WM8978簡介</strong></p><p>WM8978是歐勝（Wolfson）推出的一款全功能音頻處理器。它帶有一個HI-FI級數字信號處</p><p>理內核，支持增強3D硬件環繞音效，以及5頻段的硬件均衡器，可以有效改善音質。</p><p>WM8978具有高級的片上數字信號處理功能，包含一個5路均衡功能，一個用於ADC和麥克風</p><p>或者線路輸入之間的混合信號的電平自動控制功能，一個純粹的錄音或者重放的數字限幅功能。</p><p>另外在ADC的線路上提供了一個數字濾波的功能，可以更好的應用濾波，比如“減少風噪”。</p><p>WM8978集成了立體聲差分麥克風的前置放大與揚聲器、耳機和差分、立體聲線輸出的驅動，</p><p>減少了應用時必需的外部組件，比如不需要單獨的麥克風或者耳機的放大器。WM8978提供了一</p><p>個強悍的揚聲器功放，可提供高達900mW的高質量音響效果揚聲器功率，一個數字回放限制器</p><p>可防止揚聲器聲音過載。WM8978進一步提升了耳機放大器輸出功率，在推動16歐姆耳機的時候，</p><p>每個聲道最大輸出功率高達40毫瓦！可以連接市面上絕大多數適合隨身聽的高端HI-FI耳機。</p><p>WM8978整體功能模塊的框圖如圖 32.1.1所示：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af46b0d04a9144bb825a3b581f979193><p class=pgc-img-caption></p></div><p><br></p><p>圖 32.1.1 WM8978整體功能框圖</p><p>WM8978可通過I2S或PCM音頻接口（I2S/PCM AUDIO INTERFACE）與FPGA進行音頻數據傳輸。</p><p>具體應用哪種方式可通過控制接口（Control Interface）配置相應的寄存器。控制接口是一</p><p>個可選的2線或3線結構。通過MODE引腳選擇（MODE引腳接高電平時為3線接口模式、低電平時</p><p>為2線接口模式），當控制接口為2線接口模式時，其時序圖如下圖所示。</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/29260db47da044969006c94a27cefceb><p class=pgc-img-caption></p></div><p>圖 32.1.2 兩線接口時序圖</p><p>由上圖可見，其時序圖與I2C時序相同。此時SCLK為串行時鐘線、SDIN為串行數據線，WM8978</p><p>芯片的器件地址固定為0011010b。本次實驗我們使用的是兩線的控制接口。</p><p>音頻接口的ADCDAT為ADC數據的輸出接口，本實驗中WM8978通過此接口輸出音頻給FPGA，</p><p>DACDAT為DAC數據的輸入接口，WM8978通過此接口接收FPGA輸出的音頻。LRC為音頻左右聲道的</p><p>數據對齊時鐘信號，BCLK即Bit Clock（位時鐘），用於同步數據輸入和輸出。MCLK為主時鐘</p><p>輸入接口，MCLK的頻率為256fs，fs為音頻的採樣率，一般為48kHz，所以MCLK為256 × 48 =</p><p>12288kHz = 12.288MHz。我們一般使用FPGA內部的PLL分頻得到12MHz的時鐘信號，然後通過</p><p>配置WM8978內部的寄存器使其PLL輸出12.288MHz的時鐘信號。</p><p>WM8978支持主從兩種工作模式。主從工作模式的區別在於BCLK和LRC由誰控制。在主模式</p><p>下，WM8978作為主控設備，產生BCLK和LRC信號並輸出。在從模式下，BCLK和LRC信號由外部設</p><p>備（本實驗指FPGA）提供，WM8978作為從設備接收BCLK和LRC信號。可見如果使WM8978工作在</p><p>從模式下，我們需要通過FPGA產生BCLK和LRC信號，既浪費FPGA內部的資源也浪費（空閒）了</p><p>WM8978本身的資源，所以一般使WM8978工作在主模式下。主從工作模式通過配置R6寄存器的</p><p>bit0位來設置，bit0位為0時WM8978工作在從模式下，為1時WM8978工作在主模式下，本次實驗</p><p>我們使WM8978工作在主模式下。</p><p>對於音頻接口，本次實驗我們採用I2S音頻總線接口傳輸音頻數據。I2S(Inter-IC Sound)</p><p>總線，又稱集成電路內置音頻總線，是飛利浦公司為數字音頻設備之間的音頻數據傳輸而制定</p><p>的一種總線標準，該總線專門負責音頻設備之間的數據傳輸，廣泛應用於各種多媒體系統。I2S</p><p>的優點是接收端與發送端的音頻數據有效位數可以不同。如果接收端能處理的有效位數少於發</p><p>送端，可以放棄數據幀中多餘的低位數據；如果接收端能處理的有效位數多於發送端，可以自</p><p>行補足剩餘的位。這種同步機制使得數字音頻設備的互連更加方便，而且不會造成數據錯位。</p><p>I2S總線的音頻傳輸格式如下圖：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/82272114282f415986fea7048633978f><p class=pgc-img-caption></p></div><p>圖 32.1.3 I2S總線音頻傳輸格式</p><p>fs為音頻的採樣率，LRC為左右聲道的對齊時鐘。由上圖可知，當LRC為低電平時傳輸左聲</p><p>道的音頻數據，高電平時傳輸右聲道的音頻數據。位時鐘BCLK的頻率=2×採樣頻率×採樣位數，</p><p>由於使用的是主模式，LRC和位時鐘BCLK由WM8978提供，所以我們無需關心其頻率的大小。我</p><p>們需要注意的是I2S格式的音頻信號DACDAT和ADCDAT無論有多少位有效數據，數據的最高位總</p><p>是出現在LRC變化後的第2個BCLK脈衝處，即傳輸數據時高位在前，且該位在LRC變化後BCLK的</p><p>第2個上升沿採樣到。</p><p>圖 32.1.1中的LIP（LIN）、RIP（RIN）分別為左麥克風前置放大同相（反相）輸入和右</p><p>麥克風前置放大同相（反相）輸入，L2/GPIO2和R2/GPIO3分別為左通道線輸入/GPIO引腳和右</p><p>通道線輸入/GPIO引腳，AUXL和AUXR為左右輔助輸入。LOUT1和ROUT1為耳機的左右輸出，LOUT2</p><p>為第二左輸出或者BTL揚聲器反相輸出，ROUT2第二右輸出或者BTL揚聲器同相輸出。</p><p>由圖 32.1.1可見輸入到輸出的通道通過一個個開關控制，每個開關由相應的寄存器控制。</p><p>配置相應的寄存器就可打開相應的通道、使能相應的功能。</p><p>WM8978內部有58個寄存器。每個寄存器的地址位為7位，數據位為9位。可通過控制接口配</p><p>置相應的寄存器以打開相應的通道或使能相應的功能。這裡我們簡單介紹一下要正常使用</p><p>WM8978來播放音樂時，需要配置的寄存器。</p><p>1.寄存器R0（00h），該寄存器用於控制WM8978的軟復位，寫任意值到該寄存器地址，即</p><p>可實現WM8978的軟復位。</p><p>2.寄存器R1（01h），該寄存器需要設置VMIDSEL（bit[1:0]）為2’b11，開啟最快啟動；</p><p>BUFIOEN（bit2）為1，避免輸入輸出直接在WM8978內部環回；BIASEN（bit3）為1，模擬部分</p><p>的放大器才會工作，才可以聽到聲音，PLLEN（bit5）為1使能WM8978內部PLL功能，使WM8978</p><p>內部的主時鐘為12.288MHz。</p><p>3.寄存器R2（02h），該寄存器需要設置ROUT1EN(bit8)、LOUT1EN(bit7)為1，使能耳機輸</p><p>出；BOOSTENR（bit5）、BOOSTENL（bit4）為1，使能左右聲道進入BOOST；ADCENR（bit1）、</p><p>ADCENL（bit0）為1，使能左右聲道的ADC功能。</p><p>4.寄存器R3（03h），該寄存器要設置LOUT2EN(bit6)，ROUT2EN(bit5)，RMIXER(bit3)，</p><p>LMIXER(bit2)，DACENR(bit1)和DACENL(bit0)等6個位為1。LOUT2EN和ROUT2EN，設置為1，使</p><p>能喇叭輸出；LMIXER和RMIXER設置為1，使能左右聲道混合器；DACENL和DACENR則是使能左右</p><p>聲道的DAC，使數字音頻信號轉換為模擬音頻信號。</p><p>5.寄存器R4（04h），該寄存器要設置WL(bit[6:5])和FMT(bit[4:3]) 4個位。WL(bit[6:5])</p><p>用於設置字長（即設置音頻數據有效位數），00表示16位音頻，10表示24位音頻；FMT(bit[4:3])</p><p>用於設置音頻接口數據傳輸格式，我們設置為10，使用I2S音頻數據格式傳輸音頻數據。</p><p>6.寄存器R6（06h），該寄存器的MS（bit0）設置為1，使WM8978工作在主模式下，輸出BCLK</p><p>和LRC給FPGA。</p><p>7.寄存器R7（07h），該寄存器我們要設置採樣率SR（bit[3:1]）為000，使用48kHz的採</p><p>樣率；設置SLOWCLKEN（bit0）為1，使能零交叉功能。</p><p>8.寄存器R10（0Ah），該寄存器我們要設置DACOSR128(bit3)為1，DAC得到最好的SNR。</p><p>9.寄存器R14（0Eh），該寄存器我們要設置ADCOSR128(bit3)為1，ADC得到最好的SNR。</p><p>10.寄存器R43（2Bh），該寄存器我們只需要設置INVROUT2（bit4）為1即可，反轉ROUT2</p><p>輸出，更好的驅動喇叭。</p><p>11.寄存器R47（2Fh）和寄存器R48（30h），這兩個寄存器設置類似，一個用於設置左聲</p><p>道（R47）輸入增益（bit[6:4]），另外一個用於設置右聲道（R48）輸入增益（bit[6:4]）。</p><p>12.寄存器R49（31h），該寄存器我們要設置SPKBOOST(bit2)和TSDEN(bit1)這兩個位。</p><p>SPKBOOST用於設置喇叭的增益，我們設置為1（gain=+1.5）以獲得更大的聲音；TSDEN用於設</p><p>置過熱保護，設置為1（開啟）即可。</p><p>13.寄存器R50（32h）和 R51（33h），這兩個寄存器一個用於設置左聲道（R50），另外</p><p>一個用於設置右聲道（R51）。我們只需要設置這兩個寄存器的最低位為1即可，將左右聲道的</p><p>DAC輸出接入左右聲道混合器裡面，才能在耳機/喇叭聽到音樂。</p><p>14.寄存器R52（34h）和R53（35h），這兩個寄存器用於設置耳機音量，同樣一個用於設</p><p>置左聲道（R52），另外一個用於設置右聲道（R53）。這兩個寄存器的最高位（HPVU）用於設</p><p>置是否更新左右聲道的音量，最低6位用於設置左右聲道的音量，我們可以先設置好兩個寄存器的音量值，最後設置其中一個寄存器最高位為1，即可更新音量設置。</p><p>15.寄存器R54（36h）和R55（37h），這兩個寄存器用於設置喇叭音量，同R52，R53設置</p><p>一模一樣，這裡就不細說了。</p><p>以上，就是我們用WM8978播放音樂時的設置，按照以上所述，對各個寄存器進行相應的配</p><p>置，即可使用WM8978播放音樂了。還有其他一些3D設置，EQ設置等，我們這裡就不再介紹了，</p><p>大家參考WM8978的數據手冊自行研究下即可。</p><p><strong>實驗任務</strong></p><p>本節實驗任務是將電腦或手機的音樂通過開拓者開發板上的WM8978器件輸出到FPGA，然後</p><p>FPGA通過WM8978器件輸出給耳機和喇叭。</p><p><strong>硬件設計</strong></p><p>開拓者開發板上音頻模塊WM8978接口部分的原理圖如圖 32.3.1所示。</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c98adda02ec4e718b38ce981637211a><p class=pgc-img-caption></p></div><p><br></p><p>圖 32.3.1 WM8978接口原理圖</p><p>WM8978的MODE引腳接地，選擇的是兩線接口模式，等同於I2C接口。L2/GPIO2和R2/GPIO3</p><p>作為音頻輸入接口（LINE_IN），外部音頻從此接口輸入；LOUT1和ROUT1作為音頻輸出接口</p><p>（PHONE），輸出給外接耳機。LOUT2和ROUT2為喇叭接口。</p><p>本實驗中，各端口信號的管腳分配如下表所示：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ece245ba4c634131a200303bf056e8ea><p class=pgc-img-caption></p></div><p><br></p><p>表 32.3.1 音頻環回實驗管腳分配</p><p><strong>程序設計</strong></p><p>根據實驗任務，我們可以大致規劃出系統的控制流程：FPGA首先通過控制接口配置WM8978</p><p>相關的寄存器，然後接收WM8978傳輸過來的音頻數據，並將接收到的音頻數據傳遞給WM8978發</p><p>送出去。由此畫出系統的功能框圖如下所示：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f25a30c1a3547e6b3b8622a229e78ab><p class=pgc-img-caption></p></div><p>圖 32.4.1 WM8978音頻環回實驗系統框圖</p><p>由系統框圖可知，FPGA部分包括八個模塊，頂層模塊（audio_speak）、WM8978控制模塊（wm8978_ctrl）、時鐘分頻模塊（pll_clk）、音頻接收模塊（audio_receive）、音頻發送模</p><p>塊（audio_send）、WM8978配置模塊（wm8978_config）、I2C配置模塊（i2c_reg_cfg）和I2C</p><p>驅動模塊（i2c_dri）。各模塊的功能如下：</p><p>頂層模塊（audio_speak）：頂層模塊完成了對WM8978控制模塊和時鐘分頻模塊的例化。</p><p>並將音頻接收模塊接收到的音頻數據adc_data連接至音頻發送模塊的數據端口dac_data，實現</p><p>信號的交互連接。頂層模塊的原理圖如下圖所示：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01ed80c5143147f59ab62e35e2227a45><p class=pgc-img-caption></p></div><p><br></p><p>圖 32.4.2 頂層模塊原理圖</p><p>時鐘分頻模塊（pll_clk）：時鐘分頻模塊即鎖相環（PLL）模塊，調用鎖相環（PLL）IP</p><p>核以產生12Mhz時鐘作為WM8978的主時鐘MCLK。</p><p>WM8978控制模塊（wm8978_ctrl）：WM8978控制模塊例化了WM8978配置模塊，音頻接收模</p><p>塊和音頻發送模塊。WM8978控制模塊是對WM8978器件底層操作的封裝，使用WM8978時例化此模</p><p>塊即可。WM8978控制模塊的原理圖如下圖所示：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dfb79da18baf4dd78e187ead69255c3d><p class=pgc-img-caption></p></div><p>圖 32.4.3 WM8978控制模塊原理圖</p><p>音頻接收模塊（audio_receive）：音頻接收模塊是接收來自WM8978的音頻數據，並將WM8978</p><p>串行輸入的音頻數據進行並行處理。</p><p>音頻發送模塊（audio_send）：音頻發送模塊是將FPGA輸出的並行音頻數據串行輸出至</p><p>WM8978。</p><p>WM8978配置模塊（wm8978_config）：WM8978配置模塊例化了I2C驅動模塊（i2c_dri）和</p><p>I2C配置模塊（i2c_reg_cfg），其內部端口及信號連接如下圖所示：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/708f33e8db0c4af6a8312b013253d419><p class=pgc-img-caption></p></div><p><br></p><p>圖 32.4.4 WM8978配置模塊原理圖</p><p>I2C驅動模塊（i2c_dri）：因為WM8978的兩線控制接口的時序與I2C時序相同，所以我們</p><p>這裡調用了“EEPROM實驗”的I2C驅動模塊，實現FPGA對WM8978控制接口的操作。</p><p>I2C配置模塊（i2c_reg_cfg）：主要完成對WM8978相關寄存器的配置。</p><p>頂層模塊的代碼如下：</p><p>1 <strong>module </strong>audio_speak<strong>(</strong></p><p>2 //system clock 50MHz</p><p>3 <strong>input</strong> sys_clk <strong>,</strong> // 系統時鐘(50MHz)</p><p>4 <strong>input</strong> sys_rst_n <strong>,</strong> // 系統復位</p><p>5</p><p>6 //wm8978 interface</p><p>7 //audio interface(master mode)</p><p>8 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位時鐘</p><p>9 <strong>input</strong> aud_lrc <strong>,</strong> // 對齊信號</p><p>10 <strong>input</strong> aud_adcdat<strong>,</strong> // 音頻輸入</p><p>11 <strong>output</strong> aud_mclk <strong>,</strong> // WM8978的主時鐘(最大為12.288MHz)</p><p>12 <strong>output</strong> aud_dacdat<strong>,</strong> // 音頻輸出</p><p>13 //control interface</p><p>14 <strong>output</strong> aud_scl <strong>,</strong> // WM8978的SCL信號</p><p>15 <strong>inout</strong> aud_sda // WM8978的SDA信號</p><p>16 <strong>);</strong></p><p>17</p><p>18 //wire define</p><p>19 <strong>wire</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> adc_data<strong>;</strong> // FPGA採集的音頻數據</p><p>20</p><p>21 //*****************************************************</p><p>22 //** main code</p><p>23 //*****************************************************</p><p>24</p><p>25 //例化pll_clk</p><p>26 pll_clk u_pll_clk<strong>(</strong></p><p>27 <strong>.</strong>areset <strong>(~</strong>sys_rst_n<strong>),</strong> // pll_clk異步復位信號</p><p>28 <strong>.</strong>inclk0 <strong>(</strong>sys_clk <strong>),</strong> // 輸入sys_clk = 50 MHZ</p><p>29 <strong>.</strong>c0 <strong>(</strong>aud_mclk <strong>)</strong> // WM8978的MCLK信號（12MHz)</p><p>30 <strong>);</strong></p><p>31</p><p>32 //例化WM89878控制模塊</p><p>33 wm8978_ctrl u_wm8978_ctrl<strong>(</strong></p><p>34 //system clock</p><p>35 <strong>.</strong>clk <strong>(</strong>sys_clk <strong>),</strong> // 時鐘信號</p><p>36 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 復位信號</p><p>37 //wm8978 interface</p><p>38 //audio interface(master mode)</p><p>39 <strong>.</strong>aud_bclk <strong>(</strong>aud_bclk <strong>),</strong> // WM8978位時鐘</p><p>40 <strong>.</strong>aud_lrc <strong>(</strong>aud_lrc <strong>),</strong> // 對齊信號</p><p>41 <strong>.</strong>aud_adcdat <strong>(</strong>aud_adcdat <strong>),</strong> // 音頻輸入</p><p>42 <strong>.</strong>aud_dacdat <strong>(</strong>aud_dacdat <strong>),</strong> // 音頻輸出</p><p>43 //control interface</p><p>44 <strong>.</strong>aud_scl <strong>(</strong>aud_scl <strong>),</strong> // WM8978的SCL信號</p><p>45 <strong>.</strong>aud_sda <strong>(</strong>aud_sda <strong>),</strong> // WM8978的SDA信號</p><p>46 //user interface</p><p>47 <strong>.</strong>dac_data <strong>(</strong>adc_data <strong>),</strong> // 輸出的音頻數據</p><p>48 <strong>.</strong>adc_data <strong>(</strong>adc_data <strong>),</strong> // 輸入的音頻數據</p><p>49 <strong>.</strong>rx_done <strong>(),</strong> // 一次接收完成</p><p>50 <strong>.</strong>tx_done <strong>()</strong> // 一次發送完成</p><p>51 <strong>);</strong></p><p>52</p><p>53 <strong>endmodule</strong></p><p>頂層模塊中主要完成對其餘模塊的例化。程序中第29行的c0是經鎖相環（PLL）分頻輸出</p><p>的WM8978的主時鐘。第48行是FPGA串轉並處理後的音頻數據，這裡我們直接把該端口的音頻數</p><p>據信號連到第47行的音頻數據端口dac_data，實現音頻數據的環回。當然了也可以直接將音頻</p><p>輸入信號aud_adcdat直接連接至第42行的音頻輸出端口aud_dacdat，來實現音頻環回，但這樣</p><p>處理就不能測試音頻接收模塊和音頻發送模塊的功能是否正確。</p><p>WM8978控制模塊的代碼如下所示：</p><p>1 <strong>module </strong>wm8978_ctrl<strong>(</strong></p><p>2 //system clock</p><p>3 <strong>input</strong> clk <strong>,</strong> // 時鐘信號</p><p>4 <strong>input</strong> rst_n <strong>,</strong> // 復位信號</p><p>5</p><p>6 //wm8978 interface</p><p>7 //audio interface(master mode)</p><p>8 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位時鐘</p><p>9 <strong>input</strong> aud_lrc <strong>,</strong> // 對齊信號</p><p>10 <strong>input</strong> aud_adcdat <strong>,</strong> // 音頻輸入</p><p>11 <strong>output</strong> aud_dacdat <strong>,</strong> // 音頻輸出</p><p>12 //control interface</p><p>13 <strong>output</strong> aud_scl <strong>,</strong> // WM8978的SCL信號</p><p>14 <strong>inout</strong> aud_sda <strong>,</strong> // WM8978的SDA信號</p><p>15</p><p>16 //user interface</p><p>17 <strong>input</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> dac_data <strong>,</strong> // 輸出的音頻數據</p><p>18 <strong>output</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> adc_data <strong>,</strong> // 錄音的數據</p><p>19 <strong>output</strong> rx_done <strong>,</strong> // 一次接收完成</p><p>20 <strong>output</strong> tx_done // 一次發送完成</p><p>21 <strong>);</strong></p><p>22</p><p>23 //parameter define</p><p>24 <strong>parameter</strong> WL <strong>= </strong>6'd32<strong>;</strong> // word length音頻字長定義</p><p>25</p><p>26 //*****************************************************</p><p>27 //** main code</p><p>28 //*****************************************************</p><p>29</p><p>30 //例化wm8978_config,配置WM8978的寄存器</p><p>31 wm8978_config <strong>#(.</strong>WL<strong>(</strong>WL<strong>)) </strong>u_wm8978_config<strong>(</strong></p><p>32 //system clock</p><p>33 <strong>.</strong>clk <strong>(</strong>clk <strong>),</strong> // 時鐘信號</p><p>34 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 復位信號</p><p>35 //wm8978 interface</p><p>36 <strong>.</strong>aud_scl <strong>(</strong>aud_scl <strong>),</strong> // WM8978的SCL時鐘</p><p>37 <strong>.</strong>aud_sda <strong>(</strong>aud_sda <strong>)</strong> // WM8978的SDA信號</p><p>38 //user interface</p><p>39 <strong>);</strong></p><p>40</p><p>41 //例化audio_receive，FPGA接收WM8978的音頻數據</p><p>42 audio_receive <strong>#(.</strong>WL<strong>(</strong>WL<strong>)) </strong>u_audio_receive<strong>(</strong></p><p>43 //system reset</p><p>44 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 復位信號</p><p>45 //wm8978 interface</p><p>46 <strong>.</strong>aud_bclk <strong>(</strong>aud_bclk<strong>),</strong> // WM8978位時鐘</p><p>47 <strong>.</strong>aud_lrc <strong>(</strong>aud_lrc <strong>),</strong> // 對齊信號</p><p>48 <strong>.</strong>aud_adcdat<strong>(</strong>aud_adcdat<strong>),</strong> // 音頻輸入</p><p>49 //user interface</p><p>50 <strong>.</strong>rx_done <strong>(</strong>rx_done <strong>),</strong> // FPGA接收數據完成</p><p>51 <strong>.</strong>adc_data <strong>(</strong>adc_data<strong>)</strong> // FPGA接收的數據</p><p>52 <strong>);</strong></p><p>53</p><p>54 //例化audio_send，FPGA向WM8978傳送音頻數據</p><p>55 audio_send <strong>#(.</strong>WL<strong>(</strong>WL<strong>)) </strong>u_audio_send<strong>(</strong></p><p>56 //system reset</p><p>57 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 復位信號</p><p>58 //wm8978 interface</p><p>59 <strong>.</strong>aud_bclk <strong>(</strong>aud_bclk <strong>),</strong> // WM8978位時鐘</p><p>60 <strong>.</strong>aud_lrc <strong>(</strong>aud_lrc <strong>),</strong> // 對齊信號</p><p>61 <strong>.</strong>aud_dacdat<strong>(</strong>aud_dacdat<strong>),</strong> // 音頻數據輸出</p><p>62 //user interface</p><p>63 <strong>.</strong>dac_data <strong>(</strong>dac_data <strong>),</strong> // 預輸出的音頻數據</p><p>64 <strong>.</strong>tx_done <strong>(</strong>tx_done <strong>)</strong> // 發送完成信號</p><p>65 <strong>);</strong></p><p>66</p><p>67 <strong>endmodule</strong></p><p>WM8978控制模塊主要完成對WM8978器件層代碼的封裝，這樣當操作WM8978時，只需例化</p><p>此模塊即可實現WM8978的寄存器配置、音頻接收、音頻發送的功能。代碼第24行的參數WL即音</p><p>頻字長（word length），當用於接收、發送不同字長的音頻數據時，可修改此參數。</p><p>WM8978音頻配置模塊的代碼如下所示：</p><p>1 <strong>module </strong>wm8978_config<strong>(</strong></p><p>2 //system clock</p><p>3 <strong>input</strong> clk <strong>,</strong> // 時鐘信號</p><p>4 <strong>input</strong> rst_n <strong>,</strong> // 復位信號</p><p>5</p><p>6 //wm8978 interface</p><p>7 <strong>output</strong> aud_scl <strong>,</strong> // WM8978的SCL時鐘</p><p>8 <strong>inout</strong> aud_sda // WM8978的SDA信號</p><p>9</p><p>10 //user interface</p><p>11 <strong>);</strong></p><p>12</p><p>13 //parameter define</p><p>14 <strong>parameter</strong> SLAVE_ADDR <strong>=</strong> 7'h1a <strong>;</strong> // 器件地址</p><p>15 <strong>parameter</strong> WL <strong>=</strong> 6'd32 <strong>;</strong> // word length音頻字長參數設置</p><p>16 <strong>parameter</strong> BIT_CTRL <strong>=</strong> 1'b0 <strong>;</strong> // 字地址位控制參數(16b/8b)</p><p>17 <strong>parameter</strong> CLK_FREQ <strong>= </strong>26'd50_000_000<strong>;</strong> // i2c_dri模塊的驅動時鐘頻率(CLK_FREQ)</p><p>18 <strong>parameter</strong> I2C_FREQ <strong>= </strong>18'd250_000 <strong>;</strong> // I2C的SCL時鐘頻率</p><p>19</p><p>20 //wire define</p><p>21 <strong>wire</strong> clk_i2c <strong>;</strong> // i2c的操作時鐘</p><p>22 <strong>wire</strong> i2c_exec <strong>;</strong> // i2c觸發控制</p><p>23 <strong>wire</strong> i2c_rh_wl <strong>;</strong> // I2C讀寫控制信號</p><p>24 <strong>wire</strong> i2c_done <strong>;</strong> // i2c操作結束標誌</p><p>25 <strong>wire</strong> cfg_done <strong>;</strong> // WM8978配置完成標誌</p><p>26 <strong>wire</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> reg_data <strong>;</strong> // WM8978需要配置的寄存器（地址及數據）</p><p>27</p><p>28 //*****************************************************</p><p>29 //** main code</p><p>30 //*****************************************************</p><p>31</p><p>32 //例化i2c_dri,調用IIC協議</p><p>33 i2c_dri <strong>#(</strong></p><p>34 <strong>.</strong>SLAVE_ADDR <strong>(</strong>SLAVE_ADDR<strong>),</strong> // slave address從機地址，放此處方便參數傳遞</p><p>35 <strong>.</strong>CLK_FREQ <strong>(</strong>CLK_FREQ <strong>),</strong> // i2c_dri模塊的驅動時鐘頻率(CLK_FREQ)</p><p>36 <strong>.</strong>I2C_FREQ <strong>(</strong>I2C_FREQ <strong>)</strong> // I2C的SCL時鐘頻率</p><p>37 <strong>) </strong>u_i2c_dri<strong>(</strong></p><p>38 //global clock</p><p>39 <strong>.</strong>clk <strong>(</strong>clk <strong>),</strong> // i2c_dri模塊的驅動時鐘(CLK_FREQ)</p><p>40 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 復位信號</p><p>41 //i2c interface</p><p>42 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C觸發執行信號</p><p>43 <strong>.</strong>bit_ctrl <strong>(</strong>BIT_CTRL <strong>),</strong> // 器件地址位控制(16b/8b)</p><p>44 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl <strong>),</strong> // I2C讀寫控制信號</p><p>45 <strong>.</strong>i2c_addr <strong>(</strong>reg_data<strong>[</strong>15<strong>:</strong>8<strong>]),</strong> // I2C器件字地址</p><p>46 <strong>.</strong>i2c_data_w <strong>(</strong>reg_data<strong>[ </strong>7<strong>:</strong>0<strong>]),</strong> // I2C要寫的數據</p><p>47 <strong>.</strong>i2c_data_r <strong>(),</strong> // I2C讀出的數據</p><p>48 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I 2C一次操作完成</p><p>49 <strong>.</strong>scl <strong>(</strong>aud_scl <strong>),</strong> // I2C的SCL時鐘信號</p><p>50 <strong>.</strong>sda <strong>(</strong>aud_sda <strong>),</strong> // I2C的SDA信號</p><p>51 //user interface</p><p>52 <strong>.</strong>dri_clk <strong>(</strong>clk_i2c <strong>)</strong> // I2C操作時鐘</p><p>53 <strong>);</strong></p><p>54</p><p>55 //例化i2c_reg_cfg模塊，配置WM8978的寄存器</p><p>56 i2c_reg_cfg <strong>#(.</strong>WL<strong>(</strong>WL<strong>)</strong> // word length音頻字長參數設置</p><p>57 <strong>) </strong>u_i2c_reg_cfg<strong>(</strong></p><p>58 //clock & reset</p><p>59 <strong>.</strong>clk <strong>(</strong>clk_i2c <strong>),</strong> // i2c_reg_cfg驅動時鐘(一般取1MHz)</p><p>60 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 復位信號</p><p>61 //i2c interface</p><p>62 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I2C一次操作完成的反饋信號</p><p>63 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C觸發執行信號</p><p>64 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl<strong>),</strong> // i2c讀寫控制</p><p>65 <strong>.</strong>cfg_done <strong>(</strong>cfg_done <strong>),</strong> // WM8978配置完成</p><p>66 <strong>.</strong>i2c_data <strong>(</strong>reg_data <strong>)</strong> // 寄存器數據（7位地址+9位數據）</p><p>67 <strong>);</strong></p><p>68</p><p>69 <strong>endmodule</strong></p><p>WM8978音頻配置模塊主要完成對I2C驅動模塊和寄存器配置模塊的例化。程序中第15行的</p><p>WL參數用於音頻字長設置，也即音頻的採樣後的量化位數。音頻字長可選擇為16bit、20bit、</p><p>24bit或32bit，量化位數越多，聲音的質量越高，這裡我們採用32bit。</p><p>其中I2C驅動模塊（i2c_dri）程序與“EEPROM讀寫實驗”章節中的IIC驅動模塊（i2c_dri）</p><p>程序完全相同。有關IIC驅動模塊的詳細介紹請大家參考“EEPROM讀寫實驗”。</p><p>I2C配置模塊的代碼如下：</p><p>1 <strong>module </strong>i2c_reg_cfg <strong>(</strong></p><p>2 <strong>input</strong> clk <strong>,</strong> // i2c_reg_cfg驅動時鐘(一般取1MHz)</p><p>3 <strong>input</strong> rst_n <strong>,</strong> // 復位信號</p><p>4 <strong>input</strong> i2c_done <strong>,</strong> // I2C一次操作完成反饋信號</p><p>5 <strong>output</strong> <strong>reg</strong> i2c_exec <strong>,</strong> // I2C觸發執行信號</p><p>6 <strong>output</strong> <strong>reg</strong> cfg_done <strong>,</strong> // WM8978配置完成</p><p>7 <strong>output</strong> <strong>reg</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> i2c_data // 寄存器數據（7位地址+9位數據）</p><p>8 <strong>);</strong></p><p>9</p><p>10 //parameter define</p><p>11 <strong>parameter</strong> WL <strong>= </strong>6'd32<strong>;</strong> // word length音頻字長參數設置</p><p>12</p><p>13 //parameter define</p><p>14 <strong>localparam </strong>REG_NUM <strong>= </strong>5'd19<strong>;</strong> // 總共需要配置的寄存器個數</p><p>15 <strong>localparam </strong>PHONE_VOLUME <strong>= </strong>6'd30<strong>;</strong> // 耳機輸出音量大小參數（0~63）</p><p>16 <strong>localparam </strong>SPEAK_VOLUME <strong>= </strong>6'd45<strong>;</strong> // 喇叭輸出音量大小參數（0~63）</p><p>17</p><p>18 //reg define</p><p>19 <strong>reg</strong> <strong>[</strong>1<strong>:</strong>0<strong>]</strong> wl <strong>;</strong> // word length音頻字長參數定義</p><p>20 <strong>reg</strong> <strong>[</strong>7<strong>:</strong>0<strong>]</strong> start_init_cnt<strong>;</strong> // 初始化延時計數器</p><p>21 <strong>reg</strong> <strong>[</strong>4<strong>:</strong>0<strong>]</strong> init_reg_cnt <strong>;</strong> // 寄存器配置個數計數器</p><p>22</p><p>23 //*****************************************************</p><p>24 //** main code</p><p>25 //*****************************************************</p><p>26</p><p>27 //音頻字長（位數）參數設置</p><p>28 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>29 <strong>if(!</strong>rst_n<strong>)</strong></p><p>30 wl <strong>&lt;= </strong>2'b00<strong>;</strong></p><p>31 <strong>else begin</strong></p><p>32 <strong>case(</strong>WL<strong>)</strong></p><p>33 6'd16<strong>:</strong> wl <strong>&lt;= </strong>2'b00<strong>;</strong></p><p>34 6'd20<strong>:</strong> wl <strong>&lt;= </strong>2'b01<strong>;</strong></p><p>35 6'd24<strong>:</strong> wl <strong>&lt;= </strong>2'b10<strong>;</strong></p><p>36 6'd32<strong>:</strong> wl <strong>&lt;= </strong>2'b11<strong>;</strong></p><p>37 <strong>default:</strong></p><p>38 wl <strong>&lt;= </strong>2'd00<strong>;</strong></p><p>39 <strong>endcase</strong></p><p>40 <strong>end</strong></p><p>41 <strong>end</strong></p><p>42</p><p>43 //上電或復位後延時一段時間</p><p>44 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>45 <strong>if(!</strong>rst_n<strong>)</strong></p><p>46 start_init_cnt <strong>&lt;= </strong>8'd0<strong>;</strong></p><p>47 <strong>else if(</strong>start_init_cnt <strong>&lt; </strong>8'hff<strong>)</strong></p><p>48 start_init_cnt <strong>&lt;= </strong>start_init_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>49 <strong>end</strong></p><p>50</p><p>51 //觸發I2C操作</p><p>52 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>53 <strong>if(!</strong>rst_n<strong>)</strong></p><p>54 i2c_exec <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>55 <strong>else if(</strong>init_reg_cnt <strong>== </strong>5'd0 <strong>& </strong>start_init_cnt <strong>== </strong>8'hfe<strong>)</strong></p><p>56 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>57 <strong>else if(</strong>i2c_done <strong>&& </strong>init_reg_cnt <strong>&lt; </strong>REG_NUM<strong>)</strong></p><p>58 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>59 <strong>else</strong></p><p>60 i2c_exec <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>61 <strong>end</strong></p><p>62</p><p>63 //配置寄存器計數</p><p>64 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>65 <strong>if(!</strong>rst_n<strong>)</strong></p><p>66 init_reg_cnt <strong>&lt;= </strong>5'd0<strong>;</strong></p><p>67 <strong>else if(</strong>i2c_exec<strong>)</strong></p><p>68 init_reg_cnt <strong>&lt;= </strong>init_reg_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>69 <strong>end</strong></p><p>70</p><p>71 //寄存器配置完成信號</p><p>72 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>73 <strong>if(!</strong>rst_n<strong>)</strong></p><p>74 cfg_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>75 <strong>else if(</strong>i2c_done <strong>& (</strong>init_reg_cnt <strong>== </strong>REG_NUM<strong>) )</strong></p><p>76 cfg_done <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>77 <strong>end</strong></p><p>78</p><p>79 //配置I2C器件內寄存器地址及其數據</p><p>80 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>81 <strong>if(!</strong>rst_n<strong>)</strong></p><p>82 i2c_data <strong>&lt;= </strong>16'b0<strong>;</strong></p><p>83 <strong>else begin</strong></p><p>84 <strong>case(</strong>init_reg_cnt<strong>)</strong></p><p>85 // R0,軟復位</p><p>86 5'd0 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd0 <strong>,</strong>9'b1<strong>};</strong></p><p>87 // R1,設置VMIDSEL,BUFIOEN,BIASEN,PLLEN,BUFDCOPEN</p><p>88 5'd1 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd1 <strong>,</strong>9'b1_0010_1111<strong>};</strong></p><p>89 // R2,使能BOOSTENR,BOOSTENL和ADCENR/L；使能ROUT1,LOUT1</p><p>90 5'd2 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd2 <strong>,</strong>9'b1_1011_0011<strong>};</strong></p><p>91 // R3,LOUT2,ROUT2輸出使能(喇叭工作),RMIX,LMIX,DACENR、DACENL使能</p><p>92 5'd3<strong>: </strong>i2c_data <strong>&lt;=</strong> <strong>{</strong>7'd3 <strong>,</strong>9'b0_0110_1111<strong>};</strong></p><p>93 // R4,配置wm8978音頻接口數據為I2S格式（bit4：3），字長度(wl)</p><p>94 5'd4 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd4 <strong>,{</strong>2'd0<strong>,</strong>wl<strong>,</strong>5'b10000<strong>}};</strong></p><p>95 // R6,設置為MASTER MODE(BCLK和LRC輸出)</p><p>96 5'd5 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd6 <strong>,</strong>9'b0_0000_0001<strong>};</strong></p><p>97 // R7,使能slow clock，採樣率為48KHz（bit3：1）</p><p>98 5'd6 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd7 <strong>,</strong>9'b0_0000_0001<strong>};</strong></p><p>99 // R10,設置DAC過採樣率為128x（bit3）,以實現最佳信噪比</p><p>100 5'd7 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd10<strong>,</strong>9'b0_0000_1000<strong>};</strong></p><p>101 // R14,設置ADC過採樣率為128x（bit3）,以達到最佳信噪比</p><p>102 5'd8 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd14<strong>,</strong>9'b1_0000_1000<strong>};</strong></p><p>103 // R43,INVROUT2（bit4）反向,驅動喇叭</p><p>104 5'd9 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd43<strong>,</strong>9'b0_0001_0000<strong>};</strong></p><p>105 // R47,左通道輸入增益控制，L2_2BOOSTVOL（bit6：4）</p><p>106 5'd10<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd47<strong>,</strong>9'b0_0111_0000<strong>};</strong></p><p>107 // R48,右通道輸入增益控制</p><p>108 5'd11<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd48<strong>,</strong>9'b0_0111_0000<strong>};</strong></p><p>109 // R49,TSDEN（bit0）,開啟過熱保護；SPKBOOST（bit2）1.5倍增益</p><p>110 5'd12<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd49<strong>,</strong>9'b0_0000_0110<strong>};</strong></p><p>111 // R50,選擇左DAC輸出至左輸出混合器（bit0）</p><p>112 5'd13<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd50<strong>,</strong>9'b1<strong>};</strong></p><p>113 // R51,選擇右DAC輸出至右輸出混合器（bit0）</p><p>114 5'd14<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd51<strong>,</strong>9'b1<strong>};</strong></p><p>115 // R52,耳機左聲道音量設置（bit5:0），使能零交叉（bit7）</p><p>116 5'd15<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd52<strong>,{</strong>3'b010<strong>,</strong>PHONE_VOLUME<strong>}};</strong></p><p>117 // R53,耳機右聲道音量設置（bit5:0），使能零交叉（bit7）,同步更新(HPVU=1)</p><p>118 5'd16<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd53<strong>,{</strong>3'b110<strong>,</strong>PHONE_VOLUME<strong>}};</strong></p><p>119 // R54,喇叭左聲道音量設置（bit5:0），使能零交叉（bit7）</p><p>120 5'd17<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd54<strong>,{</strong>3'b010<strong>,</strong>SPEAK_VOLUME<strong>}};</strong></p><p>121 // R55,喇叭右聲道音量設置（bit5:0），使能零交叉（bit7）,同步更新(SPKVU=1)</p><p>122 5'd18<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd55<strong>,{</strong>3'b110<strong>,</strong>SPEAK_VOLUME<strong>}};</strong></p><p>123 <strong>default : ;</strong></p><p>124 <strong>endcase</strong></p><p>125 <strong>end</strong></p><p>126 <strong>end</strong></p><p>127</p><p>128 <strong>endmodule</strong></p><p>I2C配置模塊主要完成對WM8978的寄存器配置。WM8978開始上電時電壓有可能不夠穩定，</p><p>所以程序中定義了一個延時計數器（start_init_cnt）等待WM8978工作在穩定的狀態。當計數</p><p>器計數到預設值之後，開始第一次配置即軟復位，目的是讓所有的寄存器復位到默認的狀態。</p><p>發送完軟件復位命令後，緊接著配置剩下的寄存器。在代碼的第14行定義了總共需要配置的寄</p><p>存器的個數，如果增加或者刪減了寄存器的配置，需要修改此參數。第15行和第16行分別為耳</p><p>機和喇叭的音量參數，調整耳機和喇叭的音量可修改此參數。</p><p>音頻接收模塊代碼如下：</p><p>1 <strong>module </strong>audio_receive <strong>#(parameter </strong>WL <strong>= </strong>6'd32<strong>) (</strong> // WL(word length音頻字長定義)</p><p>2 //system clock 50MHz</p><p>3 <strong>input</strong> rst_n <strong>,</strong> // 復位信號</p><p>4</p><p>5 //wm8978 interface</p><p>6 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位時鐘</p><p>7 <strong>input</strong> aud_lrc <strong>,</strong> // 對齊信號</p><p>8 <strong>input</strong> aud_adcdat<strong>,</strong> // 音頻輸入</p><p>9</p><p>10 //user interface</p><p>11 <strong>output</strong> <strong>reg</strong> rx_done <strong>,</strong> // FPGA接收數據完成</p><p>12 <strong>output</strong> <strong>reg [</strong>31<strong>:</strong>0<strong>]</strong> adc_data // FPGA接收的數據</p><p>13 <strong>);</strong></p><p>14</p><p>15 //reg define</p><p>16 <strong>reg</strong> aud_lrc_d0<strong>;</strong> // aud_lrc延遲一個時鐘週期</p><p>17 <strong>reg</strong> <strong>[ </strong>5<strong>:</strong>0<strong>]</strong> rx_cnt<strong>;</strong> // 發送數據計數</p><p>18 <strong>reg</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> adc_data_t<strong>;</strong> // 預輸出的音頻數據的暫存值</p><p>19</p><p>20 //wire define</p><p>21 <strong>wire</strong> lrc_edge <strong>;</strong> // 邊沿信號</p><p>22</p><p>23 //*****************************************************</p><p>24 //** main code</p><p>25 //*****************************************************</p><p>26</p><p>27 <strong>assign</strong> lrc_edge <strong>= </strong>aud_lrc <strong>^ </strong>aud_lrc_d0<strong>;</strong> // LRC信號的邊沿檢測</p><p>28</p><p>29 //為了在aud_lrc變化的第二個AUD_BCLK上升沿採集aud_adcdat,延遲打拍採集</p><p>30 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>31 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>32 aud_lrc_d0 <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>33 <strong>end</strong></p><p>34 <strong>else</strong></p><p>35 aud_lrc_d0 <strong>&lt;= </strong>aud_lrc<strong>;</strong></p><p>36 <strong>end</strong></p><p>37</p><p>38 //採集32位音頻數據的計數</p><p>39 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>40 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>41 rx_cnt <strong>&lt;= </strong>6'd0<strong>;</strong></p><p>42 <strong>end</strong></p><p>43 <strong>else if(</strong>lrc_edge <strong>== </strong>1'b1<strong>)</strong></p><p>44 rx_cnt <strong>&lt;= </strong>6'd0<strong>;</strong></p><p>45 <strong>else if(</strong>rx_cnt <strong>&lt; </strong>6'd35<strong>)</strong></p><p>46 rx_cnt <strong>&lt;= </strong>rx_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>47 <strong>end</strong></p><p>48</p><p>49 //把採集到的音頻數據臨時存放在一個寄存器內</p><p>50 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>51 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>52 adc_data_t <strong>&lt;= </strong>32'b0<strong>;</strong></p><p>53 <strong>end</strong></p><p>54 <strong>else if(</strong>rx_cnt <strong>&lt; </strong>WL<strong>)</strong></p><p>55 adc_data_t<strong>[</strong>WL <strong>- </strong>1'd1 <strong>- </strong>rx_cnt<strong>] &lt;= </strong>aud_adcdat<strong>;</strong></p><p>56 <strong>end</strong></p><p>57</p><p>58 //把臨時數據傳遞給adc_data,並使能rx_done,表明一次採集完成</p><p>59 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>60 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>61 rx_done <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>62 adc_data <strong>&lt;= </strong>32'b0<strong>;</strong></p><p>63 <strong>end</strong></p><p>64 <strong>else if(</strong>rx_cnt <strong>== </strong>6'd32<strong>) begin</strong></p><p>65 rx_done <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>66 adc_data<strong>&lt;= </strong>adc_data_t<strong>;</strong></p><p>67 <strong>end</strong></p><p>68 <strong>else</strong></p><p>69 rx_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>70 <strong>end</strong></p><p>71</p><p>72 <strong>endmodule</strong></p><p>音頻接收模塊的時鐘信號是WM8978的位時鐘信號aud_bclk，所以在程序的第3行我們只定</p><p>義了rst_n信號。</p><p>第27行的assign語句和第30行的always語句實現了aud_lrc信號的雙邊沿檢測。第39行和</p><p>第50行的always語句實現了音頻信號 aud_adcdat在aud_lrc信號變化後的第二個 BCLK</p><p>（aud_bclk）的上升沿採樣，以及把音頻信號的最高有效位放在adc_data_t的最高位。</p><p>音頻發送模塊的代碼如下：</p><p>1 <strong>module </strong>audio_send <strong>#(parameter </strong>WL <strong>= </strong>6'd32<strong>) (</strong> // WL(word length音頻字長定義)</p><p>2 //system reset</p><p>3 <strong>input</strong> rst_n <strong>,</strong> // 復位信號</p><p>4</p><p>5 //wm8978 interface</p><p>6 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位時鐘</p><p>7 <strong>input</strong> aud_lrc <strong>,</strong> // 對齊信號</p><p>8 <strong>output</strong> <strong>reg</strong> aud_dacdat<strong>,</strong> // 音頻數據輸出</p><p>9 //user interface</p><p>10 <strong>input</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> dac_data <strong>,</strong> // 預輸出的音頻數據</p><p>11 <strong>output</strong> <strong>reg</strong> tx_done // 發送一次音頻位數完成</p><p>12 <strong>);</strong></p><p>13</p><p>14 //reg define</p><p>15 <strong>reg</strong> aud_lrc_d0<strong>;</strong> // aud_lrc延遲一個時鐘週期</p><p>16 <strong>reg</strong> <strong>[ </strong>5<strong>:</strong>0<strong>]</strong> tx_cnt<strong>;</strong> // 發送數據計數</p><p>17 <strong>reg</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> dac_data_t<strong>;</strong> // 預輸出的音頻數據的暫存值</p><p>18</p><p>19 //wire define</p><p>20 <strong>wire</strong> lrc_edge<strong>;</strong> // 邊沿信號</p><p>21</p><p>22 //*****************************************************</p><p>23 //** main code</p><p>24 //*****************************************************</p><p>25</p><p>26 <strong>assign</strong> lrc_edge <strong>= </strong>aud_lrc <strong>^ </strong>aud_lrc_d0<strong>;</strong> // LRC信號的邊沿檢測</p><p>27</p><p>28 //為了在aud_lrc變化的第二個AUD_BCLK上升沿採集aud_adcdat,延遲打拍採集</p><p>29 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>30 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>31 aud_lrc_d0 <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>32 <strong>end</strong></p><p>33 <strong>else</strong></p><p>34 aud_lrc_d0 <strong>&lt;= </strong>aud_lrc<strong>;</strong></p><p>35 <strong>end</strong></p><p>36</p><p>37 //發送32位音頻數據的計數</p><p>38 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>39 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>40 tx_cnt <strong>&lt;=</strong> 6'd0<strong>;</strong></p><p>41 dac_data_t <strong>&lt;= </strong>32'd0<strong>;</strong></p><p>42 <strong>end</strong></p><p>43 <strong>else if(</strong>lrc_edge <strong>== </strong>1'b1<strong>) begin</strong></p><p>44 tx_cnt <strong>&lt;= </strong>6'd0<strong>;</strong></p><p>45 dac_data_t <strong>&lt;= </strong>dac_data<strong>;</strong></p><p>46 <strong>end</strong></p><p>47 <strong>else if(</strong>tx_cnt <strong>&lt; </strong>6'd35<strong>)</strong></p><p>48 tx_cnt <strong>&lt;= </strong>tx_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>49 <strong>end</strong></p><p>50</p><p>51 //發送完成信號</p><p>52 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>53 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>54 tx_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>55 <strong>end</strong></p><p>56 <strong>else if(</strong>tx_cnt <strong>== </strong>6'd32<strong>)</strong></p><p>57 tx_done <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>58 <strong>else</strong></p><p>59 tx_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>60 <strong>end</strong></p><p>61</p><p>62 //把預發送的音頻數據串行發送出去</p><p>63 <strong>always @(negedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>64 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>65 aud_dacdat <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>66 <strong>end</strong></p><p>67 <strong>else if(</strong>tx_cnt <strong>&lt; </strong>WL<strong>)</strong></p><p>68 aud_dacdat <strong>&lt;= </strong>dac_data_t<strong>[</strong>WL <strong>- </strong>1'd1 <strong>- </strong>tx_cnt<strong>];</strong></p><p>69 <strong>else</strong></p><p>70 aud_dacdat <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>71 <strong>end</strong></p><p>72</p><p>73 <strong>endmodule</strong></p><p>音頻發送模塊與音頻接收模塊基本相同，有一點區別是程序第63行我們使用的是aud_bclk</p><p>的下降沿。這是為了能夠讓WM8978正確採集到I2S總線上的音頻數據，即aud_lrc信號變化後的</p><p>第二個BCLK（aud_bclk）的上升沿採樣到FPGA發送的音頻信號aud_dacdat。</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/68925809a31748da9af4832f3d7c9a20><p class=pgc-img-caption></p></div><p><br></p><p>圖 32.4.5是為音頻環回過程中SignalTap抓取到的波形圖。</p><p>從圖中可以看到音頻環回模塊的aud_lrc信號的邊沿檢測信號lrc_edge，在aud_lrc變化後的第一個aud_bclk的低電平時拉高。</p><p>當FPGA接收音頻時，在接下來的aud_bclk的第一個上升沿rx_cnt變為00h，在第二個上升沿時</p><p>採集WM8978發送過來的音頻數據。當FPGA發送音頻時，在接下來的aud_bclk的第一個下降沿傳</p><p>輸音頻數據給WM8978，在第二個上升沿時WM8978採集FPGA發送的音頻數據。這樣就滿足了I2S</p><p>信號傳輸格式的要求。</p><p>圖 32.4.5 音頻環回過程中 SignalTap抓取的波形圖</p><p><strong>下載驗證</strong></p><p>首先我們打開音頻環回實驗工程，在工程所在的路徑下打開audio_speak/par文件夾，在</p><p>裡面找到“audio_speak.qpf”並雙擊打開。注意工程所在的路徑名只能由字母、數字以及下</p><p>劃線組成，不能出現中文、空格以及特殊字符等。工程打開後如圖 32.5.1所示。</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/77a9e33e5b16491a9f430ca616b0169b><p class=pgc-img-caption></p></div><p><br></p><p>圖 32.5.1 音頻環回實驗工程</p><p>然後將下載器一端連電腦，另一端與開發板上對應端口連接，將音頻連接線的一端連接至</p><p>電腦或手機的音頻輸出端口，另一端連接至WM8978的LINE_IN接口，然後將耳機連接至WM8978</p><p>的PHONE接口，最後連接電源線並打開電源開關。</p><p>開拓者開發板實物圖如下所示：</p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f49ccc9ab92843189d9e512ad9e478cf><p class=pgc-img-caption></p></div><p>圖 32.5.2 開拓者開發板硬件圖</p><p>接下來我們下載程序，驗證WM8978的音頻環回功能。</p><p>工程打開後通過點擊工具欄中的“Programmer”圖標打開下載界面，通過“Add File”按</p><p>鈕選擇audio_speak/par/output_files目錄下的“audio_speak.sof”文件。開發板電源打開</p><p>後，在程序下載界面點擊“Hardware Setup”，在彈出的對話框中選擇當前的硬件連接為“USB-</p><p>Blaster[USB-0]”。然後點擊“Start”將工程編譯完成後得到的sof文件下載到開發板中，如</p><p>圖 32.5.3所示。</p><p><br></p><div class=pgc-img><img alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/33ad51f6505a4057bd483bdb198af6f5><p class=pgc-img-caption></p></div><p>圖 32.5.3 程序下載界面</p><p>下載完成後打開音頻連接線一端連接的電腦或手機，播放一首音樂，這時聽到喇叭播放音</p><p>樂，戴上耳機，也能聽到播放的音樂，說明音頻環回實驗程序下載驗證成功。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>正點</a></li><li><a>開拓者</a></li><li><a>FPGA</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html title=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示>正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cbd5c1.html alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cbd5c1.html title=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗>正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html alt=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html title=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗>正點原子開拓者NiosII資料連載第二十六章高速示波器實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html alt="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html title="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理">正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html alt=FPGA無線通信課程連載——擾碼的原理及實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RzH3OlM2Sr7uEv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html title=FPGA無線通信課程連載——擾碼的原理及實現>FPGA無線通信課程連載——擾碼的原理及實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html alt="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html title="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器">「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html alt="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html title="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器">「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html alt=FPGA管腳調整注意事項及技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rt0Fp44Iqh26UT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html title=FPGA管腳調整注意事項及技巧>FPGA管腳調整注意事項及技巧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html alt=基於FPGA的多通道同步實時高速數據採集系統設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RT9ec7T8clHaQI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html title=基於FPGA的多通道同步實時高速數據採集系統設計>基於FPGA的多通道同步實時高速數據採集系統設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51718fda.html alt=FPGA基礎之時序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b67909f181e2497f883a202aadca9129 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51718fda.html title=FPGA基礎之時序設計>FPGA基礎之時序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/769d1d2c04b9410aa18cd0add525013f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html title=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了>「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3006b33b.html alt=基於FPGA的LVDS高可靠性傳輸優化設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153533281868967dc1af365 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3006b33b.html title=基於FPGA的LVDS高可靠性傳輸優化設計>基於FPGA的LVDS高可靠性傳輸優化設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html alt=FPGA為什麼可編程，這篇文章來告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7abe76ede514e308d57ca293420a430 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html title=FPGA為什麼可編程，這篇文章來告訴你>FPGA為什麼可編程，這篇文章來告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ae61a10.html alt=FPGA的建立時間、保持時間、傳播延時、組合邏輯延時都是什麼呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ca8d58bfb9fd4b5cb2c14c1edbae1701 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ae61a10.html title=FPGA的建立時間、保持時間、傳播延時、組合邏輯延時都是什麼呢？>FPGA的建立時間、保持時間、傳播延時、組合邏輯延時都是什麼呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3301fa18.html alt=FPGA乘法器的簡單用法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15321368486336e286b374a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3301fa18.html title=FPGA乘法器的簡單用法>FPGA乘法器的簡單用法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>