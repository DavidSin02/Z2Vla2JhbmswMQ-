<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「譯」V8中的指針壓縮 | 极客快訊</title><meta property="og:title" content="「譯」V8中的指針壓縮 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b1c6245abfe14806844464dbac346fd3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e6ccb0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e6ccb0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e6ccb0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e6ccb0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e6ccb0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e6ccb0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e6ccb0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e6ccb0.html><meta property="article:published_time" content="2020-10-29T21:00:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:27+08:00"><meta name=Keywords content><meta name=description content="「譯」V8中的指針壓縮"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5e6ccb0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「譯」V8中的指針壓縮</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>內存和性能之間的鬥爭始終存在。作為用戶，我們希望速度又快佔用內存又少。然而通常情況下，提高性能需要消耗更多的內存（反之亦然）。</p><p>時間回到2014年，那時Chrome從32位切換到64位。這個變化帶給了Chrome更好的安全性、穩定性和性能，但同時也帶來了更多內存的消耗，因為之前每個指針佔用4個字節而現在佔用是8個字節。我們面臨在V8中儘可能減少這種多出來4個字節開銷的挑戰。</p><p>在實施改進之前，我們需要知道我們目前的狀況，從而正確的評估如何改進。為了測量當前的內存和性能，我們使用一組可以代表目前流行站點的頁面。數據顯示在桌面端Chrome渲染進程內存佔用中V8佔用了60%，平均為40%。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b1c6245abfe14806844464dbac346fd3><p class=pgc-img-caption>在Chrome渲染進程內存佔用中V8的內存消耗百分比</p></div><p>指針壓縮是改進V8內存佔用的多項工作之一。想法很簡單：我們可以存儲一些“基”地址的32位偏移量而不是存儲64位指針。這樣一個簡單的想法，我們可以從V8中的這種壓縮獲得多少收益？</p><p>V8的堆區包含大量的項目（items），例如浮點值（floating point values），字符串字符（string characters），解析器字節碼（interpreter bytecode）和標記值（tagged values）。在檢查堆區時，我們發現在現實使用的網站中，這些標記值佔了V8堆區的70%！</p><p>下面我們具體看看這些標記值是什麼。</p><h1 class=pgc-h-center-line>V8中的標記值</h1><p>在V8中JavaScript的對象，數組，數字或者字符串都用對象表示，分配在V8堆區。這使得我們可以用一個指向對象的指針表示任何值。</p><p>許多JavaScript程序都會對整數進行計算，例如在循環中增加索引。為了避免每次整數遞增時重新分配一個新的number對象，V8使用著名的指針標記技術(pointer tagging)在V8的堆指針中存儲其他或替代數據。</p><p>標記位（tag bits）有雙重作用：用於指示位於V8堆中對象的強/弱指針或一個小整數的信號。因此，整數能夠直接存儲在標記值中，而不必為其分配額外的存儲空間。</p><p>V8在堆中按字對齊的地址分配對象，這使得它可以使用2（或3，取決於機器字大小）最低有效位進行標記。在32位架構中，V8使用最低有效位去區分Smis和堆對象指針。對於堆指針，它使用第二個最低有效位去區分強引用和弱引用：</p><pre><code>                        |----- 32 bits -----|Pointer:                |_____address_____w1|Smi:                    |___int31_value____0|</code></pre><p>這裡的 <strong>w</strong> 用來區分強指針和弱指針。</p><p>注意：一個Smi值只能攜帶一個31bit有效載荷（payload），包括符號位。對於指針，我們有30bit用來作為堆對象地址有效載荷（payload）。由於字對齊，分配粒度為4個字節，這給了我們4GB的尋址空間。</p><p>在64位架構中，V8的值看起來像這樣：</p><pre><code>            |----- 32 bits -----|----- 32 bits -----|Pointer:    |________________address______________w1|Smi:        |____int32_value____|0000000000000000000|</code></pre><p>不同於32位架構，在64位架構中V8可以將32位用於Smi值有效載荷（payload）。以下各節將討論32位Smis對指針壓縮的影響。</p><h1 class=pgc-h-center-line>壓縮標記值（tagged values）和新的堆佈局</h1><p>使用指針壓縮，我們的目標是以某種方式在64位架構中將兩種標記值轉換為32位。我們通過以下方式將指針調整為32位：</p><ul><li>確保所有V8對象分配在4GB範圍內</li><li>將指針表示為這個範圍內的偏移量</li></ul><p>這樣嚴格的限制是非常不幸的，但是Chrome中的V8已經將堆限制到2GB或4GB大小（具體限制到多少取決於設備），即使在64位架構上也是如此。其他V8嵌入程序，例如Node.js可能需要更大的堆。如果我們添加最大4GB的限制，就會讓這些嵌入V8的程序無法使用指針壓縮。</p><p>現在的問題是如何更新堆佈局才能讓32位指針唯一標識V8對象。</p><p><strong>簡單的堆內存佈局（Trivial heap layout）</strong></p><p>簡單的壓縮方案是在前4GB的地址空間分配對象。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b00ae77124040d78fc9ca8ed20db5f1><p class=pgc-img-caption>簡單的堆內存佈局</p></div><p>但是很可惜V8不能這樣做，因為Chrome的渲染進程可能需要在同一渲染器進程中創建多個V8的實例，例如對於Web/Service Workers。除此之外，用這個方案會導致所有的V8實例競爭相同的4GB地址空間從而導致所有的V8實例都受到4GB內存的限制。</p><p><strong>堆內存佈局，v1</strong></p><p>如果我們將V8堆（heap）放在其他地方的連續4GB地址空間，那麼一個從base開始的無符號32位偏移量將唯一標識一個指針。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/033b1ae80e0b437fb760be5ca9f93451><p class=pgc-img-caption>堆內存佈局，開始base對齊</p></div><p>如果我們確保base是4GB對齊（4-GB-aligned），則所有指針的高位32位都相同。</p><pre><code>            |----- 32 bits -----|----- 32 bits -----|Pointer:    |________base_______|______offset_____w1|</code></pre><p>通過將Smi的有效載荷（payload）限制為31位並將其放在低32位，我們還可以壓縮Smis。基本上，使它和在32位架構中類似。</p><pre><code>         |----- 32 bits -----|----- 32 bits -----|Smi:     |sssssssssssssssssss|____int31_value___0|</code></pre><p>這裡 <strong>s</strong> 是Smi有效載荷的符號值。如果再有使用符號擴展表示，我們就可以僅用64位字的一位算數移位來壓縮和解壓Smis。</p><p>現在，我們可以看到指針和Smis的上半字（upper half-word）完全由下半字定義。這樣，我們就可以只將後者存儲在內存中，從而將存儲標記值所需的內存減少一半。</p><pre><code>                    |----- 32 bits -----|----- 32 bits -----|Compressed pointer:                     |______offset_____w1|Compressed Smi:                         |____int31_value___0|</code></pre><p>假設base是4GB對齊的，則壓縮就是截斷：</p><pre><code>uint64_t uncompressed_tagged;uint32_t compressed_tagged = uint32_t(uncompressed_tagged);</code></pre><p>但是解壓代碼要複雜一些。我們需要區分符號擴展（sign-extending）Smi和零擴展（zero-extending）指針，以及是否要添加base。</p><pre><code>uint32_t compressed_tagged;uint64_t uncompressed_tagged;if (compressed_tagged &amp; 1) {  // pointer case  uncompressed_tagged = base + uint64_t(compressed_tagged);} else {  // Smi case  uncompressed_tagged = int64_t(compressed_tagged);}</code></pre><p>嘗試改變壓縮方案來簡化解壓代碼。</p><p><strong>堆內存佈局，v2</strong></p><p>如果將base不是放在4GB的開頭，而是中間，就可以將壓縮值視為從base開始的一個有符號32位偏移量。注意，整個保留不再是4GB對齊（4-GB-aligned），但是base依然是對齊的。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aea6be50e443490caca64706ed4866d8><p class=pgc-img-caption>堆內存佈局，中間base對齊</p></div><p>在這個新的佈局中，壓縮代碼和上面堆內存佈局v1中的相同。</p><p>然而解壓代碼變得更好了。現在對Smi和指針來說，符號擴展是相同的，唯一的分支在於如果是指針，需要添加base。</p><pre><code>int32_t compressed_tagged;// Common code for both pointer and Smi casesint64_t uncompressed_tagged = int64_t(compressed_tagged);if (uncompressed_tagged &amp; 1) {  // pointer case  uncompressed_tagged += base;}</code></pre><p>代碼中分支的性能取決於CPU中的分支預測單元。如果我們以無分支的方式執行解壓，我們可以得到更好的性能。通過少量魔術，我們可以寫出一個無分支版本的代碼：</p><pre><code>int32_t compressed_tagged;// Same code for both pointer and Smi casesint64_t sign_extended_tagged = int64_t(compressed_tagged);int64_t selector_mask = -(sign_extended_tagged &amp; 1);// Mask is 0 in case of Smi or all 1s in case of pointerint64_t uncompressed_tagged =    sign_extended_tagged + (base &amp; selector_mask);</code></pre><p>然後，我們決定從無分支實現開始。</p><h1 class=pgc-h-center-line>性能演化</h1><p><strong>初始性能</strong></p><p>我們使用Octane測試性能，Octane是我們過去使用的性能基準測試。儘管我們在日常工作中不再專注於提高性能峰值（improving peak performance），但我們也不希望降低它，特別是一些像指針這樣對性能敏感的東西。Octane依然是完成這個任務的好的基準測試。</p><p>圖形顯示了在使用指針壓縮時Octane在x64架構上的得分。在圖中，線越高越好。紅色的線是未壓縮指針的x64構建，綠色的線是指針壓縮的版本。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8fb9866f252a4c9ab906c1ba22332c11><p class=pgc-img-caption>Octane第一輪改進</p></div><p>在第一個方案中，我們的迴歸差約為35%。</p><p><strong>Bump(1), +7%</strong></p><p>首先我們通過比較無分支解壓和有分支解壓，驗證了“無分支會更快”的假設。事實證明，我們的假設是錯誤的，在x64上，有分支版本的速度提高了7%。這是非常大的不同！</p><p>下面看一下x64彙編</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/723f486a21f14b01a1149fcc542aa246><p class=pgc-img-caption>x64彙編</p></div><p>r13是base值的專用寄存器。注意，無分支代碼在這裡代碼量更多且需要的寄存器也更多。</p><p>在Arm64，我們觀察到相同的現象——在強大的CPU上，有分支版本明顯更快（儘管這兩種情況的代碼大小是一樣的）。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7ed6ffaabac84ce3a3231ec696ca415d><p class=pgc-img-caption>Arm64彙編</p></div><p>在低端Arm64設備上我們發現在任一方向上幾乎沒什麼性能差異。</p><p>我們的收穫是：在現代CPU中分支預測器非常的好，代碼的大小（code size）（尤其是執行路徑的長度）對性能影響更大。</p><p><strong>Bump(2), +2%</strong></p><p>TurboFan是V8的優化編譯器，圍繞“Sea of Nodes”概念構建。簡單來說就是每一個操作在graph中用一個Node表示。這些節點有各種依賴，包括數據流和控制流。</p><p>有兩個對指針壓縮至關重要的操作：加載和存儲，因為它們將V8堆內存和管道（pipeline）的其餘部分連起來。如果我們每次從堆內存加載壓縮值的時候都解壓，並且在存儲之前對其壓縮，那麼管道（pipeline）就可以像在全指針模式（full-pointer mode）下工作了。因此我們在節點圖中添加了新的顯式操作——壓縮和解壓。</p><p>在某些情況下解壓是不需要的，例如，如果一個壓縮值僅僅是從某個位置被加載然後存儲到新的位置。</p><p>為了優化不必要的操作，我們在TurboFan中實施了一個新的“消除解壓”階段。它的工作就是消除直接壓縮後的解壓。由於這些節點可能不會直接相連，因此它會嘗試通過graph傳播解壓，以期遇到壓縮問題並消除。這給使我們的Octane的值提高了2%。</p><p><strong>Bump(3), +2%</strong></p><p>在查看生成代碼時，我們注意到解壓一個剛剛被加載的值會導致代碼的冗長：</p><pre><code>movl rax, &lt;mem&gt;   // loadmovlsxlq rax, rax // sign extend</code></pre><p>一旦我們修復了標誌擴展的問題，value就可以直接從內存中加載。</p><pre><code>movlsxlq rax, &lt;mem&gt;</code></pre><p>我們得到了另外2%的改善。</p><p><strong>Bump(4), +11%</strong></p><p>TurboFan優化階段通過在graph上使用模式匹配工作：一旦一個sub-garph與一個特定模式匹配，就會被替換為語義上等效（但是更好）的sub-graph或指令（instruction）。</p><p>嘗試匹配不成功並不會有明確的失敗提示。在graph中顯式的壓縮/解壓操作導致之前成功的模式匹配嘗試失敗，從而導致優化失敗且沒有提示。</p><p>“中斷”優化的其中一個例子是分配預配置（allocation preternuring）。一旦我們更新匹配模式（pattern matching）使其能夠匹配到新的壓縮 / 解壓 node，我們就可以得到另外11%的改進。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b2d0587c66e24baeb4aa30e3dd4ef5ea><p class=pgc-img-caption>Octane的第二輪改進</p></div><p><strong>Bump(5), +0.5%</strong></p><p>在TurboFan中使用解壓去除（Decompression Elimination）我們學到了很多。顯式的解壓 / 壓縮node方法具有以下特性：</p><p>優點：</p><ul><li>很明顯我們通過對sub-graphs的規範模式匹配可以優化不必要的解壓。</li></ul><p>但是，隨著我們進一步的實施，我們發現缺點：</p><ul><li>新的內部值的表示可能會導致轉換操作變的難以管理。除了現有的表示集（tagged Smi, tagged pointer），我們還有壓縮指針，壓縮Smi，壓縮任何值（壓縮值可以是指針或Smi）。</li><li>現有的基於graph的模式匹配（pattern-matching）的優化並沒有生效，這導致了一些地方的回退（regressions）。儘管我們找到並修復其中的問題，但TurboFan的複雜性仍在不斷增加。</li><li>寄存器分配器（register allocator）對graph中的node數量越來越不滿意，並且經常生成錯誤的代碼。</li><li>較大的node graph會減緩TurboFan優化階段，並增加編譯期間的內存消耗。</li></ul><p>我們決定回退一步，考慮在TurboFan中實現一種更簡單的指針壓縮方式。新的方法是刪除壓縮指針/Smi/任何表示，然後讓所有顯式的壓縮/解壓 node 隱藏在存儲和加載中，並假設我們始終在加載之前壓縮，在存儲之前解壓。</p><p>我們還在TurboFan中添加新的階段，該階段將替代“解壓消除（Decompression Elimination”。這個新的階段能夠識別我們什麼時候不需要壓縮或解壓並相應地更新“加載和存儲”。這種方法顯著降低了TurboFan中指針壓縮的複雜性，提高了生成代碼的質量。</p><p>新的操作和初始時候一樣有效，並且又提高了0.5%的性能。</p><p><strong>Bump(6), +2.5%</strong></p><p>我們已經接近平均性能，但是依然有差距。我們必須有更好的想法。其中一個想法是：如果我們確保任何處理Smi值的代碼都不處理高32位，結果會怎麼樣？</p><p>之前的解壓實現：</p><pre><code>// Old decompression implementationint64_t uncompressed_tagged = int64_t(compressed_tagged);if (uncompressed_tagged &amp; 1) {  // pointer case  uncompressed_tagged += base;}</code></pre><p>如果我們忽略一個Smi的高32位就可以假定它是`undefined`。這樣，我們就可以避免指針和Smi之間的特殊case，並且可以在解壓的時候無條件的添加base，即使是對Smis也可以！我們稱這個方法為“Smi-corrupting”。</p><pre><code>// New decompression implementationint64_t uncompressed_tagged = base + int64_t(compressed_tagged);</code></pre><p>由於我們不關注Smi的符號擴展（sign extending），因此這個改變允許我們回到堆內存佈局v1。這是一個base指向4GB預留空間的開始位置。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe87a9203d0c40d188f7282b05d0ab02><p class=pgc-img-caption>Heap layout, base aligned to start</p></div><p>就解壓代碼而言，這個改變將符號擴展（sign-extension）變為零擴展（zero-extension），這也同樣簡單。但是這簡化了運行時（C++）端的工作。例如，例如地址空間區域保留代碼。</p><p>這是用於比較的彙編：</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/80bd6b7c47dc4b61b336f23145d5fa36><p class=pgc-img-caption>彙編</p></div><p>因此我們更將8中所有的使用Smi的代碼塊調整為新的壓縮方案，這給我們另外2.5%的性能提升。</p><p><strong>剩餘差距（Remaining gap）</strong></p><p>剩餘的性能差距可以用對64位構建的兩個優化來解釋，這些優化由於與指針壓縮不兼容而禁用。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f1a96e50da4f4531a074055f9e02e692><p class=pgc-img-caption>Octane的最後一輪改進</p></div><p><strong>32-bit Smi優化(7), -1%</strong></p><p>我們回顧一下，Smis在64位架構全指針模式中看起來是這樣：</p><pre><code>        |----- 32 bits -----|----- 32 bits -----|Smi:    |____int32_value____|0000000000000000000|</code></pre><p>32-bit Smi有如下好處：</p><ul><li>它可以有更大的整數範圍且不需要封裝成整數對象</li><li>這樣的形式可以在讀/寫時直接訪問32位值</li></ul><p>由於使用指針壓縮後會具有區分指針和Smis的bit，導致在32-bit壓縮指針中沒有空間，所以導致該優化無法使用。如果我們在64-bit版本中禁用32-bit smis，將會看到Octane值下降1%。</p><p><strong>雙精度字段拆箱（雙精度 field unboxing） (8), -3%</strong></p><blockquote class=pgc-blockquote-abstract><p>譯者注：裝箱（boxing）是指編譯器自動將基本數據類型值轉換成對應的包裝類的對象，拆箱（unboxing）則是反過來。</p></blockquote><p>在某些假設下，這種優化嘗試直接將浮點值存儲在對象的字段中。這樣做的目的是減少數字對象分配的數量，這比單獨用Smis減少的更多。</p><p>想象一下下面這段代碼：</p><pre><code>function Point(x, y) {  this.x = x;  this.y = y;}const p = new Point(3.1, 5.3);</code></pre><p>一般來說，對象p在內存中的樣子如下：</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/618f4de9f3834ec6bf98f6f3aef753e0><p class=pgc-img-caption>對象p在內存中的形式</p></div><p>關於更多存儲中的隱藏類，屬性和元素可以[閱讀此文](https://v8.dev/blog/fast-properties)</p><p>在64位架構中，雙精度值和指針的大小相同。所以**如果我們假設Point字段總是包含number值**，則可以將它們直接存儲在對象中。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/beac8370ae1148b79bdeaf68b6dcad82><p class=pgc-img-caption></p></div><p>如果某個字段導致假設不成立，例如執行下面這段代碼：</p><pre><code>const q = new Point(2, 'ab');</code></pre><p>y屬性的number值必須裝箱存儲（store boxed instead）。另外，如果某處的優化的代碼依賴此假設，則該優化必須捨棄。進行這些“字段類型”泛化的原因是為了儘量減少通過同一構造函數創建的對象的Shapes數量，反過來這對於具有穩定的性能是很必要的。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1e9206b6021644fe97a689040434213e><p class=pgc-img-caption>對象p和q在內存中的形式</p></div><p>如果應用該優化，雙精度字段拆箱給我們如下好處：</p><ul><li>通過對象指針提供對浮點數據的直接訪問，避免通過number對象進行額外的取消引用操作。</li><li>允許我們對緊湊循環（tight loops）生成更小更快的優化代碼從而可以做大量的雙精度字段訪問。（例如在數字運算應用程序中）</li></ul><p>啟用指針壓縮後，雙精度值不再適合壓縮字段。然而，在未來我們可能為指針壓縮適配該優化。</p><p>注意，即使沒有雙精度字段拆箱優化（以與指針壓縮兼容的方式），也可以通過將數據存儲在Float64 TypedArrays，甚至是使用Wasm重寫要求高吞吐量的數字運算代碼。</p><p><strong>更多的優化（9），1%</strong></p><p>最後，對TurboFan中的解壓消除優化進行微調又得到另外1%的性能提升。</p><h1 class=pgc-h-center-line>一些優化細節</h1><p>為了簡化將指針壓縮整合到現有代碼中，我們決定在每次加載values的時候解壓並且在每次存儲的時壓縮它們。因此只是改變標誌值的存儲格式，而執行格式保持不變。</p><p><strong>NaNative代碼端</strong></p><p>為了在解壓的時候生成有效的代碼，必須保證始終提供base值。幸運的是V8已經有一個專用的寄存器指向一個“根表（roots table）”，該表包含JavaScript和V8內部對象的引用，這些對象必須始終可用（例如：undefined，null，true，false等）。該寄存器被稱為“根寄存器”，它用來生成較小的，可以共享的內部代碼。</p><p>所以，我們將根表放在V8堆保留區，根寄存器可以同時有兩種用途：</p><ul><li>作為根指針</li><li>作為解壓的的base值</li></ul><p><strong>C++ 端</strong></p><p>V8運行時通過C++類訪問在V8堆區的對象，從而提供對堆中存儲的數據的便捷訪問。請注意，V8對象比C++對象更類似於POD的結構。助手（helper）“view”類僅僅包含一個帶有相應標記值的uintptr_t字段。由於view類是字大小的（word-size），因此我們可以將它按值傳遞，開銷為零（這樣感謝現代C++編譯器）。</p><p>這裡是一個helper類的偽代碼：</p><pre><code>// Hidden classclass Map {  ...  inline DescriptorArray instance_descriptors() const;  ...  // The actual tagged pointer value stored in the Map view object.  cosnt uintptr_t ptr_;}DescriptorArray Map::instance_descriptors() const {  uintptr_t field_address = FieldAddress(ptr_, kInstanceDescriptorsOffset);  uintptr_t da = *reinterpret_cast&lt;uintptr_t*&gt;(field_address);  return DescriptorArray(da);}</code></pre><p>為了儘量減少首次運行指針壓縮版本的所需的更改次數，我們將解壓必須的base值的計算集成到getter中。</p><pre><code>inline uintptr_t GetBaseForPointerCompression(uintptr_t address) {  // Round address down to 4 GB  const uintptr_t kBaseAlignment = 1 &lt;&lt; 32;  return address &amp; -kBaseAlignment;}DescriptorArray Map::instance_descriptors() const {  uintptr_t field_address = FieldAddress(ptr_, kInstanceDescriptorsOffset);  uint32_t compressed_da = *reinterpret_cast&lt;uint32_t*&gt;(field_address);  uintptr_t base = GetBaseForPointerCompression(ptr_);  uintptr_t da = base + compressed_da;  return DescriptorArray(da);}</code></pre><p>性能測量結果證實，在每次加載的時候計算base值會影響性能。原因在於C++編譯器不知道，對於V8堆區的任何地址調用`GetBaseForPointerCompression()`的結果是相同的，因此編譯器無法合併base值的計算。鑑於代碼包含多個指令和一個64位常量，這將導致代碼顯著膨脹。</p><p>為了處理這個問題，我們重用V8實例指針作為解壓時用的base（記住，V8實例數據在堆區佈局中）。該指針通常在運行時函數中可用，所以我們通過要求使用V8實例指針簡化getters代碼，並恢復來了性能：</p><pre><code>DescriptorArray Map::instance_descriptors(const Isolate* isolate) const {  uintptr_t field_address =      FieldAddress(ptr_, kInstanceDescriptorsOffset);  uint32_t compressed_da = *reinterpret_cast&lt;uint32_t*&gt;(field_address);  // No rounding is needed since the Isolate pointer is already the base.  uintptr_t base = reinterpret_cast&lt;uintptr_t&gt;(isolate);  uintptr_t da = DecompressTagged(base, compressed_value);  return DescriptorArray(da);}</code></pre><h1 class=pgc-h-center-line>結果</h1><p>讓我們來看看指針壓縮的最後結果！對於這些結果，我們使用與本文開頭介紹的相同的網站測試。提醒一下，他們代表用戶在真實世界網站使用情況。</p><p>我們發現指針壓縮將V8堆區大小減少43%！反過來，它減少桌面端Chrome渲染進程20%的內存佔用。</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2655b68726c3480ba52be4a2641e45ea><p class=pgc-img-caption>在Windows 10中的內存節省</p></div><p>另一個重要的事情是，不是每一個網站都有相同的改進。例如，在沒有使用指針壓縮的時候Facebook使用V8堆區內存比紐約時報要多，但是使用該優化後，使用堆內存情況變得相反。這個不同可以通過以下事實解釋：某些網站具有比其他網站更多的標記值（Tagged values）。</p><p>除了這些內存改進，我們還看到了實際性能的改進。在真實網站上，我們使用更少的CPU和垃圾回收時間！</p><div class=pgc-img><img alt=「譯」V8中的指針壓縮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52318b0905e54cbcba00c8f41d240a7e><p class=pgc-img-caption>在CPU和GC time上的改進</p></div><h1 class=pgc-h-center-line>結論</h1><p>這一路上儘管沒有鳥語花香，但是值得度過。300+的提交後，指針壓縮讓V8擁有64位應用的性能，同時擁有32位的內存佔用。</p><p>我們一直期待著性能的改進，並在流程中完成以下相關任務：</p><ul><li>改進生成彙編代碼的質量。我們知道在某些情況下我們能夠生成更少的代碼來提高性能。</li><li>解決相關的性能下降，包括一個機制，該機制以指針壓縮友好的方式再次對doble字段拆箱。</li><li>探索支持8～16G範圍內更大堆的想法。</li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>V8</a></li><li><a>指針</a></li><li><a>壓縮</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8775ee99.html alt=音頻壓縮編碼的基本原理詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1d62465bab4542babd5647386c272c82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8775ee99.html title=音頻壓縮編碼的基本原理詳解>音頻壓縮編碼的基本原理詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22525cee.html alt=數字音視頻壓縮編碼標準及H.265的編碼優勢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/558a023201a84604894ebc359d178ed2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22525cee.html title=數字音視頻壓縮編碼標準及H.265的編碼優勢>數字音視頻壓縮編碼標準及H.265的編碼優勢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e4f2831.html alt=C++｜類封裝如何提升安全和可維護性，以智能指針封裝裸指針為例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e4f2831.html title=C++｜類封裝如何提升安全和可維護性，以智能指針封裝裸指針為例>C++｜類封裝如何提升安全和可維護性，以智能指針封裝裸指針為例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a41e30c.html alt="乾貨 | 離心壓縮機幹氣密封原理與典型故障分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/90500f6b56a14817916f16ef0ed2fd63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a41e30c.html title="乾貨 | 離心壓縮機幹氣密封原理與典型故障分析">乾貨 | 離心壓縮機幹氣密封原理與典型故障分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ad89f6a.html alt=大慶石化壓縮機幹氣密封實現國產化 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ad89f6a.html title=大慶石化壓縮機幹氣密封實現國產化>大慶石化壓縮機幹氣密封實現國產化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e269274b.html alt=材料力學基礎，杆件的拉伸與壓縮，62頁內容詳細介紹材料力學基礎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d238749283454d088aaa3febd084d52a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e269274b.html title=材料力學基礎，杆件的拉伸與壓縮，62頁內容詳細介紹材料力學基礎>材料力學基礎，杆件的拉伸與壓縮，62頁內容詳細介紹材料力學基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3c597b2.html alt=壓縮機油壓差的原理、結構、檢修 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8bd40a8a24df46c2ba7ddf926b736818 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3c597b2.html title=壓縮機油壓差的原理、結構、檢修>壓縮機油壓差的原理、結構、檢修</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3cbb9f5.html alt=維修案例：壓縮空氣冷幹機控制電路沒電，順藤摸故障 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/85cb0a6064ed4bce9bd971579c6dc54d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3cbb9f5.html title=維修案例：壓縮空氣冷幹機控制電路沒電，順藤摸故障>維修案例：壓縮空氣冷幹機控制電路沒電，順藤摸故障</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/154be17c.html alt="Java 壓縮算法哪家強" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/649441a963e5442397dd58994f8d3f31 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/154be17c.html title="Java 壓縮算法哪家強">Java 壓縮算法哪家強</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e54e928.html alt=VBScript中的LZW壓縮算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e54e928.html title=VBScript中的LZW壓縮算法>VBScript中的LZW壓縮算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5bd75600.html alt=你不知道的Linux壓縮解壓命令-rar class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15309360853288f1001d48d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5bd75600.html title=你不知道的Linux壓縮解壓命令-rar>你不知道的Linux壓縮解壓命令-rar</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab13ad86.html alt=壓縮純數據Excel表格必學的正確姿勢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0bff9df0ee954b909787b16b2b4db226 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab13ad86.html title=壓縮純數據Excel表格必學的正確姿勢>壓縮純數據Excel表格必學的正確姿勢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7f40c9f.html alt=超大動圖壓縮到2M，新媒體必備的壓縮工具 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1539157683659efc40eb9fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7f40c9f.html title=超大動圖壓縮到2M，新媒體必備的壓縮工具>超大動圖壓縮到2M，新媒體必備的壓縮工具</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a4e2fe3.html alt="Archiver for Mac(全面的壓縮解壓工具) v3.0.9漢化版" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1cd6cd720fdb43e79a73c4f324165816 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a4e2fe3.html title="Archiver for Mac(全面的壓縮解壓工具) v3.0.9漢化版">Archiver for Mac(全面的壓縮解壓工具) v3.0.9漢化版</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8af8bcfc.html alt="Java 複製、壓縮PDF文檔" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0c8af1656070453991d0564813b0fe23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8af8bcfc.html title="Java 複製、壓縮PDF文檔">Java 複製、壓縮PDF文檔</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>