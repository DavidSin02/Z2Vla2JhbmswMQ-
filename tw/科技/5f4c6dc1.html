<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>事務機制和鎖機制 | 极客快訊</title><meta property="og:title" content="事務機制和鎖機制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/5a547c8c402142cca7ed81d05fe0e3e3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f4c6dc1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f4c6dc1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f4c6dc1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f4c6dc1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f4c6dc1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f4c6dc1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f4c6dc1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f4c6dc1.html><meta property="article:published_time" content="2020-11-14T21:08:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:12+08:00"><meta name=Keywords content><meta name=description content="事務機制和鎖機制"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>事務機制和鎖機制</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>事務的必要性</p><p>為了避免出現數據不一致問題，需要在存儲過程中引入事務的概念，將更新語句綁在一起，讓它們成為一個”原子性”的操作：更新語句要麼都執行，要麼都不執行。</p><p>一、關閉MySQL自動提交的方法</p><p>1、顯示關閉自動提交</p><p>set autocommit=0;1</p><p>2、隱式關閉自動提交：（推薦）</p><p>start transaction1</p><p>一般推薦使用隱式的提交方式，因為不會修改到autocommit系統變量。</p><p>二、關閉自動提交後，提交更新語句的方法有</p><p>1.顯示地提交：（推薦）</p><p>commit;1</p><p>2.隱式地提交</p><p>包括了begin、set autocommit=1、start transaction、rename table、truncate table等語句；</p><p>數據定義（create、alter、drop）function、alter procedure、drop database、drop table、drop function、drop index、drop procedure等；</p><p>權限管理和賬戶管理語句（grant、revoke、set password、create user、drop user、rename user）</p><p>鎖語句（lock tables、unlock tables）</p><p>更推薦用顯示提交地方式。</p><p>三、事務處理使用方法</p><p>在處理錯誤代碼地程序中使用rollback（事務回滾）。</p><p>在具有原子性操作的地方，使用start transaction隱式地關閉自動提交，並且在結束的為止上使用commit顯示提交。</p><p>四、事務保存點的使用方法</p><p>在事務中使用savepoint 保存點名 的格式創建保存點，實現事務的”部分”提交或”部分”撤銷（rollback to savepoint 保存點名）。</p><p>保存點是”臨時狀態”，既可以回滾到事務開始前的狀態，也能決定事務的下一個狀態，是介於兩自動提交語句所引發狀態中的一種臨時狀態。</p><p>五、鎖機制的必要性</p><p>內存中的數據與外存中的數據不同步，其中的表記錄之間存在“同步延遲“。</p><p>六、MyISAM表施加表級鎖的語法格式</p><p>lock tables 表1 [as 別名] read [local]</p><p>[,表2[ as 別名2][low_priority] write] ...12</p><p>其中read local與read選項的差別為 READ LOCAL允許在鎖定被保持時，執行非衝突性INSERT語句（同時插入）。</p><p>七、鎖的粒度、隱式鎖與顯示鎖、鎖的類型、鎖的鑰匙、鎖的生命週期</p><p>1.鎖的粒度指鎖的作用範圍：</p><p>多個MySQL客戶機併發訪問同一個數據時，為保證數據的一致性，數據庫管理系統會自動地為該數據加鎖、解鎖，這種是隱式鎖。</p><p>而有時單靠隱式鎖無法實現數據的一致性訪問要求（例如對於臨界資源的爭奪上），此時需要手動地加鎖、解鎖，這種稱為顯示鎖。</p><p>2.鎖的類型分為：讀鎖（共享鎖）和寫鎖（排他鎖或獨佔鎖）</p><p>3.鎖的鑰匙： 當多個MySQL客戶機併發訪問同一個數據時、如果MySQL客戶機A對該數據成功地施加了鎖，那麼只有MySQL客戶機A擁有這把鎖的鑰匙。</p><p>4.鎖的生命週期：在同一個MySQL會話內，對數據加鎖到解鎖之間的時間間隔。鎖的生命週期越長，併發訪問性能越低；鎖的生命週期越短，併發訪問性能越高。</p><p>八、InnoDB表施加行級鎖的語法格式</p><p>共享鎖 select * from 表 where 條件語句 lock in share mode;</p><p>排他鎖 select * from 表 where 條件語句 for update;</p><p>九、InnoDB中的間隙鎖、記錄鎖</p><p>當檢索條件滿足某區間範圍，但表中不存在的記錄，此時也有共享鎖或排他鎖，即行級鎖會鎖定相鄰的鍵，這種機制就是間隙鎖（next－key鎖）</p><p>當事務隔離級別設置為repeatable read，此時InnoDB表施加行級鎖，默認使用間隔鎖（需要索引），</p><p>當事務的隔離級別設置為read uncommited或者read commited，此時InnoDB表施加行級鎖，默認情況下使用記錄鎖（record lock）。</p><p>與間隙鎖不同，記錄鎖僅僅為滿足該查詢範圍的記錄施加共享鎖或排他鎖。</p><p>十、鎖等待與死鎖</p><p>一）鎖等待：是為了保證事務可以正常地併發運行，鎖等待不一定導致死鎖問題的發生。而死鎖問題的發生一定伴隨著鎖等待現象。</p><p>二）死鎖：</p><p>1、定義： 是指兩個或兩個以上的進程在執行過程中，由於競爭資源或者由於彼此通信而造成的一種阻塞的現象，若無外力作用，它們都將無法推進下去。當線程進入對象的synchronized代碼塊時，便佔有了資源，直到它退出該代碼塊或者調用wait方法，才釋放資源，在此期間，其他線程將不能進入該代碼塊。當線程互相持有對方所需要的資源時，會互相等待對方釋放資源，如果線程都不主動釋放所佔有的資源，將產生死鎖。</p><p>2、<strong>死鎖的產生4個必要條件：</strong></p><p>1）互斥條件：進程對於所分配到的資源具有排它性，即一個資源只能被一個進程佔用，直到被該進程釋放</p><p>2）<strong>佔有且等待</strong>：一個進程因請求被佔用資源而發生阻塞時，對已獲得的資源保持不放。</p><p>3）<strong>不可搶佔</strong>條件：任何一個資源在沒被該進程釋放之前，任何其他進程都無法對他剝奪佔用</p><p>4）循環等待條件：當發生死鎖時，所等待的進程必定會形成一個環路（類似於死循環），造成永久阻塞。</p><p>3、死鎖的另一種：遞歸死鎖，舉例：</p><p>遞歸函數就是自調用函數，在函數體內直接或間接的調用自己，即函數的嵌套是函數本身。</p><p>遞歸方式有兩種:直接遞歸和間接遞歸，直接遞歸就是在函數中出現調用函數本身。間接遞歸，指函數中調用了其他函數，而該其他函數又調用了本函數。</p><p>那什麼時候使用遞歸呢？一般來說當你要在某段代碼邏輯中使用循環迭代的時候但是迭代的次數在迭代之前無法知曉的情況下使用遞歸。打個比方你要在一個文件夾中查找某個文件，而這個文件夾底下有N多子文件夾和文件，當你在不知道有多少層文件夾和文件的情況下你就得用到遞歸了。</p><p>遞歸的優點就是讓代碼顯得很簡潔，同時有些應用場景不得不使用遞歸比如前面說的找文件。遞歸是個好東西但是在某些時候也會給你帶來一些麻煩。比如在多線程的環境下使用遞歸，遇到了多線程那麼就不得不面對同步的問題。而遞歸程序遇到同步的時候很容易出問題。</p><p>多線程的遞歸就是指遞歸鏈中的某個方法由另外一個線程來操作，以下代碼的意思都是這個意思即調用recursive()和businessLogic()並非一個線程<strong>(如果是在一個線程中就不存在死鎖問題，例如下面的recursive變成private就不存在問題。</strong>)</p><p><strong>[java]</strong> view plain copy</p><ol><li><strong>public class Test {</strong></li><li><strong>public void recursive(){</strong></li><li><strong>this.businessLogic();</strong></li><li>}</li><li><strong>public synchronized void businessLogic(){</strong></li><li>System.out.println("處理業務邏輯");</li><li>System.out.println("保存到&lt;a href="http://lib.csdn.net/base/mysql" class='replace_word' title="MySQL知識庫" target='_blank' style='color:#df3434; font-weight:bold;'>數據庫&lt;/a>");</li><li><strong>this.recursive();</strong></li><li>}</li><li>}</li></ol><p>以上這段代碼就是個能形成死鎖的代碼，事實上這個“synchronized”放在“businessLogic()”和“recursive()”都會形成死鎖，並且是多線程的情況下就會鎖住！他的邏輯順序是先執行recursive()方法然後接下來執行businessLogic()方法同時將businessLogic()方法鎖住，接下來程序進入businessLogic()方法內部執行完打印語句後開始執行recursive()，進入recursive()後準備執行businessLogic()，等等問題來了！之前執行的businessLogic()的鎖還沒有放開這次又執行到這裡了，當然是過不去的了，形成了死鎖！從這個例子我們總結出來一個規律就是在遞歸的時候在遞歸鏈上面的方法上加鎖肯定會出現死鎖（所謂遞歸鏈就是指recursive()鏈向businessLogic()，businessLogic()又鏈回recursive()），解決這個問題的方法就是避免在遞歸鏈上加鎖，請看以下的例子</p><p><strong>[java]</strong> view plain copy</p><ol><li><strong>public class Test {</strong></li><li><strong>public void recursive(){</strong></li><li><strong>this.businessLogic();</strong></li><li>}</li><li><strong>public void businessLogic(){</strong></li><li>System.out.println("處理業務邏輯");</li><li><strong>this.saveToDB();</strong></li><li><strong>this.recursive();</strong></li><li>}</li><li><strong>public synchronized void saveToDB(){</strong></li><li>System.out.println("保存到數據庫");</li><li>}</li><li>}</li></ol><p>saveToDB()不在這條遞歸鏈上面自然不會出現死鎖，所以說在遞歸中加鎖是件很危險的事情，實在逃不過要加鎖就加在最小的粒度的程序代碼上以減小死鎖的概率。</p><p>4、處理死鎖的方法</p><p>4.1 預防死鎖</p><p>4.2 避免死鎖</p><p>4.2.1 常用避免死鎖的方法</p><p>4.2.1.1 有序資源分配法</p><p>4.2.1.2 銀行家算法</p><p>4.2.2 常用避免死鎖的技術</p><p>4.2.2.1 加鎖順序</p><p>4.2.2.2 加鎖時限</p><p>4.2.2.3 死鎖檢測</p><p>4.3 檢測死鎖</p><p>4.4 解除死鎖</p><p>處理死鎖的方法</p><p>4.1、死鎖預防 ----- 確保系統永遠不會進入死鎖狀態 產生死鎖需要四個條件，那麼，只要這四個條件中至少有一個條件得不到滿足，就不可能發生死鎖了。由於互斥條件是非共享資源所必須的，不僅不能改變，還應加以保證，所以，主要是破壞產生死鎖的其他三個條件。</p><p>a、破壞“佔有且等待”條件</p><p>方法1：所有的進程在開始運行之前，必須一次性地申請其在整個運行過程中所需要的全部資源。</p><p>優點：簡單易實施且安全。</p><p>缺點：因為某項資源不滿足，進程無法啟動，而其他已經滿足了的資源也不會得到利用，嚴重降低了資源的利用率，造成資源浪費。 使進程經常發生飢餓現象。</p><p>方法2：該方法是對第一種方法的改進，允許進程只獲得運行初期需要的資源，便開始運行，在運行過程中逐步釋放掉分配到的已經使用完畢的資源，然後再去請求新的資源。這樣的話，資源的利用率會得到提高，也會減少進程的飢餓問題。</p><p>b、破壞“不可搶佔”條件 當一個已經持有了一些資源的進程在提出新的資源請求沒有得到滿足時，它必須釋放已經保持的所有資源，待以後需要使用的時候再重新申請。這就意味著進程已佔有的資源會被短暫地釋放或者說是被搶佔了。 該種方法實現起來比較複雜，且代價也比較大。釋放已經保持的資源很有可能會導致進程之前的工作實效等，反覆的申請和釋放資源會導致進程的執行被無限的推遲，這不僅會延長進程的週轉週期，還會影響系統的吞吐量。</p><p>c、破壞“循環等待”條件 可以通過定義資源類型的線性順序來預防，可將每個資源編號，當一個進程佔有編號為i的資源時，那麼它下一次申請資源只能申請編號大於i的資源。如圖所示：這樣雖然避免了循環等待，但是這種方法是比較低效的，資源的執行速度回變慢，並且可能在沒有必要的情況下拒絕資源的訪問，比如說，進程c想要申請資源1，如果資源1並沒有被其他進程佔有，此時將它分配個進程c是沒有問題的，但是為了避免產生循環等待，該申請會被拒絕，這樣就降低了資源的利用率</p><p>4.2、避免死鎖 ----- 在使用前進行判斷，只允許不會產生死鎖的進程申請資源的死鎖避免是利用額外的檢驗信息，在分配資源時判斷是否會出現死鎖，只在不會出現死鎖的情況下才分配資源。</p><p>兩種避免辦法：</p><p>1、如果一個進程的請求會導致死鎖，則不啟動該進程</p><p>2、如果一個進程的增加資源請求會導致死鎖 ，則拒絕該申請。</p><p>注意：預防死鎖和避免死鎖的區別：</p><p>預防死鎖是設法至少破壞產生死鎖的四個必要條件之一,嚴格的防止死鎖的出現,</p><p>而避免死鎖則不那麼嚴格的限制產生死鎖的必要條件的存在,因為即使死鎖的必要條件存在,也不一定發生死鎖。避免死鎖是在系統運行過程中注意避免死鎖的最終發生。</p><p><strong>4.2.1 常用避免死鎖的方法</strong></p><p>4.2.1.1 有序資源分配法</p><p>這種算法資源按某種規則系統中的所有資源統一編號（例如打印機為1、磁帶機為2、磁盤為3、等等），申請時必須以上升的次序。系統要求申請進程：</p><p>1、對它所必須使用的而且屬於同一類的所有資源，必須一次申請完；</p><p>2、在申請不同類資源時，必須按各類設備的編號依次申請。例如：進程PA，使用資源的順序是R1，R2； 進程PB，使用資源的順序是R2，R1；若採用動態分配有可能形成環路條件，造成死鎖。</p><p>採用有序資源分配法：R1的編號為1，R2的編號為2；</p><p>PA：申請次序應是：R1，R2</p><p>PB：申請次序應是：R1，R2</p><p>這樣就破壞了環路條件，避免了死鎖的發生。</p><p><strong>4.2.1.2銀行家算法</strong></p><p>詳見銀行家算法.</p><p>避免死鎖的具體實現通常利用銀行家算法 銀行家算法a、銀行家算法的相關數據結構</p><p>1）可利用資源向量Available：用於表示系統裡邊各種資源剩餘的數目。由於系統裡邊擁有的資源通常都是有很多種（假設有m種），所以，我們用一個有m個元素的數組來表示各種資源。數組元素的初始值為系統裡邊所配置的該類全部可用資源的數目，其數值隨著該類資源的分配與回收動態地改變。</p><p>2） 最大需求矩陣Max：用於表示各個進程對各種資源的額最大需求量。進程可能會有很多個（假設為n個），那麼，我們就可以用一個nxm的矩陣來表示各個進程多各種資源的最大需求量</p><p>3）分配矩陣Allocation：顧名思義，就是用於表示已經分配給各個進程的各種資源的數目。也是一個nxm的矩陣。</p><p>4）需求矩陣Need：用於表示進程仍然需要的資源數目，用一個nxm的矩陣表示。</p><p>系統可能沒法一下就滿足了某個進程的最大需求（通常進程對資源的最大需求也是指它在整個運行週期中需要的資源數目，並不是每一個時刻都需要這麼多），於是，為了進程的執行能夠向前推進，通常，系統會先分配個進程一部分資源保證進程能夠執行起來。那麼，進程的最大需求減去已經分配給進程的數目，就得到了進程仍然需要的資源數目了。</p><p>銀行家算法通過對進程需求、佔有和系統擁有資源的實時統計，確保系統在分配給進程資源不會造成死鎖才會給與分配。</p><p>注意：死鎖避免的優缺點</p><p>1）死鎖避免的優點：不需要死鎖預防中的搶佔和重新運行進程，並且比死鎖預防的限制要少。</p><p>2）死鎖避免的限制： 必須事先聲明每個進程請求的最大資源量 考慮的進程必須無關的，也就是說，它們執行的順序必須沒有任何同步要求的限制 分配的資源數目必須是固定的。 在佔有資源時，進程不能退出</p><p>4.2.2 常用避免死鎖的技術：</p><p>4.2.2.1 加鎖順序：（線程按照一定的順序加鎖）</p><p>4.2.2.2 加鎖時限（線程嘗試獲取鎖的時候加上一定的時限，超過時限則放棄對該鎖的請求，並釋放自己佔有的鎖）</p><p>4.2.2.3 死鎖檢測</p><p><strong>1]加鎖順序</strong></p><p>當多個線程需要相同的一些鎖，但是按照不同的順序加鎖，死鎖就很容易發生。</p><p>如果能確保所有的線程都是按照相同的順序獲得鎖，那麼死鎖就不會發生。看下面這個例子：</p><pre>Thread 1: lock A  lock BThread 2: wait for A lock C (when A locked)Thread 3: wait for A wait for B wait for C</pre><p>如果一個線程（比如線程3）需要一些鎖，那麼它必須按照確定的順序獲取鎖。它只有獲得了從順序上排在前面的鎖之後，才能獲取後面的鎖。</p><p>例如，線程2和線程3只有在獲取了鎖A之後才能嘗試獲取鎖C(<em>譯者注：獲取鎖A是獲取鎖C的必要條件</em>)。因為線程1已經擁有了鎖A，所以線程2和3需要一直等到鎖A被釋放。然後在它們嘗試對B或C加鎖之前，必須成功地對A加了鎖。</p><p>按照順序加鎖是一種有效的死鎖預防機制。但是，這種方式需要你事先知道所有可能會用到的鎖(<em>譯者注：並對這些鎖做適當的排序</em>)，但總有些時候是無法預知的。</p><p><strong>2]加鎖時限</strong></p><p>另外一個可以避免死鎖的方法是在嘗試獲取鎖的時候加一個超時時間，這也就意味著在嘗試獲取鎖的過程中若超過了這個時限該線程則放棄對該鎖請求。若一個線程沒有在給定的時限內成功獲得所有需要的鎖，則會進行回退並釋放所有已經獲得的鎖，然後等待一段隨機的時間再重試。這段隨機的等待時間讓其它線程有機會嘗試獲取相同的這些鎖，並且讓該應用在沒有獲得鎖的時候可以繼續運行(<em>譯者注：加鎖超時後可以先繼續運行乾點其它事情，再回頭來重複之前加鎖的邏輯</em>)。</p><p>以下是一個例子，展示了兩個線程以不同的順序嘗試獲取相同的兩個鎖，在發生超時後回退並重試的場景：</p><pre>Thread 1 locks AThread 2 locks BThread 1 attempts to lock B but is blockedThread 2 attempts to lock A but is blockedThread 1's lock attempt on B times outThread 1 backs up and releases A as wellThread 1 waits randomly (e.g. 257 millis) before retrying.Thread 2's lock attempt on A times outThread 2 backs up and releases B as wellThread 2 waits randomly (e.g. 43 millis) before retrying.</pre><p>在上面的例子中，線程2比線程1早200毫秒進行重試加鎖，因此它可以先成功地獲取到兩個鎖。這時，線程1嘗試獲取鎖A並且處於等待狀態。當線程2結束時，線程1也可以順利的獲得這兩個鎖（除非線程2或者其它線程在線程1成功獲得兩個鎖之前又獲得其中的一些鎖）。</p><p>需要注意的是，由於存在鎖的超時，所以我們不能認為這種場景就一定是出現了死鎖。也可能是因為獲得了鎖的線程（導致其它線程超時）需要很長的時間去完成它的任務。</p><p>此外，如果有非常多的線程同一時間去競爭同一批資源，就算有超時和回退機制，還是可能會導致這些線程重複地嘗試但卻始終得不到鎖。如果只有兩個線程，並且重試的超時時間設定為0到500毫秒之間，這種現象可能不會發生，但是如果是10個或20個線程情況就不同了。因為這些線程等待相等的重試時間的概率就高的多（或者非常接近以至於會出現問題）。</p><p>(<em>譯者注：超時和重試機制是為了避免在同一時間出現的競爭，但是當線程很多時，其中兩個或多個線程的超時時間一樣或者接近的可能性就會很大，因此就算出現競爭而導致超時後，由於超時時間一樣，它們又會同時開始重試，導致新一輪的競爭，帶來了新的問題。</em>)</p><p>這種機制存在一個問題，在Java中不能對synchronized同步塊設置超時時間。你需要創建一個自定義鎖，或使用Java5中java.util.concurrent包下的工具。寫一個自定義鎖類不復雜，但超出了本文的內容。後續的Java併發系列會涵蓋自定義鎖的內容。</p><p><strong>3]死鎖檢測</strong></p><p>死鎖檢測是一個更好的死鎖預防機制，它主要是針對那些不可能實現按序加鎖並且鎖超時也不可行的場景。</p><p>每當一個線程獲得了鎖，會在線程和鎖相關的數據結構中（map、graph等等）將其記下。除此之外，每當有線程請求鎖，也需要記錄在這個數據結構中。</p><p>當一個線程請求鎖失敗時，這個線程可以遍歷鎖的關係圖看看是否有死鎖發生。例如，線程A請求鎖7，但是鎖7這個時候被線程B持有，這時線程A就可以檢查一下線程B是否已經請求了線程A當前所持有的鎖。如果線程B確實有這樣的請求，那麼就是發生了死鎖（線程A擁有鎖1，請求鎖7；線程B擁有鎖7，請求鎖1）。</p><p>當然，死鎖一般要比兩個線程互相持有對方的鎖這種情況要複雜的多。線程A等待線程B，線程B等待線程C，線程C等待線程D，線程D又在等待線程A。線程A為了檢測死鎖，它需要遞進地檢測所有被B請求的鎖。從線程B所請求的鎖開始，線程A找到了線程C，然後又找到了線程D，發現線程D請求的鎖被線程A自己持有著。這是它就知道發生了死鎖。</p><p>下面是一幅關於四個線程（A,B,C和D）之間鎖佔有和請求的關係圖。像這樣的數據結構就可以被用來檢測死鎖。</p><div class=pgc-img><img alt=事務機制和鎖機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5a547c8c402142cca7ed81d05fe0e3e3><p class=pgc-img-caption></p></div><p><strong>4.3 檢測死鎖</strong></p><p>死鎖檢測算法。</p><p>算法一：</p><p>算法使用的數據結構是如下這些：</p><p>佔有矩陣A：n*m階，其中n表示併發進程的個數，m表示系統的各類資源的個數，這個矩陣記錄了每一個進程當前佔有各個資源類中資源的個數。</p><p>申請矩陣R：n*m階，其中n表示併發進程的個數，m表示系統的各類資源的個數，這個矩陣記錄了每一個進程當前要完成工作需要申請的各個資源類中資源的個數。</p><p>空閒向量T：記錄當前m個資源類中空閒資源的個數。</p><p>完成向量F：布爾型向量值為真（true）或假（false），記錄當前n個併發進程能否進行完。為真即能進行完，為假則不能進行完。</p><p>臨時向量W：開始時W：=T。</p><p>算法步驟：</p><p>（1）W：=T，</p><p>對於所有的i=1，2，…，n，</p><p>如果A[i]=0，則F[i]：=true；否則，F[i]：=false</p><p>（2）找滿足下面條件的下標i：</p><p>F[i]：=false並且R[i]〈=W</p><p>如果不存在滿足上面的條件i，則轉到步驟（4）。</p><p>（3）W：=W+A[i]</p><p>F[i]：=true</p><p>轉到步驟（2）</p><p>（4）如果存在i，F[i]：=false，則系統處於死鎖狀態，且Pi進程參與了死鎖。什麼時候進行死鎖的檢測取決於死鎖發生的頻率。如果死鎖發生的頻率高，那麼死鎖檢測的頻率也要相應提高，這樣一方面可以提高系統資源的利用率，一方面可以避免更多的進程捲入死鎖。如果進程申請資源不能滿足就立刻進行檢測，那麼每當死鎖形成時即能被發現，這和死鎖避免的算法相近，只是系統的開銷較大。為了減小死鎖檢測帶來的系統開銷，一般採取每隔一段時間進行一次死鎖檢測，或者在CPU的利用率降低到某一數值時，進行死鎖的檢測。</p><p>那麼當檢測出死鎖時，這些線程該做些什麼呢？</p><p>1）一個可行的做法是釋放所有鎖，回退，並且等待一段隨機的時間後重試。這個和簡單的加鎖超時類似，不一樣的是隻有死鎖已經發生了才回退，而不會是因為加鎖的請求超時了。雖然有回退和等待，但是如果有大量的線程競爭同一批鎖，它們還是會重複地死鎖（<em>編者注：原因同超時類似，不能從根本上減輕競爭</em>）。</p><p>2）一個更好的方案是給這些線程設置優先級，讓一個（或幾個）線程回退，剩下的線程就像沒發生死鎖一樣繼續保持著它們需要的鎖。如果賦予這些線程的優先級是固定不變的，同一批線程總是會擁有更高的優先級。為避免這個問題，可以在死鎖發生的時候設置隨機的優先級。</p><p>算法二：</p><p>死鎖檢測與解除 ----- 在檢測到運行系統進入死鎖，進行恢復。 允許系統進入到死鎖狀態 死鎖檢測下圖截自《操作系統--精髓與設計原理》</p><div class=pgc-img><img alt=事務機制和鎖機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/07e44c757381405086b273d226196c12><p class=pgc-img-caption></p></div><p>4.4 死鎖的解除</p><p>如果利用死鎖檢測算法檢測出系統已經出現了死鎖 ，那麼，此時就需要對系統採取相應的措施。</p><p>常用的解除死鎖的方法：</p><p>1、搶佔資源：從一個或多個進程中搶佔足夠數量的資源分配給死鎖進程，以解除死鎖狀態。但應防止被掛起的進程長時間得不到資源，而處於資源匱乏的狀態。</p><p>2、終止（或撤銷）進程：終止或撤銷系統中的一個或多個死鎖進程，直至打破死鎖狀態。撤銷的原則可以按進程優先級和撤銷進程代價的高低進行。</p><p>a、終止所有的死鎖進程。這種方式簡單粗暴，但是代價很大，很有可能會導致一些已經運行了很久的進程前功盡棄。</p><p>b、逐個終止進程，直至死鎖狀態解除。該方法的代價也很大，因為每終止一個進程就需要使用死鎖檢測來檢測系統當前是否處於死鎖狀態。要求系統保持進程的歷史信息，設置還原點。另外，每次終止進程的時候終止那個進程呢？每次都應該採用最優策略來選擇一個“代價最小”的進程來解除死鎖狀態。</p><p>一般根據如下幾個方面來決定終止哪個進程： 1】進程的優先級</p><p>2】進程已運行時間以及運行完成還需要的時間</p><p>3】進程已佔用系統資源</p><p>4】進程運行完成還需要的資源終止進程數目</p><p>5】進程是交互還是批處理</p><p>十一、MySQL支持的事務隔離級別</p><p>4種：</p><p>read uncommited –> 讀”髒”數據現象，“髒讀"</p><p>read commited –> 不可重複讀現象，</p><p>repeatable read（MySQL默認）–>幻讀現象</p><p>serializable->可串行化，</p><p>©著作權歸作者所有：來自51CTO博客作者淺嫣的原創作品，如需轉載，請註明出處，否則將追究法律責任</p><p>轉載地址：https://blog.51cto.com/14150615/2351911</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>事務機</a></li><li><a>制和鎖</a></li><li><a>機制</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html alt=連mysql鎖的機制都不瞭解，怎麼做架構師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html title=連mysql鎖的機制都不瞭解，怎麼做架構師>連mysql鎖的機制都不瞭解，怎麼做架構師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html alt=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html title=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位>天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html alt=市稅務局創新制度機制爭創“模範機關” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d879650a7d06416c90fb7286175f1f59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html title=市稅務局創新制度機制爭創“模範機關”>市稅務局創新制度機制爭創“模範機關”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html alt="機制砂 | 大家知多少？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54b1eea319b842bcb8483f4056798bec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html title="機制砂 | 大家知多少？">機制砂 | 大家知多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html alt=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2b6d9a5dccf246aeaba80b2a1ecb9f0a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html title=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？>機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html alt=幾種基於可靠性指標的容量支持機制分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZYfwddDNSSyQW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html title=幾種基於可靠性指標的容量支持機制分析>幾種基於可靠性指標的容量支持機制分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html alt=java反射機制的講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad2c92f100a4d2e8213dcf70d4781c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html title=java反射機制的講解>java反射機制的講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/496f3f6a.html alt=劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7737ac36f58f40a98a798a5cbf5d5295 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/496f3f6a.html title=劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要>劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ff1f42a9.html alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f31195000b32401b8a5173b87a78fb6f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ff1f42a9.html title=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用>多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cc850e6c.html alt="乾貨 | 一文讀懂關於機制砂的25個問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ddbce23af5e3487f8e5d2fd05226eedf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cc850e6c.html title="乾貨 | 一文讀懂關於機制砂的25個問題">乾貨 | 一文讀懂關於機制砂的25個問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c82056cd.html alt=搞管樁不懂機制砂？你想要的都在這裡（機制砂100問）！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c82056cd.html title=搞管樁不懂機制砂？你想要的都在這裡（機制砂100問）！>搞管樁不懂機制砂？你想要的都在這裡（機制砂100問）！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fc6b5c1.html alt=機制砂專業知識30問，你想知道的這裡都有... class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4af0386fad84627a5c0f88367623c5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fc6b5c1.html title=機制砂專業知識30問，你想知道的這裡都有...>機制砂專業知識30問，你想知道的這裡都有...</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>