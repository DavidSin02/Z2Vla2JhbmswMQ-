<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>隨遇而安的適配器模式 | Spring 中的適配器 | 极客快訊</title><meta property="og:title" content="隨遇而安的適配器模式 | Spring 中的適配器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d853820995924ce0999a1591563a5636"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/60385d3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/60385d3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/60385d3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/60385d3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/60385d3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/60385d3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/60385d3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/60385d3.html><meta property="article:published_time" content="2020-10-29T20:53:45+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:45+08:00"><meta name=Keywords content><meta name=description content="隨遇而安的適配器模式 | Spring 中的適配器"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/60385d3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>隨遇而安的適配器模式 | Spring 中的適配器</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br>歡迎關注公號“JavaKeeper ”，一起成長，做牛逼閃閃的技術人</p><div class=pgc-img><img alt="隨遇而安的適配器模式 | Spring 中的適配器" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d853820995924ce0999a1591563a5636><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>問題</h1><p>假設我們在做一套股票看盤系統，數據提供方給我們提供 XML 格式數據，我們獲取數據用來顯示，隨著系統的迭代，我們要整合一些第三方系統的對外數據，但是他們只提供獲取 JSON 格式的數據接口。在不想改變原有代碼邏輯的情況下，如何解決呢？這時候我們就可以創建一個「適配器」。這是一個特殊的對象， 能夠轉換對象接口， 使其能與其他對象進行交互。適配器模式通過封裝對象將複雜的轉換過程隱藏於幕後。 被封裝的對象甚至察覺不到適配器的存在。</p><div class=pgc-img><img alt="隨遇而安的適配器模式 | Spring 中的適配器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b116559b8e3041b695f9e3b74449012d><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>真實世界類比</h1><p>適配器是什麼，不難理解，生活中也隨處可見。比如，筆記本電腦的電源適配器、萬能充（曾經的它真有一個這麼牛逼的名字）、一拖十數據線等等。</p><div class=pgc-img><img alt="隨遇而安的適配器模式 | Spring 中的適配器" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3b3fdae6e0b04fad89b795c33bd23d7b><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>基本介紹</h1><ul><li>適配器模式將一個類的接口，轉換成客戶期望的另外一個接口。適配器讓原本接口不兼容的類可以合作無間。也可以叫包裝器（Wrapper）。</li><li><strong>適配器模式</strong>是一種結構型設計模式， 它能使接口不兼容的對象能夠相互合作。</li><li>主要分為兩類：類適配器模式、對象適配器模式</li></ul><h1 class=pgc-h-arrow-right>工作原理</h1><ul><li>適配器模式：將一個類的接口轉換成另一種接口.讓原本接口不兼容的類可以兼容</li><li>從用戶的角度看不到被適配者，是解耦的</li><li>用戶調用適配器轉化出來的目標接口方法，適配器再調用被適配者的相關接口方法</li><li>用戶收到反饋結果，感覺只是和目標接口交互</li></ul><h1 class=pgc-h-arrow-right>適配器模式結構</h1><h1 class=pgc-h-arrow-right>對象適配器</h1><p>實現時使用了構成原則： 適配器實現了其中一個對象的接口， 並對另一個對象進行封裝。 所有流行的編程語言都可以實現適配器。</p><div class=pgc-img><img alt="隨遇而安的適配器模式 | Spring 中的適配器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b0d2c221cb6464d804e476a6c2cbfb8><p class=pgc-img-caption></p></div><p>適配器設計模式的結構（對象適配器）</p><ol start=1><li><strong>客戶端</strong> （Client） 是包含當前程序業務邏輯的類。</li><li><strong>客戶端接口</strong> （Target） 描述了其他類與客戶端代碼合作時必須遵循的協議。</li><li><strong>服務</strong> （Service） 中有一些功能類 （通常來自第三方或遺留系統）。 客戶端與其接口不兼容， 因此無法直接調用其功能，也可以叫適配者類（Adaptee）。</li><li><strong>適配器</strong> （Adapter） 是一個可以同時與客戶端和服務交互的類： 它在實現客戶端接口的同時封裝了服務對象。 適配器接受客戶端通過適配器接口發起的調用， 並將其轉換為適用於被封裝服務對象的調用。</li><li><strong>客戶端代碼只需通過接口與適配器交互即可， 無需與具體的適配器類耦合</strong>。 因此， 你可以向程序中添加新類型的適配器而無需修改已有代碼。 這在服務類的接口被更改或替換時很有用： 你無需修改客戶端代碼就可以創建新的適配器類。</li></ol><h1 class=pgc-h-arrow-right>Coding.</h1><ol start=1><li>定義客戶端使用的接口，與業務相關</li></ol><pre><code>public interface Target {    /*     * 客戶端請求處理的方法     */    void request();}</code></pre><ol start=2><li>已經存在的接口，這個接口需要配置</li></ol><pre><code>public class Adaptee {    /*     * 原本存在的方法     */    public void specificRequest(){    //業務代碼    }}</code></pre><ol start=3><li>適配器類</li></ol><pre><code>public class Adapter implements Target {    /*     * 持有需要被適配的接口對象     */    private Adaptee adaptee;    /*     * 構造方法，傳入需要被適配的對象     * @param adaptee 需要被適配的對象     */    public Adapter(Adaptee adaptee) {        this.adaptee = adaptee;    }    @Override    public void request() {        // TODO Auto-generated method stub        adaptee.specificRequest();    }}</code></pre><ol start=4><li>使用適配器的客戶端</li></ol><pre><code>public class Client {    public static void main(String[] args) {        //創建需要被適配的對象        Adaptee adaptee = new Adaptee();        //創建客戶端需要調用的接口對象        Target target = new Adapter(adaptee);        //請求處理        target.request();    }}</code></pre><h1 class=pgc-h-arrow-right>類適配器</h1><p>這一實現使用了繼承機制： 適配器同時繼承兩個對象的接口。 請注意， 這種方式僅能在支持多重繼承的編程語言中實現，例如 C++， Java 不支持多重繼承，也就沒有這種適配器了。</p><div class=pgc-img><img alt="隨遇而安的適配器模式 | Spring 中的適配器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5cbc192322c54e7bbbe5babe481af9cb><p class=pgc-img-caption></p></div><p>適配器設計模式（類適配器）<strong>類適配器</strong>不需要封裝任何對象， 因為它同時繼承了客戶端和服務的行為。 適配功能在重寫的方法中完成。 最後生成的適配器可替代已有的客戶端類進行使用。</p><h1 class=pgc-h-arrow-right>Coding</h1><p>Java 雖然不能實現標準的類適配器，但是有一種變通的方式，也能夠使用繼承來實現接口的適配，那就是讓適配器去實現 Target 的接口，然後繼承 Adaptee 的實現，雖然不是十分標準，但意思差不多。</p><ol start=1><li>首先有一個已存在的將被適配的類</li></ol><pre><code>public class Adaptee {    public void adapteeRequest() {        System.out.println("被適配者的方法");    }}</code></pre><ol start=2><li>定義客戶端使用的接口，與業務相關</li></ol><pre><code>public interface Target {    void request();}</code></pre><ol start=3><li>怎麼才可以在目標接口中的 request() 調用 Adaptee 的 adapteeRequest() 方法呢？直接實現 Target 肯定是不行的，所以我們通過一個適配器類，實現 Target 接口，同時繼承了 Adaptee 類，然後在實現的 request() 方法中調用父類的 adapteeRequest() 即可</li></ol><pre><code>public class Adapter extends Adaptee implements Target{    @Override    public void request() {        //...一些操作...        super.adapteeRequest();        //...一些操作...    }}</code></pre><ol start=4><li>使用適配器的客戶端</li></ol><pre><code>public class Client {    public static void main(String[] args) {        Target adapterTarget = new Adapter();        adapterTarget.request();    }}</code></pre><h1 class=pgc-h-arrow-right>適配器模式適合應用場景</h1><ul><li>當你希望使用某個類， 但是其接口與其他代碼不兼容時， 可以使用適配器類。</li><li>適配器模式允許你創建一箇中間層類， 其可作為代碼與遺留類、 第三方類或提供怪異接口的類之間的轉換器。</li><li>如果您需要複用這樣一些類， 他們處於同一個繼承體系， 並且他們又有了額外的一些共同的方法， 但是這些共同的方法不是所有在這一繼承體系中的子類所具有的共性。</li><li>你可以擴展每個子類， 將缺少的功能添加到新的子類中。 但是， 你必須在所有新子類中重複添加這些代碼， 這樣會使得代碼有壞味道。將缺失功能添加到一個適配器類中是一種優雅得多的解決方案。 然後你可以將缺少功能的對象封裝在適配器中， 從而動態地獲取所需功能。 如要這一點正常運作， 目標類必須要有通用接口， 適配器的成員變量應當遵循該通用接口。 這種方式同裝飾模式非常相似。</li></ul><h1 class=pgc-h-arrow-right>demo</h1><p>用一個生活中的充電器的例子來講解下適配器，我國民用電都是 220V，而我們的手機充電一般需要 5V。220V 的交流電相當於被適配者 Adaptee，我們的目標 Target 是 5V 直流電，充電器本身相當於一個 Adapter，將220V 的輸入電壓變換為 5V 輸出。</p><pre><code>首先是我們的名用電（我國是 220V，當然還可以有其他國家的其他準備，可隨時擴展）public class Volatage220V {    public final int output = 220;    public int output220v() {        System.out.println("輸出電壓 " + output);        return output;    }}適配接口public interface IVoltage5V {     int output5V();}我們的手機充電，只支持 5V 電壓public class Phone {    public void charging(IVoltage5V v) {        if (v.output5V() == 5) {            System.out.println("電壓 5V ，符合充電標準，開始充電");        } else {            System.out.println("電壓不符合標準，無法充電");        }    }}適配器public class VoltageAdapter implements IVoltage5V {    private Volatage220V volatage220V;  //聚合    public VoltageAdapter(Volatage220V v) {        this.volatage220V = v;    }    @Override    public int output5V() {        int dst = 0;        if (null != volatage220V) {            int src = volatage220V.output220v();            System.out.println("適配器工作~~~~~");            dst = src / 44;            System.out.println("適配器工作完成，輸出電壓" + dst);        }        return dst;    }}工作，如果去國外旅遊，有不同的電壓，只需要擴展適配器即可。public class Client {    public static void main(String[] args) {        Phone phone = new Phone();        phone.charging(new VoltageAdapter(new Volatage220V()));    }}</code></pre><h1 class=pgc-h-arrow-right>適配器模式優缺點</h1><ul><li>單一職責原則，你可以將接口或數據轉換代碼從程序主要業務邏輯中分離。</li><li>開閉原則。 只要客戶端代碼通過客戶端接口與適配器進行交互， 你就能在不修改現有客戶端代碼的情況下在程序中添加新類型的適配器。</li><li>代碼整體複雜度增加， 因為你需要新增一系列接口和類。 有時直接更改服務類使其與其他代碼兼容會更簡單。</li></ul><h1 class=pgc-h-arrow-right>Spring 中的適配器</h1><p>Spring 源碼中搜關鍵字Adapter 會出現很多實現類，SpringMVC 中的 HandlerAdapter ，就是適配器的應用。我們先回顧下 SpringMVC 處理流程：</p><div class=pgc-img><img alt="隨遇而安的適配器模式 | Spring 中的適配器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a846ff272be748f69cb94516c86eb90e><p class=pgc-img-caption></p></div><p>qsli.github.ioSpring MVC中的適配器模式主要用於執行目標 Controller 中的請求處理方法。在Spring MVC中，DispatcherServlet 作為用戶，HandlerAdapter 作為期望接口，具體的適配器實現類用於對目標類進行適配，Controller 作為需要適配的類。為什麼要在 Spring MVC 中使用適配器模式？Spring MVC 中的 Controller 種類眾多，不同類型的 Controller 通過不同的方法來對請求進行處理。如果不利用適配器模式的話，DispatcherServlet 直接獲取對應類型的 Controller，需要的自行來判斷，像下面這段代碼一樣：</p><pre><code>if(mappedHandler.getHandler() instanceof MultiActionController){     ((MultiActionController)mappedHandler.getHandler()).xxx  }else if(mappedHandler.getHandler() instanceof XXX){      ...  }else if(...){     ...  }  </code></pre><p>這樣假設如果我們增加一個 Controller，就要在代碼中加入一行 if 語句，這種形式就使得程序難以維護，也違反了設計模式中的開閉原則 – 對擴展開放，對修改關閉。我們通過源碼看看 SpringMVC 是如何實現的，首先看下核心類 DispatcherServlet：</p><pre><code>public class DispatcherServlet extends FrameworkServlet {   //......  //維護所有HandlerAdapter類的集合    @Nullable    private List&lt;HandlerAdapter&gt; handlerAdapters;    //初始化handlerAdapters    private void initHandlerAdapters(ApplicationContext context) {        this.handlerAdapters = null;        if (this.detectAllHandlerAdapters) {            Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);            if (!matchingBeans.isEmpty()) {                this.handlerAdapters = new ArrayList(matchingBeans.values());                AnnotationAwareOrderComparator.sort(this.handlerAdapters);            }        } else {            try {                HandlerAdapter ha = (HandlerAdapter)context.getBean("handlerAdapter", HandlerAdapter.class);                this.handlerAdapters = Collections.singletonList(ha);            } catch (NoSuchBeanDefinitionException var3) {            }        }        if (this.handlerAdapters == null) {            this.handlerAdapters = this.getDefaultStrategies(context, HandlerAdapter.class);            if (this.logger.isTraceEnabled()) {                this.logger.trace("No HandlerAdapters declared for servlet '" + this.getServletName() + "': using default strategies from DispatcherServlet.properties");            }        }    }    //dispatch 方法中會獲取 HandlerAdapter  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        //...        //獲得controller對應的適配器        HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());                  //調用適配器的handler方法處理請求，並返回ModelAndView        mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                    //...    }     //返回對應的controller的處理器      protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {        if (this.handlerAdapters != null) {            Iterator var2 = this.handlerAdapters.iterator();            while(var2.hasNext()) {                HandlerAdapter adapter = (HandlerAdapter)var2.next();                if (adapter.supports(handler)) {                    return adapter;                }            }        }    }</code></pre><p>接著看下 HandlerAdapter 的源碼，也就是適配器接口:</p><pre><code>public interface HandlerAdapter {    boolean supports(Object var1);    @Nullable    ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;    long getLastModified(HttpServletRequest var1, Object var2);}</code></pre><p>再來屢一下這個流程：</p><ol start=1><li>首先是適配器接口 DispatchServlet 中有一個集合維護所有的 HandlerAdapter，如果配置文件中沒有對適配器進行配置，那麼 DispatchServlet 會在創建時對該變量進行初始化，註冊所有默認的 HandlerAdapter。</li><li>當一個請求過來時，DispatchServlet 會根據傳過來的 handler 類型從該集合中尋找對應的 HandlerAdapter子類進行處理，並且調用它的 handler() 方法</li><li>對應的 HandlerAdapter 中的 handler() 方法又會執行對應 Controller 的 handleRequest() 方法</li></ol><p>適配器與 handler 有對應關係，而各個適配器又都是適配器接口的實現類，因此，它們都遵循相同的適配器標準，所以用戶可以按照相同的方式，通過不同的 handler 去處理請求。 當然了，Spring 框架中也為我們定義了一些默認的 Handler 對應的適配器。</p><div class=pgc-img><img alt="隨遇而安的適配器模式 | Spring 中的適配器" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f8e20ab5f6040eabc7c3a76a80f9231><p class=pgc-img-caption></p></div><p>通過適配器模式我們將所有的 controller 統一交給 HandlerAdapter 處理，免去了寫大量的 if-else 語句對 Controller 進行判斷，也更利於擴展新的 Controller 類型。</p><h1 class=pgc-h-arrow-right>參考與感謝</h1><ul><li>《圖解 Java 設計模式》</li><li>《Head First設計模式》</li><li>https://refactoringguru.cn/design-patterns/</li><li>https://blog.csdn.net/lu__peng/article/details/79117894</li><li>https://juejin.im/post/5ba28986f265da0abc2b6084#heading-12</li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>配器</a></li><li><a>隨遇</a></li><li><a>而安</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/c4d1f32a.html alt=深圳電源開關適配器生產批發廠家介紹幾種電源適配器基本拓撲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ce73399baff941788a62fb73a1064eeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/c4d1f32a.html title=深圳電源開關適配器生產批發廠家介紹幾種電源適配器基本拓撲>深圳電源開關適配器生產批發廠家介紹幾種電源適配器基本拓撲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22c3383.html alt=什麼是適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/a104570b-d125-40ab-86ee-09600a71b5e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22c3383.html title=什麼是適配器模式>什麼是適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b107d89.html alt=結合案例深入解析適配器模式（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bd456204219a48e9937689a686b2f5d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b107d89.html title=結合案例深入解析適配器模式（一）>結合案例深入解析適配器模式（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9e79757.html alt=結構型模式：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/30110d0d4c774c4cb5a554250bfca1b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9e79757.html title=結構型模式：適配器模式>結構型模式：適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4a07ffc.html alt=設計模式-適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/384a009efd5c451396583ca4b3567129 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4a07ffc.html title=設計模式-適配器模式>設計模式-適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6407054.html alt=設計模式之-適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5771206505ac4d0c8341436d3c0b7b9b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6407054.html title=設計模式之-適配器模式>設計模式之-適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63e29ca.html alt=設計模式之——適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/509a0001916fee81cd67 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63e29ca.html title=設計模式之——適配器模式>設計模式之——適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/741efdd.html alt=設計模式之適配器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4567f41288284f008f1606af24e0f309 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/741efdd.html title=設計模式之適配器>設計模式之適配器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677197d.html alt=通俗易懂設計模式解析——適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677197d.html title=通俗易懂設計模式解析——適配器模式>通俗易懂設計模式解析——適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b80f992.html alt=適配器模式實例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b80f992.html title=適配器模式實例>適配器模式實例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/707bb2b.html alt=面試題：說說你理解的適配器模式？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e7f03097-2a01-41c0-b5fb-a009254307a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/707bb2b.html title=面試題：說說你理解的適配器模式？>面試題：說說你理解的適配器模式？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5398d2a.html alt=光纖適配器的接口和結構有哪些？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17fd80ab6630424599f0a5526e57f557 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5398d2a.html title=光纖適配器的接口和結構有哪些？>光纖適配器的接口和結構有哪些？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd32f3f.html alt=網絡適配器怎麼修復 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f301c76a9d3844c7a857fe78a806228f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd32f3f.html title=網絡適配器怎麼修復>網絡適配器怎麼修復</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>