<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何增強Linux內核中的訪問控制安全 | 极客快訊</title><meta property="og:title" content="如何增強Linux內核中的訪問控制安全 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/4803f61d402c4c5eb125f3c52460a705"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><meta property="article:published_time" content="2020-10-29T21:05:53+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:53+08:00"><meta name=Keywords content><meta name=description content="如何增強Linux內核中的訪問控制安全"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6130ea0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何增強Linux內核中的訪問控制安全</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>背景</strong></h1><p>前段時間，我們的項目組在幫客戶解決一些操作系統安全領域的問題，涉及到windows，Linux，macOS三大操作系統平臺。無論什麼操作系統，本質上都是一個軟件，任何軟件在一開始設計的時候，都不能百分之百的滿足人們的需求，所以操作系統也是一樣，為了儘可能的滿足人們需求，不得不提供一些供人們定製操作系統的機制。當然除了官方提供的一些機制，也有一些黑魔法，這些黑魔法不被推薦使用，但是有時候面對具體的業務場景，可以作為一個參考的思路。</p><h1><strong>Linux中常見的攔截過濾</strong></h1><p>本文著重介紹Linux平臺上常見的攔截：</p><ol><li>用戶態動態庫攔截。</li><li>內核態系統調用攔截。</li><li>堆棧式文件系統攔截。</li><li>inline hook攔截。</li><li>LSM(Linux Security Modules)</li></ol><h1><strong>動態庫劫持</strong></h1><p>Linux上的動態庫劫持主要是基於LD_ PRELOAD環境變量，這個環境變量的主要作用是改變動態庫的加載順序，讓用戶有選擇的載入不同動態庫中的相同函數。但是使用不當就會引起嚴重的安全問題，我們可以通過它在主程序和動態連接庫中加載別的動態函數，這就給我們提供了一個機會，向別人的程序注入惡意的代碼。</p><p>假設有以下用戶名密碼驗證的函數：</p><pre>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv){char passwd[] = "password";if (argc &lt; 2) {printf("Invalid argc!\n");return;}if (!strcmp(passwd, argv[1])) {printf("Correct Password!\n");return;}printf("Invalid Password!\n");}</pre><p>我們再寫一段hookStrcmp的程序，讓這個比較永遠正確。</p><pre>#include &lt;stdio.h&gt;int strcmp(const char *s1, const char *s2){/* 永遠返回0，表示兩個字符串相等 */return 0;}</pre><p>依次執行以下命令，就會使我們的hook程序先執行。</p><pre>gcc -Wall -fPIC -shared -o hookStrcmp.so hookStrcmp.cexport LD_PRELOAD=”./hookStrcmp.so”</pre><p>結果會發現，我們自己寫的strcmp函數優先被調用了。這是一個最簡單的劫持 ，但是如果劫持了類似於geteuid/getuid/getgid，讓其返回0，就相當於暴露了root權限。所以為了安全起見，一般將LD_ PRELOAD環境變量禁用掉。</p><h1><strong>Linux系統調用劫持</strong></h1><p>最近發現在4.4.0的內核中有513多個系統調用(很多都沒用過)，系統調用劫持的目的是改變系統中原有的系統調用，用我們自己的程序替換原有的系統調用。Linux內核中所有的系統調用都是放在一個叫做sys_ call _table的內核數組中，數組的值就表示這個系統調用服務程序的入口地址。整個系統調用的流程如下：</p><div class=pgc-img><img alt=如何增強Linux內核中的訪問控制安全 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4803f61d402c4c5eb125f3c52460a705><p class=pgc-img-caption></p></div><p>當用戶態發起一個系統調用時，會通過80軟中斷進入到syscall hander，進而進入全局的系統調用表sys_ call _table去查找具體的系統調用，那麼如果我們將這個數組中的地址改成我們自己的程序地址，就可以實現系統調用劫持。但是內核為了安全，對這種操作做了一些限制：</p><ol><li>sys_ call _table的符號沒有導出，不能直接獲取。</li><li>sys_ call _table所在的內存頁是隻讀屬性的，無法直接進行修改。</li></ol><p>對於以上兩個問題，解決方案如下（方法不止一種）：</p><ol><li>獲取sys<em> call </em>table的地址 ：grep sys _ call _table /boot/System.map-uname -r</li><li>控制頁表只讀屬性是由CR0寄存器的WP位控制的，只要將這個位清零就可以對只讀頁表進行修改。</li></ol><pre>/* make the page writable */int make_rw(unsigned long address){unsigned int level;pte_t *pte = lookup_address(address, &amp;level);//查找虛擬地址所在的頁表地址pte-&gt;pte |= _PAGE_RW;//設置頁表讀寫屬性return 0;}/* make the page write protected */int make_ro(unsigned long address){unsigned int level;pte_t *pte = lookup_address(address, &amp;level);pte-&gt;pte &amp;= ~_PAGE_RW;//設置只讀屬性return 0;}</pre><p><strong>開始替換系統調用</strong></p><p>本文實現的是對 ls這個命令對應的系統調用，系統調用號是 _ NR _getdents。</p><pre>static int syscall_init_module(void){orig_getdents = sys_call_table[__NR_getdents];make_rw((unsigned long)sys_call_table); //修改頁屬性sys_call_table[__NR_getdents] = (unsigned long *)hacked_getdents; //設置新的系統調用地址make_ro((unsigned long)sys_call_table);return 0;}</pre><p><strong>恢復原狀</strong></p><pre>static void syscall_cleanup_module(void){printk(KERN_ALERT "Module syscall unloaded.\n");make_rw((unsigned long)sys_call_table);sys_call_table[__NR_getdents] = (unsigned long *)orig_getdents;make_ro((unsigned long)sys_call_table);}</pre><p>使用Makefile編譯，insmod插入內核模塊後，再執行ls時，就會進入到我們的系統調用，我們可以在hook代碼中刪掉某些文件，ls就不會顯示這些文件，但是這些文件還是存在的。</p><h1><strong>堆棧式文件系統</strong></h1><p>Linux通過vfs虛擬文件系統來統一抽象具體的磁盤文件系統，從上到下的IO棧形成了一個堆棧式。通過對內核源碼的分析，以一次讀操作為例，從上到下所執行的流程如下：</p><div class=pgc-img><img alt=如何增強Linux內核中的訪問控制安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0009b55506774c3889852a0b9941be96><p class=pgc-img-caption></p></div><p>內核中採用了很多c語言形式的面向對象，也就是函數指針的形式，例如read是vfs提供用戶的接口，具體底下調用的是ext2的read操作。我們只要實現VFS提供的各種接口，就可以實現一個堆棧式文件系統。Linux內核中已經集成了一些堆棧式文件系統，例如Ubuntu在安裝時會提醒你是否需要加密home目錄，其實就是一個堆棧式的加密文件系統（eCryptfs），原理如下：</p><div class=pgc-img><img alt=如何增強Linux內核中的訪問控制安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0acc8b09d5b3414d84195f9c461f5b2f><p class=pgc-img-caption></p></div><p>實現了一個堆棧式文件系統，相當於所有的讀寫操作都會進入到我們的文件系統，可以拿到所有的數據，就可以進行做一些攔截過濾。</p><p>以下是我實現的一個最簡單的堆棧式文件系統，實現了最簡單的打開、讀寫文件，麻雀雖小但五臟俱全。</p><p>https://github.com/wangzhangjun/wzjfs</p><p><strong>inline hook</strong></p><p>我們知道內核中的函數不可能把所有功能都在這個函數中全部實現，它必定要調用它的下層函數。如果這個下層函數可以得到我們想要的過濾信息內容，就可以把下層函數在上層函數中的offset替換成新的函數的offset，這樣上層函數調用下層函數時，就會跳到新的函數中，在新的函數中做過濾和劫持內容的工作。所以從原理上來說，inline hook可以想hook哪裡就hook哪裡。</p><div class=pgc-img><img alt=如何增強Linux內核中的訪問控制安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bb86371eb13a41c9abdf07a63af7bf2b><p class=pgc-img-caption></p></div><p><strong>inline hook 有兩個重要的問題：</strong></p><ol><li>如何定位hook點。</li><li>如何注入hook函數入口。</li></ol><p><strong>對於第一個問題:</strong></p><p>需要有一點的內核源碼經驗，比如說對於read操作，源碼如下：</p><div class=pgc-img><img alt=如何增強Linux內核中的訪問控制安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fad0ebc8dddb4329883cd5cfd660ca7b><p class=pgc-img-caption></p></div><p>在這裡當發起read系統調用後，就會進入到sys<em> read,在sys</em> read中會調用vfs<em> read函數，在vfs</em> read的參數中正好有我們需要過濾的信息，那麼就可以把vfs_ read當做一個hook點。</p><p><strong>對於第二個問題:</strong></p><p>如何Hook？這裡介紹兩種方式：</p><p><strong>第一種方式：</strong>直接進行二進制替換，將call指令的操作數替換為hook函數的地址。</p><div class=pgc-img><img alt=如何增強Linux內核中的訪問控制安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7c44ee124cd847ac9fe63f3f2d10e02f><p class=pgc-img-caption></p></div><p><strong>第二種方式：</strong>Linux內核提供的kprobes機制。</p><p>其原理是在hook點注入int 3(x86)的機器碼，讓cpu運行到這裡的時候會觸發sig<em> trap信號，然後將用戶自定義的hook函數注入到sig</em> trap的回調函數中，達到觸發hook函數的目的。這個其實也是調試器的原理。</p><h1><strong>LSM</strong></h1><p>LSM是Linux Secrity Module的簡稱，即linux安全模塊。是一種通用的Linux安全框架，具有效率高，簡單易用等特點。原理如下：</p><div class=pgc-img><img alt=如何增強Linux內核中的訪問控制安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/598c84cbbfc34b5c926dd083fe986d4a><p class=pgc-img-caption></p></div><p>LSM在內核中做了以下工作：</p><ol><li>在特定的內核數據結構中加入安全域。</li><li>在內核源代碼中不同的關鍵點插入對安全鉤子函數的調用。</li><li>加入一個通用的安全系統調用。</li><li>提供了函數允許內核模塊註冊為安全模塊或者註銷。</li><li>將capabilities邏輯的大部分移植為一個可選的安全模塊,具有可擴展性。</li></ol><h1><strong>適用場景</strong></h1><p>對於以上幾種Hook方式，有其不同的應用場景。</p><ol><li>動態庫劫持不太完全，劫持的信息有可能滿足不了我們的需求，還有可能別人在你之前劫持了，一旦禁用LD_ PRELOAD就失效了。</li><li>系統調用劫持，劫持的信息有可能滿足不了我們的需求，例如不能獲取struct file結構體，不能獲取文件的絕對路徑等。</li><li>堆棧式文件系統，依賴於Mount,可能需要重啟系統。</li><li>inline hook，靈活性高，隨意Hook，即時生效無需重啟，但是在不同內核版本之間通用性差，一旦某些函數發生了變化，Hook失效。</li><li>LSM，在早期的內核中，只能允許一個LSM內核模塊加載，例如加載了SELinux，就不能加載其他的LSM模塊，在最新的內核版本中不存在這個問題。</li></ol><h1><strong>總結</strong></h1><p>篇幅有限，本文只是介紹了Linux上的攔截技術，後續有機會可以一起探討windows和macOS上的攔截技術。事實上類似的審計HOOK放到任何一個系統中都是剛需，不只是kernel，我們可以看到越來越多的vm和runtime甚至包括很多web組件、前端應用都提供了更靈活的hook方式，這是透明化和實時性兩個安全大趨勢下最常見的解決方案。</p><hr><p>文/ThoughtWorks 王張軍</p><p>原文：https://insights.thoughtworks.cn/access-control-security-of-linux/</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>增強</a></li><li><a>Linux</a></li><li><a>內核</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f65dd506.html alt=Linux內核簡介，你能看懂麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/01f248e03b78487093db92f7873aacb8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f65dd506.html title=Linux內核簡介，你能看懂麼>Linux內核簡介，你能看懂麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6395d518.html alt=Linux內核網絡設備驅動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a142a9a74ca54da4851cedb3505e52ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6395d518.html title=Linux內核網絡設備驅動>Linux內核網絡設備驅動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfddf98c.html alt=Linux內核中的hash與bucket簡單介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153113365765421287673dd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfddf98c.html title=Linux內核中的hash與bucket簡單介紹>Linux內核中的hash與bucket簡單介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cadc1ac.html alt="Linux 內核深度剖析與實踐" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c8bc4b450aff4e848c73de7bade9c264 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cadc1ac.html title="Linux 內核深度剖析與實踐">Linux 內核深度剖析與實踐</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/496b42e7.html alt=增強迴路：讓自己變得越來越好，你需要設置一個自動增長模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/474a051eb0254f308197d5a87c9e3ce8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/496b42e7.html title=增強迴路：讓自己變得越來越好，你需要設置一個自動增長模式>增強迴路：讓自己變得越來越好，你需要設置一個自動增長模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/73601be3.html alt="《纖維增強板材 高應變速率拉伸試驗——液壓伺服控制系統》通知" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/73601be3.html title="《纖維增強板材 高應變速率拉伸試驗——液壓伺服控制系統》通知">《纖維增強板材 高應變速率拉伸試驗——液壓伺服控制系統》通知</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/396da680.html alt=增強背部厚實度！5個背肌劃式垂直動作推薦，增強你的強壯標識度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11c0417f09d40fe9fcd305bb95307d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/396da680.html title=增強背部厚實度！5個背肌劃式垂直動作推薦，增強你的強壯標識度>增強背部厚實度！5個背肌劃式垂直動作推薦，增強你的強壯標識度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>