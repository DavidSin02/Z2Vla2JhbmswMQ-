<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高級程序員之海量數據處理 | 极客快訊</title><meta property="og:title" content="高級程序員之海量數據處理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/be4ce471fc54456c91d051709a4fb30d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62495504.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62495504.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62495504.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62495504.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62495504.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62495504.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62495504.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62495504.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="高級程序員之海量數據處理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/62495504.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高級程序員之海量數據處理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>何謂海量數據處理？</p><p>所謂海量數據處理，無非就是基於海量數據上的存儲、處理、操作。何謂海量，就是數據量太大，所以導致要麼是無法在較短時間內迅速解決，要麼是數據太大，導致無法一次性裝入內存。</p><div class=pgc-img><img alt=高級程序員之海量數據處理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/be4ce471fc54456c91d051709a4fb30d><p class=pgc-img-caption></p></div><p>那解決辦法呢?針對時間，我們可以採用巧妙的算法搭配合適的數據結構，如Bloom filter/Hash/bit-map/堆/數據庫或倒排索引/trie樹，針對空間，無非就一個辦法：大而化小，分而治之（hash映射），你不是說規模太大嘛，那簡單啊，就把規模大化為規模小的，各個擊破不就完了嘛。</p><p>至於所謂的單機及集群問題，通俗點來講，單機就是處理裝載數據的機器有限(只要考慮cpu，內存，硬盤的數據交互)，而集群，機器有多輛，適合分佈式處理，並行計算(更多考慮節點和節點間的數據交互)。</p><p>再者，通過本blog內的有關海量數據處理的文章：Big Data Processing，我們已經大致知道，處理海量數據問題，無非就是：</p><p>分而治之/hash映射 + hash統計 + 堆/快速/歸併排序；</p><p>雙層桶劃分</p><p>Bloom filter/Bitmap；</p><p>Trie樹/數據庫/倒排索引；</p><p>外排序；</p><p>分佈式處理之Hadoop/Mapreduce。</p><p>下面，本文第一部分、從set/map談到hashtable/hash_map/hash_set，簡要介紹下set/map/multiset/multimap，及hash_set/hash_map/hash_multiset/hash_multimap之區別(萬丈高樓平地起，基礎最重要)，而本文第二部分，則針對上述那6種方法模式結合對應的海量數據處理面試題分別具體闡述。</p><p>第一部分、從set/map談到hashtable/hash_map/hash_set</p><p>稍後本文第二部分中將多次提到hash_map/hash_set，下面稍稍介紹下這些容器，以作為基礎準備。一般來說，STL容器分兩種，</p><p>序列式容器(vector/list/deque/stack/queue/heap)，</p><p>關聯式容器。關聯式容器又分為set(集合)和map(映射表)兩大類，以及這兩大類的衍生體multiset(多鍵集合)和multimap(多鍵映射表)，這些容器均以RB-tree完成。此外，還有第3類關聯式容器，如hashtable(散列表)，以及以hashtable為底層機制完成的hash_set(散列集合)/hash_map(散列映射表)/hash_multiset(散列多鍵集合)/hash_multimap(散列多鍵映射表)。也就是說，set/map/multiset/multimap都內含一個RB-tree，而hash_set/hash_map/hash_multiset/hash_multimap都內含一個hashtable。</p><p>所謂關聯式容器，類似關聯式數據庫，每筆數據或每個元素都有一個鍵值(key)和一個實值(value)，即所謂的Key-Value(鍵-值對)。當元素被插入到關聯式容器中時，容器內部結構(RB-tree/hashtable)便依照其鍵值大小，以某種特定規則將這個元素放置於適當位置。</p><p>包括在非關聯式數據庫中，比如，在MongoDB內，文檔(document)是最基本的數據組織形式，每個文檔也是以Key-Value（鍵-值對）的方式組織起來。一個文檔可以有多個Key-Value組合，每個Value可以是不同的類型，比如String、Integer、List等等。</p><p>{ "name" : "July",</p><p>"sex" : "male",</p><p>"age" : 23 }</p><p>set/map/multiset/multimap</p><p>set，同map一樣，所有元素都會根據元素的鍵值自動被排序，因為set/map兩者的所有各種操作，都只是轉而調用RB-tree的操作行為，不過，值得注意的是，兩者都不允許兩個元素有相同的鍵值。</p><p>不同的是：set的元素不像map那樣可以同時擁有實值(value)和鍵值(key)，set元素的鍵值就是實值，實值就是鍵值，而map的所有元素都是pair，同時擁有實值(value)和鍵值(key)，pair的第一個元素被視為鍵值，第二個元素被視為實值。</p><p>至於multiset/multimap，他們的特性及用法和set/map完全相同，唯一的差別就在於它們允許鍵值重複，即所有的插入操作基於RB-tree的insert_equal()而非insert_unique()。</p><p>hash_set/hash_map/hash_multiset/hash_multimap</p><p>hash_set/hash_map，兩者的一切操作都是基於hashtable之上。不同的是，hash_set同set一樣，同時擁有實值和鍵值，且實質就是鍵值，鍵值就是實值，而hash_map同map一樣，每一個元素同時擁有一個實值(value)和一個鍵值(key)，所以其使用方式，和上面的map基本相同。但由於hash_set/hash_map都是基於hashtable之上，所以不具備自動排序功能。為什麼?因為hashtable沒有自動排序功能。</p><p>至於hash_multiset/hash_multimap的特性與上面的multiset/multimap完全相同，唯一的差別就是它們hash_multiset/hash_multimap的底層實現機制是hashtable（而multiset/multimap，上面說了，底層實現機制是RB-tree），所以它們的元素都不會被自動排序，不過也都允許鍵值重複。</p><p>所以，綜上，說白了，什麼樣的結構決定其什麼樣的性質，因為set/map/multiset/multimap都是基於RB-tree之上，所以有自動排序功能，而hash_set/hash_map/hash_multiset/hash_multimap都是基於hashtable之上，所以不含有自動排序功能，至於加個前綴multi_無非就是允許鍵值重複而已。如下圖所示：</p><div class=pgc-img><img alt=高級程序員之海量數據處理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4fc466a7b1e84b7b8001efce4e47470a><p class=pgc-img-caption></p></div><p>此外，</p><p>關於什麼hash，請看blog內此篇文章；</p><p>關於紅黑樹，請參看blog內系列文章，</p><p>關於hash_map的具體應用：請看這裡，關於hash_set：請看此文。</p><p>OK，接下來，請看本文第二部分、處理海量數據問題之六把密匙。</p><p>第二部分、處理海量數據問題之六把密匙</p><p>密匙一、分而治之/Hash映射 + Hash_map統計 + 堆/快速/歸併排序</p><p>1、海量日誌數據，提取出某日訪問百度次數最多的那個IP。</p><p>既然是海量數據處理，那麼可想而知，給我們的數據那就一定是海量的。針對這個數據的海量，我們如何著手呢?對的，無非就是分而治之/hash映射 + hash統計 + 堆/快速/歸併排序，說白了，就是先映射，而後統計，最後排序：</p><p>分而治之/hash映射：針對數據太大，內存受限，只能是：把大文件化成(取模映射)小文件，即16字方針：大而化小，各個擊破，縮小規模，逐個解決</p><p>hash_map統計：當大文件轉化了小文件，那麼我們便可以採用常規的hash_map(ip，value)來進行頻率統計。</p><p>堆/快速排序：統計完了之後，便進行排序(可採取堆排序)，得到次數最多的IP。</p><p>具體而論，則是： “首先是這一天，並且是訪問百度的日誌中的IP取出來，逐個寫入到一個大文件中。注意到IP是32位的，最多有個2^32個IP。同樣可以採用映射的方法，比如%1000，把整個大文件映射為1000個小文件，再找出每個小文中出現頻率最大的IP（可以採用hash_map對那1000個文件中的所有IP進行頻率統計，然後依次找出各個文件中頻率最大的那個IP）及相應的頻率。然後再在這1000個最大的IP中，找出那個頻率最大的IP，即為所求。”--十道海量數據處理面試題與十個方法大總結。</p><p>關於本題，還有幾個問題，如下：</p><p>1、Hash取模是一種等價映射，不會存在同一個元素分散到不同小文件中的情況，即這裡採用的是mod1000算法，那麼相同的IP在hash取模後，只可能落在同一個文件中，不可能被分散的。因為如果兩個IP相等，那麼經過Hash(IP)之後的哈希值是相同的，將此哈希值取模（如模1000），必定仍然相等。</p><p>2、那到底什麼是hash映射呢？簡單來說，就是為了便於計算機在有限的內存中處理big數據，從而通過一種映射散列的方式讓數據均勻分佈在對應的內存位置(如大數據通過取餘的方式映射成小樹存放在內存中，或大文件映射成多個小文件)，而這個映射散列方式便是我們通常所說的hash函數，設計的好的hash函數能讓數據均勻分佈而減少衝突。儘管數據映射到了另外一些不同的位置，但數據還是原來的數據，只是代替和表示這些原始數據的形式發生了變化而已。</p><p>OK，有興趣的，還可以再瞭解下一致性hash算法，見blog內此文第五部分：http://blog.csdn.net/v_july_v/article/details/6879101。</p><p>2、尋找熱門查詢，300萬個查詢字符串中統計最熱門的10個查詢</p><p>原題：搜索引擎會通過日誌文件把用戶每次檢索使用的所有檢索串都記錄下來，每個查詢串的長度為1-255字節。假設目前有一千萬個記錄（這些查詢串的重複度比較高，雖然總數是1千萬，但如果除去重複後，不超過3百萬個。一個查詢串的重複度越高，說明查詢它的用戶越多，也就是越熱門），請你統計最熱門的10個查詢串，要求使用的內存不能超過1G。</p><p>解答：由上面第1題，我們知道，數據大則劃為小的，如如一億個Ip求Top 10，可先%1000將ip分到1000個小文件中去，並保證一種ip只出現在一個文件中，再對每個小文件中的ip進行hashmap計數統計並按數量排序，最後歸併或者最小堆依次處理每個小文件的top10以得到最後的結。</p><p>但如果數據規模比較小，能一次性裝入內存呢?比如這第2題，雖然有一千萬個Query，但是由於重複度比較高，因此事實上只有300萬的Query，每個Query255Byte，因此我們可以考慮把他們都放進內存中去（300萬個字符串假設沒有重複，都是最大長度，那麼最多佔用內存3M*1K/4=0.75G。所以可以將所有字符串都存放在內存中進行處理），而現在只是需要一個合適的數據結構，在這裡，HashTable絕對是我們優先的選擇。</p><p>所以我們放棄分而治之/hash映射的步驟，直接上hash統計，然後排序。So，針對此類典型的TOP K問題，採取的對策往往是：hashmap + 堆。如下所示：</p><p>hash_map統計：先對這批海量數據預處理。具體方法是：維護一個Key為Query字串，Value為該Query出現次數的HashTable，即hash_map(Query，Value)，每次讀取一個Query，如果該字串不在Table中，那麼加入該字串，並且將Value值設為1；如果該字串在Table中，那麼將該字串的計數加一即可。最終我們在O(N)的時間複雜度內用Hash表完成了統計；</p><p>堆排序：第二步、藉助堆這個數據結構，找出Top K，時間複雜度為N‘logK。即藉助堆結構，我們可以在log量級的時間內查找和調整/移動。因此，維護一個K(該題目中是10)大小的小根堆，然後遍歷300萬的Query，分別和根元素進行對比。所以，我們最終的時間複雜度是：O（N） + N' * O（logK），（N為1000萬，N’為300萬）。</p><p>別忘了這篇文章中所述的堆排序思路：“維護k個元素的最小堆，即用容量為k的最小堆存儲最先遍歷到的k個數，並假設它們即是最大的k個數，建堆費時O（k），並調整堆(費時O（logk）)後，有k1>k2>...kmin（kmin設為小頂堆中最小元素）。繼續遍歷數列，每次遍歷一個元素x，與堆頂元素比較，若x>kmin，則更新堆（x入堆，用時logk），否則不更新堆。這樣下來，總費時O（k*logk+（n-k）*logk）=O（n*logk）。此方法得益於在堆中，查找等各項操作時間複雜度均為logk。”--第三章續、Top K算法問題的實現。</p><p>當然，你也可以採用trie樹，關鍵字域存該查詢串出現的次數，沒有出現為0。最後用10個元素的最小推來對出現頻率進行排序。</p><p>3、有一個1G大小的一個文件，裡面每一行是一個詞，詞的大小不超過16字節，內存限制大小是1M。返回頻數最高的100個詞。</p><p>由上面那兩個例題，分而治之 + hash統計 + 堆/快速排序這個套路，我們已經開始有了屢試不爽的感覺。下面，再拿幾道再多多驗證下。請看此第3題：又是文件很大，又是內存受限，咋辦?還能怎麼辦呢?無非還是：</p><p>分而治之/hash映射：順序讀文件中，對於每個詞x，取hash(x)%5000，然後按照該值存到5000個小文件（記為x0,x1,...x4999）中。這樣每個文件大概是200k左右。如果其中的有的文件超過了1M大小，還可以按照類似的方法繼續往下分，直到分解得到的小文件的大小都不超過1M。</p><p>hash_map統計：對每個小文件，採用trie樹/hash_map等統計每個文件中出現的詞以及相應的頻率。</p><p>堆/歸併排序：取出出現頻率最大的100個詞（可以用含100個結點的最小堆）後，再把100個詞及相應的頻率存入文件，這樣又得到了5000個文件。最後就是把這5000個文件進行歸併（類似於歸併排序）的過程了。</p><p>4、海量數據分佈在100臺電腦中，想個辦法高效統計出這批數據的TOP10。</p><p>如果每個數據元素只出現一次，而且只出現在某一臺機器中，那麼可以採取以下步驟統計出現次數TOP10的數據元素：</p><p>堆排序：在每臺電腦上求出TOP10，可以採用包含10個元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆，比如求TOP10大，我們首先取前10個元素調整成最小堆，如果發現，然後掃描後面的數據，並與堆頂元素比較，如果比堆頂元素大，那麼用該元素替換堆頂，然後再調整為最小堆。最後堆中的元素就是TOP10大）。</p><p>求出每臺電腦上的TOP10後，然後把這100臺電腦上的TOP10組合起來，共1000個數據，再利用上面類似的方法求出TOP10就可以了。</p><p>但如果同一個元素重複出現在不同的電腦中呢，如下例子所述：</p><div class=pgc-img><img alt=高級程序員之海量數據處理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ffe16dfe87c6476d9f0ae00a8d4ad738><p class=pgc-img-caption></p></div><p>這個時候，你可以有兩種方法：</p><p>遍歷一遍所有數據，重新hash取摸，如此使得同一個元素只出現在單獨的一臺電腦中，然後採用上面所說的方法，統計每臺電腦中各個元素的出現次數找出TOP10，繼而組合100臺電腦上的TOP10，找出最終的TOP10。</p><p>或者，暴力求解：直接統計統計每臺電腦中各個元素的出現次數，然後把同一個元素在不同機器中的出現次數相加，最終從所有數據中找出TOP10。</p><p>5、有10個文件，每個文件1G，每個文件的每一行存放的都是用戶的query，每個文件的query都可能重複。要求你按照query的頻度排序。</p><p>方案1：直接上：</p><p>hash映射：順序讀取10個文件，按照hash(query)%10的結果將query寫入到另外10個文件（記為a0,a1,..a9）中。這樣新生成的文件每個的大小大約也1G（假設hash函數是隨機的）。</p><p>hash_map統計：找一臺內存在2G左右的機器，依次對用hash_map(query, query_count)來統計每個query出現的次數。注：hash_map(query,query_count)是用來統計每個query的出現次數，不是存儲他們的值，出現一次，則count+1。</p><p>堆/快速/歸併排序：利用快速/堆/歸併排序按照出現次數進行排序，將排序好的query和對應的query_cout輸出到文件中，這樣得到了10個排好序的文件（記為）。最後，對這10個文件進行歸併排序（內排序與外排序相結合）。根據此方案1，這裡有一份實現：https://github.com/ooooola/sortquery/blob/master/querysort.py。</p><p>除此之外，此題還有以下兩個方法：</p><p>方案2：一般query的總量是有限的，只是重複的次數比較多而已，可能對於所有的query，一次性就可以加入到內存了。這樣，我們就可以採用trie樹/hash_map等直接來統計每個query出現的次數，然後按出現次數做快速/堆/歸併排序就可以了。</p><p>方案3：與方案1類似，但在做完hash，分成多個文件後，可以交給多個文件來處理，採用分佈式的架構來處理（比如MapReduce），最後再進行合併。</p><p>6、 給定a、b兩個文件，各存放50億個url，每個url各佔64字節，內存限制是4G，讓你找出a、b文件共同的url？</p><p>可以估計每個文件安的大小為5G×64=320G，遠遠大於內存限制的4G。所以不可能將其完全加載到內存中處理。考慮採取分而治之的方法。</p><p>分而治之/hash映射：遍歷文件a，對每個url求取，然後根據所取得的值將url分別存儲到1000個小文件（記為，這裡漏寫個了a1）中。這樣每個小文件的大約為300M。遍歷文件b，採取和a相同的方式將url分別存儲到1000小文件中（記為）。這樣處理後，所有可能相同的url都在對應的小文件（）中，不對應的小文件不可能有相同的url。然後我們只要求出1000對小文件中相同的url即可。</p><p>hash_set統計：求每對小文件中相同的url時，可以把其中一個小文件的url存儲到hash_set中。然後遍歷另一個小文件的每個url，看其是否在剛才構建的hash_set中，如果是，那麼就是共同的url，存到文件裡面就可以了。</p><p>OK，此第一種方法：分而治之/hash映射 + hash統計 + 堆/快速/歸併排序，再看最後4道題，如下：</p><p>7、怎麼在海量數據中找出重複次數最多的一個？</p><p>方案：先做hash，然後求模映射為小文件，求出每個小文件中重複次數最多的一個，並記錄重複次數。然後找出上一步求出的數據中重複次數最多的一個就是所求（具體參考前面的題）。</p><p>8、上千萬或上億數據（有重複），統計其中出現次數最多的前N個數據。</p><p>方案：上千萬或上億的數據，現在的機器的內存應該能存下。所以考慮採用hash_map/搜索二叉樹/紅黑樹等來進行統計次數。然後利用堆取出前N個出現次數最多的數據。</p><p>9、一個文本文件，大約有一萬行，每行一個詞，要求統計出其中最頻繁出現的前10個詞，請給出思想，給出時間複雜度分析。</p><p>方案1：如果文件比較大，無法一次性讀入內存，可以採用hash取模的方法，將大文件分解為多個小文件，對於單個小文件利用hash_map統計出每個小文件中10個最常出現的詞，然後再進行歸併處理，找出最終的10個最常出現的詞。</p><p>方案2：通過hash取模將大文件分解為多個小文件後，除了可以用hash_map統計出每個小文件中10個最常出現的詞，也可以用trie樹統計每個詞出現的次數，時間複雜度是O(n*le)（le表示單詞的平準長度），最終同樣找出出現最頻繁的前10個詞（可用堆來實現），時間複雜度是O(n*lg10)。</p><p>10. 1000萬字符串，其中有些是重複的，需要把重複的全部去掉，保留沒有重複的字符串。請怎麼設計和實現？</p><p>方案1：這題用trie樹比較合適，hash_map也行。</p><p>方案2：from xjbzju:，1000w的數據規模插入操作完全不現實，以前試過在stl下100w元素插入set中已經慢得不能忍受，覺得基於hash的實現不會比紅黑樹好太多，使用vector+sort+unique都要可行許多，建議還是先hash成小文件分開處理再綜合。</p><p>上述方案2中讀者xbzju的方法讓我想到了一些問題，即是set/map，與hash_set/hash_map的性能比較?共計3個問題，如下：</p><p>1、hash_set在千萬級數據下，insert操作優於set? 這位blog：http://t.cn/zOibP7t 給的實踐數據可靠不?</p><p>2、那map和hash_map的性能比較呢? 誰做過相關實驗?</p><div class=pgc-img><img alt=高級程序員之海量數據處理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/224d314756894cf6ae8ac131f6673f13><p class=pgc-img-caption></p></div><ul><li>3、那查詢操作呢，如下段文字所述?</li></ul><div class=pgc-img><img alt=高級程序員之海量數據處理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2ef51fa72f504e07bfa78a8ddebac540><p class=pgc-img-caption></p></div><p>或者小數據量時用map，構造快，大數據量時用hash_map?</p><p>rbtree PK hashtable</p><p>據朋友№邦卡貓№的做的紅黑樹和hash table的性能測試中發現：當數據量基本上int型key時，hash table是rbtree的3-4倍，但hash table一般會浪費大概一半內存。</p><p>因為hash table所做的運算就是個%，而rbtree要比較很多，比如rbtree要看value的數據 ，每個節點要多出3個指針（或者偏移量） 如果需要其他功能，比如，統計某個範圍內的key的數量，就需要加一個計數成員。</p><p>且1s rbtree能進行大概50w+次插入，hash table大概是差不多200w次。不過很多的時候，其速度可以忍了，例如倒排索引差不多也是這個速度，而且單線程，且倒排表的拉鍊長度不會太大。正因為基於樹的實現其實不比hashtable慢到哪裡去，所以數據庫的索引一般都是用的B/B+樹，而且B+樹還對磁盤友好(B樹能有效降低它的高度，所以減少磁盤交互次數)。比如現在非常流行的NoSQL數據庫，像MongoDB也是採用的B樹索引。關於B樹系列，請參考本blog內此篇文章：從B樹、B+樹、B*樹談到R 樹。更多請待後續實驗論證。</p><p>11. 一個文本文件，找出前10個經常出現的詞，但這次文件比較長，說是上億行或十億行，總之無法一次讀入內存，問最優解。</p><p>方案1：首先根據用hash並求模，將文件分解為多個小文件，對於單個文件利用上題的方法求出每個文件件中10個最常出現的詞。然後再進行歸併處理，找出最終的10個最常出現的詞。</p><p>12. 100w個數中找出最大的100個數。</p><p>方案1：採用局部淘汰法。選取前100個元素，並排序，記為序列L。然後一次掃描剩餘的元素x，與排好序的100個元素中最小的元素比，如果比這個最小的要大，那麼把這個最小的元素刪除，並把x利用插入排序的思想，插入到序列L中。依次循環，知道掃描了所有的元素。複雜度為O(100w*100)。</p><p>方案2：採用快速排序的思想，每次分割之後只考慮比軸大的一部分，知道比軸大的一部分在比100多的時候，採用傳統排序算法排序，取前100個。複雜度為O(100w*100)。</p><p>方案3：在前面的題中，我們已經提到了，用一個含100個元素的最小堆完成。複雜度為O(100w*lg100)。</p><p>接下來，咱們來看第二種方法，雙層捅劃分。</p><p>密匙二、多層劃分</p><p>多層劃分----其實本質上還是分而治之的思想，重在“分”的技巧上！</p><p>適用範圍：第k大，中位數，不重複或重複的數字</p><p>基本原理及要點：因為元素範圍很大，不能利用直接尋址表，所以通過多次劃分，逐步確定範圍，然後最後在一個可以接受的範圍內進行。</p><p>問題實例：</p><p>13、2.5億個整數中找出不重複的整數的個數，內存空間不足以容納這2.5億個整數。</p><p>有點像鴿巢原理，整數個數為2^32,也就是，我們可以將這2^32個數，劃分為2^8個區域(比如用單個文件代表一個區域)，然後將數據分離到不同的區域，然後不同的區域在利用bitmap就可以直接解決了。也就是說只要有足夠的磁盤空間，就可以很方便的解決。</p><p>14、5億個int找它們的中位數。</p><p>思路一：這個例子比上面那個更明顯。首先我們將int劃分為2^16個區域，然後讀取數據統計落到各個區域裡的數的個數，之後我們根據統計結果就可以判斷中位數落到那個區域，同時知道這個區域中的第幾大數剛好是中位數。然後第二次掃描我們只統計落在這個區域中的那些數就可以了。</p><p>實際上，如果不是int是int64，我們可以經過3次這樣的劃分即可降低到可以接受的程度。即可以先將int64分成2^24個區域，然後確定區域的第幾大數，在將該區域分成2^20個子區域，然後確定是子區域的第幾大數，然後子區域裡的數的個數只有2^20，就可以直接利用direct addr table進行統計了。</p><p>思路二@綠色夾克衫：同樣需要做兩遍統計，如果數據存在硬盤上，就需要讀取2次。</p><p>方法同基數排序有些像，開一個大小為65536的Int數組，第一遍讀取，統計Int32的高16位的情況，也就是0-65535，都算作0,65536 - 131071都算作1。就相當於用該數除以65536。Int32 除以 65536的結果不會超過65536種情況，因此開一個長度為65536的數組計數就可以。每讀取一個數，數組中對應的計數+1，考慮有負數的情況，需要將結果加32768後，記錄在相應的數組內。</p><p>第一遍統計之後，遍歷數組，逐個累加統計，看中位數處於哪個區間，比如處於區間k，那麼0- k-1的區間裡數字的數量sum應該&lt;n/2（2.5億）。而k+1 - 65535的計數和也&lt;n/2，第二遍統計同上面的方法類似，但這次只統計處於區間k的情況，也就是說(x / 65536) + 32768 = k。統計只統計低16位的情況。並且利用剛才統計的sum，比如sum = 2.49億，那麼現在就是要在低16位裡面找100萬個數(2.5億-2.49億)。這次計數之後，再統計一下，看中位數所處的區間，最後將高位和低位組合一下就是結果了。</p><p>密匙三：Bloom filter/Bitmap</p><p>Bloom filter</p><p>適用範圍：可以用來實現數據字典，進行數據的判重，或者集合求交集</p><p>基本原理及要點：</p><p>對於原理來說很簡單，位數組+k個獨立hash函數。將hash函數對應的值的位數組置1，查找時如果發現所有hash函數對應位都是1說明存在，很明顯這個過程並不保證查找的結果是100%正確的。同時也不支持刪除一個已經插入的關鍵字，因為該關鍵字對應的位會牽動到其他的關鍵字。所以一個簡單的改進就是 counting Bloom filter，用一個counter數組代替位數組，就可以支持刪除了。</p><p>還有一個比較重要的問題，如何根據輸入元素個數n，確定位數組m的大小及hash函數個數。當hash函數個數k=(ln2)*(m/n)時錯誤率最小。在錯誤率不大於E的情況下，m至少要等於n*lg(1/E)才能表示任意n個元素的集合。但m還應該更大些，因為還要保證bit數組裡至少一半為0，則m應該>=nlg(1/E)*lge 大概就是nlg(1/E)1.44倍(lg表示以2為底的對數)。</p><p>舉個例子我們假設錯誤率為0.01，則此時m應大概是n的13倍。這樣k大概是8個。</p><p>注意這裡m與n的單位不同，m是bit為單位，而n則是以元素個數為單位(準確的說是不同元素的個數)。通常單個元素的長度都是有很多bit的。所以使用bloom filter內存上通常都是節省的。</p><p>擴展：</p><p>Bloom filter將集合中的元素映射到位數組中，用k（k為哈希函數個數）個映射位是否全1表示元素在不在這個集合中。Counting bloom filter（CBF）將位數組中的每一位擴展為一個counter，從而支持了元素的刪除操作。Spectral Bloom Filter（SBF）將其與集合元素的出現次數關聯。SBF採用counter中的最小值來近似表示元素的出現頻率。</p><p>可以看下上文中的第6題：</p><p>“6、給你A,B兩個文件，各存放50億條URL，每條URL佔用64字節，內存限制是4G，讓你找出A,B文件共同的URL。如果是三個乃至n個文件呢？</p><p>根據這個問題我們來計算下內存的佔用，4G=2^32大概是40億*8大概是340億，n=50億，如果按出錯率0.01算需要的大概是650億個bit。現在可用的是340億，相差並不多，這樣可能會使出錯率上升些。另外如果這些urlip是一一對應的，就可以轉換成ip，則大大簡單了。</p><p>同時，上文的第5題：給定a、b兩個文件，各存放50億個url，每個url各佔64字節，內存限制是4G，讓你找出a、b文件共同的url？如果允許有一定的錯誤率，可以使用Bloom filter，4G內存大概可以表示340億bit。將其中一個文件中的url使用Bloom filter映射為這340億bit，然後挨個讀取另外一個文件的url，檢查是否與Bloom filter，如果是，那麼該url應該是共同的url（注意會有一定的錯誤率）。”</p><p>Bitmap</p><p>下面關於Bitmap的應用，可以看下上文中的第13題，以及另外一道新題：</p><p>“13、在2.5億個整數中找出不重複的整數，注，內存不足以容納這2.5億個整數。</p><p>方案1：採用2-Bitmap（每個數分配2bit，00表示不存在，01表示出現一次，10表示多次，11無意義）進行，共需內存2^32 * 2 bit=1 GB內存，還可以接受。然後掃描這2.5億個整數，查看Bitmap中相對應位，如果是00變01，01變10，10保持不變。所描完事後，查看bitmap，把對應位是01的整數輸出即可。</p><p>方案2：也可採用與第1題類似的方法，進行劃分小文件的方法。然後在小文件中找出不重複的整數，並排序。然後再進行歸併，注意去除重複的元素。”</p><p>15、給40億個不重複的unsigned int的整數，沒排過序的，然後再給一個數，如何快速判斷這個數是否在那40億個數當中？</p><p>方案1：frome oo，用位圖/Bitmap的方法，申請512M的內存，一個bit位代表一個unsigned int值。讀入40億個數，設置相應的bit位，讀入要查詢的數，查看相應bit位是否為1，為1表示存在，為0表示不存在。</p><p>密匙四、Trie樹/數據庫/倒排索引</p><p>Trie樹</p><p>適用範圍：數據量大，重複多，但是數據種類小可以放入內存</p><p>基本原理及要點：實現方式，節點孩子的表示方式</p><p>擴展：壓縮實現。</p><p>問題實例：</p><p>上面的第2題：尋找熱門查詢：查詢串的重複度比較高，雖然總數是1千萬，但如果除去重複後，不超過3百萬個，每個不超過255字節。</p><p>上面的第5題：有10個文件，每個文件1G，每個文件的每一行都存放的是用戶的query，每個文件的query都可能重複。要你按照query的頻度排序。</p><p>1000萬字符串，其中有些是相同的(重複),需要把重複的全部去掉，保留沒有重複的字符串。請問怎麼設計和實現？</p><p>上面的第8題：一個文本文件，大約有一萬行，每行一個詞，要求統計出其中最頻繁出現的前10個詞。其解決方法是：用trie樹統計每個詞出現的次數，時間複雜度是O(n*le)（le表示單詞的平準長度），然後是找出出現最頻繁的前10個詞。</p><p>更多有關Trie樹的介紹，請參見此文：從Trie樹（字典樹）談到後綴樹。</p><p>數據庫索引</p><p>適用範圍：大數據量的增刪改查</p><p>基本原理及要點：利用數據的設計實現方法，對海量數據的增刪改查進行處理。</p><p>倒排索引(Inverted index)</p><p>適用範圍：搜索引擎，關鍵字查詢</p><p>基本原理及要點：為何叫倒排索引？一種索引方法，被用來存儲在全文搜索下某個單詞在一個文檔或者一組文檔中的存儲位置的映射。</p><p>以英文為例，下面是要被索引的文本：</p><p>T0 = "it is what it is"</p><p>T1 = "what is it"</p><p>T2 = "it is a banana"</p><p>我們就能得到下面的反向文件索引：</p><p>"a": {2}</p><p>"banana": {2}</p><p>"is": {0, 1, 2}</p><p>"it": {0, 1, 2}</p><p>"what": {0, 1}</p><p>檢索的條件"what","is"和"it"將對應集合的交集。</p><p>正向索引開發出來用來存儲每個文檔的單詞的列表。正向索引的查詢往往滿足每個文檔有序頻繁的全文查詢和每個單詞在校驗文檔中的驗證這樣的查詢。在正向索引中，文檔佔據了中心的位置，每個文檔指向了一個它所包含的索引項的序列。也就是說文檔指向了它包含的那些單詞，而反向索引則是單詞指向了包含它的文檔，很容易看到這個反向的關係。</p><p>擴展：</p><p>問題實例：文檔檢索系統，查詢那些文件包含了某單詞，比如常見的學術論文的關鍵字搜索。</p><p>關於倒排索引的應用，更多請參見：</p><p>第二十三、四章：楊氏矩陣查找，倒排索引關鍵詞Hash不重複編碼實踐，</p><p>第二十六章：基於給定的文檔生成倒排索引的編碼與實踐。</p><p>密匙五、外排序</p><p>適用範圍：大數據的排序，去重</p><p>基本原理及要點：外排序的歸併方法，置換選擇敗者樹原理，最優歸併樹</p><p>問題實例：</p><p>1).有一個1G大小的一個文件，裡面每一行是一個詞，詞的大小不超過16個字節，內存限制大小是1M。返回頻數最高的100個詞。</p><p>這個數據具有很明顯的特點，詞的大小為16個字節，但是內存只有1M做hash明顯不夠，所以可以用來排序。內存可以當輸入緩衝區使用。</p><p>關於多路歸併算法及外排序的具體應用場景，請參見blog內此文：</p><p>第十章、如何給10^7個數據量的磁盤文件排序</p><p>密匙六、分佈式處理之Mapreduce</p><p>MapReduce是一種計算模型，簡單的說就是將大批量的工作（數據）分解（MAP）執行，然後再將結果合併成最終結果（REDUCE）。這樣做的好處是可以在任務被分解後，可以通過大量機器進行並行計算，減少整個操作的時間。但如果你要我再通俗點介紹，那麼，說白了，Mapreduce的原理就是一個歸併排序。</p><p>適用範圍：數據量大，但是數據種類小可以放入內存</p><p>基本原理及要點：將數據交給不同的機器去處理，數據劃分，結果歸約。</p><p>問題實例：</p><p>The canonical example application of MapReduce is a process to count the appearances of each different word in a set of documents:</p><p>海量數據分佈在100臺電腦中，想個辦法高效統計出這批數據的TOP10。</p><p>一共有N個機器，每個機器上有N個數。每個機器最多存O(N)個數並對它們操作。如何找到N^2個數的中數(median)？</p><p>其它模式/方法論，結合操作系統知識</p><p>至此，六種處理海量數據問題的模式/方法已經闡述完畢。據觀察，這方面的面試題無外乎以上一種或其變形，然題目為何取為是：秒殺99%的海量數據處理面試題，而不是100%呢。OK，給讀者看最後一道題，如下：</p><p>非常大的文件，裝不進內存。每行一個int類型數據，現在要你隨機取100個數。</p><p>我們發現上述這道題，無論是以上任何一種模式/方法都不好做，那有什麼好的別的方法呢？我們可以看看：操作系統內存分頁系統設計(說白了，就是映射+建索引)。</p><p>Windows 2000使用基於分頁機制的虛擬內存。每個進程有4GB的虛擬地址空間。基於分頁機制，這4GB地址空間的一些部分被映射了物理內存，一些部分映射硬盤上的交換文 件，一些部分什麼也沒有映射。程序中使用的都是4GB地址空間中的虛擬地址。而訪問物理內存，需要使用物理地址。 關於什麼是物理地址和虛擬地址，請看：</p><p>物理地址 (physical address): 放在尋址總線上的地址。放在尋址總線上，如果是讀，電路根據這個地址每位的值就將相應地址的物理內存中的數據放到數據總線中傳輸。如果是寫，電路根據這個 地址每位的值就將相應地址的物理內存中放入數據總線上的內容。物理內存是以字節(8位)為單位編址的。</p><p>虛擬地址 (virtual address): 4G虛擬地址空間中的地址，程序中使用的都是虛擬地址。 使用了分頁機制之後，4G的地址空間被分成了固定大小的頁，每一頁或者被映射到物理內存，或者被映射到硬盤上的交換文件中，或者沒有映射任何東西。對於一 般程序來說，4G的地址空間，只有一小部分映射了物理內存，大片大片的部分是沒有映射任何東西。物理內存也被分頁，來映射地址空間。對於32bit的 Win2k，頁的大小是4K字節。CPU用來把虛擬地址轉換成物理地址的信息存放在叫做頁目錄和頁表的結構裡。</p><p>物理內存分頁，一個物理頁的大小為4K字節，第0個物理頁從物理地址 0x00000000 處開始。由於頁的大小為4KB，就是0x1000字節，所以第1頁從物理地址 0x00001000 處開始。第2頁從物理地址 0x00002000 處開始。可以看到由於頁的大小是4KB，所以只需要32bit的地址中高20bit來尋址物理頁。</p><p>返回上面我們的題目：非常大的文件，裝不進內存。每行一個int類型數據，現在要你隨機取100個數。針對此題，我們可以借鑑上述操作系統中內存分頁的設計方法，做出如下解決方案：</p><p>操作系統中的方法，先生成4G的地址表，在把這個表劃分為小的4M的小文件做個索引，二級索引。30位前十位表示第幾個4M文件，後20位表示在這個4M文件的第幾個，等等，基於key value來設計存儲，用key來建索引。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>高級</a></li><li><a>數據</a></li><li><a>處理</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a0402fae.html alt=數據處理：Excel日期時間函數-生成/提取/計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/28798cf2fc06448584123118072b7507 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a0402fae.html title=數據處理：Excel日期時間函數-生成/提取/計算>數據處理：Excel日期時間函數-生成/提取/計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e6598f8.html alt="python數據處理，pandas也有Excel Vlookup 模糊查找功能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/88d28d52-213f-4bc2-a199-4c80bc66275a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e6598f8.html title="python數據處理，pandas也有Excel Vlookup 模糊查找功能">python數據處理，pandas也有Excel Vlookup 模糊查找功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f93ef5.html alt=高級數據鏈路控制協議-HDLC class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84eeef335a874e5189b605261c879f87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f93ef5.html title=高級數據鏈路控制協議-HDLC>高級數據鏈路控制協議-HDLC</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d360bf5.html alt=GDPR“數據處理”、“處理安全”、“加密”分別對應哪些內容？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b41d59e6bd749539bba46031c12f7f7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d360bf5.html title=GDPR“數據處理”、“處理安全”、“加密”分別對應哪些內容？>GDPR“數據處理”、“處理安全”、“加密”分別對應哪些內容？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6680dc.html alt=數據的機器級表示與處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6680dc.html title=數據的機器級表示與處理>數據的機器級表示與處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7631193.html alt=Excel如何批量處理數據？用這個方法，不到3秒就搞定了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3c6eebfda7b74ceb9350189dce77993e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7631193.html title=Excel如何批量處理數據？用這個方法，不到3秒就搞定了>Excel如何批量處理數據？用這個方法，不到3秒就搞定了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a547d0.html alt=快速掌握Excel中批量處理數據的技巧（2） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/58edc66dd73e4d7b9995c8279d182d28 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a547d0.html title=快速掌握Excel中批量處理數據的技巧（2）>快速掌握Excel中批量處理數據的技巧（2）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fa33ffe.html alt=Excel數據處理：開始菜單-單元格功能區-格式選項卡 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ad8325d0789645fcbe6dd3e170dac289 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fa33ffe.html title=Excel數據處理：開始菜單-單元格功能區-格式選項卡>Excel數據處理：開始菜單-單元格功能區-格式選項卡</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/7b7b650.html alt=Python數據處理：五分鐘搞定異常值和重複值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1c8aef2db0884250a7268ec089f7ad4b style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/7b7b650.html title=Python數據處理：五分鐘搞定異常值和重複值>Python數據處理：五分鐘搞定異常值和重複值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4044e1f.html alt=2019年中式烹調師（高級）安全生產模擬考試題庫及答案（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4044e1f.html title=2019年中式烹調師（高級）安全生產模擬考試題庫及答案（一）>2019年中式烹調師（高級）安全生產模擬考試題庫及答案（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f855d5ae.html alt=2019年中式烹調師（高級）安全生產模擬考試題庫及答案（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9796cfd44f754f9ab22310d91088423e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f855d5ae.html title=2019年中式烹調師（高級）安全生產模擬考試題庫及答案（二）>2019年中式烹調師（高級）安全生產模擬考試題庫及答案（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>