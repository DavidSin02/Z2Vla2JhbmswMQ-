<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>認識Java異步編程 | 极客快訊</title><meta property="og:title" content="認識Java異步編程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e1e2b766f8f9413597586d35d1739683"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/630242c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/630242c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/630242c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/630242c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/630242c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/630242c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/630242c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/630242c.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="認識Java異步編程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/630242c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>認識Java異步編程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一 、認識異步編程</h1><p>通常Java開發人員喜歡使用同步代碼編寫程序,因為這種請求(request)/響應(response)的方式比較簡單，並且比較符合編程人員的思維習慣;這種做法很好，直到系統出現性能瓶頸；在同步編程方式時由於每個線程同時只能發起一個請求並同步等待返回，所以為了提高系統性能，此時我們就需要引入更多的線程來實現並行化處理；但是多線程下對共享資源進行訪問時，不可避免會引入資源爭用和併發問題；另外操作系統層面對線程的個數是有限制的，不可能通過無限的增加線程數來提供系統性能；最後使用同步阻塞的編程方式還會導致浪費資源，比如發起網絡IO請求時候，調用線程就會處於同步阻塞等待響應結果的狀態，而這時候調用線程明明可以去做其他事情，等網絡IO響應結果返回後在對結果進行處理。</p><p>可見通過增加單機系統線程個數的並行編程方式並不是靈丹妙藥；通過編寫異步、非阻塞的代碼，則可以使用相同的底層資源將執行切換到另一個活動任務，然後在異步處理完成後在返回到當前線程進行繼續處理，從而提高系統性能。</p><p>異步編程是可以讓程序並行運行的一種手段，其可以讓程序中的一個工作單元與主應用程序線程分開獨立運行，並且等工作單元運行結束後通知主應用程序線程它的運行結果或者失敗原因。使用它有許多好處，例如可以提高應用程序的性能和響應能力。</p><p>比如當調用線程使用異步方式發起網絡IO請求後，調用線程就不會同步阻塞等待響應結果，而是在內存保存請求上下文後，會馬上返回後做其他事情，等網絡IO響應結果返回後在使用IO線程通知業務線程響應結果已經返回，然後業務線程在對結果進行處理。可知異步調用方式提高了線程的利用率，讓系統有更多的線程資源來處理更多的請求。</p><p>比如在移動應用程序中，在用戶操作移動設備屏幕發起請求後，如果是同步等待後臺服務器返回結果，則當後臺服務操作非常耗時時，就會造成用戶看到移動設備屏幕凍結（一直處理請求處理中），在結果返回前，用戶不能操作移動設備的其他功能，這對用戶體驗非常不好。而使用異步編程則當發起請求後，調用線程會馬上返回，具體返回結果則會通過UI線程異步進行渲染，而在這期間用戶可以使用移動設備的其他功能。</p><h1 class=pgc-h-arrow-right>二、 異步編程場景概述</h1><p>在日常開發中我們經常會遇到這樣的情況，就是需要異步的處理一些事情，而不需要知道異步任務的結果；比如在調用線程裡面異步打日誌，為了不讓日誌打印阻塞調用線程，會把日誌設置為異步方式。如下圖1-2-1日誌異步化打印，使用一個內存隊列把日誌打印異步化，使用單一線程來消費隊列裡面日誌事件執行具體的日誌落盤操作（本質是一個多生產單消費模型），這種情況下調用線程把日誌任務放入隊列後就繼續去幹自己的事情了，而不再關心日誌任務具體是什麼時候入盤的；</p><p><br></p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e1e2b766f8f9413597586d35d1739683><p class=pgc-img-caption></p></div><p>image.png</p><p><br></p><p>圖 1-2-1 日誌異步打印</p><p>在Java中每當我們需要執行異步任務的時候我們可以直接開啟一個線程來實現，也可以把異步任務封裝為任務對象投遞到線程池裡面來執行，在Spring框架中則提供了@Async註解把一個任務異步化來進行處理，這些內容會在後面章節具體講解。</p><p>另外有時候我們還需要在主線程等待異步任務的執行結果，這時候Future就排上用場了；比如調用線程要等執行任務A執行完畢後在順序執行任務B，並且把兩者結果拼接起來作為前端展示使用，如果調用線程是同步調用兩次查詢（如下圖1-2-2同步調用），則整個過程耗時時間為執行任務A的耗時加上執行任務B的耗時。</p><p><br></p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c5c1c497dcfe44339f9140f6c91bf842><p class=pgc-img-caption></p></div><p>image.png</p><p><br></p><p>圖1-2-2 同步調用</p><p>如果使用異步編程（如下圖1-2-3）則可以在調用線程內開啟一個異步運行單元來執行任務A，開啟異步運行單元后調用線程會馬上返回一個Future對象（futureB），然後調用線程本身來執行任務B，等任務B執行完畢後，調用線程可以調用futureB的get（）方法獲取任務A的執行結果，最後在拼接兩者結果。這時由於任務A和任務B是並行運行的，所以整個過程耗時為max(調用線程執行任務B耗時，異步運行單元執行任務A耗時）。</p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d39d2b134a234cc4a0843915765d6c1b><p class=pgc-img-caption></p></div><p>image.png</p><p><br></p><p>圖1-2-3 異步調用</p><p>可見整個過程耗時有顯著縮短，對於用戶來說頁面響應時間會更短，對用戶體驗會更好，其中異步單元的執行一般是線程池中的線程。</p><p>使用Future確實可以獲取異步任務的執行結果，但是獲取其結果還是會阻塞調用線程的，並沒有實現完全異步化處理，在JDK8中提供了CompletableFuture來彌補了其缺點。CompletableFuture類允許以非阻塞方式和基於通知的方式處理結果，其通過設置回調函數方式，讓主線程徹底解放出來，做自己的事情，實現了實際意義上的異步處理；</p><p>如下圖1-2-4使用CompletableFuture時候當異步單元返回futureB後，調用線程可以在其上調用whenComplete方法設置一個回調函數action,然後調用線程就會馬上返回了，等異步任務執行完畢後會使用異步線程來執行回調函數action，而無需調用線程干預，如果你對CompletableFuture不瞭解，沒關係，後面章節我們會詳細講解，這裡你只需要知道其解決了傳統Future的缺陷就可以了。</p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f5a0eacb559414782544b3b6ac5a906><p class=pgc-img-caption></p></div><p>image.png</p><p><br></p><p>圖1-2-4 CompletableFuture異步執行</p><p>JDK8還引入了Stream，它旨在有效地處理數據流（包括原始類型），其使用聲明式編程讓我們可以寫出可讀性、可維護性很強的代碼，並且結合CompletableFuture可以完美的實現異步編程。但是它產生的流只能使用一次，並且缺少與時間相關的操作（例如RxJava中的基於時間窗口的緩存元素），雖然可以執行並行計算，但無法指定要使用的線程池。並且它還沒有設計用於處理延遲的操作（例如RxJava中的defer操作）；而Reactor或RxJava等Reactive API就是為了解決這些問題而生的。</p><p>Reactor或RxJava等反應式API也提供Java 8 Stream的運算符，但它們更適用於任何流序列（不僅僅是集合），並允許定義一個轉換操作的管道，該管道將應用於通過它的數據，這要歸功於方便的流暢API和Lambda表達式的使用。Reactive旨在處理同步或異步操作，並允許您緩衝（buffer）、合併（merge）、連接(join) 元素等對元素做各種轉換。</p><p>上面我們講解了單JVM內的異步編程，那麼對於跨網絡的交互是否也存在異步編程範疇那？對於網絡請求來說，同步調用時比較直截了當的，比如我們在一個線程A中通過RPC請求獲取服務B和服務C的數據，然後基於兩者結果做一些事情。在同步調用情況下，線程A需要調用服務B，然後需要同步等待服務B結果返回後，才可以對服務C發起調用，然後等服務C結果返回後才可以結合服務B和C的結果做一件事,如下圖1-2-5：</p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b42e136693804300b21d972ac784431f><p class=pgc-img-caption></p></div><p>image.png</p><p>圖1-2-5 同步RPC調用</p><p>如上圖1-2-5線程A同步獲取服務B結果後，在同步調用服務C獲取結果，可見在同步調用情況下業務執行語義比較清晰，線程A順序的對多個服務請求進行調用；但是同步調用意味著當前發起請求的調用線程在遠端機器返回結果前必須阻塞等待，這明顯很浪費資源。好的做法應該是發起請求的調用線程發起請求後，註冊一個回調函數，然後馬上返回去做其他事情，當遠端把結果返回後在使用IO線程執行回調函數。</p><p>那麼如何實現異步調用？在Java中NIO的出現讓實現上面的功能變得簡單，而高性能異步、基於事件驅動的網絡編程框架Netty的出現讓我們從編寫繁雜的Java NIO程序出解放出來了，現在的RPC框架比如Dubbo底層網絡通信就是基於Netty實現的;Netty框架將網絡編程邏輯與業務邏輯處理分離開來，其內部幫我們自動處理好網絡與異步處理邏輯，讓我們專心寫自己的業務處理邏輯，Netty的異步非阻塞能力與CompletableFuture結合就可以輕鬆的實現網絡請求的異步調用。</p><p>在執行RPC(遠程過程調用)調用時候，使用異步編程可以提高系統的性能；如下圖1-2-6，在異步調用情況下，當線程A調用服務B後，馬上會返回一個異步的futureB對象，然後線程A可以在futureB上設置一個回調函數；然後線程A可以繼續訪問服務C，也會馬上返回一個futureC對象，然後線程A可以在futureC上設置一個回調函數：</p><p><br></p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bffae781b11e49ce98e619d1a072b086><p class=pgc-img-caption></p></div><p>image.png</p><p><br></p><p>圖1-2-6 RPC異步調用</p><p>如上圖1-2-6可知異步調用情況下線程A可以併發的調用服務B和服務C，而不再是順序的，由於服務B和服務C是併發運行，所以相比線程A同步調用，線程A獲取到服務B和服務C結果的時間會縮短很多（同步調用情況下耗時時間為服務B和服務C返回結果耗時的和，異步調用時候耗時為max(服務B耗時，服務C耗時））；另外這裡可以藉助CompletableFuture的能力等兩次RPC調用都異步返回結果後做一件事情，這時候調用流程如下圖圖1-2-7：</p><p><br></p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74c72af40c2a4046931b285026eef4e8><p class=pgc-img-caption></p></div><p>image.png</p><p><br></p><p>圖1-2-7 合併Rpc調用結果</p><p>如上圖圖1-2-7調用線程A首先發起服務B的遠程調用，然後馬上返回一個futureB對象，然後發起服務C的遠程調用，然後馬上返回一個futureC對象，最後調用線程A使用代碼futureB.thenCombine(futureC,action)等futureB和futureC結果可用時候執行回調函數action；這裡我們只是簡單的概述下基於Netty的異步非阻塞能力以及CompletableFuture的可編排能力，我們可以實現功能很強大的異步編程能力，後面章節我們會以Dubbo框架為例講解其藉助Netty的非阻塞異步API實現了服務消費端的異步調用。</p><p>其實有了CompletableFuture實現異步編程，我們可以很自然的使用適配器來實現Reactive風格的編程，當我們使用RxJava API時候我們只需要使用Flowable的一些函數轉換CompletableFuture為Flowable對象即可，這個我們在後面章節也會講述。</p><p>上節講解了網絡請求中的RPC框架的異步請求，其實還有一類，也就是Web請求，在Web應用中Servlet佔有一席之地。在Servlet3.0規範前，Servlet容器對Servlet的處理都是每個請求對應一個線程這種1：1的模式進行處理的（如下圖1-2-8），每當來一個請求時候都會開啟一個Servlet容器內的線程來進行處理，如果Servlet內處理比較耗時，則會把Servlet容器內線程使用耗盡，然後容器就不能再處理新的請求。</p><p><br></p><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f025f5a3a2174f2da428ec07e1dc3b0a><p class=pgc-img-caption></p></div><p>image.png</p><p><br></p><p>圖1-2-8 Servlet的阻塞處理模型</p><p>Servlet3.0規範中則提供了異步處理的能力，讓Servlet容器中的線程可以及時釋放，具體Servlet業務處理邏輯是在業務自己線程池內來處理；雖然Servlet3.0規範讓Servlet的執行變為了異步，但是其IO還是阻塞式的，IO阻塞是說在Servlet處理請求時候從ServletInputStream中讀取請求體時候是阻塞的，而我們想要的是當數據已經就緒時候通知我們去讀取就可以了，因為這可以避免佔用我們自己的線程來進行阻塞讀取，Servlet3.1規範則提供了非阻塞IO來解決這個問題。</p><p>雖然Servlet技術棧的不斷髮展實現了異步處理與非阻塞IO，但是其異步是不徹底的，因為受制於Servlet規範本身，比如其規範是同步的（Filter，Servlet）或阻塞（getParameter，getPart）。所以新的使用少量線程和較少的硬件資源來處理併發的非阻塞Web技術棧應運而生-WebFlux,其是與Servlet技術棧並行存在的一種新的技術，其基於JDK8函數式編程與Netty實現天然的異步、非阻塞處理，這些我們在後面章節會具體介紹。</p><p>另外為了更好的處理異步編程，降低我們異步編程的成本，一些框架也應運而生，比如高性能線程間消息傳遞庫Disruptor，其通過為事件（events）預先分配內存、無鎖CAS算法、緩衝行填充、兩階段協議提交來實現多線程併發的處理不同的元素，從而實現高性能的異步處理；比如Akka其基於Actor模式實現了天然支持分佈式的使用消息進行異步處理的服務；比如高性能分佈式消息中間件Apache RocketMetaQ用來實現應用間的異步解耦、流量削峰。</p><p>一些新興的語言對異步處理的支持能力讓我們忍不住稱讚，GoLang就是其中之一，其通過語言層面內置的goroutine與channel可以輕鬆的實現複雜的異步處理能力。</p><p>《Java異步編程實戰》，一書則是根據上述介紹的次序，把內容劃分了若干章節，每章則具體展開討論相應的異步編程技術。</p><h1 class=pgc-h-arrow-right>三、 為何寫作本書</h1><p>異步編程是可以讓程序並行運行的一種手段，其可以讓程序中的一個工作單元與主應用程序線程分開獨立運行，使用它有許多好處，例如可以提高應用程序的性能和響應能力。</p><p>雖然Java中不同技術域提供了相應的異步編程技術，但是對異步編程技術的描述散落到了不同技術域的技術文檔中，並沒有一個統一的地方對這些技術進行梳理歸納。另外這些技術之間是什麼關係，各自的出現都是為了解決什麼問題，我們也很難找到資料來解釋。</p><p>本書的出現則是為了打破這種局面，本書旨在把Java中相關的異步編程技術進行歸納分類總結，然後呈現給大家，讓大家可以有一個統一的地方來查看與探究。</p><h1 class=pgc-h-arrow-right>四、本書特色</h1><p>本書涵蓋了Java中常見的異步編程場景，這包含單JVM內的異步編程、以及跨主機通過網絡通訊的遠程過程調用的異步調用與異步處理、以及Web請求的異步處理等等。</p><p>本書在講解Java中每種異步編程技術時都附有案例，以便理論與實踐進行結合。</p><p>本書在講解每種異步編程技術時大多都會對其實現原理進行講解，以便讓讀者知其然也知其所以然。</p><p>本書對最近比較火的反應式編程以及WebFlux的使用與原理解析有一定深入的探索。</p><h1 class=pgc-h-arrow-right>五、 業界推薦</h1><div class=pgc-img><img alt=認識Java異步編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bed14ef9ed284862a1bd053367022465><p class=pgc-img-caption></p></div><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>認識</a></li><li><a>Java</a></li><li><a>異步</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html alt="Java 異步編程導論" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3c356b1aa9b4416ca7b35a07f3033e13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html title="Java 異步編程導論">Java 異步編程導論</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/325007f.html alt="教你如何用 Java 實現異步調用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/325007f.html title="教你如何用 Java 實現異步調用">教你如何用 Java 實現異步調用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8829489.html alt="Java NIO(8) : 異步模型之狀態機" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1522223705458c14ec4daaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8829489.html title="Java NIO(8) : 異步模型之狀態機">Java NIO(8) : 異步模型之狀態機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a2e003a.html alt=你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cc30aa4b32114cb7aa98314ba1519473 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a2e003a.html title=你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力>你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/429ef3cd.html alt=認識七天在一起一天，離別時卻是一輩子 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/98e368bb546b47699c3f48c661fa0076 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/429ef3cd.html title=認識七天在一起一天，離別時卻是一輩子>認識七天在一起一天，離別時卻是一輩子</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa09bc26.html alt=帶您認識防靜電滾輪的基礎知識！-山西天罡 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2b8a90d785874d838aa0057c8a5a4ecf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa09bc26.html title=帶您認識防靜電滾輪的基礎知識！-山西天罡>帶您認識防靜電滾輪的基礎知識！-山西天罡</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62f3704c.html alt="哈密 最美的季節重新認識你！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15399338780300ff4260a66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62f3704c.html title="哈密 最美的季節重新認識你！">哈密 最美的季節重新認識你！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>