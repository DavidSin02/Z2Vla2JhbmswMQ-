<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JavaConcurrentHashMap高併發安全原理解析 | 极客快訊</title><meta property="og:title" content="JavaConcurrentHashMap高併發安全原理解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/34c30d964f7e4bcb957877397e18c3ea"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6338c6db.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6338c6db.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6338c6db.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6338c6db.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6338c6db.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6338c6db.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6338c6db.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6338c6db.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="JavaConcurrentHashMap高併發安全原理解析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6338c6db.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JavaConcurrentHashMap高併發安全原理解析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><ul><li>位的確定可以用一次與運算來替代取餘運算。</li><li>會對hashcode調用若干次擾動函數，將高16位與低16位做異或運算，因為高16位的隨機性更強。</li><li>當表中的元素總數超過tableSize * 0.75時，哈希表會發生擴容操作，每次擴容的tableSize是原先的兩倍。</li><li>下文提到的槽位(bucket)、哈希分桶、BIN均表示同一個概念，即哈希table上的某一列。</li><li>舊錶在做搬運時i槽位的node可以根據其哈希值的第tableSize位的bit決定在新表上的槽位是i還是i+tableSize。</li><li>每個槽位上有可能會出現哈希衝突，在未達到某個閾值時它是一個鏈表結構，達到閾值後會升級到紅黑樹結構。</li><li>HashMap本身並非為多線程環境設計，永遠不要嘗試在併發環境下直接使用HashMap，C13Map不存在這個安全問題。</li></ul><div class=pgc-img><img alt=JavaConcurrentHashMap高併發安全原理解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/34c30d964f7e4bcb957877397e18c3ea><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>三、C13Map的字段定義</h1><p>C13Map的字段定義</p><pre><code>//最大容量private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默認初始容量private static final int DEFAULT_CAPACITY = 16;//數組的最大容量,防止拋出OOMstatic final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//最大並行度，僅用於兼容JDK1.7以前版本private static final int DEFAULT_CONCURRENCY_LEVEL = 16;//擴容因子private static final float LOAD_FACTOR = 0.75f;//鏈表轉紅黑樹的閾值static final int TREEIFY_THRESHOLD = 8;//紅黑樹退化閾值static final int UNTREEIFY_THRESHOLD = 6;//鏈表轉紅黑樹的最小總量static final int MIN_TREEIFY_CAPACITY = 64;//擴容搬運時批量搬運的最小槽位數private static final int MIN_TRANSFER_STRIDE = 16;//當前待擴容table的郵戳位,通常是高16位private static final int RESIZE_STAMP_BITS = 16;//同時搬運的線程數自增的最大值private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;//搬運線程數的標識位，通常是低16位private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;static final int MOVED     = -1; // 說明是forwardingNodestatic final int TREEBIN   = -2; // 紅黑樹static final int RESERVED  = -3; // 原子計算的佔位Nodestatic final int HASH_BITS = 0x7fffffff; // 保證hashcode擾動計算結果為正數//當前哈希表transient volatile Node&lt;K,V&gt;[] table;//下一個哈希表private transient volatile Node&lt;K,V&gt;[] nextTable;//計數的基準值private transient volatile long baseCount;//控制變量，不同場景有不同用途，參考下文private transient volatile int sizeCtl;//併發搬運過程中CAS獲取區段的下限值private transient volatile int transferIndex;//計數cell初始化或者擴容時基於此字段使用自旋鎖private transient volatile int cellsBusy;//加速多核CPU計數的cell數組private transient volatile CounterCell[] counterCells;複製代碼</code></pre><p><br></p><h1 class=pgc-h-arrow-right>四、安全操作N需要藉助於Unsafe來保證Node&lt;K,V>[]元素的“讀/寫/CAS”操作在多核併發環境下的原子或者可見性。</h1><h1 class=pgc-h-arrow-right>五、讀操作get為什麼是線程安全的</h1><p>首先需要明確的是，C13Map的讀操作一般是不加鎖的(TreeBin的讀寫鎖除外)，而讀操作與寫操作有可能並行；可以保證的是，因為C13Map的寫操作都要獲取bin頭部的syncronized互斥鎖，能保證最多隻有一個線程在做更新，這其實是一個單線程寫、多線程讀的併發安全性的問題。</p><p>C13Map的get方法</p><pre><code>public V get(Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;    //執行擾動函數    int h = spread(key.hashCode());    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) {        if ((eh = e.hash) == h) {            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))                return e.val;        }        else if (eh &lt; 0)            return (p = e.find(h, key)) != null ? p.val : null;        while ((e = e.next) != null) {            if (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))                return e.val;        }    }    return null;}複製代碼</code></pre><p><br></p><h1 class=pgc-h-arrow-right>1、如果當前哈希表table為null</h1><p>哈希表未初始化或者正在初始化未完成，直接返回null；雖然line5和line18之間其它線程可能經歷了千山萬水，至少在判斷tab==null的時間點key肯定是不存在的，返回null符合某一時刻的客觀事實。</p><h1 class=pgc-h-arrow-right>2、如果讀取的bin頭節點為null</h1><p>說明該槽位尚未有節點，直接返回null。</p><h1 class=pgc-h-arrow-right>3、如果讀取的bin是一個鏈表</h1><p>說明頭節點是個普通Node。</p><p>（1）如果正在發生鏈表向紅黑樹的treeify工作，因為treeify本身並不破壞舊的鏈表bin的結構，只是在全部treeify完成後將頭節點一次性替換為新創建的TreeBin，可以放心讀取。</p><p>（2）如果正在發生resize且當前bin正在被transfer，因為transfer本身並不破壞舊的鏈表bin的結構，只是在全部transfer完成後將頭節點一次性替換為ForwardingNode，可以放心讀取。</p><p>（3）如果其它線程正在操作鏈表，在當前線程遍歷鏈表的任意一個時間點，都有可能同時在發生add/replace/remove操作。</p><ul><li>如果是add操作，因為鏈表的節點新增從JDK8以後都採用了後入式，無非是多遍歷或者少遍歷一個tailNode。</li><li>如果是remove操作，存在遍歷到某個Node時，正好有其它線程將其remove，導致其孤立於整個鏈表之外；但因為其next引用未發生變更，整個鏈表並沒有斷開，還是可以照常遍歷鏈表直到tailNode。</li><li>如果是replace操作，鏈表的結構未變，只是某個Node的value發生了變化，沒有安全問題。</li></ul><p><strong>結論：</strong>對於鏈表這種線性數據結構，單線程寫且插入操作保證是後入式的前提下，併發讀取是安全的；不會存在誤讀、鏈表斷開導致的漏讀、讀到環狀鏈表等問題。</p><h1 class=pgc-h-arrow-right>4、如果讀取的bin是一個紅黑樹</h1><p>說明頭節點是個TreeBin節點。</p><p>（1）如果正在發生紅黑樹向鏈表的untreeify操作，因為untreeify本身並不破壞舊的紅黑樹結構，只是在全部untreeify完成後將頭節點一次性替換為新創建的普通Node，可以放心讀取。</p><p>（2）如果正在發生resize且當前bin正在被transfer，因為transfer本身並不破壞舊的紅黑樹結構，只是在全部transfer完成後將頭節點一次性替換為ForwardingNode，可以放心讀取。</p><p>（3）如果其他線程在操作紅黑樹，在當前線程遍歷紅黑樹的任意一個時間點，都可能有單個的其它線程發生add/replace/remove/紅黑樹的翻轉等操作，參考下面的紅黑樹的讀寫鎖實現。</p><p>TreeBin中的讀寫鎖實現</p><pre><code> TreeNode&lt;K,V&gt; root;    volatile TreeNode&lt;K,V&gt; first;    volatile Thread waiter;    volatile int lockState;    // values for lockState    static final int WRITER = 1; // set while holding write lock    static final int WAITER = 2; // set when waiting for write lock    static final int READER = 4; // increment value for setting read lock    private final void lockRoot() {        //如果一次性獲取寫鎖失敗，進入contendedLock循環體，循環獲取寫鎖或者休眠等待        if (!U.compareAndSetInt(this, LOCKSTATE, 0, WRITER))            contendedLock(); // offload to separate method    }    private final void unlockRoot() {        lockState = 0;    }    //對紅黑樹加互斥鎖,也就是寫鎖    private final void contendedLock() {        boolean waiting = false;        for (int s;;) {            //如果lockState除了第二位外其它位上都為0，表示紅黑樹當前既沒有上讀鎖，又沒有上寫鎖，僅有可能存在waiter，可以嘗試直接獲取寫鎖            if (((s = lockState) &amp; ~WAITER) == 0) {                if (U.compareAndSetInt(this, LOCKSTATE, s, WRITER)) {                    if (waiting)                        waiter = null;                    return;                }            }            //如果lockState第二位是0,表示當前沒有線程在等待寫鎖            else if ((s &amp; WAITER) == 0) {                //將lockState的第二位設置為1，相當於打上了waiter的標記，表示有線程在等待寫鎖                if (U.compareAndSetInt(this, LOCKSTATE, s, s | WAITER)) {                    waiting = true;                    waiter = Thread.currentThread();                }            }            //休眠當前線程            else if (waiting)                LockSupport.park(this);        }    }    //查找紅黑樹中的某個節點    final Node&lt;K,V&gt; find(int h, Object k) {        if (k != null) {            for (Node&lt;K,V&gt; e = first; e != null; ) {                int s; K ek;                //如果當前有waiter或者有寫鎖，走線性檢索，因為紅黑樹雖然替代了鏈表，但其內部依然保留了鏈表的結構，雖然鏈表的查詢性能一般，但根據先前的分析其讀取的安全性有保證。                //發現有寫鎖改走線性檢索，是為了避免等待寫鎖釋放花去太久時間; 而發現有waiter改走線性檢索，是為了避免讀鎖疊加的太多，導致寫鎖線程需要等待太長的時間; 本質上都是為了減少讀寫碰撞                //線性遍歷的過程中，每遍歷到下一個節點都做一次判斷，一旦發現鎖競爭的可能性減少就改走tree檢索以提高性能                if (((s = lockState) &amp; (WAITER|WRITER)) != 0) {                    if (e.hash == h &amp;&amp;                        ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                        return e;                    e = e.next;                }                //對紅黑樹加共享鎖,也就是讀鎖,CAS一次性增加4，也就是增加的只是3~32位                else if (U.compareAndSetInt(this, LOCKSTATE, s,                                             s + READER)) {                    TreeNode&lt;K,V&gt; r, p;                    try {                        p = ((r = root) == null ? null :                             r.findTreeNode(h, k, null));                    } finally {                        Thread w;                        //釋放讀鎖，如果釋放完畢且有waiter,則將其喚醒                        if (U.getAndAddInt(this, LOCKSTATE, -READER) ==                            (READER|WAITER) &amp;&amp; (w = waiter) != null)                            LockSupport.unpark(w);                    }                    return p;                }            }        }        return null;    }    //更新紅黑樹中的某個節點    final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) {        Class&lt;?&gt; kc = null;        boolean searched = false;        for (TreeNode&lt;K,V&gt; p = root;;) {            int dir, ph; K pk;            //...省略處理紅黑樹數據結構的代碼若干                          else {                    //寫操作前加互斥鎖                    lockRoot();                    try {                        root = balanceInsertion(root, x);                    } finally {                        //釋放互斥鎖                        unlockRoot();                    }                }                break;            }        }        assert checkInvariants(root);        return null;    }}複製代碼</code></pre><p><br></p><p>紅黑樹內置了一套讀寫鎖的邏輯，其內部定義了32位的int型變量lockState，第1位是寫鎖標誌位，第2位是寫鎖等待標誌位，從3~32位則是共享鎖標誌位。</p><p><br></p><div class=pgc-img><img alt=JavaConcurrentHashMap高併發安全原理解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9546967ac2594849b9ae9732082eab40><p class=pgc-img-caption></p></div><p><br></p><p>讀寫操作是互斥的，允許多個線程同時讀取，但不允許讀寫操作並行，同一時刻只允許一個線程進行寫操作；這樣任意時間點讀取的都是一個合法的紅黑樹，整體上是安全的。</p><p>有的同學會產生疑惑，寫鎖釋放時為何沒有將waiter喚醒的操作呢？是否有可能A線程進入了等待區，B線程獲取了寫鎖，釋放寫鎖時僅做了lockState=0的操作。</p><p>那麼A線程是否就沒有機會被喚醒了，只有等待下一個讀鎖釋放時的喚醒了呢 ？</p><p>顯然這種情況違背常理，C13Map不會出現這樣的疏漏，再進一步觀察，紅黑樹的變更操作的外圍，也就是在putValue/replaceNode那一層，都是對BIN的頭節點加了synchornized互斥鎖的，同一時刻只能有一個寫線程進入TreeBin的方法範圍內，當寫線程發現當前waiter不為空，其實此waiter只能是當前線程自己，可以放心的獲取寫鎖，不用擔心無法被喚醒的問題。</p><p>TreeBin在find讀操作檢索時，在linearSearch(線性檢索)和treeSearch(樹檢索)間做了折衷，前者性能差但併發安全，後者性能佳但要做併發控制，可能導致鎖競爭；設計者使用線性檢索來儘量避免讀寫碰撞導致的鎖競爭，但評估到race condition已消失時，又立即趨向於改用樹檢索來提高性能，在安全和性能之間做到了極佳的平衡。具體的折衷策略請參考find方法及註釋。</p><p>由於有線性檢索這樣一個抄底方案，以及入口處bin頭節點的synchornized機制，保證了進入到TreeBin整體代碼塊的寫線程只有一個；TreeBin中讀寫鎖的整體設計與ReentrantReadWriteLock相比還是簡單了不少，比如並未定義用於存放待喚醒線程的threadQueue，以及讀線程僅會自旋而不會阻塞等等， 可以看做是特定條件下ReadWriteLock的簡化版本。</p><h1 class=pgc-h-arrow-right>5、如果讀取的bin是一個ForwardingNode</h1><p>說明當前bin已遷移，調用其find方法到nextTable讀取數據。</p><p>forwardingNode的find方法</p><pre><code>static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {    final Node&lt;K,V&gt;[] nextTable;    ForwardingNode(Node&lt;K,V&gt;[] tab) {        super(MOVED, null, null);        this.nextTable = tab;    }    //遞歸檢索哈希錶鏈    Node&lt;K,V&gt; find(int h, Object k) {        // loop to avoid arbitrarily deep recursion on forwarding nodes        outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {            Node&lt;K,V&gt; e; int n;            if (k == null || tab == null || (n = tab.length) == 0 ||                (e = tabAt(tab, (n - 1) &amp; h)) == null)                return null;            for (;;) {                int eh; K ek;                if ((eh = e.hash) == h &amp;&amp;                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))                    return e;                if (eh &lt; 0) {                    if (e instanceof ForwardingNode) {                        tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                        continue outer;                    }                    else                        return e.find(h, k);                }                if ((e = e.next) == null)                    return null;            }        }    }}複製代碼</code></pre><p><br></p><p>ForwardingNode中保存了nextTable的引用，會轉向下一個哈希表進行檢索，但並不能保證nextTable就一定是currentTable，因為在高併發插入的情況下，極短時間內就可以導致哈希表的多次擴容，內存中極有可能駐留一條哈希錶鏈，彼此以bin的頭節點上的ForwardingNode相連，線程剛讀取時拿到的是table1，遍歷時卻有可能經歷了哈希表的鏈條。</p><p>eh&lt;0有三種情況：</p><blockquote><p>如果是ForwardingNode繼續遍歷下一個哈希表。 如果是TreeBin,調用其find方法進入TreeBin讀寫鎖的保護區讀取數據。 如果是ReserveNode，說明當前有compute計算中，整條bin還是一個空結構，直接返回null。</p><p><br></p></blockquote><h1 class=pgc-h-arrow-right>6、如果讀取的bin是一個ReserveNode</h1><p>ReserveNode用於compute/computeIfAbsent原子計算的方法，在BIN的頭節點為null且計算尚未完成時，先在bin的頭節點打上一個ReserveNode的佔位標記。</p><p>讀操作發現ReserveNode直接返回null，寫操作會因為爭奪ReserveNode的互斥鎖而進入阻塞態，在compute完成後被喚醒後循環重試。</p><h1 class=pgc-h-arrow-right>六、寫操作putValue/replaceNode為什麼是線程安全的</h1><p>典型的編程範式如下：</p><p>C13Map的putValue方法</p><pre><code>Node&lt;K,V&gt;[] tab = table;  //將堆中的table變量賦給線程堆棧中的局部變量Node f = tabAt(tab, i );if(f==null){ //當前槽位沒有頭節點,直接CAS寫入 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))    break;}else if(f.hash == MOVED){ //加入協助搬運行列 helpTransfer(tab,f);}//不是forwardingNodeelse if(f.hash != MOVED){    //先鎖住I槽位上的頭節點    synchronized (f) {    //再doubleCheck看此槽位上的頭節點是否還是f    if (tabAt(tab, i) == f) {       ...各種寫操作    }  }}複製代碼</code></pre><p><br></p><h1 class=pgc-h-arrow-right>1、當前槽位如果頭節點為null時，直接CAS寫入</h1><p>有人也許會質疑，如果寫入時resize操作已完成，發生了table向nextTable的轉變，是否會存在寫入的是舊錶的bin導致數據丟失的可能 ?</p><p>這種可能性是不存在的，因為一個table在resize完成後所有的BIN都會被打上ForwardingNode的標記，可以形象的理解為所有槽位上都插滿了紅旗，而此處在CAS時的compare的變量null，能夠保證至少在CAS原子操作發生的時間點table並未發生變更。</p><h1 class=pgc-h-arrow-right>2、當前槽位如果頭節點不為null</h1><p>這裡採用了一個小技巧：先鎖住I槽位上的頭節點，進入同步代碼塊後，再doubleCheck看此槽位上的頭節點是否有變化。</p><p>進入同步塊後還需要doubleCheck的原因：雖然一開始獲取到的頭節點f並非ForwardingNode，但在獲取到f的同步鎖之前，可能有其它線程提前獲取了f的同步鎖並完成了transfer工作，並將I槽位上的頭節點標記為ForwardingNode，此時的f就成了一個過時的bin的頭節點。</p><p>然而因為標記操作與transfer作為一個整體在同步的代碼塊中執行，如果doubleCheck的結果是此槽位上的頭節點還是f，則表明至少在當前時間點該槽位還沒有被transfer到新表(假如當前有transfer in progress的話)，可以放心的對該bin進行put/remove/replace等寫操作。</p><p>只要未發生transfer或者treeify操作，鏈表的新增操作都是採取後入式，頭節點一旦確定不會輕易改變，這種後入式的更新方式保證了鎖定頭節點就等於鎖住了整個bin。</p><p>如果不作doubleCheck判斷，則有可能當前槽位已被transfer，寫入的還是舊錶的BIN，從而導致寫入數據的丟失；也有可能在獲取到f的同步鎖之前，其它線程對該BIN做了treeify操作，並將頭節點替換成了TreeBin, 導致寫入的是舊的鏈表，而非新的紅黑樹；</p><h1 class=pgc-h-arrow-right>3、doubleCheck是否有ABA問題</h1><p>也許有人會質疑，如果有其它線程提前對當前bin進行了的remove/put的操作，引入了新的頭節點，並且恰好發生了JVM的內存釋放和重新分配，導致新的Node的引用地址恰好跟舊的相同，也就是存在所謂的ABA問題。</p><p>這個可以通過反證法來推翻，在帶有GC機制的語言環境下通常不會發生ABA問題，因為當前線程包含了對頭節點f的引用，當前線程並未消亡，不可能存在f節點的內存被GC回收的可能性。</p><p>還有人會質疑，如果在寫入過程中主哈希表發生了變化，是否可能寫入的是舊錶的bin導致數據丟失，這個也可以通過反證法來推翻，因為table向nextTable的轉化(也就是將resize後的新哈希表正式commit)只有在所有的槽位都已經transfer成功後才會進行，只要有一個bin未transfer成功，則說明當前的table未發生變化，在當前的時間點可以放心的向table的bin內寫入數據。</p><h1 class=pgc-h-arrow-right>4、如何操作才安全</h1><p>可以總結出規律，在對table的槽位成功進行了CAS操作且compare值為null，或者對槽位的非forwardingNode的頭節點加鎖後，doubleCheck頭節點未發生變化，對bin的寫操作都是安全的。</p><h1 class=pgc-h-arrow-right>七、原子計算相關方法</h1><p>原子計算主要包括：computeIfAbsent、computeIfPresent、compute、merge四個方法。</p><h1 class=pgc-h-arrow-right>1、幾個方法的比較</h1><p>主要區別如下：</p><p>（1）computeIfAbsent只會在判斷到key不存在時才會插入，判空與插入是一個原子操作，提供的FunctionalInterface是一個二元的Function, 接受key參數，返回value結果；如果計算結果為null則不做插入。</p><p>（2）computeIfPresent只會在判讀單到Key非空時才會做更新，判斷非空與插入是一個原子操作，提供的FunctionalInterface是一個三元的BiFunction,接受key,value兩個參數，返回新的value結果；如果新的value為null則刪除key對應節點。</p><p>（3）compute則不加key是否存在的限制，提供的FunctionalInterface是一個三元的BiFunction,接受key,value兩個參數，返回新的value結果；如果舊的value不存在則以null替代進行計算；如果新的value為null則保證key對應節點不會存在。</p><p>（4）merge不加key是否存在的限制，提供的FunctionalInterface是一個三元的BiFunction,接受oldValue, newVALUE兩個參數，返回merge後的value；如果舊的value不存在，直接以newVALUE作為最終結果，存在則返回merge後的結果；如果最終結果為null，則保證key對應節點不會存在。</p><h1 class=pgc-h-arrow-right>2、何時會使用ReserveNode佔位</h1><p>如果目標bin的頭節點為null，需要寫入的話有兩種手段：一種是生成好新的節點r後使用casTabAt(tab, i, null, r)原子操作，因為compare的值為null可以保證併發的安全；</p><p>另外一種方式是創建一個佔位的ReserveNode，鎖住該節點並將其CAS設置到bin的頭節點，再進行進一步的原子計算操作；這兩種辦法都有可能在CAS的時候失敗，需要自旋反覆嘗試。</p><h1 class=pgc-h-arrow-right>（1）為什麼只有computeIfAbsent/compute方法使用佔位符的方式</h1><p>computeIfPresent只有在BIN結構非空的情況下才會展開原子計算，自然不存在需要ReserveNode佔位的情況；鎖住已有的頭節點即可。</p><p>computeIfAbsent/compute方法在BIN結構為空時，需要展開Function或者BiFunction的運算，這個操作是外部引入的需要耗時多久無法準確評估；這種情況下如果採用先計算，再casTabAt(tab, i, null, r)的方式，如果有其它線程提前更新了這個BIN，那麼就需要重新鎖定新加入的頭節點，並重復一次原子計算(C13Map無法幫你緩存上次計算的結果，因為計算的入參有可能會變化)，這個開銷是比較大的。</p><p>而使用ReserveNode佔位的方式無需等到原子計算出結果，可以第一時間先搶佔BIN的所有權，使其他併發的寫線程阻塞。</p><h1 class=pgc-h-arrow-right>（2）merge方法為何不需要佔位</h1><p>原因是如果BIN結構為空時，根據merge的處理策略，老的value為空則直接使用新的value替代，這樣就省去了BiFunction中新老value進行merge的計算，這個消耗幾乎是沒有的；因此可以使用casTabAt(tab, i, null, r)的方式直接修改，避免了使用ReserveNode佔位，鎖定該佔位ReserveNode後再進行CAS修改的兩次CAS無謂的開銷。</p><p>C13Map的compute方法</p><pre><code>public V compute(K key,                 BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {    if (key == null || remappingFunction == null)        throw new nullPointerException();    int h = spread(key.hashCode());    V val = null;    int delta = 0;    int binCount = 0;    for (Node&lt;K, V&gt;[] tab = table; ; ) {        Node&lt;K, V&gt; f;        int n, i, fh;        if (tab == null || (n = tab.length) == 0)            tab = initTable();        else if ((f = tabAt(tab, i = (n - 1) &amp; h)) == null) {            //創建佔位Node            Node&lt;K, V&gt; r = new ReservationNode&lt;K, V&gt;();           //先鎖定該佔位Node            synchronized (r) {                //將其設置到BIN的頭節點                if (casTabAt(tab, i, null, r)) {                    binCount = 1;                    Node&lt;K, V&gt; node = null;                    try {                        //開始原子計算                        if ((val = remappingFunction.apply(key, null)) != null) {                            delta = 1;                            node = new Node&lt;K, V&gt;(h, key, val, null);                        }                    } finally {                        //設置計算後的最終節點                        setTabAt(tab, i, node);                    }                }            }            if (binCount != 0)                break;        } else if ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        else {            synchronized (f) {                if (tabAt(tab, i) == f) {                    if (fh &gt;= 0) {                       //此處省略對普通鏈表的變更操作                    } else if (f instanceof TreeBin) {                       //此處省略對紅黑樹的變更操作                    }                }            }        }    }    if (delta != 0)        addCount((long) delta, binCount);    return val;}複製代碼</code></pre><h1 class=pgc-h-arrow-right>3、如何保證原子性</h1><p>computeIfAbsent/computeIfPresent中判空與計算是原子操作，根據上述分析主要是通過casTabAt(tab, i, null, r)原子操作，或者使用ReserveNode佔位並鎖定的方式，或者鎖住bin的頭節點的方式來實現的。</p><p>也就是說整個bin一直處於鎖定狀態，在獲取到目標KEY的value是否為空以後，其它線程無法變更目標KEY的值，判空與計算自然是原子的。</p><p>而casTabAt(tab, i, null, r)是由硬件層面的原子指令來保證的，能夠保證同一個內存區域在compare和set操作之間不會有任何其它指令對其進行變更。</p><h1 class=pgc-h-arrow-right>八、resize過程中的併發transfer</h1><p>C13Map中總共有三處地方會觸發transfer方法的調用，分別是addCount、tryPresize、helpTransfer三個函數。</p><ul><li><strong>addCount</strong>用於寫操作完成後檢驗元素數量，如果超過了sizeCtl中的閾值，則觸發resize擴容和舊錶向新表的transfer。</li><li><strong>tryPresize</strong>是putAll一次性插入一個集合前的自檢，如果集合數目較大，則預先觸發一次resize擴容和舊錶向新表的transfer。</li><li><strong>helpTransfer</strong>是寫操作過程中發現bin的頭節點是ForwardingNode, 則調用helpTransfer加入協助搬運的行列。</li></ul><h1 class=pgc-h-arrow-right>1、開始transfer前的檢查工作</h1><p>以addCount中的檢查邏輯為例：</p><p>addCount中的transfer檢查</p><pre><code>Node&lt;K, V&gt;[] tab, nt;int n, sc;//當前的tableSize已經超過sizeCtl閾值，且小於最大值while (s &gt;= (long) (sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;        (n = tab.length) &lt; MAXIMUM_CAPACITY) {    int rs = resizeStamp(n);    //已經在搬運中    if (sc &lt; 0) {        if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                transferIndex &lt;= 0)            break;        //搬運線程數加一        if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))            transfer(tab, nt);    } else if (U.compareAndSwapInt(this, SIZECTL, sc,            (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))        //尚未搬運，當前線程是本次resize工作的第一個線程，設置初始值為2，非常巧妙的設計        transfer(tab, null);    s = sumCount();}複製代碼</code></pre><p>多處應用了對變量sizeCtl的CAS操作，sizeCtl是一個全局控制變量。</p><p>參考下此變量的定義：private transient volatile int sizeCtl;</p><blockquote><p>初始值是0表示哈希表尚未初始化 如果是-1表示正在初始化，只允許一個線程進入初始化代碼塊 初始化或者reSize成功後，sizeCtl=loadFactor * tableSize也就是觸發再次擴容的閾值，是一個正整數 在擴容過程中，sizeCtrl是一個負整數，其高16位是與當前的tableSize關聯的郵戳resizeStamp，其低16位是當前從事搬運工作的線程數加1</p></blockquote><p>在方法的循環體中每次都將table、sizeCtrl、nextTable賦給局部變量以保證讀到的是當前的最新值，且保證邏輯計算過程中變量的穩定。</p><p>如果sizeCtrl中高16位的郵戳與當前tableSize不匹配，或者搬運線程數達到了最大值，或者所有搬運的線程都已經退出(只有在遍歷完所有槽位後才會退出，否則會一直循環)，或者nextTable已經被清空，跳過搬運操作。</p><p>如果滿足搬運條件，則對sizeCtrl做CAS操作，sizeCtrl>=0時設置初始線程數為2，sizeCtrl&lt;0時將其值加1，CAS成功後開始搬運操作，失敗則進入下一次循環重新判斷。</p><p>首個線程設置初始值為2的原因是：線程退出時會通過CAS操作將參與搬運的總線程數-1，如果初始值按照常規做法設置成1，那麼減1後就會變為0。</p><p>此時其它線程發現線程數為0時，無法區分是沒有任何線程做過搬運，還是有線程做完搬運但都退出了，也就無法判斷要不要加入搬運的行列。</p><p>值得注意的是，代碼中的“sc == rs + 1 || sc == rs + MAX_RESIZERS“是JDK8中的明顯的BUG，少了rs無符號左移16位的操作；JDK12已經修復了此問題。</p><h1 class=pgc-h-arrow-right>2、併發搬運過程和退出機制</h1><p>C13Map的transfer方法</p><pre><code>private final void transfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab) {    int n = tab.length, stride;    //一次搬運多少個槽位    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE;    if (nextTab == null) {                   try {            //首個搬運線程，負責初始化nextTable            Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) new Node&lt;?, ?&gt;[n &lt;&lt; 1];            nextTab = nt;        } catch (Throwable ex) {                 sizeCtl = Integer.MAX_VALUE;            return;        }        nextTable = nextTab;        //初始化當前搬運索引        transferIndex = n;    }    int nextn = nextTab.length;    //公共的forwardingNode    ForwardingNode&lt;K, V&gt; fwd = new ForwardingNode&lt;K, V&gt;(nextTab);    boolean advance = true;    boolean finishing = false; // 保證提交nextTable之前已遍歷舊錶的所有槽位    for (int i = 0, bound = 0; ; ) {        Node&lt;K, V&gt; f;        int fh;        //循環CAS獲取下一個搬運區段        while (advance) {            int nextIndex, nextBound;            //搬運已結束，或者當前區段尚未完成，退出循環體;最後一次抄底掃描時，僅輔助做i減一的運算            if (--i &gt;= bound || finishing)                advance = false;            else if ((nextIndex = transferIndex) &lt;= 0) {                i = -1;                advance = false;            } else if (U.compareAndSwapInt                    (this, TRANSFERINDEX, nextIndex,                            nextBound = (nextIndex &gt; stride ?                                    nextIndex - stride : 0))) {                bound = nextBound;                i = nextIndex - 1;                advance = false;            }        }        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {            int sc;            if (finishing) {                nextTable = null;                table = nextTab;                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            }            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {                //並非最後一個退出的線程                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                               finishing = advance = true;                //異常巧妙的設計，最後一個線程推出前將i回退到最高位，等於是強制做最後一次的全表掃描；程序直接執行後續的else if代碼，看有沒有哪個槽位漏掉了，或者說是否全部是forwardingNode標記；                //可以視為抄底邏輯，雖然檢測到漏掉槽位的概率基本是0                i = n;            }        } else if ((f = tabAt(tab, i)) == null)            //空槽位直接打上forwardingNode標記，CAS失敗下一次循環繼續搬運該槽位，成功則進入下一個槽位            advance = casTabAt(tab, i, null, fwd);        else if ((fh = f.hash) == MOVED)            advance = true; //最後一次抄底遍歷時，正常情況下所有的槽位應該都被打上forwardingNode標記        else {            //鎖定頭節點            synchronized (f) {                if (tabAt(tab, i) == f) {                    Node&lt;K, V&gt; ln, hn;                    if (fh &gt;= 0) {                        //......此處省略鏈表搬運代碼:職責是將鏈表拆成兩份,搬運到nextTable的i和i+n槽位                        setTabAt(nextTab, i, ln);                         setTabAt(nextTab, i + n, hn);                        //設置舊錶對應槽位的頭節點為forwardingNode                        setTabAt(tab, i, fwd);                        advance = true;                    } else if (f instanceof TreeBin) {                        //......此處省略紅黑樹搬運代碼:職責是將紅黑樹拆成兩份,搬運到nextTable的i和i+n槽位，如果滿足紅黑樹的退化條件，順便將其退化為鏈表                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        //設置舊錶對應槽位的頭節點為forwardingNode                        setTabAt(tab, i, fwd);                        advance = true;                    }                }            }        }    }}複製代碼</code></pre><p>多個線程併發搬運時，如果是首個搬運線程，負責nextTable的初始化工作；然後藉助於全局的transferIndex變量從當前table的n-1槽位開始依次向低位掃描搬運，通過對transferIndex的CAS操作一次獲取一個區段（默認是16），當transferIndex達到最低位時，不再能夠獲取到新的區段，線程開始退出，退出時會在sizeCtl上將總的線程數減一，最後一個退出的線程將掃描座標i回退到最高位，強迫做一次抄底的全局掃描。</p><h1 class=pgc-h-arrow-right>3、transfer過程中的讀寫安全性分析</h1><p><strong>（1）首先是transfer過程中是否有可能全局的哈希表table發生多次resize，或者說存在過期的風險？</strong></p><p>觀察nextTable提交到table的代碼，發現只有在所有線程均搬運完畢退出後才會commit，所以但凡有一個線程在transfer代碼塊中，table都不可能被替換；所以不存在table過期的風險。</p><p><strong>（2）有併發的寫操作時，是否存在安全風險？</strong></p><p>因為transfer操作與寫操作都要競爭bin的頭節點的syncronized鎖，兩者是互斥串行的；當寫線程得到鎖後，還要做doubleCheck，發現不是一開始的頭節點時什麼事情都不會做，發現是forwardingNode，就會加入搬運行列直到新表被提交，然後去直接操作新表。</p><p>nextTable的提交總是在所有的槽位都已經搬運完畢，插上ForwardingNode的標識之後的，因此只要新表已提交，舊錶必定無法寫入；這樣就能夠有效的避免數據寫入舊錶。</p><p>推理：獲取到bin頭節點的同步鎖開始寫操作----------> transfer必然未完成--------->新表必然未提交-------→寫入的必然是當前表。</p><p>也就說永遠不可能存在新舊兩張表同時被寫入的情況，table被寫入時nextTable永遠都只能被讀取。</p><p><strong>（3）有併發的讀操作時，是否存在安全風險？</strong></p><p>transfer操作並不破壞舊的bin結構，如果尚未開始搬運，將會照常遍歷舊的BIN結構；如果已搬運完畢，會調用到forwadingNode的find方法到新表中遞歸查詢，參考上文中的forwadingNode介紹。</p><h1 class=pgc-h-arrow-right>九、Traverser遍歷器</h1><p>因為iterator或containsValue等通用API的存在，以及某些業務場景確實需要遍歷整個Map，設計一種安全且有性能保證的遍歷機制顯得理所當然。</p><p>C13Map遍歷器實現的難點在於讀操作與transfer可能並行，在掃描各個bin時如果遇到forwadingNode該如何處理的問題。</p><p>由於併發transfer機制的存在，在某個槽位上遇到了forwadingNode，僅表明當前槽位已被搬運，並不能代表其後的槽位一定被搬運或者尚未被搬運；也就是說其後的若干槽位是一個不可控的狀態。</p><p>解決辦法是引入了類似於方法調用堆棧的機制，在跳轉到nextTable時記錄下當前table和已經抵達的槽位並進行入棧操作，然後開始遍歷下一個table的i和i+n槽位，如果遇到forwadingNode再一次入棧，周而復始循環往復；</p><p>每次如果i+n槽位如果到了右半段快要溢出的話就會遵循原來的入棧規則進行出棧，也就是回到上一個上下文節點，最終會回到初始的table也就是initialTable中的節點。</p><p>C13Map的Traverser組件</p><pre><code>static class Traverser&lt;K,V&gt; {    Node&lt;K,V&gt;[] tab;        // current table; updated if resized    Node&lt;K,V&gt; next;         // the next entry to use    TableStack&lt;K,V&gt; stack, spare; // to save/restore on ForwardingNodes    int index;              // index of bin to use next    int baseIndex;          // current index of initial table    int baseLimit;          // index bound for initial table    final int baseSize;     // initial table size    Traverser(Node&lt;K,V&gt;[] tab, int size, int index, int limit) {        this.tab = tab;        this.baseSize = size;        this.baseIndex = this.index = index;        this.baseLimit = limit;        this.next = null;    }    /**     * 返回下一個節點     */    final Node&lt;K,V&gt; advance() {        Node&lt;K,V&gt; e;        if ((e = next) != null)            e = e.next;        for (;;) {            Node&lt;K,V&gt;[] t; int i, n;  // 局部變量保證穩定性            if (e != null)                return next = e;            if (baseIndex &gt;= baseLimit || (t = tab) == null ||                (n = t.length) &lt;= (i = index) || i &lt; 0)                return next = null;            if ((e = tabAt(t, i)) != null &amp;&amp; e.hash &lt; 0) {                if (e instanceof ForwardingNode) {                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;                    e = null;                    pushState(t, i, n);                    continue;                }                else if (e instanceof TreeBin)                    e = ((TreeBin&lt;K,V&gt;)e).first;                else                    e = null;            }            //當前如果有跳轉堆棧直接回放            if (stack != null)                recoverState(n);            //沒有跳轉堆棧說明已經到initalTable            else if ((index = i + baseSize) &gt;= n)                index = ++baseIndex; // visit upper slots if present        }    }    /**     * 遇到ForwardingNode時保存當前上下文     */    private void pushState(Node&lt;K,V&gt;[] t, int i, int n) {        TableStack&lt;K,V&gt; s = spare;  // reuse if possible        if (s != null)            spare = s.next;        else            s = new TableStack&lt;K,V&gt;();        s.tab = t;        s.length = n;        s.index = i;        s.next = stack;        stack = s;    }    /**     * 彈出上下文     *     */    private void recoverState(int n) {        TableStack&lt;K,V&gt; s; int len;        //如果當前有堆棧，且index已經到達右半段後溢出當前table,說明該回去了        //如果index還在左半段，則只輔助做index+=s.length操作        while ((s = stack) != null &amp;&amp; (index += (len = s.length)) &gt;= n) {            n = len;            index = s.index;            tab = s.tab;            s.tab = null;            TableStack&lt;K,V&gt; next = s.next;            s.next = spare; // save for reuse            stack = next;            spare = s;        }        //已經到initialTable,索引自增        if (s == null &amp;&amp; (index += baseSize) &gt;= n)            index = ++baseIndex;    }}複製代碼</code></pre><p>假設在整個遍歷過程中初始表initalTable=table1，遍歷到結束時最大的表為table5，也就是在遍歷過程中經歷了四次擴容，屬於一邊遍歷一邊擴容的最複雜場景；</p><p>那麼整個遍歷過程就是一個以初始化表initalTable為基準表，以下一張表的i和i+n槽位為forwadingNode的跳轉目標，類似於粒子裂變一般的從最低表向最高表放射的過程；</p><p>traverser並不能保證一定遍歷某張表的所有的槽位，但如果假設低階表的某個槽位在最高階表總是有相應的投影，比如table1的一個節點在table5中就會對應16個投影；</p><p>traverser能夠保證一次遍歷的所有槽位在最高階表上的投影，可以佈滿整張最高階表，而不會有任何遺漏。</p><h1 class=pgc-h-arrow-right>十、併發計數</h1><p>與HashMap中直接定義了size字段類似，獲取元素的totalCount在C13MAP中肯定不會去遍歷完整的數據結構；那樣元素較多時性能會非常差，C13MAP設計了CounterCell[]數組來解決併發計數的問題。</p><p>CounterCell[]機制並不理會新舊table的更迭，不管是操作的新表還是舊錶，對於計數而言沒有本質的差異，CounterCell[]只關注總量的增加或減少。</p><h1 class=pgc-h-arrow-right>1、從LongAdder到CounterCell內存對齊</h1><p>C13MAP借鑑了JUC中LongAdder和Striped64的計數機制，有大量代碼與LongAdder和Striped64是重複的，其核心思想是多核環境下對於64位long型數據的計數操作，雖然藉助於volatile和CAS操作能夠保證併發的安全性，但是因為多核操作的是同一內存區域，而每個CPU又有自己的本地cache，例如LV1 Cache，LVL2 Cache，寄存器等。</p><p>由於內存一致性協議MESI的存在，會導致本地Cache的頻繁刷新影響性能，一個比較好的解決思路是每個CPU只操作固定的一塊內存對齊區域，最終採用求和的方式來計數。</p><p>這種方式能提高性能，但是並非所有場景都適用，因為其最終的value是求和估算出來的，CounterCell累加求和的過程並非原子，不能代表某個時刻的精準value，所以像compareAndSet這樣的原子操作就無法支持。</p><h1 class=pgc-h-arrow-right>2、CounterCell[] 、cellBusy、baseCount的作用</h1><p>CounterCell[]中存放2的指數冪個CounterCell，併發操作期間有可能會擴容，每次擴容都是原有size的兩倍，一旦超過了CPU的核數即不再擴容，因為CPU的總數通常也是2的指數冪，所以其size往往等於CPU的核數CounterCell[]初始化、擴容、填充元素時，藉助cellBusy其進行spinLock控制baseCount是基礎數據。</p><p>在併發量不那麼大，CAS沒有出現失敗時直接基於baseCount變量做計數；一旦出現CAS失敗，說明有併發衝突，就開始考慮CounterCell[]的初始化或者擴容操作，但在初始化未完成時，還是會將其視為抄底方案進行計數。</p><p>所以最終的技術總和=baseCount+所有CounterCell中的value。</p><p>C13Map的addCount方法</p><pre><code>private final void addCount(long x, int check) {    CounterCell[] cs; long b, s;   //初始時總是直接對baseCount計數，直到出現第一次失敗，或者已經有現成的CounterCell[]數組可用    if ((cs = counterCells) != null ||        !U.compareAndSetLong(this, BASECOUNT, b = baseCount, s = b + x)) {        CounterCell c; long v; int m;        //是否存在競態，為true時表示無競態        boolean uncontended = true;        if (cs == null || (m = cs.length - 1) &lt; 0 ||            //先生成隨機數再對CounterCell[]數組size求餘,也就是隨機分配到其中某個槽位            (c = cs[ThreadLocalRandom.getProbe() &amp; m]) == null ||            !(uncontended =              U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) {            //該槽位尚未初始化或者CAS操作又出現競態            fullAddCount(x, uncontended);            return;        }        if (check &lt;= 1)            return;        s = sumCount();    }    //檢測元素總數是否超過sizeCtl閾值    if (check &gt;= 0) {        Node&lt;K,V&gt;[] tab, nt; int n, sc;        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;               (n = tab.length) &lt; MAXIMUM_CAPACITY) {            int rs = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT;            if (sc &lt; 0) {                if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||                    (nt = nextTable) == null || transferIndex &lt;= 0)                    break;                if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            }            else if (U.compareAndSetInt(this, SIZECTL, sc, rs + 2))                transfer(tab, null);            s = sumCount();        }    }}複製代碼</code></pre><p><br></p><p>其中ThreadLocalRandom是線程上下文內的隨機數生成器，可以不受其它線程的影響，提高隨機數生成的性能；總是在CAS失敗以後，也就是明確感知到存在多線程的競爭的前提下，才會對CounterCell[]進行初始化或者擴容操作。</p><p>C13Map的fullAddCount方法</p><pre><code>//完整的計數,與LongAdder的代碼基本雷同private final void fullAddCount(long x, boolean wasUncontended) {    int h;    if ((h = ThreadLocalRandom.getProbe()) == 0) {        ThreadLocalRandom.localInit();      // force initialization        h = ThreadLocalRandom.getProbe();        wasUncontended = true;    }    boolean collide = false;                // 是否有新的衝突    for (;;) {        CounterCell[] cs; CounterCell c; int n; long v;        if ((cs = counterCells) != null &amp;&amp; (n = cs.length) &gt; 0) {                   if ((c = cs[(n - 1) &amp; h]) == null) {                //隨機匹配的槽位尚未有CounterCell元素則初始化之                if (cellsBusy == 0) {            // Try to attach new Cell                    CounterCell r = new CounterCell(x); // Optimistic create                    if (cellsBusy == 0 &amp;&amp;                        U.compareAndSetInt(this, CELLSBUSY, 0, 1)) {                        boolean created = false;                        try {               // Recheck under lock                            CounterCell[] rs; int m, j;                            if ((rs = counterCells) != null &amp;&amp;                                (m = rs.length) &gt; 0 &amp;&amp;                                rs[j = (m - 1) &amp; h] == null) {                                rs[j] = r;                                created = true;                            }                        } finally {                            cellsBusy = 0;                        }                        if (created)                            break;                        continue;           // Slot is now non-empty                    }                }                collide = false;            }            else if (!wasUncontended)                      wasUncontended = true;      //fullAddCount前已經存在cas失敗但並不立即擴容，重新生成一個隨機數進行CAS重試            else if (U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))                break;            else if (counterCells != cs || n &gt;= NCPU)                collide = false;            // 超過CPU的最大核數，或者檢測到counterCells已擴容，都將衝突狀態置為無            else if (!collide)                collide = true;             // 以上的若干條件都不滿足，可以判定必定有衝突，再生成一個隨機數試探一下            else if (cellsBusy == 0 &amp;&amp;                     U.compareAndSetInt(this, CELLSBUSY, 0, 1)) {                try {                    if (counterCells == cs)   //對counterCells進行doubleCheck                        counterCells = Arrays.copyOf(cs, n &lt;&lt; 1);   //擴容，容量翻倍                } finally {                    cellsBusy = 0;                }                collide = false;                continue;                   // 對性的counterCell[]進行重試CAS操作            }            h = ThreadLocalRandom.advanceProbe(h);   //以舊的隨機數為基數生成一個新的隨機數        }        else if (cellsBusy == 0 &amp;&amp; counterCells == cs &amp;&amp;                 U.compareAndSetInt(this, CELLSBUSY, 0, 1)) {            //第一次初始化工作，初始的數組大小為2            boolean init = false;            try {                           // Initialize table                if (counterCells == cs) {                    CounterCell[] rs = new CounterCell[2];                    rs[h &amp; 1] = new CounterCell(x);                    counterCells = rs;                    init = true;                }            } finally {                cellsBusy = 0;            }            if (init)                break;        }        //初始化過程中其它線程的抄底方案        else if (U.compareAndSetLong(this, BASECOUNT, v = baseCount, v + x))            break;                            }}複製代碼</code></pre><p><br></p><p>循環生成新的隨機數匹配到新的槽位進行CAS的計數操作，出現CAS失敗後並不急於擴容；而是總是在連續出現CAS失敗的情況才會嘗試擴容。</p><p>CounterCell[]的整體方案相對獨立，與C13Map的關係並不大，可以視為一種成熟的高性能技術方案在各個場景使用。</p><h1 class=pgc-h-arrow-right>十一、與stream類似的bulk操作支持</h1><h1 class=pgc-h-arrow-right>1、bulkTask類的子類</h1><p><br></p><p>所有的批量任務執行類均為bulkTask的子類, bulkTask內置了與traverser類似的實現，用以支持對C13Map的遍歷；同時它也是ForkJoinTask的子類，支持以fork/join的方式來完成各種批量任務的執行。</p><p>因為ForkJoinTask並非本文的重點，這裡僅列出幾種有代表性的批量方法，以及相應的的task實現。</p><h1 class=pgc-h-arrow-right>2、幾種有代表性的批量方法</h1><p>C13Map的批量任務</p><pre><code>//將所有的entry按照transformer函數進行二元計算，再對所有生成的結果執行action一元函數public &lt;U&gt; void forEach(long parallelismThreshold,                        BiFunction&lt;? super K, ? super V, ? extends U&gt; transformer,                        Consumer&lt;? super U&gt; action);//對所有的entry執行searchFunction二元計算，一旦發現任意一個計算結果不為null，即全盤返回public &lt;U&gt; U search(long parallelismThreshold,                    BiFunction&lt;? super K, ? super V, ? extends U&gt; searchFunction);//對所有的entry執行transformer二元計算，再對所有的結果執行reducer收斂函數public &lt;U&gt; U reduce(long parallelismThreshold,                    BiFunction&lt;? super K, ? super V, ? extends U&gt; transformer,                    BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer)//對所有的entry中的value執行transformer二元計算，再對所有的結果執行reducer收斂函數public &lt;U&gt; U reduceValues(long parallelismThreshold,                          Function&lt;? super V, ? extends U&gt; transformer,                          BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer)複製代碼</code></pre><p><br></p><p>以上所有的批量方法都有唯一與其對應的批量task執行類，背後均是基於fork/join思想實現。</p><h1 class=pgc-h-arrow-right>3、批量task的實現</h1><p>以2中列出的reduce方法所對應的MapReduceMappingsTask為例，有關fork/join中的實現細節不屬於本文的範疇，不做詳細討論。</p><p>C13Map的MapReduceMappingsTask</p><pre><code>static final class MapReduceMappingsTask&lt;K,V,U&gt; extends BulkTask&lt;K,V,U&gt; {    final BiFunction&lt;? super K, ? super V, ? extends U&gt; transformer;    final BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer;    U result;    MapReduceMappingsTask&lt;K,V,U&gt; rights, nextRight;    MapReduceMappingsTask        (BulkTask&lt;K,V,?&gt; p, int b, int i, int f, Node&lt;K,V&gt;[] t,         MapReduceMappingsTask&lt;K,V,U&gt; nextRight,         BiFunction&lt;? super K, ? super V, ? extends U&gt; transformer,         BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer) {        super(p, b, i, f, t); this.nextRight = nextRight;        this.transformer = transformer;        this.reducer = reducer;    }    public final U getRawResult() { return result; }    public final void compute() {        final BiFunction&lt;? super K, ? super V, ? extends U&gt; transformer;        final BiFunction&lt;? super U, ? super U, ? extends U&gt; reducer;        if ((transformer = this.transformer) != null &amp;&amp;            (reducer = this.reducer) != null) {            for (int i = baseIndex, f, h; batch &gt; 0 &amp;&amp;                     (h = ((f = baseLimit) + i) &gt;&gt;&gt; 1) &gt; i;) {                addToPendingCount(1);                //裂變出新的fork-join任務                (rights = new MapReduceMappingsTask&lt;K,V,U&gt;                 (this, batch &gt;&gt;&gt;= 1, baseLimit = h, f, tab,                  rights, transformer, reducer)).fork();            }            U r = null;            //遍歷本batch元素            for (Node&lt;K,V&gt; p; (p = advance()) != null; ) {                U u;                //對本batch做reduce收斂操作                if ((u = transformer.apply(p.key, p.val)) != null)                    r = (r == null) ? u : reducer.apply(r, u);            }            //對自己和自己fork出的子任務做reducer收斂操作            result = r;            CountedCompleter&lt;?&gt; c;            for (c = firstComplete(); c != null; c = c.nextComplete()) {                @SuppressWarnings("unchecked")                MapReduceMappingsTask&lt;K,V,U&gt;                    t = (MapReduceMappingsTask&lt;K,V,U&gt;)c,                    s = t.rights;                while (s != null) {                    U tr, sr;                    if ((sr = s.result) != null)                        t.result = (((tr = t.result) == null) ? sr :                                    reducer.apply(tr, sr));                    s = t.rights = s.nextRight;                }            }        }    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>十二、小結</h1><p>自JDK8開始C13Map摒棄了JDK7中的Segment段實現方案，將鎖的粒度細化到了每個bin上，鎖的粒度更小併發能力更強。用syncronized關鍵字代替原先的ReentrantLock互斥鎖，因JDK8中對syncronized做了大量優化，可以達到比ReentrantLock更優的性能。</p><p>引入併發transfer的機制支持多線程搬運，寫操作和transfer操作在不同bin上可並行。引入ForwardingNode支持讀操作和transfer並行，並進一步支持transfer過程有可能存在的哈希錶鏈的遍歷。引入ReserveNode在compute原子計算可能耗時較長的情況下搶先佔位，避免重複計算。</p><p>引入紅黑樹來優化哈希衝突時的檢索性能，其內部實現了輕量級的讀寫鎖保證讀寫安全，在線性檢索和tree檢索之間做了智能切換，達到了性能與安全的極佳的平衡。引入CounterCell機制優化多核場景的計數，解決內存偽共享問題。</p><p>引入 ForkJoinTask的子類優化bulk計算時的性能。整個C13Map的實現過程大量使用volatile保證可見，使用CAS保證原子，是一種局部無鎖的lockFree dataStructure的典範實現。</p><p>與HashMap的單線程讀寫操作不同的是，HashMap讀到的數據在下一次寫操作間是一直穩定的，在多個寫操作之間是一個穩定的snapshot，而C13Map因為併發線程的存在，數據瞬息萬變，讀到的永遠只是某個時間點的正確數據，寫入成功也只是在某個時間點保證寫入是安全的，因此C13Map通常只談安全而不談實時，這極大提高了編程的難度，也是單線程和併發數據結構之間的明顯差異。</p><p><br>鏈接：https://juejin.im/post/6874771578685489165<br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JavaConcurrentHashMap</a></li><li><a>解析</a></li><li><a>原理</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/31bf5ba.html alt=全面解析泵的結構和原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fc707344140b4dbaa30029d7c0827f5f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/31bf5ba.html title=全面解析泵的結構和原理>全面解析泵的結構和原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4adca96d.html alt=不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532917894689e20edadba9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4adca96d.html title=不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹>不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html alt=解析橋樑設計計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa4d0bcf2a204a2fac9b37978b1b0713 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html title=解析橋樑設計計算>解析橋樑設計計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/798c35eb.html alt=鼠標滾輪工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a32f01002df34196a3ca95824a0705c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/798c35eb.html title=鼠標滾輪工作原理>鼠標滾輪工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b0fcc3c2.html alt=來看看，什麼是高解析數字音頻！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153562218779909d30fcdab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b0fcc3c2.html title=來看看，什麼是高解析數字音頻！>來看看，什麼是高解析數字音頻！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a2e8d15.html alt=常見數字音頻格式解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/6c2f000314f485982daf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a2e8d15.html title=常見數字音頻格式解析>常見數字音頻格式解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fe7a863.html alt=土壤採樣器的工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3591b04ce0ef4b24b7f04dcf6d4f0e5a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fe7a863.html title=土壤採樣器的工作原理>土壤採樣器的工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c9afde0.html alt="一起來談談ThreadLocal 原理吧！你需要了解！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/499a403f2b63464db8e3e12298c1a3e5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c9afde0.html title="一起來談談ThreadLocal 原理吧！你需要了解！">一起來談談ThreadLocal 原理吧！你需要了解！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/203dfed4.html alt=和麵機的原理及運用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1bd01e6484624601ae66ef141b0cdbd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/203dfed4.html title=和麵機的原理及運用>和麵機的原理及運用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2537ec20.html alt=和麵機的工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/01f3205782f045a2a5aec20d70b9efc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2537ec20.html title=和麵機的工作原理>和麵機的工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16005ce4.html alt=2020年註冊測繪師職業資格考試測繪綜合能力試卷及答案和解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ba39c80703f74d0b8f209ada195d71a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16005ce4.html title=2020年註冊測繪師職業資格考試測繪綜合能力試卷及答案和解析>2020年註冊測繪師職業資格考試測繪綜合能力試卷及答案和解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ac331a0.html alt=功率因素表的工作原理及接線方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/470a0003e8a9a1d2d829 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ac331a0.html title=功率因素表的工作原理及接線方式>功率因素表的工作原理及接線方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/504d903f.html alt=疊加原理及其應用（第1集） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/504d903f.html title=疊加原理及其應用（第1集）>疊加原理及其應用（第1集）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b9eda782.html alt=製冷原理和製冷循環原理，製冷劑在循環中什麼狀態？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/304eeaadf64047798a7c26b9d06a7987 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b9eda782.html title=製冷原理和製冷循環原理，製冷劑在循環中什麼狀態？>製冷原理和製冷循環原理，製冷劑在循環中什麼狀態？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd0589ca.html alt=溼式報警閥組工作原理及火警聯動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/54f715f0f1cf45ec93d3be6f2e77be54 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd0589ca.html title=溼式報警閥組工作原理及火警聯動>溼式報警閥組工作原理及火警聯動</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>