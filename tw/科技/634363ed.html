<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>InnoDB事務原理講解 | 极客快訊</title><meta property="og:title" content="InnoDB事務原理講解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/024a3c3bb3fc419ea01e5bda6640fd73"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/634363ed.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/634363ed.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/634363ed.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/634363ed.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/634363ed.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/634363ed.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/634363ed.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/634363ed.html><meta property="article:published_time" content="2020-11-14T21:00:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:21+08:00"><meta name=Keywords content><meta name=description content="InnoDB事務原理講解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/634363ed.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>InnoDB事務原理講解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>本文準備通俗的講解MySQL的InnoDB存儲引擎事務的實現原理。</p><p>首先，我們知道事務具有ACID四個特性。也即：原子性，一致性，隔離性，持久性。</p><p>這四個性質我們不用幹癟的文字去闡述，我們只需要知道事務保證了一系列的操作要麼全部執行，要麼一個也不執行，同時一旦事務提交，則其所做的修改會永久保存到數據庫即可。</p><p>接下來我們一起看看InnoDB怎麼實現的事務。</p><p>ACD三個特性是通過Redo log（重做日誌）和Undo log 實現的。 而隔離性是通過鎖來實現的。由於隔離性和鎖在之前的文章講過了。所以本文重點關注Redo log 和Undo log。</p><p>一、Redo log</p><p>重做日誌用來實現事務的持久性，即D特性。它由兩部分組成：</p><p>①內存中的重做日誌緩衝</p><p>②重做日誌文件</p><p>一看有內存和磁盤上的兩個對應實體，我們就知道這樣做一定是為了效率考慮，因為內存的讀寫效率要比磁盤讀寫效率高太多。</p><p>Innodb是支持事務的存儲引擎，在事務提交時，必須先將該事務的所有日誌寫入到redo日誌文件中，待事務的commit操作完成才算整個事務操作完成。在每次將redo log buffer寫入redo log file後，都需要調用一次fsync操作，因為重做日誌緩衝只是把內容先寫入操作系統的緩衝系統中，並沒有確保直接寫入到磁盤上，所以必須進行一次fsync操作。因此，磁盤的性能在一定程度上也決定了事務提交的性能。</p><blockquote><p>關於fsync這個操作用戶是可以干預的，因為每次提交事務都執行一次fsync，確實影響數據庫性能。通過innodb_flush_log_at_trx_commit來控制redo log刷新到磁盤的策略。該參數的默認值為1，表示每次提交事務時都執行一次fsync操作。0則表示事務提交時不進行寫入重做日誌文件，這個寫入操作由master thread進程來完成，master thread每一秒會進行一次重做日誌文件的fsync操作。2則表示事務提交時將重做日誌寫入重做日誌文件，但僅寫入文件系統的緩存中，並不進行fsync操作。用戶可以通過設置0或者2啦提高事務提交的性能，也可以設置1來要求確保redo log是寫入文件中的，總之三種方法各有利弊。</p><p><strong>還有需要了解的是：</strong></p><p>redo log buffer將內存中的log block刷新到磁盤是有一定的規則的：事務提交時(前面已經提到)、當log buffer中有一半的內存空間被使用時、log checkpoint時。</p></blockquote><p>那接下來我們就需要看看redo log file存儲的內容到底是什麼了。</p><p>為了避免大家懵圈，不打算把存儲格式一個一個細鑽（我也沒那實力，哈哈）。我們只需要知道他大致是怎麼設計的就行了。這樣，我們以後如果自己設計一個類似場景的產品，就完全可以借鑑它的設計思想啦。</p><p>好，開始：</p><p>在InnoDB存儲引擎中，重做日誌都是以512字節為單位進行存儲的，這意味著重做日誌緩存、重做日誌文件塊都是以塊（block）的方式進行保存的，稱為重做日誌塊(redo log block)。每塊的大小512字節。由於重做日誌塊的大小和磁盤扇區大小一樣，都是512字節，因此重做日誌的寫入可以保證原子性，不需要double write技術。</p><p>每個重做日誌塊的內容快除了日誌記錄本身之外，還由日誌塊頭(log block header)及日誌塊尾(log block tailer)兩部分組成。重做日誌頭一共佔用12字節，重做日誌尾佔用8字節。這兩部分是固定的。故每個重做日誌塊實際可以存儲的大小為492字節(512-12-8)，如下圖顯示重做日誌塊緩存的結構：</p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/024a3c3bb3fc419ea01e5bda6640fd73><p class=pgc-img-caption></p></div><p>在圖中標註出來不用太過關注這幾個字段的含義，因為他們對理解Redo log實現事務的機制沒有太大影響，反而如果關注這些，容易讓人看到這些大寫字母的變量感到頭暈。</p><p><strong>ps:</strong>這些變量是維護log block狀態的一些變量。比如表示log block當前使用量，當前redo block的第一個redo log開始位置等等。舉個例子吧：</p><p>事務T1的重做日誌1佔用762字節，事務T2的重做日誌佔用100字節，。由於每個log block實際只能保存492字節，因此其在log buffer的情況應該如下圖所示：</p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbbeb063b5cc41dd9d6a78e5a96eca6b><p class=pgc-img-caption></p></div><p>實現這個功能就是靠log block的頭部的字段來實現的。好了，這不是我們關注的問題，講這個只是為了滿足大家的好奇心以及對這些變量的初步認識。</p><p>重做日誌塊中出去header和tailer的內容就是具體的redo log了。不同的數據庫操作會有對應的重做日誌格式。此外，由於InnoDB存儲引擎的存儲管理是基於頁的，故其重做日誌格式也是基於頁的。雖然有著不同的重做日誌格式，但他們有著通用的頭部格式，如圖：</p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/57fd5ece3e6e4fbfbe884fa1f2af0725><p class=pgc-img-caption></p></div><p>通用的頭部格式由一下3部分組成</p><p><strong>redo_log_type：</strong> 重做日誌類型</p><p><strong>space:</strong>表空間ID</p><p><strong>page_no</strong> 頁的偏移量即頁的位置</p><p>之後是redo log body ，根據重做日誌類型的不同，會有不同的存儲內容，例如，對於頁上記錄的插入和刪除操作，分別對應的如圖的格式（同樣，不要細扣每一個字段的含義，這不是我們要抓的重點）：</p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c50a891957f1482fad900c69fede9709><p class=pgc-img-caption></p></div><p>大體上的redo log結構介紹完了。在說從redo log file恢復之前，還要說一個LSN的概念，LSN是Log Sequence Number的縮寫，其代表的是日誌序列號，在InnoDB存儲引擎中，LSN佔用8個字節，並且單調遞增。</p><p>LSN表示事務寫入重做日誌字節的總量。例如當前重做日誌的LSN為1000，有一個事務T1寫入了100字節的重做日誌，那麼LSN就變成1100，若又有事務T2寫入200字節的重做日誌，那麼LSN就變為1300。</p><p>LSN不僅記錄在重做日誌中，還存在每個頁中，在每個頁的頭部，有一個值FIL_PAGE_LSN，記錄了該頁的LSN，在頁中，LSN表示該頁最後刷新時LSN的大小。因為重做日誌記錄的是每個頁的日誌，因此頁中的LSN可以判斷頁是否需要進行恢復操作。例如，頁P1的LSN為10000，而數據庫啟動時，InnoDB檢測到寫入重做日誌中的LSN為13000，並且事務已經提交，那麼數據庫需要進行恢復操作。將重做日誌應用到P1頁中，同樣的，對於重做日誌中LSN小於P1頁的LSN，不需要進行重做，因為P1頁中的LSN表示已經被刷新到該位置，在此位置之前的內容已經被成功的處理了。</p><p>接下來就是恢復操作了：</p><p>InnoDB存儲引擎在啟動時不管上次數據運行是否正常關閉，都會嘗試進行恢復操作，因為重做日誌記錄的是物理日誌（不要糾結這個），因此恢復的速度比邏輯日誌，如二進制日誌要快的多，於此同時，InnoDB存儲引擎自身也對恢復進行了一定程度的優化，如順序讀取及並行應用重做日誌，這樣可以進一步提高數據庫恢復的速度</p><p>由於checkpoint表示已經刷新到磁盤頁上的LSN，因此在恢復過程中僅需恢復checkpoint開始的日誌部分。對於圖中的例子，當數據庫在checkpoint的LSN為10 000時發生宕機，恢復操作僅恢復LSN 10000~13000範圍內的日誌。</p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/926bc6f1a14b451f808f0811e99402f4><p class=pgc-img-caption></p></div><blockquote><p>物理日誌</p><p>舉個例子，對於Insert操作，物理日誌記錄的是每個頁的變化：</p><p>若執行SQL語句：</p><p>INSERT INTO t SELECT 1,2;</p><p>其記錄的重做日誌大致類似這個樣子：</p><p>page(2,3),offset 32,value 1,2</p></blockquote><p>二、Undo log</p><p>第二部分是Undo log，它可以實現如下兩個<strong>功能：</strong></p><p>1.實現事務回滾</p><p>2.實現MVCC</p><p>undo log和redo log記錄物理日誌不一樣，它是邏輯日誌。可以認為當delete一條記錄時，undo log中會記錄一條對應的insert記錄，反之亦然，當update一條記錄時，它記錄一條對應相反的update記錄。</p><p>當執行回滾時，就可以從undo log中的邏輯記錄讀取到相應的內容並進行回滾。有時候應用到行版本控制的時候，也是通過undo log來實現的：當讀取的某一行被其他事務鎖定時，它可以從undo log中分析出該行記錄以前的數據是什麼，從而提供該行版本信息，幫助用戶實現一致性非鎖定讀取。我們舉一個具體的例子。例子來自此文。</p><p>這個例子主要演示事務對某行記錄的更新過程：</p><blockquote><p>在演示之前，補充一下：</p><p>InnoDB為每行記錄都實現了三個隱藏字段，用來實現MVCC：</p></blockquote><ul><li>6字節的事務ID（DB_TRX_ID ,每處理一個事務，其值自動+1。</li><li>7字節的回滾指針（DB_ROLL_PTR），指向寫到rollback segment（回滾段）的一條undo log記錄。</li><li>隱藏的ID</li></ul><p><strong>1. 初始數據行</strong></p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/74ae8a3aa76f4d65889cacabb3bb73ab><p class=pgc-img-caption></p></div><p>F1～F6是某行列的名字，1～6是其對應的數據。後面三個隱含字段分別對應該行的事務號和回滾指針，假如這條數據是剛INSERT的，可以認為ID為1，其他兩個字段為空。</p><p><strong>2.事務1更改該行的各字段的值</strong></p><p>當事務1更改該行的值時，會進行如下操作：</p><ul><li>用排他鎖鎖定該行</li><li>記錄redo log</li><li>把該行修改前的值Copy（可以理解成Copy，不要糾結前面說反向更新這裡說複製，原理是一樣的）到undo log，即上圖中下面的行</li><li>修改當前行的值，填寫事務編號，使回滾指針指向undo log中的修改前的行。</li></ul><p><strong>3.事務2修改該行的值</strong></p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bcf7bd14bb1841a0aa73f65d0c65745b><p class=pgc-img-caption></p></div><p>與事務1相同，此時undo log，中有有兩行記錄，並且通過回滾指針連在一起。</p><p>這些通過回滾指針聯繫起來的行相當於是數據的多個快照，從而實現MVCC的一致性非鎖定讀了。</p><p>具體規則如下：</p><p>InnoDB的MVCC，是通過上面我們說的每行紀錄後面隱藏的列來實現的。他們保存了行的創建時間和行的過期時間（或刪除時間），當然存儲的並不是實際的時間值，而是系統版本號。每開始一個新的事務，系統版本號都會自動遞增。事務開始時刻的系統版本號會作為事務的版本號，用來和查詢到的每行紀錄的版本號進行比較。在REPEATABLE READ隔離級別下，MVCC具體的操作如下：</p><p>SELECT</p><p>InnoDB會根據以下兩個條件檢查每行紀錄：</p><ul><li>InnoDB只查找版本早於當前事務版本的數據行，即，行的系統版本號小於或等於事務的系統版本號，這樣可以確保事務讀取的行，要麼是在事務開始前已經存在的，要麼是事務自身插入或者修改過的。</li><li>行的刪除版本，要麼未定義，要麼大於當前事務版本號。這樣可以確保事務讀取到的行，在事務開始之前未被刪除。</li><li>只有符合上述兩個條件的紀錄，才能作為查詢結果返回。</li></ul><p>INSERT</p><ul><li>InnoDB為插入的每一行保存當前系統版本號作為行版本號。</li></ul><p>DELETE</p><ul><li>InnoDB為刪除的每一行保存當前系統版本號作為行刪除標識。</li></ul><p>UPDATE</p><ul><li>InnoDB為插入一行新紀錄，保存當前系統版本號作為行版本號，同時，保存當前系統版本號到原來的行作為行刪除標識。</li></ul><p>讀到這裡，也許會有一個疑問，考慮如下執行序列：</p><div class=pgc-img><img alt=InnoDB事務原理講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46def86db6be40f5a67b60d6147c7197><p class=pgc-img-caption></p></div><p>011.png</p><p>按照之前的Select規則，會話B 的事務是在 會話A的後面開啟的，那麼B的事務版本號大於A的事務版本號。這樣在A中插入的數據在未提交的情況下，B可以讀到A修改的數據，這不就自相矛盾了麼？</p><p>其實不是，InnoDB通過read view來確定一致性讀時的數據庫snapshot,InnoDB的read view確定一條記錄能否看到,有兩條法則 ：</p><p>1 看不到read view創建時刻以後啟動的事務</p><p>2 看不到read view創建時活躍的事務</p><p>對於Session A，start transaction時並沒有創建read view，而是在update語句才創建。所以Session A 的read view創建時間要比Session B的晚。所以B是不會看到A的操作的。因此防止了不可重複讀。</p><blockquote><p>兩條法則原文描述如下：</p><p><strong>Rule 1:</strong> When the read view object is created it notes down the smallest transaction identifier that is not yet used as a transaction identifier (trx_sys_t::max_trx_id). The read view calls it the low limit. So the transaction using the read view must not see any transaction with identifier greater than or equal to this low limit.</p><p><strong>Rule 2:</strong> The transaction using the read view must not see a transaction that was active when the read view was created.</p><p>補充：如果undo log一直不刪除，則會通過當前記錄的回滾指針回溯到該行創建時的初始內容，所幸的時在Innodb中存在purge線程，它會查詢那些比現在最老的活動事務還早的undo log，並刪除它們，從而保證undo log文件不至於無限增長。</p></blockquote><p>作者：小北覓</p><p>鏈接：https://www.jianshu.com/p/9b83ea78b380</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>InnoDB</a></li><li><a>事務</a></li><li><a>講解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/0b9067b.html alt="@Transactional（事務講解）和springboot 整合事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/73f3020aa84e470a966e40a6302f6c00 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/0b9067b.html title="@Transactional（事務講解）和springboot 整合事務">@Transactional（事務講解）和springboot 整合事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8234770.html alt=關於齒輪常識由淺及深講解透徹，推薦收藏！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4e18dad6a34c44ed850916d34339092b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8234770.html title=關於齒輪常識由淺及深講解透徹，推薦收藏！>關於齒輪常識由淺及深講解透徹，推薦收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/189fa616.html alt=驅動橋設計講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/eb89bb6bddcb4755b82277febac75960 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/189fa616.html title=驅動橋設計講解>驅動橋設計講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html alt=Mysql事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html title=Mysql事務>Mysql事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html alt=SpringBoot事務詳細簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html title=SpringBoot事務詳細簡介>SpringBoot事務詳細簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html alt=SqlServer使用事務注意事項，高級程序員必背 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html title=SqlServer使用事務注意事項，高級程序員必背>SqlServer使用事務注意事項，高級程序員必背</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>