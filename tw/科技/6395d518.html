<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux內核網絡設備驅動 | 极客快訊</title><meta property="og:title" content="Linux內核網絡設備驅動 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/a142a9a74ca54da4851cedb3505e52ef"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6395d518.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6395d518.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6395d518.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6395d518.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6395d518.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6395d518.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6395d518.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6395d518.html><meta property="article:published_time" content="2020-11-14T21:02:19+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:19+08:00"><meta name=Keywords content><meta name=description content="Linux內核網絡設備驅動"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6395d518.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux內核網絡設備驅動</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1. </strong>接收數據包過程概述</p><p style=text-align:justify>介紹數據包收包過程，有助於我們瞭解Linux內核網絡設備在數據收包過程中的位置，下面從宏觀的角度介紹數據包從被網卡接收到進入 socket 接收隊列的整個過程：</p><ul><li>加載網卡驅動，初始化</li><li>數據包從外部網絡進入網卡</li><li>網卡（通過DMA）將包拷貝到內核內存中的ring buffer</li><li>產生硬件中斷，通知系統收到了一個包</li><li>驅動調用 NAPI ，如果輪詢（poll）還沒有開始，就開始輪詢</li><li>ksoftirqd軟中斷調用 NAPI 的poll函數從ring buffer收包（poll 函數是網卡驅動在初始化階段註冊的；每個cpu上都運行著一個ksoftirqd進程，在系統啟動期間就註冊了）</li><li>ring buffer裡面對應的內存區域解除映射（unmapped）</li><li>如果 packet steering 功能打開，或者網卡有多隊列，網卡收到的數據包會被分發到多個cpu</li><li>數據包從隊列進入協議層</li><li>協議層處理數據包</li><li>數據包從協議層進入相應 socket 的接收隊列</li></ul><h1 class=pgc-h-arrow-right><strong>2. 網絡設備初始化</strong></h1><p style=text-align:justify>下面以常見的Intel I350 網卡的驅動 ibg 為例介紹它的工作過程：</p><h1 class=pgc-h-arrow-right><strong>2.1 初始化</strong></h1><p style=text-align:justify>驅動會使用module_init向內核註冊一個初始化函數，當驅動被加載時，內核會調用這個函數。在drivers/net/ethernet/intel/igb/igb_main.c中初始化函數（igb_init_module）：</p><pre><code>/** *  igb_init_module - Driver Registration Routine * *  igb_init_module is the first routine called when the driver is *  loaded. All it does is register with the PCI subsystem. **/static int __init igb_init_module(void){  int ret;  pr_info("%s - version %s\n", igb_driver_string, igb_driver_version);  pr_info("%s\n", igb_copyright);  /* ... */  ret = pci_register_driver(&amp;igb_driver);  return ret;}module_init(igb_init_module);</code></pre><p>初始化的大部分工作在pci_register_driver中完成。</p><h1 class=pgc-h-arrow-right><strong>2.2 PCI初始化</strong></h1><p style=text-align:justify>Intel I350 網卡是 PCI express 設備。PCI 設備通過PCI Configuration Space 裡面的寄存器識別自己。</p><blockquote><p>PCI express 總線是一種完全不同於過去PCI總線的一種全新總線規範，與PCI總線共享並行架構相比，PCI Express總線是一種點對點串行連接的設備連接方式，點對點意味著每一個PCI Express設備都擁有自己獨立的數據連接，各個設備之間併發的數據傳輸互不影響，而對於過去PCI那種共享總線方式，PCI總線上只能有一個設備進行通信，一旦PCI總線上掛接的設備增多，每個設備的實際傳輸速率就會下降，性能得不到保證。PCI Express以點對點的方式處理通信，每個設備在要求傳輸數據的時候各自建立自己的傳輸通道，對於其他設備這個通道是封閉的，這樣的操作保證了通道的專有性，避免其他設備的干擾。</p></blockquote><p style=text-align:justify>當設備驅動編譯時，MODULE_DEVICE_TABLE 宏（定義在 include/module.h） 會導出一個 PCI 設備 ID 列表（a table of PCI device IDs），驅動據此識別它可以控制的設備，內核也會依據這個列表對不同設備加載相應驅動。</p><p style=text-align:justify>igb 驅動的設備表和 PCI 設備 ID 分別見：drivers/net/ethernet/intel/igb/igb_main.c 和drivers/net/ethernet/intel/igb/e1000_hw.h。</p><pre><code>static DEFINE_PCI_DEVICE_TABLE(igb_pci_tbl) = {  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_1GBPS) },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_SGMII) },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_2_5GBPS) },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I211_COPPER), board_82575 },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER), board_82575 },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_FIBER), board_82575 },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES), board_82575 },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SGMII), board_82575 },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER_FLASHLESS), board_82575 },  { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES_FLASHLESS), board_82575 },  /* ... */};MODULE_DEVICE_TABLE(pci, igb_pci_tbl);</code></pre><p>前面提到，驅動初始化的時候會調用 pci_register_driver，這個函數會將該驅動的各種回調方法註冊到一個 struct pci_driver 變量，drivers/net/ethernet/intel/igb/igb_main.c：</p><pre><code>static struct pci_driver igb_driver = {  .name     = igb_driver_name,  .id_table = igb_pci_tbl,  .probe    = igb_probe,  .remove   = igb_remove,  /* ... */};</code></pre><h1 class=pgc-h-arrow-right><strong>2.3 網絡設備初始化</strong><br></h1><p style=text-align:justify>通過 PCI ID 識別設備後，內核就會為它選擇合適的驅動。每個 PCI 驅動註冊了一個 probe() 方法，內核會對每個設備依次調用其驅動的 probe 方法，一旦找到一個合適的驅動，就不會再為這個設備嘗試其他驅動。</p><p style=text-align:justify>很多驅動都需要大量代碼來使得設備 ready，具體做的事情各有差異。典型的過程：</p><ul><li>啟用 PCI 設備</li><li>請求（requesting）內存範圍和 IO 端口</li><li>設置 DMA 掩碼</li><li>註冊設備驅動支持的 ethtool 方法（後面介紹）</li><li>註冊所需的 watchdog（例如，e1000e 有一個檢測設備是否僵死的 watchdog）</li><li>其他和具體設備相關的事情，例如一些 workaround，或者特定硬件的非常規處理</li><li>創建、初始化和註冊一個 struct net_device_ops 類型變量，這個變量包含了用於設備相關的回調函數，例如打開設備、發送數據到網絡、設置 MAC 地址等</li><li>創建、初始化和註冊一個更高層的 struct net_device 類型變量（一個變量就代表了 一個設備）</li></ul><p style=text-align:justify>下面來看 igb 驅動的 igb_probe 包含哪些過程（drivers/net/ethernet/intel/igb/igb_main.c）：</p><pre><code>err = pci_enable_device_mem(pdev);/* ... */err = dma_set_mask_and_coherent(&amp;pdev-&gt;dev, DMA_BIT_MASK(64));/* ... */err = pci_request_selected_regions(pdev, pci_select_bars(pdev,           IORESOURCE_MEM),           igb_driver_name);pci_enable_pcie_error_reporting(pdev);pci_set_master(pdev);pci_save_state(pdev);</code></pre><p>更詳細的過程可以查看內核文檔：https://github.com/torvalds/linux/blob/v3.13/Documentation/PCI/pci.txt</p><h1 class=pgc-h-arrow-right><strong>3. 網絡設備啟動</strong></h1><p style=text-align:justify>igb_probe 做了很多重要的設備初始化工作。除了 PCI 相關的，還有如下一些通用網絡功能和網絡設備相關的工作：</p><ul><li>註冊 struct net_device_ops 變量</li><li>註冊 ethtool 相關的方法</li><li>從網卡獲取默認 MAC 地址</li><li>設置 net_device 特性標記</li></ul><h1 class=pgc-h-arrow-right><strong>3.1 struct net_device_ops</strong></h1><p style=text-align:justify>網絡設備相關的操作函數都註冊到struct net_device_ops類型的變量中（drivers/net/ethernet/intel/igb/igb_main.c）:</p><pre><code>static const struct net_device_ops igb_netdev_ops = {  .ndo_open               = igb_open,  .ndo_stop               = igb_close,  .ndo_start_xmit         = igb_xmit_frame,  .ndo_get_stats64        = igb_get_stats64,  .ndo_set_rx_mode        = igb_set_rx_mode,  .ndo_set_mac_address    = igb_set_mac,  .ndo_change_mtu         = igb_change_mtu,  .ndo_do_ioctl           = igb_ioctl,  /* ... */</code></pre><p>這個變量會在 igb_probe()中賦給 struct net_device 中的netdev_ops字段：</p><pre><code>static int igb_probe(struct pci_dev *pdev, const struct pci_device_id *ent){  ...  netdev-&gt;netdev_ops = &amp;igb_netdev_ops;}</code></pre><h1 class=pgc-h-arrow-right><strong>3.2 ethtool 函數註冊</strong><br></h1><p style=text-align:justify>ethtool 是一個命令行工具，可以查看和修改網絡設備的一些配置，常用於收集網卡統計數據。在 Ubuntu 上，可以 通過 apt-get install ethtool 安裝，過會演示通過此工具監控網卡數據。</p><p style=text-align:justify>ethtool 通過 ioctl 和設備驅動通信。內核實現了一個通用 ethtool 接口，網卡驅動實現這些接口，就可以被 ethtool 調用。當 ethtool 發起一個系統調用之後，內核會找到對應操作的回調函數 。回調實現了各種簡單或複雜的函數，簡單的如改變一個 flag 值，複雜的包括調整網卡硬件如何運行。</p><p style=text-align:justify>相關實現見:drivers/net/ethernet/intel/igb/igb_ethtool.c。</p><h1 class=pgc-h-arrow-right><strong>3.3 軟中斷</strong></h1><p style=text-align:justify>當一個數據幀通過 DMA 寫到 RAM（內存）後，網卡是如何通知其他系統這個包可以被處理了呢？</p><p style=text-align:justify>傳統的方式是，網卡會產生一個硬件中斷（IRQ），通知數據包到了。有三種常見的硬中斷類型：</p><ul><li>MSI-X</li><li>MSI</li><li>legacy IRQ</li></ul><p style=text-align:justify>如果有大量的數據包到達，就會產生大量的硬件中斷。CPU 忙於處理硬件中斷的時候，可用於處理其他任務的時間就會減少。</p><p style=text-align:justify>NAPI（New API）是一種新的機制，可以減少產生的硬件中斷的數量（但不能完全消除硬中斷 ）。</p><h1 class=pgc-h-arrow-right><strong>3.4 NAPI</strong></h1><p style=text-align:justify>NAPI 接收數據包的方式和傳統方式不同，它允許設備驅動註冊一個 poll 方法，然後調用這個方法完成收包。</p><p style=text-align:justify>NAPI 的使用方式：</p><ul><li>驅動打開 NAPI 功能，默認處於未工作狀態（沒有在收包）</li><li>數據包到達，網卡通過 DMA 寫到內存</li><li>網卡觸發一個硬中斷，中斷處理函數開始執行</li><li>軟中斷（softirq），喚醒 NAPI 子系統。這會觸發在一個單獨的線程裡， 調用驅動註冊的 poll 方法收包</li><li>驅動禁止網卡產生新的硬件中斷，這樣做是為了 NAPI 能夠在收包的時候不會被新的中斷打擾</li><li>一旦沒有包需要收了，NAPI 關閉，網卡的硬中斷重新開啟</li><li>轉步驟 2</li></ul><p style=text-align:justify>和傳統方式相比，NAPI 一次中斷會接收多個包，因此可以減少硬件中斷的數量。</p><p style=text-align:justify>poll 方法是通過調用 netif_napi_add 註冊到 NAPI 的，同時還可以指定權重 weight，大部分驅動都 hardcode 為 64。</p><p style=text-align:justify>通常來說，驅動在初始化的時候註冊 NAPI poll 方法。</p><h1 class=pgc-h-arrow-right><strong>3.5 igb 驅動的 NAPI 初始化</strong></h1><p style=text-align:justify>igb 驅動的初始化過程是一個很長的調用鏈：</p><ul><li>igb_probe -> igb_sw_init</li><li>igb_sw_init -> igb_init_interrupt_scheme</li><li>igb_init_interrupt_scheme -> igb_alloc_q_vectors</li><li>igb_alloc_q_vectors -> igb_alloc_q_vector</li><li>igb_alloc_q_vector -> netif_napi_add</li></ul><p style=text-align:justify>從宏觀角度來看，這個調用過程會做以下事情：</p><ul><li>如果支持 MSI-X，調用 pci_enable_msix 打開它</li><li>計算和初始化一些配置，包括網卡收發隊列的數量</li><li>調用 igb_alloc_q_vector 創建每個發送和接收隊列</li><li>igb_alloc_q_vector 會進一步調用 netif_napi_add 註冊 poll 方法到 NAPI 變量</li></ul><p style=text-align:justify>下面介紹 igb_alloc_q_vector 是如何註冊 poll 方法和私有數據的（drivers/net/ethernet/intel/igb/igb_main.c）：</p><pre><code>static int igb_alloc_q_vector(struct igb_adapter *adapter,                              int v_count, int v_idx,                              int txr_count, int txr_idx,                              int rxr_count, int rxr_idx){  /* ... */  /* allocate q_vector and rings */  q_vector = kzalloc(size, GFP_KERNEL);  if (!q_vector)          return -ENOMEM;  /* initialize NAPI */  netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, igb_poll, 64);  /* ... */</code></pre><p>q_vector 是新分配的隊列，igb_poll 是 poll 方法，當它收包的時候，會通過這個接收隊列找到關聯的 NAPI 變量（q_vector->napi）。</p><h1 class=pgc-h-arrow-right><strong>4. 啟用網卡(Bring A Network Device Up)</strong></h1><p style=text-align:justify>前面提到structure net_device_ops 變量，它包含網卡啟用、發包、設置 mac 地址等回調函數（函數指針）。</p><p style=text-align:justify>當啟用一個網卡時（例如，通過 ifconfig eth0 up），net_device_ops 的 ndo_open 方法會被調用。它通常會做以下事情：</p><ul><li>分配 RX、TX 隊列內存</li><li>打開 NAPI 功能</li><li>註冊中斷處理函數</li><li>打開（enable）硬中斷</li><li>其他</li></ul><p style=text-align:justify>igb 驅動中，這個方法對應的是 igb_open 函數。</p><h1 class=pgc-h-arrow-right><strong>4.1 準備從網絡接收數據</strong></h1><p style=text-align:justify>目前大部分網卡都使用 DMA 將數據直接寫到內存，接下來操作系統可以直接從裡面讀取。實現這一目的所使用的數據結構是 ring buffer（環形緩衝區）。</p><p style=text-align:justify>要實現這一功能，設備驅動必須和操作系統合作，預留（reserve）出一段內存來給網卡使用。預留成功後，網卡知道了這塊內存的地址，接下來收到的數據包就會放到這裡，進而被操作系統取走。</p><p style=text-align:justify>由於這塊內存區域是有限的，如果數據包的速率非常快，單個 CPU 來不及取走這些包，新來的包就會被丟棄。這時候，Receive Side Scaling（RSS，接收端擴展）或者多隊列（ multiqueue）一類的技術可能就會排上用場。</p><p style=text-align:justify>一些網卡有能力將接收到的數據包寫到多個不同的內存區域，每個區域都是獨立的接收隊列。這樣操作系統就可以利用多個 CPU（硬件層面）並行處理收到的數據包。只有部分網卡支持這個功能。</p><p style=text-align:justify>Intel I350 網卡支持多隊列，我們可以在 igb 的驅動裡看出來。igb 驅動啟用的時候 ，最開始做的事情之一就是調用 igb_setup_all_rx_resources 函數。這個函數會對每個 RX 隊列調用 igb_setup_rx_resources， 裡面會管理 DMA 的內存。</p><p style=text-align:justify><strong>RX 隊列的數量和大小可以通過 ethtool 進行配置，調整這兩個參數會對收包或者丟包產生可見影響。</strong></p><p style=text-align:justify>網卡通過對 packet 頭（例如源地址、目的地址、端口等）做哈希來決定將 packet 放到哪個 RX 隊列。只有很少的網卡支持調整哈希算法。如果支持的話，可以根據算法將特定 的 flow 發到特定的隊列，<strong>甚至可以做到在硬件層面直接將某些包丟棄</strong>。</p><p style=text-align:justify>一些網卡支持調整 RX 隊列的權重，可以有意地將更多的流量發到指定的 queue。</p><h1 class=pgc-h-arrow-right><strong>4.2 Enable NAPI</strong></h1><p style=text-align:justify>前面介紹了驅動如何註冊 NAPI poll 方法，但是，一般直到網卡被啟用之後，NAPI 才被啟用。</p><p style=text-align:justify>啟用 NAPI 很簡單，調用 napi_enable 函數就行，這個函數會設置 NAPI 變量（struct napi_struct）中一個表示是否啟用的標誌位。前面說到，NAPI 啟用後並不是立即開始工作（而是等硬中斷觸發）。</p><p style=text-align:justify>對於 igb，驅動初始化或者通過 ethtool 修改 queue 數量或大小的時候，會啟用每個q_vector 的 NAPI 變量（ drivers/net/ethernet/intel/igb/igb_main.c）：</p><pre><code>for (i = 0; i &lt; adapter-&gt;num_q_vectors; i++)    napi_enable(&amp;(adapter-&gt;q_vector[i]-&gt;napi));</code></pre><h1 class=pgc-h-arrow-right><strong>4.3 註冊中斷處理函數</strong><br></h1><p style=text-align:justify>啟用 NAPI 之後，下一步就是註冊中斷處理函數。設備有多種方式觸發一箇中斷：</p><ul><li>MSI-X</li><li>MSI</li><li>legacy interrupts</li></ul><p style=text-align:justify>設備驅動的實現也因此而異。驅動必須判斷出設備支持哪種中斷方式，然後註冊相應的中斷處理函數，這些函數在中斷髮生的時候會被執行。</p><p style=text-align:justify>一些驅動，例如 igb，會試圖為每種中斷類型註冊一箇中斷處理函數，如果註冊失敗，就嘗試下一種類型。</p><p style=text-align:justify>MSI-X 中斷是比較推薦的方式，尤其是對於支持多隊列的網卡。因為每個 RX 隊列有獨立的 MSI-X 中斷，因此可以被不同的 CPU 處理（通過 irqbalance 方式，或者修改/proc/irq/IRQ_NUMBER/smp_affinity）。處理中斷的 CPU 也是隨後處理這個包的 CPU。這樣的話，從網卡硬件中斷的層面就可以設置讓收到的包被不同的 CPU 處理。</p><p style=text-align:justify>如果不支持 MSI-X，那 MSI 相比於傳統中斷方式仍然有一些優勢，驅動仍然會優先考慮它。</p><p style=text-align:justify>在 igb 驅動中，函數 igb_msix_ring，igb_intr_msi，igb_intr 分別是 MSI-X，MSI 和傳統中斷方式的中斷處理函數。</p><p style=text-align:justify>驅動是如何嘗試各種中斷類型的（ drivers/net/ethernet/intel/igb/igb_main.c）：</p><pre><code>static int igb_request_irq(struct igb_adapter *adapter){  struct net_device *netdev = adapter-&gt;netdev;  struct pci_dev *pdev = adapter-&gt;pdev;  int err = 0;  if (adapter-&gt;msix_entries) {    err = igb_request_msix(adapter);    if (!err)      goto request_done;    /* fall back to MSI */    /* ... */  }  /* ... */  if (adapter-&gt;flags &amp; IGB_FLAG_HAS_MSI) {    err = request_irq(pdev-&gt;irq, igb_intr_msi, 0,          netdev-&gt;name, adapter);    if (!err)      goto request_done;    /* fall back to legacy interrupts */    /* ... */  }  err = request_irq(pdev-&gt;irq, igb_intr, IRQF_SHARED,        netdev-&gt;name, adapter);  if (err)    dev_err(&amp;pdev-&gt;dev, "Error %d getting interrupt\n", err);request_done:  return err;}</code></pre><p>這就是 igb 驅動註冊中斷處理函數的過程，這個函數在一個數據包到達網卡觸發一個硬件中斷時就會被執行。</p><h1 class=pgc-h-arrow-right><strong>4.4 Enable Interrupts</strong></h1><p style=text-align:justify>到這裡，幾乎所有的準備工作都就緒了。唯一剩下的就是打開硬中斷，等待數據包進來。打開硬中斷的方式因硬件而異，igb 驅動是在 __igb_open 裡調用輔助函數igb_irq_enable 完成的。</p><p style=text-align:justify>中斷通過寫寄存器的方式打開：</p><pre><code>static void igb_irq_enable(struct igb_adapter *adapter){  /* ... */    wr32(E1000_IMS, IMS_ENABLE_MASK | E1000_IMS_DRSTA);    wr32(E1000_IAM, IMS_ENABLE_MASK | E1000_IMS_DRSTA);  /* ... */}</code></pre><p>現在，網卡已經啟用了。驅動可能還會做一些額外的事情，例如啟動定時器，工作隊列（ work queue），或者其他硬件相關的設置。這些工作做完後，網卡就可以接收數據包了。</p><h1 class=pgc-h-arrow-right><strong>5. 網卡監控</strong></h1><p style=text-align:justify>監控網絡設備有幾種不同的方式，每種方式的監控粒度（granularity）和複雜度不同。我們先從最粗的粒度開始，逐步細化。</p><h1 class=pgc-h-arrow-right><strong>5.1 ethtool -S</strong></h1><p style=text-align:justify>ethtool -S 可以查看網卡統計信息（例如接收和發送的數據包總數，接收和發送的流量，丟棄的包數量，錯誤的數據包數量等）：</p><div class=pgc-img><img alt=Linux內核網絡設備驅動 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a142a9a74ca54da4851cedb3505e52ef><p class=pgc-img-caption></p></div><p style=text-align:justify>監控這些數據比較困難。因為用命令行獲取很容易，但是以上字段並沒有一個統一的標準。不同的驅動，甚至同一驅動的不同版本可能字段都會有差異。</p><p style=text-align:justify>可以先粗略的查看 “drop”, “buffer”, “miss” 等字樣。然後，在驅動的源碼裡找到對應的更新這些字段的地方，這可能是在軟件層面更新的，也有可能是在硬件層面通過寄存器更新的。如果是通過硬件寄存器的方式，就得查看網卡的 data sheet（說明書），搞清楚這個寄存器代表什麼。ethtoool 給出的這些字段名，有一些是有誤導性的（misleading）。</p><h1 class=pgc-h-arrow-right><strong>5.2 sysfs</strong></h1><p style=text-align:justify>sysfs 也提供了統計信息，但相比於網卡層的統計，要更上層一些。</p><p style=text-align:justify>例如，可以獲取的 ens33 的接收端數據包的類型有這些：</p><div class=pgc-img><img alt=Linux內核網絡設備驅動 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4a20d5b1b2d64acc9bab03a56eb5bf51><p class=pgc-img-caption></p></div><p style=text-align:justify>獲取接收到的數據包的總數為：</p><div class=pgc-img><img alt=Linux內核網絡設備驅動 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3d05995c6d744e2a9bb3d057a7bea344><p class=pgc-img-caption></p></div><p style=text-align:justify>不同類型的統計分別位於 /sys/class/net/&lt;NIC>/statistics/ 下面的不同文件，包括collisions, rx_dropped, rx_errors, rx_missed_errors 等等。</p><p style=text-align:justify>要注意的是，每種類型代表什麼意思，是由驅動來決定的，因此也是由驅動決定何時以及在哪裡更新這些計數的。你可能會發現一些驅動將一些特定類型的錯誤歸類為 drop，而另外一些驅動可能將它們歸類為 miss。</p><p style=text-align:justify>這些值至關重要，因此需要查看對應的網卡驅動，搞清楚它們真正代表什麼。</p><h1 class=pgc-h-arrow-right><strong>5.2 /proc/net/dev</strong></h1><p style=text-align:justify>/proc/net/dev 提供了更高一層的網卡統計。</p><div class=pgc-img><img alt=Linux內核網絡設備驅動 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/288f9d5ed08245fe9b5cc1552de3de7b><p class=pgc-img-caption></p></div><p style=text-align:justify>這個文件裡顯示的統計只是 sysfs 裡面的一個子集，但適合作為一個常規的統計參考。</p><p style=text-align:justify>如果對這些數據準確度要求特別高，那必須查看內核源碼 、驅動源碼和驅動手冊，搞清楚每個字段真正代表什麼意思，計數是如何以及何時被更新的。Linux內核網絡設備驅動先介紹到這裡，感謝閱讀。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>內核</a></li><li><a>網絡</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html alt=Linux高級網絡編程篇-UDP丟包問題總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html title=Linux高級網絡編程篇-UDP丟包問題總結>Linux高級網絡編程篇-UDP丟包問題總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1703d4a.html alt=網絡內核之TCP是如何發送和接收消息的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d1b708de7db2403cbc70a570db2177f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1703d4a.html title=網絡內核之TCP是如何發送和接收消息的>網絡內核之TCP是如何發送和接收消息的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f65dd506.html alt=Linux內核簡介，你能看懂麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/01f248e03b78487093db92f7873aacb8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f65dd506.html title=Linux內核簡介，你能看懂麼>Linux內核簡介，你能看懂麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/426b5581.html alt="一篇文章告訴你：Linux 網絡驅動，網卡原理，它們之間怎麼交互？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/558e398aa7324540ab97b34d2d46930a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/426b5581.html title="一篇文章告訴你：Linux 網絡驅動，網卡原理，它們之間怎麼交互？">一篇文章告訴你：Linux 網絡驅動，網卡原理，它們之間怎麼交互？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfddf98c.html alt=Linux內核中的hash與bucket簡單介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153113365765421287673dd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfddf98c.html title=Linux內核中的hash與bucket簡單介紹>Linux內核中的hash與bucket簡單介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6130ea0.html alt=如何增強Linux內核中的訪問控制安全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/4803f61d402c4c5eb125f3c52460a705 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6130ea0.html title=如何增強Linux內核中的訪問控制安全>如何增強Linux內核中的訪問控制安全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cadc1ac.html alt="Linux 內核深度剖析與實踐" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c8bc4b450aff4e848c73de7bade9c264 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cadc1ac.html title="Linux 內核深度剖析與實踐">Linux 內核深度剖析與實踐</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/103109d.html alt=Linux網絡編程——無連接和面向連接協議的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/38755fbc61154d06a243d159fdae398b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/103109d.html title=Linux網絡編程——無連接和面向連接協議的區別>Linux網絡編程——無連接和面向連接協議的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html alt=光纜——未來網絡主導 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e75c1afe12354a93bad8495ad1057693 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html title=光纜——未來網絡主導>光纜——未來網絡主導</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdc59733.html alt="網絡詞名場面是什麼意思 名場面是什麼梗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdc59733.html title="網絡詞名場面是什麼意思 名場面是什麼梗">網絡詞名場面是什麼意思 名場面是什麼梗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a002ca18.html alt=王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/26add5cdc08e4214800b25e21b623eb1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a002ca18.html title=王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯>王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad6f0929.html alt=谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/65c4000bda98898dcdbb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad6f0929.html title=谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼>谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>