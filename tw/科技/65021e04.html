<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java併發編程 -- 手動實現可重入Lock | 极客快訊</title><meta property="og:title" content="Java併發編程 -- 手動實現可重入Lock - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/65021e04.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/65021e04.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/65021e04.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/65021e04.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/65021e04.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/65021e04.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/65021e04.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/65021e04.html><meta property="article:published_time" content="2020-11-14T20:55:07+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:07+08:00"><meta name=Keywords content><meta name=description content="Java併發編程 -- 手動實現可重入Lock"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/65021e04.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java併發編程 -- 手動實現可重入Lock</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>內容導讀</h1><blockquote><p>同步塊不保證等待輸入它的線程被授予訪問權限的順序。同步塊必須完全包含在單個方法中。調用此方法的其他線程可能會導致未經檢查的異常（RuntimeException）。結果沒有出現線程安全問題，這裡不做截圖了，自己可以試試。但是我們寫的方法還有一定的問題，就是MyLock這個類不支持 可重入鎖，意思就是如果有兩個鎖嵌套，如果相同的線程先調用a方法，再調用帶鎖的b方法，則就會進入自旋鎖。第一個線程執行a()方法，得到了鎖，使lockedBy等於當前線程，也就是說，執行的這個方法的線程獲得了這個鎖，執行add()方法時，同樣要先獲得鎖，因不滿足while循環的條件，也就是不等待，繼續進行，將此時的lockedCount變量，也就是當前獲得鎖的數量加一，當釋放了所有的鎖，才執行notify()。</p></blockquote><blockquote><p>Lock就像synchronized塊一樣是一個線程同步機制。 然而，Lock定比synchronized更靈活、更復雜。</p></blockquote><h3>Lock和synchronized塊 的區別</h3><ul class=list-paddingleft-2><li><p>同步塊不保證等待輸入它的線程被授予訪問權限的順序。</p></li><li><p>不能將任何參數傳遞給同步塊的條目。</p></li><li><p>同步塊必須完全包含在單個方法中。 一個Lock可以在不同的方法中調用lock（）和unlock（）。</p></li></ul><h3>簡單例子</h3><pre>Lock lock = new ReentrantLock();lock.lock();//要保證線程安全的代碼lock.unlock();</pre><p>其中，你應該能夠猜到，lock() 方法是加鎖，unlock()方法是解鎖。</p><h3>Lock接口含有的方法</h3><ul class=list-paddingleft-2><li><p>lock()</p></li><li><p>lockInterruptibly()</p></li><li><p>tryLock()</p></li><li><p>tryLock(long timeout, TimeUnit timeUnit)</p></li><li><p>unlock()</p></li></ul><p>lock（）方法鎖定Lock實例。 如果鎖定實例已被鎖定，則線程調用鎖定（）將被鎖定，直到解鎖鎖定。</p><p>lockInterruptibly（）方法鎖定Lock，除非調用該方法的線程已被中斷。如果一個線程被阻塞，等待通過此方法鎖定Lock，該線程將被中斷，並退出此方法調用。（獲取鎖的時候可以被中斷）</p><p>tryLock（）方法立即嘗試鎖定Lock實例。 如果鎖定成功則返回true;如果Lock已經被鎖定，則返回false。 <strong>這個方法永遠不會阻塞</strong></p><p>tryLock（long timeout，TimeUnit timeUnit）的工作方式與tryLock（）方法相似，只是它對超時時間有所規定。</p><p>unlock（）方法解鎖Lock實例。 通常，Lock實現將只允許已鎖定Lock的線程調用此方法。 調用此方法的其他線程可能會導致未經檢查的異常（RuntimeException）。</p><h3>ReentrantLock實例</h3><p>ReentrantLock 可重入鎖，是Lock的一個子類。我們這裡來使用它實現線程安全編程。</p><pre>package com.lock;import com.thread.security.Task;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 重入鎖 * Created by Fant.J. * 2018/3/6 20:09 */public class ReentrantLockTest { public int value = 0; //實例化重入鎖鎖 Lock lock = new ReentrantLock(); public int getValue() { //加鎖 lock.lock(); int a = value++; //消除鎖 lock.unlock(); return a; } public static void main(String[] args) { ReentrantLockTest task = new ReentrantLockTest(); new Thread(){ @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName() + " " + task.getValue()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); new Thread(){ @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName() + " " + task.getValue()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); }}</pre><h3>手寫自己的Lock實現類</h3><p>如果有特殊業務需求，我們也可以重寫Lock接口，來打造一個自己的lock鎖。</p><pre>package com.lock;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;/** * Created by Fant.J. * 2018/3/6 20:12 */public class MyLock implements Lock { //聲明一個判斷鎖的布爾值 private boolean isLocked = false; /** * 必須聲明 synchronized 原自行操作，不然jvm不會識別是哪個線程的wait方法，notify也一樣 */ @Override public synchronized void lock() { while (isLocked){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } isLocked = true; } @Override public synchronized void unlock() { isLocked = false; notify(); } @Override public void lockInterruptibly() throws InterruptedException { } @Override public boolean tryLock() { return false; } @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return false; } @Override public Condition newCondition() { return null; }}</pre><p>然後我們做測試</p><pre>package com.lock;/** * Created by Fant.J. * 2018/3/6 20:24 */public class MyLockTest { public int value = 0; MyLock myLock = new MyLock(); public int getValue(){ myLock.lock(); value++; myLock.unlock(); return value; } public static void main(String[] args) { MyLockTest task = new MyLockTest(); new Thread(){ @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName() + " " + task.getValue()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); new Thread(){ @Override public void run() { while (true) { System.out.println(Thread.currentThread().getName() + " " + task.getValue()); try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start(); }}</pre><p>結果沒有出現線程安全問題，這裡不做截圖了，自己可以試試。但是我們寫的方法還有一定的問題，就是MyLock這個類不支持 可重入鎖，意思就是如果有兩個鎖嵌套，如果相同的線程先調用a方法，再調用帶鎖的b方法，則就會進入自旋鎖。</p><h5>測試方法源碼</h5><pre>package com.lock;/** * Created by Fant.J. * 2018/3/6 20:24 */public class MyLockTest2 { public int value = 0; MyLock myLock = new MyLock(); public void a(){ myLock.lock(); System.out.println("a"); b(); myLock.unlock(); } public void b(){ myLock.lock(); System.out.println("b"); myLock.unlock(); } public static void main(String[] args) { MyLockTest2 task = new MyLockTest2(); new Thread(){ @Override public void run() { task.a(); } }.start(); new Thread(){ @Override public void run() { task.a(); } }.start(); }}</pre><p>執行該方法後，我們會發現，線程停止在打印出"a"後，一直在等待。這就是因為該鎖不是可重入鎖。</p><h5>可重入鎖的設計</h5><p>我在這裡只貼和上面代碼不同的部分。</p><pre>public class MyLock implements Lock { //聲明一個判斷鎖的布爾值 private boolean isLocked = false; Thread lockBy = null; int lockCount = 0; @Override public synchronized void lock() { Thread currentThread = Thread.currentThread(); //獲取到當前線程 while (isLocked &amp;&amp; currentThread != lockBy){ try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } isLocked = true; lockBy = currentThread; //將currentThread線程指向 lockBy線程 lockCount++;//計數器自增 } @Override public synchronized void unlock() { if (lockBy == Thread.currentThread()){ lockCount--; if (lockCount ==0 ){ notify(); isLocked = false; } } }}</pre><p>第一個線程執行a()方法，得到了鎖，使lockedBy等於當前線程，也就是說，執行的這個方法的線程獲得了這個鎖，執行add()方法時，同樣要先獲得鎖，因不滿足while循環的條件，也就是不等待，繼續進行，將此時的lockedCount變量，也就是當前獲得鎖的數量加一，當釋放了所有的鎖，才執行notify()。如果在執行這個方法時，有第二個線程想要執行這個方法，因為lockedBy不等於第二個線程，導致這個線程進入了循環，也就是等待，不斷執行wait()方法。只有當第一個線程釋放了所有的鎖，執行了notify()方法，第二個線程才得以跳出循環，繼續執行。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>發編程</a></li><li><a>--</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f50d531.html alt="Java 併發基礎--進程&線程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f50d531.html title="Java 併發基礎--進程&線程">Java 併發基礎--進程&線程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html alt=Java併發編程：進程和線程之由來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/4f658919-1d85-46bc-bbf1-64aac52f4c80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html title=Java併發編程：進程和線程之由來>Java併發編程：進程和線程之由來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1b27915.html alt=Java總結之容器家族--Collection class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/88ce4e8325964ee3aac0b015656a3c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1b27915.html title=Java總結之容器家族--Collection>Java總結之容器家族--Collection</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/20dcfe0c.html alt=Java--字符編碼和字符集詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/20dcfe0c.html title=Java--字符編碼和字符集詳解>Java--字符編碼和字符集詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b74f39.html alt=Java併發編程-cpu的流水線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7f4148aa001d409f9c216ca503586596 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b74f39.html title=Java併發編程-cpu的流水線>Java併發編程-cpu的流水線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0ee178.html alt="「原創」Java併發編程系列36 | FutureTask" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/SAZA4S9I6wzJm7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0ee178.html title="「原創」Java併發編程系列36 | FutureTask">「原創」Java併發編程系列36 | FutureTask</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbb4fd63.html alt="Mysql --09 Innodb核心特性——事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/47618d6931fd4518a4d78c0e13623b98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbb4fd63.html title="Mysql --09 Innodb核心特性——事務">Mysql --09 Innodb核心特性——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47facbb9.html alt=SVHACKS--偽隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/10b87c79-8837-4bfd-9418-b994acbf0174 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47facbb9.html title=SVHACKS--偽隨機數>SVHACKS--偽隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>