<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>徹底解決雪花算法時間回撥問題新方案 | 极客快訊</title><meta property="og:title" content="徹底解決雪花算法時間回撥問題新方案 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/340c1f41cfee438285a19e6a869bd186"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6553762.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6553762.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6553762.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6553762.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6553762.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6553762.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6553762.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6553762.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="徹底解決雪花算法時間回撥問題新方案"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6553762.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>徹底解決雪花算法時間回撥問題新方案</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p style=text-align:start>雪花算法是twitter提出的分佈式id生成器方案，但是有三個問題，其中前兩個問題在業內很常見：</p><ul><li>時間回撥問題</li><li>機器id的分配和回收問題</li><li>機器id的上限問題</li></ul><h1 class=pgc-h-arrow-right>Butterfly 簡介</h1><p style=text-align:start>Butterfly（蝴蝶）是一個超高性能的發號器框架。起名Butterfly是用世界上沒有完全相同的蝴蝶翅膀來表示該算法的唯一性。框架通過引入多種新的方案不僅解決了雪花算法存在的所有問題，而且還能夠提供比雪花算法更高的性能。在單機版QPS理論值為51.2(w/s)這種情況下，新的方案在一些機器上可達 1000(w/s) 甚至更高。</p><p style=text-align:start>其中業內針對前兩個問題都有個自己的解決方式，但是都不是很完美，或者說沒有完全解決。我們這裡從新的思路出發，通過改造雪花算法以及其他相關方式徹底解決了以上的三個問題。該方案算是對雪花算法比較完美的一種實現方式。</p><h1 class=pgc-h-arrow-right>雪花算法</h1><p style=text-align:start>雪花算法是twitter提出的分佈式id生成器方案，也叫發號器方案。這裡簡單介紹下雪花算法</p><div class=pgc-img><img alt=徹底解決雪花算法時間回撥問題新方案 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/340c1f41cfee438285a19e6a869bd186><p class=pgc-img-caption></p></div><p style=text-align:start>這個就是原生的雪花算法分配</p><ul><li>41bit時間戳：這裡採用的就是當前系統的具體時間，單位為毫秒</li><li>10bit工作機器ID（workerId）：每臺機器分配一個id，這樣可以表示不同的機器，但是上限為1024，表示一個集群某個業務最多部署的機器個數上限</li><li>12bit序列號（自增域）：表示在某一毫秒下，這個自增域最大可以分配的bit個數，在當前這種配置下，每一毫秒可以分配2^12個數據，也就是說QPS可以到 409.6 w/s。</li></ul><h1 class=pgc-h-arrow-right>存在的問題</h1><ul><li>時間回撥問題：由於機器的時間是動態的調整的，有可能會出現時間跑到之前幾毫秒，如果這個時候獲取到了這種時間，則會出現數據重複</li><li>機器id分配及回收問題：目前機器id需要每臺機器不一樣，這樣的方式分配需要有方案進行處理，同時也要考慮，如果該機器宕機了，對應的workerId分配後的回收問題</li><li>機器id上限：機器id是固定的bit，那麼也就是對應的機器個數是有上限的，在有些業務場景下，需要所有機器共享同一個業務空間，那麼10bit表示的1024臺機器是不夠的。</li></ul><h1 class=pgc-h-arrow-right>業內方案</h1><p style=text-align:start>業內的方案中對以上三個問題有這麼幾種處理，但是都沒有徹底解決，我們這裡表述下</p><p><strong>1.時間回撥問題：</strong></p><ul><li>採用直接拋異常方式：這種很不友好，太粗暴</li><li>採用等待跟上次時間的一段範圍：這種算是簡單解決，可以接受，但是如果等待一段時間後再出現回撥，則拋異常，可接受，但是不算徹底解決</li></ul><p><strong>2.機器id分配及回收：</strong></p><ul><li>採用zookeeper的順序節點分配：解決了分配，回收可採用zookeeper臨時節點回收，但是臨時節點不可靠，存在無故消失問題，因此也不可靠</li><li>採用DB中插入數據作為節點值：解決了分配，沒有解決回收</li></ul><p><strong>3.機器id上限</strong></p><p style=text-align:start>該問題在業內都沒有處理，也就是說如果採用雪花算法，則必定會存在該問題，但是該問題也只有需要大量的業務機器共享的場景才會出現，這種情況，採用客戶端雙Buffer+DB這種非雪花算法的方案也未嘗不可。</p><h1 class=pgc-h-arrow-right>Butterfly方案</h1><p style=text-align:start>對於以上三個問題，我們這裡簡述下我們的方案。</p><p><strong>1.時間回撥問題</strong></p><p style=text-align:start>這裡採用新的方案：大概思路是：啟動時間戳採用的是“歷史時間”，每次請求只增序列值，序列值增滿，然後“歷史時間”增1，序列值重新計算。具體方案請見後面</p><p><strong>2.機器id分配和回收</strong></p><p style=text-align:start>這裡機器id分配和回收具體有兩種方案：zookeeper和db。理論上分配方案zk是通過哈希和擴容機器，而db是通過查找機制。回收方案，zk採用的是永久節點，節點中存儲下次過期時間，客戶端定時上報（設置心跳），db是添加過期時間字段，查找時候判斷過期字段。</p><p><strong>3.機器id上限</strong></p><p style=text-align:start>這個採用將改造版雪花+zookeeper分配id方案作為服務端的節點，客戶端採用雙Buffer+異步獲取提高性能，服務端採用每次請求時間戳增1。</p><p style=text-align:start>以上是方案的簡述，對於方案的具體實現請看下面</p><h1 class=pgc-h-arrow-right>改進版雪花設計</h1><p style=text-align:start>前面我們已經知道雪花算法的三個問題，以及也簡述了我們針對雪花算法的幾個方案。這裡詳細描述針對雪花算法的調整和我們自己的方案。</p><p><strong>bit劃分調整</strong></p><p style=text-align:start>我們對雪花算法的bit劃分做了調整，將“機器id（workerId）”從高位置換到了低位，同時將bit也變更為了13bit，同時縮減了序列號（自增域）的bit為9bit。</p><div class=pgc-img><img alt=徹底解決雪花算法時間回撥問題新方案 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7c8f2c39b5e94fc680aa3a468edcf8ec><p class=pgc-img-caption></p></div><p style=text-align:start>將其中“機器id”調整到最後，是為了避免“序列號”增1導致的整體數據增1的問題，這樣可以在一定程度上規避外部數據對id的猜測，以防止惡意爬取。</p><p><strong>時間獲取處理</strong></p><p>採用“歷史時間”：</p><p style=text-align:start>這裡是我們方案的核心，我們這裡採用的不是實際時間，而是歷史時間，在進程啟動後，我們會將當前時間（實際處理採用了延遲10ms啟動）作為該業務這臺機器進程的時間戳中的起始時間字段。後續的自增是在序列號自增到最大值時候時間戳增1，而序列號重新歸為0，算是將時間戳和序列號作為一個大值進行自增，只是初始化不同。</p><h1 class=pgc-h-arrow-right>序列號自增：</h1><p style=text-align:start>每次有數據請求，直接對序列號增加即可，序列號從0增加到最大，到達最大時，時間戳字段增加1，其實是時間增加1毫秒，序列號從0計算。</p><p><strong>機器id分配和回收：</strong></p><p style=text-align:start>對機器的分配和回收這裡有三種默認方式，不過也支持用戶自定義實現</p><p>（單機版）zookeeper分配和回收：</p><p style=text-align:start>分配採用哈希方式在預分配的一些空置永久節點中進行分配，節點後綴是有編號的，查找其中節點沒有被佔用，或者被佔用但是佔用超時的節點進行分配，其中分配的編號就是WorkerId。分配完畢，定期更新節點中的超時時間，超時後下次節點分配時會判斷超時。這裡初始節點默認設置為16個節點，如果節點都被佔用（佔用或者沒佔用但是超時時間沒過），則模仿HashMap方式進行2倍擴容，然後重新分配。</p><p>（單機版）db分配和回收：</p><p style=text-align:start>先看過期的裡面最小的id，找到了則當前workerId就是機器id。如果過期中沒找到，則查看其中最大的workerId並增1，然後新增，當前增1後的workerId就是分配的workerId。</p><p>（分佈式版）集群分配workerId：</p><p style=text-align:start>客戶端的wokerId是每次Buffer請求中攜帶過來的，這樣對客戶端而言就沒有workerId上限問題，因為workerId是服務端節點分配的。由於採用了網絡傳輸，為了提高性能，客戶端這裡採用雙Buffer+異步刷新方式，server端這裡採用改進版的雪花+zookeeper分配和回收wokerId方式。</p><h1 class=pgc-h-arrow-right>問題解決方式</h1><p><strong>1.時間回撥問題：</strong></p><p style=text-align:start>採用歷史時間則天然的不存在時間回撥問題。但是在超高併發情況下，歷史的時間很快用完，時間一直保持在最新時間的話，這個時候出現時間回撥，則採用業界對於時間回撥的處理方式（首次等待，即等待一段回撥時間）</p><p><strong>2.機器id分配及回收：</strong></p><p style=text-align:start>機器的id分配和回收，我們這裡採用zookeeper和db兩種方式分配，這兩種方式，均只有在進程啟動的時候生效，後續就不再跟客戶端有更多交互，唯一的是有個定時上報過期時間的任務。該過期時間為24小時，因此zookeeper或者db宕機一天，該發號器都不會有任何問題。回收這裡採用的是上報的過期時間，過期了，則下次分配可以直接使用。</p><p><strong>3.機器id上限</strong></p><p style=text-align:start>其中單機版的zookeeper和 DB均不是解決這個問題而存在的，其中（分佈式版）distribute分配workerId是採用服務端方式，用服務端方式啟動作為workerId的分配者，客戶端使用的時候每次Buffer請求中服務端會將那一次的workerId和時間戳返回過來。這樣雖然服務集群的workerId上限（即服務集群節點個數上限）是有的，但是對於客戶端擁有的集群而言，理論上無上限，因為一個服務端節點就可以服務一個業務集群中的許多節點。</p><h1 class=pgc-h-arrow-right>超高性能</h1><p style=text-align:start>由於時間戳採用的是過去時間，我們這樣來看，如果實際QPS小於理論值（我們這裡是9bit，理論值就是51.2w/s），那麼一段時間後，產生的最新的全局id中包含的時間跟當前實際時間就有一定的時間差，那麼這個時間差我們可以稱之為“時間緩存”，而每一毫秒對應的都是0~最大值的這麼多個數據，隨著時間的積累，這裡可以有海量的“邏輯上”的數據緩存。</p><p style=text-align:start>我們想象這樣一個場景，如果通常情況下業務的場景QPS是小於51.2w/s的，那麼這個緩存就會越來越大，那麼如果一瞬間有大量的請求過來的時候，由於我們有大量的緩存，我們這裡就可以產生更多不重複的id，將QPS提高到幾十倍甚至更多，自己的小本測試中最高可以達到1000w/s，性能更高的機器可以更高。</p><p style=text-align:start>如果QPS一直是高位的話比51.2w/s高的話，那麼這種其實業務方面就可以通過業務集群化擴容，將單個業務節點性能降低，不過就發號器技術上來說的話，目前單機版的這個在這種持續高併發情況下，經過測試理論上會保持在53w/s左右。</p><h1 class=pgc-h-arrow-right>workerId分配</h1><p style=text-align:start>分配workerId我們這裡有三種默認方式，用戶也可以自定義自己的默認實現方式</p><blockquote><p>1.（單機版）zookeeper分配和回收</p><p>2.（單機版）db分配和回收</p><p>3.（分佈式版）通過服務端分配和回收</p></blockquote><p style=text-align:start>﻿其中單機版都是直接提供jar包就可以直接使用，只是根據採用的方式不同，進行不同的配置即可</p><h1 class=pgc-h-arrow-right>zookeeper分配</h1><p><strong>哈希分配</strong></p><p style=text-align:start>採用zookeeper進行分配workerId的時候，首先生成一個uuid，然後根據這個uuid進行對當前的命名空間的當前已分配的空間最大值進行取餘，得到一個臨時的下標，然後查看以這個下標作為的zookeeper節點，查看該節點是否被佔用，也就是該節點中的過期時間是否過期，如果過期，則該下標就是對應的workerId。如果沒有過期，則該下標+1，並重新判斷，如果到達當前分配空間的最大值，則從0開始繼續查找可用節點，如果最後找到最開始的節點，則說明當前空間中已經沒有可用節點，則進入到擴容模塊。這裡的擴容其實很簡單，其實就是在初始節點個數（初始節點個數為16）上乘2，然後重新哈希。</p><p style=text-align:start>其中數據在zookeeper中的節點分配如下</p><pre><code>/butterfly/sequence||_bizType_1|    ||    |_config|    ||    |_worker_0|    |	   ||    |	   |_session|    |		|    |_worker_1|    |	   ||    |	   |_session|    ||    ...||_bizType_2|    ||    |_config|    ||    |_worker_0|    |	   ||    |	   |_session|    |		|    |_worker_1|    |	   ||    |	   |_session|    ...</code></pre><p><strong>節點解釋：</strong></p><p style=text-align:start>butterfly/sequence：zookeeper中的固定節點bizType<em>1/bizType</em>2：為對應的命名空間，實際命名空間為用戶自定義config：為每個命名空間中放置配置的節點，其中存儲的信息如下，一個是bit分配值，一個是命名空間中節點對應的值，bit分配的值，是為了以後擴展使用，這裡先放置在這裡</p><pre><code>{    "currentMaxMachine":16,    "sequenceBits":9,    "timestampBits":41,    "workerBits":13}</code></pre><p style=text-align:start>worker<em>x：對應的workerId對應的節點，其中有個session節點，該節點為臨時節點，如果不存在session節點，則表示當前節點沒被佔用，則不判斷過期時間，直接在內部創建session節點，並將下標x作為workerId返回。如果被佔用，採用的是查看worker</em>x中存儲的下次過期時間，如果當前過期時間小於當前時間，則認為已經過期，即創建session節點，並更新worker_x中的信息，並將x作為workerId使用。</p><pre><code>{    "ip":"127.0.0.1",    "lastExpireTime":1588955705615,    "processId":"90705",    "uidKey":"762bcaad-48f5-4da9-8a1d-5e05a28add18"}</code></pre><p><strong>﻿定時上報</strong></p><p style=text-align:start>每次客戶端對應的進程啟動，並分配好workerId之後，就會定期向該worker_x節點上報一次下次過期的時間，目前採用的下次過期時間為24小時，也就是說一個進程一旦佔用一個節點，一般情況下都是異常斷開後最多佔用24小時。但是正常斷開的話，會自動將這些信息清理掉。</p><h1 class=pgc-h-arrow-right>db分配</h1><p><strong>查找數據</strong></p><p style=text-align:start>採用db方式的話，需要先保證已經創建了butterfly_uuid_generator ，如果沒有則先在對應的庫中創建</p><pre><code>CREATE TABLE `butterfly_uuid_generator` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主鍵id',  `namespace` varchar(128) DEFAULT '' COMMENT '命名空間',  `work_id` int(16) COMMENT '工作id',  `last_expire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '下次失效時間',  `uid` varchar(128) DEFAULT '0' COMMENT '本次啟動唯一id',  `ip` bigint(20) NOT NULL DEFAULT '0' COMMENT 'ip',  `process_id` varchar(128) NOT NULL DEFAULT '0' COMMENT '進程id',  PRIMARY KEY (`id`),  UNIQUE KEY `idx_name_work` (`namespace`,`work_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='發號器表';</code></pre><p style=text-align:start>查找數據，這裡首先是在對應的命名空間中，查找過期的數據，如果能找到其中id最小的，則該id對應中的workerId就是我們要分配的workerId，如果都沒有過期，這塊有問題，明天繼續看，那麼就找最小的workerId，並將workerId+1，重新插入到數據庫中（之前查詢其實是採用事務中添加悲觀鎖方式，保證這裡不會有多個重複的插入），其中對應的workerId+1就是我們要分配的workerId。</p><p><strong>定時更新（心跳）</strong></p><p style=text-align:start>workerId分配之後，每次都要定時（每5秒）刷新當前命名空間中對應workerId中對應的下次過期時間（就是當前時間往後推24小時）。如果對應的進程異常宕機了，則該數據對應的這個數據會存在，只是過期時間不會再更新，而如果該進程是正常宕機，則會正常將db中的對應的那條數據刪除掉。方便下次分配者繼續分配workerId。</p><p style=text-align:start>我建議，在表中增加一個status字段，在數據正常宕機之後，就是將當前的這條數據狀態設置為不可用，在下次數據請求的時候，首先查找狀態為不可用的數據，如果找到，則分配</p><p style=text-align:start>1.找狀態為關閉的2.找已經過期的3.找workerId最大的，並將workerId+1插入到DB中</p><p style=text-align:start>這樣就可以得到最新的workerId了</p><h1 class=pgc-h-arrow-right>分佈式模式</h1><p><strong>客戶端</strong></p><p style=text-align:start>一、代理獲取數據</p><p style=text-align:start>二、雙Buffer+異步獲取數據</p><p><strong>服務端</strong></p><p style=text-align:start>採用改進版雪花+zookeeper模式的純內存化的無DB的服務端</p><h1 class=pgc-h-arrow-right>一、使用示例</h1><p style=text-align:start>該框架中“機器id（workerId）”的分配方式默認有三種方式</p><blockquote><p>1.（單機版）zookeeper分配</p><p>2.（單機版）db分配</p><p>3.（分佈式版）通過服務端分配</p></blockquote><p style=text-align:start>﻿不同的分配方式就是不同的用法，依賴也是不同。其中單機版和分佈式版也要根據場景來自行選擇：</p><ul><li>單機版：無網絡消耗，高可靠性，超高性能（單機可達1000w/s甚至更高），有workerId上限問題</li><li>分佈式版：有網絡消耗，高可用，高性能（集群單節點可達100w/s），無雪花算法任何問題，但是需要維護服務端</li></ul><h1 class=pgc-h-arrow-right>zookeeper分配workerId</h1><p><strong>1.添加依賴</strong></p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.github.simonalong&lt;/groupId&gt;  &lt;artifactId&gt;butterfly-zookeeper-allocator&lt;/artifactId&gt;  &lt;!--替換為具體版本號--&gt;  &lt;version&gt;${last.version.release}&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>2.使用示例</strong></p><pre><code>@Testpublic void test(){    ZkButterflyConfig config = new ZkButterflyConfig();    config.setHost("localhost:2181");    ButterflyIdGenerator generator = ButterflyIdGenerator.getInstance(config);    // 設置起始時間，如果不設置，則默認從2020年2月22日開始    generator.setStartTime(2020, 5, 1, 0, 0, 0);    // 添加業務空間，如果業務空間不存在，則會註冊    generator.addNamespaces("test1", "test2");    Long uuid = generator.getUUid("test1");    System.out.println(uuid);}</code></pre><h1 class=pgc-h-arrow-right>db分配workerId</h1><p><strong>1.添加依賴</strong></p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.github.simonalong&lt;/groupId&gt;  &lt;artifactId&gt;butterfly-db-allocator&lt;/artifactId&gt;  &lt;!--替換為具體版本號--&gt;  &lt;version&gt;${last.version.release}&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>2.建表</strong></p><p style=text-align:start>對應的庫中需要包含如下的表，沒有則創建</p><pre><code>CREATE TABLE `butterfly_uuid_generator` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主鍵id',  `namespace` varchar(128) DEFAULT '' COMMENT '命名空間',  `work_id` int(16) COMMENT '工作id',  `last_expire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '下次失效時間',  `uid` varchar(128) DEFAULT '0' COMMENT '本次啟動唯一id',  `ip` bigint(20) NOT NULL DEFAULT '0' COMMENT 'ip',  `process_id` varchar(128) NOT NULL DEFAULT '0' COMMENT '進程id',  PRIMARY KEY (`id`),  UNIQUE KEY `idx_name_work` (`namespace`,`work_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='發號器表';</code></pre><p><strong>3.使用示例</strong></p><pre><code>@Testpublic void test(){    DbButterflyConfig config = new DbButterflyConfig();    config.setUrl("jdbc:mysql://127.0.0.1:3306/neo?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;&amp;allowPublicKeyRetrieval=true");    config.setUserName("neo_test");    config.setPassword("neo@Test123");    ButterflyIdGenerator generator = ButterflyIdGenerator.getInstance(config);    // 設置起始時間，如果不設置，則默認從2020年2月22日開始    generator.setStartTime(2020, 5, 1, 0, 0, 0);    // 添加業務空間，如果業務空間不存在，則會註冊    generator.addNamespaces("test1", "test2");    Long uuid = generator.getUUid("test1");    System.out.println(uuid);}</code></pre><h1 class=pgc-h-arrow-right>服務端分配workerId</h1><p><strong>1.服務端啟動</strong></p><p style=text-align:start>服務端和客戶端採用dubbo方式進行通訊，下載server包，將如下命令中的dubbo註冊中心替換即可啟動。</p><blockquote><p>java -jar -Ddubbo.registry.address=127.0.0.1:2181 butterfly-server-1.0.0.jar</p></blockquote><p><strong>2.客戶端添加依賴</strong></p><p style=text-align:start>客戶端添加依賴</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.github.simonalong&lt;/groupId&gt;  &lt;artifactId&gt;butterfly-distribute-allocator&lt;/artifactId&gt;  &lt;!--替換為具體版本號--&gt;  &lt;version&gt;${last.version.release}&lt;/version&gt;&lt;/dependency&gt;</code></pre><p><strong>3.使用示例</strong></p><pre><code>@Testpublic void test(){    DistributeButterflyConfig config = new DistributeButterflyConfig();    config.setZkHose("localhost:2181");    ButterflyIdGenerator generator = ButterflyIdGenerator.getInstance(config);    // 設置起始時間，如果不設置，則默認從2020年2月22日開始    generator.setStartTime(2020, 5, 1, 0, 0, 0);    // 添加業務空間，如果業務空間不存在，則會註冊    generator.addNamespaces("test1", "test2");    Long uuid = generator.getUUid("test1");    System.out.println(uuid);}</code></pre><blockquote><p>原文作者：柿子</p><p style=text-align:start>原文鏈接:：https://xie.infoq.cn/article/cf27b51c9e3cde1b2c585f0ec</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>徹底</a></li><li><a>解決</a></li><li><a>時間</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6334f375.html alt=怎麼在短時間內解決滾筒軸承位磨損問題？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d764cf47bae1433787eca00aac011446 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6334f375.html title=怎麼在短時間內解決滾筒軸承位磨損問題？>怎麼在短時間內解決滾筒軸承位磨損問題？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c85ab63d.html alt=依靠立法徹底解決二手菸問題？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/02cea07b-7716-45f3-b9a5-efe0f9dd9498 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c85ab63d.html title=依靠立法徹底解決二手菸問題？>依靠立法徹底解決二手菸問題？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/3e5ae81a.html alt=脂肪肝很好辦，記住這3點，一次性徹底解決它！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/509700050f4c6f353bdb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/3e5ae81a.html title=脂肪肝很好辦，記住這3點，一次性徹底解決它！>脂肪肝很好辦，記住這3點，一次性徹底解決它！</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/0d1782fb.html alt=要想徹底解決花木紅蠟蚧的危害，瞭解清楚這些很重要！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/103b0cb21ff04830ba6914d5756b6362 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/0d1782fb.html title=要想徹底解決花木紅蠟蚧的危害，瞭解清楚這些很重要！>要想徹底解決花木紅蠟蚧的危害，瞭解清楚這些很重要！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/204d163e.html alt="五毛錢解決 蘋果 AirPods容易掉的問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/61600003f2800f627a0d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/204d163e.html title="五毛錢解決 蘋果 AirPods容易掉的問題">五毛錢解決 蘋果 AirPods容易掉的問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65709773.html alt=幹海帶泡軟太浪費時間了，這個小妙招處理後，三分鐘就變軟 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66b80001068b5f6c9893 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65709773.html title=幹海帶泡軟太浪費時間了，這個小妙招處理後，三分鐘就變軟>幹海帶泡軟太浪費時間了，這個小妙招處理後，三分鐘就變軟</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html alt=時間繼電器測試儀的使用方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1205bf787f1f4de6a5f1e73e7737887b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html title=時間繼電器測試儀的使用方法>時間繼電器測試儀的使用方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2e1ceb0.html alt="縱橫談｜徹底清除基層治理中的'灰色手段'" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2e1ceb0.html title="縱橫談｜徹底清除基層治理中的'灰色手段'">縱橫談｜徹底清除基層治理中的'灰色手段'</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd423c48.html alt=口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明…… class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rw0qyU6Ao0YcN0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd423c48.html title=口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明……>口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明……</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4a687640.html alt=寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4a687640.html title=寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動>寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60684aec.html alt=刀具斷屑不可靠的原因分析及解決方法，建議收藏！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f407c10bcc734093ba560997011073c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60684aec.html title=刀具斷屑不可靠的原因分析及解決方法，建議收藏！>刀具斷屑不可靠的原因分析及解決方法，建議收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bee33acb.html alt=中國各大城市日照時間排名 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153881187704099dbc15528 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bee33acb.html title=中國各大城市日照時間排名>中國各大城市日照時間排名</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38343fa4.html alt=全國各地年日照時間地圖：為什麼四川貴州等省日照時間特別短？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b09ab5cc1ee34e48b0267fb1a573fd3e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38343fa4.html title=全國各地年日照時間地圖：為什麼四川貴州等省日照時間特別短？>全國各地年日照時間地圖：為什麼四川貴州等省日照時間特別短？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/410f2fbf.html alt=夏至和冬至的日照時間相差多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a7f980a05ac4b079a5119635df0019b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/410f2fbf.html title=夏至和冬至的日照時間相差多少？>夏至和冬至的日照時間相差多少？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>