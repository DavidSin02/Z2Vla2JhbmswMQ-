<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ | 极客快訊</title><meta property="og:title" content="技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/153594655429837077dd27a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/682e2d04.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/682e2d04.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/682e2d04.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/682e2d04.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/682e2d04.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/682e2d04.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/682e2d04.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/682e2d04.html><meta property="article:published_time" content="2020-11-14T21:03:08+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:08+08:00"><meta name=Keywords content><meta name=description content="技術實踐——Python圖像處理進階：多種圖像變換算法實踐！"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/682e2d04.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>技術實踐——Python圖像處理進階：多種圖像變換算法實踐！</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>在上一篇文章中，我們已經介紹了利用Python進行圖像分析的基本知識和操作（《教程：使用Python進行基本圖像數據分析！》<strong>點擊原文</strong>即可閱讀，本文是上篇文章的延續，將繼續為大家介紹基本圖像處理技術，本文作者主要使用SciKit-Image - numpy執行大多數操作，而不是常用的OpenCV工具，當然，其中偶爾也會穿插使用其他庫。</p><p><strong>圖片亮度轉換</strong></p><p>讓我們先從導入圖像開始：</p><pre>%matplotlib inlineimport imageioimport matplotlib.pyplot as pltimport warningsimport matplotlib.cbookwarnings.filterwarnings("ignore",category=matplotlib.cbook.mplDeprecation)pic = imageio.imread('img/parrot.jpg')plt.figure(figsize = (6,6))plt.imshow(pic);plt.axis('off');</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/153594655429837077dd27a><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>圖片負變換</strong></p><p>亮度變換函數在數學上定義為：</p><pre>s=T(r)</pre><p>其中r是導入圖片的像素，s是輸出圖片的像素。T是一個轉換函數，它將r的每個值映射到s的每個值。</p><p>負變換，即變換顛倒。在負變換中，輸入圖像的每個值從L-1中減去並映射到輸出圖像上。</p><p>在這種情況下，使用以下公式完成轉換：</p><pre>s=(L–1)–r</pre><p>因此每個值減去255，最終效果是，圖片原來較亮的部分變暗，較暗的部分變亮，這就產生了負變換。</p><pre>negative = 255 - pic # neg = (L-1) - imgplt.figure(figsize = (6,6))plt.imshow(negative);plt.axis('off');</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535946555346ca39ccc90e><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>日誌轉換</strong></p><p>日誌轉換可以由以下公式定義：</p><p>s=c∗log(r+1)</p><p>其中，s和r是輸出和輸入圖片的像素值，c是常數。值1被添加到輸入圖片的每個像素值，如果圖片中的像素強度為0，則log（0）等於無窮大，添加1的作用是使最小值至少為1。</p><p>在對數變換期間，與較高像素值相比，圖像中的暗像素被擴展。較高的像素值在日誌轉換中被壓縮，對數變換中的c值可調整增強類型。</p><pre>%matplotlib inlineimport imageioimport numpy as npimport matplotlib.pyplot as pltpic = imageio.imread('img/parrot.jpg')gray = lambda rgb : np.dot(rgb[... , :3] , [0.299 , 0.587, 0.114])gray = gray(pic)'''log transform-&gt; s = c*log(1+r)So, we calculate constant c to estimate s-&gt; c = (L-1)/log(1+|I_max|)'''max_ = np.max(gray)def log_transform(): return (255/np.log(1+max_)) * np.log(1+gray)plt.figure(figsize = (5,5))plt.imshow(log_transform(), cmap = plt.get_cmap(name = 'gray'))plt.axis('off');</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15359465543073f817d95ba><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>Gamma校正</strong></p><p>Gamma校正是用於對視頻或靜止圖像系統中的亮度或刺激值進行編碼和解碼的非線性操作。Gamma校正也稱為冪律變換，首先，我們的圖片像素強度必須從0,255到0,1.0的範圍縮放，通過應用以下等式獲得輸出的Gamma校正圖像：</p><pre>Vo=V1 ^(1/G)</pre><p>其中Vi是輸入圖像，G是gamma值，將輸出圖像Vo縮放回0-255範圍。</p><p>gamma值G&lt;1有時被稱為編碼gamma，並且壓縮冪律非線性編碼的過程被稱為gamma壓縮; Gamma值&lt;1會將圖像移向光譜的較暗端。</p><p>相反，伽馬值G>1被稱為解碼gamma，並且膨脹冪律非線性應用的過程被稱為gamma擴展。Gamma值>1將使圖像顯得更亮，gamma值G=1對輸入圖像沒有影響：</p><pre>import imageioimport matplotlib.pyplot as plt# Gamma encodingpic = imageio.imread('img/parrot.jpg')gamma = 2.2 # Gamma &lt; 1 ~ Dark ; Gamma &gt; 1 ~ Brightgamma_correction = ((pic/255) ** (1/gamma))plt.figure(figsize = (5,5))plt.imshow(gamma_correction)plt.axis('off');</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15359465543707517644f35><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>Gamma校正的原因</strong></p><p>應用Gamma校正的原因是人的眼睛所感知的顏色和亮度與數碼相機中的傳感器不同。 雖然，數碼相機在亮度之間具有線性關係，但人眼是非線性關係。為了解釋這種關係，我們應用Gamma校正。</p><p>還有一些其他的線性變換函數，比如：</p><ul><li>Contrast Stretching</li><li>Intensity-Level Slicing</li><li>Bit-Plane Slicing</li></ul><p><strong>卷積</strong></p><p>我們在前一篇文章中簡要討論過，計算機對圖像的處理最終會呈現一個像素值數組。根據圖像的分辨率和大小，比如會出現一個32 x 32 x 3的數組，其中3表示RGB值或通道。假設我們有一個PNG格式的彩色圖像，它的大小是480 x 480，這代表的數組將是480 * 480 * 3，這些數字中的每一個都在0到255之間，描述了該點的像素強度。</p><p>假設我們輸入一個32 * 32 * 3的像素值數組，我們該如何理解卷積的概念呢？你可以把它想象為閃爍在圖像左上方的手電筒，手電筒照射區域為3 x 3，假設該手電筒滑過輸入圖像的所有區域。在機器學習中，這個手電筒被稱為過濾器或內核，它所照射的區域稱為 receptive field 。</p><p>現在，此過濾器也是一個數組，其中數字稱為權重或參數。需要注意，濾鏡的深度必須與輸入深度相同，因此濾鏡的尺寸為3*3*3。</p><p>圖像內核或濾鏡是一個小矩陣，用於應用可能在Photoshop或Gimp中找到的一些變換，例如模糊、銳化或浮雕等，它們也用於機器學習的功能提取，這是一種用於確定圖像重要部分的技術。</p><p>現在，讓我們將過濾器放在左上角。當濾波器圍繞輸入圖像滑動或卷積時，它將濾波器中的值乘以圖像的原始像素值（也稱為計算元素乘法）。現在，我們對輸入捲上的每個位置重複此過程。下一步是將過濾器向右移動一個步幅，依此類推。輸入捲上的每個位置都會生成一個數字。我們也可以選擇步幅為2甚至更多，但我們必須保證該數值適合輸入圖像。</p><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535946554310d41874567a><p class=pgc-img-caption></p></div><p>當濾鏡滑過所有位置後，我們會發現剩下的是一個30x30x1的數字數組，我們將其稱為要素圖。我們得到30x30陣列的原因是有300個不同的位置，3x3濾鏡可以放在32x32輸入圖像上。這900個數字映射到30x30陣列。我們可以通過以下方式計算卷積圖像：</p><pre>Convolved: (N−F)/S + 1</pre><p>其中，N和F分別代表輸入圖像和內核大小，S代表步幅或步長。</p><p>假設我們有一個3x3濾波器，在5x5矩陣上進行卷積，根據等式，我們應該得到一個3x3矩陣，技術上稱為激活映射或特徵映射。</p><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535946554311632db173f1><p class=pgc-img-caption></p></div><p>實際上，我們可以使用不止一個過濾器，我們的輸出量將是28 * 28 * n（其中n是激活圖的數量）。通過使用更多過濾器，我們能夠更好保留空間維度。</p><p>對於圖像矩陣邊界上的像素，內核的一些元素可能站在圖像矩陣之外，因此不具有來自圖像矩陣的任何對應元素。在這種情況下，我們可以消除這些位置的卷積運算，最終出現小於輸入的輸出矩陣，或者我們可以將填充應用於輸入矩陣。</p><p>我們可以將自定義統一窗口應用於圖像：</p><pre>%%timeimport numpy as npimport imageioimport matplotlib.pyplot as pltfrom scipy.signal import convolve2ddef Convolution(image, kernel): conv_bucket = [] for d in range(image.ndim): conv_channel = convolve2d(image[:,:,d], kernel, mode="same", boundary="symm") conv_bucket.append(conv_channel) return np.stack(conv_bucket, axis=2).astype("uint8")kernel_sizes = [9,15,30,60]fig, axs = plt.subplots(nrows = 1, ncols = len(kernel_sizes), figsize=(15,15));pic = imageio.imread('img:/parrot.jpg')for k, ax in zip(kernel_sizes, axs): kernel = np.ones((k,k)) kernel /= np.sum(kernel) ax.imshow(Convolution(pic, kernel)); ax.set_title("Convolved By Kernel: {}".format(k)); ax.set_axis_off();Wall time: 43.5 s</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15359465546062b8fdbc70d><p class=pgc-img-caption></p></div><p>輪廓內核（又名“邊緣”內核）用於突出顯示像素值之間的差異，亮度接近的相鄰像素旁邊的像素在新圖像中將顯示為黑色，而差異性較大的相鄰像素的旁邊像素將顯示為白色。</p><pre>%%timefrom skimage import colorfrom skimage import exposureimport numpy as npimport imageioimport matplotlib.pyplot as plt# import imagepic = imageio.imread('img/crazycat.jpeg')plt.figure(figsize = (5,5))plt.imshow(pic)plt.axis('off');Wall time: 34.9 ms</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1535946554684428bca3216><p class=pgc-img-caption></p></div><pre># Convert the image to grayscaleimg = color.rgb2gray(pic)# outline kernel - used for edge detectionkernel = np.array([[-1,-1,-1], [-1,8,-1], [-1,-1,-1]])# we use 'valid' which means we do not add zero padding to our imageedges = convolve2d(img, kernel, mode = 'valid')# Adjust the contrast of the filtered image by applying Histogram Equalizationedges_equalized = exposure.equalize_adapthist(edges/np.max(np.abs(edges)), clip_limit = 0.03)# plot the edges_clippedplt.figure(figsize = (5,5))plt.imshow(edges_equalized, cmap='gray') plt.axis('off');</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15359465549101c06f7b8ac><p class=pgc-img-caption></p></div><p>讓我們用不同類型的過濾器試一下，比如Sharpen Kernel。銳化內核強調相鄰像素值的之間差異，這會讓圖像看起來更生動。讓我們將邊緣檢測內核應用於銳化內核的輸出，並使用 box blur filter進一步標準化。</p><pre>%%timefrom skimage import colorfrom skimage import exposurefrom scipy.signal import convolve2dimport numpy as npimport imageioimport matplotlib.pyplot as plt# Convert the image to grayscaleimg = color.rgb2gray(pic) # apply sharpen filter to the original imagesharpen_kernel = np.array([[0,-1,0], [-1,5,-1], [0,-1,0]])image_sharpen = convolve2d(img, sharpen_kernel, mode = 'valid')# apply edge kernel to the output of the sharpen kerneledge_kernel = np.array([[-1,-1,-1], [-1,8,-1], [-1,-1,-1]])edges = convolve2d(image_sharpen, edge_kernel, mode = 'valid')# apply normalize box blur filter to the edge detection filtered imageblur_kernel = np.array([[1,1,1], [1,1,1], [1,1,1]])/9.0;denoised = convolve2d(edges, blur_kernel, mode = 'valid')# Adjust the contrast of the filtered image by applying Histogram Equalizationdenoised_equalized = exposure.equalize_adapthist(denoised/np.max(np.abs(denoised)), clip_limit=0.03)plt.figure(figsize = (5,5))plt.imshow(denoised_equalized, cmap='gray') plt.axis('off')plt.show()</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15359465549667d3513a7f0><p class=pgc-img-caption></p></div><p>為了模糊圖像，可以使用大量不同的窗口和功能。 其中最常見的是Gaussian window。為了解它對圖像的作用，讓我們將此過濾器應用於圖像。</p><pre>%%timefrom skimage import colorfrom skimage import exposurefrom scipy.signal import convolve2dimport numpy as npimport imageioimport matplotlib.pyplot as plt# import imagepic = imageio.imread('img/parrot.jpg')# Convert the image to grayscaleimg = color.rgb2gray(pic)# gaussian kernel - used for blurringkernel = np.array([[1,2,1], [2,4,2], [1,2,1]])kernel = kernel / np.sum(kernel)# we use 'valid' which means we do not add zero padding to our imageedges = convolve2d(img, kernel, mode = 'valid')# Adjust the contrast of the filtered image by applying Histogram Equalizationedges_equalized = exposure.equalize_adapthist(edges/np.max(np.abs(edges)), clip_limit = 0.03)# plot the edges_clippedplt.figure(figsize = (5,5))plt.imshow(edges_equalized, cmap='gray') plt.axis('off')plt.show()</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535946555256e32bbc8caa><p class=pgc-img-caption></p></div><p>通過使用更多窗戶，可以提取不同種類的信息。 Sobel kernels 僅用於顯示特定方向上相鄰像素值的差異，嘗試使用內核函數沿一個方向近似圖像的梯度。</p><p>通過在X和Y方向移動，我們可以得到圖像中每個顏色的梯度圖。</p><pre>%%timefrom skimage import colorfrom skimage import exposurefrom scipy.signal import convolve2dimport numpy as npimport imageioimport matplotlib.pyplot as plt# import imagepic = imageio.imread('img/parrot.jpg')# right sobelsobel_x = np.c_[ [-1,0,1], [-2,0,2], [-1,0,1]]# top sobelsobel_y = np.c_[ [1,2,1], [0,0,0], [-1,-2,-1]]ims = []for i in range(3): sx = convolve2d(pic[:,:,i], sobel_x, mode="same", boundary="symm") sy = convolve2d(pic[:,:,i], sobel_y, mode="same", boundary="symm") ims.append(np.sqrt(sx*sx + sy*sy))img_conv = np.stack(ims, axis=2).astype("uint8")plt.figure(figsize = (6,5))plt.axis('off')plt.imshow(img_conv);</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153594655539344efb4418b><p class=pgc-img-caption></p></div><p>至於降噪，我們通常使用類似Gaussian Filter的濾波器，這是一種數字濾波技術，通常用於圖片降噪。通過將Gaussian Filter和gradient finding操作結合在一起，我們可以生成一些類似於原始圖像並以有趣方式扭曲的奇怪圖案。</p><pre>%%timefrom scipy.signal import convolve2dfrom scipy.ndimage import (median_filter, gaussian_filter)import numpy as npimport imageioimport matplotlib.pyplot as pltdef gaussain_filter_(img): """ Applies a median filer to all channels """ ims = [] for d in range(3): img_conv_d = gaussian_filter(img[:,:,d], sigma = 4) ims.append(img_conv_d) return np.stack(ims, axis=2).astype("uint8")filtered_img = gaussain_filter_(pic)# right sobelsobel_x = np.c_[ [-1,0,1], [-2,0,2], [-1,0,1]]# top sobelsobel_y = np.c_[ [1,2,1], [0,0,0], [-1,-2,-1]]ims = []for d in range(3): sx = convolve2d(filtered_img[:,:,d], sobel_x, mode="same", boundary="symm") sy = convolve2d(filtered_img[:,:,d], sobel_y, mode="same", boundary="symm") ims.append(np.sqrt(sx*sx + sy*sy))img_conv = np.stack(ims, axis=2).astype("uint8")plt.figure(figsize=(7,7))plt.axis('off')plt.imshow(img_conv);</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535946555598630edceecf><p class=pgc-img-caption></p></div><p>現在，讓我們來看看使用Median filter 可以對圖像產生什麼效果。</p><pre>%%timefrom scipy.signal import convolve2dfrom scipy.ndimage import (median_filter, gaussian_filter)import numpy as npimport imageioimport matplotlib.pyplot as pltdef median_filter_(img, mask): """ Applies a median filer to all channels """ ims = [] for d in range(3): img_conv_d = median_filter(img[:,:,d], size=(mask,mask)) ims.append(img_conv_d) return np.stack(ims, axis=2).astype("uint8")filtered_img = median_filter_(pic, 80)# right sobelsobel_x = np.c_[ [-1,0,1], [-2,0,2], [-1,0,1]]# top sobelsobel_y = np.c_[ [1,2,1], [0,0,0], [-1,-2,-1]]ims = []for d in range(3): sx = convolve2d(filtered_img[:,:,d], sobel_x, mode="same", boundary="symm") sy = convolve2d(filtered_img[:,:,d], sobel_y, mode="same", boundary="symm") ims.append(np.sqrt(sx*sx + sy*sy))img_conv = np.stack(ims, axis=2).astype("uint8")plt.figure(figsize=(7,7))plt.axis('off')plt.imshow(img_conv);</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535946555634890a53db73><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>閾值之 Ostu方法</strong></p><p>閾值處理是圖像處理中非常基本的操作，將灰度圖像轉換為單色是常見的圖像處理任務。而且，一個好的算法總是以良好的基礎開始！</p><p>Otsu閾值處理是一種簡單而有效的全局自動閾值處理方法，用於二值化灰度圖像，如前景和背景。在圖像處理中，Otsu的閾值處理方法（1979）基於直方圖的形狀自動二值化水平決定，完全基於對圖像直方圖執行的計算。</p><p>該算法假設圖像由兩個基本類組成：前景和背景，計算最小閾值並最小化兩類的類方差加權。</p><p><strong>算法</strong></p><p>如果我們在這個簡單的逐步算法中加入一點數學，那麼這種解釋就會發生變化：</p><p>計算每個強度級別的直方圖和概率。</p><ul><li>設置初始wi和μi。</li><li>從閾值t = 0到t = L-1：</li><li>oupdate：wi和μi</li><li>ocompute：σ_b** 2（t）</li><li>所需閾值對應於σ_b** 2（t）的最大值。</li></ul><pre>import numpy as npimport imageioimport matplotlib.pyplot as pltpic = imageio.imread('img/potato.jpeg')plt.figure(figsize=(7,7))plt.axis('off')plt.imshow(pic);</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535946555690f8c943c0b0><p class=pgc-img-caption></p></div><pre>def otsu_threshold(im): # Compute histogram and probabilities of each intensity level pixel_counts = [np.sum(im == i) for i in range(256)] # Initialization s_max = (0,0) for threshold in range(256): # update w_0 = sum(pixel_counts[:threshold]) w_1 = sum(pixel_counts[threshold:]) mu_0 = sum([i * pixel_counts[i] for i in range(0,threshold)]) / w_0 if w_0 &gt; 0 else 0  mu_1 = sum([i * pixel_counts[i] for i in range(threshold, 256)]) / w_1 if w_1 &gt; 0 else 0 # calculate - inter class variance s = w_0 * w_1 * (mu_0 - mu_1) ** 2 if s &gt; s_max[1]: s_max = (threshold, s) return s_max[0]</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535946555663fe1699a624><p class=pgc-img-caption></p></div><p>如果可以假設直方圖具有雙峰分佈並且兩峰之間具有深且尖銳的谷，則Otsu的方法會表現更優。如果前景與背景差異較小，則直方圖不會呈現雙峰性。</p><p><strong>K-Means聚類</strong></p><p>K-Means聚類是一種矢量量化方法，最初來自信號處理，是數據挖掘中聚類分析的常用方法。</p><p>在Otsu閾值處理中，我們找到了最小化段內像素方差的閾值。 因此，我們不是從灰度圖像中尋找閾值，而是在顏色空間中尋找聚類，通過這樣做，我們最終得到了K-means聚類。</p><pre>from sklearn import clusterimport matplotlib.pyplot as plt# load imagepic = imageio.imread('img/purple.jpg')plt.figure(figsize=(7,7))plt.imshow(pic)plt.axis('off');</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535946555877d3b4440736><p class=pgc-img-caption></p></div><p>為了聚類圖像，我們需要將其轉換為二維數組。</p><p>接下來，我們使用scikit-learn方法創建集群，傳遞n_clusters 5以形成五個集群。聚類出現在生成圖像中，將其分為五個部分，每部分的顏色不同。</p><pre>%%time# fit on the image with cluster fivekmeans_cluster = cluster.KMeans(n_clusters=5)kmeans_cluster.fit(pic_2d)cluster_centers = kmeans_cluster.cluster_centers_cluster_labels = kmeans_cluster.labels_</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535946555907bfb072ebde><p class=pgc-img-caption></p></div><p>一旦形成了簇，我們就可以使用簇中心和標籤重新創建圖像，以顯示具有分組模式的圖像。</p><p><strong>直線檢測之霍夫變換</strong></p><p>如果我們能夠以數學形式表示該形狀，則霍夫變換是一種用於檢測任何形狀的流行技術。它可以檢測形狀，即使它被破壞或扭曲一點點。 我們不會過於深入分析霍夫變換的機制。</p><p><strong>算法</strong></p><ul><li>Corner或邊緣檢測</li><li>ρ範圍和θ範圍創建</li><li>ρ：Dmax至Dmax</li><li>θ：90到90</li></ul><p><strong>霍夫變換</strong></p><ul><li>2D數組的行數等於ρ值的數量，列數等於θ值的數量。</li><li>在累加器中投票</li><li>對於每個邊緣點和θ值，找到最接近的ρ值並在累加器中遞增該索引。</li><li>累加器中的局部最大值指示輸入圖像中最突出的線的參數。</li></ul><pre>def hough_line(img): # Rho and Theta ranges thetas = np.deg2rad(np.arange(-90.0, 90.0)) width, height = img.shape diag_len = int(np.ceil(np.sqrt(width * width + height * height))) # Dmax rhos = np.linspace(-diag_len, diag_len, diag_len * 2.0) # Cache some resuable values cos_t = np.cos(thetas) sin_t = np.sin(thetas) num_thetas = len(thetas) # Hough accumulator array of theta vs rho accumulator = np.zeros((2 * diag_len, num_thetas), dtype=np.uint64) y_idxs, x_idxs = np.nonzero(img) # (row, col) indexes to edges # Vote in the hough accumulator for i in range(len(x_idxs)): x = x_idxs[i] y = y_idxs[i] for t_idx in range(num_thetas): # Calculate rho. diag_len is added for a positive index rho = round(x * cos_t[t_idx] + y * sin_t[t_idx]) + diag_len accumulator[rho, t_idx] += 1 return accumulator, thetas, rhos</pre><p><strong>邊緣檢測</strong></p><p>邊緣檢測是一種用於查找圖像內對象邊界的圖像處理技術。它的工作原理是檢測亮度的不連續性。</p><p>常見的邊緣檢測算法包括</p><ul><li>Sobel</li><li>Canny</li><li>Prewitt</li><li>Roberts</li><li>fuzzy logic methods</li></ul><p>在這裡，我們將介紹一種最流行的方法，即Canny Edge Detection（Canny邊緣檢測）。</p><p><strong>Canny邊緣檢測</strong></p><p>一種能夠檢測圖像中較寬範圍邊緣的多級邊緣檢測操作，Canny邊緣檢測算法可以分解為5步：</p><ul><li>應用高斯濾波器</li><li>找出強度梯度</li><li>應用非極大值抑制</li><li>應用雙閾值</li><li>通過滯後性門限跟蹤邊緣線</li></ul><p><strong>圖片矢量之輪廓跟蹤</strong></p><p>使用Scikit-Image，我們可以使用輪廓跟蹤算法提取圖片邊緣路徑（勾勒圖片輪廓），這可以控制最終路徑遵循原始位圖的形狀。</p><pre>from sklearn.cluster import KMeansimport matplotlib.pyplot as pltfrom skimage import measureimport numpy as npimport imageiopic = imageio.imread('img/parrot.jpg')h,w = pic.shape[:2]im_small_long = pic.reshape((h * w, 3))im_small_wide = im_small_long.reshape((h,w,3))km = KMeans(n_clusters=2)km.fit(im_small_long)seg = np.asarray([(1 if i == 1 else 0) for i in km.labels_]).reshape((h,w))contours = measure.find_contours(seg, 0.5, fully_connected="high")simplified_contours = [measure.approximate_polygon(c, tolerance=5) for c in contours]plt.figure(figsize=(5,10))for n, contour in enumerate(simplified_contours): plt.plot(contour[:, 1], contour[:, 0], linewidth=2)plt.ylim(h,0)plt.axes().set_aspect('equal')</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535946555902191f40f236><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>圖像壓縮之堆疊自編碼器</strong></p><p>Autoencoder是一種數據壓縮算法，其中壓縮和解壓縮功能是：</p><ul><li>Data-specific</li><li>Lossy</li></ul><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153594655594997e8391a8c><p class=pgc-img-caption></p></div><p>以下為具體實現代碼：</p><pre>import numpy as npimport matplotlib.pyplot as pltimport tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets("MNIST_data",one_hot=True)# Parameternum_inputs = 784 # 28*28neurons_hid1 = 392neurons_hid2 = 196neurons_hid3 = neurons_hid1 # Decoder Beginsnum_outputs = num_inputslearning_rate = 0.01# activation functionactf = tf.nn.relu# place holderX = tf.placeholder(tf.float32, shape=[None, num_inputs])# Weightsinitializer = tf.variance_scaling_initializer()w1 = tf.Variable(initializer([num_inputs, neurons_hid1]), dtype=tf.float32)w2 = tf.Variable(initializer([neurons_hid1, neurons_hid2]), dtype=tf.float32)w3 = tf.Variable(initializer([neurons_hid2, neurons_hid3]), dtype=tf.float32)w4 = tf.Variable(initializer([neurons_hid3, num_outputs]), dtype=tf.float32)# Biasesb1 = tf.Variable(tf.zeros(neurons_hid1))b2 = tf.Variable(tf.zeros(neurons_hid2))b3 = tf.Variable(tf.zeros(neurons_hid3))b4 = tf.Variable(tf.zeros(num_outputs))# Activation Function and Layersact_func = tf.nn.reluhid_layer1 = act_func(tf.matmul(X, w1) + b1)hid_layer2 = act_func(tf.matmul(hid_layer1, w2) + b2)hid_layer3 = act_func(tf.matmul(hid_layer2, w3) + b3)output_layer = tf.matmul(hid_layer3, w4) + b4# Loss Functionloss = tf.reduce_mean(tf.square(output_layer - X))# Optimizeroptimizer = tf.train.AdamOptimizer(learning_rate)train = optimizer.minimize(loss)# Intialize Variablesinit = tf.global_variables_initializer()saver = tf.train.Saver()num_epochs = 5batch_size = 150with tf.Session() as sess: sess.run(init) # Epoch == Entire Training Set for epoch in range(num_epochs): num_batches = mnist.train.num_examples // batch_size # 150 batch size for iteration in range(num_batches): X_batch, y_batch = mnist.train.next_batch(batch_size) sess.run(train, feed_dict={X: X_batch}) training_loss = loss.eval(feed_dict={X: X_batch})  print("Epoch {} Complete. Training Loss: {}".format(epoch,training_loss)) saver.save(sess, "./stacked_autoencoder.ckpt") # Test Autoencoder output on Test Datanum_test_images = 10with tf.Session() as sess: saver.restore(sess,"./stacked_autoencoder.ckpt") results = output_layer.eval(feed_dict={X:mnist.test.images[:num_test_images]})Extracting MNIST_data\train-images-idx3-ubyte.gzExtracting MNIST_data\train-labels-idx1-ubyte.gzExtracting MNIST_data\t10k-images-idx3-ubyte.gzExtracting MNIST_data\t10k-labels-idx1-ubyte.gzEpoch 0 Complete. Training Loss: 0.023349963128566742Epoch 1 Complete. Training Loss: 0.022537199780344963Epoch 2 Complete. Training Loss: 0.0200303066521883Epoch 3 Complete. Training Loss: 0.021327141672372818Epoch 4 Complete. Training Loss: 0.019387174397706985INFO:tensorflow:Restoring parameters from ./stacked_autoencoder.ckpt</pre><div class=pgc-img><img alt=技術實踐——Python圖像處理進階：多種圖像變換算法實踐！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535946556183f12f15e9d4><p class=pgc-img-caption></p></div><p>第一行加載MNIST訓練集，第二行使用自編碼器進行編碼和解碼，之後重構訓練集。但是，重建圖像中缺少大量信息。因此，自編碼器不如其他壓縮技術好，但作為一門正在快速增長中的技術，其未來還會出現很多進步。</p><p>（代碼下載可訪問Github地址：https://github.com/iphton/Image-Processing-in-Python）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>實踐</a></li><li><a>圖像</a></li><li><a>技術</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/53841e0d.html alt="馬鋼3# 高爐大修技術改造實踐" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c4733b279b994389b8d95831dbfa98d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/53841e0d.html title="馬鋼3# 高爐大修技術改造實踐">馬鋼3# 高爐大修技術改造實踐</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aaeb1368.html alt=「物聯網」物聯網技術與實踐+物聯網應用開發詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/21375229d54b4ffc953a18761e6f103c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aaeb1368.html title=「物聯網」物聯網技術與實踐+物聯網應用開發詳解>「物聯網」物聯網技術與實踐+物聯網應用開發詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/ffe9c670.html alt=高考救急乾貨：生物技術實踐，從入門到精通 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152803729462688aba36da5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/ffe9c670.html title=高考救急乾貨：生物技術實踐，從入門到精通>高考救急乾貨：生物技術實踐，從入門到精通</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/d186059d.html alt=大棚青椒高產栽培配套技術探索與實踐 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152099252426392acdf2af8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/d186059d.html title=大棚青椒高產栽培配套技術探索與實踐>大棚青椒高產栽培配套技術探索與實踐</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50cceeaa.html alt=使用數字圖像技術分析不同壓實條件下瀝青混合料級配特徵 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9de4261f873441d89b108cb00baa8a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50cceeaa.html title=使用數字圖像技術分析不同壓實條件下瀝青混合料級配特徵>使用數字圖像技術分析不同壓實條件下瀝青混合料級配特徵</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ddebe5.html alt=技術文章—高性能圖像傳感器參考設計的核心集成與協作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6b63977859a842e98a2986ec001723f6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ddebe5.html title=技術文章—高性能圖像傳感器參考設計的核心集成與協作>技術文章—高性能圖像傳感器參考設計的核心集成與協作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html alt="技術帖 | 3分鐘搞定各種測試分析技術" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f055e0a4477240088de2abb7cd696cfa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html title="技術帖 | 3分鐘搞定各種測試分析技術">技術帖 | 3分鐘搞定各種測試分析技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6acbddb.html alt=「壓鑄實踐」大截面ZA27鋅合金蝸輪的雙重擠壓鑄造應用案例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/972374c8b24644389e188cb290249f17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6acbddb.html title=「壓鑄實踐」大截面ZA27鋅合金蝸輪的雙重擠壓鑄造應用案例>「壓鑄實踐」大截面ZA27鋅合金蝸輪的雙重擠壓鑄造應用案例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d0ddee5.html alt=建築房屋結構平衡技術要求，你都會知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e7d0001715d878ed66c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d0ddee5.html title=建築房屋結構平衡技術要求，你都會知道嗎？>建築房屋結構平衡技術要求，你都會知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47c8cac0.html alt=新《裝配式混凝土建築技術標準》有哪些改變？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1540524372015dc56ec3fb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47c8cac0.html title=新《裝配式混凝土建築技術標準》有哪些改變？>新《裝配式混凝土建築技術標準》有哪些改變？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6c2fc2b.html alt=鈦合金精密鑄造技術發展現狀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SCynkUUBbHN8CF style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6c2fc2b.html title=鈦合金精密鑄造技術發展現狀>鈦合金精密鑄造技術發展現狀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2e8af08.html alt=傾斜航攝技術小知識——航線設計篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RS1ucOiDvLRlVt style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2e8af08.html title=傾斜航攝技術小知識——航線設計篇>傾斜航攝技術小知識——航線設計篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d597da51.html alt=黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1528429551298e033646798 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d597da51.html title=黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量>黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdb604f6.html alt=《雷神4：愛與雷》將採用“虛擬製作”技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/83a320a69b0f44e3baf7db07faac3c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdb604f6.html title=《雷神4：愛與雷》將採用“虛擬製作”技術>《雷神4：愛與雷》將採用“虛擬製作”技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cd5b6b6.html alt=虛擬現實技術在智能製造領域具有重要的應用價值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ed327880d3b4c5384619f21d6c81823 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cd5b6b6.html title=虛擬現實技術在智能製造領域具有重要的應用價值>虛擬現實技術在智能製造領域具有重要的應用價值</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>