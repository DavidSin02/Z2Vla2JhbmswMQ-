<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android 屏幕繪製機制及硬件加速 | 极客快訊</title><meta property="og:title" content="Android 屏幕繪製機制及硬件加速 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f1fda8c0a126491eade5670556b21f64"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/68317c0f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/68317c0f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/68317c0f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/68317c0f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/68317c0f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/68317c0f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/68317c0f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/68317c0f.html><meta property="article:published_time" content="2020-10-29T21:08:51+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:51+08:00"><meta name=Keywords content><meta name=description content="Android 屏幕繪製機制及硬件加速"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/68317c0f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android 屏幕繪製機制及硬件加速</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>近日，由法拉第未來前CFO創立的電動汽車初創企業 EVelozcity向洛杉磯高等法院起訴法拉第未來大股東以及代理CEO賈躍亭，稱其引誘並要求員工簽署包含競業禁止條款的僱傭協議，EVelozcity認為法拉第未來使用威脅和欺騙手段阻止其僱員自由尋找新的工作機會。對此，法拉第未來回應稱，該訴訟是看到“FF91取得了進展，而蓄意騷擾和詆譭法拉第未來，法拉第未來滿懷信心在這一訴訟中大獲全勝。”</p><p class=ql-align-center>作者簡介</p><p>本篇來自投稿老司機 <strong>凶殘的程序員</strong>的投稿，分享了關於Android 屏幕繪製機制及硬件加速的相關內容，一起來看看！希望大家喜歡。</p><p><strong>凶殘的程序員</strong>的博客地址：</p><blockquote><p>https://blog.csdn.net/qian520ao</p></blockquote><p class=ql-align-center>前言</p><p>開發手機應用最主要的兩個點是</p><ol><li>處理用戶屏幕觸碰輸入</li><li>界面效果展示(包含動畫和各種反饋)</li></ol><p>但是在早期的 Android 並不是那麼盡人意，給用戶的感覺就是卡頓，系統處理圖形能力差，開發者再怎麼優化也是枉然。從 Android 4.0+ 開始，以 “run fast, smooth, and responsively” 為核心目標對 UI 進行優化，應用默認都開啟和使用硬件加速方式加速 UI 的繪製。首先講解一下硬件加速相關概念。</p><p class=ql-align-center>正文</p><h1><strong>硬件加速</strong></h1><h1>Android 系統的 UI 從 繪製 到 顯示在屏幕上 是分兩個步驟的</h1><h1>第一步：在Android 應用程序這一側進行的。(將 UI 構建到一個圖形緩衝區 Buffer 中，交給SurfaceFlinger )</h1><h1>第二步：在SurfaceFlinger進程這一側進行的。(獲取Buffer 併合成以及顯示到屏幕中。)</h1><h1>其中，第二步在 SurfaceFlinger 的操作一直是以硬件加速方式完成的，所以我們說的硬件加速一般指的是在 應用程序 圖形通過GPU加速渲染 到 Buffer 的過程。</h1><p><strong>CPU / GPU結構對比</strong></p><p>以下內容摘自 ： 木葉57的博客，博客地址如下：</p><blockquote><p>https://blog.csdn.net/u011403718/article/details/54630760</p></blockquote><p>總結的很到位。</p><ul><li>CPU : Central Processing Unit ， 中央處理器，是計算機設備核心器件，用於執行程序代碼。</li><li>GPU : Graphic Processing Unit ， 圖形處理器，主要用於處理圖形運算，通常所說“顯卡”的核心部件就是GPU。</li></ul><p>下面是CPU和GPU的結構對比圖。其中：</p><ul><li>黃色的Control為控制器，用於協調控制整個CPU的運行，包括取出指令、控制其他模塊的運行等；</li><li>綠色的ALU（Arithmetic Logic Unit）是算術邏輯單元，用於進行數學、邏輯運算；</li><li>橙色的Cache和DRAM分別為緩存和RAM，用於存儲信息。</li></ul><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1fda8c0a126491eade5670556b21f64><p class=pgc-img-caption></p></div><p>從結構圖可以看出，CPU的控制器較為複雜，而ALU數量較少。因此CPU擅長各種複雜的邏輯運算，但不擅長數學尤其是浮點運算。</p><ul><li>以8086為例，一百多條彙編指令大部分都是邏輯指令，數學計算相關的主要是16位加減乘除和移位運算。一次整型和邏輯運算一般需要1~3個機器週期，而浮點運算要轉換成整數計算，一次運算可能消耗上百個機器週期。</li><li>更簡單的CPU甚至只有加法指令，減法用補碼加法實現，乘法用累加實現，除法用減法循環實現。</li><li>現代CPU一般都帶有硬件浮點運算器（FPU），但主要適用於數據量不大的情況。</li></ul><p>CPU是串行結構。以計算100個數字為例，對於CPU的一個核，每次只能計算兩個數的和，結果逐步累加。</p><p>和CPU不同的是，GPU就是為實現大量數學運算設計的。從結構圖中可以看到，GPU的控制器比較簡單，但包含了大量ALU。GPU中的ALU使用了並行設計，且具有較多浮點運算單元。</p><p>硬件加速的主要原理，就是通過底層軟件代碼，將CPU不擅長的圖形計算轉換成GPU專用指令，由GPU完成。</p><p><strong>OpenGL</strong></p><p>Android 開發人員可以通過使用 OpenGL ES 來實現硬件加速渲染圖形。</p><p>首先了解一下兩個單詞 : OpenGL ，OpenGL ES</p><ul><li>OpenGL（Open Graphics Library） ： 是指定義了一個跨編程語言、跨平臺的編程接口規格的專業的圖形程序接口。它用於三維圖像（二維的亦可），是一個功能強大，調用方便的底層圖形庫。</li><li>OpenGL ES （OpenGL for Embedded Systems） 是 OpenGL 三維圖形 API 的子集，針對手機、PDA和遊戲主機等嵌入式設備而設計。</li></ul><blockquote><p>這裡我們首先要明確什麼是硬件加速渲染，其實就是通過GPU來進行渲染。</p><p>GPU作為一個硬件，用戶空間是不可以直接使用的，它是由GPU廠商按照Open GL規範實現的驅動間接進行使用的。</p><p><strong>也就是說，如果一個設備支持GPU硬件加速渲染，那麼當Android應用程序調用Open GL接口來繪製UI時，Android應用程序的 UI 就是通過硬件加速技術進行渲染的。</strong></p></blockquote><p><strong>Android 的圖形組件</strong></p><p>如果把開發者編寫的應用程序圖形效果展示過程當做是一次酣暢淋漓的畫作過程，那麼繪畫過程中 Android 的各個角色又是怎麼分工合作的 ：</p><ul><li><strong>畫筆</strong></li></ul><p>Skia : CPU 繪製 2D 圖形；</p><p>Open GL : GPU 繪製 2D / 3D 圖形；</p><ul><li><strong>畫紙</strong></li></ul><p>Surface : Android 4.4+ 應用程序都在 Surface 這張畫紙上進行繪製和渲染。</p><ul><li><strong>畫板</strong></li></ul><p>Graphic Buffer : 在屏幕刷新機制提到，Android 4.1+ 後有 3 塊 Graphic Buffer 用於應用程序圖形繪製，或 SurfaceFlinger 的合成和顯示。</p><ul><li><strong>合成及顯示</strong></li></ul><p>SurfaceFlinger : 合成所有圖層並進行顯示。（Surface 的投遞者）</p><p>下面瞭解Android 圖形系統的整體架構</p><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b40a8a1948fa48879e96a6f3b5772abf><p class=pgc-img-caption></p></div><p>Image Stream Producers ： 圖形流生產者，應用程序內繪製到 Surface 的圖形( xml / java 實現的圖形，或者是視頻 )</p><p>Window Manager ： 在Android Window 機制探索，地址如下：</p><blockquote><p>https://blog.csdn.net/qian520ao/article/details/78555397#t10</p></blockquote><p>這篇文章中說道 ——「Window是View的直接管理者。」，Window 是 View的容器，每個窗口都會包含一個 Surface 。Window Manager 管理窗口的各個方面，包括生命週期，輸入和焦點事件，屏幕旋轉，切換動畫，位置，轉換，Z-Order等。Window Manager 會將 Window 的這些元素數據傳遞給 SurfaceFlinger 。</p><p>SurfaceFlinger ： 根據Window Manager 提供的內容將它們合成並輸出到顯示屏上。它使用 OpenGL 和 HardWareComposer 來合成 Surface 。（其它消費者也有可能是OpenGL ES 應用，例如相機或者其它），開頭有提到硬件加速指的是應用程序內圖形渲染加速的過程，而 SurfaceFlinger 一直是通過 OpenGL 來合成和輸出圖形。</p><p>HWC ： Hardware Composer ，硬件合成器。（瞭解即可），這是顯示控制器系統的硬件抽象。SurfaceFlinger 會委派一些合成的工作給 Hardware Composer 以此減輕 GPU 的負載。這樣會比單純通過 GPU 來合成消耗更少的電量。</p><p>Gralloc ： Graphics memory allocator 用來分配圖形的內存。</p><ul><li>應用程序可以通過Skia來繪製2D圖形，也可以用OpenGL來繪製2D / 3D圖形（應用加速指的是應用內使用OpenGL處理和渲染圖形）</li><li>SurfaceFlinger 會通過OpenGL來混合圖形到指定的Surface上送往HWC進行合成。</li></ul><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/495c50c87a784ec78b2530e65bdff4ad><p class=pgc-img-caption></p></div><p><strong>CPU / GPU 繪製過程</strong></p><p>下面我們通過代碼來分析軟件繪製與硬件加速的不同點。</p><ul><li><strong>軟件繪製</strong></li></ul><p>talk is cheap ， read the resource code .</p><pre>//ViewRootImpl private void performDraw() { `````` try { draw(fullRedrawNeeded); } } private void draw(boolean fullRedrawNeeded) { Surface surface = mSurface; `````` if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) { //支持及開啟了硬件加速 if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) { mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this);//硬件加速繪製 } else { //軟件繪製 if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) { return; } } } } // These can be accessed by any thread, must be protected with a lock. // Surface can never be reassigned or cleared (use Surface.clear()). final Surface mSurface = new Surface();//每個ViewRootImpl對應一個Surface</pre><p>在上面有說道 ： 「Window是View的直接管理者。」，Window 是 View的容器，每個窗口都會包含一個 Surface 。</p><pre>//Surface 的三個構造函數 /** * Create an empty surface, which will later be filled in by readFromParcel(). * @hide */ public Surface() { } public Surface(SurfaceTexture surfaceTexture) { if (surfaceTexture == null) { throw new IllegalArgumentException("surfaceTexture must not be null"); } mIsSingleBuffered = surfaceTexture.isSingleBuffered(); synchronized (mLock) { mName = surfaceTexture.toString(); setNativeObjectLocked(nativeCreateFromSurfaceTexture(surfaceTexture)); } } private Surface(long nativeObject) { synchronized (mLock) { setNativeObjectLocked(nativeObject); } }</pre><blockquote><p>Surface有3種構造函數，這裡採用的是第一種構造函數，即創建一個空的Surface對象，並沒有初始化該Surface的native層，其實應用程序進程的Surface創建過程是由WMS服務來完成，WMS服務通過Binder跨進程方式將創建好Surface返回給應用程序進程。</p></blockquote><p>也就是說應用程序（在ViewRootImpl裡）雖然創建了空的Surface對象，但實際上在 WMS 那一側也會創建一個真正能用的 Surface 並賦值到這個空的Surface 。瞭解更多 Surface 創建與賦值過程可以參考文章 ： AndroidO 圖形框架下應用繪圖過程——Surface創建.</p><blockquote><p>https://blog.csdn.net/yangwen123/article/details/80674965</p></blockquote><pre>/** * @return true if drawing was successful, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) { final Canvas canvas; canvas = mSurface.lockCanvas(dirty);//獲取Skia Canvas try { mView.draw(canvas);//圖形繪製 } finally { surface.unlockCanvasAndPost(canvas);//將繪製的結果進行提交 } return true; }</pre><ul><li>lockCanvas : （鎖定界面中需要繪製的部分）每個窗口都關聯一個Surface，當這個窗口需要繪製 UI 時，就會調用關聯的 Surface 的 lockCanvas()方法獲得一個Canvas，（這個Canvas 封裝了由 Skia 提供的 2D 圖形繪製接口）並且向 SurfaceFlinger Dequeue 一個Graphic Buffer，繪製的內容都會輸出到 Graphic Buffer 上再交由 SurfaceFlinger 對圖形內容的合成及顯示到屏幕上。</li><li>draw : 將View的內容繪製到Canvas上。</li><li>unlockCanvasAndPost : 繪製完成之後，調用unlockCanvasAndPost請求將Canvas 顯示到屏幕上，其本質上是向SurfaceFlinger服務Queue一個Graphic Buffe。</li></ul><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ff4da979441541c6bf783d72cd9efccd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/99a901d2e0b44ce99d7d3a21868596fc><p class=pgc-img-caption></p></div><p><strong>硬件加速</strong></p><p>硬件加速優化點 ：</p><ul><li>軟件繪製（單純使用CPU）的整個繪製過程都是在主線程進行，如果同時要響應用戶輸入事件，那麼就很有可能造成卡頓。</li><li>GPU 對圖形的繪製渲染能力更勝一籌，如果使用 GPU 並在不同線程繪製渲染圖形，那麼整個流程會更加順暢。</li><li>硬件加速過程中包含兩個步驟 ：</li><li>構建階段 ： 遍歷所有視圖，將需要繪製的操作緩存下來，交給單獨的Render線程使用GPU進行硬件加速渲染。(這一階段在主線程中使用CPU構建)</li><li>繪製階段 ： 調用OpenGL（即使用GPU）對構建好的視圖進行繪製渲染，繪製的內容保存在Graphic Buffer 並交由 SurfaceFlinger 顯示。(Android 5.0+ 使用Render Thread線程，專門負責 UI 渲染和動畫顯示。)</li></ul><p><strong>視圖構建</strong></p><p>參考：看書的小蝸牛，地址如下：</p><blockquote><p>https://www.jianshu.com/p/40f660e17a73</p></blockquote><p>硬件加速原理分析的很透徹。</p><p>Android硬件加速過程中，View視圖被抽象成RenderNode節點，View中的繪製操作都會被抽象成一個個DrawOp，比如View中drawLine，構建中就會被抽象成一個DrawLineOp，drawBitmap操作會被抽象成DrawBitmapOp</p><p>每個子View的繪製被抽象成DrawRenderNodeOp，每個DrawOp有對應的OpenGL繪製命令，同時內部也握著繪圖所需要的數據。如下所示：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/647f791b6c914400a06f2bb11cd71659><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><blockquote><p>每個View不僅僅握有自己DrawOp List，同時還拿著子View的繪製入口，如此遞歸，便能夠統計到所有的繪製Op，源碼中稱為 Display List 。（也就是說根結點的RenderNode可以訪問所有的繪製Op）</p></blockquote><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eec24d2b13924d99ab15ae94f449ecf0><p class=pgc-img-caption></p></div><blockquote><p>構建完成後，將繪圖Op樹 Display List 交給Render線程進行繪製，這裡是同軟件繪製很不同的地方，軟件繪製時，View一般都在主線程中完成繪製，而硬件加速，除非特殊要求，一般都是在單獨線程中完成繪製，如此以來就分擔了主線程很多壓力，提高了UI線程的響應速度。</p></blockquote><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/94109f4c7c3541ed82386704ba0bcb75><p class=pgc-img-caption></p></div><p>Display List的本質是一個緩衝區，記錄了即將要執行的OpenGL繪製命令，這些繪製命令最終會為由GPU執行。</p><p>將繪製操作命令構建在 Display List 的好處有 ：</p><ol><li>如果視圖 UI 沒有發生變化，那麼就可以不用執行相關的 Canvas API （不用執行onDraw），可以直接複用上次構建的 Display List 圖形緩存。</li><li>如果視圖 UI 發生變化，但只是一些簡單的屬性變化，例如透明度平移旋轉等簡單屬性，也可以不用重新構建 Display List，而是修改上次構建的 Display List 相關屬性即可。</li></ol><pre>//ThreadedRenderer void draw(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks) { updateRootDisplayList(view, callbacks);//構建View的DrawOp樹 `````` //通知RenderThread線程繪製 int syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length); } private void updateRootDisplayList(View view, HardwareDrawCallbacks callbacks) { //來構建參數view(DecorView)視圖的Display List updateViewTreeDisplayList(view); //mRootNodeNeedsUpdate true表示要更新視圖 //mRootNode.isValid() 表示已經構建了Display List if (mRootNodeNeedsUpdate || !mRootNode.isValid()) { //獲取DisplayListCanvas DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight); try { //ReorderBarrie表示會按照Z軸座標值重新排列子View的渲染順序 canvas.insertReorderBarrier(); //構建並緩存所有的DrawOp canvas.drawRenderNode(view.updateDisplayListIfDirty()); canvas.insertInorderBarrier(); canvas.restoreToCount(saveCount); } finally { //將所有的DrawOp填充到根RootNode中，作為新的Display List mRootNode.end(canvas); } } }</pre><p>ThreadedRenderer 的主要作用是在主線程中（CPU）構建視圖，並將構建好的視圖通知到RenderThread讓其使用OpenGL繪製渲染。（調用nSyncAndDrawFrame()）</p><p>在updateRootDisplayList()方法中開始構建Display List，也就是構建Draw Op命令序列。該方法主要有以下流程 ：</p><ul><li>通過根View的RenderNode獲得DisplayListCanvas （mRootNode.start()）</li><li>調用view.updateDisplayListIfDirty()遍歷獲得Draw OP命令樹，並且構建到DisplayListCanvas 上</li><li>將緩存的Draw Op填充到根View的RenderNode中，完成視圖構建。（ mRootNode.end(canvas)）</li></ul><p>下面看一下View的updateDisplayListIfDirty()方法，從命名中就可以知道如果View沒有改變佈局（dirty），便不會重構。</p><pre>//View View() { mResources = null; mRenderNode = RenderNode.create(getClass().getName(), this); } /** * Gets the RenderNode for the view, and updates its DisplayList (if needed and supported) */ @NonNull public RenderNode updateDisplayListIfDirty() { final RenderNode renderNode = mRenderNode; if ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0 || !renderNode.isValid() || (mRecreateDisplayList)) { `````` if (renderNode.isValid() &amp;&amp; !mRecreateDisplayList) { //當前View是ViewGroup，並且自身不用重構，遞歸子View dispatchGetDisplayList(); return renderNode; } final DisplayListCanvas canvas = renderNode.start(width, height); try { if (layerType == LAYER_TYPE_SOFTWARE) { //軟件繪製 buildDrawingCache(true); Bitmap cache = getDrawingCache(true); if (cache != null) { canvas.drawBitmap(cache, 0, 0, mLayerPaint); } } else { if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) { //當前為ViewGroup，並且自身不用繪製，遞歸子View dispatchDraw(canvas); } else { //如果是ViewGroup會調用dispatchDraw從而遞歸調用子View的draw draw(canvas); } } } finally { //將緩存的Draw Op(也就是Display List)填充到RenderNode中 renderNode.end(canvas); setDisplayListProperties(renderNode);//設置renderNode屬性 } }  return renderNode;//構建完成 }</pre><p>在三種情況下，View需要重新構建當前View包括子View的Display ：</p><ul><li>View類的成員變量mPrivateFlags的值的PFLAG_DRAWING_CACHE_VALID位等於0，這表明上次構建的Display List已經失效。</li><li>View類的成員變量mRenderNode描述的Render Node內部維護的Display List Data還沒有設置或者已經被銷燬</li><li>View類的成員變量mRecreateDisplayList的值等於true，這直接表明需要重新構建Display List。</li></ul><p>在View的updateDisplayListIfDirty()流程中，構建過程如下 ：</p><ul><li>從當前View關聯的Render Node獲得一個DisplayListCanvas。</li><li>將當前View以及子View的 UI 繪製命令記錄到 DisplayListCanvas。（draw(canvas)）</li><li>最後將已經繪製在 DisplayListCanvas 的 Display List Data 填充到當前 View 關聯的 Render Node 中。（renderNode.end(canvas)）</li></ul><p>這樣，一個應用程序窗口的Display List就構建完成了。這個構建完成的Display List對應的就是應用程序窗口的Root Render Node的Display List，並且這個Display List通過遞歸的方式包含了所有子View的Display List。</p><p>額外點</p><p>硬件加速過程中如何支持軟件繪製的api</p><p>只有支持並開啟硬件加速的View才會關聯有RenderNode，同時GPU不是支持所有的2D UI 繪製命令具體可以查看android developer文檔，所以GPU不支持的繪製命令只能通過軟件方式來繪製渲染。</p><p>具體的做法是通過buildDrawingCache()方法通過View緩存獲得Bitmap，也就是說View的繪製都發生在這個Bitmap上。繪製完成之後，這個Bitmap會被記錄到父VIew的 Display List中。而當Parent View的Display List的命令被執行時，記錄在裡面的Bitmap再通過Open GL命令來繪製。</p><p>View主要的 UI 操作是由成員函數onDraw實現的，通過onDraw方法參數可以獲得一個canvas實現繪製API。但對View來說，它是不需要區別它是通過硬件渲染還是軟件渲染的。</p><p>如果當前正在處理的View是一個View Group，會通過dispatchDraw遍歷調用子View進行繪製。</p><p>此外，對於使用硬件渲染的View來說，它的Background也是抽象為一個Render Node繪製在宿主View關聯的一個Render Node上的，相當於是將Background看作是一個View的子View。（通過View的drawBackground()方法的drawRenderNode體現）所以佈局中去除重複或者不必要的background能夠加快CPU的構建速度，同時也能減輕GPU渲染負擔，具體可以在開發者選項中調試GPU過度繪製查看佈局情況。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9505abca326449a2abab19636c20863d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>藍色，淡綠，淡紅，深紅代表了4種不同程度的Overdraw情況，我們的目標就是儘量減少紅色Overdraw，看到更多的藍色區域。</p><blockquote><p>Overdraw有時候是因為你的UI佈局存在大量重疊的部分，還有的時候是因為非必須的重疊背景。例如某個Activity有一個背景，然後裡面的Layout又有自己的背景，同時子View又分別有自己的背景。僅僅是通過移除非必須的背景圖片，這就能夠減少大量的紅色Overdraw區域，增加藍色區域的佔比。這一措施能夠顯著提升程序性能。</p></blockquote><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/101ac816a4c442469a5f78f77ac763cd><p class=pgc-img-caption></p></div><p>以上便是硬件加速過程中Display List （圖形緩衝區）的構造過程，最後我們再來看一小段代碼，領略一下 Display List 帶來的如絲般順滑體驗的原理。（View 改變透明度）</p><pre>//View public void setAlpha(float alpha) { if (mTransformationInfo.mAlpha != alpha) { mTransformationInfo.mAlpha = alpha; invalidateViewProperty(true, false); mRenderNode.setAlpha(getFinalAlpha()); } } void invalidateViewProperty(boolean invalidateParent, boolean forceRedraw) { if (!isHardwareAccelerated() || !mRenderNode.isValid() || (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) != 0) { //不支持硬件加速，刷新 invalidate(false); } else { damageInParent();//通知父View 更新當前View的屬性 } if (isHardwareAccelerated() &amp;&amp; invalidateParent &amp;&amp; getZ() != 0) { damageShadowReceiver(); } }</pre><p><strong>純軟件繪製 VS 硬件加速</strong></p><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5dea6e7e0b474c888b2d0db5c1684a3a><p class=pgc-img-caption></p></div><p><strong>硬件加速小結</strong></p><p>Resterization ： 柵格化。指的是繪製Button，Shape，Path，String，Bitmap等組件最基礎的操作。柵格化把那些組件拆分到不同的像素上進行顯示。這是一個很費時的操作，GPU的引入就是為了加快柵格化的操作。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/65f811da0c6248dabf3c3352461d824c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>硬件加速過程中構建階段 CPU 負責把 UI 視圖組件計算成Polygons，Texture紋理，然後交給 GPU 在獨立線程中進行柵格化渲染。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/932b13383016492dbc55e844753171ed><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>在Android裡面那些由主題所提供的資源，例如Bitmaps，Drawables都是一起打包到統一的Texture紋理當中，然後再傳遞到GPU裡面，這意味著每次你需要使用這些資源的時候，都是直接從紋理裡面進行獲取渲染的。當然隨著UI組件的越來越豐富，有了更多演變的形態。例如顯示圖片的時候，需要先經過CPU的計算加載到內存中，然後傳遞給GPU進行渲染。文字的顯示更加複雜，需要先經過CPU換算成紋理，然後再交給GPU進行渲染，回到CPU繪製單個字符的時候，再重新引用經過GPU渲染的內容。動畫則是一個更加複雜的操作流程。</p><p>為了能夠使得App流暢，我們需要在每一幀16ms以內處理完所有的CPU與GPU計算，構建，繪製渲染等操作。</p><p><strong>GPU呈現模式</strong></p><p>最後附上 GPU 呈現模式的樣式圖，想必看完本篇文章對 Android 的屏幕繪製流程有了一個更進一步的認識。對於處理 UI 卡頓也會更得心應手。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Android 屏幕繪製機制及硬件加速" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/28ec6a95722b42c983de4bf883ac36c6><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>總結</p><h1><strong>參考</strong></h1><p>CPU / GUP 不同點 ： Android硬件加速原理與實現簡介</p><blockquote><p>https://blog.csdn.net/u011403718/article/details/54630760</p></blockquote><p>圖形組件的概念區分 ： 圖形顯示框架變化介紹</p><blockquote><p>https://blog.csdn.net/yangwen123/article/details/80221427</p></blockquote><p>有深度的硬件加速分析文章 ： 硬件加速原理</p><blockquote><p>https://www.jianshu.com/p/40f660e17a73</p></blockquote><p>老羅的源碼分析系列 ： Android應用程序UI硬件加速渲染技術</p><blockquote><p>https://blog.csdn.net/luoshengyang/article/details/45601143</p></blockquote><p>Google 之Android性能優化典範譯文 ： Android性能優化典範</p><blockquote><p>http://hukai.me/android-performance-patterns/</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Android</a></li><li><a>硬件加速</a></li><li><a>屏幕</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e02acf09.html alt="Android 屏幕適配方案" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52ae2d768efe44fe8ee014686a45271d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e02acf09.html title="Android 屏幕適配方案">Android 屏幕適配方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9829b890.html alt=Android屏幕適配方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1536979578666979cb313e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9829b890.html title=Android屏幕適配方案>Android屏幕適配方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c1058aa2.html alt="Android Q下ANGLE圖形引擎性能測試  「農步祥」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RXTy8D7HmsBWr1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c1058aa2.html title="Android Q下ANGLE圖形引擎性能測試  「農步祥」">Android Q下ANGLE圖形引擎性能測試 「農步祥」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ac13623.html alt="Android 11加入新功能：長期不用的APP自動關閉敏感權限" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rx4J9h84rlZBze style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ac13623.html title="Android 11加入新功能：長期不用的APP自動關閉敏感權限">Android 11加入新功能：長期不用的APP自動關閉敏感權限</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/192b9f57.html alt="Android版Firefox 81將引入可自動關閉舊標籤頁的選項" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SA9N6CXIS75NYa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/192b9f57.html title="Android版Firefox 81將引入可自動關閉舊標籤頁的選項">Android版Firefox 81將引入可自動關閉舊標籤頁的選項</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3073c3d.html alt="Android端Firefox 81可定時關閉不使用的標籤頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S9x6jJb18axAim style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3073c3d.html title="Android端Firefox 81可定時關閉不使用的標籤頁">Android端Firefox 81可定時關閉不使用的標籤頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/355ed5a4.html alt=在Android中的工具欄中添加菜單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3572ad9d9fb487d8927f703f18179a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/355ed5a4.html title=在Android中的工具欄中添加菜單>在Android中的工具欄中添加菜單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37aac89.html alt=【學習筆記】Android開發之kotlin語言（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ee3f9c8348ae4de58a5f62922d2042e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37aac89.html title=【學習筆記】Android開發之kotlin語言（一）>【學習筆記】Android開發之kotlin語言（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/514f2fe0.html alt=Android進階之路之網絡編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R6GseWQ6pTbxvr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/514f2fe0.html title=Android進階之路之網絡編程>Android進階之路之網絡編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d258b9eb.html alt="徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/e4fd87bc-b2e5-40e2-841d-2e3dc5f9a2b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d258b9eb.html title="徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動">徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68b758a4.html alt="訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RiF18Oh9i8jWPd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68b758a4.html title="訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎">訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03a7881d.html alt="Android 11公開測試版正式發佈，新增了實用功能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/76a9b5ad-e27f-4cea-b8b9-2134bc133e5d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03a7881d.html title="Android 11公開測試版正式發佈，新增了實用功能">Android 11公開測試版正式發佈，新增了實用功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/036cb180.html alt="首批適配！ColorOS正式發佈Android 11開發者測試版：暗色定時、超級省電" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S2cySEvGM5dtxu style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/036cb180.html title="首批適配！ColorOS正式發佈Android 11開發者測試版：暗色定時、超級省電">首批適配！ColorOS正式發佈Android 11開發者測試版：暗色定時、超級省電</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9e496dd.html alt="Android 11 beta升級方法，如何申請測試版更新？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ba850edc544843cab07cecf061a1ffde style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9e496dd.html title="Android 11 beta升級方法，如何申請測試版更新？">Android 11 beta升級方法，如何申請測試版更新？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2b5d261.html alt="三星已開始Android 11測試：Galaxy S10+首個嚐鮮" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RrbBJ1a9L1lUev style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2b5d261.html title="三星已開始Android 11測試：Galaxy S10+首個嚐鮮">三星已開始Android 11測試：Galaxy S10+首個嚐鮮</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>