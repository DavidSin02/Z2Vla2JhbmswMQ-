<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>性能調優那些事兒 | 极客快訊</title><meta property="og:title" content="性能調優那些事兒 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/c3d79b9c-c906-42a1-a176-69bc8829f9ef"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a1081a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a1081a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a1081a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a1081a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a1081a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a1081a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a1081a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a1081a.html><meta property="article:published_time" content="2020-10-29T21:01:26+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:26+08:00"><meta name=Keywords content><meta name=description content="性能調優那些事兒"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6a1081a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>性能調優那些事兒</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=性能調優那些事兒 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/c3d79b9c-c906-42a1-a176-69bc8829f9ef><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>性能調優那些事兒</h1><h1 class=pgc-h-arrow-right>問題</h1><p>性能優化是軟件開發中最重要的活動，也是軟件工程中的深水區，可以說也是衡量一個程序員能力高低的標準。在大廠的面試中性能調優的問題也是最常見的，比如：為什麼Nginx的單線程處理網絡連接模型吞吐量與效率會如此之高？為什麼Kafka的吞吐量會比其他的消息隊列高？redisTPS/QPS比關係型數據庫高出幾個數量級？</p><p>要想回答這些問題，需要做很多的實踐與探索，而且要面對雜亂無章的、真真假假的網絡文章，需要耗費大量的時間，這也就是程序員常說的"我變強了，也TM禿了"的感慨原因。</p><p>雖然性能調優的方法與例子非常多，幾乎而且每年都會湧現出新的技術、框架，很多知識因為各種原因進行了很高層次的包裝，不容易看到其本質原理，很多事實、證據需要翻源碼才能獲得，但是因為知識點分散，過程困難而且枯燥。那麼有沒有一些通用的優化原則，或者基線呢？我想應該是有的，如果你想了解這方面的知識，這篇文章就屬於你。</p><h1 class=pgc-h-arrow-right>起源</h1><p>著名的計算機科學家的Don Knuth認為計算機程序調優只有兩種方式：</p><p>1、減少執行算法的指令數；</p><p>2、減少單條指令運行的時間。</p><p>這是一個高度抽象的近乎公理一般的結論，看似平淡而無趣，但是卻推測出計算機程序的基本特點與邊界，而我想面對一件具體的問題，定義其問題的邊界是十分重要的，它能指導我們做事的方式與方法，避免一些錯誤與不必要的努力。那麼計算機程序運行的邊界在哪？我想有這些：</p><p>· 計算機程序是由指令組成的，在計算機能完成的任何工作都能對應到一條或者若干條指令；</p><p>· 每條指令都會消耗時間，而指令不同執行所需要的時間也會長或者短，通過提高指令執行運行速度可以提高程序運行效率；</p><p>· 同時，完成一個任務（算法）所消耗的指令數目也可以多也可以少，通過優化完成指令的數目可以加快程序的運行。</p><p>好了，我們到這裡已經講現在我們能夠用的調優武器都介紹完了，有沒有感覺到呢？計算機暴露給程序員的調優目標就是減少程序指令數目與"減少"程序指令的執行時間。</p><p>當然，你可能要說，我們在實際項目中哪有時間或者條件去跟蹤、分析每條指令的執行？有那閒工夫，我們項目早就做完了；再說了，我們在項目中對於性能調優都會討論緩存方案啊、多線程並行啊；說到IO速度慢我們可以用redis、kafka啊這些工具來應對，那麼這些常用的手段是否跟前面介紹的兩個基本原則有關係呢？</p><p>我想，我們不僅目前所有的工具優化實例都會對應到以上兩個原則上；而且可以預測，只要計算機結構不發生本質的變化（比如量子計算機的普及）那麼所有程序調優的活動都能對應到這兩個基本的定理上來，這給我們分析程序性能劃定了界限、指明瞭道路。</p><p>下面我們來詳細分析下這兩個原則的實際落地實例，我將整個程序調優活動按照上面兩個定理化成兩大類——加快指令執行速度與減少執行代碼的數量，先看看加快指令執行速度的例子。</p><h1 class=pgc-h-arrow-right>加快指令執行速度</h1><p>你可能感到奇怪，我們在項目中使用的絕大多數優化手段，如緩存與併發都可以歸類到這種類型的優化。程序員一般來說不是硬件工程師，我們一般不會去優化某條硬件指令的執行速度，但是我們可以通過優化組合程序指令執行順序並利用硬件工程師提供的"便利條件"變向的達到加快指令運行速度的目的。</p><p>舉個例子：我們程序的目標是將一個20斤的西瓜吃完，一個人顯然一天是吃不完的，可能需要吃兩天，為了好計算我們假設一個人吃完要20天；但是如果四個人同時吃呢？5天就吃完了，西瓜的總量沒有變化，還是20斤，現在執行的速度從20天提升到5天，提高了4倍；那麼，對於執行的速度就從1天吃1斤提升到了0.25天吃1斤，相當於單條指令的執行速度提高了4倍——這就是並行計算能加快執行指令速度的原理。</p><p>再舉個例子：我們的程序是做菜，做菜這個程序分為2個大的階段，首先，我們必須出門買菜；然後在廚房將買回來的菜做成熟菜。考慮兩種執行策略：</p><p>1. 首先拿著菜譜進入廚房開始炒菜；按照菜譜的順序開始執行；當炒菜的時候發現缺失的食材，中斷炒菜的過程，出門去菜市場買菜，將缺失的食材買回來後繼續炒制；然後循環這個過程直到最後完成整個菜的炒制過程；</p><p>1. 首先做規劃，看看菜譜收集需要的食材清單；然後根據食材的清單出門買菜；菜買回來後進入廚房按照菜譜的順序去執行。</p><p>我們可以對比下兩種執行策略，可以根據我們的生活經驗很快得出一個結論：</p><p>1、兩種策略都能完成任務，而且完成任務所執行的步驟——"菜譜"是相同的，也就是完成的指令數目是一樣多的；</p><p>2、顯然第二種策略比第一種要優秀。因為它執行的時間比第一種要快很多，因為出去買菜是一個費時的指令，如果每準備一個食材就要出門買菜，那麼整個執行過程會被拖長；然而，一個人出去買菜的"通信帶寬"往往會比較大，比如，你出去一次可以同時攜帶大於1個的食材，甚至在帶寬不足的時候還能採用騎車或者開車的方式增加帶寬，所以第一種策略無形中浪費了很多"計算資源"所以效率更低。這個例子很清晰的說明了計算機中"緩存"這個重要的概念。我們通過分析，執行的任務總量沒變，但是通過合理利用計算資源（硬件工程師提供的"便利條件"）能夠大幅的提升計算速度。</p><p>並行計算與緩存是軟件工程中的常用方法論，下面我舉幾個例子來說明他們的重要性。</p><h1 class=pgc-h-arrow-right>程序在底層的並行化——CPU的流水線模型</h1><p>並行計算為什麼能夠"看上去"提高單條指令的速度，我想其本質原因就是CPU的計算速度與數據傳遞過程中的速度嚴重不匹配，前者往往比後者快5-7個數量級——CPU的計算速度是內存頻率的5個數量級；所以計算資源被嚴重浪費了，換句話說我們程序員的任務是更好的利用CPU的計算資源，不能讓它們歇著。那我們先看看硬件工程師是怎麼提高CPU的執行效率的，這些知識能夠讓我們在寫程序的時候有更多的黑魔法可以用。一種一個典型的優化手段就是讓指令在CPU中並行的執行——CPU流水線模型。</p><p>這裡有一個前提，我們所針對的環境是單CPU單核處理器，如果是我們常見的多核那麼不在這個範圍內討論。</p><h1 class=pgc-h-arrow-right>什麼是流水線模型</h1><p>流水線模型來源於生活，還是以上面炒菜的例子，我們在廚房裡面一般都有處理食材的單元，還有炒菜的單元；我們在處理食材的時候，炒鍋是空閒的，而在炒菜的時候砧板是空閒的；那麼要提高"廚房"的吞吐量，我們就可以安排兩個人一起協同工作，當前一個人處理完食材交給廚師烹製的時候，切菜工可以接著處理下一個食材，而不是等著廚師炒完菜再"load"下一個食材——這就是流水線模式，我們的單核CPU就是這麼工作的。</p><h1 class=pgc-h-arrow-right>CPU的多級流水線</h1><p>我們拿兩條高級語言編寫的累加代碼說明CPU多級流水線如何工作：</p><p>i=0; //將0賦值給變量ii=i+1;//將i累加1</p><p>這兩條指令在多級流水線（超流水線）CPU中是並行執行的，為什麼呢？我們來詳細闡述下代碼如何在CPU上執行的。有兩個前置的知識點：</p><p>1. 不管是什麼語言，最後只能由CPU來執行；我沒見過人寫的代碼可以脫離計算機來運行的；</p><p>1. CPU運行代數計算的部件（布爾代數是核心），這就將程序分成了數據部分（變量）與算法（代碼）部分，這也是program=data structure+algorithm的原因；任何程序都能表示成f(x) = ax+b的多項式形式，帶入不同的數據會得到唯一的不同的運算結果，這也是為什麼我們寫的方法被叫成函數的原因；</p><p>1. CPU與內存是綁定在一起的，不可分開；缺少其中一方，程序就無法執行，這是馮諾依曼計算構架的基礎；程序存在內存中，CPU通過取址指令來加載指令到寄存器，然後邏輯運算單元通過讀寫寄存器的數據完成一次計算；</p><p>1. 一個機器碼，比如累加操作，在CPU內部會被分解成若干條"微指令"來執行，這樣可以提高CPU的吞吐量。（注：你是不是遇到過很多跟微相關的概念：RICS、微內核、微服務，將複雜的過程分解成相關的部分有利於資源的利用與控制，這是所有工程都適用的治理手段，這是另一個話題了以後介紹）。</p><p>可以看到對於一條指令至少可以分解成兩個階段，比如：i=0這條代碼，可以分解成：</p><p>1. 取指令：Cpu發送load指令，從內存中獲取程序機器碼；</p><p>1. 譯碼：通過指令譯碼單元將機器碼翻譯成控制電路信號；</p><p>1. 執行：執行賦值指令；</p><p>1. 訪存：獲取i對應的內存地址；</p><p>1. 寫回：將結果0寫回到i對應的內存地址存儲單元。</p><p>這些階段對於"i=0"這行代碼來說只能串行執行，但是細心的你可能會發現，當cpu執行完取指令操作，就空閒了；譯碼單元執行完譯碼操作也空閒了，而此時"i=0"還沒跑完，不能執行下一條指令，只能等著，這就造成了CPU資源浪費，一條賦值操作要等5個"週期"才能執行下一條"i=i+1"代碼。為了提高吞吐量，CPU流水線模式應運而生。</p><div class=pgc-img><img alt=性能調優那些事兒 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d020c6fc52a4200ad5191b9f5680288><p class=pgc-img-caption></p></div><p><br></p><p>這是一個典型的5級流水線，可以看到，指令2不需要等到指令1完成計算結果寫回操作就能開始取指令、開始執行；同時，第三條指令也不需要等到第二條指令執行完就能開始執行；這樣一個5級流水線可以同時並行處理5條代碼；CPU的吞吐量從5個"時鐘週期"完成1條指令，提高到1個"時鐘週期"完成1條指令，吞吐量加大了5倍之多，其宏觀效應就是單條指令的耗時從5個單位時間減小到1個單位時間，加快了運行速度。</p><p>那麼怎麼利用流水線技術來寫出高效的程序呢？舉個簡單的例子：</p><pre><code>int sum,sum1,sum2,sum3,sum4;for(i = 0;i&lt;100;i+=4){   sum0+=a[i];   sum1+=a[i+1];   sum2+=a[i+2];   sum3+=a[i+3];}sum = sum1+sum2+sum3+sum4;</code></pre><p>當你在看一些高性能組件的源代碼時你可能會看到這種代碼，為什麼循環的步長會從1變成到4？那是因為，目標機器的CPU流水線中有"超標量"的功能用於解決流水線的指令冒險問題，而這個代碼運行的CPU有4個超標量單元，可以同時執行4個整形加法運算，所以for循環中的四個加法累加操作是同時執行的，可以有效的加快循環執行速度。</p><p>關於如何利用CPU內的黑魔法寫出高效的程序本身有太多的話題，限於篇幅這裡不展開，但是可以看出CPU裡面的世界遠比我們想象得複雜，同時，這種微觀世界的優化原則也跟高級的企業級優化原則有很多共同的特點，這也使得我們可以利用相同的方式在各個層次上寫出高效的程序提供了理論基礎。</p><p>注：世間的任何好都會帶來弊端，CPU流水線也不例外，如指令衝突，數據衝突，控制衝突等等會造成CPU計算錯誤或者延遲；但是流水線帶來的收益實在太過於明顯，所以人們又不斷開發出"超標量"、"分支預測"、"L1cache指令與數據分開存儲的哈佛結構"等等技術來彌補，使得X86這種CPU的控制電路變得越來越複雜，功耗也越來越高；使得在手機上的市場出現明顯短板，從而拖累了很多公司在移動設備上的失敗（如微軟）。</p><h1 class=pgc-h-arrow-right>程序底層緩存優化技術——CPU的緩存行技術</h1><p>現在我們來看看緩存優化技術，也就是前文說的"買菜部分"的優化，通過那個例子我們可以總結出緩存類優化技術的共同特點：</p><ol start=1><li>緩存技術並不能減少指令代碼的數量，也就是說緩存技術並不能減少"讀取"操作本身的次數；更進一步說是優化前的程序的執行邏輯跟優化後的執行邏輯不會產生變化；</li><li>緩存技術針對的是讀場景，往往是高速處理部件讀取低速處理部件數據時使用；適用於讀多寫少的場景；</li><li>緩存雖然能夠加快速度，但是對於系統來說會增加額外邏輯的複雜度；有些場景要慎用。</li></ol><p>我們依然延續上節對CPU運行指令的解構過程，看看CPU如何使用緩存技術來加快程序的執行，以及如何利用緩存技術寫出高效的代碼。</p><h1 class=pgc-h-arrow-right>CPU流水線與馮諾依曼瓶頸</h1><p>我們可以回到最開始——CPU的流水線技術；最開始流水線技術其實有一個大的bug，或者說因為解決了這個問題CPU才會有流水線技術的誕生——馮諾依曼瓶頸。</p><p>馮諾依曼瓶頸其實通俗點講就是CPU與內存之間的訪問速度Gap，為什麼會有這個gap呢？根本原因是馮諾依曼設計的計算機是指令存儲執行構架的計算機，它將程序的執行與存儲做了分離，執行方只提供指令的列表與執行單元，而程序員按照執行單元提供的有限條指令組合出不同的程序來存儲到內存中，CPU通過讀取內存中的代碼執行，然後將執行結果返回到內存。這是一個劃時代的創新，使得現代程序員不用為了實現特定的功能去思考如何修改CPU的指令集，也極大的簡化了編程這個活動，推動了IT產業的進程。但是也帶來了一個問題，CPU不存儲指令與數據，那麼就要訪問內存，由於工藝原因，CPU與內存是有很大的訪問延遲的；打個比方，如果把人類世界的1秒代表CPU執行一條指令的時間，那麼訪問一次內存就相當於過了5分多鐘，300倍的gap，這是什麼概念的，如果不做緩存，我們運行打開微信這樣的App需要半個小時以上的時間，顯然是不合理的。</p><p>我們再看看前面的5級流水線CPU，其中兩條微指令"取指"與"訪存"的語義是從內存中load數據，那麼因為馮諾依曼瓶頸的存在，這兩個微指令的延遲將是其他三個指令的100多倍；而流水線的吞吐量是有短板效應的，它只跟執行時間最長的步驟有關，如果要得到一個高效的流水線就必須將任務的步驟進行均分，避免短板的出現；所以如果不解決馮諾依曼瓶頸就無法實現CPU的流水線技術。</p><h1 class=pgc-h-arrow-right>CPU的緩存行技術</h1><p>為了解決馮諾依曼瓶頸，CPU硬件工程師，在不改變原有執行邏輯的基礎之上增加了3層緩存層，分別是L1、L2與L3層，如下圖：</p><div class=pgc-img><img alt=性能調優那些事兒 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e0b574a52a7a489195bcaf2e7f6012ff><p class=pgc-img-caption></p></div><p><br></p><p>他們的容量跟訪問速度成反比，但是跟CPU基本還在一個數量級上，比如典型的多核Intel X86 CPU，L1是32K-64K，L2 256K-512K，L3 4M-8M。</p><p>增加了3層cache後，CPU的內存訪問模型發生了變化：</p><p>1. L1、L2與L3都被封裝到CPU中，外界不可見；</p><p>2. 每個計算核心core有自己的L1 L2Cache，而所有核心共享一個L3 Cache；</p><p>3. CPU不會直接訪問內存了，它只會從L1中加載數據與代碼；</p><p>4. 形成了訪問代理鏈，L1層負責代理L2，L2負責代理L3，L3又稱環形電路負責代理整個內存；上層屏蔽下層；</p><p>5. L1、L2與L3是按照緩存行cacheline來管理的，而不是一個個的字節，一個cacheline通常有64個字節。</p><p>其中第5點是值得特別關心的，因為引入了一個新的概念——cacheline。這是個什麼東西呢？還記得上文中買菜的例子，在生活中我們出去買菜肯定不是一次只買一個菜回來，而是將所有需要的菜一次都買回來，而出去一次買多少菜呢？CPU規定一次64個字節。</p><h1 class=pgc-h-arrow-right>緩存行優化的原理</h1><p>那麼你可能會問，緩存行為什麼能加快CPU讀取數據的速度呢？而緩存行又有什麼特點呢？</p><p>1. 減少了CPU直接訪問內存的次數，提高了取址指令的執行速度（彌補了取址指令的總體執行速度跟執行單元執行速度的gap）；一次讀取64個字節，對於一般的程序可能一次就把所有的數據與代碼都加載到了L1中，而CPU訪問L1的速度基本沒損失；所以起到了提速的作用；</p><p>2. 程序代碼與數據具有空間局部性；換句話說就是，程序編譯完成，加載到OS後，其代碼段與數據段往往是連續存儲的，所以可以通過一次訪問全部加載，這就是空間的局部性；</p><p>3. 程序代碼與數據具有時間局部性：一段代碼還有時間局部性，比如循環代碼，一次加載到內存後長期都會命中L1緩存，所以在程序中寫短小的循環代碼能有效的提高執行性能；</p><p>4. 當然緩存行也有些弊端，它有著複雜的更新策略，比如，當一個緩存行中任何一個字節被修改，整個緩存行都會被重新加載，而且並同步到其他的核心中，造成一定的性能損失。這導致在多核構架的CPU中需要額外的更新協議（MESI）來同步各個核心的共享緩存行，這是一個很大的話題，尤其對於多線程的高併發程序來說。</p><h1 class=pgc-h-arrow-right>一個利用緩存行優化的例子</h1><p>因為代碼在加載到OS中以後具有時間與空間的局部性，所以如果有效的利用這些局部性與緩存行機制就能寫出性能較高的程序來。比如，我們通常會在程序中使用常量，而常量的目的是在多個線程之間共享狀態，協調線程執行，那麼，我們就需要這些數據能夠常駐L1-L3級緩存以減小內存與CPU之間的IO開銷。我在一個優秀的消息隊列組件——Disruptor中找到這樣一個實例：</p><pre><code>class LhsPadding{    protected long p1, p2, p3, p4, p5, p6, p7;}class Value extends LhsPadding{    protected volatile long value;}class RhsPadding extends Value{    protected long p9, p10, p11, p12, p13, p14, p15;}/** * &lt;p&gt;Concurrent sequence class used for tracking the progress of * the ring buffer and event processors.  Support a number * of concurrent operations including CAS and order writes. * * &lt;p&gt;Also attempts to be more efficient with regards to false * sharing by adding padding around the volatile field. */public class Sequence extends RhsPadding{    static final long INITIAL_VALUE = -1L;    private static final Unsafe UNSAFE;    private static final long VALUE_OFFSET;......}</code></pre><p>1. value的前面有p1-p7共7個long，一個long類型佔用8個字節，加起來就是56個byte，後面也有56個字節，而一個緩存行共64個字節，那麼value必將跟一組常量(P1-P7或者P9-P15)在一個緩存行中；</p><p>2. 如果不加Padding的前後包裹，value就可能跟普通變量公用一個緩存行，那麼如果在多線程併發的場景下，因為其他變量的反覆更新導致常量value被動的反覆失效，刷新到內存，又被拉取到內存，造成性能的嚴重損失。</p><p>這種在常量前後包裹額外的字節的技術叫做<strong>緩存行填充技術</strong>，在很多對性能要求較高的多線程併發項目代碼中時常能夠遇到，這個技術跟語言無關，只跟CPU相關，所以屬於CPU級別的黑魔法。</p><p>當然，還有一些技術也是根據緩存行的特點來設計的，比如：很多高性能系統中使用Ring buffer做緩衝隊列，它使用了一個環形的數組做隊列，而沒有使用LinkedList，是因為數組是連續的內存，更加容易被CPU的緩存行命中，從而減少對內存的尋址，在高併發的狀態下可以提高整體系統的吞吐量。</p><p>注：緩存行是一個很大的話題，其中包括緩存行的存儲結構（虛擬內存與緩存行的映射關係，多路分組技術）與MESI多核緩存行同步協議，瞭解這些底層知識對於讀懂一些著名開源項目至關重要，甚至自己就能寫出一個來。</p><h1 class=pgc-h-arrow-right>程序在OS級別的緩存優化技術——IO治理</h1><p>我們認識緩存對於性能優化的作用更多的是在應用系統級別，也就是操作系統級別的，原因是這裡有更加豐富的場景，比如：當我們需要從關係型數據庫加載大量數據或者比較頻繁的加載數據的時候會想到Redis，因為後者具有更高的吞吐量，而Redis為什麼在吞吐量上具有如此大的優勢？我們從這兩者的區別分析說起。</p><h1 class=pgc-h-arrow-right>關係型數據庫VS Redis</h1><p>一個重要的原因在於Redis與關係型數據庫如Mysql在存取數據方式的不同：</p><p>1. Mysql等關係型數據庫著重點在於數據的安全性與健壯性上，從而對數據有更安全的保證，所以在存儲方式上使用更為存儲特性更穩定、容量更大的磁盤；</p><p>2. Redis則是互聯網高速發展催生的產品，具有超高的吞吐量，超低的延遲，但是對於保證數據的安全與一致性方面則比關係數據庫要低得多（雖然後面有很多的機制來維持比如內存數據的落地，但是相比磁盤讀寫還有要差得多，必進OS層也會對文件讀寫的安全性進行保證）；根本原因在於Redis是一個基於內存的數據結構服務器。</p><p>所以從存儲介質的不同上我們就能很容易的推導出各自的優勢與劣勢來：</p><p>1.Mysql等傳統的關係型數據庫更加擅長長久的保存重要的數據，比如交易數據、用戶信息等，而且程序對其的增刪查改操作往往有更好的原子性保證，在災難恢復與數據備份上有更好的產品級支持；但是因為磁盤的訪問延遲比內存低4-5個數量級，所以能支持的吞吐量與訪問量都不高；本質原因就是將CPU的處理時間更多的放在了數據的安全性上了；</p><p>2. 而redis是用於解決互聯網應用的超高吞吐量與超高的併發訪問性能而生的；所以需要將CPU的利用率拉高來達到用更少的機器服務更多用戶的需求，所以Redis將數據保存在內存中，使用低延遲的存儲來在達到單位時間內執行更多的指令目的。其弱點也是顯而易見的，出該容易丟以外，Redis也只提供了少量而常用的幾種數據結構，如：hashmap，list，set與zset等等，對於複雜的多維度數據的存儲與查詢顯然支持不夠，應用場景就比較單一。</p><p>所以，我們在實戰的時候往往會綜合使用兩種存儲的優勢，然後避免各自短板，如使用關係型數據庫作為最終數據備份與落地存儲；而對於數據熱點的訪問、突發性數據訪問、讀寫，可以先在應用層使用Redis來抵擋，然後再合適的時候同步回磁盤介質的關係型數據庫。</p><p>注：計算機科學中往往會有一些悖論，比如事務性與吞吐量，我們可以使用技術手段將一個程序的吞吐量拉高到CPU的滿負荷，但是這時你就必須為此放棄事務性的支持，相反也是，所以當我們看到某某工具宣稱即有超高的吞吐量又能完美支持事務性的時候，我們應該多個心眼。</p><p>注：文檔型數據庫——ES或者MangoDB。這類db或者說是數據存取工具因為具有更特殊的存儲特性——面向文檔存儲，而具有一些更加特殊的功能，其性能特點不像Mysql與Redis的區別這麼鮮明，所以不展開討論。我想，特殊的需求會催生出特殊的應用，ES就是這樣，它的檢索方式更加適合有全文檢索需求的應用，其索引是採用倒排序索引方式構建，其佔用的磁盤空間相比只能針對特定字段的B樹索引需要佔據更多的磁盤空間，所以催生出其卓越的分佈式存儲系統；但是如果把ES與Redis甚至Mysql混為一談是錯誤的，具體問題應該具體分析，更不能人云亦云。</p><h1 class=pgc-h-arrow-right>Kafka的性能優勢</h1><p>kafka是非常流行的隊列服務器，因為其超高的吞吐量被大家所青睞，我們從IO特性來簡單分析下原因。</p><h5 class=pgc-h-arrow-right>內存消息批處理機制</h5><p>大家都知道kafka是以"批"為單位來發送與接收消息的，這種"批"有以下兩個特點：</p><p>1. 消息在發送的時候不是一個個的發送，而是積累到一批才發送，在內存上有局部性；</p><p>2. 消息在持久化的時候一批數據是順序存儲的，這樣使得數據在磁盤上有很好的局部性、</p><p>這樣做有什麼好處呢？回想一下前面介紹的CPU Cache的緩存行機制就不難理解，"批"在空間上具有很高的局部性，使得發送與讀取都能用到CPU的cache機制，使得CPU在訪問這些"批"數據的時候能夠用較少的內存尋址的指令來處理同樣多的數據，從而能夠提高程序的吞吐量，特別是在數量特別巨大的"批"上，優勢就會體現的更加明顯。其本質是，處理的數據量不變，CPU的執行取址指令數量不變的基礎之上將部分的內存尋址指令替換成了cpu緩存的尋址，顯然效率提高了一兩個數量級。</p><p>當然凡事有一利必有一弊，我們也要看到，這樣做的風險也是巨大的，一旦發送方機器宕機，那麼就會丟掉數量以"批"計的數據，很明顯"批"越大，風險就越高，kafka要為這個批處理編寫大量的保障代碼，甚至多副本機制來保障數據的安全性，造成很多資源的浪費；所以當我們需要相當高的安全性保證與事務性保證，但是不是很高的吞吐時，還是使用事務性更好的隊列服務器比較好，畢竟達到一樣的效果後者使用的資源更少。</p><h5 class=pgc-h-arrow-right>磁盤文件的批處理</h5><p>眾所周知，在操作系統中，文件與內存都是以頁為單位存取的，這點跟內存與CPU的的cacheline為單位存取機制是一致的，這樣能夠將這種空間與時間的局部性特點能應用到磁盤的IO上，使得操作系統在訪問低速磁盤的時候能夠用相同的指令數獲得更大效率優勢。其具體的機制是：</p><p>1. 操作系統對磁盤驅動程序讀取或者寫入的數據按照頁（4K的塊）進行緩存；</p><p>2. 頁緩存具有時間局部性特點，如果操作系統從磁盤驅動讀取了一塊數據，那麼大概率程序還會繼續訪問同一塊數據，如果有緩存，則不需要再從磁盤load，特別是使用了"內存映射文件"機制的讀寫；</p><p>3. 頁緩存具有空間局部性特點，比如kakfa接收到一批數據，會將它寫入到磁盤暫存，而此時操作系統會先寫入內存的頁緩存，然後一次性刷入磁盤；而同時kafka的消息處理也是一批批的，所以load這同一批數據，就可以直接從操作系統緩存中獲取，而不需要從磁盤中load，從而提高了讀寫性能。</p><p>kafka在做磁盤數據批量存取的時候，因為消息是順序批存儲的，所以能夠能好的利用操作系統的磁盤緩存機制來提高IO的性能。</p><p><br></p><h5 class=pgc-h-arrow-right>"零拷貝"機制——一個減少運行指令的優化</h5><p>這也是操作系統提供的一個機制，對於數據傳輸類的程序尤其重要，我們知道數據的IO讀寫——磁盤與網絡傳輸都是通過系統調用完成與採用什麼編程語言無關。傳統操作系統的IO讀寫操作包括兩次系統調用開銷，數據從驅動程序拷貝到內核內存，然後內核程序將這段數據原封不動的拷貝到用戶態程序內存空間；本質原因是用戶態程序不能直接訪問內核態虛擬地址空間，而內核程序可以訪問用戶態虛擬地址空間造成的。</p><p><br></p><p>一種優化方式也是常見的方式是通過mmap系統調用，將一段用戶態的虛擬內存地址空間直接映射到磁盤（為什麼可以這麼做呢？因為磁盤與內存共享相同的數據存取方式——頁），然後當內核從驅動程序讀取到數據後會直接向這段共享的虛擬地址空間寫數據，跳過內核往用戶態拷貝數據的代碼，因為內核可以訪問全部的內存空間，這種拷貝是被允許的；因此，這樣一來就減少一次數據拷貝，在有大量數據要拷貝的時候就大大的節約了CPU時間，提高了系統的性能。</p><p>那麼既然可以減少一次，那麼你可能已經想到了，那麼在一些情況下是可以完全避免這種因為特殊的CPU與OS構造帶來的不必要的拷貝的，可以採用直接從磁盤通過DMA控制器向網卡發送數據就可以了。對，kafka就是這麼發送"批"數據的；使用是Linux操作系統提供的sendfile系統調用完成所謂的"零"拷貝，從而從IO上做到了機制。</p><p>同時可以看到，這種優化方式其實減少了一部分不必要的IO指令來完成的，跟緩存方式並不一樣，在大的分類上屬於減少指令運行數量來提高性能的方式。</p><p>好了，到這裡，我們要結束緩存這個機制的介紹，從而開啟另一種性能調優常常使用的手段——多線程技術。</p><h1 class=pgc-h-arrow-right>程序的並行化執行——多線程技術</h1><p>多線程技術是一個十分通用的優化方案，在編程語言級別上寫出一個有良好結構的多線程程序越來越容易，比如java的CompletetableFuture框架，.Net的anync await異步框架，眾多的語法糖大大的降低了多線程程序的構建過程。但是，多線程的基本問題卻還是會不斷被問到，比如為什麼多線程技術能夠加速程序執行？是不是所有的程序都能夠採用多線程方式提速？</p><p>我們照例從文章開頭引用的兩條定理出發來推出答案。</p><p>這要從我們前面介紹過一個事實——馮諾依曼瓶頸說起，CPU與內存，內存與外部存儲設備都存在很大的訪問延遲，導致我們讀寫數據的時候需要按照"批"與"塊"的方式進行，以充分利用程序或者數據在時間、空間具有局部性原理，從而加快訪問速度；所以我們看到了緩存行、操作系統page cache等工程實踐。</p><p>但是，只有這一種方式來填充馮諾依曼瓶頸嗎？如果換個角度看問題，一個程序要處理的事務要是能夠由多個worker分工同時做完，那麼只要加大資源投入不是也能達到降低單條指令執行速度的目標嗎？</p><p>我們接著之前炒菜的例子，對於切菜這個工序，我們完全可以使用加大切菜工資源投入來獲取並行執行的能力。比如，一個師傅切土豆，另一個師傅切肉，如果還有菜要切那麼就加入更多的師傅進來，理論上只要廚房能夠容納得下，切菜這個工序可以在一個單位時間內完成——這就是多線程的本質——切分任務讓有限的資源得到充分的利用。</p><p><br></p><p>這個方式跟流水線並行處理有何不同之處呢？我想在於切分主體不同：</p><p>1. 流水線是通過<strong>切分處理單元（CPU）</strong>本身來達到任務之間的並行執行；</p><p>2. 多線程是通過<strong>切分任務本身（WorkLoad）</strong>讓有限的計算資源獲得充分的利用來提高執行的執行效率。</p><p>下面一個重要的問題是，是不是所有的工作都能並行化呢？</p><p>我想也未必，比如準備食材與切菜、切菜與炒菜這些工序之間就不能並行，因為前後兩個工作是有先後依賴的；比如，辣椒炒肉這個菜，必須把辣椒與肉都備齊才能開始炒制，否則就不行。</p><p>這就基本可以得出多線程併發執行的特點：</p><p>1. 多線程併發也是一種利用提高CPU資源（主要是多核資源）利用率來加快指令運行速度的調優方式；</p><p>2. 不是所有的程序都能並行化執行，只有那些能夠切分成若干個前後無依賴子問題（map），並通過對這些子問題並行規約（reduce）求解，從而得到問題最終解的那些任務才能通過所謂的多線程方式並行求解；簡單的說就是任務能夠被map也要能被reduce出最終的結果。</p><p>所以，我們又可以推導出能夠做多線程併發的先決條件：</p><p>1、任務可以被map-reduce；比如：經典的統計詞頻的算法；矩陣相乘等這種計算密集型任務；</p><p>2、重I/O依賴的程序，如web服務器，隊列服務器，數據庫服務器等等；為了不讓CPU空轉，線程往往會放棄等待I/O事件，轉去執行其他不依賴I/O的任務；當然也可以去執行其他I/O ready的訪問請求，如即時通訊類程序就能完美的利用多線程帶來的紅利。</p><h1 class=pgc-h-arrow-right>多線程的弊端</h1><p>多線程技術能夠加快很多程序的運行，但是還是那句話，有利就有弊，多線程的弊端是：</p><p>1.·線程的上下文切換開銷。這也是跟操作系統的設計相關的話題，因為線程工作在用戶態，但是歸屬權卻在內核態。打個比方，廚房的師傅雖然工作地點在廚房，但是必須到辦公室拿到任務才能知道自己下一步做什麼事情；那麼經常就會遇到這種情況，師傅剛剛把土豆切到一半，辦公室就喊了，""01"號師傅來一趟，有新的任務要執行"，然後01號師傅放下手頭的工作跑去辦公室領任務；接到新的任務又重新跑回到廚房執行新的任務；試想一下，如果在一個繁忙的廚房，你可以看到所有師傅來回穿梭於廚房與辦公室之間；甚至在途中浪費的時間比實際切菜的時間還要多；這就是線程上下文切換的開銷；</p><p>2. 多線程程序雖然有語法糖，但是如果不清楚多線程運行的實質，也很難獲得性能的提升。比如，一個不能並行執行的任務，我們也用多線程語法糖去套用，就可能會得到錯誤的結果，常常表現在一些數據結構的錯誤使用上，比如java中的Hashmap並不是線程安全的，如果多線程併發會造成死循環。</p><p>3. 多線程技術會使得程序亂序執行，如果多線程讀寫了進程共享變量，往往會造成數據讀髒或者寫髒，導致程序時而計算正確時而計算錯誤，形成週期性出現的bug。如果，對鎖機制不太瞭解，就很難真正將多線程技術發揮到極致——增加了編程的難度。</p><p>多線程編程所涉及到的內容十分多，比較重要的技術點有：CPU多核處理構架（緩存行更新機制）、CPU內存屏障與原子操作、操作系統的幾個上下文切換特點、操作系統的鎖機制，最後還有每個不同編程語言的內存模型，這些都跟編寫高效的多線程程序息息相關，內容多而龐雜，讓人頭皮發麻想掉頭髮。</p><p>所以，近年來單線程+多路複用+事件通知來處理I/O的模式又興起了，其實這是另一種優化策略的體現——減少指令運行數量策略，為什麼呢？下面來細細講解。</p><h1 class=pgc-h-arrow-right>減少指令運行的數量</h1><h1 class=pgc-h-arrow-right>Epoll模型——多路複用技術</h1><p>接著討論多線程技術在超高併發環境下帶來的弊端，其最主要的弊端是線程上下文切換與鎖同步機制帶來的性能開銷。對於一個超高併發的系統，比如每秒可能要接收處理數十萬的併發請求，這時服務器上可能有數千線程在OS中來回切換，其帶來的切換開銷就會變得非常可觀，對於workload本身是計算類型，處理時間很短的業務來說線程來回上下文切換的指令執行成本甚至高於了業務計算指令的開銷，這就得不償失了。</p><p>形象的比喻就是，廚房沒有師傅在幹活，都在滿大廳的來回亂跑，把時間都耗在路上了。</p><p>而另一方面，計算機的多核構架越來越成熟，一個服務器有十幾個核心變得家常便飯，這就為單線程構架的復興提供了充分的前提條件。這裡的單線程指的是系統在處理業務時的線程數是每個核心壓上一條線程，如果有超線程技術就壓上兩條，這樣在線程不多的情況下，得到多線程併發的好處也有效的規避了其弊端。</p><p>那麼，你可能會問，單線程的程序規避了多線程帶來的上下文切換帶來的開銷，那麼對於一個重IO的程序，如web服務器，如何在一個線程中去管理數十萬的Socket鏈接呢？以前可能是一條線程一個socket，因為socket之間並沒有很強的關聯性，所以併發執行剛剛可以充分利用CPU做業務，這樣的優點不正好也是單線程不具備的嗎？更何況，當線程去處理大量的連接，需要去遍歷每個socket的IO狀態十分消耗時間，那麼如何去平衡這多出來的計算量也是單線程模型要面臨的挑戰。</p><p>下面來介紹如何彌補管理海量socket通知請求的鴻溝。</p><h1 class=pgc-h-arrow-right>Epoll模型一個成功的多路複用技術</h1><p>什麼是多路複用技術呢？這是一個通信領域的術語，簡單的說就是在原來單一的信道上去承載多路的信息傳遞；比如說，原來一根電話線只能接通一路語音通信，只能服務兩個人同時通話；那麼通過分頻技術的發展，一個電話線可以同時支持多路通話，增加了資源的利用率，這個技術叫做多路複用。</p><p>在計算機網絡編程領域，多路複用技術專指在同一個線程中響應處理多路socket連接請求。我們知道，socket是網絡IO，它位於延遲金字塔的最底層，延遲非常高，是CPU處理速度的5-7個數量級，也就是說理論上講，單線程是可以同時處理幾十萬的socket數據的（當然前提是workload不重，能夠快速計算返回結構給請求方），問題在於如何在單線程程序中高效的獲知socket IO的ready狀態，也就是解決前面提出的問題。</p><p>Linux因為歷史原因曾經支持過多路複用，比如select、poll這兩個系統調用，處理的方式是將連接socket描述符都存儲在一個鏈表中，然後每次獲得IO就緒的通知，都從頭遍歷這個鏈表從而找到一個或者多個就緒的的socket連接；學過算法的同學都知道，遍歷鏈表的複雜度是O(n)，在數據量比較大、操作十分頻繁的系統中，這種遍歷是非常消耗時間的，這就會吃光單線程程序的優勢。</p><p>但是，聰明的內核開發者，敏感的意識到這是個典型的算法優化點，只要能夠將查找就緒的socket時間從O(n)降下來不就可以完美的解決這個問題了嗎？</p><p>打個比方說，你要去學校找一個同學，而你只知道他的名字，那麼你到了學校後會只能挨個班，挨個人找，最壞的情況是需要全部遍歷所有的學生才能最終找到你的同學。</p><p>解決這個問題有兩個方法，一個是你花錢僱更多的人同時分班去找，只要人足夠多，那麼就能快速的找到你的同學；這就是多線程技術的解決方案，這個方案的弊端就是你必須花很多錢去僱傭人幫忙，當班級特別多的時候，花銷大的驚人，這個場景是線性增長；</p><p>而算法技術的提升則是一種類似於降維打擊的手段，通過採用合適搜索算法，從根本上減少搜索過程要執行的指令次數，從而縮小問題的計算規模，達到性能的提升。就好比，你託人拿到了學校所有同學的姓名與班級表，並且姓名是拼音排序好的，這是你只要根據要找人的姓名就能快速索引到你要找的同學的班級；這就是算法帶來的性能提升，它減少了執行一樣任務所包含的指令數。</p><p>Epoll最後使用了一種叫做紅黑樹的數據結構來存儲所有的幾十萬個鏈接的描述符，而這個數據結構有一個很優異而穩定的查找與插入性能，都是O(logn)！看到公式你可能還不明白這個降維打擊的厲害之處，舉個例子，如果這個學校有十萬人，這個數據結構查找一個特定的元素不會高於12次查詢，你看比原來的十萬少了多少個數量級；再比如，你要搜索一個擁有4億人的大班級，也只要30多次即可！是不是很神奇，這就是算法的魔力所在吧。</p><p>所以，有了紅黑樹有了Epoll，單線程管理海量的socket成為了現實，成功的填補了多線程切換帶來的性能損失，將CPU的功能都花在了業務處理上來了。</p><p>有很多大名鼎鼎的工具如Nginx，Redis都是使用這個模型來實現超高吞吐量的。當然，這個模型也不能濫用，一個前提就是當每個請求的workload不高的情況下，也就是處理短小的業務比較擅長。你可以看看nginx與redis的使用場景便可知道。nginx最大的作用是負載均衡與反向代理，處理的業務跟模式匹配有關屬於計算密集類型；而redis更不用說，內存型的數據結構服務器，大部分的查詢通過算法與IO優化後都能在超短的時間內完成響應。相反，如果你用這個模型去做高計算量的事務就會得不償失，顧此失彼了。</p><h1 class=pgc-h-arrow-right>算法優化——優化的終點</h1><p>從上面Epoll的單線程併發模型我們可以領略到算法的能力，將它作為性能優化的終點毫不誇張。一個問題如果在算法上找到降維打擊的手段，比如將計算量進行了降階處理，往往帶來的想象力就是無窮的；就好比，化石能源遇到核裂變反應堆，核裂變遇到核聚變一樣。</p><p>平心而論普通人要想在算法上獲得突破其實非常難，對於工程師來說，能夠掌握常用的算法知識，掌握常用的數據結構知識，並能夠正確識別算法與數據結構的使用場景就已經非常難能可貴了。所以，我們還是來討論對於軟件工程師來說應該如何從數據結構與算法的角度優化系統的性能。</p><h1 class=pgc-h-arrow-right>什麼是計算機算法</h1><p>我覺得我們常常討論的算法應該包含這麼幾個內涵：</p><p>1. 首先計算機算法，顧名思義是只能在計算機上運行的算法；我們知道算法脫胎與數學，而數學本身是博大精深的，而能在計算機上跑的算法應該是數學眾多問題中的一小部分。舉個例子，計算機能夠描述的問題都不是連續的，是離散的，比如數據討論一個簡單的方程y=x^2，數學上討論的定義域是整個實數域而計算機是不可能描述這麼多的數字的；所以計算機討論的問題都是離散的個別的；</p><p>1. 算法對程序的優化主要集中在減少程序所要運行的指令數上（分治算法除外）；</p><p>2. 算法具有數學特性，其性能可以使用數學方法形式化嚴格證明，是跟編程語言，操作系統，硬件構架都無關的普遍真理；比如，很多人說自己得出了比快速排序更優的算法，其實是算法知識掌握不牢固的表現，快速排序是基於元素比較方式下原地排序算法中最優的，這個是通過數學家嚴格證明的，我們就不用去質疑了，只要知道它的使用條件能夠靈活使用就行；</p><p>3. <strong>計算機算法是受到數據結構制約的</strong>，或者換句話說，計算機算法是運行在特定數據結構的基礎之上的，離開了數據結構討論算法是不對的。比如，還是快速排序算法，如果我麼討論這個算法的性能時不知道它是運行在數組這個基本的數據結構基礎之上的那麼我們就不可能理解它的內在思想，實現的時候如果用鏈表存儲待排序元素就得不到相應的性能數據了。</p><p>那麼，知道了什麼是計算機算法，我們應該怎麼去使用算法優化程序的執行效率呢？我想有些基本的常識是應該瞭解的，比如常用的數據結構以及運行在上面的算法。</p><h1 class=pgc-h-arrow-right>數據結構與算法</h1><p>要了解數據結構與算法，就必須要要了解計算機如何存儲與表達數據。我們知道，計算機分為計算單元CPU與存儲單元內存，CPU通過對內存進行隨機讀寫來執行程序，那麼隨機讀寫這個特性就決定了計算機存儲的一個特徵——連續存儲的數據結構——我們常說的數組。對，數組這個數據結構可以說是數據結構的始祖，任何一個更高級的數據結構都是從數組演化而來。有了數組這第一個推導出來的數據結構，我們很容易利用計算機隨機尋址的功能推測出鏈表這第二個數據結構。有點類似中國古代哲學的一生二，二生三，三生萬物。對，數組與鏈表就構成了計算機世界中的所有數據結構。</p><p>我們看看這兩個原始的數據結構的特點：</p><p><strong>數組——具有天然的隨機讀寫性能O(1)，但是在數組中插入與刪除元素的性能是O(n)</strong></p><p><strong>鏈表——具有天然的動態擴容的性能，對於隨機插入與刪除元素的性能O(1)，但是隨機讀寫的性能降為了O(n)。</strong></p><p>這是最簡單也是最重要的特點了，這兩個基本的富有對稱性與矛盾性的數據結構共同決定了所有計算機算法的運行效率，或者說，計算機算法都是通過這兩中數據結構組合而成。</p><p>是不是有點向中國文化中的太極？互相矛盾，而又富有高度的對稱美，它就是整個計算機世界的基石。</p><p>下面我們來看看如何分析數據結構與性能調優的關係：</p><h5 class=pgc-h-arrow-right>數組</h5><p>我們從數組開始，數組是一塊連續的內存空間，它其實對性能調優十分重要，因為內存與硬盤本質上就是數組：</p><p>1. 數組有相當好的時空局部性，用它存儲的數據可以很快的被CPU加載，如果常駐內存有很好的緩存命中（cachline那節有闡述）性能，可以用最少的內存訪問次數加載完程序的數據，實際會用在高併發的場景如ring buffer等高性能緩衝；如果使用數組存儲文件，也能夠很好的利用到操作系統提供的緩存機制——Kafka的高性能；總之，如果想到緩存則可以想到數組這個數據結構；</p><p>2. 隨機訪問也是一個很好的特性——訪問數組元素中任何位置的時間複雜度是O(1)。比如，快速排序算法的重要步驟是交換"標杆元素"前後兩個元素的位置，那麼就要求根據數組索引訪問到元素的位置必須是O(1)的，如果用鏈表，快排就會退化到O(n^2logn)了，比插入排序等都慢；我們知道在世界上的計算機中一半以上的時間都在排序，所以排序算法是算法中最重要的，而這跟數組的隨機訪問特性分不開；而且利用數組的隨機訪問特性另一個應用就是構建出堆這種數據結構，有些編程語言叫做priority queue優先級隊列。這個數據結構非常有用，因為它有個非常好的特性就是動態插入元素以及找出其中最大(大頂堆)或者最小元素（小頂堆）的時間複雜度都是O(logn)，跟堆中的元素的對數成正比。我們知道對數函數是互聯網級的時間複雜度，只要能夠擁有這種性能就能被用到大數據，大併發的場景中。具體的應用就是在不需要排序的情況下找到巨量元素中的排名前N的元素，如搜索引擎框中的的topN提示；當然還有流數據計算場景，因為堆是一種動態的數據結構，可以將其想象成一個隊列，流過它的數據就能馬上過濾出前N個最大或者最小值。堆在編程語言中是一定是用數組實現的，不然性能就會急劇退化；使用的就是數組的隨機訪問特性+一點點數學知識；還有就是哈希表，哈希表在元素不多的情況下可以達到查找性能O(1)，當然也是利用了數組的隨機訪問的特性。</p><p>2. 當然數組也有它的劣勢，如： 因為數組的動態特性不好，也就是隨機插入與刪除元素都涉及到大量的元素拷貝與移動，所以對於需要動態變化容量的使用場景就不適合使用數組，比如隊列，棧；ringbuffer是個例外，但是它的實現需要寫很多複雜的邏輯來保證其動態特性，導致代碼複雜健壯性不好；哈希表的適用性也受到數組擴容性能差的影響。在工程中特別是像linux內核這種要求對性能有嚴格預期的大系統，很少使用哈希表做查找表的實現，其一個重要的原因是哈希表的動態擴容性能不佳，在極端情況下，數組的擴容需要完成"拷貝"與"rehash"兩個重量級操作，系統的性能就有抖動；而且在多線程情況下容易出現死循環，所以哈希表往往只能在對性能不苛刻的業務場景。</p><h5 class=pgc-h-arrow-right>· 鏈表</h5><p>· 鏈表彌補了數組動態性能低的特點，因為有很好的可塑性，可以用來實現很多結構更離散的數據結構：二叉樹就是鏈表的一個使用場景。二叉樹是一種樹狀結構，其中平衡二叉樹在插入與刪除的過程中只要移動logn次就能找到自己的新位置，而且代碼簡單易於維護（不容易寫錯也是工程中一個重要的考慮點，如果寫得代碼過於複雜就要反思下是否使用錯了數據結構）。比如：紅黑樹就是一個綜合性能很好的平衡二叉查找樹；它是一個動態的數據結構，可以在動態添加與查找過程中穩定在O(logn)量級；在Linux內核中大量使用；而且在Java中的ConcurrentHashMap在衝突大的情況下，衝突元素大於8也會升級成紅黑樹存儲衝突元素，來平衡工程與算法效率之間的矛盾；</p><p>隊列與棧——十分重要的動態數據結構，可以用來實現大量數據的緩衝，構建大量數據的離散關係。這兩種數據結構本身的應用場景非常的多，隊列用來實現圖的廣度優先遍歷，而棧則用於深度優先的遍歷；棧的先進先出的特點，還是實現函數調用的核心數據結構，也是在編譯期器中模擬數學表達式的數據結構；隊列的使用場景就更多，java中的ReentryLock的線程排隊阻塞隊列就是一個隊列；</p><p>鏈表通過改造也可以有很快的查詢效率，比如因為Redis而火起來的skiplist（跳躍表，實現zset的數據結構），其本質跟我們平時根據地址快速投遞快遞的原理是一致的；快遞員在投遞快遞之前並不需要對所有中國人的地址進行排序，可以說我們的地址是高度離散的；雖然人們的地址存儲是無序的，但是我們地址信息是高度索引化的，比如，所有人的地址格式可以是：XX省XX市XX區XX街道XX小區XX樓XX單元XX號，這麼8個等級，每個等級可以幫助你過濾掉一大批數據；比如你在湖北省，那麼可以在O(1)的時間裡面過濾掉十幾億人，然後每比對一層過濾掉一些數據，最後精確定位到你，這樣的搜索效率可以看做是O(logn)級別的；而人的出生與遷移，也只要在各自的索引區間中動態的鏈接新的信息，刪除老的信息即可，時間複雜度也是O(logn)的，這種數據結構就是互聯網級別的。跳躍表就是在鏈表的基礎上加入了額外的索引指針，用來根據不同的維度將鏈表中的數據進行分塊，類似於對地址區域的分塊，這樣既保證了高效的查詢效率也保證了動態的更新效率；同時還能快速的輸出區間元素，是一種工程上很好的數據結構，唯一的弊端可能就是相比紅黑樹需要更多的存儲空間來存放索引信息，而些開銷相比收益是可以忽略的。</p><h5 class=pgc-h-arrow-right>· 融合是關鍵</h5><p>· 數組與鏈表是兩個極端，我想對於性能調優來說，重要的是靈活組合他們的的優勢，規避它們各自的劣勢，達到工程上的平衡才是我們的終極目標。比如java中的LinkedHashMap就是融合了數組、哈希表與鏈表的優秀實踐：</p><p>· 普通的哈希表因為通過哈希函數將元素鏈接到數組的索引號上面，實現高速的查找性能，但是丟失了元素的插入順序，而有時候我們需要這個順序性來實現特殊的需求，比如緩存淘汰策略；</p><p>· 而如果使用鏈表，形成一個插入的隊列，先插入的在隊列頭，後插入在隊列尾部；但是這樣雖然保存了插入的順序但是丟失了查找性能；</p><p>· 為了平衡，我們可以在哈希表的基礎上，每個元素再增加一個指針用來連接前後插入的元素，形成隊列，這樣沒插入一個元素不僅在哈希表上掛載新的索引點，還要將新元素掛接到隊列的尾部，而每一步都是O（1）的開銷，是可以接受的，這就是LinkedHashMap的實現原理。</p><div class=pgc-img><img alt=性能調優那些事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3249b5b5c3b44ab688a3089c979778ac><p class=pgc-img-caption></p></div><p><br></p><p>通過分析SkipList與LinkedHashMap的例子，我們可以得出結論，在優化數據結構的時候您需要綜合考慮數組與鏈表的特性，並通過要實現的插入與查找的性能特定靈活的組合出你所需要的數據結構來。</p><p>而且，在分析數據結構性能的時候，特別是平衡動態更新與快速查找效率這兩個對立面的時候，我們要想起數組與鏈表的特點，想起它們就是一個太極圖的兩個部分，如果要獲取兩者的優點，就必須要付出空間或者時間的額外代價來實現——天下沒有免費的午餐。</p><h1 class=pgc-h-arrow-right>算法設計技術——通用的算法思考方法</h1><p>很多同學對算法設計技術並不是很熟悉，我們前面知道，算法是構建在數據結構基礎之上的，具備一定數學特點的計算規則，它可以幫我們將一個問題的計算規模降維打擊，達到優化程序運行的需求。數據結構與算法往往只針對具體的技術點，比如平衡存儲與查找的效率，優化局部的技術問題，這跟具體的現實世界的問題還有區別的，比如著名的"揹包問題"，"編碼長度優化"問題，往往這些問題更加貼近生活，需要更高的算法設計能力，而不同的設計方案往往會因為最終的計算指令規模不同而體現出不同的運行效率。</p><p>舉個例子："揹包問題"如果用蠻力算法，其計算量是O(2^n)級別的，這個級別的代碼對於計算機來說因為隨著揹包中物品數量n的增長計算量是指數級別增長的，幾乎是計算機不可解範圍；而如果用分治算法優化，可以達到O(nlogn)級別，達到計算機可解範圍；而如果用動態規劃方式優化，則可以達到線性的級別O(n)；可見一個問題到底用什麼算法技術去解決就可以得到完全不同的結果，所以在實際的工作中，我們對於一些具體的問題，可以形成一些解決方案套路，通過套用這些套路獲取一個計算量的預期，從而實現優化——這就是算法設計技術的作用。</p><p>算法設計技術是一個很複雜的領域，是計算機科學的深水區，同時也是算法領域的深水區，可以說計算機能解決什麼樣的具體問題、可解問題的邊界在哪都是由算法設計技術推動與決定的。這塊內容十分高深，涉及的知識非常多，是計算機科學家工作的領域，比如著名的N=NP問題就是這個領域的著名問題，如果成功解決可以獲得圖領獎，但是直到現在也還懸而未決。</p><p>那麼工程師要知道哪些算法設計的技術呢？我遠遠不是這方面的專家沒法給出答案，但是我覺得至少算法技術的分類以及一些基本的常識還是能夠理解的，不然遇到具體程序優化問題就不知道要找什麼領域的論文尋找答案。</p><p>算法設計大致可以分為三種：</p><p>1. 貪心算法，特點是往往是最值的求解，比如尋找一種最優的編碼方案——哈夫曼編碼；在圖中尋找最小生成樹——Prim算法，大名鼎鼎的單源最短路徑算法，對這些算法中都有最字，本質是在海量的排列組合中通過一個算法高效的計算出最優的一個來。而貪心算法有一個區別其他規劃算法的特點——結構簡單，只用一個簡單容易理解的原則就能求出最優解。比如湊硬幣問題，1，2，5，10三種面額的硬幣，湊出金額n的零錢來，請問最少的硬幣數是多少？那麼可以通過每次使用最大面額來匹配來得出最後的最優解。可見，貪心算法結構是十分簡單的，編程也十分清晰，但是世界是公平的，實際能夠使用貪心解決的問題特別少（原因不明），較為不常見。而且，在使用貪心算法求解之前必須要通過數學證明，而對於貪心來說，數學證明是難點；</p><p>2. 分治算法，分治是很容易理解的，它的思想被用在很多大數據框架上，比如，Map-Reduce，PageRank的計算等等。分治的特點是：分而治之，將原本規模很大的問題分解成n個規模較小的子問題，而這些子問題是彼此無關的，計算機通過將這些子問題發送到多臺計算機上同時處理，達到加速計算的目標，最後通過線性的歸併過程處理每個分片的結果得到最後的解。分治的難點是子問題分解，要特別注意分解後的子問題要是無關聯的，只有無關聯最後歸併才會正確；而要證明一個問題能夠被分解成n個子問題是需要去證明的，這是分治的關鍵；一般來說能夠用分治解決問題的計算規模都是O(nlogn)。</p><p>3 動態規劃算法。動態規劃能夠解決的問題是最多的，從"揹包問題"、"生產規劃問題"、"CPU良品率檢測"、"工作安排"、"圖像壓縮"到"RNA最優二級子結構"，應用的領域非常廣，是經常需要使用或者考慮的算法設計方法；動態規劃的特點有：</p><p>動態規劃要解決的問題跟貪心算法很像，一般都是解決最值問題，要解決的問題都是在幾何級數增長的組合中找到最優解；</p><p>動態規劃跟分治在結構上很相似，都是將大問題切分成若干個子問題來求解，最大的區別在於分治要求子問題無關，而動態規劃要求子問題有關而且計算是有重疊的；這樣的重疊子問題越多，用動態規劃獲得的收益越高；</p><p>動態規劃的本質就是在子問題遞歸樹上通過對重複計算子問題緩存結果，減少重複計算來提高運行效率。通過對分支重複子問題計算進行優化可以動態規劃算法往往能夠得到比分治算法更好的結果。往往時間複雜度能被優化到線性O(n)級別；</p><p>40. 動態規劃算法有較好的時間複雜度收益與廣泛的使用場景，但是要找到動態規劃的遞推方程是十分難的，需要具備很好的邏輯推理能力，與長期的訓練才能達到。</p><p>· 建議大家可以讀讀算法設計領域的書，這塊已經到達了計算機科學的核心，是最後的高峰。</p><h1 class=pgc-h-arrow-right>總結</h1><p>性能優化本身是一個很大的話題，從不同的技術、不同的工具有不同的特點與實現細節，不同的技術細節又有不同的運行環境，要涵蓋所有的優化方案顯然是不可能的；但是幸好，我發現不管是什麼領域什麼技術，只要它運行在計算機上，那麼它就有一些通用的方法，本文就是努力為您闡釋兩個基本的套路——<strong>減少指令數量與縮短指令運行時間</strong>；瞭解這些分析性能問題的基本套路就能在面對具體調優問題是達到事半功倍的目的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>調優</a></li><li><a>事兒</a></li><li><a>性能</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9bedc11b.html alt=石膏固定那些事兒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9bedc11b.html title=石膏固定那些事兒>石膏固定那些事兒</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6d6e624.html alt=想做好衝壓要先了解材料的性能！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/909834881fc8459486b9048c8590044e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6d6e624.html title=想做好衝壓要先了解材料的性能！>想做好衝壓要先了解材料的性能！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc7d836d.html alt=地球那些事兒｜地球自轉軸漂移引發侏羅紀東亞大幹旱 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/addf782a840b4d288885a071cdc00d8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc7d836d.html title=地球那些事兒｜地球自轉軸漂移引發侏羅紀東亞大幹旱>地球那些事兒｜地球自轉軸漂移引發侏羅紀東亞大幹旱</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/85479f13.html alt=鐵皮文件櫃的安全性能高嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c2f526916b2044b3baccd56cbbf96214 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/85479f13.html title=鐵皮文件櫃的安全性能高嗎>鐵皮文件櫃的安全性能高嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e4338bb.html alt=計算機學科那些事兒（2）-電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/2f4fba2f-f01b-4591-9cd7-12edf3d45e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e4338bb.html title=計算機學科那些事兒（2）-電子計算機>計算機學科那些事兒（2）-電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/78530cee.html alt=阻燃劑對低煙無滷聚烯烴電纜料性能的影響 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/eb7b68cb7a5a414cb986ddf732462c3e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/78530cee.html title=阻燃劑對低煙無滷聚烯烴電纜料性能的影響>阻燃劑對低煙無滷聚烯烴電纜料性能的影響</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4036c1ac.html alt=你想知道的，編制那些事兒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44bcc4f47c474752b4bb864f7230fde1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4036c1ac.html title=你想知道的，編制那些事兒>你想知道的，編制那些事兒</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82f5d9ff.html alt=Scala循環性能問題，為了性能，你願意犧牲代碼的可維護性麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/314c9a3074774fb48305ca5173282bb5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82f5d9ff.html title=Scala循環性能問題，為了性能，你願意犧牲代碼的可維護性麼？>Scala循環性能問題，為了性能，你願意犧牲代碼的可維護性麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/06baa0d5.html alt="第三節 連接器的基本性能（中英文）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/06baa0d5.html title="第三節 連接器的基本性能（中英文）">第三節 連接器的基本性能（中英文）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/183784ae.html alt=00Cr17Ni14Mo2不鏽鋼成分及性能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1ac65c7c3bfe44a0a04b2b3d497ba3b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/183784ae.html title=00Cr17Ni14Mo2不鏽鋼成分及性能>00Cr17Ni14Mo2不鏽鋼成分及性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dd848963.html alt=不鏽鋼緊固件的性能及其分類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e10993d5b1084a2f89bbbf5884c5b6d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dd848963.html title=不鏽鋼緊固件的性能及其分類>不鏽鋼緊固件的性能及其分類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1694b3be.html alt=各種外保溫材料的性能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1694b3be.html title=各種外保溫材料的性能>各種外保溫材料的性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a04c450.html alt=兒童碘缺乏的那些事兒，你不可不知道 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3ec900046f58fba90c11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a04c450.html title=兒童碘缺乏的那些事兒，你不可不知道>兒童碘缺乏的那些事兒，你不可不知道</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/735bd002.html alt=力學性能指標大彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0cd5fadec2384a1e86a12b0cb64b5161 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/735bd002.html title=力學性能指標大彙總>力學性能指標大彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cc721d0.html alt=冷鐓材料選擇及金屬性能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15360545582299e7668ebe2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cc721d0.html title=冷鐓材料選擇及金屬性能>冷鐓材料選擇及金屬性能</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>