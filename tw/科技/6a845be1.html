<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>讓我再擼一次HashMap | 极客快訊</title><meta property="og:title" content="讓我再擼一次HashMap - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/15173e2b82454e6188f3823cb77dcb6d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a845be1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a845be1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a845be1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a845be1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a845be1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a845be1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a845be1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a845be1.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="讓我再擼一次HashMap"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6a845be1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>讓我再擼一次HashMap</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre>來源：公眾號孤獨煙 ， 作者 孤獨煙</pre><p><strong>引言</strong></p><p>其實我很早以前就想寫一篇關於HashMap的面試專題。對於JAVA求職者來說，HashMap可謂是集合類的重中之重，甚至你在複習的時候，其他集合類都不用看，專攻HashMap即可。</p><p>然而，鑑於網上大部分的關於HashMap的面試方向文章，煙哥看過後都不是太滿意。因此，斗膽嘗試也寫一篇關於HashMap的面試專題文章!</p><p><strong>正文</strong></p><p><strong>(1)HashMap的實現原理?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>你看過HashMap源碼嘛，知道原理嘛?</li><li>為什麼用數組+鏈表？</li><li>hash衝突你還知道哪些解決辦法？</li><li>我用LinkedList代替數組結構可以麼?</li><li>既然是可以的,為什麼HashMap不用LinkedList,而選用數組?</li></ul><p><em>你看過HashMap源碼嘛，知道原理嘛?</em></p><p>針對這個問題，嗯，當然是必須看過HashMap源碼。至於原理，下面那張圖很清楚了:</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15173e2b82454e6188f3823cb77dcb6d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>HashMap採用Entry數組來存儲key-value對，每一個鍵值對組成了一個Entry實體，Entry類實際上是一個單向的鏈表結構，它具有Next指針，可以連接下一個Entry實體。</p><p>只是在JDK1.8中，鏈表長度大於8的時候，鏈表會轉成紅黑樹！</p><p><em>為什麼用數組+鏈表？</em></p><p>數組是用來確定桶的位置，利用元素的key的hash值對數組長度取模得到.</p><p>鏈表是用來解決hash衝突問題，當出現hash值一樣的情形，就在數組上的對應位置形成一條鏈表。</p><p>ps:這裡的hash值並不是指hashcode，而是將hashcode高低十六位異或過的。至於為什麼要這麼做，繼續往下看。</p><p><em>hash衝突你還知道哪些解決辦法？</em></p><p>比較出名的有四種(1)開放定址法(2)鏈地址法(3)再哈希法(4)公共溢出區域法</p><p>ps:大家有興趣拓展的，自己去搜一下就懂了，這個就不拓展了！</p><p><em>我用LinkedList代替數組結構可以麼?</em></p><p>這裡我稍微說明一下，此題的意思是，源碼中是這樣的</p><pre>Entry[] table = new Entry[capacity];</pre><p>ps：Entry就是一個鏈表節點。</p><p>那我用下面這樣表示</p><pre>List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;(); </pre><p>是否可行?</p><p>答案很明顯，必須是可以的。</p><p><em>既然是可以的,為什麼HashMap不用LinkedList,而選用數組?</em></p><p>因為用數組效率最高！</p><p>在HashMap中，定位桶的位置是利用元素的key的哈希值對數組長度取模得到。此時，我們已得到桶的位置。顯然數組的查找效率比LinkedList大。</p><p><em>那ArrayList，底層也是數組，查找也快啊，為啥不用ArrayList?</em></p><p>(煙哥寫到這裡的時候，不禁覺得自己真有想法，自己把自己問死了，還好我靈機一動想出了答案)</p><p>因為採用基本數組結構，擴容機制可以自己定義，HashMap中數組擴容剛好是2的次冪，在做取模運算的效率高。</p><p>而ArrayList的擴容機制是1.5倍擴容，那ArrayList為什麼是1.5倍擴容這就不在本文說明了。</p><p><strong>(2)HashMap在什麼條件下擴容?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>HashMap在什麼條件下擴容?</li><li>為什麼擴容是2的n次冪?</li><li>為什麼為什麼要先高16位異或低16位再取模運算?</li></ul><p><em>HashMap在什麼條件下擴容?</em></p><p>如果bucket滿了(超過load factor*current capacity)，就要resize。</p><p>load factor為0.75，為了最大程度避免哈希衝突</p><p>current capacity為當前數組大小。</p><p><em>為什麼擴容是2的次冪?</em></p><p>HashMap為了存取高效，要儘量較少碰撞，就是要儘量把數據分配均勻，每個鏈表長度大致相同，這個實現就在把數據存到哪個鏈表中的算法；這個算法實際就是取模，hash%length。</p><p>但是，大家都知道這種運算不如位移運算快。</p><p>因此，源碼中做了優化hash&(length-1)。</p><p>也就是說hash%length==hash&(length-1)</p><p>那為什麼是2的n次方呢？</p><p>因為2的n次方實際就是1後面n個0，2的n次方-1，實際就是n個1。</p><p>例如長度為8時候，3&(8-1)=3 2&(8-1)=2 ，不同位置上，不碰撞。</p><p>而長度為5的時候，3&(5-1)=0 2&(5-1)=0，都在0上，出現碰撞了。</p><p>所以，保證容積是2的n次方，是為了保證在做(length-1)的時候，每一位都能&1 ，也就是和1111……1111111進行與運算。</p><p><em>為什麼為什麼要先高16位異或低16位再取模運算?</em></p><p>我先晒一下，jdk1.8裡的hash方法。1.7的比較複雜，咱就不看了。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f63979b590b94e55a9c0885b10ad76b1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>hashmap這麼做，只是為了降低hash衝突的機率。</p><p>打個比方，當我們的length為16的時候，哈希碼(字符串“abcabcabcabcabc”的key對應的哈希碼)對(16-1)與操作，對於多個key生成的hashCode，只要哈希碼的後4位為0，不論不論高位怎麼變化，最終的結果均為0。</p><p>如下圖所示</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e362b9374884c69bae317e6a59c2b06><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>而加上高16位異或低16位的“擾動函數”後，結果如下</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c03bbfab497e41b0b7a395a1f5d490ca><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>可以看到: 擾動函數優化前：1954974080 % 16 = 1954974080 & (16 - 1) = 0 擾動函數優化後：1955003654 % 16 = 1955003654 & (16 - 1) = 6 很顯然，減少了碰撞的機率。</p><p><strong>(3)講講hashmap的get/put的過程?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>知道hashmap中put元素的過程是什麼樣麼?</li><li>知道hashmap中get元素的過程是什麼樣麼？</li><li>你還知道哪些hash算法？</li><li>說說String中hashcode的實現?(此題很多大廠問過)</li></ul><p><em>知道hashmap中put元素的過程是什麼樣麼?</em></p><p>對key的hashCode()做hash運算，計算index;</p><p>如果沒碰撞直接放到bucket裡；</p><p>如果碰撞了，以鏈表的形式存在buckets後；</p><p>如果碰撞導致鏈表過長(大於等於TREEIFY_THRESHOLD)，就把鏈表轉換成紅黑樹(JDK1.8中的改動)；</p><p>如果節點已經存在就替換old value(保證key的唯一性)</p><p>如果bucket滿了(超過load factor*current capacity)，就要resize。</p><p><em>知道hashmap中get元素的過程是什麼樣麼?</em></p><p>對key的hashCode()做hash運算，計算index;</p><p>如果在bucket裡的第一個節點裡直接命中，則直接返回；</p><p>如果有衝突，則通過key.equals(k)去查找對應的Entry;</p><ul><li>若為樹，則在樹中通過key.equals(k)查找，O(logn)；</li><li>若為鏈表，則在鏈表中通過key.equals(k)查找，O(n)。</li></ul><p><em>你還知道哪些hash算法？</em></p><p>先說一下hash算法幹嘛的，Hash函數是指把一個大範圍映射到一個小範圍。把大範圍映射到一個小範圍的目的往往是為了節省空間，使得數據容易保存。</p><p>比較出名的有MurmurHash、MD4、MD5等等</p><p><em>說說String中hashcode的實現?(此題頻率很高)</em></p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1bd034069fd1420e83b3fe2191512588><p class=pgc-img-caption></p></div><p class=ql-align-justify>String類中的hashCode計算方法還是比較簡單的，就是以31為權，每一位為字符的ASCII值進行運算，用自然溢出來等效取模。</p><p class=ql-align-justify>哈希計算公式可以計為<strong>s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1]</strong></p><p class=ql-align-justify>那為什麼以31為質數呢?</p><p class=ql-align-justify>主要是因為31是一個奇質數，所以31*i=32*i-i=(i&lt;&lt;5)-i，這種位移與減法結合的計算相比一般的運算快很多。</p><p class=ql-align-justify>(4)為什麼hashmap的在鏈表元素數量超過8時改為紅黑樹?</p><p class=ql-align-justify>此題可以組成如下連環炮來問</p><ul><li class=ql-align-justify>知道jdk1.8中hashmap改了啥麼?</li><li class=ql-align-justify>為什麼在解決hash衝突的時候，不直接用紅黑樹?而選擇先用鏈表，再轉紅黑樹?</li><li class=ql-align-justify>我不用紅黑樹，用二叉查找樹可以麼?</li><li class=ql-align-justify>那為什麼閥值是8呢?</li><li class=ql-align-justify>當鏈表轉為紅黑樹後，什麼時候退化為鏈表?</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify><em>知道jdk1.8中hashmap改了啥麼?</em></p><ul><li class=ql-align-justify>由<strong>數組+鏈表</strong>的結構改為<strong>數組+鏈表+紅黑樹</strong>。</li><li class=ql-align-justify>優化了高位運算的hash算法：h^(h>>>16)</li><li class=ql-align-justify>擴容後，元素要麼是在原位置，要麼是在原位置再移動2次冪的位置，且鏈表順序不變。</li></ul><p class=ql-align-justify>最後一條是重點，因為最後一條的變動，hashmap在1.8中，不會在出現死循環問題。</p><p class=ql-align-justify><em>為什麼在解決hash衝突的時候，不直接用紅黑樹?而選擇先用鏈表，再轉紅黑樹?</em></p><p class=ql-align-justify>因為紅黑樹需要進行左旋，右旋，變色這些操作來保持平衡，而單鏈表不需要。</p><p class=ql-align-justify>當元素小於8個當時候，此時做查詢操作，鏈表結構已經能保證查詢性能。當元素大於8個的時候，此時需要紅黑樹來加快查詢速度，但是新增節點的效率變慢了。</p><p class=ql-align-justify>因此，如果一開始就用紅黑樹結構，元素太少，新增效率又比較慢，無疑這是浪費性能的。</p><p class=ql-align-justify><em>我不用紅黑樹，用二叉查找樹可以麼?</em></p><p class=ql-align-justify>可以。但是二叉查找樹在特殊情況下會變成一條線性結構（這就跟原來使用鏈表結構一樣了，造成很深的問題），遍歷查找會非常慢。</p><p class=ql-align-justify><em>那為什麼閥值是8呢?</em></p><p class=ql-align-justify>不知道，等jdk作者來回答。</p><p class=ql-align-justify>這道題，網上能找到的答案都是扯淡。</p><p class=ql-align-justify>我隨便貼一個牛客網的答案，如下圖所示</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/71e559d3eb154d0eb0a45363d9eb4f6f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>看出bug沒？交點是6.64？交點分明是4，好麼。</p><p>log4=2，4/2=2。</p><p>jdk作者選擇8，一定經過了嚴格的運算，覺得在長度為8的時候，與其保證鏈表結構的查找開銷，不如轉換為紅黑樹，改為維持其平衡開銷。</p><p class=ql-align-justify><em>當鏈表轉為紅黑樹後，什麼時候退化為鏈表?</em></p><p class=ql-align-justify>為6的時候退轉為鏈表。中間有個差值7可以防止鏈表和樹之間頻繁的轉換。假設一下，如果設計成鏈表個數超過8則鏈表轉換成樹結構，鏈表個數小於8則樹結構轉換成鏈表，如果一個HashMap不停的插入、刪除元素，鏈表個數在8左右徘徊，就會頻繁的發生樹轉鏈表、鏈表轉樹，效率會很低。</p><p class=ql-align-justify><strong>(5)HashMap的併發問題?</strong></p><p class=ql-align-justify>此題可以組成如下連環炮來問</p><ul><li class=ql-align-justify>HashMap在併發編程環境下有什麼問題啊?</li><li class=ql-align-justify>在jdk1.8中還有這些問題麼?</li><li class=ql-align-justify>你一般怎麼解決這些問題的？</li></ul><p class=ql-align-justify><em>HashMap在併發編程環境下有什麼問題啊?</em></p><ul><li class=ql-align-justify>(1)多線程擴容，引起的死循環問題</li><li class=ql-align-justify>(2)多線程put的時候可能導致元素丟失</li><li class=ql-align-justify>(3)put非null元素後get出來的卻是null</li></ul><p class=ql-align-justify><em>在jdk1.8中還有這些問題麼?</em></p><p class=ql-align-justify>在jdk1.8中，死循環問題已經解決。其他兩個問題還是存在。</p><p class=ql-align-justify><em>你一般怎麼解決這些問題的？</em></p><p class=ql-align-justify>比如ConcurrentHashmap，Hashtable等線程安全等集合類。</p><p class=ql-align-justify><strong>(6)你一般用什麼作為HashMap的key?</strong></p><p class=ql-align-justify>此題可以組成如下連環炮來問</p><ul><li class=ql-align-justify>健可以為Null值麼?</li><li class=ql-align-justify>你一般用什麼作為HashMap的key?</li><li class=ql-align-justify>我用可變類當HashMap的key有什麼問題?</li><li class=ql-align-justify>如果讓你實現一個自定義的class作為HashMap的key該如何實現？</li></ul><p class=ql-align-justify><em>健可以為Null值麼?</em></p><p class=ql-align-justify>必須可以，key為null的時候，hash算法最後的值以0來計算，也就是放在數組的第一個位置。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1c2a4485f17d4c5faf4d4c3bd27768b5><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><em>你一般用什麼作為HashMap的key?</em></p><p>一般用Integer、String這種不可變類當HashMap當key，而且String最為常用。</p><ul><li class=ql-align-justify>(1)因為字符串是不可變的，所以在它創建的時候hashcode就被緩存了，不需要重新計算。這就使得字符串很適合作為Map中的鍵，字符串的處理速度要快過其它的鍵對象。這就是HashMap中的鍵往往都使用字符串。</li><li class=ql-align-justify>(2)因為獲取對象的時候要用到equals()和hashCode()方法，那麼鍵對象正確的重寫這兩個方法是非常重要的,這些類已經很規範的覆寫了hashCode()以及equals()方法。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify><em>我用可變類當HashMap的key有什麼問題?</em></p><p class=ql-align-justify>hashcode可能發生改變，導致put進去的值，無法get出，如下所示</p><div class=pgc-img><img alt=讓我再擼一次HashMap onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5de18305e766408fa5ca0660a8b4ef4a><p class=pgc-img-caption></p></div><p class=ql-align-justify>輸出值如下</p><pre class=ql-align-justify>java.lang.Object@74a14482null</pre><p class=ql-align-justify><br></p><p class=ql-align-justify><em>如果讓你實現一個自定義的class作為HashMap的key該如何實現？</em></p><p class=ql-align-justify>此題考察兩個知識點</p><ul><li class=ql-align-justify>重寫hashcode和equals方法注意什麼?</li><li class=ql-align-justify>如何設計一個不變類</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify>針對問題一，記住下面四個原則即可</p><p class=ql-align-justify>(1)兩個對象相等，hashcode一定相等</p><p class=ql-align-justify>(2)兩個對象不等，hashcode不一定不等</p><p class=ql-align-justify>(3)hashcode相等，兩個對象不一定相等</p><p class=ql-align-justify>(4)hashcode不等，兩個對象一定不等</p><p class=ql-align-justify>針對問題二，記住如何寫一個不可變類</p><p class=ql-align-justify>(1)類添加final修飾符，保證類不被繼承。</p><p class=ql-align-justify>如果類可以被繼承會破壞類的不可變性機制，只要繼承類覆蓋父類的方法並且繼承類可以改變成員變量值，那麼一旦子類以父類的形式出現時，不能保證當前類是否可變。</p><p class=ql-align-justify>(2)保證所有成員變量必須私有，並且加上final修飾</p><p class=ql-align-justify>通過這種方式保證成員變量不可改變。但只做到這一步還不夠，因為如果是對象成員變量有可能再外部改變其值。所以第4點彌補這個不足。</p><p class=ql-align-justify>(3)不提供改變成員變量的方法，包括setter</p><p class=ql-align-justify>避免通過其他接口改變成員變量的值，破壞不可變特性。</p><p class=ql-align-justify>(4)通過構造器初始化所有成員，進行深拷貝(deep copy)</p><p class=ql-align-justify>如果構造器傳入的對象直接賦值給成員變量，還是可以通過對傳入對象的修改進而導致改變內部變量的值。例如：</p><pre class=ql-align-justify>public final class ImmutableDemo {  private final int[] myArray;  public ImmutableDemo(int[] array) {  this.myArray = array; // wrong  } }</pre><p class=ql-align-justify>這種方式不能保證不可變性，myArray和array指向同一塊內存地址，用戶可以在ImmutableDemo之外通過修改array對象的值來改變myArray內部的值。</p><p class=ql-align-justify>為了保證內部的值不被修改，可以採用深度copy來創建一個新內存保存傳入的值。正確做法：</p><pre class=ql-align-justify>public final class MyImmutableDemo {  private final int[] myArray;  public MyImmutableDemo(int[] array) {  this.myArray = array.clone();  } }</pre><p class=ql-align-justify>(5)在getter方法中，不要直接返回對象本身，而是克隆對象，並返回對象的拷貝</p><p class=ql-align-justify>這種做法也是防止對象外洩，防止通過getter獲得內部可變成員對象後對成員變量直接操作，導致成員變量發生改變。</p><p class=ql-align-justify><strong>總結</strong></p><p class=ql-align-justify>這篇文章能概括大部分HashMap的面試題了，希望大家有所收穫！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>HashMap</a></li><li><a>一次</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html alt="為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6cbd09e4427c44c082e15ec40e24b6f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html title="為什麼 HashMap 的加載因子是0.75？">為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ac7fcc9.html alt=請你認真一次吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ac7fcc9.html title=請你認真一次吧>請你認真一次吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7151ca40.html alt=頭一次寫咱也不曉得怎麼寫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5db7445d2e91431fbd0ab16411ff0a11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7151ca40.html title=頭一次寫咱也不曉得怎麼寫>頭一次寫咱也不曉得怎麼寫</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/7cfc48d0.html alt=讓我抱抱你，一次也是一輩子 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/23b62a32774f4246abf469061e4ab647 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/7cfc48d0.html title=讓我抱抱你，一次也是一輩子>讓我抱抱你，一次也是一輩子</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/ef81a7da.html alt=再一次與佛像結緣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/56750010b1d0de083c76 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/ef81a7da.html title=再一次與佛像結緣>再一次與佛像結緣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d9d9472.html alt=最後一次“你們好就好” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S9Ng1H2IPHeLBc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d9d9472.html title=最後一次“你們好就好”>最後一次“你們好就好”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c579eb4c.html alt=HashMap容量為什麼要是2的冪次方？看完你就明白了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/50ec214e-1a26-4f7f-8b1a-ac5aeed2a037 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c579eb4c.html title=HashMap容量為什麼要是2的冪次方？看完你就明白了！>HashMap容量為什麼要是2的冪次方？看完你就明白了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9fdbeb5e.html alt=探究HashMap線性不安全（二）——鏈表成環的詳細過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/28a6f8f609e24e679faf365e1b4ebf57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9fdbeb5e.html title=探究HashMap線性不安全（二）——鏈表成環的詳細過程>探究HashMap線性不安全（二）——鏈表成環的詳細過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html alt="Java HashMap源碼分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a86461eb8cc4ddb9ddf740c0aa49b00 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html title="Java HashMap源碼分析">Java HashMap源碼分析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>