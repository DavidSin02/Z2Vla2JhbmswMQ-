<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>作為 Java 開發者，這個基於雲原生的編程框架你得了解一下 | 极客快訊</title><meta property="og:title" content="作為 Java 開發者，這個基於雲原生的編程框架你得了解一下 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/440f5237989843c689311f093bb02452"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ae4f5fe.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ae4f5fe.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6ae4f5fe.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ae4f5fe.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ae4f5fe.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6ae4f5fe.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6ae4f5fe.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ae4f5fe.html><meta property="article:published_time" content="2020-10-29T21:12:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:37+08:00"><meta name=Keywords content><meta name=description content="作為 Java 開發者，這個基於雲原生的編程框架你得了解一下"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6ae4f5fe.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>作為 Java 開發者，這個基於雲原生的編程框架你得了解一下</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>隨著各種開放雲平臺的出現，傳統的基於 Java 和 J2EE 的編程模型和框架在雲環境下無法適應，高內存需求和啟動速度緩慢等限制了它們在雲平臺的擴展能力，面向雲原生的編程框架需求變得越來越多。2019 年紅帽發佈了基於雲原生的 Java 框架 Quarkus，本文作者馮徵從 Quarkus 項目背景、設計特色、應用場景、開發難點等方面做了全方位剖析，希望給關注 Quarkus 框架的開發者帶來一些幫助和思考。他還將在 QCon 全球開發大會（北京站）2020 分享 Quarkus 的更多技術動態，敬請關注！</p><p style=text-align:center>Quarkus 項目背景</p><p>2018 年，在一次內部會議中，有人問到“有什麼會成為紅帽中間件最大的威脅？”，紅帽中間件副總裁 Mark Little 的回答讓我印象很深。他最擔心的事情是，如果一種新的編程語言（比如 Go）能夠給用戶提供更快地運行速度，並且提供更豐富的類庫來支持從 Java 應用的遷移，那麼在雲環境不斷完善並進入用戶的生產系統後，這種應用替換和遷移的代價在不斷降低，使得用戶會更傾向於使用新的編程語言來進行開發。而紅帽所有基於 Java 的中間件產品都用新的編程語言來重構一遍幾乎是不可能的。所以我們必須要讓 Java 更快一些。</p><p>後來，紅帽內部建立了一個“祕密”項目 Protean ，也就是 Quarkus 早期的名稱。當時只有少數的開發人員參與設計並開發原型系統。早期測試的時候，我們在 Kubernetes 中單純利用 Wildfly 或者 JBoss EAP 的 docker 鏡像來啟動用戶的應用，最多隻能擴展到 100 多個實例，而且啟動的時間很長。而利用 Quarkus 產生的 Native 應用 docker 鏡像，可以輕鬆地擴展到 1000 多個示例，是前者的 10 倍多，並且啟動時間大大縮短。這些都促使紅帽中間件在 Quarkus 的創新，使之成為紅帽整個 Open Hybrid Cloud Strategy（開放混合雲架構）中重要和不可或缺的一部分。</p><p>Quarkus 與 Spring 等主流框架的異同</p><p>Quarkus 是基於 J2EE（ Jakarta EE ）和 MicroProfile 標準來作為技術棧，而 Spring 有自己的一套東西，大家可以從 https://simply-how.com/ Quarkus -vs-spring 來看兩者的區別。其實 Spring 社區也開始在實踐用 Graal VM 來構建 Native 應用，項目網站是 https://github.com/spring-projects-experimental/spring-graal-native。我們可以看到，目前這個項目還是處於驗證階段，和 Quarkus 相比還有很遠的距離。</p><div class=pgc-img><img alt="作為 Java 開發者，這個基於雲原生的編程框架你得了解一下" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/440f5237989843c689311f093bb02452><p class=pgc-img-caption></p></div><p>Quarkus 設計特色</p><p>從一開始， Quarkus 就圍繞容器優先理念進行設計。通過以下方式針對低內存使用量和快速啟動時間進行了優化：</p><ul><li><strong>對 Graal / SubstrateVM 的支持</strong></li></ul><p>這一直是 Quarkus 設計的重要組成部分。當把應用程序編譯為本地映像時，它的啟動速度會更快，並且可以用比標準 JVM 小得多的堆棧參數來運行。Quarkus 已經通過了 Substrate 的所有測試，可以在沒有 -H：+ ReportUnsupportedElementsAtRuntime 標誌的情況下運行。</p><ul><li><strong>構建階段的元數據處理</strong></li></ul><p>在構建階段將進行儘可能多的處理，因此應用程序將僅包含運行時實際需要的類。在傳統模型中，所有的類都會在應用程序初始化時進行處理，即使它們僅使用一次。而使用 Quarkus ，它們甚至都不會加載到運行時的 JVM 虛擬機中。因為在構建階段我們就儘量完成初始化的工作，這將減少應用在運行時的內存使用量，並縮短應用的啟動時間。</p><ul><li><strong>減少反射使用</strong></li></ul><p>Quarkus 儘可能避免使用 Java 的反射功能。</p><ul><li><strong>Native 原生應用的提前引導</strong></li></ul><p>當使用 Native 原生應用運行時， Quarkus 在 Native 映像的構建過程中提前引導儘可能多的框架代碼。這意味著生成的 Native 映像已經執行了大多數啟動代碼，並將結果序列化到最終的可執行映像文件中，從而使應用的啟動速度更快。</p><p>Quarkus 的內核是圍繞著 CDI 設計，整個核心就是一個微型的 CDI 容器，而且完全支持異步的編程模型比如 Netty 和 Vert.x ，可以支持直接利用 Kotlin 語言進行開發。整個 Quarkus 框架採用了 Extensions 進行擴展，其中包含了目前紅帽中間件大部分的產品，比如 Hibernate ORM、 Artemis、Resteasy、Undertow、Narayana、 Infinispan、Camel、KeyCloak 等等。所以對用戶來說，是可以輕鬆的利用這些框架和工具來進行開發。</p><p>從內部的 Quarkus 0.1 測試版本開始，到目前剛剛發佈 1.4.1.Final ， Quarkus 的開發速度是很快的，不斷帶來更多的 Extension 擴展來豐富功能。值得注意的是，從 Quarkus 1.4 版本開始，JDK 8 將被標記為過時，而從 1.6 版本開始， Quarkus 將不再支持 JDK 8，而會支持 JDK 11 的 LTS 版本。</p><p>Quarkus 應用場景</p><p>Quarkus 主要應用場景是開發雲原生應用，用戶可以輕鬆利用 Quarkus 生成 Native 映像並進行部署。當然， Quarkus 不僅僅可以運行在 Kerbenetes 環境中，也可以運行在 JVM 虛擬機環境中，甚至可以運行在用戶本地的 IDE 開發環境中。它解決的核心問題是加速 Java 程序的啟動和運行速度以及更小的運行時內存佔用。用戶非常驚歎 Native 應用的啟動速度，往往能比正常的 Java 應用快 10 倍以上。而且經過優化以後， Native 的映像文件可以做的很小，非常適合在雲環境中使用。</p><p>我們來看一下內存使用和啟動速度的比較：</p><div class=pgc-img><img alt="作為 Java 開發者，這個基於雲原生的編程框架你得了解一下" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4da6842cfcb44ae6b67c5a6f43364e79><p class=pgc-img-caption></p></div><p>Quarkus 開發難點</p><p>其實 Quarkus 有很多的腳手架工具來幫助用戶搭建開發環境，用戶也可以從網站 code. quarkus .redhat.com 來輕鬆的生成項目工程。開發者利用 Maven 或者 Gradle 來構建應用也是非常的方便。如果要說最難的地方的話，可能會是開發 Quarkus 的 Extension 擴展。我目前的工作就是把 Camel 的組件加入到 Quarkus 中成為擴展，這樣用戶就可以方便的在 Quarkus 應用中使用這些 Camel 組件。</p><p>我會通過一個具體的示例來說明如何進行 Quarkus 的擴展開發。目前 Quarkus 還不支持 Scratch 方式來構建擴展項目，所以只能是在 Quarkus 的代碼樹中來新增擴展。比如我們想要加一個新的擴展 Upper-extension ，它可以提供應用調用的方法 Upper.convert（String str）把字符串 str 全部轉換成大寫：</p><pre><code>public class Upper {    public String convert(String str) {        return StringUtils.upperCase(str);    }}</code></pre><p>首先我們需要從 Github 下載或者複製 Quarkus 源代碼：</p><pre><code>git clone https://github.com/quarkusio/quarkus.gitcd quarkuscd extensionsmvn io.quarkus:quarkus-maven-plugin:1.4.2.Final:create-extension -N \    -Dquarkus.artifactIdBase=upper \    -Dquarkus.artifactIdPrefix=quarkus- \    -Dquarkus.nameBase="Upper Extension"</code></pre><p>生成的 Maven 工程包含兩個子項目 Deployment 和 Runtime 。我們來分別看看這兩個子項目，首先在 Deployment 中主要包含 Quarkus 在構建階段所需要做的工作，帶有 @BuildStep 註解標記的方法都會在構建階段執行，比如在 UpperProcessor.java 文件中</p><pre><code>@BuildStepFeatureBuildItem feature() {    return new FeatureBuildItem(FEATURE);}</code></pre><p>這表明會返回一個包含當前擴展名稱的 BuildItem。</p><p>各個構建步驟之間可以通過 BuildItem 來傳遞信息，比如上面的 FeatureBuildItem 當有其它的構建步驟需要獲得這個信息的時候可以作為參數來使用：</p><pre><code>@BuildStepvoid printFeatures(List&lt;FeaturesBuildItem&gt; features) {     foreach(FeatureBuildItem feature : features) {         System.out.println(feature.getInfo());     }}</code></pre><p>我們需要在 deployment/pom.xml 中使用如下代碼處理這些 @BuildStep 註解標記的方法：</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;configuration&gt;        &lt;annotationProcessorPaths&gt;            &lt;path&gt;                &lt;groupId&gt;io.quarkus&lt;/groupId&gt;                &lt;artifactId&gt;quarkus-extension-processor&lt;/artifactId&gt;                &lt;version&gt;${quarkus.version}&lt;/version&gt;            &lt;/path&gt;        &lt;/annotationProcessorPaths&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre><p>那麼如何在構建階段創建類並實現靜態初始化操作呢 ？在這裡我們就需要用到 Bytecode Recording（字節碼記錄）。</p><p>在 Runtime 子項目中新建一個 UpperRecorder.java ：</p><pre><code>@Recorderpublic class UpperRecorder {    public void createUpper(BeanContainer container) {        Upper upper = new Upper();        container.instance(UpperProducer.class).setUpper(upper);    }}</code></pre><p>注意這裡的 @Recorder 註解標記， Quarkus 會把構建階段每次的方法調用都序列化，並通過生成 Bytecode 的方式保存下來。所以 CreateUpper 方法中的操作在構建階段都不會立即執行，而是會轉換成 bytecode 並延遲到運行時再執行。</p><p>而在構建階段，我們可以做的初始化工作，包括設置參數，掃描特定的 Annotation 並註冊（我們在 Camel- Quarkus 中也使用了）等等。這樣做的好處是在構建階段可以儘量多的完成初始化工作，這樣運行時啟動應用的速度會大大加快。如果是要通過 Graal VM 生成 Native 映像的話，有些初始化工作是不能在構建階段做的，比如監聽網絡端口，啟動線程池等等。</p><p>回到 Deplolyment 的 UpperProcessor 中，我們增加一個構建步驟來創建 Upper ：</p><pre><code>@BuildStep@Record(ExecutionTime.STATIC_INIT)void create(UpperRecorder recorder, BeanContainerBuildItem beanContainer) {    recorder.createUpper(beanContainer.getValue());}</code></pre><p>這樣我們基本完成了 Upper 擴展，為了讓用戶可以在 CDI 環境中使用 Upper，我們還需要在 Runtime 中新建 UpperProducer.java ：</p><pre><code>@Singletonpublic class UpperProducer {    private volatile Upper upper;    void setUpper(Upper upper) {        this.upper = upper;    }    @Produces    Upper getUpper() {        return upper;    }}</code></pre><p>然後在 deployment/UpperProcessor.java 中加入：</p><pre><code>@BuildStepAdditionalBeanBuildItem upper() {    return AdditionalBeanBuildItem.unremovableOf(UpperProducer.class);    }}</code></pre><p>使得 Quarkus 把 UpperProducer 也當成 CDI Bean 來處理，可以在依賴注入中使用 Upper 。</p><p>最後用戶就可以在應用中這樣來使用：</p><pre><code>@ApplicationScopedpublic class MyService {    @Inject    Upper upper;    public String onMessage(String message) {        return upper.convert(message);    }}</code></pre><p>總的來說，在 Extension 的擴展中，我們使用 @BuildStep 來標記各種構建步驟，並且儘量在構建階段完成初始化工作，這樣可以減少通過 Graal VM 生成的可執行映像文件大小，加快應用的啟動速度，縮短啟動時間。</p><p>Quarkus 進展與展望</p><p>很多公司在早期的 Tech Pre 版本開始就在關注 Quarkus ，比如（Ericsson、Amadeus）。隨著 Quarkus 正式 GA 產品的發佈，我相信會有很多的公司加入到 Quarkus 中。紅帽一直以來的都堅持採用“社區驅動”的產品開發模式，未來，紅帽中間件的所有產品都計劃考慮加入到 Quarkus 中，這樣可以讓用戶之前基於 J2EE 開發的應用能夠在 Quarkus 中進行測試。</p><p>雲原生應用越來越重要，大量基於 Java 開發的應用都面臨著同樣的問題，比如在雲環境中如何快速的部署和提高應用啟動速度。Quarkus 是紅帽開放混合雲戰略的重要組成部分，也是紅帽中間件下一代的核心產品。作為雲原生應用的開發利器，Quarkus 將幫助用戶利用 Jakarta EE 和 MicroProfile 技術棧更快和更便利的開發產品，並快速部署到雲環境中。作為 Java 開發者，需要對雲原生應用有更多的瞭解，並對 Quarkus 這樣的新框架熟悉掌握，最後也希望能夠有更多的開發者關注 Quarkus 並積極參與到社區裡。我們期待推出的產品是經過社區用戶的大量反饋，並且也能真正適應開發者需求的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>作為</a></li><li><a>Java</a></li><li><a>開發者</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/35ffd06.html alt=Java開發者必知必會的20種常用類庫和API class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e1fa8844c37042888cf90208bf943765 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35ffd06.html title=Java開發者必知必會的20種常用類庫和API>Java開發者必知必會的20種常用類庫和API</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50cccce6.html alt=作為二手車準客戶，你必須要知道汽車的車身結構件都在這裡 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68dab73e134f42e587f5144653f44d1e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50cccce6.html title=作為二手車準客戶，你必須要知道汽車的車身結構件都在這裡>作為二手車準客戶，你必須要知道汽車的車身結構件都在這裡</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>