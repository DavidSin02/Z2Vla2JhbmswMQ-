<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java併發編程-cpu的流水線 | 极客快訊</title><meta property="og:title" content="Java併發編程-cpu的流水線 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/7f4148aa001d409f9c216ca503586596"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6b74f39.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6b74f39.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6b74f39.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6b74f39.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6b74f39.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6b74f39.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6b74f39.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6b74f39.html><meta property="article:published_time" content="2020-10-29T21:04:24+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:24+08:00"><meta name=Keywords content><meta name=description content="Java併發編程-cpu的流水線"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6b74f39.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java併發編程-cpu的流水線</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>作為開發者，CPU在我們的工作中扮演了核心角色，因此瞭解處理器內部的工作方式對程序員來說不無裨益。CPU是如何工作了呢？一條指令執行需要多長時間？當我們討論某個新款處理器擁有12級流水線還是18級流水線，甚至是更深的31級流水線時，這到底都意味著什麼呢？應用程序通常會將CPU看作是黑盒子。程序中的指令按照順序依次進入CPU，執行完之後再按順序依次從CPU中出來，而內部到底發生了什麼，我們通常並不瞭解。對我們程序員來說，尤其是對做程序性能調優工作的程序員來說，學習CPU內部的細節非常必要。前文講到過為了儘量利用CPU的資源，使用高速緩存來緩解內存工作速度遠小於CPU工作速度的矛盾。那CPU本身對於效率的優化有哪些方式呢？本文僅從軟件層面來了解一下CPU的優化手段，至於硬件層面不作闡述。CPU裡存在兩樣優化速度的技術，分別是 ：指令流水線和指令亂序執行。</p><p><br></p><div class=pgc-img><img alt=Java併發編程-cpu的流水線 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7f4148aa001d409f9c216ca503586596><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>CPU技術發展歷史</h1><p>從一個非常廣的角度來說，X86處理器架構在近35年來並沒有變化太多。雖然X86架構被附加了很多新功能，但是最初的設計（包括幾乎所有最初的指令集）仍然基本上是完整保留的，即使在最新的處理器上仍然被支持。最初的8086處理器支持14個寄存器，這些寄存器在如今最新的處理器中仍然存在。這14個寄存器中，有4個是通用寄存器：AX，BX，CX和DX；有4個是段寄存器，段寄存器用來輔助指針的實現：代碼段(CS)，數據段(DS)，擴展段(ES)和堆棧段(SS)；有4個是索引寄存器，用來指向內存地址：源引用(SI)，目的引用(DI)，基指針(BP)，棧指針(SP)；有1個寄存器包含狀態位；最後是最重要的寄存器：指令指針(IP)。指令指針寄存器是一個擁有特殊功能的指針。指令指針的功能是指向將要運行的下一條指令。所有的X86處理器都按照相同的模式運行。首先，根據指令指針指向的地址取得下一條即將運行的指令並解析該指令（譯碼）。在譯碼完成後，會有一個指令的執行階段。有些指令用來從內存讀取數據或者向內存寫數據，有些指令用來執行計算或者比較等工作。當指令執行完成後，這條指令會通過退出(retire)階段並將指令指針修改為下一條指令。相較於現今的標準，最初的處理器設計顯得太過簡單。最初的8086處理器的執行過程可以簡述為從當前指令指針取得指令，通過譯碼，執行最後退出，然後繼續從指令指針指向的下一條指令處取得指令。新的處理器增加了新的功能，有些增加了新的指令，有些增加了新的寄存器。我將主要關注和本文主題有關係的改變，這些改變影響了CPU指令執行的流程。其他的一些變化比如虛擬內存或者並行處理雖然都很有意義而且有趣，但是並不在本文主題的範圍內。</p><ul><li>1971年：世界上第一塊微處理器4004在Intel公司誕生了。它出現的意義是劃時代的，比起以前的CPU，4004顯得很可憐，它是隻有2300個晶體管4位CPU，功能相當有限，而且速度還很慢。</li><li>1978年：Intel公司首次生產出16位的微處理器命名為i8086，同時還生產出與之相配合的數學協處理器i8087，這兩種芯片使用相互兼容的指令集。由於這些指令集應用於i8086和i8087，所以人們也把這些指令集統一稱之為X86指令集。這就是X86指令集的來歷。</li><li>1982年：指令緩存被加入到處理器中。通過指令緩存，處理器可以一次性從內存讀取更多指令並放在指令緩存中，而不用每條指令都從內存中取。指令緩存僅有幾個字節大小，只能容納數條指令，但是因為消除了之後每次取指往返內存和處理器的時間，極大的提高的效率</li><li>1985年：386處理器引入了數據緩存，而且擴展了指令緩存的設計。數據訪存請求通過一次性讀取更多的數據放在數據緩存中，從而提升了性能。而且，數據緩存和指令緩存都從幾個字節擴大到幾千字節。</li><li>1989年：推出的i486處理器引入了五級流水線。這時，在CPU中不再僅運行一條指令，每一級流水線在同一時刻都運行著不同的指令。這個設計使得i486比同頻率的386處理器性能提升了不止一倍。五級流水線中的取指階段將指令從指令緩存中取出（i486中的指令緩存為8KB）；第二級為譯碼階段，將取出的指令翻譯為具體的功能操作；第三級為轉址階段，用來將內存地址和偏移進行轉換；第四級為執行階段，指令在該階段真正執行運算；第五級為退出階段，運算的結果被寫回寄存器或者內存。由於處理器同時運行了多條指令，大大提升了程序運行的性能。</li><li>1993年：Intel推出了奔騰(Pentium)處理器。由於訴訟問題，Intel無法繼續沿用原來的數字編號。因此，用奔騰替代了586作為新款處理器的代號。奔騰處理器相對i486處理器對流水線做出了更多修改。奔騰處理器架構增加了第二條獨立的超標量流水線。主流水線工作方式類似於i486，第二條流水線則並行的運行一些較簡單的指令，比如說定點算術，而且該流水線能更快的進行該運算。</li><li>1995年：Intel推出了奔騰Pro(Pentium Pro)處理器。和之前的處理器相比，奔騰Pro採用了完全不同的設計。該處理器採用了諸多新特性以提高性能，包括亂序(Out-of-Order, OOO)執行的部件以及猜測執行。流水線擴展到了12級，而且引入了“超標量流水線”的概念，使得許多指令可以被同時處理。我們稍後將詳盡的介紹亂序執行的部件。</li><li>1995~2002年：亂序執行部件經過了數次重大改進。處理器中加入了更多的寄存器；單指令多數據(Single Instruction Multiple Data, or SIMD)的引入使得一條指令可以進行多組數據運算；現有的緩存變得更大而且引入了新的緩存；有些流水級被拆分成更多流水級，有些流水級被合併，使得更加適合實際的應用。這些改變對整體性能的提升有重要作用，但它們都沒有從根本影響數據在處理器中的流動方式。</li><li>2002年：Intel發佈奔騰4處理器引入了超線程技術。亂序執行部件的設計使得指令被執行的速度比處理器能夠提供指令的速度更快。因此對於大部分應用，CPU的亂序執行部件在大部分時間處於空閒狀態，甚至在高負載的情況下也不能充分利用。為了讓指令流能充分的流入亂序執行部件，Intel加入了第二套前端部件（譯註：在處理器結構中，前端是指取指，譯碼，寄存器重命名等模塊，經過前端部件的處理後，指令等待發射進入亂序執行部件）。雖然實際上只有一個亂序執行部件，但對於操作系統來說，它能看到兩個處理器。前端部件包含兩組同樣功能的X86寄存器，兩個指令譯碼器根據兩個指令指針指向的地址分別處理。所有的指令被一個共享的亂序執行部件執行，但對應用程序來說並不知情。當亂序執行部件執行完成，像之前一樣退出流水線後，最終結果返回虛擬的兩個處理器。</li><li>2006年：Intel發佈了酷睿(Core)微架構。為了品牌效應，它被稱做酷睿2（二總比一好）。令人驚訝的是，處理器頻率不升反降，而且超線程也被去掉了。通過降低時鐘頻率，每一級流水線可以做更多工作。亂序執行部件也被擴展的更寬。各種不同的緩存和隊列都相應做的更大。而且處理器被重新設計，以適應雙核和四核的共享緩存結構。</li><li>2008年：Intel開始用酷睿i3, i5, i7的方式來命名新的處理器。新處理器重新引入了超線程。這三個系列的處理器主要區別在於內部緩存大小不同。</li></ul><h1 class=pgc-h-arrow-right>CPU指令流水線</h1><p>根據之前描述的基礎，指令進入流水線，通過流水線處理，從流水線出來的過程，對於我們程序員來說，是比較直觀的。對於CPU性能有以下公式：處理器性能 = 主頻 X IPC</p><p>由這個公式我們可以知道，提高CPU性能要麼就提高主頻，要麼就提高IPC(CPU每一時鐘週期內所執行的指令數量)，提升IPC有兩種做法，一個是增加單核並行的度，一個是加多幾個核。早期一些採用非常簡單的指令集的電腦是採用單週期設計的，取指、解碼、執行、寫回都是放在同一個節拍（週期）內順序完成此時的 CPI(每條指令執行時所花費的平均時鐘週期數）基本上是 1，但是這樣設計的效率很低：當取指的時候，其餘工位都只能瞎瞪眼等開飯，這樣的設計也被稱作非流水線化執行。其執行圖如下</p><p><br></p><div class=pgc-img><img alt=Java併發編程-cpu的流水線 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b9c975e250f44b659ddabd484d2e97f8><p class=pgc-img-caption></p></div><p>因此也可得出一個結論，想要提供CPU的工作效率，就要讓CPU在每個時鐘週期內儘可能多的執行指令。I486擁有五級流水線。分別是：取指(Fetch)，譯碼(D1, main decode)，轉址(D2, translate)，執行(EX, execute)，寫回(WB)。某個指令可以在流水線的任何一級。在理想情況下，流水線級數越多，可同時流水執行的指令數越多，正比增長。這就是推出該問題的理論基礎。並行度越大，在宏觀上看其實就等效於每一條指令的執行速度都變快了。但現實不是這樣理想的。流水的時候，會遇見各種冒險機制（某硬件不支持同時鍾週期被多個資源訪問，數據依賴或邏輯關係不被滿足的情況，跳轉指令等），造成流水設計的困難。下面是流水線工作的流程圖</p><p><br></p><div class=pgc-img><img alt=Java併發編程-cpu的流水線 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/94d6cabb222e4652989f4d1a3f6fd928><p class=pgc-img-caption></p></div><p>流水線是將組合邏輯分割成多個小塊，因為每段的關鍵路徑變短了，所以能提高系統主頻。同時能讓任務以類似並行方式處理，提高硬件模塊的利用率，提高系統頻率，提高吞吐量。這裡可能有些朋友會有疑問，流水線的級數是不是越高，CPU的利用率就越高呢？理想很豐滿，現實很骨感。理論上流水線級數越多，每級所花的時間越短，時鐘週期就可以設計的越短，指令速度越快，指令平均執行時間也就越短。但實際上，流水線越長，重疊執行的指令就越多，那麼發生競爭衝突得可能性就越大，一般來說流水線越長，整體性能越差，而且還有前車之鑑。著名的奔騰四，就是因為流水線過長，而落得個高頻低能的名聲。而且，拜糟糕的奔騰四所賜， AMD 在那個時代全面超越了 intel，這也是歷史上唯一的一小段 AMD 主營 CPU 在性能上完全超越 intel 主營 CPU 的年代。（這個年代持續得不長，就因為酷睿的出世而結束了。）流水線過長對性能沒有幫助，只對提升主頻有幫助。長流水線能夠使你提升主頻更容易，所以容易造就高頻低能的芯片。另一方面，流水線技術是以空間換時間的技術，如果流水線過長，就需要更多的寄存器來保存流水線中產生的中間結果，對於芯片的製作成本也會有所提升。</p><ul><li>1993年，Pentium：5級流水線</li><li>1995年，Pentium Pro：12級流水線</li><li>1999年，ARM9：5級流水線</li><li>2002年，ARM11：8級流水線</li><li>2004年，Pentuim4(Prescott)：31級流水線</li><li>2006年，Core2 Duo(Merom)：14級</li><li>2008年，Core i7(Nehalem)：16級</li></ul><h1 class=pgc-h-arrow-right>流水線的冒險思想</h1><p>流水線技術之所以能提高性能 究其本質是利用了時間上的並行性，那它讓原本應該先後執行的指令在時間上一定程度的並行起來，然而這也會帶來一些衝突和矛盾，進而可能引發錯誤。流水線處理中，由於各個階段的依賴關係、硬件資源的競爭等原因，會出現操作無法執行的情況。造成流水線故障的原因稱為冒險。冒險分為三種：</p><ul><li>結構冒險：如果一條指令需要的硬件部件還在為之前的指令工作，而無法為這條指令提供服務，那就導致了結構冒險。（這裡結構是指硬件當中的某個部件）</li><li>數據冒險：由於指令執行所需要的數據還未準備好所引起的冒險情況。當即將執行的指令依賴於還未處理完成的數據時，會導致指令無法立刻開始執行，引發數據冒險。</li><li>控制冒險：如果現在要執行哪條指令，是由之前指令的運行結果決定，而現在那條之前指令的結果還沒產生，就導致了控制冒險。</li></ul><p><strong>分支預測</strong></p><p>雖然同一時間，流水線中執行了多條指令，但是分支判斷帶來的跳轉，導致無法正確順序地載入對應的跳轉代碼進流水線。如果沒有分支預測器，處理器將會等待分支指令通過了指令流水線的執行階段，才把下一條指令送入流水線的第一個階段—取指令階段（fetch stage）或者將後續流水線全部清空。這種技術叫做流水線停頓（pipeline stalled）或者流水線冒泡（pipeline bubbling）或者分支延遲間隙，這個非常影響流水線並行執行的效率。</p><p><br></p><div class=pgc-img><img alt=Java併發編程-cpu的流水線 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b59d5a95cae94f42888fb138f66ed8b9><p class=pgc-img-caption></p></div><p>為了解決上述問題，流水線中引入了分支預測器來完成分支預測機制。分支預測就是通過預測，把接下來最有可能執行的分支獲取進入流水線，就像不存在對比較結果的依賴那樣直接執行，這麼一來就保持了指令的流暢執行，這也被稱為Speculative Execution。不過這種通過預測獲取進入流水線的分支終究只是預測分支，實際上不一定是執行這一分支，因此這部分指令的執行結果不應該從流水線中輸出。在得到比較結果後，就能知道預測的分支是否為實際應該執行的分支，如果是，流水線中的預測分支指令就能繼續執行下去，否則就需要把預測分支的指令排空，重新獲取正確分支的指令進入流水線繼續執行。 分支預測，可能的方法有很多種。如：分支判斷可能的結果是A和B，最差的情況是永遠將分支判斷的A指令加入流水線，如果真實判斷時是A，那就直接執行，如果是B那麼再重新加入B也可以，效率能夠提高。實際的分支預測中，可能存入很多種方法，也會有固件的模式（Pattern）來適應。如改進上術的分支預判，當有一次實際判斷為B時，後面的全部就預判斷為B。上面只是簡單的介紹一下分支預測的最簡單模式，實際現在CPU的分支預測越來越強大，適應的模式越來越多。像AMD的新款Ryzen處理器，已經使用神經網絡的機器學習來強化分支預測了。 主流的分支預測器主要有兩種：靜態預測器（Static Predictor）和動態預測器(Dynamic Predictor)</p><ol start=1><li>靜態預測器：預測條件跳轉不發生，因此總是順序取下一條指令推測執行。僅當條件跳轉指令被求值確實發生了跳轉，則非順序的代碼地址被加載執行。另外一種，則預測條件跳轉總會發生，因CPU而異。對於這種靜態預測如果產生錯誤，則懲罰就是清空後續的流水線中的指令。</li><li>動態預測器：基於之前執行的分支信息，處理器對於正在執行的程序所做的決定。比如根據某個分支指令上次是否跳轉來預測此次是否跳轉。如果上次分支跳轉了，則預測此次也會跳轉。</li></ol><p>分支預測在很大程度上提高了流水線的運行效率，在明白了CPU的分支預測原理後，對於我們提高代碼的運行效率也具有指導意義，通過動態分支預測器我們可以知道本次是否跳轉是根據上次的結果來判斷的，那麼在編寫代碼時可以通過處理來提高判斷的準確率。下面是一個Java例子，通過對一個無序數組和一個有序數組的分支處理，從結果可以看出對有序數組的處理時間明顯小於無序數組的處理時間</p><pre><code>public class Test {    public static void main(String[] args){        randomTest();        SortTest();    }    private static void randomTest(){        int arraySize = 32768;        int data[] = new int[arraySize];        Random rnd = new Random(0);        for (int c = 0; c &lt; arraySize; ++c)            data[c] = rnd.nextInt() % 256;        int sum=0;        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000; i++){            for (int j = 0; j &lt; arraySize; j++){                if (data[j] &lt; 64) {                    sum += data[j];                }else if(data[j]&gt;=64 &amp;&amp; data[j]&lt;128){                    sum +=1;                }else {                    sum -= data[j];                }            }        }        System.out.println();        System.out.println("random time");        System.out.println(System.currentTimeMillis() - start);        System.out.println("sum = " + sum);    }    private static void SortTest(){        int arraySize = 32768;        int data[] = new int[arraySize];        Random rnd = new Random(0);        for (int c = 0; c &lt; arraySize; ++c)            data[c] = rnd.nextInt() % 256;        int sum=0;        Arrays.sort(data);        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 100000; i++){            for (int j = 0; j &lt; arraySize; j++){                if (data[j] &lt; 64) {                    sum += data[j];                }else if(data[j]&gt;=64 &amp;&amp; data[j]&lt;128){                    sum +=1;                }else {                    sum -= data[j];                }            }        }        System.out.println();        System.out.println("sort time");        System.out.println(System.currentTimeMillis() - start);        System.out.println("sum = " + sum);    }}</code></pre><p>執行結果如下</p><pre><code>random time12355sum = -460681728sort time2490sum = -460681728</code></pre><p><strong>指令的亂序執行</strong></p><p>在按序執行中，一旦遇到指令依賴的情況，流水線就會停滯，如果採用亂序執行，就可以跳到下一個非依賴指令併發布它。這樣，執行單元就可以總是處於工作狀態，把時間浪費減到最少。亂序執行是一種應用在高性能微處理器中來利用指令週期以避免特定類型的延遲消耗的範式。在這種範式中，處理器在一個由輸入數據可用性所決定的順序中執行指令，而不是由程序的原始數據所決定。在這種方式下，可以避免因為獲取下一條程序指令所引起的處理器等待，提前處理下一條可以立即執行的指令。其實很多設計思想都來源於生活，只是應用到不同的領域，就有了它的專業術語，讓不懂的人覺得很深奧很高大上，在搞明白怎麼回事後，會發現其實也沒那麼難。舉個生活中例子，假設晚上下班回家餓了，想煮碗麵做宵夜。需要做以下操作：1.洗水鍋，2.燒開水，3.煮麵條，4.熱菜，5，洗碗筷，6.吃麵。其中比較耗時的操作就是燒開水了，如果按CPU的流水線順序處理這些操作，那我們進行到第2步時就只能等水燒好然後才進去後面的步驟，這要做比較符合常規思維，但是太浪費資源了。雖然這樣的執行順序和我們編寫代碼的預期順序不一樣，但是因為後面的操作不依賴於前面操作的結果，因此完全可以在燒水的同時，把菜熱好，把碗筷洗乾淨準備盛面。這樣並不影響最終的結果，這就是CPU指令亂序執行。同理類比在CPU的一條流水線中，需要執行多條指令，比如有a,b,c三條指令組成的流水線，執行順序是a->b->c，這三條指令在數據上沒有依賴關係，其中b指令需要去主存中讀取數據，c指令是為變量分配內存地址，我們知道在CPU在緩存未命中情況下去主存讀取數據是比較慢的，因此b指令會佔用比較長的時鐘週期，而指令c只能乾等，這會使程序的執行效率大打折扣。這時指令亂序就會發揮出它的作用了，因為b,c指令沒有依賴關係，b,c指令執行順序調換不會影響最終結果，所以CPU在執行b指令時先會向數據總線發起向主存中讀數據的請求，在等待數據加載到CPU的高速緩存期間，會繼續執行c指令（注意此時b指令並沒有執行完，因為它還沒有真正從主存中讀到數據），然後再執行繼續b指令，這時指令的執行順序就變成了a->c->b。在理解了亂序執行，那麼對編碼有什麼幫助嗎？有的，對於開發人員來說，單例模式應該都不陌生，由於頻繁創建對象比較浪費資源，就考慮將所有用到某個類的實例時，公用同一個實例，於是就有了單例模式，然而單例模式並不是想象的那麼簡單。單例模式寫法有很多，在保證併發同步的單例模式中，有如下一種寫法：</p><pre><code>public class Singleton {    private Singleton() {}    private static Singleton singleton = null;    public static Singleton getSingleton() {        if (singleton == null) {            // 若singleton為空，則加鎖，再進一步判空            synchronized (Singleton.class) {                // 再判斷一次是否為null                if (singleton == null) {                    //若為空，則創建一個新的實例                    singleton = new Singleton();                      }            }        }        return Singleton;    }}</code></pre><p>這種寫法算是一個考慮比較周全的設計了 為了防止多線程調用產生多個實例，採用了同步鎖 ，為了降低多線程競爭鎖所帶來的性能損耗，使用了兩次判斷，加鎖位置得當，儘可能降低了鎖對性能的影響 ，但是這個例子在單線程中沒有任何問題，但在多線程中，如果出現指令亂序就會返回錯誤的結果。上面的單例模式中，出現問題的核心代碼只有一行，就是第15行。即 singleton = new Singleton(); 因為這行代碼不是一個原子操作，他實際上包含三個操作：</p><ol start=1><li>為對象 new Singleton() 分配內存空間</li><li>調用類 Singleton 的構造方法，初始化成員變量</li><li>將變量 singleton 的引用指向Singleton 對象的內存地址</li></ol><p>在這三步中，第2步依賴於第1步，但2和3並沒有依賴關係，因此第2步和第3步可能會先指令亂序。即當CPU流水線執行第2步時，由於類的初始化需要的時間比較長，為避免流水線阻塞，CPU會先執行第3步，將singleton 先指向對象的地址，因此線程有可能得到一個不為null，但是構造不完全的對象（對於不完全的對象的理解：即全部變量的初始化沒有執行完）。對於這種情況有兩種解決方案：</p><p>方案一：使用volatile關鍵字，在java5以前，volatile原語不怎麼強大，只能保證對象的可見性。但在java5之後，volatile語義加強了，被volatile修飾的對象，將禁止該對象上的讀寫指令重排序這樣，就保證了線程B讀對象時，已經初始化完全了</p><p>方案二：這也是官方比較推薦的一種方案，利用類加載機制來創建單例模式，不一樣的是，它是在內部類裡面去創建對象實例。這樣的話，只要應用中不使用內部類，JVM就不會去加載這個單例類，也就不會創建單例對象</p><pre><code>public class Singleton{          private static class SingletonHolder{          public static Singleton instance = new Singleton();      }          private Singleton(){}          public static Singleton newInstance(){          return SingletonHolder.instance;      }  }</code></pre><h1 class=pgc-h-arrow-right>as-if-serial語義</h1><p>as-if-serial語義的意思指：不管怎麼重排序（編譯器和處理器為了提高並行度），單線程程序的執行的結果不能被改變。編譯器，runtime 和處理器都必須遵守as-if-serial語義。為了遵守as-if-serial語義，編譯器和處理器不會對存在數據依賴關係的操作做重排序，因為這種重排序會改變執行結果。但是，如果操作之間不存在數據依賴關係，這些操作可能被編譯器和處理器重排序。as-if-serial語義把單線程程序保護了起來，遵守as-if-serial語義的編譯器，runtime 和處理器共同為編寫單線程程序的程序員創建了一個幻覺：單線程程序是按程序的順序來執行的（實際上沒有依賴的指令會出現重排序，但最終結果與順序執行的結果一致）。as-if-serial語義使單線程程序員無需擔心重排序會 干擾他們，也無需擔心內存可見性問題。</p><h1 class=pgc-h-arrow-right>內存屏障（Memory Barrier ）</h1><p>內存屏障，又稱內存柵欄，是一個CPU指令，它有如下特點：1.保證特定操作的執行順序。2.影響某些數據（或者是某條指令的執行結果）的內存可見性。主要有兩個指令：</p><ul><li>Store：將處理器緩存的數據刷新到內存中。</li><li>Load：將內存的數據拷貝到處理器的緩存中。</li></ul><p>編譯器和CPU能夠重排序指令，保證最終相同的結果，嘗試優化性能。插入一條Memory Barrier會告訴編譯器和CPU：不管什麼指令都不能和這條Memory Barrier指令重排序。Memory Barrier所做的另外一件事是強制刷出各種CPU cache，如一個Write-Barrier（寫入屏障）將刷出所有在Barrier之前寫入 cache 的數據，因此，任何CPU上的線程都能讀取到這些數據的最新版本。java內存模型volatile是基於Memory Barrier實現的。如果一個變量是volatile修飾的，JMM會在寫入這個字段之後插進一個Write-Barrier指令，並在讀這個字段之前插入一個Read-Barrier指令。這意味著，如果寫入一個volatile變量，就可以保證：1.一個線程寫入變量a後，任何線程訪問該變量都會拿到最新值。2.在寫入變量a之前的寫入操作，其更新的數據對於其他線程也是可見的。因為Memory Barrier會刷出cache中的所有先前的寫入。簡單來說內存屏障（Memory Barrier，或內存柵欄，Memory Fence）就是從本地或工作內存到主存之間的拷貝動作。內存屏障分為以下3類：</p><li><strong>Store barrier（寫屏障）</strong>：是x86的”<strong>sfence</strong>“指令，強制所有在store屏障指令之前的store指令，都在該store屏障指令執行之前被執行，並把store緩衝區的數據都刷到CPU緩存。這會使得程序狀態對其它CPU可見，這樣其它CPU可以根據需要介入。</li><li><strong>Load barrier（讀屏障）</strong>：是x86上的”<strong>ifence</strong>“指令，強制所有在load屏障指令之後的load指令，都在該load屏障指令執行之後被執行，並且一直等到load緩衝區被該CPU讀完才能執行之後的load指令。這使得從其它CPU暴露出來的程序狀態對該CPU可見，這之後CPU可以進行後續處理。</li><li><strong>Full barrier（全屏障）</strong>：是x86上的”<strong>mfence</strong>“指令，複合了load和save屏障的功能。</li><h1 class=pgc-h-arrow-right>原子指令和Software Locks</h1><p>原子指令，如x86上的”lock …” 指令是一個Full Barrier，執行時會鎖住內存子系統來確保執行順序，甚至跨多個CPU。Software Locks通常使用了內存屏障或原子指令來實現變量可見性和保持程序順序。對應的在java內存模型的內存屏障分為以下4類：</p><ol start=1><li>StoreStore Barriers：確保Store1數據對其他處理器可見(刷新到內存)，之前於Store2及所有後續存儲指令的存儲。</li><li>LoadStore Barriers：確保Load1數據裝載之前於Store2及所有後續存儲指令的存儲。</li><li>StoreLoad Barriers：確保Store1數據對其他處理器可見(刷新到內存)之前於Load2及所有後續裝載指令的裝載。</li><li>LoadLoad Barriers：確保Load1數據的裝載，之前於Load2及所有後續裝載指令的裝載。</li></ol><p>其中比較特殊的是StoreLoad Barriers會使該屏障之前的所有內存訪問指令(裝載和存儲指令)完成之後才執行該屏障之後的內存訪問指令，是一個”全能型”的屏障，它同時具有其他三個屏障的效果。內存屏障另一個作用是強制更新一次不同CPU的緩存。例如，一個寫屏障會把這個屏障前寫入的數據刷新到各個CPU的緩存(lazy型刷新, CPU監聽數據總線將緩存數據標記為invalid，用到時再重內存中載入)，這樣任何試圖讀取該數據的線程將得到最新值，而不用考慮到底是被哪個cpu核心或者哪顆CPU執行的。java中的volatile關鍵字正是使用了內存屏障。如果你的字段是volatile，Java內存模型將在寫操作後插入一個寫屏障指令，在讀操作前插入一個讀屏障指令。內存屏障作為另一個CPU級的指令，沒有鎖那樣大的開銷。內核並沒有在多個線程間干涉和調度。但凡事都是有代價的。內存屏障的確是有開銷的——編譯器/cpu不能重排序指令，導致不可以儘可能地高效利用CPU，另外刷新緩存亦會有開銷。所以要正確使用volatile。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>發編程</a></li><li><a>cpu</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html alt=Java併發編程：進程和線程之由來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/4f658919-1d85-46bc-bbf1-64aac52f4c80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html title=Java併發編程：進程和線程之由來>Java併發編程：進程和線程之由來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65021e04.html alt="Java併發編程 -- 手動實現可重入Lock" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65021e04.html title="Java併發編程 -- 手動實現可重入Lock">Java併發編程 -- 手動實現可重入Lock</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0ee178.html alt="「原創」Java併發編程系列36 | FutureTask" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/SAZA4S9I6wzJm7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0ee178.html title="「原創」Java併發編程系列36 | FutureTask">「原創」Java併發編程系列36 | FutureTask</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>