<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>簡單又複雜的“整數類型” | 极客快訊</title><meta property="og:title" content="簡單又複雜的“整數類型” - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1539512950121b943404743"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><meta property="article:published_time" content="2020-11-14T21:05:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:09+08:00"><meta name=Keywords content><meta name=description content="簡單又複雜的“整數類型”"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6bf9d56a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>簡單又複雜的“整數類型”</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>前言</h1><p>因為一道題目讓我不斷地深追下去，挖出了我多年的噩夢——數據類型的範圍與長度。每次都想得頭痛，因為平臺不同、編譯器不同、編程語言不同等等因素，又沒去做實驗，網上那麼多說法該相信誰都不知道……那不如趁現在就來詳細地解決掉它吧。</p><h1>一、原碼、反碼和補碼</h1><p><strong>基礎知識</strong></p><p>相信在大學的《數字邏輯》課上都學過這個內容了，原碼、反碼和補碼都是基於二進制而言的：</p><p>【原碼】第1位表示符號位，其餘位是這個數的絕對值。這是最簡單能夠馬上想到的表示方式了。</p><p>【反碼】正數的反碼是其本身；負數的反碼：在原碼的基礎上，符號位不變，其餘位取反。</p><p>【補碼】正數的補碼是其本身；負數的補碼：在原碼的基礎上，符號位不變，其餘位取反，最後+1。</p><p>舉個例子，假設整數在機器上是用8位二進制數表示的（8位就和我們經常說的32位、64位是一樣的含義）：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539512950121b943404743><p class=pgc-img-caption></p></div><p>為什麼要用原碼、反碼和補碼呢？</p><p><strong>原碼的來源</strong></p><p>為了讓二進制能夠表示負數，產生了原碼。</p><p><strong>反碼的來源</strong></p><p>一個正數和一個負數運算需要辨別符號位，然而單獨去辨別符號位會給電路設計帶來極大的複雜度，因此人們想只設計加法電路，讓符號位直接參與加法運算達到減法的目的，產生了反碼。例如：3-2 = 3+(-2) = [0000 0011]反+[1111 1101]反 = [0000 0001]反 = [0000 0001]原=1（注意反碼的加法當最高位進位的時候，最低位需要+1，不再詳細描述，參考百度百科《二進制反碼求和》）。這樣符號位就能夠參與運算了。</p><p><strong>補碼的來源</strong></p><p>反碼看起來很完美，但是仍然存在問題。例如3-3 = 3+(-3) = [0000 0011]反+[1111 1100]反 = [1111 1111]反 = [1000 0000]原=-0，而[0000 0000]反=[0000 0000]原 = +0，也就是說，零可以表示為兩種形式，這種歧義同樣不利於電路實現。並且由於反碼的加減法還需要對溢出位進行處理，於是產生了補碼。補碼對溢出位直接丟棄，而0的表示只有一種[0000 0000]補，[1000 0000]補則看成是-128，解決了所有問題。</p><p><strong>原碼、反碼和補碼的範圍問題</strong></p><p>值得注意的是，8位的原碼和反碼都只能表示[-127, +127]範圍內的整數，而補碼可以表示[-128, +127]範圍，多一個-128。這裡的-128是計算得到的，而不是從反碼推出的，-128根本無法用反碼錶示，卻能夠用補碼計算，比如-127+(-1) = [1000 0001]補+[1111 1111]補 = [1000 0000]補。所以我們經常背的整數取值範圍[-32768, +32767]之類的東西為什麼負數總比整數的真值大1，就是這樣來的。</p><h1>計算機中按位取反會發生什麼？</h1><p>既然計算機表示的時候用的是補碼，那麼如果對十進制的整數【按位取反】操作到底操作的是補碼還是二進制呢？</p><p><strong>實驗一下吧：</strong></p><pre>printf("%d\n", ~(3));printf("%d\n", ~(-3));</pre><p>【平臺】windows 8 64位</p><p>【IDE】vs2013 32位</p><p>【語言】C語言</p><p>【取反操作】~</p><p>【取反結果】~3 = -4，~(-3) = 2</p><p>數值比較小，最高位沒有影響，就按照8位來仔細觀察第一組數據：</p><p>3 = [0000 0011]b = [0000 0011]原 = [0000 0011]反 = [0000 0011]補</p><p>-4 = [無法表示]b = [1000 0100]原 = [1111 1011]反 = [1111 1100]補</p><p>對補碼取的反，再來看第二組：</p><p>-3 = [無法表示]b = [1000 0011]原 = [1111 1100]反 = [1111 1101]補</p><p>2 = [0000 0010]b = [0000 0010]原 = [0000 0010]反 = [0000 0010]補</p><p>可以確信100%是對補碼取的反了，純的。</p><h1>二、C語言中的整數類型的大小和範圍</h1><p>以前我們常常會去記憶[-32767, +32768]，尤其是在學pascal的時候，然而現在仔細想想，pascal都是多少年前的編程語言了，那時的電腦和現在的電腦完全不相同，記這個根本沒用。整數類型的大小和範圍和操作系統、編譯器、編程語言都息息相關，拋開運行環境談論sizeof出什麼結果的題目都是耍流氓，然而筆試題這種流氓經常存在………</p><p><strong>整數類型的範圍與表示位數</strong></p><p>用不同位數表示整數，取值的範圍就不相同，由於採用補碼，總可以多表示一個負數：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15395129503361983b9e620><p class=pgc-img-caption></p></div><p><strong>無符號unsigned</strong></p><p>無符號的時候，就可以不用擔心符號位了，也就是可以表示0~2^bit-1個數，比如：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539512950134668a3ea377><p class=pgc-img-caption></p></div><p><strong>C語言中的整數類型及其長度</strong></p><p>基本整數類型有：char、short int、int、long、long long（c99新增）。</p><p>我總是在死記長度，總以為long比int更長，但其實C語言標準是這樣規定的：</p><blockquote><p>int最少16位（2字節），long不能比int短，short不能比int長，具體位長由編譯器開發商根據各種情況自己決定。</p></blockquote><p>好一個“自己決定”……好一個“不能比”……還是通常情況吧，列個表：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539512950158cdc470bf08><p class=pgc-img-caption></p></div><p>32位表示方式中，long int和int是一樣大的！同時還反映了一個問題：64位運行的代碼不一定能在32位上運行。</p><h1>C語言數據類型名稱、輸出和編譯器的關係</h1><p><strong>g++和gcc</strong></p><p>g++把.c和.cpp程序都認為是c++程序，gcc則會用C語言的方式編譯.c，用C++的方式編譯.cpp。也就是說，如果你用C寫的程序，用g++編譯，很可能會報語法錯誤，因為g++對語法要求更嚴格，儘管C++是C語言的超集。其他的區別就是，g++能夠自動鏈接c++的庫，而gcc需要手動設置參數。</p><p><strong>gcc/g++與cl</strong></p><p>vs使用的編譯器是cl.exe，這是微軟自己開發的編譯器。CL.exe是控制 Microsoft C 和 C++ 編譯器與鏈接器的 32 位工具。cl和clang是不同的，在Visual Studio 2015已經整合了clang編譯器，但它是被用於Android和 iOS上的應用開發。</p><p><strong>整數類型不同表示方式以及輸出</strong></p><p>Visual Studio是在windows下運行的，通常支持__intxx這種寫法來定義不同位數的整數，這是gcc/g++通常不支持的（沒有實驗過）。而long long這種寫法在Visual C++ 6.0上是不支持的（沒有實驗過）。不過，在Visual Studio 2013上，全部的寫法都支持，很可靠，列個表：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15395129507801b96be1112><p class=pgc-img-caption></p></div><p>並且，所有的printf寫法都支持：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15395129501622602b43045><p class=pgc-img-caption></p></div><p><strong>做個實驗：</strong></p><p>【操作系統】windows 8 64位</p><p>【IDE】Microsoft Visual Studio 2013 32位</p><p>【編譯器】cl.exe win32</p><p>【代碼】</p><pre>long long a = 1231321313131313131;__int64 b = 1231321313131313131; printf(" type=long long\n d=%d\n ld=%ld\n lld=%lld\n I64d=%I64d\n ---\n", a,a,a,a);printf(" type=__int64\n d=%d\n ld=%ld\n lld=%lld\n I64d=%I64d\n", b,b,b,b);</pre><p>【輸出結果】</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15395129506302941e0bb1a><p class=pgc-img-caption></p></div><p>d和ld都溢出了，而lld、I64d可以工作得很好，而且對long long 和__int64沒有任何區別</p><p>整數類型越界會發生什麼？</p><p>這是一直都很好奇的事情，那就來實驗一下。</p><p>【操作系統】windows 8 64位</p><p>【IDE】Microsoft Visual Studio 2013 32位</p><p>【編譯器】cl.exe win32</p><p>【實驗結果】</p><ol><li>取值範圍unsigned short int 0~65535unsigned int 0～4294967295int -2147483648～2147483647long -2147483648 ~ 2147483647long long -9223372036854775808 ~ 9223372036854775807超上限（越來越大）會從最小值開始重新增長：unsigned short int 65536=0 | 65537= 1unsigned int 4294967296=0 | 4294967297= 1int 2147483648=-2147483648 | 2147483649 = -2147483647long 2147483648=-2147483648 | 2147483649 = -2147483647long long 9223372036854775808 = -9223372036854775808 | 9223372036854775809 = -9223372036854775807超下限（越來越小）會從最大值開始重新減小：unsigned short int -1=65535 | -2=65534unsigned int -1=4294967295 | -2=4294967294int -2147483649=2147483647 | -2147483650=2147483646long -2147483649=2147483647 | -2147483650=2147483646long long -9223372036854775809 = -9223372036854775807 | 9223372036854775810 = -9223372036854775806</li></ol><p>【探究原因】</p><p>想一下剛才的補碼，假設32位，int取最大值2147483647，打開你的計算器，選擇查看→程序員，輸入這個數字，看到它的補碼：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15395129505550e736a1848><p class=pgc-img-caption></p></div><p>[0111 1111 1111 1111 1111 1111 1111 1111]補 + [0000 0000 0000 0000 0000 0000 0000 0001]補的結果是[1000 0000 0000 0000 0000 0000 0000 0000]補 = -2147483648。</p><p>這就是為什麼越界的2147483648，打印輸出-2147483648的原因了。</p><p>【其他】</p><p>注意如果你直接進行賦值：</p><pre>int a = -2147483648;</pre><p>VS是會報錯的：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539512950542036cb9b12b><p class=pgc-img-caption></p></div><p>long long 也是如此，因此這時候應該用：</p><pre>int a = INT_MIN;long long b = LLONG_MIN;</pre><p>來表示，可以看到它們的宏定義：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539512950435e03f235f3b><p class=pgc-img-caption></p></div><p>說好的可以多表示一個負數呢，怎麼不行了呢，具體原因參考wiki《VS編寫C程序報錯error C4146: 一元負運算符應用於無符號類型，結果仍為無符號類》</p><h1>三、JAVA語言中的整數類型的大小和範圍</h1><p><strong>基本信息</strong></p><p>因為我在儘量主學Java副學Python，所以這裡也記錄一下java的整數類型。java的整數類型比較神奇，有四種基本整數類型：byte、short、int、long，但由於java的設計初衷是跨平臺運行的，Write Once and Run Anywhere，所以這幾種類型的字長都是固定的，與任何其他的32位64位都無關，列個表：</p><div class=pgc-img><img alt=簡單又複雜的“整數類型” onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1539512950635509b9fef52><p class=pgc-img-caption></p></div><p><strong>你可以自己測試一下：</strong></p><pre>System.out.println("Byte: " + Byte.SIZE/8);System.out.println("Short: " + Short.SIZE/8); System.out.println("Integer: " + Integer.SIZE/8); System.out.println("Long: " + Long.SIZE/8);</pre><p><strong>java中的unsigned類型</strong></p><p>java是幾乎沒有unsigned類型的。為什麼說幾乎呢，因為在多年的呼籲之後，最新的jdk8支持了unsigned的靜態方法調用（也就是說不支持直接寫unsigned int這種寫法，只能通過Integer.xxxx來調用），參看《Unsigned Integer Arithmetic API now in JDK 8》。真應了那句老話：真香！為什麼大家那麼希望有unsigned類型呢？因為常常需要處理圖片，而我們知道通常的圖片數據是從0變化到255的，如果有unsigned byte，那不就剛好了嘛~由於沒有unsigned，目前主流的做法是使用更大的類型比如short或者int。值得注意的是，如果要把表達0~255取值的byte轉換到short/int，要處理一下符號。因為當從0~255的short/int轉換為byte時，考慮他們的補碼，例如255：</p><p>255 = short [0000 0000 1111 1111]補 → byte [1111 1111]補 = -1</p><p>128 = short [0000 0000 1000 0000]補 → byte[1000 0000]補 = -128</p><p>0 = short [0000 0000 0000 0000]補 → byte[0000 0000]補 = 0</p><p>127 = short[0000 0000 0111 1111]補 → byte[0111 1111]補 = 127</p><p>可以看出，0~127(short)被映射到0~127（byte），而128~255則被映射到（-128~-1）了，因此在byte轉回short/int時，如果不加處理，得到的值會是-128：</p><p>-128 = byte[1000 0000]補 → short [1111 1111 1000 0000]補 = -128</p><p>處理的方法很簡單，加個掩碼0xff屏蔽掉高位的符號擴展即可，也就是將byte的值與0xff進行按位與：</p><p>-128 & 0xff = byte[1000 0000]補 & [1111 1111] → short[1111 1111 1000 0000]補 & [0000 0000 1111 1111] = [0000 0000 1000 0000]補 = 128</p><p>得到的值就正常了，用代碼實驗一下：</p><pre>short s_init = 128,s_force,s_and; byte b_force; b_force = (byte)s_init; s_force = (short)b_force; s_and = (short)(b_force &amp; 0xFF); System.out.println("初始short值= "+s_init+"\n轉為byte= "+b_force+"\nbyte轉為short= "+s_force+"\nbyte掩碼後轉為short= "+s_and);</pre><p>得到的結果是：</p><pre>初始short值= 128轉為byte= -128byte轉為short= -128byte掩碼後轉為short= 128</pre><p><strong>java中的char</strong></p><p>char類型長度2個字節，而且取值是無符號的0~65535，其他編程語言通常都是1個字節。java的char是Unicode編碼，可以存放中文字符。那麼為什麼不用它來作為unsigned int 用呢？</p><p>【原因1】輸出為字符。</p><p>java的char類型是設計為存儲unicode字符的，採用UTF-16固定寬度的編碼格式。雖然賦值的是數值88，但當調用System.out.println(a);的時候，出現的是字母X。</p><p>【原因2】運算困難。</p><pre>char a = 88;a = a + 1;</pre><p>編譯器會報錯需要char類型，而給的是int，因為當char類型運算後就是int類型了，不能直接存回char類型，需要進行強制轉換：</p><pre>a = (char)(a + 1);</pre><p>既然這麼麻煩，為何不直接用int呢？</p><p>java中整數類型越界會發生什麼？</p><p>和C語言是一樣的：當越上界，會從最小值繼續累加；當越下界，會從最大值繼續減小。原因同樣是因為補碼溢出位被丟棄，在測試的時候，不能直接賦值越界數值，否則會提示類型不匹配或者整數太大了。使用常量+1再強制轉換類型，達到越界目的。</p><pre>byte a = (byte)(Byte.MAX_VALUE+1);</pre><p>輸出結果：-128</p><p><strong>ps：碼字不易，如果你覺得有幫助的話，幫忙轉發一下吧～</strong></p><p>---------------------------------</p><p>微信公眾號：<strong>輪子工廠，機器學習 | 數據結構與算法 | 源碼分析 |　資源與工具分享</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>簡單</a></li><li><a>雜的</a></li><li><a>整數</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/86b47c3.html alt=精子簡史，最簡單也最複雜的人類繁衍過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1536051897050b19fb8c6e8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/86b47c3.html title=精子簡史，最簡單也最複雜的人類繁衍過程>精子簡史，最簡單也最複雜的人類繁衍過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e434ad.html alt=新手用雲服務器快速搭建個人網站簡單教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e434ad.html title=新手用雲服務器快速搭建個人網站簡單教程>新手用雲服務器快速搭建個人網站簡單教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/61d5b89d.html alt=場面描寫很簡單，讓語文老師舉例，教會你好用的寫作技巧和方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/a12e06c3-dac8-4ef1-a44b-bbf85671edb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/61d5b89d.html title=場面描寫很簡單，讓語文老師舉例，教會你好用的寫作技巧和方法>場面描寫很簡單，讓語文老師舉例，教會你好用的寫作技巧和方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ecbd05fe.html alt="比搶錢還要簡單！蘋果上架Mac Pro配件：四個輪子要五千塊" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5e07933580e64355abbbcac953abfc3d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ecbd05fe.html title="比搶錢還要簡單！蘋果上架Mac Pro配件：四個輪子要五千塊">比搶錢還要簡單！蘋果上架Mac Pro配件：四個輪子要五千塊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9ababaae.html alt=初中科學元素的簡單分類每日一練含答案解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cc6f0300765348b3a57404a617d32c99 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9ababaae.html title=初中科學元素的簡單分類每日一練含答案解析>初中科學元素的簡單分類每日一練含答案解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4707da0.html alt=高中化學物質分類竟如此簡單，你還記得多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b73cc7c22bc14eb9af43cf76f66e5d70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4707da0.html title=高中化學物質分類竟如此簡單，你還記得多少？>高中化學物質分類竟如此簡單，你還記得多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/054b7bd3.html alt=偽隨機整數生成在Python3中的實現，看完之後馬上變成高手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/39b4000272292206789f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/054b7bd3.html title=偽隨機整數生成在Python3中的實現，看完之後馬上變成高手>偽隨機整數生成在Python3中的實現，看完之後馬上變成高手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ec613168.html alt=十大世界足球先生，認識四位以上的人都不簡單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8bf0e55d0e30483abc88ce0fa1ac279d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ec613168.html title=十大世界足球先生，認識四位以上的人都不簡單>十大世界足球先生，認識四位以上的人都不簡單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35c96373.html alt=14種家常哨子面的做法，美味不油膩，簡單易學又實用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1ef1a62cd3ad4bf9b000021a38952cb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35c96373.html title=14種家常哨子面的做法，美味不油膩，簡單易學又實用>14種家常哨子面的做法，美味不油膩，簡單易學又實用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dacdca28.html alt=媽媽教的剪刀面做法，無保留分享，簡單又實用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e3e5ec81da04a70bf4d1fe077acb24c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dacdca28.html title=媽媽教的剪刀面做法，無保留分享，簡單又實用>媽媽教的剪刀面做法，無保留分享，簡單又實用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd7a84b7.html alt=鑑別被追尾車就是這麼簡單！這4個方法你都瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a51a16723af8485ab69705c547ea4fd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd7a84b7.html title=鑑別被追尾車就是這麼簡單！這4個方法你都瞭解嗎？>鑑別被追尾車就是這麼簡單！這4個方法你都瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a2d512e5.html alt=6個實用電路圖，簡單易懂！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d4ccc825dea840e0bccda3481c8a96ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a2d512e5.html title=6個實用電路圖，簡單易懂！>6個實用電路圖，簡單易懂！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75c082ee.html alt=一個買入和賣出股票的簡單方法——金字塔法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539052330140848b6dfdb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75c082ee.html title=一個買入和賣出股票的簡單方法——金字塔法>一個買入和賣出股票的簡單方法——金字塔法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d4099ff.html alt=經典的股票賣出技巧，簡單高效，掌握大有益處 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R6Vq6K4Fye4OrU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d4099ff.html title=經典的股票賣出技巧，簡單高效，掌握大有益處>經典的股票賣出技巧，簡單高效，掌握大有益處</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ea39ba5.html alt=股票交易指南：幾種簡單易學的股票賣出技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/8e36000b3bf0548a94ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ea39ba5.html title=股票交易指南：幾種簡單易學的股票賣出技巧>股票交易指南：幾種簡單易學的股票賣出技巧</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>