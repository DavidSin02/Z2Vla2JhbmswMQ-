<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 | 极客快訊</title><meta property="og:title" content="一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/f9d23b4550d741b8b8c0a156d712f69d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c172832.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c172832.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c172832.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c172832.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c172832.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c172832.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c172832.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c172832.html><meta property="article:published_time" content="2020-11-14T21:06:33+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:33+08:00"><meta name=Keywords content><meta name=description content="一文徹底掌握二叉查找樹，（多組動圖）史上最全總結"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6c172832.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文徹底掌握二叉查找樹，（多組動圖）史上最全總結</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>在數據結構中，二叉查找樹無疑是極為重要的，但是初學者理解起來卻由些吃力，網上的文章講得也不太全面。一本文希望結合多組動圖、圖片以及詳細的代碼實現，力爭讓大家完全掌握二叉查找樹（BST）的各種概念和操作。 相信你看完肯定會有收穫。</p><p>先看一下本文的目錄吧！每個操作都配有動圖和詳細實現代碼（Java）</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f9d23b4550d741b8b8c0a156d712f69d><p class=pgc-img-caption></p></div><p>首先，如果你對樹和二叉樹的定義不是很瞭解的話，建議先去看一下這個系列的第一篇文章一文入門二叉樹,力求對樹有一個基本的認識，再來學習!</p><h2 class=pgc-h-arrow-right>背景和必要性</h2><h3 class=pgc-h-arrow-right>背景</h3><p>現代計算機和網絡使我們能夠接觸和訪問海量的信息，所以 <strong>高效的檢索這些信息</strong> 將是一個巨大的挑戰。這包括 <strong>信息的存儲、處理和查找</strong> 。這一問題促使我們去研究 <strong>經典查找算法</strong> ，即如何高效的存儲和查找數據？</p><h3 class=pgc-h-arrow-right>目標</h3><p>實現一個 <strong>符號表</strong> ，我們將信息（鍵-值）儲存在符號表裡，根據相應的鍵去查找它所對應的值。你可以把它想象成一個字典，我們在字典中存儲了大量的詞語的釋義，我們應該能夠根據詞語（索引）去查找這個詞語對應的意思。</p><p>如下圖所示，就是一個很簡單的符號表，我們可以很輕鬆的通過鍵來查找值，但是，基於數組或者鏈表的這種數據結構並不 <strong>高效</strong> ，而且不能較好的維持一定的性質（比如我用數組存儲了很多數據，你讓我找到最大的那個，我該怎麼辦呢？先在內部排序再輸出，但是，不高效！你是不是會想有沒有一種數據結構天然就滿足這種性質？）</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8397fe90af434efb8972bdec129e51fc><p class=pgc-img-caption></p></div><p>總結一下，我們希望實現一個 <strong>高效的</strong> 符號表，它支持插入、查找、求最大鍵和最小鍵、求前驅節點（我們一會再說）和後驅節點等等，它的時間複雜度呢？我們儘量向O(logN)看齊。這就是我們今天的主角-- <strong>二叉查找樹</strong> ！</p><h2 class=pgc-h-arrow-right>二叉樹知識回顧</h2><p>首先，如果你對樹和二叉樹的定義不是很瞭解的話，建議先去看一下這個系列的第一篇文章一文入門二叉樹,力求對樹有一個基本的認識，再來學習</p><h3 class=pgc-h-arrow-right>二叉樹的定義</h3><p>直接上幾組圖，你只需要記住 <strong>每個節點至多有兩個子節點</strong> 即可。</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/08b02695767849cbaa4854b9e15b20e9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92277ab490f94e679223252eb5f9abec><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f862498131554c9ebe832f02c5dcf803><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7405528231d34ad0a5cfcd1a88730428><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b2674e821228428cb6651e67a6932386><p class=pgc-img-caption></p></div><p>這幾張圖幾乎代表了所有類型的二叉樹，你會發現，最後兩個其實就是鏈表，沒錯，二叉樹成功地退化成了鏈表，那性能上肯定會下降，但是關於這個問題如何避免卻不在本文的範圍內，這是下一期文章要解決的問題--[紅黑樹]。我們在這裡只是熟悉一下二叉樹的定義就好了。</p><h3 class=pgc-h-arrow-right>二叉樹的存儲方法</h3><p>上一篇文章我們就已經介紹過，這裡再重複一遍。二叉樹的存儲方法主要有兩種：鏈式存儲法和線性存儲法，它們分別對應著鏈表和數組。完全二叉樹最好用數組存放，因為數組下標和父子節點之間存在著完美的對應關係，而且也能夠盡最大可能的節省內存，如圖一所示。</p><p>我們把根節點儲存在下標為 i=1 的位置，那麼左子節點儲存在 2*i=2 的位置，右子節點儲存在下標為 2*i+1=2 的位置。依此類推，完成樹的存儲。藉助下標運算，我們可以很輕鬆的從父節點跳轉到左子節點和右子節點或者從任意一個子節點找到它的父節點。如果X的位置為i，則它的兩個子節點的下標分別為 2i 和 2i+1 ,它的父節點的位置為 i/2 (這裡結果向下取整)。</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dca69f16cf104fe098df90cf49cf38e0><p class=pgc-img-caption></p></div><p>相比用數組存儲數據，鏈式存儲法則相應的更加 <strong>靈活</strong> ，我們使用自定義類型 Node 來表示每一個節點。</p><pre><code>class Node{	int data;	Node left,right;}</code></pre><p>每個節點都是一個Node對象，它包含我們所需要存儲的數據，指向左子節點的引用，指向右子節點的引用，就像鏈表一樣將整個樹串起來。如果該節點沒有左子節點，則 Node.left==null 或者 Node.right==null ，如圖二所示。能理解就行，別在意它的美觀度了:)</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/405016fcb2994aebb3a1fdf70304ca1f><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>二叉樹的遍歷</h3><p>二叉樹的遍歷有三種方法：前序遍歷，中序遍歷和後序遍歷。在這裡我只講和本文我們實現二叉查找樹相關的中序遍歷，如果你希望瞭解更多，請看上一篇文章吧，那裡我給出了詳細的代碼和圖示。</p><p>所謂中序遍歷，就是指：對於樹種的 <strong>任意節點</strong> 來說， 先打印它的左子樹，然後再打印它本身，最後打印它的右子樹 。具體的代碼是用遞歸實現的，比較容易理解。</p><pre><code>public void inOrder(Node root){	if(root==null) return;	inOrder(root.left);	Systrm.out.println(root.data);	inOrder(root.right);}</code></pre><p>你可以結合下面這張圖理解一下</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/12466a4d0b734d66aa6ff16a1c0bf4fe><p class=pgc-img-caption></p></div><p>以上，我們回顧了二叉樹的基本知識，請確保你已經完全掌握。接下來我們將介紹今天的主角 二叉查找樹(Binary Search Tree),它是一種符號表，成功地將鏈表插入的靈活性和有序數組查找的高效性結合起來。聽起來是不是很完美？</p><h2 class=pgc-h-arrow-right>二叉查找樹</h2><p>一起來看一下它的定義吧，其實只是在二叉樹的定義上做了一個小小的限制：</p><h4 class=pgc-h-arrow-right>一棵二叉查找樹是一棵二叉樹，其中每個節點的鍵都大於它的左子樹上的任意節點的鍵，並且小於右子樹上任意節點的鍵。</h4><p>只要按照這個規則，我們構造出來的樹就是二叉查找樹。現在，請仔細看一下 <strong>上文所有帶數字</strong>的樹，它們都是二叉查找樹。</p><p>你可能會發現如果我們對二叉查找樹進行中序遍歷的話，得到的序列是 <strong>有序</strong> 的，這是二叉查找樹天生的靈活性。具體也可以看一下下面這幅圖：</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a1c41e6a61a4bfbac412900e5d77b3f><p class=pgc-img-caption></p></div><p>準備完熱身運動，接下來我們就正式進入二叉查找樹的講解:)。</p><ul><li>數據表示</li><li>查找數據</li><li>插入數據</li><li>查找最大值與最小值</li><li>查找前驅節點和後繼節點</li><li>查找向下取整和向上取整</li><li>刪除操作</li></ul><h3 class=pgc-h-arrow-right>數據表示</h3><p>完全等同於二叉樹的鏈式存儲法，我們定義一個節點類 Node 來表示二叉查找樹上的一個節點，每個節點含有一個鍵，一個值，一個左鏈接，一個右鏈接。其中鍵和值是為了儲存和查找，一般來說，給定鍵，我們能夠快速的找到它所對應的值。</p><pre><code>private class Node{    private int key;//鍵    private String value;//值，我這裡把數據設為String，為了和key區分開    private Node left,right;//指向子樹的鏈接    public Node(int key,String value);//Java中的構造函數}</code></pre><h3 class=pgc-h-arrow-right>查找數據</h3><p>查找操作接受一個鍵值（key），返回該鍵值對應的值（value），如果找不到就返回 null 。</p><p>大致思路是：如果樹是空的，則查找未命中，返回 null ；如果被查找的鍵和根節點的鍵相等，查找命中，返回根節點對應的值；如果被查找的鍵較小，則在左子樹中繼續查找；如果被查找的鍵較大，則在右子樹中繼續查找。我們用遞歸來實現這個操作，具體的代碼如下：</p><pre><code>public String find(int key){    return find(root,key);}private String find(Node x,int key){    //在以x為根結點的子樹中查找並返回鍵key所對應的值    //如果找不到，就返回null    if(x==null) return null;    if(key&lt;x.key) return find(x.left,key);    else if(key&gt;x.left) return find(x.right,key);    else return x.value;}// 注意這裡用了兩個方法，一個私有一個公開，私有的用來遞歸，公開的對外開放</code></pre><p>遞歸代碼的實現是很簡潔的，比較容易理解，我們來看你一下動圖：</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b7b4d77269f496e883ab77f6557c121><p class=pgc-img-caption></p></div><p>比如我們想查找 32 ,首先， 32 小於 41 ，所以對 41 的左子樹進行查找， 32 大於 20 ，再對 20 的右子樹進行查找，緊接著對它29 的右子樹查找，正好命中 32 ,如果查找不到的話就返回 null 。</p><h3 class=pgc-h-arrow-right>插入數據</h3><p>我們首先判斷根節點是不是空節點，如果是空節點，就直接創建一個新的 Node 對象作為根節點即可；</p><p>如果根節點非空，就通過 while 循環以及 p.key 和 key 的大小比較不斷向下尋找。循環結束時肯定會找到 一個空位置，這時我們就創建一個新的 Node 對象並把它接在這裡。當然還有一種情況，如果 p.key==key ,就更新這個鍵鍵對應的值，結束。</p><p>來一起看下面這個例子，向樹中插入 31 ，可以結合著實現方法一（非遞歸）理解一下：</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9268e50b27a8488d8844a547696f20de><p class=pgc-img-caption></p></div><p>實現方法一（非遞歸實現）：</p><pre><code>public void insert(int key,String value) {    //如果根節點為空節點    if (root == null) {        root = new Node(key,value);        return;    }    //根節點不是空節點    Node p = root;    while (p != null) {      if (key &gt; p.key) { //向右走        if (p.right == null) {          p.right = new Node(key,value);          return;        }        p = p.right;       }        else if { // key &lt; p.key,向左走         if (p.left == null) {           p.left = new Node(key,value);           return;         }        p = p.left;      }      else p.value=value;//如果原來樹中就含有value鍵，則更新它的值    }  }</code></pre><p>實現方法二（遞歸實現）：</p><pre><code>public void insert(int key,String value){    root=insert(root,key,value);}private Node insert(Node x,int key,String value){    //如果key存在於以x為根節點的子樹中則更新它的值；    //如果不在就創建新節點插入到合適的位置；    if(x==null) return new Node(key,value);    if(key&lt;x.key) x.left=insert(x.left,key,value);    else if(key&gt;x.key) x.right=insert(x.right,key,value);    else x.value=value;    return x;}</code></pre><p>這個遞歸的代碼儘管很簡潔，但卻不是那麼容易理解。</p><p>我先說一下寫遞歸算法需要注意的問題:</p><ul><li>1.一個問題的解可以分解為幾個子問題的解何為子問題</li><li>這個問題與分解之後的子問題，除了數據規模不同，求解思路完全一樣</li><li>3.存在遞歸終止條件</li></ul><p>PS:關鍵在於 <strong>寫出遞推公式</strong> ， <strong>找到終止條件</strong></p><p>在這裡，遞推公式就是根據條件判斷。然後將 <strong>根節點對應的樹</strong> 轉化為 <strong>規模小一點的左子樹或右子樹</strong> ，終止條件就是 <strong>遇到空鏈接</strong></p><p>如果實在繞腦子，你只需要理解第一種非遞歸的方法就行了:)。</p><h3 class=pgc-h-arrow-right>查找最大值和最小值</h3><p>這個操作應該是最簡單的了。根據二叉查找樹的定義，最小值就是最左邊的元素，直接從根節點一直向左查找即可。它也有兩種實現方式，具體的代碼如下：</p><p>實現一（遞歸實現）</p><pre><code>public int min(){    return min(root).key;}private Node min(Node x){    // 返回以x為根節點的樹的最小節點    if(x.left==null) return x;    return min(x.left);}</code></pre><p>實現二（非遞歸實現）</p><pre><code>public int min()    if(root==null) return -1; //表示不存在最小值    Node x=root;    //沿著左子樹一直深入搜索下去，直到遇到左子樹為空的節點，此時當前節 點為最小值    while(x.left !=null)        x = x.left    return x.key;}</code></pre><p>以下是動圖演示:</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2652c642fada44558c11d46d70a0dc87><p class=pgc-img-caption></p></div><p>查找最大元素的道理類似，只需把 left 換成 right 即可，在這裡就不再多說了，就當給你留的一個作業了:)。</p><h3 class=pgc-h-arrow-right>查找前驅節點和後繼節點</h3><p>前驅節點指的是 <strong>小於該鍵的最大鍵</strong> ，後繼節點指的是 <strong>大於該鍵的最小鍵</strong> 。你可以結合中序遍歷理解，通過中序遍歷，在得到的序列中位於該點左側的就是前驅節點，右側的就是後驅節點。</p><p>舉個例子,如圖所示：</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/68a6700d8f41445ca2dca3a834241c14><p class=pgc-img-caption></p></div><p>我們首先介紹以下前驅節點的性質：</p><p>1.若一個節點有左子樹，那麼該節點的前驅節點是其左子樹中最大的節點（也就是左子樹中最右邊的那個節點），示例如下：</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d252c270ad094e6ca1f0e6cdc8e0c629><p class=pgc-img-caption></p></div><p>2.若一個節點沒有左子樹，那麼判斷該節點和其父節點的關係</p><ul><li>2.1 若該節點是其父節點的右子節點，那麼該節點的前驅結點即為其父節點。 示例如下：</li></ul><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/16757d9f920d4e048560f082f2bccab6><p class=pgc-img-caption></p></div><ul><li>2.2 若該節點是其父節點的左子節點，那麼需要沿著其父親節點一直向樹的頂端尋找，直到找到一個節點P，P節點是其父節點Q的右子節點，那麼Q就是該節點的後繼節點，示例如下：</li></ul><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7dec5b60d8ce4492afae049bb498f0ae><p class=pgc-img-caption></p></div><p>以上就是尋找的思路，不過實際上我們還有一步操作，就是 <strong>找到這個給定的節點</strong> ，在這個過程中，我們同時記錄 <strong>最近</strong> 的一個向右走的節點 first_parent 。具體的代碼如下（已測試）：</p><pre><code>public int get_prenode(int key)    {        if (root==null)            return -1;//-1表示找不到給定的節點        if (root.key==key)            return -1;        Node p = root;        Node pp = null;        Node  first_parent=null;        while (p != null) {            if (key&gt;p.key) {                pp = p;                first_parent=p;                p = p.right;            } else if (key&lt;p.key) {                pp = p;                 p = p.left;            } else {                break;            }        }        if(p==null) return -1;        else if(p.left!=null) return max(p.left).key;//對應了第1種情況，如果左子樹不為空，則前驅一定是左子樹的最大值，即小於p的最大值（左子樹的值都小於p節點）        //以下是左子樹為空的情況2.1        else if(pp.right==p) return pp.key;        //以下是左子樹為空的情況2.2        else if(pp.left==p) return first_parent.key;        return -1;    }</code></pre><h3 class=pgc-h-arrow-right>向上取整和向下取整</h3><p>向上取整是指 <strong>大於等於該鍵的最小鍵</strong> ，向下取整是指 <strong>小於等於該鍵的最小值</strong> 。</p><p>向下取整與前驅後繼節點的區別在於 查找前驅後繼節點對應的參數是樹中的某一個節點鍵，而向下取整則允許接受任意的鍵作為參數，另一方面，向下取整可以包含等於自己的鍵，是小於等於</p><p>關於向上取整與向下取整這兩個操作，我只在 算法(第四版) 上面見到過，在其他的相關文章中沒有遇到，不過我感覺咱們可以體會一下它的思想，畢竟我感覺這個操作也蠻重要的。</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cbc3a0738247494d8817f035c884b975><p class=pgc-img-caption></p></div><p>我們拿上圖中查找 19 前驅節點為例說明一下流程：首先，在以 41 為根節點的樹中查詢，由於 19&lt;41 ,在 41 的左子樹查詢，即在以 20 為根節點的樹中查詢。接著因為 19&lt;20 ,繼續向左，在以 11 為根結點的樹中查詢。 <strong>集中注意力</strong> ，因為 19>11 ,所以 11 有可能是19的前驅節點，但是前提是 11 的右子樹中沒有比較19 小的元素。也就是說 我們應該先在11的右子樹中尋找，然後判斷尋找的情況（命中或未命中），如果命中，那就自動返回結果了，如果沒有命中，則說明 11就是 19 的前驅節點! ，這其中查找的過程是一個遞歸的過程！希望你仔細體會:)</p><p>我只能說到這裡了，不好理解:(。具體實現如下：</p><pre><code>public int floor(int key){    Node x=floor(root,key);    if(x==null) return -1;//未查找到    return x.key;}private Node floor(Node x,int key){    if(x==null) return null;//表示在以x為根節點的樹中沒有查找到    if(key=x.key) return x;//命中，且恰好在根節點x    if(key&lt;x.key) return floor(x.left,key);//在x的左子樹中查詢，根節點有x變為x的子節點，數據規模減小    //往下走說明key&gt;x.key,這個時候要去x的右子樹去尋找    Node  t=floor(x.right,key);//在右子樹中尋找    if(t!=null) return t;//在右子樹中找到了    else return x;//在右子樹中沒有找到，那就說明x節點就是要求的前驅節點}</code></pre><p>向上取整的代碼類似，我這裡就不詳細說了，你可以自己實現一下。</p><h3 class=pgc-h-arrow-right>刪除操作</h3><p>二叉樹的刪除操作就相對比較複雜了。希望你打起十二分的精神！刪除一個結點只會對一顆二叉查找樹的局部產生一定的影響，所以，我們的任務就是恢復刪除這個結點所帶來的影響。</p><p>刪除操作也有遞歸算法，不過我很迷，而且我見很多地方也不是用遞歸實現的，所以這裡就不再介紹了，感興趣的話可以看一下 <strong>算法（第四版）</strong> ，上面有詳細的介紹。好了，不囉嗦了，咱們繼續~</p><p>針對待刪除結點的子節點個數的不同，我們將它分為三種情況加以處理。</p><p>1.如果要刪除的節點沒有子節點，此時的操作時十分容易的，我們只需要將父節點中指向該節點的鏈接設置為 null 就可以了。請看下圖,我們的任務是刪除結點 27 ,找到這個節點後直接抹去就 OK 了。</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8fd9cda6a63e4261a17a1fa42f763a62><p class=pgc-img-caption></p></div><p>2.如果要刪除的節點只有一個子節點(只有左子節點或只有右子節點)，這種情況也不復雜。我們只需要更新父節點中的指向待刪除結點的鏈接即可，讓它指向待刪除結點的子節點即可。請看下圖，我們的目標是刪除節點 50 :</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2f702db7bb264f10a7ce326d7cb3759e><p class=pgc-img-caption></p></div><p>3.如果要刪除的節點有兩個子節點，這時就變得複雜了。你聽我仔細描述以下這個過程： 我們需要找到這個節點的右子樹上的最小結點【記為H】（因為它沒有左子節點），把【H】替換到我們計劃刪除的節點上；然後，再刪除這個最小的節點【H】（因為它沒有左子節點，所以可以轉化成之前的兩種情況之一） ，而且，你會發現，二叉查找樹的性質被完美的保留了下來，驚不驚喜！</p><p>接下來請看下面這三個例子，它們分別能夠轉化為情況一和情況二：</p><p>第一幅圖，想要刪除節點 20 ,它的右子樹的最小節點【H】 <strong>沒有子節點</strong></p><p>第二幅圖，想要刪除節點 20 ,它的右子樹的最小節點【H】 <strong>存在右節點</strong></p><p>注意：【H】不可能有左節點，因為它是最小的</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f1aab225f4414795884e9178ebfb8e27><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0b17587edddd4b018bbceae32f38ec32><p class=pgc-img-caption></p></div><p>具體的代碼如下:</p><pre><code>public void delete(int key){        //如果找到鍵為key的結點，就將它刪除，找不到不做處理        Node p=root;//p指向需要刪除的結點，這裡初始化為根節點        Node pp=null;//pp記錄的是p的父節點                //通過while循環查找Key結點        while(p!=null&amp;&amp;p.key!=Key){            pp=p;            if(Key&gt;p.Key) p=p.right;            else p=p.left;        }        if(p==null) return;//沒有找到        //情況一：要刪除的結點有兩個子結點        if(p.left!=null&amp;&amp;p.right!=null){            //查找右子樹的最小結點            Node minP=p.right;//minP是右子樹的最小結點            Node minPP=p;//minPP表示minP的父結點            while(minP.left!=null){                minPP=minP;                minP=minP.left;            }            p.Key=minP.Key;p.val=minP.val;//替換p（將被刪除的結點）的鍵和值                        //轉化，以下問題只需要將minP刪除即可            //因為minP作為右子樹最小的結點，肯定沒有左子結點，可以轉化為情況二處理            p=minP;//使p指向右子樹的最小結點            pp=minPP;//使被刪除結點的父結點指向右子樹最小結點的父結點                    }        //情況二：待刪除結點是葉子結點（即沒有子結點）或者僅有一個子結點        Node child;//p的子結點        if(p.left!=null) child=p.left;        else if(p.right!=null) child=p.right;        else child=null;        //執行刪除操作        if(pp==null) root=child;//刪除的是根結點        else if(pp.left==p) pp.left=child;        else pp.right=child;    }</code></pre><p>可以再根據下面這幅圖理解一下:)</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dce102128896442fbe4a741cc6ae84be><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>理論分析</h2><p>我們前面用了那麼大的力氣來講解二叉查找樹，那麼它的性能怎麼樣呢？</p><p>其實，對於二叉查找樹來說，不管是插入、刪除還是查找操作，時間複雜度都和樹的高度成正比，也就是 O(H) ，因為每次操作都對應了一條 <strong>從根節點向下的一條路徑</strong> 。而對於樹的高度，卻很可能因樹的形狀的不同而不同。</p><p>理想情況下，二叉查找樹是一顆完全二叉樹，每層的節點依次為 <strong>1、2、4、8、16…………</strong> ，不難發現，樹的高度為 log(N) ,所以時間複雜度為 O(logN) ,這是一個相當高效的算法了。下面是一張表格，對常見的符號表的耗時成本做了一個簡單的對比。</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90181141ad6741f28aa115b81709f979><p class=pgc-img-caption></p></div><p>據此可見二叉查找樹的性能，它能夠在 O(logN) 的時間複雜度內完成查找和插入操作，我們花這麼大力氣學習它是值得的！</p><p>但是，你有沒有注意到，它的最壞情況依舊是 O(logN) 。二叉查找樹在一定條件下可能會退化成鏈表，就像下圖所示，這明明就是一個彎曲的鏈表！</p><div class=pgc-img><img alt=一文徹底掌握二叉查找樹，（多組動圖）史上最全總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/18d99647c81a4d3189f3542b95bbf9de><p class=pgc-img-caption></p></div><p>我們希望找到一種數據結構，它能保證 <strong>無論鍵的插入順序如何，樹的高度將總是總鍵數的對數</strong>，這就是 <strong>平衡二叉查找樹</strong> ，更精確一點，我們在下一篇文章中介紹 <strong>紅黑樹</strong> ！（預告一下）</p><p>好了，今天的內容就到這裡了，希望你能夠對二叉查找樹有一個更深的理解，另外，記得一定要動手敲代碼！ <strong>咱們下期見紅黑樹。</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>徹底</a></li><li><a>組動圖</a></li><li><a>總結</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html alt=從域名到網站，只需要四步！服務器網站搭建流程總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7c1999b5072844f6ac01ba234e4d4ee0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html title=從域名到網站，只需要四步！服務器網站搭建流程總結>從域名到網站，只需要四步！服務器網站搭建流程總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html alt=住宅工程各區域的淨高要求，總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/072079da-ec32-43b6-9dff-93cc7beb2bc3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html title=住宅工程各區域的淨高要求，總結>住宅工程各區域的淨高要求，總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html alt=住宅工程各區域的淨高要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/27a44170db2040adab26236e40605b1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html title=住宅工程各區域的淨高要求，總結！>住宅工程各區域的淨高要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html alt=住宅工程各類淨高的規範要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cff80b0991246f69fb67d91590b1d95 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html title=住宅工程各類淨高的規範要求，總結！>住宅工程各類淨高的規範要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html alt=初三主要化學方程式按元素歸類總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fcca062886ed4b9db272cb3cb66710e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html title=初三主要化學方程式按元素歸類總結>初三主要化學方程式按元素歸類總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html alt=按照元素分類總結的高中化學方程式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/568b4c62f05c406c86ba3a1a3f1536f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html title=按照元素分類總結的高中化學方程式>按照元素分類總結的高中化學方程式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2e1ceb0.html alt="縱橫談｜徹底清除基層治理中的'灰色手段'" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2e1ceb0.html title="縱橫談｜徹底清除基層治理中的'灰色手段'">縱橫談｜徹底清除基層治理中的'灰色手段'</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d1995c0.html alt=丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/164632567d364099b1944122af1964e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d1995c0.html title=丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級>丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd423c48.html alt=口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明…… class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rw0qyU6Ao0YcN0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd423c48.html title=口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明……>口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明……</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4a687640.html alt=寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4a687640.html title=寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動>寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96e7d436.html alt="這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96e7d436.html title="這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏">這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02f4a700.html alt=牛人總結的開關電源電路圖，必須收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rw0LHkF478R1Ah style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02f4a700.html title=牛人總結的開關電源電路圖，必須收藏>牛人總結的開關電源電路圖，必須收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2dce1f09.html alt=高考地理知識點總結―地球的自轉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0453497a2cd041369b4075543c4d3795 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2dce1f09.html title=高考地理知識點總結―地球的自轉>高考地理知識點總結―地球的自轉</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>