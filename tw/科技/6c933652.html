<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ | 极客快訊</title><meta property="og:title" content="阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/305b744c-4e26-4f9a-8ab5-bed383199d42"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c933652.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c933652.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c933652.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c933652.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c933652.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c933652.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c933652.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c933652.html><meta property="article:published_time" content="2020-10-29T21:12:40+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:40+08:00"><meta name=Keywords content><meta name=description content="阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6c933652.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/305b744c-4e26-4f9a-8ab5-bed383199d42><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>1.BIO、NIO 和 AIO 的區別？</h1><p><strong>BIO：</strong>一個連接一個線程，客戶端有連接請求時服務器端就需要啟動一個線程進行處理。線程開銷大。</p><p><strong>偽異步 IO：</strong>將請求連接放入線程池，一對多，但線程還是很寶貴的資源。</p><p><strong>NIO：</strong>一個請求一個線程，但客戶端發送的連接請求都會註冊到多路複用器上，多路複用器輪詢到連接有 I/O 請求時才啟動一個線程進行處理。</p><p><strong>AIO：</strong>一個有效請求一個線程，客戶端的 I/O 請求都是由 OS 先完成了再通知服務器應用去啟動線程進行處理，BIO 是面向流的，NIO 是面向緩衝區的；BIO 的各種流是阻塞的。而 NIO 是非阻塞的；BIO的 Stream 是單向的，而 NIO 的 channel 是雙向的。</p><p><strong>NIO 的特點：</strong></p><p>事件驅動模型、單線程處理多任務、非阻塞 I/O，I/O 讀寫不再阻塞，而是返回 0、基於 block 的傳輸比基於流的傳輸更高效、更高級的 IO 函數 zero-copy、IO 多路複用大大提高了 Java 網絡應用的可伸縮性和實用性。基於 Reactor 線程模型。在 Reactor 模式中，事件分發器等待某個事件或者可應用或個操作的狀態發生，事件分發器就把這個事件傳給事先註冊的事件處理函數或者回調函數，由後者來做實際的讀寫操作。如在 Reactor 中實現讀：註冊讀就緒事件和相應的事件處理器、事件分發器等待事件、事件到來，激活分發器，分發器調用事件對應的處理器、事件處理器完成實際的讀操作，處理讀到的數據，註冊新的事件，然後返還控制權。</p><h1 class=pgc-h-arrow-right>2.NIO 的組成？</h1><p><strong>Buffer：</strong>與 Channel 進行交互，數據是從 Channel 讀入緩衝區，從緩衝區寫入 Channel 中的flip 方法 ： 反轉此緩衝區，將 position 給 limit，然後將 position 置為 0，其實就是切換讀寫模式</p><p><strong>clear 方法 ：</strong>清除此緩衝區，將 position 置為 0，把 capacity 的值給 limit。</p><p><strong>rewind 方法 ：</strong> 重繞此緩衝區，將 position 置為 0</p><p>DirectByteBuffer 可減少一次系統空間到用戶空間的拷貝。但 Buffer 創建和銷燬的成本更高，不可控，通常會用內存池來提高性能。直接緩衝區主要分配給那些易受基礎系統的本機 I/O 操作影響的大型、持久的緩衝區。如果數據量比較小的中小應用情況下，可以考慮使用 heapBuffer，由 JVM 進行管理。</p><p><strong>Channel：</strong>表示 IO 源與目標打開的連接，是雙向的，但不能直接訪問數據，只能與 Buffer進行交互。通過源碼可知，FileChannel 的 read 方法和 write 方法都導致數據複製了兩次！</p><p>Selector 可使一個單獨的線程管理多個 Channel，open 方法可創建 Selector，register 方法向多路複用器器註冊通道，可以監聽的事件類型：讀、寫、連接、accept。</p><p>註冊事件後會產生一個 SelectionKey：它表示 SelectableChannel 和 Selector 之間的註冊關係，</p><p><strong>wakeup 方法：</strong>使尚未返回的第一個選擇操作立即返回，</p><p><strong>喚醒的原因是：</strong>註冊了新的 channel 或者事件；channel 關閉，取消註冊；優先級更高的事件觸發（如定時器事件），希望及時處理。</p><p>Selector 在 Linux 的實現類是 EPollSelectorImpl，委託給 EPollArrayWrapper 實現，其中三個native 方法是對 epoll 的封裝，而 EPollSelectorImpl. implRegister 方法，通過調用 epoll_ctl向 epoll 實例中註冊事件，還將註冊的文件描述符(fd)與 SelectionKey 的對應關係添加到fdToKey 中，這個 map 維護了文件描述符與 SelectionKey 的映射。</p><p>fdToKey 有時會變得非常大，因為註冊到 Selector 上的 Channel 非常多（百萬連接）；過期或失效的 Channel 沒有及時關閉。fdToKey 總是串行讀取的，而讀取是在 select 方法中進行的，該方法是非線程安全的。</p><p><strong>Pipe：</strong>兩個線程之間的單向數據連接，數據會被寫到 sink 通道，從 source 通道讀取NIO 的服務端建立過程：Selector.open()：打開一個 Selector；</p><p><strong>ServerSocketChannel.open()：</strong>創建服務端的 Channel；</p><p><strong>bind()：</strong>綁定到某個端口上。並配置非阻塞模式；</p><p><strong>register()：</strong>註冊Channel 和關注的事件到 Selector 上；select()輪詢拿到已經就緒的事件</p><p><br></p><div class=pgc-img><img alt=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/dc254511-c173-4f94-97fd-3d52e4c1b2f4><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>3.Netty 的特點？</h1><p>一個高性能、異步事件驅動的 NIO 框架，它提供了對 TCP、UDP 和文件傳輸的支持使用更高效的 socket 底層，對 epoll 空輪詢引起的 cpu 佔用飆升在內部進行了處理，避免了直接使用 NIO 的陷阱，簡化了 NIO 的處理方式。</p><p>採用多種 decoder/encoder 支持，對 TCP 粘包/分包進行自動化處理可使用接受/處理線程池，提高連接效率，對重連、心跳檢測的簡單支持</p><p>可配置 IO 線程數、TCP 參數， TCP 接收和發送緩衝區使用直接內存代替堆內存，通過內存池的方式循環利用 ByteBuf</p><p>通過引用計數器及時申請釋放不再引用的對象，降低了 GC 頻率使用單線程串行化的方式，高效的 Reactor 線程模型大量使用了 volitale、使用了 CAS 和原子類、線程安全類的使用、讀寫鎖的使用</p><h1 class=pgc-h-arrow-right>4.Netty 的線程模型？</h1><p>Netty 通過 Reactor 模型基於多路複用器接收並處理用戶請求，內部實現了兩個線程池，boss 線程池和 work 線程池，其中 boss 線程池的線程負責處理請求的 accept 事件，當接收到 accept 事件的請求時，把對應的 socket 封裝到一個 NioSocketChannel 中，並交給 work線程池，其中 work 線程池負責請求的 read 和 write 事件，由對應的 Handler 處理。</p><p><strong>單線程模型：</strong>所有 I/O 操作都由一個線程完成，即多路複用、事件分發和處理都是在一個Reactor 線程上完成的。既要接收客戶端的連接請求,向服務端發起連接，又要發送/讀取請求或應答/響應消息。一個 NIO 線程同時處理成百上千的鏈路，性能上無法支撐，速度慢，若線程進入死循環，整個程序不可用，對於高負載、大併發的應用場景不合適。</p><p><strong>多線程模型：</strong>有一個 NIO 線程（Acceptor） 只負責監聽服務端，接收客戶端的 TCP 連接請求；NIO 線程池負責網絡 IO 的操作，即消息的讀取、解碼、編碼和發送；1 個 NIO 線程可以同時處理 N 條鏈路，但是 1 個鏈路只對應 1 個 NIO 線程，這是為了防止發生併發操作問題。但在併發百萬客戶端連接或需要安全認證時，一個 Acceptor 線程可能會存在性能不足問題。</p><p><strong>主從多線程模型：</strong>Acceptor 線程用於綁定監聽端口，接收客戶端連接，將 SocketChannel從主線程池的 Reactor 線程的多路複用器上移除，重新註冊到 Sub 線程池的線程上，用於處理 I/O 的讀寫等操作，從而保證 mainReactor 只負責接入認證、握手等操作；</p><h1 class=pgc-h-arrow-right>5.TCP 粘包/拆包的原因及解決方法？</h1><p>TCP 是以流的方式來處理數據，一個完整的包可能會被 TCP 拆分成多個包進行發送，也可能把小的封裝成一個大的數據包發送。</p><p>TCP 粘包/分包的原因：</p><p>應用程序寫入的字節大小大於套接字發送緩衝區的大小，會發生拆包現象，而應用程序寫入數據小於套接字緩衝區大小，網卡將應用多次寫入的數據發送到網絡上，這將會發生粘包現象；進行 MSS 大小的 TCP 分段，當 TCP 報文長度-TCP 頭部長度>MSS 的時候將發生拆包，以太網幀的 payload（淨荷）大於 MTU（1500 字節）進行 ip 分片。</p><p><strong>解決方法</strong></p><p>消息定長：FixedLengthFrameDecoder 類包尾增加特殊字符分割：行分隔符類：LineBasedFrameDecoder 或自定義分隔符類 ：DelimiterBasedFrameDecoder將消息分為消息頭和消息體：LengthFieldBasedFrameDecoder 類。分為有頭部的拆包與粘包、長度字段在前且有頭部的拆包與粘包、多擴展頭部的拆包與粘包。</p><h1 class=pgc-h-arrow-right>6.瞭解哪幾種序列化協議？</h1><p>序列化（編碼）是將對象序列化為二進制形式（字節數組），主要用於網絡傳輸、數據持久化等；而反序列化（解碼）則是將從網絡、磁盤等讀取的字節數組還原成原始對象，主要用於網絡傳輸對象的解碼，以便完成遠程調用。</p><p><strong>影響序列化性能的關鍵因素：</strong>序列化後的碼流大小（網絡帶寬的佔用）、序列化的性能（CPU 資源佔用）；是否支持跨語言（異構系統的對接和開發語言切換）。</p><p><strong>Java 默認提供的序列化：</strong>無法跨語言、序列化後的碼流太大、序列化的性能差XML，優點：人機可讀性好，可指定元素或特性的名稱。缺點：序列化數據只包含數據本身以及類的結構，不包括類型標識和程序集信息；只能序列化公共屬性和字段；不能序列化方法；文件龐大，文件格式複雜，傳輸佔帶寬。適用場景：當做配置文件存儲數據，實時數據轉換。</p><p><strong>JSON</strong>是一種輕量級的數據交換格式，</p><p><strong>優點：</strong>兼容性高、數據格式比較簡單，易於讀寫、序列化後數據較小，可擴展性好，兼容性好、與 XML 相比，其協議比較簡單，解析速度比較快。</p><p><strong>缺點：</strong>數據的描述性比 XML 差、不適合性能要求為 ms 級別的情況、額外空間開銷比較大。適用場景（可替代ＸＭＬ）：跨防火牆訪問、可調式性要求高、基於 Web browser 的 Ajax 請求、傳輸數據量相對小，實時性要求相對低（例如秒級別）的服務。</p><p><strong>Fastjson</strong>，採用一種“假定有序快速匹配”的算法。</p><p><strong>優點：</strong>接口簡單易用、目前 java 語言中最快的 json 庫。</p><p><strong>缺點：</strong>過於注重快，而偏離了“標準”及功能性、代碼質量不高，文檔不全。</p><p>適用場景：協議交互、Web 輸出、Android 客戶端</p><p><strong>Thrift</strong>，不僅是序列化協議，還是一個 RPC 框架。</p><p><strong>優點：</strong>序列化後的體積小, 速度快、支持多種語言和豐富的數據類型、對於數據字段的增刪具有較強的兼容性、支持二進制壓縮編碼。</p><p><strong>缺點：</strong>使用者較少、跨防火牆訪問時，不安全、不具有可讀性，調試代碼時相對困難、不能與其他傳輸層協議共同使用（例如 HTTP）、無法支持向持久層直接讀寫數據，即不適合做數據持久化序列化協議。</p><p>適用場景：分佈式系統的 RPC 解決方案 Avro，Hadoop 的一個子項目，解決了 JSON 的冗長和沒有 IDL 的問題。</p><p><strong>優點：</strong>支持豐富的數據類型、簡單的動態語言結合功能、具有自我描述屬性、提高了數據解析速度、快速可壓縮的二進制數據形式、可以實現遠程過程調用 RPC、支持跨編程語言實現。</p><p><strong>缺點：</strong>對於習慣於靜態類型語言的用戶不直觀。</p><p>適用場景：在 Hadoop 中做 Hive、Pig 和 MapReduce的持久化數據格式。</p><p><strong>Protobuf</strong></p><p>將數據結構以.proto 文件進行描述，通過代碼生成工具可以生成對應數據結構的POJO 對象和 Protobuf 相關的方法和屬性。</p><p><strong>優點：</strong>序列化後碼流小，性能高、結構化數據存儲格式（XML JSON 等）、通過標識字段的順序，可以實現協議的前向兼容、結構化的文檔更容易管理和維護。</p><p><strong>缺點：</strong>需要依賴於工具生成代碼、支持的語言相對較少，官方只支持Java 、C++ 、python。</p><p>適用場景：對性能要求高的 RPC 調用、具有良好的跨防火牆的訪問屬性、適合應用層對象的持久化</p><p><strong>其它</strong></p><p>protostuff 基於 protobuf 協議，但不需要配置 proto 文件，直接導包即可</p><p>Jboss marshaling 可以直接序列化 java 類， 無須實 java.io.Serializable 接口</p><p>Message pack 一個高效的二進制序列化格式</p><p>Hessian 採用二進制協議的輕量級 remoting onhttp 工具</p><p>kryo 基於 protobuf 協議，只支持 java 語言,需要註冊（Registration），然後序列化（Output），反序列化（Input）</p><p><br></p><div class=pgc-img><img alt=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/5a35affa-9dd8-4a66-a315-21f22aa4f82a><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>7.如何選擇序列化協議？</h1><p>具體場景:對於公司間的系統調用，如果性能要求在 100ms 以上的服務，基於 XML 的 SOAP 協議是一個值得考慮的方案。</p><p>基於 Web browser 的 Ajax，以及 Mobile app 與服務端之間的通訊，JSON 協議是首選。</p><p>對於性能要求不太高，或者以動態類型語言為主，或者傳輸數據載荷很小的的運用場景，JSON也是非常不錯的選擇。</p><p>對於調試環境比較惡劣的場景，採用 JSON 或 XML 能夠極大的提高調試效率，降低系統開發成本。</p><p>當對性能和簡潔性有極高要求的場景，Protobuf，Thrift，Avro 之間具有一定的競爭關係。</p><p>對於 T 級別的數據的持久化應用場景，Protobuf 和 Avro 是首要選擇。如果持久化後的數據存儲在 hadoop 子項目裡，Avro 會是更好的選擇。</p><p>對於持久層非 Hadoop 項目，以靜態類型語言為主的應用場景，Protobuf 會更符合靜態類型語言工程師的開發習慣。由於 Avro 的設計理念偏向於動態類型語言，對於動態語言為主的應用場景，Avro 是更好的選擇。</p><p>如果需要提供一個完整的 RPC 解決方案，Thrift 是一個好的選擇。</p><p>如果序列化之後需要支持不同的傳輸層協議，或者需要跨防火牆訪問的高性能場景，Protobuf 可以優先考慮。</p><p>protobuf 的數據類型有多種：bool、double、float、int32、int64、string、bytes、enum、message。</p><p>protobuf 的限定符：required: 必須賦值，不能為空、optional:字段可以賦值，也可以不賦值、repeated: 該字段可以重複任意次數（包括 0 次）、枚舉；只能用指定的常量集中的一個值作為其值；</p><p>protobuf 的基本規則：每個消息中必須至少留有一個 required 類型的字段、包含 0 個或多個 optional 類型的字段；repeated 表示的字段可以包含 0 個或多個數據；[1,15]之內的標識號在編碼的時候會佔用一個字節（常用），[16,2047]之內的標識號則佔用 2 個字節，標識號</p><p>一定不能重複、使用消息類型，也可以將消息嵌套任意多層，可用嵌套消息類型來代替組。</p><p>protobuf 的消息升級原則：不要更改任何已有的字段的數值標識；不能移除已經存在的required 字段，optional 和 repeated 類型的字段可以被移除，但要保留標號不能被重用。</p><p>新添加的字段必須是 optional 或 repeated。因為舊版本程序無法讀取或寫入新增的required 限定符的字段。</p><p>編譯器為每一個消息類型生成了一個.java 文件，以及一個特殊的 Builder 類（該類是用來創建消息類接口的）。如：UserProto.User.Builder builder =UserProto.User.newBuilder();builder.build()；</p><p>Netty 中的使用：ProtobufVarint32FrameDecoder 是用於處理半包消息的解碼類；</p><p>ProtobufDecoder(UserProto.User.getDefaultInstance())這是創建的 UserProto.java 文件中的解碼類；ProtobufVarint32LengthFieldPrepender 對 protobuf 協議的消息頭上加上一個長度為32 的整形字段，用於標誌這個消息的長度的類；ProtobufEncoder 是編碼類將 StringBuilder 轉換為 ByteBuf 類型：copiedBuffer()方法</p><h1 class=pgc-h-arrow-right>8.Netty 的零拷貝實現？</h1><p>加粗樣式Netty 的接收和發送 ByteBuffer 採用 DIRECT BUFFERS，使用堆外直接內存進行 Socket 讀寫，不需要進行字節緩衝區的二次拷貝。堆內存多了一次內存拷貝，JVM 會將堆內存Buffer 拷貝一份到直接內存中，然後才寫入 Socket 中。ByteBuffer 由 ChannelConfig 分配，</p><p>而 ChannelConfig 創建 ByteBufAllocator 默認使用 Direct BufferCompositeByteBuf 類可以將多個 ByteBuf 合併為一個邏輯上的 ByteBuf, 避免了傳統通過內存拷貝的方式將幾個小 Buffer 合併成一個大的 Buffer。addComponents 方法將 header與 body 合併為一個邏輯上的 ByteBuf, 這兩個 ByteBuf 在 CompositeByteBuf 內部都是單獨存在的, CompositeByteBuf 只是邏輯上是一個整體</p><p>通過 FileRegion 包裝的 FileChannel.tranferTo 方法 實現文件傳輸, 可以直接將文件緩衝區的數據發送到目標 Channel，避免了傳統通過循環 write 方式導致的內存拷貝問題。</p><p>通過 wrap 方法, 我們可以將 byte[] 數組、ByteBuf、ByteBuffer 等包裝成一個 NettyByteBuf 對象, 進而避免了拷貝操作。</p><p>Selector BUG：若 Selector 的輪詢結果為空，也沒有 wakeup 或新消息處理，則發生空輪詢，CPU 使用率 100%，</p><p><strong>Netty 的解決辦法：</strong></p><p>對 Selector 的 select 操作週期進行統計，每完成一次空的 select 操作進行一次計數，若在某個週期內連續發生 N 次空輪詢，則觸發了 epoll 死循環 bug。重建Selector，判斷是否是其他線程發起的重建請求，若不是則將原 SocketChannel 從舊的Selector 上去除註冊，重新註冊到新的 Selector 上，並將原來的 Selector 關閉。</p><h1 class=pgc-h-arrow-right>9.Netty 的高性能表現在哪些方面？</h1><p>心跳，對服務端：會定時清除閒置會話 inactive(netty5)，</p><p>對客戶端:用來檢測會話是否斷開，是否重來，檢測網絡延遲，其中 idleStateHandler 類 用來檢測會話狀態串行無鎖化設計，即消息的處理儘可能在同一個線程內完成，期間不進行線程切換，這樣就避免了多線程競爭和同步鎖。表面上看，串行化設計似乎 CPU 利用率不高，併發程度不夠。但是，通過調整 NIO 線程池的線程參數，可以同時啟動多個串行化的線程並行運行，這種局部無鎖化的串行線程設計相比一個隊列-多個工作線程模型性能更優。可靠性，</p><p><strong>鏈路有效性檢測：</strong>鏈路空閒檢測機制，讀/寫空閒超時機制；</p><p><strong>內存保護機制：</strong>通過內存池重用 ByteBuf;ByteBuf 的解碼保護；</p><p><strong>優雅停機：</strong>不再接收新消息、退出前的預處理操作、資源的釋放操作。</p><p><strong>Netty 安全性：</strong>支持的安全協議：SSL V2 和 V3，TLS，SSL 單向認證、雙向認證和第三方 CA認證。</p><p><strong>高效併發編程的體現：</strong>volatile 的大量、正確使用；CAS 和原子類的廣泛使用；線程安全容器的使用；通過讀寫鎖提升併發性能。IO 通信性能三原則：傳輸（AIO）、協議（Http）、線程（主從多線程）</p><p><strong>流量整型的作用（變壓器）：</strong>防止由於上下游網元性能不均衡導致下游網元被壓垮，業務流中斷；</p><p>防止由於通信模塊接受消息過快，後端業務線程處理不及時導致撐死問題。</p><p><strong>TCP 參數配置：</strong>SO_RCVBUF 和 SO_SNDBUF：通常建議值為 128K 或者 256K；</p><p>SO_TCPNODELAY：NAGLE 算法通過將緩衝區內的小封包自動相連，組成較大的封包，阻止大量小封包的發送阻塞網絡，從而提高網絡應用效率。但是對於時延敏感的應用場景需要關閉該優化算法；</p><p><br></p><div class=pgc-img><img alt=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/f7bf0a41-7fa1-478d-a8f6-0175fb74312b><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>10.NIOEventLoopGroup 源碼？</h1><p>NioEventLoopGroup(其實是 MultithreadEventExecutorGroup) 內部維護一個類型為EventExecutor children [], 默認大小是處理器核數 * 2,這樣就構成了一個線程池，初始化EventExecutor 時 NioEventLoopGroup 重載 newChild 方法，所以 children 元素的實際類型為NioEventLoop。</p><p>線程啟動時調用 SingleThreadEventExecutor 的構造方法，執行 NioEventLoop 類的 run 方法，</p><p>首先會調用 hasTasks()方法判斷當前 taskQueue 是否有元素。</p><p>如果 taskQueue 中有元素，執行 selectNow() 方法，最終執行 selector.selectNow()，該方法會立即返回。</p><p>如果taskQueue 沒有元素，執行 select(oldWakenUp) 方法select ( oldWakenUp) 方法解決了 Nio 中的 bug，selectCnt 用來記錄 selector.select 方法的執行次數和標識是否執行過 selector.selectNow()，若觸發了 epoll 的空輪詢 bug，則會反覆執行 selector.select(timeoutMillis)，變量 selectCnt 會逐漸變大，當 selectCnt 達到閾值（默認 512），則執行 rebuildSelector 方法，進行 selector 重建，解決 cpu 佔用 100%的 bug。</p><p>rebuildSelector 方法先通過 openSelector 方法創建一個新的 selector。然後將 old selector 的selectionKey 執行 cancel。最後將 old selector 的 channel 重新註冊到新的 selector 中。rebuild 後，需要重新執行方法 selectNow，檢查是否有已 ready 的 selectionKey。</p><p>接下來調用 processSelectedKeys 方法（處理 I/O 任務），當 selectedKeys != null 時，調用processSelectedKeysOptimized 方法，迭代 selectedKeys 獲取就緒的 IO 事件的 selectkey 存放在數組 selectedKeys 中, 然後為每個事件都調用 processSelectedKey 來處理它，processSelectedKey 中分別處理 OP_READ；OP_WRITE；OP_CONNECT 事件。</p><p>最後調用 runAllTasks 方法（非 IO 任務），該方法首先會調用 fetchFromScheduledTaskQueue方法，把 scheduledTaskQueue 中已經超過延遲執行時間的任務移到 taskQueue 中等待被執行，然後依次從 taskQueue 中取任務執行，每執行 64 個任務，進行耗時檢查，如果已執行時間超過預先設定的執行時間，則停止執行非 IO 任務，避免非 IO 任務太多，影響 IO 任務的執行。</p><p>每個 NioEventLoop 對應一個線程和一個 Selector，NioServerSocketChannel 會主動註冊到某一個 NioEventLoop 的 Selector 上，NioEventLoop 負責事件輪詢。Outbound 事件都是請求事件, 發起者是 Channel，處理者是 unsafe，通過 Outbound 事件進行通知，傳播方向是 tail 到 head。Inbound 事件發起者是 unsafe，事件的處理者是Channel, 是通知事件，傳播方向是從頭到尾。</p><p>內存管理機制，首先會預申請一大塊內存 Arena，Arena 由許多 Chunk 組成，而每個 Chunk默認由 2048 個 page 組成。Chunk 通過 AVL 樹的形式組織 Page，每個葉子節點表示一個Page，而中間節點表示內存區域，節點自己記錄它在整個 Arena 中的偏移地址。當區域被分配出去後，中間節點上的標記位會被標記，這樣就表示這個中間節點以下的所有節點都已被分配了。大於 8k 的內存分配在 poolChunkList 中，而 PoolSubpage 用於分配小於 8k 的內存，它會把一個 page 分割成多段，進行內存分配。ByteBuf 的特點：支持自動擴容（4M），保證 put 方法不會拋出異常、通過內置的複合緩衝類型，實現零拷貝（zero-copy）；不需要調用 flip()來切換讀/寫模式，讀取和寫入索引分開；</p><p>方法鏈；引用計數基於 AtomicIntegerFieldUpdater 用於內存回收；PooledByteBuf 採用二叉樹來實現一個內存池，集中管理內存的分配和釋放，不用每次使用都新建一個緩衝區對象。UnpooledHeapByteBuf 每次都會新建一個緩衝區對象。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Netty</a></li><li><a>面試</a></li><li><a>面試題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/caebf494.html alt=僅hashmap一道面試題我就搞定了面試官成功入職面試官：我裂開了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bdc28a09cd4b4ed2aa8b9250cf6e1065 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/caebf494.html title=僅hashmap一道面試題我就搞定了面試官成功入職面試官：我裂開了>僅hashmap一道面試題我就搞定了面試官成功入職面試官：我裂開了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ffb4d729.html alt=「每天一道面試題」檢查異常和非檢查異常的區別？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152112070414787f2e33262 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ffb4d729.html title=「每天一道面試題」檢查異常和非檢查異常的區別？>「每天一道面試題」檢查異常和非檢查異常的區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html alt="不怕面試被問了！二叉樹算法大盤點 | 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html title="不怕面試被問了！二叉樹算法大盤點 | 原力計劃">不怕面試被問了！二叉樹算法大盤點 | 原力計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html title="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~">別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html title=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>