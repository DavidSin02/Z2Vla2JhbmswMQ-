<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Kafka整體架構圖解 | 极客快訊</title><meta property="og:title" content="Kafka整體架構圖解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/05ae540358854cb3ba0aa4577709330d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c984f60.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c984f60.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c984f60.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c984f60.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c984f60.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c984f60.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c984f60.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c984f60.html><meta property="article:published_time" content="2020-11-14T21:06:33+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:33+08:00"><meta name=Keywords content><meta name=description content="Kafka整體架構圖解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6c984f60.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Kafka整體架構圖解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/05ae540358854cb3ba0aa4577709330d><p class=pgc-img-caption></p></div><p><strong>Java識堂</strong>，一個高原創，高收藏，有乾貨的<strong>微信公眾號，</strong>一起成長，一起進步，歡迎關注</p><h1>1.概述</h1><p>Apache Kafka最早是由LinkedIn開源出來的分佈式消息系統，現在是Apache旗下的一個子項目，並且已經成為開源領域應用最廣泛的消息系統之一。Kafka社區非常活躍,從0.9版本開始，Kafka的標語已經從“一個高吞吐量，分佈式的消息系統”改為"一個分佈式流平臺"。</p><p>Kafka和傳統的消息系統不同在於:</p><ul><li>kafka是一個分佈式系統，易於向外擴展。</li><li>它同時為發佈和訂閱提供高吞吐量</li><li>它支持多訂閱者，當失敗時能自動平衡消費者</li><li>消息的持久化</li></ul><p>kafka和其他消息隊列的對比:</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c9fddb2fc5504633a215f5b15e6cf3c5><p class=pgc-img-caption></p></div><h1>2.入門實例</h1><p>2.1生產者</p><p><strong>producer</strong></p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/39b14faa179341818368b691637aef5b><p class=pgc-img-caption></p></div><p>2.2 消費者</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7056c9624c444ce090af6dd687aaf128><p class=pgc-img-caption></p></div><h1>3.Kafka架構原理</h1><p>對於kafka的架構原理我們先提出幾個問題?</p><p>1.Kafka的topic和分區內部是如何存儲的，有什麼特點？</p><p>2.與傳統的消息系統相比,Kafka的消費模型有什麼優點?</p><p>3.Kafka如何實現分佈式的數據存儲與數據讀取?</p><p>3.1Kafka架構圖</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f7f3f793e23c456da1700ce3023d9c5b><p class=pgc-img-caption></p></div><p>3.2kafka名詞解釋</p><p>在一套kafka架構中有多個Producer，多個Broker,多個Consumer，每個Producer可以對應多個Topic，每個Consumer只能對應一個ConsumerGroup。</p><p>整個Kafka架構對應一個ZK集群，通過ZK管理集群配置，選舉Leader，以及在consumer group發生變化時進行rebalance。</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/90200d469e7242ba882e4ef5d2fa87d3><p class=pgc-img-caption></p></div><p>3.3Topic和Partition</p><p>在Kafka中的每一條消息都有一個topic。一般來說在我們應用中產生不同類型的數據，都可以設置不同的主題。一個主題一般會有多個消息的訂閱者，當生產者發佈消息到某個主題時，訂閱了這個主題的消費者都可以接收到生產者寫入的新消息。</p><p>kafka為每個主題維護了分佈式的分區(partition)日誌文件，每個partition在kafka存儲層面是append log。任何發佈到此partition的消息都會被追加到log文件的尾部，在分區中的每條消息都會按照時間順序分配到一個單調遞增的順序編號，也就是我們的offset,offset是一個long型的數字，我們通過這個offset可以確定一條在該partition下的唯一消息。在partition下面是保證了有序性，但是在topic下面沒有保證有序性。</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8682142f380a41d2b583ea9e2766bbac><p class=pgc-img-caption></p></div><p>在上圖中在我們的生產者會決定發送到哪個Partition。</p><p>1.如果沒有Key值則進行輪詢發送。</p><p>2.如果有Key值，對Key值進行Hash，然後對分區數量取餘，保證了同一個Key值的會被路由到同一個分區，如果想隊列的強順序一致性，可以讓所有的消息都設置為同一個Key。</p><p>3.4消費模型</p><p>消息由生產者發送到kafka集群后，會被消費者消費。一般來說我們的消費模型有兩種:推送模型(psuh)和拉取模型(pull)</p><p>基於推送模型的消息系統，由消息代理記錄消費狀態。消息代理將消息推送到消費者後，標記這條消息為已經被消費，但是這種方式無法很好地保證消費的處理語義。比如當我們把已經把消息發送給消費者之後，由於消費進程掛掉或者由於網絡原因沒有收到這條消息，如果我們在消費代理將其標記為已消費，這個消息就永久丟失了。如果我們利用生產者收到消息後回覆這種方法，消息代理需要記錄消費狀態，這種不可取。如果採用push，消息消費的速率就完全由消費代理控制，一旦消費者發生阻塞，就會出現問題。</p><p>Kafka採取拉取模型(poll)，由自己控制消費速度，以及消費的進度，消費者可以按照任意的偏移量進行消費。比如消費者可以消費已經消費過的消息進行重新處理，或者消費最近的消息等等。</p><p>3.5網絡模型</p><p>3.5.1 KafkaClient --單線程Selector</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ffd897b90e2c456b87220a52a1858ebc><p class=pgc-img-caption></p></div><p>單線程模式適用於併發鏈接數小，邏輯簡單，數據量小。</p><p>在kafka中，consumer和producer都是使用的上面的單線程模式。這種模式不適合kafka的服務端，在服務端中請求處理過程比較複雜，會造成線程阻塞，一旦出現後續請求就會無法處理，會造成大量請求超時，引起雪崩。而在服務器中應該充分利用多線程來處理執行邏輯。</p><p>3.5.2 Kafka--server -- 多線程Selector</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47fb4eebbd1242f78866438787c542a6><p class=pgc-img-caption></p></div><p>在kafka服務端採用的是多線程的Selector模型，Acceptor運行在一個單獨的線程中，對於讀取操作的線程池中的線程都會在selector註冊read事件，負責服務端讀取請求的邏輯。成功讀取後，將請求放入message queue共享隊列中。然後在寫線程池中，取出這個請求，對其進行邏輯處理，即使某個請求線程阻塞了，還有後續的縣城從消息隊列中獲取請求並進行處理，在寫線程中處理完邏輯處理，由於註冊了OP_WIRTE事件，所以還需要對其發送響應。</p><p>3.6高可靠分佈式存儲模型</p><p>在Kafka中保證高可靠模型的依靠的是副本機制，有了副本機制之後，就算機器宕機也不會發生數據丟失。</p><p>3.6.1高性能的日誌存儲</p><p>kafka一個topic下面的所有消息都是以partition的方式分佈式的存儲在多個節點上。同時在kafka的機器上，每個Partition其實都會對應一個日誌目錄，在目錄下面會對應多個日誌分段(LogSegment)。LogSegment文件由兩部分組成，分別為“.index”文件和“.log”文件，分別表示為segment索引文件和數據文件。這兩個文件的命令規則為：partition全局的第一個segment從0開始，後續每個segment文件名為上一個segment文件最後一條消息的offset值，數值大小為64位，20位數字字符長度，沒有數字用0填充，如下，假設有1000條消息，每個LogSegment大小為100，下面展現了900-1000的索引和Log：</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eebcb26f38a0492a8d3cb830424b3c55><p class=pgc-img-caption></p></div><p>由於kafka消息數據太大，如果全部建立索引，即佔了空間又增加了耗時，所以kafka選擇了稀疏索引的方式，這樣的話索引可以直接進入內存，加快偏查詢速度。</p><p>簡單介紹一下如何讀取數據，如果我們要讀取第911條數據首先第一步，找到他是屬於哪一段的，根據二分法查找到他屬於的文件，找到0000900.index和00000900.log之後，然後去index中去查找 (911-900) =11這個索引或者小於11最近的索引,在這裡通過二分法我們找到了索引是[10,1367]然後我們通過這條索引的物理位置1367，開始往後找，直到找到911條數據。</p><p>上面講的是如果要找某個offset的流程，但是我們大多數時候並不需要查找某個offset,只需要按照順序讀即可，而在順序讀中，操作系統會對內存和磁盤之間添加page cahe，也就是我們平常見到的預讀操作，所以我們的順序讀操作時速度很快。但是kafka有個問題，如果分區過多，那麼日誌分段也會很多，寫的時候由於是批量寫，其實就會變成隨機寫了，隨機I/O這個時候對性能影響很大。所以一般來說Kafka不能有太多的partition。針對這一點，RocketMQ把所有的日誌都寫在一個文件裡面，就能變成順序寫，通過一定優化，讀也能接近於順序讀。</p><blockquote><p>可以思考一下:1.為什麼需要分區，也就是說主題只有一個分區，難道不行嗎？2.日誌為什麼需要分段</p><p>1.分區是為了水平擴展 2.日誌如果在同一個文件太大會影響性能。如果日誌無限增長，查詢速度會減慢</p></blockquote><p>3.6.2副本機制</p><p>Kafka的副本機制是多個服務端節點對其他節點的主題分區的日誌進行復制。當集群中的某個節點出現故障，訪問故障節點的請求會被轉移到其他正常節點(這一過程通常叫Reblance),kafka每個主題的每個分區都有一個主副本以及0個或者多個副本，副本保持和主副本的數據同步，當主副本出故障時就會被替代。</p><div class=pgc-img><img alt=Kafka整體架構圖解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cd8ca84ca36548959f3c5339fb02cd0c><p class=pgc-img-caption></p></div><p>在Kafka中並不是所有的副本都能被拿來替代主副本，所以在kafka的leader節點中維護著一個ISR(In sync Replicas)集合，翻譯過來也叫正在同步中集合，在這個集合中的需要滿足兩個條件:</p><ul><li>節點必須和ZK保持連接</li><li>在同步的過程中這個副本不能落後主副本太多</li></ul><p>另外還有個AR(Assigned Replicas)用來標識副本的全集,OSR用來表示由於落後被剔除的副本集合，所以公式如下:ISR = leader + 沒有落後太多的副本; AR = OSR+ ISR;</p><p>這裡先要說下兩個名詞:HW(高水位)是consumer能夠看到的此partition的位置，LEO是每個partition的log最後一條Message的位置。HW能保證leader所在的broker失效，該消息仍然可以從新選舉的leader中獲取，不會造成消息丟失。</p><p>當producer向leader發送數據時，可以通過request.required.acks參數來設置數據可靠性的級別：</p><ul><li>1（默認）：這意味著producer在ISR中的leader已成功收到的數據並得到確認後發送下一條message。如果leader宕機了，則會丟失數據。</li><li>0：這意味著producer無需等待來自broker的確認而繼續發送下一批消息。這種情況下數據傳輸效率最高，但是數據可靠性確是最低的。</li><li>-1：producer需要等待ISR中的所有follower都確認接收到數據後才算一次發送完成，可靠性最高。但是這樣也不能保證數據不丟失，比如當ISR中只有leader時(其他節點都和zk斷開連接，或者都沒追上)，這樣就變成了acks=1的情況。</li></ul><h1>4.高可用模型及冪等</h1><p>在分佈式系統中一般有三種處理語義:</p><ul><li><strong>at-least-once：</strong></li><li>至少一次，有可能會有多次。如果producer收到來自ack的確認，則表示該消息已經寫入到Kafka了，此時剛好是一次，也就是我們後面的exactly-once。但是如果producer超時或收到錯誤，並且request.required.acks配置的不是-1，則會重試發送消息，客戶端會認為該消息未寫入Kafka。如果broker在發送Ack之前失敗，但在消息成功寫入Kafka之後，這一次重試將會導致我們的消息會被寫入兩次，所以消息就不止一次地傳遞給最終consumer，如果consumer處理邏輯沒有保證冪等的話就會得到不正確的結果。</li><li>在這種語義中會出現亂序，也就是當第一次ack失敗準備重試的時候，但是第二消息已經發送過去了，這個時候會出現單分區中亂序的現象,我們需要設置Prouducer的參數max.in.flight.requests.per.connection，flight.requests是Producer端用來保存發送請求且沒有響應的隊列，保證Producer端未響應的請求個數為1。</li><li><strong>at-most-once:</strong></li><li>如果在ack超時或返回錯誤時producer不重試，也就是我們講request.required.acks=-1，則該消息可能最終沒有寫入kafka，所以consumer不會接收消息。</li><li><strong>exactly-once：</strong></li><li>剛好一次，即使producer重試發送消息，消息也會保證最多一次地傳遞給consumer。該語義是最理想的，也是最難實現的。在0.10之前並不能保證exactly-once，需要使用consumer自帶的冪等性保證。0.11.0使用事務保證了</li></ul><p>4.1 如何實現exactly-once</p><p>要實現exactly-once在Kafka 0.11.0中有兩個官方策略:</p><p>4.1.1單Producer單Topic</p><p>每個producer在初始化的時候都會被分配一個唯一的PID，對於每個唯一的PID，Producer向指定的Topic中某個特定的Partition發送的消息都會攜帶一個從0單調遞增的sequence number。</p><p>在我們的Broker端也會維護一個維度為&lt;PID,Topic,Partition>，每次提交一次消息的時候都會對齊進行校驗:</p><ul><li>如果消息序號比Broker維護的序號大一以上，說明中間有數據尚未寫入，也即亂序，此時Broker拒絕該消息，Producer拋出InvalidSequenceNumber</li><li>如果消息序號小於等於Broker維護的序號，說明該消息已被保存，即為重複消息，Broker直接丟棄該消息，Producer拋出DuplicateSequenceNumber</li><li>如果消息序號剛好大一，就證明是合法的</li></ul><p>上面所說的解決了兩個問題:</p><p>1.當Prouducer發送了一條消息之後失敗，broker並沒有保存，但是第二條消息卻發送成功，造成了數據的亂序。</p><p>2.當Producer發送了一條消息之後，broker保存成功，ack回傳失敗，producer再次投遞重複的消息。</p><p>上面所說的都是在同一個PID下面，意味著必須保證在單個Producer中的同一個seesion內，如果Producer掛了，被分配了新的PID，這樣就無法保證了，所以Kafka中又有事務機制去保證。</p><p>4.1.2事務</p><p>在kafka中事務的作用是</p><ul><li>實現exactly-once語義</li><li>保證操作的原子性，要麼全部成功，要麼全部失敗。</li><li>有狀態的操作的恢復</li></ul><p>事務可以保證就算跨多個&lt;Topic, Partition>，在本次事務中的對消費隊列的操作都當成原子性，要麼全部成功，要麼全部失敗。並且，有狀態的應用也可以保證重啟後從斷點處繼續處理，也即事務恢復。在kafka的事務中，應用程序必須提供一個唯一的事務ID，即Transaction ID，並且宕機重啟之後，也不會發生改變，Transactin ID與PID可能一一對應。區別在於Transaction ID由用戶提供，而PID是內部的實現對用戶透明。為了Producer重啟之後，舊的Producer具有相同的Transaction ID失效，每次Producer通過Transaction ID拿到PID的同時，還會獲取一個單調遞增的epoch。由於舊的Producer的epoch比新Producer的epoch小，Kafka可以很容易識別出該Producer是老的Producer並拒絕其請求。為了實現這一點，Kafka 0.11.0.0引入了一個服務器端的模塊，名為Transaction Coordinator，用於管理Producer發送的消息的事務性。該Transaction Coordinator維護Transaction Log，該log存於一個內部的Topic內。由於Topic數據具有持久性，因此事務的狀態也具有持久性。Producer並不直接讀寫Transaction Log，它與Transaction Coordinator通信，然後由Transaction Coordinator將該事務的狀態插入相應的Transaction Log。Transaction Log的設計與Offset Log用於保存Consumer的Offset類似。</p><h1>最後</h1><p>關於消息隊列或者Kafka的一些常見的面試題，通過上面的文章可以提煉出以下幾個比較經典的問題:</p><ol><li>為什麼使用消息隊列？消息隊列的作用是什麼？</li><li>Kafka的topic和分區內部是如何存儲的，有什麼特點？</li><li>與傳統的消息系統相比,Kafka的消費模型有什麼優點?</li><li>Kafka如何實現分佈式的數據存儲與數據讀取?</li><li>kafka為什麼比rocketmq支持的單機partion要少?</li><li>為什麼需要分區，也就是說主題只有一個分區，難道不行嗎？</li><li>日誌為什麼需要分段？</li><li>kafka是依靠什麼機制保持高可靠，高可用？</li><li>消息隊列如何保證消息冪等？</li><li>讓你自己設計個消息隊列，你會怎麼設計，會考慮哪些方面？</li></ol><pre>原文：https://my.oschina.net/u/4072299/blog/3017420</pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Kafka</a></li><li><a>整體</a></li><li><a>架構</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html alt=MyBatis整體架構分析：基礎支持層、核心處理層和接口層 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d6a0b300b114d07b2f3fe66d7ef7005 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html title=MyBatis整體架構分析：基礎支持層、核心處理層和接口層>MyBatis整體架構分析：基礎支持層、核心處理層和接口層</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html alt=K8S整體架構解析，簡單明瞭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/37380f3294a54bbf8c6bec1de3e08ba0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html title=K8S整體架構解析，簡單明瞭>K8S整體架構解析，簡單明瞭</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html alt=支付系統：整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1d94fa40459462fa825d407a1904c7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html title=支付系統：整體架構>支付系統：整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b00b993.html alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a03943b7e3c456fb535e18f902470e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b00b993.html title=《深入精通Mysql（一）》Mysql整體架構和sql執行過程>《深入精通Mysql（一）》Mysql整體架構和sql執行過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2123c3c.html alt=橋樑蓋樑計算“整體圖式法”不明白？這篇詳解能幫你！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15380322769483d1101ea07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2123c3c.html title=橋樑蓋樑計算“整體圖式法”不明白？這篇詳解能幫你！>橋樑蓋樑計算“整體圖式法”不明白？這篇詳解能幫你！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05253828.html alt=泉州酒店坍塌事故分析：結構如何從局部失穩到整體失穩？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c6578f894a647f7abbfeb9d80c550da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05253828.html title=泉州酒店坍塌事故分析：結構如何從局部失穩到整體失穩？>泉州酒店坍塌事故分析：結構如何從局部失穩到整體失穩？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html alt=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0670cbc9828449c782ac323a238b99e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html title=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效>朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42a7eb8a.html alt=“整體驅動橋殼體”有望國內率先量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RAZAR125NY4yo4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42a7eb8a.html title=“整體驅動橋殼體”有望國內率先量產>“整體驅動橋殼體”有望國內率先量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b55df2d7.html alt=【看點】整體技術達到國際先進水平——青島海佳HW-8010型高速高密噴水織機通過科技成果鑑定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RDVYAVcGehzkiX style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b55df2d7.html title=【看點】整體技術達到國際先進水平——青島海佳HW-8010型高速高密噴水織機通過科技成果鑑定>【看點】整體技術達到國際先進水平——青島海佳HW-8010型高速高密噴水織機通過科技成果鑑定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html alt=活動文件櫃的架構是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/104d3629a97947b19d62b03dc3b8d82f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html title=活動文件櫃的架構是什麼>活動文件櫃的架構是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a171e528.html alt=如何快速全面掌握Kafka？5000字吐血整理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RreaNY7GvCqWFq style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a171e528.html title=如何快速全面掌握Kafka？5000字吐血整理>如何快速全面掌握Kafka？5000字吐血整理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9b73f4ec.html alt=鼻基底對鼻子的整體美觀和麵部氣質也很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6c3510311e7f425e9b32b5c0f9e2e1b7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9b73f4ec.html title=鼻基底對鼻子的整體美觀和麵部氣質也很重要>鼻基底對鼻子的整體美觀和麵部氣質也很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html alt=九年新浪架構師整理PHP架構核心技術教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b3a3c32254344742b6746996f7fab54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html title=九年新浪架構師整理PHP架構核心技術教程>九年新浪架構師整理PHP架構核心技術教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4345a9b.html alt=網絡工程｜綜合佈線整體解決方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4345a9b.html title=網絡工程｜綜合佈線整體解決方案>網絡工程｜綜合佈線整體解決方案</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>