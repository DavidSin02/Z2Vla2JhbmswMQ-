<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>密碼學基礎：AES加密算法 | 极客快訊</title><meta property="og:title" content="密碼學基礎：AES加密算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/deb209a70991491a8637d3fbe44268b7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ca2762d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ca2762d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6ca2762d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ca2762d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ca2762d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6ca2762d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6ca2762d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6ca2762d.html><meta property="article:published_time" content="2020-11-14T21:00:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:34+08:00"><meta name=Keywords content><meta name=description content="密碼學基礎：AES加密算法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6ca2762d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>密碼學基礎：AES加密算法</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/deb209a70991491a8637d3fbe44268b7><p class=pgc-img-caption></p></div><p><br></p><p>本節目的： 這一章作為AES算法的基礎部分，目的主要是整理下密碼學中AES加密與解密的相關知識點，並把它們分享出來。</p><p>閱讀方法： 希望大家在瀏覽完本章文章後可以自己去實現一下，相信一定會對你的編程技術有所提高。（附件中提供參考代碼，請點擊閱讀原文下載）</p><p>具備基礎：</p><p>（1）熟練掌握C語言； （2）相關數學知識</p><p>學習環境： 任意C語言開發環境，一個正確的AES算法程序（方便調試，驗證程序結果 ）</p><p>第一節：AES算法簡介</p><p>AES的全稱是Advanced Encryption Standard，意思是高級加密標準。它的出現主要是為了取代DES加密算法的，因為我們都知道DES算法的密鑰長度是56Bit，因此算法的理論安全強度是2的56次方。</p><p>但二十世紀中後期正是計算機飛速發展的階段，元器件製造工藝的進步使得計算機的處理能力越來越強，雖然出現了3DES的加密方法，但由於它的加密時間是DES算法的3倍多，64Bit的分組大小相對較小，所以還是不能滿足人們對安全性的要求。</p><p>於是1997年1月2號，美國國家標準技術研究所宣佈希望徵集高級加密標準，用以取代DES。AES也得到了全世界很多密碼工作者的響應，先後有很多人提交了自己設計的算法。</p><p>最終有5個候選算法進入最後一輪： Rijndael，Serpent，Twofish，RC6 和 MARS 。最終經過安全性分析、軟硬件性能評估等嚴格的步驟，Rijndael算法獲勝。</p><p>在密碼標準徵集中，所有AES候選提交方案都必須滿足以下標準：</p><ul><li>分組大小為128位的分組密碼。</li><li>必須支持三種密碼標準：128位、192位和256位。</li><li>比提交的其他算法更安全。</li><li>在軟件和硬件實現上都很高效。</li></ul><p>AES密碼與分組密碼Rijndael基本上完全一致，Rijndael分組大小和密鑰大小都可以為128位、192位和256位。然而AES只要求分組大小為128位，因此只有分組長度為128Bit的Rijndael才稱為AES算法。</p><p>本文只對分組大小128位，密鑰長度也為128位的Rijndael算法進行分析。密鑰長度為192位和256位的處理方式和128位的處理方式類似，只不過密鑰長度每增加64位，算法的循環次數就增加2輪，128位循環10輪、192位循環12輪、256位循環14輪。</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee6b4b65e7bc478b9d22dded60700309><p class=pgc-img-caption></p></div><p>第二節：AES算法相關數學知識</p><p>在AES算法中的MixColumn層中會用到伽羅瓦域中的乘法運算，而伽羅瓦域的運算涉及一些數學知識，所以本節將會介紹其相關的知識幫助大家瞭解，知識不難看過就清楚了。</p><p>> > > ></p><p><strong>素域簡介</strong></p><p>有限域有時也稱伽羅瓦域，它指的是由有限個元素組成的集合，在這個集合內可以執行加、減、乘和逆運算。</p><p>而在密碼編碼學中，我們只研究擁有有限個元素的域，也就是有限域。域中包含元素的個數稱為域的階。只有當m是一個素數冪時，即m=p^n(其中n為正整數是p的次數，p為素數)，階為m的域才存在。</p><p>p稱為這個有限域的特徵。 也就是說，有限域中元素的個數可以是11(p=11是一個素數,n=1)、可以是81(p=3是一個素數，n=4)、也可以是256(p=2是一個素數，n=8).....但有限域的中不可能擁有12個元素，因為12=2·2·3，因此12也不是一個素數冪。</p><p>有限域中最直觀的例子就是階為素數的域，即n=1的域。域GF(p)的元素可以用整數0、1、...、p-1l來表示。域的兩種操作就是模整數加法和整數乘法模p。加上p是一個素數，整數環Z表示為GF(p)，也成為擁有素數個元素的素數域或者伽羅瓦域。GF(p)中所有的非零元素都存在逆元，GF(p)內所有的運算都是模p實現的。</p><p>素域內的算數運算規則如下：(1)加法和乘法都是通過模p實現的；(2)任何一個元素a的加法逆元都是由a+(a的逆元)=0 mod p得到的；(3)任何一個非零元素a的乘法逆元定義為a·a的逆元=1。</p><p>舉個例子，在素域GF(5)={0、1、2、3、4}中，2的加法逆元為3，這是因為2+(3)=5，5mod5=0,所以2+3=5mod5=0。2的乘法逆元為3，這是因為2·3=6，6mod5=1，所以2·3=6mod5=1。(在很多地方a的加法逆元用-a表示，a的乘法逆元用1/a表示)</p><p>注：GF(2)是一個非常重要的素域，也是存在的最小的有限域，由於GF(2)的加法，即模2加法與異或(XOR)門等價，GF(2)的乘法與邏輯與(AND)門等價，所以GF(2)對AES非常重要。</p><p>> > > ></p><p><strong>擴展域簡介</strong></p><p>如果有限域的階不是素數，則這樣的有限域內的加法和乘法運算就不能用模整數加法和整數乘法模p表示。而且m>1的域被稱為擴展域，為了處理擴展域，我們就要使用不同的符號表示擴展域內的元素，使用不同的規則執行擴展域內元素的算術運算。</p><p>在擴展域GF(2^m)中，元素並不是用整數表示的，而是用係數為域GF(2)中元素的多項式表示。這個多項式最大的度(冪)為m-1，所以每個元素共有m個係數，在AES算法使用的域GF(2^8)中，每個元素A∈GF(2^8)都可以表示為</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e1204818b57f4b009bc8a0d10afb39ce><p class=pgc-img-caption></p></div><p>注意：在域GF(2^8)中這樣的多項式共有256個，這256個多項式組成的集合就是擴展域GF(2^8)。 每個多項式都可以按一個8位項鍊的數值形式存儲：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/860b18793df64b4cbe2d3294f36865c7><p class=pgc-img-caption></p></div><p>像x^7、x^6等因子都無需存儲，因為從位的位置就可以清楚地判斷出每個係數對應的冪。</p><p>> > > ></p><p><strong>擴展域GF(2^m)內的加減法</strong></p><p>在AES算法中的密鑰加法層中就使用了這部分的知識，但是不是很明顯，因為我們通常把擴展域中的加法當作異或運算進行處理了，因為在擴展域中的加減法處理都是在底層域GF(2)內完成的，與按位異或運算等價。假設A(x)、B(x)∈GF(2^m)，計算兩個元素之和的方法就是：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bb417244947b4490b49eaaf829815608><p class=pgc-img-caption></p></div><p>而兩個元素之差的計算公式就是：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ab9609bdc0443398f16fce7f9226b7d><p class=pgc-img-caption></p></div><p>注：在減法運算中減號之所以變成加號，這就和二進制減法的性質有關了，大家可以試著驗算下。從上述兩個公式中我們發現在擴展域中加法和減法等價，並且與XOR等價(異或運算也被稱作二進制加法)。</p><p>> > > ></p><p><strong>擴展域GF(2^m)內的乘法</strong></p><p>**擴展域的乘法主要運用在AES算法的列混淆層(Mix Column)中，也是列混淆層中最重要的操作。我們項要將擴展域中的兩個元素用多項式形式展開，然後使用標準的多項式乘法規則將兩個多項式相乘：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c4540bd0134248da868b5eaefb0c59d7><p class=pgc-img-caption></p></div><p>注意：通常在多項式乘法中C(x)的度會大於m-1，因此需要對此進行化簡，而化簡的基本思想與素域內乘法情況相似：在素域GF(p)中，將兩個整數相乘得到的結果除以一個素數，化簡後的結果就是最後的餘數。</p><p>而在擴展域中進行的操作就是：將兩個多項式相乘的結果除以一個不可約多項式，最後的結果就是最後的餘數。(這裡的不可約多項式大致可以看作一個素數)</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d5d4281fecc543fa9f3a2596b001bea2><p class=pgc-img-caption></p></div><p>舉例：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/bae53c690d8e4e81a1f07155a5b8740d><p class=pgc-img-caption></p></div><p>第三節：AES算法原理</p><p>AES算法主要有四種操作處理，分別是密鑰加法層(也叫輪密鑰加，英文Add Round Key)、字節代換層(SubByte)、行位移層(Shift Rows)、列混淆層(Mix Column)。</p><p>而明文x和密鑰k都是由16個字節組成的數據(當然密鑰還支持192位和256位的長度，暫時不考慮)，它是按照字節的先後順序從上到下、從左到右進行排列的。</p><p>加密出的密文讀取順序也是按照這個順序讀取的，相當於將數組還原成字符串的模樣了，然後再解密的時候又是按照4·4數組處理的。</p><p>AES算法在處理的輪數上只有最後一輪操作與前面的輪處理上有些許 不同(最後一輪只是少了列混淆處理)，在輪處理開始前還單獨進行了一次輪密鑰加的處理。</p><p>在處理輪數上，我們只考慮128位密鑰的10輪處理。接下來，就開始一步步的介紹AES算法的處理流程了。</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e0ba31bf7ed540a89da338104b6a5fe9><p class=pgc-img-caption></p></div><p>AES算法流程圖</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b56b44d1046447819e7768cf7443631d><p class=pgc-img-caption></p></div><p>> > > ></p><p><strong>密鑰加法層</strong></p><p>在密鑰加法層中有兩個輸入的參數，分別是明文和子密鑰k[0]，而且這兩個輸入都是128位的。k[0]實際上就等同於密鑰k，具體原因在密鑰生成中進行介紹。</p><p>我們前面在介紹擴展域加減法中提到過，在擴展域中加減法操作和異或運算等價，所以這裡的處理也就異常的簡單了，只需要將兩個輸入的數據進行按字節異或操作就會得到運算的結果。</p><p>圖示：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a6d09fb5cdcb477bbbe6be59369c4941><p class=pgc-img-caption></p></div><p>相關代碼：</p><p>int AddRoundKey( unsigned char (*PlainArray)[ 4 ], unsigned char (*ExtendKeyArray)[ 44 ], unsigned int MinCol)</p><p>{</p><p>int ret = 0 ;</p><p>for ( int i = 0 ; i &lt; 4 ; i++)</p><p>{</p><p>for ( int j = 0 ; j &lt; 4 ; j++)</p><p>{</p><p>PlainArray[i][j] ^= ExtendKeyArray[i][MinCol + j];</p><p>}</p><p>}</p><p>return ret;</p><p>}</p><p>> > > ></p><p><strong>字節代換層</strong></p><p>字節代換層的主要功能就是讓輸入的數據通過S_box表完成從一個字節到另一個字節的映射，這裡的S_box表是通過某種方法計算出來的，具體的計算方法將在進階部分進行介紹，我們基礎部分就只給出計算好的S_box結果。</p><p>S_box表是一個擁有256個字節元素的數組，可以將其定義為一維數組，也可以將其定義為16·16的二維數組，如果將其定義為二維數組，讀取S_box數據的方法就是要將輸入數據的每個字節的高四位作為第一個下標，第四位作為第二個下標，略有點麻煩。</p><p>這裡建議將其視作一維數組即可。逆S盒與S盒對應，用於解密時對數據處理，我們對解密時的程序處理稱作逆字節代換，只是使用的代換表盒加密時不同而已。</p><p>S盒</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3b827ade38084bf3a1bb071620440027><p class=pgc-img-caption></p></div><p>逆S盒</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bcfcf9d901e3483db48ea736e9fc3a9d><p class=pgc-img-caption></p></div><p>加密圖示：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44e7ccfb890341ee830be1ffc54e797a><p class=pgc-img-caption></p></div><p>相關代碼：</p><p>//S盒</p><p>const unsigned char S_Table[ 16 ][ 16 ] =</p><p>{</p><p>0x63 , 0x7C , 0x77 , 0x7B , 0xF2 , 0x6B , 0x6F , 0xC5 , 0x30 , 0x01 , 0x67 , 0x2B , 0xFE , 0xD7 , 0xAB , 0x76 ,</p><p>0xCA , 0x82 , 0xC9 , 0x7D , 0xFA , 0x59 , 0x47 , 0xF0 , 0xAD , 0xD4 , 0xA2 , 0xAF , 0x9C , 0xA4 , 0x72 , 0xC0 ,</p><p>0xB7 , 0xFD , 0x93 , 0x26 , 0x36 , 0x3F , 0xF7 , 0xCC , 0x34 , 0xA5 , 0xE5 , 0xF1 , 0x71 , 0xD8 , 0x31 , 0x15 ,</p><p>0x04 , 0xC7 , 0x23 , 0xC3 , 0x18 , 0x96 , 0x05 , 0x9A , 0x07 , 0x12 , 0x80 , 0xE2 , 0xEB , 0x27 , 0xB2 , 0x75 ,</p><p>0x09 , 0x83 , 0x2C , 0x1A , 0x1B , 0x6E , 0x5A , 0xA0 , 0x52 , 0x3B , 0xD6 , 0xB3 , 0x29 , 0xE3 , 0x2F , 0x84 ,</p><p>0x53 , 0xD1 , 0x00 , 0xED , 0x20 , 0xFC , 0xB1 , 0x5B , 0x6A , 0xCB , 0xBE , 0x39 , 0x4A , 0x4C , 0x58 , 0xCF ,</p><p>0xD0 , 0xEF , 0xAA , 0xFB , 0x43 , 0x4D , 0x33 , 0x85 , 0x45 , 0xF9 , 0x02 , 0x7F , 0x50 , 0x3C , 0x9F , 0xA8 ,</p><p>0x51 , 0xA3 , 0x40 , 0x8F , 0x92 , 0x9D , 0x38 , 0xF5 , 0xBC , 0xB6 , 0xDA , 0x21 , 0x10 , 0xFF , 0xF3 , 0xD2 ,</p><p>0xCD , 0x0C , 0x13 , 0xEC , 0x5F , 0x97 , 0x44 , 0x17 , 0xC4 , 0xA7 , 0x7E , 0x3D , 0x64 , 0x5D , 0x19 , 0x73 ,</p><p>0x60 , 0x81 , 0x4F , 0xDC , 0x22 , 0x2A , 0x90 , 0x88 , 0x46 , 0xEE , 0xB8 , 0x14 , 0xDE , 0x5E , 0x0B , 0xDB ,</p><p>0xE0 , 0x32 , 0x3A , 0x0A , 0x49 , 0x06 , 0x24 , 0x5C , 0xC2 , 0xD3 , 0xAC , 0x62 , 0x91 , 0x95 , 0xE4 , 0x79 ,</p><p>0xE7 , 0xC8 , 0x37 , 0x6D , 0x8D , 0xD5 , 0x4E , 0xA9 , 0x6C , 0x56 , 0xF4 , 0xEA , 0x65 , 0x7A , 0xAE , 0x08 ,</p><p>0xBA , 0x78 , 0x25 , 0x2E , 0x1C , 0xA6 , 0xB4 , 0xC6 , 0xE8 , 0xDD , 0x74 , 0x1F , 0x4B , 0xBD , 0x8B , 0x8A ,</p><p>0x70 , 0x3E , 0xB5 , 0x66 , 0x48 , 0x03 , 0xF6 , 0x0E , 0x61 , 0x35 , 0x57 , 0xB9 , 0x86 , 0xC1 , 0x1D , 0x9E ,</p><p>0xE1 , 0xF8 , 0x98 , 0x11 , 0x69 , 0xD9 , 0x8E , 0x94 , 0x9B , 0x1E , 0x87 , 0xE9 , 0xCE , 0x55 , 0x28 , 0xDF ,</p><p>0x8C , 0xA1 , 0x89 , 0x0D , 0xBF , 0xE6 , 0x42 , 0x68 , 0x41 , 0x99 , 0x2D , 0x0F , 0xB0 , 0x54 , 0xBB , 0x16</p><p>};</p><p>//字節代換</p><p>int Plain_S_Substitution ( unsigned char *PlainArray)</p><p>{</p><p>int ret = 0 ;</p><p>for ( int i = 0 ; i &lt; 16 ; i++)</p><p>{</p><p>PlainArray[i] = S_Table[PlainArray[i] >> 4 ][PlainArray[i] & 0x0F ];</p><p>}</p><p>return ret;</p><p>}</p><p>//逆S盒</p><p>const unsigned char ReS_Table[ 16 ][ 16 ] =</p><p>{</p><p>0x52 , 0x09 , 0x6A , 0xD5 , 0x30 , 0x36 , 0xA5 , 0x38 , 0xBF , 0x40 , 0xA3 , 0x9E , 0x81 , 0xF3 , 0xD7 , 0xFB ,</p><p>0x7C , 0xE3 , 0x39 , 0x82 , 0x9B , 0x2F , 0xFF , 0x87 , 0x34 , 0x8E , 0x43 , 0x44 , 0xC4 , 0xDE , 0xE9 , 0xCB ,</p><p>0x54 , 0x7B , 0x94 , 0x32 , 0xA6 , 0xC2 , 0x23 , 0x3D , 0xEE , 0x4C , 0x95 , 0x0B , 0x42 , 0xFA , 0xC3 , 0x4E ,</p><p>0x08 , 0x2E , 0xA1 , 0x66 , 0x28 , 0xD9 , 0x24 , 0xB2 , 0x76 , 0x5B , 0xA2 , 0x49 , 0x6D , 0x8B , 0xD1 , 0x25 ,</p><p>0x72 , 0xF8 , 0xF6 , 0x64 , 0x86 , 0x68 , 0x98 , 0x16 , 0xD4 , 0xA4 , 0x5C , 0xCC , 0x5D , 0x65 , 0xB6 , 0x92 ,</p><p>0x6C , 0x70 , 0x48 , 0x50 , 0xFD , 0xED , 0xB9 , 0xDA , 0x5E , 0x15 , 0x46 , 0x57 , 0xA7 , 0x8D , 0x9D , 0x84 ,</p><p>0x90 , 0xD8 , 0xAB , 0x00 , 0x8C , 0xBC , 0xD3 , 0x0A , 0xF7 , 0xE4 , 0x58 , 0x05 , 0xB8 , 0xB3 , 0x45 , 0x06 ,</p><p>0xD0 , 0x2C , 0x1E , 0x8F , 0xCA , 0x3F , 0x0F , 0x02 , 0xC1 , 0xAF , 0xBD , 0x03 , 0x01 , 0x13 , 0x8A , 0x6B ,</p><p>0x3A , 0x91 , 0x11 , 0x41 , 0x4F , 0x67 , 0xDC , 0xEA , 0x97 , 0xF2 , 0xCF , 0xCE , 0xF0 , 0xB4 , 0xE6 , 0x73 ,</p><p>0x96 , 0xAC , 0x74 , 0x22 , 0xE7 , 0xAD , 0x35 , 0x85 , 0xE2 , 0xF9 , 0x37 , 0xE8 , 0x1C , 0x75 , 0xDF , 0x6E ,</p><p>0x47 , 0xF1 , 0x1A , 0x71 , 0x1D , 0x29 , 0xC5 , 0x89 , 0x6F , 0xB7 , 0x62 , 0x0E , 0xAA , 0x18 , 0xBE , 0x1B ,</p><p>0xFC , 0x56 , 0x3E , 0x4B , 0xC6 , 0xD2 , 0x79 , 0x20 , 0x9A , 0xDB , 0xC0 , 0xFE , 0x78 , 0xCD , 0x5A , 0xF4 ,</p><p>0x1F , 0xDD , 0xA8 , 0x33 , 0x88 , 0x07 , 0xC7 , 0x31 , 0xB1 , 0x12 , 0x10 , 0x59 , 0x27 , 0x80 , 0xEC , 0x5F ,</p><p>0x60 , 0x51 , 0x7F , 0xA9 , 0x19 , 0xB5 , 0x4A , 0x0D , 0x2D , 0xE5 , 0x7A , 0x9F , 0x93 , 0xC9 , 0x9C , 0xEF ,</p><p>0xA0 , 0xE0 , 0x3B , 0x4D , 0xAE , 0x2A , 0xF5 , 0xB0 , 0xC8 , 0xEB , 0xBB , 0x3C , 0x83 , 0x53 , 0x99 , 0x61 ,</p><p>0x17 , 0x2B , 0x04 , 0x7E , 0xBA , 0x77 , 0xD6 , 0x26 , 0xE1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0C , 0x7D</p><p>};</p><p>//逆字節代換</p><p>int Cipher_S_Substitution ( unsigned char *CipherArray)</p><p>{</p><p>int ret = 0 ;</p><p>for ( int i = 0 ; i &lt; 16 ; i++)</p><p>{</p><p>CipherArray[i] = ReS_Table[CipherArray[i] >> 4 ][CipherArray[i] & 0x0F ];</p><p>}</p><p>return ret;</p><p>}</p><p>> > > ></p><p><strong>行位移——ShiftRows</strong></p><p>行位移操作最為簡單，它是用來將輸入數據作為一個4·4的字節矩陣進行處理的，然後將這個矩陣的字節進行位置上的置換。ShiftRows子層屬於AES手動的擴散層，目的是將單個位上的變換擴散到影響整個狀態當，從而達到雪崩效應。</p><p>在加密時行位移處理與解密時的處理相反，我們這裡將解密時的處理稱作逆行位移。它之所以稱作行位移，是因為它只在4·4矩陣的行間進行操作，每行4字節的數據。</p><p>在加密時，保持矩陣的第一行不變，第二行向左移動8Bit(一個字節)、第三行向左移動2個字節、第四行向左移動3個字節。而在解密時恰恰相反，依然保持第一行不變，將第二行向右移動一個字節、第三行右移2個字節、第四行右移3個字節。操作結束！</p><p>正向行位移圖解:</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a911ff3e85e6413984db70aa73c3a217><p class=pgc-img-caption></p></div><p>對應代碼(這裡將char二維數組強制轉換成int一維數組處理)：</p><p>int ShiftRows ( unsigned int *PlainArray)</p><p>{</p><p>int ret = 0 ;</p><p>//第一行 不移位</p><p>//PlainArray[0] = PlainArray[0];</p><p>//第二行 左移8Bit</p><p>PlainArray[ 1 ] = (PlainArray[ 1 ] >> 8 ) | (PlainArray[ 1 ] &lt;&lt; 24 );</p><p>//第三行 左移16Bit</p><p>PlainArray[ 2 ] = (PlainArray[ 2 ] >> 16 ) | (PlainArray[ 2 ] &lt;&lt; 16 );</p><p>//第四行 左移24Bit</p><p>PlainArray[ 3 ] = (PlainArray[ 3 ] >> 24 ) | (PlainArray[ 3 ] &lt;&lt; 8 );</p><p>return ret;</p><p>}</p><p>逆向行位移圖解:</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe579196ddff4bdfb963edf10c9c7a1b><p class=pgc-img-caption></p></div><p>對應代碼(這裡將char二維數組強制轉換成int一維數組處理)：</p><p>int ReShiftRows ( unsigned int *CipherArray)</p><p>{</p><p>int ret = 0 ;</p><p>//第一行 不移位</p><p>//CipherArray[0] = CipherArray[0];</p><p>//第二行 右移8Bit</p><p>CipherArray[ 1 ] = (CipherArray[ 1 ] &lt;&lt; 8 ) | (CipherArray[ 1 ] >> 24 );</p><p>//第三行 右移16Bit</p><p>CipherArray[ 2 ] = (CipherArray[ 2 ] &lt;&lt; 16 ) | (CipherArray[ 2 ] >> 16 );</p><p>//第四行 右移24Bit</p><p>CipherArray[ 3 ] = (CipherArray[ 3 ] &lt;&lt; 24 ) | (CipherArray[ 3 ] >> 8 );</p><p>return ret;</p><p>}</p><p>> > > ></p><p><strong>列混淆——MixColumn</strong></p><p>列混淆子層是AES算法中最為複雜的部分，屬於擴散層，列混淆操作是AES算法中主要的擴散元素，它混淆了輸入矩陣的每一列，使輸入的每個字節都會影響到4個輸出字節。</p><p>行位移子層和列混淆子層的組合使得經過三輪處理以後，矩陣的每個字節都依賴於16個明文字節成可能。其中包含了矩陣乘法、伽羅瓦域內加法和乘法的相關知識。</p><p>在加密的正向列混淆中，我們要將輸入的4·4矩陣左乘一個給定的4·4矩陣。而它們之間的加法、乘法都在擴展域GF(2^8)中進行，所以也就可以將這一個步驟分成兩個部分進行講解：</p><p>先上一個矩陣乘法的代碼：</p><p>//列混淆左乘矩陣</p><p>const unsigned char MixArray[ 4 ][ 4 ] =</p><p>{</p><p>0x02 , 0x03 , 0x01 , 0x01 ,</p><p>0x01 , 0x02 , 0x03 , 0x01 ,</p><p>0x01 , 0x01 , 0x02 , 0x03 ,</p><p>0x03 , 0x01 , 0x01 , 0x02</p><p>};</p><p>int MixColum( unsigned char (*PlainArray)[ 4 ])</p><p>{</p><p>int ret = 0 ;</p><p>//定義變量</p><p>unsigned char ArrayTemp[ 4 ][ 4 ];</p><p>//初始化變量</p><p>memcpy(ArrayTemp, PlainArray, 16 );</p><p>//矩陣乘法 4*4</p><p>for ( int i = 0 ; i &lt; 4 ; i++)</p><p>{</p><p>for ( int j = 0 ; j &lt; 4 ; j++)</p><p>{</p><p>PlainArray[i][j] =</p><p>MixArray[i][ 0 ] * ArrayTemp[ 0 ][j] +</p><p>MixArray[i][ 1 ] * ArrayTemp[ 1 ][j] +</p><p>MixArray[i][ 2 ] * ArrayTemp[ 2 ][j] +</p><p>MixArray[i][ 3 ] * ArrayTemp[ 3 ][j];</p><p>}</p><p>}</p><p>return ret;</p><p>}</p><p>我們發現在 矩陣乘法中，出現了加法和乘法運算，我們前面也提到過在擴展域中加法操作等同於異或運算，而乘法操作需要一個特殊的方式進行處理，於是我們就先把代碼中的加號換成異或符號，然後將伽羅瓦域的乘法定義成一個有兩個參數的函數，並讓他返回最後計算結果。於是列混淆的代碼就會變成下面的樣子：</p><p>const unsigned char MixArray[ 4 ][ 4 ] =</p><p>{</p><p>0x02 , 0x03 , 0x01 , 0x01 ,</p><p>0x01 , 0x02 , 0x03 , 0x01 ,</p><p>0x01 , 0x01 , 0x02 , 0x03 ,</p><p>0x03 , 0x01 , 0x01 , 0x02</p><p>};</p><p>int MixColum( unsigned char (*PlainArray)[ 4 ])</p><p>{</p><p>int ret = 0 ;</p><p>//定義變量</p><p>unsigned char ArrayTemp[ 4 ][ 4 ];</p><p>//初始化變量</p><p>memcpy(ArrayTemp, PlainArray, 16 );</p><p>//矩陣乘法 4*4</p><p>for ( int i = 0 ; i &lt; 4 ; i++)</p><p>{</p><p>for ( int j = 0 ; j &lt; 4 ; j++)</p><p>{</p><p>PlainArray[i][j] =</p><p>GaloisMultiplication(MixArray[i][ 0 ], ArrayTemp[ 0 ][j]) ^</p><p>GaloisMultiplication(MixArray[i][ 1 ], ArrayTemp[ 1 ][j]) ^</p><p>GaloisMultiplication(MixArray[i][ 2 ], ArrayTemp[ 2 ][j]) ^</p><p>GaloisMultiplication(MixArray[i][ 3 ], ArrayTemp[ 3 ][j]);</p><p>}</p><p>}</p><p>return ret;</p><p>}</p><p>接下來我們就只用處理伽羅瓦域乘法相關處理了，由於前面介紹過相關概念，所以代碼就不在此進行講解了，大家可以參考下方的代碼註釋進行理解：</p><p>///////////////////////////////////////////////////////////////</p><p>//功能: 伽羅瓦域內的乘法運算 GF(128)</p><p>//參數: Num_L 輸入的左參數</p><p>// Num_R 輸入的右參數</p><p>//返回值:計算結果</p><p>char GaloisMultiplication ( unsigned char Num_L, unsigned char Num_R)</p><p>{</p><p>//定義變量</p><p>unsigned char Result = 0 ; //伽羅瓦域內乘法計算的結果</p><p>while (Num_L)</p><p>{</p><p>//如果Num_L最低位是1就異或Num_R，相當於加上Num_R * 1</p><p>if (Num_L & 0x01 )</p><p>{</p><p>Result ^= Num_R;</p><p>}</p><p>//Num_L右移一位，相當於除以2</p><p>Num_L = Num_L >> 1 ;</p><p>//如果Num_R最高位為1</p><p>if (Num_R & 0x80 )</p><p>{</p><p>//左移一位相當於乘二</p><p>Num_R = Num_R &lt;&lt; 1 ; //注：這裡會丟失最高位，但是不用擔心</p><p>Num_R ^= 0x1B ;</p><p>}</p><p>else</p><p>{</p><p>//左移一位相當於乘二</p><p>Num_R = Num_R &lt;&lt; 1 ;</p><p>}</p><p>}</p><p>return Result;</p><p>}</p><p>在解密的逆向列混淆中與正向列混淆的不同之處在於使用的左乘矩陣不同，它與正向列混淆的左乘矩陣互為逆矩陣，也就是說，數據矩陣同時左乘這兩個矩陣後，數據矩陣不會發生任何變化。</p><p>正向列混淆處理：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3d23bba6d5584c54b0155d7ce98ac6b8><p class=pgc-img-caption></p></div><p>逆向列混淆：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b4a0d487362f4c248b1bde075f4b44b7><p class=pgc-img-caption></p></div><p>加解密驗證：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90cac961dfd1400798332ff2b3afff57><p class=pgc-img-caption></p></div><p>加密部分講解完畢，最後應該注意要將密文結果從矩陣形式還原成字符串形式輸出！</p><p>第四節：AES密鑰生成</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6e076054df284eb5a5a24a010ba2dde0><p class=pgc-img-caption></p></div><p>子密鑰的生成是以列為單位進行的，一列是32Bit，四列組成子密鑰共128Bit。生成子密鑰的數量比AES算法的輪數多一個，因為第一個密鑰加法層進行密鑰漂白時也需要子密鑰。</p><p>密鑰漂白是指在AES的輸入盒輸出中都使用的子密鑰的XOR加法。子密鑰在圖中都存儲在W[0]、W[1]、...、W[43]的擴展密鑰數組之中。k1-k16表示原始密鑰對應的字節，而圖中子密鑰k0與原始子密鑰相同。</p><p>在生成的擴展密鑰中W的下標如果是4的倍數時(從零開始)需要對異或的參數進行G函數處理。擴展密鑰生成有關公式如下：</p><p>1 &lt;= i &lt;= 10</p><p>1 &lt;= j &lt;= 3</p><p>w[ 4i ] = W[ 4 (i -1 )] + G(W[ 4i -1 ]);</p><p>w[ 4i +j] = W[ 4 (i -1 )+j] + W[ 4i</p><p>-1</p><p>+j];</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fff286edc171461d9ddee00737ae90db><p class=pgc-img-caption></p></div><p>函數G()首先將4個輸入字節進行翻轉，並執行一個按字節的S盒代換，最後用第一個字節與輪系數Rcon進行異或運算。輪系數是一個有10個元素的一維數組，一個元素1個字節。</p><p>G()函數存在的目的有兩個，一是增加密鑰編排中的非線性；二是消除AES中的對稱性。這兩種屬性都是抵抗某些分組密碼攻擊必要的。</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0fcc9afd24444f2b2d45eed0adf6e0d><p class=pgc-img-caption></p></div><p>生成密鑰代碼:</p><p>//用於密鑰擴展 Rcon[0]作為填充，沒有實際用途</p><p>const unsigned int Rcon[ 11 ] = { 0x00 , 0x01 , 0x02 , 0x04 , 0x08 , 0x10 , 0x20 , 0x40 , 0x80 , 0x1B , 0x36 };</p><p>int Key_S_Substitution( unsigned char (*ExtendKeyArray)[ 44 ], unsigned int nCol)</p><p>{</p><p>int ret = 0 ;</p><p>for ( int i = 0 ; i &lt; 4 ; i++)</p><p>{</p><p>ExtendKeyArray[i][nCol] = S_Table[(ExtendKeyArray[i][nCol]) >> 4 ][(ExtendKeyArray[i][nCol]) & 0x0F ];</p><p>}</p><p>return ret;</p><p>}</p><p>int G_Function( unsigned char (*ExtendKeyArray)[ 44 ], unsigned int nCol)</p><p>{</p><p>int ret = 0 ;</p><p>for ( int i = 0 ; i &lt; 4 ; i++)</p><p>{</p><p>ExtendKeyArray[i][nCol] = ExtendKeyArray[(i + 1 ) % 4 ][nCol - 1 ];</p><p>}</p><p>//2、將nCol列進行S盒替換</p><p>Key_S_Substitution(ExtendKeyArray, nCol);</p><p>//3、將該列第一行元素與Rcon進行異或運算</p><p>ExtendKeyArray[ 0 ][nCol] ^= Rcon[nCol / 4 ];</p><p>return ret;</p><p>}</p><p>int CalculateExtendKeyArray( const unsigned char (*PasswordArray)[ 4 ], unsigned char (*ExtendKeyArray)[ 44 ])</p><p>{</p><p>int ret = 0 ;</p><p>//1、將密鑰數組放入前四列擴展密鑰組</p><p>for ( int i = 0 ; i &lt; 16 ; i++)</p><p>{</p><p>ExtendKeyArray[i & 0x03 ][i >> 2 ] = PasswordArray[i & 0x03 ][i >> 2 ];</p><p>}</p><p>//2、計算擴展矩陣的後四十列</p><p>for ( int i = 1 ; i &lt; 11 ; i++) //進行十輪循環</p><p>{</p><p>//(1)如果列號是4的倍數，這執行G函數 否則將nCol-1列複製到nCol列上</p><p>G_Function(ExtendKeyArray, 4 *i);</p><p>//(2)每一輪中，各列進行異或運算</p><p>// 列號是4的倍數</p><p>for ( int k = 0 ; k &lt; 4 ; k++) //行號</p><p>{</p><p>ExtendKeyArray[k][ 4 * i] = ExtendKeyArray[k][ 4 * i] ^ ExtendKeyArray[k][ 4 * (i - 1 )];</p><p>}</p><p>// 其他三列</p><p>for ( int j = 1 ; j &lt; 4 ; j++) //每一輪的列號</p><p>{</p><p>for ( int k = 0 ; k &lt; 4 ; k++) //行號</p><p>{</p><p>ExtendKeyArray[k][ 4 * i + j] = ExtendKeyArray[k][ 4 * i + j - 1 ] ^ ExtendKeyArray[k][ 4 * (i - 1 ) + j];</p><p>}</p><p>}</p><p>}</p><p>return ret;</p><p>}</p><p>第五節：AES解密流程圖</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/835c1962ff454f5097aee3ca142e0dbc><p class=pgc-img-caption></p></div><p>至此，AES算法基礎部分介紹完畢！</p><p>進階部分</p><p>本節目的： 這一章作為AES算法的進階部分，目的主要是對AES算法中的S盒的建立做一些介紹。</p><p>閱讀方法： 希望大家在瀏覽完本章文章後可以自己去實現一下，相信一定會對你的編程技術有所提高。(附件中提供參考代碼)</p><p><strong>具備基礎：</strong></p><p>（1）熟練掌握C語言；（2）相關數學知識</p><p>學習環境： 任意C語言開發環境</p><p>第六節：相關的數學知識</p><p>在接觸密碼學之前我認為數學的主要用途就是考試， 但是接觸密碼學 後我才發現數學的魅力，雖然數學只是一個工具，但這個工具卻異常強大，我也因此吃了以前不認真學習相關知識的虧。 好了，不多說了現在學習還不算太遲。</p><p>> > > ></p><p><strong>歐幾里得算法：</strong></p><p>兩個正整數r0和r1的gcd表示為gcd(r0, r1)，它指的是可以被r0和r1同時整除的最大正整數，例如gcd(21, 6)=3。對與較小的整數而言gcd就是將兩個整數進行因式分解，並找出最大的公因子。</p><p>例：r0=84,r1=30，因式分解：r0=2·2·3·7；r1=2·3·5；gcd的結果就是：gcd(30,84)=2·3=6。</p><p>gcd(r0,r1)=gcd(r0-r1,r1)，其中假設r0>r1，並且兩個數均是正整數。</p><p>證明：gcd(r0,r1)=g，由於g可以同時被r0、r1整除，則可以記作r0=g·x、r1=g·y，其中x>y，並且x和y互為素數。所以得到：gcd(r0,r1)=gcd(r0-r1,r1)=gcd(g·(x-y),g·y)=g=gcd(ri,0)。</p><p>例：r0=973,r1=301,gcd的計算方式為：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba354c35ce3e4afb91ce2b2ea90c9aaa><p class=pgc-img-caption></p></div><p>歐幾里得算法代碼：</p><p>//輸入兩個正整數r0>r1，輸出計算結果</p><p>int gcd ( int r0, int r1)</p><p>{</p><p>int r= 0 ;</p><p>while (r1 != 0 )</p><p>{</p><p>r = r0 % r1;</p><p>r0 = r1;</p><p>r1 = r;</p><p>}</p><p>return r0;</p><p>}</p><p>> > > ></p><p><strong>擴展歐幾里得算法：</strong></p><p>擴展歐幾里得算法主要的應用不是為例計算最大公因子，它的在密碼學中主要的作用是為了計算乘法逆元，乘法逆元在公鑰密碼學中佔有著舉足輕重的地位。</p><p>當然，除了擴展歐幾里得算法(EEA)除了可以計算gcd，它還可以計算以下形式的線性組合：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6671c287fa34d8bbc990cc084b969cb><p class=pgc-img-caption></p></div><p>其中s和t都表示整型係數。關於如何計算這兩個係數的推到過程這裡就不介紹了，我們只給出最後的公式結論:</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/822b6d018502463a942360252e79d754><p class=pgc-img-caption></p></div><p>介紹完這些公式，我們來看看乘法的逆元是怎麼計算的吧。假設我們要計算r1 mod r0的逆元，其中r1 &lt; r0。</p><p>我們前面提到過乘法的逆元計算公式為a*b=1 mod p，b就是a mod p的乘法逆元，也就是gcd(p, a)=1的情況 下才存在乘法逆元。 則s·r0+t·r1=1=gcd(r0,r1)，將這個等式執行模r0計算可得：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3d89978504f64e998a12438974236478><p class=pgc-img-caption></p></div><p>例題：計算12 mod 67，12的逆元，即gcd(67,12)=1</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d3c8fe367069406fa96b23c74fbb8473><p class=pgc-img-caption></p></div><p>注：通常情況下不需要計算係數S,而且實際中一般也用不上它，另外結果t可能是一個負數，這種情況下就必須把t加是r0讓人的結果為正，因為t=(t+r0) mod r0。</p><p>擴展歐幾里得算法代碼：</p><p>int EEA ( int r0, int r1)</p><p>{</p><p>int mod = r0;</p><p>int r = 0 ;</p><p>int t0 = 0 ;</p><p>int t1 = 1 ;</p><p>int t = t1;</p><p>int q = 0 ;</p><p>//0不存在乘法逆元</p><p>if (r1 == 0 )</p><p>{</p><p>return 0 ;</p><p>}</p><p>while (r1 != 1 )</p><p>{</p><p>q = r0 / r1;</p><p>r = r0 - q * r1;</p><p>t = t0 - q * t1;</p><p>r0 = r1;</p><p>r1 = r;</p><p>t0 = t1;</p><p>t1 = t;</p><p>}</p><p>//結果為負數</p><p>if (t &lt; 0 )</p><p>{</p><p>t = t + mod;</p><p>}</p><p>return t;</p><p>}</p><p>現在相關知識已經學完了，開始進入重點。如果要想計算伽羅瓦域內乘法的逆元，函數的輸入r0就是GF(2^8)的不可約多項式p(x)，r1就是域元素a(x)，然後通過EEA計算多項式t(x)得到a(x)的乘法逆元。</p><p>只不過在上方給出的EEA代碼略有不同，因為在伽羅瓦域中多項式都是在GF(2)上進行加減運算的，也就是說上面的加號和減號都要換成異或運算符，同時乘法和除法也有要進行適當的調整，轉變成多項式乘法和除法。否則結果會出現偏差。</p><p>伽羅瓦域的擴展歐幾里得算法：</p><p>//獲取最高位</p><p>int GetHighestPosition ( unsigned short Number)</p><p>{</p><p>int i = 0 ;</p><p>while (Number)</p><p>{</p><p>i++;</p><p>Number = Number >> 1 ;</p><p>}</p><p>return i;</p><p>}</p><p>//GF(2^8)的多項式除法</p><p>unsigned char Division ( unsigned short Num_L, unsigned short Num_R, unsigned short *Remainder)</p><p>{</p><p>unsigned short r0 = 0 ;</p><p>unsigned char q = 0 ;</p><p>int bitCount = 0 ;</p><p>r0 = Num_L;</p><p>bitCount = GetHighestPosition(r0) - GetHighestPosition(Num_R);</p><p>while (bitCount >= 0 )</p><p>{</p><p>q = q | ( 1 &lt;&lt; bitCount);</p><p>r0 = r0 ^ (Num_R &lt;&lt; bitCount);</p><p>bitCount = GetHighestPosition(r0) - GetHighestPosition(Num_R);</p><p>}</p><p>*Remainder = r0;</p><p>return q;</p><p>}</p><p>//GF(2^8)多項式乘法</p><p>short Multiplication ( unsigned char Num_L, unsigned char Num_R)</p><p>{</p><p>//定義變量</p><p>unsigned short Result = 0 ; //伽羅瓦域內乘法計算的結果</p><p>for ( int i = 0 ; i &lt; 8 ; i++)</p><p>{</p><p>Result ^= ((Num_L >> i) & 0x01 ) * (Num_R &lt;&lt; i);</p><p>}</p><p>return Result;</p><p>}</p><p>int EEA_V2 ( int r0, int r1)</p><p>{</p><p>int mod = r0;</p><p>int r = 0 ;</p><p>int t0 = 0 ;</p><p>int t1 = 1 ;</p><p>int t = t1;</p><p>int q = 0 ;</p><p>if (r1 == 0 )</p><p>{</p><p>return 0 ;</p><p>}</p><p>while (r1 != 1 )</p><p>{</p><p>//q = r0 / r1;</p><p>q = Division(r0, r1, &r);</p><p>r = r0 ^ Multiplication(q, r1);</p><p>t = t0 ^ Multiplication(q, t1);</p><p>r0 = r1;</p><p>r1 = r;</p><p>t0 = t1;</p><p>t1 = t;</p><p>}</p><p>if (t &lt; 0 )</p><p>{</p><p>t = t ^ mod;</p><p>}</p><p>return t;</p><p>}</p><p>第七節：生成S盒的過程</p><p>我們以前介紹過DES算法，那裡面也有一個S盒，我們沒有介紹過它是怎麼形成的是因為DES的S盒是一種特殊的隨即表。而AES中的S盒則不同，這個S盒具有非常強的代數結構，它是經過兩個步驟計算而來的：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ddcc78da056a49639b1af88b5aad5f82><p class=pgc-img-caption></p></div><p>我們已經瞭解的逆元的計算過程，接下來只剩下了仿射映射過程了。</p><p>> > > ></p><p><strong>S盒的仿射映射</strong></p><p>仿射映射這個名詞聽起來有點高深莫測的感覺，不過在我的理解上，它就是一個計算過程。S盒的仿射映射也比較簡單，主要就是運用到了矩陣乘法，不過這個矩陣是Bit矩陣。先上一下計算方法：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f2369509eb447b38d083991cf542ec1><p class=pgc-img-caption></p></div><p>注意仿射映射所有的計算都是基於GF(2)上的。我們從計算過程上發現，輸入數據A的逆元B在仿射映射中被展開成了一個8·1的矩陣，最上方是LSB，然後左乘了一個8·8的Bit矩陣，後加上了0x63展開的8·1矩陣，由於是基於GF(2)的，所以需要進行mod 2操作，最終的結果才是輸出數據C。</p><p>可能有些同學還是看不懂這張圖，那我們就以輸入數據為A=0x7為例，手動計算一下這個結果C:</p><p>1、計算乘法逆元：</p><p>將以下兩個參數帶入EEA_V2()函數可以得到A的逆元:</p><p>最終結果為：B=EEA(A)=0xD1</p><p>2、仿射映射(重點):</p><p>我們將上述結果B拆成Bit帶入第二個矩陣得：</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d56f217ccac74cb692532dd7255251ea><p class=pgc-img-caption></p></div><p>計算輸出值C:</p><p>c[0] = (1 *1) ^ (0* 0) ^ (0 *0) ^ (0* 0) ^ (1 *1) ^ (1* 0) ^ (1 *1) ^ (1* 1) ^ 1 = 1</p><p>c[1] = (1 *1) ^ (1* 0) ^ (0 *0) ^ (0* 0) ^ (0 *1) ^ (1* 0) ^ (1 *1) ^ (1* 1) ^ 1 = 0</p><p>c[2] = (1 *1) ^ (1* 0) ^ (1 *0) ^ (0* 0) ^ (0 *1) ^ (0* 0) ^ (1 *1) ^ (1* 1) ^ 0 = 1</p><p>c[3] = (1 *1) ^ (1* 0) ^ (1 *0) ^ (1* 0) ^ (0 *1) ^ (0* 0) ^ (0 *1) ^ (1* 1) ^ 0 = 0</p><p>c[4] = (1 *1) ^ (1* 0) ^ (1 *0) ^ (1* 0) ^ (1 *1) ^ (0* 0) ^ (0 *1) ^ (0* 1) ^ 0 = 0</p><p>c[5] = (0 *1) ^ (1* 0) ^ (1 *0) ^ (1* 0) ^ (1 *1) ^ (1* 0) ^ (0 *1) ^ (0* 1) ^ 1 = 0</p><p>c[6] = (0 *1) ^ (0* 0) ^ (1 *0) ^ (1* 0) ^ (1 *1) ^ (1* 0) ^ (1 *1) ^ (0* 1) ^ 1 = 1</p><p>c[7] = (0 *1) ^ (0* 0) ^ (0 *0) ^ (1* 0) ^ (1 *1) ^ (1*</p><p>*1) ^ (1*</p><p>1) ^ 0 = 1</p><p>最後得到的仿射映射的結果為：C=0xC5</p><p>查看S盒，驗證結果正確！</p><p>仿射映射代碼：</p><p>unsigned char ByteImage ( int imput)</p><p>{</p><p>unsigned char Result = 0 ;</p><p>for ( int i = 0 ; i &lt; 8 ; i++)</p><p>{</p><p>Result ^= (((imput >> i) & 1 ) ^ ((imput >> ((i + 4 ) % 8 )) & 1 ) ^ ((imput >> ((i + 5 ) % 8 )) & 1 ) ^ ((imput >> ((i + 6 ) % 8 )) & 1 ) ^ ((imput >> ((i + 7 ) % 8 )) & 1 )) &lt;&lt; i;</p><p>}</p><p>Result = Result ^ 0x63 ;</p><p>return Result;</p><p>}</p><p>第八節：生成逆S盒的過程</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d28b99ad98864078b3802874a81531fe><p class=pgc-img-caption></p></div><p>可以發現逆S盒是先進行逆仿射映射，然後才計算乘法逆元的，這也是與S盒生成的不同之處，而逆仿射映射與仿射映射的結構是相同的，只不過8·8Bit矩陣的數值不同，最後異或的那個數字不是0x63而是0xA0。</p><div class=pgc-img><img alt=密碼學基礎：AES加密算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aa0f76f5d1e8457c9367dc4414d26296><p class=pgc-img-caption></p></div><p>筆者在這裡偷個懶，就不提供逆仿射映射的代碼盒過程了，大家有興趣可以自己實現下^_^!</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>加密算法</a></li><li><a>密碼</a></li><li><a>學基礎</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ecc07c69.html alt=密碼學基礎——偽隨機數生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/REjHSN258CdIig style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ecc07c69.html title=密碼學基礎——偽隨機數生成器>密碼學基礎——偽隨機數生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf07d31.html alt=自學寶典第二彈：密碼學基礎與應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6ecbd7bab6b34747999f9185137ed8b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf07d31.html title=自學寶典第二彈：密碼學基礎與應用>自學寶典第二彈：密碼學基礎與應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c527340.html alt=密碼學基礎知識概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/45282164103a45248fd611187792b874 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c527340.html title=密碼學基礎知識概述>密碼學基礎知識概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0939d38f.html alt="乾貨 | 材料科學基礎的108個知識點" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0939d38f.html title="乾貨 | 材料科學基礎的108個知識點">乾貨 | 材料科學基礎的108個知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9eb90942.html alt="Excel2016 如何對工作簿和表設置密碼，並設置只讀權限？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153397512017106e9ffbd78 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9eb90942.html title="Excel2016 如何對工作簿和表設置密碼，並設置只讀權限？">Excel2016 如何對工作簿和表設置密碼，並設置只讀權限？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cca5a74d.html alt=材料科學基礎108個知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5284c6ed4a9d4732b1e413ce7fc0225c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cca5a74d.html title=材料科學基礎108個知識點>材料科學基礎108個知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32ee6540.html alt=JAVA上加密算法的實現用例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6aa97b7dfebc473ebb4ea11cc67c6614 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32ee6540.html title=JAVA上加密算法的實現用例>JAVA上加密算法的實現用例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35d1d959.html alt=WiFi密碼被破解？攻擊方法離不開這四種 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/97202ff0b7bc4449bf383e67c70aba27 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35d1d959.html title=WiFi密碼被破解？攻擊方法離不開這四種>WiFi密碼被破解？攻擊方法離不開這四種</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ad3e14e.html alt=架構師基礎：對稱密鑰加密算法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/bfcf850c-1bdf-44e3-995d-1667bb3c3a02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ad3e14e.html title=架構師基礎：對稱密鑰加密算法？>架構師基礎：對稱密鑰加密算法？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1fe72d7a.html alt=心理學基礎知識之言語及思維 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1fe72d7a.html title=心理學基礎知識之言語及思維>心理學基礎知識之言語及思維</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/3f857cc1.html alt=解密數學的密碼-代數思想篇 （附初中代數總結以及常見考點） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/c9265d98-4fcd-4627-adb7-dfcadab94e80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/3f857cc1.html title=解密數學的密碼-代數思想篇 （附初中代數總結以及常見考點）>解密數學的密碼-代數思想篇 （附初中代數總結以及常見考點）</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/11daaf51.html alt=探索天賦密碼——皮紋測試 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/57e14adace6e4c7da40bbcf38b347dd2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/11daaf51.html title=探索天賦密碼——皮紋測試>探索天賦密碼——皮紋測試</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/ef46af08.html alt=中國臨床研究找到危重型胰腺炎致死“密碼” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/ef46af08.html title=中國臨床研究找到危重型胰腺炎致死“密碼”>中國臨床研究找到危重型胰腺炎致死“密碼”</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/d6603f86.html alt="自然| 解密紅樹林的“生態密碼”" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/514fe68bf44548ddb7793deb3188d117 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/d6603f86.html title="自然| 解密紅樹林的“生態密碼”">自然| 解密紅樹林的“生態密碼”</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/e08e8324.html alt=銅川市保密和密碼知識有獎競賽題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RqALLGVINNInKI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/e08e8324.html title=銅川市保密和密碼知識有獎競賽題>銅川市保密和密碼知識有獎競賽題</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>