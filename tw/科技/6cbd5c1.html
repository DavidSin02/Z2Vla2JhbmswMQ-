<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 | 极客快訊</title><meta property="og:title" content="正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><meta property="article:published_time" content="2020-10-29T21:05:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:37+08:00"><meta name=Keywords content><meta name=description content="正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6cbd5c1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p style=text-align:start>1）實驗平臺：正點原子開拓者FPGA 開發板</p><p style=text-align:start>2）摘自《開拓者FPGA開發指南》關注官方微信號公眾號，獲取更多資料：正點原子</p><p style=text-align:start>3）全套實驗源碼+手冊+視頻下載地址：http://www.openedv.com/thread-13912-1-1.html</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f><p class=pgc-img-caption></p></div><p><strong>第二十八章 EEPROM讀寫測試實驗</strong></p><p>EEPROM是一種用於計算機系統的非易失性存儲器，也常在嵌入式領域中作為數據的存儲設</p><p>備，在物聯網及可穿戴設備等需要存儲少量數據的場景中也有廣泛應用。本章我們學習EEPROM</p><p>的讀寫操作並進行EEPROM讀寫實驗。</p><p>本章包括以下幾個部分：</p><p>28.1 EEPROM簡介</p><p>28.2 實驗任務</p><p>28.3 硬件設計</p><p>28.4 程序設計</p><p>28.5 下載驗證</p><p><strong>EEPROM簡介</strong></p><p>EEPROM (Electrically Erasable Progammable Read Only Memory，E2PROM)即電可擦除</p><p>可編程只讀存儲器，是一種常用的非易失性存儲器（掉電數據不丟失），EEPROM有多種類型的</p><p>產品，我們開拓者FPGA開發板上使用的是ATMEL公司生產的AT24C系列的AT24C64這一型號。</p><p>AT24C64具有高可靠性，可對所存數據保存100年，並可多次擦寫，擦寫次數達一百萬次。</p><p>一般而言，對於存儲類型的芯片，我們比較關注其存儲容量。我們這次實驗所用的</p><p>AT24C64存儲容量為64Kbit，內部分成256頁，每頁32字節，共有8192個字節，且其讀寫操作都</p><p>是以字節為基本單位。可以把AT24C64看作一本書，那麼這本書有256頁，每頁有32行，每行有</p><p>8個字，總共有256*32*8=65536個字，對應著AT24C64的64*1024=65536個bit。</p><p>知道了AT24C64的存儲容量，就知道了讀寫的空間大小。那麼我們該如何對AT24C64進行讀</p><p>寫操作呢？</p><p>由於AT24C64採用兩線串行接口的雙向數據傳輸協議——I2C協議實現讀寫操作，所以我們</p><p>有必要了解一下I2C協議。</p><p>I2C即Inter-Integrated Circuit(集成電路總線），是由Philips半導體公司（現在的NXP</p><p>半導體公司）在八十年代初設計出來的一種簡單、雙向、二線制總線標準。多用於主機和從機</p><p>在數據量不大且傳輸距離短的場合下的主從通信。主機啟動總線，併產生時鐘用於傳送數據，</p><p>此時任何接收數據的器件均被認為是從機。</p><p>I2C總線由數據線SDA和時鐘線SCL構成通信線路，既可用於發送數據，也可接收數據。在</p><p>主控與被控IC之間可進行雙向數據傳送，數據的傳輸速率在標準模式下可達100kbit/s，在快</p><p>速模式下可達400kbit/s，在高速模式下可達3.4Mbit/s，各種被控器件均並聯在總線上，通過</p><p>器件地址（SLAVE ADDR，具體可查器件手冊）識別。我們開拓者I2C總線物理拓撲結構如下圖</p><p>所示。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f77db343b8f641e5994ea012ab2f809c><p class=pgc-img-caption></p></div><p>圖 28.1.1 開拓者I2C總線物理拓撲結構圖</p><p>圖中的I2C_SCL是串行時鐘線，I2C_SDA是串行數據線，由於I2C器件一般採用開漏結構與</p><p>總線相連，所以I2C_SCL和I2C_SDA均需接上拉電阻，也正因此，當總線空閒時，這兩條線路都</p><p>處於高電平狀態，當連到總線上的任一器件輸出低電平，都將使總線拉低，即各器件的SDA及</p><p>SCL都是“線與”關係。</p><p>I2C總線支持多主和主從兩種工作方式，通常工作在主從工作方式，我們的開發板就採用</p><p>主從工作方式。在主從工作方式中，系統中只有一個主機，其它器件都是具有I2C總線的外圍</p><p>從機。在主從工作方式中，主機啟動數據的發送（發出啟動信號）併產生時鐘信號，數據發送</p><p>完成後，發出停止信號。</p><p>I2C總線結構雖然簡單，使用兩線傳輸，然而要實現器件間的通信，需要通過控制SCL和SDA</p><p>的時序，使其滿足I2C的總線傳輸協議，方可實現器件間的數據傳輸。那麼I2C協議的時序是怎</p><p>樣的呢？</p><p>在I2C器件開始通信（傳輸數據）之前，串行時鐘線SCL和串行數據線SDA線由於上拉的原</p><p>因處於高電平狀態，此時I2C總線處於空閒狀態。如果主機（此處指FPGA）想開始傳輸數據，</p><p>只需在SCL為高電平時將SDA線拉低，產生一個起始信號，從機檢測到起始信號後，準備接收數</p><p>據，當數據傳輸完成，主機只需產生一個停止信號，告訴從機數據傳輸結束，停止信號的產生</p><p>是在SCL為高電平時，SDA從低電平跳變到高電平，從機檢測到停止信號後，停止接收數據。I2C</p><p>整體時序如下圖。起始信號之前為空閒狀態，起始信號之後到停止信號之前的這一段為數據傳</p><p>輸狀態，主機可以向從機寫數據，也可以讀取從機輸出的數據，數據的傳輸由雙向數據線（SDA）</p><p>完成。停止信號產生後，總線再次處於空閒狀態。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb444c6da96c493ebe5b1f3b4beedc79><p class=pgc-img-caption></p></div><p>圖 28.1.2 I2C整體時序圖</p><p>瞭解到了整體時序之後，我們可能有疑問，數據是以什麼樣的格式傳輸的呢？滿足怎樣的</p><p>時序要求呢？是在任何時候改變都可以嗎？怎麼知道從機有沒有接收到數據呢？帶著這些疑</p><p>問，我們繼續學習I2C。</p><p>由於只有一根數據線進行數據的傳輸，如果不規定好傳輸規則肯定會導致信息錯亂，如同</p><p>在單條道路上駕駛，沒有交通規則，再好的道路也會發生擁堵甚至更糟。採用兩線結構的I2C</p><p>雖然只有一根數據線，但由於還有一條時鐘線，可以讓數據線在時鐘線的帶領下有順序的傳送，</p><p>就好像單條道路上的車輛在交警或信號指示燈的指示下有規則的通行。那麼I2C遵循怎樣的規</p><p>則呢？</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d5fc8db0522e44af9743cc430ecb586d><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.3 I2C具體時序圖</p><p>如果要想回答這些問題，我們得讀懂圖 28.1.3。由圖 28.1.3可知，我們在起始信號之後，</p><p>主機開始發送傳輸的數據；在串行時鐘線SCL為低電平狀態時，SDA允許改變傳輸的數據位（1</p><p>為高電平，0為低電平），在SCL為高電平狀態時，SDA要求保持穩定，相當於一個時鐘週期傳</p><p>輸1bit數據，經過8個時鐘週期後，傳輸了8bit數據，即一個字節。第8個時鐘週期末，主機釋</p><p>放SDA以使從機應答，在第9個時鐘週期，從機將SDA拉低以應答；如果第9個時鐘週期，SCL為</p><p>高電平時，SDA未被檢測到為低電平，視為非應答，表明此次數據傳輸失敗。第9個時鐘週期末，</p><p>從機釋放SDA以使主機繼續傳輸數據，如果主機發送停止信號，此次傳輸結束。我們要注意的是數據以8bit即一個字節為單位串行發出，其最先發送的是字節的最高位。</p><p>I2C的時序部分已經基本介紹完了，但還有一個小問題，就是當多個I2C器件掛接在總線上</p><p>時，怎樣才能與我們想要傳輸數據的器件進行通信。這就涉及到了器件地址（也稱從機地址，</p><p>SLAVE ADDRESS）。</p><p>每個I2C器件都有一個器件地址，有些I2C器件的器件地址是固定的，而有些I2C器件的器</p><p>件地址由一個固定部分和一個可編程的部分構成，這是因為很可能在一個系統中有幾個同樣的</p><p>器件，器件地址的可編程部分能最大數量的使這些器件連接到I2C總線上，例如EEPROM器件，</p><p>為了增加系統的EEPROM容量，可能需要多個EEPROM。器件可編程地址位的數量由它可使用的管</p><p>腳決定，比如EEPROM器件一般會留下3個管腳用於可編程地址位。但有些I2C器件在出廠時器件</p><p>地址就設置好了，用戶不可以更改（如實時時鐘PCF8563的器件地址為固定的7’h51）。所以</p><p>當主機想給某個器件發送數據時，只需向總線上發送接收器件的器件地址即可。</p><p>對於AT24C64而言，其器件地址為1010加3位的可編程地址，3位可編程地址由器件上的3個</p><p>管腳A2、A1、A0（見圖 28.3.2）的硬件連接決定。當硬件電路上分別將這三個管腳連接到GND</p><p>或VCC時，就可以設置不同的可編程地址。對於我們的開發板，這3個管腳連接到地。</p><p>進行數據傳輸時，主機首先向總線上發出開始信號，對應開始位S，然後按照從高到低的</p><p>位序發送器件地址，一般為7bit，第8bit位為讀寫控制位R/W，該位為0時表示主機對從機進行</p><p>寫操作，當該位為1時表示主機對從機進行讀操作，然後接收從機響應。對於AT24C64來說，其</p><p>傳輸器件地址格式如下圖所示。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1d7f80efcc924cdbaf91de9c1a71351c><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.4 器件地址格式示意圖</p><p>發送完第一個字節（7位器件地址和一位讀寫控制位）並收到從機正確的應答後就開始發</p><p>送字地址（Word Address）。一般而言，每個兼容I2C協議的器件，內部總會有可供讀寫的寄</p><p>存器或存儲器，對於我們本次實驗用到的EEPROM存儲器，內部就是一系列順序編址的存儲單元。</p><p>所以，當我們對一個器件中的存儲單元（包括寄存器）進行讀寫時，首先要指定存儲單元的地</p><p>址即字地址，然後再向該地址寫入內容。該地址為一個或兩個字節長度，具體長度由器件內部</p><p>的存儲單元的數量決定，當存儲單元數量不超過一個字節所能表示的最大數量（2^8=256）時，</p><p>用一個字節表示，超過一個字節所能表示的最大數量時，就需要用兩個字節來表示，例如同是</p><p>EEPROM存儲器，AT24C02的存儲單元容量為2Kbit=256Byte（一般bit縮寫為b，Byte縮寫為B），用一個字節地址即可尋址所有的存儲單元，而AT24C64的存儲單元容量為64Kb=8KB，需要13位</p><p>（2^13=8KB）的地址位，而I2C又是以字節為單位進行傳輸的，所以需要用兩個字節地址來尋</p><p>址整個存儲單元。圖 28.1.4 和圖 28.1.5分別為單字節字地址和雙字節字地址器件的地址分</p><p>布圖，其中單字節字地址的器件是以存儲容量為2Kb的EEPROM存儲器AT24C02為例，雙字節字地</p><p>址的器件是以存儲容量為64Kb的EEPROM存儲器AT24C64為例，WA7即字地址Word Address的第7</p><p>位，以此類推，用WA是為了區別前面器件地址中的A。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d588fe8afe954c27813c10dcb77c7a22><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.4 單字節字地址分佈</p><p><br></p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e4842632f9e2472b9bb8630f3d079f61><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.5 雙字節字地址分佈</p><p>主機發送完字地址，從機正確應答後就把內部的存儲單元地址指針指向該單元。如果讀寫</p><p>控制位R/W位為“0”即寫命令，從機就處於接收數據的狀態，此時，主機就開始寫數據了。寫</p><p>數據分為單次寫（對於EEPROM而言，稱為字節寫）和連續寫（對於EEPROM而言，稱為頁寫），</p><p>那麼這兩者有什麼區別呢？對比圖 28.1.6和圖 28.1.7可知，兩者的區別在於發送完一字節</p><p>數據後，是發送結束信號還是繼續發送下一字節數據，如果發送的是結束信號，就稱為單次寫，</p><p>如果繼續發送下一字節數據，就稱為連續寫。圖 28.1.6是AT24C64的單次寫（字節寫）時序，對於字地址為單字節的I2C器件而言，在發送完字地址（對應圖 28.1.6的字地址高位），且從</p><p>機應答後即可串行發送8bit數據。圖 28.1.7是AT24C64連續寫（頁寫）時序。要注意的是，對</p><p>於AT24C64的頁寫，是不能發送超過一頁的單元容量的數據的，而AT24C64的一頁的單元容量為</p><p>32Byte，當寫完一頁的最後一個單元時，地址指針指向該頁的開頭，如果再寫入數據，就會覆</p><p>蓋該頁的起始數據。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b82d267760574f90aaaaa568bb15a3e3><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.6 單次寫（字節寫）時序</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52912b281c6144ca919e68dc5442a371><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.7 連續寫（頁寫）時序</p><p>如果讀寫控制位R/W位為“1”即讀命令，主機就處於接收數據的狀態，從機從該地址單元</p><p>輸出數據。讀數據有三種方式：當前地址讀、隨機讀和連續讀。當前地址讀是指在一次讀或寫</p><p>操作後發起讀操作。由於I2C器件在讀寫操作後，其內部的地址指針自動加一，因此當前地址</p><p>讀可以讀取下一個字地址的數據。也就是說上次讀或寫操作的單元地址為02時，當前地址讀的內容就是地址03處的單元數據，時序圖如圖 28.1.8所示。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1010474168f946b8a94cc7534e7be905><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.8 當前地址讀時序</p><p>由於當前地址讀極不方便讀取任意的地址單元的數據，所以就有了隨機讀，隨機讀的時序</p><p>有點奇怪，見圖 28.1.9，發送完器件地址和字地址後，竟然又發送起始信號和器件地址，而</p><p>且第一次發送器件地址時後面的讀寫控制位為“0”，也就是寫命令，第二次發送器件地址時</p><p>後面的讀寫控制位為“1”，也就是讀。為什麼會有這樣奇怪的操作呢？這是因為我們需要使</p><p>從機內的存儲單元地址指針指向我們想要讀取的存儲單元地址處，所以首先發送了一次Dummy</p><p>Write也就是虛寫操作，只所以稱為虛寫，是因為我們並不是真的要寫數據，而是通過這種虛</p><p>寫操作使地址指針指向虛寫操作中字地址的位置，等從機應答後，就可以以當前地址讀的方式</p><p>讀數據了，如圖 28.1.9所示，隨機地址讀是沒有發送數據的單次寫操作和當前地址讀操作的</p><p>結合體。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/17bf56456294400aa3a716309225a84c><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.1.9 隨機地址讀時序</p><p>至於連續讀，對應的是當前地址讀和隨機讀都是一次讀取一個字節而言的，它是將當前地</p><p>址讀或隨機讀的主機非應答改成應答，表示繼續讀取數據，圖 28.1.10是在當前地址讀下的連</p><p>續讀。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1fd48149af604cb0a7b6c6d508a07d2b><p class=pgc-img-caption></p></div><p>圖 28.1.10 順序讀時序</p><p>至此，I2C協議就基本講完了，本章我們主要採用單次寫和隨機讀方式進行EEPROM讀寫測</p><p>試。</p><p><strong>實驗任務</strong></p><p>本次實驗任務是先通過FPGA從EEPROM（AT24C64）的存儲器地址0至存儲器地址255分別寫</p><p>入數據0~255；寫完之後再開始讀取存儲器地址0~ 255中的數據，若讀取的值正確則LED燈常亮，</p><p>否則LED燈閃爍。</p><p><strong>硬件設計</strong></p><p>AT24C64芯片的常用封裝形式有直插（DIP8）式和貼片（SO-8）式兩種，無論是直插式還</p><p>是貼片式，其引腳功能與序號都一樣，我們開發板上採用的是貼片式，實物圖和引腳圖分別如</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2216e1f820c44a96a067be20d64bf0f7><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.3.1和圖 28.3.2所示。</p><p>圖 28.3.1 開發板上的AT24C64實物圖</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1fc0801ba14d429fafb2809d75da5bbd><p class=pgc-img-caption></p></div><p>AT24C64的引腳功能如下：</p><p>A2,A1,A0：可編程地址輸入端。</p><p>GND：電源地引腳</p><p>SDA：SDA（Serial Data，串行數據）是雙向串行數據輸入/輸出端。</p><p>SCL：SCL（Serial clock，串行時鐘）串行時鐘輸入端。</p><p>WP（寫保護）：AT24C64有一個寫保護引腳用於提供數據保護，當寫保護引腳連接至GND時，</p><p>芯片可以正常寫，當寫保護引腳連接至VCC時，使能寫保護功能，此時禁止向芯片寫入數據，</p><p>只能進行讀操作。</p><p>VCC：電源輸入引腳</p><p>我們的開拓者FPGA開發板上EEPROM的原理圖如圖 28.3.3所示：</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/26096342278f4f0b80e803e139ae8e7b><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.3.3 EEPROM原理圖</p><p>由上圖可知，我們開發板上的EEPROM可編程地址A2、A1、A0連接到地，所以AT24C64的器</p><p>件地址為1010000，如下圖所示：</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d85285418b241b0a4e11df321c6ed90><p class=pgc-img-caption></p></div><p>圖 28.3.4 AT24C64的器件地址</p><p>本實驗中，系統時鐘、按鍵復位以及EEPROM的SCL和SDA的管腳分配如下表所示：</p><p>表 28.3.1 串口通信實驗管腳分配</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e745209797349668f21a36b131d2f3d><p class=pgc-img-caption></p></div><p><strong>程序設計</strong></p><p>根據實驗任務，我們可以大致規劃出系統的控制流程：首先FPGA向EEPROM寫數據，寫完之</p><p>後從EEPROM讀出所寫入的數據，並判斷讀出的數據與寫入的數據是否相同，如果相同則LED燈</p><p>常亮，否則LED燈閃爍。由此畫出系統的功能框圖如下圖所示：</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7127ca624edf41abafbdf2611da40bf9><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.4.1 EEPROM讀寫實驗系統框圖</p><p>由系統總體框圖可知，FPGA部分包括四個模塊，頂層模塊（e2prom_top）、讀寫模塊</p><p>（e2prom_rw）、I2C驅動模塊（i2c_dri）和LED燈顯示模塊（led_alarm）。其中在頂層模塊</p><p>中完成對I2C驅動模塊的例化。</p><p>各模塊端口及信號連接如圖 28.4.2所示：</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2c112965e25246f597f020dfc2e8e1a2><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.4.2 頂層模塊原理圖</p><p>i2c_dri為I2C驅動模塊，用來驅動I2C的讀寫操作。當FPGA通過EEPROM讀寫模塊e2prom_rw</p><p>向EEPROM讀寫數據時，拉高i2c觸發控制信號i2c_exec以使能I2C驅動模塊，並使用讀寫控制信</p><p>號i2c_rh_wl控制讀寫操作，當i2c_rh_wl為低電平時，I2C驅動模塊i2c_dri執行寫操作，當</p><p>i2c_rh_wl為高電平時，I2C驅動模塊i2c_dri執行讀操作。此外，e2prom_rw模塊通過i2c_addr</p><p>接口向i2c_dri模塊輸入器件字地址，通過i2c_data_w接口向i2c_dri模塊輸入寫的數據，並通</p><p>過i2c_data_r接口讀取i2c_dri模塊讀到的數據。error_flag是錯誤標誌，用來控制led的顯示</p><p>狀態。</p><p>頂層模塊的代碼如下：</p><p>1 <strong>module </strong>e2prom_top<strong>(</strong></p><p>2 //system clock</p><p>3 <strong>input</strong> sys_clk <strong>,</strong> // 系統時鐘</p><p>4 <strong>input</strong> sys_rst_n <strong>,</strong> // 系統復位</p><p>5 //eeprom interface</p><p>6 <strong>output</strong> scl <strong>,</strong> // eeprom的時鐘線scl</p><p>7 <strong>inout</strong> sda <strong>,</strong> // eeprom的數據線sda</p><p>8 //user interface</p><p>9 <strong>output</strong> <strong>[</strong>3<strong>:</strong>0<strong>] </strong>led // led顯示</p><p>10 <strong>);</strong></p><p>11</p><p>12 //parameter define</p><p>13 <strong>parameter</strong> SLAVE_ADDR <strong>=</strong> 7'b1010000 <strong>; </strong>// 器件地址</p><p>14 <strong>parameter</strong> BIT_CTRL <strong>=</strong> 1'b1 <strong>; </strong>// 字地址位控制參數(16b/8b)</p><p>15 <strong>parameter</strong> CLK_FREQ <strong>= </strong>26'd50_000_000<strong>; </strong>// i2c_dri模塊的驅動時鐘頻率</p><p>16 <strong>parameter</strong> I2C_FREQ <strong>= </strong>18'd250_000 <strong>; </strong>// I2C的SCL時鐘頻率</p><p>17 <strong>parameter</strong> L_TIME <strong>= </strong>17'd125_000 <strong>; </strong>// led閃爍時間參數</p><p>18</p><p>19 //reg define</p><p>20 <strong>reg</strong> <strong>[</strong>25<strong>:</strong>0<strong>]</strong> cnt <strong>;</strong> // 計數</p><p>21 <strong>reg</strong> <strong>[ </strong>1<strong>:</strong>0<strong>]</strong> flow_cnt <strong>;</strong> // 狀態流控制</p><p>22 <strong>reg</strong> <strong>[</strong>13<strong>:</strong>0<strong>]</strong> wait_cnt <strong>;</strong> // 等待計數</p><p>23</p><p>24 //wire define</p><p>25 <strong>wire</strong> clk <strong>;</strong> // I2C操作時鐘</p><p>26 <strong>wire</strong> i2c_exec <strong>;</strong> // i2c觸發控制</p><p>27 <strong>wire</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> i2c_addr <strong>;</strong> // i2c操作地址</p><p>28 <strong>wire</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_w<strong>;</strong> // i2c寫入的數據</p><p>29 <strong>wire</strong> i2c_done <strong>;</strong> // i2c操作結束標誌</p><p>30 <strong>wire</strong> i2c_rh_wl <strong>;</strong> // i2c讀寫控制</p><p>31 <strong>wire</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_r<strong>;</strong> // i2c讀出的數據</p><p>32 <strong>wire</strong> error_flag<strong>;</strong> // 錯誤標誌</p><p>33</p><p>34 //*****************************************************</p><p>35 //** main code</p><p>36 //*****************************************************</p><p>37</p><p>38 //例化e2prom讀寫模塊</p><p>39 e2prom_rw u_e2prom_rw <strong>(</strong></p><p>40 //global clock</p><p>41 <strong>.</strong>clk <strong>(</strong>clk <strong>),</strong> // 時鐘信號</p><p>42 <strong>.</strong>rst_n <strong>(</strong>sys_rst_n <strong>),</strong> // 復位信號</p><p>43 //i2c interface</p><p>44 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C觸發執行信號</p><p>45 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl <strong>),</strong> // I2C讀寫控制信號</p><p>46 <strong>.</strong>i2c_addr <strong>(</strong>i2c_addr <strong>),</strong> // I2C器件內地址</p><p>47 <strong>.</strong>i2c_data_w <strong>(</strong>i2c_data_w<strong>),</strong> // I2C要寫的數據</p><p>48 <strong>.</strong>i2c_data_r <strong>(</strong>i2c_data_r<strong>),</strong> // I2C讀出的數據</p><p>49 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I2C一次操作完成</p><p>50 //user interface</p><p>51 <strong>.</strong>error_flag <strong>(</strong>error_flag<strong>)</strong> // 錯誤標誌</p><p>52 <strong>);</strong></p><p>53</p><p>54 //例化i2c_dri</p><p>55 i2c_dri <strong>#(</strong></p><p>56 <strong>.</strong>SLAVE_ADDR <strong>(</strong>SLAVE_ADDR<strong>),</strong> // slave address從機地址，放此處方便參數傳遞</p><p>57 <strong>.</strong>CLK_FREQ <strong>(</strong>CLK_FREQ <strong>),</strong> // i2c_dri模塊的驅動時鐘頻率(CLK_FREQ)</p><p>58 <strong>.</strong>I2C_FREQ <strong>(</strong>I2C_FREQ <strong>)</strong> // I2C的SCL時鐘頻率</p><p>59 <strong>) </strong>u_i2c_dri<strong>(</strong></p><p>60 //global clock</p><p>61 <strong>.</strong>clk <strong>(</strong>sys_clk <strong>),</strong> // i2c_dri模塊的驅動時鐘(CLK_FREQ)</p><p>62 <strong>.</strong>rst_n <strong>(</strong>sys_rst_n <strong>),</strong> // 復位信號</p><p>63 //i2c interface</p><p>64 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C觸發執行信號</p><p>65 <strong>.</strong>bit_ctrl <strong>(</strong>BIT_CTRL <strong>),</strong> // 器件地址位控制(16b/8b)</p><p>66 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl <strong>),</strong> // I2C讀寫控制信號</p><p>67 <strong>.</strong>i2c_addr <strong>(</strong>i2c_addr <strong>),</strong> // I2C器件內地址</p><p>68 <strong>.</strong>i2c_data_w <strong>(</strong>i2c_data_w<strong>),</strong> // I2C要寫的數據</p><p>69 <strong>.</strong>i2c_data_r <strong>(</strong>i2c_data_r<strong>),</strong> // I2C讀出的數據</p><p>70 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I 2C一次操作完成</p><p>71 <strong>.</strong>scl <strong>(</strong>scl <strong>),</strong> // I2C的SCL時鐘信號</p><p>72 <strong>.</strong>sda <strong>(</strong>sda <strong>),</strong> // I2C的SDA信號</p><p>73 //user interface</p><p>74 <strong>.</strong>dri_clk <strong>(</strong>clk <strong>)</strong> // I2C操作時鐘</p><p>75 <strong>);</strong></p><p>76</p><p>77 //例化led_alarm模塊</p><p>78 led_alarm <strong>#(.</strong>L_TIME<strong>(</strong>L_TIME <strong>)</strong> // 控制led閃爍時間</p><p>79 <strong>) </strong>u_led_alarm<strong>(</strong></p><p>80 //system clock</p><p>81 <strong>.</strong>clk <strong>(</strong>sys_clk <strong>),</strong> // 時鐘信號</p><p>82 <strong>.</strong>rst_n <strong>(</strong>sys_rst_n <strong>),</strong> // 復位信號</p><p>83 //led interface</p><p>84 <strong>.</strong>led <strong>(</strong>led <strong>),</strong> // LED燈</p><p>85 //user interface</p><p>86 <strong>.</strong>error_flag <strong>(</strong>error_flag<strong>)</strong> // 錯誤標誌</p><p>87 <strong>);</strong></p><p>88 <strong>endmodule</strong></p><p>頂層模塊中主要完成對其餘模塊的例化，需要注意的是程序第13行到第17行定義了五個參</p><p>數，在模塊例化時會將這些變量傳遞到相應的模塊。</p><p>當程序用於讀寫不同器件地址的EEPROM時將SLAVE_ADDR修改為新的器件地址；字地址位控</p><p>制參數(16b/8b)BIT_CTRL是用來控制不同字地址的I2C器件讀寫時序中字地址的位數，當I2C器</p><p>件的字地址為16位時，參數BIT_CTRL設置為“1”，當I2C器件的字地址為8位時，參數BIT_CTRL</p><p>設置為“0”；i2c_dri模塊的驅動時鐘頻率CLK_FREQ是指在例化I2C驅動模塊i2c_dri時，驅動</p><p>i2c_dri模塊的時鐘頻率；I2C的SCL時鐘頻率參數I2C_FREQ是用來控制I2C協議中的SCL的頻率，</p><p>一般不超過400KHz；led閃爍時間參數L_TIME用來控制led的閃爍間隔時間，參數值與驅動該模</p><p>塊的clk時鐘頻率有關。例如，控制led閃爍的間隔時間為0.25s，clk的頻率為1MHz時，</p><p>0.25s/1us=250000，由於代碼中當計數器計數到L_TIME的值時，LED的狀態改變一次，LED高電</p><p>平加上低電平的時間才是一次閃爍的時間，所以L_TIME的值應定義成125000。</p><p>由前面的I2C讀寫操作時序圖我們可以發現，I2C驅動模塊非常適合採用狀態機來編寫。無</p><p>論是字節寫（圖 28.1.6）還是隨機讀（圖 28.1.9），都要先從空閒狀態開始，先發送起始信</p><p>號，然後發送器件地址和讀寫命令（這裡為了方便表示我們使用“控制命令”來表示器件地址</p><p>和讀寫命令）。發送完控制命令並接收應答信號後發送字地址，然後就可以進行讀寫數據的傳</p><p>輸了。讀寫數據傳輸結束後接收應答信號，最後發送停止信號，此時I2C讀寫操作結束，再次</p><p>進入空閒狀態。</p><p>狀態機的狀態跳轉圖如下所示，總共有8個狀態，一開始狀態機處於空閒狀態st_idle，當</p><p>I2C觸發執行信號觸發（i2c_exec=1）時，狀態機進入發送控制命令狀態st_sladdr；發送完控</p><p>制命令後就發送字地址，這裡出於簡單考慮，不對從機EEPROM的應答信號進行判斷。由於字地</p><p>址存在單字節和雙字節的區別，我們通過bit_ctrl信號判斷是單字節還是雙字節字地址。對於</p><p>雙字節的字地址我們先發送高8位即第一個字節，發送完高8位後進入發送8位字地址狀態st_addr8，也就是發送雙字節地地址的低8位；對於單字節的字地址我們直接進入發送8位字地址</p><p>狀態st_addr8。發送完字地址後，根據讀寫判斷標誌來判斷是讀操作還是寫操作。如果是寫</p><p>（wr_flag=0）就進入寫數據狀態st_data_wr，開始向EEPROM發送數據；如果是讀（wr_flag=1）</p><p>就進入發送器件地址讀狀態st_addr_rd發送器件地址，此狀態結束後就進入讀數據狀態</p><p>st_data_rd接收EEPROM輸出的數據。讀或寫數據結束後就進入結束I2C操作狀態st_done併發送</p><p>結束信號，此時，I2C總線再次進入空閒狀態st_idle。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01c57d8ea1724026bf74ef0af3c47395><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.4.3 I2C驅動模塊狀態跳轉圖</p><p>在程序中我們採用三段式狀態機。由於代碼較長，我們在這裡將其中第二段的源代碼粘貼</p><p>如下：</p><p>105 //組合邏輯判斷狀態轉移條件</p><p>106 <strong>always @( * ) begin</strong></p><p>107 next_state <strong>= </strong>st_idle<strong>;</strong></p><p>108 <strong>case(</strong>cur_state<strong>)</strong></p><p>109 st_idle<strong>: begin</strong> // 空閒狀態</p><p>110 <strong>if(</strong>i2c_exec<strong>) begin</strong></p><p>111 next_state <strong>= </strong>st_sladdr<strong>;</strong></p><p>112 <strong>end</strong></p><p>113 <strong>else</strong></p><p>114 next_state <strong>= </strong>st_idle<strong>;</strong></p><p>115 <strong>end</strong></p><p>116 st_sladdr<strong>: begin</strong></p><p>117 <strong>if(</strong>st_done<strong>) begin</strong></p><p>118 <strong>if(</strong>bit_ctrl<strong>)</strong> // 判斷是16位還是8位字地址</p><p>119 next_state <strong>= </strong>st_addr16<strong>;</strong></p><p>120 <strong>else</strong></p><p>121 next_state <strong>= </strong>st_addr8 <strong>;</strong></p><p>122 <strong>end</strong></p><p>123 <strong>else</strong></p><p>124 next_state <strong>= </strong>st_sladdr<strong>;</strong></p><p>125 <strong>end</strong></p><p>126 st_addr16<strong>: begin</strong> // 寫16位字地址</p><p>127 <strong>if(</strong>st_done<strong>) begin</strong></p><p>128 next_state <strong>= </strong>st_addr8<strong>;</strong></p><p>129 <strong>end</strong></p><p>130 <strong>else begin</strong></p><p>131 next_state <strong>= </strong>st_addr16<strong>;</strong></p><p>132 <strong>end</strong></p><p>133 <strong>end</strong></p><p>134 st_addr8<strong>: begin</strong> // 8位字地址</p><p>135 <strong>if(</strong>st_done<strong>) begin</strong></p><p>136 <strong>if(</strong>wr_flag<strong>==</strong>1'b0<strong>)</strong> // 讀寫判斷</p><p>137 next_state <strong>= </strong>st_data_wr<strong>;</strong></p><p>138 <strong>else</strong></p><p>139 next_state <strong>= </strong>st_addr_rd<strong>;</strong></p><p>140 <strong>end</strong></p><p>141 <strong>else begin</strong></p><p>142 next_state <strong>= </strong>st_addr8</p><p>143 <strong>end</strong></p><p>144 <strong>end</strong></p><p>145 st_data_wr<strong>: begin</strong> // 寫數據(8 bit)</p><p>146 <strong>if(</strong>st_done<strong>)</strong></p><p>147 next_state <strong>= </strong>st_stop<strong>;</strong></p><p>148 <strong>else</strong></p><p>149 next_state <strong>= </strong>st_data_wr<strong>;</strong></p><p>150 <strong>end</strong></p><p>151 st_addr_rd<strong>: begin</strong> // 寫地址以進行讀數據</p><p>152 <strong>if(</strong>st_done<strong>) begin</strong></p><p>153 next_state <strong>= </strong>st_data_rd<strong>;</strong></p><p>154 <strong>end</strong></p><p>155 <strong>else begin</strong></p><p>156 next_state <strong>= </strong>st_addr_rd<strong>;</strong></p><p>157 <strong>end</strong></p><p>158 <strong>end</strong></p><p>159 st_data_rd<strong>: begin</strong> // 讀取數據(8 bit)</p><p>160 <strong>if(</strong>st_done<strong>)</strong></p><p>161 next_state <strong>= </strong>st_stop<strong>;</strong></p><p>162 <strong>else</strong></p><p>163 next_state <strong>= </strong>st_data_rd<strong>;</strong></p><p>164 <strong>end</strong></p><p>165 st_stop<strong>: begin</strong> // 結束I2C操作</p><p>166 <strong>if(</strong>st_done<strong>)</strong></p><p>167 next_state <strong>= </strong>st_idle<strong>;</strong></p><p>168 <strong>else</strong></p><p>169 next_state <strong>= </strong>st_stop <strong>;</strong></p><p>170 <strong>end</strong></p><p>171 <strong>default: </strong>next_state<strong>= </strong>st_idle<strong>;</strong></p><p>172 <strong>endcase</strong></p><p>173 <strong>end</strong></p><p>我們可以對照著圖 28.4.3來分析程序中各狀態之間是如何跳轉的。</p><p>EEPROM讀寫模塊主要實現對I2C讀寫過程的控制，包括給出字地址及需要寫入該地址中的數據、啟動I2C讀寫操作、判斷讀寫數據是否一致等。EEPROM讀寫模塊的代碼如下：</p><p>1 <strong>module </strong>e2prom_rw<strong>(</strong></p><p>2 //global clock</p><p>3 <strong>input</strong> clk <strong>,</strong> // 時鐘信號</p><p>4 <strong>input</strong> rst_n <strong>,</strong> // 復位信號</p><p>5</p><p>6 //i2c interface</p><p>7 <strong>output</strong> i2c_rh_wl <strong>,</strong> // I2C讀寫控制信號</p><p>8 <strong>output</strong> <strong>reg</strong> i2c_exec <strong>,</strong> // I2C觸發執行信號</p><p>9 <strong>output</strong> <strong>reg</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> i2c_addr <strong>,</strong> // I2C器件字地址</p><p>10 <strong>output</strong> <strong>reg</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_w <strong>,</strong> // I2C要寫的數據</p><p>11 <strong>input</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_r <strong>,</strong> // I2C讀出的數據</p><p>12 <strong>input</strong> i2c_done <strong>,</strong> // I2C一次操作完成</p><p>13</p><p>14 //user interface</p><p>15 <strong>output</strong> <strong>reg</strong> error_flag // 錯誤標誌</p><p>16 <strong>);</strong></p><p>17</p><p>18 //parameter define</p><p>19 <strong>parameter</strong> WAIT <strong>= </strong>14'd5000 <strong>;</strong> // 讀寫等待時間</p><p>20 <strong>parameter</strong> BYTE_N <strong>= </strong>16'd255 <strong>;</strong> // 讀寫的字節數</p><p>21</p><p>22 //reg define</p><p>23 <strong>reg</strong> addr_over <strong>;</strong> // 地址結束標誌</p><p>24 <strong>reg</strong> rom_w_done<strong>;</strong> // 字節全部寫入e2prom的標誌</p><p>25 <strong>reg</strong> <strong>[ </strong>1<strong>:</strong>0<strong>]</strong> flow_cnt <strong>;</strong> // 狀態流控制</p><p>26 <strong>reg</strong> <strong>[</strong>13<strong>:</strong>0<strong>]</strong> wait_cnt <strong>;</strong> // 等待計數</p><p>27</p><p>28 //*****************************************************</p><p>29 //** main code</p><p>30 //*****************************************************</p><p>31</p><p>32 //讀寫控制</p><p>33 <strong>assign </strong>i2c_rh_wl <strong>= </strong>addr_over <strong>& </strong>rom_w_done<strong>;</strong></p><p>34</p><p>35 //eeprom字節地址配置</p><p>36 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>37 <strong>if(</strong>rst_n <strong>== </strong>1'b0<strong>) begin</strong></p><p>38 i2c_addr <strong>&lt;= </strong>16'd0<strong>;</strong></p><p>39 addr_over<strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>40 <strong>end</strong></p><p>41 <strong>else if(</strong>i2c_done <strong>== </strong>1'b1<strong>) begin</strong></p><p>42 <strong>if(</strong>i2c_rh_wl <strong>== </strong>1'b1<strong>) begin</strong></p><p>43 <strong>if(</strong>i2c_addr <strong>&lt; </strong>BYTE_N<strong>)</strong></p><p>44 i2c_addr <strong>&lt;= </strong>i2c_addr <strong>+ </strong>1'd1<strong>;</strong></p><p>45 <strong>else</strong></p><p>46 i2c_addr <strong>&lt;= </strong>i2c_addr<strong>;</strong></p><p>47 <strong>end</strong></p><p>48 <strong>else begin</strong></p><p>49 <strong>if(</strong>i2c_addr <strong>== </strong>BYTE_N<strong>) begin</strong></p><p>50 i2c_addr <strong>&lt;= </strong>16'd0<strong>;</strong></p><p>51 addr_over<strong>&lt;=</strong> 1'b1<strong>;</strong> //寫完指定地址標誌</p><p>52 <strong>end</strong></p><p>53 <strong>else</strong></p><p>54 i2c_addr <strong>&lt;= </strong>i2c_addr <strong>+ </strong>1'd1<strong>;</strong></p><p>55 <strong>end</strong></p><p>56 <strong>end</strong></p><p>57 <strong>else</strong></p><p>58 i2c_addr <strong>&lt;= </strong>i2c_addr<strong>;</strong></p><p>59 <strong>end</strong></p><p>60</p><p>61 //讀寫eeprom</p><p>62 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>63 <strong>if(</strong>rst_n <strong>== </strong>1'b0<strong>) begin</strong></p><p>64 flow_cnt <strong>&lt;=</strong> 2'b0<strong>;</strong></p><p>65 wait_cnt <strong>&lt;= </strong>14'b0<strong>;</strong></p><p>66 i2c_exec <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>67 i2c_data_w <strong>&lt;=</strong> 8'd0<strong>;</strong></p><p>68 rom_w_done <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>69 error_flag <strong>&lt;=</strong> 1'b1<strong>;</strong></p><p>70 <strong>end</strong></p><p>71 <strong>else begin</strong></p><p>72 i2c_exec <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>73 //從eeprom的第1頁的第1個字節到第16頁的第16個字節(共256字節)寫入數據0~255</p><p>74 <strong>if(</strong>i2c_rh_wl <strong>== </strong>1'b0<strong>) begin</strong></p><p>75 <strong>case(</strong>flow_cnt<strong>)</strong></p><p>76 2'd0<strong>: begin</strong></p><p>77 rom_w_done <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>78 wait_cnt <strong>&lt;= </strong>wait_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>79 <strong>if(</strong>wait_cnt <strong>== </strong>14'd100<strong>) begin</strong></p><p>80 wait_cnt <strong>&lt;= </strong>14'd0<strong>;</strong></p><p>81 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>82 <strong>end</strong></p><p>83 <strong>end</strong></p><p>84 2'd1<strong>: begin</strong></p><p>85 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>86 i2c_data_w <strong>&lt;= </strong>i2c_addr<strong>[</strong>7<strong>:</strong>0<strong>];</strong></p><p>87 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>88 <strong>end</strong></p><p>89 2'd2<strong>: begin</strong></p><p>90 <strong>if(</strong>i2c_done <strong>== </strong>1'b1<strong>)</strong></p><p>91 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>92 <strong>end</strong></p><p>93 2'd3<strong>:begin</strong></p><p>94 <strong>if(</strong>wait_cnt <strong>== </strong>WAIT<strong>) begin</strong> //寫間隔控制</p><p>95 flow_cnt <strong>&lt;=</strong> 2'b0<strong>;</strong></p><p>96 wait_cnt <strong>&lt;= </strong>14'd0<strong>;</strong></p><p>97 rom_w_done <strong>&lt;=</strong> 1'b1<strong>;</strong></p><p>98 <strong>end</strong></p><p>99 <strong>else</strong></p><p>100 wait_cnt <strong>&lt;= </strong>wait_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>101 <strong>end</strong></p><p>102 <strong>endcase</strong></p><p>103 <strong>end</strong></p><p>104 //讀取從eeprom的第1頁的第1個字節開始的共256字節的值並判斷值是否正確</p><p>105 <strong>else begin</strong></p><p>106 <strong>case(</strong>flow_cnt<strong>)</strong></p><p>107 2'd0<strong>: begin</strong></p><p>108 wait_cnt <strong>&lt;= </strong>wait_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>109 <strong>if(</strong>wait_cnt <strong>== </strong>14'd100<strong>) begin</strong></p><p>110 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>111 wait_cnt <strong>&lt;= </strong>14'd0<strong>;</strong></p><p>112 <strong>end</strong></p><p>113 <strong>end</strong></p><p>114 2'd1<strong>: begin</strong></p><p>115 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>116 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>117 <strong>end</strong></p><p>118 2'd2<strong>: begin</strong></p><p>119 <strong>if(</strong>i2c_done <strong>== </strong>1'b1<strong>) begin</strong> // 判斷I2C操作是否完成</p><p>120 <strong>if(</strong>i2c_addr<strong>[</strong>7<strong>:</strong>0<strong>] == </strong>i2c_data_r<strong>) begin</strong> // 判斷讀到的值正確與否</p><p>121 error_flag <strong>&lt;= </strong>1'b0<strong>;</strong> // 讀到的值正確</p><p>122 flow_cnt <strong>&lt;= </strong>2'b0<strong>;</strong> // 返回狀態0</p><p>123 <strong>end</strong></p><p>124 <strong>else begin</strong></p><p>125 error_flag <strong>&lt;= </strong>1'b1<strong>;</strong> // 讀到的值錯誤</p><p>126 <strong>end</strong></p><p>127 <strong>end</strong></p><p>128 <strong>end</strong></p><p>129 <strong>default: </strong>flow_cnt <strong>&lt;= </strong>2'b0<strong>;</strong></p><p>130 <strong>endcase</strong></p><p>131 <strong>end</strong></p><p>132 <strong>end</strong></p><p>133 <strong>end</strong></p><p>134</p><p>135 <strong>endmodule</strong></p><p>程序中第62行的always塊是讀寫控制塊，具體是讀還是寫由I2C讀寫控制信號i2c_rh_wl決</p><p>定。當該信號為低電平時，為寫數據操作，從EEPROM的存儲地址0開始，每寫入一個字節的數</p><p>據，地址加1，直至寫入指定的字節數（BYTE_N）。當寫最後一個存儲地址結束後，寫EEPROM</p><p>結束的標誌信號rom_w_done拉高，寫數據過程結束。由程序第33行可知，此時i2c_rh_wl為高</p><p>電平，程序進入讀數據過程。由於寫入每個存儲單元的數據與該單元的地址相同，所以當讀到</p><p>的數據與該存儲單元的地址相等時，表明讀寫一致，錯誤標誌信號error_flag為低電平；若兩</p><p>者不相等，則說明讀寫過程發生錯誤，此時將error_flag拉高，結束讀操作。圖 28.4.4為寫</p><p>過程中SignalTap抓取的波形圖：</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4163c88e20694b7d91793d50879a2e56><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.4.4 寫過程中SignalTap抓取的波形圖</p><p>從該波形圖中我們看到讀寫控制信號i2c_rh_wl為低電平，表示處於寫操作狀態。當I2C觸</p><p>發執行信號i2c_exec為高電平時開始執行I2C寫操作，從上圖中可以看到當前寫的存儲單元地</p><p>址為0000h，寫入的數據為00h。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2671254118d546cfb195db7310651930><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.4.5為讀過程中SignalTap抓取的波形圖。</p><p>圖 28.4.5 讀過程中SignalTap抓取的波形圖</p><p>從該波形圖中我們看到讀寫控制信號i2c_rh_wl為高電平，表示處於讀操作狀態，當I2C觸</p><p>發執行信號i2c_exec為高電平時開始執行I2C讀操作，從上圖中可以看到當前讀的存儲單元地</p><p>址為0001h，讀到的數據為01h。</p><p>led顯示模塊利用LED燈的顯示狀態來標識讀寫過程是否出錯，在模塊中通過檢測錯誤標誌</p><p>信號error_flag來改變LED燈的顯示狀態。</p><p>LED顯示模塊led_alarm代碼如下：</p><p>1 <strong>module </strong>led_alarm <strong>#(parameter</strong> L_TIME <strong>= </strong>25'd25_000_000 // 控制led閃爍間隔時間</p><p>2 <strong>)(</strong> // 此處為500ms</p><p>3 //system clock</p><p>4 <strong>input</strong> clk <strong>,</strong> // 時鐘信號</p><p>5 <strong>input</strong> rst_n <strong>,</strong> // 復位信號</p><p>6</p><p>7 //led interface</p><p>8 <strong>output</strong> <strong>[</strong>3<strong>:</strong>0<strong>]</strong> led <strong>, </strong>// LED 燈</p><p>9</p><p>10 //user interface</p><p>11 <strong>input</strong> error_flag // 錯誤標誌</p><p>12 <strong>);</strong></p><p>13</p><p>14 //reg define</p><p>15 <strong>reg</strong> led_t <strong>;</strong> // 使用的led燈</p><p>16 <strong>reg</strong> <strong>[</strong>24<strong>:</strong>0<strong>]</strong> led_cnt<strong>;</strong> // led計數</p><p>17</p><p>18 //*****************************************************</p><p>19 //** main code</p><p>20 //*****************************************************</p><p>21</p><p>22 //led輸出</p><p>23 <strong>assign</strong> led <strong>= {</strong>3'b000<strong>,</strong>led_t<strong>};</strong></p><p>24</p><p>25 //錯誤標誌為1時led閃爍，否則，LED0常亮</p><p>26 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>27 <strong>if(</strong>rst_n <strong>== </strong>1'b0<strong>) begin</strong></p><p>28 led_cnt <strong>&lt;= </strong>25'd0<strong>;</strong></p><p>29 led_t <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>30 <strong>end</strong></p><p>31 <strong>else begin</strong></p><p>32 <strong>if(</strong>error_flag<strong>) begin</strong> // 讀到的值錯誤</p><p>33 led_cnt <strong>&lt;= </strong>led_cnt <strong>+ </strong>25'd1<strong>;</strong></p><p>34 <strong>if(</strong>led_cnt <strong>== </strong>L_TIME<strong>) begin</strong> // 數據錯誤時LED燈每隔L_TIME時間閃爍一次</p><p>35 led_cnt <strong>&lt;= </strong>25'd0<strong>;</strong></p><p>36 led_t <strong>&lt;= ~</strong>led_t<strong>;</strong></p><p>37 <strong>end</strong></p><p>38 <strong>end</strong></p><p>39 <strong>else begin</strong> // 讀完且讀到的值正確</p><p>40 led_cnt <strong>&lt;= </strong>25'd0<strong>;</strong></p><p>41 led_t <strong>&lt;= </strong>1'b1<strong>;</strong> // led燈常亮</p><p>42 <strong>end</strong></p><p>43 <strong>end</strong></p><p>44 <strong>end</strong></p><p>45</p><p>46 <strong>endmodule</strong></p><p>程序第一行的參數L_TIME用於控制led閃爍間隔時間，在例化時重新指定參數值，可以改</p><p>變led閃爍的快慢。程序中第32行判斷error_flag的值，當error_flag為高電平時表明讀寫數</p><p>據不一致，此時，led燈每隔L_TIME時間閃爍一次；當error_flag為低電平時，表明讀寫數據</p><p>一致，EEPROM讀寫正確，led燈常亮。</p><p><strong>下載驗證</strong></p><p>首先我們打開工程，在工程所在的路徑下打開e2prom_top/par文件夾，在裡面找到</p><p>“e2prom_top.qpf”並雙擊打開。注意工程所在的路徑名只能由字母、數字以及下劃線組成，</p><p>不能出現中文、空格以及特殊字符等。EEPROM讀寫工程打開後如圖 28.5.1所示。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/370425be859847788de53ddeee5cc5aa><p class=pgc-img-caption></p></div><p>圖 28.5.1 EEPROM讀寫工程</p><p>接下來我們下載程序，驗證EEPROM讀寫功能。工程打開後通過點擊工具欄中的“Programmer”</p><p>圖 標 打 開 下 載 界 面 ， 通 過 “ Add File ” 按 鈕 選 擇 EEPROM 讀 寫 工 程 中</p><p>e2prom_top/par/output_files 目錄下的“e2prom_top.sof”文件。開發板電源打開後，在程</p><p>序下載界面點擊“Hardware Setup”，在彈出的對話框中選擇當前的硬件連接為“USB</p><p>Blaster[USB-0]”。然後點擊“Start”將工程編譯完成後得到的 sof 文件下載到開發板中，</p><p>如圖 28.5.2所示。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0faf45ad3f344f859cb14ad2a501ed23><p class=pgc-img-caption></p></div><p>圖 28.5.2 程序下載界面</p><p>接下來我們下載程序，驗證通過I2C協議讀寫EEPROM功能。下載完成後觀察開發板的led顯</p><p>示如圖 28.5.3所示，led燈常亮，說明通過EEPROM讀寫程序下載驗證正確。</p><div class=pgc-img><img alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/239ca09b3ba647dea701ec7a17a646c2><p class=pgc-img-caption></p></div><p><br></p><p>圖 28.5.3 開發板LED燈常亮</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>正點</a></li><li><a>開拓者</a></li><li><a>FPGA</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html title=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示>正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html title="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗">正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html alt=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html title=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗>正點原子開拓者NiosII資料連載第二十六章高速示波器實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html alt="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html title="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理">正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html alt=FPGA無線通信課程連載——擾碼的原理及實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RzH3OlM2Sr7uEv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html title=FPGA無線通信課程連載——擾碼的原理及實現>FPGA無線通信課程連載——擾碼的原理及實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html alt="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html title="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器">「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html alt="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html title="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器">「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html alt=FPGA管腳調整注意事項及技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rt0Fp44Iqh26UT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html title=FPGA管腳調整注意事項及技巧>FPGA管腳調整注意事項及技巧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html alt=基於FPGA的多通道同步實時高速數據採集系統設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RT9ec7T8clHaQI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html title=基於FPGA的多通道同步實時高速數據採集系統設計>基於FPGA的多通道同步實時高速數據採集系統設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51718fda.html alt=FPGA基礎之時序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b67909f181e2497f883a202aadca9129 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51718fda.html title=FPGA基礎之時序設計>FPGA基礎之時序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/769d1d2c04b9410aa18cd0add525013f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html title=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了>「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3006b33b.html alt=基於FPGA的LVDS高可靠性傳輸優化設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153533281868967dc1af365 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3006b33b.html title=基於FPGA的LVDS高可靠性傳輸優化設計>基於FPGA的LVDS高可靠性傳輸優化設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html alt=FPGA為什麼可編程，這篇文章來告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7abe76ede514e308d57ca293420a430 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html title=FPGA為什麼可編程，這篇文章來告訴你>FPGA為什麼可編程，這篇文章來告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ae61a10.html alt=FPGA的建立時間、保持時間、傳播延時、組合邏輯延時都是什麼呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ca8d58bfb9fd4b5cb2c14c1edbae1701 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ae61a10.html title=FPGA的建立時間、保持時間、傳播延時、組合邏輯延時都是什麼呢？>FPGA的建立時間、保持時間、傳播延時、組合邏輯延時都是什麼呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3301fa18.html alt=FPGA乘法器的簡單用法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15321368486336e286b374a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3301fa18.html title=FPGA乘法器的簡單用法>FPGA乘法器的簡單用法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>