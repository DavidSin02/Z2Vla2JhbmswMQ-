<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring 核心知識講解，太簡單啦 | 极客快訊</title><meta property="og:title" content="Spring 核心知識講解，太簡單啦 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cfd4e0e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cfd4e0e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cfd4e0e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cfd4e0e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cfd4e0e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cfd4e0e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cfd4e0e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cfd4e0e.html><meta property="article:published_time" content="2020-11-14T21:08:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:12+08:00"><meta name=Keywords content><meta name=description content="Spring 核心知識講解，太簡單啦"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring 核心知識講解，太簡單啦</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>各位志同道合的朋友們大家好，我是一個一直在一線互聯網踩坑十餘年的編碼愛好者，現在將我們的各種經驗以及架構實戰分享出來，如果大家喜歡，就關注我，一起將技術學深學透，我會每一篇分享結束都會預告下一專題</p></blockquote><p>Spring Framework 簡稱 Spring，是 Java 開發中最常用的框架，地位僅次於 Java API，就連近幾年比較流行的微服務框架 SpringBoot，也是基於 Spring 實現的，SpringBoot 的誕生是為了讓開發者更方便地使用 Spring，因此 Spring 在 Java 體系中的地位可謂首屈一指。當然，如果想要把 Spring 所有功能都講的一清二楚，遠遠不是一兩篇文章能夠做到的，但幸運的是，Spring 的基礎資料可以很輕易的搜索到，那麼我們本講主要的目的就是把 Spring 中的核心知識點和常見面試題分享給大家，希望對大家能有所幫助。</p><h3 class=pgc-h-arrow-right>Spring 介紹</h3><p>Spring 是一個開源框架，為了解決企業應用程序開發複雜性而創建的，Spring 的概念誕生於 2002 年，於 2003 年正式發佈第一個版本 Spring Framework 0.9。下面一起來看 Spring 各個版本的更新特性和它的發展變化吧。</p><p>Spring 1.x</p><p>此版本主要是為了解決企業應用程序開發複雜性而創建的，當時 J2EE 應用的經典架構是分層架構：表現層、業務層、持久層，最流行的組合就是 SSH（Struts、Spring、Hibernate）。Spring 1.x 僅支持基於 XML 的配置，確保用戶代碼不依賴 Spring，它主要包含了以下功能模塊：aop、beans、ejb、jdbc、jndi、orm、transation、validation、web 等。</p><p>Spring 2.x</p><p>Spring 2.x 的改動並不是很大，主要是在 Spring 1.x 的基礎上增加了幾個新模塊，如 ehcache、jms、jmx、scripting、stereotype 等。</p><p>Spring 3.x</p><p>Spring 3.x 開始不止支持 XML 的配置，還擴展了基於 Java 類的配置，還增加了 Expression、Instructment、Tomcat、oxm 等組件，同時將原來的 Web 細分為：Portlet、Servlet。</p><p>Spring 4.x</p><p>Spring 4.x 擴充了 Groovy、Messaging、WebMvc、Tiles2、WebSocket 等功能組件，同時 Spring 還適配了 Java 版本，全面支持 Java 8.0、Lambda 表達式等。隨著 RESTful 架構風格被越來越多的用戶所採用，Spring 4.x 也提供了 RestController 等註解新特性。</p><p>Spring 5.x</p><p>Spring 5.x 緊跟 Java 相關技術的更新迭代，不斷適配 Java 的新版本，同時不斷重構優化自身核心框架代碼，支持函數式、響應式編程模型等。</p><h3 class=pgc-h-arrow-right>Spring 核心</h3><p>Spring 核心包括以下三個方面：</p><ul><li>控制反轉（Ioc）</li><li>依賴注入（DI）</li><li>面向切面編程（AOP）</li></ul><p>下面分別來看它的這些特性。</p><p>控制反轉（IoC）</p><p>控制反轉（Inversion of Control，IoC），顧名思義所謂的控制反轉就是把創建對象的權利交給框架去控制，而不需要人為地去創建，這樣就實現了可插拔式的接口編程，有效地降低代碼的耦合度，降低了擴展和維護的成本。比如，你去某地旅遊不再用自己親自為訂購 A 酒店還是 B 酒店而發愁了，只需要把住店的需求告訴給某個託管平臺，這個託管平臺就會幫你訂購一個既便宜又舒適的酒店，而這個幫你訂購酒店的行為就可以稱之為控制反轉。</p><p>依賴注入（DI）</p><p>依賴注入（Dependency Injection，DI），是組件之間依賴關係由容器在運行期決定，即由容器動態的將某個依賴關係注入到組件之中。依賴注入的目的並非為軟件系統帶來更多功能，而是為了提升組件重用的頻率，併為系統搭建一個靈活、可擴展的平臺。通過依賴注入機制，只需要通過簡單的配置，而無需任何代碼就可指定目標需要的資源，完成自身的業務邏輯，而不需要關心具體的資源來自何處，由誰實現。</p><p>IoC 和 DI 的關係</p><p>IoC 是 Spring 中一個極為重要的概念，而 DI 則是實現 IoC 的方法和手段。接下來，我們來看依賴注入的常見實現方式有哪些？依賴注入的常見實現方式如下：</p><ol start=1><li>setter 注入</li><li>構造方法注入</li><li>註解注入</li></ol><p>1）setter 注入</p><p>Java 代碼：</p><pre><code>public&nbsp;class&nbsp;UserController&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;注入&nbsp;UserService&nbsp;對象&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;UserService&nbsp;userService;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setUserService(UserService&nbsp;userService){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.userService&nbsp;=&nbsp;userService;&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>XML 配置：</p><pre><code>‹bean&nbsp;name=&#34;userController&#34;&nbsp;class=&#34;com.learning.controller.UserController&#34;›&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‹!--&nbsp;依賴注入&nbsp;--›&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‹property&nbsp;name=&#34;userService&#34;&nbsp;ref=&#34;userService&#34;›‹/property›&nbsp;&nbsp;‹/bean›&nbsp;&nbsp;‹bean&nbsp;name=&#34;userService&#34;&nbsp;class=&#34;com.learning.dao.impl.UserServiceImpl&#34;›‹/bean›</code></pre><p>Bean 標籤的常用屬性說明：</p><ul><li>id：為實例化對象起名稱，根據 id 值可以得到我們配置的實例化對象，id 屬性的名稱原則上可以任意命名，但是能包含任何特殊符號；</li><li>class：創建對象所在類的全路徑；</li><li>name：功能和 id 屬性一樣，但是現在一般不用；與 id 的區別在於：name 屬性值裡可以包含特殊符號，但是 id 不可以；</li><li>scope：一般最常用的有兩個值： Singleton：單例模式，整個應用程序，只創建 bean 的一個實例；Prototype：原型模式，每次注入都會創建一個新的 bean 實例，Spring 默認的是單例模式。</li></ul><p>2）構造方法注入</p><p>Java 代碼：</p><pre><code>public&nbsp;class&nbsp;UserController&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;UserService&nbsp;userService;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;UserController(UserService&nbsp;userService){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.userService&nbsp;=&nbsp;userService;&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>XML 配置：</p><pre><code>‹bean&nbsp;name=&#34;userController&#34;&nbsp;class=&#34;com.learning.controller.UserController&#34;›&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‹!--&nbsp;依賴注入&nbsp;--›&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;‹constructor-arg&nbsp;ref=&#34;userService&#34;›‹/constructor-arg›&nbsp;&nbsp;‹/bean›&nbsp;&nbsp;‹bean&nbsp;name=&#34;userService&#34;&nbsp;class=&#34;com.learning.dao.impl.UserServiceImpl&#34;›‹/bean›</code></pre><p>3）註解注入</p><pre><code>@Controllerpublic&nbsp;class&nbsp;UserController&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;使用註解自動注入&nbsp;&nbsp;&nbsp;&nbsp;@Autowired()&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;UserService&nbsp;userService;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something}//&nbsp;創建依賴對象@Servicepublic&nbsp;class&nbsp;UserService&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;}</code></pre><p>創建依賴對象的常見註解：@Component、@Controller、@Service、@Repository。</p><p>總結：可以看出註解的方式要比傳統的 XML（setter 和構造器注入）實現注入更為方便，同時註解方式也是官方力推的依賴注入最佳使用方式。</p><p>面向切面編程（AOP）</p><p>面向切面編程（Aspect Oriented Programming，AOP），它就好比將系統按照功能分類，每一個類別就是一個“切面”，我們再針對不同的切面制定相應的規則，類似開發模式被稱為面向切面編程。</p><p>AOP 使用場景</p><ul><li>日誌系統</li><li>安全統一效驗</li></ul><p>AOP 優點</p><ul><li>集中處理某一類問題，方便維護</li><li>邏輯更加清晰</li><li>降低模塊間的耦合度</li></ul><p>AOP 相關概念</p><ul><li>Join point：連接點，程序執行期間的某一個點，例如執行方法或處理異常時候的點，在 Spring AOP 中，連接點總是表示方法的執行。</li><li>Advice：通知，通知分為方法執行前通知，方法執行後通知、環繞通知等。許多 AOP 框架（包括 Spring）都將通知建模為攔截器，在連接點周圍維護一系列攔截器（形成攔截器鏈），對連接點的方法進行增強。</li><li>Pointcut：切點，匹配連接點（Join point）的表達式，是 AOP 的核心，並且 Spring 默認使用 AspectJ 作為切入點表達式語言。</li><li>Aspect：切面，是一個跨越多個類的模塊化的關注點，它是通知（Advice）和切點（Pointcut）合起來的抽象，它定義了一個切點（Pointcut）用來匹配連接點（Join point），也就是需要對需要攔截的那些方法進行定義。</li><li>Target object：目標對象，被一個或者多個切面（Aspect）通知的對象，也就是需要被 AOP 進行攔截對方法進行增強（使用通知）的對象，也稱為被通知的對象。由於在 AOP 裡面使用運行時代理，因而目標對象一直是被代理的對象。</li><li>AOP proxy：AOP 代理，為了實現切面（Aspect）功能使用 AOP 框架創建一個對象，在 Spring 框架裡面一個 AOP 代理指的是 JDK 自身的動態代理或 CGLIB 實現的動態代理。</li><li>Weaving：把切面加入到對象，並創建出代理對象的過程。</li><li>Advisor：一個 Advisor 相當於一個小型的切面，不同的是它只有一個通知（Advice），Advisor 在事務管理裡面會經常遇到。</li></ul><p>AOP 代碼實現</p><p>AOP 的示例我們就以開車為例，開車的完成流程是這樣的：巡視車體及周圍情況 → 發動 → 開車 → 熄火 → 鎖車。</p><p>當然我們的主要目的是“開車”，但在開車之前和開完車之後，我們要做一些其他的工作，這些“其他”的工作，可以理解為 AOP 編程。</p><p>1）創建類和方法</p><pre><code>package&nbsp;com.learning.aop;import&nbsp;org.springframework.stereotype.Component;&nbsp;@Component(&#34;person&#34;)public&nbsp;class&nbsp;Person&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;drive()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&#34;開車&#34;);&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>2）創建 AOP 攔截</p><pre><code>package&nbsp;com.learning.aop;&nbsp;import&nbsp;org.aspectj.lang.annotation.After;import&nbsp;org.aspectj.lang.annotation.Aspect;import&nbsp;org.aspectj.lang.annotation.Before;import&nbsp;org.springframework.stereotype.Component;&nbsp;@Component@Aspectpublic&nbsp;class&nbsp;CarAop&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Before(&#34;execution(*&nbsp;com.learning.aop.Person.drive())&#34;)&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;before()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&#34;巡視車體及周圍情況&#34;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&#34;發動&#34;);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@After(&#34;execution(*&nbsp;com.learning.aop.Person.drive())&#34;)&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;after()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&#34;熄火&#34;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&#34;鎖車&#34;);&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>3）XML 配置注入掃描包路徑</p><pre><code>‹?xml&nbsp;version=&#34;1.0&#34;&nbsp;encoding=&#34;UTF-8&#34;?›‹beans&nbsp;xmlns=&#34;http://www.springframework.org/schema/beans&#34;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:context=&#34;http://www.springframework.org/schema/context&#34;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:aop=&#34;http://www.springframework.org/schema/aop&#34;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/beans/spring-beans.xsd&nbsp;http://www.springframework.org/schema/context&nbsp;http://www.springframework.org/schema/context/spring-context.xsd&nbsp;http://www.springframework.org/schema/aop&nbsp;http://www.springframework.org/schema/aop/spring-aop.xsd&#34;›&nbsp;&nbsp;&nbsp;&nbsp;‹context:component-scan&nbsp;base-package=&#34;com.learning&#34;/›&nbsp;&nbsp;&nbsp;&nbsp;‹aop:aspectj-autoproxy/›‹/beans›</code></pre><p>4）創建測試類</p><pre><code>package&nbsp;com.learning.aop;&nbsp;import&nbsp;org.springframework.context.ApplicationContext;import&nbsp;org.springframework.context.support.ClassPathXmlApplicationContext;&nbsp;public&nbsp;class&nbsp;PersonTest&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext&nbsp;context&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;ClassPathXmlApplicationContext(&#34;applicationContext.xml&#34;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;landlord&nbsp;=&nbsp;context.getBean(&#34;person&#34;,&nbsp;Person.class);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;landlord.drive();&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>運行測試代碼，執行結果如下：</p><blockquote><p>巡視車體及周圍情況</p><p>發動</p><p>開車</p><p>熄火</p><p>鎖車</p></blockquote><p>AspectJ 註解說明：</p><ul><li>@Before — 前置通知，在連接點方法前調用；</li><li>@Around — 環繞通知，它將覆蓋原有方法，但是允許你通過反射調用原有方法；</li><li>@After — 後置通知，在連接點方法後調用；</li><li>@AfterReturning — 返回通知，在連接點方法執行並正常返回後調用，要求連接點方法在執行過程中沒有發生異常；</li><li>@AfterThrowing — 異常通知，當連接點方法異常時調用。</li></ul><h3 class=pgc-h-arrow-right>相關面試題</h3><p>1.@Value 註解的作用是什麼？</p><p>答：基於 @Value 的註解可以讀取 properties 配置文件，使用如下:</p><blockquote><p>@Value("#{configProperties['jdbc.username']}")</p><p>private String userName;</p></blockquote><p>以上為讀取 configProperties 下的 jdbc.username 配置。</p><p>2.Spring 通知類型有哪些？</p><p>答：Spring 通知類型總共有 5 種：前置通知、環繞通知、後置通知、異常通知、最終通知。</p><ul><li>前置通知（Before advice）：在目標方法執行之前執行的通知。在某連接點（ join point ）之前執行的通知，但這個通知不能阻止連接點前的執行（除非它拋出一個異常）。</li><li>環繞通知（Around Advice）：在目標方法執行之前和之後都可以執行額外代碼的通知，也可以選擇是否繼續執行連接點或直接返回它們自己的返回值或拋出異常來結束執行。</li><li>後置通知（After (finally) advice）：目標方法執行之後（某連接點退出的時候）執行的通知（不論是正常返回還是異常退出）。</li><li>異常後通知（After throwing advice）：在方法拋出異常退出時執行的通知。</li><li>最終通知（After returning advice）：在某連接點（join point）正常完成後執行的通知，例如，一個方法沒有拋出任何異常，正常返回。</li></ul><p>3.怎麼理解 Spring 中的 IOC 容器？</p><p>答：Spring IOC 就是把創建對象的權利交給框架去控制，而不需要人為的去創建，這樣就實現了可插拔式的接口編程，有效地降低代碼的耦合度，降低了擴展和維護的成本。</p><p>比如，去某地旅遊不再用自己親自為訂購 A 酒店還是 B 酒店而發愁了，只需要把住店的需求告訴給某個託管平臺，這個託管平臺就會幫你訂購一個既便宜又舒適的酒店，而這個幫你訂購酒店的行為就可以稱之為控制反轉。</p><p>4.怎麼理解 Spring 中的依賴注入？</p><p>答：依賴注入是指組件之間的依賴關係由容器在運行期決定，即由容器動態的將某個依賴關係注入到組件之中。依賴注入的目的並非為軟件系統帶來更多功能，而是為了提升組件重用的頻率，併為系統搭建一個靈活、可擴展的平臺。通過依賴注入機制，我們只需要通過簡單的配置，而無需任何代碼就可指定目標需要的資源，完成自身的業務邏輯，而不需要關心具體的資源來自何處，由誰實現。</p><p>5.IoC 和 DI 有什麼關係？</p><p>答：IoC 是 Spring 中一個極為重要的概念，提供了對象管理的功能，從而省去了人為創建麻煩，而 DI 正是實現 IoC 的方法和手段。</p><p>6.@Component 和 @Bean 有什麼區別？</p><p>答：它們的作用對象不同：@Component 作用於類，而 @Bean 註解作用於方法。</p><p>@Component 通常是通過類路徑掃描來自動偵測和裝配對象到 Spring 容器中，比如 @ComponentScan 註解就是定義掃描路徑中的類裝配到 Spring 的 Bean 容器中；@Bean 註解是告訴 Spring 這是某個類的實例，當我需要用它的時把它給我，@Bean 註解比 @Component 註解自定義性更強，很多地方我們只能通過 @Bean 註解來註冊 Bean，比如當我們引用第三方庫中的類需要裝配到 Spring容器時，則只能通過 @Bean 來實現，比如以下示例，只能通過 @Bean 註解來實現：</p><pre><code>public&nbsp;class&nbsp;WireThirdLibClass&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Bean&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ThirdLibClass&nbsp;getThirdLibClass()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ThirdLibClass();&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>7.Spring 中 bean 的作用域有幾種類型？</p><p>答：Spring 中 bean 的作用域有四種類型，如下列表：</p><ul><li>單例（Singleton）：整個應用程序，只創建 bean 的一個實例；</li><li>原型（Prototype）：每次注入都會創建一個新的 bean 實例；</li><li>會話（Session）：每個會話創建一個 bean 實例，只在 Web 系統中有效；</li><li>請求（Request）：每個請求創建一個 bean 實例，只在 Web 系統中有效。</li></ul><p>Spring 默認的是單例模式。</p><p>8.什麼是 Spring 的內部 bean？</p><p>答：當一個 bean 僅被用作另一個 bean 的屬性時，它能被聲明為一個內部 bean，為了定義 inner Bean，在 Spring 的基於 XML 的配置元數據中，可以在 ‹property/› 或 ‹constructor-arg/› 元素內使用 ‹bean/› 元素，內部 bean 通常是匿名的，它們的 Scope 一般是 prototype。</p><p>9.Spring 注入方式有哪些？</p><p>答：Spring 的注入方式包含以下五種：</p><ul><li>setter 注入</li><li>構造方法注入</li><li>註解注入</li><li>靜態工廠注入</li><li>實例工廠注入</li></ul><p>其中最常用的是前三種，官方推薦使用的是註解注入，相對使用更簡單，維護成本更低，更直觀。</p><p>10.在 Spring 中如何操作數據庫？</p><p>答：在 Spring 中操作數據庫，可以使用 Spring 提供的 JdbcTemplate 對象，JdbcTemplate 類提供了很多便利的方法，比如把數據庫數據轉變成基本數據類型或對象，執行自定義的 SQL 語句，提供了自定義的數據錯誤處理等，JdbcTemplate 使用示例如下：</p><pre><code>@Autowiredprivate&nbsp;JdbcTemplate&nbsp;jdbcTemplate;//&nbsp;新增@GetMapping(&#34;save&#34;)public&nbsp;String&nbsp;save(){&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;sql&nbsp;=&nbsp;&#34;INSERT&nbsp;INTO&nbsp;USER&nbsp;(USER_NAME,PASS_WORD)&nbsp;VALUES&nbsp;(&#39;laowang&#39;,&#39;123&#39;)&#34;;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;rows&nbsp;=&nbsp;jdbcTemplate.update(sql);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&#34;執行成功，影響&#34;&nbsp;+&nbsp;rows&nbsp;+&nbsp;&#34;行&#34;;}//&nbsp;刪除@GetMapping(&#34;del&#34;)public&nbsp;String&nbsp;del(int&nbsp;id){&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;rows=&nbsp;jdbcTemplate.update(&#34;DELETE&nbsp;FROM&nbsp;&nbsp;USER&nbsp;&nbsp;WHERE&nbsp;ID&nbsp;=&nbsp;?&#34;,id);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&#34;執行成功，影響&#34;&nbsp;+&nbsp;rows&nbsp;+&nbsp;&#34;行&#34;;}//&nbsp;查詢@GetMapping(&#34;getMapById&#34;)public&nbsp;Map&nbsp;getMapById(Integer&nbsp;id){&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;sql&nbsp;=&nbsp;&#34;SELECT&nbsp;*&nbsp;FROM&nbsp;USER&nbsp;WHERE&nbsp;ID&nbsp;=&nbsp;?&#34;;&nbsp;&nbsp;&nbsp;&nbsp;Map&nbsp;map=&nbsp;jdbcTemplate.queryForMap(sql,id);&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map;}</code></pre><p>11.Spring 的 JdbcTemplate 對象和 JDBC 有什麼區別？</p><p>答：Spring 的 JdbcTemplate 是對 JDBC API 的封裝，提供更多的功能和更便利的操作，比如 JdbcTemplate 擁有：</p><ul><li>JdbcTemplate 是線程安全的；</li><li>實例化操作比較簡單，僅需要傳遞 DataSource；</li><li>自動完成資源的創建和釋放工作；</li><li>創建一次 JdbcTemplate，到處可用，避免重複開發。</li></ul><p>12.Spring 有幾種實現事務的方式？</p><p>答：Spring 實現事務有兩種方式：編程式事務和聲明式事務。編程式事務，使用 TransactionTemplate 或 PlatformTransactionManager 實現，示例代碼如下：</p><pre><code>private&nbsp;final&nbsp;TransactionTemplate&nbsp;transactionTemplate;public&nbsp;void&nbsp;add(User&nbsp;user)&nbsp;throws&nbsp;Exception{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Spring編碼式事務，回調機制&nbsp;&nbsp;&nbsp;&nbsp;transactionTemplate.execute(new&nbsp;TransactionCallback‹Object›()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Object&nbsp;doInTransaction(TransactionStatus&nbsp;status)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userMapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;異常，設置為回滾&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status.setRollbackOnly();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;});}</code></pre><p>如果有異常，調用 status.setRollbackOnly() 回滾事務，否則正常執行 doInTransaction() 方法，正常提交事務。如果事務控制的方法不需要返回值，就可以使用 TransactionCallbackWithoutResult（TransactionCallback 接口的抽象實現類）示例代碼如下：</p><pre><code>public&nbsp;void&nbsp;add(User&nbsp;user)&nbsp;throws&nbsp;Exception&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Spring編碼式事務，回調機制&nbsp;&nbsp;&nbsp;&nbsp;transactionTemplate.execute(new&nbsp;TransactionCallbackWithoutResult()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;doInTransactionWithoutResult(TransactionStatus&nbsp;status)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userMapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;異常，設置為回滾&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;status.setRollbackOnly();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;});}</code></pre><p>聲明式事務，底層是建立在 Spring AOP 的基礎上，在方式執行前後進行攔截，並在目標方法開始執行前創建新事務或加入一個已存在事務，最後在目標方法執行完後根據情況提交或者回滾事務。聲明式事務的優點：不需要編程，減少了代碼的耦合，在配置文件中配置並在目標方法上添加 @Transactional 註解來實現，示例代碼如下：</p><pre><code>@Transactionalpublic&nbsp;void&nbsp;save()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;User&nbsp;user&nbsp;=&nbsp;new&nbsp;User(&#34;laowang&#34;);&nbsp;&nbsp;&nbsp;&nbsp;userMapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(true)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException(&#34;異常&#34;);&nbsp;&nbsp;&nbsp;&nbsp;}}</code></pre><p>拋出異常，事務會自動回滾，如果方法正常執行，則會自動提交事務。</p><p>13.Spring 事務隔離級別有哪些？</p><p>答：Spring 的注入方式包含以下五種：</p><ul><li>ISOLATION_DEFAULT：用底層數據庫的設置隔離級別，數據庫設置的是什麼我就用什麼；</li><li>ISOLATIONREADUNCOMMITTED：未提交讀，最低隔離級別、事務未提交前，就可被其他事務讀取（會出現幻讀、髒讀、不可重複讀）；</li><li>ISOLATIONREADCOMMITTED：提交讀，一個事務提交後才能被其他事務讀取到（會造成幻讀、不可重複讀），SQL server 的默認級別；</li><li>ISOLATIONREPEATABLEREAD：可重複讀，保證多次讀取同一個數據時，其值都和事務開始時候的內容是一致，禁止讀取到別的事務未提交的數據（會造成幻讀），MySQL 的默認級別；</li><li>ISOLATION_SERIALIZABLE：序列化，代價最高最可靠的隔離級別，該隔離級別能防止髒讀、不可重複讀、幻讀。</li></ul><p>默認值為 ISOLATION_DEFAULT 遵循數據庫的事務隔離級別設置。</p><p>14.Spring 聲明式事務無效可能的原因有哪些？</p><p>答：可能的原因如下：</p><ul><li>MySQL 使用的是 MyISAM 引擎，而 MyISAM 是不支持事務的；</li><li>@Transactional 使用在非 public 方法上，@Transactional 註解只能支持 public 級別，其他類型聲明的事務不會生效；</li><li>@Transactional 在同一個類中無事務方法 A() 內部調用有事務方法 B()，那麼此時 B() 事物不會生效。Spring 中的 AOP 的底層實現原理是什麼？</li></ul><p>答：Spring AOP 的底層實現原理就是動態代理。Spring AOP 的動態代理有兩種實現方式，對於接口使用的是 JDK 自帶的動態代理來實現的，而對比非接口使用的是 CGLib 來實現的，關於動態代理的詳細內容，可參考前面【反射和動態代理】的那篇文章。</p><p>15.Spring 中的 Bean 是線程安全的嗎？</p><p>答：Spring 中的 Bean 默認是單例模式，Spring 框架並沒有對單例 Bean 進行多線程的封裝處理，因此默認的情況 Bean 並非是安全的，最簡單保證 Bean 安全的舉措就是設置 Bean 的作用域為 Prototype（原型）模式，這樣每次請求都會新建一個 Bean。</p><p>16.說一下 Spring 中 Bean 的生命週期？</p><p>答：Spring 中 Bean 的生命週期如下：</p><ul><li>① 實例化 Bean：對於 BeanFactory 容器，當客戶向容器請求一個尚未初始化的 Bean 時，或初始化 Bean 的時候需要注入另一個尚未初始化的依賴時，容器就會調用 createBean 進行實例化。對於 ApplicationContext 容器，當容器啟動結束後，通過獲取 BeanDefinition 對象中的信息，實例化所有的 Bean；</li><li>② 設置對象屬性（依賴注入）：實例化後的對象被封裝在 BeanWrapper 對象中，緊接著 Spring 根據 BeanDefinition 中的信息以及通過 BeanWrapper 提供的設置屬性的接口完成依賴注入；</li><li>③ 處理 Aware 接口：Spring 會檢測該對象是否實現了 xxxAware 接口，並將相關的 xxxAware 實例注入給 Bean：</li><li>如果這個 Bean 已經實現了 BeanNameAware 接口，會調用它實現的 setBeanName(String BeanId) 方法，此處傳遞的就是 Spring 配置文件中 Bean 的 id 值；</li><li>如果這個 Bean 已經實現了 BeanFactoryAware 接口，會調用它實現的 setBeanFactory() 方法，傳遞的是 Spring 工廠自身；</li><li>如果這個 Bean 已經實現了 ApplicationContextAware 接口，會調用 setApplicationContext(ApplicationContext) 方法，傳入 Spring 上下文；</li><li>④ BeanPostProcessor：如果想對 Bean 進行一些自定義的處理，那麼可以讓 Bean 實現了 BeanPostProcessor 接口，那將會調用 postProcessBeforeInitialization(Object obj, String s) 方法；</li><li>⑤ InitializingBean 與 init-method：如果 Bean 在 Spring 配置文件中配置了 init-method 屬性，則會自動調用其配置的初始化方法；</li><li>⑥ 如果這個 Bean 實現了 BeanPostProcessor 接口，將會調用 postProcessAfterInitialization(Object obj, String s) 方法；由於這個方法是在 Bean 初始化結束時調用的，因而可以被應用於內存或緩存技術；</li></ul><p>以上幾個步驟完成後，Bean 就已經被正確創建了，之後就可以使用這個 Bean 了。</p><ul><li>⑦ DisposableBean：當 Bean 不再需要時，會經過清理階段，如果 Bean 實現了 DisposableBean 這個接口，會調用其實現的 destroy() 方法；</li><li>⑧ destroy-method：最後，如果這個 Bean 的 Spring 配置中配置了 destroy-method 屬性，會自動調用其配置的銷燬方法。</li></ul><p>17.Spring 有哪些優點?</p><p>答：Spring 優點如下：</p><ul><li>開源免費的熱門框架，穩定性高、解決問題成本低；</li><li>方便集成各種優秀的框架；</li><li>降低了代碼耦合性，通過 Spring 提供的 IoC 容器，我們可以將對象之間的依賴關係交由 Spring 進行控制，避免硬編碼所造成的過度程序耦合；</li><li>方便程序測試，在 Spring 裡，測試變得非常簡單，例如：Spring 對 Junit 的支持，可以通過註解方便的測試 Spring 程序；</li><li>降低 Java EE API 的使用難度，Spring 對很多難用的 Java EE API（如 JDBC、JavaMail、遠程調用等）提供了一層封裝，通過 Spring 的簡易封裝，讓這些 Java EE API 的使用難度大為降低。</li></ul><p>18.Spring 和 Struts 的區別？</p><p>答：Spring 和 Struts 區別如下：Spring 特性如下：</p><ul><li>具備 IOC/DI、AOP 等通用能力，提高研發效率</li><li>除了支持 Web 層建設以外，還提供了 J2EE 整體服務</li><li>方便與其他不同技術結合使用，如 Hibernate、MyBatis 等</li><li>Spring 攔截機制是方法級別</li></ul><p>Struts 特性如下：</p><ul><li>是一個基於 MVC 模式的一個 Web 層的處理</li><li>Struts 攔截機制是類級別</li></ul><p>19.Spring、SpringBoot、SpringCloud 的區別是什麼？</p><p>答：它們的區別如下：</p><ul><li>Spring Framework 簡稱 Spring，是整個 Spring 生態的基礎。</li><li>Spring Boot 是一個快速開發框架，讓開發者可以迅速搭建一套基於 Spring 的應用程序，並且將常用的 Spring 模塊以及第三方模塊，如 MyBatis、Hibernate 等都做了很好的集成，只需要簡單的配置即可使用，不需要任何的 XML 配置文件，真正做到了開箱即用，同時默認支持 JSON 格式的數據，使用 Spring Boot 進行前後端分離開發也非常便捷。</li><li>Spring Cloud 是一套整合了分佈式應用常用模塊的框架，使得開發者可以快速實現微服務應用。作為目前非常熱門的技術，有關微服務的話題總是在各種場景下被大家討論，企業的招聘信息中也越來越多地出現對於微服務架構能力的要求。</li></ul><p>20.Spring 中都是用了哪些設計模式？</p><p>答：Spring 中使用的設計模式如下：</p><ul><li>工廠模式：通過 BeanFactory、ApplicationContext 來創建 bean 都是屬於工廠模式；</li><li>單例、原型模式：創建 bean 對象設置作用域時，就可以聲明 Singleton（單例模式）、Prototype（原型模式）；</li><li>察者模式：Spring 可以定義一下監聽，如 ApplicationListener 當某個動作觸發時就會發出通知；</li><li>責任鏈模式：AOP 攔截器的執行；</li><li>策略模式：在創建代理類時，如果代理的是接口使用的是 JDK 自身的動態代理，如果不是接口使用的是 CGLIB 實現動態代理。</li></ul><h3 class=pgc-h-arrow-right>總結</h3><p>通過本節內容我們充分的瞭解了 Spring 的核心：IoC、DI、AOP，也是用代碼演示了 Spring 核心功能的示例，其中可以發現的是 Spring 正在從之前的 XML 配置編程變為 Java 註解編程，註解編程讓 Spring 更加輕量化簡單化了，這一點在我們後面介紹 SpringBoot 的時候，會讓你更加感同身受。對於開發者來說，只有真正掌握了 Spring，才能稱得上是一名合格的 Java 工程師。當然，學習的目的是為了更好的應用，因此現在就一起動手實踐起來吧。</p><p><strong>下一篇：SpringBoot 核心知識</strong></p><blockquote><p>在公眾號菜單中可自行獲取專屬架構視頻資料，包括不限於 java架構、python系列、人工智能系列、架構系列，以及最新面試、小程序、大前端均無私奉獻，你會感謝我的哈</p></blockquote><p>​</p><p><strong>往期精選(全集wx公號【架構師修煉】)</strong></p><p><strong>分佈式數據之緩存技術，一起來揭開其神祕面紗</strong></p><p>分佈式數據複製技術，今天就教你真正分身術</p><p>數據分佈方式之哈希與一致性哈希，我就是個神算子</p><p>分佈式存儲系統三要素，掌握這些就離成功不遠了</p><p>想要設計一個好的分佈式系統，必須搞定這個理論</p><p>分佈式通信技術之發佈訂閱，乾貨滿滿</p><p>分佈式通信技術之遠程調用：RPC</p><p>消息隊列Broker主從架構詳細設計方案，這一篇就搞定主從架構</p><p>消息中間件路由中心你會設計嗎，不會就來學學</p><p>消息隊列消息延遲解決方案，跟著做就行了</p><p>秒殺系統每秒上萬次下單請求，我們該怎麼去設計</p><p>【分佈式技術】分佈式系統調度架構之單體調度，非掌握不可</p><p>CDN加速技術，作為開發的我們真的不需要懂嗎？</p><p>煩人的緩存穿透問題，今天教就你如何去解決</p><p>分佈式緩存高可用方案，我們都是這麼幹的</p><p>每天百萬交易的支付系統，生產環境該怎麼設置JVM堆內存大小</p><p>你的成神之路我已替你鋪好，沒鋪你來捶我</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>知識</a></li><li><a>講解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/7c999c2f.html alt=空壓機原理知識講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a6c55ec908e24bdea766da76a5d7ddeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7c999c2f.html title=空壓機原理知識講解>空壓機原理知識講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/29412007.html alt=高中化學知識講解——離子平衡中的電離常數和電離度有什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ba308363-e961-4481-9c72-657dd9bed90d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/29412007.html title=高中化學知識講解——離子平衡中的電離常數和電離度有什麼關係？>高中化學知識講解——離子平衡中的電離常數和電離度有什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7aa4b2.html alt=電動工具六大知識講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/365e3bae9dd54fba8fa13b568006bbd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7aa4b2.html title=電動工具六大知識講解>電動工具六大知識講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/58171be.html alt=知識講解：計算機基礎——計算機組成 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/03014edc364349ee979fb14c70a987df style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/58171be.html title=知識講解：計算機基礎——計算機組成>知識講解：計算機基礎——計算機組成</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe502e2.html alt=淨水器超濾膜知識講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f3776a54b88d42e5b4bf9cecbd968b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe502e2.html title=淨水器超濾膜知識講解>淨水器超濾膜知識講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f885145.html alt=“灌溉”知識系列講解之七：過濾器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1297b1b4af04e37a7c63a593a8b54a4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f885145.html title=“灌溉”知識系列講解之七：過濾器>“灌溉”知識系列講解之七：過濾器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc4b8c3.html alt=超全面的齒輪知識由淺及深講解透徹，圖文並茂、推薦收藏！（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1d932448b74c44c485ee535eb659abf6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc4b8c3.html title=超全面的齒輪知識由淺及深講解透徹，圖文並茂、推薦收藏！（二）>超全面的齒輪知識由淺及深講解透徹，圖文並茂、推薦收藏！（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3657623.html alt=關於齒輪知識由淺及深講解透徹，推薦收藏！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d8f3385a30a4150989abc97e78506e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3657623.html title=關於齒輪知識由淺及深講解透徹，推薦收藏！>關於齒輪知識由淺及深講解透徹，推薦收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/804ea540.html alt=「行業知識」結構工程師的心結——鋼樑扭轉計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/177f1b37fa4b41698a4e78accf7efbb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/804ea540.html title=「行業知識」結構工程師的心結——鋼樑扭轉計算>「行業知識」結構工程師的心結——鋼樑扭轉計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc4c942.html alt=「鋼構知識」經典鋼結構設計問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc4c942.html title=「鋼構知識」經典鋼結構設計問答>「鋼構知識」經典鋼結構設計問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f6e1fd9.html alt=「鋼構知識」經典鋼結構設計問答彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/76195b1e9d934c2e952b060dad0951e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f6e1fd9.html title=「鋼構知識」經典鋼結構設計問答彙總>「鋼構知識」經典鋼結構設計問答彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html alt=各種門窗知識大全，是我見過最全的了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349013240149cf1ef5531 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html title=各種門窗知識大全，是我見過最全的了>各種門窗知識大全，是我見過最全的了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0ff6432.html alt=鋼結構必備知識38問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0ff6432.html title=鋼結構必備知識38問>鋼結構必備知識38問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb258a5a.html alt=鋼結構必備知識38問，你的晉級之路！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1535975955779bcac330762 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb258a5a.html title=鋼結構必備知識38問，你的晉級之路！>鋼結構必備知識38問，你的晉級之路！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html alt=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1537941825042b6f495fa56 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html title=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？>長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>