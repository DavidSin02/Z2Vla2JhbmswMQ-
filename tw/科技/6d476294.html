<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>hashmap源碼分析及常用方法測試_一點課堂（多岸學院） | 极客快訊</title><meta property="og:title" content="hashmap源碼分析及常用方法測試_一點課堂（多岸學院） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/13a1f2cd86c14f888755d75f00bc57ff"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d476294.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d476294.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6d476294.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d476294.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d476294.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6d476294.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6d476294.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d476294.html><meta property="article:published_time" content="2020-10-29T21:09:21+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:21+08:00"><meta name=Keywords content><meta name=description content="hashmap源碼分析及常用方法測試_一點課堂（多岸學院）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6d476294.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>hashmap源碼分析及常用方法測試_一點課堂（多岸學院）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><ul><li>#hashmap-簡介</li><li>#底層數據結構分析</li><li class=ql-indent-1>#jdk18之前</li><li class=ql-indent-1>#jdk18之後</li><li>#hashmap源碼分析</li><li class=ql-indent-1>#構造方法</li><li class=ql-indent-1>#put方法</li><li class=ql-indent-1>#get方法</li><li class=ql-indent-1>#resize方法</li><li>#hashmap常用方法測試</li></ul><blockquote><p>感謝 https://github.com/changfubai 對本文的改進做出的貢獻！</p></blockquote><p>HashMap 簡介</p><p>HashMap 主要用來存放鍵值對，它基於哈希表的Map接口實現，是常用的Java集合之一。</p><p>JDK1.8 之前 HashMap 由 數組+鏈表 組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的（“拉鍊法”解決衝突）.JDK1.8 以後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為 8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><p>底層數據結構分析</p><p>JDK1.8之前</p><p>JDK1.8 之前 HashMap 底層是 <strong>數組和鏈表</strong> 結合在一起使用也就是 <strong>鏈表散列</strong>。<strong>HashMap 通過 key 的 hashCode 經過擾動函數處理過後得到 hash 值，然後通過 (n - 1) & hash 判斷當前元素存放的位置（這裡的 n 指的是數組的長度），如果當前位置存在元素的話，就判斷該元素與要存入的元素的 hash 值以及 key 是否相同，如果相同的話，直接覆蓋，不相同就通過拉鍊法解決衝突。</strong></p><p><strong>所謂擾動函數指的就是 HashMap 的 hash 方法。使用 hash 方法也就是擾動函數是為了防止一些實現比較差的 hashCode() 方法 換句話說使用擾動函數之後可以減少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源碼:</strong></p><p>JDK 1.8 的 hash方法 相比於 JDK 1.7 hash 方法更加簡化，但是原理不變。</p><pre> static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位異或 // &gt;&gt;&gt;:無符號右移，忽略符號位，空位都以0補齊 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); }</pre><p>對比一下 JDK1.7的 HashMap 的 hash 方法源碼.</p><pre>static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}</pre><p>相比於 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能會稍差一點點，因為畢竟擾動了 4 次。</p><p>所謂 <strong>“拉鍊法”</strong> 就是：將鏈表和數組相結合。也就是說創建一個鏈表數組，數組中每一格就是一個鏈表。若遇到哈希衝突，則將衝突的值加到鏈表中即可。</p><div class=pgc-img><img alt=hashmap源碼分析及常用方法測試_一點課堂（多岸學院） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/13a1f2cd86c14f888755d75f00bc57ff><p class=pgc-img-caption></p></div><p>JDK1.8之後</p><p>相比於之前的版本，jdk1.8在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><div class=pgc-img><img alt=hashmap源碼分析及常用方法測試_一點課堂（多岸學院） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e25f41eebc6541ecb91ae02e248faf89><p class=pgc-img-caption></p></div><p><strong>類的屬性：</strong></p><pre>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { // 序列號 private static final long serialVersionUID = 362498820763181265L;  // 默認的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;  // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;  // 默認的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 當桶(bucket)上的結點數大於這個值時會轉成紅黑樹 static final int TREEIFY_THRESHOLD = 8;  // 當桶(bucket)上的結點數小於這個值時樹轉鏈表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中結構轉化為紅黑樹對應的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存儲元素的數組，總是2的冪次倍 transient Node&lt;k,v&gt;[] table;  // 存放具體元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的個數，注意這個不等於數組的長度。 transient int size; // 每次擴容和更改map結構的計數器 transient int modCount;  // 臨界值 當實際大小(容量*填充因子)超過臨界值時，會進行擴容 int threshold; // 加載因子 final float loadFactor;}</pre><ul><li><strong>loadFactor加載因子</strong></li></ul><p>loadFactor加載因子是控制數組存放數據的疏密程度，loadFactor越趨近於1，那麼 數組中存放的數據(entry)也就越多，也就越密，也就是會讓鏈表的長度增加，loadFactor越小，也就是趨近於0，數組中存放的數據(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor太大導致查找元素效率低，太小導致數組的利用率低，存放的數據會很分散。loadFactor的默認值為0.75f是官方給出的一個比較好的臨界值</strong>。</p><p>給定的默認容量為 16，負載因子為 0.75。Map 在使用過程中不斷的往裡面存放數據，當數量達到了 16 * 0.75 = 12 就需要將當前 16 的容量進行擴容，而擴容這個過程涉及到 rehash、複製數據等操作，所以非常消耗性能。</p><ul><li><strong>threshold</strong></li></ul><p><strong>threshold = capacity * loadFactor</strong>，<strong>當Size>=threshold</strong>的時候，那麼就要考慮對數組的擴增了，也就是說，這個的意思就是 <strong>衡量數組是否需要擴增的一個標準</strong>。</p><p><strong>Node節點類源碼:</strong></p><pre>// 繼承自 Map.Entry&lt;K,V&gt;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash;// 哈希值，存放元素到hashmap中時用來與其他元素hash值比較 final K key;//鍵 V value;//值 // 指向下一個節點 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + "=" + value; } // 重寫hashCode()方法 public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 重寫 equals() 方法 public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; }}</pre><p><strong>樹節點類源碼:</strong></p><pre>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent; // 父 TreeNode&lt;K,V&gt; left; // 左 TreeNode&lt;K,V&gt; right; // 右 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 判斷顏色 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } // 返回根節點 final TreeNode&lt;K,V&gt; root() { for (TreeNode&lt;K,V&gt; r = this, p;;) { if ((p = r.parent) == null) return r; r = p; }</pre><p>HashMap源碼分析</p><p>構造方法</p><div class=pgc-img><img alt=hashmap源碼分析及常用方法測試_一點課堂（多岸學院） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7257e586e40e46548a35996cbad14b6c><p class=pgc-img-caption></p></div><pre> // 默認構造函數。 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted }  // 包含另一個“Map”的構造函數 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面會分析到這個方法 }  // 指定“容量大小”的構造函數 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); }  // 指定“容量大小”和“加載因子”的構造函數 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); }</pre><p><strong>putMapEntries方法：</strong></p><pre>final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { // 判斷table是否已經初始化 if (table == null) { // pre-size // 未初始化，s為m的實際元素個數 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 計算得到的t大於閾值，則初始化閾值 if (t &gt; threshold) threshold = tableSizeFor(t); } // 已初始化，並且m元素個數大於閾值，進行擴容處理 else if (s &gt; threshold) resize(); // 將m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } }}</pre><p>put方法</p><p>HashMap只提供了put用於添加元素，putVal方法只是給put方法調用的一個方法，並沒有提供給用戶使用。</p><p><strong>對putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的數組位置沒有元素 就直接插入。</li><li>②如果定位到的數組位置有元素就和要插入的key比較，如果key相同就直接覆蓋，如果key不相同，就判斷p是否是一個樹節點，如果是就調用e = ((TreeNode )p).putTreeVal(this, tab, hash, key, value) 將元素添加進入。如果不是就遍歷鏈表插入。</li></ul><div class=pgc-img><img alt=hashmap源碼分析及常用方法測試_一點課堂（多岸學院） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ec5aa0b33f2d42828def81a089517b7c><p class=pgc-img-caption></p></div><pre>public V put(K key, V value) { return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者長度為0，進行擴容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 確定元素存放在哪個桶中，桶為空，新生成結點放入桶中(此時，這個結點是放在數組中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已經存在元素 else { Node&lt;K,V&gt; e; K k; // 比較桶中第一個元素(數組中的結點)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 將第一個元素賦值給e，用e來記錄 e = p; // hash值不相等，即key不相等；為紅黑樹結點 else if (p instanceof TreeNode) // 放入樹中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 為鏈表結點 else { // 在鏈表最末插入結點 for (int binCount = 0; ; ++binCount) { // 到達鏈表的尾部 if ((e = p.next) == null) { // 在尾部插入新結點 p.next = newNode(hash, key, value, null); // 結點數量達到閾值，轉化為紅黑樹 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循環 break; } // 判斷鏈表中結點的key值與插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循環 break; // 用於遍歷桶中的鏈表，與前面的e = p.next組合，可以遍歷鏈表 p = e; } } // 表示在桶中找到key值、hash值與插入元素相等的結點 if (e != null) {  // 記錄e的value V oldValue = e.value; // onlyIfAbsent為false或者舊值為null if (!onlyIfAbsent || oldValue == null) //用新值替換舊值 e.value = value; // 訪問後回調 afterNodeAccess(e); // 返回舊值 return oldValue; } } // 結構性修改 ++modCount; // 實際大小大於閾值則擴容 if (++size &gt; threshold) resize(); // 插入後回調 afterNodeInsertion(evict); return null;} </pre><p><strong>我們再來對比一下 JDK1.7 put方法的代碼</strong></p><p><strong>對於put方法的分析如下：</strong></p><ul><li>①如果定位到的數組位置沒有元素 就直接插入。</li><li>②如果定位到的數組位置有元素，遍歷以這個元素為頭結點的鏈表，依次和插入的key比較，如果key相同就直接覆蓋，不同就採用頭插法插入元素。</li></ul><pre>public V put(K key, V value) if (table == EMPTY_TABLE) {  inflateTable(threshold); }  if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { // 先遍歷 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue;  } } modCount++; addEntry(hash, key, value, i); // 再插入 return null;}</pre><p>get方法</p><pre>public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 數組元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一個節點 if ((e = first.next) != null) { // 在樹中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在鏈表中get do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;}</pre><p>resize方法</p><p>進行擴容，會伴隨著一次重新hash分配，並且會遍歷hash表中所有的元素，是非常耗時的。在編寫程序中，要儘量避免resize。</p><pre>final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { // 超過最大值就不再擴充了，就只好隨你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 沒超過最大值，就擴充為原來的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else {  // signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 計算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({"rawtypes","unchecked"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每個bucket都移動到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else {  Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引+oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket裡 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket裡 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;}</pre><p>HashMap常用方法測試</p><pre>package map;import java.util.Collection;import java.util.HashMap;import java.util.Set;public class HashMapDemo { public static void main(String[] args) { HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 鍵不能重複，值可以重複 map.put("san", "張三"); map.put("si", "李四"); map.put("wu", "王五"); map.put("wang", "老王"); map.put("wang", "老王2");// 老王被覆蓋 map.put("lao", "老王"); System.out.println("-------直接輸出hashmap:-------"); System.out.println(map); /** * 遍歷HashMap */ // 1.獲取Map中的所有鍵 System.out.println("-------foreach獲取Map中所有的鍵:------"); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) { System.out.print(key+" "); } System.out.println();//換行 // 2.獲取Map中所有值 System.out.println("-------foreach獲取Map中所有的值:------"); Collection&lt;String&gt; values = map.values(); for (String value : values) { System.out.print(value+" "); } System.out.println();//換行 // 3.得到key的值的同時得到key所對應的值 System.out.println("-------得到key的值的同時得到key所對應的值:-------"); Set&lt;String&gt; keys2 = map.keySet(); for (String key : keys2) { System.out.print(key + "：" + map.get(key)+" "); } /** * 另外一種不常用的遍歷方式 */ // 當我調用put(key,value)方法的時候，首先會把key和value封裝到 // Entry這個靜態內部類對象中，把Entry對象再添加到數組中，所以我們想獲取 // map中的所有鍵值對，我們只要獲取數組中的所有Entry對象，接下來 // 調用Entry對象中的getKey()和getValue()方法就能獲取鍵值對了 Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) { System.out.println(entry.getKey() + "--" + entry.getValue()); }  /** * HashMap其他常用方法 */ System.out.println("after map.size()："+map.size()); System.out.println("after map.isEmpty()："+map.isEmpty()); System.out.println(map.remove("san")); System.out.println("after map.remove()："+map); System.out.println("after map.get(si)："+map.get("si")); System.out.println("after map.containsKey(si)："+map.containsKey("si")); System.out.println("after containsValue(李四)："+map.containsValue("李四")); System.out.println(map.replace("si", "李四2")); System.out.println("after map.replace(si, 李四2):"+map); }}</pre><hr><p>【感謝您能看完，如果能夠幫到您，麻煩點個贊~】</p><p>更多經驗技術歡迎前來共同學習交流：一點課堂-為夢想而奮鬥的在線學習平臺 http://www.yidiankt.com/</p><p>想要深入學習的同學們可以<strong>關注私信我</strong>，一起學習討論~還有全套資源分享，經驗探討，等你哦!</p><div class=pgc-img><img alt=hashmap源碼分析及常用方法測試_一點課堂（多岸學院） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/17a927867f004f8296ebbf80e8fa9ad5><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>hashmap</a></li><li><a>源碼</a></li><li><a>測試</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d1c2a0c.html alt=塑料扯斷伸長率的概念及測試要點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/6fe0ba07-c929-4046-9216-7f6d5eaa1716 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d1c2a0c.html title=塑料扯斷伸長率的概念及測試要點>塑料扯斷伸長率的概念及測試要點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html alt=時間繼電器測試儀的使用方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1205bf787f1f4de6a5f1e73e7737887b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html title=時間繼電器測試儀的使用方法>時間繼電器測試儀的使用方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bee6be40.html alt=河北省邯鄲市計量測試所大力實施專業技能提升行動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bee6be40.html title=河北省邯鄲市計量測試所大力實施專業技能提升行動>河北省邯鄲市計量測試所大力實施專業技能提升行動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9b084990.html alt=介質損耗測試儀的操作方法與注意事項 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/1a746168-e5df-4643-9117-3f1fb4faf100 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9b084990.html title=介質損耗測試儀的操作方法與注意事項>介質損耗測試儀的操作方法與注意事項</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d38b572e.html alt=有關於射頻測試設備：電纜/天線分析儀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0e79c2e668d84f09be994180e66f90c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d38b572e.html title=有關於射頻測試設備：電纜/天線分析儀>有關於射頻測試設備：電纜/天線分析儀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0f90fbd.html alt=透氣性、透氣度測試知多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/45ac8fb9-3365-4327-901d-b21b7cd9cbbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0f90fbd.html title=透氣性、透氣度測試知多少？>透氣性、透氣度測試知多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26e2bf51.html alt=振動測試中需要了解的27個常識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/523bd012e455466f857587d9314c3084 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26e2bf51.html title=振動測試中需要了解的27個常識>振動測試中需要了解的27個常識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html alt="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ab1d67934084ab6bd585f4c84094c76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html title="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究">thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72951256.html alt=現場密度測試方法——灌砂法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e780002be67a3fa5bad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72951256.html title=現場密度測試方法——灌砂法>現場密度測試方法——灌砂法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html alt=測試開發專題：spring-boot統一異常捕獲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/135918e30e2f4a2ea248b539eb383688 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html title=測試開發專題：spring-boot統一異常捕獲>測試開發專題：spring-boot統一異常捕獲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/01e5dc8b.html alt=汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1527412810099aa43fbd71b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/01e5dc8b.html title=汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險>汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbf8b0cf.html alt=Tomcat源碼分析之整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531465870453535efa0b79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbf8b0cf.html title=Tomcat源碼分析之整體架構>Tomcat源碼分析之整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07f82832.html alt="SynchronousQueue 同步隊列入門使用&源碼詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f76c27ed738844d099b011022d2e054f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07f82832.html title="SynchronousQueue 同步隊列入門使用&源碼詳解">SynchronousQueue 同步隊列入門使用&源碼詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>