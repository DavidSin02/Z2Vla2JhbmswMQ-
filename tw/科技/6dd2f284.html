<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面向設計編程 | 极客快訊</title><meta property="og:title" content="面向設計編程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/06312b2d5f874bb380d18771109fc7ee"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6dd2f284.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6dd2f284.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6dd2f284.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6dd2f284.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6dd2f284.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6dd2f284.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6dd2f284.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6dd2f284.html><meta property="article:published_time" content="2020-10-29T21:10:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:38+08:00"><meta name=Keywords content><meta name=description content="面向設計編程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6dd2f284.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面向設計編程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6682238250024698376/?group_id=6682238250024698376" target=_blank>領域設計：聚合與聚合根</a>一文中，提到了兩個導致設計與代碼脫節的情況：</p><ul><li><strong>代碼未反映出軟件架構</strong>：架構圖說的是一回事，代碼說的卻是另外一回事</li><li><strong>設計的表現力不足</strong>：設計沒有體現出某些約束，需要閱讀代碼實現才能清楚具體的內容</li></ul><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6682238250024698376/?group_id=6682238250024698376" target=_blank>領域設計：聚合與聚合根</a>通過淘寶購物的例子說明了「設計的表現力不足」的問題。本文將通過《敏捷軟件開發：原則、模式與實踐》中保齡球計分軟件的例子來說明「代碼未反映出軟件架構」的問題。</p><h1>保齡球記分規則</h1><p>在開始之前，我們需要了解需求，這裡就是「保齡球的記分規則」：</p><ul><li>保齡球一局比賽由10輪組成，在每輪比賽中，參賽者可以投擲兩次來嘗試擊倒所有的瓶子。</li><li>如果參賽者一次即擊倒所有的瓶子，則稱為「全中」，並且本輪結束。</li><li>如果參賽者第一次沒有擊倒所有的瓶子，第二次擊倒了所有的瓶子，則稱為「補中」。</li><li>如果一輪比賽中，兩次投擲都沒有擊倒所有的瓶子，本輪也宣告結束。</li><li><strong>全中輪記分規則</strong>：本輪擊倒得到的10分，加上接下來的兩次投擲擊倒的瓶子數量，再加上前一輪的分數</li><li><strong>補中輪記分規則</strong>：本輪擊倒得到的10分，加上接下來的一次投擲擊倒的瓶子數量，再加上前一輪的分數</li><li><strong>其它輪記分規則</strong>：本輪兩次擊倒的瓶子數量，再加上前一輪的分數</li><li>如果第十輪為全中，那麼參賽者可以多投兩次，以完成對全中的記分</li><li>相應的，如果第十輪為補中，那麼參賽者可以多投一次，以完成對補中的記分。</li></ul><h1>初步設計</h1><p>從上面的規則，我們可以得到初步的設計：</p><ul><li>一局比賽(Game)有10輪(Frame)</li><li>每輪(Frame)有一到三次投擲(Throw)</li><li class=ql-indent-1>全中則是一次投擲</li><li class=ql-indent-1>其它為兩次投擲</li><li class=ql-indent-1>最後一輪如果全中或補中，則是三次投擲</li><li class=ql-indent-1>也就是說，遊戲最多可以投23次</li><li>每輪的記分規則如下：</li><li class=ql-indent-1>全中輪：本輪10分+後兩次投擲得分+前一輪得分</li><li class=ql-indent-1>補中輪：本輪10分+後一次投擲得分+前一輪得分</li><li class=ql-indent-1>其它輪：本輪兩次投擲得分綜合+前一輪得分</li><li class=ql-indent-1>也就是說，遊戲得分即當前輪的得分</li></ul><p>對象初步關係如下：</p><div class=pgc-img><img alt=面向設計編程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06312b2d5f874bb380d18771109fc7ee><p class=pgc-img-caption></p></div><h1>《敏捷》中的代碼</h1><p>《敏捷》花了一章的內容來討論這個軟件的開發過程。初步設計如上圖所示，然後通過結對編程+TDD的方式一步步的進行代碼演進（具體推導過程請閱讀《敏捷》，這裡不再贅述），最終得到的如下代碼：</p><pre>public class Game { private int itsCurrentFrame = 0; private boolean firstThrowInFrame = true; private Scorer itsScorer = new Scorer(); public int score() { return scoreForFrame(itsCurrentFrame); } public void add(int pins) { itsScorer.addThrow(pins); adjustCurrentFrame(pins); } public int scoreForFrame(int theFrame) { return itsScorer.scoreForFrame(theFrame); } private void adjustCurrentFrame(int pins) { if (lastBallInFrame(pins)) { advanceFrame(); } else { firstThrowInFrame = false; } } private boolean lastBallInFrame(int pins) { return strike(pins) || !firstThrowInFrame; } private boolean strike(int pins) { return (firstThrowInFrame &amp;&amp; pins == 10); } private void advanceFrame() { itsCurrentFrame = Math.min(10, itsCurrentFrame + 1); }}public class Scorer { private int ball; private int[] itsThrows = new int[21]; private int itsCurrentThrow = 0; public void addThrow(int pins) { itsThrows[itsCurrentThrow++] = pins; } public int scoreForFrame(int theFrame) { ball = 0; int score = 0; for (int currentFrame = 0; currentFrame &lt; theFrame; currentFrame++) { if (strike()) { score += 10 + nextTwoBallsForStrike(); ball++; } else if (spare()) { score += 10 + nextBallForSpare(); ball += 2; } else { score += twoBallsInFrame(); ball += 2; } } return score; } private int twoBallsInFrame() { return itsThrows[ball] + itsThrows[ball + 1]; } private int nextBallForSpare() { return itsThrows[ball + 2]; } private int nextTwoBallsForStrike() { return itsThrows[ball + 1] + itsThrows[ball + 2]; } private boolean spare() { return (itsThrows[ball] + itsThrows[ball + 1]) == 10; } private boolean strike() { return itsThrows[ball] == 10; }}</pre><ul><li>一個Game類表示遊戲本身</li><li>一個Scorer類用於計算Game的得分</li><li>初始設計中的Frame和Throw都隱藏到了代碼中</li></ul><p>從代碼本身來看，實現足夠簡單，變量名、方法名取得都有意義，符合開發原則，有完整的單元測試。但是，<strong>代碼結構沒有體現出業務邏輯</strong>。</p><p>上面的代碼結構如下：</p><div class=pgc-img><img alt=面向設計編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6086da09c6e94d99afbf7ac38b0ca24b><p class=pgc-img-caption></p></div><p>從這個類關係圖中，只能看出來有一個遊戲（Game）和這個遊戲的得分（Scorer）！這是從編程的角度一步步推導出來的代碼，在推導的過程中可能是理所當然的，但是過了一段時間後，你再來看這段代碼的時候，可能就不記得這段代碼是幹嘛的了！</p><p>另一方面，當別人來接手這段代碼時，你是否是先告訴他業務邏輯，然後讓他看代碼？但是因為代碼結構與設計的脫離，導致了雖然已經理解了業務邏輯、代碼結構也很清晰，但是還是需要讀了源碼才能清楚這段代碼具體是幹嘛的！這是否是增加了理解的難度？</p><p>原因就是這個結構關係<strong>沒有體現出業務邏輯</strong>！理想情況應該是在開發人員<strong>理解業務以後，從代碼結構就可以理解具體的實現</strong>！</p><h1>從業務推導</h1><p>在保齡球記分邏輯中，是有輪（Frame）和投擲（Throw）這兩個概念的，所以在代碼中需要保留這兩個類！</p><pre>public class Frame {}public class Throw {}</pre><p>一局遊戲有十輪，所以在創建Game時就初始化十個Frame。同時，當前Frame的計算，需要前一個Frame的得分，所以除了第一個Frame，其它Frame都持有前一個Frame的引用，同時每個Frame都知道自己是第幾局（roundNum）！</p><pre>public class Game { private static final int MAX_ROUND = 10;// 一局有十輪 private Frame[] frameList = new Frame[MAX_ROUND]; public Game() { for (int i = 0; i &lt; MAX_ROUND; i++) { frameList[i] = new Frame(i); if (i &gt; 0) { frameList[i].setPreFrame(frameList[i - 1]); } } }}public class Frame { private int roundNum; // 所在局，從0開始 private Frame preFrame; public Frame(int roundNum) { this.roundNum = roundNum; }  public void setPreFrame(Frame preFrame) { this.preFrame = preFrame; }}</pre><p>每一次投擲都會有擊倒數量，所以Throw中需要有字段表示擊倒數量，同時因為一次投擲後，數量是不可修改的，所以數量由構造函數傳入，只有get方法而沒有set方法：</p><pre>public class Throw { private int num; // 擊倒數量 public Throw(int num) { this.num = num; } public int getNum() { return num; }}</pre><p>Frame可以包括1到3次Throw，而按照全中、補中、其它擊中的不同，記分方式也有所不同。如果完全按照這個邏輯編寫，代碼會相對複雜。因為需要根據擊倒方式的不同，判斷是否要獲取後兩次的投擲。我們是否可以做一些調整？我們實際上是要計算投擲的得分，那麼這個投擲屬於哪一輪，是不是就不是那麼重要了？也就是說，投擲和記分規則可以調整為下面這樣：</p><ul><li>每輪(Frame)有一到三次投擲(Throw)</li><li class=ql-indent-1>全中為一次當前輪投擲+後兩次投擲</li><li class=ql-indent-1>補中為兩次當前輪投擲+後一次投擲</li><li class=ql-indent-1>其它為兩次投擲</li><li class=ql-indent-1>也就是說，遊戲最多可以投23次</li><li>每輪的記分，為<strong>當前Frame投擲的得分的總和+前一輪的得分</strong></li></ul><p>現在Frame分數的計算就統一了！</p><pre>public class Frame { private List&lt;Throw&gt; throwList = new ArrayList&lt;&gt;(); public int score() { int throwScore = throwList.stream().mapToInt(it -&gt; it.getNum()).sum(); if (preFrame != null) { throwScore += preFrame.score(); } return throwScore; }}</pre><p>最後，就是怎麼將一個Throw添加到Frame中，按照上面的設計調整，一次Throw可能既屬於當前輪，也屬於上一輪甚至上上輪！怎們樣來判斷呢？根據Frame是全中、還是補中還是其它來判定，所以Frame中需要有方法來判定自身是全中、補中還是其它！</p><pre>public class Frame { private boolean isSpare() { // 是否是補中 return throwList.size() &gt;= 2 &amp;&amp; throwList.get(0).getNum() &lt; 10 &amp;&amp; (throwList.get(0).getNum() + throwList.get(1).getNum() == 10); } private boolean isStrike() { // 是否是全中 return throwList.size() &gt;= 1 &amp;&amp; throwList.get(0).getNum() == 10; }}</pre><p>一次Throw添加到Frame後，還要判斷這個Frame是否已經結束，即：</p><ul><li>如果這個Frame是全中或補中，是否已經包含了三次投擲</li><li>如果這個Frame為普通擊倒，是否已經包含了兩次投擲</li></ul><pre>public class Frame {  public boolean isFinish() { if (throwList.size() == 3) return true; if (throwList.size() == 2 &amp;&amp; !isStrike() &amp;&amp; !isSpare()) { return true; } return false; } }</pre><p>同時還要判斷，是否進入下一輪：</p><pre>public class Frame {  public int add(Throw aThrow) { this.throwList.add(aThrow); if (isStrike() || isSpare() || isFinish()) return Math.min(9, roundNum + 1); return roundNum; } }</pre><p>Game就是將Throw添加到當前輪和上一輪及上上輪的邏輯：</p><pre>public class Game { public void add(int pins) { Throw aThrow = new Throw(pins); add2PreFrame(aThrow);// 根據邏輯判定是否要添加到上一輪，或上上輪 currentFrameIdx = frameList[currentFrameIdx].add(aThrow); // 添加當前輪後，是否進入下一輪 } private void add2PreFrame(Throw aThrow) { if (currentFrameIdx - 1 &gt;= 0 &amp;&amp; !frameList[currentFrameIdx - 1].isFinish()) { frameList[currentFrameIdx - 1].add(aThrow); } if (currentFrameIdx - 2 &gt;= 0 &amp;&amp; !frameList[currentFrameIdx - 2].isFinish()) { frameList[currentFrameIdx - 2].add(aThrow); } }}</pre><p><strong>調整後的設計如下</strong>：</p><ul><li>一局比賽(Game)有10輪(Frame)</li><li>一次投擲(Throw)得分可能屬於一到三輪(Frame)</li><li class=ql-indent-1>屬於當前輪</li><li class=ql-indent-1>如果前一輪是全中或補中，則此次投擲也屬於前一輪</li><li class=ql-indent-1>如果上上輪屬於全中，則此次投擲也屬於上上輪</li><li class=ql-indent-1>遊戲最多可以投擲23次</li><li>每輪的記分，為<strong>當前Frame投擲的得分的總和+前一輪的得分</strong></li></ul><p>對應的類結構如下：</p><div class=pgc-img><img alt=面向設計編程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5f4569635a814ec588281e49f8257bda><p class=pgc-img-caption></p></div><p>此結構與設計相符和，只要理解了業務邏輯，順著業務就可以梳理出代碼結構，即使不看源碼，也能猜到代碼的邏輯！</p><p>《敏捷》中有效代碼行數為71行，上面的有效代碼為79行，多了8行代碼！但是從理解上來看的話，後者更易於理解！完整代碼見下文。</p><h1>完整代碼</h1><pre>public class Game { private static final int MAX_ROUND = 10;// 一局有十輪 private Frame[] frameList = new Frame[MAX_ROUND]; private int currentFrameIdx = 0; public Game() { for (int i = 0; i &lt; MAX_ROUND; i++) { frameList[i] = new Frame(i); if (i &gt; 0) { frameList[i].setPreFrame(frameList[i - 1]); } } } public int score() { return frameList[currentFrameIdx].score(); } public void add(int pins) { Throw aThrow = new Throw(pins); add2PreFrame(aThrow); currentFrameIdx = frameList[currentFrameIdx].add(aThrow); } private void add2PreFrame(Throw aThrow) { if (currentFrameIdx - 1 &gt;= 0 &amp;&amp; !frameList[currentFrameIdx - 1].isFinish()) { frameList[currentFrameIdx - 1].add(aThrow); } if (currentFrameIdx - 2 &gt;= 0 &amp;&amp; !frameList[currentFrameIdx - 2].isFinish()) { frameList[currentFrameIdx - 2].add(aThrow); } } public int scoreForFrame(int theFrame) { return frameList[theFrame - 1].score(); }}public class Frame { private int roundNum; // 所在局,從0開始 private Frame preFrame; private List&lt;Throw&gt; throwList = new ArrayList&lt;&gt;(); public Frame(int roundNum) { this.roundNum = roundNum; } public int score() { int throwScore = throwList.stream().mapToInt(it -&gt; it.getNum()).sum(); if (preFrame != null) { throwScore += preFrame.score(); } return throwScore; } public int add(Throw aThrow) { this.throwList.add(aThrow); if (isStrike() || isSpare() || isFinish()) return Math.min(9, roundNum + 1); return roundNum; } public boolean isFinish() { if (throwList.size() == 3) return true; if (throwList.size() == 2 &amp;&amp; !isStrike() &amp;&amp; !isSpare()) { return true; } return false; } private boolean isSpare() { return throwList.size() &gt;= 2 &amp;&amp; throwList.get(0).getNum() &lt; 10 &amp;&amp; (throwList.get(0).getNum() + throwList.get(1).getNum() == 10); } private boolean isStrike() { return throwList.size() &gt;= 1 &amp;&amp; throwList.get(0).getNum() == 10; } public void setPreFrame(Frame preFrame) { this.preFrame = preFrame; }}public class Throw { private int num; // 擊倒數量 public Throw(int num) { this.num = num; } public int getNum() { return num; }}</pre><h1>總結</h1><p>本文通過《敏捷》中保齡球的例子，來<strong>說明了代碼不能體現設計的原因及提出一種保證代碼和設計相一致的方法</strong>。</p><p>設計本身就是一種取捨，沒有完全正確的方法，只有適合的方法。從代碼本身出發，能夠構建出符合編碼原則的代碼，但是可能和設計本身有出入，這可能會增加後續的理解難度，變相增加了修改代碼的難度；反之從設計觸發，能構建出和設計相匹配的代碼，但是可能代碼本身的易讀性、代碼量、符合編碼原則上會有所妥協。</p><p>個人認為，<strong>對於業務邏輯不復雜，但是計算邏輯很複雜的代碼，以按照代碼原則來編寫代碼為主，以按照業務邏輯編寫代碼邏輯為輔，以保證代碼的簡潔明瞭；而對於業務邏輯複雜，但是計算邏輯不復雜的代碼，以按照業務邏輯編寫代碼為主，以按照代碼原則編寫代碼為輔，以保證代碼結構與業務邏輯的直觀匹配</strong>。</p><p>以上內容僅為個人觀點，歡迎探討！</p><h1>參考資料</h1><ul><li>《敏捷軟件開發：原則、模式與實踐》</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>設計</a></li><li><a>編程</a></li><li><a>面向</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d04923f.html alt=「分享」可編程控制器控制系統設計的基本步驟，你還知道哪些？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49ce3ce367f44139b7385596fc0df095 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d04923f.html title=「分享」可編程控制器控制系統設計的基本步驟，你還知道哪些？>「分享」可編程控制器控制系統設計的基本步驟，你還知道哪些？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b74636e.html alt=程序設計中面向接口編程是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b74636e.html title=程序設計中面向接口編程是什麼>程序設計中面向接口編程是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44f62298.html alt=面向過程編程，面向對象編程，我們到底在面向什麼編程？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/225971a8627149b6917c882e94a4cbbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44f62298.html title=面向過程編程，面向對象編程，我們到底在面向什麼編程？>面向過程編程，面向對象編程，我們到底在面向什麼編程？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html alt=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532998144998addd88387a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html title=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則>都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html alt=面向對象編程設計的類與對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/86e56bdd947940c4b06129e01f19706a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html title=面向對象編程設計的類與對象>面向對象編程設計的類與對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d1cde35.html alt=面向思維的程序設計——你知道麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/1b840004df5541d24d4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d1cde35.html title=面向思維的程序設計——你知道麼？>面向思維的程序設計——你知道麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ee1c425.html alt=面向對象程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ee1c425.html title=面向對象程序設計>面向對象程序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af61cd5.html alt=編程｜從數據與函數的關係看面向對象與面向過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9b3f5f06061c4fa4992aafd0c381ef76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af61cd5.html title=編程｜從數據與函數的關係看面向對象與面向過程>編程｜從數據與函數的關係看面向對象與面向過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ec57e2.html alt=可編程控制系統設計的七個步驟 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ec57e2.html title=可編程控制系統設計的七個步驟>可編程控制系統設計的七個步驟</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c1015d.html alt=設計模式與面向對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/16acdcfa22704aa79304befb027b6588 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c1015d.html title=設計模式與面向對象>設計模式與面向對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/963f612.html alt=面向對象的程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/830e36c55b764c49b77ad9420aba5039 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/963f612.html title=面向對象的程序設計>面向對象的程序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html alt=鋼構人福利——鋼結構設計經典問題解讀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a72bd60ea48d471b8ce03ebf0ce15869 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html title=鋼構人福利——鋼結構設計經典問題解讀>鋼構人福利——鋼結構設計經典問題解讀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html alt=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153569494612546362474a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html title=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先>鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html alt=38個鋼結構設計問題，都很常見 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f1181ce8-cf01-4194-b9c2-362f43894ddb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html title=38個鋼結構設計問題，都很常見>38個鋼結構設計問題，都很常見</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>