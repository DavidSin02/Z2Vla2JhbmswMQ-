<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>事件循環：微任務與宏任務 | 极客快訊</title><meta property="og:title" content="事件循環：微任務與宏任務 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/0bfecfff8e394205b16a211beb605d5d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e3e1b61.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e3e1b61.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6e3e1b61.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e3e1b61.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e3e1b61.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6e3e1b61.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6e3e1b61.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e3e1b61.html><meta property="article:published_time" content="2020-11-14T21:05:39+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:39+08:00"><meta name=Keywords content><meta name=description content="事件循環：微任務與宏任務"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6e3e1b61.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>事件循環：微任務與宏任務</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>JavaScript的執行流，無論是瀏覽器還是Node.js，都是基於 事件循環 。</p><p>理解事件循環能夠讓我們寫出更可靠的高性能代碼。</p><p>讓我們先介紹一下事件循環的原理，然後再來看看實際應用。</p><h2 class=pgc-h-arrow-right>事件循環（Event Loop）</h2><p>事件循環的概念非常簡單。它就是一個無止境的循環，JavaScript引擎等待任務（tasks）出現，然後執行任務，執行完畢後繼續等待任務出現。</p><p>JavaScript引擎對事件循環的算法為：</p><ol start=1><li>當發現任務時：執行任務，從最先進入隊列的任務開始</li><li>等待其他任務出現，然後執行步驟1。</li></ol><p>當瀏覽網頁時，就是以這種方式呈現。JavaScript引擎在大部分時間都處於空閒狀態，僅在被腳本文件、處理函數，事件系統激活時才運行。</p><p>比如：</p><pre><code>&lt;script src=''&gt;</code></pre><p>任務出現 - 引擎處理任務 - 然後等待其他任務出現（空閒時CPU消耗幾乎為0）。</p><p>在引擎處理任務的過程中，有可能會有其他任務出現，此時其他任務將會被放進隊列。</p><p>這些由任務組成的隊列就叫做“宏任務隊列(macrotasks queue)”（ <strong>V8</strong> 術語）：</p><div class=pgc-img><img alt=事件循環：微任務與宏任務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0bfecfff8e394205b16a211beb605d5d><p class=pgc-img-caption></p></div><p>例如，當引擎正在處理一個 script 文件時，用戶移動鼠標觸發了 mousemove 事件，此時剛好 setTimeout 的回調函數也將執行，這些任務將會形成一個隊列， 如上圖所示。</p><p>來自隊列的任務會按照“先進先出”的順序來執行，當瀏覽器處理完畢 script 文件，然後就會執行 mousemove 事件處理函數，然後 setTimeout 回調函數，等等。</p><p>到目前為止，還算簡單，對吧？</p><p>還有兩條重要的詳細信息：</p><ol start=1><li>當引擎在處理任務時，頁面絕對不會開始渲染。即使任務會執行很長一段時間。對DOM的修改僅僅在任務處理完畢後才會渲染到頁面上。</li><li>如果任務處理消耗很長時間，瀏覽器無法處理其他任務，例如用戶事件，那麼一段時間後瀏覽器將會彈框提示頁面無響應，並建議關閉頁面。當進行大量的複雜運算或者由於程序錯誤導致死循環時，彈窗就會出現。</li></ol><p>這就是事件循環的原理。現在來看看實際應用吧。</p><h4 class=pgc-h-arrow-right>使用案例1：分離耗CPU的任務</h4><p>假如我們有一個耗費CPU的任務。</p><p>例如，語法高亮（用於給示例代碼上色）是非常消耗CPU的。為了使代碼高亮，它分析、創建許多已經對代碼進行高亮的元素，將他們添加到文檔 - 這樣的元素越多，消耗的時間越長。</p><p>當引擎正在處理語法高亮時，它無法處理其他與DOM相關的事情，例如處理用戶事件。並且可能會帶來一些我們無法接受的頁面“卡住”。</p><p>我們可以通過將這些非常消耗CPU的任務分離成一個個的小任務來阻止這種情況。先高亮100行，然後設置一個計時器（延遲0秒）高亮下一個100行，等等。</p><p>為了更加簡單地闡述這個過程，讓我們用一個從0到1的計數函數來代替語法高亮。</p><p>如果你運行下面的代碼，引擎將會卡住一段時間。對於服務端來說，更加的顯而易見，如果你在瀏覽器中運行，然後點擊頁面中的其他按鈕-你就會發現在計數操作執行完畢之前，其他事件都不會觸發。</p><pre><code>let i = 0;let start = Date.now();function count() {  // do a heavy job  for (let j = 0; j &lt; 1e9; j++) {    i++;  }  alert("Done in " + (Date.now() - start) + 'ms');}count();</code></pre><p>瀏覽器甚至可能會顯示出一個“the script takes too long”的警告。</p><p>讓我們使用嵌套的 setTimeout 來分離這個任務：</p><pre><code>let i = 0;let start = Date.now();function count() {  // do a piece of the heavy job (*)  do {    i++;  } while (i % 1e6 != 0);  if (i == 1e9) {    alert("Done in " + (Date.now() - start) + 'ms');  } else {    setTimeout(count); // schedule the new call (**)  }}count();</code></pre><p>現在即使在處理計數的過程中，瀏覽器的事件系統也會是可用的。</p><p>單次運行 count() 執行計數的一部分（用*號表示），如果後面還需要執行，則通過計時器再重複執行。</p><ol start=1><li>先執行的數字：i=1...1000000</li><li>然後執行的數字：i=1000001..2000000</li><li>等等...</li></ol><p>現在，如果引擎正在執行第一步時，另一個任務（例如 onclick 事件）觸發，這個任務將被放入隊列，然後在第一步執行完畢後、在第二步之前被執行。週期性地執行計數操作能夠使JavaScript引擎有足夠的空閒去做其他事情，比如響應用戶的操作。</p><h4 class=pgc-h-arrow-right>使用案例2：進度指示</h4><p>在瀏覽器腳本中，分離耗費CPU任務的另一個好處是可以顯示進度信息。</p><p>通常情況下，只有在當前正在運行的代碼執行完畢後，瀏覽器才會進行渲染。無論其是否消耗很長一段時間。當任務完成以後，瀏覽器才會對DOM操作進行渲染。</p><p>不得不說這樣做有它的好處，因為函數執行過程中可能會創建多個元素、一個一個的添加到文檔中並且修改它們的樣式-用戶不會看到任何中間的、沒有完成的狀態。</p><p>例如：對i的改變不會立即顯示，而是等到函數執行完畢，所以我們只會看到最後一個值。</p><pre><code>&lt;div id="progress"&gt;&lt;/div&gt;&lt;script&gt;  function count() {    for (let i = 0; i &lt; 1e6; i++) {      i++;      progress.innerHTML = i;    }  }  count();&lt;/script&gt;</code></pre><p>...但是假如我們想在任務執行過程中展示一些額外信息，例如進度條。</p><p>如果我們把這些‘重’的任務通過 setTimeout 分離成一個一個的小任務，那麼對i的改變會不斷地被渲染出來。</p><p>例如：</p><pre><code>&lt;div id="progress"&gt;&lt;/div&gt;&lt;script&gt;  let i = 0;  function count() {    // do a piece of the heavy job (*)    do {      i++;      progress.innerHTML = i;    } while (i % 1e3 != 0);    if (i &lt; 1e7) {      setTimeout(count);    }  }  count();&lt;/script&gt;</code></pre><p>現在， div 元素會顯示不斷增加的i的值，像極了進度條。</p><h4 class=pgc-h-arrow-right>使用案例3：在事件以後做些什麼</h4><p>在一個事件處理函數中，我們可能會延緩執行某些操作，直到事件冒泡完成並且被所有事件階段所處理。我們可以通過將某些操作包裹在0秒延遲的 setTimeout 中。</p><p>因為原文案例設計一些額外知識( <strong>CustomeEvent 自定義事件</strong> )，為了簡單起見，此處為作者提供案例 ：</p><pre><code>&lt;div id='div'&gt;      &lt;button id='button'&gt;hello&lt;/button&gt;    &lt;/div&gt;        &lt;script&gt;      div.addEventListener('click', () =&gt; {        alert('div!')      });      button.addEventListener('click', () =&gt; {        alert('button!');        setTimeout(() =&gt; {          alert('click事件已被處理完畢!')        })      })    &lt;/script&gt;</code></pre><h4 class=pgc-h-arrow-right>宏任務和微任務</h4><p>除了在上文提到過的宏任務外，還存在著 微任務(microtasks) 。</p><p>異步任務需要更準確地管理。所以，ECMA標準定義了一個內部隊列 promiseJobs ，更多地被稱作是“微任務隊列（microtask queue）”（ES8術語）。</p><p>如ESMA262中所 <strong>定義</strong> :</p><ul><li>微任務隊列為“先進先出”：最先進入隊列的任務最先執行</li><li>只有當目前沒有運行其他任何任務時，微任務才會開始執行</li></ul><p>簡單來說，當一個 Promise 已就緒，它的 .then/catch/finally 事件處理函數將被放入隊列；它們暫時不會被執行。只有當JS引擎處理完當前的代碼，才會按照順序執行微任務隊列中的任務。</p><p>例如：</p><pre><code>let promise = Promise.resolve();promise.then(() =&gt; alert("promise done!"));alert("code finished"); // this alert shows first</code></pre><p>執行上面代碼， code finished 將會先顯示，然後是 promise done! 。</p><div class=pgc-img><img alt=事件循環：微任務與宏任務 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/58993bdc4edb48b7a5e4400a6bf28e48><p class=pgc-img-caption></p></div><p>Promise函數永遠會按照這個順序執行。</p><p>如果是鏈式的 .then/catch/finally ，那麼會異步地執行每一項。也就是說，先將他們放入微任務隊列，然後等待當前代碼執行完畢，並且微任務隊列中前面的任務執行完畢，然後執行。</p><p>如果需要按照順序執行呢？如果確保 promise done 先顯示，然後才是 code finished 呢？</p><p>只需要通過 .then 來將它們依次放入隊列：</p><pre><code>Promise.resolve()  .then(() =&gt; alert("promise done!"))  .then(() =&gt; alert("code finished"));</code></pre><p>微任務來自於我們的代碼。通常是通過Promise創建， .then/catch/finally 的處理函數成為一個微任務。同樣， await 函數也適用，它是另一種Promise的處理方式。</p><p>另外，通過 queueMicrotask(func) 函數可以將 func 這個函數放入微任務隊列（目前IE還不支持）。</p><p>在每一個宏任務執行完畢後，引擎會立即執行微任務隊列中的所有任務，然後繼續執行其他宏任務或渲染DOM操作。</p><p>例如：</p><pre><code>setTimeout(() =&gt; alert("timeout"));Promise.resolve()  .then(() =&gt; alert("promise"));alert("code");</code></pre><p>上面的代碼中彈框將會按照什麼順序顯示呢？</p><ol start=1><li>先顯示 code ，因為它是一個普通的同步函數；</li><li>然後顯示 promise ，因為 .then 處於微任務隊列中，所以噹噹前宏任務執行完畢就會執行；</li><li>最後顯示 timeout ，因為它是另一個宏任務。</li></ol><p>完整的事件循環流程：（從上往下，腳本文件(宏任務) -> 微任務 -> 渲染操作 -> 重複流程...）</p><div class=pgc-img><img alt=事件循環：微任務與宏任務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/556c25f388fc4aafb31c3daed4e9ce30><p class=pgc-img-caption></p></div><p>在任何其他的事件處理函數、渲染操作或其他宏任務執行之前，所有的微任務都會執行完畢。</p><p>如果我們希望去異步地執行一個函數（當前代碼執行完畢後），但是在DOM操作被渲染之前，或者其他事件處理函數、宏任務執行之前，可以通過 queueMicrotask 來設置。</p><p>另一個進度指示條的例子：和上文中提到的那個類似，但是在這裡用的是 queueMicrotask ，而不是 setTimeout 。在每一個宏任務執行完畢後都會進行渲染操作，就好像是同步代碼：</p><pre><code>&lt;div id="progress"&gt;&lt;/div&gt;&lt;script&gt;  let i = 0;  function count() {    // do a piece of the heavy job (*)    do {      i++;      progress.innerHTML = i;    } while (i % 1e3 != 0);    if (i &lt; 1e6) {      queueMicrotask(count);    }  }  count();&lt;/script&gt;</code></pre><h4 class=pgc-h-arrow-right>總結</h4><p>更多關於事件循環算法的詳細信息（和 <strong>事件循環定義</strong> 來比，仍然是很簡單的）：</p><ol start=1><li>宏任務中最先進入的任務最先出列並且執行（例如腳本文件）；</li><li>執行所有微任務：當微任務隊列不為空時：微任務隊列中最先進入的任務出列並且執行</li><li>執行渲染操作（如果有對DOM進行修改的話）；</li><li>如果宏任務隊列為空的話，等待宏任務出現；</li><li>執行步驟1。</li></ol><p>如果要設置一個新的宏任務：</p><ul><li>使用0秒延遲 setTimeout(f)</li></ul><p>當把一個涉及大量運算的任務分離成一個一個的小任務時，設置新的宏任務就能夠使得瀏覽器能夠對用戶的操作做出響應並展示進度。</p><p>同樣可用於事件處理函數，當事件被完全處理完畢（事件冒泡完畢）後執行一個操作。</p><p>如果要設置一個新的微任務：</p><pre><code>queueMicrotask(f)Promise</code></pre><p>在微任務隊列處理期間，任何UI或者網絡事件都不會被處理，微任務隊列中的所有任務會一個一個立即執行。</p><p>所以我們可能會用 queueMicrotask 去異步執行一個函數，但是當前的環境狀態（environment state）還沒有被改變。</p><p>Web Workers</p><p>如果不想阻塞事件循環，在涉及到非常大的複雜運算時，可以使用 <strong>Web Workers</strong> 。</p><p>通過並行線程的方式來運行代碼</p><p>Web Workers能夠與主過程交換信息，但它擁有自己的變量、事件循環</p><p>Web Workers不能訪問DOM，所以在進行計算時同時使用多核CPU是非常有用的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>循環</a></li><li><a>微任務</a></li><li><a>宏任務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/09fe16de.html alt="JavaScript 之 宏任務，微任務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/164237e0297c4f8697eccedecb547980 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09fe16de.html title="JavaScript 之 宏任務，微任務">JavaScript 之 宏任務，微任務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32c82df2.html alt=熱水鍋爐房循環水泵選型建議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32c82df2.html title=熱水鍋爐房循環水泵選型建議>熱水鍋爐房循環水泵選型建議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48532629.html alt=循環⽔養殖指標-溶解氧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/56d1472f673a48fcb736dca88bf7b39c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48532629.html title=循環⽔養殖指標-溶解氧>循環⽔養殖指標-溶解氧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d9a5540.html alt=循環流化床鍋爐耐磨耐火材料都有哪些？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/85eb71ea22e548ff81c68a4c0216f09a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d9a5540.html title=循環流化床鍋爐耐磨耐火材料都有哪些？>循環流化床鍋爐耐磨耐火材料都有哪些？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f833cb1e.html alt="技術 | 淺談循環流化床鍋爐大修時的防磨處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f833cb1e.html title="技術 | 淺談循環流化床鍋爐大修時的防磨處理">技術 | 淺談循環流化床鍋爐大修時的防磨處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/80eda0c9.html alt=工業循環冷卻水處理（三） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a8094522823a4a4fab20b39b9c4a062c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/80eda0c9.html title=工業循環冷卻水處理（三）>工業循環冷卻水處理（三）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/41882779.html alt=什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e06e4d3087d4032ab0d9dfb3d7d2e89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/41882779.html title=什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司>什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7061034.html alt=循環流化床鍋爐1000問（四）優化試驗篇1循環流化床鍋爐冷態試驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3cfade6d49b044d199d262c3b6d40f1a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7061034.html title=循環流化床鍋爐1000問（四）優化試驗篇1循環流化床鍋爐冷態試驗>循環流化床鍋爐1000問（四）優化試驗篇1循環流化床鍋爐冷態試驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90f40400.html alt="挪威小鎮改造方案：景觀循環the landscape loop" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/435200015e999fea9af2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90f40400.html title="挪威小鎮改造方案：景觀循環the landscape loop">挪威小鎮改造方案：景觀循環the landscape loop</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a83bdbe.html alt=燃料電池氫氣循環設計方案探討 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c98d4743f6e749ff993165fcb3fe7ed8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a83bdbe.html title=燃料電池氫氣循環設計方案探討>燃料電池氫氣循環設計方案探討</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3eb1a09.html alt=10億元新材料循環利用項目落戶寶雞高新區 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3eb1a09.html title=10億元新材料循環利用項目落戶寶雞高新區>10億元新材料循環利用項目落戶寶雞高新區</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/120d09ba.html alt=基於能量法的混凝土循環加卸載動態損傷特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8ada258408d346f99afe358fede68d5c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/120d09ba.html title=基於能量法的混凝土循環加卸載動態損傷特性>基於能量法的混凝土循環加卸載動態損傷特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/31ee2bf4.html alt=用完的瓶子扔進自動回收機，超九成循環利用創造了丹麥新紀錄 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rzzw97J7yjjkfH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/31ee2bf4.html title=用完的瓶子扔進自動回收機，超九成循環利用創造了丹麥新紀錄>用完的瓶子扔進自動回收機，超九成循環利用創造了丹麥新紀錄</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82f5d9ff.html alt=Scala循環性能問題，為了性能，你願意犧牲代碼的可維護性麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/314c9a3074774fb48305ca5173282bb5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82f5d9ff.html title=Scala循環性能問題，為了性能，你願意犧牲代碼的可維護性麼？>Scala循環性能問題，為了性能，你願意犧牲代碼的可維護性麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1d32f3f.html alt=javascript中的宏任務與微任務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/664e98c4-c156-458f-a172-5502c246e157 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1d32f3f.html title=javascript中的宏任務與微任務>javascript中的宏任務與微任務</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>