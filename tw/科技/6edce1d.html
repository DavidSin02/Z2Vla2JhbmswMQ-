<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Golang(四)語言特性(下) | 极客快訊</title><meta property="og:title" content="Golang(四)語言特性(下) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6edce1d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6edce1d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6edce1d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6edce1d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6edce1d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6edce1d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6edce1d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6edce1d.html><meta property="article:published_time" content="2020-10-29T21:00:26+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:26+08:00"><meta name=Keywords content><meta name=description content="Golang(四)語言特性(下)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6edce1d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Golang(四)語言特性(下)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>索引表達式</strong> 基本表達式形如</p><pre>a[x]</pre><p>表示數組的元素、指向數組的指針、切片、字符串或可由x索引的map，值x分別被稱為索引鍵或map鍵。以下規則適用</p><p>如果a不是map</p><ul><li>索引x必須是整數類型或未定義類型的常量</li><li>常量索引必須是非負的，並且可以由int類型的值表示</li><li>非類型化的常量索引被賦予int類型</li><li>如果x取值超出[0, len(x) - 1]範圍，則索引x越界</li></ul><p>對於數組類型A</p><ul><li>常數索引必須在範圍內</li><li>如果x越界，會發生運行時panic</li><li>a[x]是索引位置x處的數組元素，a[x]的類型為數組A的元素類型</li></ul><p>對於數組類型的指針</p><ul><li>a[x]是(*a)[x]的縮寫</li></ul><p>對於切片類型S</p><ul><li>如果x運行時越界，產生運行時panic</li><li>a[x]是索引位置x處的切片元素，a[x]的類型為切片S的元素類型</li></ul><p>對於字符串類型</p><ul><li>如果字符串a也是常量，則常量索引必須在有效範圍內</li><li>如果發生運行時越界，會產生運行時panic</li><li>a[x]是索引位置x處的byte值，a[x]的類型為byte</li><li>a[x]不可被賦值</li></ul><p>對於Map類型M</p><ul><li>索引x的類型必須可賦值給Map的Key類型</li><li>如果Map包含key為x的項，a[x]是Map中key為x的元素，a[x]的類型為M的元素類型</li><li>如果Map是nil或者不包含這樣的項，a[x]是M元素類型的零值</li></ul><p>否則，a[x]是非法的。在map[K]V類型的map上的索引表達式，用於特殊形式的賦值或初始化</p><pre>v, ok = a[x]v, ok := a[x]var v, ok = a[x]</pre><p>額外產生一個非類型化布爾值，如果鍵x在map中，ok的值為true，否則為false。向nil映射賦值一個元素，引起運行時異常</p><p><strong>切片表達式</strong> 切片表達式可以從切片、數組、指針數組或切片構造子串。有兩種變體: 一種指定下限和上限的簡單形式，以及一種指定容量上限的完整形式</p><p><strong>簡單切片表達式</strong> 對於字符串、數組、指針數組或切片a，使用如下基本表達式</p><pre>a[low : high]</pre><p>構造子字符串或切片，索引low和high選擇操作數a的哪些元素出現在結果中。結果索引從0開始，長度等於 high-low。對數組A進行切片後</p><pre>a := [5]int{1, 2, 3, 4, 5}s := a[1:4]</pre><p>切片s具有類型[]int，長度3，容量為4，它元素為</p><pre>s[0] == 2s[1] == 3s[2] == 4</pre><p>為方便起見，有些場景可以省略索引。缺省的low索引默認為零；缺省的high索引默認為切片操作數的長度</p><pre>a[2:] // same as a[2 : len(a)]a[:3] // same as a[0 : 3]a[:] // same as a[0 : len(a)]</pre><p>如果a是指向數組的指針，a[low : high]是(*a)[low : high]的縮寫形式</p><p>對於數組或字符串，有效索引範圍為: 0 &lt;= low &lt;= high &lt;= len(a)，否則越界。對於切片的上邊界是它的容量cap(a)，而非長度。常量索引必須是非負的，並且可以用int類型的值表示；對於數組或常量字符串，常量索引也必須在有效範圍內。如果兩個索引都是常量，它們必須滿足low &lt;= high；如果運行時發生索引號越界，會產生運行時panic</p><p>除未類型化字符串外，如果切片操作數是字符串或切片，則切片操作的結果是與操作數類型相同的非常量值。對於非類型化字符串操作數，結果是字符串類型的非常量值。如果切片操作數是數組，則它必須是可尋址的，切片操作的結果是與數組具有相同元素類型的切片</p><p>如果有效切片表達式的切片操作數為nil，則結果為nil。否則，如果結果是一個切片，則它與操作數共享其基礎數組</p><pre>var a [10]ints1 := a[3:7] // s1的基礎數組是數組a; &amp;s1[2] == &amp;a[5]s2 := s1[1:4] // s2的基礎數組是s1的基礎數組，即數組a; &amp;s2[1] == &amp;a[5]s2[1] = 42 // s2[1] == s1[2] == a[5] == 42; they all refer to the same underlying array element</pre><p><strong>全切片表達式</strong> 對一個數組、指針數組、切片(但不是字符串)，基本表達式為</p><pre>a[low : high : max]</pre><p>構造一個類型相同、長度和元素與簡單切片表達式相同的切片a[low : high]。此外，它通過將結果切片的容量設置為max-low來控制其容量。只能省略第一個索引，它默認為0。對數組a進行切片後</p><pre>a := [5]int{1, 2, 3, 4, 5}t := a[1:3:5]</pre><p>切片t具有類型[]int，長度為2，容量為4，其中元素為</p><pre>t[0] == 2t[1] == 3</pre><p>作為簡單切片表達式，如果a是指向數組的指針，a[low: high : max] 是 (*a)[low : high : max] 的縮寫形式。如果切片操作數是數組，則它必須是可尋址的</p><p>索引範圍在 0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)內為有效，否則視為越界。常量索引必須是非負的，並且可以由int類型的值表示。對於數組，常量索引也必須在有效範圍內。如果多個索引是常數，則存在的常數必須在彼此相對的範圍內。如果運行時索引越界，會引發運行時panic</p><p><strong>類型斷言</strong> 對接口類型的表達式x和類型T，基礎表達式 x.(T)斷言x不是nil，並且存儲在x中的值是T類型的。表達式x.(T)稱為類型斷言。更準確的說，如果T不是接口類型，x.(T)斷言x的動態類型與T類型相同。在這種情況下，T必須實現x的(接口)類型；否則類型斷言無效，因為x不可能存儲T類型的值。如果T是接口類型，x.(T)斷言x的動態類型實現了接口T</p><p>如果類型斷言成立，則表達式的值是存儲在x中的值，其類型為T；如果類型斷言為false，則會發生運行時panic。換句話說，即使x的動態類型只有在運行時才知道，x.(T)的類型在正確的程序中是T</p><pre>var x interface{} = 7 // x 動態類型是 int 值是 7i := x.(int) // i 類型是 int 值是 7type I interface { m() }func f(y I) { s := y.(string) // 非法: string 沒有s實現 I (缺少方法 m) r := y.(io.Reader) // r 有類型 io.Reader 並且動態類型 y 必須實現 I 和 io.Reader …}</pre><p>通常在特殊格式的賦值或初始化中使用類型斷言</p><pre>v, ok = x.(T)v, ok := x.(T)var v, ok = x.(T)var v, ok T1 = x.(T)</pre><p>額外產生一個未定義類型的布爾值，如果斷言成立，ok的值為true；否則它是false，並且v的值是類型T的零值。在這些情況中不會發生運行時panic</p><p><strong>調用</strong> 給定函數類型F的表達式 f(a1, a2, ..., an)，使用參數a1,a2,...an來調用函數f。除一種特殊情況外，參數必須是可賦值給F的參數類型的單值表達式，並且在調用函數之前對其求值，表達式的類型是F的結果類型。與方法調用類似，但方法本身被指定為方法的接收方類型值的選擇器</p><pre>math.Atan2(x, y) // function callvar pt *Pointpt.Scale(3.5) // method call with receiver pt</pre><p>在函數調用中，函數值和參數按通常的順序計算。在對它們求值之後，調用的參數按值傳遞給函數，被調用的函數開始執行。當函數返回時，函數的返回參數按值傳遞迴調用函數。調用nil函數值會發生運行時panic</p><p>一種特殊情況，如果一個函數或方法g的返回值在數量上是相等的，並且可以單獨地分配給另一個函數或方法f的參數，那麼調用f(g(parameters_of_g))將g的返回值綁定到f的參數後將調用f。f的調用不能包含除g的調用以外的任何參數，並且g必須至少有一個返回值。如果f有...參數，它被賦值為在指定正則參數後保留的g的返回值</p><pre>func Split(s string, pos int) (string, string) { return s[0:pos], s[pos:]}func Join(s, t string) string { return s + t}if Join(Split(value, len(value)/2)) != value { log.Panic("test fails")}</pre><p>如果x的方法集(類型)包含m並且參數列表可以被賦值給m的參數列表，則方法調用x.m()是有效的。如果x是可尋址的並且&x的方法集包含m，x.m()是(&x).m()的縮寫形式</p><pre>var p Pointp.Scale(3.5)</pre><p><strong>將參數傳遞給...參數</strong> 如果f是帶有類型為...T的最終參數p的變量，則在f中，p的類型等同於類型[]T。如果調用f時沒有p的實參，則傳遞給p的值為nil。否則，傳遞的值是一個類型為[]T的新切片，其中有一個新的底層數組，該數組的連續元素是實參，所有這些參數都必須可賦值給T。因此，切片的長度和容量是綁定到p的參數的數量，並且對於每個調用站點可能不同</p><pre>func Greeting(prefix string, who ...string)Greeting("nobody") // who 是 nilGreeting("hello:", "Joe", "Anna", "Eileen") // who 的值 []string{"Joe", "Anna", "Eileen"}</pre><p>如果最後一個參數可賦值給切片類型[]T，則如果參數後面跟有...在這種情況下，不會創建新的切片</p><pre>s := []string{"James", "Jasmine"}Greeting("goodbye:", s...) // 在 Greeting 中，who與切片s具有相同的值並且共享相同的底層數組</pre><p><strong>運算符</strong> 運算符將操作數合併到表達式中</p><pre>Expression = UnaryExpr | Expression binary_op Expression .UnaryExpr = PrimaryExpr | unary_op UnaryExpr .binary_op = "||" | "&amp;&amp;" | rel_op | add_op | mul_op .rel_op = "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" .add_op = "+" | "-" | "|" | "^" .mul_op = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .unary_op = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .</pre><p>對於其他二進制運算符，除非操作涉及移位或非類型化常量，否則操作數類型必須相同。除移位操作外，如果一個操作數是非類型化常量，而另一個操作數不是，則該常量將隱式轉換為另一個操作數的類型</p><p>移位表達式中的右操作數必須是整數類型，或者是可由uint類型的值表示的非類型化常量。如果非常量移位表達式的左操作數是非類型化常量，則首先將其隱式轉換為移位表達式被其左操作數單獨替換時假定的類型</p><pre>var s uint = 33var i = 1&lt;&lt;s // 1 has type intvar j int32 = 1&lt;&lt;s // 1 has type int32; j == 0var k = uint64(1&lt;&lt;s) // 1 has type uint64; k == 1&lt;&lt;33var m int = 1.0&lt;&lt;s // 1.0 has type int; m == 0 if ints are 32bits in sizevar n = 1.0&lt;&lt;s == j // 1.0 has type int32; n == truevar o = 1&lt;&lt;s == 2&lt;&lt;s // 1 and 2 have type int; o == true if ints are 32bits in sizevar p = 1&lt;&lt;s == 1&lt;&lt;33 // illegal if ints are 32bits in size: 1 has type int, but 1&lt;&lt;33 overflows intvar u = 1.0&lt;&lt;s // illegal: 1.0 has type float64, cannot shiftvar u1 = 1.0&lt;&lt;s != 0 // illegal: 1.0 has type float64, cannot shiftvar u2 = 1&lt;&lt;s != 1.0 // illegal: 1 has type float64, cannot shiftvar v float32 = 1&lt;&lt;s // illegal: 1 has type float32, cannot shiftvar w int64 = 1.0&lt;&lt;33 // 1.0&lt;&lt;33 is a constant shift expressionvar x = a[1.0&lt;&lt;s] // 1.0 has type int; x == a[0] if ints are 32bits in sizevar a = make([]byte, 1.0&lt;&lt;s) // 1.0 has type int; len(a) == 0 if ints are 32bits in size</pre><p><strong>運算符優先級</strong> 單目運算符具有最高的優先級。由於++和--運算符形式語句，而不是表達式，因此它們不屬於運算符層次結構。因此，語句*p++與(*p)++相同</p><p>二進制運算符有5個優先級別，乘法運算符最強，然後是加法運算符、比較運算符，&&(邏輯與)，最後是||(邏輯或)</p><pre>Precedence Operator 5 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 4 + - | ^ 3 == != &lt; &lt;= &gt; &gt;= 2 &amp;&amp; 1 ||</pre><p>具有相同優先級的二元運算符按從左到右結合。例如，x / y * z與(x / y) * z相同</p><pre>+x23 + 3*x[i]x &lt;= f()^a &gt;&gt; bf() || g()x == y+1 &amp;&amp; &lt;-chanPtr &gt; 0</pre><p><strong>算術運算符</strong> 算術運算符應用於數值併產生與第一個操作數類型相同的結果。四個標準算術運算符(+,-,*,/)應用於整數、浮點數和複數類型; + 也可以用於字符串類型。模運算符、按位邏輯運算符和移位運算符僅適用於整數</p><pre>+ sum integers, floats, complex values, strings- difference integers, floats, complex values* product integers, floats, complex values/ quotient integers, floats, complex values% remainder integers&amp; bitwise AND integers| bitwise OR integers^ bitwise XOR integers&amp;^ bit clear (AND NOT) integers&lt;&lt; left shift integer &lt;&lt; unsigned integer&gt;&gt; right shift integer &gt;&gt; unsigned integer</pre><p><strong>整數運算符</strong> 對於兩個整數值x和y，整數商 q = x / y 和餘數 r = x % y滿足下列關係</p><pre>x = q*y + r and |r| &lt; |y|</pre><p>x / y 被截斷為零</p><pre> x y x / y x % y 5 3 1 2-5 3 -1 -2 5 -3 -1 2-5 -3 1 -2</pre><p>另一個規則是如果被除數x是整數類型x的最負值，則商 q = x / -1 等於x(且r=0)，這是由於2的補整數溢出所致</p><pre> x qint8 -128int16 -32768int32 -2147483648int64 -9223372036854775808</pre><p>如果除數是常數，必須非零，否則會發生運行時panic。如果被除數是非負的，除數是2的常數冪，除數可以用右移運算符代替，餘數可以用按位運算(&)代替</p><pre>x x / 4 x % 4 x &gt;&gt; 2 x &amp; 3 11 2 3 2 3-11 -2 -3 -3 1</pre><p>移位運算符按右操作數指定的移位計數移位左操作數，該移位計數必須為正；如果移位計數為負，會發生運行時panic。如果左操作數是有符號整數，則移位運算符實現算術移位；如果是無符號整數，則移位運算符實現邏輯移位。移位計數沒有上限，移位的行為就像在移位計數為n時將左操作數1移位n次。因此，x&lt;&lt;1與x*2相同，x>>1與x/2相同，但被截斷為負無窮大</p><p>對於整數操作數，一元運算符+、-、^被定義為</p><pre>+x is 0 + x-x negation is 0 - x^x bitwise complement is m ^ x with m = "all bits set to 1" for unsigned x and m = -1 for signed x</pre><p><strong>整數溢出</strong> 對於無符號整數值，運算+、-、*和&lt;&lt;是以2<sup><em>n</em></sup>為模計算的，其中n是無符號整數值類型的位寬度。這些無符號整數操作在溢出時丟棄高位，程序可能依賴於“環繞”</p><p>對於有符號整數，運算+、-、*、/、&lt;&lt;可能合法溢出，結果值存在，並由有符號整數表示、運算及其操作數確定定義，溢出不會發生運行時panic。編譯器可能不會在不發生溢出的假設下優化代碼，例如，它可能不會假設x &lt; x + 1總是對的</p><p><strong>浮點運算符</strong> 對於浮點數和複數，+x 與 x 相同，而 -x 是 x 的反。浮點或複數除零的結果沒有超出IEEE-754標準，是否發生運行時panic是特定於實現的</p><p>一個實現可以將多個浮點操作組合成一個單一的融合操作(可能是跨語句的)，併產生不同於單獨執行和舍入指令所獲得的值的結果；顯式浮點類型轉換將舍入到目標類型的精度，防止聚變而丟棄捨入</p><p>例如，一些體系結構提供了一個"融合乘法和加法"(FMA)指令，該指令在不捨入中間結果x*y的情況下計算x*y+z。這些示例顯示go實現何時可以使用該指令</p><pre>// FMA allowed for computing r, because x*y is not explicitly rounded:r = x*y + zr = z; r += x*yt = x*y; r = t + z*p = x*y; r = *p + zr = x*y + float64(z)// FMA disallowed for computing r, because it would omit rounding of x*y:r = float64(x*y) + zr = z; r += float64(x*y)t = float64(x*y); r = t + z</pre><p><strong>字符串連接</strong> 字符串可以通過+操作符連接或使用+=賦值操作符</p><pre>s := "hi" + string(c)s += " and good bye"</pre><p>字符串加法通過連接操作數創建新字符串</p><p><strong>比較運算符</strong> 比較運算符比較兩個操作數並生成非類型化布爾值</p><pre>== equal!= not equal&lt; less&lt;= less or equal&gt; greater&gt;= greater or equal</pre><p>在任何比較中，第一個操作數必須可賦值給第二個操作數的類型，反之亦然</p><p>等式運算符==和!=應用於可比較的操作數，排序操作符&lt;、&lt;=、>、>=應用於操作數的排序。這些術語和比較結果定義如下</p><ul><li>布爾值是可比較的；如果兩個布爾值都為真或都為假，則它們相等</li><li>整數值是可比較的，並按常規方式排序</li><li>根據IEEE-754標準的定義，浮點值具有可比性和順序性</li><li>複數值具有可比性，兩個複數值u和v，如果它們的實部和虛部分別相等，那麼它們是相等的</li><li>字符串值具有可比性和順序性</li><li>指針值是可比較的；如果兩個指針值指向同一個變量，或者兩者的值都為nil，則它們相等。指向不同零大小<em>變量</em>的指針可能相等，也可能不相等</li><li>通道值是可比較的；如果兩個通道值是由同一個調用make創建的，或者兩者的值都為nil，則它們相等</li><li>接口類型是可比較的；如果兩個接口值具有相同的動態類型和相同的動態值，或者如果兩個接口值都具有值nil，則它們相等</li><li>非接口類型X的一個值x和一個接口類型T的值t是可比較的，當類型X的值是可比較的並且類型X實現接口類型T；如果t的動態類型與x相同，且t的動態值等於x，則它們相等</li><li>如果所有字段都是可比較的，則結構值是可比較的；如果對應的非空字段相等，則兩個結構值相等</li><li>如果數組元素類型的值是可比較的，則數組值是可比較的；如果兩個數組的對應元素相等，則兩個數組值相等</li></ul><p>如果比較具有相同動態類型的兩個不可比較接口的值，則會導致運行時panic。此行為不僅適用於直接的接口值比較，還適用於將接口值數組或結構與接口值字段進行比較</p><p><em>切片、map和函數值是不可比較的</em>。但是，作為一種特殊情況，切片、map或函數值可以與預聲明的標識符nil進行比較。指針、通道和接口值也可以與nil進行比較，並遵循上述一般規則</p><pre>const c = 3 &lt; 4 // c 是未定義的布爾常量truetype MyBool boolvar x, y intvar ( // 這些比較結果是未定義的布爾類型. // 通用的賦值規則適用. b3 = x == y // b3 has type bool b4 bool = x == y // b4 has type bool b5 MyBool = x == y // b5 has type MyBool)</pre><p><strong>邏輯運算符</strong> 應用於布爾值併產生與相同類型操作數的結果。右操作數是按條件計算的</p><pre>&amp;&amp; conditional AND p &amp;&amp; q is "if p then q else false"|| conditional OR p || q is "if p then true else q"! NOT !p is "not p"</pre><p><strong>地址運算符</strong> 對於一個T類型的操作數x，取地址操作&x生成類型為*T並指向x的指針。操作數必須是可尋址的，即變量、指針間接尋址或切片索引操作；或可尋址結構操作數的字段選擇器；或可尋址數組的數組索引操作。作為可尋址性要求的一個例外，x也可以是(可能是用括號括起來的)複合文本。如果對x的求值會導致運行時panic，那麼對&x的求值也會導致panic</p><p>對於指針類型*T的操作數x，間接指針*x表示由x指向的類型T的變量。如果x是nil，試圖計算*x將會導致運行時panic</p><pre>&amp;x&amp;a[f(2)]&amp;Point{2, 3}*p*pf(x)var x *int = nil*x // causes a run-time panic&amp;*x // causes a run-time panic</pre><p><strong>接收操作符</strong> 對於一個通道類型的操作數ch，接收操作的值&lt;-ch表示從通道ch接收到的值。通道方向必須允許接收操作，接收操作的類型是通道的元素類型。表達式將阻塞，直到某個值可用為止；從nil通道接收值永遠處於阻塞狀態。在關閉的通道時接收操作總是立即處理，在接收到以前發送的任何值之後，將生成元素類型的零值</p><pre>v1 := &lt;-chv2 = &lt;-chf(&lt;-ch)&lt;-strobe // 等待時鐘脈衝並丟棄接收值</pre><p>在特殊格式的賦值或初始化中使用的接收表達式</p><pre>x, ok = &lt;-chx, ok := &lt;-chvar x, ok = &lt;-chvar x, ok T = &lt;-ch</pre><p>生成一個附加的非類型化布爾結果，報告通信是否成功。如果接收到的值是通過發送操作成功傳遞到通道的，則ok的值為true；而如果是由於通道關閉且為空而生成的零值，則為false</p><p><strong>轉換</strong> 轉換將表達式的類型更改為轉換指定的類型，轉換可以按字面意思出現在源代碼中，也可以由表達式出現的上下文暗示。顯式轉換是T(x)形式的表達式，其中T是類型，x是可以轉換為類型T的表達式</p><pre>Conversion = Type "(" Expression [ "," ] ")" .</pre><p>如果類型以運算符*、&lt;-開頭，或者類型以關鍵字func開頭，但沒有返回結果列表，必要時必須用括號括起來以避免歧義</p><pre>*Point(p) // same as *(Point(p))(*Point)(p) // p is converted to *Point&lt;-chan int(c) // same as &lt;-(chan int(c))(&lt;-chan int)(c) // c is converted to &lt;-chan intfunc()(x) // function signature func() x(func())(x) // x is converted to func()(func() int)(x) // x is converted to func() intfunc() int(x) // x is converted to func() int (unambiguous)</pre><p>如果x可以由T類型的值表示，則常量x可以轉換為類型T。作為特殊情況，整型常量x可以使用與非常量x相同的規則顯式轉換為字符串類型。轉換一個常量會產生一個類型化的常量</p><pre>uint(iota) // uint類型的iota值float32(2.718281828) // 2.718281828 float32類型complex128(1) // 1.0 + 0.0i of type complex128float32(0.49999999) // 0.5 of type float32float64(-1e-1000) // 0.0 of type float64string('x') // "x" of type stringstring(0x266c) // "♬" of type stringMyString("foo" + "bar") // "foobar" of type MyStringstring([]byte{'a'}) // not a constant: []byte{'a'} is not a constant(*int)(nil) // not a constant: nil is not a constant, *int is not a boolean, numeric, or string typeint(1.2) // illegal: 1.2 cannot be represented as an intstring(65.0) // illegal: 65.0 is not an integer constant</pre><p>以下情況下，非常量值x可以轉換為類型T</p><ul><li>x可賦值給T</li><li>忽略結構標記(見下文)，x和T具有相同的基礎類型</li><li>忽略結構標記(見下文)，x和T是未定義類型的指針類型，它們的指針基類型具有相同的基礎類型</li><li>x和T都是整數或浮點類型</li><li>x和T都是複數類型</li><li>x是整數、byte切片或rune類型，T是string byte</li><li>x是string類型，T是byte切片或rune類型</li></ul><p>在比較用於轉換的標識的結構類型時，將忽略結構標記</p><pre>type Person struct { Name string Address *struct { Street string City string }}var data *struct { Name string `json:"name"` Address *struct { Street string `json:"street"` City string `json:"city"` } `json:"address"`}var person = (*Person)(data) // ignoring tags, the underlying types are identical</pre><p>適用於數字類型之間的(非常量)轉換或字符串類型之間轉換的特定規則，這些轉換可能會改變x的表示形式併產生運行時成本。所有其他轉換隻更改x的類型，而不更改x的表示形式</p><p>指針和整數之間沒有轉換的語言機制，包unsafe在受限制的情況下實現此功能</p><p><strong>數字類型之間的轉換</strong> 對於非常數數字值轉換，以下規則適用</p><ul><li>整數之間的轉換，如果值是有符號整數，則將其符號擴展為隱式無限精度；否則將其擴展為零。然後將其截斷以適合結果類型的大小。例如，如果 v := uint16(0x10f0)，則uint32(int8(v)) == 0xFFFFFFF0；轉換總是產生一個有效值；沒有溢出的跡象</li><li>將浮點數轉換為整數時，小數將被丟棄(向零截斷)</li><li>當轉換一個整數或浮點數到浮點類型，或者轉換一個複數到複數類型，結果值四捨五入到目標類型指定的精度。例如，float32類型的變量x的值可以使用超出IEEE-754 32位數字的附加精度來存儲，但是float32(x)表示將x的值舍入到32位精度的結果。類似地，x + 0.1可能使用超過32位的精度，但是float32(x+0.1)不使用</li></ul><p>在所有涉及浮點值或複數值的非常量轉換中，如果結果類型不能表示轉換成功的值，但結果值依賴於實現</p><p><strong>字符串類型之間的轉換</strong></p><ul><li>將有符號或無符號整數值轉換為字符串類型將生成包含整數的UTF-8表示形式的字符串，超出有效Unicode代碼點範圍的值將轉換為"\uFFFD"</li></ul><pre>string('a') // "a"string(-1) // "\ufffd" == "efbfbd"string(0xf8) // "\u00f8" == "ø" == "c3b8"type MyString stringMyString(0x65e5) // "\u65e5" == "日" == "e697a5"</pre><ul><li>將byte切片轉換為字符串類型會產生一個字符串，該字符串的連續字節是該切片的元素</li></ul><pre>string([]byte{'h', 'e', 'l', 'l', 'c3', 'b8'}) // "hellø"string([]byte{}) // ""string([]byte(nil)) // ""type MyBytes []bytestring(MyBytes{'h', 'e', 'l', 'l', 'c3', 'b8'}) // "hellø"</pre><ul><li>將寬字符切片轉換為字符串類型將生成一個字符串，該字符串是轉換為單個寬字符值的連接</li></ul><pre>string([]rune{0x767d, 0x9d6c, 0x7fd4}) // "\u767d\u9d6c\u7fd4" == "白鵬翔"string([]rune{}) // ""string([]rune(nil)) // ""type MyRunes []runestring(MyRunes{0x767d, 0x9d6c, 0x7fd4}) // "\u767d\u9d6c\u7fd4" == "白鵬翔"</pre><ul><li>將字符串類型的值轉換為byte切片類型將產生一個連續的元素為字符串字節的切片</li></ul><pre>[]byte("hellø") // []byte{'h', 'e', 'l', 'l', 'c3', 'b8'}[]byte("") // []byte{}MyBytes("hellø") // []byte{'h', 'e', 'l', 'l', 'c3', 'b8'}</pre><ul><li>將字符串類型的值轉換為runes類型的切片將生成一個包含字符串的各個Unicode代碼點的切片</li></ul><pre>[]rune(MyString("白鵬翔")) // []rune{0x767d, 0x9d6c, 0x7fd4}[]rune("") // []rune{}MyRunes("白鵬翔") // []rune{0x767d, 0x9d6c, 0x7fd4}</pre><p><strong>常量表達式</strong> 常量表達式只能包含常量操作數，並在編譯時計算。非類型化布爾、數字和字符串常量可以用作操作數，只要分別使用布爾、數字或字符串類型的操作數是合法的</p><p>常量比較總是產生非類型化的布爾常量。如果常量移位表達式的左操作數是非類型化常量，則結果是整型常量；否則，它是與左操作數類型相同的常量，必須是整型</p><p>對非類型化常量執行的任何其他操作都會生成同類的非類型化常量，即布爾、整數、浮點、複數或字符串常量。如果二進制操作(移位除外)的非類型化操作數是不同類型的，則結果是此列表後面顯示的操作數類型：整數、rune、浮點、複數。例如，非類型化整型常數除以非類型化復常數，得到非類型化復常數</p><pre>const a = 2 + 3.0 // a == 5.0 (untyped floating-point constant)const b = 15 / 4 // b == 3 (untyped integer constant)const c = 15 / 4.0 // c == 3.75 (untyped floating-point constant)const Θ float64 = 3/2 // Θ == 1.0 (type float64, 3/2 is integer division)const Π float64 = 3/2. // Π == 1.5 (type float64, 3/2. is float division)const d = 1 &lt;&lt; 3.0 // d == 8 (untyped integer constant)const e = 1.0 &lt;&lt; 3 // e == 8 (untyped integer constant)const f = int32(1) &lt;&lt; 33 // illegal (constant 8589934592 overflows int32)const g = float64(2) &gt;&gt; 1 // illegal (float64(2) is a typed floating-point constant)const h = "foo" &gt; "bar" // h == true (untyped boolean constant)const j = true // j == true (untyped boolean constant)const k = 'w' + 1 // k == 'x' (untyped rune constant)const l = "hi" // l == "hi" (untyped string constant)const m = string(k) // m == "x" (type string)const Σ = 1 - 0.707i // (untyped complex constant)const Δ = Σ + 2.0e-4 // (untyped complex constant)const Φ = iota*1i - 1/1i // (untyped complex constant)</pre><p>應用內置函數complex到未定義整數、rune、或浮點數常量產生一個非類型化的複數常量</p><pre>const ic = complex(0, c) // ic == 3.75i (untyped complex constant)const iΘ = complex(0, Θ) // iΘ == 1i (type complex128)</pre><p>常量表達式的計算總是準確的；中間值和常量本身可能需要的精度遠遠大於語言中任何預聲明類型所支持的精度。以下是合法聲明</p><pre>const Huge = 1 &lt;&lt; 100 // Huge == 1267650600228229401496703205376 (untyped integer constant)const Four int8 = Huge &gt;&gt; 98 // Four == 4 (type int8)</pre><p>常數除法或餘數運算的除數不能為零</p><pre>3.14 / 0.0 // illegal: division by zero</pre><p>類型化常量的值必須始終可以由常量類型的值精確表示。以下常量表達式是非法的</p><pre>uint(-1) // -1 cannot be represented as a uintint(3.14) // 3.14 cannot be represented as an intint64(Huge) // 1267650600228229401496703205376 cannot be represented as an int64Four * 300 // operand 300 cannot be represented as an int8 (type of Four)Four * 100 // product 400 cannot be represented as an int8 (type of Four)</pre><p>一元逐位補碼運算符^使用的掩碼與非常量的規則匹配：對於無符號常量，掩碼均為1；對於有符號常量和非類型常量，掩碼均為-1</p><pre>^1 // untyped integer constant, equal to -2uint8(^1) // illegal: same as uint8(-2), -2 cannot be represented as a uint8^uint8(1) // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)int8(^1) // same as int8(-2)^int8(1) // same as -1 ^ int8(1) = -2</pre><p>實現限制：編譯器在計算非類型浮點或複數常量表達式時可能使用舍入，這種舍入可能導致浮點常量表達式在整數上下文中無效，即使它在使用無限精度計算時是整數，反之亦然</p><p><strong>計算順序</strong> 在包級別，初始化依賴項確定變量聲明中單個初始化表達式的求值順序。否則，在對表達式、賦值或返回語句的操作數求值時，所有函數調用、方法調用和通信操作都將按從左到右的詞法順序求值。例如，在函數局部賦值中</p><pre>y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()</pre><p>函數調用和通信按f()、h()、i()、j()、&lt;-c、g()和k()的順序進行，但未指定這些事件相對於x的求值和索引以及y的求值的順序</p><pre>a := 1f := func() int { a++; return a }x := []int{a, f()} // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specifiedm := map[int]int{a: 1, a: 2} // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specifiedn := map[int]int{a: f()} // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified</pre><p>在包級別，初始化依賴項覆蓋單個初始化表達式的從左到右規則，但不覆蓋每個表達式中的操作數</p><pre>var a, b, c = f() + v(), g(), sqr(u()) + v()func f() int { return c }func g() int { return a }func sqr(x int) int { return x*x }// functions u and v are independent of all other variables and functions</pre><p>函數調用的順序是u()、sqr()、v()、f()、v()和g()</p><p>根據運算符的關聯性計算單個表達式中的浮點運算，顯式括號通過重寫默認優先級來影響計算。在表達式x+(y+z) 中，在與x求和之前執行y+z</p><p><strong>語句</strong> 語句控制執行</p><pre>Statement = Declaration | LabeledStmt | SimpleStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt | DeferStmt .SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</pre><p><strong>終止語句</strong> 終止語句阻止在同一塊中以詞彙形式出現在它後面的所有語句執行，以下終止語句</p><ul><li>return或goto語句</li><li>調用內置函數panic</li><li>語句列表以終止語句結尾的塊</li><li>一個if語句塊，其中</li><li class=ql-indent-1>else分支語句塊存在，並且</li><li class=ql-indent-1>兩個分支都是終止語句塊</li><li>一個for語句塊，其中</li><li class=ql-indent-1>沒有引用break語句，並且</li><li class=ql-indent-1>不存在循環條件</li><li>一個switch語句塊，其中</li><li class=ql-indent-1>沒有引用break語句</li><li class=ql-indent-1>存在default情況，並且</li><li class=ql-indent-1>在每種情況下的語句列表(包括default語句)都以終止語句或者一個可能被標記為"fallthrough"的語句結尾</li><li>select語句塊，其中</li><li class=ql-indent-1>沒有引用break語句</li><li class=ql-indent-1>在每種情況下，語句都會以終止語句結尾，包括default(如果存在)</li><li>標記終止語句的標記語句</li></ul><p>所有其他語句塊都不是終止語句塊。如果列表不為空並且其最後一個非空語句是終止塊，則語句列表以終止語句結尾</p><p><strong>空語句</strong> 不起任何作用</p><pre>EmptyStmt = .</pre><p><strong>標記語句</strong> 可以是goto、break或continue語句的目標</p><pre>LabeledStmt = Label ":" Statement .Label = identifier .Error: log.Panic("error encountered")</pre><p><strong>表達式語句</strong> 除了特定的內置函數外，函數和方法調用以及接收操作可以出現在語句上下文中。這些陳述可以用括號括起來</p><pre>ExpressionStmt = Expression .</pre><p>語句上下文中不允許使用以下內置函數</p><pre>append cap complex imag len make new realunsafe.Alignof unsafe.Offsetof unsafe.Sizeofh(x+y)f.Close()&lt;-ch(&lt;-ch)len("foo") // illegal if len is the built-in function</pre><p><strong>發送語句</strong> 在通道上發送值，通道表達式必須是channel類型，通道方向必須允許發送操作，要發送的值的類型必須可賦值給通道的元素類型</p><pre>SendStmt = Channel "&lt;-" Expression .Channel = Expression .</pre><p>通道和值表達式都是在通信開始之前計算的。通信阻塞，直到發送可以繼續：如果接收器準備就緒，則無緩衝信道上的發送可以繼續；如果緩衝區中有空間，緩衝通道上的發送可以繼續。在一個關閉的通道上發送會引起運行時的panic。nil通道上的發送會永遠阻塞</p><pre>ch &lt;- 3 // send value 3 to channel ch</pre><p><strong>自增/自減語句</strong> ++和--語句按非類型常量1自增或自減其操作數。與賦值一樣，操作數必須是可尋址的或映射可索引的表達式</p><pre>IncDecStmt = Expression ( "++" | "--" ) .</pre><p>以下賦值語句在語義上是等價的</p><pre>IncDec statement Assignmentx++ x += 1x-- x -= 1</pre><p><strong>賦值</strong></p><pre>Assignment = ExpressionList assign_op ExpressionList .assign_op = [ add_op | mul_op ] "=" .</pre><p>每個左側操作數都必須是可尋址的、映射索引表達式或(僅適用於=賦值)空標識符。操作數可以用括號括起來</p><pre>x = 1*p = f()a[i] = 23(k) = &lt;-ch // same as: k = &lt;-ch</pre><p>賦值操作 x op= y，其中op是二進制算術運算符，與 x = x op (y) 等價，但只對x求值一次。op= 構造是單個標記。在賦值操作中，左邊和右邊的表達式列表必須正好包含一個單值表達式，左邊的表達式不能是空標識符</p><pre>a[i] &lt;&lt;= 2i &amp;^= 1&lt;&lt;n</pre><p>元組賦值將多值操作的各個元素賦給變量列表。有兩種形式，在第一種情況下，右邊的操作數是單個多值表達式，例如函數調用、通道或映射操作或類型斷言。左側的操作數必須與值的數目匹配。例如，如果f是返回兩個值的函數</p><pre>x, y = f()</pre><p>將第一個值賦給x，將第二個值賦給y。在第二種形式中，左邊的操作數必須等於右邊的表達式數，每個表達式都必須是單值的，右邊的第n個表達式賦給左邊的第n個操作數</p><pre>one, two, three = '一', '二', '三'</pre><p>空白標識符提供了一種忽略賦值中右側值的方法</p><pre>_ = x // 計算 x 但忽略它x, _ = f() // 計算 f() 但忽略第二個結果值</pre><p>賦值分兩階段進行，首先，左邊的索引表達式和指針間接(包括選擇器中的隱式指針間接)的操作數和右邊的表達式都按通常的順序計算。其次，賦值按從左到右的順序進行</p><pre>a, b = b, a // exchange a and bx := []int{1, 2, 3}i := 0i, x[i] = 1, 2 // set i = 1, x[0] = 2i = 0x[i], i = 2, 1 // set x[0] = 2, i = 1x[0], x[0] = 1, 2 // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)x[1], x[3] = 4, 5 // set x[1] = 4, then panic setting x[3] = 5.type Point struct { x, y int }var p *Pointx[2], p.x = 6, 7 // set x[2] = 6, then panic setting p.x = 7i = 2x = []int{3, 5, 7}for i, x[i] = range x { // set i, x[2] = 0, x[0] break}// after this loop, i == 0 and x == []int{3, 5, 3}</pre><p>在賦值中，每個值都必須可賦值給它被賦值的操作數類型，有以下特殊情況</p><ul><li>任何類型的值都可以賦值給空白標識符</li><li>如果將非類型化常量分配給接口類型的變量或空標識符，則首先將該常量隱式轉換為其默認類型</li><li>如果將非類型化布爾值賦給接口類型的變量或空標識符，則首先將其隱式轉換為bool類型</li></ul><p><strong>If語句</strong> 根據布爾表達式的值指定兩個分支的條件執行。如果表達式的計算結果為true，則執行if分支，否則，執行else分支(如果存在)</p><pre>IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .if x &gt; max { x = max}</pre><p>表達式前面可以有一個簡單語句，該語句在計算表達式之前執行</p><pre>if x := f(); x &lt; y { return x} else if x &gt; z { return z} else { return y}</pre><p><strong>switch語句</strong> 提供多路執行，表達式或類型說明符與switch中的cases進行比較，以確定要執行的分支</p><pre>SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .</pre><p>有兩種形式：表達式switch和類型switch。在表達式switch中，cases包含與switch表達式的值進行比較的表達式。在類型switch中，cases包含與特殊註釋的switch表達式的類型進行比較的類型。switch表達式在switch語句中只計算一次</p><p><strong>表達式switch</strong> 在表達式switch中，將對switch表達式求值，並從左到右和從上到下求值不必為常量的case表達式；第一個等於switch表達式的表達式將觸發執行關聯case的語句；其他情況將被跳過</p><p>如果沒有case匹配，並且存在default case，則執行其語句。最多可以有一個default case，它可能出現在switch語句中的任何位置，缺省的switch表達式等於布爾值true</p><pre>ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .ExprCaseClause = ExprSwitchCase ":" StatementList .ExprSwitchCase = "case" ExpressionList | "default" .</pre><p>如果switch表達式的計算結果為非類型化常量，則首先隱式轉換為其默認類型；如果是非類型化布爾值，則首先隱式轉換為bool類型。預聲明的非類型化值nil不能用作switch表達式</p><p>如果case表達式是非類型化的，則首先將其隱式轉換為switch表達式的類型。對於每個(可能轉換的)cases表達式x和swicth表達式的值t，x==t 必須是有效的比較</p><p>換言之，switch表達式被視為是用來聲明和初始化臨時變量t而不是顯式類型；它是測試每個case表達式x是否相等的t值</p><p>在case或default子句中，最後一個非空語句可以是(可能標記為)fallthrough語句，指示控件應該從該子句的結尾流向下一個子句的第一個語句。否則，控制流將流向switch語句的末尾。fallthrough語句可以出現在表達式switch的除最後一個子句外的所有語句的最後一個語句</p><p>switch表達式前面可以有一個簡單語句，該語句在計算表達式之前執行</p><pre>switch tag {default: s3()case 0, 1, 2, 3: s1()case 4, 5, 6, 7: s2()}switch x := f(); { // missing switch expression means "true"case x &lt; 0: return -xdefault: return x}switch {case x &lt; y: f1()case x &lt; z: f2()case x == 4: f3()}</pre><p>實現限制：編譯器可能不允許對的多個case表達式的同一常量求值。例如，當前編譯器不允許在case表達式中使用重複的整數、浮點或字符串常量</p><p><strong>類型switch</strong> 用於比較類型而不是值，它在其他方面類似於表達式switch。它由一個特殊的switch表達式標記，該表達式具有使用保留字類型而不是實際類型的類型斷言的形式</p><pre>switch x.(type) {// cases}</pre><p>然後，case將實際類型t與表達式x的動態類型相匹配。與類型斷言一樣，x必須是接口類型，case中列出的每個非接口類型t必須實現x的類型。類型switch的case中列出的類型必須都是不同的</p><pre>TypeSwitchStmt = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .TypeCaseClause = TypeSwitchCase ":" StatementList .TypeSwitchCase = "case" TypeList | "default" .TypeList = Type { "," Type } .</pre><p>TypeSwitchGuard可能包括一個短變量聲明，當使用該形式時，變量將在每個子句的隱式塊中的TypeSwitchCase末尾聲明。在case列表類型的子句中，變量具有該類型；否則，變量具有TypeSwitchGuard中表達式的類型</p><p>一個case可以使用預先聲明的標識符nil，而不是一個類型；當TypeSwitchGuard中的表達式是nil接口值時，將選擇該case，最多只能有一個nil的case</p><p>給定一個類型為interface{}的表達式x，下面的類型swicth</p><pre>switch i := x.(type) {case nil: printString("x is nil") // type of i is type of x (interface{})case int: printInt(i) // type of i is intcase float64: printFloat64(i) // type of i is float64case func(int) float64: printFunction(i) // type of i is func(int) float64case bool, string: printString("type is bool or string") // type of i is type of x (interface{})default: printString("don't know the type") // type of i is type of x (interface{})}</pre><p>可以重寫為</p><pre>v := x // x is evaluated exactly onceif v == nil { i := v // type of i is type of x (interface{}) printString("x is nil")} else if i, isInt := v.(int); isInt { printInt(i) // type of i is int} else if i, isFloat64 := v.(float64); isFloat64 { printFloat64(i) // type of i is float64} else if i, isFunc := v.(func(int) float64); isFunc { printFunction(i) // type of i is func(int) float64} else { _, isBool := v.(bool) _, isString := v.(string) if isBool || isString { i := v // type of i is type of x (interface{}) printString("type is bool or string") } else { i := v // type of i is type of x (interface{}) printString("don't know the type") }}</pre><p>類型switch保護可以在前面加上一個簡單語句，該語句在對保護求值之前執行。類型開關中不允許使用fallthrough語句</p><p><strong>For語句</strong> 指定語句塊的重複執行，有三種形式：可以由一個條件控制迭代、一個for子句或一個range子句控制</p><pre>ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .Condition = Expression .</pre><p><strong>單條件的For語句</strong> 在最簡單的形式中，for語句指定塊的重複執行，只要布爾條件的計算結果為true。條件在每次迭代前都會被計算出來。如果條件不存在，則相當於布爾值true</p><pre>for a &lt; b { a *= 2}</pre><p><strong>For語句與for子句</strong> 帶有ForClause的For語句也受其條件控制，但它還可以指定init和post語句，例如，賦值語句、遞增和遞減語句。init語句可以是短變量聲明，但post語句不能。init語句聲明的變量在每次迭代中都會被重用</p><pre>ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .InitStmt = SimpleStmt .PostStmt = SimpleStmt .for i := 0; i &lt; 10; i++ { f(i)}</pre><p>如果非空，則在計算第一次迭代的條件之前執行init語句一次；post語句在每次執行塊之後執行(並且僅在執行塊時)。ForClause的任何元素都可以為空，但分號是必需的，除非只有條件。如果條件不存在，則相當於布爾值true</p><pre>for cond { S() } is the same as for ; cond ; { S() }for { S() } is the same as for true { S() }</pre><p><strong>For語句與range子句</strong> 帶有range子句的for語句遍歷數組、切片、字符串、map的所有條目或通道上接收到的值。對於每個條目，它將迭代值賦給相應的迭代變量(如果存在)，然後執行塊</p><pre>RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .</pre><p>range子句右側的表達式稱為range表達式，它可以是數組、指向數組的指針、切片、字符串、映射或允許接收操作的通道。與賦值一樣，如果存在，則左側的操作數必須是可尋址或映射索引表達式；它們表示迭代變量。如果range表達式是通道，則最多允許一個迭代變量，否則最多可以有兩個。如果最後一個迭代變量是空標識符，則range子句等同於沒有該標識符的同一子句</p><p>在開始循環之前，對range表達式x求值一次，但有一個例外: 如果至多存在一個迭代變量且len(x)為常量，則range表達式不會被求值</p><p>左邊的函數調用在每次迭代中計算一次，對於每個迭代，如果存在相應的迭代變量，則按如下方式生成迭代值</p><pre>Range expression 1st value 2nd valuearray or slice a [n]E, *[n]E, or []E index i int a[i] Estring s string type index i int see below runemap m map[K]V key k K m[k] Vchannel c chan E, &lt;-chan E element e E</pre><ul><li>對於數組、指針數組或切片a，從元素索引0開始，按遞增順序生成索引迭代值。如果最多存在一個迭代變量，則range循環將生成從0到len(a)-1的迭代值，並且不會索引到數組或切片本身。對於nil切片，迭代次數為0</li><li>對於string類型的值，range子句從字節索引0開始的Unicode代碼點迭代字符串。在連續的迭代中，索引值將是字符串中連續的UTF-8編碼代碼點的第一個字節的索引，第二個值(rune類型)將是相應代碼點的值。如果迭代遇到一個無效的UTF-8序列，第二個值將是0xFFFD(Unicode替換字符)，下一個迭代將在字符串中前進一個字節</li><li>未指定map上的迭代順序，並且不能保證從一次迭代到下一次迭代的順序相同。如果在迭代過程中移除尚未到達的映射項，則不會生成相應的迭代值；如果在迭代期間創建了映射項，則該項可能在迭代期間生成，也可能被跳過。對於創建的每個項以及從一個迭代到下一個迭代，選擇可能會有所不同。如果映射為nil，則迭代次數為0</li><li>對於通道，生成的迭代值是通道上發送的連續值，直到通道關閉。如果通道為nil，則range表達式將永遠阻塞</li></ul><p>在賦值語句中，迭代值被賦給相應的迭代變量。迭代變量可以由range子句使用短變量聲明(:=)的形式聲明。在這種情況下，它們的類型被設置為各自迭代值的類型，它們的作用域是for語句的塊；它們在每次迭代中都被重用。如果迭代變量是在for語句之外聲明的，則在執行之後，它們的值將是上一次迭代的值</p><pre>var testdata *struct { a *[7]int}for i, _ := range testdata.a { // testdata.a is never evaluated; len(testdata.a) is constant // i ranges from 0 to 6 f(i)}var a [10]stringfor i, s := range a { // type of i is int // type of s is string // s == a[i] g(i, s)}var key stringvar val interface {} // element type of m is assignable to valm := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}for key, val = range m { h(key, val)}// key == last map key encountered in iteration// val == map[key]var ch chan Work = producer()for w := range ch { doWork(w)}// empty a channelfor range ch {}</pre><p><strong>Go語句</strong> go語句在同一地址空間內以獨立的併發控制線程或goroutine的形式開始執行函數調用</p><pre>GoStmt = "go" Expression .</pre><p><em>表達式必須是函數或方法調用</em>；不能用括號括起來。內置函數的調用與表達式語句一樣受到限制</p><p>函數值和參數的計算通常與調用goroutine中的一樣，但與常規調用不同，程序執行不會等待調用的函數完成。相反，函數開始在新的goroutine中獨立執行。當函數終止時，其goroutine也將終止。如果函數有任何返回值，則在函數完成時丟棄它們</p><pre>go Server()go func(ch chan&lt;- bool) { for { sleep(10); ch &lt;- true }} (c)</pre><p><strong>Select語句</strong> 選擇一組可能的<em>發送或接收</em>操作中的哪一個將繼續。它看起來類似於switch語句，但在所有情況下都是指通信操作</p><pre>SelectStmt = "select" "{" { CommClause } "}" .CommClause = CommCase ":" StatementList .CommCase = "case" ( SendStmt | RecvStmt ) | "default" .RecvStmt = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .RecvExpr = Expression .</pre><p>帶有RecvStmt的case可以將RecvExpr的結果賦給一個或兩個變量，這些變量可以使用短變量聲明來聲明。RecvExpr必須是(可能用括號括起來的)接收操作。最多可以有一個default case，它可能出現在case列表中的任何位置</p><p>select語句的執行分幾個步驟執行</p><ul><li>對於語句中的所有cases，在輸入select語句時，接收操作的通道操作數和發送語句的通道和右側表達式將按源順序精確計算一次，結果是一組要接收或發送到的通道，以及要發送的相應值。無論選擇哪個(如果有的話)通信操作繼續，都將發生計算中的任何副作用。帶有短變量聲明或賦值的RecvStmt左側的表達式尚未求值</li><li>如果一個或多個通信可以繼續，則通過統一的偽隨機選擇來選擇可以繼續的單個通信。否則，如果存在default case，則選擇該case。如果沒有default case，select語句將阻塞，直到至少一個通信可以繼續</li><li>除非所選的是default case，否則執行相應的通信操作</li><li>如果所選的case是帶有短變量聲明或賦值的RecvStmt，則計算左側表達式並賦值接收值</li><li>執行所選case的語句列表</li></ul><p>由於nil通道上的通信永遠無法繼續，因此只有nil通道且沒有default case的select將永遠阻塞</p><pre>var a []intvar c, c1, c2, c3, c4 chan intvar i1, i2 intselect {case i1 = &lt;-c1: print("received ", i1, " from c1\n")case c2 &lt;- i2: print("sent ", i2, " to c2\n")case i3, ok := (&lt;-c3): // same as: i3, ok := &lt;-c3 if ok { print("received ", i3, " from c3\n") } else { print("c3 is closed\n") }case a[f()] = &lt;-c4: // same as: // case t := &lt;-c4 // a[f()] = tdefault: print("no communication\n")}for { // send random sequence of bits to c select { case c &lt;- 0: // note: no statement, no fallthrough, no folding of cases case c &lt;- 1: }}select {} // block forever</pre><p><strong>返回語句</strong> 函數F中的return語句終止F的執行，並可選地提供一個或多個返回結果值。任何被F延遲的函數都在F返回其調用方之前執行</p><pre>ReturnStmt = "return" [ ExpressionList ] .</pre><p>在沒有結果類型的函數中，return語句不能指定任何結果值</p><pre>func noResult() { return}</pre><p>有三種方法可以從帶有結果類型的函數返回值</p><ul><li>返回值可以在return語句中顯式列出，每個表達式必須是單值的，並且可以賦值給函數結果類型的相應元素</li></ul><pre>func simpleF() int { return 2}func complexF1() (re float64, im float64) { return -7.0, -4.0}</pre><ul><li>return語句中的表達式列表可以是對多值函數的單個調用。其效果就好像從該函數返回的每個值都被賦給了一個臨時變量，其類型是相應的值，後面跟著一個列出這些變量的return語句，在這一點上，前一種情況的規則適用</li></ul><pre>func complexF2() (re float64, im float64) { return complexF1()}</pre><ul><li>如果函數的結果類型指定其結果參數的名稱，則表達式列表可能為空。結果參數充當普通局部變量，函數可以根據需要為其賦值。return語句返回這些變量的值</li></ul><pre>func complexF3() (re float64, im float64) { re = 7.0 im = 4.0 return}func (devnull) Write(p []byte) (n int, _ error) { n = len(p) return}</pre><p>無論它們是如何聲明的，在進入函數時，所有結果值都會初始化為其類型的零值。指定results的return語句在執行任何延遲函數之前設置結果參數</p><p>實現限制：如果與結果參數同名的其他實體(常量、類型或變量)在返回位置的作用域中，編譯器可能會禁止return語句中的空表達式列表</p><pre>func f(n int) (res int, err error) { if _, err := f(n-1); err != nil { return // invalid return statement: err is shadowed } return}</pre><p><strong>Break語句</strong> break語句終止同一函數中最裡面的for、switch或select語句的執行</p><pre>BreakStmt = "break" [ Label ] .</pre><p>如果有一個標籤，那麼它必須是一個封閉的for、switch或select語句，並且它是執行可終止的語句</p><pre>OuterLoop: for i = 0; i &lt; n; i++ { for j = 0; j &lt; m; j++ { switch a[i][j] { case nil: state = Error break OuterLoop case item: state = Found break OuterLoop } } }</pre><p><strong>Continue語句</strong> 在post語句處開始最裡面的for循環的下一次迭代。for循環必須在同一函數內</p><pre>ContinueStmt = "continue" [ Label ] .</pre><p>如果有一個標籤，那麼它必須是一個包含for語句的標籤，並且這是促進執行的標籤</p><pre>RowLoop: for y, row := range rows { for x, data := range row { if data == endOfRow { continue RowLoop } row[x] = data + bias(x, y) } }</pre><p><strong>Goto語句</strong> 將控制權轉移到同一函數中具有相應標籤的語句</p><pre>GotoStmt = "goto" Label .goto Error</pre><p>執行goto語句不能導致任何變量進入goto點作用域之外的作用域。例如，此示例</p><pre> goto L // BAD v := 3L:</pre><p>是錯誤的，因為跳轉到標籤L會跳過v的創建。塊外的goto語句不能跳轉到該塊內的標籤。例如，此示例</p><pre>if n%2 == 1 { goto L1}for n &gt; 0 { f() n--L1: f() n--}</pre><p>是錯誤的，因為標籤L1在for語句塊內，但goto不在</p><p><strong>Fallthrough語句</strong> 將控制權轉移到表達式switch語句中下一個case子句的第一個語句。它只能用作此類子句中的最後一個非空語句</p><pre>FallthroughStmt = "fallthrough" .</pre><p><strong>Defer語句</strong> 調用一個函數，該函數的執行被推遲到包裹函數返回的那一刻，這可能是因為包裹的函數執行了一個返回語句，到達了其函數體的末尾，或者是因為相應的goroutine發生panic</p><pre>DeferStmt = "defer" Expression .</pre><p>表達式必須是函數或方法調用；不能用括號括起來。內置函數的調用與表達式語句一樣受到限制</p><p>每次執行defer語句時，調用的函數值和參數都會像往常一樣計算並重新保存，但不會調用實際的函數。相反，被延遲的函數在包裹函數返回之前立即調用，順序與defered的順序相反(LIFO)</p><p>也就是說，如果包裹函數通過顯式返回語句返回，則在該返回語句設置任何結果參數之後、函數返回其調用方之前執行延遲函數。如果延遲函數值的計算結果為nil，則在<em>調用該函數時執行會發生運行時panic</em>，而不是在執行defer語句時執行</p><p>例如，如果延遲函數是一個函數文本，並且包裹的函數已命名了文本範圍內的結果參數，則延遲函數可以在返回結果參數之前訪問和修改它們；如果延遲函數有任何返回值，則在函數完成時將丟棄這些值</p><pre>lock(l)defer unlock(l) // 在包裹函數返回之前進行釋放鎖// prints 3 2 1 0 before surrounding function returnsfor i := 0; i &lt;= 3; i++ { defer fmt.Print(i)}// f 返回值為 42func f() (result int) { defer func() { // 結果在被return語句設置為6之後被訪問 result *= 7 }() return 6}</pre><p><strong>內置函數</strong></p><p>內置函數是預先聲明的，它們像任何其他函數一樣被調用，但其中一些函數接受類型而不是表達式作為第一個參數。內置函數沒有標準go類型，因此它們只能出現在調用表達式中；不能用作函數值</p><p><strong>Close</strong> 對於通道c，內置函數close(c)記錄通道上不再發送值；如果c是一個只接收通道，這樣會發生error。向已關閉的通道發送數據會導致運行時panic，關閉nil通道也會發生運行時panic。在調用close之後，並且在接收到任何以前發送的值之後，接收操作將在不阻塞的情況下返回通道類型的零值。多值接收操作返回接收值，並指示信道是否關閉</p><p><strong>Length 和 capacity</strong> 內置函數len和cap接受各種類型的參數並返回int類型的結果。該實現確保結果始終適合於int類型</p><pre>Call Argument type Resultlen(s) string type string length in bytes [n]T, *[n]T array length (== n) []T slice length map[K]T map length (number of defined keys) chan T number of elements queued in channel buffercap(s) [n]T, *[n]T array length (== n) []T slice capacity chan T channel buffer capacity</pre><p>切片的容量是在底層數組中為其分配空間的元素數。以下關係在任何時候都成立</p><pre>0 &lt;= len(s) &lt;= cap(s)</pre><p>如果切片、數組、map或通道值是nil，則其長度為0；如果s是字符串常量，則表達式len(s)為常量。如果s的類型是數組或指向數組的指針，並且表達式s不包含通道接收或(非常量)函數調用，則表達式len(s)和cap(s)是常量；在這種情況下，不計算s。否則，對len和cap的調用不是常量，將計算s</p><pre>const ( c1 = imag(2i) // imag(2i) = 2.0 is a constant c2 = len([10]float64{2}) // [10]float64{2} contains no function calls c3 = len([10]float64{c1}) // [10]float64{c1} contains no function calls c4 = len([10]float64{imag(2i)}) // imag(2i) is a constant and no function call is issued c5 = len([10]float64{imag(z)}) // invalid: imag(z) is a (non-constant) function call)var z complex128</pre><p><strong>Allocation</strong> 內置函數new接收T類型，在運行時為該類型的變量分配存儲空間，並返回指向該變量的*T類型的值，形如，new(T)。例如</p><pre>type S struct { a int; b float64 }new(S)</pre><p>為S類型的變量分配存儲空間，初始化它(a=0，b=0.0)，並返回包含位置地址的S類型的值</p><p><strong>Making slices, map, channels</strong> 內置函數make採用類型T，它必須是slice、map或channel類型，後面還可以是特定類型的表達式列表。它返回一個T類型的值(不是*T)</p><pre>Call Type T Resultmake(T, n) slice slice of type T with length n and capacity nmake(T, n, m) slice slice of type T with length n and capacity mmake(T) map map of type Tmake(T, n) map map of type T with initial space for approximately n elementsmake(T) channel unbuffered channel of type Tmake(T, n) channel buffered channel of type T, buffer size n</pre><p>每個大小參數n和m都必須是整數類型或非類型常量。常量大小參數必須是非負的，並且可以由int類型的值表示；如果它是非類型化的常量，則為int類型。如果n和m都提供並且都是常量，則n不能大於m，如果n是複數或者大於m則會發生運行時panic</p><pre>s := make([]int, 10, 100) // slice with len(s) == 10, cap(s) == 100s := make([]int, 1e3) // slice with len(s) == cap(s) == 1000s := make([]int, 1&lt;&lt;63) // illegal: len(s) is not representable by a value of type ints := make([]int, 10, 0) // illegal: len(s) &gt; cap(s)c := make(chan int, 10) // channel with a buffer size of 10m := make(map[string]int, 100) // map with initial space for approximately 100 elements</pre><p>使用map類型和size提示n調用make將創建一個初始空間為n個元素的map。精確的行為依賴於實現</p><p><strong>Appending to and coping slices</strong> 內置函數append和copy有助於執行常見的切片操作。對於這兩個函數，結果與參數引用的內存是否重疊無關</p><p>可變函數append將零個或多個值x附加到S類型(必須是切片類型)的s，並返回結果切片(也是s類型)。值x被傳遞給類型為...T的參數，T是S的元素類型並且各自的參數傳遞規則適用。作為特殊情況，append還接受第一個參數，該參數可賦值給類型為[]byte，第二個參數的字符串類型後跟….此格式追加字符串的字節</p><pre>append(s S, x ...T) S // T 是 S 的元素類型</pre><p>如果s的容量不足以容納額外的值，append將分配一個新的、足夠大的底層數組，該數組既適合現有的slice元素，也適合額外的值。否則，append將重用基礎數組</p><pre>s0 := []int{0, 0}s1 := append(s0, 2) // append a single element s1 == []int{0, 0, 2}s2 := append(s1, 3, 5, 7) // append multiple elements s2 == []int{0, 0, 2, 3, 5, 7}s3 := append(s2, s0...) // append a slice s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}s4 := append(s3[3:6], s3[2:]...) // append overlapping slice s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}var t []interface{}t = append(t, 42, 3.1415, "foo") // t == []interface{}{42, 3.1415, "foo"}var b []byteb = append(b, "bar"...) // append string contents b == []byte{'b', 'a', 'r' }</pre><p>函數copy將切片元素從源src複製到目標dst，並返回複製的元素數。兩個參數必須具有相同的元素類型T，並且必須可賦值給類型為[]T的切片。複製的元素是len(src)和len(dst)的最小值。作為一種特殊情況，copy還接受一個目標參數，該參數可複製給帶有字符串類型的源參數的類型[]byte。此形式將字符串中的字節複製到字節片中</p><pre>copy(dst, src []T) intcopy(dst []byte, src string) int</pre><p>例如</p><pre>var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}var s = make([]int, 6)var b = make([]byte, 5)n1 := copy(s, a[0:]) // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}n2 := copy(s, s[2:]) // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}n3 := copy(b, "Hello, World!") // n3 == 5, b == []byte("Hello")</pre><p><strong>刪除map的元素</strong> 內置函數delete從映射m中刪除鍵為k的元素，k的類型必須可賦值給m的鍵的類型</p><pre>delete(m, k) // remove element m[k] from map m</pre><p>如果映射m是nil，或者元素m[k]不存在，刪除是一個no-op</p><p><strong>操作複數</strong> 三個函數組合與反組合複數，內置函數complex從浮點實部和虛部構造複數，而real和imag則提取複數的實部和虛部</p><pre>complex(realPart, imaginaryPart floatT) complexTreal(complexT) floatTimag(complexT) floatT</pre><p>參數的類型和返回值對應。對於複數，兩個參數必須是相同的浮點類型，返回類型是具有相應浮點成分的complex類型：complex64表示float32參數，complex128表示float64參數。如果其中一個參數的計算結果為非類型化常量，則首先將其隱式轉換為另一個參數的類型；如果兩個參數的計算結果都是非類型化常量，則它們必須是非複數或其虛部必須為零，並且函數的返回值是非類型化的複數常量</p><p>對於real和imag，它們的參數必須是複數類型，返回類型是對應的浮點類型：float32表示complex64參數，float64表示complex128參數；如果參數的計算結果是非類型化常量，則它必須是數字，並且函數的返回值是非類型化浮點常量</p><p>real和imag函數一起構成複數的逆函數，因此對於複數類型Z的值z，z == Z(complex(real(z), imag(z)))</p><p>如果這些函數的操作數都是常量，則返回值是常量</p><pre>var a = complex(2, -2) // complex128const b = complex(1.0, -1.4) // untyped complex constant 1 - 1.4ix := float32(math.Cos(math.Pi/2)) // float32var c64 = complex(5, -x) // complex64var s int = complex(1, 0) // untyped complex constant 1 + 0i can be converted to int_ = complex(1, 2&lt;&lt;s) // illegal: 2 assumes floating-point type, cannot shiftvar rl = real(c64) // float32var im = imag(a) // float64const c = imag(b) // untyped constant -1.4_ = imag(3 &lt;&lt; s) // illegal: 3 assumes complex type, cannot shift</pre><p><strong>處理panic</strong> 兩個內置函數，panic和recover，有助於報告和處理運行時panic和程序定義的錯誤條件</p><pre>func panic(interface{})func recover() interface{}</pre><p>在執行函數F時，顯式調用panic或運行時panic會終止F的執行，任何被F延遲的函數都會像往常一樣執行。接下來，F的調用者運行的任何延遲函數都將運行，以此類推，直到執行goroutine中的頂級函數執行的任何延遲。這時，程序終止並報告錯誤情況，包括參數panic的值，這種終止序列稱為panic</p><pre>panic(42)panic("unreachable")panic(Error("cannot parse"))</pre><p>recover函數允許程序管理panic的goroutine的行為，假設函數G延遲函數D它調用recover，並且在G執行的goroutine上的同一個函數中發生panic。當延遲函數的運行到達D時，D的recover調用的返回值將是傳遞給panic調用的值。如果D返回正常，而沒有開始新的panic，panic序列就會停止。在這種情況下，在G和對panic的調用之間調用的函數的狀態將被丟棄，並恢復正常執行。然後運行G在D之前延遲的任何函數，G的執行通過返回其調用方而終止</p><p>如果滿足以下條件，recover返回nil值</p><ul><li>panic的參數是nil</li><li>goroutine沒有panic</li><li>延遲函數未直接調用recover</li></ul><p>下面示例中的protect函數調用函數參數G，並保護調用者免受G引發的運行時panic</p><pre>func protect(g func()) { defer func() { log.Println("done") // Println executes normally even if there is a panic if x := recover(); x != nil { log.Printf("run time panic: %v", x) } }() log.Println("start") g()}</pre><p><strong>Bootstrapping</strong> 當前的實現提供了幾個在引導過程中有用的內置函數。這些函數是為了完整性而記錄的，但不能保證它們保持在語言中。他們不返回結果</p><pre>Function Behaviorprint prints all arguments; formatting of arguments is implementation-specificprintln like print but prints spaces between arguments and a newline at the end</pre><p>實現限制：print和println不需要接受任意參數類型，但必須支持布爾、數字和字符串類型的打印</p><p><strong>包</strong> go程序是通過將包鏈接在一起來構建的。一個包依次由一個或多個源文件構造，這些源文件一起聲明屬於該包的常量、類型、變量和函數，並且可以在同一個包的所有文件中訪問這些源文件。這些元素可以導出並在另一個包中使用</p><p><strong>源文件組織</strong> 每個源文件都由一個package子句組成，該子句定義它所屬的包，後跟一組可能為空的導入聲明，這些聲明聲明它希望使用其內容的包，後跟一組可能為空的函數、類型、變量和常量聲明</p><pre>SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .</pre><p><strong>包子句</strong> 開始每個源文件並定義文件所屬的包</p><pre>PackageClause = "package" PackageName .PackageName = identifier .</pre><p>包名稱必須是非空的標識符。一組共享同一包名的文件構成一個包的實現，實現可能要求包的所有源文件都位於同一目錄中</p><p><strong>導入聲明</strong> 導入聲明聲明包含聲明的源文件依賴於導入包的功能，並允許訪問該包的導出標識符。導入將命名用於訪問的標識符(PackageName)和指定要導入的包的ImportPath</p><pre>ImportDecl = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .ImportSpec = [ "." | PackageName ] ImportPath .ImportPath = string_lit .</pre><p>PackageName在限定標識符中用於訪問導入源文件中包的導出標識符。它在文件塊中聲明。如果省略包名，則默認為導入包的package子句中指定的標識符。如果出現顯式句點(.)而不是名稱，則在該包的包塊中聲明的所有包的導出標識符都將在導入源文件的文件塊中聲明，並且必須在不使用限定符的情況下訪問</p><p>ImportPath的解釋依賴於實現，但它通常是編譯包的完整文件名的子字符串，可能與已安裝包的存儲庫有關</p><pre>Import declaration Local name of Sinimport "lib/math" math.Sinimport m "lib/math" m.Sinimport . "lib/math" Sinimport _ "lib/math"</pre><p><strong>程序初始化和執行</strong></p><p><strong>零值</strong> 當通過聲明或調用new為變量分配存儲時，或者當通過複合文本或調用make創建新值時，如果未提供顯式初始化，則會為變量或值指定默認值。此類變量或值的每個元素的類型都設置為零值：對於布爾值為false，對於數值類型為0，對於字符串""，對於指針、函數、接口、切片、通道和映射為nil。這個初始化是遞歸完成的，例如，如果沒有指定值，結構數組中的每個元素的字段都將為零值</p><p>這兩個簡單的聲明是等價的</p><pre>var i intvar i int = 0</pre><p>After...</p><pre>type T struct { i int; f float64; next *T }t := new(T) // var t Tt.i == 0t.f == 0.0t.next == nil</pre><p><strong>包初始化</strong> 在包中，包級變量初始化逐步進行，每個步驟按照聲明順序最早選擇一個變量，該變量不依賴於未初始化的變量</p><p>更準確地說，如果包級變量尚未初始化並且沒有初始化表達式或其初始化表達式不依賴於未初始化的變量，則認為該變量已準備好初始化。初始化是通過重複初始化下一個包級變量來進行的，該變量是聲明順序中最早並準備好初始化的，直到沒有準備好初始化的變量為止</p><p>如果此進程結束時仍存在變量未初始化，則這些變量是一個或多個初始化週期的一部分，並且程序無效</p><p>在多個文件中聲明的變量聲明順序由文件呈現給編譯器的順序決定：在第一個文件中聲明的變量在第二個文件中聲明的任何變量之前聲明，依此類推。依賴項分析不依賴於變量的實際值，只依賴於源代碼中對它們的詞法引用，並進行傳遞性分析。例如，如果變量x的初始化表達式引用其主體引用變量y的函數，那麼x依賴於y</p><ul><li>對變量或函數的引用是表示該變量或函數的標識符</li><li>對方法m的引用是形式t.m的方法值或方法表達式，其中t的(靜態)類型不是接口類型，方法m在t的方法集中。是否調用結果函數值t.m並不重要</li><li>如果x的初始化表達式或主體(用於函數和方法)包含對y的引用或對依賴於y的函數或方法的引用，則變量、函數或方法x依賴於變量y</li></ul><pre>var ( a = c + b // == 9 b = f() // == 4 c = f() // == 5 d = 3 // == 5 after initialization has finished)func f() int { d++ return d}</pre><p>初始化順序為d、b、c、a,初始化表達式中子表達式的順序不相關：在本例中，a=c+b和a=b+c導致相同的初始化順序。每個包都執行依賴關係分析；只考慮引用當前包中聲明的變量、函數和(非接口)方法。如果變量之間存在其他隱藏的數據依賴關係，則未指定這些變量之間的初始化順序。例如</p><pre>var x = I(T{}).ab() // x has an undetected, hidden dependency on a and bvar _ = sideEffect() // unrelated to x, a, or bvar a = bvar b = 42type I interface { ab() []int }type T struct{}func (T) ab() []int { return []int{a, b} }</pre><p>變量a將在b之後初始化，但x是在b之前、b和a之間還是在a之後初始化，因此也沒有指定調用sideEfect()的時刻(在x初始化之前或之後)。變量也可以使用包塊中聲明的名為init的函數初始化，不帶參數和結果參數</p><pre>func init() { … }</pre><p>即使在單個源文件中，也可以為每個包定義多個這樣的函數。在包塊中，init標識符只能用於聲明init函數，但標識符本身沒有聲明。因此，不能從程序的任何地方引用init函數</p><p>一個沒有導入的包通過給它的所有包級變量分配初始值，然後按它們在源中出現的順序調用所有init函數(可能在多個文件中)來初始化，如編譯器所示。如果包具有導入，則在初始化包本身之前初始化導入的包。如果多個包導入一個包，則導入的包將僅初始化一次。通過構造導入包可以保證不存在循環初始化依賴項</p><p>包初始化變量初始化和init函數調用發生在單個goroutine中，按順序，一次一個包。init函數可以啟動其他goroutine，這些goroutine可以與初始化代碼同時運行。但是，初始化總是對init函數進行排序：在前一個函數返回之前，它不會調用下一個函數</p><p>為了確保可重複的初始化行為，建議構建系統以詞法文件名的順序向編譯器呈現屬於同一個包的多個文件</p><p><strong>程序執行</strong> 一個完整的程序是通過將一個名為main包的未導入的包與它導入的所有包以可傳遞的方式鏈接起來創建的。main包必須具有包名稱main，並聲明一個不帶參數且不返回值的函數main</p><pre>func main() { … }</pre><p>程序執行首先初始化main包，然後調用main函數。當函數調用返回時，程序退出。它不會等待其他(non-main)goroutine完成</p><p><strong>Errors</strong> 預聲明類型error定義為</p><pre>type error interface { Error() string}</pre><p>它是表示錯誤條件的常規接口，nil值表示沒有錯誤。例如，可以定義從文件讀取數據的函數</p><pre>func Read(f *File, b []byte) (n int, err error)</pre><p><strong>運行時panic</strong> 執行錯誤(如試圖索引超出邊界的數組)會觸發一個運行時異常，該異常等價於使用實現定義的接口類型runtime.Error的值調用內置函數異常。該類型滿足預聲明接口類型錯誤。未指定表示不同運行時錯誤條件的確切錯誤值</p><pre>package runtimetype Error interface { error // and perhaps other methods}</pre><p><strong>系統注意事項</strong></p><p><strong>unsafe包</strong> 內置包unsafe(編譯器已知並可通過導入路徑unsafe訪問)為低級編程(包括違反類型系統的操作)提供了便利。使用unsafe包必須手動進行類型安全檢查，並且可能不可移植。包提供以下接口</p><pre>package unsafetype ArbitraryType int // shorthand for an arbitrary Go type; it is not a real typetype Pointer *ArbitraryTypefunc Alignof(variable ArbitraryType) uintptrfunc Offsetof(selector ArbitraryType) uintptrfunc Sizeof(variable ArbitraryType) uintptr</pre><p>Pointer是指針類型，但指針值不能被取消引用。基礎類型uintptr的任何指針或值都可以轉換為基礎類型指針的類型，反之亦然。Pointer和uintptr之間的轉換效果是由實現定義的</p><pre>var f float64bits = *(*uint64)(unsafe.Pointer(&amp;f))type ptr unsafe.Pointerbits = *(*uint64)(ptr(&amp;f))var p ptr = nil</pre><p>函數Alignof和Sizeof獲取任意類型的表達式x並返回對齊或大小，分別是假設變量v，就好像v是通過var v=x聲明的一樣</p><p>函數Offsetof接受(可能帶圓括號)選擇器s.f，表示由s或*s表示的結構的字段f，並返回相對於結構地址的字段偏移量(字節)。如果f是一個嵌入字段，那麼它必須是可訪問的，而無需通過結構的字段進行指針間接指向。對於字段為f的結構s</p><pre>uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&amp;s.f))</pre><p>計算機體系結構可能需要對齊內存地址；也就是說，如果變量的地址是一個因子的倍數，則變量的類型對齊。函數Alignof接受表示任何類型變量的表達式，並以字節為單位返回變量(類型)的對齊方式。對於變量x</p><pre>uintptr(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == 0</pre><p>對Alignof、Offsetof和Sizeof的調用是uintpttr類型的編譯時常量表達式</p><p><strong>Size and alignment guarantees</strong> 對於數字類型，保證以下size</p><pre>type size in bytesbyte, uint8, int8 1uint16, int16 2uint32, int32, float32 4uint64, int64, float64, complex64 8complex128 16</pre><p>保證以下最小對齊屬性</p><ul><li>對於任意類型的變量x: unsafe.Alignof(x)至少為1</li><li>對於結構類型的變量x: unsafe.Alignof(x)是x每個字段f的unsafe.Alignof(x.f)值中最大的一個，但至少為1</li><li>對於數組類型的變量x: unsafe.Alignof(x)與數組元素類型的變量的對齊方式相同</li></ul><p>如果結構或數組類型不包含byte size大於零的字段(或元素)，則其size為零。兩個不同的zero-size變量在內存中可能具有相同的地址</p><hr><p>小結</p><p>語言特性，即語法規則和特點的概述。想通過文字來準確描述語法規則，需要保持規則的嚴謹性，文章讀/寫起來會有些咬文嚼字，此處也不刻意追求文本流暢程度。關於Golang的語言特性知識點零碎且分散，本文專門歸納整理，希望對您有所幫助</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Golang</a></li><li><a>語言</a></li><li><a>特性</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html alt=什麼是梯度：用形象的語言解讀梯度的本質原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/557c7b377c5449bb885df35b2d354e03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html title=什麼是梯度：用形象的語言解讀梯度的本質原理>什麼是梯度：用形象的語言解讀梯度的本質原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html alt=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S5YRqTH6awaqmG style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html title=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行>我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html alt=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/46ea0001172cab9535dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html title=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用>谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html alt=C語言經典100例004-統計各個年齡階段的人數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/98c4bb54-8d7e-4234-bf07-0d8190ba1a0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html title=C語言經典100例004-統計各個年齡階段的人數>C語言經典100例004-統計各個年齡階段的人數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html alt=CC++語言19｜靜態成員（對象共享數據成員及其成員函數） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html title=CC++語言19｜靜態成員（對象共享數據成員及其成員函數）>CC++語言19｜靜態成員（對象共享數據成員及其成員函數）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc78327d.html alt=零基礎學C語言——運算符 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/fa8bd8c0-66cc-4cf5-a447-dbe6409abebb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc78327d.html title=零基礎學C語言——運算符>零基礎學C語言——運算符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html alt="Java入門 - 語言基礎 - 18.正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ddf3412c71244bcaa3cb911e988fed3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html title="Java入門 - 語言基礎 - 18.正則表達式">Java入門 - 語言基礎 - 18.正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8996a003.html alt=錫青銅、黃銅和紫銅的特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/508132631a8f40fda06c11b96c41fd21 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8996a003.html title=錫青銅、黃銅和紫銅的特性>錫青銅、黃銅和紫銅的特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a4dfb108.html alt=中國的主要語言和方言分佈：你的家鄉說的是什麼話？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a57a5bd9fd3d431991bf2e3fdb12f9e8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a4dfb108.html title=中國的主要語言和方言分佈：你的家鄉說的是什麼話？>中國的主要語言和方言分佈：你的家鄉說的是什麼話？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45b722bf.html alt=第12屆自然語言處理和知識工程國際會議將在西華大學舉行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45b722bf.html title=第12屆自然語言處理和知識工程國際會議將在西華大學舉行>第12屆自然語言處理和知識工程國際會議將在西華大學舉行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49bb3bbd.html alt=第12屆自然語言處理與知識工程國際學術會議在西華大學舉行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e62000034a58600d55e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49bb3bbd.html title=第12屆自然語言處理與知識工程國際學術會議在西華大學舉行>第12屆自然語言處理與知識工程國際學術會議在西華大學舉行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a9b1eec.html alt="Golang 入門 : 理解併發與並行" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cf0d86c0222b4f50ad5ba925231b361e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a9b1eec.html title="Golang 入門 : 理解併發與並行">Golang 入門 : 理解併發與並行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4be34efa.html alt=C語言：數據結構-二叉樹的定義和基本術語和二叉樹的性質 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f9fe517ff46746b99d14e3e154a1d319 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4be34efa.html title=C語言：數據結構-二叉樹的定義和基本術語和二叉樹的性質>C語言：數據結構-二叉樹的定義和基本術語和二叉樹的性質</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>