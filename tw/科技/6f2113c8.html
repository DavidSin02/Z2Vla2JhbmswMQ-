<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>這樣設計 Java 異常更優雅，趕緊學習吧 | 极客快訊</title><meta property="og:title" content="這樣設計 Java 異常更優雅，趕緊學習吧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/f55e4e93-073c-48d4-803e-699c75a9e084"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f2113c8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f2113c8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6f2113c8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f2113c8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f2113c8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6f2113c8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6f2113c8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f2113c8.html><meta property="article:published_time" content="2020-11-14T21:06:59+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:59+08:00"><meta name=Keywords content><meta name=description content="這樣設計 Java 異常更優雅，趕緊學習吧"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/6f2113c8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>這樣設計 Java 異常更優雅，趕緊學習吧</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="這樣設計 Java 異常更優雅，趕緊學習吧" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/f55e4e93-073c-48d4-803e-699c75a9e084><p class=pgc-img-caption></p></div><p>導語</p><p>異常處理是程序開發中必不可少操作之一，但如何正確優雅的對異常進行處理確是一門學問，筆者根據自己的開發經驗來談一談我是如何對異常進行處理的。</p><p>由於本文只作一些經驗之談，不涉及到基礎知識部分，如果讀者對異常的概念還很模糊，請先查看基礎知識。</p><p class=ql-align-justify><br></p><p>如何選擇異常類型</p><p class=ql-align-justify><br></p><p><strong>異常的類別</strong></p><p class=ql-align-justify><br></p><p>正如我們所知道的，java中的異常的超類是java.lang.Throwable(後文省略為Throwable),它有兩個比較重要的子類,java.lang.Exception(後文省略為Exception)和java.lang.Error(後文省略為Error)，其中Error由JVM虛擬機進行管理,如我們所熟知的OutOfMemoryError異常等，所以我們本文不關注Error異常，那麼我們細說一下Exception異常。</p><p class=ql-align-justify><br></p><p>Exception異常有個比較重要的子類，叫做RuntimeException。我們將RuntimeException或其他繼承自RuntimeException的子類稱為非受檢異常(unchecked Exception)，其他繼承自Exception異常的子類稱為受檢異常(checked Exception)。本文重點來關注一下受檢異常和非受檢異常這兩種異常。</p><p class=ql-align-justify><br></p><p><strong>如何選擇異常</strong></p><p class=ql-align-justify><br></p><p>從筆者的開發經驗來看，如果在一個應用中，需要開發一個方法(如某個功能的service方法)，這個方法如果中間可能出現異常，那麼你需要考慮這個異常出現之後是否調用者可以處理，並且你是否希望調用者進行處理，如果調用者可以處理，並且你也希望調用者進行處理，那麼就要拋出受檢異常，提醒調用者在使用你的方法時，考慮到如果拋出異常時如果進行處理，相似的，如果在寫某個方法時，你認為這是個偶然異常，理論上說，你覺得運行時可能會碰到什麼問題，而這些問題也許不是必然發生的，也不需要調用者顯示的通過異常來判斷業務流程操作的，那麼這時就可以使用一個RuntimeException這樣的非受檢異常.</p><p class=ql-align-justify><br></p><p>好了，估計我上邊說的這段話，你讀了很多遍也依然覺得晦澀了。</p><p>那麼，請跟著我的思路，在慢慢領會一下。</p><p class=ql-align-justify><br></p><p><strong>什麼時候才需要拋異常</strong></p><p class=ql-align-justify><br></p><p>首先我們需要了解一個問題，什麼時候才需要拋異常？異常的設計是方便給開發者使用的，但不是亂用的，筆者對於什麼時候拋異常這個問題也問了很多朋友，能給出準確答案的確實不多。其實這個問題很簡單，如果你覺得某些”問題”解決不了了，那麼你就可以拋出異常了。比如，你在寫一個service,其中在寫到某段代碼處,你發現可能會產生問題，那麼就請拋出異常吧，相信我，你此時拋出異常將是一個最佳時機。</p><p class=ql-align-justify><br></p><p><strong>應該拋出怎樣的異常</strong></p><p class=ql-align-justify><br></p><p>瞭解完了什麼時候才需要拋出異常後，我們再思考一個問題，真的當我們拋出異常時，我們應該選用怎樣的異常呢？究竟是受檢異常還是非受檢異常呢(RuntimeException)呢？我來舉例說明一下這個問題，先從受檢異常說起,比如說有這樣一個業務邏輯，需要從某文件中讀取某個數據，這個讀取操作可能是由於文件被刪除等其他問題導致無法獲取從而出現讀取錯誤，那麼就要從redis或mysql數據庫中再去獲取此數據,參考如下代碼，getKey(Integer)為入口程序.</p><p class=ql-align-justify><br></p><blockquote>public String getKey(Integer key){ String value; try { InputStream inputStream = getFiles("/file/nofile"); //接下來從流中讀取key的value指 value = ...; } catch (Exception e) { //如果拋出異常將從mysql或者redis進行取之 value = ...; }} public InputStream getFiles(String path) throws Exception { File file = new File(path); InputStream inputStream = null; try { inputStream = new BufferedInputStream(new FileInputStream(file)); } catch (FileNotFoundException e) { throw new Exception("I/O讀取錯誤",e.getCause()); } return inputStream;}</blockquote><p class=ql-align-justify><br></p><p>ok，看了以上代碼以後，你也許心中有一些想法，原來受檢異常可以控制義務邏輯，對，沒錯，通過受檢異常真的可以控制業務邏輯，但是切記不要這樣使用，我們應該合理的拋出異常，因為程序本身才是流程，異常的作用僅僅是當你進行不下去的時候找到的一個藉口而已，它並不能當成控制程序流程的入口或出口，如果這樣使用的話，是在將異常的作用擴大化，這樣將會導致代碼複雜程度的增加，耦合性會提高，代碼可讀性降低等問題。那麼就一定不要使用這樣的異常嗎？其實也不是，在真的有這樣的需求的時候，我們可以這樣使用，只是切記，不要把它真的當成控制流程的工具或手段。那麼究竟什麼時候才要拋出這樣的異常呢？要考慮，如果調用者調用出錯後，一定要讓調用者對此錯誤進行處理才可以，滿足這樣的要求時，我們才會考慮使用受檢異常。</p><p class=ql-align-justify><br></p><p>接下來，我們來看一下非受檢異常呢(RuntimeException)，對於RuntimeException這種異常，我們其實很多見，比如java.lang.NullPointerException／java.lang.IllegalArgumentException等，那麼這種異常我們時候拋出呢？當我們在寫某個方法的時候，可能會偶然遇到某個錯誤，我們認為這個問題時運行時可能為發生的，並且理論上講，沒有這個問題的話，程序將會正常執行的時候，它不強制要求調用者一定要捕獲這個異常，此時拋出RuntimeException異常,舉個例子，當傳來一個路徑的時候，需要返回一個路徑對應的File對象:</p><p class=ql-align-justify><br></p><blockquote>public void test() { myTest.getFiles("");} public File getFiles(String path) { if(null == path || "".equals(path)){ throw new NullPointerException("路徑不能為空!"); } File file = new File(path); return file;}</blockquote><p class=ql-align-justify><br></p><p>上述例子表明，如果調用者調用getFiles(String)的時候如果path是空，那麼就拋出空指針異常(它是RuntimeException的子類),調用者不用顯示的進行try…catch…操作進行強制處理.這就要求調用者在調用這樣的方法時先進行驗證，避免發生RuntimeException.如下:</p><p class=ql-align-justify><br></p><p><strong>應該選用哪種異常</strong></p><p class=ql-align-justify><br></p><p>通過以上的描述和舉例，可以總結出一個結論，RuntimeException異常和受檢異常之間的區別就是:是否強制要求調用者必須處理此異常，如果強制要求調用者必須進行處理，那麼就使用受檢異常，否則就選擇非受檢異常(RuntimeException)。一般來講，如果沒有特殊的要求，我們建議使用RuntimeException異常。</p><p class=ql-align-justify><br></p><p>場景介紹和技術選型</p><p class=ql-align-justify><br></p><p><strong>架構描述</strong></p><p class=ql-align-justify><br></p><p>正如我們所知，傳統的項目都是以MVC框架為基礎進行開發的，本文主要從使用restful風格接口的設計來體驗一下異常處理的優雅。</p><p class=ql-align-justify><br></p><p>我們把關注點放在restful的api層(和web中的controller層類似)和service層，研究一下在service中如何拋出異常，然後api層如何進行捕獲並且轉化異常。</p><p class=ql-align-justify><br></p><p>使用的技術是:spring-boot,jpa(hibernate),mysql,如果對這些技術不是太熟悉，讀者需要自行閱讀相關材料。</p><p class=ql-align-justify><br></p><p><strong>業務場景描述</strong></p><p class=ql-align-justify><br></p><p>選擇一個比較簡單的業務場景，以電商中的收貨地址管理為例，用戶在移動端進行購買商品時，需要進行收貨地址管理，在項目中，提供一些給移動端進行訪問的api接口，如:添加收貨地址，刪除收貨地址，更改收貨地址，默認收貨地址設置，收貨地址列表查詢，單個收貨地址查詢等接口。</p><p class=ql-align-justify><br></p><p><strong>構建約束條件</strong></p><p class=ql-align-justify><br></p><p>ok，這個是設置好的一個很基本的業務場景，當然，無論什麼樣的api操作，其中都包含一些規則:</p><p class=ql-align-justify><br></p><p>添加收貨地址:</p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li><li class=ql-align-justify>收貨地址實體信息</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在 的</li><li class=ql-align-justify>收貨地址的必要字段不能為 空</li><li class=ql-align-justify>如果用戶還沒有收貨地址，當此收貨地址創建時設置成默認收貨地址 —</li></ul><p class=ql-align-justify><br></p><p>刪除收貨地址:</p><p class=ql-align-justify><br></p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li><li class=ql-align-justify>收貨地址id</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li><li class=ql-align-justify>收貨地址不能為空，且此收貨地址確實是存在的</li><li class=ql-align-justify>判斷此收貨地址是否是用戶的收貨地址</li><li class=ql-align-justify>判斷此收貨地址是否為默認收貨地址，如果是默認收貨地址，那麼不能進行刪除</li></ul><p class=ql-align-justify><br></p><p>更改收貨地址:</p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li><li class=ql-align-justify>收貨地址id</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li><li class=ql-align-justify>收貨地址不能為空，且此收貨地址確實是存在的</li><li class=ql-align-justify>判斷此收貨地址是否是用戶的收貨地址</li></ul><p class=ql-align-justify><br></p><p>默認地址設置:</p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li><li class=ql-align-justify>收貨地址id</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li><li class=ql-align-justify>收貨地址不能為空，且此收貨地址確實是存在的</li><li class=ql-align-justify>判斷此收貨地址是否是用戶的收貨地址</li></ul><p class=ql-align-justify><br></p><p>收貨地址列表查詢:</p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li></ul><p class=ql-align-justify><br></p><p>單個收貨地址查詢:</p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li><li class=ql-align-justify>收貨地址id</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li><li class=ql-align-justify>收貨地址不能為空，且此收貨地址確實是存在的</li><li class=ql-align-justify>判斷此收貨地址是否是用戶的收貨地址</li></ul><p class=ql-align-justify><br></p><p><strong>約束判斷和技術選型</strong></p><p class=ql-align-justify><br></p><p>對於上述列出的約束條件和功能列表，我選擇幾個比較典型的異常處理場景進行分析:添加收貨地址，刪除收貨地址，獲取收貨地址列表。</p><p>那麼應該有哪些必要的知識儲備呢，讓我們看一下收貨地址這個功能:</p><p>添加收貨地址中需要對用戶id和收貨地址實體信息就行校驗，那麼對於非空的判斷，我們如何進行工具的選擇呢？傳統的判斷如下:</p><p class=ql-align-justify><br></p><blockquote>/** * 添加地址 * @param uid * @param address * @return */public Address addAddress(Integer uid,Address address){ if(null != uid){ //進行處理.. } return null;}</blockquote><p class=ql-align-justify><br></p><p>上邊的例子，如果只判斷uid為空還好，如果再去判斷address這個實體中的某些必要屬性是否為空，在字段很多的情況下，這無非是災難性的。</p><p>那我們應該怎麼進行這些入參的判斷呢，給大家介紹兩個知識點:</p><p class=ql-align-justify><br></p><ol><li class=ql-align-justify>Guava中的Preconditions類實現了很多入參方法的判斷</li><li class=ql-align-justify>jsr 303的validation規範(目前實現比較全的是hibernate實現的hibernate-validator)</li></ol><p class=ql-align-justify><br></p><p>如果使用了這兩種推薦技術，那麼入參的判斷會變得簡單很多。推薦大家多使用這些成熟的技術和jar工具包，他可以減少很多不必要的工作量。我們只需要把重心放到業務邏輯上。而不會因為這些入參的判斷耽誤更多的時間。</p><p class=ql-align-justify><br></p><p>如何優雅的設計java異常</p><p class=ql-align-justify><br></p><p><strong>domain介紹</strong></p><p class=ql-align-justify><br></p><p>根據項目場景來看，需要兩個domain模型，一個是用戶實體，一個是地址實體.</p><p>Address domain如下:</p><p class=ql-align-justify><br></p><blockquote>@Entity@Datapublic class Address { @Id @GeneratedValue private Integer id; private String province;//省 private String city;//市 private String county;//區 private Boolean isDefault;//是否是默認地址 @ManyToOne(cascade={CascadeType.ALL}) @JoinColumn(name="uid") private User user;}</blockquote><p class=ql-align-justify><br></p><p>User domain如下:</p><p class=ql-align-justify><br></p><blockquote>@Entity@Datapublic class User { @Id @GeneratedValue private Integer id; private String name;//姓名 @OneToMany(cascade= CascadeType.ALL,mappedBy="user",fetch = FetchType.LAZY) private Set&lt;Address> addresses;}</blockquote><p class=ql-align-justify><br></p><p>ok,上邊是一個模型關係，用戶-收貨地址的關係是1-n的關係。上邊的@Data是使用了一個叫做lombok的工具，它自動生成了Setter和Getter等方法，用起來非常方便，感興趣的讀者可以自行了解一下。</p><p class=ql-align-justify><br></p><p><strong>dao介紹</strong></p><p class=ql-align-justify><br></p><p>數據連接層，我們使用了spring-data-jpa這個框架，它要求我們只需要繼承框架提供的接口，並且按照約定對方法進行取名，就可以完成我們想要的數據庫操作。</p><p class=ql-align-justify><br></p><p>用戶數據庫操作如下:</p><p class=ql-align-justify><br></p><blockquote>@Repositorypublic interface IUserDao extends JpaRepository&lt;User,Integer> { }</blockquote><p class=ql-align-justify><br></p><p>收貨地址操作如下:</p><p class=ql-align-justify><br></p><blockquote>@Repositorypublic interface IAddressDao extends JpaRepository&lt;Address,Integer> { }</blockquote><p class=ql-align-justify><br></p><p>正如讀者所看到的，我們的DAO只需要繼承JpaRepository,它就已經幫我們完成了基本的CURD等操作，如果想了解更多關於spring-data的這個項目，請參考一下spring的官方文檔，它比不方案我們對異常的研究。</p><p class=ql-align-justify><br></p><p><strong>Service異常設計</strong></p><p class=ql-align-justify><br></p><p>ok，終於到了我們的重點了，我們要完成service一些的部分操作:添加收貨地址，刪除收貨地址，獲取收貨地址列表.</p><p>首先看我的service接口定義:</p><p class=ql-align-justify><br></p><blockquote>public interface IAddressService { /** * 創建收貨地址 * @param uid * @param address * @return */Address createAddress(Integer uid,Address address); /** * 刪除收貨地址 * @param uid * @param aid */void deleteAddress(Integer uid,Integer aid); /** * 查詢用戶的所有收貨地址 * @param uid * @return */List&lt;Address> listAddresses(Integer uid);}</blockquote><p class=ql-align-justify><br></p><p>我們來關注一下實現:</p><p class=ql-align-justify><br></p><p>添加收貨地址</p><p>首先再來看一下之前整理的約束條件:</p><p class=ql-align-justify><br></p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li><li class=ql-align-justify>收貨地址實體信息</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li><li class=ql-align-justify>收貨地址的必要字段不能為空</li><li class=ql-align-justify>如果用戶還沒有收貨地址，當此收貨地址創建時設置成默認收貨地址</li></ul><p class=ql-align-justify><br></p><p>先看以下代碼實現:</p><p class=ql-align-justify><br></p><blockquote>@Overridepublic Address createAddress(Integer uid, Address address) { //============ 以下為約束條件 ============== //1.用戶id不能為空，且此用戶確實是存在的 Preconditions.checkNotNull(uid); User user = userDao.findOne(uid); if(null == user){ throw new RuntimeException("找不到當前用戶!"); } //2.收貨地址的必要字段不能為空 BeanValidators.validateWithException(validator, address); //3.如果用戶還沒有收貨地址，當此收貨地址創建時設置成默認收貨地址 if(ObjectUtils.isEmpty(user.getAddresses())){ address.setIsDefault(true); } //============ 以下為正常執行的業務邏輯 ============== address.setUser(user); Address result = addressDao.save(address); return result;}</blockquote><p class=ql-align-justify><br></p><p>其中，已經完成了上述所描述的三點約束條件，當三點約束條件都滿足時，才可以進行正常的業務邏輯，否則將拋出異常(一般在此處建議拋出運行時異常-RuntimeException)。</p><p class=ql-align-justify><br></p><p>介紹以下以上我所用到的技術:</p><p class=ql-align-justify><br></p><p>1. Preconfitions.checkNotNull(T t)這個是使用Guava中的com.google.common.base.Preconditions進行判斷的，因為service中用到的驗證較多，所以建議將Preconfitions改成靜態導入的方式:</p><p class=ql-align-justify><br></p><blockquote>import static com.google.common.base.Preconditions.checkNotNull;</blockquote><p class=ql-align-justify><br></p><p>當然Guava的github中的說明也建議我們這樣使用。</p><p class=ql-align-justify><br></p><p>2. BeanValidators.validateWithException(validator, address);</p><p class=ql-align-justify><br></p><p>這個使用了hibernate實現的jsr 303規範來做的，需要傳入一個validator和一個需要驗證的實體,那麼validator是如何獲取的呢,如下:</p><p class=ql-align-justify><br></p><blockquote>@Configurationpublic class BeanConfigs { @Beanpublic javax.validation.Validator getValidator(){ return new LocalValidatorFactoryBean();}}</blockquote><p class=ql-align-justify><br></p><p>他將獲取一個Validator對象，然後我們在service中進行注入便可以使用了:</p><p class=ql-align-justify><br></p><p>@Autowired</p><p>private Validator validator ;</p><p class=ql-align-justify><br></p><p>那麼BeanValidators這個類是如何實現的？其實實現方式很簡單，只要去判斷jsr 303的標註註解就ok了。</p><p>那麼jsr 303的註解寫在哪裡了呢？當然是寫在address實體類中了:</p><p class=ql-align-justify><br></p><blockquote>@Entity@Setter@Getterpublic class Address {@Id @GeneratedValue private Integer id; @NotNullprivate String province;//省@NotNullprivate String city;//市@NotNullprivate String county;//區private Boolean isDefault = false;//是否是默認地址 @ManyToOne(cascade={CascadeType.ALL})@JoinColumn(name="uid")private User user;}</blockquote><p class=ql-align-justify><br></p><p>寫好你需要的約束條件來進行判斷，如果合理的話，才可以進行業務操作，從而對數據庫進行操作。</p><p class=ql-align-justify><br></p><p>這塊的驗證是必須的，一個最主要的原因是:這樣的驗證可以避免髒數據的插入。如果讀者有正式上線的經驗的話，就可以理解這樣的一個事情，任何的代碼錯誤都可以容忍和修改，但是如果出現了髒數據問題，那麼它有可能是一個毀滅性的災難。程序的問題可以修改，但是髒數據的出現有可能無法恢復。所以這就是為什麼在service中一定要判斷好約束條件，再進行業務邏輯操作的原因了。</p><p class=ql-align-justify><br></p><p>此處的判斷為業務邏輯判斷，是從業務角度來進行篩選判斷的，除此之外，有可能在很多場景中都會有不同的業務條件約束，只需要按照要求來做就好。</p><p>對於約束條件的總結如下:</p><p class=ql-align-justify><br></p><ol><li class=ql-align-justify>基本判斷約束(null值等基本判斷)</li><li class=ql-align-justify>實體屬性約束(滿足jsr 303等基礎判斷)</li><li class=ql-align-justify>業務條件約束(需求提出的不同的業務約束)</li></ol><p class=ql-align-justify><br></p><p>當這個三點都滿足時，才可以進行下一步操作</p><p class=ql-align-justify><br></p><p>ok,基本介紹瞭如何做一個基礎的判斷，那麼再回到異常的設計問題上，上述代碼已經很清楚的描述如何在適當的位置合理的判斷一個異常了，那麼如何合理的拋出異常呢？</p><p class=ql-align-justify><br></p><p>只拋出RuntimeException就算是優雅的拋出異常嗎？當然不是，對於service中的拋出異常，筆者認為大致有兩種拋出的方法:</p><p class=ql-align-justify><br></p><ol><li class=ql-align-justify>拋出帶狀態碼RumtimeException異常</li><li class=ql-align-justify>拋出指定類型的RuntimeException異常</li></ol><p class=ql-align-justify><br></p><p>相對這兩種異常的方式進行結束，第一種異常指的是我所有的異常都拋RuntimeException異常，但是需要帶一個狀態碼，調用者可以根據狀態碼再去查詢究竟service拋出了一個什麼樣的異常。</p><p class=ql-align-justify><br></p><p>第二種異常是指在service中拋出什麼樣的異常就自定義一個指定的異常錯誤，然後在進行拋出異常。</p><p class=ql-align-justify><br></p><p>一般來講，如果系統沒有別的特殊需求的時候，在開發設計中，建議使用第二種方式。但是比如說像基礎判斷的異常，就可以完全使用guava給我們提供的類庫進行操作。jsr 303異常也可以使用自己封裝好的異常判斷類進行操作，因為這兩種異常都是屬於基礎判斷，不需要為它們指定特殊的異常。但是對於第三點義務條件約束判斷拋出的異常，就需要拋出指定類型的異常了。</p><p class=ql-align-justify><br></p><p>對於</p><p class=ql-align-justify><br></p><blockquote>throw new RuntimeException("找不到當前用戶!");</blockquote><p class=ql-align-justify><br></p><p>定義一個特定的異常類來進行這個義務異常的判斷:</p><p class=ql-align-justify><br></p><blockquote>public class NotFindUserException extends RuntimeException {public NotFindUserException() { super("找不到此用戶");} public NotFindUserException(String message) { super(message);}}</blockquote><p class=ql-align-justify><br></p><p>然後將此處改為:</p><p class=ql-align-justify><br></p><blockquote>throw new NotFindUserException("找不到當前用戶!");</blockquote><p class=ql-align-justify><br></p><p>or</p><p class=ql-align-justify><br></p><blockquote>throw new NotFindUserException();</blockquote><p class=ql-align-justify><br></p><p>ok,通過以上對service層的修改，代碼更改如下:</p><p class=ql-align-justify><br></p><blockquote>@Overridepublic Address createAddress(Integer uid, Address address) { //============ 以下為約束條件 ============== //1.用戶id不能為空，且此用戶確實是存在的 checkNotNull(uid); User user = userDao.findOne(uid); if(null == user){ throw new NotFindUserException("找不到當前用戶!"); } //2.收貨地址的必要字段不能為空 BeanValidators.validateWithException(validator, address); //3.如果用戶還沒有收貨地址，當此收貨地址創建時設置成默認收貨地址 if(ObjectUtils.isEmpty(user.getAddresses())){ address.setIsDefault(true); } //============ 以下為正常執行的業務邏輯 ============== address.setUser(user); Address result = addressDao.save(address); return result;}</blockquote><p class=ql-align-justify><br></p><p>這樣的service就看起來穩定性和理解性就比較強了。</p><p class=ql-align-justify><br></p><p>刪除收貨地址:</p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li><li class=ql-align-justify>收貨地址id</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li><li class=ql-align-justify>收貨地址不能為空，且此收貨地址確實是存在的</li><li class=ql-align-justify>判斷此收貨地址是否是用戶的收貨地址</li><li class=ql-align-justify>判斷此收貨地址是否為默認收貨地址，如果是默認收貨地址，那麼不能進行刪除</li></ul><p class=ql-align-justify><br></p><p>它與上述添加收貨地址類似，故不再贅述，delete的service設計如下:</p><p class=ql-align-justify><br></p><blockquote>@Overridepublic void deleteAddress(Integer uid, Integer aid) { //============ 以下為約束條件 ============== //1.用戶id不能為空，且此用戶確實是存在的 checkNotNull(uid); User user = userDao.findOne(uid); if(null == user){ throw new NotFindUserException(); } //2.收貨地址不能為空，且此收貨地址確實是存在的 checkNotNull(aid); Address address = addressDao.findOne(aid); if(null == address){ throw new NotFindAddressException(); } //3.判斷此收貨地址是否是用戶的收貨地址 if(!address.getUser().equals(user)){ throw new NotMatchUserAddressException(); } //4.判斷此收貨地址是否為默認收貨地址，如果是默認收貨地址，那麼不能進行刪除 if(address.getIsDefault()){ throw new DefaultAddressNotDeleteException(); } //============ 以下為正常執行的業務邏輯 ============== addressDao.delete(address);}</blockquote><p class=ql-align-justify><br></p><p>設計了相關的四個異常類:NotFindUserException,NotFindAddressException,NotMatchUserAddressException,DefaultAddressNotDeleteException.根據不同的業務需求拋出不同的異常。</p><p class=ql-align-justify><br></p><p>獲取收貨地址列表:</p><p>入參:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id</li></ul><p class=ql-align-justify><br></p><p>約束:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>用戶id不能為空，且此用戶確實是存在的</li></ul><p class=ql-align-justify><br></p><p>代碼如下:</p><p class=ql-align-justify><br></p><blockquote>@Overridepublic List&lt;Address> listAddresses(Integer uid) { //============ 以下為約束條件 ============== //1.用戶id不能為空，且此用戶確實是存在的 checkNotNull(uid); User user = userDao.findOne(uid); if(null == user){ throw new NotFindUserException(); } //============ 以下為正常執行的業務邏輯 ============== User result = userDao.findOne(uid); return result.getAddresses();}</blockquote><p class=ql-align-justify><br></p><p><strong>api異常設計</strong></p><p class=ql-align-justify><br></p><p>大致有兩種拋出的方法:</p><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>拋出帶狀態碼RumtimeException異常</li><li class=ql-align-justify>拋出指定類型的RuntimeException異常</li></ul><p class=ql-align-justify><br></p><p>這個是在設計service層異常時提到的，通過對service層的介紹，我們在service層拋出異常時選擇了第二種拋出的方式，不同的是，在api層拋出異常我們需要使用這兩種方式進行拋出:要指定api異常的類型，並且要指定相關的狀態碼，然後才將異常拋出，這種異常設計的核心是讓調用api的使用者更能清楚的瞭解發生異常的詳細信息，除了拋出異常外，我們還需要將狀態碼對應的異常詳細信息以及異常有可能發生的問題製作成一個對應的表展示給用戶，方便用戶的查詢。（如github提供的api文檔，微信提供的api文檔等）,還有一個好處:如果用戶需要自定義提示消息，可以根據返回的狀態碼進行提示的修改。</p><p class=ql-align-justify><br></p><p><strong>api驗證約束</strong></p><p class=ql-align-justify><br></p><p>首先對於api的設計來說，需要存在一個dto對象，這個對象負責和調用者進行數據的溝通和傳遞，然後dto->domain在傳給service進行操作，這一點一定要注意，第二點，除了說道的service需要進行基礎判斷(null判斷)和jsr 303驗證以外，同樣的，api層也需要進行相關的驗證，如果驗證不通過的話，直接返回給調用者，告知調用失敗，不應該帶著不合法的數據再進行對service的訪問，那麼讀者可能會有些迷惑，不是service已經進行驗證了，為什麼api層還需要進行驗證麼？這裡便設計到了一個概念:編程中的墨菲定律，如果api層的數據驗證疏忽了，那麼有可能不合法數據就帶到了service層，進而講髒數據保存到了數據庫。</p><p class=ql-align-justify><br></p><p>所以縝密編程的核心是:永遠不要相信收到的數據是合法的。</p><p class=ql-align-justify><br></p><p><strong>api異常設計</strong></p><p class=ql-align-justify><br></p><p>設計api層異常時，正如我們上邊所說的，需要提供錯誤碼和錯誤信息，那麼可以這樣設計，提供一個通用的api超類異常，其他不同的api異常都繼承自這個超類:</p><p class=ql-align-justify><br></p><blockquote>public class ApiException extends RuntimeException {protected Long errorCode ;protected Object data ; public ApiException(Long errorCode,String message,Object data,Throwable e){ super(message,e); this.errorCode = errorCode ; this.data = data ;} public ApiException(Long errorCode,String message,Object data){ this(errorCode,message,data,null);} public ApiException(Long errorCode,String message){ this(errorCode,message,null,null);} public ApiException(String message,Throwable e){ this(null,message,null,e);} public ApiException(){ } public ApiException(Throwable e){ super(e);} public Long getErrorCode() { return errorCode;} public void setErrorCode(Long errorCode) { this.errorCode = errorCode;} public Object getData() { return data;} public void setData(Object data) { this.data = data;}}</blockquote><p class=ql-align-justify><br></p><p>然後分別定義api層異常：ApiDefaultAddressNotDeleteException,ApiNotFindAddressException,ApiNotFindUserException,ApiNotMatchUserAddressException。</p><p>以默認地址不能刪除為例:</p><p class=ql-align-justify><br></p><blockquote>public class ApiDefaultAddressNotDeleteException extends ApiException { public ApiDefaultAddressNotDeleteException(String message) { super(AddressErrorCode.DefaultAddressNotDeleteErrorCode, message, null);}}</blockquote><p class=ql-align-justify><br></p><p>AddressErrorCode.DefaultAddressNotDeleteErrorCode就是需要提供給調用者的錯誤碼。錯誤碼類如下:</p><p class=ql-align-justify><br></p><blockquote>public abstract class AddressErrorCode { public static final Long DefaultAddressNotDeleteErrorCode = 10001L;//默認地址不能刪除 public static final Long NotFindAddressErrorCode = 10002L;//找不到此收貨地址 public static final Long NotFindUserErrorCode = 10003L;//找不到此用戶 public static final Long NotMatchUserAddressErrorCode = 10004L;//用戶與收貨地址不匹配}</blockquote><p class=ql-align-justify><br></p><p>ok,那麼api層的異常就已經設計完了，在此多說一句，AddressErrorCode錯誤碼類存放了可能出現的錯誤碼，更合理的做法是把他放到配置文件中進行管理。</p><p class=ql-align-justify><br></p><p><strong>api處理異常</strong></p><p class=ql-align-justify><br></p><p>api層會調用service層，然後來處理service中出現的所有異常，首先，需要保證一點，一定要讓api層非常輕，基本上做成一個轉發的功能就好(接口參數，傳遞給service參數，返回給調用者數據,這三個基本功能)，然後就要在傳遞給service參數的那個方法調用上進行異常處理。</p><p class=ql-align-justify><br></p><p>此處僅以添加地址為例:</p><p class=ql-align-justify><br></p><blockquote>@Autowiredprivate IAddressService addressService; /** * 添加收貨地址 * @param addressDTO * @return */@RequestMapping(method = RequestMethod.POST)public AddressDTO add(@Valid @RequestBody AddressDTO addressDTO){ Address address = new Address(); BeanUtils.copyProperties(addressDTO,address); Address result; try { result = addressService.createAddress(addressDTO.getUid(), address); }catch (NotFindUserException e){ throw new ApiNotFindUserException("找不到該用戶"); }catch (Exception e){//未知錯誤 throw new ApiException(e); } AddressDTO resultDTO = new AddressDTO(); BeanUtils.copyProperties(result,resultDTO); resultDTO.setUid(result.getUser().getId()); return resultDTO;}</blockquote><p class=ql-align-justify><br></p><p>這裡的處理方案是調用service時，判斷異常的類型，然後將任何service異常都轉化成api異常，然後拋出api異常，這是常用的一種異常轉化方式。相似刪除收貨地址和獲取收貨地址也類似這樣處理，在此，不在贅述。</p><p class=ql-align-justify><br></p><p><strong>api異常轉化</strong></p><p class=ql-align-justify><br></p><p>已經講解了如何拋出異常和何如將service異常轉化為api異常，那麼轉化成api異常直接拋出是否就完成了異常處理呢？ 答案是否定的，當拋出api異常後，我們需要把api異常返回的數據(json or xml)讓用戶看懂，那麼需要把api異常轉化成dto對象(ErrorDTO),看如下代碼:</p><p class=ql-align-justify><br></p><blockquote>@ControllerAdvice(annotations = RestController.class)class ApiExceptionHandlerAdvice { /** * Handle exceptions thrown by handlers. */@ExceptionHandler(value = Exception.class)@ResponseBodypublic ResponseEntity&lt;ErrorDTO> exception(Exception exception,HttpServletResponse response) { ErrorDTO errorDTO = new ErrorDTO(); if(exception instanceof ApiException){//api異常 ApiException apiException = (ApiException)exception; errorDTO.setErrorCode(apiException.getErrorCode()); }else{//未知異常 errorDTO.setErrorCode(0L); } errorDTO.setTip(exception.getMessage()); ResponseEntity&lt;ErrorDTO> responseEntity = new ResponseEntity&lt;>(errorDTO,HttpStatus.valueOf(response.getStatus())); return responseEntity;} @Setter@Getterclass ErrorDTO{ private Long errorCode; private String tip;}}</blockquote><p class=ql-align-justify><br></p><p>ok,這樣就完成了api異常轉化成用戶可以讀懂的DTO對象了，代碼中用到了@ControllerAdvice，這是spring MVC提供的一個特殊的切面處理。</p><p class=ql-align-justify><br></p><p>當調用api接口發生異常時，用戶也可以收到正常的數據格式了,比如當沒有用戶(uid為2)時，卻為這個用戶添加收貨地址,postman(Google plugin 用於模擬http請求)之後的數據:</p><p class=ql-align-justify><br></p><blockquote>{ "errorCode": 10003, "tip": "找不到該用戶"}</blockquote><p class=ql-align-justify><br></p><p>總結</p><p class=ql-align-justify><br></p><p>本文只從如何設計異常作為重點來講解，涉及到的api傳輸和service的處理，還有待優化，比如api接口訪問需要使用https進行加密，api接口需要OAuth2.0授權或api接口需要簽名認證等問題，文中都未曾提到，本文的重心在於異常如何處理，所以讀者只需關注涉及到異常相關的問題和處理方式就可以了。希望本篇文章對你理解異常有所幫助。</p><p><strong>私信回覆學習，領取更多學習資料。</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>這樣</a></li><li><a>設計</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e73ac859.html alt=破碎篩分工藝這樣設計！節能高效、省電還省錢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5c8e659d99b64261aff3b6c5148f1287 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e73ac859.html title=破碎篩分工藝這樣設計！節能高效、省電還省錢>破碎篩分工藝這樣設計！節能高效、省電還省錢</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/1026b24f.html alt=《Java語言程序設計》在線作業題目與答案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/1026b24f.html title=《Java語言程序設計》在線作業題目與答案>《Java語言程序設計》在線作業題目與答案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d50be9a.html alt=高薪Java工程師必備技能分享：設計模式與框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/847d89520ef24bb0a34a7a73628f7234 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d50be9a.html title=高薪Java工程師必備技能分享：設計模式與框架>高薪Java工程師必備技能分享：設計模式與框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/417dda7d.html alt=卡座這樣設計，既省空間又實用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/54af503c7331408a84cc4814cb4a8110 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/417dda7d.html title=卡座這樣設計，既省空間又實用>卡座這樣設計，既省空間又實用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html alt=Java程序設計-面向對象思路（筆記） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9fcc6e3cac554acc8790d6b14e6aceaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html title=Java程序設計-面向對象思路（筆記）>Java程序設計-面向對象思路（筆記）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c3fe45e.html alt=Java程序設計概述：設計平臺+關鍵術語+發展簡史+常見誤解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/39135c0b091e4aaeb3270f9495cf7ee9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c3fe45e.html title=Java程序設計概述：設計平臺+關鍵術語+發展簡史+常見誤解>Java程序設計概述：設計平臺+關鍵術語+發展簡史+常見誤解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2f8e3c7.html alt=要是中國水槽也能設計這樣就好了！打破常規成凸形，多個瀝水區 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/46ff58b52cc24bceb19d7d840231ff62 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2f8e3c7.html title=要是中國水槽也能設計這樣就好了！打破常規成凸形，多個瀝水區>要是中國水槽也能設計這樣就好了！打破常規成凸形，多個瀝水區</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/768bb322.html alt=Java程序設計-繼承性（筆記） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/84841b9782fe48cab249b931b5c4742a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/768bb322.html title=Java程序設計-繼承性（筆記）>Java程序設計-繼承性（筆記）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6f3b4b.html alt=走廊過道這樣設計，讓空間美出新高度！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ce49d1985879443994d00f5ac0ca22d3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6f3b4b.html title=走廊過道這樣設計，讓空間美出新高度！>走廊過道這樣設計，讓空間美出新高度！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d1e8df.html alt=這樣的走廊設計，你1秒就愛上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/62ae45cbdd2549668b4dfdde0f67fa01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d1e8df.html title=這樣的走廊設計，你1秒就愛上>這樣的走廊設計，你1秒就愛上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48a7e33.html alt=過道走廊這樣設計，讓你的家變得與眾不同 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RV7aHEl3QDpH8x style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48a7e33.html title=過道走廊這樣設計，讓你的家變得與眾不同>過道走廊這樣設計，讓你的家變得與眾不同</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/0d02081.html alt=像平面設計這樣的專業，我們可以直接上圖，少點廢話嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/150e00054ab7ab580998 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/0d02081.html title=像平面設計這樣的專業，我們可以直接上圖，少點廢話嗎？>像平面設計這樣的專業，我們可以直接上圖，少點廢話嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/deff23b.html alt=樓梯間竟可以這樣設計，大戶型的福利 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/db36a256772542728937986e6b843b52 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/deff23b.html title=樓梯間竟可以這樣設計，大戶型的福利>樓梯間竟可以這樣設計，大戶型的福利</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/81188f5.html alt=樓梯間設計，樓梯間這樣裝好美又實用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3de0927ab88c4bfa80cca4e2f569006a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/81188f5.html title=樓梯間設計，樓梯間這樣裝好美又實用>樓梯間設計，樓梯間這樣裝好美又實用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/54f3037.html alt=Java程序設計-類和對象（筆記） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d441b8fb53774c4c84e372c0c03b248e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/54f3037.html title=Java程序設計-類和對象（筆記）>Java程序設計-類和對象（筆記）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>