<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從3 個方面增加代碼可讀性和可維護性 | 极客快訊</title><meta property="og:title" content="從3 個方面增加代碼可讀性和可維護性 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/55f537f25ed145dfad88eaf11ffa4fe1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/713bfab7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/713bfab7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/713bfab7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/713bfab7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/713bfab7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/713bfab7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/713bfab7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/713bfab7.html><meta property="article:published_time" content="2020-11-14T21:01:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:42+08:00"><meta name=Keywords content><meta name=description content="從3 個方面增加代碼可讀性和可維護性"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/713bfab7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從3 個方面增加代碼可讀性和可維護性</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=article-title>故事</h2><p>領導：“原來項目有個需求變動，需要你去改一下，沒有改很多，這個應該很快吧。”</p><p>二盛：“好，我先看一下。”</p><p>內心忐忑的二盛打開了那個古老的項目，不看不知道，一看嚇一跳，項目的代碼大概是這樣的：</p><p>一文千行洋洋灑灑<br>每行代碼密密麻麻<br>一氣呵成想哪寫哪<br>條理不清一團亂麻<br></p><p>重複代碼整齊好看<br>寧寫多次絕不封裝<br>全局變量滿天飛翔<br>想用就用從天而降<br></p><p>變量命名全按順序<br>a1 , a2 , a3 , a4<br>只用for+if語句<br>實現一切無所畏懼<br></p><p>這裡寫死那裡寫死<br>複用全是直接複製<br>惜墨如金不寫註釋<br>看不懂是別人的事<br></p><p><br></p><div class=pgc-img><img alt="從3 個方面增加代碼可讀性和可維護性" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/55f537f25ed145dfad88eaf11ffa4fe1><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt="從3 個方面增加代碼可讀性和可維護性" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3d50519b5d5a4110821e2f6b132d5aa3><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt="從3 個方面增加代碼可讀性和可維護性" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2d1b5badbcf847aa82a488cc8e78a4d7><p class=pgc-img-caption></p></div><p><br></p><p>面對著這些雜亂無章隨心所欲的代碼，二盛哇的一聲哭了出來。</p><p>成年人的世界沒有容易二字，二盛擦乾淚，開始小心翼翼地改代碼。</p><p>最後90%的時間花在了閱讀代碼，10%的時間花在修改上，如同完成一個多米諾骨牌的項目，成就感油然而生。</p><p>於是二盛在工作彙報中自豪地寫下：今天改一個XXX(小功能)，備註：原來的代碼不好讀懂。</p><p>當領導看到工作報告時的內心活動：“一個小小的功能，改了那麼久？原來的代碼是一個<strong>新手</strong>寫的，居然還說不好讀懂，看來這個員工能力不行啊。”</p><p>前言</p><ul><li>文章目的：幫助大家寫出可讀性和可維護性高的代碼</li><li>適合人員：初級人員，以及想讓隊友好好寫代碼的朋友們</li><li>閱讀時長：因人而異，總共4000+字，看不完點個收藏⭐</li></ul><h2 class=article-title>3 個方面</h2><h3 class=article-title>準備數據</h3><pre><code>// 鼠籠const mouseList = [    { id: 'm01', name: '小白鼠', type: '0' },    { id: 'm02', name: '小黑鼠', type: '4' },    { id: 'm03', name: '小紅鼠', type: '5' },    { id: 'm04', name: '小橙鼠', type: '3' },    { id: 'm05', name: '小黃鼠', type: '1' },    { id: 'm06', name: '小青鼠', type: '1' },    { id: 'm07', name: '小藍鼠', type: '2' },    { id: 'm08', name: '小綠鼠', type: '2', cap:{} },    { id: 'm09', name: '小紫鼠', type: '5' },]// 類型對照表const typeMap = {    '0': '家鼠',    '1': '田鼠',    '2': '竹鼠',    '3': '松鼠',    '4': '米老鼠',    '5': '快樂番薯'}複製代碼</code></pre><h2 class=article-title>第1方面：表明意圖</h2><p>明確告訴讀代碼的人你在幹什麼</p><p>下面是例子</p><h4 class=article-title>需求</h4><p>你去委婉的告訴小綠鼠，他老婆出軌了。</p><h4 class=article-title>✍實現</h4><pre><code>var flag = falsefor (var i = 0; i &lt; mouseList.length; i++) {    if (mouseList[i].name == '小綠鼠') {        mouseList[i].cap.color = 'green'        flag = true        break    }}if (flag) {    console.log('我已經告訴他了')} else {    console.warn('沒有找到小綠鼠')}複製代碼</code></pre><h4 class=article-title>分析</h4><p>現在我們來分析以上代碼做的事情：</p><ol start=1><li>定義一個變量flag, 默認值為false</li><li>對mouseList進行遍歷</li><li>如果數組元素的name是小綠鼠</li><li>給該數組元素的cap屬性的color屬性賦值</li><li>把變量flag重新賦值true</li><li>終止循環</li><li>通過flag判斷是否找到，給出提示</li></ol><p>可以看到，我們需要看完一整段代碼之後，才能知道代碼是在做什麼，因為第一眼看到的是for+if，我們只能由此得知要進行遍歷+判斷，而無法得知更明確的意圖。</p><h4 class=article-title>優化</h4><p>下面這3種方法可以讓代碼的意圖更加明確：</p><ol start=1><li>直接寫註釋</li></ol><p>在兩小段代碼開通分別添加註釋：</p><ul><li>在所有老鼠中找到一隻名字叫小綠鼠的老鼠，幫他把帽子染成綠色</li><li>事情做完了給出提示</li></ul><p>寫註釋簡單粗暴，可是十分有效。然而無論是作者寫註釋，還是讀者讀註釋，都需要耗費時間，因此如果是簡單的功能，那麼註釋是沒有必要的，好鋼用在刀刃上，註釋也應該寫在關鍵之處。</p><ol start=2><li>命名裡面給訊息</li></ol><p>註釋可以省略不寫，但是命名一般跑不掉，正所謂命名不規範，隊友兩行淚，瞎起名傷害的不僅僅是隊友，還有將來看代碼的自己。</p><p>原代碼的寫法是立一個flag</p><pre><code>var flag = false複製代碼</code></pre><p>現在我們把它改成這樣</p><pre><code>let isFound = false複製代碼</code></pre><p>這樣寫有3個好處：</p><ol start=1><li>用ES6的let而非const，說明我將來要對這個變量<strong>重新賦值</strong>，而var只是單純聲明</li><li>is開頭說明變量是Boolean類型，如果在下文中更一群雜七雜八的變量混在一起，也能一眼認出個大概</li><li>isFound的意思是是否找到，這個found一出來，讀者馬上就知道作者<strong>找東西的意圖</strong></li></ol><blockquote><p>found 是 find 的過去分詞</p></blockquote><p>所以，單看let isFound = false，不看下面的代碼，我們就可以推測出作者是在尋找目標，isFound是作為是否找到目標的標識，如果找到目標以後，一定會有isFound = true的代碼出現</p><ol start=3><li>使用函數</li></ol><p>這裡使用函數的意思是，把非必要內容封裝進函數中，只留下主要信息，通過主要信息來凸顯意圖。</p><p>封裝之前我們先把代碼邏輯再拆分細一些， 把<strong>尋找目標</strong>和<strong>對目標進行操作</strong>分成兩步，下面把<strong>尋找目標</strong>封裝成函數，首先提取要素：</p><ul><li>範圍 (在哪裡找)</li><li>目標描述 (找啥樣的)</li><li>數量 (找幾個)</li><li>結果 (找到沒)</li></ul><p>以此為來封裝函數</p><pre><code>/** * 數組裡面找元素 * @param {array} array 範圍 * @param {function} callback 目標描述 * @param {number} count 數量 * @return {array} 結果 */function arrayFindItem(array, callback, count) {    const result = []    let _count = 0    for (let i = 0; i &lt; array.length; i++) {        if (callback(array[i])) {            _count++            result.push(array[i])            if (_count === count) {                return result            }        }    }    return result}複製代碼</code></pre><p>接著使用它</p><pre><code>const result = arrayFindItem(mouseList, function(mouse) {    return mouse.name === '小綠鼠'}, 1)複製代碼</code></pre><p>這樣一來，代碼裡面剩下部分的信息就很明確了：</p><ul><li>行為： arrayFindItem 在數組中找元素</li><li>在哪裡找：mouseList</li><li>找啥樣的：function(mouse) { return mouse.name === '小綠鼠' }</li><li>找幾個： 1</li><li>找到沒： result</li></ul><p>雖然清晰了不少，但前提是需要把arrayFindItem的參數和返回值瞭解清楚，而就本例而言，有更好的解決方法： Array.prototype.find</p><pre><code>const result = mouseList.find(function(mouse) {    return mouse.name === '小綠鼠'})複製代碼</code></pre><p>由於是es6規範裡的數組方法，所以大家對它的行為已經非常瞭解，不需要額外的閱讀成本。</p><hr><h3 class=article-title>第2方面：代碼拆分</h3><p>事情要一件一件地做，代碼要一塊一塊地寫。</p><h4 class=article-title>需求</h4><ol start=1><li>把籠子裡面生的鼠，並按照下面的做法烹飪一下：竹鼠 -> 油炸家鼠和田鼠 -> 水煮番薯 -> 碳烤</li><li>做成晚餐，我晚上要吃</li></ol><h4 class=article-title>✍實現</h4><p>新手可能寫出來的代碼</p><pre><code>var dinnerList = []for (var i = 0; i &lt; mouseList.length; i++) {    if (mouseList[i].isRaw != true) {        if (mouseList[i].type === '2') {            // 寬油竹鼠            mouseList[i].recipe = '油炸配方'            mouseList[i].newName = '油炸' + mouseList[i].name            // ...被省略的油炸的其他操作            mouseList[i].isRaw = true            dinnerList.push(mouseList[i])        } else if (mouseList[i].type === '0' || mouseList[i].type === '1') {            // 水煮家鼠 + 田鼠            mouseList[i].recipe = '水煮配方'            mouseList[i].newName = '水煮' + mouseList[i].name            // ...被省略的水煮的其他操作            mouseList[i].isRaw = true            dinnerList.push(mouseList[i])        } else if (mouseList[i].type === '5') {            // 烤番薯            mouseList[i].recipe = '碳烤配方'            mouseList[i].newName = '碳烤' + mouseList[i].name            // ...被省略的碳烤的其他操作            mouseList[i].isRaw = true            dinnerList.push(mouseList[i])        }    }}console.log(dinnerList)複製代碼</code></pre><h4 class=article-title>分析</h4><ol start=1><li>定義數組dinnerList</li><li>遍歷mouseList</li><li>找出所有屬性isRaw是true的數組元素</li><li>在3的基礎上，根據屬性 type的不同，進行不同的操作type 是 2 ==> 油炸操作type 是 0或1 ==> 水煮操作type 是 5 ==> 碳烤操作</li></ol><p>很明顯，把烹飪過程直接寫在for循環裡面會造成循環過長，不利於閱讀，所以應該將其拆分出來。</p><h4 class=article-title>優化</h4><p>那麼我們先進行第一步，將烹飪方法拆分出來</p><pre><code>/* ****** 這裡是烹飪的方法們 ****** */function fry(mouse) {    mouse.recipe = '油炸配方'    mouse.newName = '油炸' + mouse.name    // ...被省略的油炸的其他操作    mouse.isRaw = true}function boil(mouse) {    mouse.recipe = '水煮配方'    mouse.newName = '水煮' + mouse.name    // ...被省略的水煮的其他操作    mouse.isRaw = true}function roast(mouse) {    mouse.recipe = '碳烤配方'    mouse.newName = '碳烤' + mouse.name    // ...被省略的碳烤的其他操作    mouse.isRaw = true}複製代碼</code></pre><p>這樣我們就有3個烹飪方法了，把它們放一起給上註釋，既清晰又方便維護。</p><p>假設現在的需求是修改某一種烹飪方法，我們只需要找到方法，並修改方法內部的實現就搞定了，甚至不用去管該方法在哪裡被調用。</p><p>還沒完，接著把代碼補充完整</p><pre><code>var dinnerList = []for (var i = 0; i &lt; mouseList.length; i++) {    if (mouseList[i].isRaw != true) {        if (mouseList[i].type === '2') {            fry(mouseList[i]) // 寬油竹鼠            dinnerList.push(mouseList[i])        } else if (mouseList[i].type === '0' || mouseList[i].type === '1') {            boil(mouseList[i]) // 水煮家鼠 + 田鼠            dinnerList.push(mouseList[i])        } else if (mouseList[i].type === '5') {            roast(mouseList[i]) // 烤番薯            dinnerList.push(mouseList[i])        }    }}console.log(dinnerList)複製代碼</code></pre><p>這段循環中出現了if... else if... else if...，並且判斷的對象都是type，這就證明了裡面有可以拆分出來的邏輯。</p><p>回顧一下我們最開始的需求</p><ul><li>竹鼠 -> 寬油竹鼠</li><li>家鼠和田鼠 -> 水煮</li><li>番薯 -> 碳烤</li></ul><p>讓一段代碼的邏輯貼近需求，那麼無論是<strong>代碼可讀性</strong>還是<strong>應對需求變更</strong>的能力，都會上升一個層次。</p><p>接下來就是把需求轉換成代碼： 左邊用類型代替，右邊用函數代替，初步版：</p><p>條件操作type 是 2油炸操作type 是 0或1水煮操作type 是 5碳烤操作</p><p>接著用代碼符號代替：</p><p>typecookFn2fry()0 || 1boil()5roast()</p><p>到這一步會發現這種對映關係就是key => value，key是老鼠的type, value是烹飪的方法cookFn, 所以我們理所應當用對象來存儲對應關係</p><pre><code>// 老鼠烹飪方法映射表const mouseCookFnMap = {    // type: cookFn     '0': boil,    '1': boil,    '2': fry,    '5': roast}複製代碼</code></pre><p>完美！你如果有強迫症的話，也可以把所有的類型都補充完整，像這樣</p><pre><code>// 老鼠烹飪方法映射表(強迫症版)const mouseCookFnMapIllVer = {    // type: cookFn     '0': boil,    '1': boil,    '2': fry,    '3': undefined, // 未指定烹飪方法    '4': undefined,    '5': roast}複製代碼</code></pre><p>寫好了就馬上用一下</p><pre><code>var dinnerList = []for (var i = 0; i &lt; mouseList.length; i++) {    if (mouseList[i].isRaw != true) {        var cookFn = mouseCookFnMap[mouseList[i].type]        if (cookFn) { // cookFn !== undefined            cookFn(mouseList[i])            dinnerList.push(mouseList[i])        }    }}console.log(dinnerList)複製代碼</code></pre><p>這時候，你收到一個需求變動：“寬油竹鼠太費油了，給我改成碳烤。”</p><p>只需要把'2': fry,改成'2': roast,就了。</p><p>並且，使用<strong>映射關係表</strong>可以輕鬆應對某些需求更為複雜的場景。</p><p>比如說寬油竹鼠，實際上並非油炸就能完成的，竹鼠的皮肉比較厚實，還需要長時間的燜煮，所以對於竹鼠，需要先油炸再燜煮。</p><p>此時，映射表的value就不單單是一個方法了，應該是多個方法並且是有序的，顯然可以用數組來存儲：</p><pre><code>// 加一個`燜煮方法`function braise(mouse) {     // ... 省略的燜煮方法具體實現 }// 老鼠烹飪方法映射表加強版const mouseCookFnMapPlus = {    // type: cookFnArray    '0': [boil],    '1': [boil],    '2': [fry, braise],    '5': [roast]}複製代碼</code></pre><p>使用的時候將直接調用方法</p><pre><code>cookFn(mouseList[i])複製代碼</code></pre><p>改成遍歷數組依次調用</p><pre><code>cookFnArray.forEach(cookFn =&gt; cookFn(mouseList(i)))複製代碼</code></pre><p>這裡實在不想寫for循環了，用了forEach，下文會勸你們不要儘量寫for循環</p><hr><h3 class=article-title>第3方面：去除冗餘</h3><p>這一方面主要是從語法層面上，來探討如何去掉代碼中的冗餘，具體做法是找到代碼中與主題無關或重複的部分(主要是變量)，嘗試去除它們。</p><p>這裡就不加新的需求了，直接把上面的例子拿過來用</p><h4 class=article-title>箭頭函數➡</h4><p>ES6箭頭函數的優點有兩個：</p><ol start=1><li><strong>改變函數內this指向</strong></li></ol><p>過去為了將函數內部的this指向到外層作用域，主要方法是</p><pre><code>var that = this// orvar self = this複製代碼</code></pre><p>講真的，看到that我頭都大了，每個函數開始前都定義一個that不累嗎？</p><p>而箭頭函數中的this就是指向到外層的，徹底去除了上面這種冗餘的代碼！</p><p>能寫=>的時候，就不要寫function。與其說用箭頭函數是為了將this指向到外層，不如說function關鍵字是為了將this指向到本層才會去用。</p><ol start=2><li><strong>簡化寫法</strong></li></ol><p>先感受一下</p><pre><code>mouseList.find(function(mouse) {    return mouse.name === '小綠鼠'})// 箭頭函數寫法mouseList.find(mouse =&gt; mouse.name === '小綠鼠')複製代碼</code></pre><p>少寫很多字有沒有，附上寫法對比</p><p>寫法function(參數)=>{自動return函數體}原寫法function(參數){函數體}箭頭1(參數)=>{函數體}箭頭2(參數)=>// 有單行代碼</p><p>箭頭函數太棒了！寫者能少寫，看者能少看。具體使用看文檔，我們接著往下看</p><h4 class=article-title>循環</h4><p>首先看這個for循環，它又長又寬</p><pre><code>for (var i = 0; i &lt; mouseList.length; i++) {    if (mouseList[i].name == '小綠鼠') {        mouseList[i].cap.color = 'green'    }}複製代碼</code></pre><p>很明顯此處的變量i毫無意義，那麼如何去除i呢？</p><p>第一種是使用ES6的 for..of</p><pre><code>for (const mouse of mouseList) {    if (mouse.name == '小綠鼠') {        mouse.cap.color = 'green'    }}複製代碼</code></pre><p>不過使用for...of，即使想要下標 i 它也給不了，推薦一般情況下，能用 forEach 的時候都用Array.prototype.forEach()</p><pre><code>mouseList.forEach((mouse) =&gt; {    if (mouse.name == '小綠鼠') {        mouse.cap.color = 'green'    }})複製代碼</code></pre><p>說明：for...of可以遍歷所有部署了iterator(迭代器)的數據，而forEach僅僅是數組原型上的方法。但是你如果鐵了心要用forEach，可以利用<strong>展開運算符</strong>(...)來把可迭代對象轉換成數組：[...iterableValue].forEach()</p><p>forEach雖然好用，但是千萬別隻用forEach用到死，數組還有那麼多好用的方法，它們封裝得更完整也更具<strong>語義化</strong>，對數組方法不熟悉的話可以多看幾遍文檔</p><p>知道有寫著方法，一直想不起來去用怎麼辦？</p><p>在寫循環之前，先想想自己最後想要什麼，有了明確的目標之後再下手</p><p>目標手段返回值找一項find數組元素 (沒找到是undefined)找一項的下標findIndexnumber(沒找到是-1)找多個(過濾)filterarray複製全部並改造maparray有部分是？someboolean全都是？everyboolean.........</p><h4 class=article-title>解構(析構)</h4><p>變量的解構賦值(destructuring)</p><p>變量的解構有很多種，都差不多，這裡只介紹最常用的一種，<strong>對象解構</strong></p><p><strong>例子</strong></p><p>假設我們要取出小白鼠的幾個屬性，不用解構賦值是這樣的</p><pre><code>const whiteMouse = { id: 'm01', name: '小白鼠', type: '0' }const id = whiteMouse.idconst name = whiteMouse.nameconst type = whiteMouse.type複製代碼</code></pre><p>用瞭解構賦值是這樣的</p><pre><code>const whiteMouse = { id: 'm01', name: '小白鼠', type: '0' }const { id, name, type } = whiteMouse複製代碼</code></pre><p>優勢很明顯了，去掉了很多冗餘的代碼。</p><p>解構可以用在很多地方，只要是取對象的某個屬性賦值給一個變量，就可以用解構，下面是小綠鼠的例子的加強版</p><pre><code>const greenMouse = mouseList.find(mouse =&gt; mouse.name === '小綠鼠')if (greenMouse) {    greenMouse.cap.color = 'green'    greenMouse.cap.size = 'big'    greenMouse.cap.brightness = 'high'}複製代碼</code></pre><p>由於擔心太過委婉以致於小綠鼠沒有發覺，我們增大了帽子尺寸並且讓帽子變得更加耀眼。</p><p>在遇到這種一個對象屬性在後文中被<strong>多次使用</strong>的情況，最好用一個變量來存一下，避免多個 對象.屬性.屬性... 的寫法讓代碼臃腫不堪，影響閱讀。</p><pre><code>const greenMouse = mouseList.find(({ name }) =&gt; name === '小綠鼠')if (greenMouse) {    const { cap } = greenMouse    cap.color = 'green'    cap.size = 'big'    cap.brightness = 'high'}複製代碼</code></pre><p>好理解也好用，不過細心的話會發現這裡還有另一個地方也用瞭解構，就是.find()的回調函數的參數部分。</p><p>這樣寫可以減少一個自定義的變量mouse，它也是與主題無關的，而且定義出來只用一次，也算一種冗餘。</p><p><strong>解釋一下這個解構</strong></p><pre><code>(mouse) =&gt; mouse.name === '小綠鼠'複製代碼</code></pre><p>.find()傳入的回調函數(mouse) => mouse.name === '小綠鼠'， 它的第一個參數mouse，是mouseList中的元素，也就是</p><pre><code>   { id: 'm01', name: '小白鼠', type: '0' } // 第一次回調運行時`mouse`的值   { id: 'm02', name: '小黑鼠', type: '4' } // 第二次回調運行時`mouse`的值   // ...複製代碼</code></pre><p>既然mouse是一個對象，我們只需要它的name屬性，那就({ name })只不過是把</p><pre><code>const mouse = { id: 'm01', name: '小白鼠', type: '0' }複製代碼</code></pre><p>改成了</p><pre><code>const { name } = { id: 'm01', name: '小白鼠', type: '0' }複製代碼</code></pre><p>解構真的很常用，請求接口回來的時候，就經常會這麼寫</p><pre><code>async function getData() {    const { code, msg, data } = await requestFn()    // ...}複製代碼</code></pre><p>所以這裡說一句，請求接口後把回調函數和.then()收起來吧，你看這async + await，它不清晰嗎，可讀性不高嗎？</p><p><strong>碼農三哥，一名普通程序員，會點java軟件開發，對AI人工智能有點興趣，後續會每日分享些關於互聯網技術方面的文章，感興趣的朋友可以關注我，一起交流學習。</strong></p><p><strong>想轉型或剛步入程序員Java開發的朋友，有問題可以留言或私信我！</strong></p><p><br></p><div class=pgc-img><img alt="從3 個方面增加代碼可讀性和可維護性" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b98bec8e9ca04b26922cc216a6a766ad><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>代碼</a></li><li><a>讀性</a></li><li><a>可維護性</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8047790.html alt=如何提高代碼可讀性、可維護性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15347603698757dfd164fc5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8047790.html title=如何提高代碼可讀性、可維護性>如何提高代碼可讀性、可維護性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d905fea2.html alt=什麼是可維護性的代碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/873b731f575d49aeb6d782b780581e82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d905fea2.html title=什麼是可維護性的代碼>什麼是可維護性的代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9ad6a3e.html alt=（1-2我們的第一段PHP代碼）php基礎php學習基礎實例代碼操作教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b707f4e4acce41bda439262a966603f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9ad6a3e.html title=（1-2我們的第一段PHP代碼）php基礎php學習基礎實例代碼操作教程>（1-2我們的第一段PHP代碼）php基礎php學習基礎實例代碼操作教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html alt="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html title="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結">Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4e78a26.html alt=二叉樹的算法代碼，一篇文章全搞定！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4e78a26.html title=二叉樹的算法代碼，一篇文章全搞定！>二叉樹的算法代碼，一篇文章全搞定！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/873415c9.html alt=錯誤代碼大全2，時刻掌握計算機的故障原因！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/152937668211718b8850640 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/873415c9.html title=錯誤代碼大全2，時刻掌握計算機的故障原因！>錯誤代碼大全2，時刻掌握計算機的故障原因！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45c8b4b0.html alt=關於“神祕代碼”的含義 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c040bb33daee4d30bc48cb70d5bf8ee1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45c8b4b0.html title=關於“神祕代碼”的含義>關於“神祕代碼”的含義</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d4cfc67.html alt=VBA代碼自動讓一個空閒工作薄關閉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49f19f02a01b4aa28fab830611f1ae2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d4cfc67.html title=VBA代碼自動讓一個空閒工作薄關閉>VBA代碼自動讓一個空閒工作薄關閉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55fe58a0.html alt=對不起，我的VBA代碼將暫停運行，並於10秒後自動關閉主程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84e4fd546fe349bebfed630910a1b643 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55fe58a0.html title=對不起，我的VBA代碼將暫停運行，並於10秒後自動關閉主程序>對不起，我的VBA代碼將暫停運行，並於10秒後自動關閉主程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c733e892.html alt=「軟件工程」代碼質量綜合指南：最佳實踐和工具 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/236ba3959c874246b78fcd77527eeceb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c733e892.html title=「軟件工程」代碼質量綜合指南：最佳實踐和工具>「軟件工程」代碼質量綜合指南：最佳實踐和工具</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4f100a9.html alt=做好安全防範系統可維護性設計，安防運維省時省力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d9f86c94ec774732bcab4eaf2d430bd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4f100a9.html title=做好安全防範系統可維護性設計，安防運維省時省力>做好安全防範系統可維護性設計，安防運維省時省力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/535dc896.html alt=米帝武器的可維護性怎麼樣？航母上就能更換飛機發動機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50a90002fd76f70ec2aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/535dc896.html title=米帝武器的可維護性怎麼樣？航母上就能更換飛機發動機>米帝武器的可維護性怎麼樣？航母上就能更換飛機發動機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a63befb.html alt=志高空調故障代碼—室內機與主機通訊故障 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2458a1e3f357436b89196b74341218e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a63befb.html title=志高空調故障代碼—室內機與主機通訊故障>志高空調故障代碼—室內機與主機通訊故障</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83b0c7a4.html alt=VBA代碼利用Listview控件來顯示你的工作表任務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7127f7ca7e064dd8b8a4283b5246d4d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83b0c7a4.html title=VBA代碼利用Listview控件來顯示你的工作表任務>VBA代碼利用Listview控件來顯示你的工作表任務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1085ff4a.html alt=利用VBA代碼自定義設置我的菜單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/04d2083257c844a8a10542a635548b26 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1085ff4a.html title=利用VBA代碼自定義設置我的菜單>利用VBA代碼自定義設置我的菜單</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>