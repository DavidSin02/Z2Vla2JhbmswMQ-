<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>ReentrantLock 可重入鎖這樣學，面試沒煩惱 | 极客快訊</title><meta property="og:title" content="ReentrantLock 可重入鎖這樣學，面試沒煩惱 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/171a3f887b56417fbb19b5fc26084bc9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71738cfb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71738cfb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/71738cfb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71738cfb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71738cfb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/71738cfb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/71738cfb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71738cfb.html><meta property="article:published_time" content="2020-11-14T20:55:07+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:07+08:00"><meta name=Keywords content><meta name=description content="ReentrantLock 可重入鎖這樣學，面試沒煩惱"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/71738cfb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>ReentrantLock 可重入鎖這樣學，面試沒煩惱</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="ReentrantLock 可重入鎖這樣學，面試沒煩惱" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/171a3f887b56417fbb19b5fc26084bc9><p class=pgc-img-caption>ReentrantLock+可重入鎖</p></div><p><br></p><h1 class=pgc-h-arrow-right>為什麼需要 ReentrantLock ？</h1><p>既生 synchronized，何生 ReentrantLock？</p><p>每一個接觸過多線程的 java coder 肯定都知道 synchronized 關鍵字，那為什麼還需要 ReentrantLock 呢？</p><p>其實這就是 ReentrantLock 與 synchronized 對比的優勢問題：</p><p>（1）ReentrantLock 使用起來更來更加靈活。我們在需要控制的地方，可以靈活指定加鎖或者解鎖。</p><p>這可以讓加鎖的範圍更小，記住老馬的一句話，<strong>更小往往意味著更快</strong>。</p><p>（2）ReentrantLock 提供了公平鎖、非公平鎖等多種方法特性，這些都是 synchronized 關鍵字無法提供的。</p><p>接下來，就讓我們一起來學習一下 ReentrantLock 可重入鎖吧。</p><div class=pgc-img><img alt="ReentrantLock 可重入鎖這樣學，面試沒煩惱" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4d5833b6cdab4007ae32e851ad376f7a><p class=pgc-img-caption>可重入鎖</p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>ReentrantLock 使用</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">線程定義</span></span></strong></h1><p>創建一個可重入鎖線程。</p><pre><code>/** * @author 老馬嘯西風 */public class ReconnectThread extends Thread {    /**     * 聲明可重入鎖     */    private static final ReentrantLock reentrantLock = new ReentrantLock();    /**     * 用於標識當前線程     */    private String name;    public ReconnectThread(String name) {        this.name = name;    }    @Override    public void run() {        reentrantLock.lock();        try {            for (int i = 0; i &lt; 5; i++) {                System.out.println(name+" "+i+" times");                Thread.sleep(1000);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            reentrantLock.unlock();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">測試</span></span></strong></h1><ul><li>Test</li></ul><pre><code>/** * @author 老馬嘯西風 */public static void main(String[] args) {    Thread one = new ReconnectThread("one");    Thread two = new ReconnectThread("two");    one.start();    two.start();}</code></pre><ul><li>result</li></ul><p>根據結果可知。兩個必須要等待另外一個執行完成才能運行。</p><pre><code>two 0 timestwo 1 timestwo 2 timestwo 3 timestwo 4 timesone 0 timesone 1 timesone 2 timesone 3 timesone 4 times</code></pre><h1 class=pgc-h-arrow-right><strong>鎖的釋放和獲取</strong></h1><p>鎖是 java 併發編程中最重要的同步機制。</p><p>鎖除了讓<strong>臨界區互斥執行</strong>外，還可以讓釋放鎖的線程向獲取同一個鎖的線程發送消息。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">實例</span></span></strong></h1><ul><li>MonitorExample.java</li></ul><pre><code>/** * @author 老馬嘯西風 */class MonitorExample {    int a = 0;    public synchronized void writer() {  //1        a++;                             //2    }                                    //3    public synchronized void reader() {  //4        int i = a;                       //5        //……    }                                    //6}</code></pre><p>假設線程 A 執行 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">writer()</span> 方法，隨後線程 B 執行 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">reader()</span> 方法。</p><p>根據 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">happens-before</span> 規則，這個過程包含的 happens-before 關係可以分為兩類：</p><ul><li>根據程序次序規則，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。</li><li>根據監視器鎖規則，3 happens before 4。</li><li>根據 happens before 的傳遞性，2 happens before 5。</li></ul><p>因此，線程 A 在釋放鎖之前所有可見的共享變量，在線程 B 獲取同一個鎖之後，將立刻變得對 B 線程可見。</p><h1 class=pgc-h-arrow-right><strong>鎖釋放和獲取的內存語義</strong></h1><p>當線程釋放鎖時，JMM 會把該線程對應的本地內存中的共享變量刷新到主內存中。</p><p>以上面的 MonitorExample 程序為例，A 線程釋放鎖後，共享數據的狀態示意圖如下：</p><ul><li>線程 A</li></ul><pre><code>本地內存 A: a = 1;(寫入到主內存)主內存：a = 1;</code></pre><p>當線程獲取鎖時，JMM 會把該線程對應的本地內存置為無效。</p><p>從而使得被監視器保護的臨界區代碼必須要從主內存中去讀取共享變量。</p><p>下面是鎖獲取的狀態過程：</p><p>在線程 A 寫入主內存之後。</p><p>線程之間通信：線程 A 向 B 發送消息</p><ul><li>線程 B</li></ul><pre><code>主內存：a = 1;(從主內存中讀取)本地內存 B: a = 1;</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">和 volatile 內存語義對比</span></span></strong></h1><p>對比鎖釋放-獲取的內存語義與 volatile 寫-讀的內存語義，</p><p>可以看出：<strong>鎖釋放與 volatile 寫有相同的內存語義；</strong><strong>鎖</strong><strong>獲取與 volatile </strong><strong>讀</strong><strong>有相同的內存語義</strong>。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">內存語義小結</span></span></strong></h1><p>下面對鎖釋放和鎖獲取的內存語義做個總結：</p><ul><li>線程 A 釋放一個鎖，實質上是線程A向接下來將要獲取這個鎖的某個線程發出了（線程A對共享變量所做修改的）消息。</li><li>線程 B 獲取一個鎖，實質上是線程 B 接收了之前某個線程發出的（在釋放這個鎖之前對共享變量所做修改的）消息。</li><li>線程 A 釋放鎖，隨後線程 B 獲取這個鎖，這個過程實質上是線程 A 通過主內存向線程 B 發送消息。</li></ul><h1 class=pgc-h-arrow-right><strong>鎖內存語義的實現</strong></h1><p>本文將藉助 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">ReentrantLock</span> 的源代碼，來分析鎖內存語義的具體實現機制。</p><ul><li>ReentrantLockExample.java</li></ul><pre><code>/** * @author 老馬嘯西風 */class ReentrantLockExample {    int a = 0;    ReentrantLock lock = new ReentrantLock();    public void writer() {        lock.lock();         //獲取鎖        try {            a++;        } finally {            lock.unlock();  //釋放鎖        }    }    public void reader () {        lock.lock();        //獲取鎖        try {            int i = a;            //……        } finally {            lock.unlock();  //釋放鎖        }    }}</code></pre><p>在 ReentrantLock 中，調用 lock() 方法獲取鎖；調用 unlock() 方法釋放鎖。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">源碼實現</span></span></strong></h1><p>ReentrantLock 的實現依賴於 java 同步器框架 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">AbstractQueuedSynchronizer</span>（本文簡稱之為AQS）。</p><p>AQS 使用一個整型的 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">volatile</span> 變量（命名為state）來維護同步狀態，馬上我們會看到，這個 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">volatile</span> 變量是 ReentrantLock 內存語義實現的關鍵。</p><pre><code>/** * @author 老馬嘯西風 */public class ReentrantLock implements Lock, java.io.Serializable {    /**     * Base of synchronization control for this lock. Subclassed     * into fair and nonfair versions below. Uses AQS state to     * represent the number of holds on the lock.     */    abstract static class Sync extends AbstractQueuedSynchronizer {        //...    }    /**     * Sync object for non-fair locks     */    static final class NonfairSync extends Sync {        //...    }    /**     * Sync object for fair locks     */    static final class FairSync extends Sync {        //...            }}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">公平鎖</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>lock()</strong></h1><p>使用公平鎖時，加鎖方法lock()的方法調用軌跡如下：</p><ol start=1><li>ReentrantLock : lock()</li><li>FairSync : lock()</li><li>AbstractQueuedSynchronizer : acquire(int arg)</li><li>ReentrantLock : tryAcquire(int acquires)</li></ol><p>在第 4 步真正開始加鎖，下面是該方法的源代碼(JDK 1.8)：</p><pre><code>/** * Fair version of tryAcquire.  Don't grant access unless * recursive call or no waiters or is first. * @author 老馬嘯西風 */protected final boolean tryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {        if (!hasQueuedPredecessors() &amp;&amp;            compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0)            throw new Error("Maximum lock count exceeded");        setState(nextc);        return true;    }    return false;}</code></pre><p>加鎖方法首先讀 volatile 變量 state。</p><h1 class=pgc-h-arrow-right><strong>unlock()</strong></h1><p>在使用公平鎖時，解鎖方法unlock()的方法調用軌跡如下：</p><ol start=1><li>ReentrantLock : unlock()</li><li>AbstractQueuedSynchronizer : release(int arg)</li><li>Sync : tryRelease(int releases)</li></ol><p>在第 3 步真正開始釋放鎖，下面是該方法的源代碼：</p><pre><code>/** * @author 老馬嘯西風 */protected final boolean tryRelease(int releases) {    int c = getState() - releases;    if (Thread.currentThread() != getExclusiveOwnerThread())        throw new IllegalMonitorStateException();    boolean free = false;    if (c == 0) {        free = true;        setExclusiveOwnerThread(null);    }    setState(c);    return free;}</code></pre><p>在釋放鎖的最後寫 volatile 變量 state。</p><p>公平鎖在釋放鎖的最後寫 volatile 變量 state；在獲取鎖時首先讀這個 volatile 變量。</p><p>根據 volatile 的 happens-before 規則，釋放鎖的線程在寫 volatile 變量之前可見的共享變量，在獲取鎖的線程讀取同一個 volatile 變量後將立即變的對獲取鎖的線程可見。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">非公平鎖</span></span></strong></h1><p>非公平鎖的釋放和公平鎖完全一樣，所以這裡僅僅分析非公平鎖的獲取。</p><h1 class=pgc-h-arrow-right><strong>lock()</strong></h1><p>使用非公平鎖時，加鎖方法lock()的方法調用軌跡如下：</p><ol start=1><li>ReentrantLock : lock()</li><li>NonfairSync : lock()</li><li>AbstractQueuedSynchronizer : compareAndSetState(int expect, int update)</li></ol><p>在第 3 步真正開始加鎖，下面是該方法的源代碼：</p><pre><code>/** * Atomically sets synchronization state to the given updated * value if the current state value equals the expected value. * This operation has memory semantics of a {@code volatile} read * and write. * * @param expect the expected value * @param update the new value * @return {@code true} if successful. False return indicates that the actual *         value was not equal to the expected value. * @author 老馬嘯西風 */protected final boolean compareAndSetState(int expect, int update) {    // See below for intrinsics setup to support this    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);}</code></pre><p>該方法以原子操作的方式更新 state 變量，本文把 java 的 compareAndSet() 方法調用簡稱為CAS。</p><p>JDK文檔對該方法的說明如下：<strong>如果當前狀態值等於預期值，則以原子方式將同步狀態設置為給定的更新值。此操作具有 volatile 讀和寫的內存語義</strong>。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">內存語義總結</span></span></strong></h1><p>現在對公平鎖和非公平鎖的內存語義做個總結：</p><ul><li>公平鎖和非公平鎖釋放時，最後都要寫一個 volatile 變量 state。</li><li>公平鎖獲取時，首先會去讀這個 volatile 變量。</li><li>非公平鎖獲取時，首先會用 CAS 更新這個 volatile 變量,這個操作同時具有 volatile 讀和 volatile 寫的內存語義。</li></ul><p>從本文對 ReentrantLock 的分析可以看出，鎖釋放-獲取的內存語義的實現至少有下面兩種方式：</p><ol start=1><li>利用 volatile 變量的寫-讀所具有的內存語義。</li><li>利用 CAS 所附帶的 volatile 讀和 volatile 寫的內存語義。</li></ol><h1 class=pgc-h-arrow-right><strong>小結</strong></h1><p>本文從介紹 ReentrantLock 使用案例開始，引出了鎖的獲取和釋放的內存語義。</p><p>為了讀者加深印象，對源碼進行了簡單的學習，下一節將對源碼進行深入講解。</p><p>秉著<strong>沒有對比，就沒有發現</strong>的原則，我們對比了 ReentrantLock 和 volatile 以及 synchronized 的差異性，便於讀者正確地根據自己的場景選擇合適的加鎖策略。</p><p>希望本文對你有幫助，如果有其他想法的話，也可以評論區和大家分享哦。</p><p>各位<strong>極客</strong>的點贊收藏轉發，是老馬寫作的最大動力！</p><p><br></p><div class=pgc-img><img alt="ReentrantLock 可重入鎖這樣學，面試沒煩惱" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ef9423a1b1f4641a5365eb5bb140041><p class=pgc-img-caption>深入學習</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>ReentrantLock</a></li><li><a>可重</a></li><li><a>入鎖</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7d3ffd2.html alt=「ReentrantLock」可重入鎖，使用場景 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3914d0316be14cb6bdc585ccb482b6a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7d3ffd2.html title=「ReentrantLock」可重入鎖，使用場景>「ReentrantLock」可重入鎖，使用場景</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/874a768a.html alt=可重入鎖ReentrantLock class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/af2d1fa083d64835aee2987581761467 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/874a768a.html title=可重入鎖ReentrantLock>可重入鎖ReentrantLock</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04ffa3c5.html alt=一文徹底理解ReentrantLock可重入鎖的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fac9edcff76544d79bff13c1d73e74a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04ffa3c5.html title=一文徹底理解ReentrantLock可重入鎖的使用>一文徹底理解ReentrantLock可重入鎖的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9bcded29.html alt=併發編程——可重入鎖，你真的理解？面試必備 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8206c837466344b683ffdc494114fbb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9bcded29.html title=併發編程——可重入鎖，你真的理解？面試必備>併發編程——可重入鎖，你真的理解？面試必備</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7159dfa5.html alt=ReenTrantLock可重入鎖（和synchronized的區別）總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/13afd974-ea64-4125-8991-d192b87b92be style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7159dfa5.html title=ReenTrantLock可重入鎖（和synchronized的區別）總結>ReenTrantLock可重入鎖（和synchronized的區別）總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/28802093.html alt=賓夕法尼亞大學楊澍團隊《AM》:光響應性金納米棒/液晶彈性體複合材料：可重複驅動、可重編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SEgOenaB4Iohpm style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/28802093.html title=賓夕法尼亞大學楊澍團隊《AM》:光響應性金納米棒/液晶彈性體複合材料：可重複驅動、可重編程>賓夕法尼亞大學楊澍團隊《AM》:光響應性金納米棒/液晶彈性體複合材料：可重複驅動、可重編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/581a04b6.html alt=(原創)Java的ReentrantLock(可重入鎖)下的Condition class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/dcc50577a6344f7c94cfba48ed89d04d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/581a04b6.html title=(原創)Java的ReentrantLock(可重入鎖)下的Condition>(原創)Java的ReentrantLock(可重入鎖)下的Condition</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24abe09b.html alt=(原創)Java的ReentrantLock(可重入鎖)詳解上篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f6ffe7fa302246e8842caeeaae9fca86 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24abe09b.html title=(原創)Java的ReentrantLock(可重入鎖)詳解上篇>(原創)Java的ReentrantLock(可重入鎖)詳解上篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4672a0fb.html alt=牛人講解Java可重入鎖原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535262549376823724db60 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4672a0fb.html title=牛人講解Java可重入鎖原理>牛人講解Java可重入鎖原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/47d6af05.html alt=500秒！星際榮耀可重複使用液氧甲烷火箭發動機試車成功 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RlerUhw10uTHzi style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/47d6af05.html title=500秒！星際榮耀可重複使用液氧甲烷火箭發動機試車成功>500秒！星際榮耀可重複使用液氧甲烷火箭發動機試車成功</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/596d4e2.html alt=可重編程的變形電磁軟機器人超材料 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/812e7a556fc847b0931893f01541aae9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/596d4e2.html title=可重編程的變形電磁軟機器人超材料>可重編程的變形電磁軟機器人超材料</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/8dc2fd9.html alt=心絞痛可輕可重！若符合這4個指徵，說明是嚴重的那類，及早就醫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/dfic-imagehandler/4fc031b8-d3a0-4895-b320-8439f3bb8d3c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/8dc2fd9.html title=心絞痛可輕可重！若符合這4個指徵，說明是嚴重的那類，及早就醫>心絞痛可輕可重！若符合這4個指徵，說明是嚴重的那類，及早就醫</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>