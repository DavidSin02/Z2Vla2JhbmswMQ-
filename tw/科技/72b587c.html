<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>各種配置文件總結 | 极客快訊</title><meta property="og:title" content="各種配置文件總結 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/1534392036166ddc12edbb5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72b587c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72b587c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72b587c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72b587c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72b587c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72b587c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72b587c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72b587c.html><meta property="article:published_time" content="2020-10-29T20:59:53+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:53+08:00"><meta name=Keywords content><meta name=description content="各種配置文件總結"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/72b587c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>各種配置文件總結</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>1. Spring Data JPA 配置:</strong></h1><p><strong>0.框架知識概述:</strong></p><p>Spring Data JPA 是一個持久層的框架,而一個持久層框架所做的事情不過兩件:</p><ol><li>連接數據庫(比如 JDBD連接數據庫) 2.操作數據庫(比如 sql 操作數據庫);</li><li><strong>連接數據庫:</strong></li><li><strong>配置參數抽取: config.properties 配置:</strong></li></ol><p># oracle jdbc properties</p><p>jdbc.url = jdbc:oracle:thin:@localhost:1521:XE</p><p>jdbc.driver= oracle.jdbc.driver.OracleDriver</p><p>jdbc.user = bos</p><p>jdbc.password = bos</p><ol><li><strong>applicationContext-dataSource.xml 配置:</strong></li><li><strong>數據庫連接池配置: config.properties</strong></li></ol><p>在主配置文件 applicationContext.xml 中通過配置加載屬性文件:</p><p>&lt;!-- 加載properties文件 --></p><p>&lt;context:property-placeholder location="classpath:config.properties" /></p><p>( ${jdbc.url} 這種類似EL表達式的是SpringEL 表達式 )</p><p>&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"></p><p>&lt;property name="driverClass" value="${jdbc.driver}" /></p><p>&lt;property name="jdbcUrl" value="${jdbc.url}" /></p><p>&lt;property name="user" value="${jdbc.user}" /></p><p>&lt;property name="password" value="${jdbc.password}" /></p><p>&lt;/bean></p><ol><li><strong>Spring整合JPA配置:</strong></li></ol><p>(在 entityManagerFactory中配置了連接池 和 domain中的bean ,這就相當於是用連接把實體類與數據庫表建立了聯繫, [這裡說明一點:實體和表之間的準確對應關係是依賴實體類中的註解來準確定位的] 這種聯繫是非常緊密的,實體對象屬性值的變化直接會反映到數據庫表中, 而JPA作為接口規範,這裡選擇 hibernate作為持久化提供者; 然後就是一些數據庫的基本配置了;)</p><p>&lt;!-- 整合JPA配置 --></p><p>&lt;bean id="entityManagerFactory"</p><p>class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"></p><p>&lt;property name="dataSource" ref="dataSource" /></p><p>&lt;property name="packagesToScan" value="cn.itcast.bos.domain" /></p><p>&lt;property name="persistenceProvider"></p><p>&lt;bean class="org.hibernate.jpa.HibernatePersistenceProvider" /></p><p>&lt;/property></p><p>&lt;property name="jpaVendorAdapter"></p><p>&lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"></p><p>&lt;property name="generateDdl" value="true" /></p><p>&lt;property name="database" value="ORACLE" /></p><p>&lt;property name="databasePlatform" value="org.hibernate.dialect.Oracle10gDialect" /></p><p>&lt;property name="showSql" value="true" /></p><p>&lt;/bean></p><p>&lt;/property></p><p>&lt;property name="jpaDialect"></p><p>&lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaDialect" /></p><p>&lt;/property></p><p>&lt;!-- &lt;property name="jpaPropertyMap"> --></p><p>&lt;!-- &lt;map> --></p><p>&lt;!-- &lt;entry key="hibernate.query.substitutions" value="true 1, false 0" /> --></p><p>&lt;!-- &lt;entry key="hibernate.default_batch_fetch_size" value="16" /> --></p><p>&lt;!-- &lt;entry key="hibernate.max_fetch_depth" value="2" /> --></p><p>&lt;!-- &lt;entry key="hibernate.generate_statistics" value="true" /> --></p><p>&lt;!-- &lt;entry key="hibernate.bytecode.use_reflection_optimizer" --></p><p>&lt;!-- value="true" /> --></p><p>&lt;!-- &lt;entry key="hibernate.cache.use_second_level_cache" value="false" /> --></p><p>&lt;!-- &lt;entry key="hibernate.cache.use_query_cache" value="false" /> --></p><p>&lt;!-- &lt;/map> --></p><p>&lt;!-- &lt;/property> --></p><p>&lt;/bean></p><p><strong>2.操作數據庫:</strong></p><ol><li><strong>整合Spring Data JPA (相當於掃描了Dao, 這樣dao的操作才能被識別;)</strong></li></ol><p>這裡說明一點: dao的操作能被識別是CRUD的哪種操作, 至於操作哪個表, 是由在接口創建時傳入的泛型參數確定的, 傳入了一個泛型類,這個類代表著某張表; 簡而言之:dao描述了兩個問題: 1.我要執行什麼操作, 2.我要操作那張表;</p><p>&lt;!-- 整合spring data jpa --></p><p>&lt;jpa:repositories base-package="cn.itcast.bos.dao" /></p><p><strong>3.聲明式事務管理配置:</strong></p><p><strong>1. 配置事務管理器:</strong></p><p>(JDBC事務管理的本質,是對Session的管理, 那麼這裡配置了事務管理器, 就相當於指明瞭由誰來管理事務, 而同時屬性注入了 entityManagerFactory 實體管理者工廠,這就相當於將數據庫操作中的session交給了事務管理器,也就容易實現事務的管理了)</p><p>&lt;!-- JPA事務管理器 --></p><p>&lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager" ></p><p>&lt;property name="entityManagerFactory" ref="entityManagerFactory" /></p><p>&lt;/bean></p><ol><li><strong>配置”事務註解驅動”</strong></li></ol><p>(這樣就可以識別 Service 中的 @Transactional了)</p><p>&lt;!-- 註解管理事務 --></p><p>&lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/></p><p><strong>4.Spring Data JPA 配置小結:</strong></p><p>1. SpringDataJPA 的配置就是通過將基本數據庫連接參數:比如driven , url , username, password通過SPEL讀取到連接池DataSource, 這個時候連接池其實已經拿到了數據庫的連接connection, 理論上已經可以通過sql操作數據庫了,但是此時我們又將: dataSource, , domain , persistenceProvider 通過屬性注入到 entityManagerFactory ,其實這個時候 ”實體管理器工廠” 已經利用 DataSource中的 connection 將 domain 下的實體類 entity 與數據庫中的表 table 建立了緊密聯繫, 此時已經完成類與表的強相關; 至此,我們對數據庫的操作對象不再是真真正正的表了,而是與之強相關的類了,操作的實現不再是sql語句,而是使用java代碼來實現了; 至於哪個類對應哪個表,這就是 映射文件 hbm.xml 或者是類中的映射註解配置來細化了;</p><p>2. 在第1步獲得類與數據庫的連接以後,我們就要操作數據庫了,我們是通過:</p><p>&lt;jpa:repositories base-package="cn.itcast.bos.dao" /></p><p>這個相當於是掃描指定包下的 repository 接口, (當然這些repository 繼承了jpaRepository,或者JpaSpecificationExecutor接口), 這樣其實底層也是利用了AOP 當我們在Service中 @autowired 這些接口實現時, AOP 會給我們注入 SpringDataJPA 默認實現,這些實現了本身已經封裝了一些常見的CRUD操作,所以我們可以省去常見CRUD操作的sql的編寫,但是對於一些複雜的CRUD操作, SpringDataJPA 也給我們留了一個口子:</p><ol><li>比如一些標準的操作:</li><li>findById() , findByProvinceAndCityAndDistrict 等</li><li>更復雜的操作:</li></ol><p>@Query(value="update Courier set deltag='1' where id=?")</p><p>@Modifying</p><p>public void updateDeltag(int id);</p><p>或者是這個:</p><p>@Query(value="update Courier set deltag='' where id=?")</p><p>@Modifying</p><p>public void doRestore(int id);</p><p>3 . 至於事務管理: 原理是Spring 有IOC ,那麼類的創建,準確來說是Service類的創建,也是由Spring來創建, 根據Spring創建bean的生命週期方法的執行流程,我們知道,後處理bean中的方法執行時機是在我們獲得bean對象之前,那麼,後處理bean會利用AOP思想,在我們獲得的Service對象的方法執行開始都加上session的事務開啟,在方法執行末尾加上session的事務提交,和事務回滾,那麼在我們拿到IOC 容器給我們創建的bean時,這個bean就是在事務管理之中的bean了; 這就完成了事務管理;</p><p>===============以上SpringDataJPA == 以下 WebService====================</p><ol><li><strong>WebService的配置:</strong></li></ol><p><strong>0.框架知識概述:</strong></p><p>(WebService 按目前使用來看就是提供了跨服務器遠程數據獲取的一種方式, 那我們只會關心兩個問題: 1. 遠程服務的創建與發佈, 2,本地對遠程服務的訪問與數據接收; 其實遠程服務的創建,就是一個service接口 中方法訪問路徑,訪問方式,接收數據格式,返回數據格式的聲明, 至於服務的發佈其實是交給了配置文件; 至於本地客戶端可能只需要WebClient 加上一個正確格式的url就可以了)我們這裡說一下 JAX-RS 的配置:</p><p><strong>1.首先說一下服務端配置:</strong></p><ol><li>作為一個服務提供端,它需要識別到對 它的所有WebService請求, 那麼它就是通過在 web.xml中配置一個 CXFServlet 用來專門接收並處理WebService請求:</li></ol><p>比如下面配置會攔截所有端口號後以 /services 開頭的url請求:</p><p>&lt;servlet></p><p>&lt;servlet-name>CXFService&lt;/servlet-name></p><p>&lt;servlet-class>org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class></p><p>&lt;load-on-startup>1&lt;/load-on-startup></p><p>&lt;/servlet></p><p>&lt;servlet-mapping></p><p>&lt;servlet-name>CXFService&lt;/servlet-name></p><p>&lt;url-pattern>/services/*&lt;/url-pattern></p><p>&lt;/servlet-mapping></p><ol><li>在第1步攔截到所有WebService請求的基礎上,它會根據請求的url 去尋找對應的Service , 那麼到哪裡去尋找呢? 當然是到已經發布到服務器中的Service中去找, 那麼怎麼才算是發佈到服務器中了呢? 這裡我們是通過在 .xml配置文件來實現發佈的:</li></ol><p>比如下面配置 是將 PromotionServiceImpl 發佈到服務器中</p><p>&lt;jaxrs:server id="promotionService" address="/promotionService"></p><p>&lt;jaxrs:serviceBeans></p><p>&lt;bean class="cn.itcast.bos.service.take_delivery.impl.PromotionServiceImpl" /></p><p>&lt;/jaxrs:serviceBeans></p><p>&lt;jaxrs:inInterceptors></p><p>&lt;bean class="org.apache.cxf.interceptor.LoggingInInterceptor">&lt;/bean></p><p>&lt;/jaxrs:inInterceptors></p><p>&lt;jaxrs:outInterceptors></p><p>&lt;bean class="org.apache.cxf.interceptor.LoggingOutInterceptor">&lt;/bean></p><p>&lt;/jaxrs:outInterceptors></p><p>&lt;/jaxrs:server></p><p>--------------------------------下面附上 Service接口中方法聲明---------------------------------------</p><p>// 根據page和rows 返回分頁數據</p><p>@Path("/pageQuery")</p><p>@GET</p><p>@Produces({ "application/xml", "application/json" })</p><p>PageBean&lt;Promotion> findPageData(@QueryParam("page") int page,</p><p>@QueryParam("rows") int rows);</p><p>--------------------------------下面附上 Service實現編寫示例---------------------------------------</p><p>@Override</p><p>public PageBean&lt;Promotion> findPageData(int page, int rows) {</p><p>Pageable pageable = new PageRequest(page - 1, rows);</p><p>Page&lt;Promotion> pageData = promotionRepository.findAll(pageable);</p><p>// 封裝到Page對象</p><p>PageBean&lt;Promotion> pageBean = new PageBean&lt;Promotion>();</p><p>pageBean.setTotalCount(pageData.getTotalElements());</p><p>pageBean.setPageData(pageData.getContent());</p><p>return pageBean;</p><p>}</p><p><strong>2.服務端配置小結:</strong></p><p>其實以上已經說明了Service 接口編寫, Service接口實現編寫, Service服務在服務器端發佈, 以及服務器端對 WebService 請求的攔截;</p><p><strong>3.客戶端請求操作:</strong></p><p>客戶端作為服務的調用者,相對來說不需要特別的配置,只需要使用一個客戶端請求對象WebClient 加上正確的url 就可以發送請求了:其中 WebClient.create 創建了請求; .accept 指明瞭是接收數據(接收用accept, 發送用 type) ; .get 指明瞭請求方式是get請求(get請求是查詢操作, post請求是添加操作, put請求是更新操作, delete 請求是刪除操作)</p><p>@Action(value = "promotion_pageQuery", results = { @Result(name = "success", type = "json") })</p><p>public String pageQuery() {</p><p>// 基於WebService 獲取 bos_management的 活動列表 數據信息</p><p>PageBean&lt;Promotion> pageBean = WebClient</p><p>.create(Constants.BOS_MANAGEMENT_URL</p><p>+ "/bos_management/services/promotionService/pageQuery?page="</p><p>+ page + "&rows=" + rows)</p><p>.accept(MediaType.APPLICATION_JSON).get(PageBean.class);</p><p>ActionContext.getContext().getValueStack().push(pageBean);</p><p>return SUCCESS;</p><p>}</p><p><strong>4.WebService配置小結:</strong></p><p>其實我們來理順整個過程: 客戶端 使用WebClient.create();發起請求-------->服務端 web.xml配置 CXFServlet 攔截所有 /services 開頭請求--------> applicationContext-webService.xml 發佈服務-------> Service接口中的具體方法, 聲明服務訪問方式,-------> Service實現類中 提供了服務真正的操作內容;</p><p>=================以上WebService == 以下 ActiveMQ ======================</p><h1><strong>3.ActiveMQ 的配置:</strong></h1><p><strong>0.框架知識概述:</strong></p><p>ActiveMQ 是JMS java消息服務的規範的實現: 個人感覺它是一個服務器,有著自己的訪問端口,但是它的工作卻是存儲消息, 又很像一個存放消息的數據庫,所以在和 Spring整合時特像一個數據庫: 其實:ActiveMQ 的事情也是兩件:1.給生產者提供存放消息的入口, 2.給消費者提供消費消息的入口:</p><ol><li><strong>基礎連接配置:</strong></li></ol><p>無論是 “生產消息” 還是 “消費消息” :我們都要有基礎的連接配置:</p><ol><li><strong>ActiveMQ 本身給我們提供了一個連接工廠: ActiveMQConnectionFactory</strong></li></ol><p>&lt;!-- ActiveMQ 連接工廠 --></p><p>&lt;!-- 真正可以產生Connection的ConnectionFactory，由對應的 JMS服務廠商提供--></p><p>&lt;!-- 如果連接網絡：tcp://ip:61616；未連接網絡：tcp://localhost:61616 以及用戶名，密碼--></p><p>下面這種連接方式需要是為了簡化&lt;bean>配置,但需要下載第三方的支持,開始運行時較慢:</p><p>&lt;!-- &lt;amq:connectionFactory id="amqConnectionFactory" --></p><p>&lt;!-- brokerURL="tcp://localhost:61616" userName="admin" password="admin" /> --></p><p>&lt;bean id="amqConnectionFactory"</p><p>class="org.apache.activemq.ActiveMQConnectionFactory"></p><p>&lt;property name="brokerURL" value="tcp://localhost:61616">&lt;/property></p><p>&lt;property name="userName" value="admin">&lt;/property></p><p>&lt;property name="password" value="admin">&lt;/property></p><p>&lt;/bean></p><ol><li><strong>Spring 對 ActiveMQ 連接工廠的封裝 CachingConnectionFactory</strong></li></ol><p>Spring在 JMS服務供應商提供連接工廠的基礎上,給我們進行了一次封裝,這個封裝可以理解成 Spring 提供的API 與 ActiveMQ 之間的適配器 ; 達到了解耦的作用, 這樣Spring就可以整合各個JMS供應商提供的連接工廠了;</p><p>&lt;!-- Spring Caching連接工廠 --></p><p>&lt;!-- Spring用於管理真正的ConnectionFactory的ConnectionFactory --></p><p>&lt;bean id="mqConnectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"></p><p>&lt;!-- 目標ConnectionFactory對應真實的可以產生JMS Connection的ConnectionFactory --></p><p>&lt;property name="targetConnectionFactory" ref="amqConnectionFactory">&lt;/property></p><p>&lt;!-- 同上，同理 --></p><p>&lt;!-- &lt;constructor-arg ref="amqConnectionFactory" /> --></p><p>&lt;!-- Session緩存數量 --></p><p>&lt;property name="sessionCacheSize" value="1" /></p><p>&lt;/bean></p><ol><li><strong>基礎配置小結</strong></li></ol><p>不管我們用那種JMS產品,它都會提供一個連接工廠,而與Spring整合時,我們用 CachingConnectionFactory 將JMS服務廠商提供的連接工廠進行封裝, 那麼我們就可以不需要針對不同的 連接工廠操作了,只需要對同一個 CachingConnectionFactory 進行操作,達到了解耦的目的; 流程如下:</p><p>JMS廠商提供ActiveMQ 提供 ActiveMQConnectionFactory 連接工廠------>Spring 提供 CachingConnectionFactory 緩存連接工廠 封裝廠商提供的連接工廠</p><ol><li><strong>生產者配置:</strong></li><li>這個消息生產者配置,Spring使用了它慣用的模板思想,給你提供了一個模板對象,沒有什麼特別之處,這個模板對象封裝了連接工廠,就相當於持有了對ActiveMQ的連接, 那麼這個時候向ActiveMQ中添加消息應該是可以的; 下邊配置了兩種類型的jmsTemplate: 1. 點對點模式: 隊列Queue, 2. 發佈訂閱模式的: 話題Topic ; 他們的配置大同小異,唯一不同之處在於 :</li></ol><p>&lt;property name="pubSubDomain" value="false" /></p><p>的配置的value 值是false 還是 true; (true:發佈訂閱模式 false:點對點模式;)</p><p>&lt;!-- 定義JmsTemplate的Queue類型 --></p><p>&lt;bean id="jmsQueueTemplate" class="org.springframework.jms.core.JmsTemplate"></p><p>&lt;!-- 這個connectionFactory對應的是我們定義的Spring提供的那個ConnectionFactory對象 --></p><p>&lt;constructor-arg ref="mqConnectionFactory" /></p><p>&lt;!-- 非pub/sub模型（發佈/訂閱），即隊列模式 --></p><p>&lt;property name="pubSubDomain" value="false" /></p><p>&lt;/bean></p><p>&lt;!-- 定義JmsTemplate的Topic類型 --></p><p>&lt;bean id="jmsTopicTemplate" class="org.springframework.jms.core.JmsTemplate"></p><p>&lt;!-- 這個connectionFactory對應的是我們定義的Spring提供的那個ConnectionFactory對象 --></p><p>&lt;constructor-arg ref="mqConnectionFactory" /></p><p>&lt;!-- pub/sub模型（發佈/訂閱） --></p><p>&lt;property name="pubSubDomain" value="true" /></p><p>&lt;/bean></p><p>&lt;!--Spring JmsTemplate 的消息生產者 end--></p><p><strong>3.生產者編程:</strong></p><p>1.在消息生產者配置的基礎上,配置了一個jmsTemplate模板,我們可以使用:</p><p>// 注入queue消息模板</p><p>@Autowired</p><p>@Qualifier("jmsQueueTemplate")</p><p>private JmsTemplate jmsQueueTemplate;</p><p>注入到我們的程序中,然後調用send方法,向activeMQ中生產消息:</p><p>// 調用MQ服務,發送短信驗證碼</p><p>jmsQueueTemplate.send("bos_sms", new MessageCreator() {</p><p>@Override</p><p>public Message createMessage(Session session) throws JMSException {</p><p>MapMessage mapMessage = session.createMapMessage();</p><p>mapMessage.setString("telephone", model.getTelephone());</p><p>mapMessage.setString("checkCode", checkCode);</p><p>return mapMessage;</p><p>}</p><p>});</p><p>簡單解釋一下: send(消息名稱, 消息創建接口);</p><p>這個地方相當複雜:利用了兩個不容易理解的知識點: 我們簡單聊聊:</p><ol><li>第一個問題: jmsQueueTemplate 的Send()方法需要 MessageCreator 的createMessage()方法創建的消息內容,但是 MessageCreator 創建消息時需要 session,但是它卻沒有; 然而 jmsQueueTemplate 的execute()方法 卻可以獲得session , 所以 jmsQueueTemplate 對 MessageCreator 說:你先過來,然後我給你弄個session , 然後你給我弄message, 這裡邊體現的是, 接口作為參數時,實現了主調方法的資源對接口中的方法的共享, 這裡主調方法是 send ,它可以想辦法拿到 session,然後 它把session共享給了 createMessage()方法;</li></ol><p>如果說一般數據類型數據做為形參,主調方法是為了獲取實參的值,</p><p>那麼接口作為形參時,主調方法是為了獲得接口的方法, 還有一點附帶效果:傳入的接口中的方法可以共享主調方法的參數訪問權限(就是主調方法可以用的參數,接口中的方法也可以用;)</p><ol><li>第二個問題: send 發送的消息內容是不固定的(有:1.MapMessage;2.ByteMessage;3.ObjectMessage;4.StreamMessage;5.TextMessage),也就是說 創建消息的方法體是不固定的,那麼是如何實現的呢? 用接口作為參數傳入,由用戶動態定義方法的實現;</li></ol><p>如果說我們在方法中調用類的靜態方法,是將一段固定代碼插入到主調方法中;</p><p>那麼對接口方法的調用,就是將一段動態代碼插入到主調方法中;</p><p><strong>4.生產者總結:</strong></p><p>ActiveMQ 的生產者:</p><p>廠商的 ActiveMQConnectionFactory 注入到 ------>Spring的 CachingConnectionFactory ------>注入到 Spring的 JmsTemplate ; 配置提供了這個模板對象之後,我們就可以在java代碼中注入這個對象,進行消息的創建;</p><p><strong>5.消費者配置:</strong></p><p>消費者要從ActiveMQ中拿消息, 肯定是要連接ActiveMQ服務器的,所以基礎連接配置,消費者配置中也需要一份,我們假設消費者配置中,已經配置好了基礎連接; 那麼這個時候已經可以拿到 CachingConnectionFactory , 這意味著我們已經可以通過這個連接工廠獲得與ActiveMQ的連接了; 如何完成消費呢? 首先編寫一個類實現 MessageListener 接口 ,然後將這個類註冊到消息監聽器容器中; 這裡說明一點,類實現了 MessageListener 接口本質上是為了讓這個類實現監聽器應該具有的方法, 然而並沒有真正監聽ActiveMQ中的消息,這個時候需要配置到消息監聽器的容器(listener-container)中才能生效; 而這個(listener-container) 到底如何工作的呢? 我們來看看這個,消費者配置:</p><p>&lt;!-- 定義Queue監聽器 --></p><p>&lt;jms:listener-container destination-type="queue" container-type="default"</p><p>connection-factory="connectionFactory" acknowledge="auto"></p><p>&lt;!-- 默認註冊bean名稱，應該是類名首字母小寫 --></p><p>&lt;jms:listener destination="bos_sms" ref="smsConsumer"/></p><p>&lt;/jms:listener-container></p><p>&lt;!-- 定義Topic監聽器 --></p><p>&lt;!-- &lt;jms:listener-container destination-type="topic" container-type="default"</p><p>connection-factory="connectionFactory" acknowledge="auto"></p><p>&lt;jms:listener destination="spring_topic" ref="topicConsumer1"/></p><p>&lt;jms:listener destination="spring_topic" ref="topicConsumer2"/></p><p>&lt;/jms:listener-container> --></p><p>我們可以看到:在消息監聽容器中,注入了兩個參數:</p><p>connection-factory="connectionFactory"</p><p>這個是配置了連接工廠, 是獲得與ActiveMQ服務器連接的;</p><p>&lt;jms:listener destination="bos_sms" ref="smsConsumer"/></p><p>這個是配置了監聽的消息目標: destination="bos_sms"</p><p>(監聽者)消費者: ref="smsConsumer"</p><p><strong>6.消費者編程:</strong></p><p>(監聽者)消費者 本身是一個類,實現了 MessageListener 接口:</p><p>@Service("smsConsumer")</p><p>public class SmsConsumer implements MessageListener {</p><p>@Override</p><p>public void onMessage(Message message) {</p><p>MapMessage mapMessage = (MapMessage) message;</p><p>String telephone = null;</p><p>String checkCode = null;</p><p>try {</p><p>telephone = mapMessage.getString("telephone");</p><p>checkCode = mapMessage.getString("checkCode");</p><p>} catch (JMSException e) {</p><p>// TODO Auto-generated catch block</p><p>e.printStackTrace();</p><p>}</p><p>// 用輸出語句代替短信發送</p><p>System.out.println(telephone+" 的驗證碼是 : "+checkCode);</p><p>}</p><p>}</p><p><strong>7.消費者總結:</strong></p><p>其實消費者無非就是從ActiveMQ中獲得獲得消息, 那麼首先要獲得與ActiveMQ的連接,這個是通過基礎配置完成的, 連接以後要從裡邊拿消息呀,這個地方是在配置文件中配置一個監聽器容器, 將連接工廠和監聽器(其實就是一個實現了MessageListener的java類) 注入到這個監聽器中,這個時候就相當於通過監聽器容器,將監聽器和ActiveMQ建立了聯繫;</p><p>=================以上ActiveMQ == 以下 Quartz=====================</p><h1><strong>4.Quartz的配置:</strong></h1><p><strong>0.框架知識概述:</strong></p><p>Quartz是一個定時任務調度框架, 它關心的只有兩件事情:</p><ol><li>要做什麼事情---->jobDetail(即任務詳情)</li><li>什麼時候做,頻率是什麼---->SimpleTrigger(依據時間)/CronTriggerFactoryBean(依據日曆) 即:任務執行策略;</li></ol><p>Ps:</p><ol><li>任務調度員scheduler,這個是將 jobDetail 和 SimpleTrigger 進行組合,生成一個日程,</li><li>另外還有一點要說明一下,在實際生產中,我們 jobDetail(即任務詳情)可能並不在Spring的管理之中, 但是, jobDetail(即任務詳情) 卻需要@autowired 被Spring管理的Service 或者其他bean, 這就違背了Spring規定:一個對象要想被注入對象,必須自己在Spring 管理之中,這個時候該怎麼解決呢, 我們知道, Struts2與Spring整合時, action 沒有被Spring管理,卻可以注入被Spring管理的Service, 這裡我們使用同樣的方法解決這個問題,那就是創建了一個可以使 我們的 jobDetail 具有可以自動注入功能的工廠類 JobFactory ;我們在實際配置中是將 jobDetail 注入 SimpleTrigger ,再將 SimpleTrigger 注入 SchedulerFactoryBean ,那麼,此時我們將 JobFactory 也注入到 SchedulerFactoryBean 中,那麼創建出來的 jobDetail 就具有了自動注入的功能; 問題得以解決;</li><li><strong>JobDetailFactoryBean配置:</strong></li></ol><p>JobDetailFactoryBean 是job的工廠,我們在裡邊注入我們的job類對象, 下面的配置中job並不在Spring管理中;</p><p>&lt;bean id="promotionJob" class="org.springframework.scheduling.quartz.JobDetailFactoryBean"></p><p>&lt;property name="jobClass" value="cn.itcast.bos.quartz.PromotionJob">&lt;/property></p><p>&lt;/bean></p><ol><li><strong>Job類編寫:</strong></li></ol><p>public class PromotionJob implements Job{</p><p>@Autowired</p><p>private PromotionService promotionService;</p><p>@Override</p><p>public void execute(JobExecutionContext context)</p><p>throws JobExecutionException {</p><p>//每分鐘執行一次,當前時間大於promotion數據表中的endDate ,活動已經過期,設置status='2'</p><p>promotionService.updateStatus(new Date());</p><p>}</p><p>}</p><ol><li><strong>SimpleTriggerFactoryBean 配置:</strong></li></ol><p>將JobDetailFactoryBean 注入到 SimpleTriggerFactoryBean中:</p><p>&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"></p><p>&lt;property name="jobDetail" ref="promotionJob">&lt;/property></p><p>&lt;property name="startDelay" value="0">&lt;/property></p><p>&lt;property name="repeatInterval" value="10000">&lt;/property></p><p>&lt;/bean></p><ol><li><strong>SchedulerFactoryBean的配置:</strong></li></ol><p>將 SimpleTriggerFactoryBean 注入到 SchedulerFactoryBean中,同時還注入了一個 jobFactory這個jobFactory 注入的目的是是為了讓我們的Job具有Spring自動注入功能;</p><p>&lt;bean id="" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"></p><p>&lt;property name="jobFactory" ref="jobFactory">&lt;/property></p><p>&lt;property name="triggers"></p><p>&lt;list></p><p>&lt;ref bean="simpleTrigger"/></p><p>&lt;/list></p><p>&lt;/property></p><p>&lt;/bean></p><ol><li><strong>附上 jobFactory的代碼:</strong></li></ol><p>@Service("jobFactory")</p><p>public class JobFactory extends AdaptableJobFactory {</p><p>@Autowired</p><p>private AutowireCapableBeanFactory capableBeanFactory;</p><p>@Override</p><p>protected Object createJobInstance(TriggerFiredBundle bundle)</p><p>throws Exception {</p><p>Object jobInstance = super.createJobInstance(bundle);</p><p>capableBeanFactory.autowireBean(jobInstance);</p><p>return jobInstance;</p><p>}</p><p>}</p><h1><strong>5.redis配置:</strong></h1><p>Redis是一個內存數據庫,由於存取速度非常快,往往用作緩存; 作為一個數據庫, 無非就是考慮兩個問題:</p><ol><li>怎麼連接這個數據庫,</li><li>怎麼操作這個數據庫;</li><li><strong>配置連接池基本參數:</strong></li></ol><p>&lt;!-- jedis 連接池配置 --></p><p>&lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"></p><p>&lt;property name="maxIdle" value="300" /></p><p>&lt;property name="maxWaitMillis" value="3000" /></p><p>&lt;property name="testOnBorrow" value="true" /></p><p>&lt;/bean></p><ol><li><strong>配置連接工廠:</strong></li></ol><p>&lt;!-- jedis 連接工廠 --></p><p>&lt;bean id="redisConnectionFactory"</p><p>class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</p><p>p:host-name="localhost" p:port="6379" p:pool-config-ref="poolConfig"</p><p>p:database="0" /></p><ol><li><strong>配置模板:</strong></li></ol><p>&lt;!-- spring data 提供 redis模板 --></p><p>&lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"></p><p>&lt;property name="connectionFactory" ref="redisConnectionFactory" /></p><p>&lt;!-- 如果不指定 Serializer --></p><p>&lt;property name="keySerializer"></p><p>&lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /></p><p>&lt;/property></p><p>&lt;property name="valueSerializer"></p><p>&lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer"></p><p>&lt;/bean></p><p>&lt;/property></p><p>&lt;/bean></p><ol><li><strong>Java代碼編寫示例:</strong></li></ol><p>// 2.將激活碼保存到redis中 可以設置存貨時間;</p><p>redisTemplate.opsForValue().set(model.getTelephone(), activeCode, 24, TimeUnit.HOURS);</p><h1><strong>6.SpringDataElasticSearch配置:</strong></h1><p><strong>0.框架知識概述:</strong></p><p>簡化操作ElasticSearch的技術: 是SpringData 項目下的一個子項目,為了整合 ElasticSearch ; 經過一系列配置,提供了類似SpringDataJPA的操作模式;</p><p>ElasticSearch是一個全文搜索服務器 , 但本質上是一個索引庫: 它的一些基本概念和關係型數據庫概念對應關係如下:</p><p>索引(index)------->表(table)</p><p>文檔(document)------->一條數據實體(entity)</p><p>域(filed) --------> 字段(field)</p><p>作為一個數據庫,我們還是關心兩個老問題:1.怎麼連接上這個數據庫, 2.怎麼操作這個數據庫;</p><ol><li><strong>連接ElasticSearch:</strong></li></ol><p><strong>1.配置客戶端 client</strong></p><p>&lt;!-- 配置elasticsearch 連接 其實這個地方配置的是客戶端 :transportclient --></p><p>&lt;elasticsearch:transport-client id="client" cluster-nodes="localhost:9300" /></p><p><strong>2.配置模板對象: 注入client對象</strong></p><p>&lt;!-- spring data elasticsearch DAO 必須依賴 elasticsearchTemplate --></p><p>&lt;bean id="elasticsearchTemplate"</p><p>class="org.springframework.data.elasticsearch.core.ElasticsearchTemplate"></p><p>&lt;constructor-arg name="client" ref="client" /></p><p>&lt;/bean></p><p><strong>3.實體類要配置映射</strong></p><p>這個映射與hibernate中的對象映射有些類似,但是還有不同,這個映射配置, 其實配置了實體的存儲策略(就想當於指明關係數據庫的表結構怎麼建),檢索策略,分詞策略,等;</p><p><strong>4.連接配置小結:</strong></p><p>配置客戶端:client ------>注入 elasticsearchTemplate ----->實體配置映射註解;</p><p>這個地方實體映射配置某種程度上說是一個 單純的映射配置的載體; 模板對象讀取這個類時,可以讀取這個對象中的映射文件;</p><ol><li><strong>操作ElasticSearch:</strong></li></ol><p>配置掃描dao , 並且我們的dao繼承了 ElasticSearchRepository 接口,這樣我們在</p><p>@autowired dao實現時,就會注入框架默認的實現;</p><p>&lt;!-- 掃描DAO包 自動創建實現 --></p><p>&lt;elasticsearch:repositories base-package="cn.itcast.dao" /></p><p><strong>3.ElasticSearch 配置小結:</strong></p><p>我們連接ElasticSearch 是通過配置客戶端操作對象 transportclient , 其實拿著這個client已經可以操作 ElasticSearch 了,但是 我們又對這個client進行了一次封裝,封裝成了一個 template (模板), 這個模板已經可以完成了一些基本操作了, 然而在此時,我們沒有止步,而是又做了一層封裝, 封裝成了一個默認實現,我們編寫一個dao 繼承 ElasticsearchRepository 這個接口,然後AOP就會給我們返回一個默認實現的 repository,這個repository 實現了基本增刪改, 規範的find查詢方法,等等 這點有點兒類似SpringDataJPA ;</p><h1><strong>7.shiro配置:</strong></h1><p>Shiro是一個權限控制框架:</p><p>權限控制流程: applicationCode -----> Subject------> ShiroSecurityManager----->Realm ;</p><p>其實權限控制問題簡單來說就是: 哪些user 可以訪問哪些 url的問題;</p><p><strong>1.粗粒度url權限驗證流程:</strong></p><p>request 請求發出--->web.xml中的DelegatingFilterProxy 代理過濾器過濾到請求----> 交給applicationContext.xml 中的真正的過濾器 ShiroFilterFactoryBean----> 過濾器將請求交給 "安全管理器" securityManager ----->"安管"讀取過濾器中的 "資源與訪問權限對應清單" filterChainDefinitions ----->"安管"找到request要訪問的資源需要的權限:permission1 ----></p><p>"安管" 調用 "小弟" realm 的 doGetAuthorizationInfo()方法,獲得當前用戶所持有的權限: permission2 ---->此時:"安管"已經從過濾器中拿到 1. 要訪問的資源需要的權限:permission1 2. 前用戶所持有的權限: permission2 ,所以"安管"可以很輕鬆地將兩個權限做比較,如果匹配,那麼就允許用戶訪問資源,如果不匹配,則拒絕訪問該資源,並跳轉到沒有權限訪問的頁面;</p><p><strong>2.細粒度方法級別權限驗證流程:</strong></p><p>request請求發出----> 調用 save()方法----> Spring 嘗試利用 IOC 創建cglib 動態代理對象,卻發現目標類 的save()方法上有shiro註解,然後就利用AOP 在代理類的save方法上加上前置通知: AuthorizationAttributeSourceAdvisor 來讀取save()方法上的 shiro註解,並將結果交給"安管"----->securityManager 獲得 save()方法訪問應具備的權限 -----> 調用realm的doGetAuthorizationInfo()方法,來獲得當前用戶所持有的權限, 然後安管自己會對兩個權限作對比,判定是否可以訪問資源...;</p><p><strong>3.兩種權限驗證方式對比分析:</strong></p><p><strong>粗粒度url權限控制 與 細粒度方法級別權限控制 對比分析:</strong></p><p>粗粒度url權限控制</p><p>細粒度方法級別權限控制</p><p>資源控制者</p><p>securityManager</p><p>securityManager</p><p>資源訪問所需權限獲取來源</p><p>過濾器 shiroFilter 中的屬性配置</p><p>Spring框架 (IOC和AOP共同作用)從方法的註解讀取</p><p>當前用戶訪問權限獲取來源</p><p>小弟: realm</p><p>小弟:realm</p><p>權限不足時處理方式</p><p>過濾器配置相應友好提示頁面</p><p>拋出相應異常給方法調用者;</p><ol><li><strong>緩存框架Ehcache 的配置</strong></li></ol><p><strong>0.框架知識概述:</strong></p><p>當我們用Shiro做權限管理的時候,我們每一次對資源進行訪問時我們的 “安全管理器” securityManager 會對當前用戶進行權限的授權信息獲取, 如果每次獲取當前用戶的授權信息都到數據庫中查詢,這樣無疑是降低了資源獲取的速度,用戶體驗不好,所以這種情況,我們必然要對用戶權限信息進行緩存處理;</p><p>Flag:緩存技術不一定用在權限管理,但權限管理一定會用到緩存;</p><ol><li><strong>複製自帶配置文件 ehcache-failsafe.xml</strong></li></ol><p>Ehcache 的jar包下有默認配置文件,我們將它複製到與applicationContext.xml 同級目錄下;</p><p>我們在這個配置文件裡邊創建自定義的緩存空間;</p><ol><li><strong>Spring整合(管理)Ehcache</strong></li></ol><p>Ehcache 的 EhCacheManager “緩存管理器” 交給Spring的EhCacheManagerFactoryBean “緩存管理器工廠bean” 來管理;</p><p>至此, ehcache已經在Spring的管理之中了;</p><p>&lt;!-- Ehcache配置 (ehcache的 "緩存管理器" 納入Spring管理) --></p><p>&lt;bean id="ehCacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"></p><p>&lt;property name="configLocation" value="classpath:ehcache.xml">&lt;/property></p><p>&lt;/bean></p><ol><li><strong>Ehcache 對Shiro 的權限數據進行數據緩存</strong></li><li><strong>Shiro 整合 Ehcache</strong></li></ol><p>Ehcache 底層是Map結構實現,所以Shiro要對Ehcache 的緩存管理器再做一層封裝,指明什麼作為key,什麼作為value ,這個封裝類就是: EhCacheManager ,我們將ehcache的 "緩存管理器" 屬性注入到shiro 的 EhCacheManager :</p><p>&lt;!-- shiro配置 (將ehcache的 "緩存管理器" 屬性注入到shiro) --></p><p>&lt;!-- ehcache 底層是Map實現,所以Shiro要對ehcache的緩存管理器在做一層封裝,指明什麼作為key,什麼作為value --></p><p>&lt;bean id="shiroEhCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"></p><p>&lt;property name="cacheManager" ref="ehCacheManager">&lt;/property></p><p>&lt;/bean></p><ol><li><strong>Shiro “安全管理器” 獲得 “Ehcache緩存管理器”</strong></li></ol><p>根據Shiro權限驗證執行流程: 應用程序代碼------> subject ------> securityManager-----></p><p>Realm ------> 訪問安全數據 ;</p><p>&lt;!-- 安全管理器 --></p><p>&lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"></p><p>&lt;property name="realm" ref="bosRealm">&lt;/property></p><p>&lt;property name="cacheManager" ref="shiroEhCacheManager">&lt;/property></p><p>&lt;/bean></p><p>上邊配置的結果是: “安全管理器” 獲得了緩存操作權限; 這樣它的小弟 realm 就可以向 “安全管理器” 申請一個緩存空間, 什麼意思呢? 就是小弟realm說:你把 “bos” 這個緩存區給我,以後你找我要數據,你先到這個緩存區看看有沒有,如果沒有,我再去數據庫幫你找到,然後你要把數據放進去,下次不要找我要了;</p><ol><li><strong>Reaml 指定將 哪些 數據存入 哪個 緩存區</strong></li></ol><p>&lt;!-- Realm配置, 指明將 "授權數據" 緩存到 "bos" 緩衝區--></p><p>&lt;bean id="bosRealm" class="cn.itcast.bos.realm.BosRealm"></p><p>&lt;property name="authorizationCacheName" value="bos">&lt;/property></p><p>&lt;/bean></p><ol><li><strong>Ehcache對權限數據緩存的 配置流程總結:</strong></li></ol><p>在Ehcache的 ehcache-failsafe.xml中自定義緩存區 ------> Spring與Ehcache的整合類(EhCacheManagerFactoryBean)讀取配置文件 得到 ehCacheManager------> ehCacheManager</p><p>注入到 Shiro的 shiroEhCacheManager ------> shiroEhCacheManager 注入到 “安全管理器” securityManager ------> Reaml 通過屬性配置 來 聲明要緩存數據,以及要緩存的區域 (比如 bos) ;</p><p><strong>4. Ehcache對一般數據的緩存配置:</strong></p><p><strong>1. Spring “緩存管理器” 封裝 Ehcache的 “緩存管理器”</strong></p><p>在Shiro 整合Ehcache時,有一個 shiroEhCacheManager 來管理 key-value的生成策略, 那麼在對一般數據的緩存配置時,肯定是不能用這個緩存管理器了, 這個時候Spring 就出來說話了,他說 我定義一個 “緩存管理器” 來管理 一般數據的key-value的生成策略;</p><p>&lt;!-- Spring 封裝Ehcache的緩存管理器,它規範了普通數據緩存時的key-value 生成策略 --></p><p>&lt;bean id="springCacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"></p><p>&lt;property name="cacheManager" ref="ehCacheManager"/></p><p>&lt;/bean></p><p>這個緩存管理器一方面是獲得 Ehcache 的緩存管理器,擁有了緩存操作權限 ; 另一方面是提供了一些標籤,它可以解釋這些標籤,來執行緩存操作 ;</p><p><strong>2.在Spring的配置文件中 激活spring 緩存註解</strong></p><p>目的就是讓Spring 能夠識別它管理的類中的緩存註解;</p><p>&lt;!-- 激活spring 緩存註解 --></p><p>&lt;cache:annotation-driven cache-manager="springCacheManager"/></p><p><strong>3.在被Spring管理的bean的方法上使用 @Cacheable() , @CacheEvict() :</strong></p><p>@Cacheable(value=”緩存區”) : 應用緩存, 對方法返回結果進行緩存, 這個註解多用在查詢方法上; 至於誰是key ,誰是value 由Spring的緩存管理器來負責; 如果被註解的方法有不同的 傳入參數, 可在註解中使用SpEL (Spring表達式) 自定義key值;</p><p>@CacheEvict (value=”緩存區”,allEntries=”true”): 清除緩存區的數據, allEntries代表所有數據;</p><ol><li><strong>緩存配置中的注意點:</strong></li></ol><p>被緩存的對象數據對應的類要序列化 : implements Serializable ;</p><ol><li><strong>Freemarker 模板引擎</strong></li></ol><p>Struts2 默認是使用 Freemarker作為自定義標籤模板,所以項目導入了Struts2 就已經導入了Freemarker的jar包;</p><p><strong>0.技術概述:</strong></p><p>Freemarker就是一個模板引擎,它類似我們之前學習的jsp; FreeMarker 它通過編寫一個模板文件,結合我們程序中的動態數據,輸出標準的文本內容,一般情況下我們用它來生成html文件比較多;</p><p>簡單來說: 模板文件 + java數據對象 == 輸出 (任何格式文本)</p><p>FreeMarker 模板文件,通常擴展名 .ftl (當然也可以用 .html / .jsp)</p><p>我們編寫前,要安裝一個Freemarker的插件,安裝到eclipse ,這樣我們編輯時就會有提示; Freemarker 模板文件中的變量 跟EL 表達式一樣,都是 ${變量名}</p><ol><li><strong>編寫模板文件 promotion_detail.ftl</strong></li></ol><p>&lt;link rel="stylesheet" type="text/css" href="css/promotion_detail.css"></p><p>&lt;div class="container promotions" ></p><p>&lt;div class="col-md-2 prolist"></p><p>&lt;h5 class="title">&lt;a href="#/promotion">&lt;strong>返回促銷列表&lt;/strong>&lt;/a>&lt;/h5></p><p>&lt;img src="images/pro.jpg" class="img-responsive"></p><p>&lt;/div></p><p>&lt;div class="col-md-10 procontent"></p><p>&lt;h5 class="title">${promotion.title}&lt;/h5></p><p>&lt;div class="intro"></p><p>&lt;p>活動範圍: ${promotion.activeScope}&lt;/p></p><p>&lt;p>活動時間: ${promotion.startDate?string("yyyy-MM-dd")} -</p><p>${promotion.endDate?string("yyyy-MM-dd")}&lt;/p></p><p>&lt;/div></p><p>&lt;div class="partline clearfix">&lt;/div></p><p>&lt;div class="promotionbox"></p><p>${promotion.description}</p><p>&lt;/div></p><p>&lt;/div></p><p>&lt;/div></p><ol><li><strong>編寫java代碼</strong></li></ol><p>// 用面向對象思想,將配置文件目錄封裝為configuration對象</p><p>Configuration configuration = new Configuration(</p><p>Configuration.VERSION_2_3_22);</p><p>configuration.setDirectoryForTemplateLoading(new File(</p><p>ServletActionContext.getServletContext().getRealPath(</p><p>"/WEB-INF/freemarker_templates")));</p><p>// 用 configuration 獲取模板對象 template</p><p>Template template = configuration</p><p>.getTemplate("promotion_detail.ftl");</p><p>// 動態數據</p><p>Promotion promotion = WebClient</p><p>.create(Constants.BOS_MANAGEMENT_URL</p><p>+ "/bos_management/services/promotionService/promotion/"</p><p>+ model.getId()).accept(MediaType.APPLICATION_JSON)</p><p>.get(Promotion.class);</p><p>//構造動態數據 ()</p><p>Map&lt;String, Object> parameterMap = new HashMap&lt;String, Object>();</p><p>parameterMap.put("promotion", promotion);</p><p>//使用模對象合併數據 template 合併輸出</p><p>/* @param dataModel the holder of the variables visible from the template (name-value pairs); usually a {@code Map&lt;String, Object>} or a JavaBean (where the JavaBean properties will be the variables) */</p><p>template.process(parameterMap, new OutputStreamWriter(</p><p>new FileOutputStream(htmlFile), "utf-8"));</p><p>模板對象 template 合併數據時,將數據模型數據dataModel 輸出到writer流中; 而這個dataModel 的數據類型一般是 Map&lt;String, Object> , 當然也可以是 JavaBean ,這個 JavaBean 的屬性是模板中的變量; 另外要說一點,如果模板中有變量必須全部賦值, 如果存在一個沒有賦值, 好像會報錯;</p><ol><li><strong>Spring與Mybatis整合配置</strong></li></ol><p>PS: mybatis框架的特別之處是,它實現了sql語句與java代碼的分離,所以它要解決的核心問題是如何讓mapper.xml中的sql語句在數據庫操作時起作用;</p><p>另外說明一點:</p><p>在mybatis單獨使用時: mapper.xml-----> SqlMapConfig.xml ------> sqlSessionFactory ----->sqlSession , 所以這個時候 mapper.xml的引用在sqlSession中,因此 外置sql語句的調用是由sqlSession來完成的;</p><p>在mybatis與spring整合時: SqlMapConfig.xml ----> sqlSessionFactory ----> MapperFactoryBean; 由於在mybatis與spring整合時,SqlMapConfig.xml是一個空的文件,所以裡邊沒有mapper.xml的引用,所以沒有辦法使用裡邊的sql,這個時候怎麼解決這個問題呢? 通過一個強制要求: 映射文件(mapper.xml)必須與相應的接口同名且在同一個目錄下,這樣在創建代理時,在讀取接口的同時會在相同目錄下去尋找映射文件,這樣就同時利用接口和映射文件生成了代理對象;</p><ol><li><strong>連接數據庫</strong></li><li><strong>數據庫連接參數抽取: db.properties</strong></li></ol><p>jdbc.driver=com.mysql.jdbc.Driver</p><p>jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8</p><p>jdbc.username=root</p><p>jdbc.password=123</p><ol><li><strong>Spring核心配置文件applicationContext.xml 中加載db.properties並配置連接池BasicDataSource</strong></li></ol><p><strong>1.簡單說明:</strong></p><p>連接池的作用是提供連接,並且不用反覆創建銷燬數據庫連接;</p><p><strong>2.配置內容:</strong></p><p>&lt;!-- 加載屬性配置文件 --></p><p>&lt;context:property-placeholder location="classpath:db.properties"/></p><p>&lt;!-- 配置連接池 --></p><p>&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"</p><p>destroy-method="close"></p><p>&lt;property name="driverClassName" value="${jdbc.driver}" /></p><p>&lt;property name="url" value="${jdbc.url}" /></p><p>&lt;property name="username" value="${jdbc.username}" /></p><p>&lt;property name="password" value="${jdbc.password}" /></p><p>&lt;property name="maxActive" value="10" /></p><p>&lt;property name="maxIdle" value="5" /></p><p>&lt;/bean></p><ol><li><strong>配置Spring與Mybatis整合類 org.mybatis.spring.SqlSessionFactoryBean</strong></li></ol><p><strong>1.簡單說明:</strong></p><p>sqlSessionFactory 跟hibernate的SessionFactory , SpringDataJPA的EntityManagerFactory 的功能非常類似:</p><p>1.注入連接池,獲得了連接數據庫的能力;</p><p>2. 注入了映射配置文件位置; 區別在於:hibernate的映射配置文件是配置了實體與表之間的映射,最後乾脆通過註解,將映射配置放到了實體類中,最後sql語句(或者hql)的編寫就寫到dao中了; 然後就是SpringDataJPA, 它是在Hibernate基礎之上,將一部分sql語句做了封裝實現,這樣我們在對數據庫進行一些簡單操作的時候,我們可以直接通過調用一些方法就可以了,等於是幫我們已經完成了一些簡單的CRUD操作; 但是一些複雜的查詢操作,我們還是需要自己在 Dao中編寫查詢語句(hql或者是sql),不論是hibernate還是 SpringDataJPA 都沒有將Sql語句與java 代碼分離, 而mybatis卻做了這一點: mybatis的映射配置文件中有三部分: 1.輸入映射; 2.輸出映射;3. sql語句映射; 其中輸入輸出映射完成了類似orm映射的功能,完成類與表的對應; 而sql語句映射其實是提供了一些固定的sql操作,然後我們通過:</p><p>1. sql映射的namespace 使用Dao接口的 全限定名</p><p>2.sql映射的 statementId 與Dao接口的方法名一致</p><p>3.sql映射的parameterType與Dao中方法的參數類型一致</p><p>4.sql映射的resultType與Dao中方法的返回值類型一致</p><p>以上四點約定,我們的sql映射實際上已經成為以後Mybatis使用Mapper代理方式時,Spring創建代理的依據; 所以說某種程度上說mapper映射文件中的sql映射部分可以視作是Dao接口的實現類; 這樣其實實現了 “實現類”到”映射文件”的轉變( java代碼----->xml配置的轉變), 將sql語句從java 代碼中抽離出來了;</p><p><strong>2.配置內容:</strong></p><p>&lt;!-- 配置sqlSessionFactoryBean --></p><p>&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"></p><p>&lt;!-- 注入連接池 --></p><p>&lt;property name="dataSource" ref="dataSource">&lt;/property></p><p>&lt;!-- 加載mybatis 核心配置文件 --></p><p>&lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml"/></p><p>&lt;/bean></p><ol><li><strong>操作數據庫</strong></li><li><strong>簡單說明:</strong></li></ol><p>我在前面總結持久層框架的時候喜歡將配置分為兩部分:</p><ol><li>連接數據庫 : 得到SessionFactory</li><li>操作數據庫 : 將SessionFactory 與dao融合;</li></ol><p><strong>2.配置內容:</strong></p><p>&lt;!-- 第一種方式: 通過設置mapper接口 ; 缺點:一次只能配置一個接口--></p><p>&lt;!-- &lt;bean class="org.mybatis.spring.mapper.MapperFactoryBean&lt;T>"></p><p>&lt;property name="sqlSessionFactory" ref="sqlSessionFactory">&lt;/property></p><p>&lt;property name="mapperInterface" value="cn.itheima.mybatis.mapper.UserMapper">&lt;/property></p><p>&lt;/bean> --></p><p>&lt;!-- 第二種方式: 通過對mapper包掃描;</p><p>優點:1.可以對mapper包下的所有接口完成代理; 2.會自動注入 sqlSessionFactory --></p><p>&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"></p><p>&lt;property name="basePackage" value="cn.itheima.mybatis.mapper"/></p><p>&lt;/bean></p><p>上邊兩種配置都可以完成 sqlSessionFactory 與Dao的融合,但是第二種更有優勢: 我們簡單分析一下: 它是通過掃描包,然後找到包下的接口,然後讀取到包下同名的mapper.xml映射文件,然後根據 接口和映射文件創建 接口實現類對象;</p><h1><strong>8.持久層框架配置套路總結:</strong></h1><p>其實:持久層無非做了兩件事: 1.連接數據庫, 2操作數據庫 ;圍繞這兩件事每個框架都各有千秋,但是它們與Spring整合時的配置應該是有一些套路的:</p><p><strong>1 . Spring 的JdbcTemplate</strong></p><p>這個類簡化了JDBC操作,</p><p>它的基本操作: update(sql語句, 參數); query(sql語句, 參數);</p><p><strong>操作流程如下:</strong></p><ol><li>配置驅動連接池 (可以用默認的,也可以單獨配比如C3P0連接池),屬性注入連接參數: driven, url , username , password</li><li>配置 JdbcTemplate</li><li>我們可以在java類中直接注入 JdbcTemplate 進行CRUD操作;</li></ol><p><strong>2.hibernate:</strong></p><p>這是一個orm框架,通過映射文件,實現了對數據庫表的操作 到 對類的對象操作的轉化</p><p>操作流程如下:</p><ol><li>將基本連接參數分離成一個.properties文件</li><li>在application.xml中引入.properties文件</li><li>配置連接池 (注入連接參數)</li><li>配置 LocalSessionFactory (注入1.連接池; 2.數據庫基本配置; 3.映射文件位置 )</li><li>編寫dao 繼承 HibernateDaoSupport類 並在</li><li>配置dao (注入sessionFactory, 本質上是注入到HibernateDaoSupport 中) 這樣在dao中就可以獲得: hibernateTemplate 模板對象;</li><li>利用模板對象進行CRUD操作,這個時候操作的,這個模板對象也是簡化hibernate數據訪問操作;</li></ol><p><strong>3.SpringDataJPA</strong></p><p>1. 將基本連接參數分離成一個.properties文件</p><p>2. 在application.xml中引入.properties文件</p><p>3. 配置連接池 (注入連接參數)</p><p>4. 配置LocalContainerEntityManagerFactoryBean</p><p>注入 : 1.連接池; 2.domain掃描包路徑(相當於映射文件配置); 3.持久化提供者; 4.其他數據庫基本配置;</p><p>&lt;property name="dataSource" ref="dataSource" /></p><p>&lt;property name="packagesToScan" value="cn.itcast.bos.domain" /></p><p>&lt;property name="persistenceProvider"></p><p>&lt;bean class="org.hibernate.jpa.HibernatePersistenceProvider" /></p><p>&lt;/property></p><p>...</p><p>5. Jpa掃描dao; 這一步等價於hibernate中的 dao配置,hibernate中是給dao中注入sessionFactory,使到可以獲得hibernateTemplate模板, 這個地方 通過掃描dao的方式,在獲得dao對象時通過AOP技術提供給我們默認的dao實現;</p><p>&lt;jpa:repositories base-package="cn.itcast.bos.dao" /></p><p><strong>4.redis</strong></p><p>1.配置連接池 JedisPoolConfig</p><p>2.配置連接工廠 JedisConnectionFactory</p><p>3.配置模板 RedisTemplate</p><p>4.java代碼中操作:</p><p>redisTemplate.opsForValue().set(model.getTelephone(), activeCode, 24, TimeUnit.HOURS);</p><p><strong>5.小結:</strong></p><p>通過比較持久層這個幾個配置,我們可以看出來,Spring在整個各種框架是,基本套路也就是:</p><ol><li>配置連接參數, 2.配置連接池, 3.配置連接工廠 4.配置模板;</li></ol><p>相比之下: SpringDataJPA做的事情更多一些,它沒有直接提供給你一個模板,而是編寫了一個默認實現,你只要讓你的dao實現了JPARepository / JpaSpecificationExecutor , 在配上 jpa掃描:</p><p>&lt;jpa:repositories base-package="cn.itcast.bos.dao" /></p><p>在你注入這個包下的對象時,它就會判斷你是否繼承了 JPARepository / JpaSpecificationExecutor 這些接口,如果繼承了,那麼它會利用AOP返給你一個默認實現的類,而在這個類中,已經給我們默認實現了一些CRUD常用操作,所以避免了常用CRUD操作的方法編寫;</p><div class=pgc-img><img alt=各種配置文件總結 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1534392036166ddc12edbb5><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>配置文件</a></li><li><a>各種</a></li><li><a>總結</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/15b15eed.html alt=國外各種奇特的房事方式總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/7135/5806912548 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15b15eed.html title=國外各種奇特的房事方式總結>國外各種奇特的房事方式總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/794014a.html alt=最全MyBatis核心配置文件總結，可以作為工具先收藏了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8b86d270726a4e139c85ca61e7458d7d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/794014a.html title=最全MyBatis核心配置文件總結，可以作為工具先收藏了>最全MyBatis核心配置文件總結，可以作為工具先收藏了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html alt=各種門窗知識大全，是我見過最全的了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349013240149cf1ef5531 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html title=各種門窗知識大全，是我見過最全的了>各種門窗知識大全，是我見過最全的了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html alt="技術帖 | 3分鐘搞定各種測試分析技術" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f055e0a4477240088de2abb7cd696cfa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html title="技術帖 | 3分鐘搞定各種測試分析技術">技術帖 | 3分鐘搞定各種測試分析技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a2f47a.html alt=識別各種各樣的電纜電線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3e680001e11c782e8928 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a2f47a.html title=識別各種各樣的電纜電線>識別各種各樣的電纜電線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html alt=從域名到網站，只需要四步！服務器網站搭建流程總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7c1999b5072844f6ac01ba234e4d4ee0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html title=從域名到網站，只需要四步！服務器網站搭建流程總結>從域名到網站，只需要四步！服務器網站搭建流程總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html alt=住宅工程各區域的淨高要求，總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/072079da-ec32-43b6-9dff-93cc7beb2bc3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html title=住宅工程各區域的淨高要求，總結>住宅工程各區域的淨高要求，總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html alt=住宅工程各區域的淨高要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/27a44170db2040adab26236e40605b1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html title=住宅工程各區域的淨高要求，總結！>住宅工程各區域的淨高要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html alt=住宅工程各類淨高的規範要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cff80b0991246f69fb67d91590b1d95 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html title=住宅工程各類淨高的規範要求，總結！>住宅工程各類淨高的規範要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4df1d2c4.html alt=飛行裡的各種“高度”小總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/895f051cf5e2438aa63b08f44bd1cbff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4df1d2c4.html title=飛行裡的各種“高度”小總結>飛行裡的各種“高度”小總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12c5d155.html alt=防控新冠病毒的的各種“新”方法，靠譜不 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/987bbc71-1082-4586-875c-b97870275bbb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12c5d155.html title=防控新冠病毒的的各種“新”方法，靠譜不>防控新冠病毒的的各種“新”方法，靠譜不</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html alt=初三主要化學方程式按元素歸類總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fcca062886ed4b9db272cb3cb66710e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html title=初三主要化學方程式按元素歸類總結>初三主要化學方程式按元素歸類總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html alt=按照元素分類總結的高中化學方程式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/568b4c62f05c406c86ba3a1a3f1536f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html title=按照元素分類總結的高中化學方程式>按照元素分類總結的高中化學方程式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0903fbf9.html alt=常見的調整浪：三角形的各種變形圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/57c439a06ccf4f9f93d01541668817b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0903fbf9.html title=常見的調整浪：三角形的各種變形圖解>常見的調整浪：三角形的各種變形圖解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>