<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>社區投稿 | MySQL 層事務提交流程簡析 | 极客快訊</title><meta property="og:title" content="社區投稿 | MySQL 層事務提交流程簡析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1b33dc60658b44448691120ae3608081"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7319932.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7319932.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7319932.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7319932.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7319932.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7319932.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7319932.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7319932.html><meta property="article:published_time" content="2020-10-29T20:50:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:42+08:00"><meta name=Keywords content><meta name=description content="社區投稿 | MySQL 層事務提交流程簡析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7319932.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>社區投稿 | MySQL 層事務提交流程簡析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>原創作者：高鵬</p></blockquote><p>本文提要</p><p>本節將解釋 MySQL 層詳細的提交流程，但是由於能力有限，這裡不可能包含全部的步驟，只是包含了一些重要的、並且我學習過的步驟。</p><p>我們首先需要來假設參數設置，因為某些參數的設置會直接影響到提交流程，我們也會逐一解釋這些參數的含義。</p><p>本節介紹的大部分內容都集中在函數 MYSQL_BIN_LOG::prepare和MYSQL_BIN_LOG::ordered_commit 之中。</p><p><strong>一、參數設置</strong></p><p>本部分假定參數設置為：</p><ul><li class=ql-align-justify>binlog_group_commit_sync_delay：0</li><li class=ql-align-justify>binlog_group_commit_sync_no_delay_count：0</li><li class=ql-align-justify>binlog_order_commits：ON</li><li class=ql-align-justify>sync_binlog：1</li><li class=ql-align-justify>binlog_transaction_dependency_tracking：COMMIT_ORDER</li></ul><p>關於參數 binlog_transaction_dependency_tracking 需要重點說明一下。我們知道 Innodb 的行鎖是在語句運行期間就已經獲取，因此如果多個事務同時進入了提交流程（prepare階段），在 Innodb 層提交釋放 Innodb 行鎖資源之前各個事務之間肯定是沒有行衝突的，因此可以在從庫端並行執行。在基於 COMMIT_ORDER 的並行複製中，last commit 和 seq number 正是基於這種思想生成的，如果 last commit 相同則視為可以在從庫並行回放，在19節我們將解釋從庫判定並行回放的規則。而在基於 WRITESET 的並行複製中，last commit 將會在 WRITESET 的影響下繼續降低，來使從庫獲得更好的並行回放效果，但是它也是 COMMIT_ORDER 為基礎的，這個下一節將討論。我們這節只討論基於COMMIT_ORDER 的並行複製中 last commit 和 seq number 的生成方式。</p><p>而sync_binlog參數則有兩個功能：</p><ul><li class=ql-align-justify>sync_binlog=0：binary log 不 sync 刷盤，依賴於 OS 刷盤機制。同時會在flush階段後通知DUMP線程發送Event。</li><li class=ql-align-justify>sync_binlog=1：binary log 每次 sync 隊列形成後都進行sync刷盤，約等於每次group commit 進行刷盤。同時會在 sync 階段後通知DUMP線程發送 Event。注意sync_binlog 非1的設置可能導致從庫比主庫多事務。</li><li class=ql-align-justify>sync_binlog>1：binary log 將在指定次 sync 隊列形成後進行 sync 刷盤，約等於指定次 group commit 後刷盤。同時會在 flush 階段後通知 DUMP 線程發送 Event。</li></ul><p>第二功能將在第17節還會進行介紹。</p><p><strong>二、總體流程圖</strong></p><p>這裡我們先展示整個流程，如下（圖15-1，高清原圖包含在文末原圖中）：</p><div class=pgc-img><img alt="社區投稿 | MySQL 層事務提交流程簡析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1b33dc60658b44448691120ae3608081><p class=pgc-img-caption></p></div><p><strong>三、步驟解析第一階段（圖中藍色部分）</strong></p><p><strong>注意：</strong>在第1步之前會有一個獲取 MDL_key::COMMIT 鎖的操作，因此 FTWRL 將會堵塞 commit 操作，堵塞狀態為 Waiting for commit lock ，這個可以參考 FTWRL 調用的函數make_global_read_lock_block_commit。</p><p>（1）binlog 準備。將上一次 COMMIT 隊列中最大的 seq number 寫入到本次事務的 last_commit 中。可參考 binlog_prepare 函數。</p><p>（2）Innodb 準備。更改事務的狀態為準備並且將事務的狀態和 XID 寫入到 Undo 中。可參考 trx_prepare 函數。</p><p>（3）XID_EVENT 生成並且寫到 binlog cache 中。在第10節中我們說過實際上 XID 來自於query_id，早就生成了，這裡只是生成Event而已。可參考 MYSQL_BIN_LOG::commit 函數。</p><p><strong>四、步驟解析第二階段（圖中粉色部分）</strong></p><p>（4）形成 FLUSH 隊列。這一步正在不斷的有事務加入到這個 FLUSH 隊列。第一個進入 FLUSH 隊列的為本階段的 leader，非 leader 線程將會堵塞，直到 COMMIT 階段後由 leader 線程的喚醒。</p><p>（5）獲取 LOCK log 鎖。</p><p>（6）這一步就是將 FLUSH 階段的隊列取出來準備進行處理。也就是這個時候本 FLUSH 隊列就不能在更改了。可參考 stage_manager.fetch_queue_for 函數。</p><p>（7）這裡事務會進行 Innodb 層的 redo 持久化，並且會幫助其他事務進行 redo 的持久化。可以參考 MYSQL_BIN_LOG::process_flush_stage_queue 函數。下面是註釋和一小段代碼：</p><pre>/* We flush prepared records of transactions to the log of storage engine (for example, InnoDB redo log) in a group right before flushing them to binary log.*/ha_flush_logs(NULL, true);//做innodb redo持久化</pre><p>（8）生成 GTID 和 seq number ，並且連同前面的 last commit 生成 GTID_EVENT ，然後直接寫入到 binary log 中。我們注意到這裡直接寫入到了 binary log 而沒有寫入到 binlog cache ，因此 GTID_EVENT 是事務的第一個 Event 。參考函數 binlog_cache_data::flush 中下面一段：</p><pre>trn_ctx-&gt;sequence_number= mysql_bin_log.m_dependency_tracker.step();//int64 state +1... if (!error) if ((error= mysql_bin_log.write_gtid(thd, this, &amp;writer)))//生成GTID 寫入binary log文件 thd-&gt;commit_error= THD::CE_FLUSH_ERROR; if (!error) error= mysql_bin_log.write_cache(thd, this, &amp;writer);//將其他Event寫入到binary log文件</pre><p>而對於 seq number 和 last commit 的取值來講，實際上在 MySQL 內部維護著一個全局的結構 Transaction_dependency_tracker。其中包含三種可能取值方式，如下 ：</p><ul><li class=ql-align-justify>Commit_order_trx_dependency_tracker</li><li class=ql-align-justify>Writeset_trx_dependency_tracker</li><li class=ql-align-justify>Writeset_session_trx_dependency_tracker</li></ul><p>到底使用哪一種取值方式，由參數 binlog_transaction_dependency_tracking 來決定的。這裡我們先研究參數設置為 COMMIT_ORDER 的取值方式，對於 WRITESET 取值的方式下一節專門討論。</p><p>對於設置為 COMMIT_ORDER 會使用 Commit_order_trx_dependency_tracker 的取值方式，有如下特點：</p><div class=pgc-img><img alt="社區投稿 | MySQL 層事務提交流程簡析" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5e776264e95840e3beecd9689cecc5f6><p class=pgc-img-caption></p></div><p>其次 seq number 和 last commit 這兩個值類型都為 Logical_clock ，其中維護了一個叫做 offsets 偏移量的值，用來記錄每次binary log切換時 sequence_number 的相對偏移量。因此 seq number 和 last commit 在每個 binary log 總是重新計數，下面是 offset 的源碼註釋：</p><pre>/* Offset is subtracted from the actual "absolute time" value at logging a replication event. That is the event holds logical timestamps in the "relative" format. They are meaningful only in the context of the current binlog. The member is updated (incremented) per binary log rotation.*/int64 offset;</pre><p>下面是我們計算 seq number 的方式，可以參考 Commit_order_trx_dependency_tracker::get_dependency 函數。</p><pre> sequence_number= trn_ctx-&gt;sequence_number - m_max_committed_transaction.get_offset();//這裡獲取seq number</pre><p>我們清楚的看到這裡有一個減去 offset 的操作，這也是為什麼我們的 seq number 和 last commit 在每個 binary log 總是重新計數的原因。</p><p>（9）這一步就會將我們的 binlog cache 裡面的所有Event寫入到我們的 binary log 中了。對於一個事務來講，我們這裡應該很清楚這裡包含的Event有：</p><ul><li class=ql-align-justify>QUERY_EVENT</li><li class=ql-align-justify>MAP_EVENT</li><li class=ql-align-justify>DML EVENT</li><li class=ql-align-justify>XID_EVENT</li></ul><p>注意 GTID_EVENT 前面已經寫入到的 binary logfile 。這裡我說的寫入是調用的 Linux 的 write 函數，正常情況下它會進入圖中的 OS CACHE 中。實際上這個時候可能還沒有真正寫入到磁盤介質中。</p><p>重複 7 ~ 9步 把FLUSH隊列中所有的事務做同樣的處理。</p><p><strong>注意：</strong>如果 sync_binlog != 1 這裡將會喚醒 DUMP 線程進行 Event 的發送。</p><p>（10）這一步還會判斷 binary log 是否需要切換，並且設置一個切換標記。依據就是整個隊列每個事務寫入的 Event 總量加上現有的 binary log 大小是否超過了 max_binlog_size。可參考 MYSQL_BIN_LOG::process_flush_stage_queue函數，如下部分：</p><pre> if (total_bytes &gt; 0 &amp;&amp; my_b_tell(&amp;log_file) &gt;= (my_off_t) max_size) *rotate_var= true; //標記需要切換</pre><p>但是注意這裡是先將所有的 Event 寫入 binary log ，然後才進行的判斷。因此對於大事務來講其 Event 肯定都包含在同一個 binary log 中。</p><p>到這裡 FLUSH 階段就結束了。</p><p><strong>五、步驟解析第三階段（圖中紫色部分）</strong></p><p>（11）FLUSH 隊列加入到 SYNC 隊列。第一個進入的 FLUSH 隊列的 leader 為本階段的leader。其他 FLUSH 隊列加入 SYNC 隊列，且其他FLUSH隊列的leader會被 LOCK sync 堵塞，直到 COMMIT 階段後由 leader 線程的喚醒。</p><p>（12）釋放 LOCK log。</p><p>（13）獲取 LOCK sync。</p><p>（14）這裡根據參數 delay 的設置來決定是否等待一段時間。我們從圖中我們可以看出如果 delay 的時間越久那麼加入 SYNC 隊列的時間就會越長，也就可能有更多的 FLUSH 隊列加入進來，那麼這個 SYNC 隊列的事務就越多。這不僅會提高 sync 效率，並且增大了 GROUP COMMIT 組成員的數量<strong>（因為 last commit 還沒有更改，時間拖得越長那麼一組事務中事務數量就越多）</strong>，從而提高了從庫MTS的並行效率。但是缺點也很明顯可能導致簡單的 DML 語句時間拖長，因此不能設置過大，下面是我簡書中的一個案列就是因為delay參數設置不當引起的，如下：</p><p>https://www.jianshu.com/p/bfd4a88307f2</p><p>參數delay一共包含兩個參數如下：</p><ul><li class=ql-align-justify>binlog_group_commit_sync_delay：通過人為的設置 delay 時長來加大整個 GROUP COMMIT 組中事務數量，並且減少進行磁盤刷盤 sync 的次數，但是受到 binlog_group_commit_sync_no_delay_count 的限制。單位為1/1000000秒，最大值1000000也就是1秒。</li><li class=ql-align-justify>binlog_group_commit_sync_no_delay_count：在 delay 的時間內如果 GROUP COMMIT 中的事務數量達到了這個設置就直接跳出等待，而不需要等待 binlog_group_commit_sync_delay 的時長。單位是事務的數量。</li></ul><p>（15）這一步就是將 SYNC 階段的隊列取出來準備進行處理。也就是這個時候 SYNC 隊列就不能再更改了。這個隊列和 FLUSH 隊列並不一樣，事務的順序一樣但是數量可能不一樣。</p><p>（16）根據 sync_binlog 的設置決定是否刷盤。可以參考函數 MYSQL_BIN_LOG::sync_binlog_file ，邏輯也很簡單。</p><p>到這裡 SYNC 階段就結束了。</p><p><strong>注意：</strong>如果 sync_binlog = 1 這裡將會喚醒 DUMP 線程進行 Event 的發送。</p><p><strong>六、步驟解析第四階段（圖中黃色部分）</strong></p><p>（17）SYNC 隊列加入到 COMMIT 隊列。第一個進入的 SYNC 隊列的 leader 為本階段的 leader 。其他 SYNC 隊列加入 COMMIT 隊列，且其他 SYNC 隊列的 leader 會被 LOCK commit 堵塞，直到 COMMIT 階段後由leader線程的喚醒。</p><p>（18）釋放 LOCK sync 。</p><p>（19）獲取 LOCK commit 。</p><p>（20）根據參數 binlog_order_commits 的設置來決定是否按照隊列的順序進行 Innodb 層的提交，如果 binlog_order_commits=1 則按照隊列順序提交則事務的可見順序和提交順序一致。如果 binlog_order_commits=0 則下面21步到23步將不會進行，也就是這裡不會進行 Innodb 層的提交。</p><p>（21）這一步就是將 COMMIT 階段的隊列取出來準備進行處理。也就是這個時候 COMMIT 隊列就不能在更改了。這個隊列和 FLUSH 隊列和 SYNC 隊列並不一樣，事務的順序一樣，數量可能不一樣。</p><p><strong>注意：</strong>如果 rpl_semi_sync_master_wait_point 參數設置為 AFTERSYNC ，這裡將會進行 ACK 確認，可以看到實際的 Innodb 層提交操作還沒有進行，等待期間狀態為 Waiting for semi-sync ACK from slave 。</p><p>（22）在 Innodb 層提交之前必須要更改 last_commit 了。COMMIT 隊列中每個事務都會去更新它，如果大於則更改，小於則不變。可參考Commit_order_trx_dependency_tracker::update_max_committed 函數，下面是這一小段代碼：</p><pre>{ m_max_committed_transaction.set_if_greater(sequence_number);//如果更大則更改}</pre><p>（23）COMMI T隊列中每個事務按照順序進行 Innodb 層的提交。可參考 innobase_commit 函數。</p><p>這一步 Innodb 層會做很多動作，比如：</p><ul><li class=ql-align-justify>Readview 的更新</li><li class=ql-align-justify>Undo 的狀態的更新</li><li class=ql-align-justify>Innodb 鎖資源的釋放</li></ul><p>完成這一步，實際上在 Innodb 層事務就可以見了。我曾經遇到過一個由於 leader 線程喚醒本組其他線程出現問題而導致整個 commit 操作 hang 住，但是在數據庫中這些事務的修改已經可見的案例。</p><p>循環22~23直到 COMMIT 隊列處理完。</p><p><strong>注意：</strong>如果 rpl_semi_sync_master_wait_point 參數設置為 AFTER_COMMIT ，這裡將會進行 ACK 確認，可以看到實際的Innodb層提交操作已經完成了，等待期間狀態為 Waiting for semi-sync ACK from slave 。</p><p>（24） 釋放 LOCK commit。</p><p>到這裡 COMMIT 階段就結束了。</p><p><strong>七、步驟解析第五階段（圖中綠色部分）</strong></p><p>（25）這裡 leader 線程會喚醒所有的組內成員，各自進行各自的操作了。</p><p>（26）每個事務成員進行 binlog cache 的重置，清空 cache 釋放臨時文件。</p><p>（27）如果 binlog_order_commits 設置為0，COMMIT 隊列中的每個事務就各自進行 Innodb 層提交（不按照 binary log 中事務的的順序）。</p><p>（28）根據前面第10步設置的切換標記，決定是否進行 binary log 切換。</p><p>（29）如果切換了 binary log，則還需要根據 expire_logs_days 的設置判斷是否進行 binlog log 的清理。</p><p><strong>八、總結</strong></p><ul><li class=ql-align-justify>整個過程我們看到生成 last commit 和 seq number 的過程並沒有其它的開銷，但是下一節介紹的基於 WRITESET 的並行複製就有一定的開銷了。</li><li class=ql-align-justify>我們需要明白的是 FLUSH/SYNC/COMMIT 每一個階段都有一個相應的隊列，每個隊列並不一樣。但是其中的事務順序卻是一樣的，是否能夠在從庫進行並行回放完全取決於準備階段獲取的 last_commit ，這個我們將在第19節詳細描述。</li><li class=ql-align-justify>對於 FLUSH/SYNC/COMMIT 三個隊列事務的數量實際有這樣關係，即 COMMIT 隊列 >=SYNC隊列>=FLUSH 隊列。如果壓力不大它們三者可能相同且都只包含一個事務。</li><li class=ql-align-justify>從流程中可以看出基於 COMMIT_ORDER 的並行複製如果數據庫壓力不大的情況下可能出現每個隊列都只有一個事務的情況。這種情況就不能在從庫並行回放了，但是下一節我們講的基於WRITESET的並行複製卻可以改變這種情況。</li><li class=ql-align-justify>這裡我們也更加明顯的看到大事務的 Event 會在提交時刻一次性的寫入到 binary log 。如果 COMMIT 隊列中包含了大事務，那麼必然堵塞本隊列中的其它事務提交，後續的提交操作也不能完成。我認為這也是 MySQL 不適合大事務的一個重要原因。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>社區</a></li><li><a>MySQL</a></li><li><a>層事務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html alt="圖解MySQL | 「原理解析」 MySQL組提交(group commit)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e5444e9094614d6b88bd3fc8ac0524fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html title="圖解MySQL | 「原理解析」 MySQL組提交(group commit)">圖解MySQL | 「原理解析」 MySQL組提交(group commit)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html alt=MySQL系列-第14篇：事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html title=MySQL系列-第14篇：事務詳解>MySQL系列-第14篇：事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html alt=MySQL進階之InnoDB事務原子性實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e1d208ac-c0ed-4238-bce5-e4b3760228c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html title=MySQL進階之InnoDB事務原子性實現原理>MySQL進階之InnoDB事務原子性實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d11f8f6a.html alt=對於“社區”和“韌性”的概念探討 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SG7kbohSBCm3V style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d11f8f6a.html title=對於“社區”和“韌性”的概念探討>對於“社區”和“韌性”的概念探討</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html alt="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html title="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務">技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html alt=深入學習MySQL事務：ACID特性的實現原理「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cdc702d66d6943499997d11e931425eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html title=深入學習MySQL事務：ACID特性的實現原理「轉」>深入學習MySQL事務：ACID特性的實現原理「轉」</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>