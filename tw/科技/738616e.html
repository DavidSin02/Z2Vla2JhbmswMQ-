<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>簡說設計模式之設計模式概述 | 极客快訊</title><meta property="og:title" content="簡說設計模式之設計模式概述 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/1b30f3e2a7f142c0b14470e6e23fa214"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/738616e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/738616e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/738616e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/738616e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/738616e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/738616e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/738616e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/738616e.html><meta property="article:published_time" content="2020-10-29T20:58:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:42+08:00"><meta name=Keywords content><meta name=description content="簡說設計模式之設計模式概述"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/738616e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>簡說設計模式之設計模式概述</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=簡說設計模式之設計模式概述 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1b30f3e2a7f142c0b14470e6e23fa214><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right>一、軟件設計模式的概念與意義</h2><h4 class=pgc-h-arrow-right>1. 軟件設計模式的概念</h4><p>軟件設計模式（Software Design Pattern），又稱設計模式，是一套被反覆使用、多數人知曉的、經過分類編目的、代碼設計經驗的總結。它描述了在軟件設計過程中的一些不斷重複發生的問題，以及該問題的解決方案。也就是說，它是解決特定問題的一系列套路，是前輩們的代碼設計經驗的總結，具有一定的普遍性，可以反覆使用。其目的是為了提高代碼的可重用性、代碼的可讀性和代碼的可靠性。</p><h4 class=pgc-h-arrow-right>2. 學習設計模式的意義</h4><p>設計模式的本質是面向對象設計原則的實際運用，是對類的封裝性、繼承性和多態性以及類的關聯關係和組合關係的充分理解。正確使用設計模式具有以下優點。</p><ul><li>可以提高程序員的思維能力、編程能力和設計能力。</li><li>使程序設計更加標準化、代碼編制更加工程化，使軟件開發效率大大提高，從而縮短軟件的開發週期。</li><li>使設計的代碼可重用性高、可讀性強、可靠性高、靈活性好、可維護性強。</li></ul><h2 class=pgc-h-arrow-right>二、軟件設計模式的基本要素</h2><p>軟件設計模式使人們可以更加簡單方便地複用成功的設計和體系結構，它通常包含以下幾個基本要素：模式名稱、別名、動機、問題、解決方案、效果、結構、模式角色、合作關係、實現方法、適用性、已知應用、例程、模式擴展和相關模式等，其中最關鍵的元素包括以下 4 個主要部分。</p><h4 class=pgc-h-arrow-right>1. 模式名稱</h4><p>每一個模式都有自己的名字，通常用一兩個詞來描述，可以根據模式的問題、特點、解決方案、功能和效果來命名。模式名稱（PatternName）有助於我們理解和記憶該模式，也方便我們來討論自己的設計。</p><h4 class=pgc-h-arrow-right>2. 問題</h4><p>問題（Problem）描述了該模式的應用環境，即何時使用該模式。它解釋了設計問題和問題存在的前因後果，以及必須滿足的一系列先決條件。</p><h4 class=pgc-h-arrow-right>3. 解決方案</h4><p>模式問題的解決方案（Solution）包括設計的組成成分、它們之間的相互關係及各自的職責和協作方式。因為模式就像一個模板，可應用於多種不同場合，所以解決方案並不描述一個特定而具體的設計或實現，而是提供設計問題的抽象描述和怎樣用一個具有一般意義的元素組合（類或對象的 組合）來解決這個問題。</p><h4 class=pgc-h-arrow-right>4. 效果</h4><p>描述了模式的應用效果以及使用該模式應該權衡的問題，即模式的優缺點。主要是對時間和空間的衡量，以及該模式對系統的靈活性、擴充性、可移植性的影響，也考慮其實現問題。顯式地列出這些效果（Consequence）對理解和評價這些模式有很大的幫助。</p><h2 class=pgc-h-arrow-right>三、面向對象設計原則</h2><p>在軟件開發中，為了提高軟件系統的可維護性和可複用性，增加軟件的可擴展性和靈活性，程序員要儘量根據 7 條原則來開發程序，從而提高軟件開發效率、節約軟件開發成本和維護成本。我們將在下面依次來介紹這 7 條原則。</p><h4 class=pgc-h-arrow-right>1. 開閉原則</h4><h5 class=pgc-h-arrow-right>1.1 開閉原則的定義</h5><p>開閉原則（Open Closed Principle，OCP）由勃蘭特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向對象軟件構造》（Object Oriented Software Construction）中提出：軟件實體應當對擴展開放，對修改關閉（Software entities should be open for extension，but closed for modification），這就是開閉原則的經典定義。</p><p>開閉原則的含義是：當應用的需求改變時，在不修改軟件實體的源代碼或者二進制代碼的前提下，可以擴展模塊的功能，使其滿足新的需求。開閉原則是面向對象程序設計的終極目標</p><h5 class=pgc-h-arrow-right>1.2 開閉原則的作用</h5><h6 class=pgc-h-arrow-right>1. 對軟件測試的影響</h6><p>軟件遵守開閉原則的話，軟件測試時只需要對擴展的代碼進行測試就可以了，因為原有的測試代碼仍然能夠正常運行。</p><h6 class=pgc-h-arrow-right>2. 可以提高代碼的可複用性</h6><p>粒度越小，被複用的可能性就越大；在面向對象的程序設計中，根據原子和抽象編程可以提高代碼的可複用性。</p><h6 class=pgc-h-arrow-right>3. 可以提高軟件的可維護性</h6><p>遵守開閉原則的軟件，其穩定性高和延續性強，從而易於擴展和維護。</p><h5 class=pgc-h-arrow-right>1.3 開閉原則的實現方法</h5><p>可以通過“抽象約束、封裝變化”來實現開閉原則，即通過接口或者抽象類為軟件實體定義一個相對穩定的抽象層，而將相同的可變因素封裝在相同的具體實現類中。</p><h4 class=pgc-h-arrow-right>2. 里氏替換原則</h4><h5 class=pgc-h-arrow-right>2.1 里氏替換原則定義</h5><p>里氏替換原則（Liskov Substitution Principle，LSP）由麻省理工學院計算機科學實驗室的里斯科夫（Liskov）女士在 1987 年的“面向對象技術的高峰會議”（OOPSLA）上發表的一篇文章《數據抽象和層次》（Data Abstraction and Hierarchy）裡提出來的，她提出：繼承必須確保超類所擁有的性質在子類中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><p>里氏替換原則主要闡述了有關繼承的一些原則，也就是什麼時候應該使用繼承，什麼時候不應該使用繼承，以及其中蘊含的原理。里氏替換原是繼承複用的基礎，它反映了基類與子類之間的關係，是對開閉原則的補充，是對實現抽象化的具體步驟的規範。</p><h5 class=pgc-h-arrow-right>2.2 里氏替換原則的作用</h5><ol start=1><li>里氏替換原則是實現開閉原則的重要方式之一。</li><li>它克服了繼承中重寫父類造成的可複用性變差的缺點。</li><li>它是動作正確性的保證。即類的擴展不會給已有的系統引入新的錯誤，降低了代碼出錯的可能性</li></ol><h5 class=pgc-h-arrow-right>2.3 里氏替換原則的實現方法</h5><p>里氏替換原則通俗來講就是：子類可以擴展父類的功能，但不能改變父類原有的功能。也就是說：子類繼承父類時，除添加新的方法完成新增功能外，儘量不要重寫父類的方法。</p><h4 class=pgc-h-arrow-right>3. 依賴倒置原則</h4><h5 class=pgc-h-arrow-right>3.1 依賴倒置原則定義</h5><p>依賴倒置原則（Dependence Inversion Principle，DIP）是 Object Mentor 公司總裁羅伯特·馬丁（Robert C.Martin）於 1996 年在 C++ Report 上發表的文章。</p><p>依賴倒置原則的原始定義為：高層模塊不應該依賴低層模塊，兩者都應該依賴其抽象；抽象不應該依賴細節，細節應該依賴抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要面向接口編程，不要面向實現編程。</p><p>依賴倒置原則是實現開閉原則的重要途徑之一，它降低了客戶與實現模塊之間的耦合。</p><h5 class=pgc-h-arrow-right>3.2 依賴、倒置原則的作用</h5><ul><li>依賴倒置原則可以降低類間的耦合性。</li><li>依賴倒置原則可以提高系統的穩定性。</li><li>依賴倒置原則可以減少並行開發引起的風險。</li><li>依賴倒置原則可以提高代碼的可讀性和可維護性。</li></ul><h5 class=pgc-h-arrow-right>3.3 依賴倒置原則的實現方法</h5><p>依賴倒置原則的目的是通過要面向接口的編程來降低類間的耦合性，所以我們在實際編程中只要遵循以下4點，就能在項目中滿足這個規則。</p><ol start=1><li>每個類儘量提供接口或抽象類，或者兩者都具備。</li><li>變量的聲明類型儘量是接口或者是抽象類。</li><li>任何類都不應該從具體類派生。</li><li>使用繼承時儘量遵循里氏替換原則。</li></ol><h4 class=pgc-h-arrow-right>4. 單一職責原則</h4><h5 class=pgc-h-arrow-right>4.1 單一職責原則的定義</h5><p>單一職責原則（Single Responsibility Principle，SRP）又稱單一功能原則，由羅伯特·C.馬丁（Robert C. Martin）於《敏捷軟件開發：原則、模式和實踐》一書中提出的。這裡的職責是指類變化的原因，單一職責原則規定一個類應該有且僅有一個引起它變化的原因，否則類應該被拆分（There should never be more than one reason for a class to change）。</p><p>該原則提出對象不應該承擔太多職責，如果一個對象承擔了太多的職責，至少存在以下兩個缺點：</p><ol start=1><li>一個職責的變化可能會削弱或者抑制這個類實現其他職責的能力；</li><li>當客戶端需要該對象的某一個職責時，不得不將其他不需要的職責全都包含進來，從而造成冗餘代碼或代碼的浪費。</li></ol><h5 class=pgc-h-arrow-right>4.2 單一職責原則的優點</h5><ul><li>降低類的複雜度。一個類只負責一項職責，其邏輯肯定要比負責多項職責簡單得多。</li><li>提高類的可讀性。複雜性降低，自然其可讀性會提高。</li><li>提高系統的可維護性。可讀性提高，那自然更容易維護了。</li><li>變更引起的風險降低。變更是必然的，如果單一職責原則遵守得好，當修改一個功能時，可以顯著降低對其他功能的影響。</li></ul><h5 class=pgc-h-arrow-right>4.3 單一職責原則的實現方法</h5><p>單一職責原則是最簡單但又最難運用的原則，需要設計人員發現類的不同職責並將其分離，再封裝到不同的類或模塊中。而發現類的多重職責需要設計人員具有較強的分析設計能力和相關重構經驗。下面以大學學生工作管理程序為例介紹單一職責原則的應用。</p><h4 class=pgc-h-arrow-right>5. 接口隔離原則</h4><h5 class=pgc-h-arrow-right>5.1 接口隔離原則的定義</h5><p>接口隔離原則（Interface Segregation Principle，ISP）要求程序員儘量將臃腫龐大的接口拆分成更小的和更具體的接口，讓接口中只包含客戶感興趣的方法。</p><p>2002 年羅伯特·C.馬丁給“接口隔離原則”的定義是：客戶端不應該被迫依賴於它不使用的方法（Clients should not be forced to depend on methods they do not use）。該原則還有另外一個定義：一個類對另一個類的依賴應該建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。</p><p>以上兩個定義的含義是：要為各個類建立它們需要的專用接口，而不要試圖去建立一個很龐大的接口供所有依賴它的類去調用。</p><p>接口隔離原則和單一職責都是為了提高類的內聚性、降低它們之間的耦合性，體現了封裝的思想，但兩者是不同的：</p><ul><li>單一職責原則注重的是職責，而接口隔離原則注重的是對接口依賴的隔離。</li><li>單一職責原則主要是約束類，它針對的是程序中的實現和細節；接口隔離原則主要約束接口，主要針對抽象和程序整體框架的構建。</li></ul><h5 class=pgc-h-arrow-right>5.2 接口隔離原則的優點</h5><ol start=1><li>將臃腫龐大的接口分解為多個粒度小的接口，可以預防外來變更的擴散，提高系統的靈活性和可維護性。</li><li>接口隔離提高了系統的內聚性，減少了對外交互，降低了系統的耦合性。</li><li>如果接口的粒度大小定義合理，能夠保證系統的穩定性；但是，如果定義過小，則會造成接口數量過多，使設計複雜化；如果定義太大，靈活性降低，無法提供定製服務，給整體項目帶來無法預料的風險。</li><li>使用多個專門的接口還能夠體現對象的層次，因為可以通過接口的繼承，實現對總接口的定義。</li><li>能減少項目工程中的代碼冗餘。過大的大接口裡面通常放置許多不用的方法，當實現這個接口的時候，被迫設計冗餘的代碼。</li></ol><h5 class=pgc-h-arrow-right>5.3 接口隔離原則的實現方法</h5><ul><li>接口儘量小，但是要有限度。一個接口只服務於一個子模塊或業務邏輯。</li><li>為依賴接口的類定製服務。只提供調用者需要的方法，屏蔽不需要的方法。</li><li>瞭解環境，拒絕盲從。每個項目或產品都有選定的環境因素，環境不同，接口拆分的標準就不同深入瞭解業務邏輯。</li><li>提高內聚，減少對外交互。使接口用最少的方法去完成最多的事情。</li></ul><h4 class=pgc-h-arrow-right>6. 迪米特法則</h4><h5 class=pgc-h-arrow-right>6.1 迪米特法則的定義</h5><p>迪米特法則（Law of Demeter，LoD）又叫作最少知識原則（Least Knowledge Principle，LKP)，產生於 1987 年美國東北大學（Northeastern University）的一個名為迪米特（Demeter）的研究項目，由伊恩·荷蘭（Ian Holland）提出，被 UML 創始者之一的布奇（Booch）普及，後來又因為在經典著作《程序員修煉之道》（The Pragmatic Programmer）提及而廣為人知。</p><p>迪米特法則的定義是：只與你的直接朋友交談，不跟“陌生人”說話（Talk only to your immediate friends and not to strangers）。其含義是：如果兩個軟件實體無須直接通信，那麼就不應當發生直接的相互調用，可以通過第三方轉發該調用。其目的是降低類之間的耦合度，提高模塊的相對獨立性。</p><p>迪米特法則中的“朋友”是指：當前對象本身、當前對象的成員對象、當前對象所創建的對象、當前對象的方法參數等，這些對象同當前對象存在關聯、聚合或組合關係，可以直接訪問這些對象的方法。</p><h5 class=pgc-h-arrow-right>6.2 迪米特法則的優點</h5><ul><li>降低了類之間的耦合度，提高了模塊的相對獨立性。</li><li>由於親合度降低，從而提高了類的可複用率和系統的擴展性。</li></ul><p>但是，過度使用迪米特法則會使系統產生大量的中介類，從而增加系統的複雜性，使模塊之間的通信效率降低。所以，在釆用迪米特法則時需要反覆權衡，確保高內聚和低耦合的同時，保證系統的結構清晰。</p><h5 class=pgc-h-arrow-right>6.3 迪米特法則的實現方法</h5><p>從迪米特法則的定義和特點可知，它強調以下兩點：</p><ol start=1><li>從依賴者的角度來說，只依賴應該依賴的對象。</li><li>從被依賴者的角度說，只暴露應該暴露的方法。</li></ol><p>所以，在運用迪米特法則時要注意以下 6 點。</p><ol start=1><li>在類的劃分上，應該創建弱耦合的類。類與類之間的耦合越弱，就越有利於實現可複用的目標。</li><li>在類的結構設計上，儘量降低類成員的訪問權限。</li><li>在類的設計上，優先考慮將一個類設置成不變類。</li><li>在對其他類的引用上，將引用其他對象的次數降到最低。</li><li>不暴露類的屬性成員，而應該提供相應的訪問器（set 和 get 方法）。</li><li>謹慎使用序列化（Serializable）功能。</li></ol><h4 class=pgc-h-arrow-right>7. 合成複用原則</h4><h5 class=pgc-h-arrow-right>7.1 合成複用原則的定義</h5><p>合成複用原則（Composite Reuse Principle，CRP）又叫組合/聚合複用原則（Composition/Aggregate Reuse Principle，CARP）。它要求在軟件複用時，要儘量先使用組合或者聚合等關聯關係來實現，其次才考慮使用繼承關係來實現。</p><p>如果要使用繼承關係，則必須嚴格遵循里氏替換原則。合成複用原則同里氏替換原則相輔相成的，兩者都是開閉原則的具體實現規範。</p><h5 class=pgc-h-arrow-right>7.2 合成複用原則的重要性</h5><p>通常類的複用分為繼承複用和合成複用兩種，繼承複用雖然有簡單和易實現的優點，但它也存在以下缺點。</p><ol start=1><li>繼承複用破壞了類的封裝性。因為繼承會將父類的實現細節暴露給子類，父類對子類是透明的，所以這種複用又稱為“白箱”複用。</li><li>子類與父類的耦合度高。父類的實現的任何改變都會導致子類的實現發生變化，這不利於類的擴展與維護。</li><li>它限制了複用的靈活性。從父類繼承而來的實現是靜態的，在編譯時已經定義，所以在運行時不可能發生變化。</li></ol><p>採用組合或聚合複用時，可以將已有對象納入新對象中，使之成為新對象的一部分，新對象可以調用已有對象的功能，它有以下優點。</p><ol start=1><li>它維持了類的封裝性。因為成分對象的內部細節是新對象看不見的，所以這種複用又稱為“黑箱”複用。</li><li>新舊類之間的耦合度低。這種複用所需的依賴較少，新對象存取成分對象的唯一方法是通過成分對象的接口。</li><li>複用的靈活性高。這種複用可以在運行時動態進行，新對象可以動態地引用與成分對象類型相同的對象。</li></ol><h5 class=pgc-h-arrow-right>7.3 合成複用原則的實現方法</h5><p>合成複用原則是通過將已有的對象納入新對象中，作為新對象的成員對象來實現的，新對象可以調用已有對象的功能，從而達到複用。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>設計</a></li><li><a>模式</a></li><li><a>簡說</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f93758.html alt=簡說設計模式之適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c5eda805f6914ff7ba90466f1fbf8941 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f93758.html title=簡說設計模式之適配器模式>簡說設計模式之適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/210ccbc7.html alt=設計模式專題07-適配模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/61e5bbbccefd445ca47e5ac95ad5c655 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/210ccbc7.html title=設計模式專題07-適配模式>設計模式專題07-適配模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48a6b6a.html alt="5 PHP 設計模式系列「對象池模式（Object Pool）」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29c712d86aa04c48ad6b0d262ed8026e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48a6b6a.html title="5 PHP 設計模式系列「對象池模式（Object Pool）」">5 PHP 設計模式系列「對象池模式（Object Pool）」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86177a0.html alt=「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/24bf1fc955de499183243bc4f9fb6120 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86177a0.html title=「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？>「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2463a2a.html alt=面向對象的可複用設計模式-裝飾模式（java代碼實現） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b27d2e0e6d6347d5aa5a0633d8867ea4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2463a2a.html title=面向對象的可複用設計模式-裝飾模式（java代碼實現）>面向對象的可複用設計模式-裝飾模式（java代碼實現）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1059237.html alt=面向對象的可複用設計模式之中介者模式（18/24） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4afbebaa300046e6be67c5085faaf5ac style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1059237.html title=面向對象的可複用設計模式之中介者模式（18/24）>面向對象的可複用設計模式之中介者模式（18/24）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a3ab9c.html alt=設計模式之對象池模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153421232504357f6330f7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a3ab9c.html title=設計模式之對象池模式>設計模式之對象池模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3756335.html alt=設計模式之空對象設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6ea14e17fa9b49ccaa5079bd6d256f1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3756335.html title=設計模式之空對象設計模式>設計模式之空對象設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d69059.html alt=設計模式實踐系列：面向對象經典的設計原則及設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d69059.html title=設計模式實踐系列：面向對象經典的設計原則及設計模式>設計模式實踐系列：面向對象經典的設計原則及設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a9b14d6.html alt=面向對象的可複用設計模式之裝飾模式（10/24） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/55017ba25c1a44e1a73201f0542b0858 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a9b14d6.html title=面向對象的可複用設計模式之裝飾模式（10/24）>面向對象的可複用設計模式之裝飾模式（10/24）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/298dfd0.html alt="JavaScript設計模式之適配器模式（Adaptor Pattern）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/eb26d1ff-cac4-452b-bd03-089b79157a6a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/298dfd0.html title="JavaScript設計模式之適配器模式（Adaptor Pattern）">JavaScript設計模式之適配器模式（Adaptor Pattern）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c5ca3c1.html alt=Java描述設計模式(07)：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3d0d9f42897848478e118ef916ba1624 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c5ca3c1.html title=Java描述設計模式(07)：適配器模式>Java描述設計模式(07)：適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc8c270.html alt=Java設計模式7：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4fb24e6568784c2bbc8b86a9a6f7027d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc8c270.html title=Java設計模式7：適配器模式>Java設計模式7：適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3bed020.html alt=Java設計模式之適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1a3bb08006b4da3b69b1e1c7fcee9fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3bed020.html title=Java設計模式之適配器模式>Java設計模式之適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/46f4759.html alt=Java設計模式（十四）：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5941000582d4f8ab6030 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/46f4759.html title=Java設計模式（十四）：適配器模式>Java設計模式（十四）：適配器模式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>