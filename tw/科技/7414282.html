<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>安全系列之——手寫 JAVA 加密、解密 | 极客快訊</title><meta property="og:title" content="安全系列之——手寫 JAVA 加密、解密 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fdba6af1e4e34df49ee3eebbc57123b4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7414282.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7414282.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7414282.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7414282.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7414282.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7414282.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7414282.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7414282.html><meta property="article:published_time" content="2020-10-29T20:52:29+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:29+08:00"><meta name=Keywords content><meta name=description content="安全系列之——手寫 JAVA 加密、解密"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7414282.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>安全系列之——手寫 JAVA 加密、解密</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>軟件的加密與解密是一個迷人的研究領域，它幾乎可以與任意一種計算機技術緊密結合——密碼學、程序設計語言、操作系統、數據結構。而由於這樣或者那樣的原因，對於這一領域的關注程度一直還處於低溫狀態。</p><p style=text-align:start>﻿</p><p style=text-align:start>網絡安全一般需要注意以下幾個關鍵點：</p><p style=text-align:start>﻿</p><ul><li>完整性（Integrity）：確保信息在傳輸過程中，沒有被篡改。</li></ul><p style=text-align:start>﻿</p><ul><li>私密性（Confidentiality）：也就是通過加密，確保只有可信的實體可以看到這些信息。</li></ul><p style=text-align:start>﻿</p><ul><li>源認證（Authenticity）：確保是可信的源發送了這些信息，而不是偽裝源發送的消息。</li><li>不可否認性（Nonrepudiation）：不能事後否認發送過這條信息。</li></ul><p style=text-align:start>﻿</p><p style=text-align:start>今天我們說的是數據傳輸的私密性。加密技術是最常用的安全保密手段，利用技術手段把重要的數據變為亂碼（加密）傳送，到達目的地後再用相同或不同的手段還原（解密）。</p><p style=text-align:start>﻿</p><div class=pgc-img><img alt="安全系列之——手寫 JAVA 加密、解密" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fdba6af1e4e34df49ee3eebbc57123b4><p class=pgc-img-caption></p></div><p style=text-align:start>﻿</p><p style=text-align:start>加密技術包括兩個元素：<strong>算法和密鑰</strong>。</p><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>一、使用異或加密解密</h1><p style=text-align:start>﻿</p><p style=text-align:start>先來看一個簡單的加密解密的實例。</p><pre><code>package com.wuxiaolong.EncrypteDecrypt;import org.apache.commons.codec.digest.DigestUtils;/** * Description: * * @author 諸葛小猿 * @date 2020-07-22 */public class Test1 {    public static void main(String[] args) {        String content = "我愛你";        Integer key = 1000;        // 用戶A發消息前，通過某種方式加密        String encryptStr = xor(content,key);        System.out.println(encryptStr);        // 密文通過網絡傳輸        // 用戶B收到密文後使用相同的方式解密        String decryptStr = xor(encryptStr,key);        System.out.println(decryptStr);    }    /**     * 加密算法及祕鑰     * @param content     * @return     */    public static String  xor(String content, Integer key){        char[] chars = content.toCharArray();        for(int i=0; i&lt;chars.length; i++){            chars[i] = (char)  (chars[i]^key) ;        }        return new String(chars);    }}﻿</code></pre><p style=text-align:start>這裡自定義了一個加解密方法xor，這個方法接收兩個參數，一個是原文content，一個祕鑰key。這樣有加密算法，有祕鑰，就可以加密了。</p><p style=text-align:start>﻿</p><p style=text-align:start>運行的結果:</p><pre><code>﻿懹燙䲈    // 加密結果我愛你    // 解密結果</code></pre><h1 class=pgc-h-arrow-right>二、異或加密解密原理講解</h1><p style=text-align:start>﻿</p><p style=text-align:start>在發消息前，需要使用算法+祕鑰對傳輸的消息（明文）進行加密，加密後使用密文在網絡傳輸，傳輸到目的地時，再使用相同的算法+祕鑰將密文翻譯成明文。</p><p style=text-align:start>﻿</p><p style=text-align:start>在這個加密和解密的過程中，使用了相同的算法+祕鑰。</p><p style=text-align:start>﻿</p><div class=pgc-img><img alt="安全系列之——手寫 JAVA 加密、解密" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f9c6d5a48235418298ffa64f81aa3b3e><p class=pgc-img-caption></p></div><p style=text-align:start>﻿</p><p style=text-align:start>這裡可以看出，一個明文連續使用相同的算法+祕鑰做兩次加密，就可以得到原來的明文了。</p><p style=text-align:start>﻿</p><p style=text-align:start>這和計算機中的<strong>異或運算</strong>（^）很像，異或英文為exclusive OR，縮寫成xor，異或運行有兩個特點：</p><p style=text-align:start>﻿</p><ul><li>兩個二進制數字相同為0，不同為1。</li></ul><p style=text-align:start>﻿</p><ul><li>一個數字兩次異或後，得到的是原數字本身。</li></ul><p style=text-align:start>﻿</p><p style=text-align:start>下面使用一個字符a為例，和數字三進行兩次異或運算，可以看出最終得到的結果還是a。</p><p style=text-align:start>﻿</p><div class=pgc-img><img alt="安全系列之——手寫 JAVA 加密、解密" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab32aff3564d4bc58382405cfe09546e><p class=pgc-img-caption></p></div><p style=text-align:start>﻿</p><p style=text-align:start>由於是位運算，參與運算的參數必須要轉化成二進制後才能參與運算。上面的算法public static String xor(String content, Integer key)中，首先要將content轉化成一個字符數組，然後將數組的每一個字符，和整形的key做異或運算得到新的字符，最終，將新的字符數組轉化成新的字符串。</p><p style=text-align:start>﻿</p><p style=text-align:start>為什麼不能使用content字符串直接與key求異或運算？因為字符串不能直接與數字運算，但是字符可以與數字運算，所以字符串轉換成字符數組。</p><p style=text-align:start>﻿</p><p style=text-align:start>下面介紹的加密解密方法的底層，使用的都是二進制，所以加密解密的參數最終都會轉換成二進制字節數組的形式進行處理。</p><p style=text-align:start>﻿</p><p style=text-align:start>上面這種方法中，加密和解密使用的是相同的密鑰key，我們通常將這種方式稱為<strong>對稱加密</strong>。如果加密和解密使用的是不同的祕鑰，則稱之為<strong>非對稱加密</strong>。</p><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>三、對稱加密</h1><p style=text-align:start>﻿</p><p style=text-align:start>對於對稱性加密，雙方通訊之前，都要事先知道<strong>相同的密匙和算法</strong>，之後便是對數據進行加解密了。</p><p style=text-align:start>﻿</p><div class=pgc-img><img alt="安全系列之——手寫 JAVA 加密、解密" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e37a22a743fe461f895e726bdbdf72c7><p class=pgc-img-caption></p></div><p style=text-align:start>﻿</p><p style=text-align:start>這裡介紹幾種常見的對稱加密算法：DES，AES。</p><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>3.1 DES</h1><p style=text-align:start>﻿</p><p style=text-align:start>DES（Data Encryption Standard） 算法是美國政府機關為了保護信息處理中的計算機數據而使用的一種加密方式，是一種常規密碼體制的密碼算法，目前已廣泛使用。該算法輸入的是64比特的明文，在64比特密鑰的控制下產生64比特的密文；反之輸入64比特的密文，輸出64比特的明文。64比特 的密鑰中含有8個比特的奇偶校驗位，所以實際有效密鑰長度為56比特。使用一個 56 位的密鑰以及附加的 8 位奇偶校驗位，產生最大 64 位的分組大小。這是一個迭代的分組密碼，使用稱為 Feistel 的技術，其中將加密的文本塊分成兩半。使用子密鑰對其中一半應用循環功能，然後將輸出與另一半進行"異或"運算；接著交換這兩半，這一過程會繼續下去，但最後一個循環不交換。DES 使用 16 個循環，使用異或，置換，代換，移位操作四種基本運算。</p><p style=text-align:start>﻿</p><p style=text-align:start>下面是使用JDK進行加密的示例代碼：</p><pre><code>package com.wuxiaolong.EncrypteDecrypt;import javax.crypto.Cipher;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import javax.crypto.spec.IvParameterSpec;import java.security.Key;import java.util.Base64;/** * Description: * * @author 諸葛小猿 * @date 2020-07-23 */public class DESUtil {    /**     * 偏移變量，固定佔8位字節     */    private final static String IV_PARAMETER = "12345678";    /**     * 加密算法     */    private static final String ALGORITHM = "DES";    /**     * 加密/解密算法-工作模式-填充模式     */    private static final String CIPHER_ALGORITHM = "DES/CBC/PKCS5Padding";    /**     * 默認編碼     */    private static final String CHARSET = "utf-8";    /**     * 祕鑰     */    private static final String KEY = "key12345678";    public static void main(String[] args) {        String content = "我愛你";        String encptStr = encrypt(KEY,content);        System.out.println(encptStr);        String decptStr = decrypt(KEY,encptStr);        System.out.println(decptStr);    }    /**     * 生成key     *     * @param password     * @return     * @throws Exception     */    private static Key generateKey(String password) throws Exception {        DESKeySpec dks = new DESKeySpec(password.getBytes(CHARSET));        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);        return keyFactory.generateSecret(dks);    }    /**     * DES加密字符串     *     * @param password 加密密碼，長度不能夠小於8位     * @param data 待加密字符串     * @return 加密後內容     */    public static String encrypt(String password, String data) {        if (password== null || password.length() &lt; 8) {            throw new RuntimeException("加密失敗，key不能小於8位");        }        if (data == null)            return null;        try {            Key secretKey = generateKey(password);            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);            IvParameterSpec iv = new IvParameterSpec(IV_PARAMETER.getBytes(CHARSET));            cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);            // 加密            byte[] bytes = cipher.doFinal(data.getBytes(CHARSET));            // base64編碼  JDK1.8及以上可直接使用Base64，JDK1.7及以下可以使用BASE64Encoder            byte[] encode = Base64.getEncoder().encode(bytes);            return new String(encode);        } catch (Exception e) {            e.printStackTrace();            return data;        }    }    /**     * DES解密字符串     *     * @param password 解密密碼，長度不能夠小於8位     * @param data 待解密字符串     * @return 解密後內容     */    public static String decrypt(String password, String data) {        if (password== null || password.length() &lt; 8) {            throw new RuntimeException("加密失敗，key不能小於8位");        }        if (data == null)            return null;        try {            Key secretKey = generateKey(password);            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);            IvParameterSpec iv = new IvParameterSpec(IV_PARAMETER.getBytes(CHARSET));            cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);            // base64解碼            byte[] decode = Base64.getDecoder().decode(data.getBytes(CHARSET));            // 解密            byte[] decrypt = cipher.doFinal(decode);            return new String(decrypt, CHARSET);        } catch (Exception e) {            e.printStackTrace();            return data;        }    }}    ﻿</code></pre><p style=text-align:start>上面代碼運行的結果：</p><pre><code>﻿Xii999DE7LPx5io0awfOFw==        // 加密結果我愛你                                            // 解密結果  </code></pre><p style=text-align:start>DES是一種分組數據加密技術（先將數據分成固定長度的小數據塊，之後進行加密），速度較快，適用於大量數據加密，比如文件加密。文件加密的代碼，可以關注我的公眾號，輸入關鍵字“<strong>java-summary</strong>”獲取。</p><p style=text-align:start>﻿</p><p style=text-align:start>1997 年RSA數據安全公司發起了一項“DES 挑戰賽”的活動，志願者四次分別用四個月、41天、56個小時和22個小時破解了其用56bit DES算法加密的密文。即DES加密算法在計算機速度提升後的今天被認為是<strong>不安全</strong>的。所以針對保密級別特別高的數據推薦使用非對稱加密算法。</p><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>3.2 AES</h1><p style=text-align:start>﻿</p><p style=text-align:start>AES （Advanced Encryption Standard），高級加密標準，是一種區塊加密標準。這個標準用來替代原先的DES，已經被多方分析且廣為全世界所使用。</p><p style=text-align:start>﻿</p><p style=text-align:start>DES使用56位密鑰，比較容易被破解，而AES可以使用128、192、和256位密鑰，並且用128位分組加密和解密數據，相對來說安全很多。完善的加密算法在理論上是無法破解的，除非使用窮盡法。使用窮盡法破解密鑰長度在128位以上的加密數據是不現實的，僅存在理論上的可能性。統計顯示，即使使用目前世界上運算速度最快的計算機，窮盡128位密鑰也要花上幾十億年的時間，更不用說去破解採用256位密鑰長度的AES算法了。</p><p style=text-align:start>﻿</p><p style=text-align:start>下面是AES的源碼展示：</p><pre><code>package com.wuxiaolong.EncrypteDecrypt;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom;/** * Description: * * @author 諸葛小猿 * @date 2020-07-23 */public class AESUtil {    /**     * 加密算法     */    private static final String ALGORITHM = "AES";    /**     * 祕鑰長度     */    private static final Integer KEY_LENGTH = 128;    /**     * 默認編碼     */    private static final String CHARSET = "utf-8";    /**     * 祕鑰     */    private static final String KEY = "key12345678";    public static void main(String[] args) throws Exception {        String content = "我愛你";        String encrypt = encrypt(content, KEY);        System.out.println(encrypt);        String decrypt = decrypt(encrypt, KEY);        System.out.println(decrypt);    }    /**     * 生成key     *     * @param password     * @return     * @throws Exception     */    private static SecretKeySpec generateKey(String password) throws Exception {        // 創建AES的Key生產者        KeyGenerator kgen = KeyGenerator.getInstance(ALGORITHM);        // 利用用戶密碼作為隨機數初始化出        // SecureRandom是生成安全隨機數序列，password.getBytes()是種子，只要種子相同，序列就一樣，所以解密只要有password就行        kgen.init(KEY_LENGTH, new SecureRandom(password.getBytes()));        // 根據用戶密碼，生成一個密鑰        SecretKey secretKey = kgen.generateKey();        // 返回基本編碼格式的密鑰，如果此密鑰不支持編碼，則返回        byte[] enCodeFormat = secretKey.getEncoded();        // 轉換為AES專用密鑰        SecretKeySpec key = new SecretKeySpec(enCodeFormat, ALGORITHM);        return key;    }    /**     * AES加密字符串     *     * @param content 需要被加密的字符串     * @param password 加密需要的密碼     * @return 密文     */    public static String encrypt(String content, String password) {        try {            SecretKeySpec key = generateKey(password);            // 創建密碼器            Cipher cipher = Cipher.getInstance(ALGORITHM);            byte[] byteContent = content.getBytes(CHARSET);            // 初始化為加密模式的密碼器            cipher.init(Cipher.ENCRYPT_MODE, key);            // 加密            byte[] result = cipher.doFinal(byteContent);            // 二進制轉換成16進制字符串            String hexStr = parseByte2HexStr(result);            return hexStr;        } catch (Exception e) {            e.printStackTrace();        }        return null;    }    /**     * 解密AES加密過的字符串     *     * @param content AES加密過過的內容     * @param password 加密時的密碼     * @return 明文     */    public static String decrypt(String content, String password) {        try {            // 十六進制字符串轉換成二進制字節數組            byte[] byteArr = parseHexStr2Byte(content);            SecretKeySpec key = generateKey(password);            Cipher cipher = Cipher.getInstance(ALGORITHM);            cipher.init(Cipher.DECRYPT_MODE, key);            // 解密            byte[] result = cipher.doFinal(byteArr);            return new String(result,CHARSET);        } catch (Exception e) {            e.printStackTrace();        }        return null;    }    /**將二進制轉換成16進制     * @param buf     * @return     */    public static String parseByte2HexStr(byte buf[]) {        StringBuffer sb = new StringBuffer();        for (int i = 0; i &lt; buf.length; i++) {            String hex = Integer.toHexString(buf[i] &amp; 0xFF);            if (hex.length() == 1) {                hex = '0' + hex;            }            sb.append(hex.toUpperCase());        }        return sb.toString();    }    /**將16進制轉換為二進制     * @param hexStr     * @return     */    public static byte[] parseHexStr2Byte(String hexStr) {        if (hexStr.length() &lt; 1)            return null;        byte[] result = new byte[hexStr.length()/2];        for (int i = 0;i&lt; hexStr.length()/2; i++) {            int high = Integer.parseInt(hexStr.substring(i*2, i*2+1), 16);            int low = Integer.parseInt(hexStr.substring(i*2+1, i*2+2), 16);            result[i] = (byte) (high * 16 + low);        }        return result;    }}﻿</code></pre><p style=text-align:start>上面代碼運行的結果：</p><pre><code>765B2080D288F81355CB2A235AD7938C        // 加密結果我愛你                                                               // 解密結果  </code></pre><p style=text-align:start>相較於DES而言，AES算法有著更高的速度和資源使用效率，安全級別也較之更高了，被稱為下一代加密標準。目前世界上還有組織在研究如何攻破AES這堵堅厚的牆，但是因為破解時間太長，AES得到保障，但是所用的時間不斷縮小。隨著計算機計算速度的增快，新算法的出現，AES遭到的攻擊只會越來越猛烈，不會停止的。</p><p style=text-align:start>﻿</p><p style=text-align:start>AES現在廣泛用於金融財務、在線交易、無線通信、數字存儲等領域，經受了最嚴格的考驗，但說不定哪天就會步DES的後塵。</p><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>3.3 對稱加密的特點</h1><p style=text-align:start>﻿</p><p style=text-align:start>優點:</p><p style=text-align:start>﻿</p><ul><li>速度快。相對於非對稱加密，對稱加密的性能更好，加解密速度更快。</li><li>安全。只能說相對還是安全的。</li><li>緊湊。加密後內容的長度基本變化不大。</li></ul><p style=text-align:start>﻿</p><p style=text-align:start>缺點:</p><p style=text-align:start>﻿</p><ul><li>如果雙方通訊時，通過明文傳輸共享密鑰，容易出現中途劫持和竊聽的問題。</li><li>隨著通訊的參與者數量的增加，密鑰數量急劇膨脹((n×(n-1))/2)。</li><li>因為密鑰數量過多，對密鑰的管理和存儲是一個很大的問題（後面我會專門開一期說祕鑰管理及系統設計）。</li><li>不支持數字簽名和不可否認性。</li></ul><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>四、非對稱加密</h1><p style=text-align:start>﻿</p><p style=text-align:start>對於非對稱算法，雙方通訊之前，都需要事先生成一對密匙（公鑰、私鑰），然後雙方交換公鑰。通常非對稱加密使用的就是RAS算法。</p><p style=text-align:start>﻿</p><div class=pgc-img><img alt="安全系列之——手寫 JAVA 加密、解密" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bd0bd39f898f42eca8bbb466693c2ad8><p class=pgc-img-caption></p></div><p style=text-align:start>﻿</p><p style=text-align:start>在使用非對稱密鑰技術之前，所有參與者，不管是用戶還是路由器等網絡設備，都需要預先使用非對稱密鑰算法(例如RSA)產生一對密鑰，其中包括一個公鑰和一個私鑰。公鑰可以放在一個服務器上共享給屬於這個密鑰系統的所有用戶與設備，而私鑰需要由持有者嚴格保護，確保只有持有者才能唯一擁有。</p><p style=text-align:start>﻿</p><div class=pgc-img><img alt="安全系列之——手寫 JAVA 加密、解密" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1895eb03a2f446a1a6e523a621643080><p class=pgc-img-caption></p></div><p style=text-align:start>﻿</p><p style=text-align:start>非對稱加密有很多優點，安全、公鑰可以網絡傳輸等。但是加密速度很慢，不會用來加密上KB的數據。</p><p style=text-align:start>﻿</p><p style=text-align:start>關於RAS算法，可以說的內容太多太多，比如RSR的數學原理、公鑰加密私鑰解密、私鑰簽名公鑰驗籤、公私鑰生成、大文件如何加密、祕鑰如何管理等問題。這些我都會在這個安全系列的其他文章中詳細說明的。這一期以代碼展示為主，就不過多在這裡說了。</p><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>4.1 RSA</h1><p style=text-align:start>﻿</p><p style=text-align:start>這裡需要注意的是，加密使用的是對方的公鑰，解密使用的是對應的私鑰。</p><p style=text-align:start>﻿</p><pre><code>package com.wuxiaolong.EncrypteDecrypt;import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.SecureRandom;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.HashMap;import java.util.Map;/** * Description: * * @author 諸葛小猿 * @date 2020-07-24 */public class RSAEncrypt {    //用於封裝隨機產生的公鑰與私鑰    private static Map&lt;Integer, String&gt; keyMap = new HashMap&lt;Integer, String&gt;();    public static void main(String[] args) throws Exception {        //生成公鑰和私鑰        genKeyPair();        //加密字符串        String message = "我愛你";        System.out.println("隨機生成的公鑰為:" + keyMap.get(0));        System.out.println("隨機生成的私鑰為:" + keyMap.get(1));        String messageEn = encrypt(message,keyMap.get(0));        System.out.println(message + "\t加密後的字符串為:" + messageEn);        String messageDe = decrypt(messageEn,keyMap.get(1));        System.out.println("還原後的字符串為:" + messageDe);    }    /**     * 隨機生成密鑰對     * @throws Exception     */    public static void genKeyPair() throws Exception {        // KeyPairGenerator類用於生成公鑰和私鑰對，基於RSA算法生成對象        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");        // 初始化密鑰對生成器，密鑰大小為        keyPairGen.initialize(2048,new SecureRandom());        // 生成一個密鑰對，保存在keyPair中        KeyPair keyPair = keyPairGen.generateKeyPair();        // 得到私鑰、公鑰        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();        // 得到私鑰字符串        String publicKeyString = new String(Base64.encodeBase64(publicKey.getEncoded()));        String privateKeyString = new String(Base64.encodeBase64((privateKey.getEncoded())));        // 將公鑰和私鑰保存到Map  0表示公鑰  1表示私鑰        keyMap.put(0,publicKeyString);        keyMap.put(1,privateKeyString);    }    /**     * RSA公鑰加密     * @param str 加密字符串     * @param publicKey 公鑰     * @return 密文     * @throws Exception 加密過程中的異常信息     */    public static String encrypt( String str, String publicKey ) throws Exception{        //base64編碼的公鑰        byte[] decoded = Base64.decodeBase64(publicKey);        RSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance("RSA").generatePublic(new X509EncodedKeySpec(decoded));        //RSA加密        Cipher cipher = Cipher.getInstance("RSA");        cipher.init(Cipher.ENCRYPT_MODE, pubKey);        String outStr = Base64.encodeBase64String(cipher.doFinal(str.getBytes("UTF-8")));        return outStr;    }    /**     * RSA私鑰解密     * @param str 加密字符串     * @param privateKey 私鑰     * @return 明文     * @throws Exception 解密過程中的異常信息     */    public static String decrypt(String str, String privateKey) throws Exception{        //64位解碼加密後的字符串        byte[] inputByte = Base64.decodeBase64(str.getBytes("UTF-8"));        //base64編碼的私鑰        byte[] decoded = Base64.decodeBase64(privateKey);        RSAPrivateKey priKey = (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(new PKCS8EncodedKeySpec(decoded));        //RSA解密        Cipher cipher = Cipher.getInstance("RSA");        cipher.init(Cipher.DECRYPT_MODE, priKey);        String outStr = new String(cipher.doFinal(inputByte));        return outStr;    }}</code></pre><p style=text-align:start>代碼運行的結果：</p><pre><code>隨機生成的公鑰為:MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAgJW1vVhZWd8NDiTIrAJK5N4EipP5jWw8WIsWiX3SzZGpzRuz5duRjhubxS2kOoGP6GnOI8KMAHwcFCjtgQNLfvoufHG9OiRaKQEkPhypF1vsuEC0rzeOcWbzIAsWk7B6wboGd6Or4L2MAHsIrluISgICq6BU1cVb/XSPX9tbIOfrjRNsbX5DnNd39XZ4yUlqIDocCQtV3rmQlG4e4nlsJTw073/7/eNCkp7FMJVTch+rQspUPlks9V1ic9TmBhW7dszAGWz4BmIe1elar5bapivBtnVpRX+yEGZSQWkchTqSQTOeYfuh3GFDAYoWlGEx+OeUX8SsRK1V3zeiwv6lpQIDAQAB隨機生成的私鑰為:MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCAlbW9WFlZ3w0OJMisAkrk3gSKk/mNbDxYixaJfdLNkanNG7Pl25GOG5vFLaQ6gY/oac4jwowAfBwUKO2BA0t++i58cb06JFopASQ+HKkXW+y4QLSvN45xZvMgCxaTsHrBugZ3o6vgvYwAewiuW4hKAgKroFTVxVv9dI9f21sg5+uNE2xtfkOc13f1dnjJSWogOhwJC1XeuZCUbh7ieWwlPDTvf/v940KSnsUwlVNyH6tCylQ+WSz1XWJz1OYGFbt2zMAZbPgGYh7V6VqvltqmK8G2dWlFf7IQZlJBaRyFOpJBM55h+6HcYUMBihaUYTH455RfxKxErVXfN6LC/qWlAgMBAAECggEAe+FAFWpfsuDcsAqqNmWDCBoJoATOAP0M6nUdwlqxVBGI2K1e1Q2Dnrhki0Pcm+0k2tHMotEUlob7ekSwBIJLIssfLA9cMf7Byg1qgFiWY4XRevYD3WcV2ZVImE92cdUtfySchHjv53ZVwkTGaUyP8lUbg4PVF5qrdHTuiHhJxFmqLwB6DC7HM9X2jleYJaNSZ2UwiloqkHAMDhqAu9212qZ4ISjbOg/iHDeTRKG3wIX989rsxAVSsruQm3DMZ/jeXzx8MpNjiLaT448dDSOhjhb1tOycMI7CWhYsuT7fOSFmtCtb9E3L8AVarKD2eiOqMaXj28wiuoST7lxa26hHoQKBgQDSmLPYHLXgOfJPIjuYv3IrBv9wr6H9N5FnSKYfISo8gQZJj4YWVFsc9/9vQyOOk0VvtSd28z0dixo1P4axEFe84vwVUsbgo7797nFLZWFm6tZZLgDiSgcxLhz9/5cjnY7irZMdPqKWQKkcFMm4Km8JX8BipwKVwuDiZ74enE1viQKBgQCcTpi0IxOaQQXWaDjG50MBBUIU0F1vM69apsJKeIY8XgE9Vsz/4yqwW7enIZHY15yx4btmZ/1ieOTqRI3x6SwFcgRZQD8OiKf/6WpHp7hXmTE34QJd9CPq+c8MgImd9BAX4rsdKp9pOGsTjFcAvLkU1crk/JQdht+p6VErJUwCPQKBgHLcFjqobgn9kMrYQOjugbY1+tva7t7Mj+FlHjWcQQz+0g8M2HUVTRxfplForNv2NsjWZM/bmlmipIimPTAVWcULh7GZlB6xMFoO0nvsr1MSghXhoVnKRmHsZKOj4yrppCS9xp8MqmCIo7NNIzfu7OCP+L3VmPNVdpIFQwwu840BAoGAUJx8RpK8flZAc3YmqfYE6VbT4LYhKcOHEQJlu1BzMljs3LySVvnKP0/d5FT8yc9Q4bBgHI1O8WUV8ffPGM6/REOsGHd4zb8OnX28sR2/hXXdG0txFBFgIMQa0wDLeGmxjxAAnicoNXTCTD+Zcyjhbuxfij71CFFRsmhA0zaV/6UCgYEAua9INHaJQ5VIFEyAWMHhfwQOU00BynQP0MugNwPypH9qejEzzBJ2fq8j69fxfeG2EENIiDymZMPwHybpYcipKT1aksCPu95HF1+yR6lNrSFDzn/kQu06bgB3V61wsgsKeDuDh++z381m1BONfK3MS1+BlxR/pJ59ikBLyB15tiQ=我愛你	加密後的字符串為:Qo2qkCPF27rfbfAV8k3uLH4ogVA8BlnhtKEvL77KH6wZQKmzrq3z794TuWU9PbJpkYLD2tALt6t0y+Rr9rpPHCqtAGXkzDddu7get/8eNs4N3i8yoOYW2ui7yny7v5cVd8ZsxSHcszmaSV+wb+5AJcMzQhOvWaRwx1WVEOkDp/qBENGFdfPJ8gecbL7YgnqzUtccaJQomQWIlXk88mAU8nAALHO/goEI2CK1HRtb+9qyQgjHU1zFhBsli5yA8NDcqiczFb/nV90yKLMhn5DpIm3gU/qquQltfnkflSk+KXe5BFThIVxcu2FBIovOaX+s82L4DJXtRZS+aCSrHOPfSg==還原後的字符串為:我愛你</code></pre><p style=text-align:start>﻿</p><p style=text-align:start>加密解密使用的祕鑰和簽名驗籤的祕鑰使用不一樣，參考這個系列的其他文章。</p><p style=text-align:start>﻿</p><h1 class=pgc-h-arrow-right>4.2 非對稱加密的特點</h1><p style=text-align:start>﻿</p><p style=text-align:start>工作特點：</p><p style=text-align:start>﻿</p><ul><li>用一個密鑰（公鑰）加密的數據，只能用另一個密鑰（私鑰）來解密。</li><li>一個密鑰（私鑰）用來簽名，一個密鑰（公鑰）用來驗籤。</li></ul><p style=text-align:start>﻿</p><p style=text-align:start>優點：</p><p style=text-align:start>﻿</p><ul><li>由於不必擔心交換的公鑰被劫持，所以非對稱密鑰的分發更安全。</li><li>密鑰數目和參與者數目相同。</li><li>在交換公鑰之前，不需要預先建立某種信任關係。</li><li>支持數字簽名和不可否認性。</li></ul><p style=text-align:start>﻿</p><p style=text-align:start>缺點:</p><p style=text-align:start>﻿</p><ul><li>加密速度很慢。要不用來加密上KB的數據，可以用來加密key，key的數據量較小。</li><li>加密後，密文會變長。</li></ul><p style=text-align:start>﻿</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>手寫</a></li><li><a>JAVA</a></li><li><a>解密</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html alt=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15310942260931dda577a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html title=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點>JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html alt=JAVA入門到大神（玩轉正則表達式） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html title=JAVA入門到大神（玩轉正則表達式）>JAVA入門到大神（玩轉正則表達式）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a3d9e7a.html alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ea11259e-5098-451f-b989-4e3169a16a1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a3d9e7a.html title=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道>「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html alt=給JAVA開發人員的正則表達式入門課 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html title=給JAVA開發人員的正則表達式入門課>給JAVA開發人員的正則表達式入門課</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html alt=JAVA怎麼處理異常 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/6cf507ab-d41c-4bb0-bef0-6def0eb1fef8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html title=JAVA怎麼處理異常>JAVA怎麼處理異常</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaf6fcd.html alt=手寫壁紙｜你從這邊走向那邊，你避開了我的一生 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535341020756dc1a9b3f3f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaf6fcd.html title=手寫壁紙｜你從這邊走向那邊，你避開了我的一生>手寫壁紙｜你從這邊走向那邊，你避開了我的一生</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html alt=JAVA應用程序開發之集合類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aa9e1fe1752a4a1886a691485e0e1373 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html title=JAVA應用程序開發之集合類>JAVA應用程序開發之集合類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html alt=小白學JAVA之——List接口的實現類——ArrayList class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b14b6a69b8354d53a35156eaa365395e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html title=小白學JAVA之——List接口的實現類——ArrayList>小白學JAVA之——List接口的實現類——ArrayList</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/29e24fd0.html alt=新陳玉米的特點與危害（玉米解密一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1535414817033946695b74c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/29e24fd0.html title=新陳玉米的特點與危害（玉米解密一）>新陳玉米的特點與危害（玉米解密一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/408b28ff.html alt=解密AI芯片的加速原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RcmBnwg8xNu7at style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/408b28ff.html title=解密AI芯片的加速原理>解密AI芯片的加速原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/882264f6.html alt=26個英文字母逐字母手寫模板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/839d9b3c13514c34bdee8c146f18fef6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/882264f6.html title=26個英文字母逐字母手寫模板>26個英文字母逐字母手寫模板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ebd12f8.html alt=在線仿真手寫文稿生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/037e6191d7d64ce68d87b59280afc56e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ebd12f8.html title=在線仿真手寫文稿生成器>在線仿真手寫文稿生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be61162.html alt=手寫AOP實現過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6ac9667b9b064f57903047a4156004fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be61162.html title=手寫AOP實現過程>手寫AOP實現過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67364b11.html alt="不要被商家噱頭迷惑 解密表面活性劑" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/007f1b6eb94545c0b66e08c9be9a1b99 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67364b11.html title="不要被商家噱頭迷惑 解密表面活性劑">不要被商家噱頭迷惑 解密表面活性劑</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>