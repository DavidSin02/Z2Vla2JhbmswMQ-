<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>5萬字、97 張圖總結操作系統核心知識點(上) | 极客快訊</title><meta property="og:title" content="5萬字、97 張圖總結操作系統核心知識點(上) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/98a0e3ef45ee4fc4b806e816919b54f0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/74c701b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><meta property="article:published_time" content="2020-10-29T21:05:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:04+08:00"><meta name=Keywords content><meta name=description content="5萬字、97 張圖總結操作系統核心知識點(上)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/74c701b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>5萬字、97 張圖總結操作系統核心知識點(上)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/98a0e3ef45ee4fc4b806e816919b54f0></p><p>文末領取大圖。</p><p>這不是一篇教你如何創建一個操作系統的文章，相反，這是一篇指導性文章，教你從幾個方面來理解操作系統。首先你需要知道你為什麼要看這篇文章以及為什麼要學習操作系統。</p><h2>搞清楚幾個問題</h2><p>首先你要搞明白你學習操作系統的目的是什麼？操作系統的重要性如何？學習操作系統會給我帶來什麼？下面我會從這幾個方面為你回答下。</p><p>操作系統也是一種軟件，但是操作系統是一種非常複雜的軟件。操作系統提供了幾種抽象模型</p><ul><li>文件：對 I/O 設備的抽象</li><li>虛擬內存：對程序存儲器的抽象</li><li>進程：對一個正在運行程序的抽象</li><li>虛擬機：對整個操作系統的抽象</li></ul><p>這些抽象和我們的日常開發息息相關。搞清楚了操作系統是如何抽象的，才能培養我們的抽象性思維和開發思路。</p><p>很多問題都和操作系統相關，操作系統是解決這些問題的基礎。如果你不學習操作系統，可能會想著從框架層面來解決，那是你瞭解的還不夠深入，當你學習了操作系統後，能夠培養你的全局性思維。</p><p>學習操作系統我們能夠有效的解決併發問題，併發幾乎是互聯網的重中之重了，這也從側面說明了學習操作系統的重要性。</p><p>學習操作系統的重點不是讓你從頭製造一個操作系統，而是告訴你<strong>操作系統是如何工作的</strong>，能夠讓你對計算機底層有所瞭解，打實你的基礎。</p><p>相信你一定清楚什麼是編程</p><p><strong>Data structures + Algorithms = Programming</strong></p><p>操作系統內部會涉及到眾多的數據結構和算法描述，能夠讓你瞭解算法的基礎上，讓你編寫更優秀的程序。</p><p>我認為可以把計算機比作一棟樓</p><p>計算機的底層相當於就是樓的根基，計算機應用相當於就是樓的外形，而操作系統就相當於是告訴你大樓的構造原理，編寫高質量的軟件就相當於是告訴你構建一個穩定的房子。</p><h2>認識操作系統</h2><p>在瞭解操作系統前，你需要先知道一下什麼是計算機系統：現代計算機系統由<strong>一個或多個處理器、主存、打印機、鍵盤、鼠標、顯示器、網絡接口以及各種輸入/輸出設備構成的系統</strong>。這些都屬於硬件的範疇。我們程序員不會直接和這些硬件打交道，並且每位程序員不可能會掌握所有計算機系統的細節。</p><p>所以計算機科學家在硬件的基礎之上，安裝了一層軟件，這層軟件能夠根據用戶輸入的指令達到控制硬件的效果，從而滿足用戶的需求，這樣的軟件稱為 操作系統，它的任務就是為用戶程序提供一個更好、更簡單、更清晰的計算機模型。也就是說，操作系統相當於是一箇中間層，為用戶層和硬件提供各自的藉口，屏蔽了不同應用和硬件之間的差異，達到統一標準的作用。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb4122e603fe4c44a557742c9c4ed258></p><p>上面一個操作系統的簡化圖，最底層是硬件，硬件包括<strong>芯片、電路板、磁盤、鍵盤、顯示器</strong>等我們上面提到的設備，在硬件之上是軟件。大部分計算機有兩種運行模式：內核態 和 用戶態，軟件中最基礎的部分是操作系統，它運行在 內核態 中。操作系統具有硬件的訪問權，可以執行機器能夠運行的任何指令。軟件的其餘部分運行在 用戶態 下。</p><p>在大概瞭解到操作系統之後，我們先來認識一下硬件都有哪些</p><h2>計算機硬件</h2><p>計算機硬件是計算機的重要組成部分，其中包含了 5 個重要的組成部分：<strong>運算器、控制器、存儲器、輸入設備、輸出設備</strong>。</p><ul><li>運算器：運算器最主要的功能是對數據和信息進行加工和運算。它是計算機中執行算數和各種邏輯運算的部件。運算器的基本運算包括加、減、乘、除、移位等操作，這些是由 算術邏輯單元(Arithmetic&logical Unit) 實現的。而運算器主要由算數邏輯單元和寄存器構成。</li><li>控制器：指按照指定順序改變主電路或控制電路的部件，它主要起到了控制命令執行的作用，完成協調和指揮整個計算機系統的操作。控制器是由程序計數器、指令寄存器、解碼譯碼器等構成。</li></ul><blockquote><p>運算器和控制器共同組成了 CPU</p></blockquote><ul><li><p>存儲器：存儲器就是計算機的記憶設備，顧名思義，存儲器可以保存信息。存儲器分為兩種，一種是主存，也就是內存，它是 CPU 主要交互對象，還有一種是外存，比如硬盤軟盤等。下面是現代計算機系統的存儲架構</p></li><li><p>輸入設備：輸入設備是給計算機獲取外部信息的設備，它主要包括鍵盤和鼠標。</p></li><li><p>輸出設備：輸出設備是給用戶呈現根據輸入設備獲取的信息經過一系列的計算後得到顯示的設備，它主要包括顯示器、打印機等。</p></li></ul><p>這五部分也是馮諾伊曼的體系結構，它認為計算機必須具有如下功能：</p><p>把需要的程序和數據送至計算機中。必須具有長期記憶程序、數據、中間結果及最終運算結果的能力。能夠完成各種算術、邏輯運算和數據傳送等數據加工處理的能力。能夠根據需要控制程序走向，並能根據指令控制機器的各部件協調操作。能夠按照要求將處理結果輸出給用戶。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b2ea176490f84d7caafc781e76d4dd18></p><p>下面是一張 intel 家族產品圖，是一個詳細的計算機硬件分類，我們在根據圖中涉及到硬件進行介紹</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5e5b95938fe744cc9fada99cd90ae183></p><ul><li>總線(Buses)：在整個系統中運行的是稱為總線的電氣管道的集合，這些總線在組件之間來回傳輸字節信息。通常總線被設計成傳送定長的字節塊，也就是 字(word)。字中的字節數（字長）是一個基本的系統參數，各個系統中都不盡相同。現在大部分的字都是 4 個字節（32 位）或者 8 個字節（64 位）。</li></ul><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/000ab977b9f84f6e806199773f3adeb9></p><ul><li><p>I/O 設備(I/O Devices)：Input/Output 設備是系統和外部世界的連接。上圖中有四類 I/O 設備：用於用戶輸入的鍵盤和鼠標，用於用戶輸出的顯示器，一個磁盤驅動用來長時間的保存數據和程序。剛開始的時候，可執行程序就保存在磁盤上。</p><p>每個I/O 設備連接 I/O 總線都被稱為控制器(controller) 或者是 適配器(Adapter)。控制器和適配器之間的主要區別在於封裝方式。控制器是 I/O 設備本身或者系統的主印製板電路（通常稱作主板）上的芯片組。而適配器則是一塊插在主板插槽上的卡。無論組織形式如何，它們的最終目的都是彼此交換信息。</p></li><li><p>主存(Main Memory)，主存是一個臨時存儲設備，而不是永久性存儲，磁盤是 永久性存儲 的設備。主存既保存程序，又保存處理器執行流程所處理的數據。從物理組成上說，主存是由一系列 DRAM(dynamic random access memory) 動態隨機存儲構成的集合。邏輯上說，內存就是一個線性的字節數組，有它唯一的地址編號，從 0 開始。一般來說，組成程序的每條機器指令都由不同數量的字節構成，C 程序變量相對應的數據項的大小根據類型進行變化。比如，在 Linux 的 x86-64 機器上，short 類型的數據需要 2 個字節，int 和 float 需要 4 個字節，而 long 和 double 需要 8 個字節。</p></li><li><p>處理器(Processor)，CPU(central processing unit) 或者簡單的處理器，是解釋（並執行）存儲在主存儲器中的指令的引擎。處理器的核心大小為一個字的存儲設備（或寄存器），稱為程序計數器(PC)。在任何時刻，PC 都指向主存中的某條機器語言指令（即含有該條指令的地址）。</p><p>從系統通電開始，直到系統斷電，處理器一直在不斷地執行程序計數器指向的指令，再更新程序計數器，使其指向下一條指令。處理器根據其指令集體系結構定義的指令模型進行操作。在這個模型中，指令按照嚴格的順序執行，執行一條指令涉及執行一系列的步驟。處理器從程序計數器指向的內存中讀取指令，解釋指令中的位，執行該指令指示的一些簡單操作，然後更新程序計數器以指向下一條指令。指令與指令之間可能連續，可能不連續（比如 jmp 指令就不會順序讀取）</p></li></ul><p>下面是 CPU 可能執行簡單操作的幾個步驟</p><ul><li>加載(Load)：從主存中拷貝一個字節或者一個字到內存中，覆蓋寄存器先前的內容</li><li>存儲(Store)：將寄存器中的字節或字複製到主存儲器中的某個位置，從而覆蓋該位置的先前內容</li><li>操作(Operate)：把兩個寄存器的內容複製到 ALU(Arithmetic logic unit)。把兩個字進行算術運算，並把結果存儲在寄存器中，重寫寄存器先前的內容。</li></ul><blockquote><p>算術邏輯單元（ALU）是對數字二進制數執行算術和按位運算的組合數字電子電路。</p></blockquote><ul><li>跳轉(jump)：從指令中抽取一個字，把這個字複製到程序計數器(PC) 中，覆蓋原來的值</li></ul><h2>進程和線程</h2><p>關於進程和線程，你需要理解下面這張腦圖中的重點</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/29d7c00aea2948d38565591c2efb82c3></p><h2>進程</h2><p>操作系統中最核心的概念就是 進程，進程是對正在運行中的程序的一個抽象。操作系統的其他所有內容都是圍繞著進程展開的。</p><p>在多道程序處理的系統中，CPU 會在進程間快速切換，使每個程序運行幾十或者幾百毫秒。然而，嚴格意義來說，在某一個瞬間，CPU 只能運行一個進程，然而我們如果把時間定位為 1 秒內的話，它可能運行多個進程。這樣就會讓我們產生並行的錯覺。因為 CPU 執行速度很快，進程間的換進換出也非常迅速，因此我們很難對多個並行進程進行跟蹤。所以，操作系統的設計者開發了用於描述並行的一種概念模型（順序進程），使得並行更加容易理解和分析。</p><h3>進程模型</h3><p>一個進程就是一個正在執行的程序的實例，進程也包括程序計數器、寄存器和變量的當前值。從概念上來說，每個進程都有各自的虛擬 CPU，但是實際情況是 CPU 會在各個進程之間進行來回切換。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e3103f2f68df463c83c541e7af862912></p><p>如上圖所示，這是一個具有 4 個程序的多道處理程序，在進程不斷切換的過程中，程序計數器也在不同的變化。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/230653c035b44e1994b11a0b762d47da></p><p>在上圖中，這 4 道程序被抽象為 4 個擁有各自控制流程（即每個自己的程序計數器）的進程，並且每個程序都獨立的運行。當然，實際上只有一個物理程序計數器，每個程序要運行時，其邏輯程序計數器會裝載到物理程序計數器中。當程序運行結束後，其物理程序計數器就會是真正的程序計數器，然後再把它放回進程的邏輯計數器中。</p><p>從下圖我們可以看到，在觀察足夠長的一段時間後，所有的進程都運行了，<strong>但在任何一個給定的瞬間僅有一個進程真正運行</strong>。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0d2c92e8eee445b7b5c5a9ed629bdd49></p><p>因此，當我們說一個 CPU 只能真正一次運行一個進程的時候，即使有 2 個核（或 CPU），<strong>每一個核也只能一次運行一個線程</strong>。</p><p>由於 CPU 會在各個進程之間來回快速切換，所以每個進程在 CPU 中的運行時間是無法確定的。並且當同一個進程再次在 CPU 中運行時，其在 CPU 內部的運行時間往往也是不固定的。</p><p>這裡的關鍵思想是認識到一個進程所需的條件，進程是某一類特定活動的總和，它有程序、輸入輸出以及狀態。</p><h3>進程的創建</h3><p>操作系統需要一些方式來創建進程。下面是一些創建進程的方式</p><ul><li>系統初始化（init）：啟動操作系統時，通常會創建若干個進程。</li><li>正在運行的程序執行了創建進程的系統調用（比如 fork）</li><li>用戶請求創建一個新進程：在許多交互式系統中，輸入一個命令或者雙擊圖標就可以啟動程序，以上任意一種操作都可以選擇開啟一個新的進程，在基本的 UNIX 系統中運行 X，新進程將接管啟動它的窗口。</li><li>初始化一個批處理工作</li></ul><p>從技術上講，在所有這些情況下，讓現有流程執行流程是通過創建系統調用來創建新流程的。該進程可能是正在運行的用戶進程，是從鍵盤或鼠標調用的系統進程或批處理程序。這些就是系統調用創建新進程的過程。該系統調用告訴操作系統創建一個新進程，並直接或間接指示在其中運行哪個程序。</p><p>在 UNIX 中，僅有一個系統調用來創建一個新的進程，這個系統調用就是 fork。這個調用會創建一個與調用進程相關的副本。在 fork 後，一個父進程和子進程會有相同的內存映像，相同的環境字符串和相同的打開文件。</p><p>在 Windows 中，情況正相反，一個簡單的 Win32 功能調用 CreateProcess，會處理流程創建並將正確的程序加載到新的進程中。這個調用會有 10 個參數，包括了需要執行的程序、輸入給程序的命令行參數、各種安全屬性、有關打開的文件是否繼承控制位、優先級信息、進程所需要創建的窗口規格以及指向一個結構的指針，在該結構中新創建進程的信息被返回給調用者。<strong>在 Windows 中，從一開始父進程的地址空間和子進程的地址空間就是不同的</strong>。</p><h3>進程的終止</h3><p>進程在創建之後，它就開始運行並做完成任務。然而，沒有什麼事兒是永不停歇的，包括進程也一樣。進程早晚會發生終止，但是通常是由於以下情況觸發的</p><ul><li>正常退出(自願的) ： 多數進程是由於完成了工作而終止。當編譯器完成了所給定程序的編譯之後，編譯器會執行一個系統調用告訴操作系統它完成了工作。這個調用在 UNIX 中是 exit ，在 Windows 中是 ExitProcess。</li><li>錯誤退出(自願的)：比如執行一條不存在的命令，於是編譯器就會提醒並退出。</li><li>嚴重錯誤(非自願的)</li><li>被其他進程殺死(非自願的) ： 某個進程執行系統調用告訴操作系統殺死某個進程。在 UNIX 中，這個系統調用是 kill。在 Win32 中對應的函數是 TerminateProcess（注意不是系統調用）。</li></ul><h3>進程的層次結構</h3><p>在一些系統中，當一個進程創建了其他進程後，父進程和子進程就會以某種方式進行關聯。子進程它自己就會創建更多進程，從而形成一個進程層次結構。</p><h4>UNIX 進程體系</h4><p>在 UNIX 中，進程和它的所有子進程以及子進程的子進程共同組成一個進程組。當用戶從鍵盤中發出一個信號後，該信號被髮送給當前與鍵盤相關的進程組中的所有成員（它們通常是在當前窗口創建的所有活動進程）。每個進程可以分別捕獲該信號、忽略該信號或採取默認的動作，即被信號 kill 掉。整個操作系統中所有的進程都隸屬於一個單個以 init 為根的進程樹。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3df50f6030ff48f49771f7cc2ee32ac5></p><h4>Windows 進程體系</h4><p>相反，Windows 中沒有進程層次的概念，Windows 中所有進程都是平等的，唯一類似於層次結構的是在創建進程的時候，父進程得到一個特別的令牌（稱為句柄），該句柄可以用來控制子進程。然而，這個令牌可能也會移交給別的操作系統，這樣就不存在層次結構了。而在 UNIX 中，進程不能剝奪其子進程的 進程權。（這樣看來，還是 Windows 比較渣）。</p><h3>進程狀態</h3><p>儘管每個進程是一個獨立的實體，有其自己的程序計數器和內部狀態，但是，進程之間仍然需要相互幫助。當一個進程開始運行時，它可能會經歷下面這幾種狀態</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bbff8cc6411849a5a50464342474743a></p><p>圖中會涉及三種狀態</p><ol><li>運行態，運行態指的就是進程實際佔用 CPU 時間片運行時</li><li>就緒態，就緒態指的是可運行，但因為其他進程正在運行而處於就緒狀態</li><li>阻塞態，除非某種外部事件發生，否則進程不能運行</li></ol><h3>進程的實現</h3><p>操作系統為了執行進程間的切換，會維護著一張表，這張表就是 進程表(process table)。每個進程佔用一個進程表項。該表項包含了進程狀態的重要信息，包括程序計數器、堆棧指針、內存分配狀況、所打開文件的狀態、賬號和調度信息，以及其他在進程由運行態轉換到就緒態或阻塞態時所必須保存的信息。</p><p>下面展示了一個典型系統中的關鍵字段</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/92f3b07a52b147e2943eb3c05da00361></p><p>第一列內容與進程管理有關，第二列內容與 存儲管理有關，第三列內容與文件管理有關。</p><p>現在我們應該對進程表有個大致的瞭解了，就可以在對單個 CPU 上如何運行多個順序進程的錯覺做更多的解釋。與每一 I/O 類相關聯的是一個稱作 中斷向量(interrupt vector) 的位置（靠近內存底部的固定區域）。它包含中斷服務程序的入口地址。假設當一個磁盤中斷髮生時，用戶進程 3 正在運行，則中斷硬件將程序計數器、程序狀態字、有時還有一個或多個寄存器壓入堆棧，計算機隨即跳轉到中斷向量所指示的地址。這就是硬件所做的事情。然後軟件就隨即接管一切剩餘的工作。</p><p>當中斷結束後，操作系統會調用一個 C 程序來處理中斷剩下的工作。在完成剩下的工作後，會使某些進程就緒，接著調用調度程序，決定隨後運行哪個進程。然後將控制權轉移給一段彙編語言代碼，為當前的進程裝入寄存器值以及內存映射並啟動該進程運行，下面顯示了中斷處理和調度的過程。</p><ol><li><p>硬件壓入堆棧程序計數器等</p></li><li><p>硬件從中斷向量裝入新的程序計數器</p></li><li><p>彙編語言過程保存寄存器的值</p></li><li><p>彙編語言過程設置新的堆棧</p></li><li><p>C 中斷服務器運行（典型的讀和緩存寫入）</p></li><li><p>調度器決定下面哪個程序先運行</p></li><li><p>C 過程返回至彙編代碼</p></li><li><p>彙編語言過程開始運行新的當前進程</p></li></ol><p>一個進程在執行過程中可能被中斷數千次，但關鍵每次中斷後，被中斷的進程都返回到與中斷髮生前完全相同的狀態。</p><h2>線程</h2><p>在傳統的操作系統中，每個進程都有一個地址空間和一個控制線程。事實上，這是大部分進程的定義。不過，在許多情況下，經常存在同一地址空間中運行多個控制線程的情形，這些線程就像是分離的進程。下面我們就著重探討一下什麼是線程</p><h3>線程的使用</h3><p>或許這個疑問也是你的疑問，為什麼要在進程的基礎上再創建一個線程的概念，準確的說，這其實是進程模型和線程模型的討論，回答這個問題，可能需要分三步來回答</p><ul><li>多線程之間會共享同一塊地址空間和所有可用數據的能力，這是進程所不具備的</li><li>線程要比進程更輕量級，由於線程更輕，所以它比進程更容易創建，也更容易撤銷。在許多系統中，創建一個線程要比創建一個進程快 10 - 100 倍。</li><li>第三個原因可能是性能方面的探討，如果多個線程都是 CPU 密集型的，那麼並不能獲得性能上的增強，但是如果存在著大量的計算和大量的 I/O 處理，擁有多個線程能在這些活動中彼此重疊進行，從而會加快應用程序的執行速度</li></ul><h3>經典的線程模型</h3><p>進程中擁有一個執行的線程，通常簡寫為 線程(thread)。線程會有程序計數器，用來記錄接著要執行哪一條指令；線程實際上 CPU 上調度執行的實體。</p><p>下圖我們可以看到三個傳統的進程，每個進程有自己的地址空間和單個控制線程。每個線程都在不同的地址空間中運行</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d14bbd4b069a416ba4c2a5c216cefc6f></p><p>下圖中，我們可以看到有一個進程三個線程的情況。每個線程都在相同的地址空間中運行。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6c61d840c58a446282a7d87dfa6e8c33></p><p>線程不像是進程那樣具備較強的獨立性。同一個進程中的所有線程都會有完全一樣的地址空間，這意味著它們也共享同樣的全局變量。由於每個線程都可以訪問進程地址空間內每個內存地址，<strong>因此一個線程可以讀取、寫入甚至擦除另一個線程的堆棧</strong>。線程之間除了共享同一內存空間外，還具有如下不同的內容</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d927dd83658742518d2e22d5178f9a9d></p><p>上圖左邊的是同一個進程中每個線程共享的內容，上圖右邊是每個線程中的內容。也就是說左邊的列表是進程的屬性，右邊的列表是線程的屬性。</p><p><strong>線程之間的狀態轉換和進程之間的狀態轉換是一樣的</strong>。</p><p>每個線程都會有自己的堆棧，如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf502f22f32e4399a1a005a67e802536></p><h4>線程系統調用</h4><p>進程通常會從當前的某個單線程開始，然後這個線程通過調用一個庫函數（比如 thread_create）創建新的線程。線程創建的函數會要求指定新創建線程的名稱。創建的線程通常都返回一個線程標識符，該標識符就是新線程的名字。</p><p>當一個線程完成工作後，可以通過調用一個函數（比如 thread_exit）來退出。緊接著線程消失，狀態變為終止，不能再進行調度。在某些線程的運行過程中，可以通過調用函數例如 thread_join ，表示一個線程可以等待另一個線程退出。這個過程阻塞調用線程直到等待特定的線程退出。在這種情況下，線程的創建和終止非常類似於進程的創建和終止。</p><p>另一個常見的線程是調用 thread_yield，它允許線程自動放棄 CPU 從而讓另一個線程運行。這樣一個調用還是很重要的，因為不同於進程，線程是無法利用時鐘中斷強制讓線程讓出 CPU 的。</p><h3>POSIX 線程</h3><p>POSIX 線程 通常稱為 pthreads是一種獨立於語言而存在的執行模型，以及並行執行模型。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/56373349678a4346b3419cd24555f8d6></p><p>它允許程序控制時間上重疊的多個不同的工作流程。每個工作流程都稱為一個線程，可以通過調用 POSIX Threads API 來實現對這些流程的創建和控制。可以把它理解為線程的標準。</p><blockquote><p>POSIX Threads 的實現在許多類似且符合POSIX的操作系統上可用，例如 <strong>FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</strong>，它在現有 Windows API 之上實現了<strong>pthread</strong>。</p><p>IEEE 是世界上最大的技術專業組織，致力於為人類的利益而發展技術。</p></blockquote><p>線程調用描述pthread_create創建一個新線程pthread_exit結束調用的線程pthread_join等待一個特定的線程退出pthread_yield釋放 CPU 來運行另外一個線程pthread_attr_init創建並初始化一個線程的屬性結構pthread_attr_destory刪除一個線程的屬性結構</p><p>所有的 Pthreads 都有特定的屬性，每一個都含有標識符、一組寄存器（包括程序計數器）和一組存儲在結構中的屬性。這個屬性包括堆棧大小、調度參數以及其他線程需要的項目。</p><h3>線程實現</h3><p>主要有三種實現方式</p><ul><li>在用戶空間中實現線程；</li><li>在內核空間中實現線程；</li><li>在用戶和內核空間中混合實現線程。</li></ul><p>下面我們分開討論一下</p><h4>在用戶空間中實現線程</h4><p>第一種方法是把整個線程包放在用戶空間中，內核對線程一無所知，它不知道線程的存在。所有的這類實現都有同樣的通用結構</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ef7e05728ba647ae94f1874af93b9bd9></p><p>線程在運行時系統之上運行，運行時系統是管理線程過程的集合，包括前面提到的四個過程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</p><h3>在內核中實現線程</h3><p>當某個線程希望創建一個新線程或撤銷一個已有線程時，它會進行一個系統調用，這個系統調用通過對線程表的更新來完成線程創建或銷燬工作。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c8427c173be94beaa49bded24a776a37></p><p>內核中的線程表持有每個線程的寄存器、狀態和其他信息。這些信息和用戶空間中的線程信息相同，但是位置卻被放在了內核中而不是用戶空間中。另外，內核還維護了一張進程表用來跟蹤系統狀態。</p><p>所有能夠阻塞的調用都會通過系統調用的方式來實現，當一個線程阻塞時，內核可以進行選擇，是運行在同一個進程中的另一個線程（如果有就緒線程的話）還是運行一個另一個進程中的線程。但是在用戶實現中，運行時系統始終運行自己的線程，直到內核剝奪它的 CPU 時間片（或者沒有可運行的線程存在了）為止。</p><h3>混合實現</h3><p>結合用戶空間和內核空間的優點，設計人員採用了一種內核級線程的方式，然後將用戶級線程與某些或者全部內核線程多路複用起來</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/928de0d5349140e9a332ba8a18d53f3f></p><p>在這種模型中，編程人員可以自由控制用戶線程和內核線程的數量，具有很大的靈活度。採用這種方法，內核只識別內核級線程，並對其進行調度。其中一些內核級線程會被多個用戶級線程多路複用。</p><h2>進程間通信</h2><p>進程是需要頻繁的和其他進程進行交流的。下面我們會一起討論有關 進程間通信(Inter Process Communication, IPC) 的問題。大致來說，進程間的通信機制可以分為 6 種</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1e9a3ab259e1488d84921cde6d5beeac></p><p>下面我們分別對其進行概述</p><h3>信號 signal</h3><p>信號是 UNIX 系統最先開始使用的進程間通信機制，因為 Linux 是繼承於 UNIX 的，所以 Linux 也支持信號機制，通過向一個或多個進程發送異步事件信號來實現，信號可以從鍵盤或者訪問不存在的位置等地方產生；信號通過 shell 將任務發送給子進程。</p><p>你可以在 Linux 系統上輸入 kill -l 來列出系統使用的信號，下面是我提供的一些信號</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b532605323874d6c86264a5ad179e243></p><p>進程可以選擇忽略發送過來的信號，但是有兩個是不能忽略的：SIGSTOP 和 SIGKILL 信號。SIGSTOP 信號會通知當前正在運行的進程執行關閉操作，SIGKILL 信號會通知當前進程應該被殺死。除此之外，進程可以選擇它想要處理的信號，進程也可以選擇阻止信號，如果不阻止，可以選擇自行處理，也可以選擇進行內核處理。如果選擇交給內核進行處理，那麼就執行默認處理。</p><p>操作系統會中斷目標程序的進程來向其發送信號、在任何非原子指令中，執行都可以中斷，如果進程已經註冊了新號處理程序，那麼就執行進程，如果沒有註冊，將採用默認處理的方式。</p><h3>管道 pipe</h3><p>Linux 系統中的進程可以通過建立管道 pipe 進行通信</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b4eec716830949989ee39055758296d3></p><p>在兩個進程之間，可以建立一個通道，一個進程向這個通道里寫入字節流，另一個進程從這個管道中讀取字節流。管道是同步的，當進程嘗試從空管道讀取數據時，該進程會被阻塞，直到有可用數據為止。shell 中的管線 pipelines 就是用管道實現的，當 shell 發現輸出</p><p>sort &lt;f | head</p><p>它會創建兩個進程，一個是 sort，一個是 head，sort，會在這兩個應用程序之間建立一個管道使得 sort 進程的標準輸出作為 head 程序的標準輸入。sort 進程產生的輸出就不用寫到文件中了，如果管道滿了系統會停止 sort 以等待 head 讀出數據</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/92a5e278c9484d90a726c31153ab3558></p><p>管道實際上就是 |，兩個應用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</p><h3>共享內存 shared memory</h3><p>兩個進程之間還可以通過共享內存進行進程間通信，其中兩個或者多個進程可以訪問公共內存空間。兩個進程的共享工作是通過共享內存完成的，一個進程所作的修改可以對另一個進程可見(很像線程間的通信)。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f4cb78e33a4c4bd9bcf4251b718a0c33></p><p>在使用共享內存前，需要經過一系列的調用流程，流程如下</p><ul><li>創建共享內存段或者使用已創建的共享內存段(shmget())</li><li>將進程附加到已經創建的內存段中(shmat())</li><li>從已連接的共享內存段分離進程(shmdt())</li><li>對共享內存段執行控制操作(shmctl())</li></ul><h3>先入先出隊列 FIFO</h3><p>先入先出隊列 FIFO 通常被稱為 命名管道(Named Pipes)，命名管道的工作方式與常規管道非常相似，但是確實有一些明顯的區別。未命名的管道沒有備份文件：操作系統負責維護內存中的緩衝區，用來將字節從寫入器傳輸到讀取器。一旦寫入或者輸出終止的話，緩衝區將被回收，傳輸的數據會丟失。相比之下，命名管道具有支持文件和獨特 API ，命名管道在文件系統中作為設備的專用文件存在。當所有的進程通信完成後，命名管道將保留在文件系統中以備後用。命名管道具有嚴格的 FIFO 行為</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/36ead583514340b192bb8b30f83e392f></p><p>寫入的第一個字節是讀取的第一個字節，寫入的第二個字節是讀取的第二個字節，依此類推。</p><h3>消息隊列 Message Queue</h3><p>一聽到消息隊列這個名詞你可能不知道是什麼意思，消息隊列是用來描述內核尋址空間內的內部鏈接列表。可以按幾種不同的方式將消息按順序發送到隊列並從隊列中檢索消息。每個消息隊列由 IPC 標識符唯一標識。消息隊列有兩種模式，一種是嚴格模式， 嚴格模式就像是 FIFO 先入先出隊列似的，消息順序發送，順序讀取。還有一種模式是 非嚴格模式，消息的順序性不是非常重要。</p><h3>套接字 Socket</h3><p>還有一種管理兩個進程間通信的是使用 socket，socket 提供端到端的雙相通信。一個套接字可以與一個或多個進程關聯。就像管道有命令管道和未命名管道一樣，套接字也有兩種模式，套接字一般用於兩個進程之間的網絡通信，網絡套接字需要來自諸如TCP（傳輸控制協議）或較低級別UDP（用戶數據報協議）等基礎協議的支持。</p><p>套接字有以下幾種分類</p><ul><li>順序包套接字(Sequential Packet Socket)： 此類套接字為最大長度固定的數據報提供可靠的連接。此連接是雙向的並且是順序的。</li><li>數據報套接字(Datagram Socket)：數據包套接字支持雙向數據流。數據包套接字接受消息的順序與發送者可能不同。</li><li>流式套接字(Stream Socket)：流套接字的工作方式類似於電話對話，提供雙向可靠的數據流。</li><li>原始套接字(Raw Socket)： 可以使用原始套接字訪問基礎通信協議。</li></ul><h2>調度</h2><p>當一個計算機是多道程序設計系統時，會頻繁的有很多進程或者線程來同時競爭 CPU 時間片。當兩個或兩個以上的進程/線程處於就緒狀態時，就會發生這種情況。如果只有一個 CPU 可用，那麼必須選擇接下來哪個進程/線程可以運行。操作系統中有一個叫做 調度程序(scheduler) 的角色存在，它就是做這件事兒的，該程序使用的算法叫做 調度算法(scheduling algorithm) 。</p><h3>調度算法的分類</h3><p>毫無疑問，不同的環境下需要不同的調度算法。之所以出現這種情況，是因為不同的應用程序和不同的操作系統有不同的目標。也就是說，在不同的系統中，調度程序的優化也是不同的。這裡有必要劃分出三種環境</p><ul><li>批處理(Batch) : 商業領域</li><li>交互式(Interactive)： 交互式用戶環境</li><li>實時(Real time)</li></ul><h3>批處理中的調度</h3><p>現在讓我們把目光從一般性的調度轉換為特定的調度算法。下面我們會探討在批處理中的調度。</p><h4>先來先服務</h4><p>最簡單的非搶佔式調度算法的設計就是 先來先服務(first-come,first-serverd)。當第一個任務從外部進入系統時，將會立即啟動並允許運行任意長的時間。它不會因為運行時間太長而中斷。當其他作業進入時，它們排到就緒隊列尾部。當正在運行的進程阻塞，處於等待隊列的第一個進程就開始運行。當一個阻塞的進程重新處於就緒態時，它會像一個新到達的任務，會排在隊列的末尾，即排在所有進程最後。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/70a98177954f41409d5970a94dd827a4></p><p>這個算法的強大之處在於易於理解和編程，在這個算法中，一個單鏈表記錄了所有就緒進程。要選取一個進程運行，只要從該隊列的頭部移走一個進程即可；要添加一個新的作業或者阻塞一個進程，只要把這個作業或進程附加在隊列的末尾即可。這是很簡單的一種實現。</p><h4>最短作業優先</h4><p>批處理中，第二種調度算法是 最短作業優先(Shortest Job First)，我們假設運行時間已知。例如，一家保險公司，因為每天要做類似的工作，所以人們可以相當精確地預測處理 1000 個索賠的一批作業需要多長時間。當輸入隊列中有若干個同等重要的作業被啟動時，調度程序應使用最短優先作業算法</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8ae3e193d8354bb49e56973546da9cc5></p><blockquote><p>需要注意的是，在所有的進程都可以運行的情況下，最短作業優先的算法才是最優的。</p></blockquote><h4>最短剩餘時間優先</h4><p>最短作業優先的搶佔式版本被稱作為 最短剩餘時間優先(Shortest Remaining Time Next) 算法。使用這個算法，調度程序總是選擇剩餘運行時間最短的那個進程運行。</p><h3>交互式系統中的調度</h3><p>交互式系統中在個人計算機、服務器和其他系統中都是很常用的，所以有必要來探討一下交互式調度</p><h4>輪詢調度</h4><p>一種最古老、最簡單、最公平並且最廣泛使用的算法就是 輪詢算法(round-robin)。每個進程都會被分配一個時間段，稱為時間片(quantum)，在這個時間片內允許進程運行。如果時間片結束時進程還在運行的話，則搶佔一個 CPU 並將其分配給另一個進程。如果進程在時間片結束前阻塞或結束，則 CPU 立即進行切換。輪詢算法比較容易實現。調度程序所做的就是維護一個可運行進程的列表，就像下圖中的 a，當一個進程用完時間片後就被移到隊列的末尾，就像下圖的 b。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/120020ceaf7e416a86ee6db16419c0e4></p><h4>優先級調度</h4><p>輪詢調度假設了所有的進程是同等重要的。但事實情況可能不是這樣。例如，在一所大學中的等級制度，首先是院長，然後是教授、祕書、後勤人員，最後是學生。這種將外部情況考慮在內就實現了優先級調度(priority scheduling)</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb0200482436459aa9891900f82522e1></p><p>它的基本思想很明確，每個進程都被賦予一個優先級，優先級高的進程優先運行。</p><h4>多級隊列</h4><p>最早使用優先級調度的系統是 CTSS(Compatible TimeSharing System)。CTSS 在每次切換前都需要將當前進程換出到磁盤，並從磁盤上讀入一個新進程。為 CPU 密集型進程設置較長的時間片比頻繁地分給他們很短的時間要更有效（減少交換次數）。另一方面，如前所述，長時間片的進程又會影響到響應時間，解決辦法是設置優先級類。屬於最高優先級的進程運行一個時間片，次高優先級進程運行 2 個時間片，再下面一級運行 4 個時間片，以此類推。當一個進程用完分配的時間片後，它被移到下一類。</p><h4>最短進程優先</h4><p>最短進程優先是根據進程過去的行為進行推測，並執行估計運行時間最短的那一個。假設每個終端上每條命令的預估運行時間為 T0，現在假設測量到其下一次運行時間為 T1，可以用兩個值的加權來改進估計時間，即aT0+ (1- 1)T1。通過選擇 a 的值，可以決定是儘快忘掉老的運行時間，還是在一段長時間內始終記住它們。當 a = 1/2 時，可以得到下面這個序列</p><p>![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)</p><p>可以看到，在三輪過後，T0 在新的估計值中所佔比重下降至 1/8。</p><h4>保證調度</h4><p>一種完全不同的調度方法是對用戶做出明確的性能保證。一種實際而且容易實現的保證是：若用戶工作時有 n 個用戶登錄，則每個用戶將獲得 CPU 處理能力的 1/n。類似地，在一個有 n 個進程運行的單用戶系統中，若所有的進程都等價，則每個進程將獲得 1/n 的 CPU 時間。</p><h4>彩票調度</h4><p>對用戶進行承諾並在隨後兌現承諾是一件好事，不過很難實現。但是存在著一種簡單的方式，有一種既可以給出預測結果而又有一種比較簡單的實現方式的算法，就是 彩票調度(lottery scheduling)算法。</p><p>其基本思想是為進程提供各種系統資源（例如 CPU 時間）的彩票。當做出一個調度決策的時候，就隨機抽出一張彩票，擁有彩票的進程將獲得該資源。在應用到 CPU 調度時，系統可以每秒持有 50 次抽獎，每個中獎者將獲得比如 20 毫秒的 CPU 時間作為獎勵。</p><h4>公平分享調度</h4><p>到目前為止，我們假設被調度的都是各個進程自身，而不用考慮該進程的擁有者是誰。結果是，如果用戶 1 啟動了 9 個進程，而用戶 2 啟動了一個進程，使用輪轉或相同優先級調度算法，那麼用戶 1 將得到 90 % 的 CPU 時間，而用戶 2 將之得到 10 % 的 CPU 時間。</p><p>為了阻止這種情況的出現，一些系統在調度前會把進程的擁有者考慮在內。在這種模型下，每個用戶都會分配一些CPU 時間，而調度程序會選擇進程並強制執行。因此如果兩個用戶每個都會有 50% 的 CPU 時間片保證，那麼無論一個用戶有多少個進程，都將獲得相同的 CPU 份額。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eb0a11978bf3497bac18d248274232e1></p><h3>實時系統中的調度</h3><p>實時系統(real-time) 是一個時間扮演了重要作用的系統。實時系統可以分為兩類，硬實時(hard real time) 和 軟實時(soft real time) 系統，前者意味著必須要滿足絕對的截止時間；後者的含義是雖然不希望偶爾錯失截止時間，但是可以容忍。</p><p>實時系統中的事件可以按照響應方式進一步分類為週期性(以規則的時間間隔發生)事件或 非週期性(發生時間不可預知)事件。一個系統可能要響應多個週期性事件流，根據每個事件處理所需的時間，可能甚至無法處理所有事件。例如，如果有 m 個週期事件，事件 i 以週期 Pi 發生，並需要 Ci 秒 CPU 時間處理一個事件，那麼可以處理負載的條件是</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b623d2a282144fbb00fcbf78e4627ec></p><p>只有滿足這個條件的實時系統稱為可調度的，這意味著它實際上能夠被實現。一個不滿足此檢驗標準的進程不能被調度，因為這些進程共同需要的 CPU 時間總和大於 CPU 能提供的時間。</p><p>下面我們來了解一下內存管理，你需要知道的知識點如下</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d78500d90de43629ca4c439a0779a8c></p><h2>地址空間</h2><p>如果要使多個應用程序同時運行在內存中，必須要解決兩個問題：保護和 重定位。第一種解決方式是用保護密鑰標記內存塊，並將執行過程的密鑰與提取的每個存儲字的密鑰進行比較。這種方式只能解決第一種問題（破壞操作系統），但是不能解決多進程在內存中同時運行的問題。</p><p>還有一種更好的方式是創造一個存儲器抽象：地址空間(the address space)。就像進程的概念創建了一種抽象的 CPU 來運行程序，地址空間也創建了一種抽象內存供程序使用。</p><h4>基址寄存器和變址寄存器</h4><p>最簡單的辦法是使用動態重定位(dynamic relocation)技術，它就是通過一種簡單的方式將每個進程的地址空間映射到物理內存的不同區域。還有一種方式是使用基址寄存器和變址寄存器。</p><ul><li>基址寄存器：存儲數據內存的起始位置</li><li>變址寄存器：存儲應用程序的長度。</li></ul><p>每當進程引用內存以獲取指令或讀取、寫入數據時，CPU 都會自動將基址值添加到進程生成的地址中，然後再將其發送到內存總線上。同時，它檢查程序提供的地址是否大於或等於變址寄存器 中的值。如果程序提供的地址要超過變址寄存器的範圍，那麼會產生錯誤並中止訪問。</p><h3>交換技術</h3><p>在程序運行過程中，經常會出現內存不足的問題。</p><p>針對上面內存不足的問題，提出了兩種處理方式：最簡單的一種方式就是交換(swapping)技術，即把一個進程完整的調入內存，然後再內存中運行一段時間，再把它放回磁盤。空閒進程會存儲在磁盤中，所以這些進程在沒有運行時不會佔用太多內存。另外一種策略叫做虛擬內存(virtual memory)，虛擬內存技術能夠允許應用程序部分的運行在內存中。下面我們首先先探討一下交換</p><h4>交換過程</h4><p>下面是一個交換過程</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f6f13e17142e4d57bb3fcf05fe71a3fb></p><p>剛開始的時候，只有進程 A 在內存中，然後從創建進程 B 和進程 C 或者從磁盤中把它們換入內存，然後在圖 d 中，A 被換出內存到磁盤中，最後 A 重新進來。因為圖 g 中的進程 A 現在到了不同的位置，所以在裝載過程中需要被重新定位，或者在交換程序時通過軟件來執行；或者在程序執行期間通過硬件來重定位。基址寄存器和變址寄存器就適用於這種情況。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86dd8707c072426797f27160985a981a></p><p>交換在內存創建了多個 空閒區(hole)，內存會把所有的空閒區儘可能向下移動合併成為一個大的空閒區。這項技術稱為內存緊縮(memory compaction)。但是這項技術通常不會使用，因為這項技術會消耗很多 CPU 時間。</p><h3>空閒內存管理</h3><p>在進行內存動態分配時，操作系統必須對其進行管理。大致上說，有兩種監控內存使用的方式</p><ul><li>位圖(bitmap)</li><li>空閒列表(free lists)</li></ul><h4>使用位圖的存儲管理</h4><p>使用位圖方法時，內存可能被劃分為小到幾個字或大到幾千字節的分配單元。每個分配單元對應於位圖中的一位，0 表示空閒， 1 表示佔用（或者相反）。一塊內存區域和其對應的位圖如下</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30fe541b987d40c0a988784ee43f1997></p><p>位圖提供了一種簡單的方法在固定大小的內存中跟蹤內存的使用情況，因為<strong>位圖的大小取決於內存和分配單元的大小</strong>。這種方法有一個問題是，當決定為把具有 k 個分配單元的進程放入內存時，內容管理器(memory manager) 必須搜索位圖，在位圖中找出能夠運行 k 個連續 0 位的串。在位圖中找出制定長度的連續 0 串是一個很耗時的操作，這是位圖的缺點。（可以簡單理解為在雜亂無章的數組中，找出具有一大長串空閒的數組單元）</p><h4>使用鏈表進行管理</h4><p>另一種記錄內存使用情況的方法是，維護一個記錄已分配內存段和空閒內存段的鏈表，段會包含進程或者是兩個進程的空閒區域。可用上面的圖 c <strong>來表示內存的使用情況</strong>。鏈表中的每一項都可以代表一個 空閒區(H) 或者是進程(P)的起始標誌，長度和下一個鏈表項的位置。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/711c3e07db3345dd829d84abb6562a3a></p><p>當按照地址順序在鏈表中存放進程和空閒區時，有幾種算法可以為創建的進程（或者從磁盤中換入的進程）分配內存。我們先假設內存管理器知道應該分配多少內存，最簡單的算法是使用 首次適配(first fit)。內存管理器會沿著段列表進行掃描，直到找個一個足夠大的空閒區為止。 除非空閒區大小和要分配的空間大小一樣，否則將空閒區分為兩部分，一部分供進程使用；一部分生成新的空閒區。首次適配算法是一種速度很快的算法，因為它會儘可能的搜索鏈表。</p><p>首次適配的一個小的變體是 下次適配(next fit)。它和首次匹配的工作方式相同，只有一個不同之處那就是下次適配在每次找到合適的空閒區時就會記錄當時的位置，以便下次尋找空閒區時從上次結束的地方開始搜索，而不是像首次匹配算法那樣每次都會從頭開始搜索。</p><p>另外一個著名的並且廣泛使用的算法是 最佳適配(best fit)。最佳適配會從頭到尾尋找整個鏈表，找出能夠容納進程的最小空閒區。</p><h2>虛擬內存</h2><p>儘管基址寄存器和變址寄存器用來創建地址空間的抽象，但是這有一個其他的問題需要解決：管理軟件的不斷增大(managing bloatware)。虛擬內存的基本思想是，每個程序都有自己的地址空間，這個地址空間被劃分為多個稱為頁面(page)的塊。每一頁都是連續的地址範圍。這些頁被映射到物理內存，但並不是所有的頁都必須在內存中才能運行程序。當程序引用到一部分在物理內存中的地址空間時，硬件會立刻執行必要的映射。當程序引用到一部分不在物理內存中的地址空間時，由操作系統負責將缺失的部分裝入物理內存並重新執行失敗的指令。</p><h3>分頁</h3><p>大部分使用虛擬內存的系統中都會使用一種 分頁(paging) 技術。在任何一臺計算機上，程序會引用使用一組內存地址。當程序執行</p><p>MOV REG,1000</p><p>這條指令時，它會把內存地址為 1000 的內存單元的內容複製到 REG 中（或者相反，這取決於計算機）。地址可以通過索引、基址寄存器、段寄存器或其他方式產生。</p><p>這些程序生成的地址被稱為 虛擬地址(virtual addresses) 並形成虛擬地址空間(virtual address space)，在沒有虛擬內存的計算機上，系統直接將虛擬地址送到內存中線上，讀寫操作都使用同樣地址的物理內存。<strong>在使用虛擬內存時，虛擬地址不會直接發送到內存總線上</strong>。相反，會使用 MMU(Memory Management Unit) 內存管理單元把<strong>虛擬地址映射為物理內存地址</strong>，像下圖這樣</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4134993dd1ca403aa77860dec4bcd797></p><p>下面這幅圖展示了這種映射是如何工作的</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c18a75e781944ad1855cada7e469f0ed></p><p>頁表給出虛擬地址與物理內存地址之間的映射關係。每一頁起始於 4096 的倍數位置，結束於 4095 的位置，所以 4K 到 8K 實際為 4096 - 8191 ，8K - 12K 就是 8192 - 12287</p><p>在這個例子中，我們可能有一個 16 位地址的計算機，地址從 0 - 64 K - 1，這些是虛擬地址。然而只有 32 KB 的物理地址。所以雖然可以編寫 64 KB 的程序，但是程序無法全部調入內存運行，在磁盤上必須有一個最多 64 KB 的程序核心映像的完整副本，以保證程序片段在需要時被調入內存。</p><h3>頁表</h3><p>虛擬頁號可作為頁表的索引用來找到虛擬頁中的內容。由頁表項可以找到頁框號（如果有的話）。然後把頁框號拼接到偏移量的高位端，以替換掉虛擬頁號，形成物理地址。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ff1abf50d9214edf8e172d1c1696ad47></p><p>因此，頁表的目的是把虛擬頁映射到頁框中。從數學上說，頁表是一個函數，它的參數是虛擬頁號，結果是物理頁框號。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81e798cbe5c14c1aa1dc9778d982a1a9></p><p>通過這個函數可以把虛擬地址中的虛擬頁轉換為頁框，從而形成物理地址。</p><h4>頁表項的結構</h4><p>下面我們探討一下頁表項的具體結構，上面你知道了頁表項的大致構成，是由頁框號和在/不在位構成的，現在我們來具體探討一下頁表項的構成</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af10b735a77d4e36a15b4dc436f243b0></p><p>頁表項的結構是與機器相關的，但是不同機器上的頁表項大致相同。上面是一個頁表項的構成，不同計算機的頁表項可能不同，但是一般來說都是 32 位的。頁表項中最重要的字段就是頁框號(Page frame number)。畢竟，頁表到頁框最重要的一步操作就是要把此值映射過去。下一個比較重要的就是在/不在位，如果此位上的值是 1，那麼頁表項是有效的並且能夠被使用。如果此值是 0 的話，則表示該頁表項對應的虛擬頁面不在內存中，訪問該頁面會引起一個缺頁異常(page fault)。</p><p>保護位(Protection) 告訴我們哪一種訪問是允許的，啥意思呢？最簡單的表示形式是這個域只有一位，<strong>0 表示可讀可寫，1 表示的是隻讀</strong>。</p><p>修改位(Modified) 和 訪問位(Referenced) 會跟蹤頁面的使用情況。當一個頁面被寫入時，硬件會自動的設置修改位。修改位在頁面重新分配頁框時很有用。如果一個頁面已經被修改過（即它是 髒 的），則必須把它寫回磁盤。如果一個頁面沒有被修改過（即它是 乾淨的），那麼重新分配時這個頁框會被直接丟棄，因為磁盤上的副本仍然是有效的。這個位有時也叫做 髒位(dirty bit)，因為它反映了頁面的狀態。</p><p>訪問位(Referenced) 在頁面被訪問時被設置，不管是讀還是寫。這個值能夠幫助操作系統在發生缺頁中斷時選擇要淘汰的頁。不再使用的頁要比正在使用的頁更適合被淘汰。這個位在後面要討論的頁面置換算法中作用很大。</p><p>最後一位用於禁止該頁面被高速緩存，這個功能對於映射到設備寄存器還是內存中起到了關鍵作用。通過這一位可以禁用高速緩存。具有獨立的 I/O 空間而不是用內存映射 I/O 的機器來說，並不需要這一位。</p><h2>頁面置換算法</h2><p>下面我們就來探討一下有哪些頁面置換算法。</p><h3>最優頁面置換算法</h3><p>最優的頁面置換算法的工作流程如下：在缺頁中斷髮生時，這些頁面之一將在下一條指令（包含該指令的頁面）上被引用。其他頁面則可能要到 10、100 或者 1000 條指令後才會被訪問。每個頁面都可以用在該頁首次被訪問前所要執行的指令數作為標記。</p><p>最優化的頁面算法表明應該標記最大的頁面。如果一個頁面在 800 萬條指令內不會被使用，另外一個頁面在 600 萬條指令內不會被使用，則置換前一個頁面，從而把需要調入這個頁面而發生的缺頁中斷推遲。計算機也像人類一樣，會把不願意做的事情儘可能的往後拖。</p><p>這個算法最大的問題時無法實現。當缺頁中斷髮生時，操作系統無法知道各個頁面的下一次將在什麼時候被訪問。這種算法在實際過程中根本不會使用。</p><h3>最近未使用頁面置換算法</h3><p>為了能夠讓操作系統收集頁面使用信息，大部分使用虛擬地址的計算機都有兩個狀態位，R 和 M，來和每個頁面進行關聯。<strong>每當引用頁面（讀入或寫入）時都設置 R，寫入（即修改）頁面時設置 M</strong>，這些位包含在每個頁表項中，就像下面所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/465e443916a74425b1eb696dc800a11d></p><p>因為每次訪問時都會更新這些位，因此由硬件來設置它們非常重要。一旦某個位被設置為 1，就會一直保持 1 直到操作系統下次來修改此位。</p><p>如果硬件沒有這些位，那麼可以使用操作系統的缺頁中斷和時鐘中斷機制來進行模擬。當啟動一個進程時，將其所有的頁面都標記為不在內存；一旦訪問任何一個頁面就會引發一次缺頁中斷，此時操作系統就可以設置 R 位(在它的內部表中)，修改頁表項使其指向正確的頁面，並設置為 READ ONLY 模式，然後重新啟動引起缺頁中斷的指令。如果頁面隨後被修改，就會發生另一個缺頁異常。從而允許操作系統設置 M 位並把頁面的模式設置為 READ/WRITE。</p><p>可以用 R 位和 M 位來構造一個簡單的頁面置換算法：當啟動一個進程時，操作系統將其所有頁面的兩個位都設置為 0。R 位定期的被清零（在每個時鐘中斷）。用來將最近未引用的頁面和已引用的頁面分開。</p><p>當出現缺頁中斷後，操作系統會檢查所有的頁面，並根據它們的 R 位和 M 位將當前值分為四類：</p><ul><li>第 0 類：沒有引用 R，沒有修改 M</li><li>第 1 類：沒有引用 R，已修改 M</li><li>第 2 類：引用 R ，沒有修改 M</li><li>第 3 類：已被訪問 R，已被修改 M</li></ul><p>儘管看起來好像無法實現第一類頁面，但是當第三類頁面的 R 位被時鐘中斷清除時，它們就會發生。時鐘中斷不會清除 M 位，因為需要這個信息才能知道是否寫回磁盤中。清除 R 但不清除 M 會導致出現一類頁面。</p><p>NRU(Not Recently Used) 算法從編號最小的非空類中隨機刪除一個頁面。此算法隱含的思想是，在一個時鐘內（約 20 ms）淘汰一個已修改但是沒有被訪問的頁面要比一個大量引用的未修改頁面好，NRU 的主要優點是<strong>易於理解並且能夠有效的實現</strong>。</p><h3>先進先出頁面置換算法</h3><p>另一種開銷較小的方式是使用 FIFO(First-In,First-Out) 算法，這種類型的數據結構也適用在頁面置換算法中。由操作系統維護一個所有在當前內存中的頁面的鏈表，最早進入的放在表頭，最新進入的頁面放在表尾。在發生缺頁異常時，會把頭部的頁移除並且把新的頁添加到表尾。</p><h3>第二次機會頁面置換算法</h3><p>我們上面學到的 FIFO 鏈表頁面有個缺陷，那就是出鏈和入鏈並不會進行 check 檢查，這樣就會容易把經常使用的頁面置換出去，為了避免這一問題，我們對該算法做一個簡單的修改：我們檢查最老頁面的 R 位，如果是 0 ，那麼這個頁面就是最老的而且沒有被使用，那麼這個頁面就會被立刻換出。如果 R 位是 1，那麼就清除此位，此頁面會被放在鏈表的尾部，修改它的裝入時間就像剛放進來的一樣。然後繼續搜索。</p><p>這種算法叫做 第二次機會(second chance)算法，就像下面這樣，我們看到頁面 A 到 H 保留在鏈表中，並按到達內存的時間排序。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f89e0afcb34a44f3b363e43ebc596933></p><p>a）按照先進先出的方法排列的頁面；b）在時刻 20 處發生缺頁異常中斷並且 A 的 R 位已經設置時的頁面鏈表。</p><p>假設缺頁異常發生在時刻 20 處，這時最老的頁面是 A ，它是在 0 時刻到達的。如果 A 的 R 位是 0，那麼它將被淘汰出內存，或者把它寫回磁盤（如果它已經被修改過），或者只是簡單的放棄（如果它是未被修改過）。另一方面，如果它的 R 位已經設置了，則將 A 放到鏈表的尾部並且重新設置裝入時間為當前時刻（20 處），然後清除 R 位。然後從 B 頁面開始繼續搜索合適的頁面。</p><p>尋找第二次機會的是在最近的時鐘間隔中未被訪問過的頁面。如果所有的頁面都被訪問過，該算法就會被簡化為單純的 FIFO 算法。具體來說，假設圖 a 中所有頁面都設置了 R 位。操作系統將頁面依次移到鏈表末尾，每次都在添加到末尾時清除 R 位。最後，算法又會回到頁面 A，此時的 R 位已經被清除，那麼頁面 A 就會被執行出鏈處理，因此算法能夠正常結束。</p><h3>時鐘頁面置換算法</h3><p>一種比較好的方式是把所有的頁面都保存在一個類似鐘面的環形鏈表中，一個錶針指向最老的頁面。如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cc59316ed3b145679636a19487f4a270></p><p>當缺頁錯誤出現時，算法首先檢查錶針指向的頁面，如果它的 R 位是 0 就淘汰該頁面，並把新的頁面插入到這個位置，然後把錶針向前移動一位；如果 R 位是 1 就清除 R 位並把錶針前移一個位置。重複這個過程直到找到了一個 R 位為 0 的頁面位置。瞭解這個算法的工作方式，就明白為什麼它被稱為 時鐘(clokc)算法了。</p><h3>最近最少使用頁面置換算法</h3><p>在前面幾條指令中頻繁使用的頁面和可能在後面的幾條指令中被使用。反過來說，已經很久沒有使用的頁面有可能在未來一段時間內仍不會被使用。這個思想揭示了一個可以實現的算法：在缺頁中斷時，置換未使用時間最長的頁面。這個策略稱為 LRU(Least Recently Used) ，最近最少使用頁面置換算法。</p><p>雖然 LRU 在理論上是可以實現的，但是從長遠看來代價比較高。為了完全實現 LRU，會在內存中維護一個所有頁面的鏈表，最頻繁使用的頁位於表頭，最近最少使用的頁位於表尾。困難的是在每次內存引用時更新整個鏈表。在鏈表中找到一個頁面，刪除它，然後把它移動到表頭是一個非常耗時的操作，即使使用硬件來實現也是一樣的費時。</p><h3>用軟件模擬 LRU</h3><p>儘管上面的 LRU 算法在原則上是可以實現的，<strong>但是很少有機器能夠擁有那些特殊的硬件</strong>。上面是硬件的實現方式，那麼現在考慮要用軟件來實現 LRU 。一種可以實現的方案是 NFU(Not Frequently Used，最不常用)算法。它需要一個軟件計數器來和每個頁面關聯，初始化的時候是 0 。在每個時鐘中斷時，操作系統會瀏覽內存中的所有頁，會將每個頁面的 R 位（0 或 1）加到它的計數器上。這個計數器大體上跟蹤了各個頁面訪問的頻繁程度。當缺頁異常出現時，則置換計數器值最小的頁面。</p><p>只需要對 NFU 做一個簡單的修改就可以讓它模擬 LRU，這個修改有兩個步驟</p><ul><li>首先，在 R 位被添加進來之前先把計數器右移一位；</li><li>第二步，R 位被添加到最左邊的位而不是最右邊的位。</li></ul><p>修改以後的算法稱為 老化(aging) 算法，下圖解釋了老化算法是如何工作的。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bdccc7c258c044a78dac8501c7d485db></p><p>我們假設在第一個時鐘週期內頁面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是頁面 0 是 1，頁面 1 是 0，頁面 2 是 1 這樣類推）。也就是說，<strong>在 0 個時鐘週期到 1 個時鐘週期之間，0，2，4，5 都被引用了</strong>，從而把它們的 R 位設置為 1，剩下的設置為 0 。在相關的六個計數器被右移之後 R 位被添加到 左側 ，就像上圖中的 a。剩下的四列顯示了接下來的四個時鐘週期內的六個計數器變化。</p><blockquote><p>CPU正在以某個頻率前進，該頻率的週期稱為時鐘滴答或時鐘週期。一個 100Mhz 的處理器每秒將接收100,000,000個時鐘滴答。</p></blockquote><p>當缺頁異常出現時，將置換（就是移除）計數器值最小的頁面。如果一個頁面在前面 4 個時鐘週期內都沒有被訪問過，那麼它的計數器應該會有四個連續的 0 ，因此它的值肯定要比前面 3 個時鐘週期內都沒有被訪問過的頁面的計數器小。</p><p>這個算法與 LRU 算法有兩個重要的區別：看一下上圖中的 e，第三列和第五列</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebf68175f87347c198ecb9cd42964f67></p><h3>工作集時鐘頁面置換算法</h3><p>當缺頁異常發生後，需要掃描整個頁表才能確定被淘汰的頁面，因此基本工作集算法還是比較浪費時間的。一個對基本工作集算法的提升是基於時鐘算法但是卻使用工作集的信息，這種算法稱為WSClock(工作集時鐘)。由於它的實現簡單並且具有高性能，因此在實踐中被廣泛應用。</p><p>與時鐘算法一樣，所需的數據結構是一個以頁框為元素的循環列表，就像下面這樣</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa76676b35da40b499e33c6fafdd2290></p><p>工作集時鐘頁面置換算法的操作：a) 和 b) 給出 R = 1 時所發生的情形；c) 和 d) 給出 R = 0 的例子</p><p>最初的時候，該表是空的。當裝入第一個頁面後，把它加載到該表中。隨著更多的頁面的加入，它們形成一個環形結構。每個表項包含來自基本工作集算法的上次使用時間，以及 R 位（已標明）和 M 位（未標明）。</p><p>與時鐘算法一樣，在每個缺頁異常時，首先檢查指針指向的頁面。如果 R 位被是設置為 1，該頁面在當前時鐘週期內就被使用過，那麼該頁面就不適合被淘汰。然後把該頁面的 R 位置為 0，指針指向下一個頁面，並重復該算法。該事件序列化後的狀態參見圖 b。</p><p>現在考慮指針指向的頁面 R = 0 時會發生什麼，參見圖 c，如果頁面的使用期限大於 t 並且頁面為被訪問過，那麼這個頁面就不會在工作集中，並且在磁盤上會有一個此頁面的副本。申請重新調入一個新的頁面，並把新的頁面放在其中，如圖 d 所示。另一方面，如果頁面被修改過，就不能重新申請頁面，因為這個頁面在磁盤上沒有有效的副本。為了避免由於調度寫磁盤操作引起的進程切換，指針繼續向前走，算法繼續對下一個頁面進行操作。畢竟，有可能存在一個老的，沒有被修改過的頁面可以立即使用。</p><p>原則上來說，所有的頁面都有可能因為磁盤I/O 在某個時鐘週期內被調度。為了降低磁盤阻塞，需要設置一個限制，即最大隻允許寫回 n 個頁面。一旦達到該限制，就不允許調度新的寫操作。</p><p>那麼就有個問題，指針會繞一圈回到原點的，如果回到原點，它的起始點會發生什麼？這裡有兩種情況：</p><ul><li>至少調度了一次寫操作</li><li>沒有調度過寫操作</li></ul><p>在第一種情況中，指針僅僅是不停的移動，尋找一個未被修改過的頁面。由於已經調度了一個或者多個寫操作，最終會有某個寫操作完成，它的頁面會被標記為未修改。置換遇到的第一個未被修改過的頁面，這個頁面不一定是第一個被調度寫操作的頁面，因為硬盤驅動程序為了優化性能可能會把寫操作重排序。</p><p>對於第二種情況，所有的頁面都在工作集中，否則將至少調度了一個寫操作。由於缺乏額外的信息，最簡單的方法就是置換一個未被修改的頁面來使用，掃描中需要記錄未被修改的頁面的位置，如果不存在未被修改的頁面，就選定當前頁面並把它寫回磁盤。</p><h3>頁面置換算法小結</h3><p>我們到現在已經研究了各種頁面置換算法，現在我們來一個簡單的總結，算法的總結歸納如下</p><p>算法註釋最優算法不可實現，但可以用作基準NRU(最近未使用) 算法和 LRU 算法很相似FIFO(先進先出) 算法有可能會拋棄重要的頁面第二次機會算法比 FIFO 有較大的改善時鐘算法實際使用LRU(最近最少)算法比較優秀，但是很難實現NFU(最不經常食用)算法和 LRU 很類似老化算法近似 LRU 的高效算法工作集算法實施起來開銷很大工作集時鐘算法比較有效的算法</p><ul><li><p>最優算法在當前頁面中置換最後要訪問的頁面。不幸的是，沒有辦法來判定哪個頁面是最後一個要訪問的，因此實際上該算法不能使用。然而，它可以作為衡量其他算法的標準。</p></li><li><p>NRU 算法根據 R 位和 M 位的狀態將頁面氛圍四類。從編號最小的類別中隨機選擇一個頁面。NRU 算法易於實現，但是性能不是很好。存在更好的算法。</p></li><li><p>FIFO 會跟蹤頁面加載進入內存中的順序，並把頁面放入一個鏈表中。有可能刪除存在時間最長但是還在使用的頁面，因此這個算法也不是一個很好的選擇。</p></li><li><p>第二次機會算法是對 FIFO 的一個修改，它會在刪除頁面之前檢查這個頁面是否仍在使用。如果頁面正在使用，就會進行保留。這個改進大大提高了性能。</p></li><li><p>時鐘 算法是第二次機會算法的另外一種實現形式，時鐘算法和第二次算法的性能差不多，但是會花費更少的時間來執行算法。</p></li><li><p>LRU 算法是一個非常優秀的算法，但是沒有特殊的硬件(TLB)很難實現。如果沒有硬件，就不能使用 LRU 算法。</p></li><li><p>NFU 算法是一種近似於 LRU 的算法，它的性能不是非常好。</p></li><li><p>老化 算法是一種更接近 LRU 算法的實現，並且可以更好的實現，因此是一個很好的選擇</p></li><li><p>最後兩種算法都使用了工作集算法。工作集算法提供了合理的性能開銷，但是它的實現比較複雜。WSClock 是另外一種變體，它不僅能夠提供良好的性能，而且可以高效地實現。</p></li></ul><p>總之，<strong>最好的算法是老化算法和WSClock算法</strong>。他們分別是基於 LRU 和工作集算法。他們都具有良好的性能並且能夠被有效的實現。還存在其他一些好的算法，但實際上這兩個可能是最重要的。</p><p>下面來聊一聊文件系統，你需要知道下面這些知識點</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8783a883a02b4772a5b2ae5b0b2f0672></p><h2>文件</h2><h3>文件命名</h3><p>文件是一種抽象機制，它提供了一種方式用來存儲信息以及在後面進行讀取。可能任何一種機制最重要的特性就是管理對象的命名方式。在創建一個文件後，它會給文件一個命名。當進程終止時，文件會繼續存在，並且其他進程可以使用名稱訪問該文件。</p><p>文件命名規則對於不同的操作系統來說是不一樣的，但是所有現代操作系統都允許使用 1 - 8 個字母的字符串作為合法文件名。</p><p>某些文件區分大小寫字母，而大多數則不區分。UNIX 屬於第一類；歷史悠久的 MS-DOS 屬於第二類（順便說一句，儘管 MS-DOS 歷史悠久，但 MS-DOS 仍在嵌入式系統中非常廣泛地使用，因此它絕不是過時的）；因此，UNIX 系統會有三種不同的命名文件：maria、Maria、MARIA 。在 MS-DOS ，所有這些命名都屬於相同的文件。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a6e9511ee8b41e3afe48a909912893e></p><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>萬字</a></li><li><a>97</a></li><li><a>張圖</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/aafa7dc.html alt="5萬字、97 張圖總結操作系統核心知識點(下)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c3b64f421acc45b2a147aa814c139b48 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aafa7dc.html title="5萬字、97 張圖總結操作系統核心知識點(下)">5萬字、97 張圖總結操作系統核心知識點(下)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4c5606f.html alt=21張圖譜解析21種儀器原理及應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e4cf495f5e44418f95dbf149a8f2b174 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4c5606f.html title=21張圖譜解析21種儀器原理及應用>21張圖譜解析21種儀器原理及應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1dfdbb27.html alt=這4張圖如果不懂，自噴至少損失8分！（詳解報警閥！） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5fe122eff5694ace8861fcc8d3dab174 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1dfdbb27.html title=這4張圖如果不懂，自噴至少損失8分！（詳解報警閥！）>這4張圖如果不懂，自噴至少損失8分！（詳解報警閥！）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b011459.html alt=拳皇97金家藩隊全人物介紹、出招表、高清圖片僅供收藏（七） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d1297f468bc64cd296fec5cd8b06b67f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b011459.html title=拳皇97金家藩隊全人物介紹、出招表、高清圖片僅供收藏（七）>拳皇97金家藩隊全人物介紹、出招表、高清圖片僅供收藏（七）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5368032e.html alt=僅28張圖說清壓力錶及附件的選擇與安裝姿勢，就這麼簡單？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/94975f451af74934a9557e45396dab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5368032e.html title=僅28張圖說清壓力錶及附件的選擇與安裝姿勢，就這麼簡單？>僅28張圖說清壓力錶及附件的選擇與安裝姿勢，就這麼簡單？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/46ff8566.html alt=輸入主題就能生成萬字文章？解密狗屁不通文章生成器！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c2383ec46acf4ed5aec149441b42dea8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/46ff8566.html title=輸入主題就能生成萬字文章？解密狗屁不通文章生成器！>輸入主題就能生成萬字文章？解密狗屁不通文章生成器！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/530dc6c1.html alt=西遊記連載（文字版）第97一100回 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d55f1c57abc5485b92a6876b29ab5793 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/530dc6c1.html title=西遊記連載（文字版）第97一100回>西遊記連載（文字版）第97一100回</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51b15950.html alt=18張圖，幫你“扒”光一箇中國醫生 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R69MoTNH1oohss style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51b15950.html title=18張圖，幫你“扒”光一箇中國醫生>18張圖，幫你“扒”光一箇中國醫生</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe84c631.html alt=武漢：6日97條求助信息得到積極響應 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe84c631.html title=武漢：6日97條求助信息得到積極響應>武漢：6日97條求助信息得到積極響應</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea1261c8.html alt="25 張圖讀懂「文件系統」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S7ioqtx8IVQKiQ style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea1261c8.html title="25 張圖讀懂「文件系統」">25 張圖讀懂「文件系統」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/453083d5.html alt=福州97條道路廣告牌大提升，你覺得好看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d6e1524b0a9a4c0bbfb54b25f73f9d3d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/453083d5.html title=福州97條道路廣告牌大提升，你覺得好看嗎>福州97條道路廣告牌大提升，你覺得好看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/140771cb.html alt=20張圖讓你掌握常用放大器配置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/674ee6fd7b0d433aaf3b8279b7f1efef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/140771cb.html title=20張圖讓你掌握常用放大器配置>20張圖讓你掌握常用放大器配置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fd215c8.html alt=22張圖帶你瞭解螺紋緊固件及螺紋連接畫法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c43522f7797b434f927a4761a25a0d3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fd215c8.html title=22張圖帶你瞭解螺紋緊固件及螺紋連接畫法>22張圖帶你瞭解螺紋緊固件及螺紋連接畫法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a7bf3e2.html alt=什麼葡萄品種好？7張圖囊括50個品種對比！幾十年實戰經驗總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15281038686255b03364e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a7bf3e2.html title=什麼葡萄品種好？7張圖囊括50個品種對比！幾十年實戰經驗總結！>什麼葡萄品種好？7張圖囊括50個品種對比！幾十年實戰經驗總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb440040.html alt=拐角裝修怎麼做？9張圖告訴你答案，省空間又有格調！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66b600029597e8d74b6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb440040.html title=拐角裝修怎麼做？9張圖告訴你答案，省空間又有格調！>拐角裝修怎麼做？9張圖告訴你答案，省空間又有格調！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>