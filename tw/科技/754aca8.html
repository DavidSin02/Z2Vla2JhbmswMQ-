<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus | 极客快訊</title><meta property="og:title" content="Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/153260587912802d119c482"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/754aca8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><meta property="article:published_time" content="2020-10-29T21:04:29+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/754aca8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>背景</strong></p><p>對於Android系統來說，消息傳遞是最基本的組件，每一個App內的不同頁面，不同組件都在進行消息傳遞。消息傳遞既可以用於Android四大組件之間的通信，也可用於異步線程和主線程之間的通信。對於Android開發者來說，經常使用的消息傳遞方式有很多種，從最早使用的Handler、BroadcastReceiver、接口回調，到近幾年流行的通信總線類框架EventBus、RxBus。Android消息傳遞框架，總在不斷的演進之中。</p><p><strong>從EventBus說起</strong></p><p>EventBus是一個Android事件發佈/訂閱框架，通過解耦發佈者和訂閱者簡化Android事件傳遞。EventBus可以代替Android傳統的Intent、Handler、Broadcast或接口回調，在Fragment、Activity、Service線程之間傳遞數據，執行方法。</p><p>EventBus最大的特點就是簡潔、解耦。在沒有EventBus之前我們通常用廣播來實現監聽，或者自定義接口函數回調，有的場景我們也可以直接用Intent攜帶簡單數據，或者在線程之間通過Handler處理消息傳遞。但無論是廣播還是Handler機制遠遠不能滿足我們高效的開發。EventBus簡化了應用程序內各組件間、組件與後臺線程間的通信。EventBus一經推出，便受到廣大開發者的推崇。</p><p>現在看來，EventBus給Android開發者世界帶來了一種新的框架和思想，就是消息的發佈和訂閱。這種思想在其後很多框架中都得到了應用。</p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153260587912802d119c482><p class=pgc-img-caption></p></div><p>圖片摘自EventBus GitHub主頁</p><p><strong>發佈/訂閱模式</strong></p><p>訂閱發佈模式定義了一種“一對多”的依賴關係，讓多個訂閱者對象同時監聽某一個主題對象。這個主題對象在自身狀態變化時，會通知所有訂閱者對象，使它們能夠自動更新自己的狀態。</p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1532605879208bb17a1c8b4><p class=pgc-img-caption></p></div><p><strong>RxBus的出現</strong></p><p>RxBus不是一個庫，而是一個文件，實現只有短短30行代碼。RxBus本身不需要過多分析，它的強大完全來自於它基於的RxJava技術。響應式編程（Reactive Programming）技術這幾年特別火，RxJava是它在Java上的實作。RxJava天生就是發佈/訂閱模式，而且很容易處理線程切換。所以，RxBus憑藉區區30行代碼，就敢挑戰EventBus“江湖老大”的地位。</p><p><strong>RxBus原理</strong></p><p>在RxJava中有個Subject類，它繼承Observable類，同時實現了Observer接口，因此Subject可以同時擔當訂閱者和被訂閱者的角色，我們使用Subject的子類PublishSubject來創建一個Subject對象（PublishSubject只有被訂閱後才會把接收到的事件立刻發送給訂閱者），在需要接收事件的地方，訂閱該Subject對象，之後如果Subject對象接收到事件，則會發射給該訂閱者，此時Subject對象充當被訂閱者的角色。</p><p>完成了訂閱，在需要發送事件的地方將事件發送給之前被訂閱的Subject對象，則此時Subject對象作為訂閱者接收事件，然後會立刻將事件轉發給訂閱該Subject對象的訂閱者，以便訂閱者處理相應事件，到這裡就完成了事件的發送與處理。</p><p>最後就是取消訂閱的操作了，RxJava中，訂閱操作會返回一個Subscription對象，以便在合適的時機取消訂閱，防止內存洩漏，如果一個類產生多個Subscription對象，我們可以用一個CompositeSubscription存儲起來，以進行批量的取消訂閱。</p><p><strong>RxBus有很多實現，如：</strong></p><blockquote><p>AndroidKnife/RxBus（https://github.com/AndroidKnife/RxBus）</p><p>Blankj/RxBus（https://github.com/Blankj/RxBus）</p></blockquote><p>其實正如前面所說的，RxBus的原理是如此簡單，我們自己都可以寫出一個RxBus的實現：</p><p><strong>基於RxJava1的RxBus實現：</strong></p><blockquote><p>public final class RxBus {</p><p>private final Subject&lt;Object, Object> bus;</p><p>private RxBus() {</p><p>bus = new SerializedSubject&lt;>(PublishSubject.create());</p><p>}</p><p>private static class SingletonHolder {</p><p>private static final RxBus defaultRxBus = new RxBus();</p><p>}</p><p>public static RxBus getInstance() {</p><p>return SingletonHolder.defaultRxBus;</p><p>}</p><p>/*</p><p>* 發送</p><p>*/</p><p>public void post(Object o) {</p><p>bus.onNext(o);</p><p>}</p><p>/*</p><p>* 是否有Observable訂閱</p><p>*/</p><p>public boolean hasObservable() {</p><p>return bus.hasObservers();</p><p>}</p><p>/*</p><p>* 轉換為特定類型的Obserbale</p><p>*/</p><p>public &lt;T> Observable&lt;T> toObservable(Class&lt;T> type) {</p><p>return bus.ofType(type);</p><p>}</p><p>}</p></blockquote><p><strong>基於RxJava2的RxBus實現：</strong></p><blockquote><p>public final class RxBus2 {</p><p>private final Subject&lt;Object> bus;</p><p>private RxBus2() {</p><p>// toSerialized method made bus thread safe</p><p>bus = PublishSubject.create().toSerialized();</p><p>}</p><p>public static RxBus2 getInstance() {</p><p>return Holder.BUS;</p><p>}</p><p>private static class Holder {</p><p>private static final RxBus2 BUS = new RxBus2();</p><p>}</p><p>public void post(Object obj) {</p><p>bus.onNext(obj);</p><p>}</p><p>public &lt;T> Observable&lt;T> toObservable(Class&lt;T> tClass) {</p><p>return bus.ofType(tClass);</p><p>}</p><p>public Observable&lt;Object> toObservable() {</p><p>return bus;</p><p>}</p><p>public boolean hasObservers() {</p><p>return bus.hasObservers();</p><p>}</p><p>}</p></blockquote><p><strong>引入LiveDataBus的想法</strong></p><p><strong>從LiveData談起</strong></p><p>LiveData是Android Architecture Components提出的框架。LiveData是一個可以被觀察的數據持有類，它可以感知並遵循Activity、Fragment或Service等組件的生命週期。正是由於LiveData對組件生命週期可感知特點，因此可以做到僅在組件處於生命週期的激活狀態時才更新UI數據。</p><p>LiveData需要一個觀察者對象，一般是Observer類的具體實現。當觀察者的生命週期處於STARTED或RESUMED狀態時，LiveData會通知觀察者數據變化；在觀察者處於其他狀態時，即使LiveData的數據變化了，也不會通知。</p><p><strong>LiveData的優點</strong></p><ul><li><strong>UI和實時數據保持一致，</strong>因為LiveData採用的是觀察者模式，這樣一來就可以在數據發生改變時獲得通知，更新UI。</li><li><strong>避免內存洩漏，</strong>觀察者被綁定到組件的生命週期上，當被綁定的組件銷燬（destroy）時，觀察者會立刻自動清理自身的數據。</li><li><strong>不會再產生由於Activity處於stop狀態而引起的崩潰，</strong>例如：當Activity處於後臺狀態時，是不會收到LiveData的任何事件的。</li><li><strong>不需要再解決生命週期帶來的問題，</strong>LiveData可以感知被綁定的組件的生命週期，只有在活躍狀態才會通知數據變化。</li><li><strong>實時數據刷新，</strong>當組件處於活躍狀態或者從不活躍狀態到活躍狀態時總是能收到最新的數據。</li><li><strong>解決Configuration Change問題，</strong>在屏幕發生旋轉或者被回收再次啟動，立刻就能收到最新的數據。</li></ul><p>談一談Android Architecture Components</p><p>Android Architecture Components的核心是Lifecycle、LiveData、ViewModel 以及 Room，通過它可以非常優雅的讓數據與界面進行交互，並做一些持久化的操作，高度解耦，自動管理生命週期，而且不用擔心內存洩漏的問題。</p><ul><li><strong>Room</strong></li><li>一個強大的SQLite對象映射庫。</li><li><strong>ViewModel</strong></li><li>一類對象，它用於為UI組件提供數據，在設備配置發生變更時依舊可以存活。</li><li><strong>LiveData</strong> 一個可感知生命週期、可被觀察的數據容器，它可以存儲數據，還會在數據發生改變時進行提醒。</li><li><strong>Lifecycle</strong></li><li>包含LifeCycleOwer和LifecycleObserver，分別是生命週期所有者和生命週期感知者。</li></ul><p><strong>Android Architecture Components的特點</strong></p><ul><li><strong>數據驅動型編程</strong></li><li>變化的永遠是數據，界面無需更改。</li><li><strong>感知生命週期，防止內存洩漏</strong></li><li><strong>高度解耦</strong></li><li>數據，界面高度分離。</li><li><strong>數據持久化</strong></li><li>數據、ViewModel不與 UI的生命週期掛鉤，不會因為界面的重建而銷燬。</li></ul><p><strong>重點：為什麼使用LiveData構建數據通信總線LiveDataBus</strong></p><p><strong>使用LiveData的理由</strong></p><ul><li><strong>LiveData具有的這種可觀察性和生命週期感知的能力，使其非常適合作為Android通信總線的基礎構件。</strong></li><li><strong>使用者不用顯示調用反註冊方法。</strong></li><li>由於LiveData具有生命週期感知能力，所以LiveDataBus只需要調用註冊回調方法，而不需要顯示的調用反註冊方法。這樣帶來的好處不僅可以編寫更少的代碼，而且可以完全杜絕其他通信總線類框架（如EventBus、RxBus）忘記調用反註冊所帶來的內存洩漏的風險。</li></ul><p><strong>為什麼要用LiveDataBus替代EventBus和RxBus</strong></p><ul><li><strong>LiveDataBus的實現及其簡單</strong>，相對EventBus複雜的實現，LiveDataBus只需要一個類就可以實現。</li><li><strong>LiveDataBus可以減小APK包的大小</strong>，由於LiveDataBus只依賴Android官方Android Architecture Components組件的LiveData，沒有其他依賴，本身實現只有一個類。作為比較，EventBus JAR包大小為57kb，RxBus依賴RxJava和RxAndroid，其中RxJava2包大小2.2MB，RxJava1包大小1.1MB，RxAndroid包大小9kb。使用LiveDataBus可以大大減小APK包的大小。</li><li><strong>LiveDataBus依賴方支持更好</strong>，LiveDataBus只依賴Android官方Android Architecture Components組件的LiveData，相比RxBus依賴的RxJava和RxAndroid，依賴方支持更好。</li><li><strong>LiveDataBus具有生命週期感知</strong>，LiveDataBus具有生命週期感知，在Android系統中使用調用者不需要調用反註冊，相比EventBus和RxBus使用更為方便，並且沒有內存洩漏風險。</li></ul><p><strong>LiveDataBus的設計和架構</strong></p><p><strong>LiveDataBus的組成</strong></p><ul><li><strong>消息</strong></li><li>消息可以是任何的Object，可以定義不同類型的消息，如Boolean、String。也可以定義自定義類型的消息。</li><li><strong>消息通道</strong></li><li>LiveData扮演了消息通道的角色，不同的消息通道用不同的名字區分，名字是String類型的，可以通過名字獲取到一個LiveData消息通道。</li><li><strong>消息總線</strong></li><li>消息總線通過單例實現，不同的消息通道存放在一個HashMap中。</li><li><strong>訂閱</strong></li><li>訂閱者通過getChannel獲取消息通道，然後調用observe訂閱這個通道的消息。</li><li><strong>發佈</strong></li><li>發佈者通過getChannel獲取消息通道，然後調用setValue或者postValue發佈消息。</li></ul><p><strong>LiveDataBus原理圖</strong></p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1532605879297c275574cb1><p class=pgc-img-caption></p></div><p><strong>LiveDataBus的實現</strong></p><p><strong>第一個實現：</strong></p><blockquote><p>public final class LiveDataBus {</p><p>private final Map&lt;String, MutableLiveData&lt;Object>> bus;</p><p>private LiveDataBus() {</p><p>bus = new HashMap&lt;>();</p><p>}</p><p>private static class SingletonHolder {</p><p>private static final LiveDataBus DATA_BUS = new LiveDataBus();</p><p>}</p><p>public static LiveDataBus get() {</p><p>return SingletonHolder.DATA_BUS;</p><p>}</p><p>public &lt;T> MutableLiveData&lt;T> getChannel(String target, Class&lt;T> type) {</p><p>if (!bus.containsKey(target)) {</p><p>bus.put(target, new MutableLiveData&lt;>());</p><p>}</p><p>return (MutableLiveData&lt;T>) bus.get(target);</p><p>}</p><p>public MutableLiveData&lt;Object> getChannel(String target) {</p><p>return getChannel(target, Object.class);</p><p>}</p><p>}</p></blockquote><p>短短二十行代碼，就實現了一個通信總線的全部功能，並且還具有生命週期感知功能，並且使用起來也及其簡單：</p><p><strong>註冊訂閱：</strong></p><blockquote><p>LiveDataBus.get().getChannel("key_test", Boolean.class)</p><p>.observe(this, new Observer&lt;Boolean>() {</p><p>@Override</p><p>public void onChanged(@Nullable Boolean aBoolean) {</p><p>}</p><p>});</p></blockquote><p><strong>發送消息：</strong></p><blockquote><p>LiveDataBus.get().getChannel("key_test").setValue(true);</p></blockquote><p>我們發送了一個名為"key_test"，值為true的事件。</p><p>這個時候訂閱者就會收到消息，並作相應的處理，非常簡單。</p><p><strong>問題出現</strong></p><p>對於LiveDataBus的第一版實現，我們發現，在使用這個LiveDataBus的過程中，訂閱者會收到訂閱之前發佈的消息。對於一個消息總線來說，這是不可接受的。無論EventBus或者RxBus，訂閱方都不會收到訂閱之前發出的消息。對於一個消息總線，LiveDataBus必須要解決這個問題。</p><p><strong>問題分析</strong></p><p>怎麼解決這個問題呢？先分析下原因：</p><p>當LifeCircleOwner的狀態發生變化的時候，會調用LiveData.ObserverWrapper的activeStateChanged函數，如果這個時候ObserverWrapper的狀態是active，就會調用LiveData的dispatchingValue。</p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15326058791517f12641571><p class=pgc-img-caption></p></div><p>在LiveData的dispatchingValue中，又會調用LiveData的considerNotify方法。</p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15326058792210910f8b537><p class=pgc-img-caption></p></div><p>在LiveData的considerNotify方法中，紅框中的邏輯是關鍵，如果ObserverWrapper的mLastVersion小於LiveData的mVersion，就會去回調mObserver的onChanged方法。而每個新的訂閱者，其version都是-1，LiveData一旦設置過其version是大於-1的（每次LiveData設置值都會使其version加1），這樣就會導致LiveDataBus每註冊一個新的訂閱者，這個訂閱者立刻會收到一個回調，即使這個設置的動作發生在訂閱之前。</p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/153260587914599287f92a0><p class=pgc-img-caption></p></div><p><strong>問題原因總結</strong></p><p>對於這個問題，總結一下發生的核心原因。對於LiveData，其初始的version是-1，當我們調用了其setValue或者postValue，其vesion會+1；對於每一個觀察者的封裝ObserverWrapper，其初始version也為-1，也就是說，每一個新註冊的觀察者，其version為-1；當LiveData設置這個ObserverWrapper的時候，如果LiveData的version大於ObserverWrapper的version，LiveData就會強制把當前value推送給Observer。</p><p><strong>如何解決這個問題</strong></p><p>明白了問題產生的原因之後，我們來看看怎麼才能解決這個問題。很顯然，根據之前的分析，只需要在註冊一個新的訂閱者的時候把Wrapper的version設置成跟LiveData的version一致即可。</p><p>那麼怎麼實現呢，看看LiveData的observe方法，他會在步驟1創建一個LifecycleBoundObserver，LifecycleBoundObserver是ObserverWrapper的派生類。然後會在步驟2把這個LifecycleBoundObserver放入一個私有Map容器mObservers中。無論ObserverWrapper還是LifecycleBoundObserver都是私有的或者包可見的，所以無法通過繼承的方式更改LifecycleBoundObserver的version。</p><p>那麼能不能從Map容器mObservers中取到LifecycleBoundObserver，然後再更改version呢？答案是肯定的，通過查看SafeIterableMap的源碼我們發現有一個protected的get方法。因此，在調用observe的時候，我們可以通過反射拿到LifecycleBoundObserver，再把LifecycleBoundObserver的version設置成和LiveData一致即可。</p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153260587956410d5916b87><p class=pgc-img-caption></p></div><p>對於非生命週期感知的observeForever方法來說，實現的思路是一致的，但是具體的實現略有不同。observeForever的時候，生成的wrapper不是LifecycleBoundObserver，而是AlwaysActiveObserver（步驟1），而且我們也沒有機會在observeForever調用完成之後再去更改AlwaysActiveObserver的version，因為在observeForever方法體內，步驟3的語句，回調就發生了。</p><div class=pgc-img><img alt=Android消息總線的演進之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1532605879463daf62b18de><p class=pgc-img-caption></p></div><p>那麼對於observeForever，如何解決這個問題呢？既然是在調用內回調的，那麼我們可以寫一個ObserverWrapper，把真正的回調給包裝起來。把ObserverWrapper傳給observeForever，那麼在回調的時候我們去檢查調用棧，如果回調是observeForever方法引起的，那麼就不回調真正的訂閱者。</p><p><strong>LiveDataBus最終實現</strong></p><blockquote><p>public final class LiveDataBus {</p><p>private final Map&lt;String, BusMutableLiveData&lt;Object>> bus;</p><p>private LiveDataBus() {</p><p>bus = new HashMap&lt;>();</p><p>}</p><p>private static class SingletonHolder {</p><p>private static final LiveDataBus DEFAULT_BUS = new LiveDataBus();</p><p>}</p><p>public static LiveDataBus get() {</p><p>return SingletonHolder.DEFAULT_BUS;</p><p>}</p><p>public &lt;T> MutableLiveData&lt;T> with(String key, Class&lt;T> type) {</p><p>if (!bus.containsKey(key)) {</p><p>bus.put(key, new BusMutableLiveData&lt;>());</p><p>}</p><p>return (MutableLiveData&lt;T>) bus.get(key);</p><p>}</p><p>public MutableLiveData&lt;Object> with(String key) {</p><p>return with(key, Object.class);</p><p>}</p><p>private static class ObserverWrapper&lt;T> implements Observer&lt;T> {</p><p>private Observer&lt;T> observer;</p><p>public ObserverWrapper(Observer&lt;T> observer) {</p><p>this.observer = observer;</p><p>}</p><p>@Override</p><p>public void onChanged(@Nullable T t) {</p><p>if (observer != null) {</p><p>if (isCallOnObserve()) {</p><p>return;</p><p>}</p><p>observer.onChanged(t);</p><p>}</p><p>}</p><p>private boolean isCallOnObserve() {</p><p>StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</p><p>if (stackTrace != null && stackTrace.length > 0) {</p><p>for (StackTraceElement element : stackTrace) {</p><p>if ("android.arch.lifecycle.LiveData".equals(element.getClassName()) &&</p><p>"observeForever".equals(element.getMethodName())) {</p><p>return true;</p><p>}</p><p>}</p><p>}</p><p>return false;</p><p>}</p><p>}</p><p>private static class BusMutableLiveData&lt;T> extends MutableLiveData&lt;T> {</p><p>private Map&lt;Observer, Observer> observerMap = new HashMap&lt;>();</p><p>@Override</p><p>public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T> observer) {</p><p>super.observe(owner, observer);</p><p>try {</p><p>hook(observer);</p><p>} catch (Exception e) {</p><p>e.printStackTrace();</p><p>}</p><p>}</p><p>@Override</p><p>public void observeForever(@NonNull Observer&lt;T> observer) {</p><p>if (!observerMap.containsKey(observer)) {</p><p>observerMap.put(observer, new ObserverWrapper(observer));</p><p>}</p><p>super.observeForever(observerMap.get(observer));</p><p>}</p><p>@Override</p><p>public void removeObserver(@NonNull Observer&lt;T> observer) {</p><p>Observer realObserver = null;</p><p>if (observerMap.containsKey(observer)) {</p><p>realObserver = observerMap.remove(observer);</p><p>} else {</p><p>realObserver = observer;</p><p>}</p><p>super.removeObserver(realObserver);</p><p>}</p><p>private void hook(@NonNull Observer&lt;T> observer) throws Exception {</p><p>//get wrapper's version</p><p>Class&lt;LiveData> classLiveData = LiveData.class;</p><p>Field fieldObservers = classLiveData.getDeclaredField("mObservers");</p><p>fieldObservers.setAccessible(true);</p><p>Object objectObservers = fieldObservers.get(this);</p><p>Class&lt;?> classObservers = objectObservers.getClass();</p><p>Method methodGet = classObservers.getDeclaredMethod("get", Object.class);</p><p>methodGet.setAccessible(true);</p><p>Object objectWrapperEntry = methodGet.invoke(objectObservers, observer);</p><p>Object objectWrapper = null;</p><p>if (objectWrapperEntry instanceof Map.Entry) {</p><p>objectWrapper = ((Map.Entry) objectWrapperEntry).getValue();</p><p>}</p><p>if (objectWrapper == null) {</p><p>throw new NullPointerException("Wrapper can not be bull!");</p><p>}</p><p>Class&lt;?> classObserverWrapper = objectWrapper.getClass().getSuperclass();</p><p>Field fieldLastVersion = classObserverWrapper.getDeclaredField("mLastVersion");</p><p>fieldLastVersion.setAccessible(true);</p><p>//get livedata's version</p><p>Field fieldVersion = classLiveData.getDeclaredField("mVersion");</p><p>fieldVersion.setAccessible(true);</p><p>Object objectVersion = fieldVersion.get(this);</p><p>//set wrapper's version</p><p>fieldLastVersion.set(objectWrapper, objectVersion);</p><p>}</p><p>}</p><p>}</p></blockquote><p><strong>註冊訂閱：</strong></p><blockquote><p>LiveDataBus.get()</p><p>.with("key_test", String.class)</p><p>.observe(this, new Observer&lt;String>() {</p><p>@Override</p><p>public void onChanged(@Nullable String s) {</p><p>}</p><p>});</p></blockquote><p><strong>發送消息：</strong></p><blockquote><p>LiveDataBus.get().with("key_test").setValue(s);</p></blockquote><p><strong>源碼說明</strong></p><p>LiveDataBus的源碼可以直接拷貝使用，也可以前往作者的GitHub倉庫查看下載：</p><blockquote><p>https://github.com/JeremyLiao/LiveDataBus</p></blockquote><p><strong>總結</strong></p><p>本文提供了一個新的消息總線框架——LiveDataBus。訂閱者可以訂閱某個消息通道的消息，發佈者可以把消息發佈到消息通道上。利用LiveDataBus，不僅可以實現消息總線功能，而且對於訂閱者，他們不需要關心何時取消訂閱，極大減少了因為忘記取消訂閱造成的內存洩漏風險。</p><p><strong>作者簡介</strong></p><p>海亮，美團高級工程師，2017年加入美團，目前主要負責美團輕收銀、美團收銀零售版等App的相關業務及模塊開發工作。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Android</a></li><li><a>總線</a></li><li><a>演進</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a3ee55d.html alt=臺達PLC、伺服、總線在多線切割機排線應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/81b4f47eaf02436d85835d3a63750236 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a3ee55d.html title=臺達PLC、伺服、總線在多線切割機排線應用>臺達PLC、伺服、總線在多線切割機排線應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c1058aa2.html alt="Android Q下ANGLE圖形引擎性能測試  「農步祥」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RXTy8D7HmsBWr1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c1058aa2.html title="Android Q下ANGLE圖形引擎性能測試  「農步祥」">Android Q下ANGLE圖形引擎性能測試 「農步祥」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/604d6a24.html alt=光通信傳送網的發展與演進 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/37ec00024ce9c81c7060 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/604d6a24.html title=光通信傳送網的發展與演進>光通信傳送網的發展與演進</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9be3efd7.html alt=數字化演進：從互聯網+到全鏈路數字化 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6c7d0a20c6454717944d6921ce56a06e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9be3efd7.html title=數字化演進：從互聯網+到全鏈路數字化>數字化演進：從互聯網+到全鏈路數字化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ac13623.html alt="Android 11加入新功能：長期不用的APP自動關閉敏感權限" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rx4J9h84rlZBze style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ac13623.html title="Android 11加入新功能：長期不用的APP自動關閉敏感權限">Android 11加入新功能：長期不用的APP自動關閉敏感權限</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/192b9f57.html alt="Android版Firefox 81將引入可自動關閉舊標籤頁的選項" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SA9N6CXIS75NYa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/192b9f57.html title="Android版Firefox 81將引入可自動關閉舊標籤頁的選項">Android版Firefox 81將引入可自動關閉舊標籤頁的選項</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3073c3d.html alt="Android端Firefox 81可定時關閉不使用的標籤頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S9x6jJb18axAim style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3073c3d.html title="Android端Firefox 81可定時關閉不使用的標籤頁">Android端Firefox 81可定時關閉不使用的標籤頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/355ed5a4.html alt=在Android中的工具欄中添加菜單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3572ad9d9fb487d8927f703f18179a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/355ed5a4.html title=在Android中的工具欄中添加菜單>在Android中的工具欄中添加菜單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37aac89.html alt=【學習筆記】Android開發之kotlin語言（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ee3f9c8348ae4de58a5f62922d2042e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37aac89.html title=【學習筆記】Android開發之kotlin語言（一）>【學習筆記】Android開發之kotlin語言（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/514f2fe0.html alt=Android進階之路之網絡編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R6GseWQ6pTbxvr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/514f2fe0.html title=Android進階之路之網絡編程>Android進階之路之網絡編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d258b9eb.html alt="徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/e4fd87bc-b2e5-40e2-841d-2e3dc5f9a2b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d258b9eb.html title="徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動">徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a46b181d.html alt=古代書寫材料的演進與魏晉史學的發展 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f658572243034c679691e700acd6f17d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a46b181d.html title=古代書寫材料的演進與魏晉史學的發展>古代書寫材料的演進與魏晉史學的發展</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d54e0b8c.html alt=從網絡架構演進的前世今生詳解5G各NF網絡功能體 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/56c5f01170a843fea40bd4f1a164b677 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d54e0b8c.html title=從網絡架構演進的前世今生詳解5G各NF網絡功能體>從網絡架構演進的前世今生詳解5G各NF網絡功能體</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc7b0de9.html alt=總線控制盤、多線控制盤的區別及應用-火災自動報警系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/71b4fd2b0652481e9818bdf50bb6fdce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc7b0de9.html title=總線控制盤、多線控制盤的區別及應用-火災自動報警系統>總線控制盤、多線控制盤的區別及應用-火災自動報警系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68b758a4.html alt="訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RiF18Oh9i8jWPd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68b758a4.html title="訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎">訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>