<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>五分鐘詳解MySQL併發控制及事務原理 | 极客快訊</title><meta property="og:title" content="五分鐘詳解MySQL併發控制及事務原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/46d2e2db930d4487b7576901dc739988"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/75a1612.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/75a1612.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/75a1612.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/75a1612.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/75a1612.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/75a1612.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/75a1612.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/75a1612.html><meta property="article:published_time" content="2020-10-29T20:50:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:42+08:00"><meta name=Keywords content><meta name=description content="五分鐘詳解MySQL併發控制及事務原理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/75a1612.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>五分鐘詳解MySQL併發控制及事務原理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#000;--tt-darkmode-bgcolor: #383838"><br></span></span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46d2e2db930d4487b7576901dc739988><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在如今互聯網業務中使用範圍最廣的數據庫無疑還是關係型數據庫MySQL，之所以用"還是"這個詞，是因為最近幾年國內數據庫領域也取得了一些長足進步，例如以TIDB、OceanBase等為代表的分佈式數據庫，但它們暫時還沒有形成絕對的覆蓋面，所以現階段還得繼續學習MySQL數據庫以應對工作中遇到的一些問題，以及面試過程中關於數據庫部分的考察。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">今天的內容就和大家聊一聊MySQL數據庫中關於併發控制、事務以及存儲引擎這幾個最核心的問題。本內容涉及的知識圖譜如下圖所示：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7f68999dfa6545f087afd6eb0f97410b><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">併發控制</span></strong></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">併發控制是一個內容龐大的話題，在計算機軟件系統中只要在同一時刻存在多個請求同時修改數據的情況，就都會產生併發控制的問題，例如Java中的多線程安全問題等。在MySQL中的併發控制，主要是討論數據庫如何控制表數據的併發讀寫。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">例如有一張表useraccount，其結構如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a01f06b5ac7945ff95d59251365c681b><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">此時如果有如下兩條SQL語句同一時刻向數據庫發起請求：</span></p><p style=text-align:start><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">SQL-A:</span></em></p><pre><code>update useraccount t set t.account=t.account+100 where username='wudimanong';</code></pre><p style=text-align:start><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">SQL-B:</span></em></p><pre><code>update useraccount t set t.account=t.account-100 where username='wudimanong'</code></pre><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">當上述語句都執行完成，正確結果應該是account=100，但在併發情況下，卻有可能發生這樣的情況：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7899fdf5c049416a967cee0b1e5d50a3><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">那麼在MySQL中是如何進行併發控制的呢？實際上與大多數併發控制方式一樣，在MySQL中也是利用鎖機制來實現併發控制的。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1.MySQL鎖類型</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在MySQL中主要是通過"讀寫鎖"來實現併發控制。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">讀鎖(read lock)：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">也叫共享鎖(share lock)，多個讀請求可以同時共享一把鎖來讀取數據，而不會造成阻塞。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">寫鎖(write lock)：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">也叫排他鎖(exclusive lock)，寫鎖會排斥其他所有獲取鎖的請求，一直阻塞，直到完成寫入並釋放鎖。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">讀寫鎖可以做到讀讀並行，但是無法做到寫讀、寫寫並行。後面會講到的事務隔離性就是根據讀寫鎖來實現的！</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2.MySQL鎖粒度</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">上面提及的讀寫鎖是根據MySQL的鎖類型來劃分的，而讀寫鎖能夠施加的粒度在數據庫中主要體現為表和行，也稱為</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">表鎖</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">(table lock)、行鎖(row lock)</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">表鎖(table lock)</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">：是MySQL中最基本的鎖策略，它會鎖定整張表，這樣維護鎖的開銷最小，但是會降低表的讀寫效率。如果一個用戶通過表鎖來實現對錶的寫操作(插入、刪除、更新)，那麼先需要獲得鎖定該表的寫鎖，那麼在這種情況下，其他用戶對該表的讀寫都會被阻塞。一般情況下"alter table"之類的語句才會使用表鎖。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">行鎖(row lock)</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">：行鎖可以最大程度地支持併發讀寫，但數據庫維護鎖的開銷會比較大。行鎖是我們日常使用最多的鎖策略，一般情況下MySQL中的行級鎖由具體的存儲引擎實現，而不是MySQL服務器層面去實現(表鎖MySQL服務器層面會實現)。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3.多版本併發控制(MVCC)</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">MVCC(MultiVersion Concurrency Control)，多版本併發控制。在MySQL的大多數事務引擎(如InnoDB)中，都不只是簡單地實現了行級鎖，否則會出現這樣的情況：</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">"數據A被某個用戶更新期間(獲取行級寫鎖),其他用戶讀取該條數據(獲取讀鎖)都會被阻塞</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">“。但現實情況顯然不是這樣，這是因為MySQL的存儲引擎基於提升併發性能的考慮，通過MVCC數據多版本控制，做到了讀寫分離，從而實現不加鎖讀取數據進而做到了讀寫並行。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">以InnoDB存儲引擎的MVCC實現為例：</span></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">InnoDB的MVCC，是通過在每行記錄後面保存兩個隱藏的列來實現的。這兩個列，一個保存了行的創建時間，一個保存了行的過期時間。當然它們存儲的並不是實際的時間值，而是系統版本號。每開啟一個新的事務，系統版本號都會自動遞增；事務開始時刻的系統版本號會作為事務的版本號，用來和查詢到的每行記錄的版本號進行比較。</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">MVCC在MySQL中實現所依賴的手段主要是:"</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">undo log和read view</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">"。</span></p><ul><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">undo log :undo log 用於記錄某行數據的多個版本的數據。</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">read view :用來判斷當前版本數據的可見性</span></li></ul><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">undo log在後面講述事務還會介紹到。關於MVCC的讀寫原理示意圖如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/41ebd2ee480847b091ef00c7f55dfc99><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">上圖演示了MySQL InnoDB存儲引擎，在REPEATABLE READ(可重複讀)事務隔離級別下，通過額外保存兩個系統版本號(行創建版本號、行刪除版本號)實現MVCC，從而使得大多數讀操作都可以不用再加讀鎖。這樣的設計使得數據讀取操作更加簡單、性能更好。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">那麼在MVCC模式下數據讀取操作是如何保證數據讀取正確的呢？以InnoDB為例，Select時會根據以下兩個條件檢查每行記錄：</span></p><ul><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">只查找版本號小於或等於當前事務版本的數據行，這樣可以確保事務讀取的行要麼是在事務開始前已經存在，要麼是事務自身插入或者修過的。</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">行的刪除版本號要麼未定義，要麼大於當前事務版本號。這樣可以確保事務讀取到的行，在事務開始之前未被刪除。</span></li></ul><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">只有符合上述兩個條件的記錄，才能返回作為查詢的結果！以圖中示範的邏輯為例，寫請求將account變更為200的過程中，InnoDB會再插入一行新記錄(account=200），並將當前系統版本號作為</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">行</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">創建版本號(createVersion=2)，同時將當前系統版本號作為原來行的行刪除版本號(deleteVersion=2)，那麼此時關於這條數據有兩個版本的數據副本，具體如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ae81bfbdb5dd4c0d8578c9562109fd38><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">假如現在寫操作還未結束，事務對其他用戶暫不可見，按照Select檢查條件只有accout=100的記錄才符合條件，因此查詢結果會返回account=100的記錄！</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">上述過程就是InnoDB存儲引擎關於MVCC實現的基本原理，但是後面需要注意MVCC多版本併發控制的邏輯只能工作在“</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">REPEATABLE READ(可重複讀)和READ COMMITED(提交讀)”</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">兩種事務隔離級別下。其他兩個隔離級別都與MVCC不兼容，因為</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">READ UNCOMMITED(未提交讀)</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">總是讀取最新的數據行，而不是符合當前事務版本的數據行；而</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">SERIALIZABLE</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">則會對所有讀取的行都加鎖，也不符合MVCC的思想。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">MySQL事務</span></strong></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">前面在講解了關於MySQL併發控制的過程中，也提到了事務相關的內容，接下來我們來更全面的梳理下關於事務的核心知識。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">相信大家在日常的開發過程中，都使用過數據庫事務，對事務的特點也都能張口就來——ACID。那麼事務內部到底是怎麼實現的呢？在接下來的內容中，就來和大傢俱體聊一聊這個問題！</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1.事務概述</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">數據庫事務本身所要達成的效果主要體現在：</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">"可靠性"</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">以及</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">"併發處理"</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這兩個方面。</span></p><ul><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">可靠性：數據庫要保證當insert或update操作拋出異常，或者數據庫crash的時候要保障數據操作的前後一致。</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">併發處理：說的是當多個併發請求過來，並且其中有一個請求是對數據進行修改操作，為了避免其他請求讀到髒數據，需要對事務之間的讀寫進行隔離。</span></li></ul><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">實現MySQL數據庫事務功能主要有三個技術，分別是日誌文件（redo log和undo log）、鎖技術及MVCC。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2.redo log與undo log</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">redo log與undo log是實現MySQL事務功能的核心技術。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）、redo log</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">redo log叫做重做日誌，是實現事務持久性的關鍵。redo log日誌文件主要由2部分組成：</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">重做日誌緩衝</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">(redo log buffer)、</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">重做日誌文件</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">(redo log file)</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">。</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在MySql中為了提升數據庫性能並不會把每次的修改都實時同步到磁盤，而是會先存到一個叫做“Boffer Pool”的緩衝池中，之後會再使用後臺線程去實現緩衝池和磁盤之間的同步。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如果採取這樣的模式，可能會出現這樣的問題：如果在數據還沒來得及同步的情況下出現宕機或斷電，那麼就可能會丟失部分已提交事務的修改信息！而這種情況對於數據庫軟件來說是不可以接受的。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">所以redo log的主要作用就是用來記錄已成功提交事務的修改信息，並且會在事務提交後實時將redo log持久化到磁盤，這樣在系統重啟之後就可以讀取redo log來恢復最新的數據。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">接下來我們以前面</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">SQL-A</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">所開啟的事務為例來演示redo log的具體是如何運行的，如下圖所示：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6ee7b233e664b62a2963e608e593277><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如上圖所示，當修改一行記錄的事務開啟，MySQL存儲引擎是把數據從磁盤讀取到內存的緩衝池上進行修改，這個時候數據在內存中被修改後就與磁盤中的數據產生了差異，這種有差異的數據也被稱之為</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">“髒頁”</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而一般存儲引擎對於髒頁的處理並不是每次生成髒頁就即刻將髒頁刷新回磁盤，而是通過後臺線程</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">“master thread”</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">以大致每秒運行一次或每10秒運行一次的頻率去刷新磁盤。在這種情況下，出現數據庫宕機或斷電等情況，那麼尚未刷新回磁盤的數據就有可能丟失。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而redo log日誌的作用就是為了調和內存與磁盤的速度差異。當事務被提交時，存儲引擎會首先將要修改的數據寫入redo log，然後再去修改緩衝池中真正的數據頁，並實時刷新一次數據同步。如果在這個過程中，數據庫掛了，由於redo log物理日誌文件已經記錄了事務修改，所以在數據庫重啟後就可以根據redo log日誌進行事務數據恢復。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）、undo log</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">上面我們聊了redo log日誌，它的作用主要是用來恢復數據，保障已提交事務的持久化特性。在MySQL中還有另外一種非常重要的日誌類型undo log，又叫回滾日誌，它主要是用於記錄數據被修改前的信息，這與記錄數據被修改後信息的redo log日誌正好相反。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">undo log 主要記錄事務修改之前版本的數據信息，假如由於系統錯誤或者rollback操作而回滾的話就可以根據undo log日誌來將數據回滾到沒被修改之前的狀態。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">每次寫入數據或者修改數據之前存儲引擎都會將修改前的信息記錄到undo log。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3.事務的實現</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">前面我們講到了鎖、多版本併發控制(MVCC)、重做日誌(redo log)以及回滾日誌（undo log），這些內容就是MySQL實現數據庫事務的基礎。從事務的四大特性來說，其對應關係主要體現如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/330ff61f92634dbd877349c3449ce976><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">實際上事務原子性、持久性、隔離性的最終目的都是為了確保事務數據的一致性。而ACID只是個概念，事務的最終目的是要保障數據的可靠性和一致性。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">接下來我們再具體分析下事務ACID特性的實現原理。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）、原子性的實現</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">原子性，是指一個事務必須被視為不可分割的最小單位，一個事務中的所有操作要麼全部執行成功、要麼全部失敗回滾，對一個事務來說不可能只執行其中的部分操作，這就是事務原子性的概念。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而MySQL數據庫實現原子性的主要是通過回滾操作來實現的。所謂回滾操作就是當發生錯誤異常或者顯示地執行rollback語句時需要把數據還原到原先的模樣，而這個過程就需要藉助undo log來進行。具體規則如下：</span></p><ul><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">每條數據變更(insert/update/delete)操作都伴隨著一條undo log的生成，並且回滾日誌必須先於數據持久化到磁盤上；</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">所謂的回滾就是根據undo log日誌做逆向操作，比如delete的逆向操作為insert，insert的逆向操作為delete，update的逆向操作為update等；</span></li></ul><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）、持久性的實現</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">持久性，指的是事務一旦提交其所作的修改會永久地保存到數據庫中，此時即使系統崩潰修改的數據也不會丟失。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">事務的持久性主要是通過redo log日誌來實現的。redo log日誌之所以能夠彌補緩存同步所造成的數據差異，主要其具備以下特點：</span></p><ul><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">redo log的存儲是順序的，而緩存同步則是隨機操作；</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">緩存同步是以數據頁為單位，每次傳輸的數據大小大於redo log；</span></li></ul><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">關於redo log實現事務持久性的邏輯可參考本文前面關於redo log部分的內容！</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）、隔離性的實現</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">隔離性是事務ACID特性中最複雜的一個。在SQL標準裡定義了四種隔離級別，每一種隔離級別都規定一個事務中的修改，那些是事務之間可見的，那些是不可見的。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">MySQL隔離級別有以下四種（級別由低到高）：</span></p><ul><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">READ UNCOMMITED (未提交讀)；</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">READ COMMITED (提交讀)</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">REPEATABLE READ (可重複讀)</span></li><li><span style="color:#404040;--tt-darkmode-color: #A3A3A3">SERIALIZABLE (可串行化)</span></li></ul><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">隔離級別越低，則數據庫可以執行的併發度越高，但是實現的複雜度和開銷也越大。只要徹底理解了隔離級別以及它的實現原理，就相當於理解了ACID中的事務隔離性。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">前面提到過，原子性、持久性、隔離性的目的最終都是為了實現數據的一致性，但隔離性與其它兩個有所區別，原子性和持久性主要是為了保障數據的可靠性，比如做到宕機後的數據恢復，以及錯誤後的數據回滾。而隔離性的核心目標則是要管理多個併發讀寫請求的訪問順序，實現數據庫數據的安全和高效訪問，實質上就是一場數據的安全性與性能之間的權衡遊戲。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">可靠性高的隔離級別，併發性能低（例如SERIALIZABLE隔離級別，因為所有的讀寫都會加鎖）；而可靠性低的，併發性能高（例如READ UNCOMMITED，因為讀寫完全不加鎖）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">接下來我們再分別分析下這四種隔離級別的特點：</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">READ UNCOMMITTED</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在READ UNCOMMITTED隔離級別下，一個事務中的修改即使還沒有提交，對其它事務也是可見，也就是說事務可以讀取到未提交的數據。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">因為讀不會添加鎖，所以寫操作在讀的過程中修改數據的話會造成"髒讀"。未提交讀隔離級別讀寫示意圖如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ec619c7ac37489e8655812ac571400e><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如上圖所示，寫請求將account修改為200，此時事務未提交；但是讀請求可以讀取到未提交的事務數據account=200；隨後寫請求事務失敗回滾account=100；那麼此時讀請求讀取的account=200的數據就是髒數據。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這種隔離級別的優點是讀寫並行、性能高；但是缺點是容易造成髒讀。所以在MySQL數據庫中一般情況下並不會採取此種隔離級別！</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">READ COMMITED</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這種事務隔離級別也叫</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">"不可重複讀或提交讀"。</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">它的特點是一個事務在它提交之前的所有修改，其它事務都是不可見的；其它事務只能讀到已提交的修改變化。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這種隔離級別看起來很完美，也符合大部分邏輯場景，但該事務隔離級別會產生</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">"不可重讀"</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">和</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">"幻讀"</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">的問題。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">不可重讀：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">是指一個事務內多次讀取的相</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">同行</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">的數據，結果卻不一樣。例如事務A讀取a行數據，而事務B此時修改了a行的數據並提交了事務，那麼事務A在下一次讀取a行數據時，發現和第一次不一樣了！</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">幻讀：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">是指一個事務按照相同的查詢條件檢索數據，但是多次檢索出的數據結果卻不一樣。例如事務A第一次以條件x=0檢索數據獲取了5條記錄；此時事務B向表中插入了一條x=0的數據並提交了事務；那麼事務A第二次再以條件x=0檢索數據時，發現獲取了6條記錄！</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">那麼在READ COMMITED隔離級別下為什麼會產生不可重複讀和幻讀的問題呢？</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">實際上不可重複讀事務隔離級別也採用了我們前面講過的MVCC（多版本併發控制）機制。但在READ COMMITED隔離級別下的MVCC機制，會在每次select的時候都生成一個新的系統版本號，所以事務中每次select操作讀到的不是一個副本而是不同的副本數據，所以在每次select之間，如果有其它事務更新並提交了我們讀取的數據，那麼就會產生不可重複讀和幻讀的現象。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">不可重複讀產生的原因示意圖如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0de3ba55a5ad446e8de140ef3602f0b8><p class=pgc-img-caption></p></div><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">REPEATABLE READ</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">事務隔離級別REPEATABLE READ，也叫可重複讀，它是MySQL數據庫的默認事務隔離級別。在這種事務隔離級別下，一個事務內的多次讀取結果是一致的，這種隔離級別可以避免髒讀、不可重複讀等查詢問題。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這種事務隔離級別的實現手段主要是採用讀寫鎖+MVCC機制。具體示意圖如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0043de05d6a74c0e8bbfe923b0e15bda><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如上圖所示，在該事務隔離級別下的MVCC機制，並不會在事務內每次查詢都產生一個新的系統版本號，所以一個事務內的多次查詢，數據副本都是一個，因此不會產生不可重複讀問題。關於此隔離級別下MVCC更多的細節可參考前面內容！</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">但是需要注意，此隔離級別解決了不可重複讀的問題，但是並沒有解決幻讀的問題，所以如果事務A中存在條件查詢，另外一個事務B在此期間新增或刪除了該條件的數據並提交了事務，那麼依然會造成事務A產生幻讀。所以在使用MySQL時需要注意這個問題！</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">SERIALIZABLE</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">該隔離級別理解起來最簡單，因為它讀寫請求都會加排他鎖，所以不會造成任何數據不一致的問題，就是性能不高，所以採用此隔離級別的數據庫很少！</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4）、一致性的實現</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">一致性主要是指通過回滾、恢復以及在併發條件下的隔離性來實現數據庫數據的一致！前面所講述的原子性、持久性及隔離性最終就是為了實現一致性！</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">MySQL存儲引擎</span></strong></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">前面的內容我們分別講述了MySQL併發控制和事務的內容，而實際上在併發控制和事務的具體細節都是依賴於MySql存儲引擎來實現的。MySQL最重要、最與眾不同的特性就是它的存儲引擎架構，這種將數據處理和存儲分離的架構設計使得用戶在使用時可以根據性能、特性以及其它具體需求來選擇相應的存儲引擎。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">雖然如此，但絕大部分情況下使用MySQL數據庫時選擇的還是InnoDB存儲引擎，不過這並不妨礙我們適當地瞭解下其它存儲引擎的特點。接下來給大家簡單總結下，具體如下：</span></p><div class=pgc-img><img alt=五分鐘詳解MySQL併發控制及事務原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d96b82fa3b704e81a5b8a36389f9ce72><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">以上我們簡單總結了MySQL各種存儲引擎的大概特點及其大致適用的場景，但實際上除了InnoDB存儲引擎外，在互聯網業務中很少會看到其它存儲引擎的身影。雖然MySQL內置了多種針對特定場景的存儲引擎，但是它們大多都有相應的替代技術，例如日誌類應用現在有Elasticsearch、而數倉類應用現在則有Hive、HBase等產品，至於內存數據庫有MangoDB、Redis等NoSQL數據產品，所以能夠給MySQL發揮的也只有InnoDB了！</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">寫在最後</span></strong></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">歡迎大家關注我的公眾號【</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">風平浪靜如碼</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">】，海量Java相關文章，學習資料都會在裡面更新，整理的資料也會放在裡面。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">覺得寫的還不錯的就點個贊，加個關注唄！點關注，不迷路，持續更新！！！</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>鐘詳解</a></li><li><a>MySQL</a></li><li><a>及事務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html alt="圖解MySQL | 「原理解析」 MySQL組提交(group commit)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e5444e9094614d6b88bd3fc8ac0524fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html title="圖解MySQL | 「原理解析」 MySQL組提交(group commit)">圖解MySQL | 「原理解析」 MySQL組提交(group commit)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html alt=MySQL系列-第14篇：事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html title=MySQL系列-第14篇：事務詳解>MySQL系列-第14篇：事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html alt=MySQL進階之InnoDB事務原子性實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e1d208ac-c0ed-4238-bce5-e4b3760228c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html title=MySQL進階之InnoDB事務原子性實現原理>MySQL進階之InnoDB事務原子性實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html alt="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html title="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務">技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html alt=深入學習MySQL事務：ACID特性的實現原理「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cdc702d66d6943499997d11e931425eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html title=深入學習MySQL事務：ACID特性的實現原理「轉」>深入學習MySQL事務：ACID特性的實現原理「轉」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html alt=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html title=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理>解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>