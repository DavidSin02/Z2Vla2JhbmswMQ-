<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JDK8新特性你都用了嗎？ | 极客快訊</title><meta property="og:title" content="JDK8新特性你都用了嗎？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/761cd770.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/761cd770.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/761cd770.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/761cd770.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/761cd770.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/761cd770.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/761cd770.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/761cd770.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="JDK8新特性你都用了嗎？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/761cd770.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JDK8新特性你都用了嗎？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>JDK8新特性：</strong></p><p><strong>1.Lambda表達式</strong></p><p><strong>2.新的日期API</strong></p><p><strong>3.引入Optional</strong></p><p><strong>4.使用Base64</strong></p><p><strong>5.接口的默認方法和靜態方法</strong></p><p><strong>6.新增方法引用格式</strong></p><p><strong>7.新增Stream類</strong></p><p><strong>8.註解相關的改變</strong></p><p><strong>9.支持並行（parallel）數組</strong></p><p><strong>10.對併發類（Concurrency）的擴展。</strong></p><p>一、Lambda表達式</p><p>Lambda 表達式也可稱為閉包，是推動 Java 8 發佈的最重要新特性。lambda表達式本質上是一個匿名方法。Lambda允許把函數作為一個方法的參數（函數作為參數傳遞進方法中）或者把代碼看成數據。使用 Lambda 表達式可以使代碼變的更加簡潔緊湊。在最簡單的形式中，一個lambda可以由：用逗號分隔的參數列表、–>符號、函數體三部分表示，在某些情況下lambda的函數體會更加複雜，這時可以把函數體放到在一對花括號中，就像在Java中定義普通函數一樣。Lambda可以引用類的成員變量與局部變量（如果這些變量不是final的話，它們會被隱含的轉為final，這樣效率更高）。Lambda可能會返回一個值。返回值的類型也是由編譯器推測出來的。如果lambda的函數體只有一行的話，那麼沒有必要顯式使用return語句。</p><p>如何使現有的函數友好地支持lambda。最終採取的方法是：增加函數式接口的概念。函數式接口就是接口裡面必須有且只有一個抽象方法的普通接口，像這樣的接口可以被隱式轉換為lambda表達式成為函數式接口。 在可以使用lambda表達式的地方，方法聲明時必須包含一個函數式的接口。 任何函數式接口都可以使用lambda表達式替換，例如：ActionListener、Comparator、Runnable。</p><p>函數式接口是容易出錯的：如有某個人在接口定義中增加了另一個方法，這時，這個接口就不再是函數式的了，並且編譯過程也會失敗。為了克服函數式接口的這種脆弱性並且能夠明確聲明接口作為函數式接口的意圖，Java 8增加了一種特殊的註解@FunctionalInterface，但是默認方法與靜態方法並不影響函數式接口的契約，可以任意使用。</p><p>使用lambda表達式替換匿名類，而實現Runnable接口是匿名類的最好示例。通過() -> {}代碼塊替代了整個匿名類。</p><p>java 8之前：</p><p>new Thread(new Runnable() {</p><p>@Override</p><p>public void run() {</p><p>System.out.println("Before Java8, too much code for too little to do");</p><p>}</p><p>}).start();</p><p>Java 8方式：</p><p>new Thread( () -> System.out.println("In Java8, Lambda expression rocks !!") ).start();</p><p>Lambda 表達式免去了使用匿名方法的麻煩，並且給予Java簡單但是強大的函數化的編程能力。</p><p>二、新的日期API</p><p>Java 8通過發佈新的Date-Time API (JSR 310)來進一步加強對日期與時間的處理。在舊版的 Java 中，日期時間 API 存在諸多問題，比如：</p><p>1.非線程安全 − java.util.Date 是非線程安全的，所有的日期類都是可變的，這是Java日期類最大的問題之一。</p><p>2.設計很差 − Java的日期/時間類的定義並不一致，在java.util和java.sql的包中都有日期類，此外用於格式化和解析的類在java.text包中定義。java.util.Date同時包含日期和時間，而java.sql.Date僅包含日期，將其納入java.sql包並不合理。另外這兩個類都有相同的名字，這本身就是一個非常糟糕的設計。</p><p>3.時區處理麻煩 − 日期類並不提供國際化，沒有時區支持，因此Java引入了java.util.Calendar和java.util.TimeZone類，但他們同樣存在上述所有的問題。</p><p>Java 8 在 java.time 包下提供了很多新的 API。以下為兩個比較重要的 API：</p><p>1.Local(本地) − 簡化了日期時間的處理，沒有時區的問題。</p><p>2.Zoned(時區) − 通過制定的時區處理日期時間。</p><p>新的java.time包涵蓋了所有處理日期，時間，日期/時間，時區，時刻（instants），過程（during）與時鐘（clock）的操作。</p><p>三、Optional</p><p>Optional類實際上是個容器：它可以保存類型T的值，或者僅僅保存null。Optional 類的引入很好的解決空指針異常。Optional提供很多有用的方法，這樣我們就不用顯式進行空值檢測。儘量避免在程序中直接調用Optional對象的get()和isPresent()方法，避免使用Optional類型聲明實體類的屬性。</p><p>（1）Optional.of(T t) : 創建一個 Optional 實例</p><p>（2）Optional.empty() : 創建一個空的 Optional 實例</p><p>（3）Optional.ofNullable(T t):若 t 不為 null,創建 Optional 實例,否則創建空實例</p><p>（4）isPresent() : 判斷是否包含值 orElse(T t) : 如果調用對象包含值，返回該值，否則返回t</p><p>（5）orElseGet(Supplier s) :如果調用對象包含值，返回該值，否則返回 s 獲取的值</p><p>（6）map(Function f): 如果有值對其處理，並返回處理後的Optional，否則返回Optional.empty()</p><p>（7）flatMap(Function mapper):與 map 類似，要求返回值必須是Optional</p><p>1.創建optional對象，一般用ofNullable()而不用of()：</p><p>（1）empty() ：用於創建一個沒有值的Optional對象：Optional&lt;String> emptyOpt = Optional.empty();</p><p>（2）of() ：使用一個非空的值創建Optional對象：Optional&lt;String> notNullOpt = Optional.of(str);</p><p>（3）ofNullable() ：接收一個可以為null的值：Optional&lt;String> nullableOpt = Optional.ofNullable(str);</p><p>2.判斷Null：</p><p>（1）isPresent()：如果創建的對象實例為非空值的話，isPresent()返回true，調用get()方法會返回該對象，如果沒有值，調用isPresent()方法會返回false，調用get()方法拋出NullPointerException異常。</p><p>3.獲取對象：</p><p>（1）get()</p><p>4.使用map提取對象的值，如果我們要獲取User對象中的roleId屬性值，常見的方式是先判斷是否為null然後直接獲取，但使用Optional中提供的map()方法可以以更簡單的方式實現</p><p>5.使用orElse方法設置默認值，Optional類還包含其他方法用於獲取值，這些方法分別為：</p><p>（1）orElse()：如果有值就返回，否則返回一個給定的值作為默認值；</p><p>（2）orElseGet()：與orElse()方法作用類似，區別在於生成默認值的方式不同。該方法接受一個Supplier&lt;? extends T>函數式接口參數，用於生成默認值；</p><p>（3）orElseThrow()：與前面介紹的get()方法類似，當值為null時調用這兩個方法都會拋出NullPointerException異常，區別在於該方法可以指定拋出的異常類型。</p><p>6.使用filter()方法過濾，filter()方法可用於判斷Optional對象是否滿足給定條件，一般用於條件過濾，在代碼中，如果filter()方法中的Lambda表達式成立，filter()方法會返回當前Optional對象值，否則，返回一個值為空的Optional對象。：</p><p>四、Base64</p><p>Base64編碼的作用 ：</p><p>  由於某些系統中只能使用ASCII字符。Base64就是用來將非ASCII字符的數據轉換成ASCII字符的一種方法。 Base64其實不是安全領域下的加密解密算法，而是一種編碼，也就是說，它是可以被翻譯回原來的樣子。它並不是一種加密過程。所以base64只能算是一個編碼算法，對數據內容進行編碼來適合傳輸。雖然base64編碼過後原文也變成不能看到的字符格式，但是這種方式很初級，很簡單。</p><p>使用Base64編碼原因 ：</p><p>  1.base64是網絡上最常見的用於傳輸8bit字節代碼的編碼方式之一。有時我們需要把二進制數據編碼為適合放在URL中的形式。這時採用base64編碼具有不可讀性，即所編碼的數據不會被人直接看出。</p><p>  2.用於在http環境下傳遞較長的標識信息。</p><p>在Java 8中，Base64編碼已經成為Java類庫的標準，並內置了 Base64 編碼的編碼器和解碼器。Base64工具類提供了一套靜態方法獲取下面三種BASE64編解碼器：</p><p>基本：輸出被映射到一組字符A-Za-z0-9+/，編碼不添加任何行標，輸出的解碼僅支持A-Za-z0-9+/。</p><p>URL：輸出映射到一組字符A-Za-z0-9+_，輸出是URL和文件。</p><p>MIME：輸出隱射到MIME友好格式。輸出每行不超過76字符，並且使用'\r'並跟隨'\n'作為分割。編碼輸出最後沒有行分割。</p><p>五、接口的默認方法和靜態方法</p><p>Java 8用默認方法與靜態方法這兩個新概念來擴展接口的聲明。默認方法與抽象方法不同之處在於抽象方法必須要求實現，但是默認方法則沒有這個要求，就是接口可以有實現方法，而且不需要實現類去實現其方法。我們只需在方法名前面加個default關鍵字即可實現默認方法。為什麼要有這個特性？以前當需要修改接口的時候，需要修改全部實現該接口的類。而引進的默認方法的目的是為了解決接口的修改與現有的實現不兼容的問題。</p><p>默認方法語法格式如下：</p><p>public interface Vehicle {</p><p>default void print(){</p><p>System.out.println("我是一輛車!");</p><p>}</p><p>}</p><p>當出現這樣的情況，一個類實現了多個接口，且這些接口有相同的默認方法，這種情況的解決方法：</p><p>1.是創建自己的默認方法，來覆蓋重寫接口的默認方法</p><p>2.可以使用 super 來調用指定接口的默認方法</p><p>Java 8 的另一個特性是接口可以聲明（並且可以提供實現）靜態方法。在JVM中，默認方法的實現是非常高效的，並且通過字節碼指令為方法調用提供了支持。默認方法允許繼續使用現有的Java接口，而同時能夠保障正常的編譯過程。儘管默認方法非常強大，但是在使用默認方法時我們需要小心注意一個地方：在聲明一個默認方法前，請仔細思考是不是真的有必要使用默認方法，因為默認方法會帶給程序歧義，並且在複雜的繼承體系中容易產生編譯錯誤。</p><p>六、方法引用</p><p>方法引用提供了非常有用的語法，可以直接引用已有Java類或對象（實例）的方法或構造器。與lambda聯合使用，方法引用可以使語言的構造更緊湊簡潔，減少冗餘代碼。</p><p>定義了4個方法的Car這個類作為例子，區分Java中支持的4種不同的方法引用。</p><p>public static class Car {</p><p>public static Car create( final Supplier&lt; Car > supplier ) {</p><p>return supplier.get();</p><p>}</p><p>public static void collide( final Car car ) {</p><p>System.out.println( "Collided " + car.toString() );</p><p>}</p><p>public void follow( final Car another ) {</p><p>System.out.println( "Following the " + another.toString() );</p><p>}</p><p>public void repair() {</p><p>System.out.println( "Repaired " + this.toString() );</p><p>}</p><p>}</p><p>第一種方法引用是構造器引用，它的語法是Class::new，或者更一般的Class&lt; T >::new。請注意構造器沒有參數。</p><p>final Car car = Car.create( Car::new );</p><p>final List&lt; Car > cars = Arrays.asList( car );</p><p>第二種方法引用是靜態方法引用，它的語法是Class::static_method。請注意這個方法接受一個Car類型的參數</p><p>cars.forEach( Car::collide );</p><p>第三種方法引用是特定類的任意對象的方法引用，它的語法是Class::method。請注意，這個方法沒有參數。</p><p>cars.forEach( Car::repair );</p><p>第四種方法引用是特定對象的方法引用，它的語法是instance::method。請注意，這個方法接受一個Car類型的參數</p><p>final Car police = Car.create( Car::new );</p><p>cars.forEach( police::follow );</p><p>七、Stream</p><p>Java 8 API添加了一個新的抽象稱為流Stream把真正的函數式編程風格引入到Java中，可以讓你以一種聲明的方式處理數據。Stream 使用一種類似用 SQL 語句從數據庫查詢數據的直觀方式來提供一種對 Java 集合運算和表達的高階抽象。Stream API極大簡化了集合框架的處理，這種風格將要處理的元素集合看作一種流， 流在管道中傳輸， 並且可以在管道的節點上進行處理， 比如篩選， 排序，聚合等。</p><p>Stream流有一些特性：</p><p>1.Stream流不是一種數據結構，不保存數據，它只是在原數據集上定義了一組操作。</p><p>2.這些操作是惰性的，即每當訪問到流中的一個元素，才會在此元素上執行這一系列操作。</p><p>3.Stream不保存數據，故每個Stream流只能使用一次。</p><p>所以這邊有兩個概念:流、管道。元素流在管道中經過中間操作的處理，最後由最終操作得到前面處理的結果。這裡有2個操作：中間操作、最終操作。</p><p>中間操作：返回結果都是Stream，故可以多箇中間操作疊加。</p><p>終止操作：用於返回我們最終需要的數據，只能有一個終止操作。</p><p>使用Stream流，可以清楚地知道我們要對一個數據集做何種操作，可讀性強。而且可以很輕鬆地獲取並行化Stream流，不用自己編寫多線程代碼，可以更加專注於業務邏輯。默認情況下，從有序集合、生成器、迭代器產生的流或者通過調用Stream.sorted產生的流都是有序流，有序流在並行處理時會在處理完成之後恢復原順序。無限流的存在，側面說明了流是惰性的，即每當用到一個元素時，才會在這個元素上執行這一系列操作。</p><p>使用Stream的基本步驟：</p><p>1.創建Stream</p><p>2.轉換Stream，每次轉換原有Stream對象不改變，返回一個新的Stream對象（可以有多次轉換）</p><p>3.對Stream進行聚合操作，獲取想要的結果</p><p>一、 流的生成方法</p><p>1.Collection接口的stream()或parallelStream()方法</p><p>2.靜態的Stream.of()、Stream.empty()方法</p><p>3.Arrays.stream(array, from, to)</p><p>4.靜態的Stream.generate()方法生成無限流，接受一個不包含引元的函數</p><p>5.靜態的Stream.iterate()方法生成無限流，接受一個種子值以及一個迭代函數</p><p>6.Pattern接口的splitAsStream(input)方法</p><p>7.靜態的Files.lines(path)、Files.lines(path, charSet)方法</p><p>8.靜態的Stream.concat()方法將兩個流連接起來</p><p>二、 流的Intermediate方法(中間操作)</p><p>1.filter(Predicate) ：將結果為false的元素過濾掉</p><p>2.map(fun) ：轉換元素的值，可以用方法引元或者lambda表達式</p><p>3.flatMap(fun) ：若元素是流，將流攤平為正常元素，再進行元素轉換</p><p>4.limit(n) ：保留前n個元素</p><p>5.skip(n) ：跳過前n個元素</p><p>6.distinct() ：剔除重複元素</p><p>7.sorted() ：將Comparable元素的流排序</p><p>8.sorted(Comparator) ：將流元素按Comparator排序</p><p>9.peek(fun) ：流不變，但會把每個元素傳入fun執行，可以用作調試</p><p>三、 流的Terminal方法(終結操作)</p><p>（1）約簡操作</p><p>1.reduce(fun) ：從流中計算某個值，接受一個二元函數作為累積器，從前兩個元素開始持續應用它，累積器的中間結果作為第一個參數，流元素作為第二個參數</p><p>2.reduce(a, fun) ：a為么元值，作為累積器的起點</p><p>3.reduce(a, fun1, fun2) ：與二元變形類似，併發操作中，當累積器的第一個參數與第二個參數都為流元素類型時，可以對各個中間結果也應用累積器進行合併，但是當累積器的第一個參數不是流元素類型而是類型T的時候，各個中間結果也為類型T，需要fun2來將各個中間結果進行合併</p><p>（2）收集操作</p><p>1.iterator()：</p><p>2.forEach(fun)：</p><p>3.forEachOrdered(fun) ：可以應用在並行流上以保持元素順序</p><p>4.toArray()：</p><p>5.toArray(T[] :: new) ：返回正確的元素類型</p><p>6.collect(Collector)：</p><p>7.collect(fun1, fun2, fun3) ：fun1轉換流元素；fun2為累積器，將fun1的轉換結果累積起來；fun3為組合器，將並行處理過程中累積器的各個結果組合起來</p><p>（3）查找與收集操作</p><p>1.max(Comparator)：返回流中最大值</p><p>2.min(Comparator)：返回流中最小值</p><p>3.count()：返回流中元素個數</p><p>4.findFirst() ：返回第一個元素</p><p>5.findAny() ：返回任意元素</p><p>6.anyMatch(Predicate) ：任意元素匹配時返回true</p><p>7.allMatch(Predicate) ：所有元素匹配時返回true</p><p>8.noneMatch(Predicate) ：沒有元素匹配時返回true</p><p>八、註解相關</p><p>（1）可以進行重複註解</p><p>自從Java 5引入了註解機制，這一特性就變得非常流行並且廣為使用。然而，使用註解的一個限制是相同的註解在同一位置只能聲明一次，不能聲明多次。Java 8打破了這條規則，引入了重複註解機制，這樣相同的註解可以在同一地方聲明多次。</p><p>重複註解機制本身必須用@Repeatable註解。事實上，這並不是語言層面上的改變，更多的是編譯器的技巧，底層的原理保持不變。</p><p>（2）擴展註解的支持</p><p>Java 8擴展了註解的上下文。現在幾乎可以為任何東西添加註解：局部變量、泛型類、父類與接口的實現，就連方法的異常也能添加註解。</p><p>九、並行（parallel）數組</p><p>Java 8增加了大量的新方法來對數組進行並行處理。可以說，最重要的是parallelSort()方法，因為它可以在多核機器上極大提高數組排序的速度。下面的例子展示了新方法（parallelXxx）的使用。</p><p>上面的代碼片段使用了parallelSetAll()方法來對一個有20000個元素的數組進行隨機賦值。然後，調用parallelSort方法。這個程序首先打印出前10個元素的值，之後對整個數組排序。這個程序在控制檯上的輸出如下（請注意數組元素是隨機生產的）：</p><p>十、併發（Concurrency）</p><p>在新增Stream機制與lambda的基礎之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法來支持聚集操作。同時也在java.util.concurrent.ForkJoinPool類中加入了一些新方法來支持共有資源池（common pool）（請查看我們關於Java 併發的免費課程）。</p><p>新增的java.util.concurrent.locks.StampedLock類提供一直基於容量的鎖，這種鎖有三個模型來控制讀寫操作（它被認為是不太有名的java.util.concurrent.locks.ReadWriteLock類的替代者）。</p><p>在java.util.concurrent.atomic包中還增加了下面這些類：</p><p>1.DoubleAccumulator</p><p>2.DoubleAdder</p><p>3.LongAccumulator</p><p>4.LongAdder</p><p>————————————————</p><p>版權聲明：本文為CSDN博主「ZytheMoon」的原創文章，遵循 CC 4.0 BY-SA 版權協議，轉載請附上原文出處鏈接及本聲明。</p><p>原文鏈接：https://blog.csdn.net/ZytheMoon/article/details/89715618</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JDK8</a></li><li><a>特性</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8996a003.html alt=錫青銅、黃銅和紫銅的特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/508132631a8f40fda06c11b96c41fd21 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8996a003.html title=錫青銅、黃銅和紫銅的特性>錫青銅、黃銅和紫銅的特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90e80280.html alt=鐵素體不鏽鋼的特性及應用研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/10e30003030014ad86b8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90e80280.html title=鐵素體不鏽鋼的特性及應用研究>鐵素體不鏽鋼的特性及應用研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49ac5ba2.html alt=鋁板牌號及特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e47fe4686c894e0bafd8bd779463a898 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49ac5ba2.html title=鋁板牌號及特性>鋁板牌號及特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1ec108.html alt=暖通設計｜常用製冷劑種類及特性對比 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1538385712496c1349d0372 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1ec108.html title=暖通設計｜常用製冷劑種類及特性對比>暖通設計｜常用製冷劑種類及特性對比</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/de3994a1.html alt=慶陽地區溼陷性黃土工程力學特性研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15229987328385133ff193e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/de3994a1.html title=慶陽地區溼陷性黃土工程力學特性研究>慶陽地區溼陷性黃土工程力學特性研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d5b9800.html alt=軟件的質量特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/962e5e99-78a4-4d38-a598-06779c2d79d1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d5b9800.html title=軟件的質量特性>軟件的質量特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed0b6dad.html alt=常溫溼式除塵器的分類和工作特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cd4da037b97b4ce6aea1d089e3997b3c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed0b6dad.html title=常溫溼式除塵器的分類和工作特性>常溫溼式除塵器的分類和工作特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a5a5b711.html alt=超限絕緣的特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/470a0004732a658ad36f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a5a5b711.html title=超限絕緣的特性>超限絕緣的特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a7057a13.html alt=不鏽鋼的種類、區別和特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/738150bed64741afacdee4e09b5ba9b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a7057a13.html title=不鏽鋼的種類、區別和特性>不鏽鋼的種類、區別和特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62cb4833.html alt=鐵——分類、牌號及其特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7918677acbf94444b32c9709f93279a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62cb4833.html title=鐵——分類、牌號及其特性>鐵——分類、牌號及其特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/4b24e5ab.html alt=常用水泥的主要特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15313088659177faaa84365 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/4b24e5ab.html title=常用水泥的主要特性>常用水泥的主要特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4345dd31.html alt=電磁繼電器特性測試方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5685000307fd8159b2d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4345dd31.html title=電磁繼電器特性測試方法>電磁繼電器特性測試方法</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/f735544d.html alt=草莓的生長髮育特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/95bb5a3f8d55485084b65840bcfa8f75 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/f735544d.html title=草莓的生長髮育特性>草莓的生長髮育特性</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/22a72876.html alt=幾種常用殺菌劑的特性及使用方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8a426fa804784a46a51d42c75762f0ec style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/22a72876.html title=幾種常用殺菌劑的特性及使用方法>幾種常用殺菌劑的特性及使用方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/46f63908.html alt=煤的著火與燃燒特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/becdb8adbd894d7a8858320167ee963a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/46f63908.html title=煤的著火與燃燒特性>煤的著火與燃燒特性</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>