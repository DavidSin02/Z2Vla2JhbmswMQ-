<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ | 极客快訊</title><meta property="og:title" content="IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/af57fda2821d40ac90eed42e840e18ab"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7693935.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><meta property="article:published_time" content="2020-10-29T20:53:21+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:21+08:00"><meta name=Keywords content><meta name=description content="IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7693935.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>本文引用了餓了麼資深開發工程師萬汨“Redis 到底是怎麼實現“附近的人”這個功能的呢？”一文的內容，感謝原作者的分享，為了提升文章品質，即時通訊收錄時有內容補充和修訂。</p><h1>1、引言</h1><p>基本上以陌生人社交為主的IM產品裡，都會增加“附近的人”、“附近的xxx”這種以LBS（地理位置）為導向的產品特色（微信這個熟人社交產品裡為啥也有“附近的人”？這當然是歷史原因了，微信當初還不是想借此引流嘛。。。），因為“附近的xxx”這種類似功能在產品運營早期，對於種子用戶的積累有很大幫助（必竟某種需求，對於人類來說，是上帝賦予的最原始衝動，你懂的...）。<br><strong>比如下圖中的幾款主流移動端IM中的“附近的xxx”功能：</strong></p><div class=pgc-img><img alt=IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af57fda2821d40ac90eed42e840e18ab><p class=pgc-img-caption></p></div><p>那麼，對於很多即時通訊（IM）的開發者初學者來說，“附近的人”或者類似功能，在技術實現上還有點摸不著頭腦。本文將簡要的為你講解“附近的人”的基本理論原理，並以Redis的GEO系列地理位置操作指令為例，理論聯繫實際地為你講解它們是如何被高效實現的。<br><strong>閱讀提示：</strong>本文適合有一定Redis使用經驗的服務器後端開發人員閱讀，IM移動客戶端開發人員沒有太多閱讀的必要（理論原理倒是可以知道一下），必竟“附近的xxx”功能主要工作在服務端，而不在客戶端。</p><p>（本文同步發佈於：http://www.52im.net/thread-2827-1-1.html）<br></p><h1>2、IM開發乾貨系列文章</h1><p><strong>本文是系列文章中的第19篇，總目錄如下：</strong></p><ul class=litype_1><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-294-1-1.html target=_blank>IM消息送達保證機制實現(一)：保證在線實時消息的可靠投遞</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-594-1-1.html target=_blank>IM消息送達保證機制實現(二)：保證離線消息的可靠投遞</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-714-1-1.html target=_blank>如何保證IM實時消息的“時序性”與“一致性”？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-715-1-1.html target=_blank>IM單聊和群聊中的在線狀態同步應該用“推”還是“拉”？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-753-1-1.html target=_blank>IM群聊消息如此複雜，如何保證不丟不重？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-783-1-1.html target=_blank>一種Android端IM智能心跳算法的設計與實現探討（含樣例代碼）</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-787-1-1.html target=_blank>移動端IM登錄時拉取數據如何作到省流量？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-802-1-1.html target=_blank>通俗易懂：基於集群的移動端IM接入層負載均衡方案分享</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-867-1-1.html target=_blank>淺談移動端IM的多點登陸和消息漫遊原理</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1351-1-1.html target=_blank>IM開發基礎知識補課(一)：正確理解前置HTTP SSO單點登陸接口的原理</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1356-1-1.html target=_blank>IM開發基礎知識補課(二)：如何設計大量圖片文件的服務端存儲架構？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1366-1-1.html target=_blank>IM開發基礎知識補課(三)：快速理解服務端數據庫讀寫分離原理及實踐建議</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1525-1-1.html target=_blank>IM開發基礎知識補課(四)：正確理解HTTP短連接中的Cookie、Session和Token</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1611-1-1.html target=_blank>IM群聊消息的已讀回執功能該怎麼實現？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1616-1-1.html target=_blank>IM群聊消息究竟是存1份(即擴散讀)還是存多份(即擴散寫)？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1979-1-1.html target=_blank>IM開發基礎知識補課(五)：通俗易懂，正確理解並用好MQ消息隊列</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-866-1-1.html target=_blank>一個低成本確保IM消息時序的方法探討</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2759-1-1.html target=_blank>IM開發基礎知識補課(六)：數據庫用NoSQL還是SQL？讀這篇就夠了！</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2827-1-1.html target=_blank>IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？</a>》（本文）</li></ul><h1>3、“附近的人”功能原理</h1><p>其實，“附近的人”功能原理並不複雜。<br><strong>它需要做以下兩件事情：</strong></p><ul><li>1）所有使用該IM產品的人，在使用“附近的人”功能前提交自已的地理位置；</li><li>2）根據“我”的地理位置，計算出別人跟我的距離；</li><li>3）將第2步中計算出的距離由近及遠，進行排序。<br></li></ul><p><strong>具體在產品技術上的實現原理，也很容易理解：</strong></p><ul><li>1）現在移動端（ios、android等），通過系統的API很容易抓到用戶當前的位置（即經緯度數據）；</li><li>2）根據第1步中的經緯度數據，很容易計算出兩個點之間的距離（計算公式原理，可以百度一下，我的幾何和數學知識都還給老師了，給你講不了）；</li><li>3）對第2步中的計算結果排序就更簡單了，沒什麼好提的。<br></li></ul><p>對於IM新手來說，可能對於第2步中的根據經緯度數據計算出兩點距離，覺得有點難度，實際上根據數據公式（自已百度一下吧，有點複雜，哥不貼了），用代碼來實現，只有短短的十來行代碼。<br><strong>下面是一個簡單的Java版實現：</strong></p><blockquote><p>/**</p><p>* 計算地球上任意兩點(經緯度)距離</p><p>*</p><p>* @param long1 第一點經度</p><p>* @param lat1 第一點緯度</p><p>* @param long2 第二點經度</p><p>* @param lat2 第二點緯度</p><p>* @return 返回距離 單位：米</p><p>*/</p><p>public static double Distance(double long1, double lat1, double long2, double lat2)</p><p>{</p><p>double a, b, R;</p><p>R = 6378137; // 地球半徑</p><p>lat1 = lat1 * Math.PI / 180.0;</p><p>lat2 = lat2 * Math.PI / 180.0;</p><p>a = lat1 - lat2;</p><p>b = (long1 - long2) * Math.PI / 180.0;</p><p>double d;</p><p>double sa2, sb2;</p><p>sa2 = Math.sin(a / 2.0);</p><p>sb2 = Math.sin(b / 2.0);</p><p>d = 2 * R * Math.asin(Math.sqrt(sa2 * sa2 + Math.cos(lat1) * Math.cos(lat2) * sb2 * sb2));</p><p>return d;</p><p>}</p></blockquote><p>在進行代碼測試的時候，可以結合這個在線工具網頁進行結果檢驗：<a class=pgc-link data-content=mp href=http://www.hhlink.com/%E7%BB%8F%E7%BA%AC%E5%BA%A6/ target=_blank>http://www.hhlink.com/%E7%BB%8F%E7%BA%AC%E5%BA%A6/</a><br>嗯，看起來好簡單！<br></p><h1>4、自已從零實現的話，沒有難度嗎？</h1><p>嗯，通過上一節的原理講解，目前為止，看起來確實很簡單。<br>但，如果自已從零實現的話，對於IM這種高性能、高併發場景來說，確實有一點難度，難不在移動客戶端，而是在服務端。<br><strong>技術難點主要包括：</strong></p><ul><li>1）如何高效地進行兩點距離的計算，對於高併發服務端來說，像上一節中的代碼那樣，一個一個計算，還是有點不高效；</li><li>2）如何高效地進行地理圍欄的圈定（難道是把所有當前在線的用戶，離我的距離都一一算一遍，然後按距離進行篩選？那性能豈不是噩夢？）。<br></li></ul><p>那，有救嗎？答案是有！繼續看下一節。<br></p><h1>5、Redis裡的GEO地理位置相關指令，就能很好的上述問題</h1><p>針對“附近的人”這一位置服務領域的應用場景，服務端高性能場景下，常見的可使用PG、MySQL和MongoDB等多種DB的空間索引進行實現。<br>而<a class=pgc-link data-content=mp href=http://www.52im.net/redis.io/ target=_blank>Redis</a>另闢蹊徑，結合其有序隊列zset以及geohash編碼，實現了空間搜索功能，且擁有極高的運行效率。<br>要提供完整的“附近的人”這樣的功能或服務，最基本的是要實現“增”、“刪”、“查”的功能。本文餘下的文字，以下將分別進行介紹，其中會重點對查詢功能進行解析。並將從Redis源碼角度對其算法原理進行解析，並推算查詢時間複雜度。<br><strong>Redis相關資源：</strong></p><ul><li>1）Redis官網：<a class=pgc-link data-content=mp href=https://redis.io/ target=_blank>https://redis.io</a><br></li><li>2）Redis的GEO指令說明（英文）：<a class=pgc-link data-content=mp href=https://redis.io/commands target=_blank>https://redis.io/commands</a><br></li><li>3）Redis的GEO指令說明（中文）：<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geoadd.html target=_blank>http://redisdoc.com/geo/geoadd.html</a><br></li></ul><h1>6、Redis的GEO地理位置操作指令</h1><p>自 Redis 3.2版 開始，Redis基於geohash和有序集合提供了地理位置相關功能。<br><strong>Redis中的6個地理位置相關操作指令（見<a class=pgc-link data-content=mp href=https://redis.io/commands target=_blank>官方文檔</a>）：</strong></p><div class=pgc-img><img alt=IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a71387f252854b4d8f98bc2dfe1648c9><p class=pgc-img-caption></p></div><p><strong>Redis Geo模塊的6個指令用途說明：</strong></p><ul><li>1）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geoadd.html# target=_blank>GEOADD</a>：將給定的位置對象（緯度、經度、名字）添加到指定的key；</li><li>2）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geopos.html target=_blank>GEOPOS</a>：從key裡面返回所有給定位置對象的位置（經度和緯度）；</li><li>3）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geodist.html target=_blank>GEODIST</a>：返回兩個給定位置之間的距離；</li><li>4）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geohash.html target=_blank>GEOHASH</a>：返回一個或多個位置對象的Geohash表示；</li><li>5）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadius.html target=_blank>GEORADIUS</a>：以給定的經緯度為中心，返回目標集合中與中心的距離不超過給定最大距離的所有位置對象；</li><li>6）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadiusbymember.html target=_blank>GEORADIUSBYMEMBER</a>：以給定的位置對象為中心，返回與其距離不超過給定最大距離的所有位置對象。</li></ul><p>其中，組合使用<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geoadd.html# target=_blank>GEOADD</a>和<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadius.html target=_blank>GEORADIUS</a>可實現“附近的人”中“增”和“查”的基本功能。要實現類似於微信中“附近的人”功能，可直接使用<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadiusbymember.html target=_blank>GEORADIUSBYMEMBER</a>命令。<br>其中“給定的位置對象”即為用戶本人，搜索的對象為其他用戶。不過本質上，GEORADIUSBYMEMBER = GEOPOS + GEORADIUS，即先查找用戶位置再通過該位置搜索附近滿足位置相互距離條件的其他用戶對象。<br><strong>使用時的注意點：</strong></p><ul><li>1）Redis GEO操作中只包含了“增”和“查”的操作，並無專門“刪除”命令。主要是因為Redis內部使用有序集合(zset)保存位置對象，可用zrem刪除；</li><li>2）在Redis源碼geo.c的文件註釋中，只說明了該文件為GEOADD、GEORADIUS和GEORADIUSBYMEMBER的實現；</li><li>3）從側面看出其他三個命令為輔助命令。</li></ul><p>本文的餘下內容，將會從源碼角度入手，著生理地對GEOADD和GEORADIUS命令進行分析，剖析其算法原理。<br></p><h1>7、Redis的GEOADD指令是如何高效實現的</h1><p><strong>7.1 使用方式</strong></p><blockquote><p>GEOADD key longitude latitude member [longitude latitude member ...]</p></blockquote><p>以上命令，將給定的位置對象（緯度、經度、名字）添加到指定的key。<br>其中，key為集合名稱，member為該經緯度所對應的對象。在實際運用中，當所需存儲的對象數量過多時，可通過設置多key(如一個省一個key)的方式對對象集合變相做sharding，避免單集合數量過多。<br><strong>成功插入後的返回值：</strong></p><blockquote><p>(integer) N</p></blockquote><p>其中N為成功插入的個數。</p><p><strong>7.2 源碼分析</strong></p><blockquote><p>/* GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN] */</p><p>void geoaddCommand(client *c) {</p><p>//參數校驗</p><p>/* Check arguments number for sanity. */</p><p>if ((c->argc - 2) % 3 != 0) {</p><p>/* Need an odd number of arguments if we got this far... */</p><p>addReplyError(c, "syntax error. Try GEOADD key [x1] [y1] [name1] "</p><p>"[x2] [y2] [name2] ... ");</p><p>return;</p><p>}</p><p>//參數提取Redis</p><p>int elements = (c->argc - 2) / 3;</p><p>int argc = 2+elements*2; /* ZADD key score ele ... */</p><p>robj **argv = zcalloc(argc*sizeof(robj*));</p><p>argv[0] = createRawStringObject("zadd",4);</p><p>argv[1] = c->argv[1]; /* key */</p><p>incrRefCount(argv[1]);</p><p>//參數遍歷+轉換</p><p>/* Create the argument vector to call ZADD in order to add all</p><p>* the score,value pairs to the requested zset, where score is actually</p><p>* an encoded version of lat,long. */</p><p>int i;</p><p>for (i = 0; i &lt; elements; i++) {</p><p>double xy[2];</p><p>//提取經緯度</p><p>if (extractLongLatOrReply(c, (c->argv+2)+(i*3),xy) == C_ERR) {</p><p>for (i = 0; i &lt; argc; i++)</p><p>if (argv[i ]) decrRefCount(argv[i ]);</p><p>zfree(argv);</p><p>return;</p><p>}</p><p>//將經緯度轉換為52位的geohash作為分值 & 提取對象名稱</p><p>/* Turn the coordinates into the score of the element. */</p><p>GeoHashBits hash;</p><p>geohashEncodeWGS84(xy[0], xy[1], GEO_STEP_MAX, &hash);</p><p>GeoHashFix52Bits bits = geohashAlign52Bits(hash);</p><p>robj *score = createObject(OBJ_STRING, sdsfromlonglong(bits));</p><p>robj *val = c->argv[2 + i * 3 + 2];</p><p>//設置有序集合的對象元素名稱和分值</p><p>argv[2+i*2] = score;</p><p>argv[3+i*2] = val;</p><p>incrRefCount(val);</p><p>}</p><p>//調用zadd命令，存儲轉化好的對象</p><p>/* Finally call ZADD that will do the work for us. */</p><p>replaceClientCommandVector(c,argc,argv);</p><p>zaddCommand(c);</p><p>}</p></blockquote><p>通過Redis源碼分析可以看出，Redis內部使用有序集合(zset)保存位置對象，有序集合中每個元素都是一個帶位置的對象，元素的score值為其經緯度對應的52位的geohash值：</p><p>1）double類型精度為52位；<br>2）geohash是以base32的方式編碼，52bits最高可存儲10位geohash值，對應地理區域大小為0.6*0.6米的格子。換句話說經Redis geo轉換過的位置理論上會有約0.3*1.414=0.424米的誤差。</p><p><strong>7.3 算法小結</strong></p><p><strong>簡單總結下GEOADD命令都幹了啥：</strong></p><ul><li>1）參數提取和校驗；</li><li>2）將入參經緯度轉換為52位的geohash值（score）；</li><li>3）調用ZADD命令將member及其對應的score存入集合key中。</li></ul><h1>8、Redis的GEORADIUS指令是如何高效實現的</h1><p><strong>8.1 使用方式</strong></p><blockquote><p>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count] [STORE key] [STORedisT key]</p></blockquote><p>以上指令，將以給定的經緯度為中心，返回目標集合中與中心的距離不超過給定最大距離的所有位置對象。<br></p><blockquote><p>範圍單位：m | km | ft | mi --> 米 | 千米 | 英尺 | 英里<br>額外參數：<br>- WITHDIST：在返回位置對象的同時，將位置對象與中心之間的距離也一併返回。距離的單位和用戶給定的範圍單位保持一致。<br>- WITHCOORD：將位置對象的經度和維度也一併返回。<br>- WITHHASH：以 52 位有符號整數的形式，返回位置對象經過原始 geohash 編碼的有序集合分值。這個選項主要用於底層應用或者調試，實際中的作用並不大。<br>- ASC|DESC：從近到遠返回位置對象元素 | 從遠到近返回位置對象元素。<br>- COUNT count：選取前N個匹配位置對象元素。（不設置則返回所有元素）<br>- STORE key：將返回結果的地理位置信息保存到指定key。<br>- STORedisT key：將返回結果離中心點的距離保存到指定key。</p></blockquote><p>由於 STORE 和 STORedisT 兩個選項的存在，GEORADIUS 和 GEORADIUSBYMEMBER 命令在技術上會被標記為寫入命令，從而只會查詢（寫入）主實例，QPS過高時容易造成主實例讀寫壓力過大。<br>為解決這個問題，在 Redis 3.2.10 和 Redis 4.0.0 中，分別新增了 GEORADIUS_RO 和 GEORADIUSBYMEMBER_RO兩個只讀命令。<br>不過，在實際開發中筆者發現 在java package Redis.clients.jedis.params.geo 的 GeoRadiusParam 參數類中並不包含 STORE 和 STORedisT 兩個參數選項，在調用georadius時是否真的只查詢了主實例，還是進行了只讀封裝。感興趣的朋友可以自己研究下。<br><strong>成功查詢後的返回值：</strong></p><blockquote><p>不帶WITH限定，返回一個member list，如：["member1","member2","member3"]</p></blockquote><p><br><strong>帶WITH限定，member list中每個member也是一個嵌套list，如：</strong></p><blockquote><p>[</p><p>["member1", distance1, [longitude1, latitude1]]</p><p>["member2", distance2, [longitude2, latitude2]]</p><p>]</p></blockquote><p><strong>8.2源碼分析</strong></p><p><br>此段源碼較長，看不下去的可直接看中文註釋，或直接跳到小結部分。</p><blockquote><p>/* GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]</p><p>* [COUNT count] [STORE key] [STORedisT key]</p><p>* GEORADIUSBYMEMBER key member radius unit ... options ... */</p><p>void georadiusGeneric(client *c, int flags) {</p><p>robj *key = c->argv[1];</p><p>robj *storekey = NULL;</p><p>int stoRedist = 0; /* 0 for STORE, 1 for STORedisT. */</p><p>//根據key獲取有序集合</p><p>robj *zobj = NULL;</p><p>if ((zobj = lookupKeyReadOrReply(c, key, shared.null[c->resp])) == NULL ||</p><p>checkType(c, zobj, OBJ_ZSET)) {</p><p>return;</p><p>}</p><p>//根據用戶輸入（經緯度/member）確認中心點經緯度</p><p>int base_args;</p><p>double xy[2] = { 0 };</p><p>if (flags & RADIUS_COORDS) {</p><p>……</p><p>}</p><p>//獲取查詢範圍距離</p><p>double radius_meters = 0, conversion = 1;</p><p>if ((radius_meters = extractDistanceOrReply(c, c->argv + base_args - 2,</p><p>&conversion)) &lt; 0) {</p><p>return;</p><p>}</p><p>//獲取可選參數 （withdist、withhash、withcoords、sort、count）</p><p>int withdist = 0, withhash = 0, withcoords = 0;</p><p>int sort = SORT_NONE;</p><p>long long count = 0;</p><p>if (c->argc > base_args) {</p><p>... ...</p><p>}</p><p>//獲取 STORE 和 STORedisT 參數</p><p>if (storekey && (withdist || withhash || withcoords)) {</p><p>addReplyError(c,</p><p>"STORE option in GEORADIUS is not compatible with "</p><p>"WITHDIST, WITHHASH and WITHCOORDS options");</p><p>return;</p><p>}</p><p>//設定排序</p><p>if (count != 0 && sort == SORT_NONE) sort = SORT_ASC;</p><p>//利用中心點和半徑計算目標區域範圍</p><p>GeoHashRadius georadius =</p><p>geohashGetAreasByRadiusWGS84(xy[0], xy[1], radius_meters);</p><p>//對中心點及其周圍8個geohash網格區域進行查找，找出範圍內元素對象</p><p>geoArray *ga = geoArrayCreate();</p><p>membersOfAllNeighbors(zobj, georadius, xy[0], xy[1], radius_meters, ga);</p><p>//未匹配返空</p><p>/* If no matching results, the user gets an empty reply. */</p><p>if (ga->used == 0 && storekey == NULL) {</p><p>addReplyNull(c);</p><p>geoArrayFree(ga);</p><p>return;</p><p>}</p><p>//一些返回值的設定和返回</p><p>……</p><p>geoArrayFree(ga);</p><p>}</p></blockquote><p><br><strong>上文代碼中最核心的步驟有兩個：</strong></p><ul><li>一是“計算中心點範圍；</li><li>二是“對中心點及其周圍8個geohash網格區域進行查找”。</li></ul><p>對應的是geohashGetAreasByRadiusWGS84和membersOfAllNeighbors兩個函數。<br>我們依次來看。<br><strong>計算中心點範圍：</strong></p><blockquote><p>// geohash_helper.c</p><p>GeoHashRadius geohashGetAreasByRadiusWGS84(double longitude, double latitude,</p><p>double radius_meters) {</p><p>return geohashGetAreasByRadius(longitude, latitude, radius_meters);</p><p>}</p><p>//返回能夠覆蓋目標區域範圍的9個geohashBox</p><p>GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double radius_meters) {</p><p>//一些參數設置</p><p>GeoHashRange long_range, lat_range;</p><p>GeoHashRadius radius;</p><p>GeoHashBits hash;</p><p>GeoHashNeighbors neighbors;</p><p>GeoHashArea area;</p><p>double min_lon, max_lon, min_lat, max_lat;</p><p>double bounds[4];</p><p>int steps;</p><p>//計算目標區域外接矩形的經緯度範圍（目標區域為：以目標經緯度為中心，半徑為指定距離的圓）</p><p>geohashBoundingBox(longitude, latitude, radius_meters, bounds);</p><p>min_lon = bounds[0];</p><p>min_lat = bounds[1];</p><p>max_lon = bounds[2];</p><p>max_lat = bounds[3];</p><p>//根據目標區域中心點緯度和半徑，計算帶查詢的9個搜索框的geohash精度（位）</p><p>//這裡用到latitude主要是針對極地的情況對精度進行了一些調整（緯度越高，位數越小）</p><p>steps = geohashEstimateStepsByRadius(radius_meters,latitude);</p><p>//設置經緯度最大最小值：-180&lt;=longitude&lt;=180, -85&lt;=latitude&lt;=85</p><p>geohashGetCoordRange(&long_range,&lat_range);</p><p>//將待查經緯度按指定精度（steps）編碼成geohash值</p><p>geohashEncode(&long_range,&lat_range,longitude,latitude,steps,&hash);</p><p>//將geohash值在8個方向上進行擴充，確定周圍8個Box（neighbors）</p><p>geohashNeighbors(&hash,&neighbors);</p><p>//根據hash值確定area經緯度範圍</p><p>geohashDecode(long_range,lat_range,hash,&area);</p><p>//一些特殊情況處理</p><p>……</p><p>//構建並返回結果</p><p>radius.hash = hash;</p><p>radius.neighbors = neighbors;</p><p>radius.area = area;</p><p>return radius;</p><p>}</p></blockquote><p><br><strong>對中心點及其周圍8個geohash網格區域進行查找:</strong></p><blockquote><p>// geo.c</p><p>//在9個hashBox中獲取想要的元素</p><p>int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, double lon, double lat, double radius, geoArray *ga) {</p><p>GeoHashBits neighbors[9];</p><p>unsigned int i, count = 0, last_processed = 0;</p><p>int debugmsg = 0;</p><p>//獲取9個搜索hashBox</p><p>neighbors[0] = n.hash;</p><p>……</p><p>neighbors[8] = n.neighbors.south_west;</p><p>//在每個hashBox中搜索目標點</p><p>for (i = 0; i &lt; sizeof(neighbors) / sizeof(*neighbors); i++) {</p><p>if (HASHISZERO(neighbors[i ])) {</p><p>if (debugmsg) D("neighbors[%d] is zero",i);</p><p>continue;</p><p>}</p><p>//剔除可能的重複hashBox (搜索半徑>5000KM時可能出現)</p><p>if (last_processed &&</p><p>neighbors[i ].bits == neighbors[last_processed].bits &&</p><p>neighbors[i ].step == neighbors[last_processed].step)</p><p>{</p><p>continue;</p><p>}</p><p>//搜索hashBox中滿足條件的對象</p><p>count += membersOfGeoHashBox(zobj, neighbors[i ], ga, lon, lat, radius);</p><p>last_processed = i;</p><p>}</p><p>return count;</p><p>}</p><p>int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, double lon, double lat, double radius) {</p><p>//獲取hashBox內的最大、最小geohash值（52位）</p><p>GeoHashFix52Bits min, max;</p><p>scoresOfGeoHashBox(hash,&min,&max);</p><p>//根據最大、最小geohash值篩選zobj集合中滿足條件的點</p><p>return geoGetPointsInRange(zobj, min, max, lon, lat, radius, ga);</p><p>}</p><p>int geoGetPointsInRange(robj *zobj, double min, double max, double lon, double lat, double radius, geoArray *ga) {</p><p>//搜索Range的參數邊界設置（即9個hashBox其中一個的邊界範圍）</p><p>zrangespec range = { .min = min, .max = max, .minex = 0, .maxex = 1 };</p><p>size_t origincount = ga->used;</p><p>sds member;</p><p>//搜索集合zobj可能有ZIPLIST和SKIPLIST兩種編碼方式，這裡以SKIPLIST為例，邏輯是一樣的</p><p>if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {</p><p>……</p><p>} else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {</p><p>zset *zs = zobj->ptr;</p><p>zskiplist *zsl = zs->zsl;</p><p>zskiplistNode *ln;</p><p>//獲取在hashBox範圍內的首個元素（跳錶數據結構，效率可比擬於二叉查找樹），沒有則返0</p><p>if ((ln = zslFirstInRange(zsl, &range)) == NULL) {</p><p>/* Nothing exists starting at our min. No results. */</p><p>return 0;</p><p>}</p><p>//從首個元素開始遍歷集合</p><p>while (ln) {</p><p>sds ele = ln->ele;</p><p>//遍歷元素超出range範圍則break</p><p>/* Abort when the node is no longer in range. */</p><p>if (!zslValueLteMax(ln->score, &range))</p><p>break;</p><p>//元素校驗（計算元素與中心點的距離）</p><p>ele = sdsdup(ele);</p><p>if (geoAppendIfWithinRadius(ga,lon,lat,radius,ln->score,ele)</p><p>== C_ERR) sdsfree(ele);</p><p>ln = ln->level[0].forward;</p><p>}</p><p>}</p><p>return ga->used - origincount;</p><p>}</p><p>int geoAppendIfWithinRadius(geoArray *ga, double lon, double lat, double radius, double score, sds member) {</p><p>double distance, xy[2];</p><p>//解碼錯誤, 返回error</p><p>if (!decodeGeohash(score,xy)) return C_ERR; /* Can't decode. */</p><p>//最終距離校驗(計算球面距離distance看是否小於radius)</p><p>if (!geohashGetDistanceIfInRadiusWGS84(lon,lat, xy[0], xy[1],</p><p>radius, &distance))</p><p>{</p><p>return C_ERR;</p><p>}</p><p>//構建並返回滿足條件的元素</p><p>geoPoint *gp = geoArrayAppend(ga);</p><p>gp->longitude = xy[0];</p><p>gp->latitude = xy[1];</p><p>gp->dist = distance;</p><p>gp->member = member;</p><p>gp->score = score;</p><p>return C_OK;</p><p>}</p></blockquote><p><strong>8.3 算法小結</strong></p><p><strong>拋開眾多可選參數不談，簡單總結下GEORADIUS命令是怎麼利用geohash獲取目標位置對象的：</strong></p><ul><li>1）參數提取和校驗；</li><li>2）利用中心點和輸入半徑計算待查區域範圍。這個範圍參數包括滿足條件的最高的geohash網格等級(精度) 以及 對應的能夠覆蓋目標區域的九宮格位置；（後續會有詳細說明）</li><li>3）對九宮格進行遍歷，根據每個geohash網格的範圍框選出位置對象。進一步找出與中心點距離小於輸入半徑的對象，進行返回。<br></li></ul><p><strong>直接描述不太好理解，我們通過如下兩張圖在對算法進行簡單的演示：</strong></p><div class=pgc-img><img alt=IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1e93bc8088524232b29062d4c8ada6bb><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc9e2446d3fc4726b626aa9361be4cfa><p class=pgc-img-caption></p></div><p><br>如上圖所示，令左圖的中心為搜索中心，綠色圓形區域為目標區域，所有點為待搜索的位置對象，紅色點則為滿足條件的位置對象。<br>在實際搜索時,首先會根據搜索半徑計算geohash網格等級（即右圖中網格大小等級），並確定九宮格位置（即紅色九宮格位置信息）；再依次查找計算九宮格中的點（藍點和紅點）與中心點的距離，最終篩選出距離範圍內的點（紅點）。<br></p><p><strong>8.4 算法分析</strong></p><p>為什麼要用這種算法策略進行查詢，或者說這種策略的優勢在哪，讓我們以問答的方式進行分析說明。<br><strong>為什麼要找到滿足條件的最高的geohash網格等級？為什麼用九宮格？</strong><br>這其實是一個問題，本質上是對所有的元素對象進行了一次初步篩選。 在多層geohash網格中，每個低等級的geohash網格都是由4個高一級的網格拼接而成（如下圖）。</p><div class=pgc-img><img alt=IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7f75c7af853049eea44d0a7cfb80b19d><p class=pgc-img-caption></p></div><p>換句話說，geohash網格等級越高，所覆蓋的地理位置範圍就越小。 當我們根據輸入半徑和中心點位置計算出的能夠覆蓋目標區域的最高等級的九宮格（網格）時，就已經對九宮格外的元素進行了篩除。 這裡之所以使用九宮格，而不用單個網格，主要原因還是為了避免邊界情況，儘可能縮小查詢區域範圍。試想以0經緯度為中心，就算查1米範圍，單個網格覆蓋的話也得查整個地球區域。而向四周八個方向擴展一圈可有效避免這個問題。<br><strong>如何通過geohash網格的範圍框選出元素對象？效率如何？</strong><br>首先在每個geohash網格中的geohash值都是連續的，有固定範圍。所以只要找出有序集合中，處在該範圍的位置對象即可。以下是有序集合的跳錶數據結構：</p><div class=pgc-img><img alt=IM裡“附近的人”功能實現原理是什麼？如何高效率地實現它？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2a268ad53bb04c368424286f898f8ccb><p class=pgc-img-caption></p></div><p>其擁有類似二叉查找樹的查詢效率，操作平均時間複雜性為O(log(N))。且最底層的所有元素都以鏈表的形式按序排列。所以在查詢時，只要找到集合中處在目標geohash網格中的第一個值，後續依次對比即可，不用多次查找。 九宮格不能一起查，要一個個遍歷的原因也在於九宮格各網格對應的geohash值不具有連續性。只有連續了，查詢效率才會高，不然要多做許多距離運算。<br></p><h1>9、本文小結</h1><p><br>綜合上述章節，我們從源碼角度解析了Redis Geo模塊中 “增（GEOADD）” 和 “查（GEORADIUS）” 的詳細過程。並可推算出Redis中GEORADIUS查找附近的人功能，時間複雜度為：O(N+log(M))。<br><strong>其中：</strong></p><ul><li>1）N為九宮格範圍內的位置元素數量（要算距離）；</li><li>2）M是指定層級格子的數量；</li><li>3）log(M)是跳錶結構中找到每個格子首元素的時間複雜度（這個過程一般會進行9次）。</li></ul><p>結合Redis本身基於內存的存儲特性，在實際使用過程中有非常高的運行效率。<br>以上，就是本文的全部答案，不知是否對你有幫助！<br></p><h1>附錄：更多IM開發綜合文章</h1><p>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-464-1-1.html target=_blank>新手入門一篇就夠：從零開發移動端IM</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1587-1-1.html target=_blank>移動端IM開發者必讀(一)：通俗易懂，理解移動網絡的“弱”和“慢”</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1588-1-1.html target=_blank>移動端IM開發者必讀(二)：史上最全移動弱網絡優化方法總結</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1470-1-1.html target=_blank>從客戶端的角度來談談移動端IM的消息可靠性和送達機制</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1413-1-1.html target=_blank>現代移動端網絡短連接的優化手段總結：請求速度、弱網適應、安全保障</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1391-1-1.html target=_blank>騰訊技術分享：社交網絡圖片的帶寬壓縮技術演進之路</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1686-1-1.html target=_blank>小白必讀：閒話HTTP短連接中的Session和Token</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1351-1-1.html target=_blank>IM開發基礎知識補課：正確理解前置HTTP SSO單點登陸接口的原理</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1221-1-1.html target=_blank>移動端IM中大規模群消息的推送如何保證效率、實時性？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-133-1-1.html target=_blank>移動端IM開發需要面對的技術問題</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-150-1-1.html target=_blank>開發IM是自己設計協議用字節流好還是字符流好？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-175-1-1.html target=_blank>請問有人知道語音留言聊天的主流實現方式嗎？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-802-1-1.html target=_blank>通俗易懂：基於集群的移動端IM接入層負載均衡方案分享</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-195-1-1.html target=_blank>微信對網絡影響的技術試驗及分析（論文全文）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-218-1-1.html target=_blank>即時通訊系統的原理、技術和應用（技術論文）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-447-1-1.html target=_blank>開源IM工程“蘑菇街TeamTalk”的現狀：一場有始無終的開源秀</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1208-1-1.html target=_blank>QQ音樂團隊分享：Android中的圖片壓縮技術詳解（上篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1212-1-1.html target=_blank>QQ音樂團隊分享：Android中的圖片壓縮技術詳解（下篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-675-1-1.html target=_blank>騰訊原創分享(一)：如何大幅提升移動網絡下手機QQ的圖片傳輸速度和成功率</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-696-1-1.html target=_blank>騰訊原創分享(二)：如何大幅壓縮移動網絡下APP的流量消耗（上篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-697-1-1.html target=_blank>騰訊原創分享(三)：如何大幅壓縮移動網絡下APP的流量消耗（下篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-684-1-1.html target=_blank>如約而至：微信自用的移動端IM網絡層跨平臺組件庫Mars已正式開源</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1191-1-1.html target=_blank>基於社交網絡的Yelp是如何實現海量用戶圖片的無損壓縮的？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1559-1-1.html target=_blank>騰訊技術分享：騰訊是如何大幅降低帶寬和網絡流量的(圖片壓縮篇)</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1560-1-1.html target=_blank>騰訊技術分享：騰訊是如何大幅降低帶寬和網絡流量的(音視頻技術篇)</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1693-1-1.html target=_blank>字符編碼那點事：快速理解ASCII、Unicode、GBK和UTF-8</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1802-1-1.html target=_blank>全面掌握移動端主流圖片格式的特點、性能、調優等</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1961-1-1.html target=_blank>子彈短信光鮮的背後：網易雲信首席架構師分享億級IM平臺的技術實踐</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1979-1-1.html target=_blank>IM開發基礎知識補課(五)：通俗易懂，正確理解並用好MQ消息隊列</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1998-1-1.html target=_blank>微信技術分享：微信的海量IM聊天消息序列號生成實踐（算法原理篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2671-1-1.html target=_blank>自已開發IM有那麼難嗎？手把手教你自擼一個Andriod版簡易IM (有源碼)</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2747-1-1.html target=_blank>融雲技術分享：解密融雲IM產品的聊天消息ID生成策略</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2768-1-1.html target=_blank>適合新手：從零開發一個IM服務端（基於Netty，有完整源碼）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2775-1-1.html target=_blank>拿起鍵盤就是幹：跟我一起徒手開發一套分佈式IM系統</a>》<br>>> <a class=pgc-link data-content=mp href="http://www.52im.net/forum.php?mod=collection&action=view&ctid=10" target=_blank>更多同類文章 ……</a><br></p><p>（本文同步發佈於：http://www.52im.net/thread-2827-1-1.html）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>IM</a></li><li><a>實現</a></li><li><a>什麼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8b906e2.html alt=超導體是什麼，為什麼實現室溫超導體這麼難？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e46b6a8082244b67a65e834afd15e24a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8b906e2.html title=超導體是什麼，為什麼實現室溫超導體這麼難？>超導體是什麼，為什麼實現室溫超導體這麼難？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b887511.html alt=什麼是圖像識別？圖像識別是如何實現的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b076d72b1ccc4fac99809dba1c4614c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b887511.html title=什麼是圖像識別？圖像識別是如何實現的？>什麼是圖像識別？圖像識別是如何實現的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2277c6.html alt=為什麼要實現存儲控制器國產化？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15282537344873d68e7cf56 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2277c6.html title=為什麼要實現存儲控制器國產化？>為什麼要實現存儲控制器國產化？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdedb94f.html alt=科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d84b472b45474058bfd6bd4b87450f53 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdedb94f.html title=科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！>科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52ecc739.html alt=科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f0b8a6daf6e4f9bab21e7c06cbc9111 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52ecc739.html title=科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！>科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html alt=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1537941825042b6f495fa56 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html title=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？>長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83641773.html alt=什麼是懸挑結構？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/faebf061b82546f58e63afab5ede5fa2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83641773.html title=什麼是懸挑結構？>什麼是懸挑結構？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a27253ff.html alt=港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a3c45dcf4c374ed4be36f55d44847637 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a27253ff.html title=港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事>港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3eed9cb8.html alt=科普！港珠澳大橋為什麼是彎的！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/41bd66f3348b464c89b66628810a1aeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3eed9cb8.html title=科普！港珠澳大橋為什麼是彎的！>科普！港珠澳大橋為什麼是彎的！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/765025c9.html alt=電纜與光纜有什麼區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c289a44885646ac904fbae012632866 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/765025c9.html title=電纜與光纜有什麼區別>電纜與光纜有什麼區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c5053ab7.html alt="網站服務器是什麼 網站服務器怎麼搭建「詳解」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f9cfb6ae0c13447eab17646a80117f1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c5053ab7.html title="網站服務器是什麼 網站服務器怎麼搭建「詳解」">網站服務器是什麼 網站服務器怎麼搭建「詳解」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b60dd43.html alt=長壽者的耳朵為什麼比別人長？原來耳朵還有這個大祕密 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/616a0000c4f325f77564 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b60dd43.html title=長壽者的耳朵為什麼比別人長？原來耳朵還有這個大祕密>長壽者的耳朵為什麼比別人長？原來耳朵還有這個大祕密</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c33cb41.html alt=為什麼每天都那麼累？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S2HRVEQ6t1WhxB style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c33cb41.html title=為什麼每天都那麼累？>為什麼每天都那麼累？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f7c0fd3.html alt=什麼是場景？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f7c0fd3.html title=什麼是場景？>什麼是場景？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd2acf38.html alt=寫場面要注意什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e5a000167e332d06355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd2acf38.html title=寫場面要注意什麼？>寫場面要注意什麼？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>