<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>TypeScript 手冊完結版 | 极客快訊</title><meta property="og:title" content="TypeScript 手冊完結版 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/4d389e1d77a54cff8a8117a59bf29159"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/783a28ab.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/783a28ab.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/783a28ab.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/783a28ab.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/783a28ab.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/783a28ab.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/783a28ab.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/783a28ab.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="TypeScript 手冊完結版"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/783a28ab.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>TypeScript 手冊完結版</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>根據對 90,000 名開發人員的 Stack Overflow 調查，TypeScript 是人們最想學習的框架之一。</p><p>在過去幾年中，TypeScript 的受歡迎程度，社區規模和採用率都在不斷提高。 目前，Facebook 的 Facebook Jest 項目正在向 TypeScript 轉移。</p><p>TypeScript 是什麼?</p><p>TypeScript 是 JavaScript 的靜態類型超集，提供了類型系統和對 ES6 的支持，它可以編譯成純 JavaScript。編譯出來的 JavaScript 可以運行在任何瀏覽器上。TypeScript 編譯工具可以運行在任何服務器和任何系統上</p><p>為什麼使用 Typescript?</p><p>JavaScript 在過去幾年中發展了很多。 它是用於客戶端和服務器端的最通用的跨平臺語言。</p><p>但 JavaScript 從未意味著進行如此大規模的應用程序開發。 它是一種沒有類型系統的動態語言，這意味著變量可以具有任何類型的值，例如字符串或布爾值。</p><p>類型系統可提高代碼質量，可讀性，並使代碼庫的維護和重構更容易。 更重要的是，錯誤可以在編譯時而不是在運行時捕獲。</p><p>如果沒有類型系統，很難擴展 JavaScript 以構建複雜的應用程序，而大型團隊則使用相同的代碼。</p><p>TypeScript 在編譯時提供代碼不同部分之間的保證。 編譯器錯誤通常會告訴您確切的錯誤位置以及出現了什麼問題，而運行時錯誤伴隨著堆棧跟蹤可能會產生誤導並導致花費大量時間在調試工作上。</p><p>TypeScript 專業的地方</p><ol><li>在編譯階段實時捕獲潛在錯誤。</li><li>管理大型代碼庫。</li><li>增強了編輯器和 IDE 的功能，包括代碼補全、接口提示、跳轉到定義、，更容易重構等。</li><li>它可以減少開發人員的認知負擔，它可以定義從簡單到複雜的幾乎一切類型，讓團隊更容易工作</li><li>文檔 - 類型提供了一些開發人員可以遵循的文檔，大部分的函數看看類型的定義就可以知道如何使用了</li></ol><p>TypeScript 不足的地方</p><ol><li>學習成本較高，要理解接口（Interfaces）、泛型（Generics）、類（Classes）、枚舉類型（Enums）等前端工程師可能不是很熟悉的概念，需要在項目週期和維護成本中權衡，大家可以根據自己團隊和項目的情況判斷是否需要使用 TypeScript。</li><li>類型錯誤可能不一致，短期可能會增加一些開發成本，畢竟要多寫一些類型的定義，不過對於一個需要長期維護的項目，TypeScript 能夠減少其維護成本。</li><li>集成到構建流程需要一些工作量。</li></ol><p>類型</p><p>布爾值</p><pre>const isLoading: boolean = false複製代碼</pre><p>數值</p><pre>const decimal: number = 8const binary: number = 0b110複製代碼</pre><p>字符串</p><pre>const fruit: string = 'orange'複製代碼</pre><p>數組</p><p>數組類型可以用以下兩種方式之一編寫：</p><pre>// 常見的let firstFivePrimes: number[] = [2, 3, 5, 7, 11]// 不常見。 使用泛型類型（稍後會詳細介紹）let firstFivePrimes2: Array&lt;number&gt; = [2, 3, 5, 7, 11]複製代碼</pre><p>元組</p><p>數組合並了相同類型的對象，而元組（Tuple）合併了不同類型的對象。元組起源於函數編程語言（如 F#）,在這些語言中頻繁使用元組。</p><pre>let contact: [string, number] = ['John', 954683]contact = ['Ana', 842903, 'extra argument'] /* Error! Type '[string, number, string]' is not assignable to type '[string, number]'. */複製代碼</pre><p>任意值</p><p>any 與類型系統中的任何和所有類型兼容，這意味著可以將任何內容分配給它，並且可以將其分配給任何類型。它使您能夠選擇不通過類型檢查。</p><pre>let variable: any = 'a string';variable = 5;variable = false;variable.someRandomMethod(); /_ Okay,someRandomMethod might exist at runtime. _/複製代碼</pre><p>Void</p><p>void 是沒有任何類型的。它通常用作不返回值的函數的返回類型。</p><pre>function sayMyName(name: string): void { console.log(name)}sayMyName('Heisenberg')複製代碼</pre><p>Never</p><p>never 類型表示從未發生的值的類型。例如，never 函數的返回類型將始終拋出異常或未達到其終點。</p><pre>// throws an exceptionfunction error(message: string): never { throw new Error(message)}// unreachable end pointfunction continuousProcess(): never { while (true) { // ... }}複製代碼</pre><p>Null and Undefined</p><p>可以使用 null 和 undefined 來定義這兩個原始數據類型,它們本身並不是非常有用，但是當它們在聯合類型中使用時會變得非常有用 (等下會有更多內容)</p><pre>type someProp = string | null | undefined複製代碼</pre><p>未知類型</p><p>TypeScript 3.0 引入了未知類型，它是任何類型安全的對應類型。 任何東西都可以分配給未知的，但是未知的東西除了本身和任何東西外都不能分配。 如果沒有先聲明或縮小為更具體的類型，則不允許對未知操作進行操作。</p><pre>type I1 = unknown &amp; null // nulltype I2 = unknown &amp; string // stringtype U1 = unknown | null // unknowntype U2 = unknown | string // unknown複製代碼</pre><p>類型別名</p><p>類型別名提供類型註釋的名稱，允許您在多個位置使用它。它們使用以下語法創建：</p><pre>type Login = string複製代碼</pre><p>聯合類型</p><p>TypeScript 允許我們為屬性使用多種數據類型。這稱為聯合類型。</p><pre>type Password = string | number複製代碼</pre><p>混合類型</p><p>混合類型是組合所有成員類型的屬性的類型</p><pre>interface Person { name: string age: number}interface Worker { companyId: string}type Employee = Person &amp; Workerconst bestOfTheMonth: Employee = { name: 'Peter', age: 39, companyId: '123456'}複製代碼</pre><p>接口</p><p>在 TypeScript 中，我們使用接口（Interfaces）來定義對象的類型。 在面嚮對象語言中，接口（Interfaces）是一個很重要的概念，它是對行為的抽象，而具體如何行動需要由類（classes）去實現（implement）。 TypeScript 中的接口是一個非常靈活的概念，除了可用於對類的一部分行為進行抽象以外，也常用於對「對象的形狀（Shape）」進行描述。 附註：接口的運行時 JS 影響為零，它僅用於類型檢查。</p><p>您可以聲明標記帶有？的可選屬性，這意味著接口的對象可能定義這些屬性，也可能不定義這些屬性。 您可以聲明只讀屬性，這意味著一旦為屬性分配了值，就無法更改它。</p><pre>interface ICircle { readonly id: string center: { x: number y: number } radius: number color?: string // 可選屬性}const circle1: ICircle = { id: '001', center: { x: 0 }, radius: 8}/* Error! Property 'y' is missing in type '{ x: number; }'but required in type '{ x: number; y: number; }'. */const circle2: ICircle = { id: '002', center: { x: 0, y: 0 }, radius: 8} // Okaycircle2.color = '#666' // Okaycircle2.id = '003'/* Error!Cannot assign to 'id' because it is a read-only property. */複製代碼</pre><p>擴展接口</p><p>接口可以擴展一個或多個接口。這使得編寫接口變得靈活且可重用。</p><pre>interface ICircleWithArea extends ICircle { getArea: () =&gt; number}const circle3: ICircleWithArea = { id: '003', center: { x: 0, y: 0 }, radius: 6, color: '#fff', getArea: function() { return this.radius ** 2 * Math.PI }}複製代碼</pre><p>實現接口</p><p>實現接口的類需要嚴格遵循接口的結構。</p><pre>interface IClock { currentTime: Date setTime(d: Date): void}class Clock implements IClock { currentTime: Date = new Date() setTime(d: Date) { this.currentTime = d } constructor(h: number, m: number) {}}複製代碼</pre><p>枚舉</p><p>一個 enum（或枚舉）是組織相關的值，可以是數值或字符串值的集合的方式。</p><pre>enum CardSuit { Clubs, Diamonds, Hearts, Spades}let card = CardSuit.Clubscard = 'not a card suit' /* Error! Type '"not a card suit"'is not assignable to type 'CardSuit'. */複製代碼</pre><p>Under the hood(不會翻譯), 枚舉默認情況下是基於數字的。enum 值從零開始，每個成員遞增 1。</p><p>我們之前的示例生成的 JavaScript 代碼：</p><pre>var CardSuit;(function(CardSuit) { CardSuit[(CardSuit['Clubs'] = 0)] = 'Clubs' CardSuit[(CardSuit['Diamonds'] = 1)] = 'Diamonds' CardSuit[(CardSuit['Hearts'] = 2)] = 'Hearts' CardSuit[(CardSuit['Spades'] = 3)] = 'Spades'})(CardSuit || (CardSuit = {}))/** * 這導致以下對象： * { * 0: "Clubs", * 1: "Diamonds", * 2: "Hearts", * 3: "Spades", * Clubs: 0, * Diamonds: 1, * Hearts: 2, * Spades: 3 * } */複製代碼</pre><p>或者，可以使用字符串值初始化枚舉，這是一種更易讀的方法。</p><pre>enum SocialMedia { Facebook = 'FACEBOOK', Twitter = 'TWITTER', Instagram = 'INSTAGRAM', LinkedIn = 'LINKEDIN'}複製代碼</pre><p>反向映射</p><p>enum 支持反向映射，這意味著我們可以從其值中訪問成員的值以及成員名稱。 映射到我們的 CardSuit 示例：</p><pre>const clubsAsNumber: number = CardSuit.Clubs // 3const clubsAsString: string = CardSuit[0] // 'Clubs'複製代碼</pre><p>Functions(函數)</p><p>您可以為每個參數添加類型，然後添加到函數本身以添加返回類型。</p><pre>function add(x: number, y: number): number { return x + y}複製代碼</pre><p>函數重載</p><p>TypeScript 允許您聲明函數重載。基本上，您可以使用相同名稱但不同參數類型和返回類型的多個函數。請考慮以下示例：</p><pre>function padding(a: number, b?: number, c?: number, d?: any) { if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) { b = c = d = a } else if (c === undefined &amp;&amp; d === undefined) { c = a d = b } return { top: a, right: b, bottom: c, left: d }}複製代碼</pre><p>每個參數的含義根據傳遞給函數的參數數量而變化。而且，該函數只需要一個，兩個或四個參數。要創建函數重載，只需多次聲明函數頭。最後一個函數頭是一個實際上是活躍中的函數體，但不是提供給外面的世界。</p><pre>function padding(all: number)function padding(topAndBottom: number, leftAndRight: number)function padding(top: number, right: number, bottom: number, left: number)function padding(a: number, b?: number, c?: number, d?: number) { if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) { b = c = d = a } else if (c === undefined &amp;&amp; d === undefined) { c = a d = b } return { top: a, right: b, bottom: c, left: d }}padding(1) // Okaypadding(1, 1) // Okaypadding(1, 1, 1, 1) // Okaypadding(1, 1, 1) /* Error! No overload expects 3 arguments, butoverloads do exist that expect either 2 or 4 arguments. */複製代碼</pre><p>Classes</p><p>您可以向屬性和方法的參數添加類型</p><pre>class Greeter { greeting: string constructor(message: string) { this.greeting = message } greet(name: string) { return `Hi ${name}, ${this.greeting}` }}複製代碼</pre><p>訪問修飾符</p><p>TypeScript 可以使用三種訪問修飾符（Access Modifiers），分別是 public、private 和 protected。 public 修飾的屬性或方法是公有的，可以在任何地方被訪問到，默認所有的屬性和方法都是 public 的 private 修飾的屬性或方法是私有的，不能在聲明它的類的外部訪問 protected 修飾的屬性或方法是受保護的，它和 private 類似，區別是它在子類中也是允許被訪問的</p><p>Accessible onpublicprotectedprivateclassyesyesyesclass childrenyesyesnoclass instanceyesnono</p><p>只讀修飾符</p><p>A readonly property must be initialised at their declaration or in the constructor.</p><pre>class Spider { readonly name: string readonly numberOfLegs: number = 8 constructor(theName: string) { this.name = theName }}複製代碼</pre><p>參數屬性</p><p>參數屬性允許您在一個位置創建和初始化成員。它們通過在構造函數參數前加上修飾符來聲明。</p><pre>class Spider { readonly numberOfLegs: number = 8 constructor(readonly name: string) {}}複製代碼</pre><p>抽象</p><p>abstract 關鍵字既可用於類，也可用於抽象類方法。</p><ul><li>抽象類不能直接實例化。它們主要用於繼承，其中擴展抽象類的類必須定義所有抽象方法。</li><li>抽象成員不包含實現，因此無法直接訪問。這些成員必須在子類中實現（有點像接口）</li></ul><p>鍵入斷言</p><p>TypeScript 允許您以任何方式覆蓋其推斷類型。當您比變換器本身更好地理解變量類型時，可以使用此方法。</p><pre>const friend = {}friend.name = 'John' // Error! Property 'name' does not exist on type '{}'interface Person { name: string age: number}const person = {} as Personperson.name = 'John' // Okay複製代碼</pre><p>最初類型斷言的語法是&lt;type></p><pre>let person = &lt;Person&gt;{}複製代碼</pre><p>但是這在 JSX 中使用時產生了歧義。因此建議改為使用 as。</p><p>類型斷言通常在從 JavaScript 遷移代碼時使用，您可能知道變量的類型比當前分配的更準確。但斷言可被視為有害。</p><p>我們來看看上一個示例中的 Person 接口。你注意到了什麼問題嗎？如果您注意到失蹤的房產年齡，恭喜！編譯器可能會幫助您為 Person 的屬性提供自動完成功能，但如果您錯過任何屬性，它將不會抱怨。</p><p>類型推斷</p><p>當沒有類型註釋形式的可用顯式信息時，TypeScript 會推斷變量類型。</p><pre>/** * 變量定義 */let a = 'some string'let b = 1a = b /** Error! Type 'number' is not assignable to type 'string'. **///如果是複雜對象，TypeScript會查找最常見的類型//推斷對象的類型。const arr = [0, 1, false, true] // (number | boolean)[]/** * 函數返回類型 */function sum(x: number, y: number) { return x + y // 推斷返回一個數字}複製代碼</pre><h1>類型兼容性</h1><p>類型兼容性基於結構類型，結構類型僅基於其成員關聯類型。 結構類型的基本規則 x 是與 yif y 至少具有相同成員的兼容 x。</p><pre>interface Person { name: string}let x: Person // Okay, 儘管不是Person接口的實現let y = { name: 'John', age: 20 } // type { name: string; age: number }x = y//請注意x仍然是Person類型。//在以下示例中，編譯器將顯示錯誤消息，因為它不會//期望在Person中的屬性年齡，但結果將和預期的一樣console.log(x.age) // 20複製代碼</pre><p>與 y 成員一樣 name: string，它匹配 Person 接口的必需屬性，這意味著它 x 是一個子類型 y。因此，允許分配。</p><p>Functions</p><p>參數的個數</p><p>在函數調用中，您需要傳入至少足夠的參數，這意味著額外的參數不會導致任何錯誤。</p><pre>function consoleName(person: Person) { console.log(person.name)}consoleName({ name: 'John' }) // OkayconsoleName({ name: 'John', age: 20 }) //也可以是額外的參數複製代碼</pre><p>返回類型</p><p>返回類型必須至少包含足夠的數據。</p><pre>let x = () =&gt; ({ name: 'John' })let y = () =&gt; ({ name: 'John', age: 20 })x = y // OKy = x /* Error! Property 'age' is missing in type '{ name: string; }'but required in type '{ name: string; age: number; }' */複製代碼</pre><p>類型守衛</p><p>類型守衛允許您縮小條件塊中對象的類型。</p><p>類型</p><p>在條件塊中使用 typeof，編譯器將知道變量的類型是不同的。在下面的示例中，TypeScript 瞭解在條件塊之外，x 可能是布爾值，並且 toFixed 無法在其上調用該函數。</p><pre>function example(x: number | boolean) { if (typeof x === 'number') { return x.toFixed(2) } return x.toFixed(2) // Error! Property 'toFixed' does not exist on type 'boolean'.}複製代碼</pre><p>instanceof</p><pre>class MyResponse { header = 'header example' result = 'result example' // ...}class MyError { header = 'header example' message = 'message example' // ...}function example(x: MyResponse | MyError) { if (x instanceof MyResponse) { console.log(x.message) // Error! Property 'message' does not exist on type 'MyResponse'. console.log(x.result) // Okay } else { // TypeScript knows this must be MyError console.log(x.message) // Okay console.log(x.result) // Error! Property 'result' does not exist on type 'MyError'. }}複製代碼</pre><p>in</p><p>該 in 操作員檢查的對象上的屬性的存在。</p><pre>interface Person { name: string age: number}const person: Person = { name: 'John', age: 28}const checkForName = 'name' in person // true複製代碼</pre><p>文字類型</p><p>文字是精確值，是 JavaScript 原語。它們可以組合在一個類型聯合中以創建有用的抽象。</p><pre>type Orientation = 'landscape' | 'portrait'function changeOrientation(x: Orientation) { // ...}changeOrientation('portrait') // OkaychangeOrientation('vertical') /* Error! Argument of type '"vertical"' is not assignable to parameter of type 'Orientation'. */複製代碼</pre><p>條件類型</p><p>條件類型描述類型關係測試，並根據該測試的結果選擇兩種可能類型中的一種。</p><pre>type X = A extends B ? C : D複製代碼</pre><p>這意味著如果 type A 可以賦值給 type B，那麼 X 它的類型是 C。否則 X 與類型相同 D;</p><p>通用類型</p><p>通用類型是必須包含或引用其他類型才能完成的類型。它強制執行各種變量之間的有意義約束。 在以下示例中，函數返回您傳入的任何類型的數組。</p><pre>function reverse&lt;T&gt;(items: T[]): T[] { return items.reverse()}reverse([1, 2, 3]) // number[]reverse([0, true]) // (number | boolean)[]複製代碼</pre><p>keyof</p><p>該 keyof 運營商查詢組給定類型的鑰匙。</p><pre>interface Person { name: string age: number}type PersonKeys = keyof Person // 'name' | 'age'複製代碼</pre><p>映射類型</p><p>映射類型允許您通過映射屬性類型從現有類型創建新類型。根據您指定的規則轉換現有類型的每個屬性。</p><p>Partial</p><pre>type Partial&lt;T&gt; = { [P in keyof T]?: T[P] }複製代碼</pre><ul><li>通用部分類型使用單個類型參數定義 T。</li><li>keyof T 表示 T 字符串文字類型的所有屬性名稱的並集。</li><li>[P in keyof T]?: T[P]表示類型的每個屬性 P 的類型 T 應該是可選的並轉換為 T[P]。</li><li>T[P]表示類型屬性 P 的類型 T。</li></ul><p>Readonly</p><p>正如我們在 Interface 部分中所介紹的，TypeScript 允許您創建只讀屬性。有一種 Readonly 類型，它接受一個類型 T 並將其所有屬性設置為只讀。</p><pre>type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P] }複製代碼</pre><p>Exclude</p><p>Exclude 允許您從其他類型中刪除某些類型。Exclude 來自 T 任何可分配的東西 T。</p><pre>/** * type Exclude&lt;T, U&gt; = T extends U ? never : T; */type User = { _id: number name: string email: string created: number}type UserNoMeta = Exclude&lt;keyof User, '_id' | 'created'&gt;複製代碼</pre><p>Pick</p><p>Pick 允許您從其他類型中選擇某些類型。Pick 來自 T 任何可分配的東西 T。</p><pre>/** * type Pick&lt;T, K extends keyof T&gt; = { * [P in K]: T[P]; * }; */type UserNoMeta = Pick&lt;User, 'name' | 'email'&gt;複製代碼</pre><p>infer</p><p>您可以使用 infer 關鍵字在 extends 條件類型的子句中推斷類型變量。此類推斷類型變量只能用於條件類型的 true 分支。</p><p>返回類型</p><p>獲取函數的返回類型。</p><pre>/** * 原始TypeScript的ReturnType * type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any; */type MyReturnType&lt;T&gt; = T extends (...args: any) =&gt; infer R ? R : anytype TypeFromInfer = MyReturnType&lt;() =&gt; number&gt; // numbertype TypeFromFallback = MyReturnType&lt;string&gt; // any複製代碼</pre><p>分析一下 MyReturnType：</p><ul><li>返回類型 T 是......</li><li>首先，是 T 一個功能？</li><li>如果是，則類型解析為推斷的返回類型 R。</li><li>否則類型解析為 any。</li></ul><p class=ql-align-justify>【前端迷】公眾號是一個公益性的前端技術分享社區，不定期為前端開發者帶來面試經歷，源碼解析以及技術分享，歡迎大家訂閱。</p><blockquote><p>歡迎關注公眾號，回覆【教程】獲取最新教學資源視頻，回覆【pdf】獲取前端開發熱門書籍pdf。</p></blockquote><p class=ql-align-center><br></p><div class=pgc-img><img alt="TypeScript 手冊完結版" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4d389e1d77a54cff8a8117a59bf29159><p class=pgc-img-caption>微信掃碼關注</p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>TypeScript</a></li><li><a>手冊</a></li><li><a>完結版</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/03026830.html alt=HDMI延長器使用手冊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153922814035246677f40ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03026830.html title=HDMI延長器使用手冊>HDMI延長器使用手冊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7344eaf.html alt=內含質量手冊、程序文件（流程圖）、所有記錄及一整套APQP表格 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/152524184243211df7cbe71 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7344eaf.html title=內含質量手冊、程序文件（流程圖）、所有記錄及一整套APQP表格>內含質量手冊、程序文件（流程圖）、所有記錄及一整套APQP表格</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/98fd0591.html alt=全套ISO9001及ISO14001管理手冊和程序文件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2bb5d6a7ef844f0bb3bb6ef8043635f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/98fd0591.html title=全套ISO9001及ISO14001管理手冊和程序文件>全套ISO9001及ISO14001管理手冊和程序文件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7dcdceb4.html alt=PHP學習手冊，高清版 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/6411183a779d4cecb2188e52a7f746f6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7dcdceb4.html title=PHP學習手冊，高清版>PHP學習手冊，高清版</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a75107a.html alt=機械設計手冊常用計算參數表（非常全），掌握後大幅提高設計效率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bcdb7f18804b4580a12b477cc4e34fb3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a75107a.html title=機械設計手冊常用計算參數表（非常全），掌握後大幅提高設計效率>機械設計手冊常用計算參數表（非常全），掌握後大幅提高設計效率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ff2a94cd.html alt=家裝指導手冊—施工工藝篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5df375b94f964ffdb89b186d7110cb1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ff2a94cd.html title=家裝指導手冊—施工工藝篇>家裝指導手冊—施工工藝篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6642d4fc.html alt=工作必備｜堤防防汛搶險手冊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/225564b65dfb40c9a94cfed0a36d0aff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6642d4fc.html title=工作必備｜堤防防汛搶險手冊>工作必備｜堤防防汛搶險手冊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96649f6e.html alt=彙編指令速查手冊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522133498532de21050d3f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96649f6e.html title=彙編指令速查手冊>彙編指令速查手冊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b70c367.html alt="代碼規範—使用 TypeScript 裝飾器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/4b5097e2-c4fd-4d37-9c54-707760739775 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b70c367.html title="代碼規範—使用 TypeScript 裝飾器">代碼規範—使用 TypeScript 裝飾器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/405fc9c3.html alt=電工入門手冊！電纜截面估算方法一二 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/e8d2b2a1-f14d-48cf-a2f6-cba9d47d35f7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/405fc9c3.html title=電工入門手冊！電纜截面估算方法一二>電工入門手冊！電纜截面估算方法一二</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ec0862e1.html alt="軸及其連接（附PDF手冊） 從軸到聯軸器都進行詳細說明" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3033b05c2b1b46b5aa14eb3927096b7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ec0862e1.html title="軸及其連接（附PDF手冊） 從軸到聯軸器都進行詳細說明">軸及其連接（附PDF手冊） 從軸到聯軸器都進行詳細說明</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a179d9a3.html alt=離心泵應用手冊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/748aba9c4da44a438c4c170467fe57dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a179d9a3.html title=離心泵應用手冊>離心泵應用手冊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb6cf478.html alt=TypeScript+vue使用與遷移經驗總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6c507edbae104f89b6a89cce2e9abee3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb6cf478.html title=TypeScript+vue使用與遷移經驗總結>TypeScript+vue使用與遷移經驗總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75184db2.html alt=IDEA快捷鍵手冊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75184db2.html title=IDEA快捷鍵手冊>IDEA快捷鍵手冊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7c17026c.html alt=史上最全電氣電纜常用手冊（收藏版） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152836633411998bf04c647 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7c17026c.html title=史上最全電氣電纜常用手冊（收藏版）>史上最全電氣電纜常用手冊（收藏版）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>