<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux信號透徹分析理解與各種實例講解 | 极客快訊</title><meta property="og:title" content="Linux信號透徹分析理解與各種實例講解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/af1d4b0837d64d06b9e0edefe83df2a8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78e5793.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78e5793.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78e5793.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78e5793.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78e5793.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78e5793.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78e5793.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78e5793.html><meta property="article:published_time" content="2020-10-29T20:52:05+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:05+08:00"><meta name=Keywords content><meta name=description content="Linux信號透徹分析理解與各種實例講解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/78e5793.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux信號透徹分析理解與各種實例講解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">本文將從以下幾個方面來闡述信號:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)信號</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">的</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">基本知識</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)信號生命週期與處理過程分析</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(3) 基本的信號處理函數</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(4) 保護臨界區不被中斷</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(5) 信號的繼承與執行</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(6)實時信號中鎖的研究</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="color:red;--tt-darkmode-color: #FF2000"><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第一部分</span></span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">: 信號的基本知識</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">1.信號本質:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號的本質是軟件層次上對中斷的一種模擬。它是一種異步通信的處理機制，事實上，進程並不知道信號何時到來。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">2.信號來源</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)程序錯誤，如非法訪問內存</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)外部信號，如按下了CTRL+C</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(3)通過kill或sigqueue向另外一個進程發送信號</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">3.信號種類</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號分為可靠信號與不可靠信號,可靠信號又稱為實時信號，非可靠信號又稱為非實時信號。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號代碼從1到32是不可靠信號,不可靠信號主要有以下問題:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)每次信號處理完之後，就會恢復成默認處理，這可能是調用者不希望看到的</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)存在信號丟失的問題</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">現在的Linux對信號機制進行了改進，因此，不可靠信號主要是指信號丟失。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號代碼從SIGRTMIN到SIGRTMAX之間的信號是可靠信號。可靠信號不存在丟失，由sigqueue發送，可靠信號支持排隊。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">可靠信號註冊機制:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">內核每收到一個可靠信號都會去註冊這個信號，在信號的未決信號鏈中分配sigqueue結構，因此，不會存在信號丟失的問題。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">不可靠信號的註冊機制:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">而對於不可靠的信號，如果內核已經註冊了這個信號，那麼便不會再去註冊，對於進程來說，便不會知道本次信號的發生。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">可靠信號與不可靠信號與發送函數沒有關係，取決於信號代碼，前面的32種信號就是不可靠信號，而後面的32種信號就是可靠信號。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">4.信號響應的方式</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)採用系統默認處理SIG_DFL,執行缺省操作</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)捕捉信號處理，即用戶自定義的信號處理函數來處理</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(3)忽略信號SIG_IGN ,但有兩種信號不能被忽略SIGKILL，SIGSTOP</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span><span style="color:red;--tt-darkmode-color: #FF2000"><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第二部分</span></span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">: 信號的生命週期與處理過程分析</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">1. 信號的生命週期</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號產生->信號註冊－>信號在進程中註銷->信號處理函數執行完畢</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)信號的產生是指觸發信號的事件的發生</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)信號註冊</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">指的是在目標進程中註冊，該目標進程中有未決信號的信息:</span></p><pre><code>struct sigpending pending：struct sigpending{struct sigqueue *head, **tail;sigset_t signal;};struct sigqueue{struct sigqueue *next;siginfo_t info;}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">其中 sigqueue結構組成的鏈稱之為未決信號鏈，sigset_t稱之為未決信號集。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">*head,**tail分別指向未決信號鏈的頭部與尾部。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">siginfo_t info是信號所攜帶的信息。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號註冊的過程就是將信號值加入到未決信號集siginfo_t中，將信號所攜帶的信息加入到未決信號鏈的某一個sigqueue中去。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">因此，對於可靠的信號，可能存在多個未決信號的sigqueue結構，對於每次信號到來都會註冊。而不可靠信號只註冊一次，只有一個sigqueue結構。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">只要信號在進程的未決信號集中，表明進程已經知道這些信號了，還沒來得及處理，或者是這些信號被阻塞。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(3)信號在目標進程中註銷</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">在進程的執行過程中，每次從系統調用或中斷返回用戶空間的時候，都會檢查是否有信號沒有被處理。如果這些信號沒有被阻塞，那麼就調用相應的信號處理函數來處理這些信號。則調用信號處理函數之前，進程會把信號在未決信號鏈中的sigqueue結構卸掉。是否從未決信號集中把信號刪除掉，對於實時信號與非實時信號是不相同的。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">非實時信號:由於非實時信號在未決信號鏈中只有一個sigqueue結構，因此將它刪除的同時將信號從未決信號集中刪除。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">實時信號:由於實時信號在未決信號鏈中可能有多個sigqueue結構，如果只有一個，也將信號從未決信號集中刪除掉。如果有多個那麼不從未決信號集中刪除信號，註銷完畢。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(4)信號處理函數執行完畢</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">執行處理函數，本次信號在進程中響應完畢。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">在第4步，只簡單的描述了信號處理函數執行完畢，就完成了本次信號的響應，但這個信號處理函數空間是怎麼處理的呢? 內核棧與用戶棧是怎麼工作的呢? 這就涉及到了信號處理函數的過程。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號處理函數的過程:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)註冊信號處理函數</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號的處理是由內核來代理的，首先程序通過sigal或sigaction函數為每個信號註冊處理函數，而內核中維護一張信號向量表，對應信號處理機制。這樣，</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">在</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號在進程中註銷完畢之後，會調用相應的處理函數進行處理。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)信號的檢測與響應時機</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">在系統調用或中斷返回用戶態的前夕，內核會檢查未決信號集，進行相應的信號處理。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(3)處理過程:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">程序運行在用戶態時->進程由於系統調用或中斷進入內核->轉向用戶態執行信號處理函數->信號處理函數完畢後進入內核->返回用戶態繼續執行程序</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">首先程序執行在用戶態，在進程陷入內核並從內核返回的前夕，會去檢查有沒有信號沒有被處理，如果有且沒有被阻塞就會調用相應的信號處理程序去處理。首先，內核在用戶棧上創建一個層，該層中將返回地址設置成信號處理函數的地址，這樣，從內核返回用戶態時，就會執行這個信號處理函數。當信號處理函數執行完，會再次進入內核，主要是檢測有沒有信號沒有處理，以及恢復原先程序中斷執行點，恢復內核棧等工作，這樣，當從內核返回後便返回到原先程序執行的地方了。</span></p><p><span style="color:red;--tt-darkmode-color: #FF2000"><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號處理函數的過程大概是這樣了。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span><strong>需要C/C++ Linux高級服務器架構師學習資料後臺私信“資料”（包括C/C++，Linux，golang技術，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒體，CDN，P2P，K8S，Docker，TCP/IP，協程，DPDK，ffmpeg等）</strong></p><div class=pgc-img><img alt=Linux信號透徹分析理解與各種實例講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af1d4b0837d64d06b9e0edefe83df2a8><p class=pgc-img-caption></p></div><p><span style="color:red;--tt-darkmode-color: #FF2000"><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第三部分</span></span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">: 基本的信號處理函數</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">首先看一個兩個概念: 信號未決與信號阻塞</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號未決: 指的是信號的產生到信號處理之前所處的一種狀態。確切的說，是信號的產生到信號註銷之間的狀態。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號阻塞: 指的是阻塞信號被處理，是一種信號處理方式。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">1. 信號操作</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號操作最常用的方法是信號的屏蔽，信號屏蔽主要用到以下幾個函數:</span></p><pre><code>int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set,int signo);int sigdelset(sigset_t *set,int signo);int sigismemeber(sigset_t* set,int signo);int sigprocmask(int how,const sigset_t*set,sigset_t *oset);</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號集，信號掩碼，未決集</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號集: 所有的信號阻塞函數都使用一個稱之為信號集的結構表明其所受到的影響。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">信號掩碼:當前正在被阻塞的信號集。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">未決集: 進程在收到信號時到信號在未被處理之前信號所處的集合稱為未決集。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">可以看出，這三個概念沒有必然的聯繫，信號集指的是一個泛泛的概念，而未決集與信號掩碼指的是具體的信號狀態。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">對於信號集的初始化有兩種方法: 一種是用sigemptyset使信號集中不包含任何信號，然後用sigaddset把信號加入到信號集中去。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">另一種是用sigfillset讓信號集中包含所有信號，然後用sigdelset刪除信號來初始化。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigemptyset()函數初始化信號集set並將set設置為空。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigfillset()函數初始化信號集，但將信號集set設置為所有信號的集合。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigaddset()將信號signo加入到信號集中去。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigdelset()從信號集中刪除signo信號。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigprocmask()將指定的信號集合加入到進程的信號阻塞集合中去。如果提供了oset,那麼當前的信號阻塞集合將會保存到oset</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">集全</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">中去。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">參數how決定了操作的方式:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIG_BLOCK 增加一個信號集合到當前進程的阻塞集合中去</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIG_UNBLOCK 從當前的阻塞集合中刪除一個信號集合</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIG_SETMASK 將當前的信號集合設置為信號阻塞集合</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">下面看一個例子:</span></p><pre><code>#includeint sigaction(int signo,const struct sigaction *act,struct sigaction *oldact);</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">執行結果:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIGINT singal blocked<br>block 0<br>block 1<br>block 2<br>block 3<br>block 4<br>block 5<br>block 6<br>block 7<br>block 8<br>block 9<br>在執行到block 3時按下了CTRL+C並不會終止，直到執行到block9後將集合從阻塞集合中移除。<br>[root@localhost C]# ./s1<br>SIGINT singal blocked<br>block 0<br>block 1<br>block 2<br>block 3<br>block 4<br>block 5<br>block 6<br>block 7<br>block 8<br>block 9<br>SIGINT SINGAL unblokced<br>unblock 0<br>unblock 1<br>由於此時已經解除了阻塞，在unblock1後按下CTRL+C則立即終止。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">2. 信號處理函數</span></p><pre><code>struct sigaction {void (*sa_handler)(int);void (*sa_sigaction)(int,siginfo_t*,void*);sigset_t sa_mask;int sa_flags;void (*sa_restorer)(void);} </code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">這個函數主要是用於改變或檢測信號的行為。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第一個參數是變更signo指定的信號，它可以指向任何值，SIGKILL,SIGSTOP除外</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第二個參數,第三個參數是對信號進行細粒度的控制。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">如果*act不為空，*oldact不為空，那麼oldact將會存儲信號以前的行為。如果act為空，*oldact不為空，那麼oldact將會存儲信號現在的行為。</span></p><pre><code>struct sigaction {void (*sa_handler)(int);void (*sa_sigaction)(int,siginfo_t*,void*);sigset_t sa_mask;int sa_flags;void (*sa_restorer)(void);} </code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">參數含義:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sa_handler是一個函數指針，主要是表示接收到信號時所要採取的行動。此字段的值可以是SIG_DFL,SIG_IGN.分別代表默認操作與內核將忽略進程的信號。這個函數只傳遞一個參數那就是信號代碼。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">當SA_SIGINFO被設定在sa_flags中，那麼則會使用sa_sigaction來指示信號處理函數，而非sa_handler.</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sa_mask設置了掩碼集，在程序執行期間會阻擋掩碼集中的信號。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sa_flags設置了一些標誌， SA_RESETHAND當該函數處理完成之後，設定為為系統默認的處理模式。SA_NODEFER 在處理函數中，如果再次到達此信號時，將不會阻塞。默認情況下，同一信號兩次到達時，如果此時處於信號處理程序中，那麼此信號將會阻塞。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SA_SIGINFO表示用sa_sigaction指示的函數。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sa_restorer已經被廢棄。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sa_sigaction所指向的函數原型:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">void my_handler(int signo,siginfo_t *si,void *ucontext);</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第一個參數: 信號編號</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第二個參數:指向一個siginfo_t結構。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第三個參數是一個ucontext_t結構。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">其中siginfo_t結構體中包含了大量的信號攜帶信息，可以看出，這個函數比sa_handler要強大，因為前者只能傳遞一個信號代碼，而後者可以傳遞siginfo_t信息。</span></p><pre><code>typedef struct siginfo_t{int si_signo;//信號編號int si_errno;//如果為非零值則錯誤代碼與之關聯int si_code;//說明進程如何接收信號以及從何處收到pid_t si_pid;//適用於SIGCHLD，代表被終止進程的PIDpid_t si_uid;//適用於SIGCHLD,代表被終止進程所擁有進程的UIDint si_status;//適用於SIGCHLD，代表被終止進程的狀態clock_t si_utime;//適用於SIGCHLD，代表被終止進程所消耗的用戶時間clock_t si_stime;//適用於SIGCHLD，代表被終止進程所消耗系統的時間sigval_t si_value;int si_int;void * si_ptr;void* si_addr;int si_band;int si_fd;};</code></pre><pre><code> sigqueue(pid_t pid,int signo,const union sigval value)union sigval{int sival_int, void*sival_ptr};</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigqueue函數類似於kill,也是一個進程向另外一個進程發送信號的。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">但它比kill函數強大。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第一個參數指定目標進程的pid.</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第二個參數是一個信號代碼。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第三個參數是一個共用體，每次只能使用一個，用來進程發送信號傳遞的數據。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">或者傳遞整形數據，或者是傳遞指針。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">發送的數據被sa_sigaction所指示的函數的siginfo_t結構體中的si_ptr或者是si_int所接收。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigpending的用法</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigpending(sigset_t set);</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">這個函數的作用是返回未決的信號到信號集set中。即未決信號集，未決信號集不僅包括被阻塞的信號，也可能包括已經到達但沒有被處理的信號。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例1: sigaction函數的用法</span></p><pre><code>struct sigaction {void (*sa_handler)(int);void (*sa_sigaction)(int,siginfo_t*,void*);sigset_t sa_mask;int sa_flags;void (*sa_restorer)(void);} </code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">運行結果:<br>[root@localhost C]# ./s2<br>signal 1 handler is : using default hander<br>signal 2 handler is : 8048437<br>signal 3 handler is : using default hander<br>signal 4 handler is : using default hander<br>signal 5 handler is : using default hander<br>signal 6 handler is : using default hander<br>signal 7 handler is : using default hander<br>signal 8 handler is : using default hander<br>signal 9 handler is : using default hander<br>signal 10 handler is : using default hander<br>signal 11 handler is : using default hander<br>xxxxx<br>解釋:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigaction(i,NULL,&oldact);</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">signal_set(&oldact);</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">由於act為NULL,那麼oldact保存的是當前信號的行為，當前的第二個信號的行為是執行自定義的處理程序。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">當按下CTRL＋C時會執行信號處理程序，輸出xxxxxx，再按一下CTRL＋C會停止,是由於SA_RESETHAND恢復成默認的處理模式，即終止程序。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">如果沒有設置SA_NODEFER,那麼在處理函數執行過程中按一下CTRL＋C將會被阻塞，那麼程序會停在那裡。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例2: sigqueue向本進程發送數據的信號</span></p><pre><code>#include#include#include#include#includevoid myhandler(int signo,siginfo_t *si,void *ucontext);int main(){union sigval val;//定義一個攜帶數據的共用體struct sigaction oldact,act;act.sa_sigaction=myhandler;act.sa_flags=SA_SIGINFO;//表示使用sa_sigaction指示的函數，處理完恢復默認，不阻塞處理過程中到達下在被處理的信號//註冊信號處理函數sigaction(SIGUSR1,&amp;act,&amp;oldact);char data[100];int num=0;while(num&lt;10){sleep(2);printf("等待SIGUSR1信號的到來/n");sprintf(data,"%d",num++);val.sival_ptr=data;sigqueue(getpid(),SIGUSR1,val);//向本進程發送一個信號}}void myhandler(int signo,siginfo_t *si,void *ucontext){printf("已經收到SIGUSR1信號/n");printf("%s/n",(char*)(si-&gt;si_ptr));}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">程序執行的結果是:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>0<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>1<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>2<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>3<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>4<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>5<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>6<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>7<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>8<br>等待SIGUSR1信號的到來<br>已經收到SIGUSR1信號<br>9</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">解釋: 本程序用sigqueue不停的向自身發送信號,並且攜帶數據，數據被放到處理函數的第二個參數siginfo_t結構體中的si_ptr指針，當num&lt;10時不再發。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">一般而言，sigqueue與sigaction配合使用，而kill與signal配合使用。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例3: 一個進程向另外一個進程發送信號，並攜帶信息</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">發送端:</span></p><pre><code>#include#include#include#include#includeint main(){union sigval value;value.sival_int=10;if(sigqueue(4403,SIGUSR1,value)==-1){//4403是目標進程pidperror("信號發送失敗/n");}sleep(2);}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">接收端:</span></p><pre><code>#include#include#include#include#includevoid myhandler(int signo,siginfo_t*si,void *ucontext);int main(){struct sigaction oldact,act;act.sa_sigaction=myhandler;act.sa_flags=SA_SIGINFO|SA_NODEFER;//表示執行後恢復，用sa_sigaction指示的處理函數，在執行期間仍然可以接收信號sigaction(SIGUSR1,&amp;act,&amp;oldact);while(1){sleep(2);printf("等待信號的到來/n");}}void myhandler(int signo,siginfo_t *si,void *ucontext){ printf("the value is %d/n",si-&gt;si_int);}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例4: sigpending的用法</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigpending(sigset_t *set)將未決信號放到指定的set信號集中去，未決信號包括被阻塞的信號和信號到達時但還沒來得及處理的信號</span></p><pre><code>#include#include#include#include#includevoid myhandler(int signo,siginfo_t *si,void *ucontext);int main(){struct sigaction oldact,act;sigset_t oldmask,newmask,pendingmask;act.sa_sigaction=myhandler;act.sa_flags=SA_SIGINFO;sigemptyset(&amp;act.sa_mask);//首先將阻塞集合設置為空，即不阻塞任何信號//註冊信號處理函數sigaction(SIGRTMIN+10,&amp;act,&amp;oldact);//開始阻塞sigemptyset(&amp;newmask);sigaddset(&amp;newmask,SIGRTMIN+10);printf("SIGRTMIN+10 blocked/n");sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);sleep(20);//為了發出信號printf("now begin to get pending mask/n");if(sigpending(&amp;pendingmask)&lt;0){perror("pendingmask error");}if(sigismember(&amp;pendingmask,SIGRTMIN+10)){printf("SIGRTMIN+10 is in the pending mask/n");}sigprocmask(SIG_UNBLOCK,&amp;newmask,&amp;oldmask);printf("SIGRTMIN+10 unblocked/n");}//信號處理函數void myhandler(int signo,siginfo_t *si,void *ucontext){printf("receive signal %d/n",si-&gt;si_signo);} </code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">程序執行:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">在另一個shell發送信號:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">kill -44 4579</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIGRTMIN+10 blocked<br>now begin to get pending mask<br>SIGRTMIN+10 is in the pending mask<br>receive signal 44<br>SIGRTMIN+10 unblocked</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">可以看到SIGRTMIN由於被阻塞所以處於未決信號集中。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">關於基本的信號處理函數就介紹到這了。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="color:red;--tt-darkmode-color: #FF2000"><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第四部分</span></span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">: 保護臨界區不被中斷</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">1. 函數的可</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">重入性</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">函數的可</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">重入性</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">是指可以多於一個任務併發使用函數，而不必擔心數據錯誤。相反，不可重入性是指不能多於一個任務共享函數，除非能保持函數互斥(或者使用信號量，或者在代碼的關鍵部分禁用中斷)。可重入函數可以在任意時刻被中斷，稍後繼續執行，而不會丟失數據。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">可重入函數：<br>* 不為連續的調用持有靜態數據。<br>* 不返回指向靜態數據的指針；所有數據都由函數的調用者提供。<br>* 使用本地數據，或者通過製作全局數據的本地拷貝來保護全局數據。<br>* 絕不調用任何不可</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">重入</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">函數。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">不可重入函數可能導致混亂現象，如果當前進程的操作與信號處理程序同時對一個文件進行寫操作或者是調用malloc()，那麼就可能出現混亂，當從信號處理程序返回時，造成了狀態不一致。從而引發錯誤。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">因此，信號的處理必須是可重入函數。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">簡單的說，可重入函數是指在一個程序中調用了此函數，在信號處理程序中又調用了此函數，但仍然能夠得到正確的結果。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">printf，malloc函數都是不可重入函數。printf函數如果打印緩衝區一半時，又有一個printf函數，那麼此時會造成混亂。而malloc函數使用了系統全局內存分配表。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">2. 保護臨界區不被中斷</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">由於臨界區的代碼是關鍵代碼，是非常重要的部分，因此，有必要對臨界區進行保護，不希望信號來中斷臨界區操作。這裡通過信號屏蔽字來阻塞信號的發生。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">下面介紹兩個與保護臨界區不被信號中斷的相關函數。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">int pause(void);</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">int sigsuspend(const sigset_t *sigmask);</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">pause函數掛起一個進程，直到一個信號發生。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigsuspend函數的執行過程如下:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)設置新的mask去阻塞當前進程</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)收到信號，調用信號的處理函數</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(3)將mask設置為原先的掩碼</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(4)sigsuspend函數返回</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">可以看出，sigsuspend函數是等待一個信號發生，當等待的信號發生時，執行完信號處理函數後就會返回。它是一個原子操作。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">保護臨界區的中斷:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(1)首先用sigprocmask去阻塞信號</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(2)執行後關鍵代碼後,用sigsuspend去捕獲信號</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">(3)然後sigprocmask去除阻塞</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">這樣信號就不會丟失了，而且不會中斷臨界區。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">使用pause函數對臨界區的保護:</span></p><div class=pgc-img><img alt=Linux信號透徹分析理解與各種實例講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52690db7b68242a0a79d30cbfaf982ff><p class=pgc-img-caption></p></div><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">上面的程序是用pause去保護臨界區，首先用sigprocmask去阻塞SIGINT信號，執行臨界區代碼，然後解除阻塞。最後調用pause()函數等待信號的發生。但此時會產生一個問題，如果信號在解除阻塞與pause之間發生的話，信號就可能丟失。這將是一個不可靠的信號機制。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">因此，採用sigsuspend可以避免上述情況發生。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">使用sigsuspend對臨界區的保護:</span></p><div class=pgc-img><img alt=Linux信號透徹分析理解與各種實例講解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/81588ed75a4e4c7b951c63515b0c97bd><p class=pgc-img-caption></p></div><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">使用sigsuspend對臨界區的保護就不會產生上述問題了。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">3. sigsuspend函數的用法</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigsuspend函數是等待的信號發生時才會返回。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sigsuspend函數遇到結束時不會返回，這一點很重要。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">下面的例子能夠處理信號SIGUSR1,SIGUSR2,SIGSEGV,其它的信號被屏蔽，該程序輸出對應的信號，然後繼續等待其它信號的出現。</span></p><pre><code>#include#includevoid signal_set1(int);//信號處理函數，只傳遞一個參數信號代碼void signal_set(struct sigaction *act){switch(act-&gt;sa_flags){case (int)SIG_DFL:printf("using default hander/n");break;case (int)SIG_IGN:printf("ignore the signal/n");break;default:printf("%0x/n",act-&gt;sa_handler);}}void signal_set1(int x){//信號處理函數printf("xxxxx/n");while(1){}}int main(int argc,char** argv){int i;struct sigaction act,oldact;act.sa_handler = signal_set1;act.sa_flags = SA_RESETHAND;//SA_RESETHANDD 在處理完信號之後，將信號恢復成默認處理//SA_NODEFER在信號處理程序執行期間仍然可以接收信號sigaction (SIGINT,&amp;act,&amp;oldact) ;//改變信號的處理模式for (i=1; i&lt;12; i++){printf("signal %d handler is : ",i);sigaction (i,NULL,&amp;oldact) ;signal_set(&amp;oldact);//如果act為NULL，oldact會存儲信號當前的行為//act不為空，oldact不為空，則oldact會存儲信號以前的處理模式}while(1){//等待信號的到來}return 0;}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">程序運行結果:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">received sigusr1 signal</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">received sigusr2 signal</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">received sigsegv signal</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">received sigusr1 signal</span></p><p><br></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">已終止</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">另一個終端用於發送信號:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">先得到當前進程的pid, ps aux|grep 程序名</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">kill -SIGUSR1 4901</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">kill -SIGUSR2 4901</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">kill -SIGSEGV 4901</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">kill -SIGTERM 4901</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">kill -SIGUSR1 4901</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">解釋:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第一行發送SIGUSR1，則調用信號處理函數，打印出結果。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第二，第三行分別打印對應的結果。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第四行發送一個默認處理為終止進程的信號。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">但此時，但不會終止程序，由於sigsuspend遇到終止進程信號並不會返回，此時並不會打印出"已終止"，這個信號被阻塞了。當再次發送SIGURS1信號時，進程的信號阻塞恢復成默認的值，因此，此時將會解除阻塞SIGTERM信號，所以進程被終止。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="color:red;--tt-darkmode-color: #FF2000"><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第五部分</span></span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">: 信號的繼承與執行</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">當使用fork()函數時，子進程會繼承父進程完全相同的信號語義，這也是有道理的，因為父子進程共享一個地址空間，所以父進程的信號處理程序也存在於子進程中。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例: 子進程繼承父進程的信號處理函數</span></p><pre><code>#include#include#include#include#includevoid myhandler(int signo,siginfo_t *si,void *ucontext);int main(){struct sigaction oldact,act;sigset_t oldmask,newmask,pendingmask;act.sa_sigaction=myhandler;act.sa_flags=SA_SIGINFO;sigemptyset(&amp;act.sa_mask);//首先將阻塞集合設置為空，即不阻塞任何信號//註冊信號處理函數sigaction(SIGRTMIN+10,&amp;act,&amp;oldact);//開始阻塞sigemptyset(&amp;newmask);sigaddset(&amp;newmask,SIGRTMIN+10);printf("SIGRTMIN+10 blocked/n");sigprocmask(SIG_BLOCK,&amp;newmask,&amp;oldmask);sleep(20);//為了發出信號printf("now begin to get pending mask/n");if(sigpending(&amp;pendingmask)&lt;0){perror("pendingmask error");}if(sigismember(&amp;pendingmask,SIGRTMIN+10)){printf("SIGRTMIN+10 is in the pending mask/n");}sigprocmask(SIG_UNBLOCK,&amp;newmask,&amp;oldmask);printf("SIGRTMIN+10 unblocked/n");}//信號處理函數void myhandler(int signo,siginfo_t *si,void *ucontext){printf("receive signal %d/n",si-&gt;si_signo);} </code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">輸出的結果為:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">子</span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">進程<br>信號處理<br>10<br>父進程<br>信號處理<br>20</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">可以看出來，子進程繼承了父進程的信號處理函數。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="color:red;--tt-darkmode-color: #FF2000"><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第六部分</span></span><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">: 實時信號中鎖的研究</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">1. 信號處理函數與主函數之間的死鎖</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">當主函數訪問臨界資源時，通常需要加鎖，如果主函數在訪問臨界區時，給臨界資源上鎖，此時發生了一個信號，那麼轉入信號處理函數，如果此時信號處理函數也對臨界資源進行訪問，那麼信號處理函數也會加鎖，由於主程序持有鎖，信號處理程序等待主程序釋放鎖。又因為信號處理函數已經搶佔了主函數，因此，主函數在信號處理函數結束之前不能運行。因此，必然造成死鎖。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例1: 主函數與信號處理函數之間的死鎖</span></p><pre><code>#include#include#include#include#include#includeint value=0;sem_t sem_lock;//定義信號量void myhandler(int signo,siginfo_t *si,void *vcontext);//進程處理函數聲明int main(){union sigval val;val.sival_int=1;struct sigaction oldact,newact;int res;res=sem_init(&amp;sem_lock,0,1);if(res!=0){perror("信號量初始化失敗");}newact.sa_sigaction=myhandler;newact.sa_flags=SA_SIGINFO;sigaction(SIGUSR1,&amp;newact,&amp;oldact);sem_wait(&amp;sem_lock);printf("xxxx/n");value=1;sleep(10);sigqueue(getpid(),SIGUSR1,val);//sigqueue發送帶參數的信號sem_post(&amp;sem_lock);sleep(10);exit(0);}void myhandler(int signo,siginfo_t *si,void *vcontext){sem_wait(&amp;sem_lock);value=0;sem_post(&amp;sem_lock);}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">此程序將一直阻塞在信號處理函數的sem_wait函數處。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">2. 利用測試鎖解決死鎖</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">sem_trywait(&sem_lock);是非阻塞的sem_wait,如果加鎖失敗或者是超時，則返回－1。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例2: 用sem_trywait來解決死鎖</span></p><pre><code>#include#include#include#include#include#includeint value=0;sem_t sem_lock;//定義信號量void myhandler(int signo,siginfo_t *si,void *vcontext);//進程處理函數聲明int main(){union sigval val;val.sival_int=1;struct sigaction oldact,newact;int res;res=sem_init(&amp;sem_lock,0,1);if(res!=0){perror("信號量初始化失敗");}newact.sa_sigaction=myhandler;newact.sa_flags=SA_SIGINFO;sigaction(SIGUSR1,&amp;newact,&amp;oldact);sem_wait(&amp;sem_lock);printf("xxxx/n");value=1;sleep(10);sigqueue(getpid(),SIGUSR1,val);//sigqueue發送帶參數的信號sem_post(&amp;sem_lock);sleep(10);sigqueue(getpid(),SIGUSR1,val);exit(0);}void myhandler(int signo,siginfo_t *si,void *vcontext){if(sem_trywait(&amp;sem_lock)==0){value=0;sem_post(&amp;sem_lock);}}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">第一次發送sigqueue時，由於主函數持有鎖，因此，sem_trywait返回－1，當第二次發送sigqueue時，主函數已經釋放鎖，此時就可以在信號處理函數中對臨界資源加鎖了。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">但這種方法明顯丟失了一個信號，不是很好的解決方法。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">3. 利用雙線程來解決主函數與信號處理函數死鎖</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">我們知道，當進程收到一個信號時，會選擇其中的某個線程進行處理，前提是這個線程沒有屏蔽此信號。因此，可以在主線程中屏蔽信號，另選一個線程去處理這個信號。由於主線程與另外一個線程是平行執行的，因此，等待主線程執行完臨界區時，釋放鎖，這個線程去執行信號處理函數，直到執行完畢釋放臨界資源。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">這裡用到一個線程的信號處理函數: pthread_sigmask</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">int pthread_sigmask(int how,const sigset_t *set,sigset_t *oldset);</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">這個函數與sigprocmask很相似。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">how:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIG_BLOCK 將信號集加入到線程的阻塞集中去</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIG_UNBLOCK 將信號集從阻塞集中刪除</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">SIG_SETMASK 將當前集合設置為線程的阻塞集</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E"></span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">示例: 利用雙線程來解決主函數與信號處理函數之間的死鎖</span></p><pre><code>#include#include#include#include#include#include#includevoid*thread_function(void *arg);//線程處理函數void myhandler(int signo,siginfo_t *si,void *vcontext);//信號處理函數int value;sem_t semlock;int main(){int res;pthread_t mythread;void *thread_result;res=pthread_create(&amp;mythread,NULL,thread_function,NULL);//創建一個子線程if(res!=0){perror("線程創建失敗");}//在主線程中將信號屏蔽sigset_t empty;sigemptyset(∅);sigaddset(∅,SIGUSR1);pthread_sigmask(SIG_BLOCK,∅,NULL);//主線程中對臨界資源的訪問if(sem_init(&amp;semlock,0,1)!=0){perror("信號量創建失敗");}sem_wait(&amp;semlock);printf("主線程已經執行/n");value=1;sleep(10);sem_post(&amp;semlock);res=pthread_join(mythread,&amp;thread_result);//等待子線程退出exit(EXIT_SUCCESS);}void *thread_function(void *arg){struct sigaction oldact,newact;newact.sa_sigaction=myhandler;newact.sa_flags=SA_SIGINFO;//註冊信號處理函數sigaction(SIGUSR1,&amp;newact,&amp;oldact);union sigval val;val.sival_int=1;printf("子線程睡眠3秒/n");sleep(3);sigqueue(getpid(),SIGUSR1,val);pthread_exit(0);//線程結束}void myhandler(int signo,siginfo_t *si,void *vcontext){sem_wait(&amp;semlock);value=0;printf("信號處理完畢/n");sem_post(&amp;semlock);}</code></pre><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">運行結果如下:<br>主線程已經執行<br>子線程睡眠3秒<br>信號處理完</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">解釋一下:</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">在主線線程中阻塞了SIGUSR1信號,首先讓子線程睡眠3秒，目的讓主線程先運行，然後當主線程訪問臨界資源時，讓線程sleep(10),在這期間，子線程發送信號，此時子線程會去處理信號，而主線程依舊平行的運行，子線程被阻止信號處理函數的sem_wait處，等待主線程10後，信號處理函數得到鎖，然後進行臨界資源的訪問。這就解決了主函數與信號處理函數之間的死鎖問題。</span></p><p><span style="background-color:#f3f3f3;--tt-darkmode-bgcolor: #1E1E1E">擴展: 如果有多個信號到達時，還可以用多線程來處理多個信號，從而達到並行的目的，這個很好實現的，可以嘗試一下。</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>信號</a></li><li><a>透徹</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f2b7ced.html alt=新買的短波收音機收不到信號？可能是這幾方面的原因 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2ada73fab2c94718a95683a62062dc47 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f2b7ced.html title=新買的短波收音機收不到信號？可能是這幾方面的原因>新買的短波收音機收不到信號？可能是這幾方面的原因</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/269cf310.html alt=乾式報警閥組—信號蝶閥和信號閘閥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/63e490037083439e9782da12f5947f11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/269cf310.html title=乾式報警閥組—信號蝶閥和信號閘閥>乾式報警閥組—信號蝶閥和信號閘閥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c1916805.html alt=當身體出現這5個信號，是告訴你已經疲勞到極限，趕緊休息！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153414836007155e4e3fe24 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c1916805.html title=當身體出現這5個信號，是告訴你已經疲勞到極限，趕緊休息！>當身體出現這5個信號，是告訴你已經疲勞到極限，趕緊休息！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9100c6e1.html alt=身體的這5個信號是提醒你：已經疲勞到極限！趕緊休息了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15350949932138ebc5e69ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9100c6e1.html title=身體的這5個信號是提醒你：已經疲勞到極限！趕緊休息了>身體的這5個信號是提醒你：已經疲勞到極限！趕緊休息了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/14bddd32.html alt=R&S羅德與施瓦茨信號發生器自檢自校準方法彙總-安泰維修中心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/14bddd32.html title=R&S羅德與施瓦茨信號發生器自檢自校準方法彙總-安泰維修中心>R&S羅德與施瓦茨信號發生器自檢自校準方法彙總-安泰維修中心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/310d551e.html alt=五個信號30％頻段協議（BAND）校正才剛剛開始 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f23399b5df9d4b76b5f71864b6042441 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/310d551e.html title=五個信號30％頻段協議（BAND）校正才剛剛開始>五個信號30％頻段協議（BAND）校正才剛剛開始</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>