<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>分佈式系統互斥性與冪等性問題的分析與解決 | 极客快訊</title><meta property="og:title" content="分佈式系統互斥性與冪等性問題的分析與解決 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/15336083003196c982cf9e8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/794069db.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/794069db.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/794069db.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/794069db.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/794069db.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/794069db.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/794069db.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/794069db.html><meta property="article:published_time" content="2020-11-14T21:02:06+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:06+08:00"><meta name=Keywords content><meta name=description content="分佈式系統互斥性與冪等性問題的分析與解決"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/794069db.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>分佈式系統互斥性與冪等性問題的分析與解決</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>隨著互聯網信息技術的飛速發展，數據量不斷增大，業務邏輯也日趨複雜，對系統的高併發訪問、海量數據處理的場景也越來越多。如何用較低成本實現系統的高可用、易伸縮、可擴展等目標就顯得越發重要。為了解決這一系列問題，系統架構也在不斷演進。傳統的集中式系統已經逐漸無法滿足要求，分佈式系統被使用在更多的場景中。</p><p>分佈式系統由獨立的服務器通過網絡鬆散耦合組成。在這個系統中每個服務器都是一臺獨立的主機，服務器之間通過內部網絡連接。分佈式系統有以下幾個特點：</p><ul><li>可擴展性：可通過橫向水平擴展提高系統的性能和吞吐量。</li><li>高可靠性：高容錯，即使系統中一臺或幾臺故障，系統仍可提供服務。</li><li>高併發性：各機器並行獨立處理和計算。</li><li>廉價高效：多臺小型機而非單臺高性能機。</li></ul><p>然而，在分佈式系統中，其環境的複雜度、網絡的不確定性會造成諸如時鐘不一致、“拜占庭將軍問題”（Byzantine failure）等。存在於集中式系統中的機器宕機、消息丟失等問題也會在分佈式環境中變得更加複雜。</p><p>基於分佈式系統的這些特徵，有兩種問題逐漸成為了分佈式環境中需要重點關注和解決的典型問題：</p><ul><li>互斥性問題。</li><li>冪等性問題。</li></ul><p>今天我們就針對這兩個問題來進行分析。</p><p>互斥性問題</p><p>先看兩個常見的例子：</p><p><strong>例1</strong>：某服務記錄關鍵數據X，當前值為100。A請求需要將X增加200；同時，B請求需要將X減100。</p><p>在理想的情況下，A先讀取到X=100，然後X增加200，最後寫入X=300。B請求接著從讀取X=300，減少100，最後寫入X=200。</p><p>然而在真實情況下，如果不做任何處理，則可能會出現：A和B同時讀取到X=100；A寫入之前B讀取到X；B比A先寫入等情況。</p><p><strong>例2</strong>：某服務提供一組任務，A請求隨機從任務組中獲取一個任務；B請求隨機從任務組中獲取一個任務。</p><p>在理想的情況下，A從任務組中挑選一個任務，任務組刪除該任務，B從剩下的的任務中再挑一個，任務組刪除該任務。</p><p>同樣的，在真實情況下，如果不做任何處理，可能會出現A和B挑中了同一個任務的情況。</p><p>以上的兩個例子，都存在操作互斥性的問題。互斥性問題用通俗的話來講，就是對共享資源的搶佔問題。如果不同的請求對同一個或者同一組資源讀取並修改時，無法保證按序執行，無法保證一個操作的原子性，那麼就很有可能會出現預期外的情況。因此操作的互斥性問題，也可以理解為一個需要保證時序性、原子性的問題。</p><p>在傳統的基於數據庫的架構中，對於數據的搶佔問題往往是通過數據庫事務（ACID）來保證的。在分佈式環境中，出於對性能以及一致性敏感度的要求，使得分佈式鎖成為了一種比較常見而高效的解決方案。</p><p>事實上，操作互斥性問題也並非分佈式環境所獨有，在傳統的多線程、多進程情況下已經有了很好的解決方案。因此在研究分佈式鎖之前，我們先來分析下這兩種情況的解決方案，以期能夠對分佈式鎖的解決方案提供一些實現思路。</p><p>多線程環境解決方案及原理</p><p>解決方案</p><p>《Thinking in Java》書中寫到：</p><blockquote><p>基本上所有的併發模式在解決線程衝突問題的時候，都是採用序列化訪問共享資源的方案。</p></blockquote><p>在多線程環境中，線程之間因為公用一些存儲空間，衝突問題時有發生。解決衝突問題最普遍的方式就是用互斥鎖把該資源或對該資源的操作保護起來。</p><p>Java JDK中提供了兩種互斥鎖Lock和synchronized。不同的線程之間對同一資源進行搶佔，該資源通常表現為某個類的普通成員變量。因此，利用ReentrantLock或者synchronized將共享的變量及其操作鎖住，即可基本解決資源搶佔的問題。</p><p>下面來簡單聊一聊兩者的實現原理。</p><p>原理</p><p><strong>ReentrantLock</strong></p><p>ReentrantLock主要利用CAS+CLH隊列來實現。它支持公平鎖和非公平鎖，兩者的實現類似。</p><ul><li>CAS：Compare and Swap，比較並交換。CAS有3個操作數：內存值V、預期值A、要修改的新值B。當且僅當預期值A和內存值V相同時，將內存值V修改為B，否則什麼都不做。該操作是一個原子操作，被廣泛的應用在Java的底層實現中。在Java中，CAS主要是由sun.misc.Unsafe這個類通過JNI調用CPU底層指令實現。</li><li>CLH隊列：帶頭結點的雙向非循環鏈表(如下圖所示)：</li></ul><div class=pgc-img><img alt=分佈式系統互斥性與冪等性問題的分析與解決 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15336083003196c982cf9e8><p class=pgc-img-caption></p></div><p>ReentrantLock的基本實現可以概括為：先通過CAS嘗試獲取鎖。如果此時已經有線程佔據了鎖，那就加入CLH隊列並且被掛起。當鎖被釋放之後，排在CLH隊列隊首的線程會被喚醒，然後CAS再次嘗試獲取鎖。在這個時候，如果：</p><ul><li>非公平鎖：如果同時還有另一個線程進來嘗試獲取，那麼有可能會讓這個線程搶先獲取；</li><li>公平鎖：如果同時還有另一個線程進來嘗試獲取，當它發現自己不是在隊首的話，就會排到隊尾，由隊首的線程獲取到鎖。</li></ul><p>下面分析下兩個片段：</p><ol><li>final boolean nonfairTryAcquire(int acquires) {</li><li>final Thread current = Thread.currentThread();</li><li>int c = getState();</li><li>if (c == 0) {</li><li>if (compareAndSetState(0, acquires)) {</li><li>setExclusiveOwnerThread(current);</li><li>return true;</li><li>}</li><li>}</li><li>else if (current == getExclusiveOwnerThread()) {</li><li>int nextc = c + acquires;</li><li>if (nextc &lt; 0) // overflow</li><li>throw new Error("Maximum lock count exceeded");</li><li>setState(nextc);</li><li>return true;</li><li>}</li><li>return false;</li><li>}</li></ol><p>在嘗試獲取鎖的時候，會先調用上面的方法。如果狀態為0，則表明此時無人佔有鎖。此時嘗試進行set，一旦成功，則成功佔有鎖。如果狀態不為0，再判斷是否是當前線程獲取到鎖。如果是的話，將狀態+1，因為此時就是當前線程，所以不用CAS。這也就是可重入鎖的實現原理。</p><ol><li>final boolean acquireQueued(final Node node, int arg) {</li><li>boolean failed = true;</li><li>try {</li><li>boolean interrupted = false;</li><li>for (;;) {</li><li>final Node p = node.predecessor();</li><li>if (p == head && tryAcquire(arg)) {</li><li>setHead(node);</li><li>p.next = null; // help GC</li><li>failed = false;</li><li>return interrupted;</li><li>}</li><li>if (shouldParkAfterFailedAcquire(p, node) &&</li><li>parkAndCheckInterrupt())</li><li>interrupted = true;</li><li>}</li><li>} finally {</li><li>if (failed)</li><li>cancelAcquire(node);</li><li>}</li><li>}</li><li>private final boolean parkAndCheckInterrupt() {</li><li>LockSupport.park(this);</li><li>return Thread.interrupted();</li><li>}</li></ol><p>該方法是在嘗試獲取鎖失敗加入CHL隊尾之後，如果發現前序節點是head，則CAS再嘗試獲取一次。否則，則會根據前序節點的狀態判斷是否需要阻塞。如果需要阻塞，則調用LockSupport的park方法阻塞該線程。</p><p><strong>synchronized</strong></p><p>在Java語言中存在兩種內建的synchronized語法：synchronized語句、synchronized方法。</p><ul><li>synchronized語句：當源代碼被編譯成字節碼的時候，會在同步塊的入口位置和退出位置分別插入monitorenter和monitorexit字節碼指令;</li><li>synchronized方法：在Class文件的方法表中將該方法的access_flags字段中的synchronized標誌位置1。這個在specification中沒有明確說明。</li></ul><p>在Java虛擬機的specification中，有關於monitorenter和monitorexit字節碼指令的詳細描述：http://docs.oracle.com/Javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.monitorenter。</p><p><strong>monitorenter</strong></p><blockquote><p>The objectref must be of type reference.</p><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</p></blockquote><ul><li>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</li><li>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</li><li>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</li></ul><p>每個對象都有一個鎖，也就是監視器（monitor）。當monitor被佔有時就表示它被鎖定。線程執行monitorenter指令時嘗試獲取對象所對應的monitor的所有權，過程如下：</p><ul><li>如果monitor的進入數為0，則該線程進入monitor，然後將進入數設置為1，該線程即為monitor的所有者;</li><li>如果線程已經擁有了該monitor，只是重新進入，則進入monitor的進入數加1;</li><li>如果其他線程已經佔用了monitor，則該線程進入阻塞狀態，直到monitor的進入數為0，再重新嘗試獲取monitor的所有權。</li></ul><p><strong>monitorexit</strong></p><blockquote><p>The objectref must be of type reference.</p><p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</p><p>The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</p></blockquote><p>執行monitorexit的線程必須是相應的monitor的所有者。</p><p>指令執行時，monitor的進入數減1，如果減1後進入數為0，那線程退出monitor，不再是這個monitor的所有者。其他被這個monitor阻塞的線程可以嘗試去獲取這個monitor的所有權。</p><p>在JDK1.6及其之前的版本中monitorenter和monitorexit字節碼依賴於底層的操作系統的Mutex Lock來實現的，但是由於使用Mutex Lock需要將當前線程掛起並從用戶態切換到內核態來執行，這種切換的代價是非常昂貴的。然而在現實中的大部分情況下，同步方法是運行在單線程環境（無鎖競爭環境）。如果每次都調用Mutex Lock將嚴重的影響程序的性能。因此在JDK 1.6之後的版本中對鎖的實現做了大量的優化，這些優化在很大程度上減少或避免了Mutex Lock的使用。</p><p>多進程的解決方案</p><p>在多道程序系統中存在許多進程，它們共享各種資源，然而有很多資源一次只能供一個進程使用，這便是臨界資源。多進程中的臨界資源大致上可以分為兩類，一類是物理上的真實資源，如打印機；一類是硬盤或內存中的共享數據，如共享內存等。而進程內互斥訪問臨界資源的代碼被稱為臨界區。</p><p>針對臨界資源的互斥訪問，JVM層面的鎖就已經失去效力了。在多進程的情況下，主要還是利用操作系統層面的進程間通信原理來解決臨界資源的搶佔問題。比較常見的一種方法便是使用信號量（Semaphores）。</p><p>信號量在POSIX標準下有兩種，分別為有名信號量和無名信號量。無名信號量通常保存在共享內存中，而有名信號量是與一個特定的文件名稱相關聯。信號量是一個整數變量，有計數信號量和二值信號量兩種。對信號量的操作，主要是P操作（wait）和V操作（signal）。</p><ul><li>P操作：先檢查信號量的大小，若值大於零，則將信號量減1，同時進程獲得共享資源的訪問權限，繼續執行；若小於或者等於零，則該進程被阻塞後，進入等待隊列。</li><li>V操作：該操作將信號量的值加1，如果有進程阻塞著等待該信號量，那麼其中一個進程將被喚醒。</li></ul><p>舉個例子，設信號量為1，當一個進程A在進入臨界區之前，先進行P操作。發現值大於零，那麼就將信號量減為0，進入臨界區執行。此時，若另一個進程B也要進去臨界區，進行P操作，發現信號量等於0，則會被阻塞。當進程A退出臨界區時，會進行V操作，將信號量的值加1，並喚醒阻塞的進程B。此時B就可以進入臨界區了。</p><p>這種方式，其實和多線程環境下的加解鎖非常類似。因此用信號量處理臨界資源搶佔，也可以簡單地理解為對臨界區進行加鎖。</p><p>通過上面的一些瞭解，我們可以概括出解決互斥性問題，即資源搶佔的基本方式為：</p><p><strong>對共享資源的操作前後（進入退出臨界區）加解鎖，保證不同線程或進程可以互斥有序的操作資源。</strong></p><p>加解鎖方式，有顯式的加解鎖，如ReentrantLock或信號量；也有隱式的加解鎖，如synchronized。那麼在分佈式環境中，為了保證不同JVM不同主機間不會出現資源搶佔，那麼同樣只要對臨界區加解鎖就可以了。</p><p>然而在多線程和多進程中，鎖已經有比較完善的實現，直接使用即可。但是在分佈式環境下，就需要我們自己來實現分佈式鎖。</p><p>分佈式環境下的解決方案——分佈式鎖</p><p>首先，我們來看看分佈式鎖的基本條件。</p><p>分佈式鎖條件</p><p><strong>基本條件</strong></p><p>再回顧下多線程和多進程環境下的鎖，可以發現鎖的實現有很多共通之處，它們都需要滿足一些最基本的條件：</p><ol><li>需要有存儲鎖的空間，並且鎖的空間是可以訪問到的。</li><li>鎖需要被唯一標識。</li><li>鎖要有至少兩種狀態。</li></ol><p>仔細分析這三個條件：</p><ul><li>存儲空間</li></ul><p>鎖是一個抽象的概念，鎖的實現，需要依存於一個可以存儲鎖的空間。在多線程中是內存，在多進程中是內存或者磁盤。更重要的是，這個空間是可以被訪問到的。多線程中，不同的線程都可以訪問到堆中的成員變量；在多進程中，不同的進程可以訪問到共享內存中的數據或者存儲在磁盤中的文件。但是在分佈式環境中，不同的主機很難訪問對方的內存或磁盤。這就需要一個都能訪問到的外部空間來作為存儲空間。</p><p>最普遍的外部存儲空間就是數據庫了，事實上也確實有基於數據庫做分佈式鎖（行鎖、version樂觀鎖），如quartz集群架構中就有所使用。除此以外，還有各式緩存如Redis、Tair、Memcached、Mongodb，當然還有專門的分佈式協調服務Zookeeper，甚至是另一臺主機。只要可以存儲數據、鎖在其中可以被多主機訪問到，那就可以作為分佈式鎖的存儲空間。</p><ul><li>唯一標識</li></ul><p>不同的共享資源，必然需要用不同的鎖進行保護，因此相應的鎖必須有唯一的標識。在多線程環境中，鎖可以是一個對象，那麼對這個對象的引用便是這個唯一標識。多進程環境中，信號量在共享內存中也是由引用來作為唯一的標識。但是如果不在內存中，失去了對鎖的引用，如何唯一標識它呢？上文提到的有名信號量，便是用硬盤中的文件名作為唯一標識。因此，在分佈式環境中，只要給這個鎖設定一個名稱，並且保證這個名稱是全局唯一的，那麼就可以作為唯一標識。</p><ul><li>至少兩種狀態</li></ul><p>為了給臨界區加鎖和解鎖，需要存儲兩種不同的狀態。如ReentrantLock中的status，0表示沒有線程競爭，大於0表示有線程競爭；信號量大於0表示可以進入臨界區，小於等於0則表示需要被阻塞。因此只要在分佈式環境中，鎖的狀態有兩種或以上：如有鎖、沒鎖；存在、不存在等，均可以實現。</p><p>有了這三個條件，基本就可以實現一個簡單的分佈式鎖了。下面以數據庫為例，實現一個簡單的分佈式鎖：</p><p>數據庫表，字段為鎖的ID（唯一標識），鎖的狀態（0表示沒有被鎖，1表示被鎖）。</p><p>偽代碼為：</p><ol><li>lock = mysql.get(id);</li><li>while(lock.status == 1) {</li><li>sleep(100);</li><li>}</li><li>mysql.update(lock.status = 1);</li><li>doSomething();</li><li>mysql.update(lock.status = 0);</li></ol><p><strong>問題</strong></p><p>以上的方式即可以實現一個粗糙的分佈式鎖，但是這樣的實現，有沒有什麼問題呢？</p><ul><li>問題1：鎖狀態判斷原子性無法保證</li><li>從讀取鎖的狀態，到判斷該狀態是否為被鎖，需要經歷兩步操作。如果不能保證這兩步的原子性，就可能導致不止一個請求獲取到了鎖，這顯然是不行的。因此，我們需要保證鎖狀態判斷的原子性。</li><li>問題2：網絡斷開或主機宕機，鎖狀態無法清除</li><li>假設在主機已經獲取到鎖的情況下，突然出現了網絡斷開或者主機宕機，如果不做任何處理該鎖將仍然處於被鎖定的狀態。那麼之後所有的請求都無法再成功搶佔到這個鎖。因此，我們需要在持有鎖的主機宕機或者網絡斷開的時候，及時的釋放掉這把鎖。</li><li>問題3：無法保證釋放的是自己上鎖的那把鎖</li><li>在解決了問題2的情況下再設想一下，假設持有鎖的主機A在臨界區遇到網絡抖動導致網絡斷開，分佈式鎖及時的釋放掉了這把鎖。之後，另一個主機B佔有了這把鎖，但是此時主機A網絡恢復，退出臨界區時解鎖。由於都是同一把鎖，所以A就會將B的鎖解開。此時如果有第三個主機嘗試搶佔這把鎖，也將會成功獲得。因此，我們需要在解鎖時，確定自己解的這個鎖正是自己鎖上的。</li></ul><p><strong>進階條件</strong></p><p>如果分佈式鎖的實現，還能再解決上面的三個問題，那麼就可以算是一個相對完整的分佈式鎖了。然而，在實際的系統環境中，還會對分佈式鎖有更高級的要求。</p><ol><li>可重入：線程中的可重入，指的是外層函數獲得鎖之後，內層也可以獲得鎖，ReentrantLock和synchronized都是可重入鎖；衍生到分佈式環境中，一般仍然指的是線程的可重入，在絕大多數分佈式環境中，都要求分佈式鎖是可重入的。</li><li>驚群效應（Herd Effect）：在分佈式鎖中，驚群效應指的是，在有多個請求等待獲取鎖的時候，一旦佔有鎖的線程釋放之後，如果所有等待的方都同時被喚醒，嘗試搶佔鎖。但是這樣的情況會造成比較大的開銷，那麼在實現分佈式鎖的時候，應該儘量避免驚群效應的產生。</li><li>公平鎖和非公平鎖：不同的需求，可能需要不同的分佈式鎖。非公平鎖普遍比公平鎖開銷小。但是業務需求如果必須要鎖的競爭者按順序獲得鎖，那麼就需要實現公平鎖。</li><li>阻塞鎖和自旋鎖：針對不同的使用場景，阻塞鎖和自旋鎖的效率也會有所不同。阻塞鎖會有上下文切換，如果併發量比較高且臨界區的操作耗時比較短，那麼造成的性能開銷就比較大了。但是如果臨界區操作耗時比較長，一直保持自旋，也會對CPU造成更大的負荷。</li></ol><p>保留以上所有問題和條件，我們接下來看一些比較典型的實現方案。</p><p>典型實現</p><p><strong>ZooKeeper的實現</strong></p><p>ZooKeeper（以下簡稱“ZK”）中有一種節點叫做順序節點，假如我們在/lock/目錄下創建3個節點，ZK集群會按照發起創建的順序來創建節點，節點分別為/lock/0000000001、/lock/0000000002、/lock/0000000003。</p><p>ZK中還有一種名為臨時節點的節點，臨時節點由某個客戶端創建，當客戶端與ZK集群斷開連接，則該節點自動被刪除。EPHEMERAL_SEQUENTIAL為臨時順序節點。</p><p>根據ZK中節點是否存在，可以作為分佈式鎖的鎖狀態，以此來實現一個分佈式鎖，下面是分佈式鎖的基本邏輯：</p><ol><li>客戶端調用create()方法創建名為“/dlm-locks/lockname/lock-”的臨時順序節點。</li><li>客戶端調用getChildren(“lockname”)方法來獲取所有已經創建的子節點。</li><li>客戶端獲取到所有子節點path之後，如果發現自己在步驟1中創建的節點是所有節點中序號最小的，那麼就認為這個客戶端獲得了鎖。</li><li>如果創建的節點不是所有節點中需要最小的，那麼則監視比自己創建節點的序列號小的最大的節點，進入等待。直到下次監視的子節點變更的時候，再進行子節點的獲取，判斷是否獲取鎖。</li></ol><p>釋放鎖的過程相對比較簡單，就是刪除自己創建的那個子節點即可，不過也仍需要考慮刪除節點失敗等異常情況。</p><p>開源的基於ZK的Menagerie的源碼就是一個典型的例子：https://github.com/sfines/menagerie 。</p><p>Menagerie中的lock首先實現了可重入鎖，利用ThreadLocal存儲進入的次數，每次加鎖次數加1，每次解鎖次數減1。如果判斷出是當前線程持有鎖，就不用走獲取鎖的流程。</p><p>通過tryAcquireDistributed方法嘗試獲取鎖，循環判斷前序節點是否存在，如果存在則監視該節點並且返回獲取失敗。如果前序節點不存在，則再判斷更前一個節點。如果判斷出自己是第一個節點，則返回獲取成功。</p><p>為了在別的線程佔有鎖的時候阻塞，代碼中使用JUC的condition來完成。如果獲取嘗試鎖失敗，則進入等待且放棄localLock，等待前序節點喚醒。而localLock是一個本地的公平鎖，使得condition可以公平的進行喚醒，配合循環判斷前序節點，實現了一個公平鎖。</p><p>這種實現方式非常類似於ReentrantLock的CHL隊列，而且zk的臨時節點可以直接避免網絡斷開或主機宕機，鎖狀態無法清除的問題，順序節點可以避免驚群效應。這些特性都使得利用ZK實現分佈式鎖成為了最普遍的方案之一。</p><p><strong>Redis的實現</strong></p><p>Redis的分佈式緩存特性使其成為了分佈式鎖的一種基礎實現。通過Redis中是否存在某個鎖ID，則可以判斷是否上鎖。為了保證判斷鎖是否存在的原子性，保證只有一個線程獲取同一把鎖，Redis有<strong>SETNX</strong>（即SET if Not</p><p>eXists）和<strong>GETSET</strong>（先寫新值，返回舊值，原子性操作，可以用於分辨是不是首次操作）操作。</p><p>為了防止主機宕機或網絡斷開之後的死鎖，Redis沒有ZK那種天然的實現方式，只能依賴設置超時時間來規避。</p><p>以下是一種比較普遍但不太完善的Redis分佈式鎖的實現步驟（與下圖一一對應）：</p><ol><li>線程A發送SETNX lock.orderid嘗試獲得鎖，如果鎖不存在，則set並獲得鎖。</li><li>如果鎖存在，則再判斷鎖的值（時間戳）是否大於當前時間，如果沒有超時，則等待一下再重試。</li><li>如果已經超時了，在用GETSET lock.{orderid}來嘗試獲取鎖，如果這時候拿到的時間戳仍舊超時，則說明已經獲得鎖了。</li><li>如果在此之前，另一個線程C快一步執行了上面的操作，那麼A拿到的時間戳是個未超時的值，這時A沒有如期獲得鎖，需要再次等待或重試。</li></ol><div class=pgc-img><img alt=分佈式系統互斥性與冪等性問題的分析與解決 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1533608319719ea883198e3><p class=pgc-img-caption></p></div><p>該實現還有一個需要考慮的問題是全局時鐘問題，由於生產環境主機時鐘不能保證完全同步，對時間戳的判斷也可能會產生誤差。</p><p>以上是Redis的一種常見的實現方式，除此以外還可以用SETNX+EXPIRE來實現。Redisson是一個官方推薦的Redis客戶端並且實現了很多分佈式的功能。它的分佈式鎖就提供了一種更完善的解決方案，源碼：https://github.com/mrniko/redisson。</p><p><strong>Tair的實現</strong></p><p>Tair和Redis的實現類似，Tair客戶端封裝了一個expireLock的方法：通過鎖狀態和過期時間戳來共同判斷鎖是否存在，只有鎖已經存在且沒有過期的狀態才判定為有鎖狀態。在有鎖狀態下，不能加鎖，能通過大於或等於過期時間的時間戳進行解鎖。</p><p>採用這樣的方式，可以不用在Value中存儲時間戳，並且保證了判斷是否有鎖的原子性。更值得注意的是，由於超時時間是由Tair判斷，所以避免了不同主機時鐘不一致的情況。</p><p>以上的幾種分佈式鎖實現方式，都是比較常見且有些已經在生產環境中應用。隨著應用環境越來越複雜，這些實現可能仍然會遇到一些挑戰。</p><ul><li><strong>強依賴於外部組件</strong>：分佈式鎖的實現都需要依賴於外部數據存儲如ZK、Redis等，因此一旦這些外部組件出現故障，那麼分佈式鎖就不可用了。</li><li><strong>無法完全滿足需求</strong>：不同分佈式鎖的實現，都有相應的特點，對於一些需求並不能很好的滿足，如實現公平鎖、給等待鎖加超時時間等。</li></ul><p>基於以上問題，結合多種實現方式，我們開發了Cerberus（得名自希臘神話裡守衛地獄的猛犬），致力於提供靈活可靠的分佈式鎖。</p><p>Cerberus分佈式鎖</p><p>Cerberus有以下幾個特點。</p><p><strong>特點一：一套接口多種引擎</strong></p><p>Cerberus分佈式鎖使用了多種引擎實現方式（Tair、ZK、未來支持Redis），支持使用方自主選擇所需的一種或多種引擎。這樣可以結合引擎特點，選擇符合實際業務需求和系統架構的方式。</p><p>Cerberus分佈式鎖將不同引擎的接口抽象為一套，屏蔽了不同引擎的實現細節。使得使用方可以專注於業務邏輯，也可以任意選擇並切換引擎而不必更改任何的業務代碼。</p><p>如果使用方選擇了一種以上的引擎，那麼以配置順序來區分主副引擎。以下是使用主引擎的推薦：</p><p>功能需求 Tair ZK 併發量高 ✔ 響應時間敏感 ✔ 臨界區執行時間長 ✔ 公平鎖 ✔ 非公平鎖 ✔ 讀寫鎖 ✔</p><p><strong>特點二：使用靈活、學習成本低</strong></p><p>下面是Cerberus的lock方法，這些方法和JUC的ReentrantLock的方式保持一致，使用非常靈活且不需要額外的學習時間。</p><ul><li>void lock();</li><li>獲取鎖，如果鎖被佔用，將禁用當前線程，並且在獲得鎖之前，該線程將一直處於阻塞狀態。</li><li>boolean tryLock();</li><li>僅在調用時鎖為空閒狀態才獲取該鎖。</li><li>如果鎖可用，則獲取鎖，並立即返回值true。如果鎖不可用，則此方法將立即返回值false。</li><li>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</li><li>如果鎖在給定的等待時間內空閒，並且當前線程未被中斷，則獲取鎖。</li><li>如果在給定時間內鎖可用，則獲取鎖，並立即返回值true。如果在給定時間內鎖一直不可用，則此方法將立即返回值false。</li><li>void lockInterruptibly() throws InterruptedException;</li><li>獲取鎖，如果鎖被佔用，則一直等待直到線程被中斷或者獲取到鎖。</li><li>void unlock();</li><li>釋放當前持有的鎖。</li></ul><p><strong>特點三：支持一鍵降級</strong></p><p>Cerberus提供了實時切換引擎的接口:</p><ul><li>String switchEngine()</li><li>轉換分佈式鎖引擎，按配置的引擎的順序循環轉換。</li><li>返回值：返回當前的engine名字，如：”zk”。</li><li>String switchEngine(String engineName)</li><li>轉換分佈式鎖引擎，切換為指定的引擎。</li><li>參數：engineName - 引擎的名字，同配置bean的名字，”zk”/”tair”。</li><li>返回值：返回當前的engine名字，如：”zk”。</li></ul><p>當使用方選擇了兩種引擎，平時分佈式鎖會工作在主引擎上。一旦所依賴的主引擎出現故障，那麼使用方可以通過自動或者手動方式調用該切換引擎接口，平滑的將分佈式鎖切換到另一個引擎上以將風險降到最低。自動切換方式可以利用Hystrix實現。手動切換推薦的一個方案則是使用美團點評基於Zookeeper的基礎組件MCC，通過監聽MCC配置項更改，來達到手動將分佈式系統所有主機同步切換引擎的目的。需要注意的是，切換引擎目前並不會遷移原引擎已有的鎖。這樣做的目的是出於必要性、系統複雜度和可靠性的綜合考慮。在實際情況下，引擎故障到切換引擎，尤其是手動切換引擎的時間，要遠大於分佈式鎖的存活時間。作為較輕量級的Cerberus來說，遷移鎖會帶來不必要的開銷以及較高的系統複雜度。鑑於此，如果想要保證在引擎故障後的絕對可靠，那麼則需要結合其他方案來進行處理。</p><p>除此以外，Cerberus還提供了內置公用集群，免去搭建和配置集群的煩惱。Cerberus也有一套完善的應用授權機制，以此防止業務方未經評估使用，對集群造成影響。</p><p>目前，Cerberus分佈式鎖已經持續迭代了8個版本，先後在美團點評多個項目中穩定運行。</p><p>冪等性問題</p><p>所謂冪等，簡單地說，就是對接口的多次調用所產生的結果和調用一次是一致的。擴展一下，這裡的接口，可以理解為對外發布的HTTP接口或者Thrift接口，也可以是接收消息的內部接口，甚至是一個內部方法或操作。</p><p>那麼我們為什麼需要接口具有冪等性呢？設想一下以下情形：</p><ul><li>在App中下訂單的時候，點擊確認之後，沒反應，就又點擊了幾次。在這種情況下，如果無法保證該接口的冪等性，那麼將會出現重複下單問題。</li><li>在接收消息的時候，消息推送重複。如果處理消息的接口無法保證冪等，那麼重複消費消息產生的影響可能會非常大。</li></ul><p>在分佈式環境中，網絡環境更加複雜，因前端操作抖動、網絡故障、消息重複、響應速度慢等原因，對接口的重複調用概率會比集中式環境下更大，尤其是重複消息在分佈式環境中很難避免。Tyler Treat也在《You Cannot Have Exactly-Once Delivery》一文中提到：</p><blockquote><p>Within the context of a distributed system, you cannot have exactly-once message delivery.</p></blockquote><p>分佈式環境中，有些接口是天然保證冪等性的，如查詢操作。有些對數據的修改是一個常量，並且無其他記錄和操作，那也可以說是具有冪等性的。其他情況下，所有涉及對數據的修改、狀態的變更就都有必要防止重複性操作的發生。通過間接的實現接口的冪等性來防止重複操作所帶來的影響，成為了一種有效的解決方案。</p><p>GTIS</p><p>GTIS就是這樣的一個解決方案。它是一個輕量的重複操作關卡系統，它能夠確保在分佈式環境中操作的唯一性。我們可以用它來間接保證每個操作的冪等性。它具有如下特點：</p><ul><li>高效：低延時，單個方法平均響應時間在2ms內，幾乎不會對業務造成影響；</li><li>可靠：提供降級策略，以應對外部存儲引擎故障所造成的影響；提供應用鑑權，提供集群配置自定義，降低不同業務之間的干擾；</li><li>簡單：接入簡捷方便，學習成本低。只需簡單的配置，在代碼中進行兩個方法的調用即可完成所有的接入工作；</li><li>靈活：提供多種接口參數、使用策略，以滿足不同的業務需求。</li></ul><p><strong>實現原理</strong></p><p><strong>基本原理</strong></p><p>GTIS的實現思路是將每一個不同的業務操作賦予其唯一性。這個唯一性是通過對不同操作所對應的唯一的內容特性生成一個唯一的全局ID來實現的。基本原則為：相同的操作生成相同的全局ID；不同的操作生成不同的全局ID。</p><p>生成的全局ID需要存儲在外部存儲引擎中，數據庫、Redis亦或是Tair等均可實現。考慮到Tair天生分佈式和持久化的優勢，目前的GTIS存儲在Tair中。其相應的key和value如下：</p><ul><li>key：將對於不同的業務，採用APP_KEY+業務操作內容特性生成一個唯一標識trans_contents。然後對唯一標識進行加密生成全局ID作為Key。</li><li>value：current_timestamp + trans_contents，current_timestamp用於標識當前的操作線程。</li></ul><p>判斷是否重複，主要利用Tair的SETNX方法，如果原來沒有值則set且返回成功，如果已經有值則返回失敗。</p><p><strong>內部流程</strong></p><p>GTIS的內部實現流程為：</p><ol><li>業務方在業務操作之前，生成一個能夠唯一標識該操作的transContents，傳入GTIS；</li><li>GTIS根據傳入的transContents，用MD5生成全局ID；</li><li>GTIS將全局ID作為key，current_timestamp+transContents作為value放入Tair進行setNx，將結果返回給業務方；</li><li>業務方根據返回結果確定能否開始進行業務操作；</li><li>若能，開始進行操作；若不能，則結束當前操作；</li><li>業務方將操作結果和請求結果傳入GTIS，系統進行一次請求結果的檢驗；</li><li>若該次操作成功，GTIS根據key取出value值，跟傳入的返回結果進行比對，如果兩者相等，則將該全局ID的過期時間改為較長時間；</li><li>GTIS返回最終結果。</li></ol><p><strong>實現難點</strong></p><p>GTIS的實現難點在於如何保證其判斷重複的可靠性。由於分佈式環境的複雜度和業務操作的不確定性，在上一章節分佈式鎖的實現中考慮的網絡斷開或主機宕機等問題，同樣需要在GTIS中設法解決。這裡列出幾個典型的場景：</p><ul><li>如果操作執行失敗，理想的情況應該是另一個相同的操作可以立即進行。因此，需要對業務方的操作結果進行判斷，如果操作失敗，那麼就需要立即刪除該全局ID；</li><li>如果操作超時或主機宕機，當前的操作無法告知GTIS操作是否成功。那麼我們必須引入超時機制，一旦長時間獲取不到業務方的操作反饋，那麼也需要該全局ID失效；</li><li>結合上兩個場景，既然全局ID會失效並且可能會被刪除，那就需要保證刪除的不是另一個相同操作的全局ID。這就需要將特殊的標識記錄下來，並由此來判斷。這裡所用的標識為當前時間戳。</li></ul><p>可以看到，解決這些問題的思路，也和上一章節中的實現有很多類似的地方。除此以外，還有更多的場景需要考慮和解決，所有分支流程如下:</p><div class=pgc-img><img alt=分佈式系統互斥性與冪等性問題的分析與解決 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1533608333316a361feb7f4><p class=pgc-img-caption></p></div><p>使用說明</p><p>使用時，業務方只需要在操作的前後調用GTIS的前置方法和後置方法，如下圖所示。如果前置方法返回可進行操作，則說明此時無重複操作，可以進行。否則則直接結束操作。</p><div class=pgc-img><img alt=分佈式系統互斥性與冪等性問題的分析與解決 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153360834380108b32b17fa><p class=pgc-img-caption></p></div><p>使用方需要考慮的主要是下面兩個參數：</p><ul><li>空間全局性：業務方輸入的能夠標誌操作唯一性的內容特性，可以是唯一性的String類型的ID，也可以是map、POJO等形式。如訂單ID等</li><li>時間全局性：確定在多長時間內不允許重複，1小時內還是一個月內亦或是永久。</li></ul><p>此外，GTIS還提供了不同的故障處理策略和重試機制，以此來降低外部存儲引擎異常對系統造成的影響。</p><p>目前，GTIS已經持續迭代了7個版本，距離第一個版本有近1年之久，先後在美團點評多個項目中穩定運行。</p><p>結語</p><p>在分佈式環境中，操作互斥性問題和冪等性問題非常普遍。經過分析，我們找出瞭解決這兩個問題的基本思路和實現原理，給出了具體的解決方案。</p><p>針對操作互斥性問題，常見的做法便是通過分佈式鎖來處理對共享資源的搶佔。分佈式鎖的實現，很大程度借鑑了多線程和多進程環境中的互斥鎖的實現原理。只要滿足一些存儲方面的基本條件，並且能夠解決如網絡斷開等異常情況，那麼就可以實現一個分佈式鎖。目前已經有基於Zookeeper和Redis等存儲引擎的比較典型的分佈式鎖實現。但是由於單存儲引擎的侷限，我們開發了基於ZooKeeper和Tair的多引擎分佈式鎖Cerberus，它具有使用靈活方便等諸多優點，還提供了完善的一鍵降級方案。</p><p>針對操作冪等性問題，我們可以通過防止重複操作來間接的實現接口的冪等性。GTIS提供了一套可靠的解決方法：依賴於存儲引擎，通過對不同操作所對應的唯一的內容特性生成一個唯一的全局ID來防止操作重複。</p><p>目前Cerberus分佈式鎖、GTIS都已應用在生產環境並平穩運行。兩者提供的解決方案已經能夠解決大多數分佈式環境中的操作互斥性和冪等性的問題。值得一提的是，分佈式鎖和GTIS都不是萬能的，它們對外部存儲系統的強依賴使得在環境不那麼穩定的情況下，對可靠性會造成一定的影響。在併發量過高的情況下，如果不能很好的控制鎖的粒度，那麼使用分佈式鎖也是不太合適的。總的來說，分佈式環境下的業務場景紛繁複雜，要解決互斥性和冪等性問題還需要結合當前系統架構、業務需求和未來演進綜合考慮。Cerberus分佈式鎖和GTIS也會持續不斷地迭代更新，提供更多的引擎選擇、更高效可靠的實現方式、更簡捷的接入流程，以期滿足更復雜的使用場景和業務需求。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>互斥性</a></li><li><a>系統</a></li><li><a>問題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a9dd0a78.html alt=中央系統軟件出問題，Facebook兩社交軟件大規模宕機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RjAc3Dz9H8GnSD style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a9dd0a78.html title=中央系統軟件出問題，Facebook兩社交軟件大規模宕機>中央系統軟件出問題，Facebook兩社交軟件大規模宕機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a40d67a.html alt=分佈式系統核心問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30bfbd168e6c49cbbc8ebb388f55b997 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a40d67a.html title=分佈式系統核心問題>分佈式系統核心問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2058c2c.html alt=分佈式系統核心問題簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2058c2c.html title=分佈式系統核心問題簡介>分佈式系統核心問題簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f87337a.html alt=收不到交警便民通知？可能是這裡出了問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdf88511c83f431c9f75609d9e44d585 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f87337a.html title=收不到交警便民通知？可能是這裡出了問題>收不到交警便民通知？可能是這裡出了問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db1a012.html alt=問題408:在變壓器送電前後怎樣檢測差動保護裝置？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e7912ea051664f678d2616da1c042a37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db1a012.html title=問題408:在變壓器送電前後怎樣檢測差動保護裝置？>問題408:在變壓器送電前後怎樣檢測差動保護裝置？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html alt=電廠直流系統調試方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e8200036f19e04c25bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html title=電廠直流系統調試方案>電廠直流系統調試方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html alt=一文讀懂智能客服：發展歷程、系統搭建、市場推廣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RbYMTZ55OrJUgU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html title=一文讀懂智能客服：發展歷程、系統搭建、市場推廣>一文讀懂智能客服：發展歷程、系統搭建、市場推廣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html alt=生活垃圾焚燒發電及蒸汽系統優化改造項目公告 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RcblrbTDBokV23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html title=生活垃圾焚燒發電及蒸汽系統優化改造項目公告>生活垃圾焚燒發電及蒸汽系統優化改造項目公告</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html alt=電驅動橋系統或加快電氣化進程，多個案例共同說明問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539571595921bc5b27eff6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html title=電驅動橋系統或加快電氣化進程，多個案例共同說明問題>電驅動橋系統或加快電氣化進程，多個案例共同說明問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html alt=基於混沌系統的偽隨機數發生器設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html title=基於混沌系統的偽隨機數發生器設計>基於混沌系統的偽隨機數發生器設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html alt=win10系統打印機打印不了顯示已暫停的解決方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10d0de369d4746c7a0c220ff59bd2470 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html title=win10系統打印機打印不了顯示已暫停的解決方法>win10系統打印機打印不了顯示已暫停的解決方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84e317ac.html alt=檢測虛設問題，應當採取強有力的措施加以解決 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/115bad769be144f19346317e77eed4b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84e317ac.html title=檢測虛設問題，應當採取強有力的措施加以解決>檢測虛設問題，應當採取強有力的措施加以解決</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dfdb3278.html alt=南通中海問題多多？！竟遭市住建局通報批評 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZ6gaqQHcJXxWV style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dfdb3278.html title=南通中海問題多多？！竟遭市住建局通報批評>南通中海問題多多？！竟遭市住建局通報批評</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afc3600.html alt="歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fe51a7bcc26445fa95824ca74c172f17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afc3600.html title="歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑">歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html alt=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html title=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案>虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>