<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何理解：程序、進程、線程、併發、並行、高併發？ | 极客快訊</title><meta property="og:title" content="如何理解：程序、進程、線程、併發、並行、高併發？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/b101e22357854a56abf29c0745b5d9c9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e23cb7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e23cb7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/79e23cb7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e23cb7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e23cb7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/79e23cb7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/79e23cb7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e23cb7.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="如何理解：程序、進程、線程、併發、並行、高併發？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/79e23cb7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何理解：程序、進程、線程、併發、並行、高併發？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><p>在這裡你可以瞭解：</p><ul><li>為啥大家說的進程的意思有出入？</li><li>為啥併發那麼難理解？</li><li>為啥高併發不僅僅是“高”+“併發”的意思？</li><li>為啥這些概念到了現實當中就不一樣了？</li></ul><h2 class=pgc-h-arrow-right>進程，和另一種進程</h2><p>假如你想鋪一條長1000m，寬500m的目錄。為了解決這個問題，你先構想出來假如你自己1個人做，整個過程第一步幹什麼，第二步幹什麼等等。這個幹活的過程，可以被稱作一個【進程】（Process），或者你可以理解為“一個做事的辦法/步驟/方案“。進程的英文Process本意就是“過程”的意思，是一個抽象的概念。這個活有沒有真得幹並不重要，重要的是你已經預先想好了這個活該怎麼幹，<strong>有了一個可行思路</strong>。</p><p>你把這套鋪路的方案用紙張寫出來就得到一個【程序】。在軟件開發中也是如此，只不過你用的不是紙筆，而是某種編程語言。注意，這裡【進程】僅僅是描述這個方案的。至於這個方案是在腦海裡，還是已經被執行了，是不重要的。</p><p>當然，大家更加熟知的進程往往指的是另外一個意思，是指“程序在操作系統中運行的實例“。所謂“實例”是指同一個程序可以同時在操作系統裡實際的運行。就像是如果你的鋪路程序寫好了，可以鋪好幾條路。每一個具體的鋪路工作是一個“實例”。</p><p>所以wiki是這麼給定義的：</p><blockquote><p>In computing, a <strong>process </strong>is the instance of a computer program that is being executed by one or many threads.</p></blockquote><p>見 https://en.wikipedia.org/wiki/Process_(computing)</p><p>為了避免混淆，我在下文中將操作系統的這個進程概念稱為【OS進程】。而對上一節裡面講的“想辦法”的進程稱為【P進程】。</p><p>【OS進程】到底怎麼實現呢？鋪路的工作真的開干時，要不斷記錄買了什麼料，已經花了多少錢，哪一塊已經鋪好了，哪一塊剛鋪完瀝青得晾著等等。這些信息只有工作真的開幹才會有。【OS進程】也是一樣，因此比如Linux將進程實現為“task_struct"，裡面記錄了CPU要完成這個工作的一整套數據。比如一個事情A，CPU沒做完，被程序員要求做另外一件事情B。就得找個地方記錄做了一半的A的那些數據，以便於CPU回過頭來再做A時能夠繼續。</p><p>再次強調下，【P進程】和【OS進程】並不是一個意思，儘管會有一些關聯。所以在閱讀各種資料時一定要根據上下文分清楚進程到底是什麼意思。我再總結下：</p><ul><li>【P進程】指的是如何想明白做一件事情的過程。他用來幫助你理清做事的思路。這個事情做與沒做，對於【P進程】這個概念不重要。</li><li>【OS進程】是指程序真的運行起來的實例，可以被實現為存放調度給CPU的任務和狀態的數據結構。</li></ul><blockquote><p>軟件設計裡有一個經典的4 + 1 View，其中一個View叫做“Process View”，裡面的Process就是指這裡的【P進程】。“Process View”的目標就是“把怎麼解決問題的方案說明白”。</p></blockquote><h2 class=pgc-h-arrow-right>線程</h2><p>上面wiki的定義指出一個【OS進程】是由一到多個【線程】組成。這裡的【線程】（Thread）是一個抽象概念。</p><p>但在Linux中，【線程】是被實現為“輕量級進程”的。也就是說在Linux中的進程和線程實現的本質是一樣的。只不過在以下2點上有顯著區別：</p><ul><li>在資源消耗上進程的消耗多，線程消耗相對少，以及；</li><li>內存空間上有一些不同：進程的虛擬內存彼此隔離，而線程則共享同一虛擬內存空間有些不同。</li></ul><p>但Linux中【OS進程】和【線程】都用作任務調度單位。因此，<strong>Linux這種實現方式和理論上的概念不是很吻合</strong>，但是大量的程序已經跑在這個模式上了。而且大家早就已經習慣了。其他操作系統對【OS進程】和【線程】的實現會有所不同。如果碰到了不要驚訝。</p><h2 class=pgc-h-arrow-right>併發</h2><p>【併發】（Concurrency）是由【P進程】引申出來的抽象概念。</p><p>上面說到了你可以假設自己一個人按照一定的步驟來鋪路，一個人從頭幹到尾，這是一個“串行”的【P進程】。</p><p>但你也可以假設有2個人鋪路。比如你可以按照長度分兩半，一人鋪500m * 50m；也可以按寬度劃分，一人鋪1000m * 25m；你還可以說讓一個人負責鋪全部路面的前5個步驟，另外一個人負責鋪路面的餘下5個步驟。然後你可以進一步想，假如不是僱2個人，而是僱20個人概如何分工呢？你可以混搭按長度，寬度，步驟等各種方式進行拆分。你甚至可以考慮這20個人不是完全一樣的，有的能力強，有的能力弱，可以適當的調整工作量的比例等等。</p><p>不管怎樣拆，都意味著你得到了【併發】的【P進程】。換成說人話就是，<strong>你有一套方案，可以讓多個人一起把事情做的更高效</strong>。注意是“<strong>可以</strong>“讓事情更高效，而不是“必然“讓事情更高效。是不是更高效要看到底是怎麼執行的，後邊會講。</p><p>舉個寫代碼的例子，你有一個很長很長的數組，目標是把每一個數都*2。一個併發的做法就是把數組拆為很多個小段，然後每個小段的元素依次自己*2。這樣的程序寫出來就是一個【併發】的【程序】。這個程序如果運行起來就是【併發】的【OS進程】。</p><p>這時就會出現一個問題，當你想把一個【併發】的【P進程】寫成程序時，你怎麼用編程語言告訴操作系統你的程序的一些步驟是【併發】的。更確切地說，你需要一個寫法（可能是語法，也可能是函數庫）表達：</p><ul><li>幾個任務是【併發】的</li><li>【併發】的任務之間是怎麼交互協作的</li></ul><p>為了解決這兩個問題，人們總結了一些方法，並將其稱為“併發模型”。</p><p>比如：</p><ul><li>Fork & Join模型（大任務拆解為小任務併發的跑，結果再拼起來）</li><li>Actor模型（幹活的步驟之間直接發消息）</li><li>CSP模型（幹活的步驟之間訂閱通話的頻道來協作）</li><li>線程&鎖模型（幹活的人共享一個小本本，用來協作。注意小本本不能改亂套了，所以得加鎖）</li><li>……</li></ul><p>以Java中的線程為例，大家想表達【併發】就啟動新的Thread（或者某種等價操作，如利用線程池）；想讓Thread之間交互，就要依靠共享內容。但是【併發】的Thread如果同時修改同一份數據就有可能出錯（被稱為競爭問題），為了解決這個問題就要引入鎖（Lock，或者一些高級的同步工具，如CountdownLatch，Semaphore）。</p><blockquote><p>特別強調下，Java的線程是表達併發的概念的類。這個類在絕大部分操作系統上使用操作系統內核中的【線程】實現。二者之間還是有一些細微的差異。即用開發者用Java Thread寫代碼表達思路，和操作系統調度線程執行是兩個層面的事情。請努力認識到這一點。</p></blockquote><p>再比如Erlang是基於Actor的併發模型（其實這是原教旨主義的OO）。那麼就是每個參與【併發】的任務稱為Process（又一個進程……，和【P進程】以及【OS進程都不太一樣】，叫【E進程】好了，Erlang中的"進程“）。【E進程】之間通過消息來協作。每個【E進程】要不是在處理消息，要不就是在等新的消息。</p><p>如果你用go，那麼表達併發的工具就是goroutine，goroutine之間協作要用channel。（當然也可以用Sync包加鎖，不展開）。</p><p>對於併發模型《7周7併發模型》這本書講的非常好。推薦閱讀。書中展示了七種最經典的併發模型和大量的編碼實例。</p><h2 class=pgc-h-arrow-right>並行</h2><p>現在我們已經有了一個【併發】的想法，然後進入執行層面。</p><p>回到上面鋪路的例子，你雖然假設有20個人可以一起幹活。但你不一定真的能僱得到20個人。假如說你實際上最終只僱到1個人。但你有一個為20個人一起幹活設計的方法。能不能用呢？當然能，只要讓這個人先幹第1人份的活，再幹第2人份的……</p><p>但如果你真的僱了10個人，就可以很容易的讓第1個人幹第1人份和第2人份的活，第2個人幹第3和第4人份的活…… 而這10個人同時在工地上幹活，就是【並行】（Parallelism）。</p><p>在軟件系統中，【程序】是否能【並行】運行，要看物理上有多少個CPU核心可以同時幹活（或者再擴展一下，有多少臺可用的物理主機）。</p><p>比如你寫了個Java程序，同時啟動了4個線程，但CPU只有單核，那麼同一時刻只有一個線程在運行。如果有4個CPU核心，那麼可以做到4個線程完全【並行】運行。如果有2個核心，那麼就處於一種中間態。比如你可以用“併發度=4“，”並行度=2“形容這種情況。</p><h2 class=pgc-h-arrow-right>為啥要併發</h2><p>把事情設計為【併發】有什麼好處呢？假如能同時幹活的人只有1個，其實並沒有什麼好處。【併發】的方法的總耗時總會>=串行的方法。因為【併發】或多或少總會引入需要協作和溝通成本。最小的代價就是不需要溝通，此時【併發】的方法和串行的方法工作量是一樣的。</p><p>但是【併發】的巨大優勢是在可以幹活的人數量變多時，馬上得到【並行】的好處。假如我們可以得到一個【併發】的【P進程】，並且真的為其配備足夠多的人，那麼做事的效率就會高很多。回到軟件系統，假如有一個【併發】的【程序】，它在只有1個CPU的核心的機器上可以跑，在2個的CPU的也可以跑，在4核CPU上也可以跑。物理上可用CPU核心越多，程序能夠越快執行完。而不管在哪裡跑，程序本身不用做變化。編程是一件成本很高的事，能夠做到程序不變而適應各種環境，可以極大的降低開發成本。你能想象下為1核心CPU開發的Office軟件和4核心的不一樣嗎？</p><h2 class=pgc-h-arrow-right>併發和並行的關係是什麼</h2><p>Rob Pike在一個Talk裡（https://blog.golang.org/concurrency-is-not-parallelism）提到了很重要的兩個觀點：</p><ul><li><strong>Concurrency is not Parallelism</strong></li><li><strong>Concurrency enables parallelism & makes parallelism (and scaling and everything else) easy</strong></li></ul><p>前一個觀點【併發】和【並行】不是一件事，我們都可以理解了。【併發】說的是<strong>處理</strong>（Deal）的方法；【並行】說的是<strong>執行</strong>（Execution）的方法。</p><p>後一個觀點指的是，如果想讓一個事情變得容易【並行】，先得讓制定一個【併發】的方法。倘若一個事情壓根就沒有【併發】的方法，那麼無論有多少個可以幹活的人，也不能【並行】。比如你讓20個人不鋪路，而是一起去擰同一個燈泡，也只能有一個人踩在梯子上去擰，其他19個人只能看著，啥也幹不了。</p><p>對於一個問題，能不能找到【併發】的辦法，取決於問題本身。有些問題很容易【併發】，有些問題可以一部分【併發】其餘的串行（比如對數組排序就是，無論怎麼拆，最終也要把每個拆開的問題結果合併到一起再排序才行），有些問題則根本上就不能【併發】。找不到【併發】的方法也就意味著不管有多少CPU核心，也沒法【並行】執行。</p><p>換一個極端，假如為最多20個人設計了【併發】的方法，結果來了40個人，就意味著40人裡有20個人是閒著的，是浪費。也就是說【並行】的上限是由【併發】的方法的設計決定的。這就解釋了你吃雞的時候，4核CPU和8核差別不大，因為這個遊戲壓根就沒設計成可以利用這麼多個CPU核心。（BTW，但遊戲被設計為能充分利用顯卡的多核心）</p><p>其實上面只是將CPU核心當作是“做事的人“，再廣義一點，比如顯卡，網卡，磁盤都是獨立的可以幹活的人。這些組件之間也可以並行的跑。因此，在設計程序的時候，可以比如把計算和IO任務拆開設計一個【併發】的方法，然後利用CPU和網卡是兩個零件來【並行】的跑。</p><h2 class=pgc-h-arrow-right>常見的誤解</h2><p>你可能看到過下面的論斷：</p><blockquote><p><strong>併發</strong>是多個任務交替使用CPU，同一時刻只有一個任務在跑；<strong>並行</strong>是多個任務同時跑</p></blockquote><p>這個理解不能說全錯，但是合到一起就形成了錯誤的理解。這個錯誤的理解就是：併發和並行是兩個並列的，非此即彼的概念，一個狀態要不就是並行的，要不就是併發的。這是完全錯誤的，實際上看到上面的解釋你就會發現【併發】和【並行】描述的是兩個頻道的事情。正如Rob Pike所言，一個是“如何處理”，一個是“如何執行”。因此，對於：</p><blockquote><p><strong>併發</strong>是多個任務交替使用CPU，同一時刻只有一個任務在跑</p></blockquote><p>其實正確的理解是：針對一個問題，想到了一個可以拆解為多個【併發】的任務，這些任務執行時因為只有一個CPU只能“切換”的跑。</p><p>對於：</p><blockquote><p><strong>並行</strong>是多個任務同時跑</p></blockquote><p>其實的意思是：如果這些並行執行的任務是解決同一個問題的，那麼他們既是【併發】的，同時也是【並行】的。</p><p>那麼可不可以做到只【並行】，而不【併發】呢？當然可以，但這也就意味著【並行】的程序之間沒有什麼關聯，各幹各的，就像大街上來來往往的陌生人一樣。這的確是【並行】，並且是這個世界的常態。但是一群不認識的，各幹各的人是不能一起解決問題的，要一起就得有同一個目標，制定一套溝通的方法，形成【併發】的方案。這種形式在現實當中就是“公司”。</p><h2 class=pgc-h-arrow-right>為什麼要這麼理解併發</h2><p>將併發理解為一種解決問題的方法，其主要用意是表達：一個問題的解決方案是可以由許許多多的併發任務組裝（compose）到一起的。這有點像OOP裡表達一個類可以由其他類的成員組裝到一起一樣。</p><p><strong>將大的任務拆解為許許多多小的可以併發的任務是重要的編程思想</strong>。</p><p>比如當你在編寫一個GET /user/:userId接口時，實際上底層要去3個地方取用戶的基本信息（頭像、暱稱），活動的積分，當前已經下的訂單，再組裝到一起返回，用nodejs大概可以寫成：</p><pre><code>const userId = await doGetUserIdByToken(token);const [userBasic, userScore, userProcessingOrders] =   await Promise.all([ // 併發執行下面3個任務   doGetUserBasic(userId),   doGetUserScore(userId),   doGetProcessingOrders(userId)]);const user = {...userBasic, ...userScore, ...userProcessingOrders};return user;</code></pre><p>這段代碼表達的就是這樣的流程：</p><div class=pgc-img><img alt=如何理解：程序、進程、線程、併發、並行、高併發？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b101e22357854a56abf29c0745b5d9c9><p class=pgc-img-caption></p></div><p>如果把一個併發任務以函數的方式去寫就剛好把函數式編程（FP）與併發編程結合起來，就容易得到寫起來很舒服，並且有利於並行執行的代碼。這也是為什麼很多FP語言都天然很適合做併發程序設計的原因。</p><h2 class=pgc-h-arrow-right>知道了這些如何做事</h2><p>我們做事的最終目標是1）能夠得到正確的結果；2）能夠儘量高效。高效有兩個手段：一是優化做事的辦法，這相當於改進算法，比如排序用快排而不是冒泡排序，這一點本文就不贅述了；另外一種方式就是讓多個worker【並行】幹。而為了【並行】，必須先得找到一個【併發】的方案。</p><p>我把這個思路的流程畫成一張圖供大家參考。</p><div class=pgc-img><img alt=如何理解：程序、進程、線程、併發、並行、高併發？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0aab8ac28c974b1b87a01d8ca84f18f3><p class=pgc-img-caption></p></div><p>如果你理解了我在說什麼就會發現，不管是寫程序還是做任何事情，關鍵點<strong>是想到一個好的做事辦法，一個可以Scale的，未來如果資源足夠可以容易擴展到並行的辦法</strong>。有了這個辦法，具體怎麼實施，用什麼工具是次一級要考慮的問題。</p><h2 class=pgc-h-arrow-right>高併發</h2><p>最後再說說【高併發】。其實【高併發】的意思和前面說的【併發】的意思不止是差了一個“高”字，而是個寬泛得多的概念。【高併發】是指可以讓軟件系統在一段時間內能夠處理大量的請求。比如每秒鐘可以完成10萬個請求。這是互聯網系統的一個重要的特徵。</p><p>不像【併發】說的是“處理”，【並行】說的是“執行”，【高併發】說的是<strong>最終效果</strong>。只要能達到效果，不管怎麼實現都行。因此，極端一點【高併發】甚至並不一定需要【並行】，只要處理速度快的足夠滿足要求就可以。如啟動一個nginx的【OS進程】，它只能用到一個CPU核心，也就不可能【並行】。但是他如果能每秒能處理10萬個請求，而業務需求只要求8萬個請求就可以了，那麼這個單進程的nginx本身就算【高併發】了。</p><blockquote><p>有時我面試別人的時候，對方簡歷上寫做過高併發。仔細一問才發現只不過使用了nginx或者redis這種性能表現很好的系統實現功能。其實並沒有做什麼困難的工作。這樣的同學寫簡歷時一定要慎重，吹水是沒有好結果滴。</p></blockquote><p>當然，現實當中【高併發】的要求會相當“高“（雙十一都刷過吧），說的也是完整的業務流程請求，而非簡單的HTTP轉發。這樣的系統大量應用各種【併發】的集中人類智慧的各種方法，並儘可能的【並行】。</p><p>除了【併發】和【並行】，【高併發】還需要：</p><ul><li>數據表普遍被分庫分表，否則單機放不下，或者查詢性能不足</li><li>解決分佈式事務</li><li>因為機器都可能壞，為了保證少數機器壞掉不會影響處理的性能，必須引入HA機制</li><li>因為系統都有極限，超過極限響應能力就會急劇下降。因此必須引入限流的方案來保護系統</li><li>這麼複雜的系統會涉及到N個service，N個存儲，N個隊列…… 這些資源的管理又成為了新的問題，這又需要對集群和服務做管理</li><li>這麼多服務，肯定要解決分佈式的Tracing和報警問題</li><li>……</li></ul><p>當面試的時候提起【高併發】，大概率是希望面試者聊聊上面這些主題。但請特別特別留意，不同領域的【高併發】實際的意思（怎麼算“高”，如何達成，哪些問題是關鍵問題）會非常不同。電商的高併發，抖音的高併發，12306賣火車票的高併發，基金交易系統的高併發，海量數據處理的高併發，這些問題其實都很不同。所以我很建議每次都討論具體的問題，而非泛泛談論【高併發】這個名詞。</p><h2 class=pgc-h-arrow-right>商業世界的高併發</h2><p>拓展一下，從商業上考慮【高併發】，其實際的意思是“<strong>用儘可能少的資源實現足夠滿足需要的併發請求數量，以形成競爭優勢</strong>“。能用有限資源短時間內處理大量請求，也就意味著：</p><p>1）單個請求處理成本的降低。比如傳統企業處理一單交易成本是10元，而互聯網企業壓低到了0.1元。這就形成了“規模經濟下的低成本結構“，是一種碾壓式的競爭優勢。</p><p>2）提高轉化效率。為了獲客，市場部門都會拼命做如做拼團、發紅包的工作。假設兩家公司花同樣的預算做獲客。公司A的下單系統只能支持1000單/s；而B公司能做到成本不比A公司多很多的情況下實現10000單/s，那麼過一段時間，A公司將被徹底打垮。如果你是老闆，並且對用戶需求很有信息，你會玩命砸技術投入，避免系統成為商業閉環的瓶頸（如果發生了，真坑啊）。</p><p>這也就是為啥有些公司突然火起來，然後玩命招技術人員。而做技術的同學能夠有工作機會的原因。</p><div class=pgc-img><img alt=如何理解：程序、進程、線程、併發、並行、高併發？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c1be4badd3b2468394bc8ee3f352f72a><p class=pgc-img-caption></p></div><p>但如果【高併發】並非是一個公司的商業閉環的關鍵問題。公司的商業價值是建立在客戶關係之類的事情上，或者單筆交易金額比較大，沒必要搞很多用戶（比如賣保險）。就沒有必要在技術上投入大量資源了。相反，聘請許多好的銷售，公關人員才是更重要的。我想你一定看過房產中介公司每天早上喊口號對吧。因此，想要在技術上精進的同學最好也要避免去那些公司。不管在哪裡做事情，一定要保證自己做的<strong>直接和商業價值掛鉤的事情</strong>才能有更多機會成長。</p><h2 class=pgc-h-arrow-right>恭喜你</h2><p>恭喜你看到這裡，因為你已經打敗了世界上99%的用戶。非常高興你沒有被講懵逼。但為了驗證一下你到底懂沒懂，我這裡有個問題，請不要打我：）</p><p>本文中到底提到了哪幾種Process？分別都是什麼意思？</p><p><br></p><p>答案：共3種</p><ul><li>表示“做事方法”</li><li>操作系統裡表示程序執行實例</li><li>Erlang語言中的併發單元，彼此相互隔離，又俗稱“Actor”</li></ul><li><strong>另外還有一些關於c++ Linux後臺服務器開發的一些知識點分享：Linux，Nginx，MySQL，Redis，P2P，K8S，Docker，TCP/IP，協程，DPDK，webrtc，音視頻等等視頻。</strong></li><h1 class=pgc-h-arrow-right>喜歡的朋友可以後臺私信【1】獲取學習視頻</h1><p><strong>附上一份c++ Linux後臺服務器開發 學習課程大綱給大家</strong></p><p><br></p><div class=pgc-img><img alt=如何理解：程序、進程、線程、併發、並行、高併發？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/250dd8ddb3c244f8b68182fd5720135f><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>進程</a></li><li><a>線程</a></li><li><a>並行</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b97e222b.html alt=進程、線程、並行與併發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5e04293de8fb49f19388e78a9812cce4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b97e222b.html title=進程、線程、並行與併發>進程、線程、並行與併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9911d0f.html alt=程序，進程，線程與併發和並行設計實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/165d54ca-9361-4365-9d4b-12a56bebfc33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9911d0f.html title=程序，進程，線程與併發和並行設計實現>程序，進程，線程與併發和並行設計實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html alt="PHP 線程，進程和併發" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7a700a857098411d884a928d6b5f5e01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html title="PHP 線程，進程和併發">PHP 線程，進程和併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html alt=一文讀懂什麼是進程、線程、協程（建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6ba8b142-925e-418e-b20c-71e8f3c20663 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html title=一文讀懂什麼是進程、線程、協程（建議收藏）>一文讀懂什麼是進程、線程、協程（建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html alt=併發最基本要理解的進程、線程、協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f756a3627164d4f93883dd7c0e0bac5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html title=併發最基本要理解的進程、線程、協程>併發最基本要理解的進程、線程、協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf2fb099.html alt=看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/12861a08-8f52-48c2-9b25-46df51894677 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf2fb099.html title=看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏）>看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c40a49b9.html alt=線程與進程的區別以及對多線程併發的理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/813488ac38be43b29140e4917ff1e0b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c40a49b9.html title=線程與進程的區別以及對多線程併發的理解>線程與進程的區別以及對多線程併發的理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f2bf674.html alt=進程、線程、協程的選擇與文件併發操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/622e63700f544942809d9a374757630e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f2bf674.html title=進程、線程、協程的選擇與文件併發操作>進程、線程、協程的選擇與文件併發操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fc01cfc.html alt=進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fc01cfc.html title=進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫>進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b8a6681.html alt=進程與線程的區別和併發編程要素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b8a6681.html title=進程與線程的區別和併發編程要素>進程與線程的區別和併發編程要素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24e8bf5d.html alt=那些年讓你迷惑的並行、併發、多線程、多進程、協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a92ab724f71b4c36a8fdefd01f9e087a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24e8bf5d.html title=那些年讓你迷惑的並行、併發、多線程、多進程、協程>那些年讓你迷惑的並行、併發、多線程、多進程、協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0b69a5b.html alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f41e7ed497b44b618a1df64c6aaa2295 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0b69a5b.html title=高併發和高性能系統中進程、線程、協程、隊列（如何調度的）>高併發和高性能系統中進程、線程、協程、隊列（如何調度的）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/399bf08.html alt="線程，進程，協程， 併發，並行，同步，異步概念解析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/41ca5e6e9b914e628478b8262ae96e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/399bf08.html title="線程，進程，協程， 併發，並行，同步，異步概念解析">線程，進程，協程， 併發，並行，同步，異步概念解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html alt=世界發展進程中的耀眼篇章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RCLmM9dF1KnwoT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html title=世界發展進程中的耀眼篇章>世界發展進程中的耀眼篇章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6bd6cd9.html alt=並行的繁榮與衰落：58同城，神奇不在 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S97zswJAhCdbYu style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6bd6cd9.html title=並行的繁榮與衰落：58同城，神奇不在>並行的繁榮與衰落：58同城，神奇不在</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>