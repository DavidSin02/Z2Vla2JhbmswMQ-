<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>淺談Java數據結構中的常見問題 | 极客快訊</title><meta property="og:title" content="淺談Java數據結構中的常見問題 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/af35758590d44dfeb74ae9ca0ecdd31e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e477a4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e477a4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/79e477a4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e477a4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e477a4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/79e477a4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/79e477a4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/79e477a4.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="淺談Java數據結構中的常見問題"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/79e477a4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>淺談Java數據結構中的常見問題</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1、常用數據結構</h1><p>數據結構是指相互之間存在著一種或多種關係的數據元素的集合和該集合中數據元素間的關係組成。常用的數據有：數組、棧、隊列、鏈表、樹、圖、堆、散列表。</p><ul><li>1）數組：在內存中連續存儲多個元素的結構。數組元素通過下標訪問，下標從0開始。優點：訪問速度快；缺點：數組大小固定後無法擴容，只能存儲一種類型的數據，添加刪除操作慢。適用場景：適用於需頻繁查找，對存儲空間要求不高，很少添加刪除。</li><li>2）棧：一種特殊的線性表，只可以在棧頂操作，先進後出，從棧頂放入元素叫入棧，從棧頂取出元素叫出棧。應用場景：用於實現遞歸功能，如斐波那契數列。</li><li>3）隊列：一種線性表，在列表一端添加元素，另一端取出，先進先出。使用場景：多線程阻塞隊列管理中。</li><li>4）鏈表：物理存儲單元上非連續、非順序的存儲結構，數據元素的邏輯順序是通過鏈表的指針地址實現，每個元素包含兩個結點，一個是存儲元素的數據域，一個是指向下一個結點地址的指針域。有單鏈表、雙向鏈表、循環鏈表。優點：可以任意加減元素，不需要初始化容量，添加刪除元素只需改變前後兩個元素結點的指針域即可。缺點：因為含有大量指針域，固佔用空間大，查找耗時。適用場景：數據量小，需頻繁增加刪除操作。</li><li>5）樹：由n個有限節點組成一種具有層次關係的集合。二叉樹（每個結點最多有兩個子樹，結點的度最大為2，左子樹和右子樹有順序）、紅黑樹（HashMap底層源碼）、B+樹（mysql的數據庫索引結構）</li><li>6）散列表（哈希表）：根據鍵值對來存儲訪問。</li><li>7）堆：堆中某個節點的值總是不大於或不小於其父節點的值，堆總是一棵完全二叉樹。</li><li>8）圖：由結點的有窮集合V和邊的集合E組成。</li></ul><h1 class=pgc-h-arrow-right>2、併發集合瞭解哪些？</h1><ul><li>1）併發List，包括Vector和CopyOnWriteArrayList是兩個線程安全的List，Vector讀寫操作都用了同步，CopyOnWriteArrayList在寫的時候會複製一個副本，對副本寫，寫完用副本替換原值，讀時不需要同步。</li><li>2）併發Set，CopyOnWriteArraySet基於CopyOnWriteArrayList來實現的，不允許存在重複的對象。</li><li>3）併發Map，ConcurrentHashMap，內部實現了鎖分離，get操作是無鎖的。</li><li>4）併發Queue，ConcurrentLinkedQueue適用於高併發場景下的隊列，通過無鎖方式實現。 BlockingQueue阻塞隊列，應用場景，生產者-消費者模式，若生產快於消費，生產隊列裝滿時會阻塞，等待消費。</li><li>5）併發Deque, LinkedBlockingDueue沒有進行讀寫鎖分離，同一時間只能有一個線程對其操作。</li><li>6）併發鎖重入鎖ReentrantLock，互斥鎖，一次最多隻能一個線程拿到鎖。</li><li>7）讀寫鎖ReadWriteLock，有讀取和寫入鎖兩種，讀取允許多個讀取線程同時持有，而寫入只能有一個線程持有。</li></ul><h1 class=pgc-h-arrow-right>3、列舉java的集合以及集合之間的繼承關係</h1><p><strong>1.單列表</strong></p><div class=pgc-img><img alt=淺談Java數據結構中的常見問題 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/af35758590d44dfeb74ae9ca0ecdd31e><p class=pgc-img-caption></p></div><p><strong>2.雙列表</strong></p><div class=pgc-img><img alt=淺談Java數據結構中的常見問題 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c5cc280dd5a347ca852fdcfc9af0ab74><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>4、容器類介紹以及之間的區別</h1><ul><li>1）Collection接口：集合框架的根接口，它是集合類框架中最具一般性的頂層接口。</li><li>2）Map接口：提供了鍵值對的映射關係的集合，關鍵字不能有重複值，每個關鍵字至多可映射一個值。HashMap(通過散列機制，用於快速訪問)，TreeMap（保持key處於排序狀態，訪問速度不如hashmap）, LinkedHashMap(保持元素的插入順序)</li><li>3）Set接口：不能包含重複的元素，LinkedHashSet TreeSet(用紅黑樹來存儲元素) HashSet</li><li>4）List接口:可通過索引對元素進行精準的插入和查找，實現類有ArrayList LinkedList</li><li>5）Queue接口：繼承自Collection接口，LinkedList實現了Queue接口，提供了支持隊列的行為。</li><li>6）Iterator接口：為了迭代集合</li><li>7）Comparable接口：用於比較</li></ul><h1 class=pgc-h-arrow-right>5、List,Set,Map的區別</h1><ul><li>Set是一個無序的集合，不能包含重複的元素；</li><li>list是一個有序的集合可以包含重複的元素，提供了按索引訪問的方式；</li><li>map包含了key-value對，map中key必須唯一，value可以重複。</li></ul><h1 class=pgc-h-arrow-right>6、HashMap的實現原理</h1><ul><li>1）數據結構 jdk1.7及以前，HashMap由數組+鏈表組成，數組Entry是HashMap的主體，Entry是HashMap中的一個靜態內部類，每一個Entry包含一個key-value鍵值對，鏈表是為解決哈希衝突而存在。 從jdk1.8起，HashMap是由數組+鏈表/紅黑樹組成，當某個bucket位置的鏈表長度達到閥值8時，這個鏈表就轉變成紅黑樹。</li><li>2）HashMap是線程不安全的，存儲比較快，能接受null值，HashMap通過put(key, value)來儲存元素，通過get(key)來得到value值，通過hash算法來計算hashcode值，用hashcode標識Entry在bucket中存儲的位置。</li><li>3）HashMap中為什麼要使用加載因子，為什麼要進行擴容 加載因子是指當HashMap中存儲的元素/最大空間值的閥值，如果超過這個值，就會進行擴容。加載因子是為了讓空間得到充分利用，如果加載因子太大，雖對空間利用更充分，但查找效率會降低；如果加載因子太小，表中的數據過於稀疏，很多空間還沒用就開始擴容，就會對空間造成浪費。 至於為什麼要擴容，如果不擴容，HashMap中數組處的鏈表會越來越長，這樣查找效率就會大大降低。</li></ul><h1 class=pgc-h-arrow-right>6.1 HashMap如何put數據（從HashMap源碼角度講解）？</h1><p>當我們使用put(key, value)存儲對象到HashMap中時，具體實現步驟如下：</p><ul><li>1）先判斷table數組是否為空，為空以默認大小構建table，table默認空間大小為16</li><li>2）計算key的hash值，並計算hash&(n-1)值得到在數組中的位置index，如果該位置沒值即table[index]為空，則直接將該鍵值對存放在table[index]處。</li><li>3）如果table[index]處不為空，說明發生了hash衝突，判斷table[index]處結點是否是TreeNode(紅黑樹結點)類型數據，如果是則執行putTreeVal方法，按紅黑樹規則將鍵值對存入；</li><li>4）如果table[index]是鏈表形式，遍歷該鏈表上的數據，將該鍵值對放在table[index]處，並將其指向原index處的鏈表。判斷鏈表上的結點數是否大於鏈表最大結點限制（默認為8），如果超過了需執行treeifyBin()操作，則要將該鏈表轉換成紅黑樹結構。</li><li>5）判斷HashMap中數據個數是否超過了（最大容量*裝載因子），如果超過了，還需要對其進行擴容操作。</li></ul><h1 class=pgc-h-arrow-right>6.2 HashMap如何get數據？</h1><p>get(key)方法獲取key的hash值，計算hash&(n-1)得到在鏈表數組中的位置first=table[hash&(n-1)]，先判斷first（即數組中的那個）的key是否與參數key相等，不等的話，判斷結點是否是TreeNode類型，是則調用getTreeNode(hash, key)從二叉樹中查找結點，不是TreeNode類型說明還是鏈表型，就遍歷鏈表找到相同的key值返回對應的value值即可。</p><h1 class=pgc-h-arrow-right>6.3 當兩個對象的hashcode相同，即發生碰撞時，HashMap如何處理</h1><p>當兩個對象的hashcode相同，它們的bucket位置相同，hashMap會用鏈表或是紅黑樹來存儲對象。Entry類裡有一個next屬性，作用是指向下一個Entry。第一個鍵值對A進來，通過計算其key的hash得到index，記做Entry[index]=A。一會又進來一個鍵值對B，通過計算其key的hash也是index，HashMap會將B.next=A, Entry[index]=B.如果又進來C，其key的hash也是index,會將C.next=B, Entry[index]=C.這樣bucket為index的地方存放了A\B\C三個鍵值對，它們能過next屬性鏈在一起。數組中存儲的是最後插入的元素，其他元素都在後面的鏈表裡。</p><h1 class=pgc-h-arrow-right>6.4 如果兩個鍵的hashcode相同，如何獲取值對象？</h1><p>當調用get方法時，hashmap會使用鍵對象的hashcode找到bucket位置，找到bucket位置後，會調用key.equals()方法去找到鏈表中正確的節點，最終找到值對象。</p><h1 class=pgc-h-arrow-right>6.5 hashMap如何擴容</h1><p>HashMap默認負載因為是0.75，當一個map填滿了75%的bucket時，和其他集合類一樣，將會創建原來HashMap大小兩倍的bucket數組，來重新調整HashMap的大小，並將原來的對象放入新的bucket數組中。 在jdk1.7及以前，多線程擴容可能出現死循環。因為在調整大小過程中，存儲在某個bucket位置中的鏈表元素次序會反過來，而多線程情況下可能某個線程翻轉完鏈表，另外一個線程又開始翻轉，條件競爭發生了，那麼就死循環了。 而在jdk1.8中，會將原來鏈表結構保存至節點e中，將原來數組中的位置設為null，然後依次遍歷e，根據hash&n是否為0分成兩條支鏈，保存在新數組中。如果多線程情況可能會取到null值造成數據丟失。</p><h1 class=pgc-h-arrow-right>7、ConcurrentHashMap的實現原理</h1><ul><li>1）jdk1.7及以前：一個ConcurrentHashMap由一個segment數組和多個HashEntry組成，每一個segment都包含一個HashEntry數組, Segment繼承ReentrantLock用來充當鎖角色，每一個segment包含了對自己的HashEntry的操作，如get\put\replace操作，這些操作發生時，對自己的HashEntry進行鎖定。由於每一個segment寫操作只鎖定自己的HashEntry，可以存在多個線程同時寫的情況。 jdk1.8以後：ConcurrentHashMap取消了segments字段，採用transient volatile HashEntry table保存數據，採用table數組元素作為鎖，實現對每一個數組數據進行加鎖，進一步減少併發衝突概率。ConcurrentHashMap是用Node數組+鏈表+紅黑樹數據結構來實現的，併發制定用synchronized和CAS操作。</li><li>2）Segment實現了ReentrantLock重入鎖，當執行put操作，會進行第一次key的hash來定位Segment的位置，若該Segment還沒有初始化，會通過CAS操作進行賦值，再進行第二次hash操作，找到相應的HashEntry位置。</li></ul><h1 class=pgc-h-arrow-right>8、ArrayMap和HashMap的對比</h1><ul><li>1)存儲方式不一樣，HashMap內部有一個Node[]對象，每個鍵值對都會存儲到這個對象裡，當用put方法添加鍵值對時，會new一個Node對象，tab[i] = newNode(hash, key, value, next); ArrayMap存儲則是由兩個數組來維護，int[] mHashes; Object[] mArray; mHashes數組中保存的是每一項的HashCode值，mArray存的是鍵值對，每兩個元素代表一個鍵值對，前面保存key，後面保存value。mHashes[index]=hash; mArray[index&lt;&lt;1]=key; mArray[(index&lt;&lt;1)+1]=value; ArrayMap相對於HashMap，無需為每個鍵值對創建Node對象，且在數組中連續存放，更省空間。</li><li>2）添加數據時擴容處理不一樣，進行了new操作，重新創建對象，開銷很大；而ArrayMap用的是copy數據，所有效率相對高些；</li><li>3）ArrayMap提供了數組收縮功能，在clear或remove後，會重新收縮數組，釋放空間；</li><li>4）ArrayMap採用二分法查找，mHashes中的hash值是按照從小到大的順序連續存放的，通過二分查找來獲取對應hash下標index，去mArray中查找鍵值對。mHashes中的index2是mArray中的key下標，index2+1為value的下標，由於存在hash碰撞情況，二分查找到的下標可能是多個連續相同的hash值中的任意一個，此時需要用equals比對命中的key對象是否相等，不相等，應當從當前index先向後再向前遍歷所有相同hash值。</li><li>5）sparseArray比ArrayMap進一步優化空間，SparseArray專門對基本類型做了優化，Key只能是可排序的基本類型，如int\long，對value，除了泛型Value，還對每種基本類型有單獨實現，如SparseBooleanArray\SparseLongArray等。無需包裝，直接使用基本類型值，無需hash，直接使用基本類型值索引和判斷相等，無碰撞，無需調用hashCode方法，無需equals比較。SparseArray延遲刪除。</li></ul><h1 class=pgc-h-arrow-right>9、HashTable實現原理</h1><p>Hashtable中的無參構造方法Hashtable()中調用了this(11, 0.75f)，說明它默認容量是11，加載因子是0.75,在構造方法上會new HashtableEntry[initialCapacity]; 會新建一個容量是初始容量的HashtableEntry數組。HashtableEntry數組中包含hash\Key\Value\next變量，鏈表形式，重寫了hashCode和equals方法。Hashtable所有public方法都在方法體上加上了synchronized鎖操作，說明它是線程安全的。它還實現了Serializable接口中的writeObject和readObject方法，分別實現了逐行讀取和寫入的功能，並且加了synchronized鎖操作。</p><h1 class=pgc-h-arrow-right>（1） put(Key, Value)方法</h1><ul><li>1）先判斷value是否為空，為空拋出空指針異常；</li><li>2）根據key的hashCode()值，計算table表中的位置索引(hash&0x7FFFFFFF)%tab.length值index，如果該索引處有值，再判斷該索引處鏈表中是否包含相同的key，如果key值相同則替換舊值。</li><li>3）如果沒有相同的key值，調用addEntry方法，在addEntry中判斷count大小是否超過了最大容量限制，如果超過了需要重新rehash()，容量變成原來容量*2+1，將原表中的值都重新計算hash值放入新表中。再構造一個HashtableEntry對象放入相應的table表頭，如果原索引處有值，則將table[index].next指向原索引處的鏈表。</li></ul><h1 class=pgc-h-arrow-right>（2）get方法</h1><p>根據key.hashCode()，計算它在table表中的位置，(hash&0x7FFFFFFF)%tab.length，遍歷該索引處表的位置中是否有值，是否存在鏈表，再判斷是key值和hash值是否相等，相等則返回對應的value值。</p><h1 class=pgc-h-arrow-right>10、HashMap和HashTable的區別</h1><ul><li>1）Hashtable是個線程安全的類，在對外方法都添加了synchronized方法，序列化方法上也添加了synchronized同步鎖方法，而HashMap非線程安全。這也導致Hashtable的讀寫等操作比HashMap慢。</li><li>2）Hashtable不允許值和鍵為空，若為空會拋出空指針。而HashMap允許鍵和值為空；</li><li>3）Hashtable根據key值的hashCode計算索引，(hash&0x7FFFFFFF)%tab.length，保證hash值始終為正數且不超過表的長度。而HashMap中計算索引值是通過hash(key)&(tab.length-1)，是通過與操作，計算出在表中的位置會比Hashtable快。</li><li>4）Hashtable容量能為任意大於等於1的正數，而HashMap的容量必須為2^n，Hashtable默認容量為11，HashMap初始容量為16</li><li>5）Hashtable每次擴容，新容量為舊容量的2倍+1，而HashMap為舊容量的2倍。</li></ul><h1 class=pgc-h-arrow-right>11、HashMap與HashSet的區別</h1><p>HashSet底層實現是HashMap,內部包含一個HashMap map變量 private transient HashMap map; 一個Object PRESENT變量（當成插入map中的value值） private static final Object PRESENT = new Object(); HashSet中元素都存到HashMap鍵值對的Key上面。具體可以查看HashSet的add方法，直接調用了HashMap的put方法，將值作為HashMap的鍵，值用一個固定的PRESENT值。</p><pre><code>public boolean add(E e) {    return map.put(e, PRESENT)==null;}</code></pre><p>HashSet沒有單獨的get方法，用的是HashMap的。HashSet實現了Set接口，不允許集合中出現重複元素，將對象存儲進HashSet前，要先確保對象重寫了hashCode()和equals方法，以保證放入set對象是唯一的。</p><h1 class=pgc-h-arrow-right>12、HashSet與HashMap怎麼判斷集合元素重複？</h1><p>HashMap在放入key-value鍵值對是，先通過key計算其hashCode()值，再與tab.length-1做與操作，確定下標index處是否有值，如果有值，再調用key對象的equals方法，對象不同則插入到表頭，相同則覆蓋； HashSet是將數據存放到HashMap的key中，HashMap是key-value形式的數據結構，它的key是唯一的，HashSet利用此原理保證放入的對象唯一性。</p><h1 class=pgc-h-arrow-right>13、集合Set實現Hash怎麼防止碰撞</h1><p>HashSet底層實現是HashMap，HashMap如果兩個不同Key對象的hashCode()值相等，會用鏈表存儲，HashSet也一樣。</p><h1 class=pgc-h-arrow-right>14、ArrayList和LinkedList的區別，以及應用場景</h1><p>ArrayList底層是用數組實現的，隨著元素添加，其大小是動態增大的；在內存中是連續存放的；如果在集合末尾添加或刪除元素，所用時間是一致的，如果在列表中間添加或刪除元素，所用時間會大大增加。通過索引查找元素速度很快。適合場合：查詢比較多的場景 LinkedList底層是通過雙向鏈表實現的，LinkedList和ArrayList相比，增刪速度快，但查詢和修改值速度慢。在內存中不是連續內存。場景：增刪操作比較多的場景。</p><h1 class=pgc-h-arrow-right>15.其他</h1><ul><li>-二叉樹的深度優先遍歷和廣度優先遍歷的具體實現</li><li>-堆的結構</li><li>-堆和樹的區別</li><li>-堆和棧在內存中的區別是什麼</li><li>-什麼是深拷貝和淺拷貝</li><li>-手寫鏈表逆序代碼</li><li>-講一下對樹，B+樹的理解</li><li>-講一下對圖的理解</li><li>-判斷單鏈表成環與否？</li><li>-鏈表翻轉（即：翻轉一個單項鍊表）</li><li>-合併多個單有序鏈表（假設都是遞增的）</li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>淺談</a></li><li><a>Java</a></li><li><a>數據</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ff833c65.html alt=淺談java數據類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/53f20000214b460fad28 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ff833c65.html title=淺談java數據類型>淺談java數據類型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8061eff7.html alt=Java核心數據結構(List、Map、Set)原理與使用技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ca0269a1e4e94f69a8f725a31086a788 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8061eff7.html title=Java核心數據結構(List、Map、Set)原理與使用技巧>Java核心數據結構(List、Map、Set)原理與使用技巧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9053d9.html alt=淺談測風數據處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0c47d1a5ab394480a9c3040a18c37f52 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9053d9.html title=淺談測風數據處理>淺談測風數據處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0666c6c.html alt="Java 爬蟲遇上數據異步加載，試試這兩種辦法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/0266a8bc-3efe-4aa5-b440-93ca1a81ee2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0666c6c.html title="Java 爬蟲遇上數據異步加載，試試這兩種辦法">Java 爬蟲遇上數據異步加載，試試這兩種辦法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c705a95.html alt=淺談無人機傾斜攝影測量技術標準 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/433b0001f1761786a418 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c705a95.html title=淺談無人機傾斜攝影測量技術標準>淺談無人機傾斜攝影測量技術標準</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32b07cdf.html alt=淺談虛擬現實技術在實際中的應用是什麼？你的看法是？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/320e000488d3da066723 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32b07cdf.html title=淺談虛擬現實技術在實際中的應用是什麼？你的看法是？>淺談虛擬現實技術在實際中的應用是什麼？你的看法是？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>