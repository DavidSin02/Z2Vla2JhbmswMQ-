<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java後端架構師技術圖譜，你都瞭解多少？ | 极客快訊</title><meta property="og:title" content="Java後端架構師技術圖譜，你都瞭解多少？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1d4f02c014074d2bbe2de0630f061e94"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a6c83a4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a6c83a4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7a6c83a4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a6c83a4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a6c83a4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7a6c83a4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7a6c83a4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a6c83a4.html><meta property="article:published_time" content="2020-11-14T20:55:07+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:07+08:00"><meta name=Keywords content><meta name=description content="Java後端架構師技術圖譜，你都瞭解多少？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7a6c83a4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java後端架構師技術圖譜，你都瞭解多少？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>前言</h1><p>歡迎工作一到五年的Java工程師朋友們加入我們，私信回覆【資料】即可獲取我們提供免費的Java架構學習資料（裡面有高可用、高併發、高性能及分佈式、Jvm性能調優、Spring源碼，</p><p>MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多個知識點的架構資料）</p><p>合理利用自己每一分每一秒的時間來學習提升自己，不要再用"沒有時間“來掩飾自己思想上的懶惰！趁年輕，使勁拼，給未來的自己一個交代！</p><h1>數據結構</h1><p><strong>隊列</strong></p><ul><li>《java隊列——queue詳細分析》</li><li class=ql-indent-1>非阻塞隊列：ConcurrentLinkedQueue(無界線程安全)，採用CAS機制（compareAndSwapObject原子操作）。</li><li class=ql-indent-1>阻塞隊列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（無界）、DelayQueue、PriorityBlockingQueue，採用鎖機制；使用 ReentrantLock 鎖。</li><li>《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue對比分析》</li></ul><p><strong>集合</strong></p><ul><li>《Java Set集合的詳解》</li></ul><p><strong>鏈表、數組</strong></p><ul><li>《Java集合詳解--什麼是List》</li></ul><p><strong>字典、關聯數組</strong></p><ul><li>《Java map 詳解 - 用法、遍歷、排序、常用API等》</li></ul><p><strong>棧</strong></p><ul><li>《java數據結構與算法之棧（Stack）設計與實現》</li><li>《Java Stack 類》</li><li>《java stack的詳細實現分析》</li><li class=ql-indent-1>Stack 是線程安全的。</li><li class=ql-indent-1>內部使用數組保存數據，不夠時翻倍。</li></ul><p><strong>樹</strong></p><p><strong>二叉樹</strong></p><p><strong>每個節點最多有兩個葉子節點。</strong></p><ul><li>《二叉樹》</li></ul><p><strong>完全二叉樹</strong></p><ul><li>《完全二叉樹》</li><li class=ql-indent-1>葉節點只能出現在最下層和次下層，並且最下面一層的結點都集中在該層最左邊的若干位置的二叉樹。</li></ul><p><strong>平衡二叉樹</strong></p><p>左右兩個子樹的高度差的絕對值不超過1，並且左右兩個子樹都是一棵平衡二叉樹。</p><ul><li>《淺談數據結構-平衡二叉樹》</li><li>《淺談算法和數據結構: 八 平衡查找樹之2-3樹》</li></ul><p><strong>二叉查找樹（BST）</strong></p><p>二叉查找樹（Binary Search Tree），也稱有序二叉樹（ordered binary tree）,排序二叉樹（sorted binary tree）。</p><ul><li>《淺談算法和數據結構: 七 二叉查找樹》</li></ul><h1><strong>紅黑樹</strong></h1><ul><li>《最容易懂得紅黑樹》</li><li class=ql-indent-1>添加階段後，左旋或者右旋從而再次達到平衡。</li><li>《淺談算法和數據結構: 九 平衡查找樹之紅黑樹》</li></ul><p><strong>B，B+，B*樹</strong></p><p>MySQL是基於B+樹聚集索引組織表</p><ul><li>《B-樹，B+樹，B*樹詳解》</li><li>《B-樹，B+樹與B*樹的優缺點比較》</li><li class=ql-indent-1>B+樹的葉子節點鏈表結構相比於 B-樹便於掃庫，和範圍檢索。</li></ul><p><strong>LSM 樹</strong></p><p>LSM（Log-Structured Merge-Trees）和 B+ 樹相比，是犧牲了部分讀的性能來換取寫的性能(通過批量寫入)，實現讀寫之間的。 Hbase、LevelDB、Tair（Long DB）、nessDB 採用 LSM 樹的結構。LSM可以快速建立索引。</p><ul><li><strong>《LSM樹 VS B+樹》</strong></li><li class=ql-indent-1>B+ 樹讀性能好，但由於需要有序結構，當key比較分散時，磁盤尋道頻繁，造成寫性能。</li><li class=ql-indent-1>LSM 是將一個大樹拆分成N棵小樹，先寫到內存（無尋道問題，性能高），在內存中構建一顆有序小樹（有序樹），隨著小樹越來越大，內存的小樹會flush到磁盤上。當讀時，由於不知道數據在哪棵小樹上，因此必須遍歷（二分查找）所有的小樹，但在每顆小樹內部數據是有序的。</li><li><strong>《LSM樹（Log-Structured Merge Tree）存儲引擎》</strong></li><li class=ql-indent-1>極端的說，基於LSM樹實現的HBase的寫性能比MySQL高了一個數量級，讀性能低了一個數量級。</li><li class=ql-indent-1>優化方式：Bloom filter 替代二分查找；compact 小數位大樹，提高查詢性能。</li><li class=ql-indent-1>Hbase 中，內存中達到一定閾值後，整體flush到磁盤上、形成一個文件（B+數），HDFS不支持update操作，所以Hbase做整體flush而不是merge update。flush到磁盤上的小樹，定期會合併成一個大樹。</li></ul><p><strong>BitSet</strong></p><p>經常用於大規模數據的排重檢查。</p><ul><li>《Java Bitset類》</li><li>《Java BitSet（位集）》</li></ul><h1><br></h1><h1>常用算法</h1><ul><li>《常見排序算法及對應的時間複雜度和空間複雜度》</li></ul><p><strong>排序、查找算法</strong></p><ul><li>《常見排序算法及對應的時間複雜度和空間複雜度》</li></ul><p><strong>選擇排序</strong></p><ul><li>《Java中的經典算法之選擇排序（SelectionSort）》</li><li class=ql-indent-1>每一趟從待排序的記錄中選出最小的元素，順序放在已排好序的序列最後，直到全部記錄排序完畢。</li></ul><p><strong>冒泡排序</strong></p><ul><li>《冒泡排序的2種寫法》</li><li class=ql-indent-1>相鄰元素前後交換、把最大的排到最後。</li><li class=ql-indent-1>時間複雜度 O(n²)</li></ul><p><strong>插入排序</strong></p><ul><li>《排序算法總結之插入排序》</li></ul><p><strong>快速排序</strong></p><ul><li>《坐在馬桶上看算法：快速排序》</li><li class=ql-indent-1>一側比另外一次都大或小。</li></ul><p><strong>歸併排序</strong></p><ul><li>《圖解排序算法(四)之歸併排序》</li><li class=ql-indent-1>分而治之，分成小份排序，在合併(重建一個新空間進行復制)。</li></ul><p><strong>希爾排序</strong></p><p>TODO</p><p><strong>堆排序</strong></p><ul><li>《圖解排序算法(三)之堆排序》</li><li class=ql-indent-1>排序過程就是構建最大堆的過程，最大堆：每個結點的值都大於或等於其左右孩子結點的值，堆頂元素是最大值。</li></ul><p><strong>計數排序</strong></p><ul><li>《計數排序和桶排序》</li><li class=ql-indent-1>和桶排序過程比較像，差別在於桶的數量。</li></ul><p><strong>桶排序</strong></p><ul><li>《【啊哈！算法】最快最簡單的排序——桶排序》</li><li>《排序算法（三）：計數排序與桶排序》</li><li class=ql-indent-1>桶排序將[0,1)區間劃分為n個相同的大小的子區間，這些子區間被稱為桶。</li><li class=ql-indent-1>每個桶單獨進行排序，然後再遍歷每個桶。</li></ul><p><strong>基數排序</strong></p><p>按照個位、十位、百位、...依次來排。</p><ul><li>《排序算法系列：基數排序》</li><li>《基數排序》</li></ul><p><strong>二分查找</strong></p><ul><li>《二分查找(java實現)》</li><li class=ql-indent-1>要求待查找的序列有序。</li><li class=ql-indent-1>時間複雜度 O(logN)。</li><li>《java實現二分查找-兩種方式》</li><li class=ql-indent-1>while + 遞歸。</li></ul><p><strong>Java 中的排序工具</strong></p><ul><li>《Arrays.sort和Collections.sort實現原理解析》</li><li class=ql-indent-1>Collections.sort算法調用的是合併排序。</li><li class=ql-indent-1>Arrays.sort() 採用了2種排序算法 -- 基本類型數據使用快速排序法，對象數組使用歸併排序。</li></ul><p><strong>布隆過濾器</strong></p><p>常用於大數據的排重，比如email，url 等。 核心原理：將每條數據通過計算產生一個指紋（一個字節或多個字節，但一定比原始數據要少很多），其中每一位都是通過隨機計算獲得，在將指紋映射到一個大的按位存儲的空間中。注意：會有一定的錯誤率。 優點：空間和時間效率都很高。 缺點：隨著存入的元素數量增加，誤算率隨之增加。</p><ul><li>《布隆過濾器 -- 空間效率很高的數據結構》</li><li>《大量數據去重：Bitmap和布隆過濾器(Bloom Filter)》</li><li>《基於Redis的布隆過濾器的實現》</li><li class=ql-indent-1>基於 Redis 的 Bitmap 數據結構。</li><li>《網絡爬蟲：URL去重策略之布隆過濾器(BloomFilter)的使用》</li><li class=ql-indent-1>使用Java中的 BitSet 類 和 加權和hash算法。</li></ul><p><strong>字符串比較</strong></p><p><strong>KMP 算法</strong></p><p>KMP：Knuth-Morris-Pratt算法（簡稱KMP） 核心原理是利用一個“部分匹配表”，跳過已經匹配過的元素。</p><ul><li>《字符串匹配的KMP算法》</li></ul><p><strong>深度優先、廣度優先</strong></p><ul><li>《廣度優先搜索BFS和深度優先搜索DFS》</li></ul><p><strong>貪心算法</strong></p><ul><li>《算法：貪婪算法基礎》</li><li>《常見算法及問題場景——貪心算法》</li></ul><p><strong>回溯算法</strong></p><ul><li>《 五大常用算法之四：回溯法》</li></ul><p><strong>剪枝算法</strong></p><ul><li>《α-β剪枝算法》</li></ul><p><strong>動態規劃</strong></p><ul><li>《詳解動態規劃——鄒博講動態規劃》</li><li>《動態規劃算法的個人理解》</li></ul><p><strong>樸素貝葉斯</strong></p><ul><li>《帶你搞懂樸素貝葉斯分類算法》</li><li class=ql-indent-1>P(B|A)=P(A|B)P(B)/P(A)</li><li>《貝葉斯推斷及其互聯網應用1》</li><li>《貝葉斯推斷及其互聯網應用2》</li></ul><p><strong>推薦算法</strong></p><ul><li>《推薦算法綜述》</li><li>《TOP 10 開源的推薦系統簡介》</li></ul><p><strong>最小生成樹算法</strong></p><ul><li>《算法導論--最小生成樹（Kruskal和Prim算法）》</li></ul><p><strong>最短路徑算法</strong></p><ul><li>《Dijkstra算法詳解》</li></ul><h1>併發</h1><p><strong>Java 併發</strong></p><ul><li>Java 併發知識合集</li><li>JAVA併發知識圖譜</li></ul><p><strong>多線程</strong></p><ul><li>《40個Java多線程問題總結》</li></ul><p><strong>線程安全</strong></p><ul><li>《Java併發編程——線程安全及解決機制簡介》</li></ul><h1><strong>一致性、事務</strong></h1><p><strong>事務 ACID 特性</strong></p><ul><li>《數據庫事務ACID特性》</li></ul><p><strong>事務的隔離級別</strong></p><ul><li>未提交讀：一個事務可以讀取另一個未提交的數據，容易出現髒讀的情況。</li><li>讀提交：一個事務等另外一個事務提交之後才可以讀取數據，但會出現不可重複讀的情況（多次讀取的數據不一致），讀取過程中出現UPDATE操作，會多。（大多數數據庫默認級別是RC，比如SQL Server，Oracle），讀取的時候不可以修改。</li><li>可重複讀： 同一個事務裡確保每次讀取的時候，獲得的是同樣的數據，但不保障原始數據被其他事務更新（幻讀），Mysql InnoDB 就是這個級別。</li><li>序列化：所有事物串行處理（犧牲了效率）</li><li>《理解事務的4種隔離級別》</li><li>數據庫事務的四大特性及事務隔離級別</li><li>《MySQL的InnoDB的幻讀問題 》</li><li class=ql-indent-1>幻讀的例子非常清楚。</li><li class=ql-indent-1>通過 SELECT ... FOR UPDATE 解決。</li><li>《一篇文章帶你讀懂MySQL和InnoDB》</li><li class=ql-indent-1>圖解髒讀、不可重複讀、幻讀問題。</li></ul><p><strong>MVCC</strong></p><ul><li>《【mysql】關於innodb中MVCC的一些理解》</li><li class=ql-indent-1>innodb 中 MVCC 用在 Repeatable-Read 隔離級別。</li><li class=ql-indent-1>MVCC 會產生幻讀問題（更新時異常。）</li><li>《輕鬆理解MYSQL MVCC 實現機制》</li><li class=ql-indent-1>通過隱藏版本列來實現 MVCC 控制，一列記錄創建時間、一列記錄刪除時間，這裡的時間</li><li class=ql-indent-1>每次只操作比當前版本小（或等於）的 行。</li></ul><h1>鎖</h1><p><strong>Java中的鎖和同步類</strong></p><ul><li>《Java中的鎖分類》</li><li class=ql-indent-1>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。</li><li>《Java併發之AQS詳解》</li><li>《Java中信號量 Semaphore》</li><li class=ql-indent-1>有數量控制</li><li class=ql-indent-1>申請用 acquire，申請不要則阻塞；釋放用 release。</li><li>《java開發中的Mutex vs Semaphore》</li><li class=ql-indent-1>簡單的說 就是Mutex是排它的，只有一個可以獲取到資源， Semaphore也具有排它性，但可以定義多個可以獲取的資源的對象。</li></ul><p><strong>公平鎖 & 非公平鎖</strong></p><p>公平鎖的作用就是嚴格按照線程啟動的順序來執行的，不允許其他線程插隊執行的；而非公平鎖是允許插隊的。</p><ul><li>《公平鎖與非公平鎖》</li><li class=ql-indent-1>默認情況下 ReentrantLock 和 synchronized 都是非公平鎖。ReentrantLock 可以設置成公平鎖。</li></ul><p><strong>悲觀鎖</strong></p><p>悲觀鎖如果使用不當（鎖的條數過多），會引起服務大面積等待。推薦優先使用樂觀鎖+重試。</p><ul><li>《【MySQL】悲觀鎖&樂觀鎖》</li><li class=ql-indent-1>樂觀鎖的方式：版本號+重試方式</li><li class=ql-indent-1>悲觀鎖：通過 select ... for update 進行行鎖(不可讀、不可寫，share 鎖可讀不可寫)。</li><li>《Mysql查詢語句使用select.. for update導致的數據庫死鎖分析》</li><li class=ql-indent-1>mysql的innodb存儲引擎實務鎖雖然是鎖行，但它內部是鎖索引的。</li><li class=ql-indent-1>鎖相同數據的不同索引條件可能會引起死鎖。</li><li>《Mysql併發時經典常見的死鎖原因及解決方法》</li></ul><p><strong>樂觀鎖 & CAS</strong></p><ul><li>《樂觀鎖的一種實現方式——CAS》</li><li class=ql-indent-1>和MySQL樂觀鎖方式相似，只不過是通過和原值進行比較。</li></ul><p><strong>ABA 問題</strong></p><p>由於高併發，在CAS下，更新後可能此A非彼A。通過版本號可以解決，類似於上文Mysql 中提到的的樂觀鎖。</p><ul><li>《Java CAS 和ABA問題》</li><li>《Java 中 ABA問題及避免》</li><li class=ql-indent-1>AtomicStampedReference 和 AtomicStampedReference。</li></ul><p><strong>CopyOnWrite容器</strong></p><p>可以對CopyOnWrite容器進行併發的讀，而不需要加鎖。CopyOnWrite併發容器用於讀多寫少的併發場景。比如白名單，黑名單，商品類目的訪問和更新場景，不適合需要數據強一致性的場景。</p><ul><li>《JAVA中寫時複製(Copy-On-Write)Map實現》</li><li class=ql-indent-1>實現讀寫分離，讀取發生在原始數據上，寫入發生在副本上。</li><li class=ql-indent-1>不用加鎖，通過最終一致實現一致性。</li><li>《聊聊併發-Java中的Copy-On-Write容器》</li></ul><p><strong>RingBuffer</strong></p><ul><li>《線程安全的無鎖RingBuffer的實現【一個讀線程，一個寫線程】》</li></ul><p><strong>可重入鎖 & 不可重入鎖</strong></p><ul><li>《可重入鎖和不可重入鎖》</li><li class=ql-indent-1>通過簡單代碼舉例說明可重入鎖和不可重入鎖。</li><li class=ql-indent-1>可重入鎖指同一個線程可以再次獲得之前已經獲得的鎖。</li><li class=ql-indent-1>可重入鎖可以用戶避免死鎖。</li><li class=ql-indent-1>Java中的可重入鎖：synchronized 和 java.util.concurrent.locks.ReentrantLock</li><li>《ReenTrantLock可重入鎖（和synchronized的區別）總結》</li><li class=ql-indent-1>synchronized 使用方便，編譯器來加鎖，是非公平鎖。</li><li class=ql-indent-1>ReenTrantLock 使用靈活，鎖的公平性可以定製。</li><li class=ql-indent-1>相同加鎖場景下，推薦使用 synchronized。</li></ul><p><strong>互斥鎖 & 共享鎖</strong></p><p>互斥鎖：同時只能有一個線程獲得鎖。比如，ReentrantLock 是互斥鎖，ReadWriteLock 中的寫鎖是互斥鎖。 共享鎖：可以有多個線程同時或的鎖。比如，Semaphore、CountDownLatch 是共享鎖，ReadWriteLock 中的讀鎖是共享鎖。</p><ul><li>《ReadWriteLock場景應用》</li></ul><p><strong>死鎖</strong></p><ul><li>《“死鎖”四個必要條件的合理解釋》</li><li class=ql-indent-1>互斥、持有、不可剝奪、環形等待。</li><li>Java如何查看死鎖？</li><li class=ql-indent-1>JConsole 可以識別死鎖。</li><li>java多線程系列：死鎖及檢測</li><li class=ql-indent-1>jstack 可以顯示死鎖。</li></ul><h1><br></h1><h1>操作系統</h1><p><strong>計算機原理</strong></p><ul><li>《操作系統基礎知識——操作系統的原理，類型和結構》</li></ul><p><strong>CPU</strong></p><p><strong>多級緩存</strong></p><p>典型的 CPU 有三級緩存，距離核心越近，速度越快，空間越小。L1 一般 32k，L2 一般 256k，L3 一般12M。內存速度需要200個 CPU 週期，CPU 緩存需要1個CPU週期。</p><ul><li>《從Java視角理解CPU緩存和偽共享》</li></ul><p><strong>進程</strong></p><p>TODO</p><p><strong>線程</strong></p><ul><li>《線程的生命週期及狀態轉換詳解》</li></ul><p><strong>協程</strong></p><ul><li>《終結python協程----從yield到actor模型的實現》</li><li class=ql-indent-1>線程的調度是由操作系統負責，協程調度是程序自行負責</li><li class=ql-indent-1>與線程相比，協程減少了無謂的操作系統切換.</li><li class=ql-indent-1>實際上當遇到IO操作時做切換才更有意義，（因為IO操作不用佔用CPU），如果沒遇到IO操作，按照時間片切換.</li></ul><p><strong>Linux</strong></p><ul><li>《Linux 命令大全》</li></ul><h1><br></h1><h1>設計模式</h1><p><strong>設計模式的六大原則</strong></p><ul><li>《設計模式的六大原則》</li><li class=ql-indent-1>開閉原則：對擴展開放,對修改關閉，多使用抽象類和接口。</li><li class=ql-indent-1>里氏替換原則：基類可以被子類替換，使用抽象類繼承,不使用具體類繼承。</li><li class=ql-indent-1>依賴倒轉原則：要依賴於抽象,不要依賴於具體，針對接口編程,不針對實現編程。</li><li class=ql-indent-1>接口隔離原則：使用多個隔離的接口,比使用單個接口好，建立最小的接口。</li><li class=ql-indent-1>迪米特法則：一個軟件實體應當儘可能少地與其他實體發生相互作用，通過中間類建立聯繫。</li><li class=ql-indent-1>合成複用原則：儘量使用合成/聚合,而不是使用繼承。</li></ul><p><strong>23種常見設計模式</strong></p><ul><li>《設計模式》</li><li>《23種設計模式全解析》</li><li>《設計模式類圖與示例》</li></ul><p><strong>應用場景</strong></p><ul><li>《細數JDK裡的設計模式》</li><li>結構型模式：</li><li class=ql-indent-2>適配器：用來把一個接口轉化成另一個接口，如 java.util.Arrays#asList()。</li><li class=ql-indent-2>橋接模式：這個模式將抽象和抽象操作的實現進行了解耦，這樣使得抽象和實現可以獨立地變化，如JDBC；</li><li class=ql-indent-2>組合模式：使得客戶端看來單個對象和對象的組合是同等的。換句話說，某個類型的方法同時也接受自身類型作為參數，如 Map.putAll，List.addAll、Set.addAll。</li><li class=ql-indent-2>裝飾者模式：動態的給一個對象附加額外的功能，這也是子類的一種替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li class=ql-indent-2>享元模式：使用緩存來加速大量小對象的訪問時間，如 valueOf(int)。</li><li class=ql-indent-1>代理模式：代理模式是用一個簡單的對象來代替一個複雜的或者創建耗時的對象，如 java.lang.reflect.Proxy</li><li>創建模式:</li><li class=ql-indent-2>抽象工廠模式：抽象工廠模式提供了一個協議來生成一系列的相關或者獨立的對象，而不用指定具體對象的類型，如 java.util.Calendar#getInstance()。</li><li class=ql-indent-2>建造模式(Builder)：定義了一個新的類來構建另一個類的實例，以簡化複雜對象的創建，如：java.lang.StringBuilder#append()。</li><li class=ql-indent-2>工廠方法：就是 一個返* 回具體對象的方法，而不是多個，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li class=ql-indent-2>原型模式：使得類的實例能夠生成自身的拷貝、如：java.lang.Object#clone()。</li><li class=ql-indent-1>單例模式：全局只有一個實例，如 java.lang.Runtime#getRuntime()。</li><li>行為模式：</li><li class=ql-indent-2>責任鏈模式：通過把請求從一個對象傳遞到鏈條中下一個對象的方式，直到請求被處理完畢，以實現對象間的解耦。如 javax.servlet.Filter#doFilter()。</li><li class=ql-indent-2>命令模式：將操作封裝到對象內，以便存儲，傳遞和返回，如：java.lang.Runnable。</li><li class=ql-indent-2>解釋器模式：定義了一個語言的語法，然後解析相應語法的語句，如，java.text.Format，java.text.Normalizer。</li><li class=ql-indent-2>迭代器模式：提供一個一致的方法來順序訪問集合中的對象，如 java.util.Iterator。</li><li class=ql-indent-2>中介者模式：通過使用一箇中間對象來進行消息分發以及減少類之間的直接依賴，java.lang.reflect.Method#invoke()。</li><li class=ql-indent-2>空對象模式：如 java.util.Collections#emptyList()。</li><li class=ql-indent-2>觀察者模式：它使得一個對象可以靈活的將消息發送給感興趣的對象，如 java.util.EventListener。</li><li class=ql-indent-1>模板方法模式：讓子類可以重寫方法的一部分，而不是整個重寫，如 java.util.Collections#sort()。</li><li>《Spring-涉及到的設計模式彙總》</li><li>《Mybatis使用的設計模式》</li></ul><p><strong>單例模式</strong></p><ul><li>《單例模式的三種實現 以及各自的優缺點》</li><li>《單例模式－－反射－－防止序列化破壞單例模式》</li><li class=ql-indent-1>使用枚舉類型。</li></ul><p><strong>責任鏈模式</strong></p><p>TODO</p><p><strong>MVC</strong></p><ul><li>《MVC 模式》</li><li class=ql-indent-1>模型(model)－視圖(view)－控制器(controller)</li></ul><p><strong>IOC</strong></p><ul><li>《理解 IOC》</li><li>《IOC 的理解與解釋》</li><li class=ql-indent-1>正向控制：傳統通過new的方式。反向控制，通過容器注入對象。</li><li class=ql-indent-1>作用：用於模塊解耦。</li><li class=ql-indent-1>DI：Dependency Injection，即依賴注入，只關心資源使用，不關心資源來源。</li></ul><p><strong>AOP</strong></p><ul><li>《輕鬆理解AOP(面向切面編程)》</li><li>《Spring AOP詳解》</li><li>《Spring AOP的實現原理》</li><li class=ql-indent-1>Spring AOP使用的動態代理，主要有兩種方式：JDK動態代理和CGLIB動態代理。</li><li>《Spring AOP 實現原理與 CGLIB 應用》</li><li class=ql-indent-1>Spring AOP 框架對 AOP 代理類的處理原則是：如果目標對象的實現類實現了接口，Spring AOP 將會採用 JDK 動態代理來生成 AOP 代理類；如果目標對象的實現類沒有實現接口，Spring AOP 將會採用 CGLIB 來生成 AOP 代理類</li></ul><p><strong>UML</strong></p><ul><li>《UML教程》</li></ul><p><strong>微服務思想</strong></p><ul><li>《微服務架構設計》</li><li>《微服務架構技術棧選型手冊》</li></ul><p><strong>康威定律</strong></p><ul><li>《微服務架構的理論基礎 - 康威定律》</li><li class=ql-indent-1>定律一：組織溝通方式會通過系統設計表達出來，就是說架構的佈局和組織結構會有相似。</li><li class=ql-indent-1>定律二：時間再多一件事情也不可能做的完美，但總有時間做完一件事情。一口氣吃不成胖子，先搞定能搞定的。</li><li class=ql-indent-1>定律三：線型系統和線型組織架構間有潛在的異質同態特性。種瓜得瓜，做獨立自治的子系統減少溝通成本。</li><li class=ql-indent-1>定律四：大的系統組織總是比小系統更傾向於分解。合久必分，分而治之。</li><li>《微服務架構核⼼20講》</li></ul><h1><br></h1><h1>運維 & 統計 & 技術支持</h1><p><strong>常規監控</strong></p><ul><li>《騰訊業務系統監控的修煉之路》</li><li class=ql-indent-1>監控的方式：主動、被動、旁路(比如輿情監控)</li><li class=ql-indent-1>監控類型： 基礎監控、服務端監控、客戶端監控、 監控、用戶端監控</li><li class=ql-indent-1>監控的目標：全、塊、準</li><li class=ql-indent-1>核心指標：請求量、成功率、耗時</li><li>《開源還是商用？十大雲運維監控工具橫評》</li><li class=ql-indent-1>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、監控寶、 360網站服務監控、阿里雲監控、百度雲觀測、小蜜蜂網站監測等。</li><li>《監控報警系統搭建及二次開發經驗》</li></ul><p><strong>命令行監控工具</strong></p><ul><li>《常用命令行監控工具》</li><li class=ql-indent-1>top、sar、tsar、nload</li><li>《20個命令行工具監控 Linux 系統性能》</li><li>《JVM性能調優監控工具jps、jstack、jmap、jhat、jstat、hprof使用詳解》</li></ul><p><strong>APM</strong></p><p>APM — Application Performance Management</p><ul><li>《Dapper，大規模分佈式系統的跟蹤系統》</li><li>CNCF OpenTracing，中文版</li><li>主要開源軟件，按字母排序</li><li class=ql-indent-1>Apache SkyWalking</li><li class=ql-indent-1>CAT</li><li class=ql-indent-1>CNCF jaeger</li><li class=ql-indent-1>Pinpoint</li><li class=ql-indent-1>Zipkin</li><li>《開源APM技術選型與實戰》</li><li class=ql-indent-1>主要基於 Google的Dapper（大規模分佈式系統的跟蹤系統） 思想。</li></ul><p><strong>統計分析</strong></p><ul><li>《流量統計的基礎：埋點》</li><li class=ql-indent-1>常用指標：訪問與訪客、停留時長、跳出率、退出率、轉化率、參與度</li><li>《APP埋點常用的統計工具、埋點目標和埋點內容》</li><li class=ql-indent-1>第三方統計：友盟、百度移動、魔方、App Annie、talking data、神策數據等。</li><li>《美團點評前端無痕埋點實踐》</li><li class=ql-indent-1>所謂無痕、即通過可視化工具配置採集節點，在前端自動解析配置並上報埋點數據，而非硬編碼。</li></ul><p><strong>持續集成(CI/CD)</strong></p><ul><li>《持續集成是什麼？》</li><li>《8個流行的持續集成工具》</li></ul><p><strong>Jenkins</strong></p><ul><li>《使用Jenkins進行持續集成》</li></ul><p><strong>環境分離</strong></p><p>開發、測試、生成環境分離。</p><ul><li>《開發環境、生產環境、測試環境的基本理解和區》</li></ul><p><strong>自動化運維</strong></p><p><strong>Ansible</strong></p><ul><li>《Ansible中文權威指南》</li><li>《Ansible基礎配置和企業級項目實用案例》</li></ul><p><strong>puppet</strong></p><ul><li>《自動化運維工具——puppet詳解》</li></ul><p><strong>chef</strong></p><ul><li>《Chef 的安裝與使用》</li></ul><h1><strong>測試</strong></h1><p><strong>TDD 理論</strong></p><ul><li>《深度解讀 - TDD（測試驅動開發）》</li><li class=ql-indent-1>基於測試用例編碼功能代碼，XP（Extreme Programming）的核心實踐.</li><li class=ql-indent-1>好處：一次關注一個點，降低思維負擔；迎接需求變化或改善代碼的設計；提前澄清需求；快速反饋；</li></ul><p><strong>單元測試</strong></p><ul><li>《Java單元測試之JUnit篇》</li><li>《JUnit 4 與 TestNG 對比》</li><li class=ql-indent-1>TestNG 覆蓋 JUnit 功能，適用於更復雜的場景。</li><li>《單元測試主要的測試功能點》</li><li class=ql-indent-1>模塊接口測試、局部數據結構測試、路徑測試 、錯誤處理測試、邊界條件測試 。</li></ul><p><strong>壓力測試</strong></p><ul><li>《Apache ab 測試使用指南》</li><li>《大型網站壓力測試及優化方案》</li><li>《10大主流壓力/負載/性能測試工具推薦》</li><li>《真實流量壓測工具 tcpcopy應用淺析》</li><li>《nGrinder 簡易使用教程》</li></ul><p><strong>全鏈路壓測</strong></p><ul><li>《京東618：升級全鏈路壓測方案，打造軍演機器人ForceBot》</li><li>《餓了麼全鏈路壓測的探索與實踐》</li><li>《四大語言，八大框架｜滴滴全鏈路壓測解決之道》</li><li>《全鏈路壓測經驗》</li></ul><p><strong>A/B 、灰度、藍綠測試</strong></p><ul><li>《技術乾貨 | AB 測試和灰度發佈探索及實踐》</li><li>《nginx 根據IP 進行灰度發佈》</li><li>《藍綠部署、A/B 測試以及灰度發佈》</li></ul><p><strong>虛擬化</strong></p><ul><li>《VPS的三種虛擬技術OpenVZ、Xen、KVM優缺點比較》</li></ul><p><strong>KVM</strong></p><ul><li>《KVM詳解，太詳細太深入了，經典》</li><li>《【圖文】KVM 虛擬機安裝詳解》</li></ul><p><strong>Xen</strong></p><ul><li>《Xen虛擬化基本原理詳解》</li></ul><p><strong>OpenVZ</strong></p><ul><li>《開源Linux容器 OpenVZ 快速上手指南》</li></ul><h1><strong>容器技術</strong></h1><p><strong>Docker</strong></p><ul><li>《幾張圖幫你理解 docker 基本原理及快速入門》</li><li>《Docker 核心技術與實現原理》</li><li>《Docker 教程》</li></ul><h1><strong>雲技術</strong></h1><p><strong>OpenStack</strong></p><ul><li>《OpenStack構架知識梳理》</li></ul><p><strong>DevOps</strong></p><ul><li>《一分鐘告訴你究竟DevOps是什麼鬼？》</li><li>《DevOps詳解》</li></ul><p><strong>文檔管理</strong></p><ul><li>Confluence-收費文檔管理系統</li><li>GitLab?</li><li>Wiki</li></ul><h1><br></h1><h1>中間件</h1><p><strong>Web Server</strong></p><p><strong>Nginx</strong></p><ul><li>《Ngnix的基本學習-多進程和Apache的比較》</li><li class=ql-indent-1>Nginx 通過異步非阻塞的事件處理機制實現高併發。Apache 每個請求獨佔一個線程，非常消耗系統資源。</li><li class=ql-indent-1>事件驅動適合於IO密集型服務(Nginx)，多進程或線程適合於CPU密集型服務(Apache)，所以Nginx適合做反向代理，而非web服務器使用。</li><li>《nginx與Apache的對比以及優缺點》</li><li class=ql-indent-1>nginx只適合靜態和反向代理，不適合處理動態請求。</li></ul><p><strong>OpenResty</strong></p><ul><li>官方網站</li><li>《淺談 OpenResty》</li><li class=ql-indent-1>通過 Lua 模塊可以在Nginx上進行開發。</li><li>agentzh 的 Nginx 教程</li></ul><p><strong>Tengine</strong></p><ul><li>官方網站</li></ul><p><strong>Apache Httpd</strong></p><ul><li>官方網站</li></ul><p><strong>Tomcat</strong></p><p><strong>架構原理</strong></p><ul><li>《TOMCAT原理詳解及請求過程》</li><li>《Tomcat服務器原理詳解》</li><li>《Tomcat 系統架構與設計模式,第 1 部分: 工作原理》</li><li>《四張圖帶你瞭解Tomcat系統架構》</li><li>《JBoss vs. Tomcat: Choosing A Java Application Server》</li><li class=ql-indent-1>Tomcat 是輕量級的 Serverlet 容器，沒有實現全部 JEE 特性（比如持久化和事務處理），但可以通過其他組件代替，比如Spring。</li><li class=ql-indent-1>Jboss 實現全部了JEE特性，軟件開源免費、文檔收費。</li></ul><p><strong>調優方案</strong></p><p><strong>《Tomcat 調優方案》</strong></p><ul><li class=ql-indent-1>啟動NIO模式（或者APR）；調整線程池；禁用AJP連接器（Nginx+tomcat的架構，不需要AJP）；</li><li>《tomcat http協議與ajp協議》</li><li>《AJP與HTTP比較和分析》</li><li class=ql-indent-1>AJP 協議（8009端口）用於降低和前端Server（如Apache，而且需要支持AJP協議）的連接數(前端)，通過長連接提高性能。</li><li class=ql-indent-1>併發高時，AJP協議優於HTTP協議。</li></ul><p><strong>Jetty</strong></p><ul><li>《Jetty 的工作原理以及與 Tomcat 的比較》</li><li>《jetty和tomcat優勢比較》</li><li class=ql-indent-1>架構比較:Jetty的架構比Tomcat的更為簡單。</li><li class=ql-indent-1>性能比較：Jetty和Tomcat性能方面差異不大，Jetty默認採用NIO結束在處理I/O請求上更佔優勢，Tomcat默認採用BIO處理I/O請求，Tomcat適合處理少數非常繁忙的鏈接，處理靜態資源時性能較差。</li><li class=ql-indent-1>其他方面：Jetty的應用更加快速，修改簡單，對新的Servlet規範的支持較好;Tomcat 對JEE和Servlet 支持更加全面。</li></ul><p><strong>緩存</strong></p><ul><li>《緩存失效策略（FIFO 、LRU、LFU三種算法的區別）》</li></ul><p><strong>本地緩存</strong></p><ul><li>《HashMap本地緩存》</li><li>《EhCache本地緩存》</li><li class=ql-indent-1>堆內、堆外、磁盤三級緩存。</li><li class=ql-indent-1>可按照緩存空間容量進行設置。</li><li class=ql-indent-1>按照時間、次數等過期策略。</li><li>《Guava Cache》</li><li class=ql-indent-1>簡單輕量、無堆外、磁盤緩存。</li><li>《Nginx本地緩存》</li><li>《Pagespeed—懶人工具，服務器端加速》</li></ul><p><strong>客戶端緩存</strong></p><ul><li>《瀏覽器端緩存》</li><li class=ql-indent-1>主要是利用 Cache-Control 參數。</li><li>《H5 和移動端 WebView 緩存機制解析與實戰》</li></ul><p><strong>服務端緩存</strong></p><p><strong>Web緩存</strong></p><ul><li>nuster - nuster cache</li><li>varnish - varnish cache</li><li>squid - squid cache</li></ul><p><strong>Memcached</strong></p><ul><li>《Memcached 教程》</li><li>《深入理解Memcached原理》</li><li class=ql-indent-1>採用多路複用技術提高併發性。</li><li class=ql-indent-1>slab分配算法： memcached給Slab分配內存空間，默認是1MB。分配給Slab之後 把slab的切分成大小相同的chunk，Chunk是用於緩存記錄的內存空間，Chunk 的大小默認按照1.25倍的速度遞增。好處是不會頻繁申請內存，提高IO效率，壞處是會有一定的內存浪費。</li><li>《Memcached軟件工作原理》</li><li>《Memcache技術分享：介紹、使用、存儲、算法、優化、命中率》</li><li>《memcache 中 add 、 set 、replace 的區別》</li><li class=ql-indent-1>區別在於當key存在還是不存在時，返回值是true和false的。</li><li>《memcached全面剖析》</li></ul><p><strong>Redis</strong></p><ul><li>《Redis 教程》</li><li>《redis底層原理》</li><li class=ql-indent-1>使用 ziplist 存儲鏈表，ziplist是一種壓縮鏈表，它的好處是更能節省內存空間，因為它所存儲的內容都是在連續的內存區域當中的。</li><li class=ql-indent-1>使用 skiplist(跳躍表)來存儲有序集合對象、查找上先從高Level查起、時間複雜度和紅黑樹相當，實現容易，無鎖、併發性好。</li><li>《Redis持久化方式》</li><li class=ql-indent-1>RDB方式：定期備份快照，常用於災難恢復。優點：通過fork出的進程進行備份，不影響主進程、RDB 在恢復大數據集時的速度比 AOF 的恢復速度要快。缺點：會丟數據。</li><li class=ql-indent-1>AOF方式：保存操作日誌方式。優點：恢復時數據丟失少，缺點：文件大，回覆慢。</li><li class=ql-indent-1>也可以兩者結合使用。</li><li>《分佈式緩存--序列3--原子操作與CAS樂觀鎖》</li></ul><p><strong>架構</strong></p><ul><li>《Redis單線程架構》</li></ul><p><strong>回收策略</strong></p><ul><li>《redis的回收策略》</li></ul><p><strong>Tair</strong></p><ul><li>官方網站</li><li>《Tair和Redis的對比》</li><li>特點：可以配置備份節點數目，通過異步同步到備份節點</li><li>一致性Hash算法。</li><li>架構：和Hadoop 的設計思想類似，有Configserver，DataServer，Configserver 通過心跳來檢測，Configserver也有主備關係。</li></ul><p><strong>幾種存儲引擎:</strong></p><ul><li>MDB，完全內存性，可以用來存儲Session等數據。</li><li>Rdb（類似於Redis），輕量化，去除了aof之類的操作，支持Restfull操作</li><li>LDB（LevelDB存儲引擎），持久化存儲，LDB 作為rdb的持久化，google實現，比較高效，理論基礎是LSM(Log-Structured-Merge Tree)算法，現在內存中修改數據，達到一定量時（和內存彙總的舊數據一同寫入磁盤）再寫入磁盤，存儲更加高效，縣比喻Hash算法。</li><li>Tair採用共享內存來存儲數據，如果服務掛掉（非服務器），重啟服務之後，數據亦然還在。</li></ul><p><strong>消息隊列</strong></p><ul><li>《消息隊列-推/拉模式學習 & ActiveMQ及JMS學習》</li><li class=ql-indent-1>RabbitMQ 消費者默認是推模式（也支持拉模式）。</li><li class=ql-indent-1>Kafka 默認是拉模式。</li><li class=ql-indent-1>Push方式：優點是可以儘可能快地將消息發送給消費者，缺點是如果消費者處理能力跟不上，消費者的緩衝區可能會溢出。</li><li class=ql-indent-1>Pull方式：優點是消費端可以按處理能力進行拉去，缺點是會增加消息延遲。</li><li>《Kafka、RabbitMQ、RocketMQ等消息中間件的對比 —— 消息發送性能和區別》</li></ul><p><strong>消息總線</strong></p><p>消息總線相當於在消息隊列之上做了一層封裝，統一入口，統一管控、簡化接入成本。</p><ul><li>《消息總線VS消息隊列》</li></ul><p><strong>消息的順序</strong></p><ul><li>《如何保證消費者接收消息的順序》</li></ul><p><strong>RabbitMQ</strong></p><p>支持事務，推拉模式都是支持、適合需要可靠性消息傳輸的場景。</p><ul><li>《RabbitMQ的應用場景以及基本原理介紹》</li><li>《消息隊列之 RabbitMQ》</li><li>《RabbitMQ之消息確認機制（事務+Confirm）》</li></ul><p><strong>RocketMQ</strong></p><p>Java實現，推拉模式都是支持，吞吐量遜於Kafka。可以保證消息順序。</p><ul><li>《RocketMQ 實戰之快速入門》</li><li>《RocketMQ 源碼解析》</li></ul><p><strong>ActiveMQ</strong></p><p>純Java實現，兼容JMS，可以內嵌於Java應用中。</p><ul><li>《ActiveMQ消息隊列介紹》</li></ul><p><strong>Kafka</strong></p><p>高吞吐量、採用拉模式。適合高IO場景，比如日誌同步。</p><ul><li>官方網站</li><li>《各消息隊列對比，Kafka深度解析，眾人推薦，精彩好文！》</li><li>《Kafka分區機制介紹與示例》</li></ul><p><strong>Redis 消息推送</strong></p><p>生產者、消費者模式完全是客戶端行為，list 和 拉模式實現，阻塞等待採用 blpop 指令。</p><ul><li>《Redis學習筆記之十：Redis用作消息隊列》</li></ul><p><strong>ZeroMQ</strong></p><p>TODO</p><p><strong>定時調度</strong></p><p><strong>單機定時調度</strong></p><ul><li>《linux定時任務cron配置》</li><li>《Linux cron運行原理》</li><li class=ql-indent-1>fork 進程 + sleep 輪詢</li><li>《Quartz使用總結》</li><li>《Quartz源碼解析 ---- 觸發器按時啟動原理》</li><li>《quartz原理揭祕和源碼解讀》</li><li class=ql-indent-1>定時調度在 QuartzSchedulerThread 代碼中，while()無限循環，每次循環取出時間將到的trigger，觸發對應的job，直到調度器線程被關閉。</li></ul><p><strong>分佈式定時調度</strong></p><ul><li>《這些優秀的國產分佈式任務調度系統，你用過幾個？》</li><li class=ql-indent-1>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li><li>《Quartz任務調度的基本實現原理》</li><li class=ql-indent-1>Quartz集群中，獨立的Quartz節點並不與另一其的節點或是管理節點通信，而是通過相同的數據庫表來感知到另一Quartz應用的</li><li>《Elastic-Job-Lite 源碼解析》</li><li>《Elastic-Job-Cloud 源碼解析》</li></ul><p><strong>RPC</strong></p><ul><li>《從零開始實現RPC框架 - RPC原理及實現》</li><li class=ql-indent-1>核心角色：Server: 暴露服務的服務提供方、Client: 調用遠程服務的服務消費方、Registry: 服務註冊與發現的註冊中心。</li><li>《分佈式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比較》</li></ul><p><strong>Dubbo</strong></p><ul><li>官方網站</li><li>dubbo實現原理簡單介紹</li></ul><p>** SPI ** TODO</p><p><strong>Thrift</strong></p><ul><li>官方網站</li><li>《Thrift RPC詳解》</li><li class=ql-indent-1>支持多語言，通過中間語言定義接口。</li></ul><p><strong>gRPC</strong></p><p>服務端可以認證加密，在外網環境下，可以保證數據安全。</p><ul><li>官方網站</li><li>《你應該知道的RPC原理》</li></ul><p><strong>數據庫中間件</strong></p><p><strong>Sharding Jdbc</strong></p><ul><li>官網</li><li>源碼解析</li></ul><p><strong>日誌系統</strong></p><p><strong>日誌蒐集</strong></p><ul><li>《從零開始搭建一個ELKB日誌收集系統》</li><li>《用ELK搭建簡單的日誌收集分析系統》</li><li>《日誌收集系統-探究》</li></ul><p><strong>配置中心</strong></p><ul><li>Apollo - 攜程開源的配置中心應用</li><li class=ql-indent-1>Spring Boot 和 Spring Cloud</li><li class=ql-indent-1>支持推、拉模式更新配置</li><li class=ql-indent-1>支持多種語言</li><li>《基於zookeeper實現統一配置管理》</li><li>《 Spring Cloud Config 分佈式配置中心使用教程》</li></ul><p>servlet 3.0 異步特性可用於配置中心的客戶端</p><ul><li>《servlet3.0 新特性——異步處理》</li></ul><p><strong>API 網關</strong></p><p>主要職責：請求轉發、安全認證、協議轉換、容災。</p><ul><li>《API網關那些兒》</li><li>《談API網關的背景、架構以及落地方案》</li><li>《使用Zuul構建API Gateway》</li><li>《Spring Cloud Gateway 源碼解析》</li><li>《HTTP API網關選擇之一Kong介紹》</li></ul><h1><br></h1><h1>網絡</h1><p><strong>協議</strong></p><p><strong>OSI 七層協議</strong></p><ul><li>《OSI七層協議模型、TCP/IP四層模型學習筆記》</li></ul><p><strong>TCP/IP</strong></p><ul><li>《深入淺出 TCP/IP 協議》</li><li>《TCP協議中的三次握手和四次揮手》</li></ul><p><strong>HTTP</strong></p><ul><li>《http協議詳解(超詳細)》</li></ul><p><strong>HTTP2.0</strong></p><ul><li>《HTTP 2.0 原理詳細分析》</li><li>《HTTP2.0的基本單位為二進制幀》</li><li class=ql-indent-1>利用二進制幀負責傳輸。</li><li class=ql-indent-1>多路複用。</li></ul><p><strong>HTTPS</strong></p><ul><li>《https原理通俗瞭解》</li><li class=ql-indent-1>使用非對稱加密協商加密算法</li><li class=ql-indent-1>使用對稱加密方式傳輸數據</li><li class=ql-indent-1>使用第三方機構簽發的證書，來加密公鑰，用於公鑰的安全傳輸、防止被中間人串改。</li><li>《八大免費SSL證書-給你的網站免費添加Https安全加密》</li></ul><p><strong>網絡模型</strong></p><ul><li>《web優化必須瞭解的原理之I/o的五種模型和web的三種工作模式》</li><li class=ql-indent-1>五種I/O模型：阻塞I/O，非阻塞I/O，I/O複用、事件(信號)驅動I/O、異步I/O，前四種I/O屬於同步操作，I/O的第一階段不同、第二階段相同，最後的一種則屬於異步操作。</li><li class=ql-indent-1>三種 Web Server 工作方式：Prefork(多進程)、Worker方式(線程方式)、Event方式。</li><li>《select、poll、epoll之間的區別總結》</li><li class=ql-indent-1>select，poll，epoll本質上都是同步I/O，因為他們都需要在讀寫事件就緒後自己負責進行讀寫，也就是說這個讀寫過程是阻塞的。</li><li class=ql-indent-1>select 有打開文件描述符數量限制，默認1024（2048 for x64），100萬併發，就要用1000個進程、切換開銷大；poll採用鏈表結構，沒有數量限制。</li><li class=ql-indent-1>select，poll “醒著”的時候要遍歷整個fd集合，而epoll在“醒著”的時候只要判斷一下就緒鏈表是否為空就行了，通過回調機制節省大量CPU時間；select，poll每次調用都要把fd集合從用戶態往內核態拷貝一次，而epoll只要一次拷貝。</li><li class=ql-indent-1>poll會隨著併發增加，性能逐漸下降，epoll採用紅黑樹結構，性能穩定，不會隨著連接數增加而降低。</li><li>《select，poll，epoll比較 》</li><li class=ql-indent-1>在連接數少並且連接都十分活躍的情況下，select和poll的性能可能比epoll好，畢竟epoll的通知機制需要很多函數回調。</li><li>《深入理解Java NIO》</li><li class=ql-indent-1>NIO 是一種同步非阻塞的 IO 模型。同步是指線程不斷輪詢 IO 事件是否就緒，非阻塞是指線程在等待 IO 的時候，可以同時做其他任務</li><li>《BIO與NIO、AIO的區別》</li><li>《兩種高效的服務器設計模型：Reactor和Proactor模型》</li></ul><p><strong>Epoll</strong></p><ul><li>《epoll使用詳解（精髓）》</li></ul><p><strong>Java NIO</strong></p><ul><li>《深入理解Java NIO》</li><li>《Java NIO編寫Socket服務器的一個例子》</li></ul><p><strong>kqueue</strong></p><ul><li>《kqueue用法簡介》</li></ul><p><strong>連接和短連接</strong></p><ul><li>《TCP/IP系列——長連接與短連接的區別》</li></ul><p><strong>框架</strong></p><ul><li>《Netty原理剖析》</li><li class=ql-indent-1>Reactor 模式介紹。</li><li class=ql-indent-1>Netty 是 Reactor 模式的一種實現。</li></ul><p><strong>零拷貝（Zero-copy）</strong></p><ul><li>《對於 Netty ByteBuf 的零拷貝(Zero Copy) 的理解》</li><li class=ql-indent-1>多個物理分離的buffer，通過邏輯上合併成為一個，從而避免了數據在內存之間的拷貝。</li></ul><p><strong>序列化(二進制協議)</strong></p><p><strong>Hessian</strong></p><ul><li>《Hessian原理分析》 Binary-RPC;不僅僅是序列化</li></ul><p><strong>Protobuf</strong></p><ul><li>《Protobuf協議的Java應用例子》 Goolge出品、佔用空間和效率完勝其他序列化類庫，如Hessian；需要編寫 .proto 文件。</li><li>《Protocol Buffers序列化協議及應用》</li><li class=ql-indent-1>關於協議的解釋；缺點：可讀性差;</li><li>《簡單的使用 protobuf 和 protostuff》</li><li class=ql-indent-1>protostuff 的好處是不用寫 .proto 文件，Java 對象直接就可以序列化。</li></ul><h1><br></h1><h1>數據庫</h1><p><strong>基礎理論</strong></p><p><strong>數據庫設計的三大範式</strong></p><ul><li>《數據庫的三大範式以及五大約束》</li><li class=ql-indent-1>第一範式：數據表中的每一列（每個字段）必須是不可拆分的最小單元，也就是確保每一列的原子性；</li><li class=ql-indent-1>第二範式（2NF）：滿足1NF後，要求表中的所有列，都必須依賴於主鍵，而不能有任何一列與主鍵沒有關係，也就是說一個表只描述一件事情；</li><li class=ql-indent-1>第三範式：必須先滿足第二範式（2NF），要求：表中的每一列只與主鍵直接相關而不是間接相關，（表中的每一列只能依賴於主鍵）；</li></ul><p><strong>MySQL</strong></p><p><strong>原理</strong></p><ul><li>《MySQL的InnoDB索引原理詳解》</li><li>《MySQL存儲引擎－－MyISAM與InnoDB區別》</li><li class=ql-indent-1>兩種類型最主要的差別就是Innodb 支持事務處理與外鍵和行級鎖</li><li>《myisam和innodb索引實現的不同》</li></ul><p><strong>InnoDB</strong></p><ul><li>《一篇文章帶你讀懂Mysql和InnoDB》</li></ul><p><strong>優化</strong></p><ul><li>《MySQL36條軍規》</li><li>《MYSQL性能優化的最佳20+條經驗》</li><li>《SQL優化之道》</li><li>《mysql數據庫死鎖的產生原因及解決辦法》</li><li>《導致索引失效的可能情況》</li><li>《 MYSQL分頁limit速度太慢優化方法》</li><li class=ql-indent-1>原則上就是縮小掃描範圍。</li></ul><p><strong>索引</strong></p><p><strong>聚集索引, 非聚集索引</strong></p><ul><li>《MySQL 聚集索引/非聚集索引簡述》</li><li>《MyISAM和InnoDB的索引實現》</li></ul><p><strong>MyISAM 是非聚集，InnoDB 是聚集</strong></p><p><strong>複合索引</strong></p><ul><li>《複合索引的優點和注意事項》</li><li class=ql-indent-1>文中有一處錯誤：</li></ul><blockquote><p>對於複合索引,在查詢使用時,最好將條件順序按找索引的順序,這樣效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 將不會使用索引</p></blockquote><ul><li class=ql-indent-1>原文中提到索引是按照“col1，col2，col3”的順序創建的，而mysql在按照最左前綴的索引匹配原則，且會自動優化 where 條件的順序，當條件中只有 col2=B AND col1=A 時，會自動轉化為 col1=A AND col2=B，所以依然會使用索引。</li><li>《MySQL查詢where條件的順序對查詢效率的影響》</li></ul><p><strong>自適應哈希索引(AHI)</strong></p><ul><li>《InnoDB存儲引擎——自適應哈希索引》</li></ul><p><strong>explain</strong></p><ul><li>《MySQL 性能優化神器 Explain 使用分析》</li></ul><p><strong>NoSQL</strong></p><p><strong>MongoDB</strong></p><ul><li>MongoDB 教程</li><li>《Mongodb相對於關係型數據庫的優缺點》</li><li class=ql-indent-1>優點：弱一致性（最終一致），更能保證用戶的訪問速度；內置GridFS，支持大容量的存儲；Schema-less 數據庫，不用預先定義結構；內置Sharding；相比於其他NoSQL，第三方支持豐富；性能優越；</li><li class=ql-indent-1>缺點：mongodb不支持事務操作；mongodb佔用空間過大；MongoDB沒有如MySQL那樣成熟的維護工具，這對於開發和IT運營都是個值得注意的地方；</li></ul><p><strong>Hbase</strong></p><ul><li>《簡明 HBase 入門教程（開篇）》</li><li>《深入學習HBase架構原理》</li><li>《傳統的行存儲和（HBase）列存儲的區別》</li><li>《Hbase與傳統數據庫的區別》</li><li class=ql-indent-1>空數據不存儲，節省空間，且適用於併發。</li><li>《HBase Rowkey設計》</li><li class=ql-indent-1>rowkey 按照字典順序排列，便於批量掃描。</li><li class=ql-indent-1>通過散列可以避免熱點。</li></ul><h1><br></h1><h1>搜索引擎</h1><p><strong>搜索引擎原理</strong></p><ul><li>《倒排索引--搜索引擎入門》</li></ul><p><strong>Lucene</strong></p><ul><li>《Lucene入門簡介》</li></ul><p><strong>Elasticsearch</strong></p><ul><li>《Elasticsearch學習，請先看這一篇！》</li><li>《Elasticsearch索引原理》</li></ul><p><strong>Solr</strong></p><ul><li>《 Apache Solr入門教程》</li><li>《elasticsearch與solr比較》</li></ul><p><strong>sphinx</strong></p><ul><li>《Sphinx 的介紹和原理探索》</li></ul><h1><br></h1><h1>性能</h1><p><strong>性能優化方法論</strong></p><ul><li>《15天的性能優化工作，5方面的調優經驗》</li><li class=ql-indent-1>代碼層面、業務層面、數據庫層面、服務器層面、前端優化。</li><li>《系統性能優化的幾個方面》</li></ul><p><strong>容量評估</strong></p><ul><li>《聯網性能與容量評估的方法論和典型案例》</li><li>《互聯網架構，如何進行容量設計？》</li><li class=ql-indent-1>評估總訪問量、評估平均訪問量QPS、評估高峰QPS、評估系統、單機極限QPS</li></ul><p><strong>CDN 網絡</strong></p><ul><li>《CDN加速原理》</li><li>《國內有哪些比較好的 CDN？》</li></ul><p><strong>連接池</strong></p><ul><li>《主流Java數據庫連接池比較與開發配置實戰》</li></ul><p><strong>性能調優</strong></p><ul><li>《九大Java性能調試工具，必備至少一款》</li></ul><h1><br></h1><h1>大數據</h1><p><strong>流式計算</strong></p><p><strong>Storm</strong></p><ul><li>官方網站</li><li>《最詳細的Storm入門教程》</li></ul><p><strong>Flink</strong></p><ul><li>《Flink之一 Flink基本原理介紹》</li></ul><p><strong>Kafka Stream</strong></p><ul><li>《Kafka Stream調研：一種輕量級流計算模式》計；</li><li>推薦系統用戶畫像標籤實時更新；</li><li>線上服務健康狀況實時監測；</li><li>實時榜單；</li><li>實時數據統計。</li></ul><p><strong>Hadoop</strong></p><ul><li>《用通俗易懂的話說下hadoop是什麼,能做什麼》</li><li>《史上最詳細的Hadoop環境搭建》</li></ul><p><strong>HDFS</strong></p><ul><li>《【Hadoop學習】HDFS基本原理》</li></ul><p><strong>MapReduce</strong></p><ul><li>《用通俗易懂的大白話講解Map/Reduce原理》</li><li>《 簡單的map-reduce的java例子》</li></ul><p><strong>Yarn</strong></p><ul><li>《初步掌握Yarn的架構及原理》</li></ul><p><strong>Spark</strong></p><ul><li>《Spark(一): 基本架構及原理》</li></ul><h1><br></h1><h1>安全</h1><p><strong>web 安全</strong></p><p><strong>XSS</strong></p><ul><li>《xss攻擊原理與解決方法》</li></ul><p><strong>CSRF</strong></p><ul><li>《CSRF原理及防範》</li></ul><p><strong>SQL 注入</strong></p><ul><li>《SQL注入》</li></ul><p><strong>Hash Dos</strong></p><ul><li>《邪惡的JAVA HASH DOS攻擊》</li><li class=ql-indent-1>利用JsonObject 上傳大Json，JsonObject 底層使用HashMap；不同的數據產生相同的hash值，使得構建Hash速度變慢，耗盡CPU。</li><li>《一種高級的DoS攻擊-Hash碰撞攻擊》</li><li>《關於Hash Collision DoS漏洞：解析與解決方案》</li></ul><p><strong>腳本注入</strong></p><ul><li>《上傳文件漏洞原理及防範》</li></ul><p><strong>漏洞掃描工具</strong></p><ul><li>《DVWA》</li><li>W3af</li><li>OpenVAS詳解</li></ul><p><strong>驗證碼</strong></p><ul><li>《驗證碼原理分析及實現》</li><li>《詳解滑動驗證碼的實現原理》</li><li class=ql-indent-1>滑動驗證碼是根據人在滑動滑塊的響應時間，拖拽速度，時間，位置，軌跡，重試次數等來評估風險。</li><li>《淘寶滑動驗證碼研究》</li></ul><p><strong>DDoS 防範</strong></p><ul><li>《學習手冊：DDoS的攻擊方式及防禦手段》</li><li>《免費DDoS攻擊測試工具大合集》</li></ul><p><strong>用戶隱私信息保護</strong></p><ol><li>用戶密碼非明文保存，加動態salt。</li><li>身份證號，手機號如果要顯示，用 “*” 替代部分字符。</li><li>聯繫方式在的顯示與否由用戶自己控制。</li><li>TODO</li></ol><ul><li>《個人隱私包括哪些》</li><li>《在互聯網上，隱私的範圍包括哪些？》</li><li>《用戶密碼保存》</li></ul><p><strong>序列化漏洞</strong></p><ul><li>《Lib之過？Java反序列化漏洞通用利用分析》</li></ul><p><strong>加密解密</strong></p><p><strong>對稱加密</strong></p><ul><li>《常見對稱加密算法》</li><li class=ql-indent-1>DES、3DES、Blowfish、AES</li><li class=ql-indent-1>DES 採用 56位祕鑰，Blowfish 採用1到448位變長祕鑰，AES 128，192和256位長度的祕鑰。</li><li class=ql-indent-1>DES 祕鑰太短（只有56位）算法目前已經被 AES 取代，並且 AES 有硬件加速，性能很好。</li></ul><p><strong>哈希算法</strong></p><ul><li>《常用的哈希算法》</li><li class=ql-indent-1>MD5 和 SHA-1 已經不再安全，已被棄用。</li><li class=ql-indent-1>目前 SHA-256 是比較安全的。</li><li>《基於Hash摘要簽名的公網URL簽名驗證設計方案》</li></ul><p><strong>非對稱加密</strong></p><ul><li>《常見非對稱加密算法》</li><li>RSA、DSA、ECDSA(螺旋曲線加密算法)</li><li class=ql-indent-1><br></li><li class=ql-indent-1>和 RSA 不同的是 DSA 僅能用於數字簽名，不能進行數據加密解密，其安全性和RSA相當，但其性能要比RSA快。</li><li>256位的ECC祕鑰的安全性等同於3072位的RSA祕鑰。</li><li class=ql-indent-1>《區塊鏈的加密技術》</li></ul><p><strong>服務器安全</strong></p><ul><li>《Linux強化論：15步打造一個安全的Linux服務器》</li></ul><p><strong>數據安全</strong></p><p><strong>數據備份</strong></p><p>TODO</p><p><strong>網絡隔離</strong></p><p><strong>內外網分離</strong></p><p>TODO</p><p><strong>登錄跳板機</strong></p><p>在內外環境中通過跳板機登錄到線上主機。</p><ul><li>《搭建簡易堡壘機》</li></ul><p><strong>授權、認證</strong></p><p><strong>RBAC</strong></p><ul><li>《基於組織角色的權限設計》</li><li>《權限系統與RBAC模型概述》</li><li>《Spring整合Shiro做權限控制模塊詳細案例分析》</li></ul><p><strong>OAuth2.0</strong></p><ul><li>《理解OAuth 2.0》</li><li>《一張圖搞定OAuth2.0》</li></ul><p><strong>雙因素認證（2FA）</strong></p><p>2FA - Two-factor authentication，用於加強登錄驗證</p><p>常用做法是 登錄密碼 + 手機驗證碼（或者令牌Key，類似於與網銀的 USB key）</p><ul><li>【《雙因素認證（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)</li></ul><p><strong>單點登錄(SSO)</strong></p><ul><li>《單點登錄原理與簡單實現》</li><li>CAS單點登錄框架</li></ul><h1><br></h1><h1>常用開源框架</h1><p><strong>開源協議</strong></p><ul><li>《開源協議的選擇》</li><li>如何選擇一個開源軟件協議</li></ul><p><strong>日誌框架</strong></p><p><strong>Log4j、Log4j2</strong></p><ul><li>《log4j 詳細講解》</li><li>《log4j2 實際使用詳解》</li><li>《Log4j1,Logback以及Log4j2性能測試對比》</li><li class=ql-indent-1>Log4J 異步日誌性能優異。</li></ul><p><strong>Logback</strong></p><ul><li>《最全LogBack 詳解、含java案例和配置說明》</li></ul><p><strong>ORM</strong></p><ul><li>《ORM框架使用優缺點》</li><li class=ql-indent-1>主要目的是為了提高開發效率。</li></ul><p><strong>MyBatis：</strong></p><ul><li>《mybatis緩存機制詳解》</li><li class=ql-indent-1>一級緩存是SqlSession級別的緩存，緩存的數據只在SqlSession內有效</li><li class=ql-indent-1>二級緩存是mapper級別的緩存，同一個namespace公用這一個緩存，所以對SqlSession是共享的；使用 LRU 機制清理緩存，通過 cacheEnabled 參數開啟。</li><li>《MyBatis學習之代碼生成器Generator》</li></ul><p><strong>網絡框架</strong></p><p>TODO</p><p><strong>Web 框架</strong></p><p><strong>Spring 家族</strong></p><p><strong>Spring</strong></p><ul><li>Spring 簡明教程</li></ul><p><strong>Spring Boot</strong></p><ul><li>官方網站</li><li>《Spring Boot基礎教程》</li></ul><p><strong>Spring Cloud</strong></p><ul><li>Spring Boot 中文索引站</li><li>Spring Cloud 中文文檔</li><li>《Spring Cloud基礎教程》</li></ul><p><strong>工具框架</strong></p><ul><li>《Apache Commons 工具類介紹及簡單使用》</li><li>《Google guava 中文教程》</li></ul><h1><br></h1><h1>分佈式設計</h1><p><strong>擴展性設計</strong></p><ul><li>《架構師不可不知的十大可擴展架構》</li><li class=ql-indent-1>總結下來，通用的套路就是分佈、緩存及異步處理。</li><li>《可擴展性設計之數據切分》</li><li class=ql-indent-1>水平切分+垂直切分</li><li class=ql-indent-1>利用中間件進行分片如，MySQL Proxy。</li><li class=ql-indent-1>利用分片策略進行切分，如按照ID取模。</li><li>《說說如何實現可擴展性的大型網站架構》</li><li class=ql-indent-1>分佈式服務+消息隊列。</li><li>《大型網站技術架構（七）--網站的可擴展性架構》</li></ul><p><strong>穩定性 & 高可用</strong></p><ul><li>《系統設計：關於高可用系統的一些技術方案》</li><li class=ql-indent-1>可擴展：水平擴展、垂直擴展。 通過冗餘部署，避免單點故障。</li><li class=ql-indent-1>隔離：避免單一業務佔用全部資源。避免業務之間的相互影響 2. 機房隔離避免單點故障。</li><li class=ql-indent-1>解耦：降低維護成本，降低耦合風險。減少依賴，減少相互間的影響。</li><li class=ql-indent-1>限流：滑動窗口計數法、漏桶算法、令牌桶算法等算法。遇到突發流量時，保證系統穩定。</li><li class=ql-indent-1>降級：緊急情況下釋放非核心功能的資源。犧牲非核心業務，保證核心業務的高可用。</li><li class=ql-indent-1>熔斷：異常情況超出閾值進入熔斷狀態，快速失敗。減少不穩定的外部依賴對核心服務的影響。</li><li class=ql-indent-1>自動化測試：通過完善的測試，減少發佈引起的故障。</li><li class=ql-indent-1>灰度發佈：灰度發佈是速度與安全性作為妥協，能夠有效減少發佈故障。</li><li>《關於高可用的系統》</li><li class=ql-indent-1>設計原則：數據不丟(持久化)；服務高可用(服務副本)；絕對的100%高可用很難，目標是做到儘可能多的9，如99.999%（全年累計只有5分鐘）。</li></ul><p><strong>硬件負載均衡</strong></p><ul><li>《轉！！負載均衡器技術Nginx和F5的優缺點對比》</li><li class=ql-indent-1>主要是和F5對比。</li><li>《軟/硬件負載均衡產品 你知多少？》</li></ul><p><strong>軟件負載均衡</strong></p><ul><li>《幾種負載均衡算法》 輪尋、權重、負載、最少連接、QoS</li><li>《DNS負載均衡》</li><li class=ql-indent-1>配置簡單，更新速度慢。</li><li>《Nginx負載均衡》</li><li class=ql-indent-1>簡單輕量、學習成本低；主要適用於web應用。</li><li>《藉助LVS+Keepalived實現負載均衡 》</li><li class=ql-indent-1>配置比較負載、只支持到4層，性能較高。</li><li>《HAProxy用法詳解 全網最詳細中文文檔》</li><li class=ql-indent-1>支持到七層（比如HTTP）、功能比較全面，性能也不錯。</li><li>《Haproxy+Keepalived+MySQL實現讀均衡負載》</li><li class=ql-indent-1>主要是用戶讀請求的負載均衡。</li><li>《rabbitmq+haproxy+keepalived實現高可用集群搭建》</li></ul><p><strong>限流</strong></p><ul><li>《談談高併發系統的限流》</li><li class=ql-indent-1>計數器：通過滑動窗口計數器，控制單位時間內的請求次數，簡單粗暴。</li><li class=ql-indent-1>漏桶算法：固定容量的漏桶，漏桶滿了就丟棄請求，比較常用。</li><li class=ql-indent-1>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，處理請求前需要拿到令牌，拿不到令牌則丟棄請求，或進入丟隊列，可以通過控制添加令牌的速率，來控制整體速度。Guava 中的 RateLimiter 是令牌桶的實現。</li><li class=ql-indent-1>Nginx 限流：通過 limit_req 等模塊限制併發連接數。</li></ul><p><strong>應用層容災</strong></p><ul><li>《防雪崩利器：熔斷器 Hystrix 的原理與使用》</li><li class=ql-indent-1>雪崩效應原因：硬件故障、硬件故障、程序Bug、重試加大流量、用戶大量請求。</li><li class=ql-indent-1>雪崩的對策：限流、改進緩存模式(緩存預加載、同步調用改異步)、自動擴容、降級。</li><li>Hystrix設計原則：</li><li class=ql-indent-2>資源隔離：Hystrix通過將每個依賴服務分配獨立的線程池進行資源隔離, 從而避免服務雪崩。</li><li class=ql-indent-2>熔斷開關：服務的健康狀況 = 請求失敗數 / 請求總數，通過閾值設定和滑動窗口控制開關。</li><li class=ql-indent-1>命令模式：通過繼承 HystrixCommand 來包裝服務調用邏輯。</li><li>《緩存穿透，緩存擊穿，緩存雪崩解決方案分析》</li><li>《緩存擊穿、失效以及熱點key問題》</li><li class=ql-indent-1>主要策略：失效瞬間：單機使用鎖；使用分佈式鎖；不過期；</li><li class=ql-indent-1>熱點數據：熱點數據單獨存儲；使用本地緩存；分成多個子key；</li></ul><p><strong>跨機房容災</strong></p><ul><li>《“異地多活”多機房部署經驗談》</li><li class=ql-indent-1>通過自研中間件進行數據同步。</li><li>《異地多活（異地雙活）實踐經驗》</li><li class=ql-indent-1>注意延遲問題，多次跨機房調用會將延時放大數倍。</li><li class=ql-indent-1>建房間專線很大概率會出現問題，做好運維和程序層面的容錯。</li><li class=ql-indent-1>不能依賴於程序端數據雙寫，要有自動同步方案。</li><li class=ql-indent-1>數據永不在高延遲和較差網絡質量下，考慮同步質量問題。</li><li class=ql-indent-1>核心業務和次要業務分而治之，甚至只考慮核心業務。</li><li class=ql-indent-1>異地多活監控部署、測試也要跟上。</li><li class=ql-indent-1>業務允許的情況下考慮用戶分區，尤其是遊戲、郵箱業務。</li><li class=ql-indent-1>控制跨機房消息體大小，越小越好。</li><li class=ql-indent-1>考慮使用docker容器虛擬化技術，提高動態調度能力。</li><li>容災技術及建設經驗介紹</li></ul><p><strong>容災演練流程</strong></p><ul><li>《依賴治理、灰度發佈、故障演練，阿里電商故障演練系統的設計與實戰經驗》</li><li class=ql-indent-1>常見故障畫像</li><li class=ql-indent-1>案例：預案有效性、預案有效性、故障復現、架構容災測試、參數調優、參數調優、故障突襲、聯合演練。</li></ul><p><strong>平滑啟動</strong></p><ul><li>平滑重啟應用思路 1.端流量（如vip層）、2. flush 數據(如果有)、3, 重啟應用</li><li>《JVM安全退出（如何優雅的關閉java服務）》 推薦推出方式：System.exit，Kill SIGTERM；不推薦 kill-9；用 Runtime.addShutdownHook 註冊鉤子。</li><li>《常見Java應用如何優雅關閉》 Java、Spring、Dubbo 優雅關閉方式。</li></ul><p><strong>數據庫擴展</strong></p><p><strong>讀寫分離模式</strong></p><ul><li>《Mysql主從方案的實現》</li><li>《搭建MySQL主從複製經典架構》</li><li>《Haproxy+多臺MySQL從服務器(Slave) 實現負載均衡》</li><li>《DRBD+Heartbeat+Mysql高可用讀寫分離架構》</li><li class=ql-indent-1>DRDB 進行磁盤複製，避免單點問題。</li><li>《MySQL Cluster 方式》</li></ul><p><strong>分片模式</strong></p><ul><li>《分庫分表需要考慮的問題及方案》</li><li class=ql-indent-1>中間件： 輕量級：sharding-jdbc、TSharding；重量級：Atlas、MyCAT、Vitess等。</li><li class=ql-indent-1>問題：事務、Join、遷移、擴容、ID、分頁等。</li><li class=ql-indent-1>事務補償：對數據進行對帳檢查;基於日誌進行比對;定期同標準數據來源進行同步等。</li><li class=ql-indent-1>分庫策略：數值範圍；取模；日期等。</li><li class=ql-indent-1>分庫數量：通常 MySQL 單庫 5千萬條、Oracle 單庫一億條需要分庫。</li><li>《MySql分表和表分區詳解》</li><li class=ql-indent-1>分區：是MySQL內部機制，對客戶端透明，數據存儲在不同文件中，表面上看是同一個表。</li><li class=ql-indent-1>分表：物理上創建不同的表、客戶端需要管理分表路由。</li></ul><p><strong>服務治理</strong></p><p><strong>服務註冊與發現</strong></p><ul><li>《永不失聯！如何實現微服務架構中的服務發現？》</li><li class=ql-indent-1>客戶端服務發現模式：客戶端直接查詢註冊表，同時自己負責負載均衡。Eureka 採用這種方式。</li><li class=ql-indent-1>服務器端服務發現模式：客戶端通過負載均衡查詢服務實例。</li><li>《SpringCloud服務註冊中心比較:Consul vs Zookeeper vs Etcd vs Eureka》</li><li class=ql-indent-1>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li><li class=ql-indent-1>作者認為目前 Consul 對 Spring cloud 的支持比較好。</li><li>《基於Zookeeper的服務註冊與發現》</li><li class=ql-indent-1>優點：API簡單、Pinterest，Airbnb 在用、多語言、通過watcher機制來實現配置PUSH，能快速響應配置變化。</li></ul><p><strong>服務路由控制</strong></p><ul><li>《分佈式服務框架學習筆記4 服務路由》</li><li class=ql-indent-1>原則：透明化路由</li><li class=ql-indent-1>負載均衡策略：隨機、輪詢、服務調用延遲、一致性哈希、粘滯連接</li><li class=ql-indent-1>本地路由有限策略：injvm(優先調用jvm內部的服務)，innative(優先使用相同物理機的服務),原則上找距離最近的服務。</li><li class=ql-indent-1>配置方式：統一註冊表；本地配置；動態下發。</li></ul><p><strong>分佈式一致</strong></p><p><strong>CAP 與 BASE 理論</strong></p><ul><li>《從分佈式一致性談到CAP理論、BASE理論》</li><li class=ql-indent-1>一致性分類：強一致(立即一致)；弱一致(可在單位時間內實現一致，比如秒級)；最終一致(弱一致的一種，一定時間內最終一致)</li><li class=ql-indent-1>CAP：一致性、可用性、分區容錯性(網絡故障引起)</li><li class=ql-indent-1>BASE：Basically Available（基本可用）、Soft state（軟狀態）和Eventually consistent（最終一致性）</li><li class=ql-indent-1>BASE理論的核心思想是：即使無法做到強一致性，但每個應用都可以根據自身業務特點，採用適當的方式來使系統達到最終一致性。</li></ul><p><strong>分佈式鎖</strong></p><ul><li>《分佈式鎖的幾種實現方式》</li><li class=ql-indent-1>基於數據庫的分佈式鎖：優點：操作簡單、容易理解。缺點：存在單點問題、數據庫性能夠開銷較大、不可重入；</li><li class=ql-indent-1>基於緩存的分佈式鎖：優點：非阻塞、性能好。缺點：操作不好容易造成鎖無法釋放的情況。</li><li class=ql-indent-1>Zookeeper 分佈式鎖：通過有序臨時節點實現鎖機制，自己對應的節點需要最小，則被認為是獲得了鎖。優點：集群可以透明解決單點問題，避免鎖不被釋放問題，同時鎖可以重入。缺點：性能不如緩存方式，吞吐量會隨著zk集群規模變大而下降。</li><li>《基於Zookeeper的分佈式鎖》</li><li class=ql-indent-1>清楚的原理描述 + Java 代碼示例。</li><li>《jedisLock—redis分佈式鎖實現》</li><li class=ql-indent-1>基於 setnx(set if ont exists)，有則返回false，否則返回true。並支持過期時間。</li><li>《Memcached 和 Redis 分佈式鎖方案》</li><li class=ql-indent-1>利用 memcached 的 add（有別於set）操作，當key存在時，返回false。</li></ul><p><strong>分佈式一致性算法</strong></p><p><strong>PAXOS</strong></p><ul><li>《分佈式系列文章——Paxos算法原理與推導》</li><li>《Paxos-->Fast Paxos-->Zookeeper分析》</li><li>《【分佈式】Zookeeper與Paxos》</li></ul><p><strong>Zab</strong></p><ul><li>《Zab：Zookeeper 中的分佈式一致性協議介紹》</li></ul><p><strong>Raft</strong></p><ul><li>《Raft 為什麼是更易理解的分佈式一致性算法》</li><li class=ql-indent-1>三種角色：Leader（領袖）、Follower（群眾）、Candidate（候選人）</li><li class=ql-indent-1>通過隨機等待的方式發出投票，得票多的獲勝。</li></ul><p><strong>Gossip</strong></p><ul><li>《Gossip算法》</li></ul><p><strong>兩階段提交、多階段提交</strong></p><ul><li>《關於分佈式事務、兩階段提交協議、三階提交協議》</li></ul><p><strong>冪等</strong></p><ul><li>《分佈式系統---冪等性設計》</li><li class=ql-indent-1>冪等特性的作用：該資源具備冪等性，請求方無需擔心重複調用會產生錯誤。</li><li class=ql-indent-1>常見保證冪等的手段：MVCC（類似於樂觀鎖）、去重表(唯一索引)、悲觀鎖、一次性token、序列號方式。</li></ul><p><strong>分佈式一致方案</strong></p><ul><li>《分佈式系統事務一致性解決方案》</li><li>《保證分佈式系統數據一致性的6種方案》</li></ul><p><strong>分佈式 Leader 節點選舉</strong></p><ul><li>《利用zookeeper實現分佈式leader節點選舉》</li></ul><p><strong>TCC(Try/Confirm/Cancel) 柔性事務</strong></p><ul><li>《傳統事務與柔性事務》</li><li class=ql-indent-1>基於BASE理論：基本可用、柔性狀態、最終一致。</li><li class=ql-indent-1>解決方案：記錄日誌+補償（正向補充或者回滾）、消息重試(要求程序要冪等)；“無鎖設計”、採用樂觀鎖機制。</li></ul><p><strong>分佈式文件系統</strong></p><ul><li>說說分佈式文件存儲系統-基本架構 ？</li><li>《各種分佈式文件系統的比較》 ？</li><li class=ql-indent-1>HDFS：大批量數據讀寫，用於高吞吐量的場景，不適合小文件。</li><li class=ql-indent-1>FastDFS：輕量級、適合小文件。</li></ul><p><strong>唯一ID 生成</strong></p><p><strong>全局唯一ID</strong></p><ul><li>《高併發分佈式系統中生成全局唯一Id彙總》</li><li class=ql-indent-1>Twitter 方案（Snowflake 算法）：41位時間戳+10位機器標識（比如IP，服務器名稱等）+12位序列號(本地計數器)</li><li class=ql-indent-1>Flicker 方案：MySQL自增ID + "REPLACE INTO XXX:SELECT LAST_INSERT_ID();"</li><li class=ql-indent-1>UUID：缺點，無序，字符串過長，佔用空間，影響檢索性能。</li><li class=ql-indent-1>MongoDB 方案：利用 ObjectId。缺點：不能自增。</li><li>《TDDL 在分佈式下的SEQUENCE原理》</li><li class=ql-indent-1>在數據庫中創建 sequence 表，用於記錄，當前已被佔用的id最大值。</li><li class=ql-indent-1>每臺客戶端主機取一個id區間（比如 1000~2000）緩存在本地，並更新 sequence 表中的id最大值記錄。</li><li class=ql-indent-1>客戶端主機之間取不同的id區間，用完再取，使用樂觀鎖機制控制併發。</li></ul><p>一<strong>致性Hash算法</strong></p><ul><li>《一致性哈希算法》</li></ul><h1><br></h1><h1>設計思想 & 開發模式</h1><p><strong>DDD(Domain-driven Design - 領域驅動設計)</strong></p><ul><li>《淺談我對DDD領域驅動設計的理解》</li><li class=ql-indent-1>概念：DDD 主要對傳統軟件開發流程(分析-設計-編碼)中各階段的割裂問題而提出，避免由於一開始分析不明或在軟件開發過程中的信息流轉不一致而造成軟件無法交付（和需求方設想不一致）的問題。DDD 強調一切以領域（Domain）為中心，強調領域專家（Domain Expert）的作用，強調先定義好領域模型之後在進行開發，並且領域模型可以指導開發（所謂的驅動）。</li><li class=ql-indent-1>過程：理解領域、拆分領域、細化領域，模型的準確性取決於模型的理解深度。</li><li class=ql-indent-1>設計：DDD 中提出了建模工具，比如聚合、實體、值對象、工廠、倉儲、領域服務、領域事件來幫助領域建模。</li><li>《領域驅動設計的基礎知識總結》</li><li class=ql-indent-1>領域（Doamin）本質上就是問題域，比如一個電商系統，一個論壇系統等。</li><li class=ql-indent-1>界限上下文（Bounded Context）：闡述子域之間的關係，可以簡單理解成一個子系統或組件模塊。</li><li class=ql-indent-1>領域模型（Domain Model）：DDD的核心是建立（用通用描述語言、工具—領域通用語言）正確的領域模型；反應業務需求的本質，包括實體和過程；其貫穿軟件分析、設計、開發 的整個過程；常用表達領域模型的方式：圖、代碼或文字；</li><li class=ql-indent-1>領域通用語言：領域專家、開發設計人員都能立即的語言或工具。</li><li class=ql-indent-1>經典分層架構：用戶界面/展示層、應用層、領域層、基礎設施層，是四層架構模式。</li><li>使用的模式：</li><li class=ql-indent-2>關聯儘量少，儘量單項，儘量降低整體複雜度。</li><li class=ql-indent-2>實體（Entity）：領域中的唯一標示，一個實體的屬性儘量少，少則清晰。</li><li class=ql-indent-2>值對象（Value Object）：沒有唯一標識，且屬性值不可變，小二簡單的對象，比如Date。</li><li class=ql-indent-2>領域服務（Domain Service）： 協調多個領域對象，只有方法沒有狀態(不存數據)；可以分為應用層服務，領域層服務、基礎層服務。</li><li class=ql-indent-2>聚合及聚合根（Aggregate，Aggregate Root）：聚合定義了一組具有內聚關係的相關對象的集合；聚合根是對聚合引用的唯一元素；當修改一個聚合時，必須在事務級別；大部分領域模型中，有70%的聚合通常只有一個實體，30%只有2~3個實體；如果一個聚合只有一個實體，那麼這個實體就是聚合根；如果有多個實體，那麼我們可以思考聚合內哪個對象有獨立存在的意義並且可以和外部直接進行交互；</li><li class=ql-indent-2>工廠（Factory）：類似於設計模式中的工廠模式。</li><li class=ql-indent-1>倉儲（Repository）：持久化到DB，管理對象，且只對聚合設計倉儲。</li><li>《領域驅動設計(DDD)實現之路》</li><li class=ql-indent-1>聚合：比如一輛汽車（Car）包含了引擎（Engine）、車輪（Wheel）和油箱（Tank）等組件，缺一不可。</li><li>《領域驅動設計系列（2）淺析VO、DTO、DO、PO的概念、區別和用處》</li></ul><p><strong>命令查詢職責分離(CQRS)</strong></p><p>CQRS — Command Query Responsibility Seperation</p><ul><li>《領域驅動設計系列 (六)：CQRS》</li><li class=ql-indent-1>核心思想：讀寫分離（查詢和更新在不同的方法中），不同的流程只是不同的設計方式，CQ代碼分離，分佈式環境中會有明顯體現（有冗餘數據的情況下），目的是為了高性能。</li><li>《DDD CQRS架構和傳統架構的優缺點比較》</li><li class=ql-indent-1>最終一致的設計理念；依賴於高可用消息中間件。</li><li>《CQRS架構簡介》</li><li class=ql-indent-1>一個實現 CQRS 的抽象案例。</li><li>《深度長文：我對CQRS/EventSourcing架構的思考》</li><li class=ql-indent-1>CQRS 模式分析 + 12306 搶票案例</li></ul><p><strong>貧血，充血模型</strong></p><ul><li>《貧血，充血模型的解釋以及一些經驗》</li><li class=ql-indent-1>失血模型：老子和兒子分別定義，相互不知道，二者實體定義中完全沒有業務邏輯，通過外部Service進行關聯。</li><li class=ql-indent-1>貧血模型：老子知道兒子，兒子也知道老子；部分業務邏輯放到實體中；優點：各層單項依賴，結構清楚，易於維護；缺點：不符合OO思想，相比於充血模式，Service層較為厚重；</li><li class=ql-indent-1>充血模型：和貧血模型類似，區別在於如何劃分業務邏輯。優點：Service層比較薄，只充當Facade的角色，不和DAO打交道、複合OO思想；缺點：非單項依賴，DO和DAO之間雙向依賴、和Service層的邏輯劃分容易造成混亂。</li><li class=ql-indent-1>腫脹模式：是一種極端情況，取消Service層、全部業務邏輯放在DO中；優點：符合OO思想、簡化了分層；缺點：暴露信息過多、很多非DO邏輯也會強行併入DO。這種模式應該避免。</li><li class=ql-indent-1>作者主張使用貧血模式。</li></ul><p><strong>Actor 模式</strong></p><p>TODO</p><p><strong>響應式編程</strong></p><p><strong>Reactor</strong></p><p>TODO</p><p><strong>RxJava</strong></p><p>TODO</p><p><strong>Vert.x</strong></p><p>TODO</p><p><strong>DODAF2.0</strong></p><ul><li>《DODAF2.0方法論》</li><li>《DODAF2.0之能力視角如何落地》</li></ul><p><strong>Serverless</strong></p><p><strong>無需過多關係服務器的服務架構理念。</strong></p><ul><li>《什麼是Serverless無服務器架構？》</li><li class=ql-indent-1>Serverless 不代表出去服務器，而是去除對服務器運行狀態的關心。</li><li class=ql-indent-1>Serverless 代表一思維方式的轉變，從“構建一套服務在一臺服務器上，對對個事件進行響應轉變為構建一個為服務器，來響應一個事件”。</li><li class=ql-indent-1>Serverless 不代表某個具體的框架。</li><li>《如何理解Serverless？》</li><li class=ql-indent-1>依賴於 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li></ul><p><strong>Service Mesh</strong></p><ul><li>《什麼是Service Mesh？》</li><li>《初識 Service Mesh》</li></ul><h1><br></h1><h1>項目管理</h1><p><strong>架構評審</strong></p><ul><li>《架構設計之如何評審架構設計說明書》</li><li>《人人都是架構師：非功能性需求》</li></ul><p><strong>重構</strong></p><ul><li>《架構之重構的12條軍規》</li></ul><p><strong>代碼規範</strong></p><ul><li>《阿里巴巴Java開發手冊》</li></ul><p><strong>代碼 Review</strong></p><p><strong>制度還是制度! 另外，每個公司需要根據自己的需求和目標制定自己的 check list</strong></p><ul><li>《為什麼你做不好 Code Review？》</li><li class=ql-indent-1>代碼 review 做的好，在於制度建設。</li><li>《從零開始Code Review》</li><li>《Code Review Checklist》</li><li>《Java Code Review Checklist》</li><li>《如何用 gitlab 做 code review》</li></ul><p><strong>RUP</strong></p><ul><li>《運用RUP 4+1視圖方法進行軟件架構設計》</li></ul><p><strong>看板管理</strong></p><ul><li>《說說看板在項目中的應用》</li></ul><p><strong>SCRUM</strong></p><p><strong>SCRUM - 爭球</strong></p><ul><li>3個角色:Product Owner(PO) 產品負責人;Scrum Master（SM），推動Scrum執行;Team 開發團隊。</li><li>3個工件：Product Backlog 產品TODOLIST，含優先級;Sprint Backlog 功能開發 TODO LIST；燃盡圖；</li><li>五個價值觀：專注、勇氣、公開、承諾、尊重。</li><li>《敏捷項目管理流程-Scrum框架最全總結！》</li><li>《敏捷其實很簡單3---敏捷方法之scrum》</li></ul><p><strong>敏捷開發</strong></p><p>TODO</p><p><strong>極限編程（XP）</strong></p><p><strong>XP - eXtreme Programming</strong></p><ul><li>《主流敏捷開發方法：極限編程XP》</li><li>是一種指導開發人員的方法論。</li><li class=ql-indent-1><br></li><li>4大價值：</li><li class=ql-indent-2>溝通：鼓勵口頭溝通，提高效率。</li><li class=ql-indent-2>簡單：夠用就好。</li><li class=ql-indent-2>反饋：及時反饋、通知相關人。</li><li class=ql-indent-1>勇氣：提倡擁抱變化，敢於重構。</li><li class=ql-indent-1>5個原則：快速反饋、簡單性假設、逐步修改、提倡更改（小步快跑）、優質工作（保證質量的前提下保證小步快跑）。</li><li class=ql-indent-1>5個工作：階段性衝刺；衝刺計劃會議；每日站立會議；衝刺後review；回顧會議。</li></ul><p><strong>結對編程</strong></p><p><strong>邊寫碼，邊review。能夠增強代碼質量、減少bug。</strong></p><ul><li>《結對編程》</li></ul><p><strong>PDCA 循環質量管理</strong></p><p><strong>P——PLAN 策劃，D——DO 實施，C——CHECK 檢查，A——ACT 改進</strong></p><ul><li>《PDCA》</li></ul><p><strong>FMEA管理模式</strong></p><p>TODO</p><h1><br></h1><h1>通用業務術語</h1><p>TODO</p><h1><br></h1><h1>技術趨勢</h1><p>TODO</p><div class=pgc-img><img alt=Java後端架構師技術圖譜，你都瞭解多少？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1d4f02c014074d2bbe2de0630f061e94><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>端架構</a></li><li><a>師技術</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/882f16a4.html alt=阿里Java實習五面詳細面經，已拿offer！（附帶面試題解答） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/edaf055d-b7a3-43d4-9a68-c18f27a83d2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/882f16a4.html title=阿里Java實習五面詳細面經，已拿offer！（附帶面試題解答）>阿里Java實習五面詳細面經，已拿offer！（附帶面試題解答）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>