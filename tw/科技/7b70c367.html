<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>代碼規範—使用 TypeScript 裝飾器 | 极客快訊</title><meta property="og:title" content="代碼規範—使用 TypeScript 裝飾器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/dfic-imagehandler/4b5097e2-c4fd-4d37-9c54-707760739775"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="代碼規範—使用 TypeScript 裝飾器"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7b70c367.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>代碼規範—使用 TypeScript 裝飾器</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>裝飾器讓程序員可以編寫元信息以內省代碼。裝飾器的最佳使用場景是橫切關注點——面向切面編程。<br></p><blockquote><p><strong>面向切面編程（AOP）</strong> 是一種編程範式，它允許我們分離橫切關注點，藉此達到增加模塊化程度的目標。它可以在不修改代碼自身的前提下，給已有代碼增加額外的行為（通知）。</p></blockquote><pre>@log// 類裝飾器classPerson { constructor(private firstName: string, private lastName: string) {}@log// 方法裝飾器 getFullName() {return`${this.firstName} ${this.lastName}`; }}const person = newPerson('Mohan', 'Ram');person.getFullName();</pre><p>上面的代碼展示了裝飾器多麼具有聲明性。下面我們將介紹裝飾器的細節：</p><ol start=1><li>什麼是裝飾器？它的目的和類型</li><li>裝飾器的簽名</li><li>方法裝飾器</li><li>屬性裝飾器</li><li>參數裝飾器</li><li>訪問器裝飾器</li><li>類裝飾器</li><li>裝飾器工廠</li><li>元信息反射 API</li><li>結語</li></ol><p>什麼是裝飾器？它的目的和類型</p><blockquote><p>裝飾器是一種特殊的聲明，可附加在類、方法、訪問器、屬性、參數聲明上。</p></blockquote><p>裝飾器使用 @expression 的形式，其中 expression 必須能夠演算為在運行時調用的函數，其中包括裝飾聲明信息。</p><p>它起到了以聲明式方法將元信息添加至已有代碼的作用。</p><p>裝飾器類型及其執行優先級為</p><ol start=1><li>類裝飾器——優先級 4 （對象實例化，靜態）</li><li>方法裝飾器——優先級 2 （對象實例化，靜態）</li><li>訪問器或屬性裝飾器——優先級 3 （對象實例化，靜態）</li><li>參數裝飾器——優先級 1 （對象實例化，靜態）</li></ol><p>注意，如果裝飾器應用於類構造函數的參數，那麼不同裝飾器的優先級為：1. 參數裝飾器，2. 方法裝飾器，3. 訪問器或參數裝飾器，4. 構造器參數裝飾器，5. 類裝飾器。</p><pre>// 這是一個裝飾器工廠——有助於將用戶參數傳給裝飾器聲明function f() { console.log("f(): evaluated");returnfunction (target, propertyKey: string, descriptor: PropertyDescriptor) { console.log("f(): called"); }}function g() { console.log("g(): evaluated");returnfunction (target, propertyKey: string, descriptor: PropertyDescriptor) { console.log("g(): called"); }}class C {@f()@g() method() {}}// f(): evaluated// g(): evaluated// g(): called// f(): called</pre><p>我們看到，上面的代碼中， f 和 g 返回了另一個函數（裝飾器函數）。f 和 g 稱為裝飾器工廠。</p><blockquote><p><strong>裝飾器工廠</strong> 幫助用戶傳遞可供裝飾器利用的參數。</p></blockquote><p>我們還可以看到，<strong>演算順序</strong>為<strong>由頂向下</strong>，<strong>執行順序</strong>為<strong>由底向上</strong>。</p><p>裝飾器的簽名</p><pre>declare type ClassDecorator = &lt;TFunctionextendsFunction&gt;(target: TFunction) =&gt; TFunction | void;declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void;declare type MethodDecorator = &lt;T&gt;( target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt;TypedPropertyDescriptor&lt;T&gt; | void;</pre><p>方法裝飾器</p><p>從上面的簽名中，我們可以看到方法裝飾器函數有三個參數：</p><ol start=1><li><strong>target</strong> —— 當前對象的原型，也就是說，假設 Employee 是對象，那麼 target 就是 Employee.prototype</li><li><strong>propertyKey</strong> —— 方法的名稱</li><li><strong>descriptor</strong> —— 方法的屬性描述符，即 Object.getOwnPropertyDescriptor(Employee.prototype,propertyKey)</li></ol><pre>exportfunction logMethod( target: Object, propertyName: string, propertyDescriptor: PropertyDescriptor): PropertyDescriptor {// target === Employee.prototype// propertyName === "greet"// propertyDesciptor === Object.getOwnPropertyDescriptor(Employee.prototype, "greet")const method = propertyDesciptor.value; propertyDesciptor.value = function (...args: any[]) {// 將 greet 的參數列表轉換為字符串constparams = args.map(a =&gt; JSON.stringify(a)).join();// 調用 greet() 並獲取其返回值const result = method.apply(this, args);// 轉換結尾為字符串const r = JSON.stringify(result);// 在終端顯示函數調用細節 console.log(`Call: ${propertyName}(${params}) =&gt; ${r}`);// 返回調用函數的結果return result; }return propertyDesciptor;};classEmployee { constructor(private firstName: string, private lastName: string ) {}@logMethod greet(message: string): string {return`${this.firstName} ${this.lastName} says: ${message}`; }}const emp = newEmployee('Mohan Ram', 'Ratnakumar');emp.greet('hello');</pre><p>上面的代碼應該算是自解釋的——讓我們看看編譯後的 JavaScript 是什麼樣的。</p><pre>"use strict";var __decorate = (this &amp;&amp; this.__decorate) ||function (decorators, target, key, desc) {// 函數參數長度var c = arguments.length/** * 處理結果 * 如果僅僅傳入了裝飾器數組和目標，那麼應該是個類裝飾器。 * 否則，如果描述符（第 4 個參數）為 null，就根據已知值準備屬性描述符， * 反之則使用同一描述符。 */var r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;// 聲明存儲裝飾器的變量var d;// 如果原生反射可用，使用原生反射觸發裝飾器if (typeofReflect === "object" &amp;&amp; typeofReflect.decorate === "function") { r = Reflect.decorate(decorators, target, key, desc) }else {// 自右向左迭代裝飾器for (var i = decorators.length - 1; i &gt;= 0; i--) {// 如果裝飾器合法，將其賦值給 dif (d = decorators[i]) {/** * 如果僅僅傳入了裝飾器數組和目標，那麼應該是類裝飾器， * 傳入目標調用裝飾器。 * 否則，如果 4 個參數俱全，那麼應該是方法裝飾器， * 據此進行調用。 * 反之則使用同一描述符。 * 如果傳入了 3 個參數，那麼應該是屬性裝飾器，可進行相應的調用。 * 如果以上條件皆不滿足，返回處理的結果。 */ r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r } } };/** * 由於只有方法裝飾器需要根據應用裝飾器的結果修正其屬性， * 所以最後返回處理好的 r */return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; };varEmployee = /** @class */ (function () {functionEmployee(firstName, lastName) {this.firstName = firstName;this.lastName = lastName; }Employee.prototype.greet = function (message) {returnthis.firstName + " " + this.lastName + " says: " + message; };// typescript 調用 `__decorate` 輔助函數，// 以便在對象原型上應用裝飾器 __decorate([ logMethod ], Employee.prototype, "greet");returnEmployee;}());var emp = newEmployee('Mohan Ram', 'Ratnakumar');emp.greet('hello');</pre><p>讓我們開始分析 Employee 函數——構造器初始化 name 參數和 greet 方法，將其加入原型。</p><pre>__decorate([logMethod], Employee.prototype, "greet");</pre><p>這是 TypeScript 自動生成的通用方法，它根據裝飾器類型和相應參數處理裝飾器函數調用。</p><p>該函數有助於內省方法調用，併為開發者鋪平了處理類似<strong>日誌</strong>、<strong>記憶化</strong>、<strong>應用配置</strong>等橫切關注點的道路。</p><p>在這個例子中，我們僅僅打印了函數調用及其參數、響應。</p><p>注意，閱讀 __decorate 方法中的詳細註釋可以理解其內部機制。</p><p>屬性裝飾器</p><p>屬性裝飾器函數有兩個參數：</p><ol start=1><li><strong>target</strong> —— 當前對象的原型，也就是說，假設 Employee 是對象，那麼 target 就是 Employee.prototype</li><li><strong>propertyKey</strong> —— 屬性的名稱</li></ol><pre>function logParameter(target: Object, propertyName: string) {// 屬性值let _val = this[propertyName];// 屬性讀取訪問器const getter = () =&gt; { console.log(`Get: ${propertyName} =&gt; ${_val}`);return _val; };// 屬性寫入訪問器const setter = newVal =&gt; { console.log(`Set: ${propertyName} =&gt; ${newVal}`); _val = newVal; };// 刪除屬性if (deletethis[propertyName]) {// 創建新屬性及其讀取訪問器、寫入訪問器Object.defineProperty(target, propertyName, {get: getter,set: setter, enumerable: true, configurable: true }); }}classEmployee {@logParameter name: string;}const emp = newEmployee();emp.name = 'Mohan Ram';console.log(emp.name);// Set: name =&gt; Mohan Ram// Get: name =&gt; Mohan Ram// Mohan Ram</pre><p>上面的代碼中，我們在裝飾器中內省屬性的可訪問性。下面是編譯後的代碼。</p><pre>varEmployee = /** @class */ (function () {functionEmployee() { } __decorate([ logParameter ], Employee.prototype, "name");returnEmployee;}());var emp = newEmployee();emp.name = 'Mohan Ram'; // Set: name =&gt; Mohan Ramconsole.log(emp.name); // Get: name =&gt; Mohan Ram</pre><p>參數裝飾器</p><p>參數裝飾器函數有三個參數：</p><ol start=1><li><strong>target</strong> —— 當前對象的原型，也就是說，假設 Employee 是對象，那麼 target 就是 Employee.prototype</li><li><strong>propertyKey</strong> —— 參數的名稱</li><li><strong>index</strong> —— 參數數組中的位置</li></ol><pre>function logParameter(target: Object, propertyName: string, index: number) {// 為相應方法生成元數據鍵，以儲存被裝飾的參數的位置const metadataKey = `log_${propertyName}_parameters`;if (Array.isArray(target[metadataKey])) { target[metadataKey].push(index); }else { target[metadataKey] = [index]; }}classEmployee { greet(@logParameter message: string): string {return`hello ${message}`; }}const emp = newEmployee();emp.greet('hello');</pre><p>在上面的代碼中，我們收集了所有被裝飾的方法參數的索引或位置，作為元數據加入對象的原型。下面是編譯後的代碼。</p><pre>// 返回接受參數索引和裝飾器的函數var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) {// 該函數返回裝飾器returnfunction (target, key) { decorator(target, key, paramIndex); }};varEmployee = /** @class */ (function () {functionEmployee() {}Employee.prototype.greet = function (message) {return"hello " + message; }; __decorate([ __param(0, logParameter) ], Employee.prototype, "greet");returnEmployee;}());var emp = newEmployee();emp.greet('hello');</pre><p>類似之前見過的 __decorate 函數， __param 函數返回一個封裝參數裝飾器的裝飾器。</p><p>如我們所見，調用參數裝飾器時，會忽略其返回值。這意味著，調用 __param 函數時，其返回值不會用來覆蓋參數值。</p><p>這就是<strong>參數裝飾器不返回</strong>的原因所在。</p><p>訪問器裝飾器</p><p>訪問器不過是類聲明中屬性的讀取訪問器和寫入訪問器。</p><p><strong>訪問器裝飾器</strong>應用於訪問器的<strong>屬性描述符</strong>，可用於觀測、修改、替換訪問器的定義。</p><pre>function enumerable(value: boolean) {returnfunction ( target: any, propertyKey: string, descriptor: PropertyDescriptor) { console.log('decorator - sets the enumeration part of the accessor'); descriptor.enumerable = value; };}classEmployee {private _salary: number;private _name: string;@enumerable(false)get salary() { return`Rs. ${this._salary}`; }set salary(salary: any) { this._salary = +salary; }@enumerable(true)get name() {return`Sir/Madam, ${this._name}`; }set name(name: string) {this._name = name; }}const emp = newEmployee();emp.salary = 1000;for (let prop in emp) { console.log(`enumerable property = ${prop}`);}// salary 屬性不在清單上，因為我們將其設為假// output:// decorator - sets the enumeration part of the accessor// decorator - sets the enumeration part of the accessor// enumerable property = _salary// enumerable property = name</pre><p>上面的例子中，我們定義了兩個訪問器 name 和 salary，並通過裝飾器設置是否將其列入清單，據此決定對象的行為。name 將列入清單，而 salary 不會。</p><p>注意：TypeScript 不允許同時裝飾單一成員的 get 和 set 訪問器。相反，所有成員的裝飾器都必須應用於首個指定的訪問器（根據文檔順序）。這是因為裝飾器應用於屬性描述符，屬性描述符結合了 get 和 set訪問器，而不是分別應用於每項聲明。</p><p>下面是編譯的代碼。</p><pre>function enumerable(value) {returnfunction (target, propertyKey, descriptor) { console.log('decorator - sets the enumeration part of the accessor'); descriptor.enumerable = value; };}varEmployee = /** @class */ (function () {functionEmployee() { }Object.defineProperty(Employee.prototype, "salary", {get: function () { return"Rs. " + this._salary; },set: function (salary) { this._salary = +salary; }, enumerable: true, configurable: true });Object.defineProperty(Employee.prototype, "name", {get: function () {return"Sir/Madam, " + this._name; },set: function (name) {this._name = name; }, enumerable: true, configurable: true }); __decorate([ enumerable(false) ], Employee.prototype, "salary", null); __decorate([ enumerable(true) ], Employee.prototype, "name", null);returnEmployee;}());var emp = newEmployee();emp.salary = 1000;for (var prop in emp) { console.log("enumerable property = " + prop);}</pre><p>類裝飾器</p><p>類裝飾器應用於類的構造器，可用於觀測、修改、替換類定義。</p><pre>exportfunction logClass(target: Function) {// 保存一份原構造器的引用const original = target;// 生成類的實例的輔助函數function construct(constructor, args) {const c: any = function () {return constructor.apply(this, args); } c.prototype = constructor.prototype;returnnew c(); }// 新構造器行為const f: any = function (...args) { console.log(`New: ${original['name']} is created`);return construct(original, args); }// 複製 prototype 屬性，保持 intanceof 操作符可用 f.prototype = original.prototype;// 返回新構造器（將覆蓋原構造器）return f;}@logClassclassEmployee {}let emp = newEmployee();console.log('emp instanceof Employee');console.log(emp instanceofEmployee); // true</pre><p>上面的裝飾器聲明瞭一個名為 original 的變量，將其值設為被裝飾的類構造器。</p><p>接著聲明瞭名為 construct 的輔助函數。該函數用於創建類的實例。</p><p>我們接下來創建了一個名為 f 的變量，該變量將用作新構造器。該函數調用原構造器，同時在控制檯打印實例化的類名。這正是我們<strong>給原構造器加入額外行為</strong>的地方。</p><p>原構造器的原型複製到 f，以確保創建一個 Employee 新實例的時候， instanceof 操作符的效果符合預期。</p><p>新構造器一旦就緒，我們便返回它，以完成類構造器的實現。</p><p>新構造器就緒之後，每次創建實例時會在控制檯打印類名。</p><p>編譯後的代碼如下。</p><pre>varEmployee = /** @class */ (function () {functionEmployee() { }Employee = __decorate([ logClass ], Employee);returnEmployee;}());var emp = newEmployee();console.log('emp instanceof Employee');console.log(emp instanceofEmployee);</pre><p>在編譯後的代碼中，我們注意到兩處不同：</p><ol start=1><li>如你所見，傳給 __decorate 的參數有兩個，裝飾器數組和構造器函數。</li><li>TypeScript 編譯器使用 __decorate 的返回值以覆蓋原構造器。</li></ol><p>這正是<strong>類裝飾器必須返回一個構造函數</strong>的原因所在。</p><p>裝飾器工廠</p><p>由於每種裝飾器都有它自身的調用簽名，我們可以使用裝飾器工廠來泛化裝飾器調用。</p><pre>import { logClass } from'./class-decorator';import { logMethod } from'./method-decorator';import { logProperty } from'./property-decorator';import { logParameter } from'./parameter-decorator';// 裝飾器工廠，根據傳入的參數調用相應的裝飾器exportfunction log(...args) {switch (args.length) {case3: // 可能是方法裝飾器或參數裝飾器// 如果第三個參數是數字，那麼它是索引，所以這是參數裝飾器iftypeof args[2] === "number") {return logParameter.apply(this, args); }return logMethod.apply(this, args);case2: // 屬性裝飾器return logProperty.apply(this, args);case1: // 類裝飾器return logClass.apply(this, args);default: // 參數數目不合法thrownewError('Not a valid decorator'); }}@logclassEmployee {@logprivate name: string; constructor(name: string) {this.name = name; }@log greet(@log message: string): string {return`${this.name} says: ${message}`; }}</pre><p>元信息反射 API</p><p>元信息反射 API （例如 Reflect）能夠用來以標準方式組織元信息。</p><p>「反射」的意思是代碼可以偵測同一系統中的其他代碼（或其自身）。</p><p>反射在組合/依賴注入、運行時類型斷言、測試等使用場景下很有用。</p><pre>import"reflect-metadata";// 參數裝飾器使用反射 api 存儲被裝飾參數的索引exportfunction logParameter(target: Object, propertyName: string, index: number) {// 獲取目標對象的元信息const indices = Reflect.getMetadata(`log_${propertyName}_parameters`, target, propertyName) || []; indices.push(index);// 定義目標對象的元信息Reflect.defineMetadata(`log_${propertyName}_parameters`, indices, target, propertyName);}// 屬性裝飾器使用反射 api 獲取屬性的運行時類型exportfunction logProperty(target: Object, propertyName: string): void {// 獲取對象屬性的設計類型var t = Reflect.getMetadata("design:type", target, propertyName); console.log(`${propertyName} type: ${t.name}`); // name type: String}classEmployee {@logPropertyprivate name: string; constructor(name: string) {this.name = name; } greet(@logParameter message: string): string {return`${this.name} says: ${message}`; }}</pre><p>上面的代碼用到了 reflect-metadata 這個庫。其中，我們使用了反射元信息的設計鍵（例如：design:type）。目前只有三個：</p><ul class=list-paddingleft-2><li><strong>類型元信息</strong>用了元信息鍵 design:type。</li><li><strong>參數類型元信息</strong>用了元信息鍵 design:paramtypes。</li><li><strong>返回類型元信息</strong>用了元信息鍵 design:returntype。</li></ul><p>有了反射，我們就能夠在運行時得到以下信息：</p><ul class=list-paddingleft-2><li>實體<strong>名</strong>。</li><li>實體<strong>類型</strong>。</li><li>實體實現的<strong>接口</strong>。</li><li>實體<strong>構造器參數</strong>的名稱和類型。</li></ul><p>結語</p><ul class=list-paddingleft-2><li><strong>裝飾器</strong> 不過是在<strong>設計時（design time）</strong>幫助<strong>內省</strong>代碼，<strong>註解</strong>及修改類和屬性的函數。</li><li>Yehuda Katz 提議在 ECMAScript 2016 標準中加入裝飾器特性：tc39/proposal-decorators</li><li>我們可以通過<strong>裝飾器工廠</strong>將用戶提供的參數傳給裝飾器。</li><li>有 4 種裝飾器：<strong>類</strong>裝飾器、<strong>方法</strong>裝飾器、<strong>屬性/訪問器</strong>裝飾器、<strong>參數</strong>裝飾器。</li><li><strong>元信息反射 API</strong> 有助於以標準方式在對象中加入元信息，以及在<strong>運行時</strong>獲取<strong>設計類型信息</strong>。</li></ul><p>我把文中所有代碼示例都放到了 mohanramphp/typescript-decorators 這個 Git 倉庫中。謝謝閱讀！</p><div class=pgc-img><img alt="代碼規範—使用 TypeScript 裝飾器" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/4b5097e2-c4fd-4d37-9c54-707760739775><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>代碼</a></li><li><a>規範</a></li><li><a>TypeScript</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc3f9eb.html alt=解讀新規範——構建精細化橋樑之路 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9317d74f6fd541a6b6e1e5269a0a549c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc3f9eb.html title=解讀新規範——構建精細化橋樑之路>解讀新規範——構建精細化橋樑之路</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b38f41cc.html alt=無人機航攝的規範流程，讓你的飛機不再“碰壁” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/aea79096fbbf48cf9516345052e56d2f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b38f41cc.html title=無人機航攝的規範流程，讓你的飛機不再“碰壁”>無人機航攝的規範流程，讓你的飛機不再“碰壁”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html alt=住宅工程各類淨高的規範要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cff80b0991246f69fb67d91590b1d95 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html title=住宅工程各類淨高的規範要求，總結！>住宅工程各類淨高的規範要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/982ea866.html alt=住宅施工圖審查常見問題—《住宅設計規範》及其他規範涉及內容 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/6d80a01f0cdd468897170e3b4b3bb70f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/982ea866.html title=住宅施工圖審查常見問題—《住宅設計規範》及其他規範涉及內容>住宅施工圖審查常見問題—《住宅設計規範》及其他規範涉及內容</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7d1cac7.html alt=成人急性髓系白血病診療規範(2018年版) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/347f7f8605ff4b9c977adb7ffeee3a3d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7d1cac7.html title=成人急性髓系白血病診療規範(2018年版)>成人急性髓系白血病診療規範(2018年版)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52a9600f.html alt=各地清理規範“一票否決”和簽訂責任狀事項：讓基層幹部甩掉包袱輕裝上陣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5187c8e7ca7149bd895463ddd5f3b669 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52a9600f.html title=各地清理規範“一票否決”和簽訂責任狀事項：讓基層幹部甩掉包袱輕裝上陣>各地清理規範“一票否決”和簽訂責任狀事項：讓基層幹部甩掉包袱輕裝上陣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/54b76fa7.html alt="建強戰鬥堡壘 抓好清理規範 推動農村基層黨建邁上新臺階" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rh2hSGgGbHIe2f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/54b76fa7.html title="建強戰鬥堡壘 抓好清理規範 推動農村基層黨建邁上新臺階">建強戰鬥堡壘 抓好清理規範 推動農村基層黨建邁上新臺階</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e5918b5.html alt="昌吉清理規範基層檔案 紙上留痕少基層負擔輕" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e5918b5.html title="昌吉清理規範基層檔案 紙上留痕少基層負擔輕">昌吉清理規範基層檔案 紙上留痕少基層負擔輕</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/db24c3a4.html alt="江蘇部署“牌子亂象”清理規範工作 落實基層減負" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/db24c3a4.html title="江蘇部署“牌子亂象”清理規範工作 落實基層減負">江蘇部署“牌子亂象”清理規範工作 落實基層減負</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1aec48f.html alt="蘭州市公安局大幅清理規範基層派出所報表臺賬 迴歸主業 讓民警輕裝上陣" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/Ri8EAuuh4unwk style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1aec48f.html title="蘭州市公安局大幅清理規範基層派出所報表臺賬 迴歸主業 讓民警輕裝上陣">蘭州市公安局大幅清理規範基層派出所報表臺賬 迴歸主業 讓民警輕裝上陣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3796480.html alt=30項裝修施工規範工藝，節點驗收再也不怕被忽悠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1c5567e345948bf9d0e1d81f64d71ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3796480.html title=30項裝修施工規範工藝，節點驗收再也不怕被忽悠了>30項裝修施工規範工藝，節點驗收再也不怕被忽悠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc04193.html alt=《住宅裝修工程施工工藝及規範》把控，碧桂園實例，110頁ppt詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/aa78751f6c7e434d8f774ecf9b6861f2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc04193.html title=《住宅裝修工程施工工藝及規範》把控，碧桂園實例，110頁ppt詳解>《住宅裝修工程施工工藝及規範》把控，碧桂園實例，110頁ppt詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47cdf2b4.html alt=工地施工——木工工藝規範 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/10b05b0019be4201ab954d9ba4d13515 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47cdf2b4.html title=工地施工——木工工藝規範>工地施工——木工工藝規範</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45d519aa.html alt=工程施工——水電工藝規範 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/89bf5126a1604a55b168940858ee50a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45d519aa.html title=工程施工——水電工藝規範>工程施工——水電工藝規範</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f073e093.html alt=技術工藝管理模板大全：技術提升+規範、工藝設計+操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/61906b14-0af0-4197-9006-b227bd338714 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f073e093.html title=技術工藝管理模板大全：技術提升+規範、工藝設計+操作>技術工藝管理模板大全：技術提升+規範、工藝設計+操作</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>