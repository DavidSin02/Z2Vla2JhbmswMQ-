<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「計算機組成原理」：現代存儲器的結構 | 极客快訊</title><meta property="og:title" content="「計算機組成原理」：現代存儲器的結構 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/00b55c3055674199ad2684041baf094c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b9e90f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b9e90f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b9e90f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b9e90f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b9e90f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b9e90f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b9e90f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b9e90f.html><meta property="article:published_time" content="2020-10-29T21:05:09+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:09+08:00"><meta name=Keywords content><meta name=description content="「計算機組成原理」：現代存儲器的結構"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7b9e90f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「計算機組成原理」：現代存儲器的結構</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="background-color:#f3f5f9;--tt-darkmode-bgcolor: #BDBEC1">按照在計算機中作用的不同，存儲器分為緩衝存儲器、主存、輔助存儲器。按照存儲信息的材料或介質可以分為磁帶存儲器.磁盤存儲器、半導體存儲器、光盤存儲器。</span></p><p><strong>理想狀態中，我們將存儲器系統視為一個線性字節數組，CPU能在常數時間內訪問每個存儲器位置。</strong>但實際上存儲器系統（Memory System）是一個具有不同容量、成本和訪問時間的存儲設備的層次結構，分別具有以下幾部分：</p><ol start=1><li>CPU中的寄存器保存最常使用的數據，能在0個時鐘週期內訪問</li><li>高速緩存存儲器（Cache Memory）是靠近CPU的、較小的快速存儲器，保存一部分從主存儲器（Main Memory）取出的常用指令和數據，能在4~75個時鐘週期內訪問</li><li>主存緩存存儲磁盤上的數據，需要上百個時鐘週期訪問</li><li>磁盤存儲通過網絡連接的其他機器的磁盤或磁帶上的數據，需要幾千萬個週期進行訪問</li></ol><p>上方存儲器作為下方存儲器的緩存，速度更快、容量更小。</p><p><strong>存儲器的層次結構之所以有效，是因為程序具有局部性（Locality）的基本屬性</strong>，傾向於不斷訪問相同的數據項集合，或者傾向於訪問相鄰的數據項集合。我們希望程序能具有更好的局部性，使得數據項存儲在較高層次的存儲器中，這樣程序就會傾向於從存儲器結構中較高層次訪問數據項，運行會更快。</p><h1 class=pgc-h-arrow-right><strong>1 存儲技術</strong></h1><h1 class=pgc-h-arrow-right><strong>1.1 隨機訪問存儲器</strong></h1><p>隨機訪問存儲器（Random-Access Memory，RAM）根據存儲單元實現方式可以分為兩類：靜態的RAM（SRAM）和動態的RAM（DRAM）。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00b55c3055674199ad2684041baf094c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>1.1.1 SRAM</strong></h1><ul><li>將每個位保存到由6個晶體管電路構成的雙穩態的（Bistable）存儲器單元。</li><li><strong>屬性</strong>：可以無限期地保持在兩個不同的電壓配置或狀態之一，而其他的都是不穩定狀態，會迅速轉移到兩個穩定狀態之一。</li><li><strong>特點</strong>：由於具有雙穩態，所以只要有電，就會永遠保持它的值，即使有干擾，當干擾消除時就會恢復到穩態。</li></ul><p>由於SRAM存取速度較快，只要供電就會保持不變，對光和電噪音等干擾不敏感，但是每位的存儲需要6個晶體管，使得造價較為昂貴，且密集度低，使其適合作為小容量高速的高速緩存存儲器。</p><h1 class=pgc-h-arrow-right><strong>1.1.2 DRAM</strong></h1><ul><li>將每個位保存為，對一個由訪問晶體管控制的電容的充電。</li><li><strong>特點</strong>：由於每個存儲單元比較小，DRAM可以製造的十分密集，可以作為主存或圖形系統的幀緩衝區。由於通過電容電壓來保存位，當電容電壓受到擾動時就無法恢復了。並且電容存在漏電現象，存儲單元10~100毫秒會失去電荷，使得內存系統必須週期性通過讀出重寫來刷新內存的每一位。暴露在光線中會導致電容電壓改變。</li></ul><p>我們可以將<strong>w</strong>個DRAM單元組成一個<strong>超單元（Supercell）</strong>，使得一個超單元就能存儲w位的信息，並且將d個超單元組合在一個構成一個 d \times w<em>d</em>×<em>w</em> DRAM芯片，能夠存儲dw位信息，並且能對每個超單元進行尋址。並且為了降低地址引腳的數量，我們可以將d個超單元組織成r行、c列的陣列形式。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ebe0376cffc54d9888fdf17921a39fc5><p class=pgc-img-caption></p></div><p>如上圖所示，我們有一個16 \times 816×8的DRAM芯片，其中包含16個超單元，每個超單元由8個DRAM單元組成，使得每個超單元能存儲8位信息。並且16個超單元被組成4行4列的陣列形式。由一個<strong>內存控制器（Memory Controller）</strong>通過<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">addr</span></span>引腳和<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">data</span></span>引腳將控制DRAM芯片數據的傳入和傳出，比如想要獲得<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">(2,1)</span></span>處超單元的數據</p><ol start=1><li>內存控制器發送行地址（Row Access Strobe，RAS）2到DRAM芯片，則DRAM芯片會將行2中的整行內容複製到內部行緩衝區。</li><li>內存控制器發送列地址（Column Access Strobe，CAS）1到DRAM芯片，則DRAM芯片會從內部行緩衝區獲得1列的數據，將其發送到內存控制器。</li></ol><p><strong>注意：</strong></p><ul><li>內存控制器發送RAS和CAS時，使用相同的addr引腳，使得必須分兩步發送地址，會增加訪問時間。</li><li>如果將16個DRAM單元組織成線性形式，則需要4位的地址引腳才能索引到每個超單元，但是將其組織成4行4列的陣列形式，只需要2位的地址引腳。</li></ul><p>為了一次性能訪問更多的數據，可以將多個DRAM芯片封裝到一個內存模塊（Memory Module）中，將其扎到主板的擴展槽中。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8235f1dcd695442895b101b780ca80be><p class=pgc-img-caption></p></div><p>如上圖所示是封裝了<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">8</span></span>個 8M \times 88<em>M</em>×8 DRAM芯片的內存模塊，每個DRAM芯片負責<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">8</span></span>位數據，這樣一次能對<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">64</span></span>位字進行讀寫。比如想要獲得地址<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">A</span></span>處的字：</p><ul><li>內存控制器首先將A轉化為<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">(i,j)</span></span>的超單元地址，然後內存控制器依次將<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">i</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">j</span></span>廣播到所有DRAM芯片中</li><li>每個DRAM芯片依次接收到RAS <span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">i</span></span>和CAS <span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">j</span></span>，會通過上述的方法輸出<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">8</span></span>位數據</li><li>模塊中的電路收集到所有DRAM芯片輸出的8位數據，然後將其合併成一個64位的字，返回給內存控制器</li></ul><p>為了進一步擴大存儲能力，可以將多個內存模塊連接到內存控制器，能夠聚合成主存。當內存控制器想要讀取地址A處的字時，會先找到包含地址A的內存模塊k，然後根據上述步驟得到對應的字。</p><p>而基於傳統的DRAM單元，可以做一些優化來提高訪問基本DRAM單元的速度：</p><ul><li><strong>快頁模式DRAM（Fast Page Mode DRAM，FPM DRAM）：</strong>傳統的DRAM芯片通過CAS獲得數據後，會將那一行的數據從內部行緩衝區直接刪掉，如果訪問多個在同一行的超單元時，需要反覆讀取相同的行。而FPM DRAM能夠獲取一次性數據後，後面的讀取直接從內部行緩衝區讀取。</li><li><strong>擴展數據輸出DRAM（Extended Data Out DRAM，EDO DRAM）：</strong>對FPM DRAM進行改進，使得各個CAS信號在時間上更加緊密。</li><li><strong>同步DRAM（Synchronous DRAM，SDRAM）：</strong>DRAM芯片與內存控制器的通信使用一組顯示的控制信號，通常是異步的，而SDRAM使用了，控制內存控制器的外部時鐘信號的上升沿來代替控制信號。</li><li><strong>雙倍數據速率同步DRAM（Double Data-Rate Sychronous DRAM，DDR SDRAM）：</strong>對SDRAM的優化，通過使用兩個時鐘沿作為控制信號，從而使得DRAM的速度翻倍。</li><li><strong>視頻RAM（Video RAM，VRAM）：</strong> 用於圖形系統的幀緩衝區，與FPM DRAM的區別：VRAM的輸出是通過對內部緩衝區的移位得到的，VRAM允許對內存並行地讀和寫。</li></ul><p>從更高層面來看，數據流是通過稱為總線（Bus）的共享電子電路在處理器和DRAM主存之間傳遞數據的。總線是一組並行的導線，能夠攜帶地址、數據和控制信號，也可以將數據和地址信號使用相同的導線。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4175b4ecf7dc4dd69ac036638a1551ea><p class=pgc-img-caption></p></div><p>如上圖所示是一個連接CPU和DRAM主存的總線結構。其中I/O橋接器（I/O Bridge）芯片組包括內存控制器，能夠將系統總線的電子信號和內存總線的電子信號互相翻譯，也能將系統總線和內存總線連接到I/O總線。</p><p>當從內存加載數據到寄存器中：</p><ol start=1><li>CPU芯片通過<strong>總線接口（Bus Interface）</strong>在總線上發送<strong>讀事務（Read Transaction）</strong></li><li>CPU會將內存地址發送到系統總線上</li><li>I/O橋將信號傳遞到內存總線</li><li>內存接收到內存總線上的地址信號，會從DRAM讀取出數據字，然後將數據寫到內存總線</li><li>I/O橋將內存總線信號翻譯成系統總線信號，然後傳遞到系統總線上</li><li>CPU從總能線上讀取數據，並將其複製到寄存器中</li></ol><p>當將寄存器中的數據保存到內存中：</p><ol start=1><li>CPU芯片通過總線接口發起<strong>寫事務（Write Transaction）</strong></li><li>CPU會將內存地址發送到系統總線上</li><li>I/O橋將信號傳遞到內存總線</li><li>內存接收到內存總線上的地址信號，會等待數據到達</li><li>CPU將寄存器中的數據字複製到系統總線</li><li>I/O橋將內存總線信號翻譯成系統總線信號，然後傳遞到系統總線上</li><li>內存從內存總線讀出數據，並將其保存到DRAM中。</li></ol><p>這裡的讀事務和寫事務統稱為<strong>總線事務（Bus Transaction）。</strong></p><h1 class=pgc-h-arrow-right><strong>1.1.3 非易失性存儲器</strong></h1><p>之前介紹的DRAM和SRAM在斷電時都會丟失數據，所以是易失的（Volatile），而<strong>非易失性存儲器（Nonvolatile Memory）</strong>即使斷電後，也會保存信息，該類存儲器稱為<strong>只讀存儲器（Read-Only Memory，ROM）</strong>，但是現在ROM中有的類型既可以讀也可以寫了，可以根據ROM能夠重編程的次數以及對它們進行重編程所用的機制進行區分，包括：</p><ul><li>可編程ROM（PROM）：可以編程一次</li><li>可擦寫PROM（EPROM）：可以批量擦除</li><li>閃存（Flash Memory）：具有部分（塊級）擦除功能，大約擦除十萬次後會耗盡</li></ul><p>存儲在ROM設備中的程序稱為<strong>固件（Firmware）</strong>，包括BIOS、磁盤控制器、網卡、圖形加速器和安全子系統等。當計算機系統通電後，會運行存儲在ROM中的固件。</p><h1 class=pgc-h-arrow-right><strong>1.2 磁盤存儲</strong></h1><p><strong>磁盤（Disk）</strong>是被用來保存大量數據的存儲設備，但是讀信息的速度比DRAM慢10萬倍，比SRAM慢100萬倍。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3c77cb8f745436fb17090951c4706f8><p class=pgc-img-caption></p></div><p>如上圖所示是一個磁盤的構造。磁盤是由多個疊放在一起的<strong>盤片（Platter）</strong>構成，每個盤片有兩個覆蓋著磁性記錄材料的<strong>表面（Surface）</strong>。每個表面由一組稱為<strong>磁道（Track）</strong>的同心圓組成，每個磁道被劃分為若干<strong>扇區（Sector）</strong>，每個扇區包含相同數量的<strong>數據位（通常為512位）</strong>作為讀寫數據的基本單位。扇區之間通過<strong>間隙（Gap）</strong>分隔開來，間隙不保存數據信息，只用來表示扇區的格式化位。通常會使用<strong>柱面（Cylinder）</strong>來描述不同表面上相同磁道的集合，比如柱面<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k</span></span>就是6個表面上磁道<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k</span></span>的集合。盤片中央會有一個可以旋轉的<strong>主軸（Spindle）</strong>，使得盤片以固定的<strong>旋轉速率（Rotational Rate）</strong>旋轉，單位通常為<strong>RPM（Revolution Per Minute）</strong>。</p><p>將磁盤能記錄的最大位數稱為最大容量（容量），主要由以下方面決定：</p><ul><li><strong>記錄密度（Recording Density）</strong>：一英寸的磁道中可以放入的位數</li><li><strong>磁道密度（Track Density）</strong>：從盤片中心出發，沿著半徑方向一英寸，包含多少磁道</li><li><strong>面密度（Areal Density）</strong>：記錄密度和磁道密度的乘積</li></ul><p>磁盤容量的計算公式為：</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9a8016bddd5143ce83a916709cc6b33d><p class=pgc-img-caption></p></div><p>在面密度較低時，每個磁道都被分成了相同的扇區，所以能夠劃分的扇區數由最內側磁道能記錄的扇區數決定，這就使得外側的磁道具有很多間隙。現代大容量磁盤採用<strong>多區記錄（Multiple Zone Recording）</strong>技術，將一組連續的柱面劃分成一個區，在同一個區中，每個柱面的每條磁道都有相同數量的扇區，由該區中最內側的磁道決定，由此使得外側的區能劃分成更多的扇區。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a3386d1d7a994d87b6e6e2d56ec40547><p class=pgc-img-caption></p></div><p>如上圖所示，磁盤通過一個連接在<strong>傳動臂（Actuator Arm）</strong>上的<strong>讀/寫頭（Read/Write Head）</strong>來進行讀寫，對於有多個盤面的磁盤，會用多個位於同一柱面上的垂直排列的讀/寫頭。對於扇區的<strong>訪問時間（Access Time）</strong>由以下幾部分構成：</p><ul><li><strong>尋道時間：</strong>為了讀取到目標扇區，會先控制傳動臂將讀/寫頭移動到該扇區對應的磁道上，該時間稱為尋道時間。<strong>影響因素</strong>：依賴於讀/寫頭之前的位置，以及傳動臂在盤面上移動的速度。通常為3~9ms，最大時間可為20ms。<br>-<strong> 旋轉時間：</strong>當讀/寫頭處於目標磁道時，需要等待目標扇區的第一個位旋轉到讀/寫頭下。影響因素：目標扇區之前的位置，以及磁盤的旋轉速度。T_{max \, rotation} = \frac{1}{RPM} \cdot \frac{60s}{1min} ，平均旋轉時間為一半</li><li><strong>傳送時間：</strong>當讀/寫頭處於目標扇區的第一位時，就可以進行傳送了影響因素：磁盤旋轉速率，以及每條磁道的扇區數$$ T_{max \, rotation} = \frac{1}{RPM} \cdot \frac{1}{平均每條磁道的扇區數} \times \frac{60s}{1min} $$</li></ul><p><strong>可以發現：</strong>尋道時間和旋轉時間是主要影響部分，並且兩者大致相等，通常可以尋道時間乘2來估計訪問時間。</p><p>由於磁盤構造的複雜性，現代磁盤將其抽象為B個扇區大小的邏輯塊序列，編號為<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">0,1,...,B-1</span></span>，通過磁盤中的磁盤控制器來維護邏輯塊號和實際扇區之間的映射關係。為此需要通過磁盤控制器對磁盤進行格式化：</p><ul><li>會用表示扇區的信息填寫在扇區之間的間隙</li><li>表示出表面有故障的柱面，並且不進行使用</li><li>在每個區會預留一組柱面作為備用，沒有映射為邏輯塊。當損壞時，磁盤控制器會將數據複製到備用柱面，則磁盤就可以繼續正常工作了。</li></ul><p>當從磁盤讀取數據到主存，需要以下步驟：</p><ol start=1><li>操作系統發送一個命令到磁盤控制器，讀取某個邏輯塊號</li><li>磁盤控制器上的固件執行快速表查找，得到該邏輯塊號翻譯成一個三元組（盤面，磁道，扇區）</li><li>磁盤控制器解釋三元組信息，將讀/寫頭移動到對應的扇區</li><li>將讀取到的信息放到磁盤控制器的緩衝區中</li><li>將緩衝區中的數據保存到主存中。</li></ol><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a1d997ceed34f4c81df175b9f23c683><p class=pgc-img-caption></p></div><p>如上圖所示是一個總線結構實例。對於像圖形卡、鼠標、鍵盤、監視器這類輸入/輸出設備，都是通過I/O總線連接到CPU和主存的，比如Intel的<strong>外圍設備互聯（Peripheral Component Interconnect，PCI）總線</strong>，在PCI模型中，系統中所有的設備共享總線，一個時刻只能有一臺設備訪問這些線路，目前PCI總線已被PCEe總線取代了。雖然I/O總線比系統總線和內存總線慢，但是能容納種類繁多的第三方I/O設備。</p><ul><li><strong>通用串行總線（Universal Serial Bus，USB）控制器：</strong>USB總線是一個廣泛使用的標準，連接許多外圍I/O設備，而USB控制器作為連接到USB總線的設備的中轉站。</li><li><strong>圖形卡（或適配器）：</strong>包含硬件和軟件邏輯，負責CPU在顯示器上畫像素。</li><li><strong>主機總線適配器：</strong>用於將一個或多個磁盤連接到I/O總線，使用主機總線接口定義的通信協議，磁盤接口包括SCSI和SATA，通常SCSI磁盤比SATA磁盤速度更快更昂貴，且SCSI主機總線適配器可以支持多個磁盤驅動器，而SATA只能支持一個。</li><li><strong>網絡適配器：</strong>可以通過將適配器插入到主板上空的插槽，從而連接到I/O總線。</li></ul><p><strong>注意：</strong>系統總線和內存總線是與CPU相關的，而PCI總線這樣的I/O總線被設計成與底層CPU無關。</p><p>CPU會在地址空間中保留一塊地址用於與I/O設備通信，每個地址稱為I/O端口（I/O Port），而連接到總線的設備會被映射到一個或多個端口，則處理器可通過端口地址來訪問該I/O設備，該技術稱為<strong>內存映射I/O（Memory-mapped I/O）</strong>。</p><p>假設磁盤控制器映射到端口0xa0，探討磁盤的讀取過程：</p><ul><li>CPU會通過對地址0xa0執行三個存儲指令，將地址0xa0的內容保存到內存中，完成對磁盤的讀取。發送完指令後，由於磁盤讀取速度比CPU執行速度慢很多，所以CPU會先去執行其他工作。指令1：發送一個命令字，告訴磁盤發起一個Read指令2：指明應該讀取的邏輯塊號指令3：指明保存的內存地址</li><li>磁盤控制器接收到Read命令後，會通過上述方法直接將磁盤內容傳送到主存中。這種設備可以自己執行讀寫總線事務而無需CPU干涉的過程，稱為<strong>直接內存訪問（Direct Memory Access，DMA）</strong>。</li><li>磁盤發送完數據後，會給CPU發送一箇中斷信號，暫停CPU正在做的工作，然後將控制返回到CPU被中斷的地方。<strong>1.3 固態硬盤</strong></li></ul><p><strong>固態硬盤（Solid State Disk，SSD）</strong>是一種基於閃存的存儲技術，插在I/O總線上標準硬盤插槽（通常為USB或SATA），處於磁盤和DRAM存儲器的中間點。從CPU的角度來看，SSD與磁盤完全相同，有相同的接口和包裝。它由閃存和<strong>閃存翻譯層（Flash Translation Layer）</strong>組成</p><ul><li>閃存翻譯層是一個硬件/固件設備，用來將對邏輯塊的請求翻譯成對底層物理設備的訪問。</li><li>閃存的基本屬性決定了SSD隨機讀寫的性能，通常由B個塊的序列組成，每個塊由P頁組成，頁作為數據的單位進行讀寫。通常頁大小為512字節~4KB，塊中包含32~128頁，則塊的大小有16KB~512KB。</li></ul><p>當對頁進行寫操作時，首先需要先對該頁所處的整個塊進行擦除。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b3a9ec2f92de4ec5bea5ac67fb9c07ea><p class=pgc-img-caption></p></div><p>以上是Intel SSD 730的性能，IOPS是每秒I/O操作數，吞吐量數量基於4KB塊的讀寫。我們可以發現隨機寫操作較慢，這是因為：</p><ul><li>對頁進行寫操作時，通常需要花費較長時間來擦除塊，比訪問頁所需的時間慢了一個數量級</li><li>當塊中包含其他數據時，會先將塊中帶有有效數據的頁複製到被擦出過的塊中，才能對那個塊進行擦除。在閃存翻譯層中實現了複雜的邏輯，試圖最小化這些重複的操作。</li></ul><p>塊的擦除次數是有限的，當塊磨損後，就不能再使用了，閃存翻譯層中<strong>的平均磨損（Wear Leveling）</strong>邏輯會試圖將擦除平均到所有塊中，來最大化每個塊的壽命。</p><p>SSD的優缺點：</p><ul><li><strong>優點：</strong>由於閃存是半導體存儲器，沒有移動的部件，所以速度比磁盤更快且磨損小，能耗低</li><li><strong>缺點：</strong>SSD每字節比磁盤貴大約30倍，所以常用的存儲容量比磁盤小100倍左右。</li></ul><h1 class=pgc-h-arrow-right><strong>1.4 存儲技術趨勢</strong></h1><p>具有以下重要思想：</p><ul><li><strong>不同存儲技術有不同的價格和性能折中：</strong>從性能而言，SRAM>DRAM>SSD>磁盤，而從每字節造價而言，SRAM>DRAM>SSD>磁盤。</li><li>不同存儲技術的價格和性能屬性以不同的速率變化著</li></ul><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3a2b1495d11043c8b88fb3cc0d77e08e><p class=pgc-img-caption></p></div><p>從上一圖中可看出，DRAM主存和磁盤的性能滯後於CPU性能，訪問時間比單個處理器的週期時間慢很多，而SRAM的性能雖然也滯後於CPU性能，但是還保持增長，所以現代計算機會使用基於SRAM的高速緩存，來彌補CPU和內存之間的差距。</p><h1 class=pgc-h-arrow-right><strong>2 局部性</strong></h1><p>具有良好<strong>局部性（Locality）</strong>的程序，會傾向於引用最近引用過的數據項本身，或者引用最近引用過的數據項周圍的數據項。局部性主要具有兩種形式：</p><ul><li><strong>時間局部性（Temporal Locality）：</strong>引用過的數據項在不久會被多次引用。<br></li><li><strong>空間局部性（Spatial Locality）：</strong>引用過的數據項，在不久會引用附近的數據項。<br></li></ul><p>從硬件到操作系統，再到應用程序，都利用了局部性。</p><ul><li><strong>硬件：</strong>在處理器和主存之間引入一個小而快速的高速緩存存儲器，來保存最近引用的指令和數據，從而提高對主存的訪問速度。</li><li><strong>操作系統：</strong>用主存來緩存虛擬空間中最近被引用的數據塊。</li><li><strong>應用程序：</strong>比如<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">Web</span></span>瀏覽器會將最近引用的文檔放入本地磁盤中，來緩存服務器的數據。</li></ul><p>有良好局部性的程序比局部性較差的程序運行更快。</p><p>想要分析一個程序的局部性是否好，可以依次分析程序中的每個變量，然後根據所有變量的時間局部性和空間局部性來總和判斷程序的局部性。</p><p><strong>例1：</strong><br></p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/71ca4c5835894e9a93952fd1a6909018><p class=pgc-img-caption></p></div><p>分析上述程序的局部性。對於變量<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">sum</span></span>，每一輪迭代都會引用一次，所以<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">sum</span></span>具有好的時間局部性，而<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">sum</span></span>是標量，所以沒有空間局部性。對於變量<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">v</span></span>，其數據在內存中的分佈如圖<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">b</span></span>中所示，每一輪迭代都是引用不同的數據項，所以時間局部性較差，但是會按照內存存儲的順序依次引用數據項，所以空間局部性較好。 綜合來說，該程序具有較好的局部性。</p><p>並且由於程序是以指令形式保存在內存中的，而CPU會從內存中讀取指令，所以也可以考慮取指的局部性。由於該循環體內的指令是順序保存在內存中的，而CPU會按順序進行取指，所以具有良好的空間局部性，並且迭代多次會反覆讀取相同的指令，所以具有良好的時間局部性，所以該程序的局部性較好。</p><p>對於一個向量，如果每一輪引用的數據項之間在內存空間中相隔k，則稱該程序具有<strong>步長為k的引用模式（Stride-k Reference Pattern）</strong>。步長k越大，則每一輪引用的數據在內存中間隔很大，則空間局部性越差。</p><p><strong>例2：</strong><br></p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dd534f3445674a4f8298078e512c70a9><p class=pgc-img-caption></p></div><p>對於以上代碼，變量<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">sum</span></span>的時間局部性較好且不具有空間局部性，對於二維數組變量<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">v</span></span>，在內存中是按照行優先存儲的，而代碼中也是按照行優順序進行應用的，所以變量<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">v</span></span>具有步長為<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">1</span></span>的引用模式，所以具有較好的空間局部性，而時間局部性較差。總體來說，該程序具有良好的局部性。</p><p><strong>例3：</strong></p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cf006609e78a48b1b97525095dec70b8><p class=pgc-img-caption></p></div><p>上述代碼將變量<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">v</span></span>的引用順序變為了列優先，則根據<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">v</span></span>的內存存儲形式，變量<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">v</span></span>具有步長為<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">N</span></span>的引用模式，則時間局部性較差，且空間局部性也較差。總體來說，該程序的局部性較差。</p><p><strong>例4：</strong></p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/297cd801b4a6402dbe2f8aa490e1a310><p class=pgc-img-caption></p></div><p>我們需要判斷以上三個函數的局部性。首先根據結構體的定義可以得到結構體數組在內存中的存儲形式如下所示<br></p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/94b34aff010447bdbeb092fd9994e251><p class=pgc-img-caption></p></div><p>則<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">clear1</span></span>函數的步長為<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">1</span></span>，具有良好的空間局部性；而<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">clear2</span></span>函數會在結構體中不同的字段中反覆跳躍，空間局部性相對<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">clear1</span></span>差一些；而<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">clear3</span></span>函數會在相鄰兩個結構體中反覆跳躍，空間局部性相比<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">clear2</span></span>更差。</p><p><strong>總體而言：</strong></p><ul><li>重複引用相同變量的程序具有良好的時間局部性</li><li>考慮變量的內存存儲形式，判斷程序引用模式的步長，步長越大則空間局部性越差</li><li>從取指角度而言，具有循環體則空間局部性和時間局部性較好，而且循環體越小、迭代次數越多，則局部性越好。</li></ul><h1 class=pgc-h-arrow-right><strong>3 存儲器層次結構</strong></h1><p>通過上面兩節，我們可以得到<strong>存儲技術和軟件的基本屬性</strong>：</p><ul><li>不同存儲技術的訪問時間相差較大，速度快的技術每字節的成本比速度慢的技術高，且容量小。並且CPU和主存之間的差距在變大。</li><li>編寫良好的程序具有良好的局部性。</li></ul><p>兩者存在一定的互補，由此可以得到一種組織存儲器系統的方法，<strong>存儲器層次結構（Memory Hierarchy）</strong>。<br></p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7744d28d6d36472aa24d79a720abbc63><p class=pgc-img-caption></p></div><p>如上圖所示是一種經典的存儲器層次結構，會使用基於<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">SRAM</span></span>的高速緩存存儲器來解決<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">CPU</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">DRAM</span></span>主存之間的鴻溝，通常還可以在<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">DRAM</span></span>主存和本地磁盤之間添加一層<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">SSD</span></span>，來彌補兩者之間的差距。通常還可以在本地磁盤下方添加一個本地磁帶，提供成本更低的存儲。</p><p><strong>高速緩存（Cache）</strong>是一個小而快速的存儲設備，用來作為存儲在更大更慢設備中的數據對象的緩衝區域。而使用高速緩存的過程稱為<strong>緩存（Caching）</strong>。</p><p>存儲器層次結構的中心思想是讓層次結構中的每一層來緩存低一層的數據對象，將第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k</span></span>層的更快更小的存儲設備作為第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層的更大更慢的存儲設備的緩存。</p><p>該結構之所以有效，是因為程序的局部性原理。相比於第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層的數據，程序會傾向於訪問存儲在第k層的數據。如果我們訪問第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層存儲的數據，我們會將其拷貝到第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k</span></span>層，因為根據局部性原理我們很有可能將再次訪問該數據，由此我們就能以第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k</span></span>層的訪問速度來訪問數據。而且因為我們不經常訪問第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層的數據，我們就可以使用速度更慢且更便宜的存儲設備。</p><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/941fb041e3e8413c9b1c52328c6c7454><p class=pgc-img-caption></p></div><p><br>上圖展示的是存儲器層次結構的基本緩存原理。每一層存儲器都會被劃分成連續的數據對象組塊，稱為<strong>塊（Block）</strong>，每個塊都有一個唯一的地址或名字，並且通常塊的大小都是固定的。第k層作為第k+1層的緩存，數據會以塊大小作為傳送單元（Transfer Unit）在第k層和第k+1層之間來回賦值，使得第k層保存第k+1層塊的一個子集的副本。通常存儲器層次結構中較低層的設備的訪問時間較長，所以較低層中會使用較大的塊。</p><h1 class=pgc-h-arrow-right><strong>3.1 緩存命中</strong></h1><p>當程序需要第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層的某個數據對象d時，會先在第k層的塊中搜索<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">d</span></span>，如果<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">d</span></span>剛好緩存在第k層中，則成為<strong>緩存命中（Cache Hit）</strong>，則該程序會直接從第k層中讀取<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">d</span></span>。根據存儲器層次結構，可以知道第k層的讀取速度更快，因此緩存命中會使得程序更快。</p><h1 class=pgc-h-arrow-right><strong>3.2 緩存</strong><strong>不命</strong><strong>中</strong></h1><p>如果第k層沒有緩存數據對象<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">d</span></span>，則稱為<strong>緩存不命中（Cache Miss）</strong>，則會從第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層中取出包含<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">d</span></span>的塊，然後第k層的緩存會執行某個<strong>放置策略（Placement Policy）</strong>來決定該塊要保存在第k層的什麼位置</p><ul><li>來自第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層的任意塊能保存在第k層的任意塊中，如果第k層的緩存滿了，則會覆蓋現存的一個<strong>犧牲塊（Victim Block）</strong>，稱為<strong>替換（Replacing）或驅逐（Evicting</strong>）這個犧牲塊，會根據<strong>替換策略（Replacement Policy）</strong>來決定要替換第k層的哪個塊:<strong>隨機替換策略：</strong>會隨機選擇一個犧牲塊<strong>最近最少被使用（LRU）替換策略：</strong>選擇最後被訪問的時間離現在最遠的塊</li></ul><p>隨機放置塊會使得定位起來代價很高。</p><ul><li>可以採用更嚴格的放置策略，將第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層的某個塊限制放置在第k層塊的一個小的子集中，比如第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k+1</span></span>層的第i個塊保存在第k層的<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">i mod 4</span></span>中。但是該放置策略會引起<strong>衝突不命中（Conflict Miss）</strong>，此時緩衝區足夠大，但是由於需要的對象會反覆映射到同一個緩存塊，使得緩存一直不命中。此時就需要修改放置策略。</li></ul><p>比較特殊的情況是第<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">k</span></span>層的緩存為空，那麼對於任意的數據對象的訪問都會不命中。空的緩存稱為<strong>冷緩存（Cold Cache）</strong>，該不命中稱為<strong>強制性不命中（Compulsory Miss）或冷不命中（Cold Miss）</strong>。</p><p>程序通常會按照一系列階段來運行，每個階段會訪問緩存塊的某個相對穩定不變的集合，則該集合稱為<strong>工作集（Working Set）</strong>，如果工作集大小超過緩存大小，則緩存會出現<strong>容量不命中（Capacity Miss）</strong>，這是由緩存太小導致的。</p><h1 class=pgc-h-arrow-right><strong>3.3 緩存管理</strong></h1><p>對於每層存儲器，都會有某種形式的邏輯來管理緩存：將緩存劃分成塊、在不同層之間傳遞塊、判斷緩存是否命中並進行處理。</p><ul><li>編譯器管理寄存器文件，當寄存器文件中不含有數據時出現不明中，它會決定何時發射加載操作，以及確定用哪個寄存器來存放數據。</li><li>SRAM高速緩存是DRAM主存的緩存，由內置在緩存中的硬件邏輯管理的。</li><li>在有虛擬內存的系統中，DRAM主存是本地磁盤的緩存，由操作系統軟件和CPU上的地址翻譯硬件共同管理。</li><li>在具有分佈式文件系統的機器中，本地磁盤作為緩存，由運行在本地機器上的客戶端進行管理。</li></ul><div class=pgc-img><img alt=「計算機組成原理」：現代存儲器的結構 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a6a31a242a3f4d5bb33288779927ff49><p class=pgc-img-caption></p></div><p>通過以上內容，就能解釋局部性好的程序的優勢：</p><ul><li><strong>時間局部性：</strong>當一個數據對象在第一次不命中被複制到緩存中時，我們希望程序的時間局部性好，則在不久的將來就能反覆在第k層訪問到該塊，使得程序運行更快。</li><li><strong>空間局部性：</strong>由於緩存中一個塊包含多個數據對象，我們希望程序的空間局部性好，就可以直接利用第k層的數據塊，避免再從第k+1層傳輸塊到第k層。</li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>計算機</a></li><li><a>組成</a></li><li><a>現代存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/25c32309.html alt=「計算機組成原理」：常見的指令尋址方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1dc0ee5b851b4062bec43075dc04a3ac style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25c32309.html title=「計算機組成原理」：常見的指令尋址方式>「計算機組成原理」：常見的指令尋址方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/606be772.html alt=計算機組成：輸入/輸出接口的端口編址與尋址 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/32e43507-e640-452b-8b59-918c609198ed style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/606be772.html title=計算機組成：輸入/輸出接口的端口編址與尋址>計算機組成：輸入/輸出接口的端口編址與尋址</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19c284c7.html alt=計算機組成原理：存儲器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9a117d1084f74530a21f73c49bf6336f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19c284c7.html title=計算機組成原理：存儲器>計算機組成原理：存儲器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/14cf0a64.html alt=組成電子計算機的晶體管及其做為邏輯元件的工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f8c6c73e8e114ab8a6122ffd6431e043 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/14cf0a64.html title=組成電子計算機的晶體管及其做為邏輯元件的工作原理>組成電子計算機的晶體管及其做為邏輯元件的工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1f13ed18.html alt=「計算機組成原理」：數據的運算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/79121b75c9064a14acff3360f03ea4c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1f13ed18.html title=「計算機組成原理」：數據的運算>「計算機組成原理」：數據的運算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fed6eaa5.html alt=計算機組成：運算器芯片Am2901組成，控制與操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/93ee3a638c694c35842d23753104a1de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fed6eaa5.html title=計算機組成：運算器芯片Am2901組成，控制與操作>計算機組成：運算器芯片Am2901組成，控制與操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4844614.html alt=計算機組成原理：總線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e48f73b817294e09bbac00d14bb34bb8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4844614.html title=計算機組成原理：總線>計算機組成原理：總線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/20ef1426.html alt=「計算機組成原理」：總線概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8b98aa15280949e89255d5de3b6df189 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/20ef1426.html title=「計算機組成原理」：總線概述>「計算機組成原理」：總線概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/feaa7493.html alt=白中英《計算機組成原理》第5版考研教材真題視頻——才聰學習網 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/5c56896a-3313-41d7-bb3b-9b8263ed00f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/feaa7493.html title=白中英《計算機組成原理》第5版考研教材真題視頻——才聰學習網>白中英《計算機組成原理》第5版考研教材真題視頻——才聰學習網</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f1a09b9.html alt=計算機組成原理（指令） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/744904767cbc4a82b7096f4671de12d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f1a09b9.html title=計算機組成原理（指令）>計算機組成原理（指令）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f53596b.html alt=計算機網絡由哪兩部分組成，各自的作用是什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/623ba2a0a8a9492d9dde165054b57140 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f53596b.html title=計算機網絡由哪兩部分組成，各自的作用是什麼？>計算機網絡由哪兩部分組成，各自的作用是什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6da9b0e9.html alt=計算機組成：輸入輸出接口的基本組成，功能和分類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/856140c2-137f-4c53-90e6-27ed28d30e02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6da9b0e9.html title=計算機組成：輸入輸出接口的基本組成，功能和分類>計算機組成：輸入輸出接口的基本組成，功能和分類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/88924f46.html alt=計算機組成：輸入/輸出設備及工作流程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/414654c5ccd64221bca1f4abc4dd7572 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/88924f46.html title=計算機組成：輸入/輸出設備及工作流程>計算機組成：輸入/輸出設備及工作流程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a288cd.html alt=走進計算機世界-組成與體系結構之存儲器系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15264525273848ff34097bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a288cd.html title=走進計算機世界-組成與體系結構之存儲器系統>走進計算機世界-組成與體系結構之存儲器系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/483bf15.html alt=計算機組成原理（誤差檢驗碼1———奇偶校驗碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1311ec5e5ae346eebf9557ddb1997ba7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/483bf15.html title=計算機組成原理（誤差檢驗碼1———奇偶校驗碼）>計算機組成原理（誤差檢驗碼1———奇偶校驗碼）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>