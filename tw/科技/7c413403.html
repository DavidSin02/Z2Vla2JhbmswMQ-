<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>7步搞懂分佈式全內容，我不信面試官還敢“懟”著我問！ | 极客快訊</title><meta property="og:title" content="7步搞懂分佈式全內容，我不信面試官還敢“懟”著我問！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/9022b0a5-491d-4c21-813a-c4a9cad2190b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c413403.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c413403.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7c413403.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c413403.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c413403.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7c413403.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7c413403.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c413403.html><meta property="article:published_time" content="2020-11-14T21:04:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:37+08:00"><meta name=Keywords content><meta name=description content="7步搞懂分佈式全內容，我不信面試官還敢“懟”著我問！"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7c413403.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>7步搞懂分佈式全內容，我不信面試官還敢“懟”著我問！</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1. 什麼是分佈式鎖</h1><p>分佈式鎖是控制分佈式系統之間同步訪問共享資源的一種方式。在分佈式系統中，常常需要協調他們的動作。如果不同的系統或是同一個系統的不同主機之間共享了一個或一組資源，那麼訪問這些資源的時候，往往需要互斥來防止彼此干擾來保證一致性，在這種情況下，便需要使用到分佈式鎖。</p><div class=pgc-img><img alt=7步搞懂分佈式全內容，我不信面試官還敢“懟”著我問！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/9022b0a5-491d-4c21-813a-c4a9cad2190b><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2. 為什麼要使用分佈式鎖</h1><p>為了保證一個方法或屬性在高併發情況下的同一時間只能被同一個線程執行，在傳統單體應用單機部署的情況下，可以使用Java併發處理相關的API(如ReentrantLock或Synchronized)進行互斥控制。在單機環境中，Java中提供了很多併發處理相關的API。但是，隨著業務發展的需要，原單體單機部署的系統被演化成分佈式集群系統後，由於分佈式系統多線程、多進程並且分佈在不同機器上，這將使原單機部署情況下的併發控制鎖策略失效，單純的Java API並不能提供分佈式鎖的能力。為了解決這個問題就需要一種跨JVM的互斥機制來控制共享資源的訪問，這就是分佈式所要解決的問題！</p><p>舉個例子：</p><p>機器A ，機器B是一個集群，A， B兩臺機器上的程序都是一樣的，具備高可用性能。</p><p>A, B機器都有一個定時任務, 每天晚上凌晨2點需要執行一個定時任務, 但是這個定時任務只能執行一遍, 否則的話就會報錯, 那A,B兩臺機器在執行的時候, 就需要搶鎖, 誰搶到鎖, 誰執行, 誰搶不到, 就不用執行了!</p><h1 class=pgc-h-arrow-right>3. 鎖的處理</h1><ul><li>單個應用中使用鎖: (單進程多線程)</li></ul><p>synchronize分佈式鎖控制分佈式系統之間同步訪問資源的一種方式</p><p>分佈式鎖是控制分佈式系統之間同步同問共享資源的一種方式</p><h1 class=pgc-h-arrow-right>4. 分佈式鎖的實現</h1><ul><li>基於數據的樂觀鎖實現分佈式鎖</li><li>基於zookeeper臨時節點的分佈式鎖</li><li>基於redis的分佈式鎖</li></ul><h1 class=pgc-h-arrow-right>5. redis的分佈式鎖</h1><ul><li>獲取鎖:</li></ul><p>在set命令中, 有很多選項可以用來修改命令的行為, 一下是set命令可用選項的基本語法</p><pre><code>redis 127.0.0.1:6379&gt;SET KEY VALUE [EX seconds] [PX milliseconds] [NX|XX]    - EX seconds  設置指定的到期時間(單位為秒)    - PX milliseconds 設置指定的到期時間(單位毫秒)    - NX: 僅在鍵不存在時設置鍵    - XX: 只有在鍵已存在時設置</code></pre><p>方式1: 推介</p><pre><code>    private static final String LOCK_SUCCESS = "OK";    private static final String SET_IF_NOT_EXIST = "NX";    private static final String SET_WITH_EXPIRE_TIME = "PX";        public static boolean getLock(JedisCluster jedisCluster, String lockKey, String requestId, int expireTime) {        // NX: 保證互斥性        String result = jedisCluster.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);        if (LOCK_SUCCESS.equals(result)) {            return true;        }        return false;    }</code></pre><p>方式2:</p><pre><code>public static boolean getLock(String lockKey,String requestId,int expireTime) {     Long result = jedis.setnx(lockKey, requestId);     if(result == 1) {         jedis.expire(lockKey, expireTime);         return true;     }     return false; }</code></pre><p>注意: 推介方式1, 因為方式2中setnx和expire是兩個操作, 並不是一個原子操作, 如果setnx出現問題, 就是出現死鎖的情況, 所以推薦方式1</p><ul><li>釋放鎖:</li></ul><p>方式1: del命令實現</p><pre><code>public static void releaseLock(String lockKey,String requestId) {    if (requestId.equals(jedis.get(lockKey))) {        jedis.del(lockKey);    }}</code></pre><p>方式2: redis+lua腳本實現 推薦</p><pre><code>public static boolean releaseLock(String lockKey, String requestId) {        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then returnredis.call('del', KEYS[1]) else return 0 end";        Object result = jedis.eval(script, Collections.singletonList(lockKey),Collections.singletonList(requestId));        if (result.equals(1L)) {            return true;}        return false;    }</code></pre><h1 class=pgc-h-arrow-right>6. zookeeper的分佈式鎖</h1><h1 class=pgc-h-arrow-right>6.1 zookeeper實現分佈式鎖的原理</h1><p>理解了鎖的原理後，就會發現，Zookeeper 天生就是一副分佈式鎖的胚子。</p><p>首先，Zookeeper的每一個節點，都是一個天然的順序發號器。</p><p>在每一個節點下面創建子節點時，只要選擇的創建類型是有序（EPHEMERAL_SEQUENTIAL 臨時有序或者PERSISTENT_SEQUENTIAL 永久有序）類型，那麼，新的子節點後面，會加上一個次序編號。這個次序編號，是上一個生成的次序編號加一</p><p>比如，創建一個用於發號的節點“/test/lock”，然後以他為父親節點，可以在這個父節點下面創建相同前綴的子節點，假定相同的前綴為“/test/lock/seq-”，在創建子節點時，同時指明是有序類型。如果是第一個創建的子節點，那麼生成的子節點為/test/lock/seq-0000000000，下一個節點則為/test/lock/seq-0000000001，依次類推，等等。</p><div class=pgc-img><img alt=7步搞懂分佈式全內容，我不信面試官還敢“懟”著我問！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0cc779ebfd6c4f27a6967f82bd534c74><p class=pgc-img-caption></p></div><p>其次，Zookeeper節點的遞增性，可以規定節點編號最小的那個獲得鎖。</p><p>一個zookeeper分佈式鎖，首先需要創建一個父節點，儘量是持久節點（PERSISTENT類型），然後每個要獲得鎖的線程都會在這個節點下創建個臨時順序節點，由於序號的遞增性，可以規定排號最小的那個獲得鎖。所以，每個線程在嘗試佔用鎖之前，首先判斷自己是排號是不是當前最小，如果是，則獲取鎖。</p><p>第三，Zookeeper的節點監聽機制，可以保障佔有鎖的方式有序而且高效。</p><p>每個線程搶佔鎖之前，先搶號創建自己的ZNode。同樣，釋放鎖的時候，就需要刪除搶號的Znode。搶號成功後，如果不是排號最小的節點，就處於等待通知的狀態。等誰的通知呢？不需要其他人，只需要等前一個Znode 的通知就可以了。當前一個Znode 刪除的時候，就是輪到了自己佔有鎖的時候。第一個通知第二個、第二個通知第三個，擊鼓傳花似的依次向後。</p><p>Zookeeper的節點監聽機制，可以說能夠非常完美的，實現這種擊鼓傳花似的信息傳遞。具體的方法是，每一個等通知的Znode節點，只需要監聽linsten或者 watch 監視排號在自己前面那個，而且緊挨在自己前面的那個節點。 只要上一個節點被刪除了，就進行再一次判斷，看看自己是不是序號最小的那個節點，如果是，則獲得鎖。</p><p>為什麼說Zookeeper的節點監聽機制，可以說是非常完美呢？</p><p>一條龍式的首尾相接，後面監視前面，就不怕中間截斷嗎？比如，在分佈式環境下，由於網絡的原因，或者服務器掛了或者其他的原因，如果前面的那個節點沒能被程序刪除成功，後面的節點不就永遠等待麼？</p><p>其實，Zookeeper的內部機制，能保證後面的節點能夠正常的監聽到刪除和獲得鎖。在創建取號節點的時候，儘量創建臨時znode 節點而不是永久znode 節點，一旦這個 znode 的客戶端與Zookeeper集群服務器失去聯繫，這個臨時 znode 也將自動刪除。排在它後面的那個節點，也能收到刪除事件，從而獲得鎖。</p><p>說Zookeeper的節點監聽機制，是非常完美的。還有一個原因。</p><p>Zookeeper這種首尾相接，後面監聽前面的方式，可以避免羊群效應。所謂羊群效應就是每個節點掛掉，所有節點都去監聽，然後做出反映，這樣會給服務器帶來巨大壓力，所以有了臨時順序節點，當一個節點掛掉，只有它後面的那一個節點才做出反映。</p><h1 class=pgc-h-arrow-right>6.2 zookeeper實現分佈式鎖的示例</h1><p>zookeeper是通過臨時節點來實現分佈式鎖</p><pre><code>import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.recipes.locks.InterProcessMutex;import org.apache.curator.retry.ExponentialBackoffRetry;import org.junit.Before;import org.junit.Test;/** * @ClassName ZookeeperLock * @Description TODO * @Author lingxiangxiang * @Date 2:57 PM * @Version 1.0 **/public class ZookeeperLock {    // 定義共享資源    private static int NUMBER = 10;    private static void printNumber() {        // 業務邏輯: 秒殺        System.out.println("*********業務方法開始************\n");        System.out.println("當前的值: " + NUMBER);        NUMBER--;        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("*********業務方法結束************\n");    }    // 這裡使用@Test會報錯    public static void main(String[] args) {        // 定義重試的側策略 1000 等待的時間(毫秒) 10 重試的次數        RetryPolicy policy = new ExponentialBackoffRetry(1000, 10);        // 定義zookeeper的客戶端        CuratorFramework client = CuratorFrameworkFactory.builder()                .connectString("10.231.128.95:2181,10.231.128.96:2181,10.231.128.97:2181")                .retryPolicy(policy)                .build();        // 啟動客戶端        client.start();        // 在zookeeper中定義一把鎖        final InterProcessMutex lock = new InterProcessMutex(client, "/mylock");        //啟動是個線程        for (int i = 0; i &lt;10; i++) {            new Thread(new Runnable() {                @Override                public void run() {                    try {                        // 請求得到的鎖                        lock.acquire();                        printNumber();                    } catch (Exception e) {                        e.printStackTrace();                    } finally {                        // 釋放鎖, 還鎖                        try {                            lock.release();                        } catch (Exception e) {                            e.printStackTrace();                        }                    }                }            }).start();        }    }}</code></pre><h1 class=pgc-h-arrow-right>7. 基於數據的分佈式鎖</h1><p>我們在討論使用分佈式鎖的時候往往首先排除掉基於數據庫的方案，本能的會覺得這個方案不夠“高級”。從性能的角度考慮，基於數據庫的方案性能確實不夠優異，整體性能對比：緩存 > Zookeeper、etcd > 數據庫。也有人提出基於數據庫的方案問題很多，不太可靠。數據庫的方案可能並不適合於頻繁寫入的操作.</p><p>下面我們來了解一下基於數據庫（MySQL）的方案，一般分為3類：基於表記錄、樂觀鎖和悲觀鎖。</p><h1 class=pgc-h-arrow-right>7.1 基於表記錄</h1><p>要實現分佈式鎖，最簡單的方式可能就是直接創建一張鎖表，然後通過操作該表中的數據來實現了。當我們想要獲得鎖的時候，就可以在該表中增加一條記錄，想要釋放鎖的時候就刪除這條記錄。</p><p>為了更好的演示，我們先創建一張數據庫表，參考如下：</p><pre><code>CREATE TABLE `database_lock` (    `id` BIGINT NOT NULL AUTO_INCREMENT,    `resource` int NOT NULL COMMENT '鎖定的資源',    `description` varchar(1024) NOT NULL DEFAULT "" COMMENT '描述',    PRIMARY KEY (`id`),    UNIQUE KEY `uiq_idx_resource` (`resource`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='數據庫分佈式鎖表';</code></pre><ul><li>獲得鎖</li></ul><p>我們可以插入一條數據：</p><pre><code>INSERT INTO database_lock(resource, description) VALUES (1, 'lock');</code></pre><p>因為表database_lock中resource是唯一索引, 所以其他請求提交到數據庫, 就會報錯, 並不會插入成功, 只有一個可以插入. 插入成功, 我們就獲取到鎖</p><ul><li>刪除鎖</li></ul><pre><code>INSERT INTO database_lock(resource, description) VALUES (1, 'lock');</code></pre><p>這種實現方式非常的簡單，但是需要注意以下幾點：</p><p>這種鎖沒有失效時間，一旦釋放鎖的操作失敗就會導致鎖記錄一直在數據庫中，其它線程無法獲得鎖。這個缺陷也很好解決，比如可以做一個定時任務去定時清理。這種鎖的可靠性依賴於數據庫。建議設置備庫，避免單點，進一步提高可靠性。這種鎖是非阻塞的，因為插入數據失敗之後會直接報錯，想要獲得鎖就需要再次操作。如果需要阻塞式的，可以弄個for循環、while循環之類的，直至INSERT成功再返回。這種鎖也是非可重入的，因為同一個線程在沒有釋放鎖之前無法再次獲得鎖，因為數據庫中已經存在同一份記錄了。想要實現可重入鎖，可以在數據庫中添加一些字段，比如獲得鎖的主機信息、線程信息等，那麼在再次獲得鎖的時候可以先查詢數據，如果當前的主機信息和線程信息等能被查到的話，可以直接把鎖分配給它。</p><h1 class=pgc-h-arrow-right>7.2 樂觀鎖</h1><p>顧名思義，系統認為數據的更新在大多數情況下是不會產生衝突的，只在數據庫更新操作提交的時候才對數據作衝突檢測。如果檢測的結果出現了與預期數據不一致的情況，則返回失敗信息。</p><div class=pgc-img><img alt=7步搞懂分佈式全內容，我不信面試官還敢“懟”著我問！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/861fa6ef90bd4a029e0f4b4895cfece3><p class=pgc-img-caption></p></div><p>樂觀鎖大多數是基於數據版本(version)的記錄機制實現的。何謂數據版本號？即為數據增加一個版本標識，在基於數據庫表的版本解決方案中，一般是通過為數據庫表添加一個 “version”字段來實現讀取出數據時，將此版本號一同讀出，之後更新時，對此版本號加1。在更新過程中，會對版本號進行比較，如果是一致的，沒有發生改變，則會成功執行本次操作；如果版本號不一致，則會更新失敗。</p><p>為了更好的理解數據庫樂觀鎖在實際項目中的使用，這裡也就舉了業界老生常談的庫存例子。</p><p>一個電商平臺都會存在商品的庫存，當用戶進行購買的時候就會對庫存進行操作（庫存減1代表已經賣出了一件）。如果只是一個用戶進行操作數據庫本身就能保證用戶操作的正確性，而在併發的情況下就會產生一些意想不到的問題：</p><p>比如兩個用戶同時購買一件商品，在數據庫層面實際操作應該是庫存進行減2操作，但是由於高併發的情況，第一個用戶購買完成進行數據讀取當前庫存並進行減1操作，由於這個操作沒有完全執行完成。第二個用戶就進入購買相同商品，此時查詢出的庫存可能是未減1操作的庫存導致了髒數據的出現【線程不安全操作】，通常如果是單JVM情況下使用JAVA內置的鎖就能保證線程安全，如果在多JVM的情況下，使用分佈式鎖也能實現【後期會補】，而本篇著重的去講數據庫層面的。</p><p>針對上面的問題，數據庫樂觀鎖也能保證線程安全，通常哎代碼層面我們都會這樣做：</p><pre><code>select goods_num from goods where goods_name = "小本子";update goods set goods_num = goods_num -1 where goods_name = "小本子";</code></pre><p>上面的SQL是一組的，通常先查詢出當前的goods_num，然後再goods_num上進行減1的操作修改庫存，當併發的情況下，這條語句可能導致原本庫存為3的一個商品經過兩個人購買還剩下2庫存的情況就會導致商品的多賣。那麼數據庫樂觀鎖是如何實現的呢？首先定義一個version字段用來當作一個版本號，每次的操作就會變成這樣：</p><pre><code>select goods_num,version from goods where goods_name = "小本子";update goods set goods_num = goods_num -1,version =查詢的version值自增 where goods_name ="小本子" and version=查詢出來的version；</code></pre><p>其實，藉助更新時間戳（updated_at）也可以實現樂觀鎖，和採用version字段的方式相似：更新操作執行前線獲取記錄當前的更新時間，在提交更新時，檢測當前更新時間是否與更新開始時獲取的更新時間戳相等。</p><h1 class=pgc-h-arrow-right>7.3 悲觀鎖</h1><p>除了可以通過增刪操作數據庫表中的記錄以外，我們還可以藉助數據庫中自帶的鎖來實現分佈式鎖。在查詢語句後面增加FOR UPDATE，數據庫會在查詢過程中給數據庫表增加悲觀鎖，也稱排他鎖。當某條記錄被加上悲觀鎖之後，其它線程也就無法再改行上增加悲觀鎖。</p><p>悲觀鎖，與樂觀鎖相反，總是假設最壞的情況，它認為數據的更新在大多數情況下是會產生衝突的。</p><p>在使用悲觀鎖的同時，我們需要注意以下鎖的級別。MySQL InnoDB引起在加鎖的時候，只有明確地指定主鍵(或索引)的才會執行行鎖 (只鎖住被選取的數據)，否則MySQL 將會執行表鎖(將整個數據表單給鎖住)。</p><p>在使用悲觀鎖時，我們必須關閉MySQL數據庫的自動提交屬性（參考下面的示例），因為MySQL默認使用autocommit模式，也就是說，當你執行一個更新操作後，MySQL會立刻將結果進行提交。</p><pre><code>mysql&gt; SET AUTOCOMMIT = 0;Query OK, 0 rows affected (0.00 sec)</code></pre><p>這樣在使用FOR UPDATE獲得鎖之後可以執行相應的業務邏輯，執行完之後再使用COMMIT來釋放鎖。</p><p>我們不妨沿用前面的database_lock表來具體表述一下用法。假設有一線程A需要獲得鎖並執行相應的操作，那麼它的具體步驟如下：</p><p>STEP1 - 獲取鎖：SELECT * FROM database_lock WHERE id = 1 FOR UPDATE;。</p><p>STEP2 - 執行業務邏輯。</p><p>STEP3 - 釋放鎖：COMMIT。</p><h1 class=pgc-h-arrow-right>最後</h1><p>如果你就覺得這篇文章對你有用的話不妨點贊+關注+轉發三連支持一下</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>搞懂</a></li><li><a>全內容</a></li><li><a>信面</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html alt=20個機械設計知識點總結，搞懂也是半個行家 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html title=20個機械設計知識點總結，搞懂也是半個行家>20個機械設計知識點總結，搞懂也是半個行家</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html alt=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/47783c95e3a34185be9ff00f54b4fe7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html title=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？>電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html alt=軸承保持架斷裂原因，終於搞懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/926568ad42794eac8db9ccfc13716933 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html title=軸承保持架斷裂原因，終於搞懂了！>軸承保持架斷裂原因，終於搞懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html alt=「工程造價」搞懂這41個問題，你就是造價大神 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/61e6d766-6c64-42b0-8adc-44437be425ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html title=「工程造價」搞懂這41個問題，你就是造價大神>「工程造價」搞懂這41個問題，你就是造價大神</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dccc27aa.html alt=搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/45dfe66dfe2b42088ca53ab0c5d316b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dccc27aa.html title=搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏>搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/142b983a.html alt=一文搞懂常用鋼材型號、性能特性，收藏隨時查看！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533653259067c6eef0dcc2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/142b983a.html title=一文搞懂常用鋼材型號、性能特性，收藏隨時查看！>一文搞懂常用鋼材型號、性能特性，收藏隨時查看！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00a88a85.html alt="沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rd1uElWC8gP2we style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00a88a85.html title="沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃">沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/187187bc.html alt="技術趣講 | 60 分鐘搞懂「正則表達式」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/eaee8d2e512c44168627b8f244fb5e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/187187bc.html title="技術趣講 | 60 分鐘搞懂「正則表達式」">技術趣講 | 60 分鐘搞懂「正則表達式」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1538e7d2.html alt=搞懂配電箱，安全你我他！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153058170941381af740af4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1538e7d2.html title=搞懂配電箱，安全你我他！>搞懂配電箱，安全你我他！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9f5a569.html alt=搞懂給排水專業的100個問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66c9000136849b38a4a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9f5a569.html title=搞懂給排水專業的100個問題>搞懂給排水專業的100個問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3e9fc64.html alt=一次相親經歷，我徹底搞懂了阻塞非阻塞、同步異步 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e008b77db962482cb7bdad71f78cf103 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3e9fc64.html title=一次相親經歷，我徹底搞懂了阻塞非阻塞、同步異步>一次相親經歷，我徹底搞懂了阻塞非阻塞、同步異步</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c53bc93.html alt=搞懂這些複雜的機械結構，你一定是個高工 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30681751f7694dd0b8136a10fb9dc5d6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c53bc93.html title=搞懂這些複雜的機械結構，你一定是個高工>搞懂這些複雜的機械結構，你一定是個高工</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b329986.html alt=原來10張圖就可以搞懂分佈式鏈路追蹤系統原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8dbe10a35c1a45cba7a211d07fbecf24 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b329986.html title=原來10張圖就可以搞懂分佈式鏈路追蹤系統原理>原來10張圖就可以搞懂分佈式鏈路追蹤系統原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cbdef0bc.html alt=「進口知識」一篇搞懂瀝青進口那些事兒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/22cf002555424c1e8692a166cf1c9339 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cbdef0bc.html title=「進口知識」一篇搞懂瀝青進口那些事兒>「進口知識」一篇搞懂瀝青進口那些事兒</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>