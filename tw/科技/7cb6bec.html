<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？ | 极客快訊</title><meta property="og:title" content="大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/dc3238ed4c184f989370e72dc0ad69cd"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7cb6bec.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7cb6bec.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7cb6bec.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7cb6bec.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7cb6bec.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7cb6bec.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7cb6bec.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7cb6bec.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7cb6bec.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p>當一個 HTTP 請求到達 Tomcat，Tomcat 將會從線程池中取出線程，然後按照如下流程處理請求：</p><ul class=list-paddingleft-2><li>將請求信息解析為 HttpServletRequest</li><li>分發到具體 Servlet 處理相應的業務</li><li>通過 HttpServletResponse 將響應結果返回給等待客戶端</li></ul><p>整體流程如下所示：</p><div class=pgc-img><img alt="大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc3238ed4c184f989370e72dc0ad69cd><p class=pgc-img-caption></p></div><p>這是我們日常最常用同步請求模型，所有動作都交給同一個 Tomcat 線程處理，所有動作處理完成，線程才會被釋放回線程池。</p><p>想象一下如果業務需要較長時間處理，那麼這個 Tomcat 線程其實一直在被佔用，隨著請求越來越多，可用 I/O 線程越來越少，直到被耗盡。這時後續請求只能等待空閒 Tomcat 線程，這將會加長了請求執行時間。</p><p>如果客戶端不關心返回業務結果，這時我們可以自定義線程池，將請求任務提交給線程池，然後立刻返回。</p><blockquote><p>也可以使用 Spring Async 任務，大家感興趣可以自行查找一下資料</p></blockquote><p>但是很多場景下，客戶端需要處理返回結果，我們沒辦法使用上面的方案。在 Servlet2 時代，我們沒辦法優化上面的方案。</p><p>不過等到 Servlet3 ，引入異步 Servlet 新特性，可以完美解決上面的需求。</p><p>異步 Servlet 執行請求流程：</p><ul class=list-paddingleft-2><li>將請求信息解析為 HttpServletRequest</li><li>分發到具體 Servlet 處理,將業務提交給自定義業務線程池，請求立刻返回，Tomcat 線程立刻被釋放</li><li>當業務線程將任務執行結束，將會將結果轉交給 Tomcat 線程</li><li>通過 HttpServletResponse 將響應結果返回給等待客戶端</li></ul><p>引入異步 Servlet3 整體流程如下：</p><div class=pgc-img><img alt="大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/30223854ee3849e78e2830e37eed363c><p class=pgc-img-caption></p></div><p>使用異步 Servelt，Tomcat 線程僅僅處理請求解析動作，所有耗時較長的業務操作全部交給業務線程池，所以相比同步請求， Tomcat 線程可以處理 更多請求。</p><p>雖然我們將業務處理交給業務線程池異步處理，但是對於客戶端來講，其還在<strong>同步等待響應結果</strong>。</p><p>可能有些同學會覺得異步請求將會獲得更快<strong>響應時間</strong>，其實不是的，相反可能由於引入了更多線程，增加線程上下文切換時間。</p><p>雖然沒有降低響應時間，但是通過請求異步化帶來其他<strong>明顯優點</strong>：</p><ul class=list-paddingleft-2><li>可以處理更高併發連接數，提高系統整體吞吐量</li><li>請求解析與業務處理完全分離，職責單一</li><li>自定義業務線程池，我們可以更容易對其監控，降級等處理</li><li>可以根據不同業務，自定義不同線程池，相互隔離，不用互相影響</li></ul><p>所以具體使用過程，我們還需要進行的相應的壓測，觀察響應時間以及吞吐量等其他指標，綜合選擇。</p><h1 class=pgc-h-arrow-right>異步 Servelt 使用方式</h1><p>異步 Servelt 使用方式不是很難，阿粉總結就是下面三板斧：</p><ol start=1><li>HttpServletRequest#startAsync 獲取 AsyncContext 異步上下文對象</li><li>使用自定義的業務線程池處理業務邏輯</li><li>業務線程處理結束，通過 AsyncContext#complete 返回響應結果</li></ol><blockquote><p>下面的例子將會使用 SpringBoot ，Web 容器選擇 Tomcat</p></blockquote><p>示例代碼如下：</p><pre><code>ExecutorService executorService = Executors.newFixedThreadPool(10);@RequestMapping("/hello")public void hello(HttpServletRequest request) {    AsyncContext asyncContext = request.startAsync();    // 超時時間    asyncContext.setTimeout(10000);    executorService.submit(() -&gt; {        try {            // 休眠 5s，模擬業務操作            TimeUnit.SECONDS.sleep(5);            // 輸出響應結果            asyncContext.getResponse().getWriter().println("hello world");            log.info("異步線程處理結束");        } catch (Exception e) {            e.printStackTrace();        } finally {            asyncContext.complete();        }    });    log.info("servlet 線程處理結束");}</code></pre><p>瀏覽器訪問該請求將會同步等待 5s 得到輸出響應，應用日誌輸出結果如下：</p><pre><code>2020-03-24 07:27:08.997  INFO 79257 --- [nio-8087-exec-4] com.xxxx   : servlet 線程處理結束2020-03-24 07:27:13.998  INFO 79257 --- [pool-1-thread-3] com.xxxx   : 異步線程處理結束</code></pre><p>這裡我們需要注意設置<strong>合理的超時時間</strong>，防止客戶端長時間等待。</p><h1 class=pgc-h-arrow-right>SpringMVC</h1><p>Servlet3 API ，無法使用 SpringMVC 為我們提供的特性，我們需要自己處理響應信息，處理方式相對繁瑣。</p><p>SpringMVC 3.2 基於 Servelt3 引入異步請求處理方式，我們可以跟使用同步請求一樣，方便使用異步請求。</p><p>SpringMVC 提供有兩種異步方式，只要將 Controller 方法返回值修改下述類即可：</p><ul class=list-paddingleft-2><li>DeferredResult</li><li>Callable</li></ul><h1 class=pgc-h-arrow-right>DeferredResult</h1><p>DeferredResult 是 SpringMVC 3.2 之後引入新的類，只要讓請求方法返回DeferredResult，就可以快速使用異步請求，示例代碼如下：</p><pre><code>ExecutorService executorService = Executors.newFixedThreadPool(10);@RequestMapping("/hello_v1")public DeferredResult&lt;String&gt; hello_v1() {    // 設置超時時間    DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;(7000L);    // 異步線程處理結束，將會執行該回調方法    deferredResult.onCompletion(() -&gt; {        log.info("異步線程處理結束");    });    // 如果異步線程執行時間超過設置超時時間,將會執行該回調方法    deferredResult.onTimeout(() -&gt; {        log.info("異步線程超時");        // 設置返回結果        deferredResult.setErrorResult("timeout error");    });    deferredResult.onError(throwable -&gt; {        log.error("異常", throwable);        // 設置返回結果        deferredResult.setErrorResult("other error");    });    executorService.submit(() -&gt; {        try {            TimeUnit.SECONDS.sleep(5);            deferredResult.setResult("hello_v1");            // 設置返回結果        } catch (Exception e) {            e.printStackTrace();            // 若異步方法內部異常            deferredResult.setErrorResult("error");        }    });    log.info("servlet 線程處理結束");    return deferredResult;}</code></pre><p>創建 DeferredResult 實例時可以傳入特定超時時間。另外我們可以設置默認超時時間：</p><pre><code># 異步請求超時時間spring.mvc.async.request-timeout=2000</code></pre><p>如果異步程序執行完成，可以調用 DeferredResult#setResult返回響應結果。此時若有設置 DeferredResult#onCompletion 回調方法，將會觸發該回調方法。</p><p>同時我們還可以設置超時回調方法 DeferredResult#onTimeout，一旦異步線程執行超時，將會觸發該回調方法。</p><p>最後 DeferredResult 還提供其他異常的回調方法 onError，起初阿粉以為只要異步線程內發生異常，就會觸發該回調方法。嘗試在異步線程內拋出異常，但是無法成功觸發。</p><p>後續阿粉查看這個方法的 doc，當 web 容器線程處理異步請求時發生異常，才能成功觸發。</p><div class=pgc-img><img alt="大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fec105eac1b4428ca3c5df530d4d2373><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>Callable</h1><p>Spring 另外還提供一種異步請求使用方式，直接使用 JDK Callable。示例代碼如下：</p><pre><code>@RequestMapping("/hello_v2")public Callable&lt;String&gt; hello_v2() {    return new Callable&lt;String&gt;() {        @Override        public String call() throws Exception {            TimeUnit.SECONDS.sleep(5);            log.info("異步方法結束");            return "hello_v2";        }    };}</code></pre><p>默認情況下，直接執行將會輸出 <strong>WARN</strong> 日誌：</p><div class=pgc-img><img alt="大部分程序員不知道的 Servelt3 異步請求，原來這麼簡單？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/923bd69814cb4573a680fc91dfaa4d3d><p class=pgc-img-caption></p></div><p>這是因為默認情況使用 SimpleAsyncTaskExecutor 執行異步請求，每次調用執行都將會新建線程。由於這種方式不復用線程，生產<strong>不推薦</strong>使用這種方式，所以我們需要使用線程池代替。</p><p>我們可以使用如下方式自定義線程池：</p><pre><code>@Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)public AsyncTaskExecutor executor() {    ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();    threadPoolTaskExecutor.setThreadNamePrefix("test-");    threadPoolTaskExecutor.setCorePoolSize(10);    threadPoolTaskExecutor.setMaxPoolSize(20);    return threadPoolTaskExecutor;}</code></pre><p>注意 Bean 名稱一定要是 applicationTaskExecutor，若不一致， Spring 將不會使用自定義線程池。</p><p>或者可以直接使用 SpringBoot 配置文件方式配置代替：</p><pre><code># 核心線程數spring.task.execution.pool.core-size=10# 最大線程數spring.task.execution.pool.max-size=20# 線程名前綴spring.task.execution.thread-name-prefix=test# 還有另外一些配置，讀者們可以自行配置</code></pre><p>這種方式異步請求的超時時間只能通過配置文件方式配置。</p><pre><code>spring.mvc.async.request-timeout=10000</code></pre><p>如果需要為單獨請求的配置特定的超時時間，我們需要使用 WebAsyncTask 包裝 Callable 。</p><pre><code>@RequestMapping("/hello_v3")public WebAsyncTask&lt;String&gt; hello_v3() {    System.out.println("asdas");    Callable&lt;String&gt; callable=new Callable&lt;String&gt;() {        @Override        public String call() throws Exception {            TimeUnit.SECONDS.sleep(5);            log.info("異步方法結束");            return "hello_v3";        }    };    // 單位 ms    WebAsyncTask&lt;String&gt; webAsyncTask=new WebAsyncTask&lt;&gt;(10000,callable);    return webAsyncTask;}</code></pre><h1 class=pgc-h-arrow-right>總結</h1><p>SpringMVC 兩種異步請求方式，本質上就是幫我們包裝 Servlet3 API ，讓我們不用關心具體實現細節。雖然日常使用我們一般會選擇使用 SpringMVC 兩種異步請求方式，但是我們還是需要了解異步請求實際原理。所以大家如果在使用之前，可以先嚐試使用 Servlet3 API 練習，後續再使用 SpringMVC。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Servelt3</a></li><li><a>異步</a></li><li><a>請求</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ce8e34.html alt=一分鐘掌握異步操作(Ajax請求） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ce8e34.html title=一分鐘掌握異步操作(Ajax請求）>一分鐘掌握異步操作(Ajax請求）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6fa5bc.html alt=同步請求和異步請求 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/37b36c91e46045098266d0264cb7f6e8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6fa5bc.html title=同步請求和異步請求>同步請求和異步請求</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65d3d26.html alt=爬取異步請求（XHR/JS）數據方法一人工分析異步請求 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65d3d26.html title=爬取異步請求（XHR/JS）數據方法一人工分析異步請求>爬取異步請求（XHR/JS）數據方法一人工分析異步請求</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html alt=三相異步電動機絕緣處理的目的及方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c439a15bdf64f1f975914c96a2c66e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html title=三相異步電動機絕緣處理的目的及方法>三相異步電動機絕緣處理的目的及方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html alt=異步電機典型結構簡述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349080656472f5dd62512 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html title=異步電機典型結構簡述>異步電機典型結構簡述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html alt=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/56930005e593537411b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html title=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹>繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html alt=單相異步電機如何轉起來？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/66c6000099c8d7f13f98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html title=單相異步電機如何轉起來？>單相異步電機如何轉起來？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51fefa66.html alt=迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/28ca13300b9f4d55bd5af3f9156f8874 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51fefa66.html title=迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章>迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/71debf3a.html alt=如何從請求、傳輸、渲染3個方面提升Web前端性能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ec3175fa2700484eac030574b8369e79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/71debf3a.html title=如何從請求、傳輸、渲染3個方面提升Web前端性能>如何從請求、傳輸、渲染3個方面提升Web前端性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f8e9216.html alt=寫個日誌請求切面，前後端甩鍋更方便 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/9ee016d0-a9b0-43a8-95a8-2d6d7b5e7e21 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f8e9216.html title=寫個日誌請求切面，前後端甩鍋更方便>寫個日誌請求切面，前後端甩鍋更方便</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/53471e9b.html alt=mysql異步複製與半同步複製的架構原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e7b00019c175cf0ab61 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/53471e9b.html title=mysql異步複製與半同步複製的架構原理>mysql異步複製與半同步複製的架構原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48620c40.html alt=三相異步電動機是什麼樣的，來看看分解圖 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/754c280526be4ac3924cb14ab78a9583 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48620c40.html title=三相異步電動機是什麼樣的，來看看分解圖>三相異步電動機是什麼樣的，來看看分解圖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/639037be.html alt=如何選擇合適的三相異步電動機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c221d4d29d8c40bc9afbad0800693a88 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/639037be.html title=如何選擇合適的三相異步電動機>如何選擇合適的三相異步電動機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ca8329c.html alt=CORS——跨域請求那些事兒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/382fe92652924d74afe3f3ee787c9042 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ca8329c.html title=CORS——跨域請求那些事兒>CORS——跨域請求那些事兒</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86d72690.html alt="HTTP請求過程（三）—— TCP四次揮手斷開連接以及異常處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522228359775acd17c0c4a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86d72690.html title="HTTP請求過程（三）—— TCP四次揮手斷開連接以及異常處理">HTTP請求過程（三）—— TCP四次揮手斷開連接以及異常處理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>