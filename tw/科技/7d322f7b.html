<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>MySQL系列-第14篇：事務詳解 | 极客快訊</title><meta property="og:title" content="MySQL系列-第14篇：事務詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><meta property="article:published_time" content="2020-11-14T21:08:11+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:11+08:00"><meta name=Keywords content><meta name=description content="MySQL系列-第14篇：事務詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7d322f7b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>MySQL系列-第14篇：事務詳解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>打算提升sql技能的，可以加我微信itsoku，帶你成為sql高手。</p><p>這是Mysql系列第14篇。</p><p>環境：mysql5.7.25，cmd命令中進行演示。</p><p><br></p><p><strong>開發過程中，會經常用到數據庫</strong><strong>事務</strong><strong>，所以本章非常重要。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>本篇內容</h1><ol start=0><li>什麼是事務，它有什麼用？</li><li>事務的幾個特性</li><li>事務常見操作指令詳解</li><li>事務的隔離級別詳解</li><li>髒讀、不可重複讀、可重複讀、幻讀詳解</li><li>演示各種隔離級別產生的現象</li><li>關於隔離級別的選擇</li></ol><p><br></p><h1 class=pgc-h-arrow-right>什麼是事務？</h1><p><strong>數據庫中的事務是指對數據庫執行一批操作，這些操作最終要麼全部執行成功，要麼全部失敗，不會存在部分成功的情況。</strong></p><p><strong>舉個例子</strong></p><p>比如A用戶給B用戶轉賬100操作，過程如下：</p><pre><code>1.從A賬戶扣1002.給B賬戶加100</code></pre><p>如果在事務的支持下，上面最終只有2種結果：</p><ol start=0><li>操作成功：A賬戶減少100；B賬戶增加100</li><li>操作失敗：A、B兩個賬戶都沒有發生變化</li></ol><p>如果沒有事務的支持，可能出現錯：A賬戶減少了100，此時系統掛了，導致B賬戶沒有加上100，而A賬戶憑空少了100。</p><p><br></p><h1 class=pgc-h-arrow-right>事務的幾個特性(ACID)</h1><h1 class=pgc-h-arrow-right>原子性(Atomicity)</h1><p>事務的整個過程如原子操作一樣，最終要麼全部成功，或者全部失敗，這個原子性是從最終結果來看的，從最終結果來看這個過程是不可分割的。</p><h1 class=pgc-h-arrow-right>一致性(Consistency)</h1><p>一個事務必須使數據庫從一個一致性狀態變換到另一個一致性狀態。</p><p>首先回顧一下一致性的定義。所謂一致性，指的是數據處於一種有意義的狀態，這種狀態是<strong>語義上的</strong>而不是<strong>語法上的</strong>。最常見的例子是轉帳。例如從帳戶A轉一筆錢到帳戶B上，如果帳戶A上的錢減少了，而帳戶B上的錢卻沒有增加，那麼我們認為此時數據處於不一致的狀態。</p><p><strong>從這段話的理解來看，所謂一致性，即，從實際的業務邏輯上來說，最終結果是對的、是跟程序員的所期望的結果完全符合的</strong></p><h1 class=pgc-h-arrow-right>隔離性(Isolation)</h1><p>一個事務的執行不能被其他事務干擾。即一個事務內部的操作及使用的數據對併發的其他事務是隔離的，併發執行的各個事務之間不能互相干擾。</p><h1 class=pgc-h-arrow-right>持久性(Durability)</h1><p>一個事務一旦提交，他對數據庫中數據的改變就應該是永久性的。當事務提交之後，數據會持久化到硬盤，修改是永久性的。</p><p><br></p><h1 class=pgc-h-arrow-right>Mysql中事務操作</h1><p>mysql中事務默認是隱式事務，執行insert、update、delete操作的時候，數據庫自動開啟事務、提交或回滾事務。</p><p>是否開啟隱式事務是由變量autocommit控制的。</p><p>所以事務分為<strong>隱式事務</strong>和<strong>顯式事務</strong>。</p><h1 class=pgc-h-arrow-right>隱式事務</h1><blockquote><p>事務自動開啟、提交或回滾，比如insert、update、delete語句，事務的開啟、提交或回滾由mysql內部自動控制的。</p></blockquote><p>查看變量autocommit是否開啟了自動提交</p><pre><code>mysql&gt; show variables like 'autocommit';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | ON    |+---------------+-------+1 row in set, 1 warning (0.00 sec)</code></pre><blockquote><p>autocommit為ON表示開啟了自動提交。</p></blockquote><h1 class=pgc-h-arrow-right>顯式事務</h1><blockquote><p>事務需要手動開啟、提交或回滾，由開發者自己控制。</p></blockquote><p>2種方式手動控制事務：</p><p><strong>方式1：</strong></p><p>語法：</p><pre><code>//設置不自動提交事務set autocommit=0;//執行事務操作commit|rollback;</code></pre><p>示例1：提交事務操作，如下：</p><pre><code>mysql&gt; create table test1 (a int);Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from test1;Empty set (0.00 sec)​mysql&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)​mysql&gt; insert into test1 values(1);Query OK, 1 row affected (0.00 sec)​mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)​mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><p>示例2：回滾事務操作，如下：</p><pre><code>mysql&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)​mysql&gt; insert into test1 values(2);Query OK, 1 row affected (0.00 sec)​mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)​mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><blockquote><p>可以看到上面數據回滾了。</p></blockquote><p>我們把autocommit還原回去：</p><pre><code>mysql&gt; set autocommit=1;Query OK, 0 rows affected (0.00 sec)</code></pre><p><strong>方式2：</strong></p><p>語法：</p><pre><code>start transaction;//開啟事務//執行事務操作commit|rollback;</code></pre><p>示例1：提交事務操作，如下：</p><pre><code>mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)​mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)​mysql&gt; insert into test1 values (2);Query OK, 1 row affected (0.00 sec)​mysql&gt; insert into test1 values (3);Query OK, 1 row affected (0.00 sec)​mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)​mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    2 ||    3 |+------+3 rows in set (0.00 sec)</code></pre><blockquote><p>上面成功插入了2條數據。</p></blockquote><p>示例2：回滾事務操作，如下：</p><pre><code>mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    2 ||    3 |+------+3 rows in set (0.00 sec)mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from test1;Query OK, 3 rows affected (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    2 ||    3 |+------+3 rows in set (0.00 sec)</code></pre><blockquote><p>上面事務中我們刪除了test1的數據，顯示刪除了3行，最後回滾了事務。</p></blockquote><p><br></p><h1 class=pgc-h-arrow-right>savepoint關鍵字</h1><p>在事務中我們執行了一大批操作，可能我們只想回滾部分數據，怎麼做呢？</p><p>我們可以將一大批操作分為幾個部分，然後指定回滾某個部分。可以使用savepoin來實現，效果如下：</p><p>先清除test1表數據：</p><pre><code>mysql&gt; delete from test1;Query OK, 3 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)</code></pre><p>演示savepoint效果，認真看：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; savepoint part1;//設置一個保存點Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (2);Query OK, 1 row affected (0.00 sec)mysql&gt; rollback to part1;//將savepint = part1的語句到當前語句之間所有的操作回滾Query OK, 0 rows affected (0.00 sec)mysql&gt; commit;//提交事務Query OK, 0 rows affected (0.00 sec)    mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><blockquote><p>從上面可以看出，執行了2次插入操作，最後只插入了1條數據。</p><p>savepoint需要結合rollback to sp1一起使用，可以將保存點sp1到rollback to之間的操作回滾掉。</p></blockquote><p><br></p><h1 class=pgc-h-arrow-right>只讀事務</h1><p>表示在事務中執行的是一些只讀操作，如查詢，但是不會做insert、update、delete操作，數據庫內部對只讀事務可能會有一些性能上的優化。</p><p>用法如下：</p><pre><code>start transaction read only;</code></pre><p>示例：</p><pre><code>mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; start transaction read only;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)mysql&gt; delete from test1;ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)</code></pre><blockquote><p>只讀事務中執行delete會報錯。</p></blockquote><p><br></p><h1 class=pgc-h-arrow-right>事務中的一些問題</h1><p>這些問題主要是基於數據在多個事務中的可見性來說的。</p><h1 class=pgc-h-arrow-right>髒讀</h1><p>一個事務在執行的過程中讀取到了其他事務還沒有提交的數據。 這個還是比較好理解的。</p><h1 class=pgc-h-arrow-right>讀已提交</h1><p>從字面上我們就可以理解，即一個事務操作過程中可以讀取到其他事務已經提交的數據。</p><p>事務中的每次讀取操作，讀取到的都是數據庫中其他事務已提交的最新的數據（相當於當前讀）</p><h1 class=pgc-h-arrow-right>可重複讀</h1><p>一個事務操作中對於一個讀取操作不管多少次，讀取到的結果都是一樣的。</p><h1 class=pgc-h-arrow-right>幻讀</h1><p>髒讀、不可重複讀、可重複讀、幻讀，其中最難理解的是幻讀</p><p>以mysql為例：</p><p><strong>幻讀在可重複讀的模式下才會出現，其他隔離級別中不會出現</strong></p><p>幻讀現象例子：</p><p>可重複讀模式下，比如有個用戶表，手機號碼為主鍵，有兩個事物進行如下操作</p><p>事務A操作如下： 1、打開事務 2、查詢號碼為X的記錄，不存在 3、插入號碼為X的數據，插入報錯（為什麼會報錯，先向下看） 4、查詢號碼為X的記錄，發現還是不存在（由於是可重複讀，所以讀取記錄X還是不存在的）</p><p>事物B操作：在事務A第2步操作時插入了一條X的記錄，所以會導致A中第3步插入報錯（違反了唯一約束）</p><p>上面操作對A來說就像發生了幻覺一樣，明明查詢X（A中第二步、第四步）不存在，但卻無法插入成功</p><p><strong>幻讀可以這麼理解：事務中後面的操作（插入號碼X）需要上面的讀取操作（查詢號碼X的記錄）提供支持，但讀取操作卻不能支持下面的操作時產生的錯誤，就像發生了幻覺一樣。</strong></p><p>如果還是理解不了的，繼續向下看，後面後詳細的演示。</p><p><br></p><h1 class=pgc-h-arrow-right>事務的隔離級別</h1><p>當多個事務同時進行的時候，如何確保當前事務中數據的正確性，比如A、B兩個事物同時進行的時候，A是否可以看到B已提交的數據或者B未提交的數據，這個需要依靠事務的隔離級別來保證，不同的隔離級別中所產生的效果是不一樣的。</p><p>事務隔離級別主要是解決了上面多個事務之間數據可見性及數據正確性的問題。</p><p><strong>隔離級別分為4種：</strong></p><ol start=0><li><strong>讀未提交：READ-UNCOMMITTED</strong></li><li><strong>讀已提交：READ-COMMITTED</strong></li><li><strong>可重複讀：REPEATABLE-READ</strong></li><li><strong>串行：SERIALIZABLE</strong></li></ol><p>上面4中隔離級別越來越強，會導致數據庫的併發性也越來越低。</p><p><br></p><h1 class=pgc-h-arrow-right>查看隔離級別</h1><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p><br></p><h1 class=pgc-h-arrow-right>隔離級別的設置</h1><p>分2步驟，修改文件、重啟mysql，如下：</p><p>修改mysql中的my.init文件，我們將隔離級別設置為：READ-UNCOMMITTED，如下：</p><pre><code># 隔離級別設置,READ-UNCOMMITTED讀未提交,READ-COMMITTED讀已提交,REPEATABLE-READ可重複讀,SERIALIZABLE串行transaction-isolation=READ-UNCOMMITTED</code></pre><p>以管理員身份打開cmd窗口，重啟mysql，如下：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服務正在停止..mysql 服務已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服務正在啟動 .mysql 服務已經啟動成功。</code></pre><p><br></p><h1 class=pgc-h-arrow-right>各種隔離級別中會出現的問題</h1><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事務詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5><p class=pgc-img-caption></p></div><blockquote><p>表格中和網上有些不一樣，主要是幻讀這塊，幻讀只會在可重複讀級別中才會出現，其他級別下不存在。</p></blockquote><p><br></p><p>下面我們來演示一下，各種隔離級別中可見性的問題，開啟兩個窗口，叫做A、B窗口，兩個窗口中登錄mysql。</p><h1 class=pgc-h-arrow-right>READ-UNCOMMITTED：讀未提交</h1><p>將隔離級別置為READ-UNCOMMITTED：</p><pre><code># 隔離級別設置,READ-UNCOMMITTED讀未提交,READ-COMMITTED讀已提交,REPEATABLE-READ可重複讀,SERIALIZABLE串行transaction-isolation=READ-UNCOMMITTED</code></pre><p>重啟mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服務正在停止..mysql 服務已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服務正在啟動 .mysql 服務已經啟動成功。</code></pre><p>查看隔離級別：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-UNCOMMITTED |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表數據：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按時間順序在2個窗口中執行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事務詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7bea5002a6fc47c88a7c4e36bdedfe37><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>T2-A：無數據，T6-A：有數據，T6時刻B還未提交，此時A已經看到了B插入的數據，<strong>說明出現了髒讀</strong>。</p><p>T2-A：無數據，T6-A：有數據，查詢到的結果不一樣，<strong>說明不可重複讀</strong>。</p><p><strong>結論：讀未提交情況下，可以讀取到其他事務還未提交的數據，多次讀取結果不一樣，出現了髒讀、不可重複讀</strong></p><p><br></p><h1 class=pgc-h-arrow-right>READ-COMMITTED：讀已提交</h1><p>將隔離級別置為READ-COMMITTED</p><pre><code># 隔離級別設置,READ-UNCOMMITTED讀未提交,READ-COMMITTED讀已提交,REPEATABLE-READ可重複讀,SERIALIZABLE串行transaction-isolation=READ-COMMITTED</code></pre><p>重啟mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服務正在停止..mysql 服務已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服務正在啟動 .mysql 服務已經啟動成功。</code></pre><p>查看隔離級別：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表數據：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按時間順序在2個窗口中執行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事務詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aefc2324fbf645e4bdf39b68d5b2bef3><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>T5-B：有數據，T6-A窗口：無數據，A看不到B的數據，<strong>說明沒有髒讀</strong>。</p><p>T6-A窗口：無數據，T8-A：看到了B插入的數據，此時B已經提交了，A看到了B已提交的數據，<strong>說明可以讀取到已提交的數據</strong>。</p><p>T2-A、T6-A：無數據，T8-A：有數據，多次讀取結果不一樣，<strong>說明不可重複讀</strong>。</p><p><strong>結論：讀已提交情況下，無法讀取到其他事務還未提交的數據，可以讀取到其他事務已經提交的數據，多次讀取結果不一樣，未出現髒讀，出現了讀已提交、不可重複讀。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>REPEATABLE-READ：可重複讀</h1><p>將隔離級別置為REPEATABLE-READ</p><pre><code># 隔離級別設置,READ-UNCOMMITTED讀未提交,READ-COMMITTED讀已提交,REPEATABLE-READ可重複讀,SERIALIZABLE串行transaction-isolation=REPEATABLE-READ</code></pre><p>重啟mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服務正在停止..mysql 服務已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服務正在啟動 .mysql 服務已經啟動成功。</code></pre><p>查看隔離級別：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表數據：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按時間順序在2個窗口中執行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事務詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ded27a7f0ce48dd9cfa8dfe9c5d5d3c><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>T2-A、T6-A窗口：無數據，T5-B：有數據，A看不到B的數據，<strong>說明沒有髒讀</strong>。</p><p>T8-A：無數據，此時B已經提交了，A看不到B已提交的數據，A中3次讀的結果一樣都是沒有數據的，<strong>說明可重複讀</strong>。</p><p><strong>結論：可重複讀情況下，未出現髒讀，未讀取到其他事務已提交的數據，多次讀取結果一致，即可重複讀。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>幻讀演示</h1><p>幻讀只會在REPEATABLE-READ（可重複讀）級別下出現，需要先把隔離級別改為可重複讀。</p><p>將隔離級別置為REPEATABLE-READ</p><pre><code># 隔離級別設置,READ-UNCOMMITTED讀未提交,READ-COMMITTED讀已提交,REPEATABLE-READ可重複讀,SERIALIZABLE串行transaction-isolation=REPEATABLE-READ</code></pre><p>重啟mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服務正在停止..mysql 服務已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服務正在啟動 .mysql 服務已經啟動成功。</code></pre><p>查看隔離級別：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>準備數據：</p><pre><code>mysql&gt; create table t_user(id int primary key,name varchar(16) unique key);Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into t_user values (1,'路人甲Java'),(2,'路人甲Java');ERROR 1062 (23000): Duplicate entry '路人甲Java' for key 'name'mysql&gt; select * from t_user;Empty set (0.00 sec)</code></pre><blockquote><p>上面我們創建t_user表，name添加了唯一約束，表示name不能重複，否則報錯。</p></blockquote><p>按時間順序在2個窗口中執行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事務詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/981cfba0c6ac47ec8d4905ba7c510ffd><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from t_user where name='路人甲Java';Empty set (0.00 sec)mysql&gt; insert into t_user values (2,'路人甲Java');ERROR 1062 (23000): Duplicate entry '路人甲Java' for key 'name'mysql&gt; select * from t_user where name='路人甲Java';Empty set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t_user values (1,'路人甲Java');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t_user;+----+---------------+| id | name          |+----+---------------+|  1 | 路人甲Java    |+----+---------------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>A想插入數據路人甲Java，插入之前先查詢了一下（T5時刻）該用戶是否存在，發現不存在，然後在T7時刻執行插入，報錯了，報數據已經存在了，因為T6時刻B已經插入了路人甲Java。</p><p>然後A有點鬱悶，剛才查的時候不存在的，然後A不相信自己的眼睛，又去查一次（T8時刻），發現路人甲Java還是不存在的。</p><p>此時A心裡想：數據明明不存在啊，為什麼無法插入呢？這不是懵逼了麼，A覺得如同發生了幻覺一樣。</p><p><br></p><h1 class=pgc-h-arrow-right>SERIALIZABLE：串行</h1><blockquote><p><strong>SERIALIZABLE會讓併發的事務串行執行（多個事務之間讀寫、寫讀、寫寫會產生互斥，效果就是串行執行，多個事務之間的讀讀不會產生互斥）。</strong></p><p><strong>讀寫互斥</strong>：事務A中先讀取操作，事務B發起寫入操作，事務A中的讀取會導致事務B中的寫入處於等待狀態，直到A事務完成為止。</p><p>表示我開啟一個事務，為了保證事務中不會出現上面說的問題（髒讀、不可重複讀、讀已提交、幻讀），那麼我讀取的時候，其他事務有修改數據的操作需要排隊等待，等待我讀取完成之後，他們才可以繼續。</p><p>寫讀、寫寫也是互斥的，讀寫互斥類似。</p><p>這個類似於java中的java.util.concurrent.lock.ReentrantReadWriteLock類產生的效果。</p></blockquote><p>下面演示讀寫互斥的效果。</p><p>將隔離級別置為SERIALIZABLE</p><pre><code># 隔離級別設置,READ-UNCOMMITTED讀未提交,READ-COMMITTED讀已提交,REPEATABLE-READ可重複讀,SERIALIZABLE串行transaction-isolation=SERIALIZABLE</code></pre><p>重啟mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服務正在停止..mysql 服務已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服務正在啟動 .mysql 服務已經啟動成功。</code></pre><p>查看隔離級別：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+--------------+| Variable_name         | Value        |+-----------------------+--------------+| transaction_isolation | SERIALIZABLE |+-----------------------+--------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表數據：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按時間順序在2個窗口中執行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事務詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f69960b79c7c433bbe1431a01b33cba7><p class=pgc-img-caption></p></div><p>按時間順序運行上面的命令，會發現T4-B這樣會被阻塞，直到T5-A執行完畢。</p><p>上面這個演示的是讀寫互斥產生的效果，大家可以自己去寫一下寫讀、寫寫互斥的效果。</p><p><strong>可以看出來，事務只能串行執行了。串行情況下不存在髒讀、不可重複讀、幻讀的問題了。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>關於隔離級別的選擇</h1><ol start=0><li>需要對各種隔離級別產生的現象非常瞭解，然後選擇的時候才能遊刃有餘</li><li>隔離級別越高，併發性也低，比如最高級別SERIALIZABLE會讓事物串行執行，併發操作變成串行了，會導致系統性能直接降低。</li><li>具體選擇哪種需要結合具體的業務來選擇。</li><li>讀已提交（READ-COMMITTED）通常用的比較多。</li></ol><p><br></p><h1 class=pgc-h-arrow-right>總結</h1><ol start=0><li>理解事務的4個特性：原子性、一致性、隔離性、持久性</li><li>掌握事務操作常見命令的介紹</li><li>set autocommit可以設置是否開啟自動提交事務</li><li>start transaction：開啟事務</li><li>start transaction read only：開啟只讀事物</li><li>commit：提交事務</li><li>rollback：回滾事務</li><li>savepoint：設置保存點</li><li>rollback to 保存點：可以回滾到某個保存點</li><li>掌握4種隔離級別及瞭解其特點</li><li>瞭解髒讀、不可重複讀、幻讀</li></ol><p><br></p><h1 class=pgc-h-arrow-right>Mysql系列目錄</h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6850349195753341451/?group_id=6850349195753341451" rel="noopener noreferrer" target=_blank>MySQL系列-第13篇：細說NULL導致的神坑，讓人防不勝防</a></p><p><strong>mysql系列大概有20多篇，喜歡的請關注一下，歡迎大家加我微信itsoku或者留言交流mysql相關技術!</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>MySQL</a></li><li><a>14</a></li><li><a>事務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html alt="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html title="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務">技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html alt=深入學習MySQL事務：ACID特性的實現原理「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cdc702d66d6943499997d11e931425eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html title=深入學習MySQL事務：ACID特性的實現原理「轉」>深入學習MySQL事務：ACID特性的實現原理「轉」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0482a52.html alt="MySQL 事務的四種隔離級別，研讀完了你能吊打面試官" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1a7cb2436dec4249b34a8c79cdb17e9c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0482a52.html title="MySQL 事務的四種隔離級別，研讀完了你能吊打面試官">MySQL 事務的四種隔離級別，研讀完了你能吊打面試官</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dacc263.html alt=MySQL數據庫中的事務以及創建表的注意事項 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dacc263.html title=MySQL數據庫中的事務以及創建表的注意事項>MySQL數據庫中的事務以及創建表的注意事項</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/daee1f6.html alt=MySQL事務提交過程（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/61f7b3575cea4b20b5e0400f9ad4d11b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/daee1f6.html title=MySQL事務提交過程（一）>MySQL事務提交過程（一）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/720ab20.html alt=MySQL事務管理的介紹（附示例） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/720ab20.html title=MySQL事務管理的介紹（附示例）>MySQL事務管理的介紹（附示例）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/e6b01ca.html alt=數據庫事務系列－MySQL跨行事務模型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/dfic-imagehandler/64c5efca-90a2-44e0-99ff-f3cfd727679e style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/e6b01ca.html title=數據庫事務系列－MySQL跨行事務模型>數據庫事務系列－MySQL跨行事務模型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>