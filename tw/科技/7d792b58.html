<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java實現遠程服務生產與消費(RPC)的4種方法 | 极客快訊</title><meta property="og:title" content="Java實現遠程服務生產與消費(RPC)的4種方法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/856837d3a1b446dbbeb16994e9ed19da"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><meta property="article:published_time" content="2020-10-29T21:12:12+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:12+08:00"><meta name=Keywords content><meta name=description content="Java實現遠程服務生產與消費(RPC)的4種方法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7d792b58.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java實現遠程服務生產與消費(RPC)的4種方法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><em>本文將通過具體的遠程服務發佈與消費案例展示4種RPC遠程調用方法.</em></blockquote><h1 class=ql-align-justify><strong>一. 通過rmi實現遠程服務的生產與消費</strong></h1><ul><li class=ql-align-justify>Java自身提供了java.rmi包, 方便開發者進行遠程服務的部署與消費, 下面將通過具體案例進行講解.</li></ul><p class=ql-align-justify><strong>遠程服務提供者實現.</strong></p><p class=ql-align-justify>創建rmi-provider項目(Maven)</p><ol><li class=ql-align-justify>創建UserService接口.</li></ol><pre class=ql-align-justify>//將要發佈的服務的接口public interface UserService extends Remote { public String helloRmi(String name) throws RemoteException;}</pre><ol><li class=ql-align-justify>創建UserServiceImpl實現類</li></ol><ul><li class=ql-align-justify>注意, UserServiceImpl除了實現UserService接口外, 還要繼承UnicastRemoteObject類, 你可以理解為它是一個發佈出去供他人調用的類, 當UserServiceImpl實現了這個類後, UserServiceImpl就能被髮布出去供別人調用.</li></ul><pre class=ql-align-justify>//將要發佈的服務的實現類public class UserServiceImpl extends UnicastRemoteObject implements UserService { public UserServiceImpl() throws RemoteException { super(); } public String helloRmi(String name) throws RemoteException { return "hello " + name; }}</pre><ol><li class=ql-align-justify>發佈遠程服務</li></ol><pre class=ql-align-justify>public static void main(String[] args) { try { //完成遠程服務的發佈 LocateRegistry.createRegistry(8888);//將遠程服務發佈在本地的8888端口 String name = "rmi://localhost:8888/rmi";//發佈的遠程服務被訪問的url UserService userService = new UserServiceImpl();//創建一個提供具體服務的遠程對象 Naming.bind(name, userService);//給遠程服務綁定一個url System.out.println("--- 已發佈rmi遠程服務 ---"); } catch (Exception e) { e.printStackTrace(); }}</pre><p class=ql-align-justify><strong>遠程服務消費者實現</strong></p><p class=ql-align-justify>創建rmi-consumer項目</p><ol><li class=ql-align-justify>把rmi-provider項目種的UserService接口與UserServiceImpl實現類複製到本rmi-consumer項目中.(這一步可以進行優化解耦, 我們可以多創建一個rmi-resource項目, 讓rmi-provider和rmi-consumer共同依賴rmi-resource項目, 然後把資源文件比如遠程服務所用到的UserService等放入rmi-resource項目中)</li><li class=ql-align-justify>遠程服務消費者對遠程服務發起調用.</li></ol><pre class=ql-align-justify>public static void main(String[] args) { try { //發佈遠程服務的訪問url String name = "rmi://localhost:8888/rmi"; //通過發佈遠程服務的url, 獲取遠程服務的代理對象 UserService userService = (UserService) Naming.lookup(name); System.out.println("獲得的遠程服務的代理對象:" + userService.getClass().getName()); String result = userService.helloRmi("rmi");//拿到遠程方法調用的結果 System.out.println("result: " + result); }catch (Exception e) { e.printStackTrace(); }}//最後輸出獲得的遠程服務的代理對象:com.sun.proxy.$Proxy0result: hello rmi</pre><ul><li class=ql-align-justify>通過最後的輸出我們看到獲得的遠程服務對象是動態代理產生的.</li></ul><p class=ql-align-justify></p><h1 class=ql-align-justify><strong>二. 通過WebService實現遠程服務的生產與消費</strong></h1><ul><li class=ql-align-justify>WebService協議是RPC的一種具體實現, 服務提供方和消費方通過http + xml進行通信.</li></ul><p class=ql-align-justify><strong>遠程服務提供者實現.</strong></p><ol><li class=ql-align-justify>首先創建遠程服務接口UserService及其實現類UserServiceImpl.</li></ol><ul><li class=ql-align-justify>注意, 使用WebService時需要對遠程服務加上註解@WebService</li></ul><pre class=ql-align-justify>@WebServicepublic interface UserService { public String sayHello(String name);}@WebServicepublic class UserServiceImpl implements UserService { @Override public String sayHello(String name) { return "hello " + name + "~"; }}</pre><ol><li class=ql-align-justify>發佈遠程服務, 過程和rmi差不多, 需要提供遠程服務的訪問地址和具體的遠程服務實現類, 使用Endpoint類的publish()方法進行發佈, 這都是JDK封裝好的.</li></ol><pre class=ql-align-justify>public class WsProviderApp { public static void main(String[] args) { //發佈的WebService的被訪問地址 String address = "http://localhost:9999/ws"; //創建遠程服務對象 UserService userService = new UserServiceImpl(); //發佈服務 Endpoint.publish(address, userService); System.out.println("遠程服務已經發布..."); }}</pre><p class=ql-align-justify><strong>查看遠程服務文檔wdsl</strong></p><ul><li class=ql-align-justify>和rmi不同的是, WebService發佈後, 調用者可以通過查看它的文檔對遠程服務發起調用.</li><li class=ql-align-justify>查看的方法是在瀏覽器中輸入遠程服務的訪問地址加上?wdsl, 比如本案例中是http://localhost:9999/ws?wsdl</li><li class=ql-align-justify>注意, 在客戶端調用遠程方法時需要用工具對wdsl文檔進行解析, 並獲得調用遠程方法的工具類. 具體操作見下一段.</li></ul><p class=ql-align-justify><strong>遠程服務消費者實現.</strong></p><ol><li class=ql-align-justify>首先根據文檔獲得調用遠程服務的工具類, JDK已經為我們封裝好了獲取的工具, 它在bin目錄下, 名字是wsimport</li><li class=ql-align-justify>打開命令行, 在命令行中輸入解析命令</li></ol><pre class=ql-align-justify>wsimport -keep -d C:\githubRepositories\shopping\ws-consumer\src\main\java -p com.shenghao.client http://localhost:9999/ws?wsdl解釋:1. wsimport 是命令的名字2. -keep 用於保留生成的類, 如果沒有該指令會只生成class文件3. -d 後面接項目中存放這些工具類的包, 填絕對路徑4. -p 填wdsl文檔的地址</pre><div class=pgc-img><img alt=Java實現遠程服務生產與消費(RPC)的4種方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/856837d3a1b446dbbeb16994e9ed19da><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Java實現遠程服務生產與消費(RPC)的4種方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ab64a65ee9e4673a89bbe69cb2474ad><p class=pgc-img-caption></p></div><p class=ql-align-justify></p><ol><li class=ql-align-justify>可以看到命令執行完後, 指定的包中出現一堆相關的類, 最直接調用到的類是UserServiceImplService. 下面演示對遠程方法進行調用.</li></ol><pre class=ql-align-justify>public static void main(String[] args) { //創建服務類對象 UserServiceImplService service = new UserServiceImplService(); //獲得遠程服務的代理對象 UserServiceImpl userService = service.getUserServiceImplPort(); System.out.println(userService.getClass().getName()); //對遠程服務對象的方法進行調用 String result = userService.sayHello("炭燒生蠔"); System.out.println(result);}//結果輸出com.sun.proxy.$Proxy32hello 炭燒生蠔~</pre><h1 class=ql-align-justify><strong>三. 通過HttpClient實現遠程服務的生產與消費</strong></h1><ul><li class=ql-align-justify>這裡我們換一個案例進行演示. 假設現在有一套用戶系統和一套訂單系統, 要實現用戶系統訪問訂單系統以獲得某個用戶的訂單信息.</li></ul><p class=ql-align-justify><strong>遠程服務提供者實現</strong></p><ul><li class=ql-align-justify>提供遠程服務的過程和響應web請求很相似, 只不過響應的不是&lt;html>標籤, 而是json字符串. 微信小程序前後端通信也是這個原理.</li></ul><ol><li class=ql-align-justify>創建名為order-sys的Maven項目, 指定打包為war包.</li></ol><p>點擊這裡查看pom.xml文件, 常規操作</p><p class=ql-align-justify></p><ol><li class=ql-align-justify>創建訂單類</li></ol><pre class=ql-align-justify>public class Order { private String id; private Double total; private String date; //get / set ...}</pre><ol><li class=ql-align-justify>對外提供服務, 發佈時打包發佈到Tomcat上</li></ol><pre class=ql-align-justify>@Controllerpublic class OrderController { /** * 接收http請求, 響應訂單集合, 異步響應 * 將list集合序列化為json串響應 * @param uid * @return */ @RequestMapping("/loadOrderList2") @ResponseBody public List&lt;Order&gt; loadOrderList2(String uid){ System.out.println("uid: " + uid); //模擬訂單數據 Order o1 = new Order(); o1.setId("111"); o1.setTotal(333.33); o1.setDate("2019-4-29"); Order o2 = new Order(); o2.setId("222"); o2.setTotal(444.44); o2.setDate("2019-5-29"); Order o3 = new Order(); o3.setId("333"); o3.setTotal(555.55); o3.setDate("2019-6-29"); List&lt;Order&gt; list = new ArrayList&lt;&gt;(); list.add(o1); list.add(o2); list.add(o3); return list; }}</pre><p class=ql-align-justify><strong>遠程服務消費者實現</strong></p><ol><li class=ql-align-justify>在服務消費端使用HttpClient發送請求, 可以理解為模擬瀏覽器發送post/get請求. HttpClient為我們封裝了拼接一個請求的細節, 使得發送一個請求變得容易.</li></ol><pre class=ql-align-justify>public static void main(String[] args) throws IOException { //發送遠程的http請求的地址 String url = "http://localhost:7070/order/loadOrderList2"; //創建HttpClient對象 CloseableHttpClient client = HttpClients.createDefault(); //創建HttpPost對象, 發送post請求 HttpPost method = new HttpPost(url); //封裝發送到服務提供者的參數 NameValuePair id = new BasicNameValuePair("uid", "10001"); List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;(); params.add(id); //封裝請求體數據 method.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); //發送具體的http請求 HttpResponse response = client.execute(method); //獲得服務提供者響應的具體數據 HttpEntity entity = response.getEntity(); //獲得http的響應體 InputStream is = entity.getContent(); int len = 0; char[] buf = new char[1024]; //使用字符流讀 InputStreamReader reader = new InputStreamReader(is); StringBuffer sb = new StringBuffer(); while((len = reader.read(buf)) != -1){ sb.append(String.valueOf(buf, 0, len)); } System.out.println(sb); //將響應回來的json字符串解析為Order集合 List&lt;Order&gt; list = JSON.parseArray(sb.toString(), Order.class); for(Order o : list){ System.out.println(o.getId() + "\t" + o.getTotal() + "\t" + o.getDate()); }}</pre><p class=ql-align-justify></p><h1 class=ql-align-justify><strong>四. 通過spring提供的RestTemplate實現遠程服務的生產與消費</strong></h1><ul><li class=ql-align-justify>通過一個紅包系統和訂單系統進行演示, 紅包系統訪問訂單系統, 獲得某個用戶的訂單信息, 派發紅包.</li><li class=ql-align-justify>訂單系統繼續沿用HttpClient中的訂單系統, 通過訪問loadOrderList2方法能返回一個訂單集合Json字符串.</li></ul><p class=ql-align-justify><strong>遠程服務消費者實現.</strong></p><pre class=ql-align-justify>@Controllerpublic class RedController { //注入由spring提供的RestTemplate對象 @Autowired private RestTemplate restTemplate; /** * 發送遠程的http請求, 消費http服務 * 獲得訂單對象的集合 */ @RequestMapping("/loadOrderList3") @ResponseBody public List&lt;ResponseEntity&lt;Order[]&gt;&gt; loadOrderList3(String uid){ //發送遠程http請求的url String url = "http://localhost:7070/order/loadOrderList2"; //發送到遠程服務的參數 MultiValueMap&lt;String, Object&gt; params = new LinkedMultiValueMap&lt;&gt;(); params.add("uid", uid); //通過RestTemplate對象發送post請求 ResponseEntity&lt;Order[]&gt; entitys = restTemplate.postForEntity(url, params, Order[].class); //查看響應的狀態碼 System.out.println(entitys.getStatusCodeValue()); //查看響應頭 HttpHeaders headMap = entitys.getHeaders(); for(Map.Entry&lt;String, List&lt;String&gt;&gt; m : headMap.entrySet()){ System.out.println(m.getKey() + ": " + m.getValue()); } return Arrays.asList(entitys); }}</pre><p>歡迎工作一到五年的Java工程師朋友們加入Java程序員開發： 721575865</p><p>群內提供免費的Java架構學習資料（裡面有高可用、高併發、高性能及分佈式、Jvm性能調優、Spring源碼，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多個知識點的架構資料）合理利用自己每一分每一秒的時間來學習提升自己，不要再用"沒有時間“來掩飾自己思想上的懶惰！趁年輕，使勁拼，給未來的自己一個交代！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>實現</a></li><li><a>遠程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44cdc077.html alt=Java如何實現自動關閉資源？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9f24b68095db4b80b744910d2b5cced6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44cdc077.html title=Java如何實現自動關閉資源？>Java如何實現自動關閉資源？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a836fe1.html alt=Java編程技巧：如何實現參數的輸入輸出？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b36247aabf154a46aca31b642fc3cd0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a836fe1.html title=Java編程技巧：如何實現參數的輸入輸出？>Java編程技巧：如何實現參數的輸入輸出？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/891a2ed3.html alt=技術點滴：實現Java父類強制轉換子類的原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539014984935468692050e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/891a2ed3.html title=技術點滴：實現Java父類強制轉換子類的原則>技術點滴：實現Java父類強制轉換子類的原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d22a47.html alt=用蒲公英旁路路由器實現遠程調試PLC class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/584e7a6d120e4337bb439f889228ea9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d22a47.html title=用蒲公英旁路路由器實現遠程調試PLC>用蒲公英旁路路由器實現遠程調試PLC</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7771d40.html alt="5分鐘！用Java實現目標檢測 | PyTorch" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bcf4256f45fe4ac29cbc234e7f84961c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7771d40.html title="5分鐘！用Java實現目標檢測 | PyTorch">5分鐘！用Java實現目標檢測 | PyTorch</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acbe13e.html alt=基於零信任的遠程辦公系統安全模型研究與實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3f63dca9b52545c58f4fd2f5b96bcac5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acbe13e.html title=基於零信任的遠程辦公系統安全模型研究與實現>基於零信任的遠程辦公系統安全模型研究與實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea69ab1.html alt=Java可重入讀寫鎖實現：ReentrantReadWriteLock class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/87955ae16a9a4013b7b4ec6a387656f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea69ab1.html title=Java可重入讀寫鎖實現：ReentrantReadWriteLock>Java可重入讀寫鎖實現：ReentrantReadWriteLock</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/325007f.html alt="教你如何用 Java 實現異步調用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/325007f.html title="教你如何用 Java 實現異步調用">教你如何用 Java 實現異步調用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9e89bbd.html alt=22、Java實現多態的機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6b65bd7dfb1c428c87904b93b9587c07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9e89bbd.html title=22、Java實現多態的機制>22、Java實現多態的機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ae124314-674a-47ca-b794-c5b32a309a66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html title=Java多態的實現機制是什麼，看完你就知道（值得收藏）>Java多態的實現機制是什麼，看完你就知道（值得收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbd7017.html alt=遠程控制軟件，如何實現遠程電腦屏幕監控？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1948047764424e0c98fed8d94698fcf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbd7017.html title=遠程控制軟件，如何實現遠程電腦屏幕監控？>遠程控制軟件，如何實現遠程電腦屏幕監控？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>