<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>認識CC++中的函數 | 极客快訊</title><meta property="og:title" content="認識CC++中的函數 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/03bef53d-57c2-4919-aacc-110f95068f0c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7e3a646d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7e3a646d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7e3a646d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7e3a646d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7e3a646d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7e3a646d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7e3a646d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7e3a646d.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="認識CC++中的函數"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7e3a646d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>認識CC++中的函數</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>一、函數原型</p><ol start=1><li>函數原型<br>函數原型又稱為函數簽名，顧名思義，通過函數原型就能夠找到你要的函數。函數原型是一種區分函數身份的聲明，聲明指定了函數的名稱、形參類型及函數的返回類型。形參名稱在函數原型聲明中並不是必須的，即形參名稱事實上是可以忽略的。如果兩個函數的原型聲明僅返回類型不同其它都相同的原型聲明是不允許的。</li></ol><p>通過提供函數原型聲明，然後再進行函數定義或調用，Ｃ++成為強類型的程序設計語言。強類型的程序設計語言要求：調用的函數的實參類型必須和函數原型的形參類型一致。在匹配調用函數的實參和函數原型的形參時，編譯程序檢查函數名和形參類型，至於形參名稱則無關緊要。由於擴展名為.h的頭文件包含函數原型聲明，因此，在調用其中的任何函數之前必須include，如果不使用include就必須直接進行原型聲明。如下例子展示了函數的原型聲明和調用方法。</p><p>例.函數原型的聲明和函數的調用。</p><pre><code>double sin(double x);//直接進行有參數名的原型聲明double cos(double);//直接進行無參數名的原型聲明int main(void){double x=3;double y=4;return sin(3.0)+sin(x)+sin(y)+cos(3.0)+ cos(x)+cos(x+y);}</code></pre><p>對於例1，你可能有幾個疑問：</p><p>（1）雙斜線“//”的作用是什麼？它表示程序註解，從雙斜線開始到當前行結束都是註解，編譯程序會自動將註解忽略。此外，C++還支持C語言原有的形式為“/註解內容/”的註解，這種註解通常可以跨多行存在。</p><p>（2）主函數main的返回類型是int，可是return的表達式的值卻是double類型的？這沒有關係，因為編譯程序會自動將double類型的值轉化為int類型。</p><p>（3）變量x、y都是double類型的，可是卻用int類型的值初始化？這也沒有關係，因為編譯程序會自動將int類型的值轉化為double類型。</p><p>（4）變量x和sin函數原型中的x相同，這不會引起混淆嗎？這不用擔心，在調用sin(x)時，實參是主函數main定義的變量x，實參的值傳給sin(x)的形參，之後實參和形參就沒有任何關係。調用sin(x)時，編譯程序會檢查實參和形參的類型是否一致。</p><p>（5）在調用sin(3.0)中，實參3.0沒有名稱能行嗎？能行，因為編譯程序檢查的只是實參和形參類型，兩者的類型相同就可以了，然後將實參的值3.0傳給sin(double x)的形參x。</p><p>（6）在調用cos(x+y)中，使用x+y不會出錯嗎？當然不會，只要x+y的值的類型和形參類型一致即可，x+y的值將傳給cos(double)的形參，儘管在原型聲明double cos(double) 中形參沒有名字，但在定義該函數的函數體時一定會給出形參名稱。</p><p>從例1來看，函數原型的聲明出現在函數調用之前，這顯然符合C++強類型程序設計語言的要求。為了簡單起見，這些數學運算函數的函數原型聲明被一起打包，存放在一個名字為math.h的頭文件中。在調用這些函數之前，使用#include 進行原型聲明。如果使用#include "math.h"，則表示math.h可能是你自己建立的一個頭文件，這個文件應該和你的擴展名為“.cpp”的程序文件放在同一目錄。</p><p>例.聲明和函數的調用。</p><pre><code>include&lt;math.h&gt;  //math.h中的所有原型聲明將出現於此、替換本行int main(void){double x=3;double y=4;return sin(3.0)+sin(x)+sin(y)+cos(3.0)+ cos(x)+cos(x+y);}</code></pre><p>宏命令#include 在編譯時起的作用是宏替換，它將math.h中的所有函數原型聲明替換#include 所在的行。即使有些數學函數你不使用，比如對數函數log（double），它也會作為原型聲明出現在主函數main的前面。不過這並不會增加你編譯後的可執行程序的長度，因為一個函數如果沒有被使用，就不會被連接到可執行程序中。</p><p>對於sin等被C++預定義的函數來說，只需要進行函數原型聲明就行了，不必進行函數定義，即程序員不必定義其函數體，編譯程序會自動連接擴展名為.lib的庫文件；如果編譯程序沒有連接相應.lib的庫文件，也可要求操作系統動態連接.dll庫文件。但是，對於程序員自己定義的函數原型，就必須在某個程序文件內定義相應的函數體。</p><pre><code>例.函數的原型聲明和調用。int square(int);//函數原型說明int main(void){//必須先進行函數原型聲明或定義函數（體），才能調用函數int y= square(5);//函數原型已經在前面聲明，故可調用return 0;}int square(int x)//程序員自己定義的函數，必須自定義函數體{ return x*x; }//自定義的函數體</code></pre><p>2.函數重載函數重載即是對同一名稱函數或者運算符加載不同的功能。假如要定義一組減法函數sub，用來完成：</p><p>（1）整數減整數；（2）浮點數減浮點數；（3）整數減浮點數；（4）浮點數減整數；（5）單目減，求整數的負整數；（6）單目減，求浮點數的負浮點數。</p><p>如果重載時形參再考慮其它類型，那麼定義出來的重載函數就會更加多樣了。</p><p>例. 減法函數的原型聲明和調用。</p><pre><code>int sub(int x, int y){ return x – y; }//整數減整數int sub(int x) { return -x; }//單目減：求整數的負整數double sub(double x, double y){ return x – y; }//浮點數減浮點數double sub(int x, double y){ return x – y; }//整數減浮點數double sub(double x, int y){ return x – y; }//浮點數減整數double sub(double x) { return -x; }//單目減：求浮點數的負浮點數int main(void){double x, y=4, z=5;x=sub(7, 1);//調用int sub(int x, int y)y=sub(x, 1);//調用int sub(double x, int y)y=sub(3.2, 1);//調用int sub(double x, int y)return sub(-3);//調用int sub(int x)返回整數3}</code></pre><p>當同一個函數sub被重載用於完成不同的功能時，編譯程序在調用這些函數時是如何避免其相互混淆的？編譯程序是根據實參類型與形參類型是否匹配來進行區分的。例如，在例3中函數調用sub(3.2, 1)的兩個實參分別為double和int類型，因此，編譯程序將調用的函數原型為int sub(double x, int y)。要把各種形參類型都定義一遍，要定義的重載函數實在太多了。</p><p>有時並沒有定義各種形參類型的重載函數，在調用函數時編譯程序會作何選擇呢？例如，在例3中就沒有重載sub(char, char)函數，如果要用sub('B ', 'A') 調用sub函數，那麼會調用哪個函數呢？根據C和C++的類型轉換規則，char類型首先轉換為int類型，因此，sub(‘B’, ‘A’)會調用int sub(int x, int y)函數。調用時需要注意實參類型可能會被轉換，以便能夠成功地匹配被重載的原型函數。</p><p>3.重載的實現函數重載就是同一個函數名稱，通過其形參個數或者類型的不同，區分定義其完成的不同功能。為了弄清楚編譯程序如何實現函數重載，有必要檢查一下例4編譯後的彙編程序。假定例4程序的文件名為sub.cpp，採用C++ builder 6.0的32位命令行編譯器bcc32.exe，編譯產生彙編代碼的命令為bcc32 –S sub.cpp。為了節省篇幅及更清楚的查看彙編代碼，在省略了不太重要的部分彙編代碼後，例4編譯後的彙編語言程序如例5簡要所示。</p><p>例5. 例4程序編譯後的部分彙編代碼。</p><p>; int sub(int x, int y);//編譯後的函數名為@@sub$qii</p><p>@@sub$qii proc near;//@@sub$qii的兩個i代表兩個參數int</p><pre><code>push ebp;//保存ebp的值mov ebp,esp;//使用ebp代替棧指針mov eax,dword ptr [ebp+8];//取x的值送入寄存器eaxsub eax,dword ptr [ebp+12];//減去變量y的值，結果在eaxpop ebp;//恢復ebp的值ret;//函數返回值在eax寄存器</code></pre><p>; int sub(int x) { return -x; };//編譯後的函數名為@@sub$qi</p><p>@@sub$qi proc near;//@@sub$qii的一個i代表參數int</p><pre><code>push ebpmov ebp,espmov eax,dword ptr [ebp+8]neg eax;//求eax存儲的整數的負整數pop ebpret;//函數返回值在eax寄存器</code></pre><p>; double sub(double x, int y);//編譯後的函數名為@@sub$qdi</p><p>@@sub$qdi proc near;//@@sub$qdi表示有參數double, int</p><pre><code>push ebpmov ebp,espfild dword ptr [ebp+16]fsubr qword ptr [ebp+8];//真正有效的減法指令pop ebpret</code></pre><p>; int main(void);//編譯後的函數名為@_main</p><p>@_main proc near</p><pre><code>push ebpmov ebp,espadd esp,-28;//為變量x,y,z等分配棧空間</code></pre><p>; x=sub(7, 1);;//調用int sub(int x, int y)</p><pre><code>push 1;//從右至左傳實參：第2個參數，4字節入棧push 7;//從右至左傳實參：第1個參數，4字節入棧call @@sub$qii;//調用int sub(int x, int y)add esp,8;//使調用前後棧指針平衡：8字節出棧mov dword ptr [ebp-28],eax;//將減法結果賦給變量x，x的地址為[ebp-28]</code></pre><p>...</p><p>; y=sub(3.2, 1);;//調用int sub(double x, int y)</p><pre><code>push 1;//從右至左傳實參：第2個參數，4字節入棧push 1074370969;//從右至左傳實參：第1個參數分兩次8字節入棧push -1717986918call @@sub$qdiadd esp,12;//使調用前後棧指針相同：12字節出棧fstp st(0)</code></pre><p>; return sub(-3);;//調用int sub(int x)返回整數3</p><pre><code>push -3;//從右至左傳實參：整數-3用4字節入棧call @@sub$qi;//調用int sub(int x)，返回值在eaxpop ecx;//4字節出棧mov esp,ebppop ebpret;//主函數返回值在eax</code></pre><p>在上述彙編語言程序中，使用分號表示註解。仔細分析該彙編代碼，可以初步瞭解C++的編譯方法。首先要注意的是編譯後的函數名：int sub(int x, int y)編譯後函數名為@@sub$qii，而double sub(double x, int y) 編譯後函數名為@@sub$qdi。彙編語言的@和$就像C++的字母一樣，可以作為函數名和變量名等標識符的一部分，編譯自動產生的@@和$q主要起分隔和引導作用，分別表示後面出現的是函數名和形參類型，因此，彙編程序中的函數名@@sub$qii既包括了C++的原始函數名sub，也包括了該C++函數的兩個參數類型int。從C++的角度來看，所有重載函數的函數名是相同的；而從彙編語言的角度來看，所有重載函數的函數名是不同的。</p><p>當了解了編譯程序如何實現和編譯重載函數以後，就會理解為什麼調用時編譯程序不會產生混淆。例如，假如sub函數調用使用兩個整型實參7和1，編譯程序就會根據參數類型自動產生call @@sub$qii調用指令，而其對應的C++函數原型就是int sub(int, int)。需要注意的是調用後，函數的整型返回值總是存放在eax寄存器中，eax是編譯器使用的X86系列CPU的32位通用寄存器。另外，在main調用sub函數的前後，棧STACK的指針總是平衡或相同的，這就說明了為什麼使用高級語言編程很少出現棧溢出。值得注意的是：在傳遞實參時，實參的傳遞順序是自右至左的，這只是C++ builder 6.0的實現方法，當然也是大多數編譯器的實現方法。但是，C++國際標準並未強行規定傳遞實參一定要從右向左。</p><p>二、函數內聯1.為什麼需要內聯函數如果繼續觀察例4的彙編代碼，就知道為什麼需要函數內聯了。首先來看為了計算7-1，調用sub(7, 1)的彙編程序到底做了多少有用和近乎無用的工作。參看例4彙編後的主程序：</p><p>（1）首先要傳遞實參，先後通過兩條壓棧指令push 1和push 7完成，向棧頂壓入共計8個字節；</p><p>（2）然後發出函數調用指令call @@sub$qii；</p><p>（3）最後使調用前後的棧指針保持平衡，即使用add esp,8使棧頂回調8個字節。</p><p>主函數一共使用了4條指令完成sub(7, 1)的調用。</p><p>然後再來看看函數@@sub$qii做了哪些工作。在函數@@sub$qii中，一共使用了6條指令。其中，只有兩條指令真正用來完成減法操作：mov eax,dword ptr [ebp+8]用於取被減數的值，sub eax,dword ptr [ebp+12]用於減去減數的值，結果遺留在eax寄存器中，並被當作函數的返回值。在函數 @@sub$qii中只有兩條指令實際完成減法操作。</p><p>由此可見，主函數main和減法函數sub一共使用10條指令完成7-1運算，但其中僅僅兩條指令真正用來進行減法操作，可見指令的實際利用效率非常之低。如果設法用 @@sub$qii函數體的兩條減法指令，來替換主函數所有的調用減法函數的四條指令，然後去掉@@sub$qii函數，節約出來的指令總數將極其可觀，同時程序執行的速度也會大大加快。</p><p>假如主函數一共有20個int sub(int x, int y)調用，按上述方法用sub函數體的有效減法指令替換後，可執行程序的總長度將減少46條指令（20次調用4指令/每次+sub函數6指令-替換後20次調用2指令/每次），而替換前需要執行2010共計200條指令，替換後需要執行202共計40條指令，很顯然程序的執行速度也提高了4倍。上述替換方法就是函數內聯(inline，內嵌)。在被內聯函數的函數體很小時，內聯將使程序的總長度變短；而如果被調內聯函數的函數體很長時，內聯反而會使程序更加冗長。</p><p>2.內聯函數的定義及使用當被調函數的函數體很小時，函數內聯能減少程序代碼，大大降低程序運行開銷。函數內聯即用被內聯的有效函數體替代調用指令從而降低程序運行開銷。內聯函數用保留字inline聲明或定義。一個函數若被定義為內聯函數，編譯程序就會用其函數體替換每個調用，而不是把調用編譯成壓棧、調用和退棧指令。編譯為了提高效率大都只掃描程序一次，因此，內聯函數的函數體定義一定要出現在調用之前，否則，編譯程序會因無法找到內聯函數體而無法替代調用指令，從而造成函數內聯失敗而仍然按非內聯的方式編譯調用。</p><p>例. 編程計算圓的面積。</p><pre><code>說明：程序在調用函數之前定義了內聯函數area的函數體。編譯會將主程序中的調用area(m)直接替換為3.1415926*m*m，而不是編譯成push、call、pop等若干機器指令。</code></pre><p>程序：</p><pre><code>include&lt;iostream.h&gt;inline double area(double r){return 3.1415926*r*r;}void main(void){double m;cout&lt;&lt;"Please input a radius:";cin&gt;&gt;m;cout&lt;&lt;"The area is "&lt;&lt;area(m);//函數內聯成功}</code></pre><p>如前所述，若內聯函數的函數體定義出現在調用之後，可能會造成編譯時函數內聯失敗。在內聯函數內部，不能使用分支、循環、開關和函數調用等引起轉移的語句，這些函數被視為函數體複雜的函數，因編譯傾向於內聯函數體簡單的函數而造成內聯失敗。此外，若其他函數訪問了被內聯函數的入口地址，或者被內聯的函數是類的虛函數或純虛函數，都會導致內聯函數在編譯時內聯失敗。</p><p>例7. 編程計算圓的面積。</p><pre><code>include&lt;iostream.h&gt;inline double area(double r);//內聯函數原型說明inline double girth(double r);//內聯函數原型說明inline double girth(double r)//內聯函數定義：inline可省略{return 2*3.1415926*r;}void main(void){double m;cout&lt;&lt;"Please input a radius:";cin&gt;&gt;m;cout&lt;&lt;"Girth="&lt;&lt;girth(m)&lt;&lt; "\n";//函數內聯成功cout&lt;&lt;"Area="&lt;&lt;area(m) &lt;&lt; "\n";//一次性掃描的編譯：函數將內聯失敗}inline double area(double r)//內聯函數定義：inline可省略{return 3.1415926*r*r;}</code></pre><p>內聯失敗並不表示程序出現了錯誤，只是仍然按函數調用指令進行編譯。內聯函數無論內聯是否成功，其作用域都局部於當前程序文件，也就是說相當於在定義函數時使用了static保留字。因此，其他程序文件是無法訪問該內聯函數的。如果其它文件希望調用該內聯函數，可以重新進行相同的內聯定義或使用include。因為static函數或變量的作用域侷限於其定義文件，因此，在不同程序文件內重複定義相同的static函數和變量不會衝突。</p><p>是不是所有的函數都可以定義為inline的呢？當然不是，比如主函數main。現有的C++編譯器只允許出現一個main，這個main被作為操作系統的唯一調用入口，該函數的作用域是全局的而不是static的，即main在任何程序文件都能訪問到。現有C++編譯器不允許調用main或者取main的地址。事實上，如果能夠取main的地址，就可以通過函數指針調用main了，所以歸根結底是現有編譯不允許調用main。</p><p>以前的編譯允許定義多個static的main函數，但是，新版編譯器似乎都不允許這樣的定義。如此一來，用inline說明main也不被允許了：如前所述，如果main內聯成功，則相當於在main之前加上static，main的作用域就會侷限於當前程序文件；並且如前所述如果內聯成功，被內聯的main函數代碼將被拋棄，如此main函數也就不復存在，操作系統就無法調用和進入main了。所以，新編譯器大都不允許內聯main函數。</p><p>三、函數參數1.具有缺省值的函數參數在聲明函數原型和定義函數體時，必須說明函數的形參類型。形參名稱在進行原型聲明時並不是必須的。但在定義函數的函數體時，如果定義的形參沒有名稱，函數體就無法訪問該形參，因此，如果希望訪問該形參就應說明其名稱。具有缺省值的函數形參是這樣一種形參，給定的值將作為調用時不傳實參時的缺省實參值。當然，如果無名形參有缺省值，該值也無法被函數體使用。因此，在定義形參的缺省值時，通常都應該給出參數名稱，但不給也不意味程序出錯。</p><p>例8. 編程輸出對春夏秋冬的評價。</p><pre><code>include &lt;iostream.h&gt;void evaluate (char *season=" Spring")//具有缺省值的形參說明{ cout&lt;&lt;season&lt;&lt;" is a beautiful season \n"; }void main( ){evaluate( );//使用缺省值，等價於evaluate("Spring")evaluate("Automn");//不使用缺省值}</code></pre><p>在上述主函數main中，第1個調用沒有給出參數，故使用定時時的缺省參數值，相當於調用evaluate("Spring")；第2個調用沒有使用缺省參數值。在定義具有缺省值的形參時，可以定義多個有缺省值的參數，但是它們必須出現在參數表的右部，且中間不得參雜不缺省值的形參。在聲明函數原型和定義函數體時，不能重複定義函數形參的缺省值。此外，缺省值的表達式也不能用同一參數表的形參。</p><p>例. 具有缺省值的形參定義方法。</p><pre><code>int u, v; //全局變量的u=v=0int m(int x, int y=5) {return x+y; }//正確int a(int u, int x=5,int y=6+m(u,v))//正確{ return u+x+y; }int b(int x=1,char,int z=1);//錯誤，夾雜非缺省值參數int b(int x=u);//正確，定義缺省值x=u，此時u=0int w=++u;//正確：w=u=1;int b(int x=u) {return x*x;}//錯誤：不能重複定義缺省值x=u，此時u=1int c(int x, int y=x++);//錯誤：表達式中出現同一參數表的參數xvoid main( ){int q=0;c(q);//使用缺省值，等價於c(q, q++);}</code></pre><p>為什麼缺省值的表達式不能使用同一參數表的形參呢？在調用函數時，C++的國際標準沒有規定實參是從左向右計算還是從右向左計算，對於等價於c(q, q++)的函數調用c(q)，兩個方向計算實參的調用結果是不同的：（1）從左向右計算實參得到調用c(0, 0)及q=1；（2）從右向左計算實參得到調用c(1, 0)及q=1。這種不同造成程序不可移植，即不能使用不同的編譯程序：不同的編譯計算實參的次序可能不同，從而可能產生不可移植（不同）的運行結果。</p><p>2.函數的省略參數當不能確定函數到底有多少形參時，可以將函數參數定義為省略參數。省略參數是這樣一種參數，它出現在函數參數表的最右部，表示參數個數和參數類型不定。省略參數使用…定義，而…的左邊可以定義若干參數。實際上在頭文件stdio.h中，就已經說明了若干省略參數的函數，其中最常用的幾個函數說明如下：</p><p>int scanf(const char , …);//參數const char 控制輸入：確定要輸入幾個變量</p><p>int printf(const char , …);//參數const char 控制輸出：確定要輸出幾個值</p><p>int sprintf(char , const char , …);//參數char 存放輸出結果，參數const char 控制輸出</p><p>注意在上述函數中，scanf的返回值表示成功輸入的變量個數，printf和sprintf的返回值表示成功輸出的字符個數。對於printf和sprintf來說，輸出總是會成功的。但是，對於scanf來說，希望輸入的變量個數可能少於成功輸入的變量個數：因為鍵盤設備可以看作一個輸入文件，而任何文件都可能遇到文件結束而輸入尚未完成。對於不同的操作系統，鍵盤文件結束的表示方式不同，例如UNIX操作系統的文件結束為CTRL-D字符，而微軟的MS-DOS和Windows的文件結束為CTRL-Z。字符CTRL-Z表示按住CTRL鍵不放，再按下字符Z鍵然後同時釋放兩個鍵；字符CTRL-D的鍵入方法以此類推。</p><p>例. 編程輸入若干正整數，並計算每個整數有幾位有效數字。</p><pre><code>include&lt;stdio.h&gt;void main( ){int x;while(scanf("%d", &amp;x)==1)//輸入直到遇到鍵盤文件結束為止printf(" has %d digits\n", printf("%d", x));}</code></pre><p>在上述程序中，printf("%d", x)用於打印整數，並將成功輸出的字符個數作為整型返回值，這個值即正整數的有效數字位數。在MS-DOS或Windows操作系統上運行程序，可採用如下使用CTRL-Z結束鍵盤文件的輸入：</p><p>35 ↵</p><p>567 ↵</p><p>CTRL-Z ↵</p><p>如果不想同時將整數x輸出到屏幕上，可採用sprintf替代printf("%d", x)函數調用。從int printf(const char *, …)使用省略參數的方式來看，通常要用第1個參數如格式串確定後面省略了幾個參數。在定義自己的省略參數函數時，也應該遵循這種定義模式。當然，參數表僅有省略參數也是允許的，只是定義函數體時處理起來相當麻煩。</p><p>例11. 編寫函數計算n個整數的和。</p><pre><code>int sum(int n, …)//第1個參數n表示後面省略了n個整數{int s=0, *p=&amp;n+1;//p指向第1個省略參數，即n後面的參數for(int h=0; h&lt;n; h++) s+=p[h];return s;}int main( ){return sum(4,1,2,3,4);//計算1+2+3+4的和}</code></pre><p>由此可以瞭解，printf和sprintf等函數是如何實現的。需要注意的是：int printf(const char *, …)省略的可能是int、double等不同類型的參數，通過第1個參數即格式串可以知道省略的每個參數的類型，由於通過實參傳遞的不同類型的值依次存放在棧上（見例5），因此通過棧指針可依次為某參數取若干字節、然後通過強制類型轉換將其轉換成相應類型的值，就可以得到每個要輸出的省略參數的值。</p><p>3.函數調用的二義性當調用一個函數時，若有二個以上的函數原型能與之匹配，則該函數調用就產生了二義性。要從根本上解決二義性問題，可以從函數原型聲明上著手，在說明函數原型或定義函數體時，應儘量降低產生二義性的可能性。當然，如果原型聲明實在無法避免，則只能在調用時避免二義性，即通過更多或更明確的實參明確區分。</p><p>例. 函數調用的二義性問題。</p><pre><code>int f(int x) {return x; }int f(int x, int y=3) {return x+y; }char f(int x, char c="ABCDEFGH") ｛return x+c; }int f(int x, …) {return x; }void main( ){f(2);//二義性調用：四個函數原型均可匹配}</code></pre><p>在上述f(2)調用中，四個重載函數f都能和調用匹配：</p><p>（1）由於2是int類型，故能同第1個函數int f(int x)匹配；</p><p>（2）由於調用f(2)可被認為使用缺省y=3，故能和函數int f(int x, int y=3)匹配，相當於函數調用f(2,3)；</p><p>（3）同理，可以和函數char f(int x, char c="ABCDEFGH")匹配，相當於函數調用f(2, "ABCDEFGH")；</p><p>（4）由於調用f(2)可被認為省略0個參數，因此，調用f(2)能和函數原型int f(int x, …)匹配。</p><p>排除二義性的方法無非有兩種：</p><p>（1）在函數聲明或定義時避免二義性，如極端的情況是不定義重載函數；</p><p>（2）在函數調用時給出更多實參，以便提供更充分的信息匹配函數原型。</p><p>例如，調用f時給出兩個實參能區分前三個重載函數，這樣一來調用函數就不能使用參數的缺省值了。在例中，只有給出三個以上的實參調用f才能匹配第4個函數。這個例子說明在定義重載函數時，出現調用二義性問題的可能性極大，往往導致參數缺省值無法使用，失去了缺省值的定義意義。</p><p><br></p><div class=pgc-img><img alt=認識C\C++中的函數 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/03bef53d-57c2-4919-aacc-110f95068f0c><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>認識</a></li><li><a>C++</a></li><li><a>函數</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/22fd7b17.html alt="C++ 函數：形參實參，模板重載" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/ad911237-4510-453c-b211-16efcf806984 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22fd7b17.html title="C++ 函數：形參實參，模板重載">C++ 函數：形參實參，模板重載</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acfb9119.html alt=C++向函數傳遞參數的三種方式：傳值、指針、引用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/80f1df27-02c4-45cc-a3ff-bd6923e864f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acfb9119.html title=C++向函數傳遞參數的三種方式：傳值、指針、引用>C++向函數傳遞參數的三種方式：傳值、指針、引用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html alt=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/805329c3d3fc4c7aae35456efd84cd6c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html title=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板>C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a147b626.html alt=認識Python函數的兩個概念：形參與實參（16） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6d41670d583a40b88877ba02fc5f915b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a147b626.html title=認識Python函數的兩個概念：形參與實參（16）>認識Python函數的兩個概念：形參與實參（16）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6faa43d.html alt=C++｜函數與指針：簡單瞭解函數指針和指針函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153922133587228f21bd9b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6faa43d.html title=C++｜函數與指針：簡單瞭解函數指針和指針函數>C++｜函數與指針：簡單瞭解函數指針和指針函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cbdc7de1.html alt=C++｜函數聲明、定義、調用，也就是約定函數接口與接口實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d47eb8ecb81243c6b400e21c69ec3bf9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cbdc7de1.html title=C++｜函數聲明、定義、調用，也就是約定函數接口與接口實現>C++｜函數聲明、定義、調用，也就是約定函數接口與接口實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f95d5bfd.html alt=C++子類的成員函數如何成為父類的友元函數？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/912200096040d5e4e8cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f95d5bfd.html title=C++子類的成員函數如何成為父類的友元函數？>C++子類的成員函數如何成為父類的友元函數？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a2e003a.html alt=你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cc30aa4b32114cb7aa98314ba1519473 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a2e003a.html title=你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力>你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/429ef3cd.html alt=認識七天在一起一天，離別時卻是一輩子 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/98e368bb546b47699c3f48c661fa0076 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/429ef3cd.html title=認識七天在一起一天，離別時卻是一輩子>認識七天在一起一天，離別時卻是一輩子</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa09bc26.html alt=帶您認識防靜電滾輪的基礎知識！-山西天罡 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2b8a90d785874d838aa0057c8a5a4ecf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa09bc26.html title=帶您認識防靜電滾輪的基礎知識！-山西天罡>帶您認識防靜電滾輪的基礎知識！-山西天罡</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e087ca41.html alt=偏導數和函數的梯度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9d20a1e4cbff42a094d57df057fe9597 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e087ca41.html title=偏導數和函數的梯度>偏導數和函數的梯度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fc113b1.html alt=梯度原理：梯度在每一點上都指向函數增長最快的方向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cdb8db41d5024f38a2e490e66baebdb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fc113b1.html title=梯度原理：梯度在每一點上都指向函數增長最快的方向>梯度原理：梯度在每一點上都指向函數增長最快的方向</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62f3704c.html alt="哈密 最美的季節重新認識你！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15399338780300ff4260a66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62f3704c.html title="哈密 最美的季節重新認識你！">哈密 最美的季節重新認識你！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>