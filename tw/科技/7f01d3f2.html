<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>吃透Java集合系列二：Collection與其子接口 | 极客快訊</title><meta property="og:title" content="吃透Java集合系列二：Collection與其子接口 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/691aeb05fb314dfa98f57c29c5694b6b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7f01d3f2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7f01d3f2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7f01d3f2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7f01d3f2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7f01d3f2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7f01d3f2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7f01d3f2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7f01d3f2.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="吃透Java集合系列二：Collection與其子接口"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7f01d3f2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>吃透Java集合系列二：Collection與其子接口</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>前言</h1><p>本篇文章作為吃透Java集合系列第二篇文章，主要探討Collection接口及其子接口List、Set、Queue。通過本篇文章我們需要明白如下幾個問題：</p><p>1、Collection的作用？</p><p>2、List、Set、Queue接口對Collection接口做了哪些擴展，各自有什麼特點？</p><h1>一：Collection接口</h1><p>Collection接口是集合層次的根接口，定義了集合的通用操作，所有集合都是在Collection基礎上進行擴展的。</p><p>先看一下Collection的源碼：</p><pre>/** * 集合層次結構中的根接口。一個集合代表一組對象，被稱為元素。 * 一些集合允許重複的元素，而有些則不允許。一些是有序的，另一些是無序的。 * JDK沒有提供這個接口的任何直接的實現：它提供更具體的子接口像 Set和 List實現。 *  * 所有通用的Collection實現類（通常通過其子接口間接實現Collection）應該提供兩個“標準”構造函數： * void（無參數） 構造函數，它創建一個空集合，以及一個帶有Collection類型的單個參數的構造函數， * 它創建一個與它的參數具有相同元素的新集合。實際上，後者的構造函數允許用戶複製任何集合，生成所需實現類型的等效集合。 * 沒有辦法強制執行這個約定（因為接口不能包含構造函數），但是Java平臺庫中的所有通用Collection實現都符合。 *  * 如果這個集合不支持某個操作的話，調用這些方法可能（但不是必需）拋出 UnsupportedOperationException  */public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {	/** * 此方法成功完成後，可確保對象包含在集合中。 * 如果集合被修改，則返回true，如果沒有更改，則返回false。 */ boolean add(E e)	/** * 將指定集合中的所有元素添加到這個集合 */ boolean addAll(Collection&lt;? extends E&gt; c)	/** * 從這個集合中移除指定元素的一個實例 */ boolean remove(Object o)	/** * 刪除此集合中包含的所有元素的所有元素。 */ boolean removeAll(Collection&lt;?&gt; c) 	/** * 刪除滿足給定謂詞的這個集合的所有元素。 */ default boolean removeIf(Predicate&lt;? super E&gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator&lt;E&gt; each = iterator(); while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; }	/** * 從這個集合中移除所有不包含在指定集合中的元素的所有元素。 */ boolean retainAll(Collection&lt;?&gt; c)  /** * 從這個集合中移除所有的元素 */ void clear()	/**	* 返回此集合中的元素的數目。如果這個集合包含多 Integer.MAX_VALUE元素，返回 Integer.MAX_VALUE。	*/ int size();  /** * 如果此Collection不包含元素，則返回true */ boolean isEmpty()  /** * 如果集合包含指定元素，返回 true。 */ boolean contains(Object o)	/** * 返回 true如果這個集合包含指定集合的所有元素。 */ boolean containsAll(Collection&lt;?&gt; c)  /** * 返回一個包含此集合中包含的所有元素的新數組。 * 如果實現已經排序了元素，它將以與迭代器返回的順序相同的順序返回元素數組。 * 返回的數組不反映集合的任何更改。 即使底層數據結構已經是一個數組，也創建一個新數組。 */ Object[] toArray()  /** * 返回包含此集合中包含的所有元素的數組。 如果指定的數組足夠大以容納元素，則使用指定的數組 * 否則將創建相同類型的數組。 如果使用指定的數組並且大於此集合，則Collection元素之後的數組元素將設置為null。 */ &lt;T&gt; T[] toArray(T[] a)  /** * 重寫Object中的equals方法 */ boolean equals(Object o)  /** * 重寫Object中的hashCode方法 */ int hashCode()  /** * 返回可用於訪問此Collection所包含的對象的Iterator實例。 沒有定義迭代器返回元素的順序。 * 只有當Collection的實例具有定義的順序時，才能按照該順序返回元素。 */ Iterator&lt;E&gt; iterator()  /** * 返回一個並行迭代器類Spliterator */ default Spliterator&lt;E&gt; spliterator() { return Spliterators.spliterator(this, 0); }  /** * 這個集合中的元素的順序 Stream */ default Stream&lt;E&gt; stream() { return StreamSupport.stream(spliterator(), false); }  /** * 返回一個可能並行 Stream與集合的來源。 */ default Stream&lt;E&gt; parallelStream() { return StreamSupport.stream(spliterator(), true); }</pre><ul><li>Collection接口是Java語言中最基本的集合接口，在JDK中沒有直接提供Collection接口的具體實現類，Collection的功能實現類主要是對它的三個更具體的子接口List、Set和Queue的具體實現類。但是在Collection接口中定義了一套通用操作的實現方法和命名規則。</li><li>List、Set、Queue接口都繼承自Collection並定義了各自不同的方法對其擴展。</li></ul><h1>二：List接口</h1><p>List接口擴展了Collection，可以根據下標index對元素進行操作，每個元素都有唯一一個下標對應。</p><p>添加了功能更強大的ListIterator迭代器，可以沿任一方向遍歷List，並且在遍歷期間還可以修改List</p><pre>/**  * List是維護其元素的排序的集合。 List中的每個元素都有一個索引。 因此，每個元素可以被其索引訪問，第一個索引為零。  * 通常，與集合相比，List允許重複元素，其中元素必須是唯一的。 * 有序集合（也稱為&lt;i&gt;序列&lt;/ i&gt;）。 該接口的用戶可以精確控制每個元素插入到列表中的哪個位置。  * 用戶可以通過整數索引（列表中的位置）訪問元素，並搜索列表中的元素。 *  * 列表允許重複元素，也允許null元素插入 */ public interface List&lt;E&gt; extends Collection&lt;E&gt; {  /** * List作為Collection的子接口提供了Collection接口定義的方法  * 這些方法在Collection源碼中已經分析過了，就不在說明了  */  //增 boolean add(E e);  boolean addAll(Collection&lt;? extends E&gt; c);  //刪 boolean remove(Object o);  boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); default boolean removeIf(Predicate&lt;? super E&gt; filter)  void clear();  //查 int size();  boolean isEmpty(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); //轉數組 Object[] toArray();  &lt;T&gt; T[] toArray(T[] a);  //重寫Object方法 boolean equals(Object o);  int hashCode(); //迭代器  Iterator&lt;E&gt; iterator();  default Spliterator&lt;E&gt; spliterator()  //同時List接口定義了一些自己的方法來實現“有序”這一功能特點  /**  *返回列表中指定索引的元素 */  E get(int index);  /**  *設定某個列表索引的值  */  E set(int index, E element);  /**  *在指定位置插入元素，當前元素和後續元素後移  *這是可選操作，類似於順序表的插入操作  */  void add(int index, E element);  /** * 在指定位置插入指定集合中的元素，當前元素和後續元素後移 */  boolean addAll(int index, Collection&lt;? extends E&gt; c);  /**  * 刪除指定位置的元素(可選操作) */  E remove(int index);  /**  * 獲得指定對象的最小索引位置，沒有則返回-1 */  int indexOf(Object o);  /** * 獲得指定對象的最大索引位置，可以知道的是若集合中無給定元素的重複元素下  * 其和indexOf返回值是一樣的 */  int lastIndexOf(Object o);  /** * 一種更加強大的迭代器，支持向前遍歷，向後遍歷  * 插入刪除操作，此處不解釋 */  ListIterator&lt;E&gt; listIterator();  ListIterator&lt;E&gt; listIterator(int index);  /**  * 返回索引fromIndex(包括)和toIndex(不包括)之間的視圖。 */  List&lt;E&gt; subList(int fromIndex, int toIndex); } </pre><p><strong>List集合特點</strong></p><ul><li>內部元素是有序的 ，集合中每個元素都有其對應的順序索引。</li><li>元素是可以重複的 ，因為它可以通過索引來訪問指定位置的集合元素。</li><li>List接口有3個常用的實現類，分別是ArrayList、LinkedList、Vector。</li></ul><h1>三：Set接口</h1><p>Set接口完全繼承了Collection，在Collection基礎上並沒有什麼改動，但是增加了一個約定：不包含重複元素的集合！</p><p>接下來我們看一下源碼：</p><pre>/** * Set是不允許重複元素的數據結構。 */public interface Set&lt;E&gt; extends Collection&lt;E&gt; { /** * Set作為Collection的子接口提供了Collection接口定義的方法  * 這些方法在Collection源碼學習中已經分析過了，就不在說明了  */  //增 boolean add(E e);  boolean addAll(Collection&lt;? extends E&gt; c);  //刪 boolean remove(Object o);  boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); default boolean removeIf(Predicate&lt;? super E&gt; filter)  void clear();  //查 int size();  boolean isEmpty(); boolean contains(Object o); boolean containsAll(Collection&lt;?&gt; c); //轉數組 Object[] toArray();  &lt;T&gt; T[] toArray(T[] a);  //重寫Object方法 boolean equals(Object o);  int hashCode(); //迭代器  Iterator&lt;E&gt; iterator();  default Spliterator&lt;E&gt; spliterator()}</pre><p>Set內部元素是無序的，元素是不可以重複的</p><h1>四：Queue接口</h1><p>1、Queue是在處理之前保存元素的集合。除了基本的Collection操作外，Queue還提供額外的插入、刪除和檢查操作</p><p>2、每個Queue方法都有兩種形式：（1）如果操作失敗則拋出異常，（2）如果操作失敗，則返回特殊值（null或false，具體取決於操作），接口的常規結構如下表所示。</p><div class=pgc-img><img alt=吃透Java集合系列二：Collection與其子接口 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/691aeb05fb314dfa98f57c29c5694b6b><p class=pgc-img-caption></p></div><pre>/** * Queue是在處理之前保存元素的集合。除了基本的Collection操作外，Queue還提供額外的插入、刪除和檢查操作 * 每個Queue方法都有兩種形式：（1）如果操作失敗則拋出異常， * （2）如果操作失敗，則返回特殊值（null或false，具體取決於操作），接口的常規結構如下表所示。 * 插入操作的後一種形式是專為使用有容量限制 Queue實現；在大多數實現中，插入操作不會失敗。 *  * | 	 | 拋出異常 | 返回特殊值 | * |插入 | add(e) | offer(e) | * |刪除 | remove() | poll() | * |檢查 | element() | peek() | *  * 隊列通常（但不一定）以FIFO（先進先出）方式對元素進行排序，優先級隊列除外， * 它們根據元素的值對元素進行排序 — 有關詳細信息，請參閱“對象排序”部分。 * 無論使用什麼排序，隊列的頭部都是通過調用remove或poll移除的元素。 * 在FIFO隊列中，所有新元素都插入隊列的尾部，其他類型的隊列可能使用不同的放置規則， * 每個Queue實現都必須指定其排序屬性。 * * Queue實現可以限制它所擁有的元素數量，這樣的隊列被稱為有界，java.util.concurrent中的某些Queue實現是有界的，但java.util中的實現不是。 * 可不只有拋出unchecked異常添加元素。的offer方法設計時使用的失敗是正常的， * 而不是特殊的情況，例如，固定容量（或“有界”）隊列。的remove()和poll()方法移除並返回隊列的頭部。 * 從隊列中刪除的是隊列的排序策略的函數，它不同於從“實現”到“實現”的功能。的remove()和poll()方法 * 只是他們的行為當隊列為空的不同的remove()方法拋出一個異常，而poll()方法返回null。 * * Queue從Collection繼承的add方法插入一個元素，除非它違反了隊列的容量限制， * 在這種情況下它會拋出IllegalStateException。offer方法，僅用於有界隊列， * 與add不同之處僅在於它通過返回false來表示插入元素失敗。 * * remove和poll方法都移除並返回隊列的頭部，確切地移除哪個元素是隊列的排序策略的函數， * 僅當隊列為空時，remove和poll方法的行為才有所不同，在這些情況下， * remove拋出NoSuchElementException，而poll返回null。 * *element和peek方法返回但不移除隊列的頭部，它們之間的差異與remove和poll的方式完全相同：如果隊列為空，則element拋出NoSuchElementException，而peek返回null。 * 隊列實現通常不允許插入null元素，為實現Queue而進行了改進的LinkedList實現是一個例外， * 由於歷史原因，它允許null元素，但是你應該避免利用它，因為null被poll和peek方法用作特殊的返回值。 *隊列實現通常不定義equals和hashCode方法的基於元素的版本，而是從Object繼承基於標識的版本。 * Queue接口不定義阻塞隊列方法，這在併發編程中很常見，這些等待元素出現或空間可用的方法在java.util.concurrent.BlockingQueue接口中定義，該接口擴展了Queue。 * */public interface Queue&lt;E&gt; extends Collection&lt;E&gt; { /** * 將指定的元素插入到此隊列中，如果不違反容量限制立即執行此操作  * 成功後返回true，如果當前沒有可用空間，則拋出IllegalStateException。 */ boolean add(E e); /** * 如果在不違反容量限制的情況下立即執行，則將指定的元素插入到此隊列中。  * 當使用容量限制隊列時，此方法通常優於add(E) ，這可能無法僅通過拋出異常來插入元素。  * 成功返回true，失敗返回false */ boolean offer(E e); /** * 檢索並刪除此隊列的頭。 此方法與poll不同之處在於，如果此隊列為空，它將拋出異常。 */ E remove(); /** * 檢索並刪除此隊列的頭，如果此隊列為空，則返回 null 。 */ E poll(); /** * 檢索，但不刪除，這個隊列的頭。 此方法與peek的不同之處在於，如果此隊列為空，它將拋出異常。 */ E element(); /** * 檢索但不刪除此隊列的頭部，如果此隊列為空，則返回 null 。 */ E peek();}</pre><p><strong>Queue接口特點：</strong></p><ul><li>先進先出的數據結構，即從容器的一端放入對象，從另一端取出，並且對象放入容器的順序與取出的順序是相同的。</li><li>雖然Queue接口繼承Collection接口，但是Queue接口中的方法都是獨立的，在創建具有Queue功能的實現時，不需要使用Collection方法。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>Collection</a></li><li><a>吃透</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6ca1002.html alt=Java中Collection集合ArrayList和HashSet的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6ca1002.html title=Java中Collection集合ArrayList和HashSet的使用>Java中Collection集合ArrayList和HashSet的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html alt=Java集合-Collection class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html title=Java集合-Collection>Java集合-Collection</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd963681.html alt="Java集合類根接口：Collection 和 Map的深入瞭解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e6b0b352d7b44345afe8b4d5ec473a7b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd963681.html title="Java集合類根接口：Collection 和 Map的深入瞭解">Java集合類根接口：Collection 和 Map的深入瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7b89313.html alt=十年程序員總結：Java之集合Collection總覽 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ff7018c5f0c247fe9e1065846beba6f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7b89313.html title=十年程序員總結：Java之集合Collection總覽>十年程序員總結：Java之集合Collection總覽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a352c48.html alt=必須要知道：Java中的Collection重要知識點，為你簡明梳理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1521010146662fb7b5e0210 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a352c48.html title=必須要知道：Java中的Collection重要知識點，為你簡明梳理>必須要知道：Java中的Collection重要知識點，為你簡明梳理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>