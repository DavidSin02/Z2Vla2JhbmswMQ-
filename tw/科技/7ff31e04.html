<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>二叉樹遍歷算法總結：前序中序後序遍歷 | 极客快訊</title><meta property="og:title" content="二叉樹遍歷算法總結：前序中序後序遍歷 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a8aa9cd302a048e994e735a4fade4288"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff31e04.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff31e04.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7ff31e04.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff31e04.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff31e04.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7ff31e04.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7ff31e04.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff31e04.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="二叉樹遍歷算法總結：前序中序後序遍歷"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7ff31e04.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>二叉樹遍歷算法總結：前序中序後序遍歷</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=二叉樹遍歷算法總結：前序中序後序遍歷 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a8aa9cd302a048e994e735a4fade4288><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>前言</h1><p>二叉樹遍歷是非常經典的算法題，也是二叉樹的一道基礎算法題。</p><p>但是在平常的筆試面試中，其出現的頻率其實並不是特別的高，我推測是這種題目相對來說比較基礎，算是一個基礎知識點。</p><p>比如劍指offer中出現的後序遍歷題目，是給出一個數字序列，讓你判斷是不是平衡二叉樹後序遍歷序列，這樣出題的難度比直接讓你寫後序遍歷難很多。</p><p>但是，二叉樹遍歷容易嗎？在遞歸方法下，前中後序遍歷都是一個思路，理解起來也比較容易。</p><p><strong>但是隻是用迭代的話，二叉樹遍歷其實是有難度的！</strong>，這也是為什麼LeetCode會在這三題題目的下方寫出進階: 遞歸算法很簡單，你可以通過迭代算法完成嗎？這句話了。</p><p><strong>本文的主要內容如下：</strong></p><ul><li><strong>題目定義</strong>： 上篇：二叉樹前序、中序、後序遍歷 下篇：層序遍歷、其他遍歷相關題型</li><li><strong>解題思路</strong>：遞歸 + 迭代+ <strong>莫里斯Morris遍歷</strong></li><li><strong>解題代碼</strong>：Java + Python</li></ul><p><strong>注1</strong>：本文中的解題思路會盡量的全面，但是解題方法千變萬化，有很多奇技淫巧我不會去介紹，大家有興趣可以自行擴展學習。</p><p><strong>注2</strong>：本文中的代碼會盡量簡單，易懂，並不會去追求極致的寫法（比如：在一行內完成，使用各種非正式的庫等）。</p><h1 class=pgc-h-arrow-right>正文</h1><h2 class=pgc-h-arrow-right>二叉樹的定義</h2><p>最多有兩棵子樹的樹被稱為二叉樹</p><div class=pgc-img><img alt=二叉樹遍歷算法總結：前序中序後序遍歷 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/819c19c7debc4ccfa22843e29d93e0c8><p class=pgc-img-caption></p></div><p>二叉樹下還有很多種特殊的二叉樹，下方簡單介紹幾種常用的。</p><h3 class=pgc-h-arrow-right>滿二叉樹</h3><p>二叉樹中所有非葉子結點的度都是2，且葉子結點都在同一層次上</p><div class=pgc-img><img alt=二叉樹遍歷算法總結：前序中序後序遍歷 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/773582c3f4e74d63b4ae64eda010732a><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>完全二叉樹（可以不滿）</h3><p>如果一個二叉樹與滿二叉樹前m個節點的結構相同，這樣的二叉樹被稱為完全二叉樹。也就是說，如果把滿二叉樹從右至左、從下往上刪除一些節點，剩餘的結構就構成完全二叉樹。</p><div class=pgc-img><img alt=二叉樹遍歷算法總結：前序中序後序遍歷 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/11c3fde96c0f406aa6846fef705ed28b><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>二叉搜索樹</h3><p>二叉查找樹（BinarySearch Tree，也叫二叉搜索樹，或稱二叉排序樹Binary Sort Tree）或者是一棵空樹，或者是具有下列性質的二叉樹：</p><ul><li>若它的左子樹不空，則左子樹上所有結點的值均小於它的根結點的值；</li><li>若它的右子樹不空，則右子樹上所有結點的值均大於它的根結點的值；</li><li>它的左、右子樹也分別為二叉排序樹</li></ul><div class=pgc-img><img alt=二叉樹遍歷算法總結：前序中序後序遍歷 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9feca859aa4e44378a30500ac55fb159><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>二叉樹前中後序遍歷</h2><h3 class=pgc-h-arrow-right>遍歷方法</h3><p>前序遍歷：根結點 ---> 左子樹 ---> 右子樹</p><p>中序遍歷：左子樹---> 根結點 ---> 右子樹</p><p>後序遍歷：左子樹 ---> 右子樹 ---> 根結點</p><h3 class=pgc-h-arrow-right>題目介紹</h3><h4 class=pgc-h-arrow-right>前序遍歷</h4><p>LeetCode題目地址：</p><p>https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</p><pre><code>輸入: [1,null,2,3]     1    \     2    /   3 輸出: [1,2,3]</code></pre><h4 class=pgc-h-arrow-right>中序遍歷</h4><p>LeetCode題目地址：</p><p>https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</p><pre><code>輸入: [1,null,2,3]   1    \     2    /   3輸出: [1,3,2]</code></pre><h4 class=pgc-h-arrow-right>後序遍歷</h4><p>LeetCode題目地址：</p><p>https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</p><pre><code>輸入: [1,null,2,3]     1    \     2    /   3 輸出: [3,2,1]</code></pre><h3 class=pgc-h-arrow-right>解題思路詳解與代碼實現</h3><p>二叉樹的前中後序遍歷，主要就是兩種思路，一種是遞歸，一種是迭代。</p><p>如果看到這裡還沒有感覺，不用擔心，先直接往下看，第一個代碼（前序遍歷的遞歸思路）會幫助你提升感覺。</p><h4 class=pgc-h-arrow-right>遞歸思路</h4><p>遞歸思路是最容易理解的思路，並且前中後序遍歷都相同。</p><p>比如前序遍歷，在遞歸的函數裡，先往結果數組裡加入根節點，然後加入根節點的左節點，然後加入根節點的右節點。最後所有遞歸的函數運行完畢，結果集就已經完成了。</p><p>中序和後序的思路相同，就不再贅述了。</p><h5 class=pgc-h-arrow-right>前序遍歷</h5><p>Java：</p><pre><code>class Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {            List&lt;Integer&gt; result = new ArrayList&lt;&gt;();            if (root == null) {                return result;            }            preorder(root, result);            return result;        }    private static List&lt;Integer&gt; preorder(TreeNode root, List&lt;Integer&gt; result) {        if (root != null) {            result.add(root.val);            preorder(root.left, result);            preorder(root.right, result);        }        return result;    }}</code></pre><p>Python：</p><pre><code>class Solution(object):    def _preorderTraversal(self, root, result):        if root:            result.append(root.val)            self._preorderTraversal(root.left, result)            self._preorderTraversal(root.right, result)    def preorderTraversal(self, root):        """        :type root: TreeNode        :rtype: List[int]        """        if root == None:            return []        result = []        self._preorderTraversal(root, result)        return result</code></pre><h5 class=pgc-h-arrow-right>中序遍歷</h5><p>Java：</p><pre><code>class Solution {    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (root == null) {            return result;        }        result = inorder(root, result);        return result;    }    private static List&lt;Integer&gt; inorder(TreeNode root, List&lt;Integer&gt; result) {        if (root != null) {            inorder(root.left, result);            result.add(root.val);            inorder(root.right, result);        }        return result;    }}</code></pre><p>Python：</p><pre><code>class Solution(object):    def generate(self, root, result):        if root:            self.inorder(root.left, list)            result.append(root.val)            self.inorder(root.right, list)    def inorderTraversal(self, root):        """        :type root: TreeNode        :rtype: List[int]        """        if not root:            return []        result = []        self.generate(root, result)        return result</code></pre><h5 class=pgc-h-arrow-right>後序遍歷</h5><p>Java：</p><pre><code>class Solution {    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (root == null) {            return result;        }        result = postorder(root, result);        return result;    }    private static List&lt;Integer&gt; postorder(TreeNode root, List&lt;Integer&gt; result) {        if (root != null) {            postorder(root.left, result);            postorder(root.right, result);            result.add(root.val);        }        return result;    }}</code></pre><p>Python：</p><pre><code>class Solution(object):    def _postorderTraversal(self, root, result):        if root:            self._postorderTraversal(root.left, result)            self._postorderTraversal(root.right, result)            result.append(root.val)    def postorderTraversal(self, root):        """        :type root: TreeNode        :rtype: List[int]        """        if root == None:            return []        result = []        self._postorderTraversal(root, result)        return result</code></pre><h4 class=pgc-h-arrow-right>迭代思路</h4><h5 class=pgc-h-arrow-right>前序遍歷</h5><p>我們需要一個棧來完成遍歷。</p><pre><code>1.根節點入棧2.取出節點，值加入結果，然後先加右，後加左。3.重複2</code></pre><p>這樣就得到了 根節點——左子樹——右子樹 的遍歷結果集。</p><p>Java：</p><blockquote><p>來自官方題解</p></blockquote><pre><code>LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();    if (root == null) {      return output;    }    stack.add(root);    while (!stack.isEmpty()) {      TreeNode node = stack.pollLast();      output.add(node.val);      if (node.right != null) {        stack.add(node.right);      }      if (node.left != null) {        stack.add(node.left);      }    }    return output;  }</code></pre><p>Python：</p><pre><code>class Solution(object):    def preorderTraversal(self, root):        """        :type root: TreeNode        :rtype: List[int]        """        ret = []        stack = [root]        while stack:            node = stack.pop()            if node:                ret.append(node.val)                if node.right:                    stack.append(node.right)                if node.left:                    stack.append(node.left)        return ret</code></pre><h5 class=pgc-h-arrow-right>中序遍歷</h5><p>還是使用一個棧來解決問題。</p><p>步驟如下：</p><pre><code>                    　1　　　　　　　　　　/　  \　　　　　　　　   2　　  3　　　　　　     /   \　 /   \　　　　　　　  4     5  6    7</code></pre><ol start=1><li>我們將根節點1入棧，如果有左孩子，依次入棧，那麼入棧順序為：1，2，4。由於4的左子樹為空，停止入棧，此時棧為{1，2，4}。</li><li>此時將4出棧，並遍歷4，由於4也沒有右孩子，那麼根據中序遍歷的規則，我們顯然應該繼續遍歷4的父親2，情況是這樣。所以我們繼續將2出棧並遍歷2，2存在右孩子，將5入棧，此時棧為{1，5}。</li><li>5沒有孩子，則將5出棧並遍歷5，這也符合中序遍歷的規則。此時棧為{1}。</li><li>1有右孩子，則將1出棧並遍歷1，然後將右孩子3入棧，並繼續以上三個步驟即可。</li></ol><p>棧的變化過程：{1}->{1,2}->{1,2,4}->{1,2}->{1}->{1,5}->{1}->{}->{3}->{3,6}->{3}->{}->{7}->{}。</p><p><strong>總結：從根節點遍歷，先放入所有有左孩子的節點直到沒有，然後出棧，出棧的時候就將出棧的數字放入結果集，然後看其有沒有右孩子，有的話右孩子入棧。</strong></p><p>Java：</p><blockquote><p>官方題解</p></blockquote><pre><code>public class Solution {    public List &lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode curr = root;        while (curr != null || !stack.isEmpty()) {            while (curr != null) {                stack.push(curr);                curr = curr.left;            }            curr = stack.pop();            res.add(curr.val);            curr = curr.right;        }        return res;    }}</code></pre><p>Python：</p><pre><code>class Solution:    # @param root, a tree node    # @return a list of integers    def inorderTraversal(self, root):        result = []        stack = []        while root or stack:            if root:                stack.append(root)                root = root.left            else:                root = stack.pop()                result.append(root.val)                root = root.right        return result</code></pre><h5 class=pgc-h-arrow-right>後序遍歷</h5><p>將數組輸出為右子樹-左子樹-根節點。<strong>最後，再將數組倒序輸出</strong>，形成後序遍歷。這樣代碼並不用很繁瑣，也能做完迭代。</p><p>是不是似曾相識，沒錯，<strong>和前序遍歷的迭代幾乎一樣</strong>，僅僅是先放右節點再放左節點變成了先放左節點再放右節點，然後倒序輸出。</p><p>Java：</p><pre><code>class Solution {  public List&lt;Integer&gt; postorderTraversal(TreeNode root) {    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; output = new LinkedList&lt;&gt;();    if (root == null) {      return output;    }    stack.add(root);    while (!stack.isEmpty()) {      TreeNode node = stack.pollLast();      output.addFirst(node.val);      if (node.left != null) {        stack.add(node.left);      }      if (node.right != null) {        stack.add(node.right);      }    }    return output;  }}</code></pre><p>Python：</p><pre><code>class Solution(object):    def postorderTraversal(self, root):        """        :type root: TreeNode        :rtype: List[int]        """        if root is None:            return []        ret = []        stack = [root]        while stack:            node = stack.pop()            if node:                ret.append(node.val)                if node.left:                    stack.append(node.left)                if node.right:                    stack.append(node.right)        return ret[::-1]</code></pre><p>所以迭代方式，前後序是非常類似的，中序遍歷可能需要單獨理解下。</p><h4 class=pgc-h-arrow-right>莫里斯遍歷</h4><blockquote><p>二叉樹常規的遍歷方法是用遞歸來實現的，這種方法一般都需要O(n)的空間複雜度和O(n)的時間複雜度。而Morris方法實現的是O(1)的空間複雜度和O(n)的時間複雜度。</p><p>我們知道，遍歷二叉樹時，最大的難點在於，遍歷到子節點的時候怎樣重新返回到父節點（假設節點中沒有指向父節點的p指針），由於不能用棧作為輔助空間。(不然就是普通迭代方法)。</p></blockquote><p>為了解決這個問題，Morris方法用到了<strong>線索二叉樹</strong>（threaded binary tree）的概念。在Morris方法中不需要為每個節點額外分配指針指向其前驅（predecessor）和後繼節點（successor），只需要利用葉子節點中的<strong>左右空指針指向某種順序遍歷下的前驅節點或後繼節點就可以了</strong>。</p><p><strong>聽不懂沒關係，下面使用中序遍歷作為例子來理解莫里斯遍歷到底是什麼意思，例子來自LeetCode官方題解：</strong></p><h5 class=pgc-h-arrow-right>中序遍歷</h5><pre><code>Step 1: 將當前節點current初始化為根節點Step 2: While current不為空，若current沒有左子節點   a. 將current添加到輸出   b. 進入右子樹，亦即, current = current.right否則   a. 在current的左子樹中，令current成為最右側節點的右子節點   b. 進入左子樹，亦即，current = current.left</code></pre><pre><code>      1    /   \   2     3  / \   / 4   5 6</code></pre><p>首先，1 是根節點，所以將 current 初始化為 1。1 有左子節點 2，current 的左子樹是</p><pre><code>     2    / \   4   5</code></pre><p>在此左子樹中最右側的節點是 5，於是將 current(1) 作為 5 的右子節點。令 current = cuurent.left (current = 2)。 現在二叉樹的形狀為:</p><pre><code> 2/ \4   5    \     1      \       3      /     6</code></pre><p>對於 current(2)，其左子節點為4，我們可以繼續上述過程</p><pre><code>4 \  2   \    5     \      1       \        3       /      6</code></pre><p>Java：</p><pre><code>class Solution {    public List &lt; Integer &gt; inorderTraversal(TreeNode root) {        List &lt; Integer &gt; res = new ArrayList &lt; &gt; ();        TreeNode curr = root;        TreeNode pre;        while (curr != null) {            if (curr.left == null) {                res.add(curr.val);                curr = curr.right; // move to next right node            } else { // has a left subtree                pre = curr.left;                while (pre.right != null) { // find rightmost                    pre = pre.right;                }                pre.right = curr; // put cur after the pre node                TreeNode temp = curr; // store cur node                curr = curr.left; // move cur to the top of the new tree                temp.left = null; // original cur left be null, avoid infinite loops            }        }        return res;    }}</code></pre><h5 class=pgc-h-arrow-right>前序遍歷</h5><p>理解了中序遍歷，前序和後序遍歷相對來說也就更容易理解了。所以前序和後序貼了思路，代碼我也沒自己寫後submit，在這裡就不放了。</p><blockquote><p>算法的思路是從當前節點向下訪問先序遍歷的前驅節點，每個前驅節點都恰好被訪問兩次。</p><p>首先從當前節點開始，向左孩子走一步然後沿著右孩子一直向下訪問，直到到達一個葉子節點（當前節點的中序遍歷前驅節點），所以我們更新輸出並建立一條偽邊 predecessor.right = root 更新這個前驅的下一個點。如果我們第二次訪問到前驅節點，由於已經指向了當前節點，我們移除偽邊並移動到下一個頂點。</p></blockquote><h5 class=pgc-h-arrow-right>後序遍歷</h5><blockquote><p>後續遍歷稍顯複雜，需要建立一個臨時節點dump，令其左孩子是root。並且還需要一個子過程，就是倒序輸出某兩個節點之間路徑上的各個節點。</p><p>步驟：</p><p>當前節點設置為臨時節點dump。</p><p>如果當前節點的左孩子為空，則將其右孩子作為當前節點。</p><p>如果當前節點的左孩子不為空，在當前節點的左子樹中找到當前節點在中序遍歷下的前驅節點。</p><p>a) 如果前驅節點的右孩子為空，將它的右孩子設置為當前節點。當前節點更新為當前節點的左孩子。</p><p>b) 如果前驅節點的右孩子為當前節點，將它的右孩子重新設為空。倒序輸出從當前節點的左孩子到該前驅節點這條路徑上的所有節點。當前節點更新為當前節點的右孩子。</p><p>重複以上1、2直到當前節點為空。</p></blockquote><h2 class=pgc-h-arrow-right>參考</h2><ul><li>https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/</li><li>https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html</li><li>https://blog.csdn.net/softwarex4/article/details/95986102</li></ul><h1 class=pgc-h-arrow-right>關注我</h1><p>我是一名後端開發工程師。</p><p>主要關注後端開發，數據安全，爬蟲，物聯網，邊緣計算等方向，歡迎交流。</p><h3 class=pgc-h-arrow-right>各大平臺都可以找到我</h3><ul><li><strong>微信公眾號：後端技術漫談</strong></li><li>Github：@qqxx6661</li><li>CSDN：@Rude3knife</li><li>知乎：@後端技術漫談</li><li>簡書：@蠻三刀把刀</li><li>掘金：@蠻三刀把刀</li></ul><h3 class=pgc-h-arrow-right>原創博客主要內容</h3><ul><li>後端開發相關技術文章</li><li>Java面試知識點複習全手冊</li><li>設計模式/數據結構</li><li>LeetCode/劍指offer 算法題解析</li><li>SpringBoot/SpringCloud菜鳥入門實戰系列</li><li>爬蟲相關技術文章</li><li>逸聞趣事/好書分享/個人生活</li></ul><h3 class=pgc-h-arrow-right>個人公眾號：後端技術漫談</h3><div class=pgc-img><img alt=二叉樹遍歷算法總結：前序中序後序遍歷 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/134c82878780419bbf42187cec96a268><p class=pgc-img-caption></p></div><p>公眾號：後端技術漫談.jpg</p><p><strong>如果文章對你有幫助，不妨收藏，投幣，轉發，在看起來~</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>前序</a></li><li><a>樹遍歷</a></li><li><a>總結</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/579c4939.html alt=詳解二叉樹遍歷（前序、中序、後序、層次遍歷、深度、廣度優先） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bcda136bf4a447e396c35b52dbc9a128 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/579c4939.html title=詳解二叉樹遍歷（前序、中序、後序、層次遍歷、深度、廣度優先）>詳解二叉樹遍歷（前序、中序、後序、層次遍歷、深度、廣度優先）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html alt=從域名到網站，只需要四步！服務器網站搭建流程總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7c1999b5072844f6ac01ba234e4d4ee0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html title=從域名到網站，只需要四步！服務器網站搭建流程總結>從域名到網站，只需要四步！服務器網站搭建流程總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html alt=住宅工程各區域的淨高要求，總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/072079da-ec32-43b6-9dff-93cc7beb2bc3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html title=住宅工程各區域的淨高要求，總結>住宅工程各區域的淨高要求，總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html alt=住宅工程各區域的淨高要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/27a44170db2040adab26236e40605b1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html title=住宅工程各區域的淨高要求，總結！>住宅工程各區域的淨高要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html alt=住宅工程各類淨高的規範要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cff80b0991246f69fb67d91590b1d95 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html title=住宅工程各類淨高的規範要求，總結！>住宅工程各類淨高的規範要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html alt=初三主要化學方程式按元素歸類總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fcca062886ed4b9db272cb3cb66710e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html title=初三主要化學方程式按元素歸類總結>初三主要化學方程式按元素歸類總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html alt=按照元素分類總結的高中化學方程式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/568b4c62f05c406c86ba3a1a3f1536f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html title=按照元素分類總結的高中化學方程式>按照元素分類總結的高中化學方程式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d1995c0.html alt=丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/164632567d364099b1944122af1964e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d1995c0.html title=丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級>丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96e7d436.html alt="這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96e7d436.html title="這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏">這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02f4a700.html alt=牛人總結的開關電源電路圖，必須收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rw0LHkF478R1Ah style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02f4a700.html title=牛人總結的開關電源電路圖，必須收藏>牛人總結的開關電源電路圖，必須收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2dce1f09.html alt=高考地理知識點總結―地球的自轉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0453497a2cd041369b4075543c4d3795 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2dce1f09.html title=高考地理知識點總結―地球的自轉>高考地理知識點總結―地球的自轉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/73ba27bb.html alt=老股民總結的賣出技巧實戰圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/7575000bb7b8e57fa260 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/73ba27bb.html title=老股民總結的賣出技巧實戰圖解>老股民總結的賣出技巧實戰圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1010679e.html alt=總結的美國衰落的七大教訓 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b9caa688de534bc88f75c9e5d45e81cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1010679e.html title=總結的美國衰落的七大教訓>總結的美國衰落的七大教訓</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a276d5cd.html alt="高中數學 數列求和方法總結（全面系統的方法整理 值得收藏）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15325317153316605d7448a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a276d5cd.html title="高中數學 數列求和方法總結（全面系統的方法整理 值得收藏）">高中數學 數列求和方法總結（全面系統的方法整理 值得收藏）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>