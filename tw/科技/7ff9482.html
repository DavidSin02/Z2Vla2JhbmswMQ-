<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入淺出 JS 異步處理技術方案 | 极客快訊</title><meta property="og:title" content="深入淺出 JS 異步處理技術方案 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1537855085053bb78880a11"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff9482.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff9482.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7ff9482.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff9482.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff9482.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7ff9482.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7ff9482.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7ff9482.html><meta property="article:published_time" content="2020-10-29T20:59:18+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:18+08:00"><meta name=Keywords content><meta name=description content="深入淺出 JS 異步處理技術方案"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/7ff9482.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入淺出 JS 異步處理技術方案</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>為什麼要異步 “當我們在星巴克買咖啡時，假設有 100 個人在排隊，也許咖啡的下單隻要 10 秒，但是咖啡的製作到客人領取咖啡要 1000 秒。如果在同步的場景下，第一個客人下單到領取完咖啡要 1010 秒才能輪到下一個客人，這在效率（某些場景）上來說會比較低下。 如果我們異步處理這個流程，客人下單 10 秒拿到憑證，客人就可以去做別的事情，並且 10 秒後下一個客人可以繼續下單，並不阻礙流程。反而可以通過憑證，讓客人拿到自己的咖啡，也許時間上並不是第一個下單的客人先拿到。</p><div class=pgc-img><img alt="深入淺出 JS 異步處理技術方案" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1537855085053bb78880a11><p class=pgc-img-caption></p></div><p>在網頁的世界裡也是同樣的道理，不妨我們看看在執行 JS 代碼的主線程裡，如果遇到了 AJAX 請求，用戶事件等，如果不採用異步的方案，你會一直等待，等待第一個耗時的處理完成才能接上下一個 JS 代碼的執行，於是界面就卡住了。 也許有人會想，既然大家都說現在網頁上性能損耗最大的屬於 DOM 節點的操作，把這些搞成異步，行不行？其實這會帶來一個不確定性問題：既 “成功” 的狀態到底誰先來的問題。 可以想象一下，如果我們在操作 DOM，既給節點添加內容，也給節點刪除，那麼到底以誰為基準呢？考慮到複雜性，也就可見一斑了。 Event loop 雖然異步與 event loop 沒有太直接的關係，準確的來講 event loop 只是實現異步的一種機制。（瞭解為主） 還是以上面咖啡館為例子，假定場景還是 100 人，這 100 人除了下單是與咖啡本身有關聯之外，其餘的時間，比如看書，玩遊戲的等可以視為自己的執行邏輯。 如果用 event loop 來給它做一個簡單的畫像，那麼它就像：在與咖啡店店員溝通下單視為主執行棧，咖啡的製作可以視為一個異步任務，添加到一個任務隊列裡，一直等帶 100 個人都下單完成，然後開始讀取任務隊列中的異步任務，事件名就是下單憑證，如果有對應的 handler，那麼就執行叫對應的客人來領取咖啡。 這個過程，是循環不斷的。假設沒有客人來下單的時候，也就是店員處於空閒時間（可能自己去搞點別的）。 傳統的 Callback 假定一個 asyncFetchDataSource 函數用於獲取遠程數據源，可能有 20 秒。 function asyncFetchDataSource(cb){ (… 獲取數據 , function(response){ typeof cb === 'function' && cb(response) }) } 這種形式的 callback 可以適用於簡單場景，如果這裡有一個更復雜的場景，比如獲取完數據源之後，依據 id，獲取到某個數據，在這某個數據中再依據 id 來更新某個列表，可以遇見的能看到代碼變成了： asyncFetchDataSource('',function(data_a){ const { id_a } = data_a asyncFetchDataSource( id_a,function(data_b){ const { id_b } = data_b asyncFetchDataSource(id, function(data_c){ }) }) }) 如果有極端情況出現，這裡的 callback 就會變成無極限了。 Thunk 函數 這是一種 “傳名調用” 的策略，表現的形式就是將參數放入一個臨時函數，然後再將這個臨時函數傳入函數體內。 function asyncFetchDataSource(url){ return function(callback){ fetch(url, callback) } } const dataSource = asyncFetchDataSource('https://github.com/icepy'); dataSource(function(data){ }) Promise Promise 正是想來處理這樣的異步編程，如果我們用 Promise 該如何處理一段 Ajax？ function fetch(){ return new Promise(function(resolve,reject){ $.ajax({ url: 'xxx', success:function(data){ resolve(data) }, error:function(error){ reject(error) } }) }) } fetch().then(function(data){ }).catch(function(error){}) Promise 聲明週期： 進行中（pending） 已經完成（fulfilled） 拒絕（rejected） 如同上面 Ajax 的例子，我們可以很好的包裝一個函數，讓 fetch 函數返回一個 Promise 對象。 在 Promise 構造函數裡，可以傳入一個 callback，並且在這裡完成主體邏輯的編寫。唯一需要注意的是：Promise 對象只能通過 resolve 和 reject 函數來返回，在外部使用 then 或 catch 來獲取。 如果你直接拋出一個錯誤（throw new Error(‘error’)），catch 也是可以正確的捕獲到的。 Promise 其他的方法 Promise.all（當所有在可迭代參數中的 promises 已完成，或者第一個傳遞的 promise（指 reject）失敗時，返回 promise。） var p1 = Promise.resolve(3); var p2 = 1337; var p3 = new Promise((resolve, reject) => { setTimeout(resolve, 100, "foo"); }); Promise.all([p1, p2, p3]).then(values => { console.log(values); // [3, 1337, "foo"] }); Promise.race（返回一個新的 promise，參數 iterable 中只要有一個 promise 對象 “ 完成（resolve）” 或 “ 失敗（reject）”，新的 promise 就會立刻 “ 完成（resolve）” 或者 “ 失敗（reject）”，並獲得之前那個 promise 對象的返回值或者錯誤原因。） var p1 = new Promise(function(resolve, reject) { setTimeout(resolve, 500, "one"); }); var p2 = new Promise(function(resolve, reject) { setTimeout(resolve, 100, "two"); }); Promise.race([p1, p2]).then(function(value) { console.log(value); // "two" // 兩個都完成，但 p2 更快 }); 有趣的是如果你使用 ES6 的 class，你是可以去派生 Promise 的。 class MePromise extends Promise{ // 處理 ... } Generator Generator 可以輔助我們完成很多複雜的任務，而這些基礎知識，又與 iterator 息息相關。 舉一個很簡單的例子，相信有很多朋友，應該使用過 co 這個異步編程的庫，它就是用 Generator 來實現，當然它的設計會比例子要複雜的多，我們先來看一個 co 簡單的用法： import co from 'co' co(function* () { var result = yield Promise.resolve(true); return result; }).then(function (value) { console.log(value); }, function (err) { console.error(err.stack); }); 相應的，我們來實現一個簡化的版本： function co(task){ let _task = task() let resl = _task.next(); while(!resl.done){ console.log(resl); resl = _task.next(resl.value); } } function sayName(){ return { name: 'icepy' } } function assign *(f){ console.log(f) let g = yield sayName() return Object.assign(g,{age:f}); } co(function *(){ let info = yield *assign(18) console.log(info) }) 雖然，這個例子中，還不能很好的看出來 “異步” 的場景，但是它很好的描述了 Generator 的使用方式。 從最開始的定義中，已經和大家說明了，Generator 最終返回的依然是一個迭代器對象，有了這個迭代器對象，當你在處理某些場景時，你可以通過 yield 來控制，流程的走向。 通過 co 函數，我們可以看出，先來執行 next 方法，然後通過一個 while 循環，來判斷 done 是否為 true，如果為 true 則代表整個迭代過程的結束，於是，這裡就可以退出循環了。在 Generator 中的返回值，可以通過給 next 方法傳遞參數的方式來實現，也就是遇上第一個 yield 的返回值。 有邏輯，自然會存在錯誤，在 Generator 捕獲錯誤的時機與執行 throw 方法的順序有關係，一個小例子： let hu = function *(){ let g = yield 1; try { let j = yield 2; } catch(e){ console.log(e) } return 34 } let _it = hu(); console.log(_it.next()) console.log(_it.next()) console.log(_it.throw(new Error('hu error'))) 當我能捕獲到錯誤的時機是允許完第二次的 yield，這個時候就可以 try 了。 async await async function createNewDoc() { let response = await db.post({}); // post a new doc return await db.get(response.id); // find by id }</p><div class=pgc-img><img alt="深入淺出 JS 異步處理技術方案" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1537855578677698bb57627><p class=pgc-img-caption></p></div><p>https://tc39.github.io/ecmascript-asyncawait/ 根據規範規定一個 asnyc 函數總是要返回一個 Promise，從代碼直觀上來說，雖然簡潔了，但是 async await 並未萬能，它有很大的侷限性，比如： 因為是順序執行，假設有三個請求，那麼這裡並沒有很好的利用到異步帶來的止損（再包裝一個 Promise.all）； 如果要捕獲異常，需要去包 try catch； 缺少控制流程，比如 progress（進度）pause，resume 等週期性的方法； 沒有打斷的功能。 主流的異步處理方案 我喜歡用 co，而且社區使用也很廣泛，https://github.com/tj/co。 co(function* () { var result = yield Promise.resolve(true); return result; }).then(function (value) { console.log(value); }, function (err) { console.error(err.stack); }); babel polyfill 支持，在瀏覽器環境中使用異步解決方案 如果你想使用全的 polyfiil，直接 npm install —save babel-polyfill，然後在 webpack 裡進行配置即可。 module.exports = { entry: ["babel-polyfill", "./app/js"] }; 當然由於我目前的開發基於的瀏覽器都比較高，所以我一般是挑選其中的： https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime https://github.com/facebook/regenerator/tree/master/packages/regenerator-transform 如果你要使用 async await 配置上 http://babeljs.io/docs/plugins/transform-async-to-generator/ 即可 Node.js 環境中使用異步解決方案 由於本人的 node 使用的 LTS 已經是 8.9.3 版本了，所以大部分情況下已經不再使用 babel 去進行轉換，而是直接使用 co 這樣的庫。 當然 co 也不是萬能，一定要根據業務場景，與其他異步處理的方式，配合中使用。 總結 相信未來的 JS 編程，只會越來越簡單，不要拘泥於語法，語言上的特性，不妨多看一看 “外面的世界”。</p><div class=pgc-img><img alt="深入淺出 JS 異步處理技術方案" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1537855056524d925160122><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="深入淺出 JS 異步處理技術方案" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1537855602353986a356ea6><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>淺出</a></li><li><a>JS</a></li><li><a>異步</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e18864df.html alt=深入淺出西門子PLC連載一：西門子S7-300/400通信功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d2fa4bebce394c979e42408cab824fdb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e18864df.html title=深入淺出西門子PLC連載一：西門子S7-300/400通信功能>深入淺出西門子PLC連載一：西門子S7-300/400通信功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86bb40ab.html alt=深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RFHu4Sf9eDhDDd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86bb40ab.html title=深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸>深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html alt=三相異步電動機絕緣處理的目的及方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c439a15bdf64f1f975914c96a2c66e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html title=三相異步電動機絕緣處理的目的及方法>三相異步電動機絕緣處理的目的及方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html alt=異步電機典型結構簡述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349080656472f5dd62512 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html title=異步電機典型結構簡述>異步電機典型結構簡述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html alt=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/56930005e593537411b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html title=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹>繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html alt=單相異步電機如何轉起來？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/66c6000099c8d7f13f98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html title=單相異步電機如何轉起來？>單相異步電機如何轉起來？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1ce2eed.html alt=JS中如何獲取url中的某個參數的值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1ce2eed.html title=JS中如何獲取url中的某個參數的值>JS中如何獲取url中的某個參數的值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3cb692f.html alt=JS獲取瀏覽器地址欄的多個參數值的任意值實例代碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3cb692f.html title=JS獲取瀏覽器地址欄的多個參數值的任意值實例代碼>JS獲取瀏覽器地址欄的多個參數值的任意值實例代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b87553dc.html alt=LevelDB深入淺出之整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/125e826e651c48c3911abad6c8d076c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b87553dc.html title=LevelDB深入淺出之整體架構>LevelDB深入淺出之整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51fefa66.html alt=迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/28ca13300b9f4d55bd5af3f9156f8874 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51fefa66.html title=迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章>迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37add9f2.html alt=深入淺出人工智能前沿技術—機器視覺檢測，看清人類智慧工業 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f5ea93dc2cb2482296f29e57b56ea652 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37add9f2.html title=深入淺出人工智能前沿技術—機器視覺檢測，看清人類智慧工業>深入淺出人工智能前沿技術—機器視覺檢測，看清人類智慧工業</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d88578e6.html alt="「集合系列」- 深入淺出分析Collection中的List接口" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/592bdfb766d94ddcb9357373d4b2df2f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d88578e6.html title="「集合系列」- 深入淺出分析Collection中的List接口">「集合系列」- 深入淺出分析Collection中的List接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adf558e7.html alt="查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/60bc9160b4bd4c319ed419be29146606 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adf558e7.html title="查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼">查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html alt=深入淺出排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c898a3bab26542c2965d2bc5bebf9bd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html title=深入淺出排序算法>深入淺出排序算法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>