<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>第五章 棧和隊列 | 极客快訊</title><meta property="og:title" content="第五章 棧和隊列 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/f539b17725974b3fb257d8e003e0edbc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="第五章 棧和隊列"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/80b0adb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>第五章 棧和隊列</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>第五章 棧和隊列</strong></h1><h1 class=pgc-h-arrow-right><strong>5.1 棧</strong></h1><h1 class=pgc-h-arrow-right><strong>5.1.2 棧概述</strong></h1><p style=text-align:start><strong>棧（stack）又名堆棧</strong>，它是一種運算受限的線性表。在計算機中棧被定義為一個特殊的容器。其限制是僅允許在表的一端進行插入和刪除操作。這一端被稱為棧頂，相對地，把另一端稱為棧底。向一個棧插入新元素又稱作進棧、入棧或壓棧（push），它是把新元素存放到棧頂元素的上面，使之成為新的棧頂元素；也可以將已經壓入到棧中的元素彈出，即從一個棧刪除元素又稱作出棧或退棧（pop），它是把棧頂元素刪除掉，使其相鄰的元素成為新的棧頂元素。</p><p style=text-align:start><strong>【棧結構圖】</strong></p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 棧和隊列" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f539b17725974b3fb257d8e003e0edbc><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>棧按照<strong>先進後出</strong> <strong>（First In Last Out，FILO）</strong>的原則存儲數據，先進入的數據被壓入棧底，最後的數據在棧頂，需要讀數據的時候從棧頂開始彈出數據（最後一個數據被第一個讀出來）。棧具有記憶作用，對棧的插入與刪除操作中，不需要改變棧底指針。</p><p style=text-align:start>棧作為一種數據結構，是一種只能在一端進行插入和刪除操作的特殊線性表。允許進行插入和刪除操作的一端稱為棧頂(top)，另一端為棧底(bottom)；棧底固定，而棧頂浮動；棧中元素個數為零時稱為空棧。插入一般稱為進棧（push），刪除則稱為退棧（pop）。棧也稱為後進先出表。</p><p style=text-align:start>計算機系統中，棧是一個具有以上屬性的動態內存區域。程序可以將數據壓入棧中，也可以將數據從棧頂彈出。壓棧操作使得棧增長變大，而彈出操作使棧減短縮小。</p><h1 class=pgc-h-arrow-right><strong>5.1.2 棧的表示和實現</strong></h1><p style=text-align:start><strong>進棧（PUSH）算法：</strong></p><p style=text-align:start>① 若TOP≥n時，則給出溢出信息，作出錯處理（進棧前首先檢查棧是否已滿，滿則溢出；不滿則作②）；</p><p style=text-align:start>② 置TOP=TOP+1（棧指針加1，指向進棧地址）；</p><p style=text-align:start>③ S(TOP)=X，結束（X為新進棧的元素）；</p><p style=text-align:start><strong>退棧（POP）算法：</strong></p><p style=text-align:start>① 若TOP≤0，則給出下溢信息，作出錯處理（退棧前先檢查是否已為空棧， 空則下溢；不空則作②）；</p><p style=text-align:start>② X=S(TOP)，（退棧後的元素賦給X）；</p><p style=text-align:start>③ TOP=TOP-1，結束（棧指針減1，指向棧頂）。</p><p style=text-align:start><strong>定義stack的簡單代碼：</strong></p><p style=text-align:start>stack&lt;int> myStack;</p><p style=text-align:start>入棧：myStack.push(x);</p><p style=text-align:start>出棧：myStack.pop();</p><p style=text-align:start>棧頂元素：myStack.top();</p><p style=text-align:start>判斷棧的大小： myStack.size();</p><p style=text-align:start>判斷棧是否為空：myStack.empty();</p><p style=text-align:start><strong>【程序實現</strong>】</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define N 10typedef struct{    int data[N];    int top;} SqStack;    //順序棧類型別名​//初始化棧SqStack* initStack(){    SqStack* s = (SqStack * )malloc(sizeof(SqStack));    s-&gt;top = -1;    return s;}​//取棧頂元素int getTop(SqStack * s, int* e){    if (s-&gt;top == -1) {        return -1;    }    *e = s-&gt;data[s-&gt;top];    return *e;}​//進棧int Push(SqStack * s, int e){    if (s-&gt;top == N - 1) {        return -1;    }    s-&gt;top ++;    s-&gt;data[s-&gt;top] = e;    return 1;}​//出棧int Pop(SqStack * s, int* e){    if (s-&gt;top == -1) {        return -1;    }    *e = s-&gt;data[s-&gt;top];    s-&gt;top--;    return 1;}​//銷燬棧void destroyStack(SqStack * s){    free(s);}​//測試棧的初始化、入棧、出棧、獲取棧頂元素等功能int main(){    printf("初始化棧...\n");    SqStack* s = initStack();        printf("入棧中...\n");    Push(s,1);    Push(s,2);    Push(s,3);    printf("入棧完成...\n");        printf("獲取棧頂元素:\n");    int y;    getTop(s, &amp;y);    printf("y: %d\n",y);        printf("出棧:\n");    int x;    Pop(s,&amp;x);    printf("x:%d\n",x);    Pop(s,&amp;x);    printf("x:%d\n",x);    Pop(s,&amp;x);    printf("x:%d\n",x);        printf("銷燬棧...\n");    destroyStack(s);    return 0;}</code></pre><h1 class=pgc-h-arrow-right><strong>5.2 隊列</strong></h1><h1 class=pgc-h-arrow-right><strong>5.2.1 隊列概述</strong></h1><p style=text-align:start>與棧相反，<strong>隊列（queue）</strong>是一種<strong>先進先出</strong>（first in first out，縮寫為FIFO）的線性表。它只允許在表的一端進行插入元素，而在另一端刪除元素。</p><p style=text-align:start>在隊列中，允許插入的一端叫做<strong>隊尾</strong>（rear），允許刪除的一端則稱為<strong>隊頭</strong>（front）。</p><p style=text-align:start>隊列擁有兩種表示和實現方式：</p><p style=text-align:start>1、隊列的鏈式表示和實現--<strong>鏈隊列</strong></p><p style=text-align:start>2、隊列的順序表示和實現--循<strong>環隊列</strong></p><h1 class=pgc-h-arrow-right><strong>5.2.2 鏈隊列—隊列的鏈式表示和實現</strong></h1><p style=text-align:start>用鏈表表示的隊列簡稱為<strong>鏈隊列</strong>。一個鏈隊列需要兩個分別指示隊頭和隊尾的指針（分別稱為頭指針和尾指針）才能唯一確定。為操作方便，給鏈隊列添加一個頭結點，並令頭指針指向頭結點。由此，空的鏈隊列的判斷條件為頭指針和尾指針均指向頭結點。</p><p style=text-align:start><strong>【鏈隊列結構圖】</strong></p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 棧和隊列" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/493048f1ec0040b6a7d737259835ef92><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong>【鏈隊列操作示意圖】</strong>　</p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 棧和隊列" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5dada01c953745beb8802bfd29bf9716><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong>【程序實現】</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;​#define OVERFLOW -2#define ERROR 0#define OK 1​typedef int Status;​typedef int QElemType;​typedef struct QNode {    QElemType data;    struct QNode *next;    }QNode,*QueuePtr;​typedef struct {    QueuePtr front; //隊頭指針    QueuePtr rear; //隊尾指針}LinkQueue;​/***********    初始化隊列   ***********/Status InitQueue(LinkQueue * Q){    Q-&gt;front=Q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));        if (!Q-&gt;front)        exit(OVERFLOW);        Q-&gt;front-&gt;next=NULL;        return OK;}​/***********    入隊列    ***********/Status EnQueue(LinkQueue *Q, QElemType e){    //插入元素e為Q的新的隊尾元素    QueuePtr p;        p = (QueuePtr)malloc(sizeof(QNode));        if(!p)        exit(OVERFLOW);        p-&gt;data=e;    p-&gt;next=NULL;        Q-&gt;rear-&gt;next=p;    Q-&gt;rear=p;        return OK;}​/***********    出隊列    ***********/Status DeQueue(LinkQueue *Q, QElemType *e){    //若隊列不空,則刪除Q的頭元素，用e返回其值，並返回OK。    QueuePtr p;        if(Q-&gt;front==Q-&gt;rear)        exit(ERROR);        p=Q-&gt;front-&gt;next;        *e=p-&gt;data; // 一定是*e        Q-&gt;front-&gt;next=p-&gt;next;        if(Q-&gt;rear==p)        Q-&gt;rear=Q-&gt;front;        free(p);        return OK;}​/***********    銷燬隊列Q   ***********/Status DestroyQueue(LinkQueue * Q){    while (Q-&gt;front) {        Q-&gt;rear = Q-&gt;front-&gt;next;                free(Q-&gt;front);                Q-&gt;front = Q-&gt;rear;    }        return OK;}​int main(){    LinkQueue *Q;    QElemType e;        /***********    初始化隊列   ***********/    InitQueue(Q);        printf("請輸入5個整數：");    for(int i=0; i&lt;5; i++)    {        /***********    入隊列    ***********/        scanf("%d",&amp;e);        EnQueue(Q,e);    }        printf("輸出結果為：\n");    while (Q-&gt;front!=Q-&gt;rear)    {        /***********    出隊列    ***********/        DeQueue(Q,&amp;e);        printf("%d,",e);    }    printf("\n");        /***********    銷燬隊列Q   ***********/    DestroyQueue(Q);        return 0;}</code></pre><h1 class=pgc-h-arrow-right><strong>5.2.3 循環隊列—隊列的順序表示和實現</strong></h1><p style=text-align:start>為充分利用向量空間，克服"<strong>假溢出</strong>"現象的方法是：將向量空間想象為一個首尾相接的圓環，並稱這種向量為循環向量。存儲在其中的隊列稱為循環隊列（Circular Queue）。</p><p style=text-align:start>循環隊列就是將隊列存儲空間的最後一個位置繞到第一個位置，形成邏輯上的環狀空間，供隊列循環使用。在循環隊列結構中，當存儲空間的最後一個位置已被使用而再要進入隊運算時，只需要存儲空間的第一個位置空閒，便可將元素加入到第一個位置，即將存儲空間的第一個位置作為隊尾。循環隊列可以更簡單防止偽溢出的發生，但隊列大小是固定的。</p><p style=text-align:start>在循環隊列中，當隊列為空時，有front=rear，而當所有隊列空間全佔滿時，也有front=rear。為了區別這兩種情況，規定循環隊列最多只能有MaxSize-1個隊列元素，當循環隊列中只剩下一個空存儲單元時，隊列就已經滿了。因此，隊列判空的條件時front=rear，而隊列判滿的條件時front=（rear+1）%MaxSize。</p><p style=text-align:start><strong>【循環隊列結構圖】</strong></p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 棧和隊列" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/21aa970c665842f09a0be14455708013><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>【循環隊列操作示意圖】**</p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 棧和隊列" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a25292c4f4f54d6580e28911b10af459><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>【程序實現】**</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;​#define MAXQSIZE 100#define OK 1#define ERROR 0#define OVERFLOW -1#define False 0#define True 1​typedef int Status;typedef int QElemType;​typedef struct{    QElemType *base; //存儲空間的基地址    int front;      //頭指針    int rear;       //尾指針}SqQueue;​//循環隊列的初始化Status InitQueue(SqQueue &amp;q){    q.base = new QElemType[MAXQSIZE]; //為隊列分配一個最大容量為 MAXQSIZE 的數組空間        if(!q.base)        exit(OVERFLOW); //存儲分配失敗        q.front = q.rear = 0; //頭指針和尾指針置為零，隊列為空        return OK;}​//求循環隊列的長度int QueueLength(SqQueue q){    return (q.rear - q.front + MAXQSIZE) % MAXQSIZE; //返回Q的元素個數，即隊列長度}​//入隊Status EnQueue(SqQueue &amp;q, QElemType e)//插入元素 e 為Q的新的隊尾元素{    if((q.rear + 1) % MAXQSIZE == q.front) //尾指針在循環意義上加1後等於頭指針，表明隊滿        return ERROR;        q.base[q.rear] = e; //新元素插入隊尾        q.rear = (q.rear+1) % MAXQSIZE; //隊尾指針加1        return OK;}​//出隊Status DeQueue(SqQueue &amp;q, QElemType &amp;e)//刪除 q 的隊頭元素，用 e 返回其值{    if(q.front==q.rear)        return ERROR; //隊空        e = q.base[q.front]; //保存隊頭元素        q.front = (q.front+1) % MAXQSIZE;//隊頭指針加1        return OK;}​//取隊頭元素QElemType GetHead(SqQueue q)//返回  的隊頭元素，不修改隊頭指針{    if(q.front != q.rear) //隊列非空        return q.base[q.front];//返回隊頭元素的值，隊頭指針不變        return ERROR;}​//隊列判滿bool FullQueue(SqQueue &amp;q){    if(q.rear == (q.front+1) % MAXQSIZE)        return 1;    else        return 0;}​//隊列判空bool EmptyQueue(SqQueue &amp;q){    if(q.front==q.rear)        return 1;    else        return 0;}​int main(){    QElemType e;    SqQueue q;        InitQueue(q);        int count = 0;        printf("請輸入要入隊的元素個數:\n");    scanf("%d", &amp;count);        for (int i = 0; i &lt; count; i ++) {        printf("請輸入第%d個數: ", i+1);        int iNum = 0;        scanf("%d", &amp;iNum);        EnQueue(q, iNum);    }        printf("隊列長度： %d\n", QueueLength(q));        printf("獲取隊列頭元素: %d\n", GetHead(q));        printf("輸出結果為：\n");    while (q.front != q.rear)    {        /***********    出隊列    ***********/        DeQueue(q, e);        printf("%d,",e);    }        printf("\n");        if(FullQueue(q))        printf("隊列已滿\n");        if(EmptyQueue(q))        printf("隊列為空\n");        return 0;}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>隊列</a></li><li><a>第五章</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea462aa3.html alt="第五章 跳轉" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a2eec5c3db3c4779b719e60d5ec1a0c2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea462aa3.html title="第五章 跳轉">第五章 跳轉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0155a40.html alt=消息隊列及常見消息隊列介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c780000da0d4ae15990 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0155a40.html title=消息隊列及常見消息隊列介紹>消息隊列及常見消息隊列介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a7ee8a5.html alt=消息隊列的使用之RabbitMq的選型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15404744718207c9b0a18d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a7ee8a5.html title=消息隊列的使用之RabbitMq的選型>消息隊列的使用之RabbitMq的選型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc00e68.html alt=淺談消息隊列及常見的消息中間件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99348ece13f64ce49f498270b88717c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc00e68.html title=淺談消息隊列及常見的消息中間件>淺談消息隊列及常見的消息中間件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26710420.html alt=消息隊列MQ面試專題（rabbitmq） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/S86eRASG4qdgs4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26710420.html title=消息隊列MQ面試專題（rabbitmq）>消息隊列MQ面試專題（rabbitmq）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a97678b1.html alt=消息隊列之常見消息隊列分析彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b13ad5e5ff6b478797dcb7efcb7d6331 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a97678b1.html title=消息隊列之常見消息隊列分析彙總>消息隊列之常見消息隊列分析彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd67ae90.html alt=淺談消息隊列用途及常見的消息中間件的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6b0acb1aef6b4fe792b1fbd6a18d26f4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd67ae90.html title=淺談消息隊列用途及常見的消息中間件的區別>淺談消息隊列用途及常見的消息中間件的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c57ab4b0.html alt=第五章:函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/2466a268-feac-46a2-9bfa-ea0a5723a32f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c57ab4b0.html title=第五章:函數>第五章:函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/637a16cf.html alt="泔河塬人家  第五章" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/637a16cf.html title="泔河塬人家  第五章">泔河塬人家 第五章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/199264e1.html alt=使用環形隊列解決串口打印阻塞問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6595586e75984d5e9968f9ca0cab6a2e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/199264e1.html title=使用環形隊列解決串口打印阻塞問題>使用環形隊列解決串口打印阻塞問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac006a7.html alt=如何打造可以無限擴展的分佈式消息隊列？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/47f42465ac1542a6a73d611fa70090a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac006a7.html title=如何打造可以無限擴展的分佈式消息隊列？>如何打造可以無限擴展的分佈式消息隊列？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a5a3083.html alt=豆腐塊？軍姿？隊列指揮？管他什麼東西，警校生照樣盤他！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bf0e7b78a3344611b00df1a45eb2ce93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a5a3083.html title=豆腐塊？軍姿？隊列指揮？管他什麼東西，警校生照樣盤他！>豆腐塊？軍姿？隊列指揮？管他什麼東西，警校生照樣盤他！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/046fd15.html alt=數據結構（揹包、隊列和棧） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/203693f33a664988aa20d9ff7690e62c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/046fd15.html title=數據結構（揹包、隊列和棧）>數據結構（揹包、隊列和棧）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67a95f5.html alt=結構與算法：隊列和棧結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c05974b203134951bb9284740a76fea2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67a95f5.html title=結構與算法：隊列和棧結構>結構與算法：隊列和棧結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e592b29.html alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd9e3b969124f1297a6bc7627747e80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e592b29.html title="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看">高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>