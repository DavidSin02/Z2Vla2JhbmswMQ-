<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>到底什麼是面向對象編程( OOP )？ | 极客快訊</title><meta property="og:title" content="到底什麼是面向對象編程( OOP )？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/5462f49b28c446b4b9214dae06156a7c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/810c487e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><meta property="article:published_time" content="2020-10-29T21:10:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:38+08:00"><meta name=Keywords content><meta name=description content="到底什麼是面向對象編程( OOP )？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/810c487e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>到底什麼是面向對象編程( OOP )？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote>全文共<strong>9402</strong>字，預計學習時長<strong>19</strong>分鐘</blockquote><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5462f49b28c446b4b9214dae06156a7c><p class=pgc-img-caption></p></div><p class=ql-align-center>圖片來源：https://unsplash.com/@marcelheil</p><p class=ql-align-justify><br></p><p class=ql-align-justify>Python是數據科學中一種十分常用的編程語言。對一些人來講，它的語言靈活、可讀性強，對另一些人來講，它簡單易上手，對大多數人來講，是由於它的多面性。</p><p>我們將Python稱為多面語言，因為它允許使用四種不同的編碼規範進行編碼：功能性、命令性、面向對象和麵向過程。這些編碼風格被正式稱為編程範例（https://en.wikipedia.org/wiki/Programming_paradigm），代表了一種根據語言特性對語言進行分類的方法。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/34a8ec01e0b74009ab04bd754420cce6><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>本文將對面向對象編程( OOP )（https://en.wikipedia.org/wiki/Object-oriented_programming）進行研究。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>什麼是面向對象編程( OOP )？</strong></p><p>OOP是一種基於對象概念的編程範式。在計算機科學中，“對象”一詞可以指代不同概念，但基本上，它是標識符所引用的內存值（https://en.wikipedia.org/wiki/Object_(computer_science)）。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>在OOP的執行環境中，對象指狀態（變量）和行為（方法）的組合。面向對象方法的目標是創建可重複使用的軟件，以下四個特徵使其更易維護：封裝、抽象、繼承和多態。</p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/172bba3a7cb74a6d9e740a08e0ae1d49><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>還可以進一步區分面嚮對象語言，例如，基於類和基於原型。</p><p class=ql-align-justify>在基於類的OOP中，對象是類的實例。類是關於如何定義某些內容的藍圖，但它不會提供內容本身——它只是提供結構。</p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>學習策略</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>有許多方法可以用來學習和練習OOP，因必須選擇其中一種，所以筆者決定採用莎士比亞的《羅密歐與朱麗葉》的故事線，製作一個簡單的基於文本的遊戲。具體步驟如下：</p><p class=ql-align-justify>1. 寫下故事</p><p class=ql-align-justify>2. 指出問題</p><p class=ql-align-justify>3. 確定實體——這些是類別</p><p class=ql-align-justify>4. 創建實體層次結構</p><p class=ql-align-justify>5. 確定實體的功能</p><p class=ql-align-justify>6. 編寫測試</p><p class=ql-align-justify>7. 檢查測試是否成功——因未編寫過任何代碼，所以最初會出現錯誤！</p><p class=ql-align-justify>8. 編寫代碼</p><p class=ql-align-justify>9. 重複！重構！精煉！</p><p class=ql-align-justify>這個過程不是一成不變的，也不是註定要被它牽著鼻子走。這一系列步驟幫助筆者開始了編程之路。面向對象不僅僅是一種編程範式，還是一種解決問題的方法，儘管它並非沒有非議，但在構建複雜系統時卻是一個很好的選擇。</p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>兔子洞（The Rabbit Hole）</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>請注意步驟6：編寫測試。現在，這個不是筆者最初的步驟。筆者正計劃給各類別編碼。但在研究OOP時，筆者發現了測試驅動開發( TDD )這一概念。</p><p class=ql-align-justify>TDD是一種編程實踐，開始於程序每個功能所進行的測試的設計和開發。這樣，在開始編寫代碼之前，你就不得不考慮其規範、要求或設計。換句話說，在編寫任何代碼之前，都要編寫代碼來測試代碼。</p><p class=ql-align-justify>是不是感到迷惑不解？筆者也是。但做這個練習是完全值得的。</p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>測試驅動開發和單元測試</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>TDD的過程非常簡單：</p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2364032a9f4c41f6bdcd0219cd691ae4><p class=pgc-img-caption></p></div><p class=ql-align-center>圖片來自Kanchan Kulkarni的TDD教程（https://www.guru99.com/test-driven-development.html）</p><p class=ql-align-justify><br></p><p class=ql-align-justify>1. 寫出測試</p><p class=ql-align-justify>2. 運行測試</p><p class=ql-align-justify>3. 寫下代碼</p><p class=ql-align-justify>4. 運行測試</p><p class=ql-align-justify>5. 重構代碼</p><p class=ql-align-justify>6. 重複步驟</p><p>在這個例子中，筆者使用單元測試（http://softwaretestingfundamentals.com/unit-testing/）進行TDD。單元測試是軟件測試的第一級，其目的是驗證程序中的每個單元是否按設計執行。可以使用不同的框架來執行單元測試。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>人們對於TDD持有兩種不同觀點。就我個人的經歷而言，TDD的優點如下：</p><p class=ql-align-justify>· 在毫無方向地開始輸入代碼之前，TDD迫使人們必須考慮要解決的問題。</p><p class=ql-align-justify>· 在基於類別的OOP的特殊情況下，它能幫助理解每個類別內容。如職責是什麼？必須知道什麼？——目標是低耦合和高內聚性時，這變得更加息息相關。</p><p class=ql-align-justify>· 儘管一開始它可能會減慢速度，但從長遠來看，它通過最小化調試時間來節省時間。</p><p class=ql-align-justify>· 它鼓勵更好的設計，使代碼更容易維護、減少冗餘（不寫重複代碼！），並在需要時安全地重構。</p><p class=ql-align-justify>· 它是一個動態文檔——只需查看測試，就能理解每個單元應該做什麼，如此一來，代碼就能自證其明。</p><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>羅密歐與朱麗葉——代碼與測試</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>在考慮了遊戲的故事性之後，筆者決定採用兩個不同的故事線：經典橋段和另類橋段。第一個是人們熟知的羅密歐與朱麗葉，第二個故事對我們來說則較為陌生。</p><p class=ql-align-justify>故事安排（創建不同類別的引用）如下：</p><p class=ql-align-justify>· 場景：蒙面舞會、陽臺、決鬥，安排、藥劑師、卡普萊特墓和另類結局。該“場景”有兩個主要職責，即為玩家描述場景，以及以是非問題提示玩家從而獲取信息輸入。</p><p>· 地圖：地圖就像一個有限狀態機（https://en.wikipedia.org/wiki/Deterministic_finite_automaton）。它具有有限的狀態（場景）、轉換函數（從一個場景移動到另一個場景）和開始狀態（第一個場景）。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>· 故事線：定義兩個唯一常量值。</p><p class=ql-align-justify>從場景的定義中可以看到，所有場景都有相同的職責，只有它們的內容發生了變化（場景的描述和提示）。這就是為什麼要利用繼承的概念。這個概念允許定義一個類，該類別從另一個類中繼承了所有方法和屬性；在這種情況下，不重複寫代碼至關重要。</p><pre>class Storyline(Enum): CLASSIC = "classic" ALTERNATIVE = "alternative"</pre><p class=ql-align-justify><br></p><p>對於故事線這一類別，筆者使用了Python’s enumeration type（https://docs.python.org/3/library/enum.html）或enum。在文檔中，它們的定義為“一組綁定到唯一常量值的符號名（成員）。在枚舉中，成員可以按標識進行比較，枚舉本身可以循環訪問。”</p><p class=ql-align-justify>接下來，我們有Sence類和MockSence類。測試代碼中有兩個值得注意的特徵：1.使用MockMap類；2.創建TestScene類以測試Scene類。在單元測試階段，將創建一個Test類為每個類編寫測試。</p><pre>Class Scene(object): a_map = None  def __init__(self, a_map): self.a_map = a_map def get_message(self): return """ This scene is yet to be initialized """ def get_prompt(self): return """ This scene is yet to be initialized """  def enter(self): self.print_description() self.prompt_user()  def print_description(self): print(dedent(self.get_message())) def prompt_user(self): input_from_user = input(self.get_prompt()).lower() if input_from_user == "yes": self.a_map.advance_scene(Storyline.CLASSIC) elif input_from_user == "no": self.a_map.advance_scene(Storyline.ALTERNATIVE) self.a_map.play()</pre><p class=ql-align-justify><br></p><pre>import unittestfrom unittest.mock import patch, mock_openimport sysimport iofrom romeo_and_juliet import *class MockMap(Map): storyline = None play_executed = False def advance_scene(self, a_storyline): self.storyline = a_storyline def play(self): self.play_executed = True class TestScene(unittest.TestCase): def test_print_description(self): a_scene = Scene(Map()) # Capturing the standard output as a test harness. capturedOutput = io.StringIO() sys.stdout = capturedOutput a_scene.print_description() self.assertEqual(capturedOutput.getvalue(), dedent(""" This scene is yet to be initialized\n """)) # Releasing standard output. sys.stdout = sys.__stdout__  def test_prompt_user(self): a_map = MockMap() a_scene = Scene(a_map) with patch("builtins.input", return_value = "yes"): a_scene.prompt_user() self.assertEqual(a_map.storyline, Storyline.CLASSIC) with patch("builtins.input", return_value = "no"): a_scene.prompt_user() self.assertEqual(a_map.storyline, Storyline.ALTERNATIVE) self.assertTrue(a_map.play_executed)</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>最後，來看看Map類和TestMap類。和往常一樣，我們會創建一個模擬測試，但在本例中，是為Scene類創建一個MockScene類。</p><pre>class Map(object): scenes = None current_scene = None def __init__(self): self.scenes = { "the_masked_ball": TheMaskedBall(self), "the_balcony": TheBalcony(self), "the_duel": TheDuel(self), "the_arrangement": TheArrangement(self), "the_apothecary": TheApothecary(self), "the_capulet_tomb": TheCapuletTomb(self), "the_alternative_ending": TheAlternativeEnding(self) } self.current_scene = self.scenes["the_masked_ball"] def get_current_scene(self): return self.current_scene def play(self): self.current_scene.enter() def advance_scene(self, storyline): if storyline == Storyline.CLASSIC: if self.current_scene == self.scenes["the_masked_ball"]: self.current_scene = self.scenes["the_balcony"] elif self.current_scene == self.scenes["the_balcony"]: self.current_scene = self.scenes["the_duel"] elif self.current_scene == self.scenes["the_duel"]: self.current_scene = self.scenes["the_arrangement"] elif self.current_scene == self.scenes["the_arrangement"]: self.current_scene = self.scenes["the_apothecary"] elif self.current_scene == self.scenes["the_apothecary"]: self.current_scene = self.scenes["the_capulet_tomb"] elif self.current_scene == self.scenes["the_capulet_tomb"]: raise Exception if storyline == Storyline.ALTERNATIVE: if self.current_scene == self.scenes["the_masked_ball"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_balcony"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_duel"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_arrangement"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_apothecary"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_alternative_ending"]: raise Exception</pre><p class=ql-align-justify><br></p><pre>class MockScene(Scene): was_entered = False def enter(self): self.was_entered = Trueclass TestMap(unittest.TestCase): def test_play(self): a_map = Map() mock_scene = MockScene(a_map) a_map.current_scene = mock_scene a_map.play() self.assertTrue(mock_scene.was_entered)  def test_initial_state(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall)  def test_advance_scene_classic(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheArrangement) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheApothecary) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheCapuletTomb) with self.assertRaises(Exception): a_map.advance_scene(Storyline.CLASSIC) def test_advance_scene_alternative_one(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE)  def test_advance_scene_alternative_two(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE) def test_advance_scene_alternative_three(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE) def test_advance_scene_alternative_four(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheArrangement) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE)  def test_advance_scene_alternative_five(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheArrangement) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheApothecary) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE)</pre><div class=pgc-img><img alt="到底什麼是面向對象編程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e57cd3b4f104f2e86c45a61d3f68fbb><p class=pgc-img-caption></p></div><p class=ql-align-center><strong>留言 點贊 關注</strong></p><p class=ql-align-center><strong>我們一起分享AI學習與發展的乾貨</strong></p><p>編譯組：餘書敏、張璐瑤</p><p>相關鏈接：</p><p>https://towardsdatascience.com/object-oriented-programming-and-the-magic-of-test-driven-development-d377acae85fa</p><p>如需轉載，請後臺留言，遵守轉載規範</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>什麼</a></li><li><a>對象</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html alt=什麼是面向對象的編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/be4dacb2168b48e085eec6c0640bc176 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html title=什麼是面向對象的編程思想>什麼是面向對象的編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html alt=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f2e808d6760462aafc6bfbb0e718954 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html title=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維>你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc3bb81.html alt=SpringAOP-什麼是面向切面編程？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/93af441322d4418ebbb68664166fb2ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc3bb81.html title=SpringAOP-什麼是面向切面編程？>SpringAOP-什麼是面向切面編程？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a3dd46e.html alt=淺談什麼是面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cec16fd5ca3f4d19b4d848f6d373e7fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a3dd46e.html title=淺談什麼是面向切面編程AOP>淺談什麼是面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html alt=FPGA為什麼可編程，這篇文章來告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7abe76ede514e308d57ca293420a430 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html title=FPGA為什麼可編程，這篇文章來告訴你>FPGA為什麼可編程，這篇文章來告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09ffeb76.html alt=揭祕什麼是面向接口編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09ffeb76.html title=揭祕什麼是面向接口編程>揭祕什麼是面向接口編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f618890d.html alt=為什麼我們要面向接口編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/666365bd6f6e40b19810d1f3930abd70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f618890d.html title=為什麼我們要面向接口編程>為什麼我們要面向接口編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b74636e.html alt=程序設計中面向接口編程是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b74636e.html title=程序設計中面向接口編程是什麼>程序設計中面向接口編程是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce55c065.html alt="什麼是測量，測量四要素：測量對象、 計量單位、測量方法、精度" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fe45ef81004446a08ae14557b4727baa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce55c065.html title="什麼是測量，測量四要素：測量對象、 計量單位、測量方法、精度">什麼是測量，測量四要素：測量對象、 計量單位、測量方法、精度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html alt=JAVA：面向對象編程的底層邏輯，深度剖析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f7362955cbfb4eb0bb89b09491c5d9a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html title=JAVA：面向對象編程的底層邏輯，深度剖析>JAVA：面向對象編程的底層邏輯，深度剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html alt=什麼是“面向對象”程序設計-以Python為例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/12f1d2422ce145819ebe4973dcfa2b89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html title=什麼是“面向對象”程序設計-以Python為例>什麼是“面向對象”程序設計-以Python為例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3782027.html alt=漫畫：面向對象編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RSgLiL1LcHkAv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3782027.html title=漫畫：面向對象編程>漫畫：面向對象編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html alt=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532998144998addd88387a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html title=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則>都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html alt=面向對象編程設計的類與對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/86e56bdd947940c4b06129e01f19706a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html title=面向對象編程設計的類與對象>面向對象編程設計的類與對象</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>