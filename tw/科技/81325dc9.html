<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入解析HashiMap那些不為人知的事兒 | 极客快訊</title><meta property="og:title" content="深入解析HashiMap那些不為人知的事兒 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/49faff220ef84a3787f9b9e0836f857c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81325dc9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81325dc9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81325dc9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81325dc9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81325dc9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81325dc9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81325dc9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81325dc9.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="深入解析HashiMap那些不為人知的事兒"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/81325dc9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入解析HashiMap那些不為人知的事兒</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=pgc-h-arrow-right>HashMap</h2><p><strong>概述</strong></p><p>HashMap是在JDK1.2中引入的一種K/V對形式的集合類.</p><p>在底層,HashMap通過<strong>數組和單鏈表</strong>組合的結構形式來存儲數據,數組在這作為一個外部結構,數組中的每個節點被稱做Bucket(桶),而<strong>桶是由在單鏈表構成</strong>,JDK1.8之後<strong>為了解決長鏈表下,查詢和插入效率低下的情況,又引入了紅黑樹的作為桶的實現方式</strong>,</p><p>桶中的各節點是由HashMap定義的Node內部類生成的,是普通的鏈表節點類.</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/49faff220ef84a3787f9b9e0836f857c><p class=pgc-img-caption></p></div><p>注意:<strong>HashMap是線程不安全的,在JDK1.8之前多線程情況下甚至可能會出現環路(後面會講)</strong>,所以多線程狀態下還是要使用ConcurrentHashMap的.</p><p>光從名字上應該也能猜到，HashMap肯定是基於hash算法實現的，這種基於hash實現的map叫做散列表（hash table）。</p><p>散列表中維護了一個數組，數組的每一個元素被稱為一個桶（bucket），當你傳入一個key = "a"進行查詢時，散列表會先把key傳入散列（hash）函數中進行尋址，得到的結果就是數組的下標，然後再通過這個下標訪問數組即可得到相關聯的值。</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/09b9f4c82e0c406c92e819ee23770ffa><p class=pgc-img-caption></p></div><p>我們都知道數組中數據的組織方式是線性的，它會直接分配一串連續的內存地址序列，要找到一個元素只需要根據下標來計算地址的偏移量即可（查找一個元素的起始地址為：數組的起始地址加上下標乘以該元素類型佔用的地址大小）。因此散列表在理想的情況下，各種操作的時間複雜度只有O(1)，這甚至超過了二叉查找樹，雖然理想的情況並不總是滿足的，關於這點之後我們還會提及。</p><h2 class=pgc-h-arrow-right>為什麼是hash？</h2><p>hash算法是一種可以從任何數據中提取出其“指紋”的數據摘要算法，它將任意大小的數據（輸入）映射到一個固定大小的序列（輸出）上，這個序列被稱為hash code、數據摘要或者指紋。比較出名的hash算法有MD5、SHA。</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a69a3afbe2cd4b61915cebe6c9e41f24><p class=pgc-img-caption></p></div><p><br>hash是具有唯一性且不可逆的，唯一性指的是相同的輸入產生的hash code永遠是一樣的，而不可逆也比較容易理解，數據摘要算法並不是壓縮算法，它只是生成了一個該數據的摘要，沒有將數據進行壓縮。壓縮算法一般都是使用一種更節省空間的編碼規則將數據重新編碼，解壓縮只需要按著編碼規則解碼就是了，試想一下，一個幾百MB甚至幾GB的數據生成的hash code都只是一個擁有固定長度的序列，如果再能逆向解壓縮，那麼其他壓縮算法該情何以堪？</p><p>我們上述討論的僅僅是在密碼學中的hash算法，而在散列表中所需要的散列函數是要能夠將key尋址到buckets中的一個位置，散列函數的實現影響到整個散列表的性能。</p><p>一個完美的散列函數要能夠做到均勻地將key分佈到buckets中，每一個key分配到一個bucket，但這是不可能的。雖然hash算法具有唯一性，但同時它還具有重複性，唯一性保證了相同輸入的輸出是一致的，卻沒有保證不同輸入的輸出是不一致的，也就是說，完全有可能兩個不同的key被分配到了同一個bucket（因為它們的hash code可能是相同的），這叫做碰撞衝突。總之，理想很豐滿，現實很骨感，散列函數只能儘可能地減少衝突，沒有辦法完全消除衝突。</p><p>散列函數的實現方法非常多，一個優秀的散列函數要看它能不能將key分佈均勻。首先介紹一種最簡單的方法：除留餘數法，先對key進行hash得到它的hash code，然後再用該hash code對buckets數組的元素數量取餘，得到的結果就是bucket的下標，這種方法簡單高效，也可以當做對集群進行負載均衡的路由算法。</p><pre><code>privateinthash(Key key) {   // &amp; 0x7fffffff 是為了屏蔽符號位，M為bucket數組的長度   return(key.hashCode() &amp; 0x7fffffff) % M;}</code></pre><p>要注意一點，只有整數才能進行取餘運算，如果hash code是一個字符串或別的類型，那麼你需要將它轉換為整數才能使用除留餘數法，不過Java在Object對象中提供了hashCode()函數，該函數返回了一個int值，所以任何你想要放入HashMap的自定義的抽象數據類型，都必須實現該函數和equals()函數，這兩個函數之間也遵守著一種約定：如果a.equals(b) == true，那麼a與b的hashCode()也必須是相同的。</p><p>下面為String類的hashCode()函數，它先遍歷了內部的字符數組，然後在每一次循環中計算hash code（將hash code乘以一個素數並加上當前循環項的字符）：</p><pre><code>/** The value is used for character storage. */privatefinalcharvalue[];/** Cache the hash code for the string */privateinthash; // Default to 0publicinthashCode() {    inth = hash;    if(h == 0&amp;&amp; value.length &gt; 0) {        charval[] = value;        for(inti = 0; i &lt; value.length; i++) {            h = 31* h + val[i];        }        hash = h;    }    returnh;}</code></pre><p>HashMap沒有采用這麼簡單的方法，有一個原因是HashMap中的buckets數組的長度永遠為一個2的冪，而不是一個素數，如果長度為素數，那麼可能會更適合簡單暴力的除留餘數法（當然除留餘數法雖然簡單卻並不是那麼高效的），順便一提，時代的眼淚Hashtable就使用了除留餘數法，它沒有強制約束buckets數組的長度。</p><p>HashMap在內部實現了一個hash()函數，首先要對hashCode()的返回值進行處理：</p><pre><code>staticfinalinthash(Object key) {    inth;    return(key == null) ? 0: (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>該函數將key.hashCode()的低16位和高16位做了個異或運算，其目的是為了擾亂低位的信息以實現減少碰撞衝突。之後還需要把hash()的返回值與table.length - 1做與運算（table為buckets數組），得到的結果即是數組的下標。</p><p>table.length - 1就像是一個低位掩碼（這個設計也優化了擴容操作的性能），它和hash()做與操作時必然會將高位屏蔽（因為一個HashMap不可能有特別大的buckets數組，至少在不斷自動擴容之前是不可能的，所以table.length - 1的大部分高位都為0），只保留低位，看似沒什麼毛病，但這其實暗藏玄機，它會導致總是隻有最低的幾位是有效的，這樣就算你的hashCode()實現得再好也難以避免發生碰撞。這時，hash()函數的價值就體現出來了，它對hash code的低位添加了隨機性並且混合了高位的部分特徵，顯著減少了碰撞衝突的發生。</p><p>HashMap的散列函數具體流程如下圖：</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2af50814e3b143a1998ec7a0c686fcd8><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>解決衝突</h2><p>在上文中我們已經多次提到碰撞衝突，但是散列函數不可能是完美的，key分佈完全均勻的情況是不存在的，所以碰撞衝突總是難以避免。</p><p>那麼發生碰撞衝突時怎麼辦？總不能丟棄數據吧？必須要有一種合理的方法來解決這個問題，HashMap使用了叫做分離鏈接（Separate chaining，也有人翻譯成拉鍊法）的策略來解決衝突。它的主要思想是每個bucket都應當是一個互相獨立的數據結構，當發生衝突時，只需要把數據放入bucket中（因為bucket本身也是一個可以存放數據的數據結構），這樣查詢一個key所消耗的時間為訪問bucket所消耗的時間加上在bucket中查找的時間。</p><p>HashMap的buckets數組其實就是一個鏈表數組，在發生衝突時只需要把Entry（還記得Entry嗎？HashMap的Entry實現就是一個簡單的鏈表節點，它包含了key和value以及hash code）放到鏈表的尾部，如果未發生衝突（位於該下標的bucket為null），那麼就把該Entry做為鏈表的頭部。而且HashMap還使用了Lazy策略，buckets數組只會在第一次調用put()函數時進行初始化，這是一種防止內存浪費的做法，像ArrayList也是Lazy的，它在第一次調用add()時才會初始化內部的數組。</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/51fcd48da12e496da1fb93be95e84acc><p class=pgc-img-caption></p></div><p>不過鏈表雖然實現簡單，但是在查找的效率上只有O(n)，而且我們大部分的操作都是在進行查找，在hashCode()設計的不是非常良好的情況下，碰撞衝突可能會頻繁發生，鏈表也會變得越來越長，這個效率是非常差的。Java 8對其實現了優化，鏈表的節點數量在到達閾值時會轉化為紅黑樹，這樣查找所需的時間就只有O(log n)了，閾值的定義如下：</p><pre><code>/** * The bin count threshold for using a tree rather than list for a * bin.  Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */staticfinalintTREEIFY_THRESHOLD = 8;</code></pre><p>如果在插入Entry時發現一條鏈表超過閾值，就會執行以下的操作，對該鏈表進行樹化；相對的，如果在刪除Entry（或進行擴容）時發現紅黑樹的節點太少（根據閾值UNTREEIFY_THRESHOLD），也會把紅黑樹退化成鏈表。</p><pre><code>/** * 替換指定hash所處位置的鏈表中的所有節點為TreeNode， * 如果buckets數組太小，就進行擴容。 */finalvoidtreeifyBin(Node&lt;K,V&gt;[] tab, inthash) {    intn, index; Node&lt;K,V&gt; e;    // MIN_TREEIFY_CAPACITY = 64，小於該值代表數組中的節點並不是很多    // 所以選擇進行擴容，只有數組長度大於該值時才會進行樹化。    if(tab == null|| (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    elseif((e = tab[index = (n - 1) &amp; hash]) != null) {        TreeNode&lt;K,V&gt; hd = null, tl = null;        // 轉換鏈表節點為樹節點，注意要處理好連接關係        do{            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if(tl == null)                hd = p;            else{                p.prev = tl;                tl.next = p;            }            tl = p;        } while((e = e.next) != null);        if((tab[index] = hd) != null)            hd.treeify(tab); // 從頭部開始構造樹    }}    // 該函數定義在TreeNode中    finalvoidtreeify(Node&lt;K,V&gt;[] tab) {        TreeNode&lt;K,V&gt; root = null;        for(TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) {            next = (TreeNode&lt;K,V&gt;)x.next;            x.left = x.right = null;            if(root == null) { // 初始化root節點                x.parent = null;                x.red = false;                root = x;            }            else{                K k = x.key;                inth = x.hash;                Class&lt;?&gt; kc = null;                for(TreeNode&lt;K,V&gt; p = root;;) {                    intdir, ph;                    K pk = p.key;                    // 確定節點的方向                    if((ph = p.hash) &gt; h)                        dir = -1;                    elseif(ph &lt; h)                        dir = 1;                    // 如果kc == null                    // 並且k沒有實現Comparable接口                    // 或者k與pk是沒有可比較性的（類型不同）                    // 或者k與pk是相等的（返回0也有可能是相等）                    elseif((kc == null&amp;&amp;                              (kc = comparableClassFor(k)) == null) ||                             (dir = compareComparables(kc, k, pk)) == 0)                        dir = tieBreakOrder(k, pk);                    // 確定方向後插入節點，修正紅黑樹的平衡                    TreeNode&lt;K,V&gt; xp = p;                    if((p = (dir &lt;= 0) ? p.left : p.right) == null) {                        x.parent = xp;                        if(dir &lt;= 0)                            xp.left = x;                        else                            xp.right = x;                        root = balanceInsertion(root, x);                        break;                    }                }            }        }        // 確保給定的root是該bucket中的第一個節點        moveRootToFront(tab, root);    }    staticinttieBreakOrder(Object a, Object b) {        intd;        if(a == null|| b == null||            (d = a.getClass().getName().             compareTo(b.getClass().getName())) == 0)            // System.identityHashCode()將調用並返回傳入對象的默認hashCode()            // 也就是說，無論是否重寫了hashCode()，都將調用Object.hashCode()。            // 如果傳入的對象是null，那麼就返回0            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?                 -1: 1);        returnd;    }</code></pre><p>解決碰撞衝突的另一種策略叫做開放尋址法（Open addressing），它與分離鏈接法的思想截然不同。在開放尋址法中，所有Entry都會存儲在buckets數組，一個明顯的區別是，分離鏈接法中的每個bucket都是一個鏈表或其他的數據結構，而開放尋址法中的每個bucket就僅僅只是Entry本身。</p><p>開放尋址法是基於數組中的空位來解決衝突的，它的想法很簡單，與其使用鏈表等數據結構，不如直接在數組中留出空位來當做一個標記，反正都要佔用額外的內存。</p><p>當你查找一個key的時候，首先會從起始位置（通過散列函數計算出的數組索引）開始，不斷檢查當前bucket是否為目標Entry（通過比較key來判斷），如果當前bucket不是目標Entry，那麼就向後查找（查找的間隔取決於實現），直到碰見一個空位（null），這代表你想要找的key不存在。</p><p>如果你想要put一個全新的Entry（Map中沒有這個key存在），依然會從起始位置開始進行查找，如果起始位置不是空的，則代表發生了碰撞衝突，只好不斷向後查找，直到發現一個空位。</p><p>開放尋址法的名字也是來源於此，一個Entry的位置並不是完全由hash值決定的，所以也叫做Closed hashing，相對的，分離鏈接法也被稱為Open hashing或Closed addressing。</p><p>根據向後探測（查找）的算法不同，開放尋址法有多種不同的實現，我們介紹一種最簡單的算法：線性探測法（Linear probing），在發生碰撞時，簡單地將索引加一，如果到達了數組的尾部就折回到數組的頭部，直到找到目標或一個空位。</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b1772297d4554d78ace57e25eb820071><p class=pgc-img-caption></p></div><p>基於線性探測法的查找操作如下：</p><pre><code>privateK[] keys; // 存儲key的數組privateV[] vals; // 存儲值的數組publicV get(K key) {    // m是buckets數組的長度，即keys和vals的長度。    // 當i等於m時，取模運算會得0（折回數組頭部）    for(inti = hash(key); keys[i] != null; i = (i + 1) % m) {        if(keys[i].equals(key))            returnvals[i];    }    returnnull;}</code></pre><p>插入操作稍微麻煩一些，需要在插入之前判斷當前數組的剩餘容量，然後決定是否擴容。數組的剩餘容量越多，代表Entry之間的間隔越大以及越早碰見空位（向後探測的次數就越少），效率自然就會變高。代價就是額外消耗的內存較多，這也是在用空間換取時間。</p><pre><code>publicvoidput(K key, V value) {    // n是Entry的數量，如果n超過了數組長度的一半，就擴容一倍    if(n &gt;= m / 2) resize(2* m);    inti;    for(i = hash(key); keys[i] != null; i = (i + 1) % m) {        if(keys[i].equals(key)) {            vals[i] = value;            return;        }    }    // 沒有找到目標，那麼就插入一對新的Entry    keys[i] = key;    vals[i] = value;    n++;}</code></pre><p>接下來是刪除操作，需要注意一點，我們不能簡單地把目標key所在的位置（keys和vals數組）設置為null，這樣會導致此位置之後的Entry無法被探測到，所以需要將目標右側的所有Entry重新插入到散列表中：</p><pre><code>publicV delete(K key) {    inti = hash(key);    // 先找到目標的索引    while(!key.equals(keys[i])) {        i = (i + 1) % m;    }    V oldValue = vals[i];    // 刪除目標key和value    keys[i] = null;    vals[i] = null;    // 指針移動到下一個索引    i = (i + 1) % m;    while(keys[i] != null) {        // 先刪除然後重新插入        K keyToRehash = keys[i];        V valToRehash = vals[i];        keys[i] = null;        vals[i] = null;        n--;        put(keyToRehash, valToRehash);        i = (i + 1) % m;    }    n--;    // 當前Entry小於等於數組長度的八分之一時，進行縮容    if(n &gt; 0&amp;&amp; n &lt;= m / 8) resize(m / 2);    returnoldValue;}</code></pre><h2 class=pgc-h-arrow-right>動態擴容</h2><p>散列表以數組的形式組織bucket，問題在於數組是靜態分配的，為了保證查找的性能，需要在Entry數量大於一個臨界值時進行擴容，否則就算散列函數的效果再好，也難免產生碰撞。</p><p>所謂擴容，其實就是用一個容量更大（在原容量上乘以二）的數組來替換掉當前的數組，這個過程需要把舊數組中的數據重新hash到新數組，所以擴容也能在一定程度上減緩碰撞。</p><p>HashMap通過負載因子（Load Factor）乘以buckets數組的長度來計算出臨界值，算法：threshold = load_factor * capacity。比如，HashMap的默認初始容量為16（capacity = 16），默認負載因子為0.75（load_factor = 0.75），那麼臨界值就為threshold = 0.75 * 16 = 12，只要Entry的數量大於12，就會觸發擴容操作。</p><p>還可以通過下列的構造函數來自定義負載因子，負載因子越小查找的性能就會越高，但同時額外佔用的內存就會越多，如果沒有特殊需要不建議修改默認值。</p><pre><code>/** * 可以發現構造函數中根本就沒初始化buckets數組。 * （之前說過buckets數組會推遲到第一次調用put()時進行初始化） */publicHashMap(intinitialCapacity, floatloadFactor) {    if(initialCapacity &lt; 0)        thrownewIllegalArgumentException("Illegal initial capacity: "+                                           initialCapacity);    if(initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if(loadFactor &lt;= 0|| Float.isNaN(loadFactor))        thrownewIllegalArgumentException("Illegal load factor: "+                                           loadFactor);    this.loadFactor = loadFactor;    // tableSizeFor()確保initialCapacity必須為一個2的N次方    this.threshold = tableSizeFor(initialCapacity);}</code></pre><p>buckets數組的大小約束對於整個HashMap都至關重要，為了防止傳入一個不是2次冪的整數，必須要有所防範。tableSizeFor()函數會嘗試修正一個整數，並轉換為離該整數最近的2次冪。</p><pre><code>/** * Returns a power of two size for the given target capacity. */staticfinalinttableSizeFor(intcap) {    intn = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return(n &lt; 0) ? 1: (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><p><br></p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9b2c28b1f19e4215a80a1d15d2b2301e><p class=pgc-img-caption></p></div><p>還記得數組索引的計算方法嗎？</p><p>index = (table.length - 1) & hash，這其實是一種優化手段，由於數組的大小永遠是一個2次冪，在擴容之後，一個元素的新索引要麼是在原位置，要麼就是在原位置加上擴容前的容量。這個方法的巧妙之處全在於&運算，之前提到過&運算只會關注n – 1（n = 數組長度）的有效位，當擴容之後，n的有效位相比之前會多增加一位（n會變成之前的二倍，所以確保數組長度永遠是2次冪很重要），然後只需要判斷hash在新增的有效位的位置是0還是1就可以算出新的索引位置，如果是0，那麼索引沒有發生變化，如果是1，索引就為原索引加上擴容前的容量。</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e370a73ca46455288b0604410b07696><p class=pgc-img-caption></p></div><p>這樣在每次擴容時都不用重新計算hash，省去了不少時間，而且新增有效位是0還是1是帶有隨機性的，之前兩個碰撞的Entry又有可能在擴容時再次均勻地散佈開。</p><p>下面是resize()的源碼：</p><pre><code>finalNode&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table; // table就是buckets數組    intoldCap = (oldTab == null) ? 0: oldTab.length;    intoldThr = threshold;    intnewCap, newThr = 0;    // oldCap大於0，進行擴容，設置閾值與新的容量    if(oldCap &gt; 0) {        // 超過最大值不會進行擴容，並且把閾值設置成Interger.MAX_VALUE        if(oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            returnoldTab;        }        // 沒超過最大值，擴容為原來的2倍        // 向左移1位等價於乘2        elseif((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    // oldCap = 0，oldThr大於0，那麼就把閾值做為新容量以進行初始化    // 這種情況發生在用戶調用了帶有參數的構造函數（會對threshold進行初始化）    elseif(oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    // oldCap與oldThr都為0，這種情況發生在用戶調用了無參構造函數    // 採用默認值進行初始化    else{               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    // 如果newThr還沒有被賦值，那麼就根據newCap計算出閾值    if(newThr == 0) {        floatft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({"rawtypes","unchecked"})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])newNode[newCap];    table = newTab;    // 如果oldTab != null，代表這是擴容操作    // 需要將擴容前的數組數據遷移到新數組    if(oldTab != null) {        // 遍歷oldTab的每一個bucket，然後移動到newTab        for(intj = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if((e = oldTab[j]) != null) {                oldTab[j] = null;                // 索引j的bucket只有一個Entry（未發生過碰撞）                // 直接移動到newTab                if(e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                // 如果是一個樹節點（代表已經轉換成紅黑樹了）                // 那麼就將這個節點拆分為lower和upper兩棵樹                // 首先會對這個節點進行遍歷                // 只要當前節點的hash &amp; oldCap == 0就鏈接到lower樹                // 注意這裡是與oldCap進行與運算，而不是oldCap - 1(n - 1)                // oldCap就是擴容後新增有效位的掩碼                // 比如oldCap=16，二進制10000，n-1 = 1111，擴容後的n-1 = 11111                // 只要hash &amp; oldCap == 0，就代表hash的新增有效位為0                // 否則就鏈接到upper樹（新增有效位為1）                // lower會被放入newTab[原索引j]，upper樹會被放到newTab[原索引j + oldCap]                // 如果lower或者upper樹的節點少於閾值，會被退化成鏈表                elseif(e instanceofTreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else{ // preserve order                    // 下面操作的邏輯與分裂樹節點基本一致                    // 只不過split()操作的是TreeNode                    // 而且會將兩條TreeNode鏈表組織成紅黑樹                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do{                        next = e.next;                        if((e.hash &amp; oldCap) == 0) {                            if(loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else{                            if(hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while((e = next) != null);                    if(loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if(hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    returnnewTab;}</code></pre><p>使用HashMap時還需要注意一點，它不會動態地進行縮容，也就是說，你不應該保留一個已經刪除過大量Entry的HashMap（如果不打算繼續添加元素的話），此時它的buckets數組經過多次擴容已經變得非常大了，這會佔用非常多的無用內存，這樣做的好處是不用多次對數組進行擴容或縮容操作。不過一般也不會出現這種情況，如果遇見了，請毫不猶豫地丟掉它，或者把數據轉移到一個新的HashMap。</p><p>添加元素</p><p>我們已經瞭解了HashMap的內部實現與工作原理，它在內部維護了一個數組，每一個key都會經過散列函數得出在數組的索引，如果兩個key的索引相同，那麼就使用分離鏈接法解決碰撞衝突，當Entry的數量大於臨界值時，對數組進行擴容。</p><p>接下來以一個添加元素（put()）的過程為例來梳理一下知識，下圖是put()函數的流程圖：</p><div class=pgc-img><img alt=深入解析HashiMap那些不為人知的事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f29a2b54605140f0905b34022db4d418><p class=pgc-img-caption></p></div><p>然後是源碼：</p><pre><code>public V put(K key, V value) {    returnputVal(hash(key), key, value, false, true);}finalV putVal(inthash, K key, V value, booleanonlyIfAbsent,               booleanevict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; intn, i;    // table == null or table.length == 0    // 第一次調用put()，初始化table    if((tab = table) == null|| (n = tab.length) == 0)        n = (tab = resize()).length;    // 沒有發生碰撞，直接放入到數組    if((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else{        Node&lt;K,V&gt; e; K k;        // 發生碰撞（頭節點就是目標節點）        if(p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null&amp;&amp; key.equals(k))))            e = p;        // 節點為紅黑樹        elseif(p instanceofTreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        // 節點為鏈表        else{            for(intbinCount = 0; ; ++binCount) {                // 未找到目標節點，在鏈表尾部鏈接新節點                if((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if(binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        // 鏈表過長，轉換為紅黑樹                        treeifyBin(tab, hash);                    break;                }                // 找到目標節點，退出循環                if(e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null&amp;&amp; key.equals(k))))                    break;                p = e;            }        }        // 節點已存在，替換value        if(e != null) { // existing mapping for key            V oldValue = e.value;            if(!onlyIfAbsent || oldValue == null)                e.value = value;            // afterNodeXXXXX是提供給LinkedHashMap重寫的函數            // 在HashMap中沒有意義            afterNodeAccess(e);            returnoldValue;        }    }    ++modCount;    // 超過臨界值，進行擴容    if(++size &gt; threshold)        resize();    afterNodeInsertion(evict);    returnnull;}</code></pre><p><strong>喜歡的朋友們點點關注點點贊</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>HashiMap</a></li><li><a>不為</a></li><li><a>人知</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c72848f.html alt=張藝謀不為人知的愛與恨：老謀深算，終得成全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ce82f3c2f18b4ab194a13b7a6476eebd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c72848f.html title=張藝謀不為人知的愛與恨：老謀深算，終得成全>張藝謀不為人知的愛與恨：老謀深算，終得成全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/983469b0.html alt=汽油也有“調和油”，那些不為人知的玄機都在這兒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/37e2000162e3669d33a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/983469b0.html title=汽油也有“調和油”，那些不為人知的玄機都在這兒>汽油也有“調和油”，那些不為人知的玄機都在這兒</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/7f3c6668.html alt=中醫祕傳！不為人知的中醫處方配伍法則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/103c371819a44096b357dc2eaebc9a63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/7f3c6668.html title=中醫祕傳！不為人知的中醫處方配伍法則>中醫祕傳！不為人知的中醫處方配伍法則</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/1e703663.html alt=攤開你的掌心，看看你……不為人知的祕密｜活動招募 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RUUjorbJ1xNtvZ style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/1e703663.html title=攤開你的掌心，看看你……不為人知的祕密｜活動招募>攤開你的掌心，看看你……不為人知的祕密｜活動招募</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/829d35ab.html alt=那些年隱藏在黔北深山中不為人知的神祕採藥人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/798f38f3e3304c62b747e2ca7a5f7f58 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/829d35ab.html title=那些年隱藏在黔北深山中不為人知的神祕採藥人>那些年隱藏在黔北深山中不為人知的神祕採藥人</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/9d9e3299.html alt=關於水晶一些不為人知的事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8cbeb940a7a64934ad9a2bedea24fb0f style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/9d9e3299.html title=關於水晶一些不為人知的事>關於水晶一些不為人知的事</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/9fa4f298.html alt=航空航天不為人知的故事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/163a91f73bd14817aa88453b08edb238 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/9fa4f298.html title=航空航天不為人知的故事>航空航天不為人知的故事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/71527c6d.html alt=揭祕反賭人士不為人知的祕密，“反賭”還是“中飽私囊”？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d754857d3e4a4cc1831a73cb99a1b779 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/71527c6d.html title=揭祕反賭人士不為人知的祕密，“反賭”還是“中飽私囊”？>揭祕反賭人士不為人知的祕密，“反賭”還是“中飽私囊”？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/161da2e.html alt="不為人知的Oracle11g network_acl網絡訪問控制列表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/918333db182949b09fdbadbbef0ecd03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/161da2e.html title="不為人知的Oracle11g network_acl網絡訪問控制列表">不為人知的Oracle11g network_acl網絡訪問控制列表</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/1d77c07.html alt=只見普洱：金庸，不為人知的另一面 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15410720820222fa1aef18b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/1d77c07.html title=只見普洱：金庸，不為人知的另一面>只見普洱：金庸，不為人知的另一面</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/0e50962.html alt=那些不為人知的食品保存和消毒誤區 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0b64eaf3f584ae69b2a5158d7442b87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/0e50962.html title=那些不為人知的食品保存和消毒誤區>那些不為人知的食品保存和消毒誤區</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/8ef000a.html alt=不為人知的最強科技！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/152608881237066a0087049 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/8ef000a.html title=不為人知的最強科技！>不為人知的最強科技！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1de4ec1.html alt=不為人知的鑽井：定向井和水平井鑽井技術(1) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/320c00031c546476ef76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1de4ec1.html title=不為人知的鑽井：定向井和水平井鑽井技術(1)>不為人知的鑽井：定向井和水平井鑽井技術(1)</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/5554deb.html alt="不為人知的世界十大奇蹟 你敢來探險嗎？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/RCp1shtCTajk09 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/5554deb.html title="不為人知的世界十大奇蹟 你敢來探險嗎？">不為人知的世界十大奇蹟 你敢來探險嗎？</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/b0e52e3.html alt="貓咪不為人知的祕密 你信嗎反正我信了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/343217030e8a4bec94bad4aebf92fc49 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/b0e52e3.html title="貓咪不為人知的祕密 你信嗎反正我信了">貓咪不為人知的祕密 你信嗎反正我信了</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>