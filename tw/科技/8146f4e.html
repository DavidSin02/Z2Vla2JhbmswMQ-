<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>顛覆你認知的單例設計模式精講 | 极客快訊</title><meta property="og:title" content="顛覆你認知的單例設計模式精講 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8146f4e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8146f4e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8146f4e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8146f4e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8146f4e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8146f4e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8146f4e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8146f4e.html><meta property="article:published_time" content="2020-10-29T20:58:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:42+08:00"><meta name=Keywords content><meta name=description content="顛覆你認知的單例設計模式精講"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8146f4e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>顛覆你認知的單例設計模式精講</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>一、設計模式</p><p>1.1 設計模式是什麼？</p><ol start=1><li>設計模式是解決特定問題的一系列套路，是前輩們的代碼設計經驗的總結，具有一定的普遍性，可以反覆使用。其目的是為了提高代碼的可重用性、代碼的可讀性和代碼的可靠性。</li><li>設計模式的本質是面向對象設計原則的實際運用，是對類的封裝性、繼承性和多態性以及類的關聯關係和組合關係的充分理解。</li></ol><p>1.2 為什麼要使用設計模式？</p><p>項目的需求是永遠在變的，為了應對這種變化，使得我們的代碼能夠輕易的實現解耦和拓展。</p><p>1.3 設計模式類型</p><ul><li>創建型模式</li></ul><p>創建型模式的主要關注點是<strong>怎樣創建對象</strong>，它的主要特點是<strong>將對象的創建與使用分離</strong>。這樣可以降低系統的耦合度，使用者不需要關注對象的創建細節。</p><ul><li>結構型模式</li></ul><p>結構型模式描述如何將類或對象按某種佈局組成更大的結構。它分為<strong>類結構型模式和對象結構型模式</strong>，前者採用繼承機制來組織接口和類，後者釆用組合或聚合來組合對象。</p><ul><li>行為型模式</li></ul><p>行為型模式用於描述程序在運行時複雜的流程控制，即描述多個類或對象之間怎樣相互協作共同完成單個對象都無法單獨完成的任務，它涉及算法與對象間職責的分配。它分為<strong>類行為模式和對象行為模式</strong>，前者採用繼承機制來在類間分派行為，後者採用組合或聚合在對象間分配行為。</p><p>創建型模式結構型模式行為型模式單例模式、抽象工廠模式、建造者模式、工廠模式、原型模式適配器模式、橋接模式、裝飾模式、組合模式、外觀模式、享元模式、代理模式模版方法模式、命令模式、迭代器模式、觀察者模式、中介者模式、備忘錄模式、解釋器模式、狀態模式、策略模式、職責鏈模式(責任鏈模式)、訪問者模式</p><p>二、面向對象設計的六大設計原則</p><p>2.1 開閉原則</p><p>一個軟件實體如類、模塊和函數應該對擴展開放，對修改關閉</p><ul><li>解讀</li></ul><ol start=1><li>用抽象構建框架，用實現擴展細節；</li><li>不以改動原有類的方式來實現新需求，而是應該以實現事先抽象出來的接口（或具體類繼承抽象類）的方式來實現。</li></ol><ul><li>優點</li></ul><ol start=1><li>可以在不改動原有代碼的前提下給程序擴展功能，增加了程序的可擴展性；</li><li>同時也降低了程序的維護成本。</li></ol><p>2.2 單一職責原則</p><p>一個類只允許有一個職責，即只有一個導致該類變更的原因。</p><ul><li>解讀</li></ul><ol start=1><li>類職責的變化往往就是導致類變化的原因：也就是說如果一個類具有多種職責，就會有多種導致這個類變化的原因，從而導致這個類的維護變得困難；</li><li>往往在軟件開發中隨著需求的不斷增加，可能會給原來的類添加一些本來不屬於它的一些職責，從而違反了單一職責原則。<strong>如果我們發現當前類的職責不僅僅有一個，就應該將本來不屬於該類真正的職責分離出去</strong>；</li><li>不僅僅是類，函數（方法）也要遵循單一職責原則，即：<strong>一個函數（方法）只做一件事情</strong>。如果發現一個函數（方法）裡面有不同的任務，則需要將不同的任務以另一個函數（方法）的形式分離出去。</li></ol><ul><li>優點</li></ul><ol start=1><li>提高代碼的可讀性，更實際性地更降低了程序出錯的風險；</li><li>有利於bug的追蹤，降低了程序的維護成本。</li></ol><p>2.3 依賴倒置原則</p><ol start=1><li>依賴抽象，而不是依賴實現;</li><li>抽象不應該依賴細節；細節應該依賴抽象;</li><li>高層模塊不能依賴低層模塊，二者都應該依賴抽象。</li></ol><ul><li>解讀</li></ul><ol start=1><li>面向接口編程，而不是面向實現編程；</li><li>儘量不要從具體的類派生，而是以繼承抽象類或實現接口來實現；</li><li>關於高層模塊與低層模塊的劃分可以按照決策能力的高低進行劃分。業務層自然就處於上層模塊，邏輯層和數據層自然就歸類為底層。</li></ol><ul><li>優點</li></ul><ol start=1><li>通過抽象來搭建框架，建立類和類的關聯，以減少類間的耦合性；</li><li>以抽象搭建的系統要比以具體實現搭建的系統更加穩定，擴展性更高，同時也便於維護。</li></ol><ul><li>里氏替換原則</li></ul><p>子類可以擴展父類的功能，但不能改變父類原有的功能。也就是說，子類繼承父類時，除添加新的方法完成新增功能外，儘量不要重寫父類的方法。</p><p>2.4 接口隔離原則</p><p>多個特定的客戶端接口要好於一個通用性的總接口。</p><ul><li>解讀</li></ul><ol start=1><li>客戶端不應該依賴它不需要實現的接口；</li><li>不建立龐大臃腫的接口，應儘量細化接口，接口中的方法應該儘量少。</li></ol><blockquote><p>注意：接口的粒度也不能太小。如果過小，則會造成接口數量過多，使設計複雜化。</p></blockquote><ul><li>優點</li></ul><p>避免同一個接口裡麵包含不同類職責的方法，接口責任劃分更加明確，符合<strong>高內聚低耦合</strong>的思想。</p><p>2.5 迪米特法則（最少知道原則）</p><p>一個對象應該對儘可能少的對象有接觸，也就是隻接觸那些真正需要接觸的對象。</p><ul><li>解讀</li></ul><p>一個類應該只和它的成員變量，方法的輸入，返回參數中的類作交流，而不應該引入其他的類（間接交流）。</p><ul><li>優點</li></ul><p>可以良好地降低類與類之間的耦合，減少類與類之間的關聯程度，讓類與類之間的協作更加直接。</p><p>2.6 組合聚合複用原則</p><p>所有引用基類的地方必須能透明地使用其子類的對象，也就是說子類對象可以替換其父類對象，而程序執行效果不變。</p><p>-解讀</p><p>在繼承體系中，子類中可以增加自己特有的方法，也可以實現父類的抽象方法，但是不能重寫父類的非抽象方法，否則該繼承關係就不是一個正確的繼承關係。</p><ul><li>優點</li></ul><p>可以檢驗繼承使用的正確性，約束繼承在使用上的泛濫。</p><p>三、 單例模式概念</p><p>3.1 單例模式是什麼？</p><p>單例模式就是在程序運行中只實例化一次，創建一個全局唯一對象。有點像 Java 的靜態變量，但是單例模式要優於靜態變量：</p><ol start=1><li>靜態變量在程序啟動的時候JVM就會進行加載，如果不使用，會造成大量的資源浪費；</li><li>單例模式能夠實現懶加載，能夠在使用實例的時候才去創建實例。</li></ol><p>開發工具類庫中的很多工具類都應用了單例模式，比例線程池、緩存、日誌對象等，它們都只需要創建一個對象，如果創建多份實例，可能會帶來不可預知的問題，比如資源的浪費、結果處理不一致等問題。</p><p>3.2 為什麼要使用單例模式？</p><p>單例模式屬於設計模式三大分類中的第一類——創建型模式，跟對象的創建相關。也就是說，這個模式在創建對象的同時，還致力於控制創建對象的數量，是的，只能創建一個實例，多的不要。</p><p>那麼問題來了，我們為什麼要控制對象創建的個數？</p><ol start=1><li>有些場景下，不使用單例模式，會導致系統同一時刻出現多個狀態缺乏同步，用戶自然無法判斷當前處於什麼狀態；</li><li>通過控制創建對象的數量，可以節約系統資源開銷（像線程、數據庫連接等）；</li><li>全局數據共享。</li></ol><p>3.3 單例的實現思路</p><ol start=1><li>靜態化實例對象；</li><li>私有化構造方法，禁止通過構造方法創建實例；</li><li>提供一個公共的靜態方法，用來返回唯一實例。</li></ol><p>四、 餓漢模式</p><p>在定義靜態屬性時，直接實例化了對象</p><p>4.1 示例</p><pre>public class HungryMode { /** * 利用靜態變量來存儲唯一實例 */ private static final HungryMode instance = new HungryMode(); /** * 私有化構造函數 */ private HungryMode(){ // 裡面可以有很多操作 } /** * 提供公開獲取實例接口 * @return */ public static HungryMode getInstance(){ return instance; }}</pre><p>4.2 餓漢模式的優點</p><p>由於使用了static關鍵字，保證了在引用這個變量時，關於這個變量的所以寫入操作都完成，所以保證了JVM層面的線程安全。</p><p>4.3 餓漢模式的缺點</p><p>不能實現懶加載，造成空間浪費：如果一個類比較大，我們在初始化的時就加載了這個類，但是我們長時間沒有使用這個類，這就導致了內存空間的浪費。</p><blockquote><p>所以，能不能只有用到 getInstance()方法，才會去初始化單例類，才會加載單例類中的數據。所以就有了：<strong>懶漢式</strong>。</p></blockquote><p>五、懶漢模式</p><p>懶漢模式是一種偷懶的模式，在程序初始化時不會創建實例，只有在使用實例的時候才會創建實例，所以懶漢模式解決了餓漢模式帶來的空間浪費問題。</p><p>5.1 懶漢模式的一般實現</p><pre>public class LazyMode { /** * 定義靜態變量時，未初始化實例 */ private static LazyMode instance; /** * 私有化構造函數 */ private LazyMode(){ // 裡面可以有很多操作 } /** * 提供公開獲取實例接口 * @return */ public static LazyMode getInstance(){ // 使用時，先判斷實例是否為空，如果實例為空，則實例化對象 if (instance == null) { instance = new LazyMode(); } return instance; }}</pre><p>但是這種實現在多線程的情況下是不安全的，有可能會出現多份實例的情況：</p><pre>if (instance == null) { instance = new LazyMode();}</pre><p>假設有兩個線程同時進入到上面這段代碼，因為沒有任何資源保護措施，所以兩個線程可以同時判斷的 instance 都為空，都將去初始化實例，所以就會出現多份實例的情況。</p><p>5.2 懶漢模式的優化</p><p>我們給getInstance()方法加上synchronized關鍵字，使得getInstance()方法成為受保護的資源就能夠解決多份實例的問題。</p><pre>public class LazyModeSynchronized { /** * 定義靜態變量時，未初始化實例 */ private static LazyModeSynchronized instance; /** * 私有化構造函數 */ private LazyModeSynchronized(){ // 裡面可以有很多操作 } /** * 提供公開獲取實例接口 * @return */ public synchronized static LazyModeSynchronized getInstance(){ /** * 添加class類鎖，影響了性能，加鎖之後將代碼進行了串行化， * 我們的代碼塊絕大部分是讀操作，在讀操作的情況下，代碼線程是安全的 * */ if (instance == null) { instance = new LazyModeSynchronized(); } return instance; }}</pre><p>5.3 懶漢模式的優點</p><p>實現了懶加載，節約了內存空間。</p><p>5.4 懶漢模式的缺點</p><ol start=1><li>在不加鎖的情況下，線程不安全，可能出現多份實例；</li><li>在加鎖的情況下，會使程序串行化，使系統有嚴重的性能問題。</li></ol><p>懶漢模式中加鎖的問題，對於getInstance()方法來說，絕大部分的操作都是讀操作，讀操作是線程安全的，所以我們沒必讓每個線程必須持有鎖才能調用該方法，我們需要調整加鎖的問題。由此也產生了一種新的實現模式：<strong>雙重檢查鎖模式</strong>。</p><p>六、雙重檢查鎖模式</p><p>6.1 雙重檢查鎖模式的一般實現</p><pre>public class DoubleCheckLockMode { private static DoubleCheckLockMode instance; /** * 私有化構造函數 */ private DoubleCheckLockMode(){ } /** * 提供公開獲取實例接口 * @return */ public static DoubleCheckLockMode getInstance(){ // 第一次判斷，如果這裡為空，不進入搶鎖階段，直接返回實例 if (instance == null) { synchronized (DoubleCheckLockMode.class) { // 搶到鎖之後再次判斷是否為空 if (instance == null) { instance = new DoubleCheckLockMode(); } } } return instance; }}</pre><p>雙重檢查鎖模式解決了單例、性能、線程安全問題，但是這種寫法同樣存在問題：在多線程的情況下，可能會出現空指針問題，出現問題的原因是JVM在實例化對象的時候會進行優化和指令重排序操作。</p><p>6.2 什麼是指令重排？</p><pre>private SingletonObject(){ // 第一步 int x = 10; // 第二步 int y = 30; // 第三步 Object o = new Object(); }</pre><p>上面的構造函數SingletonObject()，JVM 會對它進行指令重排序，所以執行順序可能會亂掉，但是不管是那種執行順序，JVM 最後都會保證所以實例都完成實例化。 <strong>如果構造函數中操作比較多時，為了提升效率，JVM 會在構造函數裡面的屬性未全部完成實例化時，就返回對象</strong>。雙重檢測鎖出現空指針問題的原因就是出現在這裡，當某個線程獲取鎖進行實例化時，其他線程就直接獲取實例使用，由於JVM指令重排序的原因，其他線程獲取的對象也許不是一個完整的對象，所以在使用實例的時候就<strong>會出現空指針異常問題</strong>。</p><p>6.3 雙重檢查鎖模式優化</p><p>要解決雙重檢查鎖模式帶來空指針異常的問題，只需要使用volatile關鍵字，volatile關鍵字嚴格遵循happens-before原則，即：在讀操作前，寫操作必須全部完成。</p><pre>public class DoubleCheckLockModelVolatile { /** * 添加volatile關鍵字，保證在讀操作前，寫操作必須全部完成 */ private static volatile DoubleCheckLockModelVolatile instance; /** * 私有化構造函數 */ private DoubleCheckLockModelVolatile(){ } /** * 提供公開獲取實例接口 * @return */ public static DoubleCheckLockModelVolatile getInstance(){ if (instance == null) { synchronized (DoubleCheckLockModelVolatile.class) { if (instance == null) { instance = new DoubleCheckLockModelVolatile(); } } } return instance; }}</pre><p>七、靜態內部類模式</p><p>靜態內部類模式也稱單例持有者模式，實例由內部類創建，由於 JVM 在加載外部類的過程中, 是不會加載靜態內部類的, 只有內部類的屬性/方法被調用時才會被加載, 並初始化其靜態屬性。靜態屬性由static修飾，保證只被實例化一次，並且嚴格保證實例化順序。</p><pre>public class StaticInnerClassMode { private StaticInnerClassMode(){ } /** * 單例持有者 */ private static class InstanceHolder{ private final static StaticInnerClassMode instance = new StaticInnerClassMode(); } /** * 提供公開獲取實例接口 * @return */ public static StaticInnerClassMode getInstance(){ // 調用內部類屬性 return InstanceHolder.instance; }}</pre><p>這種方式跟餓漢式方式採用的機制類似，但又有不同。兩者都是採用了類裝載的機制來保證初始化實例時只有一個線程。不同的地方：</p><ol start=1><li>餓漢式方式是隻要Singleton類被裝載就會實例化，沒有Lazy-Loading的作用；</li><li>靜態內部類方式在Singleton類被裝載時並不會立即實例化，而是在需要實例化時，調用getInstance()方法，才會裝載SingletonInstance類，從而完成Singleton的實例化。</li></ol><p>類的靜態屬性只會在第一次加載類的時候初始化，所以在這裡，JVM幫助我們保證了線程的安全性，在類進行初始化時，別的線程是無法進入的。</p><p>所以這種方式<strong>在沒有加任何鎖的情況下，保證了多線程下的安全，並且沒有任何性能影響和空間的浪費</strong>。</p><p>八、枚舉類實現單例模式</p><p>因為枚舉類型是線程安全的，並且只會裝載一次，設計者充分的利用了枚舉的這個特性來實現單例模式，枚舉的寫法非常簡單，而且枚舉類型是所用單例實現中<strong>唯一一種不會被破壞的單例實現模式</strong>。</p><p>8.1 示例</p><pre>public class EnumerationMode {  private EnumerationMode(){  } /** * 枚舉類型是線程安全的，並且只會裝載一次 */ private enum Singleton{ INSTANCE; private final EnumerationMode instance; Singleton(){ instance = new EnumerationMode(); } private EnumerationMode getInstance(){ return instance; } } public static EnumerationMode getInstance(){ return Singleton.INSTANCE.getInstance(); }}</pre><p>8.2 適用場合：</p><ol start=1><li>需要頻繁的進行創建和銷燬的對象；</li><li>創建對象時耗時過多或耗費資源過多，但又經常用到的對象；</li><li>工具類對象；</li><li>頻繁訪問數據庫或文件的對象。</li></ol><p>九、單例模式的問題及解決辦法</p><p>除枚舉方式外, 其他方法都會通過反射的方式破壞單例</p><p>9.1 單例模式的破壞</p><pre>/** * 以靜態內部類實現為例 * @throws Exception */@Testpublic void singletonTest() throws Exception { Constructor constructor = StaticInnerClassMode.class.getDeclaredConstructor(); constructor.setAccessible(true); StaticInnerClassMode obj1 = StaticInnerClassMode.getInstance(); StaticInnerClassMode obj2 = StaticInnerClassMode.getInstance(); StaticInnerClassMode obj3 = (StaticInnerClassMode) constructor.newInstance(); System.out.println(&#34;輸出結果為：&#34;+obj1.hashCode()+&#34;,&#34; +obj2.hashCode()+&#34;,&#34;+obj3.hashCode());}</pre><p>控制檯打印：</p><pre>輸出結果為：1454171136,1454171136,1195396074</pre><p>從輸出的結果我們就可以看出obj1和obj2為同一對象，obj3為新對象。obj3是我們通過反射機制，進而調用了私有的構造函數，然後產生了一個新的對象。</p><p>9.2 如何阻止單例破壞</p><p>可以在構造方法中進行判斷，若已有實例, 則阻止生成新的實例，解決辦法如下:</p><pre>public class StaticInnerClassModeProtection { private static boolean flag = false; private StaticInnerClassModeProtection(){ synchronized(StaticInnerClassModeProtection.class){ if(flag == false){ flag = true; }else { throw new RuntimeException(&#34;實例已經存在，請通過 getInstance()方法獲取！&#34;); } } } /** * 單例持有者 */ private static class InstanceHolder{ private final static StaticInnerClassModeProtection instance = new StaticInnerClassModeProtection(); } /** * 提供公開獲取實例接口 * @return */ public static StaticInnerClassModeProtection getInstance(){ // 調用內部類屬性 return InstanceHolder.instance; }}</pre><p>測試：</p><pre>/** * 在構造方法中進行判斷，若存在則拋出RuntimeException * @throws Exception */@Testpublic void destroyTest() throws Exception { Constructor constructor = StaticInnerClassModeProtection.class.getDeclaredConstructor(); constructor.setAccessible(true); StaticInnerClassModeProtection obj1 = StaticInnerClassModeProtection.getInstance(); StaticInnerClassModeProtection obj2 = StaticInnerClassModeProtection.getInstance(); StaticInnerClassModeProtection obj3 = (StaticInnerClassModeProtection) constructor.newInstance(); System.out.println(&#34;輸出結果為：&#34;+obj1.hashCode()+&#34;,&#34; +obj2.hashCode()+&#34;,&#34;+obj3.hashCode());}</pre><p>控制檯打印：</p><pre>Caused by: java.lang.RuntimeException: 實例已經存在，請通過 getInstance()方法獲取！ at cn.van.singleton.demo.mode.StaticInnerClassModeProtection.&lt;init&gt;(StaticInnerClassModeProtection.java:22) ... 35 more</pre><p>十、總結</p><p>10.1 各種實現的對比</p><p>名稱餓漢模式懶漢模式雙重檢查鎖模式靜態內部類實現枚舉類實現可用性可用不推薦使用推薦使用推薦使用推薦使用特點不能實現懶加載，可能造成空間浪費不加鎖線程不安全；加鎖性能差線程安全；延遲加載；效率較高避免了線程不安全，延遲加載，效率高。寫法簡單；線程安全；只裝載一次</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>顛覆</a></li><li><a>認知</a></li><li><a>單例</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/bd18d978.html alt=顛覆認知！看完這些圖，你的世界觀還好嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/27bbcf6d4b5544d297435eb0ccf64a0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/bd18d978.html title=顛覆認知！看完這些圖，你的世界觀還好嗎？>顛覆認知！看完這些圖，你的世界觀還好嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/9f62c4dd.html alt=顛覆你們認知的催奶和產康，滿滿的乾貨文 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b4fa08679ccf46379614639de209045c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/9f62c4dd.html title=顛覆你們認知的催奶和產康，滿滿的乾貨文>顛覆你們認知的催奶和產康，滿滿的乾貨文</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/da82f96f.html alt=顛覆認知：樑模板，3條立杆竟然不如2條立杆安全？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/814c8ed884a74001bf41ecae8fb4c561 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/da82f96f.html title=顛覆認知：樑模板，3條立杆竟然不如2條立杆安全？>顛覆認知：樑模板，3條立杆竟然不如2條立杆安全？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/7aced65.html alt=顛覆了我的認知，啄木鳥到底是害鳥還是益鳥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3452182b-4712-45a1-8359-93e1020af08c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/7aced65.html title=顛覆了我的認知，啄木鳥到底是害鳥還是益鳥>顛覆了我的認知，啄木鳥到底是害鳥還是益鳥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/81c93a5.html alt=顛覆認知，中國古代的戒指就這麼美，故宮館藏的50件戒指文物 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e8ab6f69eec1444c9ec2c66654bcce8c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/81c93a5.html title=顛覆認知，中國古代的戒指就這麼美，故宮館藏的50件戒指文物>顛覆認知，中國古代的戒指就這麼美，故宮館藏的50件戒指文物</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a72314.html alt=顛覆認知，不一樣的三缸時代 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eab7e12d7ee43ffa6aa7945d08837f4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a72314.html title=顛覆認知，不一樣的三缸時代>顛覆認知，不一樣的三缸時代</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/80600523.html alt=《獬豸》：和朝鮮檢察院沒關係的顛覆歷史作品 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RIhLI8tHZnIPRU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/80600523.html title=《獬豸》：和朝鮮檢察院沒關係的顛覆歷史作品>《獬豸》：和朝鮮檢察院沒關係的顛覆歷史作品</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc721d71.html alt=單例模式VS靜態方法：你應該何去何從？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b3079753ad7344f68a7837c3bdd3e666 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc721d71.html title=單例模式VS靜態方法：你應該何去何從？>單例模式VS靜態方法：你應該何去何從？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4bbcd5d1.html alt="傳統影像的完全顛覆，XD Fusion，華為影像系統的支點" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1a58b149c7564a83b5673ac22dc557af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4bbcd5d1.html title="傳統影像的完全顛覆，XD Fusion，華為影像系統的支點">傳統影像的完全顛覆，XD Fusion，華為影像系統的支點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9257f598.html alt=你不知道的項目經理崗位認知 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8fd79e33009e4704b5be68d3cead06d3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9257f598.html title=你不知道的項目經理崗位認知>你不知道的項目經理崗位認知</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3b4b08b.html alt=基本認知：張拉整體結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d29456fe39444c65b2538db5ba1aabe3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3b4b08b.html title=基本認知：張拉整體結構>基本認知：張拉整體結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d1d464b.html alt=誰說素色拼接不用加簾頭？這些案例顛覆您的認知 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0e8b7c67799744a786384b558e5ce64c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d1d464b.html title=誰說素色拼接不用加簾頭？這些案例顛覆您的認知>誰說素色拼接不用加簾頭？這些案例顛覆您的認知</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/77bb0b4f.html alt=認知體系、空間思維、邏輯推理，這個益智玩具全包了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RRwAs8fBfkehpR style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/77bb0b4f.html title=認知體系、空間思維、邏輯推理，這個益智玩具全包了>認知體系、空間思維、邏輯推理，這個益智玩具全包了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1b71307.html alt=無P圖！顯微鏡下的晶體：顛覆想象的迷幻之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15218600759256b49b4bbbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1b71307.html title=無P圖！顯微鏡下的晶體：顛覆想象的迷幻之美>無P圖！顯微鏡下的晶體：顛覆想象的迷幻之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2bb6f64f.html alt=初中物理，歐姆定律的認知，弄明白了這些如魚得水 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e8148c41766e4c3b8683d8eedf25c2c2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2bb6f64f.html title=初中物理，歐姆定律的認知，弄明白了這些如魚得水>初中物理，歐姆定律的認知，弄明白了這些如魚得水</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>