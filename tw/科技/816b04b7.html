<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從JVM層面帶你分析Java的Object類源碼第一部分 | 极客快訊</title><meta property="og:title" content="從JVM層面帶你分析Java的Object類源碼第一部分 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/816b04b7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/816b04b7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/816b04b7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/816b04b7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/816b04b7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/816b04b7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/816b04b7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/816b04b7.html><meta property="article:published_time" content="2020-11-14T21:08:08+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:08+08:00"><meta name=Keywords content><meta name=description content="從JVM層面帶你分析Java的Object類源碼第一部分"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/816b04b7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從JVM層面帶你分析Java的Object類源碼第一部分</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>大家好，我是小圖靈視界，最近在分析Java8源碼，使用的JDK是OpenJDK8,打算將分析源碼的筆記都會分享出來，在頭條上代碼排版比較難看，想要筆記的可以關注並私信我。</strong></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6814477971127009803/?group_id=6814477971127009803" rel="noopener noreferrer" target=_blank>從JVM層面帶你分析Java的Object類源碼第二部分</a></p><h1 class=pgc-h-arrow-right>Object 源碼</h1><p><strong>位置：java.lang包</strong></p><p><strong>Object類是Java中最基本的類，是所有類的根。也就說，所有的類默認都會繼承它，包括數組等，都要繼承Object中的所有方法</strong>。Object類中大多數都是native方法，native就是本地方法，由關鍵native字修飾，這些方法不在java語言中實現，<strong>底層實現是的c/c++代碼</strong>。主要的native方法如下：</p><pre><code>//加載本地方法private static native void registerNatives();//獲取對象的類型 Classpublic final native Class&lt;?&gt; getClass();//獲取hash碼 public native int hashCode();//對象拷貝protected native Object clone() throws CloneNotSupportedException;//跟線程有關的方法//喚醒線程public final native void notify();//喚醒所有的線程public final native void notifyAll();//線程等待public final native void wait(long timeout) throws InterruptedException;</code></pre><h1 class=pgc-h-arrow-right>private static native void registerNatives()</h1><p>在Object類中，有static代碼塊，這個靜態代碼塊調用了registerNatives()方法：</p><pre><code>private static native void registerNatives();static {    registerNatives();}</code></pre><p><strong>registerNatives方法的作用是加載和註冊本地C、C++語言函數，將Java的本地方法與JVM底層的C、C++語言函數對應起來，是連接java語言與底層語言的橋樑，registerNatives方法在其他類中也可能存在，如Class類</strong>。Java類的本地方法對應C、C++函數的規則是Java_包名_方法名,包名以下劃線分隔，Object類的registerNatives對應著C語言函數是Java_java_lang_Object_registerNatives，java_lang_Object是java全類名以下劃線連接，registerNatives是Java中的方法，其中Java_java_lang_Object_registerNatives這個C語言函數如下：</p><pre><code>static JNINativeMethod methods[] = {    {&#34;hashCode&#34;,    &#34;()I&#34;,                    (void *)&JVM_IHashCode},    {&#34;wait&#34;,        &#34;(J)V&#34;,                   (void *)&JVM_MonitorWait},    {&#34;notify&#34;,      &#34;()V&#34;,                    (void *)&JVM_MonitorNotify},    {&#34;notifyAll&#34;,   &#34;()V&#34;,                    (void *)&JVM_MonitorNotifyAll},    {&#34;clone&#34;,       &#34;()Ljava/lang/Object;&#34;,   (void *)&JVM_Clone},};JNIEXPORT void JNICALLJava_java_lang_Object_registerNatives(JNIEnv *env, jclass cls){    (*env)-&gt;RegisterNatives(env, cls,                            methods, sizeof(methods)/sizeof(methods[0]));}</code></pre><p>Java_java_lang_Object_registerNatives主要是註冊Object類的hashCode、wait、notify、notifyAll、clone等方法，而getClass方法卻不在這裡加載。在Object類中，這些本地方法不是在Java層面實現的，所有在調用這些方法的時候，是調用了底層語言的具體實現。</p><p>在methods[]數組中，有多個Java本地方法對應JVM層面的函數，如Object中hashCode方法對應JVM中的JVM_IHashCode函數，返回的類型是()I，即返回的是整數類型。</p><h1 class=pgc-h-arrow-right>public final native Class&lt;?> getClass()</h1><p>getClass()方法的作用是返回對象運行時的Class類型，java編譯會將java類編譯成以.class結尾的文件，這是編譯生成的二進制字節碼文件，用於JVM加載，Java跨平臺是因為使用與平臺無關的class二進制字節碼文件，可以通過Jjava中的Class類獲取對象的構造器、方法、屬性、註解等相關信息：</p><pre><code>Object object=new Object();System.out.println(object.getClass());Class&lt;?&gt; objectClass=object.getClass();//構造器Constructor&lt;?&gt;[] constructors=objectClass.getConstructors();System.out.println(&#34;Object 類的構造器：&#34;);for (Constructor constructor:constructors){        System.out.print(constructor); }//方法Method[] methods=objectClass.getMethods();System.out.println(&#34;Object 類的方法：&#34;);for (Method method:methods){      System.out.println(method);}//屬性Field[] fields=objectClass.getFields();System.out.println(&#34;Object 類的屬性：&#34;);for (Field field:fields){       System.out.println(field);}</code></pre><p>getClass方法對應的底層C語言函數為Java_java_lang_Object_getClass，具體實現為：</p><pre><code>JNIEXPORT jclass JNICALLJava_java_lang_Object_getClass(JNIEnv *env, jobject this){    if (this == NULL) {        JNU_ThrowNullPointerException(env, NULL);        return 0;    } else {        return (*env)-&gt;GetObjectClass(env, this);    }}</code></pre><p>當傳入的對象this為null，直接拋出NullPointerException異常，否則調用GetObjectClass函數,GetObjectClass函數如下：</p><pre><code>JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))  JNIWrapper(&#34;GetObjectClass&#34;);#ifndef USDT2  DTRACE_PROBE2(hotspot_jni, GetObjectClass__entry, env, obj);#else /* USDT2 */  HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);#endif /* USDT2 *///主要作用是根據java對象引用找到JVM中引用對象，將Java對象轉換為JVM中的引用對象，然後調用klass()方法找到元數據  Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();  jclass ret =(jclass) JNIHandles::make_local(env, k-&gt;java_mirror());#ifndef USDT2  DTRACE_PROBE1(hotspot_jni, GetObjectClass__return, ret);#else /* USDT2 */  HOTSPOT_JNI_GETOBJECTCLASS_RETURN(                                    ret);#endif /* USDT2 */  return ret;JNI_END</code></pre><p>上述的核心代碼為:</p><pre><code>Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();</code></pre><p>resolve_non_null方法主要作用是根據java對象引用找到JVM中引用對象oop，將Java對象轉換為JVM中的引用對象，然後調用klass()方法找到元數據，resolve_non_null的方法為：</p><pre><code>inline oop JNIHandles::resolve_non_null(jobject handle) {  assert(handle != NULL, &#34;JNI handle should not be null&#34;);  oop result = *(oop*)handle;  assert(result != NULL, &#34;Invalid value read from jni handle&#34;);  assert(result != badJNIHandle, &#34;Pointing to zapped jni handle area&#34;);  // Don&#39;t let that private _deleted_handle object escape into the wild.  assert(result != deleted_handle(), &#34;Used a deleted global handle.&#34;);  return result;};</code></pre><p>resolve_non_null方法的核心代碼是oop result = (oop)handle;這句代碼的意思是先將傳入的Java對象轉為oop實例，（(oop*)handle），然後再獲取oop的指針，這個指針就是引用對象實例的地址（*(oop*)handle）。然後調用klass()獲取對象實例所屬的元數據Klass，Klass是指向Class類型的指針。</p><pre><code>inline Klass* oopDesc::klass() const {  if (UseCompressedClassPointers) {    return Klass::decode_klass_not_null(_metadata._compressed_klass);  } else {  //返回元數據    return _metadata._klass;  }}</code></pre><p>jclass ret =(jclass) JNIHandles::make_local(env, k->java_mirror())分為兩步，先調用Klass的java_mirror()方法，java_mirror方法的作用是返回Klass元數據的鏡像（oop），對應著jjava/lang/Class類的實例，ava_mirror方法如下：</p><pre><code> // java/lang/Class instance mirroring this classoop       _java_mirror;oop java_mirror() const              { return _java_mirror; }</code></pre><p>最後通過 JNIHandles::make_local處理oop，然後返回處理過後的oop,make_local的代碼如下：</p><pre><code>jobject JNIHandles::make_local(oop obj) {  if (obj == NULL) {      //返回null    return NULL;                // ignore null handles  } else {     //獲取當前線程    Thread* thread = Thread::current();    assert(Universe::heap()-&gt;is_in_reserved(obj), &#34;sanity check&#34;);     //利用當前線程活躍的handles對oop進行處理。    return thread-&gt;active_handles()-&gt;allocate_handle(obj);  }}</code></pre><p>在JNIHandles::make_local函數中，當傳入的oop實例obj為空時，直接返回空，否則將處理過的結果。</p><h1 class=pgc-h-arrow-right>public native int hashCode()</h1><p>hashCode方法返回對象的哈希碼，以整數形式返回。哈希表在java集合中如HashMap、HashSet中被廣泛使用，主要作用是為了提高查詢效率。hashCode方法一些規定/約定如下：</p><li>在不修改對象的equals()方法時，同一個對象無論何時調用hashCode方法，每次調用hashCode方法必須返回相同的整數（哈希碼）。此整數不需要在應用程序的一次執行與同一應用程序的另一次執行之間保持一致。</li><li>如果兩個對象相等（使用equals()方法判斷），那麼這兩個對象調用hashCode方法必須返回相同的整數結果（哈希碼）。</li><li>如果兩個對象不相等（使用equals()方法判斷），兩個對象調用hashCode方法返回的結果不一定不同，也就是不同的兩個對象的hashCode方法返回的結果可以相同也可以不相同。但是不同對象返回的哈希碼最好不同，這樣在哈希表查詢時效率會更高。</li><p>hashCode方法的使用：</p><pre><code>Object o1=new Object();Object o2=new Object();Object o3=o1;System.out.println(&#34;o1的hash的哈希碼：&#34;+ o1.hashCode());System.out.println(&#34;o2的hash的哈希碼：&#34;+ o2.hashCode());System.out.println(&#34;o3的hash的哈希碼：&#34;+ o3.hashCode());//我機器上的結果，不同機器結果不同o1的hash的哈希碼：399573350o2的hash的哈希碼：463345942o3的hash的哈希碼：399573350</code></pre><p>o1和o2是不同的對象，hashCode方法產生不同的哈希碼， o1與o3是不同的對象，它們的哈希碼不一樣。hashCode的底層C++實現</p><pre><code>static inline intptr_t get_next_hash(Thread * Self, oop obj) {  intptr_t value = 0 ;  if (hashCode == 0) {      //OpenJdk 6 &7的默認實現,此類方案返回一個Park-Miller偽隨機數生成器生成的隨機數     value = os::random() ;  } else  if (hashCode == 1) {      //此類方案將對象的內存地址，做移位運算後與一個隨機數進行異或得到結果     intptr_t addrBits = cast_from_oop&lt;intptr_t&gt;(obj) &gt;&gt; 3 ;     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom ;  } else  if (hashCode == 2) {      //此類方案將對象的內存地址，做移位運算後與一個隨機數進行異或得到結果     value = 1 ;            // for sensitivity testing  } else  if (hashCode == 3) {      //此類方案返回一個自增序列的當前值     value = ++GVars.hcSequence ;  } else  if (hashCode == 4) {      //此類方案返回當前對象的內存地址     value = cast_from_oop&lt;intptr_t&gt;(obj) ;  } else {     //OpenJdk 8 默認hashCode的計算方法     //通過和當前線程有關的一個隨機數+三個確定值      //運用Marsaglia&#39;s xorshift scheme隨機數算法得到的一個隨機數     unsigned t = Self-&gt;_hashStateX ;     t ^= (t &lt;&lt; 11) ;     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;     unsigned v = Self-&gt;_hashStateW ;     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)) ;     Self-&gt;_hashStateW = v ;     value = v ;  }  value &= markOopDesc::hash_mask;  if (value == 0) value = 0xBAD ;  assert (value != markOopDesc::no_hash, &#34;invariant&#34;) ;  TEVENT (hashCode: GENERATE) ;  return value;}</code></pre><p>get_next_hash函數根據hashCode的值，來採用不同的hashCode計算方法，當hashCode=0時，是OpenJDK6、7的默認實現方法，此類方案返回一個Park-Miller偽隨機數生成器生成的隨機數；當hashCode=1時，通過將對象的內存地址，做移位運算後與一個隨機數進行異或得到結果；當hashCode == 3，返回一個自增序列的當前值；當hashCode == 4時，返回當前對象的內存地址；當hashCode 為其他值時，是openJDK8 的hashCode 方法的默認實現。</p><p>openJDK8 的默認hashCode的計算方法是通過和當前線程有關的一個隨機數+三個確定值，運用Marsaglia's xorshift scheme隨機數算法得到的一個隨機數。xorshift算法是通過移位和與或計算，能夠在計算機上以極快的速度生成偽隨機數序列。算法如下：</p><pre><code>unsigned long xor128(){	static unsigned long x=123456789,y=362436069,z=521288629,w=88675123;	unsigned long t;	t=(xˆ(x&lt;&lt;11));x=y;y=z;z=w;     return( w=(wˆ(w&gt;&gt;19))ˆ(tˆ(t&gt;&gt;8)) );}</code></pre><p>Self->hashStateX 是隨機數、Self->hashStateY 、Self->hashStateZ、Self->hashStateW 是三個確認的數，分別對應xorshift 算法的x、y、z、w。</p><p>在啟動JVM時，可以通過設置<strong>-XX:hashCode</strong>參數，改變默認的hashCode的計算方式。</p><h1 class=pgc-h-arrow-right>public boolean equals(Object obj)</h1><pre><code>public boolean equals(Object obj) {        return (this == obj);}</code></pre><p>equals方法判斷兩個對象是否相等，在這個方法中，直接用this==obj進行比較，返回this和obj比較的結果，“==“符號是比較兩個對象是否是同一個對象，比較的是兩個對象內存地址是否相等。子類在繼承Object類的時候，一般需要重寫equals方法，如果不重寫，那麼就默認父類Object的方法，在JDK源碼中，很多對象都重寫equals方法，比如String類。</p><p>對於非空的對象引用，equals方法有幾個性質：</p><li>自反性：對於任何非空對象x和y，如果x.equals(y) 的結果為true，那麼y.equals(x) 的結果也為true。</li><li>傳遞性：對於任何非空對象x、y和z，如果x.equals(y)和y.equals(z)的結果都為true，那麼x.equals(z)的結果也為true。</li><li>一致性：對於任何非空對象x和y，如果未修改equals方法，多次調用equals方法結果始終為true或者false，不能這次返回true，下次返回false。</li><li>對於任何非空對象x，x.equals(null)的結果是false。</li><p>子類在繼承Object，重寫equals方法時，必須重寫hashCode方法，在hashCode約定中，如果兩個對象相等，hashCode必須返回相同的哈希碼。很多時候，子類在重寫父類Object的equals方法時，往往會忘了重寫hashCode，當重寫了equals但沒有重寫hashCode方法時，那麼該子類無法結合java集合正常運行，因為java集合如HashMap、HashSet等都是基於哈希碼進行存儲的。</p><h1 class=pgc-h-arrow-right>protected native Object clone() throws CloneNotSupportedException;</h1><p>clone()本地方法，創建並返回此對象的副本，該方法使用protected 修飾，Object不能直接調用clone()方法，會編譯錯誤：</p><pre><code> Object o=new Object(); //編譯錯誤 Object o1=  o.clone();</code></pre><p>如果想要使用clone()方法，子類必須重寫這個方法，並用public修飾。如果子類沒有實現clone(),子類默認調用父類的clone方法，如下：</p><pre><code>public class ObjectCloneTest {    public static void main(String [] args) throws CloneNotSupportedException {        ObjectCloneTest o=new ObjectCloneTest();        ObjectCloneTest cloneTest= (ObjectCloneTest) o.clone();        System.out.println(cloneTest);    }}</code></pre><p>但是運行時發生異常：</p><pre><code>Exception in thread &#34;main&#34; java.lang.CloneNotSupportedException: com.lingheng.java.source.ObjectCloneTest	at java.lang.Object.clone(Native Method)	at com.lingheng.java.source.ObjectCloneTest.main(ObjectCloneTest.java:12)</code></pre><p>如果子沒有實現Cloneable接口，當子類調用clone()方法時，會拋出CloneNotSupportedException異常。當子類實現Cloneable接口，程序運行會成功：</p><pre><code>//實現Cloneable接口public class ObjectCloneTest implements Cloneable{    public static void main(String [] args) throws CloneNotSupportedException {        ObjectCloneTest o=new ObjectCloneTest();        ObjectCloneTest cloneTest= (ObjectCloneTest) o.clone();        System.out.println(&#34;打印cloneTest：&#34;+cloneTest);    }}//結果打印cloneTest：com.lingheng.java.source.ObjectCloneTest@6d6f6e28</code></pre><p>所以，<strong>想要使用clone()方法，除了繼承Object外（默認繼承），還需要實現Cloneable接口。所有的數組默認是實現了Cloneable接口的，數組的clone()返回數組類型:</strong></p><pre><code>public void arrayClone(){    //字符串數組    String[] s=new String[]{&#34;hello&#34;,&#34;world&#34;};    System.out.println(s);    System.out.println(s.clone());     //整數數組     int[] num=new int[]{1,3};     System.out.println(num);     System.out.println(num.clone());}//結果[Ljava.lang.String;@17d10166[Ljava.lang.String;@1b9e1916[I@ba8a1dc[I@4f8e5cde</code></pre><p>對於任何對象x，具有以下幾個約定：</p><ol start=1><li>x.clone() != x 為true</li><li>x.clone().getClass() == x.getClass() 為true，但這不是必須滿足的要求，也就是說可能是false。按照約定，返回的對象應該通過調用super.clone來獲得。如果一個類和它所有的超類（除了Object） 遵循這個約定，那就會x.clone().getClass() == x.getClass()。</li><li>x.clone().equals(x)通常情況下為true，這不是必須滿足的要求。</li></ol><p>對於約定1，因為拷貝是創建一個新的對象，所以拷貝的對象和原對象是不相等的。</p><p>對於約定2，這個比較好理解，一個類和它所有的超類的clone方法都調用super.clone()獲取返回對象，所以這個類的Class個原對象的Claas是一樣的。clone返回的類型是Object類，也就是說，在clone中可以返回只要是Object的子類就可以了，這樣的話，x.clone().getClass() == x.getClass()的結果為false；</p><p>對於約定3，這不是必須滿足的條件，當在clone中改變了對象的屬性值，那麼x.clone().equals(x)的結果就可能不是true了。</p><p>分析了Java層面的clone的約定，我們從JVM層面看看clone底層的實現，在registerNatives函數中會加載clone的JVM實現JVM_Clone，JVM_Clone的實現如下：</p><pre><code>//JVM_Clone 的實現JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))  JVMWrapper(&#34;JVM_Clone&#34;);  Handle obj(THREAD, JNIHandles::resolve_non_null(handle));  const KlassHandle klass (THREAD, obj-&gt;klass());  JvmtiVMObjectAllocEventCollector oam;#ifdef ASSERT  // Just checking that the cloneable flag is set correct//如果是傳入的是數組  if (obj-&gt;is_array()) {      //所有的數組都默認實現了Cloneable接口    guarantee(klass-&gt;is_cloneable(), &#34;all arrays are cloneable&#34;);  } else {      //是否是實例    guarantee(obj-&gt;is_instance(), &#34;should be instanceOop&#34;);    bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());      //判斷是否是合法的cloneable    guarantee(cloneable == klass-&gt;is_cloneable(), &#34;incorrect cloneable flag&#34;);  }#endif----------------------------------分割線1-------------------------------------------------// Check if class of obj supports the Cloneable interface. // All arrays are considered to be cloneable (See JLS 20.1.5)    //如果沒有實現Cloneable接口，拋出CloneNotSupportedException異常  if (!klass-&gt;is_cloneable()) {    ResourceMark rm(THREAD);    THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());  }  // Make shallow object copy 	//淺拷貝  const int size = obj-&gt;size();  oop new_obj = NULL;  if (obj-&gt;is_array()) {//數組      //數組的長度    const int length = ((arrayOop)obj())-&gt;length();     //申請內存，創建新的數組    new_obj = CollectedHeap::array_allocate(klass, size, length, CHECK_NULL);  } else {    //申請內存，創建新的對象    new_obj = CollectedHeap::obj_allocate(klass, size, CHECK_NULL);  }----------------------------------分割線2------------------------------------------------- // 4839641 (4840070): We must do an oop-atomic copy, because if another thread  // is modifying a reference field in the clonee, a non-oop-atomic copy might  // be suspended in the middle of copying the pointer and end up with parts  // of two different pointers in the field.  Subsequent dereferences will crash.  // 4846409: an oop-copy of objects with long or double fields or arrays of same  // won&#39;t copy the longs/doubles atomically in 32-bit vm&#39;s, so we copy jlongs instead  // of oops.  We know objects are aligned on a minimum of an jlong boundary.  // The same is true of StubRoutines::object_copy and the various oop_copy  // variants, and of the code generated by the inline_native_clone intrinsic.  assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &#34;objects misaligned&#34;);  //原子性拷貝，可能另外一個線程會修改clone引用的字段  Copy::conjoint_jlongs_atomic((jlong*)obj(), (jlong*)new_obj,                               (size_t)align_object_size(size) / HeapWordsPerLong);  // Clear the header  new_obj-&gt;init_mark();  // Store check (mark entire object and let gc sort it out)  BarrierSet* bs = Universe::heap()-&gt;barrier_set();  assert(bs-&gt;has_write_region_opt(), &#34;Barrier set does not have write_region&#34;);  bs-&gt;write_region(MemRegion((HeapWord*)new_obj, size));  // Caution: this involves a java upcall, so the clone should be  // &#34;gc-robust&#34; by this stage.  //當java子類實現了finalize方法，已經調用finalize，註冊finalizer方法  if (klass-&gt;has_finalizer()) {    assert(obj-&gt;is_instance(), &#34;should be instanceOop&#34;);    new_obj = InstanceKlass::register_finalizer(instanceOop(new_obj), CHECK_NULL);  }	//創建拷貝的對象返回  return JNIHandles::make_local(env, oop(new_obj));JVM_END</code></pre><p>JVM_Clone的實現過程比較長，我將分割成三部分，分割線1上部分主要是檢查拷貝的一些標誌是否正確，判斷傳入的是數組還是對象，在上面我講過所有的數組都默認實現了Cloneable接口，在這裡就可以證明了。然後還判斷了傳入的對象是否繼承Cloneable接口，沒有繼承的話，就是非法的，這是第一段邏輯。</p><p>分割線中間部分的邏輯，主要是申請內存，供拷貝的時候使用。首先先判斷是否實現Cloneable接口，如果沒有拋出CloneNotSupportedException異常，然後根據傳入的是數組還是對象，調用不同的方法進行申請不同大小的內存。代碼的有段註釋是”Make shallow object copy “，就是說這裡的拷貝是淺拷貝。</p><p>最後的邏輯是，做一些檢查，最後返回新創建的拷貝對象。因為對象的屬性可能被另外一個線程改變，所以進行的是原子性的拷貝，最後創建拷貝的對象進行返回。這些源碼的註釋很詳細，有興趣的可以具體看看其他的一些邏輯。</p><h1 class=pgc-h-arrow-right>public String toString()</h1><p>oString()返回對象的字符串表示形式，最好所有Object的子類都重寫這個方法，Object類的toString方法返回的是"類名@哈希碼的十六進制，代碼實現如下：</p><pre><code>public String toString() {        return getClass().getName() + &#34;@&#34; + Integer.toHexString(hashCode());}</code></pre><p>當我們在代碼輸入使用System.out.println輸入對象的時候，會調用這個對象的toString方法，返回的是toString的字符串。一般在重寫的toString的過程，返回的字符串要易讀的。</p><p>Object類的源碼先分析到這裡，因為分析的筆記會比較長，我將用兩篇文章來發表。<strong>想要筆記的可以關注並私信我。</strong></p><p></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JVM</a></li><li><a>層面</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/59d7c87e.html alt=JVM/併發/MySQL/Java/網絡等一個都沒肝完，想擠BAT你說難不難？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/80833d07a23e4e4c8677376189188e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/59d7c87e.html title=JVM/併發/MySQL/Java/網絡等一個都沒肝完，想擠BAT你說難不難？>JVM/併發/MySQL/Java/網絡等一個都沒肝完，想擠BAT你說難不難？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9891406.html alt=程序員：深入理解JVM，從JVM層面來講Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/dde11845-76d0-4452-af65-97e0e223c1cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9891406.html title=程序員：深入理解JVM，從JVM層面來講Java多態>程序員：深入理解JVM，從JVM層面來講Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3cb200.html alt=「Java的JVM分析」JDK監控和故障處理工具，學會分析程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fb7c5a5f91ff439cbd458318d4316adf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3cb200.html title=「Java的JVM分析」JDK監控和故障處理工具，學會分析程序>「Java的JVM分析」JDK監控和故障處理工具，學會分析程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>