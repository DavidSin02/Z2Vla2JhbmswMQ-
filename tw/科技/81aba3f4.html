<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入介紹和使用 Java 8 的 Collector 接口和 Collectors 工具類 | 极客快訊</title><meta property="og:title" content="深入介紹和使用 Java 8 的 Collector 接口和 Collectors 工具類 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/6697a1bda5a747fc89be172989891078"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="深入介紹和使用 Java 8 的 Collector 接口和 Collectors 工具類"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/81aba3f4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入介紹和使用 Java 8 的 Collector 接口和 Collectors 工具類</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1 概述</h1><ul><li>java.util.stream.Collector: Collector 接口用於將 Stream 流中的數據加工，轉換，處理，最後返回結果。</li><li>java.util.stream.Collectors: Collectors 工具類內置了一些 Collector 接口的實現。</li></ul><p style=text-align:start>本文詳解 Java 8 的 Collector 接口方法以及 Collectors 工具類的使用，具體內容如下</p><ol start=1><li>Stream api 中的 collect 方法介紹以及使用</li><li>Collector 接口的實現</li><li>Collectors 工具類介紹以及使用</li></ol><h1 class=pgc-h-arrow-right>2 Stream 接口中的 collect 方法</h1><p style=text-align:start>collect 方法的功能是將 Stream 中數據轉換為最終的結果，具體如下</p><ol start=1><li>&lt;R, A> R collect(Collector&lt;? super T, A, R> collector)：參數類型為 Collector 接口</li><li>&lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner)：參數類型為 Supplier， BiConsumer，BiConsumer 三個對象。</li></ol><h1 class=pgc-h-arrow-right>2.1 collect 方法使用舉例</h1><p style=text-align:start>需求：將集合中的英文字符串首字母大寫，下面提供兩種實現的方法：</p><ol start=1><li>collect 方法接口參數為 Collector 對象實現</li><li>collect 方法接口參數為 Supplier， BiConsumer， BiConsumer 三個對象實現</li></ol><p style=text-align:start>具體實現如下</p><pre><code>@Testpublic void test_1() {    List&lt;String&gt; dataList = new ArrayList&lt;&gt;();    dataList.add("john");    dataList.add("kain");    dataList.add("mike");    dataList.add("milk");    dataList.add("kav");    // 1. 接口參數為 Collector 對象實現    // 1.1 Supplier 對象負責創建容器對象，以便容納 stream 中分隔後的數據，這裡使用 List&lt;Integer&gt; 作為數據的容器對象    // 1.2 accumulator 對象負責將 stream 中分隔後的數據放入上一步創建的容器中    // 1.3 combiner 對象負責將分隔的容器中的數據合併起來    // 1.4 finisher 對象負責將最終返回的結果進行最終的處理    // 1.5 characteristics 負責 Collector 執行效率的優化，具體要根據是否使用了 parallelStream 以及 數據是否有順序，不會影響最終的執行結果：    List&lt;String&gt; resultList = dataList.parallelStream().collect(new Collector&lt;String, List&lt;String&gt;, List&lt;String&gt;&gt;() {        @Override        public Supplier&lt;List&lt;String&gt;&gt; supplier() {            return () -&gt; new ArrayList&lt;&gt;();        }        @Override        public BiConsumer&lt;List&lt;String&gt;, String&gt; accumulator() {            return (list, data) -&gt; list.add(data.substring(0,1).toUpperCase().concat(data.substring(1)));        }        @Override        public BinaryOperator&lt;List&lt;String&gt;&gt; combiner() {            return (list1,list2) -&gt; {                list1.addAll(list2);                return list1;            };        }        @Override        public Function&lt;List&lt;String&gt;, List&lt;String&gt;&gt; finisher() {            return list -&gt; list;        }        @Override        public Set&lt;Characteristics&gt; characteristics() {            Set&lt;Characteristics&gt; characteristicsSet = new HashSet&lt;&gt;();            characteristicsSet.add(Characteristics.CONCURRENT);            return characteristicsSet;        }    });    resultList.forEach(System.out::println);    // 2. 接口參數為 Supplier， BiConsumer， BiConsumer 三個對象    // 2.1 Supplier 對象負責創建容器對象，以便容納 stream 中分隔後的數據，這裡使用 List&lt;Integer&gt; 作為數據的容器對象    // 2.2 BiConsumer 對象負責將 stream 中分隔後的數據放入上一步創建的容器中    // 2.3 BiConsumer 對象負責將分隔的容器中的數據合併起來    List&lt;String&gt; resultList2 = dataList.parallelStream().collect(            ArrayList::new,            (list, data) -&gt; list.add(data.substring(0,1).toUpperCase().concat(data.substring(1))),            (list1,list2) -&gt; list1.addAll(list2));    resultList2.forEach(System.out::println);}</code></pre><pre><code>new supplierJohnKainMikeMilkKavJohnKainMikeMilkKav</code></pre><h1 class=pgc-h-arrow-right>2.2 collect 方法接口參數為 Collector 對象實現</h1><p style=text-align:start>在 Collector 對象實現中主要包括如下 5 個接口對象</p><ol start=1><li>Supplier 對象負責創建容器對象，以便容納 stream 中分隔後的數據，這裡使用 List&lt;Integer> 作為數據的容器對象</li><li>accumulator 對象負責將 stream 中分隔後的數據放入上一步創建的容器中</li><li>combiner 對象負責將分隔的容器中的數據合併起來</li><li>finisher 對象負責將最終返回的結果進行最終的處理</li><li>characteristics 負責 Collector 執行效率的優化，具體要根據是否使用了 parallelStream 以及 數據是否有順序，不會影響最終的執行結果</li></ol><h1 class=pgc-h-arrow-right>2.3 collect 方法接口參數為 Supplier， BiConsumer， BiConsumer 三個對象實現</h1><p style=text-align:start>Supplier， BiConsumer， BiConsumer 三個對象的功能如下</p><ol start=1><li>Supplier 對象負責創建容器對象，以便容納 stream 中分隔後的數據，這裡使用 List&lt;Integer> 作為數據的容器對象</li><li>BiConsumer 對象負責將 stream 中分隔後的數據放入上一步創建的容器中</li><li>BiConsumer 對象負責將分隔的容器中的數據合併起來</li></ol><h1 class=pgc-h-arrow-right>2.4 Characteristics 枚舉</h1><p style=text-align:start>在接口參數為 Collector 對象實現中有一個 characteristics 方法，返回的是一個 Set 集合，負責 Collector 執行效率的優化，具體要根據是否使用了 parallelStream 以及數據是否有順序，最終不會影響執行結果。</p><p style=text-align:start>具體內容為 Collector 接口中定義的 Characteristics 泛型，具體如下</p><pre><code>enum Characteristics {    // 如果使用 parallelStream，characteristics 方法返回的 set 集合中可以加上這個枚舉    CONCURRENT,    // 如果流中的數據是沒有順序的，也可以加上這個枚舉    UNORDERED,    // 加上這個表示 finisher 方法中的參數和返回值完全一致，finisher 方法不會執行了    IDENTITY_FINISH}</code></pre><h1 class=pgc-h-arrow-right>2.5 parallelStream 線程安全問題</h1><ul><li>其中上面的兩個例子中都使用了 parallelStream，並且使用了 collect 方法</li><li>parallelStream 可以提高數據處理效率，具體是通過將流中的數據分隔成若干端後再並行處理最後將結果合併</li><li>如果不使用 collect 方法會發生什麼情況，會不會出現線程安全問題？</li></ul><p style=text-align:start>先看下面這個例子</p><pre><code>private static Lock lock = new ReentrantLock();@Testpublic void test_unsafe() {    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();    List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();    List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();    // 串行    IntStream.range(0, 10000).forEach(list1::add);    // 並行    IntStream.range(0, 10000).parallel().forEach(list2::add);    // 並行加鎖    IntStream.range(0, 10000).parallel().forEach(i -&gt; {        lock.lock();        try {            list3.add(i);        } finally {            lock.unlock();        }    });    System.out.println(String.format("串行執行的大小：%s", list1.size()));    System.out.println(String.format("有線程安全的並行問題大小：%s", list2.size()));    System.out.println(String.format("並行加鎖：%s", list1.size()));}</code></pre><p style=text-align:start>執行結果如下，可見在 parallelStream 中會出現線程安全問題，雖然通過鎖可以避免線程安全問題，但是會降低程序處理效率，從而影響系統的吞吐率。</p><pre><code>串行執行的大小：10000有線程安全的並行問題大小：7351並行加鎖：10000</code></pre><p style=text-align:start>正確的解決的方法就是通過 collect 方法和 Collector 接口，具體如下</p><pre><code>@Testpublic void test_safe() {    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();    // 串行    IntStream.range(0, 10000).forEach(list1::add);    // 通過 collect 接口解決併發問題    // 1. Supplier 對象負責創建容器對象，以便容納 stream 中分隔後的數據，這裡使用 List&lt;Integer&gt; 作為數據的容器對象    // 2. ObjIntConsumer 對象負責將 stream 中分隔後的數據放入上一步創建的容器中    // 3. BiConsumer 對象負責將分隔的容器中的數據合併起來    List&lt;Integer&gt; dataList = IntStream.range(0, 10000).parallel().collect(new Supplier&lt;List&lt;Integer&gt;&gt;() {        @Override        public List&lt;Integer&gt; get() {            System.out.println("new Supplier");            return new ArrayList&lt;&gt;();        }    }, new ObjIntConsumer&lt;List&lt;Integer&gt;&gt;() {        @Override        public void accept(List&lt;Integer&gt; dataList, int value) {            dataList.add(value);        }    }, new BiConsumer&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt;() {        @Override        public void accept(List&lt;Integer&gt; dataList1, List&lt;Integer&gt; dataList2) {            System.out.println("merge result");            dataList1.addAll(dataList2);        }    });    List&lt;Integer&gt; dataList1 = IntStream.range(0, 10000).collect(ArrayList::new, (list, i) -&gt; list.add(i), (lista, listb) -&gt; lista.addAll(listb));    List&lt;Integer&gt; dataList2 = IntStream.range(0, 10000).parallel().collect(ArrayList::new, (list, i) -&gt; list.add(i), (lista, listb) -&gt; lista.addAll(listb));    System.out.println(String.format("串行執行的大小：%s", list1.size()));    System.out.println(String.format("線程安全的並行大小：%s", dataList.size()));    System.out.println(String.format("線程安全的並行大小：%s", dataList1.size()));    System.out.println(String.format("線程安全的並行大小：%s", dataList2.size()));}</code></pre><ul><li>通過 collect 方法解決併發問題</li></ul><ol start=1><li>Supplier 對象負責創建容器對象，以便容納 stream 中分隔後的數據，這裡使用 List&lt;Integer> 作為數據的容器對象</li><li>ObjIntConsumer 對象負責將 stream 中分隔後的數據放入上一步創建的容器中</li><li>BiConsumer 對象負責將分隔的容器中的數據合併起來</li></ol><h1 class=pgc-h-arrow-right>3 Collectors 工具類介紹以及使用</h1><p style=text-align:start>在上面的例子中都使用了 collect 方法以及自行實現了 Collector 接口。有沒有 jdk 已經實現好的 Collector 接口呢？</p><h1 class=pgc-h-arrow-right>3.1 Collectors 工具類方法介紹</h1><p style=text-align:start>答案是有的，就是這裡將要介紹的 Collectors 工具類：java.util.stream.Collectors，完整的方法如下：</p><div class=pgc-img><img alt="深入介紹和使用 Java 8 的 Collector 接口和 Collectors 工具類" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6697a1bda5a747fc89be172989891078><p class=pgc-img-caption></p></div><p style=text-align:start>下面來簡要介紹一下，不談具體的參數，返回類型都是 Collector 接口對象，具體如下</p><ol start=1><li>toCollection，toList，toSet：處理並將結果返回成集合對象</li><li>joining：處理並將結果返回成字符串</li><li>mapping：首先將流中的元素從 T 轉成 U，然後再將含有 U 的流轉給 downstream 繼續處理</li><li>collectingAndThen：首先將流傳給 downstream 處理，然後將 downstream 中的 R 轉成 RR，最後的結果為 RR</li><li>counting：求流中元素的總數，類型為 Long</li><li>minBy: 求流中最小的元素</li><li>maxBy：求流中最大的元素</li><li>summingInt，summingLong，summingDouble：求流中元素之和，和的類型分別是 int, long, double 類型</li><li>averagingInt，averagingLong，averagingDouble：求流中元素的平均數，平均數的類型分別是 int, long, double 類型</li><li>reducing：減少流中的元素</li><li>groupingBy：將流中的元素分組處理</li><li>groupingByConcurrent：以並行的方式將流中的元素分組處理</li><li>partitioningBy：將流中的元素分區處理</li><li>toMap, toConcurrentMap：處理並將結果返回成 Map 對象</li><li>summarizingInt，summarizingLong，summarizingDouble：彙總流中的元素，彙總後的類型分別是 IntSummaryStatistics, LongSummaryStatistics, DoubleSummaryStatistics</li></ol><h1 class=pgc-h-arrow-right>3.2 Collectors 工具類使用</h1><p style=text-align:start>下面來介紹上面的 15 中方法具體使用</p><ul><li>增加 Student 實體如下</li></ul><pre><code>import org.apache.commons.lang3.builder.ToStringBuilder;public class Student {    private int age;//年齡    private String name;//姓名    private String enName;// 英文 姓名    private char gender;//性別，0未知，1男，2女    private double credit; // 學分    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getEnName() {        return enName;    }    public void setEnName(String enName) {        this.enName = enName;    }    public char getGender() {        return gender;    }    public void setGender(char gender) {        this.gender = gender;    }    public double getCredit() {        return credit;    }    public void setCredit(double credit) {        this.credit = credit;    }    public Student(int age, String name, String enName, char gender, double credit) {        this.age = age;        this.name = name;        this.enName = enName;        this.gender = gender;        this.credit = credit;    }    @Override    public String toString() {        return new ToStringBuilder(this)                .append("age", age)                .append("name", name)                .append("enName", enName)                .append("gender", gender)                .append("credit", credit)                .toString();    }    public Student() {    }}</code></pre><ul><li>具體的測試如下</li></ul><pre><code>import org.junit.After;import org.junit.Before;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.math.BigDecimal;import java.util.*;import java.util.stream.Collectors;public class TestCollectorsApi {    private static final Logger logger = LoggerFactory.getLogger(TestCollectorsApi.class);    private static List&lt;Student&gt; userList = new ArrayList&lt;&gt;();    /**     * 初始化 Student 集合     */    @Before    public void initEveryTestBefore() {        userList.add(new Student(22, "王旭", "wang.xu", '1', 4));        userList.add(new Student(21, "孫萍", "sun.ping", '2', 3.6));        userList.add(new Student(23, "步傳宇", "bu.zhuan.yu", '0', 4.1));        userList.add(new Student(18, "蔡明浩", "cai.ming.hao", '1', 3.5));        userList.add(new Student(17, "郭林傑", "guo.lin.jie", '1', 3.4));        userList.add(new Student(29, "韓凱", "han.kai", '0', 4));        userList.add(new Student(22, "韓天琪", "han.tian.qi", '1', 4));        userList.add(new Student(21, "郝瑋", "hao.wei", '2', 3.9));        userList.add(new Student(19, "胡亞強", "hu.ya.qing", '1', 3.5));        userList.add(new Student(14, "季愷", "ji.kai", '2', 4.2));        userList.add(new Student(17, "荊帥", "jing.shuai", '1', 4.1));        userList.add(new Student(16, "姜有琪", "jiang.you.qi", '1', 2.5));        logger.info("initEveryTestBefore, size {}", userList.size());    }    /**     * 測試結束，清理數據     */    @After    public void destroyEveryTestAfter() {        logger.info("destroyEveryTestAfter, size {}", userList.size());        userList.clear();    }    @Test    public void toList() {        // 按照學分排序        userList = userList                .stream()                .sorted(Comparator.comparing(Student::getCredit))                .collect(Collectors.toList());        // 打印數據        userList.forEach(t -&gt; logger.info(t.toString()));    }    @Test    public void joining() {        // 將學生姓名合併成以,分隔的字符串        String names = userList                .stream()                .map(Student::getName)                .collect(Collectors.joining(","));        // 打印數據        System.out.println(names);    }    @Test    public void mapping() {        // 將學生姓名合併成以,分隔的字符串        String names = userList                .stream()                .collect(Collectors.mapping(Student::getName, Collectors.joining(",")));        // 打印數據        System.out.println(names);    }    @Test    public void collectingAndThen() {        // 將學生姓名合併成以,分隔的字符串, 再通過 Function 對象將字符串轉成 String[] 對象        String[] nameArr = userList                .stream()                .map(Student::getName)                .collect(Collectors.collectingAndThen(Collectors.joining(","), data -&gt; data.split(",")));        // 打印數據        for (int i = 0; i &lt; nameArr.length; i++) {            System.out.println(nameArr[i]);        }    }    @Test    public void counting() {        // 將學生姓名合併成以,分隔的字符串, 再通過 Function 對象將字符串轉成 String[] 對象        Long count = userList                .stream()                .filter(student -&gt; student.getCredit() &gt; 4)                .collect(Collectors.counting());        // 打印數據        System.out.println(String.format("學分大於 4 的學生人數為:%s", count));    }    @Test    public void minBy() {        // 先去重，然後獲取學分最小的學生        Optional&lt;Student&gt; student = userList                            .stream()                            .distinct()                            .collect(Collectors.minBy((stu1, stu2) -&gt; BigDecimal.valueOf(stu1.getCredit()).compareTo(BigDecimal.valueOf(stu2.getCredit()))));        // 打印數據        System.out.println(String.format("學分最小的學生:%s", student.get().toString()));    }    @Test    public void maxBy() {        // 先去重，然後獲取學分最大的學生        // 使用 Comparator.comparing        Optional&lt;Student&gt; student = userList                .stream()                .distinct()                .collect(Collectors.maxBy(Comparator.comparing(Student::getCredit)));        // 打印數據        System.out.println(String.format("學分最大的學生:%s", student.get().toString()));    }    @Test    public void summingDouble() {        double total = userList                .stream()                .distinct()                .collect(Collectors.summingDouble(Student::getCredit));        // 打印數據        System.out.println(String.format("學分總計:%s", total));    }    @Test    public void averagingDouble() {        double average = userList                .stream()                .distinct()                .collect(Collectors.averagingDouble(Student::getCredit));        // 打印數據        System.out.println(String.format("學分平均:%s", average));    }    @Test    public void reducing() {        // 1 返回學分最大的學生        // reducing 第一個參數 T identity 表示最終的返回類型或者結果的容器        Student studentMax = userList                .stream()                .collect(Collectors.reducing(new Student(), (stu1, stu2) -&gt; stu1.getCredit() &gt; stu2.getCredit() ? stu1 : stu2));        // 打印數據        System.out.println(String.format("返回學分最大的學生:%s", studentMax));        // 2 返回學分最大的學生，不需要指定 返回類型或者結果的容器        Optional&lt;Student&gt; studentMin = userList                .stream()                .collect(Collectors.reducing((stu1, stu2) -&gt; stu1.getCredit() &gt; stu2.getCredit() ? stu1 : stu2));        // 打印數據        System.out.println(String.format("返回學分最大的學生:%s", studentMin.get().toString()));        // 3 所有學生的學分之和        BigDecimal total = BigDecimal.ZERO;        BigDecimal totalCredit = userList                .stream()                .collect(Collectors.reducing(total, stu -&gt; total.add(BigDecimal.valueOf(stu.getCredit())), (data1, data2) -&gt; data1.add(data2)));        // 打印數據        System.out.println(String.format("所有學生的學分之和:%s", totalCredit));    }    @Test    public void groupingBy() {        // 按照性別分組        Map&lt;Character, List&lt;Student&gt;&gt; dataMap = userList                .stream()                .collect(Collectors.groupingBy(Student::getGender));        // 打印數據        dataMap.forEach((k,v) -&gt; {            System.out.println(String.format("性別：%s", k));            v.forEach(System.out::println);            System.out.println("---------------------------");        });    }    @Test    public void groupingByConcurrent() {        // 按照性別分組        Map&lt;Character, List&lt;Student&gt;&gt; dataMap = userList                .stream()                .collect(Collectors.groupingByConcurrent(Student::getGender));        // 打印數據        dataMap.forEach((k,v) -&gt; {            System.out.println(String.format("性別：%s", k));            v.forEach(System.out::println);            System.out.println("---------------------------");        });    }    @Test    public void partitioningBy() {        // 按照學分是否大於 4 分組        Map&lt;Boolean, List&lt;Student&gt;&gt; dataMap = userList                .stream()                .collect(Collectors.partitioningBy(stu -&gt; stu.getCredit() &gt; 4));        // 打印數據        dataMap.forEach((k,v) -&gt; {            System.out.println(k ? "學分大於4：" : "學分小於4：");            v.forEach(System.out::println);            System.out.println("---------------------------");        });    }    @Test    public void toMap() {        // 將數據轉成 Map        Map&lt;String, Double&gt; dataMap = userList                .stream()                .collect(Collectors.toMap(stu -&gt; stu.getName(), stu -&gt; stu.getCredit()));        // 打印數據        dataMap.forEach((k,v) -&gt; {            System.out.println(String.format("姓名：%s， 學分：%s:", k, v));        });    }    @Test    public void summarizingDouble() {        // 數據統計        DoubleSummaryStatistics doubleSummaryStatistics = userList                .stream()                .distinct()                .collect(Collectors.summarizingDouble(Student::getCredit));        System.out.println(String.format("學生總數：%s", doubleSummaryStatistics.getCount()));        System.out.println(String.format("所有學生的平均學分：%s", doubleSummaryStatistics.getAverage()));        System.out.println(String.format("最高學分：%s", doubleSummaryStatistics.getMax()));        System.out.println(String.format("最低學分：%s", doubleSummaryStatistics.getMin()));        System.out.println(String.format("學分總和：%s", doubleSummaryStatistics.getSum()));    }}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>介紹</a></li><li><a>Java</a></li><li><a>Collector</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/4adca96d.html alt=不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532917894689e20edadba9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4adca96d.html title=不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹>不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b11a0727.html alt=今天介紹的電纜型號是：RVVP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/db5ce8c1-b1ad-424b-a931-d371d5aad449 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b11a0727.html title=今天介紹的電纜型號是：RVVP>今天介紹的電纜型號是：RVVP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c932f22.html alt=策略梯度的簡明介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1527998215130569eb83799 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c932f22.html title=策略梯度的簡明介紹>策略梯度的簡明介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c99d724e.html alt=給大家介紹幾種常見的齒輪，學機械的收藏了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/b864f3ca-e8bf-47f4-a940-027e7a96e4a5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c99d724e.html title=給大家介紹幾種常見的齒輪，學機械的收藏了>給大家介紹幾種常見的齒輪，學機械的收藏了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37860fee.html alt=「小恩學堂」壁掛爐核心部件介紹第4期——循環水泵 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e7a000263651c843347 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37860fee.html title=「小恩學堂」壁掛爐核心部件介紹第4期——循環水泵>「小恩學堂」壁掛爐核心部件介紹第4期——循環水泵</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a14a021d.html alt=火力發電廠主要設備及其作用介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a14a021d.html title=火力發電廠主要設備及其作用介紹>火力發電廠主要設備及其作用介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82ec221c.html alt="向三歲孩子介紹地球系列之一 - 天空，大地，水元素分類遊戲" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5e731406b21a45718433a22396b5282b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82ec221c.html title="向三歲孩子介紹地球系列之一 - 天空，大地，水元素分類遊戲">向三歲孩子介紹地球系列之一 - 天空，大地，水元素分類遊戲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4dce8a5a.html alt=庫爾勒景區介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/70872229-1b85-4bda-b208-afc6881ea16b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4dce8a5a.html title=庫爾勒景區介紹>庫爾勒景區介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>