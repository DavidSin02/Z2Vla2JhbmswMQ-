<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面向對象設計模式知識梳理 | 极客快訊</title><meta property="og:title" content="面向對象設計模式知識梳理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82533bc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="面向對象設計模式知識梳理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/82533bc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面向對象設計模式知識梳理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>一、設計模式概念： 設計模式（Design pattern）是一套被反覆使用、多數人知曉的、經過分類編目的、代碼設計經驗的總結。使用設計模式是為了可重用代碼、讓代碼更容易被他人理解、保證代碼可靠性。設計模式是一種用於不斷對軟件系統不斷重複設計問題的解決方案進行文檔化的技術，也是一種共享專家設計經驗的技術。（Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a partcular context.）二、設計模式的原則：我們為什麼要用設計模式呢？這麼多設計模式為什麼要這麼設計呢？ 為什麼要提倡"Design Pattern"呢？根本原因是為了代碼複用，增加可維護性。那麼怎麼才能實現代碼複用呢？OO界有前輩的幾個原則："開－閉"原則(Open Closed Principal)、里氏代換原則、合成複用原則。設計模式就是實現了這些原則，從而達到了代碼複用、增加可維護性的目的。</p><p><strong>1、"開－閉"原則（Open-Closed Principle）OCP</strong></p><p>此原則是由"Bertrand Meyer"提出的。原文是："Software entities should be open for extension,but closed for modification"。就是說模塊應對擴展開放，而對修改關閉。模塊應儘量在不修改原(是"原"，指原來的代碼)代碼的情況下進行擴展。那麼怎麼擴 展呢？我們看工廠模式"factory pattern":假設中關村有一個賣盜版盤和禁片的小子，我們給他設計一"光盤銷售管理軟件"。我們應該先設計一"光盤"接口。而盜版盤是其子類。小子通過"DiscFactory"來管理這些光盤。代碼為：public class DiscFactory{ public static 光盤 getDisc(String name){ return (光盤)Class.forName(name).getInstance(); } } 有人要買盜版盤，怎麼實現呢？public class 小子{ public static void main(String[] args){ 光盤 d=DiscFactory.getDisc("盜版盤"); 光盤.賣(); } }</p><p>如果有一天，這小子良心發現了，開始賣正版軟件。沒關係，我們只要再創建一個"光盤"的子類"正版軟件"就可以了。不需要修改原結構和代碼。對擴展開發，對修改關閉。"開-閉原則" 工廠模式是對具體產品進行擴展，有的項目可能需要更多的擴展性，要對這個"工廠"也進行擴展，那就成了"抽象工廠模式"。</p><p><strong>2、里氏代換原則（Liskov Substitution Principle）LSP</strong></p><p>里氏代換原則是由"Barbara Liskov"提出的。如果調用的是父類的話，那麼換成子類也完全可以運行。比如：</p><p>　　　　光盤 d=new 盜版盤();</p><p>　　　　d.賣();</p><p>現在要將"盜版盤"類改為"禁片"類，沒問題，完全可以運行。Java編譯程序會檢查程序是否符合里氏代換原則。子類 overload方法的訪問權限不能小於父類對應方法的訪問權限。比如"光盤"中的方法"賣"訪問權限是"public"，那麼"盜版盤"和"禁片"中的 "賣"方法就不能是package或private，編譯不能通過。為什麼要這樣呢？你想啊：如果"盜版盤"的"賣"方法是private。那麼下面這段 代碼就不能執行了：</p><p>　　　　光盤 d=new 盜版盤();</p><p>d.賣();</p><p>可以說：里氏代換原則是繼承複用的一個基礎。</p><p><strong>3、合成複用原則(Composite Reuse Principle)CRP</strong></p><p>就是說要少用繼承，多用合成關係來實現。一段程序：有幾個類要與數據庫打交道，就寫了一個數據庫操作的類，然後別的跟數據庫打交道的類都繼承這個。結果，修改了數據庫操作類的一個方法，各個類都需要改動。"牽一髮而動全身"!面向對象是要把波動限制在儘量小的範圍。</p><p>在Java中，應儘量針對Interface編程，而非實現類。這樣，更換子類不會影響調用它方法的代碼。要讓各個類儘可能少的跟別人聯繫，"不要與陌生人說話"。這樣，城門失火，才不至於殃及池魚。擴展性和維護性才能提高</p><p>理解了這些原則，再看設計模式，只是在具體問題上怎麼實現這些原則而已。張無忌學太極拳，忘記了所有招式，打倒了"玄冥二老"，所謂"心中無招"。設計模 式可謂招數，如果先學通了各種模式，又忘掉了所有模式而隨心所欲，可謂OO之最高境界。呵呵</p><p><strong>4 依賴倒轉原則（Dependency Inversion Principle）DIP</strong></p><p>抽象不應該依賴與細節，細節應當依賴與抽象。</p><p>要針對接口編程，而不是針對實現編程。</p><p>傳遞參數，或者在組合聚合關係中，儘量引用層次高的類。</p><p>主要是在構造對象時可以動態的創建各種具體對象，當然如果一些具體類比較穩定，就不必在弄一個抽象類做它的父類，這樣有畫蛇添足的感覺</p><p><strong>5 接口隔離原則（Interface Segregation Principle）ISP</strong></p><p>定製服務的例子，每一個接口應該是一種角色，不多不少，不幹不該乾的事，該乾的事都要幹</p><p><strong>6 抽象類</strong></p><p>抽象類不會有實例，一般作為父類為子類繼承，一般包含這個系的共同屬性和方法。</p><p>注意：好的繼承關係中，只有葉節點是具體類，其他節點應該都是抽象類，也就是說具體類</p><p>是不被繼承的。將儘可能多的共同代碼放到抽象類中。</p><p><strong>7 迪米特法則(LoD)</strong></p><p>每一個軟件單位對其他的單位都只有最少知識，而且侷限於那些與本單位密切相關的軟件單位。不要和陌生人說話。</p><p>三、一個設計模式的四個基本要素</p><p>設計模式使人們可以更加簡單方便地複用成功的設計和體系結構。設計模式一般包含模式名稱、問題、目的、解決方案、效果、實例代碼和相關設計模式等基本要素。</p><p>1. 模式名稱（pattern name）</p><p>通過一兩個詞來描述模式的問題、解決方案和效果，以便用戶更好地理解模式並方便與開發人員交流。絕大多數模式都是根據其功能或模式結構來命名的。命名一個新的模式增加了我們的設計詞彙。設計模式允許我們在較高的抽象層次上進行設計。基於 一個模式詞彙表，我們自己以及同事之間就可以討論模式並在編寫文檔時使用它們。模式名可以幫助我們思考，便於我們與其他人交流設計思想及設計結果。找到恰 當的模式名也是我們設計模式編目工作的難點之一。</p><p>2. 問題(problem)</p><p>描述了應該在何時使用模式，包含了原始設計中存在的問題以及問題存在的原因。它解釋了設計問題和問題存在的前因後果，它可能描述了特定的設計問題，如怎樣用對象表示算法等。也可能描述了導致不靈活設計的類或對象結構。有時候，問題部分會包括使用模式必須滿足的一系列先決條件。在對問題進行描述的同時實際上確定了模式所對應的使用環境以及模式的使用動機。</p><p>3. 解決方案(solution)</p><p>描述了設計的組成成分，它們之間的相互關係及各自的職責和協作方式。因為模式是一個通用模板，可應用於多種不同場合，解決方案並不描述一個特定而具體的 設計或實現，而是提供設計問題的抽象描述和怎樣用一個具有一般意義的元素組合（類或對象組合）來解決這個問題。</p><p>4. 效果(consequences)</p><p>描述了模式應用的效果及使用模式應權衡的問題。效果主要包含模式的優缺點分析，沒有一個解決方案是百分百完美的，在使用設計模式是需要進行合理的評價和選擇。儘管我們描述設計決策時，並不總提到模式效果，但它們對於評價設計選擇和理解使用模式的代價及好處具有重要意義。軟件效果大多關注對時間和空間的衡量，它們也表述了語言和實現問題。因為複用是面向對象設計的要素之一，所以模式效果包括它對系統的靈活性、擴充性或可移植性的影響，顯式地列出這些效果對理解和評價這些模式很有幫助。四、一些常見的設計模式（creational Pattern）創建型模式包含抽象工廠模式、建造者模式、工廠方法模式、原型模式和單利模式。</p><p><strong>Abstract Factory Pattern（抽象工廠模式）</strong>：提供一個創建一系列相關或相互依賴對象的接口，而無需指定它們具體的類。</p><p><strong>Builder Pattern（建造者模式）</strong>：將一個複雜對象的構建與它的表示分離，使得同樣的構建過程可以創建不同的表示。</p><p><strong>Factory Method Pattern（工廠方法模式）</strong>：定義一個用於創建對象的接口，讓子類決定將哪一個類實例化。Factory Method使一個類的實例化延遲到其子類。</p><p><strong>Prototype Pattern（原型模式）</strong>：用原型實例指定創建對象的種類，並且通過拷貝這個原型來創建新的對象。</p><p><strong>Singleton Pattern（單例模式）</strong>：保證一個類僅有一個實例，並提供一個訪問它的全局訪問點。 （Structural Pattern）結構型模式包含適配器模式、橋接模式、組合模式、裝飾模式、外觀模式、享元模式、代理模式。</p><p><strong>Adapter Pattern（適配器模式）</strong>：將一個類的接口轉換成客戶希望的另外一個接口。A d a p t e r模式使得原本由於接口不兼容而不能一起工作的那些類可以一起工作。</p><p><strong>Bridge Pattern（橋接模式）</strong>：將抽象部分與它的實現部分分離，使它們都可以獨立地變化。</p><p><strong>Composite Pattern（組合模式）</strong>：將對象組合成樹形結構以表示“部分-整體”的層次結構。它使得客戶對單個對象和複合對象的使用具有一致性。</p><p><strong>Decorator Pattern（裝飾模式）</strong>：動態地給一個對象添加一些額外的職責。就擴展功能而言， 它比生成子類方式更為靈活。</p><p><strong>Facade Pattern（外觀模式）</strong>：為子系統中的一組接口提供一個一致的界面， F a c a d e模式定義了一個高層接口，這個接口使得這一子系統更加容易使用。</p><p><strong>Flyweight Pattern（享元模式）</strong>：運用共享技術有效地支持大量細粒度的對象。</p><p><strong>Proxy Pattern（代理模式）</strong>：為其他對象提供一個代理以控制對這個對象的訪問。（Behavioral pattern）行為型模式包含 職責鏈模式、命令模式、解釋器模式、迭代器模式、中介者模式、備忘錄模式、觀察者模式、狀態模式、策略模式、模板方法模式、訪問者模式。</p><p><strong>Chain of Responsibility Pattern（職責鏈式模式）</strong>：為解除請求的發送者和接收者之間耦合，而使多個對象都有機會處理這個請求。將這些對象連成一條鏈，並沿著這條鏈傳遞該請求，直到有一個對象處理它。</p><p><strong>Command Pattern（命令模式）</strong>：將一個請求封裝為一個對象，從而使你可用不同的請求對客戶進行參數化；對請求排隊或記錄請求日誌，以及支持可取消的操作。</p><p><strong>Interpreter Pattern(解釋器模式)</strong>：給定一個語言, 定義它的文法的一種表示，並定義一個解釋器, 該解釋器使用該表示來解釋語言中的句子。</p><p><strong>Iterator Pattern（迭代器模式）</strong>：提供一種方法順序訪問一個聚合對象中各個元素, 而又不需暴露該對象的內部表示。</p><p><strong>Mediator Pattern（中介者模式）</strong>：用一箇中介對象來封裝一系列的對象交互。中介者使各對象不需要顯式地相互引用，從而使其耦合鬆散，而且可以獨立地改變它們之間的交互。</p><p><strong>Memento Pattern（備忘錄模式）</strong>：在不破壞封裝性的前提下，捕獲一個對象的內部狀態，並在該對象之外保存這個狀態。這樣以後就可將該對象恢復到保存的狀態。</p><p><strong>Observer Pattern（觀察者模式）</strong>：定義對象間的一種一對多的依賴關係,以便當一個對象的狀態發生改變時,所有依賴於它的對象都得到通知並自動刷新。</p><p><strong>State Pattern（狀態模式）</strong>：允許一個對象在其內部狀態改變時改變它的行為。對象看起來似乎修改了它所屬的類。</p><p><strong>Strategy Pattern（策略模式）</strong>：定義一系列的算法,把它們一個個封裝起來, 並且使它們可相互替換。本模式使得算法的變化可獨立於使用它的客戶。</p><p><strong>Template Method Pattern（模板方法模式）</strong>：定義一個操作中的算法的骨架，而將一些步驟延遲到子類中。Template Method使得子類可以不改變一個算法的結構即可重定義該算法的某些特定步驟。</p><p><strong>Visitor Pattern（訪問者模式）</strong>：表示一個作用於某對象結構中的各元素的操作。它使你可以在不改變各元素的類的前提下定義作用於這些元素的新操作。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>對象</a></li><li><a>設計</a></li><li><a>知識</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac978f8e.html alt=關於機械設計知識的20個問題專業解答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/20f3599b79df44b380f34c43c91c9afd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac978f8e.html title=關於機械設計知識的20個問題專業解答>關於機械設計知識的20個問題專業解答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html alt=面向對象設計原則之開閉原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ff63803ae3d4638b01095d32682fa70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html title=面向對象設計原則之開閉原則>面向對象設計原則之開閉原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html alt=面向對象設計的七大原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd44e43836e64ae3b2c4d6e9ffa9f033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html title=面向對象設計的七大原則>面向對象設計的七大原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3de28aba.html alt=收藏！隧道設計知識乾貨整理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2bd30e3675104ec7b8601d0051767a00 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3de28aba.html title=收藏！隧道設計知識乾貨整理>收藏！隧道設計知識乾貨整理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html alt=面向對象設計之依賴倒置原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html title=面向對象設計之依賴倒置原則>面向對象設計之依賴倒置原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html alt=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/93686fc2-2a36-4161-8664-03ae59f6e71e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html title=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺>面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html alt=C++面向對象設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c001c4074d3f4c658dfea942671f0ea6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html title=C++面向對象設計>C++面向對象設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html alt=Python面向對象設計和麵向對象編程解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html title=Python面向對象設計和麵向對象編程解析>Python面向對象設計和麵向對象編程解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html alt=什麼是“面向對象”程序設計-以Python為例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/12f1d2422ce145819ebe4973dcfa2b89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html title=什麼是“面向對象”程序設計-以Python為例>什麼是“面向對象”程序設計-以Python為例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3924ddd.html alt=軟考自查：面向對象設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8fc841fb0334a72ba00b8186b247534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3924ddd.html title=軟考自查：面向對象設計>軟考自查：面向對象設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c10ee1cd.html alt=關於面向對象程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c10ee1cd.html title=關於面向對象程序設計>關於面向對象程序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html alt=面向對象編程設計的類與對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/86e56bdd947940c4b06129e01f19706a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html title=面向對象編程設計的類與對象>面向對象編程設計的類與對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0663a3e1.html alt=面向對象設計的工作步驟一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/900239b473b34a7bb4a3a15a93f05bdc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0663a3e1.html title=面向對象設計的工作步驟一>面向對象設計的工作步驟一</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/864c3f59.html alt=C++面向對象程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b42379075324d628f329f2d6e793e4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/864c3f59.html title=C++面向對象程序設計>C++面向對象程序設計</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>