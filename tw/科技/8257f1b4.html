<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>程序員那些必須掌握的排序算法(上) | 极客快訊</title><meta property="og:title" content="程序員那些必須掌握的排序算法(上) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/c32d187d725f4bd59225a5d09a38cb37"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8257f1b4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8257f1b4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8257f1b4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8257f1b4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8257f1b4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8257f1b4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8257f1b4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8257f1b4.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="程序員那些必須掌握的排序算法(上)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8257f1b4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>程序員那些必須掌握的排序算法(上)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>現在的IT行業並不像以前那麼好混了，從業人員過多，導致初級程序員過剩，這也間接導致了公司的招聘門檻越來越高，要求程序員掌握的知識也越來越多。</p><p>算法也是一個爭論了很久的話題，程序員到底該不該掌握算法？不同的人有不同的答案，而事實上，很多公司都對算法有一定的要求，有些公司直接在面試的時候便會要求面試者手寫算法題。這就對程序員的技術要求產生了很大的考驗，所以面對如今的大環境，我們必須掌握算法，才能在今後的工作中佔據一席之地。</p><p>那麼接下來，我就簡單介紹一下幾個排序算法，希望對你們有所幫助。</p><h1>1.冒泡排序</h1><p>冒泡排序（Bubble Sort），是一種較簡單的排序算法。</p><p>它重複地走訪過要排序的元素列，依次比較兩個相鄰的元素，如果他們的順序（如從大到小、首字母從A到Z）錯誤就把他們交換過來。走訪元素的工作是重複地進行直到沒有相鄰元素需要交換，也就是說該元素列已經排序完成。</p><p>這個算法的名字由來是因為越大的元素會經由交換慢慢“浮”到數列的頂端（升序或降序排列），就如同碳酸飲料中二氧化碳的氣泡最終會上浮到頂端一樣，故名“冒泡排序”。</p><p><strong>演示：</strong></p><div class=pgc-img><img alt=程序員那些必須掌握的排序算法(上) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c32d187d725f4bd59225a5d09a38cb37><p class=pgc-img-caption></p></div><p><strong>代碼如下：</strong></p><pre>@Testpublic void bubbleSort() {	int[] arr = { 3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48 };	// 統計比較次數	int count = 0;	// 第一輪比較	for (int i = 0; i &lt; arr.length - 1; i++) {		// 第二輪比較		for (int j = 0; j &lt; arr.length - 1 - i; j++) {			if (arr[j] &gt; arr[j + 1]) {				// 交換位置				int temp = arr[j];				arr[j] = arr[j + 1];				arr[j + 1] = temp;			}			count++;		}	}	System.out.println(Arrays.toString(arr));	System.out.println("一共比較了:" + count + "次");}</pre><p><strong>運行結果：</strong></p><pre>[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]一共比較了:105次</pre><p>這段代碼相信大家都能夠寫出來，一般冒泡排序也就是這樣寫。但是這段程序有個缺點，就是當排序過程中已經將數組元素排序完成，但此時它仍然會去比較，這就做了無用功了，所以我們可以通過一個boolean變量來優化這段代，上面的程序中我們已經得出了比較次數為105次。</p><p><strong>優化代碼：</strong></p><pre>@Testpublic void bubbleSort() {	int[] arr = { 3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48 };	// 統計比較次數	int count = 0;	for (int i = 0; i &lt; arr.length - 1; i++) {		boolean flag = true;		for (int j = 0; j &lt; arr.length - 1 - i; j++) {			if (arr[j] &gt; arr[j + 1]) {				// 交換位置				int temp = arr[j];				arr[j] = arr[j + 1];				arr[j + 1] = temp;				flag = false;			}			count++;		}		if(flag) {			break;		}	}	System.out.println(Arrays.toString(arr));	System.out.println("一共比較了:" + count + "次");}</pre><p><strong>運行結果：</strong></p><pre>[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]一共比較了:95次</pre><p>我們首先在開始循環時定義了一個boolean變量為true，然後如果元素之間進行了交換，就將值置為false。所以，我們就可以通過這個boolean變量來判斷是否有元素進行了交換。如果boolean變量為true，則證明沒有元素進行交換，那麼久說明此時的數組元素已經完成排序，那麼跳出外層循環即可，否則就繼續排序。通過結果也可以看出，比較次數確實是減少了很多。</p><h1>2.選擇排序</h1><p>選擇排序（Selection sort）是一種簡單直觀的排序算法。它的工作原理是：第一次從待排序的數據元素中選出最小（或最大）的一個元素，存放在序列的起始位置，然後再從剩餘的未排序元素中尋找到最小（大）元素，然後放到已排序的序列的末尾。以此類推，直到全部待排序的數據元素的個數為零。選擇排序是不穩定的排序方法。</p><p><strong>演示：</strong></p><div class=pgc-img><img alt=程序員那些必須掌握的排序算法(上) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e8e4b404ba864e74bc9961c60d37f734><p class=pgc-img-caption></p></div><p><strong>代碼如下：</strong></p><pre>@Testpublic void SelectionSort() {	int[] arr = { 3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48 };	for (int i = 0; i &lt; arr.length - 1; i++) {		int index = i;		for (int j = 1 + i; j &lt; arr.length; j++) {			if (arr[j] &lt; arr[index]) {				index = j;// 保存最小元素的下標			}		}		// 此時已經找到最小元素的下標		// 將最小元素與前面的元素交換		int temp = arr[index];		arr[index] = arr[i];		arr[i] = temp;	}	System.out.println(Arrays.toString(arr));}</pre><p><strong>運行結果：</strong></p><pre>[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</pre><p>實現也非常的簡單，首先在外循環裡定義了一個index變量存儲i的值，這是為了避免重複地比較，因為在每一輪的比較結束後，前i個元素是已經排好序的，所以無需再次比較，只需從i開始即可。後面的比較都是基於index位置的元素進行比較，倘若比較完後index位置的元素是最小值，那就無需交換，不動即可。而如果找到了比index位置的元素更小的元素，那就將該元素的索引賦值給index，然後繼續比較，直到比較完成，比較完成之後得到的index即為數組中的最小值，那此時只需要將index位置的元素和i位置的元素交換即可。</p><h1>3.插入排序</h1><p>插入排序（Insertion sort）是一種簡單直觀且穩定的排序算法。如果有一個已經有序的數據序列，要求在這個已經排好的數據序列中插入一個數，但要求插入後此數據序列仍然有序，這個時候就要用到一種新的排序方法——插入排序法,插入排序的基本操作就是將一個數據插入到已經排好序的有序數據中，從而得到一個新的、個數加一的有序數據，算法適用於少量數據的排序，時間複雜度為O(n^2)。是穩定的排序方法。插入算法把要排序的數組分成兩部分：第一部分包含了這個數組的所有元素，但將最後一個元素除外（讓數組多一個空間才有插入的位置），而第二部分就只包含這一個元素（即待插入元素）。在第一部分排序完成後，再將這個最後元素插入到已排好序的第一部分中。</p><p>插入排序的基本思想是：每步將一個待排序的記錄，按其關鍵碼值的大小插入到前面已經排序的數組中的適當位置上，直到全部插入完為止。</p><p><strong>演示：</strong></p><div class=pgc-img><img alt=程序員那些必須掌握的排序算法(上) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/00b65feadee94221b816ad58430704c9><p class=pgc-img-caption></p></div><p><strong>代碼如下：</strong></p><pre>@Testpublic void InsertionSort() {	int[] arr = { 3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48 };	for (int i = 1; i &lt; arr.length; i++) {		// 定義待插入的數		int insertValue = arr[i];		// 找到待插入數的前一個數的下標		int insertIndex = i - 1;		while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; arr[insertIndex]) {			arr[insertIndex + 1] = arr[insertIndex];			insertIndex--;		}		arr[insertIndex + 1] = insertValue;	}	System.out.println(Arrays.toString(arr));}</pre><p><strong>運行結果：</strong></p><pre>[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</pre><p>那麼在這裡，因為數組元素我們並不確定，所以只能將數組的第一個元素看成是一個有序的序列，所以從數組的第二個元素開始才是我們需要去尋找插入位置的元素。所以外層循環從1開始，然後將arr[i]，也就是當前的第二個元素先保存起來，然後找到待插入元素的前一個元素下標，也就是i-1，此時通過一個while循環去比較。</p><p>當insertIndex小於0時應該退出循環，因為此時已經與前面的所有元素比較完畢。在比較的過程中，如果待插入元素小於前一個元素，就將前一個元素後移，也就是將前一個元素的值直接賦值給待插入元素位置。因為在最開始已經將待插入元素進行了保存，所以只需將待插入元素的值賦值給它的前一個元素即可。因為在while循環中insertIndex執行了自減操作，所以它的前一個元素下標應為insertIndex + 1。而如果待插入的元素值大於前一個元素，那麼就不會進入while循環，這樣insertIndex + 1之後的位置仍然是自己所在的位置，所以賦值後值不改變，後面的操作以此類推。</p><h1>4.希爾排序</h1><p>傳統的插入排序算法在某些場景中存在著一些問題，例如[2，3，4，5，1]這樣的一個數組，當我們對其進行插入排序的時候，發現要插入的數字是1，而要想將1插入到最前面，需要經過四個步驟，分別將5、4、3、2後移。所以得出結論：如果較小的數是我們需要進行插入的數，那效率就會比較低。鑑於這種場景的缺陷，希爾排序誕生了，它是插入排序的一種更高效的版本。</p><p><strong>先看看希爾排序的概念：</strong></p><p>希爾排序(Shell's Sort)是插入排序的一種又稱“縮小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一種更高效的改進版本。希爾排序是非穩定排序算法。該方法因D.L.Shell於1959年提出而得名。</p><p>希爾排序是把記錄按下標的一定增量分組，對每組使用直接插入排序算法排序；隨著增量逐漸減少，每組包含的關鍵詞越來越多，當增量減至1時，整個文件恰被分成一組，算法便終止。</p><p><strong>演示：</strong></p><div class=pgc-img><img alt=程序員那些必須掌握的排序算法(上) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6018a48cce284bbc9b96db2aebab0053><p class=pgc-img-caption></p></div><p>動畫如果沒有看懂，我這裡再貼幾張靜態圖：</p><div class=pgc-img><img alt=程序員那些必須掌握的排序算法(上) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/109cecc3afec4995866e8e245aae69e5><p class=pgc-img-caption></p></div><p><strong>代碼如下：</strong></p><pre>@Testpublic void ShellSort() {	int[] arr = { 3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48 };	for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) {		// 對數組元素進行分組		for (int i = gap; i &lt; arr.length; i++) {			// 遍歷各組中的元素			for (int j = i - gap; j &gt;= 0; j -= gap) {				// 交換元素				if (arr[j] &gt; arr[j + gap]) {					int temp = arr[j];					arr[j] = arr[j + gap];					arr[j + gap] = temp;				}			}		}	}	System.out.println(Arrays.toString(arr));}</pre><p><strong>運行結果：</strong></p><pre>[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</pre><p>那麼在上面的程序段中，數組長度為15，所以在第一輪，數組被分為了15 / 2 = 7個小組，然後分別對每個小組的元素進行遍歷。在第一輪中小組之間的元素間隔都為7，所以分成的小組數其實也就是元素之間的間隔。接著就可以對每個小組的元素進行比較，然後進行交換，接下來以此類推。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>必須</a></li><li><a>排序</a></li><li><a>算法</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html alt=深入淺出排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c898a3bab26542c2965d2bc5bebf9bd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html title=深入淺出排序算法>深入淺出排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html alt="算法 － 七大排序算法詳細介紹" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html title="算法 － 七大排序算法詳細介紹">算法 － 七大排序算法詳細介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html alt=算法之旅｜快速排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3b0e0000a716d98c3cba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html title=算法之旅｜快速排序法>算法之旅｜快速排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a35a8e8a.html alt=排序算法（1）——O(n^2) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/593b00001b3fdbe6409a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a35a8e8a.html title=排序算法（1）——O(n^2)>排序算法（1）——O(n^2)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f735cd3.html alt=網站建設中有哪些你必須要注意的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f735cd3.html title=網站建設中有哪些你必須要注意的？>網站建設中有哪些你必須要注意的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html alt=做跨境電商站外推廣，你必須瞭解的Facebook像素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2df772dcb2d747f8b55ff9e4610cbcad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html title=做跨境電商站外推廣，你必須瞭解的Facebook像素>做跨境電商站外推廣，你必須瞭解的Facebook像素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html alt=算法小專欄：散列表（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a831970b0ccf4e4cbe591777ebd3f2a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html title=算法小專欄：散列表（二）>算法小專欄：散列表（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f674acb.html alt=你必須掌握各種特殊體型的量體技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fded122d37c4048a34968909add59bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f674acb.html title=你必須掌握各種特殊體型的量體技巧>你必須掌握各種特殊體型的量體技巧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72ccb475.html alt=和勇士過招必須全程硬起來，一兩次防守錯誤就會讓你功虧一簣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/568c00032be28fed26f6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72ccb475.html title=和勇士過招必須全程硬起來，一兩次防守錯誤就會讓你功虧一簣>和勇士過招必須全程硬起來，一兩次防守錯誤就會讓你功虧一簣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32e171a3.html alt=5個必須學會的Excel求和公式，可直接套用，省時省力！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1535450928204b2d8afb96c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32e171a3.html title=5個必須學會的Excel求和公式，可直接套用，省時省力！>5個必須學會的Excel求和公式，可直接套用，省時省力！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html alt=七大查找算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html title=七大查找算法>七大查找算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html alt=掌握算法-散列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html title=掌握算法-散列>掌握算法-散列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3863b199.html alt=工業電工必須瞭解的知識—熱電阻和熱電偶 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dc44a9ef5dd843bba4cfa2ae5ea1ae4f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3863b199.html title=工業電工必須瞭解的知識—熱電阻和熱電偶>工業電工必須瞭解的知識—熱電阻和熱電偶</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/87f0e2f5.html alt=九鼎畫室：素描靜物你必須注意的畫面要點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fafd1a843a514b1cb19b1d3f216c5212 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/87f0e2f5.html title=九鼎畫室：素描靜物你必須注意的畫面要點>九鼎畫室：素描靜物你必須注意的畫面要點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48dc4266.html alt=這七種自我保護技巧，孩子必須學會，所以我還是用漫畫的形式！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4721000016364ca1215c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48dc4266.html title=這七種自我保護技巧，孩子必須學會，所以我還是用漫畫的形式！>這七種自我保護技巧，孩子必須學會，所以我還是用漫畫的形式！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>