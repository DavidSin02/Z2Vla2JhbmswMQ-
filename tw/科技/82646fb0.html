<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） | 极客快訊</title><meta property="og:title" content="C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d208ccdc7f074f67a257d52df74e4f48"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82646fb0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82646fb0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82646fb0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82646fb0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82646fb0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82646fb0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82646fb0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82646fb0.html><meta property="article:published_time" content="2020-11-14T20:59:47+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:47+08:00"><meta name=Keywords content><meta name=description content="C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/82646fb0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d208ccdc7f074f67a257d52df74e4f48><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>一、C語言程序的構成</strong></h1><p>與C++、Java相比，C語言其實很簡單，但卻非常重要。因為它是C++、Java的基礎。不把C語言基礎打紮實，很難成為程序員高手。</p><p><strong>1、C語言的結構</strong></p><p>先通過一個簡單的例子，把C語言的基礎打牢。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a6e698bac5be4ec19fcf26b267d1b4f3><p class=pgc-img-caption></p></div><p><br></p><p>C語言的結構要掌握以下幾點：</p><p>（1）C語言的註釋是/* ··· */，而不是//···，//是C++的單行註釋，有的C語言版本也認可。</p><p>（2）C語言區分大小寫，每句以分號結尾。</p><p>（3）C語言程序是從main函數開始的。函數的返回值如果缺省則為int，而不是void。</p><p>（4）函數必須用return來返回。即使void類型也不建議省略。</p><p>（5）使用函數時須包含相應的頭文件。自定義的頭文件用雙引號，C語言自身的頭文件用&lt;···></p><p><br></p><p><strong>2、main()函數的寫法與含義</strong></p><p>main()的參數和返回值全部省略，這和上例含義相同。省略寫法是一種很不好的習慣。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/11d4335b2b2046d781ab436b29dab92f><p class=pgc-img-caption></p></div><p><br></p><p>main()的參數是一種不限個數的寫法，argc代表參數的個數，真正的參數是放在argv[]數組裡面的。注意：當數組當參數用時，數組被降格為指針。初學者先照著樣子寫，以後小雅會詳細說明指針和數組的區別。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/128ce1f76d22417eac9a1796aef05e33><p class=pgc-img-caption></p></div><p><br></p><p><strong>3、頭文件的意義</strong></p><p>每個C程序通常分為兩個文件。一個文件用於保存程序的聲明（declaration），稱為頭文件。另一個文件用於保存程序的實現（implementation），稱為定義（definition）文件。</p><p>C程序的頭文件以“.h”為後綴，C 程序的定義文件以“.c”為後綴。</p><p>頭文件的內容也可以直接寫C程序中，但這是很不好的習慣。許多初學者用了頭文件，卻不明其理。在此略作說明。</p><p>（1）通過頭文件來調用庫功能。在很多場合，源代碼不便（或不準）向用戶公佈，只要向用戶提供頭文件和二進制的庫即可。用戶只需要按照頭文件中的接口聲明來調用庫功 能，而不必關心接口怎麼實現的。編譯器會從庫中提取相應的代碼。</p><p>（2）頭文件能加強類型安全檢查。如果某個接口被實現或被使用時，其方式與頭文件中 的聲明不一致，編譯器就會指出錯誤，這一簡單的規則能大大減輕程序員調試、改錯的 負擔。</p><p><br></p><p>關於頭文件的內容，初學者還必須注意。</p><p>（1）頭文件中可以和C程序一樣引用其它頭文件，可以寫預處理塊，但不能寫語句命令。</p><p>（2）可以申明函數，但不可以定義函數。</p><p>（3）可以申明常量，但不可以定義變量。</p><p>（4）可以“定義”一個宏函數。注意：宏函數很像函數，但卻不是函數。其實還是一個申明。</p><p>（5）結構的定義、自定義數據類型一般也放在頭文件中。</p><p>（6）#include &lt;filename.h>，編譯系統會到C語言固定目錄去引用。#include "filename.h"，系統一般首先在當前目錄查找，然後再去環境指定目錄查找。</p><p><strong>4、好的風格是成功的關鍵</strong></p><p>版本聲明、函數功能說明、註釋等是C語言程序的一部分。不養成很好的習慣則不能成為C語言高手（專業人員）。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b7cc97a921d04d998ad8e379dce5bf46><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>二、比較、邏輯、位運算符</h1><p>只有類型相同（或C語言能自動轉換）的表達式才能比較，如果類型不同就必須用函數轉換。例如：判斷一字符串的長度是否等於10，就要用strlen()將字符串的長度求出來變成了整型，才能和10比較。</p><p>比較運算符只有6個，即：等於(==)、不等於(!=)、大於(>)、小於(&lt;)、大於等於(>=)、小於等於(&lt;=)。比較運算符也叫關係運算符。</p><p>邏輯運算符只有3個，即：與AND(&&)、或OR(||)、非NOT(!)。</p><p>位運算符只有6個，即：與AND(&)、或OR(|)、非NOT(~)、異或XOR(^)、左移ShiftLeft(&lt;&lt;)、右移ShiftRight(>>)。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>三、數組</strong></h1><p>（1）數組名也是一變量名，定義時須指定類型和長度。</p><p>（2）長度可以方括號中直接指定，也可以通過賦值來間接指定。</p><p>（3）數組可以在定義時直接賦值，也可以定義時不賦值，之後再賦值。</p><p>（4）當使用超出範圍的值時，編譯不出錯，但運行會出錯。（上例運行時出錯後，選“忽略”後得到的結果）</p><p><strong>數組的地址</strong></p><p>弄清數組地址對使用數組有很大好處，另外，有的函數的參數是指針(如scanf函數)，如果要用數組的某一元素作參數，就必須知道其地址。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e64fa98e5fcb4095ae1706140fe755d4><p class=pgc-img-caption></p></div><p><br></p><p>1.數組iArr是int類型，所以它的地址是按4字節遞增。</p><p>2.數組cArr是char類型，所以它的地址是按1字節遞增。</p><p>3.數組元素的地址是通過數組元素前面加“&”來取得。(如：&iArr[3])</p><p>4.數組名單獨使用時，代表該數組的首地址。（iArr等同於&iArr[0]）(注意：以後使用指針會經常用到這一點)</p><p><br></p><h1 class=pgc-h-arrow-right>四、字符數組和字符串的重定義</h1><p>字符數組就是字符串嗎？有人說是，因為書上這麼寫，教師也這麼教的。小雅不敢說書上或教師們錯了，但至少可以說許多初學者都混淆了這兩個概念。因此，在這此將這2個概念再明確一下。</p><p>1.字符數組，完整地說叫字符類型的數組。字符數組不一定是字符串。</p><p>2.字符串是最後一個字符為NULL字符的字符數組。字符串一定是字符數組。</p><p>3.字符數組的長度是固定的，其中的任何一個字符都可以為NULL字符。</p><p>4.字符串只能以NULL結尾，其後的字符便不屬於該字符串。</p><p>5.strlen()等字符串函數對字符串完全適用，對不是字符串的字符數組不適用。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f3b8dced77ab4d19862c79953b5cade1><p class=pgc-img-caption></p></div><p><br></p><p>從上面例子看來，還要注意以下幾點：</p><p>（1）char sArr[] = "quanxue";這種方式，編譯時會自動在末尾增加一個NULL字符。</p><p>（2）NULL字符也就是'\0'，在ASCII表中排在第一個，用16進製表示為0x00。</p><p>（3）sizeof()運算符求的是字符數組的長度，而不是字符串長度。</p><p>（4）strlen()函數求的是字符串長度，而不是字符數組。它不適用於字符串以外的類型。</p><p>（5）char sArr[] = "quanxue";也可以寫成char sArr[8] = "quanxue";（注意：是8而不是7）</p><p><strong>字符數組和字符串數組的轉化</strong></p><p>字符數組中插入一個NULL字符，NULL字符前面（包括NULL字符）就成了字符串，一般NULL字符插在有效字符的最後。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/da2b6a2d594c44aa92039192172c07cd><p class=pgc-img-caption></p></div><p><br></p><p>數組的輸入輸出『gets()，puts()』</p><p>getchar()和putchar()函數是單個字符的輸入輸出，gets()和puts()是字符串的輸入輸出，也是標準函數，在stdio.h中被定義。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>五、指針</strong></h1><p><strong>指針符號『*』和地址符號『&』</strong></p><p>『&』符號是取變量的地址，『*』符號是取地址的內容(即：值)。兩個操作正好相反。例如：“&i”就是取變量i的地址，“*(&i)”就是取“&i”這個地址的值，其實就是變量i。既然如此，為什麼還要定義指針呢？原來，用『&』所取到的地址，自身只能用而不能修改。因此，直接把『&』取到的地址放到指針變量中去，既然指針變量也是變量，這個變量就可以任意存放其它地址。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/988b2e93675045038e6cda5547351935><p class=pgc-img-caption></p></div><p><br></p><p><strong>指針變量的賦值和指針的賦值</strong></p><p>上例中p是指針變量，*p是p的指針，p存放的是某個變量的地址，*p存放的是某個變量的值。當*p的內容改變時，p所指的變量的內容也發生改變，因為是同一個地址的存貯單元的值發生改變。同理，當p所指的變量的值發生改變時，*p的內容也隨之改變。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1993a7aec854bd784928bb59d538686><p class=pgc-img-caption></p></div><p><br></p><p><strong>被初始化的是指針變量還是指針</strong></p><p>上面2例，指針變量都是用的p，初學者不要認為只能用p，既然是變量，只要不違反命名規則都可以。當指針變量被定義時立即賦值，這時被賦值的是指針變量還是指針呢？下面這段程序請大家千萬注意！</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1aee0a9d5bc44f35b7c460376f2890f1><p class=pgc-img-caption></p></div><p><br></p><p>（1）charstr[] ="http://www.quanxue.cn/";中str是數組變量，當地址賦給point之後，point[11]就是str[11]，所以其內容可以改變。</p><p>（2）char*ptr ="http://www.51minge.com/";中賦值的性質和上面的str不同。這並不是將"http://www.51minge.com/"賦給*ptr指針，而是先定義一個常量"http://www.51minge.com/"，這個常量是定義在“棧”裡面，然後將這個常量的地址賦給ptr，而不是*ptr。常量是不能被修改的，因此ptr[13]也就出錯了。這是初學者經常犯的錯誤。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/32b096f8a4d74b5ea68faf139078a658><p class=pgc-img-caption></p></div><p><br></p><p><strong>不賦值的指針和NULL</strong></p><p>未賦值的指針變量是不能被使用的，其地址指向未不能使用的空間。建議定義時如果暫不使用，先賦NULL。為一個指針申請空間時，一定義要判斷其是否為空，因為分配內存失敗時返回NULL。不僅如此，甚至在使用指針時都應該判斷一下是否為空。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e209b6adced94eb38d322cbc4f69211f><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>六、指針、數組和字符串</strong></h1><p><strong>一、數組和指針的關係</strong></p><p>下面仍然是初學者容易搞錯的地方。指針變量加n或減n，並不是地址加n或減n，而是當前所指的地址向後或向前跳n次所指的地址。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d7e7322d2e624532aa28dce74ea06a2e><p class=pgc-img-caption></p></div><p><br></p><p>char型的指針數組相當於二維字符數組，並不等於說指針數組可以直接轉化為二維字符數組，相反字符數組可以直接轉化為指針數組。因為二維字符數組的地址是連續的，而指針數組所指的元素不一定連續（如下的m1、m2、m3的地址可以不連續，長度也可以不一樣）。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3d2151515d5e4211891cb79e3cfd4569><p class=pgc-img-caption></p></div><p><br></p><p><strong>三、指向指針的指針</strong></p><p>在第一章講main()函數的參數時，已經見過指針的指針，這和指針數組有相同的作用，但還是有細小的區別。指針數組可以在定義時直接初始化，而指向指針的指針不行。正如二維數組一樣，不指定第二維長度不能直接初始化一樣。即不能char str[][]={"...", "...", ...}</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9ff8de545b754a4ab026b8e0a5237d98><p class=pgc-img-caption></p></div><p><br></p><p><strong>四、指針的長度</strong></p><p>讓許多初學者遺憾的是，C語言沒有提供數組長度的函數，但可以用sizeof()運算符先求數組的總長度，再求出數組類型的長度，二者相除便得到數組的長度。C語言更大的一個遺憾便是，sizeof()對指針變量求值時，結果總是4，這是因為指針變量的內容是地址，地址總是4個字節來表示。</p><p>因此有經驗的編程人員，在用指針作參數時，一般總是同時多定義一個參數，來存放其長度。也就是指針和其長度同時傳遞過去。另外，數組長度如果事先知道，一般定義為常量。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c94a70e6bfdb4a0c95756f03e608519c><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>七、為指針動態分配內存</strong></h1><p>C語言程序員要嚴防內存洩漏，這個“內存洩漏”就是由動態內存分配引起的。指針是C語言和其它語言的最大區別，也是很多人不能跨入C語言的一道門檻。既然指針是這麼一個“危險”的壞東西，幹嗎不取消它呢？</p><p>其實指針本身並沒有好壞，它只是一種操作地址的方法，學會了便可以發揮其它語言難以匹敵的功能，沒學會的話，只能做其它語言的程序員，也同樣發揮你的光和熱。小雅本人也在C語言門外徘徊多年，至今仍屬於初學者。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/16f729f901dc4cc18f46c7b702f4b613><p class=pgc-img-caption></p></div><p><br></p><p><strong>一、變量和數組可以通過指針來轉換</strong></p><p>“int*x”中的x究竟是不是數組？光看這一句小雅無法告訴你，因為它既可表示單個變量內容，也可表示數組。下面是小雅專門為你準備的例子，理解之後，對動態分配時長度計算有好處。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7fcb9921a1fc4ef890a3fce98ce45fd1><p class=pgc-img-caption></p></div><p><br></p><p><strong>二、動態分配內存</strong></p><p>前面講到的指針，基本上將已經定義好的變量的地址賦給指針變量，現在要學的是向操作系統申請一塊新的內存。申請到的內存，必須在某個地方手動釋放，因此下面2個函數必須配對使用。malloc()和free()，都是標準函數，在stdlib.h中定義。</p><p>根據不同的電腦使用狀況，申請內存有可能失敗，失敗時返回NULL，因此，動態申請內存時，一定要判斷結果是否為空。malloc()的返回值類型是“void *”，因此，不要忘記類型轉換。（許多人都省略了。）</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/576f50ae3b3a42648110d1bdd42688d4><p class=pgc-img-caption></p></div><p><br></p><p><strong>三、隱蔽的內存洩漏</strong></p><p>內存洩漏主要有以下幾種情況：</p><p>（1）內存分配未成功，卻使用了它。</p><p>（2）內存分配雖然成功，但是尚未初始化就引用它。</p><p>（3）內存分配成功並且已經初始化，但操作越過了內存的邊界。</p><p>（4）忘記了釋放內存，造成內存洩露。</p><p>（5）釋放了內存卻繼續使用它。</p><p>下面的程序造成內存洩漏，想想錯在何處？如何修改？</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/027c87255bd841578abac5aaa9b946a0><p class=pgc-img-caption></p></div><p><br></p><p><strong>四、對動態內存的錯誤觀念</strong></p><p>有人對某一隻在函數內使用的指針動態分配了內存，用完後不釋放。其理由是：函數運行結束後，函數內的所有變量全部消亡。這是錯誤的。動態分配的內存是在“堆”裡定義，並不隨函數結束而消亡。</p><p>有人對某動態分配了內存的指針，用完後直接設置為NULL。其理由是：已經為NULL了，這就釋放了。這也是錯誤的。指針可以任意賦值，而內存並沒有釋放；相反，內存釋放後，指針也並不為NULL。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>八、return和exit、assert的區別</strong></h1><p>return語句是結束當前函數。而exit是結束main()函數，即整個程序，一般都是在遇到非常錯誤時才調用exit()。assert()是一個宏定義，在assert.h中申明，用來在DEBUG方式診斷程序，當參數中的條件不成立時，中斷main()函數。建議多多使用assert()。</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c9a58505d799437fbc4ede8b6384f15d><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>九、變量和函數</strong></h1><p>在函數之外定義的變量是全局變量，在函數內定義的變量是這個函數的局部變量。局部就是只能在當前函數內使用，而全局變量可以在任何一個函數中使用。</p><p>注意：一般而言，全局變量總是在所有函數之前定義，但如果某全局變量定義在兩個函數之間，則定義出後面的函數可以使用，而且前面函數不能使用。</p><p>有人說靜態變量相當於全局變量，這句話其實不對。全局變量變成靜態，就失去了靜態的意義，因此，靜態一般是加在局部變量上的。那麼，究竟什麼是靜態的局部變量呢？靜態變量隨函數的定義而定義，如果已經存在就延用，但並不隨函數的結束而消亡。在某一函數中定義的靜態局部變量，不能在其它函數使用。</p><p>當很多人編寫同一程序時，一般程序會被分割成幾個文件。當幾個人都定義了某一全局變量時，編譯時不出錯，Link時將出錯。解決這個問題的辦法：將其中一個定義原封不動，其餘的定義前加上extend（即外部的定義）。</p><p>剛才所說是許多書上說的，小雅做了n次試驗，證明上述編譯時也不錯，Link時也不錯，也就是說extend完全是多餘的。大概上面所說是幾十年前的版本吧。事實上與extend同列在一起的還有auto、regist等變量修飾符。auto是區別B語言的，早就沒用了，regist是將變量放到寄存器來運算，小雅認為基本沒有這種需要。</p><p>拆成多個文件，多次定義全局變量時要注意：</p><p>（1）變量的數據類型要一致。</p><p>（2）有長度的數組和沒定義長度的數組可以視為同一數據類型。</p><p>（3）數組和指針不能視為同一數據類型。</p><p><strong>文章就分享到這裡了，希望對大家有幫助！</strong></p><p>原文鏈接：https://www.cnblogs.com/lisuyun/p/3974066.html</p><hr><p>自學C/C++編程難度很大，不妨和一些志同道合的小夥伴一起學習成長！</p><p><strong>C語言C++編程學習交流圈子，關注+私信【C/C++編程】</strong>微信公眾號：C語言編程學習基地</p><p>有一些源碼和資料分享，歡迎轉行也學習編程的夥伴，和大家一起交流成長會比自己琢磨更快哦！</p><div class=pgc-img><img alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/44303aac541f495abae5974c0d3f7ce1><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編程</a></li><li><a>語言</a></li><li><a>C++</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html alt=CC++語言19｜靜態成員（對象共享數據成員及其成員函數） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html title=CC++語言19｜靜態成員（對象共享數據成員及其成員函數）>CC++語言19｜靜態成員（對象共享數據成員及其成員函數）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html alt=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3058ca03-deee-4287-a38c-9163687a0673 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html title=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上>C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f9a0ab8.html alt=P4語言編程詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b0509dc83f844c6e9e133d81e9855e4b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f9a0ab8.html title=P4語言編程詳解>P4語言編程詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a5a90058.html alt=C語言C++中assert的用法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/800dbdf4-3783-4992-8b82-525f32e81100 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a5a90058.html title=C語言C++中assert的用法>C語言C++中assert的用法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ba54309.html alt=C語言編程第19講——斷言的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/92ee4886-fdd7-4a4a-b45a-d647ef966836 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ba54309.html title=C語言編程第19講——斷言的使用>C語言編程第19講——斷言的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fb3d61e.html alt=C++編程自學寶典：如何編寫一個簡單的項目程序？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ec424c077c6a41d9a6de2b6c4c0c4954 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fb3d61e.html title=C++編程自學寶典：如何編寫一個簡單的項目程序？>C++編程自學寶典：如何編寫一個簡單的項目程序？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e551fdf0.html alt=C++｜深入理解編程中的字符編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2a9d352f7db7442987c04f2b54daf4f1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e551fdf0.html title=C++｜深入理解編程中的字符編碼>C++｜深入理解編程中的字符編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e7c6ad4.html alt=CC++語言15｜類的繼承和派生實現代碼重用、擴充 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4983def52247451589ab482f2921c1aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e7c6ad4.html title=CC++語言15｜類的繼承和派生實現代碼重用、擴充>CC++語言15｜類的繼承和派生實現代碼重用、擴充</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html alt=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/805329c3d3fc4c7aae35456efd84cd6c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html title=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板>C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04743eb6.html alt=C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/b35fbec7-2043-4f8f-b354-617f095d32cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04743eb6.html title=C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性>C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dd5b00b1.html alt=嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/40851dc497a8409bbff6a6aae1e42e8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dd5b00b1.html title=嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？>嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57af4069.html alt=C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1322941786864783877a7707ec15289f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57af4069.html title=C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？>C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2c14705.html alt=C語言編程知識總結，思維導圖版本，事半功倍！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/721353b3b68a41059d980e19083d03e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2c14705.html title=C語言編程知識總結，思維導圖版本，事半功倍！>C語言編程知識總結，思維導圖版本，事半功倍！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/293e60e3.html alt=Rust編程語言初探 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b47797c4e0b5476e86050d174aea893c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/293e60e3.html title=Rust編程語言初探>Rust編程語言初探</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>