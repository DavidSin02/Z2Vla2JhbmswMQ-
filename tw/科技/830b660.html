<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面向對象的程序設計原則之SOLID原則 | 极客快訊</title><meta property="og:title" content="面向對象的程序設計原則之SOLID原則 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1391fe67dc134aae92fef59ec541c40e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/830b660.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/830b660.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/830b660.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/830b660.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/830b660.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/830b660.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/830b660.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/830b660.html><meta property="article:published_time" content="2020-10-29T20:58:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:42+08:00"><meta name=Keywords content><meta name=description content="面向對象的程序設計原則之SOLID原則"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/830b660.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面向對象的程序設計原則之SOLID原則</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Ò<u>程序設計</u>領域， SOLID (單一功能、開閉原則、里氏替換、接口隔離以及依賴反轉)是由<u>羅伯特•C•馬丁</u>在21世紀早期 引入的<u>記憶術首字母縮略字</u>，指代了<u>面向對象編程</u>和<u>面向對象設計</u>的五個基本原則。當這些原則被一起應用時，它們使得一個<u>程序員</u>開發一個容易進行<u>軟件維護</u>和擴展的系統變得更加可能SOLID被典型的應用在<u>測試驅動開發</u>上，並且是<u>敏捷開發</u>以及<u>自適應軟件開發</u>的基本原則的重要組成部分。</p><p><br></p><p>S <u>單一功能原則</u> ：<u>單一功能原則</u> 認為<u>對象</u>應該僅具有一種單一功能的概念。</p><div class=pgc-img><img alt=面向對象的程序設計原則之SOLID原則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1391fe67dc134aae92fef59ec541c40e><p class=pgc-img-caption></p></div><p>O <u>開閉原則</u> ：<u>開閉原則</u> 認為“軟件體應該是對於擴展開放的，但是對於修改封閉的”的概念。</p><div class=pgc-img><img alt=面向對象的程序設計原則之SOLID原則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/908217fe652946dbbf547b6692b48257><p class=pgc-img-caption></p></div><p>L <u>里氏替換原則</u> ：<u>里氏替換原則</u> 認為“程序中的對象應該是可以在不改變程序正確性的前提下被它的子類所替換的”的概念。</p><div class=pgc-img><img alt=面向對象的程序設計原則之SOLID原則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e78543fd027d45f883301d384df2975e><p class=pgc-img-caption></p></div><p>I <u>接口隔離原則</u> ：<u>接口隔離原則</u> 認為“多個特定客戶端接口要好於一個寬泛用途的接口”的概念。</p><div class=pgc-img><img alt=面向對象的程序設計原則之SOLID原則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf5655cf22b34307957a7f2b03187a49><p class=pgc-img-caption></p></div><p>I <u>接口隔離原則</u> ：<u>接口隔離原則</u> 認為“多個特定客戶端接口要好於一個寬泛用途的接口”的概念。</p><div class=pgc-img><img alt=面向對象的程序設計原則之SOLID原則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/13e72537bc334a8f991ed45fb48310d3><p class=pgc-img-caption></p></div><p>D <u>依賴反轉原則</u>： <u>依賴反轉原則</u> 認為一個方法應該遵從“依賴於抽象而不是一個實例” 的概念。<u>依賴注入</u>是該原則的一種實現方式。</p><div class=pgc-img><img alt=面向對象的程序設計原則之SOLID原則 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/616b654c96c14f48a0ecb2d8b4360830><p class=pgc-img-caption></p></div><p>單一功能原則的討論</p><p><br></p><p>當需要修改某個類的時候原因有且只有一個（THERE SHOULD NEVER BE MORE THAN ONE REASON FOR A CLASS TO CHANGE）。換句話說就是讓一個類只做一種類型責任，當這個類需要承擔其他類型的責任的時候，就需要分解這個類。在所有的SOLID原則中，這是大多數開發人員感到最能完全理解的一條。嚴格來說，這也可能是違反最頻繁的一條原則了。</p><p>單一責任原則可以看作是低耦合、高內聚在面向對象原則上的引申，將責任定義為引起變化的原因，以提高內聚性來減少引起變化的原因。責任過多，可能引 起它變化的原因就越多，這將導致責任依賴，相互之間就產生影響，從而極大的損傷其內聚性和耦合度。單一責任，通常意味著單一的功能，因此不要為一個模塊實 現過多的功能點，以保證實體只有一個引起它變化的原因。</p><p><br></p><p>本原則的應用：</p><p><br></p><p>(1) Unix/Linux是這一原則的完美體現者。各個程序都獨立負責一個單一的事。</p><p><br></p><p>(2) Windows是這一原則的反面示例。幾乎所有的程序都交織耦合在一起。</p><p><br></p><p>(3) 另外舉個例子：報表的內容和報表的格式都會變化改變，但是這兩種變化的性質不同，一個是實質內在，一個是表面上的，SRP認為這是問題的兩個方面， 其實代表不同的責任，應該將它們分離放入不同的類或模塊中，而不應該放在一起，否則的話，因為不同原因發生變化，導致對方變動，比如報表格式變新的樣式， 這個變化是不應該涉及到內容的。</p><p><br></p><p>開閉原則的討論</p><p><br></p><p>(1) 軟件實體應該是可擴展，而不可修改的。也就是說，對擴展是開放的，而對修改是封閉的。這個原則是諸多面向對象編程原則中最抽象、最難理解的一個。</p><p>(2) 對擴展開放，意味著有新的需求或變化時，可以對現有代碼進行擴展，以適應新的情況。</p><p><br></p><p>(3) 對修改封閉，意味著類一旦設計完成，就可以獨立完成其工作，而不要對類進行任何修改。</p><p><br></p><p>(4) 可以使用變化和不變來說明：封裝不變部分，開放變化部分，一般使用接口繼承實現方式來實現“開放”應對變化，說大白話就是：你不是要變化嗎？，那麼我就讓你繼承實現一個對象，用一個接口來抽象你的職責，你變化越多，繼承實現的子類就越多。</p><p><br></p><p>(5) OCP的要點在於：作為開發人員，別人偶爾會向我們提供基類，偶爾也會為其他開發人員生成基類框架，供其使用。這些使用者應當僅能使用這些基類，但 不能對其進行修改。這一點是必要的，因為其他使用者也可能依賴於由基類提供的功能。如果允許使用者修改這些基類，可能會導致連鎖反應，不僅會影響到應用程 序中的各方面，還會影響到企業內的應用程序。還有一個問題，使用者有時可能會收到基類的升級版本。使用者在升級之前，必須找出一種方法用來處理其對該基類 先前版本中所做的自定義。</p><p><br></p><p>於是，問題變為："那麼，如果我需要修改這個基類的工作方式，那應當怎麼做呢？"OCP的另一部分中給出這一答案；基類應當開放，可進行擴充。在這裡，擴充是指創建一個由此基類繼承而來的派生類，它可以擴充或重載基類功能，以提供使用者所需要的特定功能。這樣，使用者就能使用類的修改版本，而不會影響到類的其他使用者。使用者還可以在將來更輕鬆地使用基類的升級版本，因為他們不用擔心丟失自己的修改內容。</p><p><br></p><p>本原則的應用：</p><p><br></p><p>對於面向對象來說，需要你依賴抽象，而不是實現，23個經典設計模式中的“策略模式”就是這個實現。對於非面向對象編程，一些API需要你傳入一個你可以擴展的函數，比如我們的C語言的qsort()允許你提供一個“比較器”，STL中的容器類的內存分配，ACE中的多線程的各種鎖。對於軟件方面，瀏覽器的各種插件屬於這個原則的實踐。</p><p><br></p><p>里氏替換原則的討論</p><p><br></p><p>(1) 軟件工程大師Robert C. Martin把里氏替換原則最終簡化為一句話：“Subtypes must be substitutable for their base types”。也就是，子類必須能夠替換成它們的基類。即：子類應該可以替換任何基類能夠出現的地方，並且經過替換以後，代碼還能正常工作。另外，不應該 在代碼中出現if/else之類對子類類型進行判斷的條件。里氏替換原則LSP是使代碼符合開閉原則的一個重要保證。正是由於子類型的可替換性才使得父類 型的模塊在無需修改的情況下就可以擴展。在很多情況下，在設計初期我們類之間的關係不是很明確，LSP則給了我們一個判斷和設計類之間關係的基準：需不需 要繼承，以及怎樣設計繼承關係。</p><p><br></p><p>(2) 當一個子類的實例應該能夠替換任何其超類的實例時，它們之間才具有is-A關係。繼承對於OCP，就相當於多態性對於里氏替換原則。子類可以代替基類，客戶使用基類，他們不需要知道派生類所做的事情。這是一個針對行為職責可替代的原則，如果S是T的子類型，那麼S對象就應該在不改變任何抽象屬性情況下替換所有T對象。</p><p><br></p><p>接口隔離原則</p><p><br></p><p>(1) 不能強迫用戶去依賴那些他們不使用的接口。換句話說，使用多個專門的接口比使用單一的總接口總要好。注意：在代碼中應用ISP並不一定意味著服務就是絕對安全的。仍然需要採用良好的編碼實踐，以確保正確的驗證與授權。</p><p><br></p><p>(2) 這個原則起源於施樂公司，他們需要建立了一個新的打印機系統，可以執行諸如裝訂的印刷品一套，傳真多種任務。此係統軟件創建從底層開始編制，並實現了這些 任務功能，但是不斷增長的軟件功能卻使軟件本身越來越難適應變化和維護。每一次改變，即使是最小的變化，有人可能需要近一個小時的重新編譯和重新部署。這 是幾乎不可能再繼續發展，所以他們聘請羅伯特Robert幫助他們。他們首先設計了一個主要類Job,幾乎能夠用於實現所有任務功能。只要調用Job類的 一個方法就可以實現一個功能，Job類就變動非常大，是一個胖模型啊，對於客戶端如果只需要一個打印功能，但是其他無關打印的方法功能也和其耦合，ISP 原則建議在客戶端和Job類之間增加一個接口層，對於不同功能有不同接口，比如打印功能就是Print接口，然後將大的Job類切分為繼承不同接口的子 類，這樣有一個Print Job類，等等。</p><p><br></p><p>依賴反轉原則</p><p><br></p><p>(1) 依賴倒置原則(Dependency Inversion Principle，DIP)規定：代碼應當取決於抽象概念，而不是具體實現。</p><p>(2) 高層模塊不應該依賴於低層模塊，二者都應該依賴於抽象</p><p>(3) 抽象不應該依賴於細節，細節應該依賴於抽象</p><p>(4) 類可能依賴於其他類來執行其工作。但是，它們不應當依賴於該類的特定具體實現，而應當是它的抽象。這個原則實在是太重要了，社會的分工化，標準化都 是這個設計原則的體現。顯然，這一概念會大大提高系統的靈活性。如果類只關心它們用於支持特定契約而不是特定類型的組件，就可以快速而輕鬆地修改這些低級 服務的功能，同時最大限度地降低對系統其餘部分的影響。</p><p><br></p><p>本原則的應用：</p><p><br></p><p>舉個例子，牆面的開關不應該依賴於電燈的開關實現，而是應該依賴於一個抽象的開關的標準接口，這樣，當我們擴展程序的時候，我們的開關同樣可以控制 其它不同的燈，甚至不同的電器。也就是說，電燈和其它電器繼承並實現我們的標準開關接口，而我們的開關產商就可不需要關於其要控制什麼樣的設備，只需要關 心那個標準的開關標準。這就是依賴倒置原則。這就好像瀏覽器並不依賴於後面的web服務器，其只依賴於HTTP協議。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>原則</a></li><li><a>對象</a></li><li><a>設計</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html alt=面向對象設計原則之開閉原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ff63803ae3d4638b01095d32682fa70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html title=面向對象設計原則之開閉原則>面向對象設計原則之開閉原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html alt=面向對象設計的七大原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd44e43836e64ae3b2c4d6e9ffa9f033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html title=面向對象設計的七大原則>面向對象設計的七大原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html alt=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/93686fc2-2a36-4161-8664-03ae59f6e71e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html title=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺>面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb60e0b.html alt="面向對象的設計原則-'里氏替換原則'" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb60e0b.html title="面向對象的設計原則-'里氏替換原則'">面向對象的設計原則-'里氏替換原則'</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ff8b90.html alt=不懂對象設計原則，都不好意思自稱php大師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ff8b90.html title=不懂對象設計原則，都不好意思自稱php大師>不懂對象設計原則，都不好意思自稱php大師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0ef77f.html alt=面向對象設計原則（OOP） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1537670193470d0e7533729 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0ef77f.html title=面向對象設計原則（OOP）>面向對象設計原則（OOP）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5862f7a.html alt=面向對象設計的原則一二 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f695e811db847a991662fc4eefa151f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5862f7a.html title=面向對象設計的原則一二>面向對象設計的原則一二</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb36434b.html alt=可靠性設計原則1000條---菜鳥走向大神必經之路 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb36434b.html title=可靠性設計原則1000條---菜鳥走向大神必經之路>可靠性設計原則1000條---菜鳥走向大神必經之路</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f7121626.html alt=可靠性設計原則1000條（完整版，建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f7121626.html title=可靠性設計原則1000條（完整版，建議收藏）>可靠性設計原則1000條（完整版，建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a11c588.html alt="PCB設計基本流程 & 佈局佈線基本原則和常識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7d8f835b7a3a4991b521f59f78f48d65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a11c588.html title="PCB設計基本流程 & 佈局佈線基本原則和常識">PCB設計基本流程 & 佈局佈線基本原則和常識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a849f9c9.html alt=燃氣管道佈置設計原則、基本要求與補償器的選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153013884a3441cdaf954d0f1510fc51 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a849f9c9.html title=燃氣管道佈置設計原則、基本要求與補償器的選擇>燃氣管道佈置設計原則、基本要求與補償器的選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d7ca019.html alt=管道佈置設計原則、基本要求與補償器的選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ba20020083df4c82a21b87b502ae0a0e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d7ca019.html title=管道佈置設計原則、基本要求與補償器的選擇>管道佈置設計原則、基本要求與補償器的選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a540ed0e.html alt=建築立面設計原則+處理手法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5dd8595ef4064bc5b4b0eee602fbaef5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a540ed0e.html title=建築立面設計原則+處理手法>建築立面設計原則+處理手法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html alt=面向對象設計之依賴倒置原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html title=面向對象設計之依賴倒置原則>面向對象設計之依賴倒置原則</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>