<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>有了 CompletableFuture，使得異步編程沒有那麼難了 | 极客快訊</title><meta property="og:title" content="有了 CompletableFuture，使得異步編程沒有那麼難了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e66a7bcfded64b34b43ebc1565b3e557"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/852c87e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/852c87e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/852c87e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/852c87e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/852c87e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/852c87e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/852c87e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/852c87e.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="有了 CompletableFuture，使得異步編程沒有那麼難了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/852c87e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>有了 CompletableFuture，使得異步編程沒有那麼難了</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>本文導讀：</strong></p><ul><li><strong>業務需求場景介紹</strong></li><li><strong>技術設計方案思考</strong></li><li><strong>Future 設計模式實戰</strong></li><li><strong>CompletableFuture 模式實戰</strong></li><li><strong>CompletableFuture 生產建議</strong></li><li><strong>CompletableFuture 性能測試</strong></li><li><strong>CompletableFuture 使用擴展</strong></li></ul><hr><p><strong>1、業務需求場景介紹</strong></p><hr><p>不變的東西就是一直在變化中。</p><p>想必，大家在閒暇時刻，會經常看視頻，經常用的幾個 APP，比如優酷、愛奇藝、騰訊等。</p><p>這些視頻 APP 不僅僅可以在手機上播放，還能夠支持在電視上播放。</p><p>在電視終端上播放的 APP 是獨立發佈的版本，跟手機端的 APP 是不一樣的。</p><p>當我們看一部電影時，點擊進入某一部電影，就進入到了專輯詳情頁頁面，此時，播放器會自動播放視頻。用戶在手機上看到的專輯詳情頁，與電視上看到的專輯詳情頁，頁面樣式設計上是不同的。</p><p>我們來直觀的看一下效果。</p><p>手機上的騰訊視頻專輯詳情頁:</p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e66a7bcfded64b34b43ebc1565b3e557><p class=pgc-img-caption></p></div><p>上半部分截圖，下面還有為你推薦、明星演員、周邊推薦、評論等功能。</p><p>相應的，在電視端的專輯詳情頁展示方式是不一樣的。假設產品經理提出一個需求，要求對詳情頁做個改版。</p><p>樣式要求如下圖所示：</p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6529422d9088498eae0ccc2fce47b782><p class=pgc-img-caption></p></div><p>兩個終端的樣式對比，在電視端專輯詳情頁中，包含了很多板塊，每個板塊橫向展示多個內容。</p><p>產品的設計上要求是，有的板塊內容來源於推薦、有的板塊來源於搜索、有的板塊來源CMS（內容管理系統）。簡單理解為，每個板塊內容來源不同，來源於推薦、搜索等接口的內容要求是近實時的請求。</p><p><strong>2、技術設計方案思考</strong></p><hr><p>考慮到產品提的這個需求，其實實現起來並不難。</p><p>主要分為了靜態數據部分和動態數據部分，對於不經常變化的數據可以通過靜態接口獲取，對於近乎實時的數據可以通過動態接口獲取。</p><p><strong>靜態接口設計：</strong></p><p>專輯本身的屬性以及專輯下的視頻數據，一般是不經常變化的。</p><p>在需求場景介紹中，我截圖的是電影頻道。如果是電視劇頻道，會展示劇集列表（專輯下的所有視頻，如第 1 集、第 2 集...），而視頻的更新一般是不太頻繁的，所以在專輯詳情頁劇集列表數據就可以從靜態接口獲取。</p><p>靜態接口數據生成流程：</p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52d585253ae24a7aa174d87db3baf078><p class=pgc-img-caption></p></div><p>另外一部分，就是需要動態接口來實現，調用第三方接口獲取數據，比如推薦、搜索數據。</p><p>同時，要求板塊與板塊之間的內容不允許重複。</p><p><strong>動態接口設計：</strong></p><p><strong>方案一：</strong></p><p>串行調用，即按照每個板塊的展示先後順序，調用相應的第三方接口獲取數據。</p><p><strong>方案二：</strong></p><p>並行調用，即多個板塊之間可以並行調用，提高整體接口響應效率。</p><p>其實以上兩個方案，各有利弊。</p><p>方案一串行調用，好處是開發模型簡單，按照串行方式依次調用接口，內容數據去重，聚合所有的數據返回給客戶端。</p><p>但是，接口響應時間依賴於第三方接口的響應時間，通常第三方接口總是不可靠的，可能就會拉高接口整體響應時間，進而導致佔用線程時間過長，影響接口整體吞吐量。</p><p>方案二並行調用，理論上是可以提高接口的整體響應時間，假設同時調用多個第三方接口，取決於最慢的接口響應時間。</p><p>並行調用時，需要考慮到「池化技術」，即不能無限制的在 JVM 進程上創建過多的線程。同時，也要考慮到板塊與板塊之間的內容數據，要按照產品設計上的先後順序做去重。</p><p>根據這個需求場景，我們選擇第二種方案來實現更合適一些。</p><p>選擇了方案二，我們抽象出如下圖所示的簡易模型：</p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9bea889c2f8f45a883b29b65072655d3><p class=pgc-img-caption></p></div><p>T1、T2、T3 表示多個板塊內容線程。T1 線程先返回結果，T2 線程返回的結果不能與與 T1 線程返回的結果內容重複，T3 線程返回的結果不能與 T1、T2 兩個線程返回的結果內容重複。</p><p>我們從技術實現上考量，當並行調用多個第三方接口時，需要獲取接口的返回結果，首先想到的就是 Future ，能夠實現異步獲取任務結果。</p><p>另外，JDK8 提供了 CompletableFuture 易於使用的獲取異步結果的工具類，解決了 Future 的一些使用上的痛點，以更優雅的方式實現組合式異步編程，同時也契合函數式編程。</p><p><strong>3、Future 設計模式實戰</strong></p><hr><p><strong>Future 接口設計：</strong></p><p>提供了獲取任務結果、取消任務、判斷任務狀態接口。調用獲取任務結果方法，在任務未完成情況下，會導致調用阻塞。</p><p><strong>Future 接口提供的方法：</strong></p><p>```</p><p>// 獲取任務結果</p><p>V get() throws InterruptedException, ExecutionException;</p><p>// 支持超時時間的獲取任務結果</p><p>V get(long timeout, TimeUnit unit)</p><p>throws InterruptedException, ExecutionException, TimeoutException;</p><p>// 判斷任務是否已完成</p><p>boolean isDone();</p><p>// 判斷任務是否已取消</p><p>boolean isCancelled();</p><p>// 取消任務</p><p>boolean cancel(boolean mayInterruptIfRunning);</p><p>```</p><p>通常，我們在考慮到使用 Future 獲取任務結果時，會使用 ThreadPoolExecutor 或者 FutureTask 來實現功能需求。</p><p><strong>ThreadPoolExecutor、FutureTask 與 Future 接口關係類圖：</strong></p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be71e30e6bc7453eaf76bc3f7e7579b0><p class=pgc-img-caption></p></div><p><strong>TheadPoolExecutor 提供三個 submit 方法：</strong></p><pre>// 1. 提交無需返回值的任務，Runnable 接口 run() 方法無返回值public Future&lt;?&gt; submit(Runnable task) {}// 2. 提交需要返回值的任務，Callable 接口 call() 方法有返回值public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {}// 3. 提交需要返回值的任務，任務結果是第二個參數 result 對象public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {}</pre><p>第 3 個 submit 方法使用示例如下所示：</p><pre>static String x = "東昇的思考";public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newFixedThreadPool(1); // 創建 Result 對象 r Result r = new Result(); r.setName(x); // 提交任務 Future&lt;Result&gt; future = executor.submit(new Task(r), r); Result fr = future.get(); // 下面等式成立 System.out.println(fr == r); System.out.println(fr.getName() == x); System.out.println(fr.getNick() == x);}static class Result { private String name; private String nick; // ... ignore getter and setter }static class Task implements Runnable { Result r; // 通過構造函數傳入 result Task(Result r) { this.r = r; } @Override public void run() { // 可以操作 result String name = r.getName(); r.setNick(name); }}</pre><p>執行結果都是true。</p><p><strong>FutureTask 設計實現：</strong></p><p>實現了 Runnable 和 Future 兩個接口。實現了 Runnable 接口，說明可以作為任務對象，直接提交給 ThreadPoolExecutor 去執行。實現了 Future 接口，說明能夠獲取執行任務的返回結果。</p><p>我們來根據產品的需求，使用 FutureTask 模擬兩個線程，通過示例實現下功能。</p><p>結合示例代碼註釋理解：</p><pre>public static void main(String[] args) throws Exception { // 創建任務 T1 的 FutureTask，調用推薦接口獲取數據 FutureTask&lt;String&gt; ft1 = new FutureTask&lt;&gt;(new T1Task()); // 創建任務 T1 的 FutureTask，調用搜索接口獲取數據，依賴 T1 結果 FutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(new T2Task(ft1)); // 線程 T1 執行任務 ft1 Thread T1 = new Thread(ft1); T1.start(); // 線程 T2 執行任務 ft2 Thread T2 = new Thread(ft2); T2.start(); // 等待線程 T2 執行結果 System.out.println(ft2.get());}// T1Task 調用推薦接口獲取數據static class T1Task implements Callable&lt;String&gt; { @Override public String call() throws Exception { System.out.println("T1: 調用推薦接口獲取數據..."); TimeUnit.SECONDS.sleep(1); System.out.println("T1: 得到推薦接口數據..."); TimeUnit.SECONDS.sleep(10); return " [T1 板塊數據] "; }} // T2Task 調用搜索接口數據，同時需要推薦接口數據static class T2Task implements Callable&lt;String&gt; { FutureTask&lt;String&gt; ft1; // T2 任務需要 T1 任務的 FutureTask 返回結果去重 T2Task(FutureTask&lt;String&gt; ft1) { this.ft1 = ft1; } @Override public String call() throws Exception { System.out.println("T2: 調用搜索接口獲取數據..."); TimeUnit.SECONDS.sleep(1); System.out.println("T2: 得到搜索接口的數據..."); TimeUnit.SECONDS.sleep(5); // 獲取 T2 線程的數據 System.out.println("T2: 調用 T1.get() 接口獲取推薦數據"); String tf1 = ft1.get(); System.out.println("T2: 獲取到推薦接口數據:" + tf1); System.out.println("T2: 將 T1 與 T2 板塊數據做去重處理"); return "[T1 和 T2 板塊數據聚合結果]"; }}</pre><p>執行結果如下：</p><pre>&gt; Task :FutureTaskTest.main()T1: 調用推薦接口獲取數據...T2: 調用搜索接口獲取數據...T1: 得到推薦接口數據...T2: 得到搜索接口的數據...T2: 調用 T1.get() 接口獲取推薦數據T2: 獲取到推薦接口數據: [T1 板塊數據] T2: 將 T1 與 T2 板塊數據做去重處理[T1 和 T2 板塊數據聚合結果] </pre><p><strong>小結：</strong></p><p>Future 表示「未來」的意思，主要是將耗時的一些操作任務，交給單獨的線程去執行。從而達到異步的目的，提交任務的當前線程，在提交任務後和獲取任務結果的過程中，當前線程可以繼續執行其他操作，不需要在那傻等著返回執行結果。</p><p><strong>4、CompleteableFuture 模式實戰</strong></p><hr><p>對於 Future 設計模式，雖然我們提交任務時，不會進入任何阻塞，但是當調用方要獲得這個任務的執行結果，還是可能會阻塞直至任務執行完成。</p><p>在 JDK1.5 設計之初就一直存在這個問題，發展到 JDK1.8 引入了 CompletableFuture 才得到完美的增強。</p><p>在此期間，Google 開源的 Guava 工具包提供了 ListenableFuture ，用於支持任務完成時支持回調方式，感興趣的朋友們可以自行查閱研究。</p><p>在業務需求場景介紹中，不同板塊的數據來源是不同的，並且板塊與板塊之間是存在數據依賴關係的。</p><p>可以理解為任務與任務之間是有時序關係的，而根據 CompletableFuture 提供的一些功能特性，是非常適合這種業務場景的。</p><p><strong>CompletableFuture 類圖：</strong></p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/963ea7f277e24eaf9ec15a916b9c2815><p class=pgc-img-caption></p></div><p>CompletableFuture 實現了 Future 和 CompletionStage 兩個接口。實現 Future 接口是為了關注異步任務什麼時候結束，和獲取異步任務執行的結果。實現 CompletionStage 接口，其提供了非常豐富的功能，實現了串行關係、並行關係、匯聚關係等。</p><p><strong>CompletableFuture 核心優勢：</strong></p><p>1）無需手工維護線程，給任務分配線程的工作無需開發人員關注；</p><p>2）在使用上，語義更加清晰明確；</p><p>例如：t3 = t1.thenCombine(t2, () -> { // doSomething ... } 能夠明確的表述任務 3 要等任務 2 和 任務 1完成後才會開始執行。</p><p>3）代碼更加簡練，支持鏈式調用，讓你更專注業務邏輯。</p><p>4）方便的處理異常情況</p><p>接下來，通過 CompletableFuture 來模擬實現專輯下多板塊數據聚合處理。</p><p>代碼如下所示：</p><pre>public static void main(String[] args) throws Exception { // 暫存數據 List&lt;String&gt; stashList = Lists.newArrayList(); // 任務 1：調用推薦接口獲取數據 CompletableFuture&lt;String&gt; t1 = CompletableFuture.supplyAsync(() -&gt; { System.out.println("T1: 獲取推薦接口數據..."); sleepSeconds(5); stashList.add("[T1 板塊數據]"); return "[T1 板塊數據]"; }); // 任務 2：調用搜索接口獲取數據 CompletableFuture&lt;String&gt; t2 = CompletableFuture.supplyAsync(() -&gt; { System.out.println("T2: 調用搜索接口獲取數據..."); sleepSeconds(3); return " [T2 板塊數據] "; }); // 任務 3：任務 1 和任務 2 完成後執行，聚合結果 CompletableFuture&lt;String&gt; t3 = t1.thenCombine(t2, (t1Result, t2Result) -&gt; { System.out.println(t1Result + " 與 " + t2Result + "實現去重邏輯處理"); return "[T1 和 T2 板塊數據聚合結果]"; }); // 等待任務 3 執行結果 System.out.println(t3.get(6, TimeUnit.SECONDS));}static void sleepSeconds(int timeout) { try { TimeUnit.SECONDS.sleep(timeout); } catch (InterruptedException e) { e.printStackTrace(); }}</pre><p>執行結果如下：</p><pre>&gt; Task :CompletableFutureTest.main()T1: 獲取推薦接口數據...T2: 調用搜索接口獲取數據...[T1 板塊數據] 與 [T2 板塊數據] 實現去重邏輯處理[T1 和 T2 板塊數據聚合結果]</pre><p>上述的示例代碼在 IDEA 中新建個Class，直接複製進去，即可正常運行。</p><p><strong>** 5、CompletableFuture 生產建議**</strong></p><hr><p><strong>創建合理的線程池：</strong></p><p>在生產環境下，不建議直接使用上述示例代碼形式。因為示例代碼中使用的</p><p>CompletableFuture.supplyAsync(() -> {});</p><p>創建 CompletableFuture 對象的 supplyAsync() 方法（這裡使用的工廠方法模式），底層使用的默認線程池，不一定能滿足業務需求。</p><p>結合底層源代碼來看一下：</p><pre>// 默認使用 ForkJoinPool 線程池private static final Executor asyncPool = useCommonPool ? ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) { return asyncSupplyStage(asyncPool, supplier);}</pre><p>創建 ForkJoinPool 線程池：</p><p>默認線程池大小是 Runtime.getRuntime().availableProcessors() - 1（CPU 核數 - 1），可以通過 JVM 參數 -Djava.util.concurrent.ForkJoinPool.common.parallelism 設置線程池大小。</p><p>JVM 參數上配置 -Djava.util.concurrent.ForkJoinPool.common.threadFactory 設置線程工廠類；配置 -Djava.util.concurrent.ForkJoinPool.common.exceptionHandler 設置異常處理類，這兩個參數設置後，內部會通過系統類加載器加載 Class。</p><p>如果所有 CompletableFuture 都使用默認線程池，一旦有任務執行很慢的 I/O 操作，就會導致所有線程都阻塞在 I/O 操作上，進而影響系統整體性能。</p><p>所以，建議大家在生產環境使用時，根據不同的業務類型創建不同的線程池，以避免互相影響。</p><p>CompletableFuture 還提供了另外支持線程池的方法。</p><pre>// 第二個參數支持傳遞 Executor 自定義線程池public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor) { return asyncSupplyStage(screenExecutor(executor), supplier);}</pre><p>自定義線程池，建議參考 「阿里巴巴 Java 開發手冊」，推薦使用 ThreadPoolExecutor 自定義線程池，使用有界隊列，根據實際業務情況設置隊列大小。</p><p>線程池大小的設置，在 「Java 併發編程實戰」一書中，Brian Goetz 提供了不少優化建議。如果線程池數量過多，競爭 CPU 和內存資源，導致大量時間在上下文切換上。反之，如果線程池數量過少，無法充分利用 CPU 多核優勢。</p><p>線程池大小與 CPU 處理器的利用率之比可以用下面公式估算：</p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15a2f43eee5747129967153c9b0fff42><p class=pgc-img-caption></p></div><p><strong>異常處理：</strong></p><p>CompletableFuture 提供了非常簡單的異常處理 ，如下這些方法，支持鏈式編程方式。</p><pre>// 類似於 try{}catch{} 中的 catch{}public CompletionStage&lt;T&gt; exceptionally (Function&lt;Throwable, ? extends T&gt; fn); // 類似於 try{}finally{} 中的 finally{}，不支持返回結果public CompletionStage&lt;T&gt; whenComplete (BiConsumer&lt;? super T, ? super Throwable&gt; action);public CompletionStage&lt;T&gt; whenCompleteAsync (BiConsumer&lt;? super T, ? super Throwable&gt; action); // 類似於 try{}finally{} 中的 finally{}，支持返回結果public &lt;U&gt; CompletionStage&lt;U&gt; handle (BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);public &lt;U&gt; CompletionStage&lt;U&gt; handleAsync (BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);</pre><p><strong>#### 6、CompletableFuture 性能測試：</strong></p><p>循環壓測任務數如下所示，每次執行壓測，從 1 到 jobNum 數據疊加匯聚結果，計算耗時。</p><p>統計維度：CompletableFuture 默認線程池 與 自定義線程池。</p><p>性能測試代碼：</p><pre>// 性能測試代碼Arrays.asList(-3, -1, 0, 1, 2, 4, 5, 10, 16, 17, 30, 50, 100, 150, 200, 300).forEach(offset -&gt; { int jobNum = PROCESSORS + offset; System.out.println( String.format("When %s tasks =&gt; stream: %s, parallelStream: %s, future default: %s, future custom: %s", testCompletableFutureDefaultExecutor(jobNum), testCompletableFutureCustomExecutor(jobNum)));});// CompletableFuture 使用默認 ForkJoinPool 線程池private static long testCompletableFutureDefaultExecutor(int jobCount) { List&lt;CompletableFuture&lt;Integer&gt;&gt; tasks = new ArrayList&lt;&gt;(); IntStream.rangeClosed(1, jobCount).forEach(value -&gt; tasks.add(CompletableFuture.supplyAsync(CompleteableFuturePerfTest::getJob))); long start = System.currentTimeMillis(); int sum = tasks.stream().map(CompletableFuture::join).mapToInt(Integer::intValue).sum(); checkSum(sum, jobCount); return System.currentTimeMillis() - start;}// CompletableFuture 使用自定義的線程池private static long testCompletableFutureCustomExecutor(int jobCount) { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(200, 200, 5, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;&gt;(100000), new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.setName("CUSTOM_DAEMON_COMPLETABLEFUTURE"); thread.setDaemon(true); return thread; } }, new ThreadPoolExecutor.CallerRunsPolicy()); List&lt;CompletableFuture&lt;Integer&gt;&gt; tasks = new ArrayList&lt;&gt;(); IntStream.rangeClosed(1, jobCount).forEach(value -&gt; tasks.add(CompletableFuture.supplyAsync(CompleteableFuturePerfTest::getJob, threadPoolExecutor))); long start = System.currentTimeMillis(); int sum = tasks.stream().map(CompletableFuture::join).mapToInt(Integer::intValue).sum(); checkSum(sum, jobCount); return System.currentTimeMillis() - start;}</pre><p>測試機器配置：8 核CPU，16G內存</p><p>性能測試結果：</p><div class=pgc-img><img alt="有了 CompletableFuture，使得異步編程沒有那麼難了" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5cbf2ad690624651b897fc36cafb8794><p class=pgc-img-caption></p></div><p>根據壓測結果看到，隨著壓測任務數量越大，使用默認的線程池性能越差。</p><p><strong>7、CompletableFuture 使用擴展：</strong></p><hr><p><strong>對象創建：</strong></p><p>除前面提到的 supplyAsync 方法外，CompletableFuture 還提供瞭如下方法：</p><pre>// 執行任務，CompletableFuture&lt;Void&gt; 無返回值，默認線程池public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) { return asyncRunStage(asyncPool, runnable);}// 執行任務，CompletableFuture&lt;Void&gt; 無返回值，支持自定義線程池public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor) { return asyncRunStage(screenExecutor(executor), runnable);}</pre><p>我們在 CompletableFuture 模式實戰中，提到了 CompletableFuture 實現了 CompletionStage 接口，該接口提供了非常豐富的功能。</p><p>CompletionStage 接口支持串行關係、匯聚 AND 關係、匯聚 OR 關係。</p><p>下面對這些關係的接口做個簡單描述，大家在使用時可以去自行查閱 JDK API。</p><p>同時，這些關係接口中每個方法都提供了對應的 xxxAsync() 方法，表示異步化執行任務。</p><p><strong>串行關係：</strong></p><p>CompletionStage 描述串行關係，主要有 thenApply、thenRun、thenAccept 和 thenCompose 系列接口。</p><p>源碼如下所示：</p><pre>// 對應 U apply(T t) ，接收參數 T並支持返回值 Upublic &lt;U&gt; CompletionStage&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn);public &lt;U&gt; CompletionStage&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);// 不接收參數也不支持返回值public CompletionStage&lt;Void&gt; thenRun(Runnable action);public CompletionStage&lt;Void&gt; thenRunAsync(Runnable action);// 接收參數但不支持返回值public CompletionStage&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action);public CompletionStage&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);// 組合兩個依賴的 CompletableFuture 對象public &lt;U&gt; CompletionStage&lt;U&gt; thenCompose (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);public &lt;U&gt; CompletionStage&lt;U&gt; thenComposeAsync (Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);</pre><p><strong>匯聚 AND 關係：</strong></p><p>CompletionStage 描述 匯聚 AND 關係，主要有 thenCombine、thenAcceptBoth 和 runAfterBoth 系列接口。</p><p>源碼如下所示（省略了Async 方法）：</p><pre>// 當前和另外的 CompletableFuture 都完成時，兩個參數傳遞給 fn，fn 有返回值public &lt;U,V&gt; CompletionStage&lt;V&gt; thenCombine (CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn);// 當前和另外的 CompletableFuture 都完成時，兩個參數傳遞給 action，action 沒有返回值public &lt;U&gt; CompletionStage&lt;Void&gt; thenAcceptBoth (CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T, ? super U&gt; action);// 當前和另外的 CompletableFuture 都完成時，執行 actionpublic CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action);</pre><p><strong>匯聚 OR 關係：</strong></p><p>CompletionStage 描述 匯聚 OR 關係，主要有 applyToEither、acceptEither 和 runAfterEither 系列接口。</p><p>源碼如下所示（省略了Async 方法）：</p><pre>// 當前與另外的 CompletableFuture 任何一個執行完成，將其傳遞給 fn，支持返回值public &lt;U&gt; CompletionStage&lt;U&gt; applyToEither (CompletionStage&lt;? extends T&gt; other, Function&lt;? super T, U&gt; fn);// 當前與另外的 CompletableFuture 任何一個執行完成，將其傳遞給 action，不支持返回值public CompletionStage&lt;Void&gt; acceptEither (CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action);// 當前與另外的 CompletableFuture 任何一個執行完成，直接執行 actionpublic CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action);</pre><p>到此，CompletableFuture 的相關特性都介紹完了。</p><p>異步編程慢慢變得越來越成熟，Java 語言官網也開始支持異步編程模式，所以學好異步編程還是有必要的。</p><p>本文結合業務需求場景驅動，引出了 Future 設計模式實戰，然後對 JDK1.8 中的 CompletableFuture 是如何使用的，核心優勢、性能測試對比、使用擴展方面做了進一步剖析。</p><p>希望對大家有所幫助！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>CompletableFuture</a></li><li><a>異步</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd08b19.html alt=異步編程：協作性多任務處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/dbd0ddd7-eda4-430a-8176-da9804319771 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd08b19.html title=異步編程：協作性多任務處理>異步編程：協作性多任務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html alt="Java 異步編程導論" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3c356b1aa9b4416ca7b35a07f3033e13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html title="Java 異步編程導論">Java 異步編程導論</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cb74cd.html alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b9d102263d0f46a0b5b203d7b6cd4a2e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cb74cd.html title="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記">Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e8c3b8.html alt=詳解編程中的同步和異步 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b292fb03b256422bb94215ce3ec3bbaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e8c3b8.html title=詳解編程中的同步和異步>詳解編程中的同步和異步</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a0dfd7.html alt="異步編程實例：Java8 API的理解和CompletableFuture類的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522150125651deaa9d51b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a0dfd7.html title="異步編程實例：Java8 API的理解和CompletableFuture類的實現">異步編程實例：Java8 API的理解和CompletableFuture類的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c81ec36.html alt=異步編程提升服務性能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15260210063976700d35c2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c81ec36.html title=異步編程提升服務性能>異步編程提升服務性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html alt=「編程基礎」PHP基礎教程（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17685aad04c54d02928724fb99fea026 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html title=「編程基礎」PHP基礎教程（二）>「編程基礎」PHP基礎教程（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html alt=「編程基礎」PHP基礎教程（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/355d0f0c0f274bdfaeb90747dbd918fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html title=「編程基礎」PHP基礎教程（一）>「編程基礎」PHP基礎教程（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html alt=零基礎如何學PHP編程語言？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html title=零基礎如何學PHP編程語言？>零基礎如何學PHP編程語言？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html alt=遊戲引擎編程需要哪些基本數學知識？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f6ca97249fa468db6982c44a024979d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html title=遊戲引擎編程需要哪些基本數學知識？>遊戲引擎編程需要哪些基本數學知識？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html alt=UG編程獨當一面，如何提高鑽孔精度方法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532093430052c29be7656f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html title=UG編程獨當一面，如何提高鑽孔精度方法？>UG編程獨當一面，如何提高鑽孔精度方法？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html alt=三相異步電動機絕緣處理的目的及方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c439a15bdf64f1f975914c96a2c66e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html title=三相異步電動機絕緣處理的目的及方法>三相異步電動機絕緣處理的目的及方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html alt=異步電機典型結構簡述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349080656472f5dd62512 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html title=異步電機典型結構簡述>異步電機典型結構簡述</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>