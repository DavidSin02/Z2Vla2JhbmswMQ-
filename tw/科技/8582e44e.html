<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>計算機實驗室之樹莓派：課程 7 屏幕02 | 极客快訊</title><meta property="og:title" content="計算機實驗室之樹莓派：課程 7 屏幕02 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fa8f776ea6c84f08b0fbfaad451371e0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8582e44e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8582e44e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8582e44e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8582e44e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8582e44e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8582e44e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8582e44e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8582e44e.html><meta property="article:published_time" content="2020-11-14T21:08:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:09+08:00"><meta name=Keywords content><meta name=description content="計算機實驗室之樹莓派：課程 7 屏幕02"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8582e44e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>計算機實驗室之樹莓派：課程 7 屏幕02</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="計算機實驗室之樹莓派：課程 7 屏幕02" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fa8f776ea6c84f08b0fbfaad451371e0><p class=pgc-img-caption></p></div><p>屏幕02 課程在屏幕01 的基礎上構建，它教你如何繪製線和一個生成偽隨機數的小特性。</p><p>-- Alex Chadwick</p><p>屏幕02 課程在屏幕01 的基礎上構建，它教你如何繪製線和一個生成偽隨機數的小特性。假設你已經有了 課程 6：屏幕01 的操作系統代碼，我們將以它為基礎來構建。</p><h1>1、點</h1><p>現在，我們的屏幕已經正常工作了，現在開始去創建一個更實用的圖像，是水到渠成的事。如果我們能夠繪製出更實用的圖形那就更好了。如果我們能夠在屏幕上的兩點之間繪製一條線，那我們就能夠組合這些線繪製出更復雜的圖形了。</p><p>我們將嘗試用匯編代碼去實現它，但在開始時，我們確實需要使用一些其它的函數去輔助。我們需要一個這樣的函數，我將調用 SetPixel 去修改指定像素的顏色，而在寄存器 r0 和 r1 中提供輸入。如果我們寫出的代碼可以在任意內存中而不僅僅是屏幕上繪製圖形，這將在以後非常有用，因此，我們首先需要一些控制真實繪製位置的方法。我認為實現上述目標的最好方法是，能夠有一個內存片段用於保存將要繪製的圖形。我應該最終得到的是一個存儲地址，它通常指向到自上次的幀緩存結構上。我們將一直在我們的代碼中使用這個繪製方法。這樣，如果我們想在我們的操作系統的另一部分繪製一個不同的圖像，我們就可以生成一個不同結構的地址值，而使用的是完全相同的代碼。為簡單起見，我們將使用另一個數據片段去控制我們繪製的顏色。</p><blockquote><p>為了繪製出更復雜的圖形，一些方法使用一個著色函數而不是一個顏色去繪製。每個點都能夠調用著色函數來確定在那裡用什麼顏色去繪製。</p></blockquote><p>複製下列代碼到一個名為 drawing.s 的新文件中。</p><blockquote><p>.section .data</p><p>.align 1</p><p>foreColour:</p><p>.hword 0xFFFF</p><p>.align 2</p><p>graphicsAddress:</p><p>.int 0</p><p>.section .text</p><p>.globl SetForeColour</p><p>SetForeColour:</p><p>cmp r0,#0x10000</p><p>movhs pc,lr</p><p>ldr r1,=foreColour</p><p>strh r0,[r1]</p><p>mov pc,lr</p><p>.globl SetGraphicsAddress</p><p>SetGraphicsAddress:</p><p>ldr r1,=graphicsAddress</p><p>str r0,[r1]</p><p>mov pc,lr</p></blockquote><p>這段代碼就是我上面所說的一對函數以及它們的數據。我們將在 main.s 中使用它們，在繪製圖像之前去控制在何處繪製什麼內容。</p><p>我們的下一個任務是去實現一個 SetPixel 方法。它需要帶兩個參數，像素的 x 和 y 軸，並且它應該要使用 graphicsAddress 和 foreColour，我們只定義精確控制在哪裡繪製什麼圖像即可。如果你認為你能立即實現這些，那麼去動手實現吧，如果不能，按照我們提供的步驟，按示例去實現它。</p><blockquote><p>構建一個通用方法，比如 SetPixel，我們將在它之上構建另一個方法是一個很好的想法。但我們必須要確保這個方法很快，因為我們要經常使用它。</p></blockquote><ol><li>加載 graphicsAddress。</li><li>檢查像素的 x 和 y 軸是否小於寬度和高度。</li><li>計算要寫入的像素地址（提示：frameBufferAddress +（x + y * 寬度）* 像素大小）</li><li>加載 foreColour。</li><li>保存到地址。</li></ol><p>上述步驟實現如下：</p><p>1、加載 graphicsAddress。</p><blockquote><p>.globl DrawPixel</p><p>DrawPixel:</p><p>px .req r0</p><p>py .req r1</p><p>addr .req r2</p><p>ldr addr,=graphicsAddress</p><p>ldr addr,[addr]</p></blockquote><p>2、記住，寬度和高度被各自保存在幀緩衝偏移量的 0 和 4 處。如有必要可以參考 frameBuffer.s。</p><blockquote><p>height .req r3</p><p>ldr height,[addr,#4]</p><p>sub height,#1</p><p>cmp py,height</p><p>movhi pc,lr</p><p>.unreq height</p><p>width .req r3</p><p>ldr width,[addr,#0]</p><p>sub width,#1</p><p>cmp px,width</p><p>movhi pc,lr</p></blockquote><p>3、確實，這段代碼是專用於高色值幀緩存的，因為我使用一個邏輯左移操作去計算地址。你可能希望去編寫一個不需要專用的高色值幀緩衝的函數版本，記得去更新 SetForeColour 的代碼。它實現起來可能更復雜一些。</p><blockquote><p>ldr addr,[addr,#32]</p><p>add width,#1</p><p>mla px,py,width,px</p><p>.unreq width</p><p>.unreq py</p><p>add addr, px,lsl #1</p><p>.unreq px</p><p>mla dst,reg1,reg2,reg3 將寄存器 reg1 和 reg2 中的值相乘，然後將結果與寄存器 reg3 中的值相加，並將結果的低 32 位保存到 dst 中。</p></blockquote><p>4、這是專用於高色值的。</p><blockquote><p>fore .req r3</p><p>ldr fore,=foreColour</p><p>ldrh fore,[fore]</p></blockquote><p>5、這是專用於高色值的。</p><blockquote><p>strh fore,[addr]</p><p>.unreq fore</p><p>.unreq addr</p><p>mov pc,lr</p></blockquote><h1>2、線</h1><p>問題是，線的繪製並不是你所想像的那麼簡單。到目前為止，你必須認識到，編寫一個操作系統時，幾乎所有的事情都必須我們自己去做，繪製線條也不例外。我建議你們花點時間想想如何在任意兩點之間繪製一條線。</p><p>我估計大多數的策略可能是去計算線的梯度，並沿著它來繪製。這看上去似乎很完美，但它事實上是個很糟糕的主意。主要問題是它涉及到除法，我們知道在彙編中，做除法很不容易，並且還要始終記錄小數，這也很困難。事實上，在這裡，有一個叫布魯塞姆的算法，它非常適合彙編代碼，因為它只使用加法、減法和位移運算。</p><blockquote><p>在我們日常編程中，我們對像除法這樣的運算通常懶得去優化。但是操作系統不同，它必須高效，因此我們要始終專注於如何讓事情做的儘可能更好。</p><p>我們從定義一個簡單的直線繪製算法開始，代碼如下：</p><p>/* 我們希望從 (x0,y0) 到 (x1,y1) 去繪製一條線，只使用一個函數 setPixel(x,y)，它的功能是在給定的 (x,y) 上繪製一個點。 */</p><p>if x1 > x0 then</p><p>set deltax to x1 - x0</p><p>set stepx to +1</p><p>otherwise</p><p>set deltax to x0 - x1</p><p>set stepx to -1</p><p>end if</p><p>if y1 > y0 then</p><p>set deltay to y1 - y0</p><p>set stepy to +1</p><p>otherwise</p><p>set deltay to y0 - y1</p><p>set stepy to -1</p><p>end if</p><p>if deltax > deltay then</p><p>set error to 0</p><p>until x0 = x1 + stepx</p><p>setPixel(x0, y0)</p><p>set error to error + deltax ÷ deltay</p><p>if error ≥ 0.5 then</p><p>set y0 to y0 + stepy</p><p>set error to error - 1</p><p>end if</p><p>set x0 to x0 + stepx</p><p>repeat</p><p>otherwise</p><p>end if</p><p>這個算法用來表示你可能想像到的那些東西。變量 error 用來記錄你離實線的距離。沿著 x 軸每走一步，這個 error 的值都會增加，而沿著 y 軸每走一步，這個 error 值就會減 1 個單位。error 是用於測量距離 y 軸的距離。</p><p>雖然這個算法是有效的，但它存在一個重要的問題，很明顯，我們使用了小數去保存 error，並且也使用了除法。所以，一個立即要做的優化將是去改變 error 的單位。這裡並不需要用特定的單位去保存它，只要我們每次使用它時都按相同數量去伸縮即可。所以，我們可以重寫這個算法，通過在所有涉及 error 的等式上都簡單地乘以 deltay，從面讓它簡化。下面只展示主要的循環：</p><p>set error to 0 × deltay</p><p>until x0 = x1 + stepx</p><p>setPixel(x0, y0)</p><p>set error to error + deltax ÷ deltay × deltay</p><p>if error ≥ 0.5 × deltay then</p><p>set y0 to y0 + stepy</p><p>set error to error - 1 × deltay</p><p>end if</p><p>set x0 to x0 + stepx</p><p>repeat</p><p>它將簡化為：</p><p>cset error to 0</p><p>until x0 = x1 + stepx</p><p>setPixel(x0, y0)</p><p>set error to error + deltax</p><p>if error × 2 ≥ deltay then</p><p>set y0 to y0 + stepy</p><p>set error to error - deltay</p><p>end if</p><p>set x0 to x0 + stepx</p><p>repeat</p><p>突然，我們有了一個更好的算法。現在，我們看一下如何完全去除所需要的除法運算。最好保留唯一的被 2 相乘的乘法運算，我們知道它可以通過左移 1 位來實現！現在，這是非常接近布魯塞姆算法的，但還可以進一步優化它。現在，我們有一個 if 語句，它將導致產生兩個代碼塊，其中一個用於 x 差異較大的線，另一個用於 y 差異較大的線。對於這兩種類型的線，如果審查代碼能夠將它們轉換成一個單語句，還是很值得去做的。</p><p>困難之處在於，在第一種情況下，error 是與 y 一起變化，而第二種情況下 error 是與 x 一起變化。解決方案是在一個變量中同時記錄它們，使用負的 error 去表示 x 中的一個 error，而用正的 error 表示它是 y 中的。</p><p>set error to deltax - deltay</p><p>until x0 = x1 + stepx or y0 = y1 + stepy</p><p>setPixel(x0, y0)</p><p>if error × 2 > -deltay then</p><p>set x0 to x0 + stepx</p><p>set error to error - deltay</p><p>end if</p><p>if error × 2 &lt; deltax then</p><p>set y0 to y0 + stepy</p><p>set error to error + deltax</p><p>end if</p><p>repeat</p><p>你可能需要一些時間來搞明白它。在每一步中，我們都認為它正確地在 x 和 y 中移動。我們通過檢查來做到這一點，如果我們在 x 或 y 軸上移動，error 的數量會變低，那麼我們就繼續這樣移動。</p><p>布魯塞姆算法是在 1962 年由 Jack Elton Bresenham 開發，當時他 24 歲，正在攻讀博士學位。</p></blockquote><p>用於畫線的布魯塞姆算法可以通過以下的偽代碼來描述。以下偽代碼是文本，它只是看起來有點像是計算機指令而已，但它卻能讓程序員實實在在地理解算法，而不是為機器可讀。</p><blockquote><p>/* 我們希望從 (x0,y0) 到 (x1,y1) 去繪製一條線，只使用一個函數 setPixel(x,y)，它的功能是在給定的 (x,y) 上繪製一個點。 */</p><p>if x1 > x0 then</p><p>set deltax to x1 - x0</p><p>set stepx to +1</p><p>otherwise</p><p>set deltax to x0 - x1</p><p>set stepx to -1</p><p>end if</p><p>set error to deltax - deltay</p><p>until x0 = x1 + stepx or y0 = y1 + stepy</p><p>setPixel(x0, y0)</p><p>if error × 2 ≥ -deltay then</p><p>set x0 to x0 + stepx</p><p>set error to error - deltay</p><p>end if</p><p>if error × 2 ≤ deltax then</p><p>set y0 to y0 + stepy</p><p>set error to error + deltax</p><p>end if</p><p>repeat</p></blockquote><p>與我們目前所使用的編號列表不同，這個算法的表示方式更常用。看看你能否自己實現它。我在下面提供了我的實現作為參考。</p><blockquote><p>.globl DrawLine</p><p>DrawLine:</p><p>push {r4,r5,r6,r7,r8,r9,r10,r11,r12,lr}</p><p>x0 .req r9</p><p>x1 .req r10</p><p>y0 .req r11</p><p>y1 .req r12</p><p>mov x0,r0</p><p>mov x1,r2</p><p>mov y0,r1</p><p>mov y1,r3</p><p>dx .req r4</p><p>dyn .req r5 /* 注意，我們只使用 -deltay，因此為了速度，我保存它的負值。（因此命名為 dyn）*/</p><p>sx .req r6</p><p>sy .req r7</p><p>err .req r8</p><p>cmp x0,x1</p><p>subgt dx,x0,x1</p><p>movgt sx,#-1</p><p>suble dx,x1,x0</p><p>movle sx,#1</p><p>cmp y0,y1</p><p>subgt dyn,y1,y0</p><p>movgt sy,#-1</p><p>suble dyn,y0,y1</p><p>movle sy,#1</p><p>add err,dx,dyn</p><p>add x1,sx</p><p>add y1,sy</p><p>pixelLoop$:</p><p>teq x0,x1</p><p>teqne y0,y1</p><p>popeq {r4,r5,r6,r7,r8,r9,r10,r11,r12,pc}</p><p>mov r0,x0</p><p>mov r1,y0</p><p>bl DrawPixel</p><p>cmp dyn, err,lsl #1</p><p>addle err,dyn</p><p>addle x0,sx</p><p>cmp dx, err,lsl #1</p><p>addge err,dx</p><p>addge y0,sy</p><p>b pixelLoop$</p><p>.unreq x0</p><p>.unreq x1</p><p>.unreq y0</p><p>.unreq y1</p><p>.unreq dx</p><p>.unreq dyn</p><p>.unreq sx</p><p>.unreq sy</p><p>.unreq err</p></blockquote><h1>3、隨機性</h1><p>到目前，我們可以繪製線條了。雖然我們可以使用它來繪製圖片及諸如此類的東西（你可以隨意去做！），我想應該藉此機會引入計算機中隨機性的概念。我將這樣去做，選擇一對隨機的座標，然後從上一對座標用漸變色繪製一條線到那個點。我這樣做純粹是認為它看起來很漂亮。</p><p>那麼，總結一下，我們如何才能產生隨機數呢？不幸的是，我們並沒有產生隨機數的一些設備（這種設備很罕見）。因此只能利用我們目前所學過的操作，需要我們以某種方式來發明“隨機數”。你很快就會意識到這是不可能的。各種操作總是給出定義好的結果，用相同的寄存器運行相同的指令序列總是給出相同的答案。而我們要做的是推導出一個偽隨機序列。這意味著數字在外人看來是隨機的，但實際上它是完全確定的。因此，我們需要一個生成隨機數的公式。其中有人可能會想到很垃圾的數學運算，比如：4x<sup>2</sup>! / 64，而事實上它產生的是一個低質量的隨機數。在這個示例中，如果 x 是 0，那麼答案將是 0。看起來很愚蠢，我們需要非常謹慎地選擇一個能夠產生高質量隨機數的方程式。</p><blockquote><p>硬件隨機數生成器很少用在安全中，因為可預測的隨機數序列可能影響某些加密的安全。</p></blockquote><p>我將要教給你的方法叫“二次同餘發生器”。這是一個非常好的選擇，因為它能夠在 5 個指令中實現，並且能夠產生一個從 0 到 232-1 之間的看似很隨機的數字序列。</p><p>不幸的是，對為什麼使用如此少的指令能夠產生如此長的序列的原因的研究，已經遠超出了本課程的教學範圍。但我還是鼓勵有興趣的人去研究它。它的全部核心所在就是下面的二次方程，其中 xn 是產生的第 n 個隨機數。</p><blockquote><p>這類討論經常尋求一個問題，那就是我們所謂的隨機數到底是什麼？通常從統計學的角度來說的隨機性是：一組沒有明顯模式或屬性能夠概括它的數的序列。</p></blockquote><p class=ql-align-center><br></p><div class=pgc-img><img alt="計算機實驗室之樹莓派：課程 7 屏幕02" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cce88d43876842dfb4a3208cfc134d0f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>這個方程受到以下的限制：</p><ol><li>a 是偶數</li><li>b = a + 1 mod 4</li><li>c 是奇數</li></ol><p>如果你之前沒有見到過 mod 運算，我來解釋一下，它的意思是被它後面的數相除之後的餘數。比如 b = a + 1 mod 4 的意思是 b 是 a + 1 除以 4 的餘數，因此，如果 a 是 12，那麼 b 將是 1，因為 a + 1 是 13，而 13 除以 4 的結果是 3 餘 1。</p><p>複製下列代碼到名為 random.s 的文件中。</p><blockquote><p>.globl Random</p><p>Random:</p><p>xnm .req r0</p><p>a .req r1</p><p>mov a,#0xef00</p><p>mul a,xnm</p><p>mul a,xnm</p><p>add a,xnm</p><p>.unreq xnm</p><p>add r0,a,#73</p><p>.unreq a</p><p>mov pc,lr</p></blockquote><p>這是隨機函數的一個實現，使用一個在寄存器 r0 中最後生成的值作為輸入，而接下來的數字則是輸出。在我的案例中，我使用 a = EF00<sub>16</sub>，b = 1, c = 73。這個選擇是隨意的，但是需要滿足上述的限制。你可以使用任何數字代替它們，只要符合上述的規則就行。</p><h1>4、Pi-casso</h1><p>OK，現在我們有了所有我們需要的函數，我們來試用一下它們。獲取幀緩衝信息的地址之後，按如下的要求修改 main：</p><ol><li>使用包含了幀緩衝信息地址的寄存器 r0 調用 SetGraphicsAddress。</li><li>設置四個寄存器為 0。一個將是最後的隨機數，一個將是顏色，一個將是最後的 x 座標，而最後一個將是最後的 y 座標。</li><li>調用 random 去產生下一個 x 座標，使用最後一個隨機數作為輸入。</li><li>調用 random 再次去生成下一個 y 座標，使用你生成的 x 座標作為輸入。</li><li>更新最後的隨機數為 y 座標。</li><li>使用 colour 值調用 SetForeColour，接著增加 colour 值。如果它大於 FFFF~16~，確保它返回為 0。</li><li>我們生成的 x 和 y 座標將介於 0 到 FFFFFFFF<sub>16</sub>。通過將它們邏輯右移 22 位，將它們轉換為介於 0 到 1023<sub>10</sub> 之間的數。</li><li>檢查 y 座標是否在屏幕上。驗證 y 座標是否介於 0 到 767<sub>10</sub> 之間。如果不在這個區間，返回到第 3 步。</li><li>從最後的 x 座標和 y 座標到當前的 x 座標和 y 座標之間繪製一條線。</li><li>更新最後的 x 和 y 座標去為當前的座標。</li><li>返回到第 3 步。</li></ol><p>一如既往，你可以在下載頁面上找到這個解決方案。</p><p>在你完成之後，在樹莓派上做測試。你應該會看到一系列顏色遞增的隨機線條以非常快的速度出現在屏幕上。它一直持續下去。如果你的代碼不能正常工作，請查看我們的排錯頁面。</p><p>如果一切順利，恭喜你！我們現在已經學習了有意義的圖形和隨機數。我鼓勵你去使用它繪製線條，因為它能夠用於渲染你想要的任何東西，你可以去探索更復雜的圖案了。它們中的大多數都可以由線條生成，但這需要更好的策略？如果你願意寫一個畫線程序，嘗試使用 SetPixel 函數。如果不是去設置像素值而是一點點地增加它，會發生什麼情況？你可以用它產生什麼樣的圖案？在下一節課 課程 8：屏幕 03 中，我們將學習繪製文本的寶貴技能。</p><hr><p>via: https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/screen02.html</p><p>作者： Alex Chadwick 選題： lujun9972 譯者： qhwdw 校對： wxy</p><p>本文由 LCTT 原創編譯， Linux中國 榮譽推出</p><h1>點擊“瞭解更多”可訪問文內鏈接</h1></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>計算機</a></li><li><a>實驗室</a></li><li><a>之樹莓</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html alt=計算機中數字、文字、圖像、聲音和視頻的表示與編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8d1d3ec88f2c4a158c7efe55b21d6ed7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html title=計算機中數字、文字、圖像、聲音和視頻的表示與編碼>計算機中數字、文字、圖像、聲音和視頻的表示與編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a937a7c6.html alt="「牛車實驗室」側部撞擊同樣危害巨大 盤點2019拆解車型車門結構" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S0MkSpqIps36mf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a937a7c6.html title="「牛車實驗室」側部撞擊同樣危害巨大 盤點2019拆解車型車門結構">「牛車實驗室」側部撞擊同樣危害巨大 盤點2019拆解車型車門結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/751f8a92.html alt="「牛車實驗室」車門的正確關閉方式很有講究 細看內部構造讓你恍然大悟" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RxX58RgAGbzd5D style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/751f8a92.html title="「牛車實驗室」車門的正確關閉方式很有講究 細看內部構造讓你恍然大悟">「牛車實驗室」車門的正確關閉方式很有講究 細看內部構造讓你恍然大悟</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html alt="“頂點”計算機面世 登頂超級計算機榜首" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15287045778959b8cdf2283 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html title="“頂點”計算機面世 登頂超級計算機榜首">“頂點”計算機面世 登頂超級計算機榜首</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html alt=美媒揭祕最新世界最快超級計算機“頂點” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html title=美媒揭祕最新世界最快超級計算機“頂點”>美媒揭祕最新世界最快超級計算機“頂點”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html alt=計算機求解微分方程的六大數值計算方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5b33cbb521894b5aa7f4cf8e1c795cf2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html title=計算機求解微分方程的六大數值計算方法>計算機求解微分方程的六大數值計算方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0724f87f.html alt="實驗室 for 工業鋅鎳合金廢水/次亞磷廢水/硝態氮廢水" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5c40a316c38245d0b7e727af93ee571f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0724f87f.html title="實驗室 for 工業鋅鎳合金廢水/次亞磷廢水/硝態氮廢水">實驗室 for 工業鋅鎳合金廢水/次亞磷廢水/硝態氮廢水</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/db935439.html alt="CMF實驗室 | 鎳合金" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/523606d1d81447dbb93a21e4d5ee767e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/db935439.html title="CMF實驗室 | 鎳合金">CMF實驗室 | 鎳合金</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/476788b3.html alt="「牛車實驗室」夾層玻璃/鋼化玻璃 汽車玻璃還有這麼多種類？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rx4HY0w8tJ7YKW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/476788b3.html title="「牛車實驗室」夾層玻璃/鋼化玻璃 汽車玻璃還有這麼多種類？">「牛車實驗室」夾層玻璃/鋼化玻璃 汽車玻璃還有這麼多種類？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html alt=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a03090d0e5804e88b4003fdcdfa7a301 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html title=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？>你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html alt=第一臺通用數字電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html title=第一臺通用數字電子計算機>第一臺通用數字電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html alt=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f30831efce324fd8ad5055d5c3312dfe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html title=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四>第一臺電子計算機的發明者諾依曼，中外發明家故事之十四</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html alt=計算機發展全歷程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/68bbbb84608c4db28b2cf2687596239a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html title=計算機發展全歷程>計算機發展全歷程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbc9d4e3.html alt=電子計算機的類別有些什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0a5e8724-b70f-4cdf-bebb-1091bfcd66d7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbc9d4e3.html title=電子計算機的類別有些什麼？>電子計算機的類別有些什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d2a4dab.html alt=五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/78bc8448e150430b99df693674b71771 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d2a4dab.html title=五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大>五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>