<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？ | 极客快訊</title><meta property="og:title" content="「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/24bf1fc955de499183243bc4f9fb6120"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/86177a0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><meta property="article:published_time" content="2020-10-29T20:58:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:42+08:00"><meta name=Keywords content><meta name=description content="「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/86177a0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h3 class=pgc-h-arrow-right>目錄</h3><ul><li>什麼是建造者模式</li><li>為什麼要使用建造者模式</li><li>構造函數創建對象</li><li>set方式構建對象</li><li>java實現建造者模式</li><ul><li>第一種實現方式</li><li>第二種方式</li></ul><li>建造者模式與構造函數的對比</li><li>建造者模式與工廠模式的對比</li><li>總結</li></ul><p><br></p><h1 class=pgc-h-arrow-right>什麼是建造者模式</h1><p>建造者模式是設計模式的一種，將一個複雜對象的構建與它的表示分離，使得同樣的構建過程可以創建不同的表示。</p><p>其實建造者模式是被翻譯過來的，他原名叫builder模式，也被稱為生成器模式，這種模式的實現非常的簡單，只是在使用方面可能會有點摸不著方向，它主要解決複雜的對象創建，比如參數過長、校驗過多等等。</p><h1 class=pgc-h-arrow-right>為什麼要使用建造者模式</h1><p>我們都知道，創建對象的方法有很多，new是我們最常見也是最熟悉的一種，我們為什麼不使用我們最熟悉的而選用建造者模式呢？雖然new是我們最熟悉的，但不一定是最合適的，為什麼這麼說呢？我們舉個例子來說明一下。</p><p>我們現在定義一個對象：ThreadConfig，ThreadConfig有5個屬性：核心線程數（corePoolSize）、最大線程數（maxPoolSize）、隊列數（queueCapacity）、空閒時間退出（keepAliveTime）、是否允許線程退出（allowCoreThreadTimeout）。屬性有必填、有選填。</p><p>屬性名必填默認值註釋threadName是線程名corePoolSize否4核心線程數maxPoolSize是核心線程數queueCapacity是最大線程數keepAliveTime是當線程空閒時間達到keepAliveTime，該線程會退出allowCoreThreadTimeout是是否允許核心線程數空閒時退出</p><p>創建對象的時候要滿足以下要求：1.最大線程數不傳，默認為核心線程數的大小。2.最大線程數不能小於核心線程數。3.如果填寫隊列數，隊列書不能小於等於0。4.如果填寫keepAliveTime，不能小於等於0。</p><p>看到這樣的一個對象，如果是你，你會怎麼設計他的對象創建呢？</p><h1 class=pgc-h-arrow-right>構造函數創建對象</h1><p>大家想到的第一種創建方式可能就是構造函數，那我們先使用構造函數實現一下這個對象的創建</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心線程默認值 */    private static final   Integer CORE_POOL_SIZE = 4;    private String threadName;    /** * 核心線程數 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大線程數 */    private Integer maxPoolSize;    /** * 隊列數 */    private Integer queueCapacity;    /** * 當線程空閒時間達到keepAliveTime，該線程會退出 */    private Integer keepAliveTime;    /** * 是否允許核心線程數空閒時退出 */    private boolean allowCoreThreadTimeout;    public ThreadConfig(String threadName,Integer corePoolSize,Integer maxPoolSize,Integer queueCapacity,Integer keepAliveTime) throws IllegalAccessException {        if(StringUtils.isEmpty(threadName)){            throw  new IllegalAccessException("線程名不能為空！");        }        this.threadName = threadName;        if(null != corePoolSize ){            if( corePoolSize &lt;= 0){                throw  new IllegalAccessException("核心線程數不能小於等於0！");            }            this.corePoolSize = corePoolSize;        }        if(null != maxPoolSize  ){            if(maxPoolSize &lt; this.corePoolSize){                throw  new IllegalAccessException("最大線程數不能小於核心線程數！");            }            this.maxPoolSize = corePoolSize;        }        if(null != queueCapacity ){            if( queueCapacity &lt;= 0 ){                throw  new IllegalAccessException("隊列書不能小於等於0！");            }            this.queueCapacity = queueCapacity;        }        if(null != keepAliveTime  ){            if( keepAliveTime &lt;= 0 ){                throw  new IllegalAccessException("空閒時間不能小於等於0！");            }            this.keepAliveTime = keepAliveTime;        }    }}</code></pre><p>@ToString註解是lombok依賴提供的</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><p>創建對象</p><pre><code>package com.ymy.builder;public class Test {    public static void main(String[] args) throws IllegalAccessException {        ThreadConfig config = new ThreadConfig("thread-1",5,2,5,10);        System.out.println(config);    }}</code></pre><p>輸出結果：</p><pre><code>Exception in thread "main" java.lang.IllegalAccessException: 最大線程數不能小於核心線程數！	at com.ymy.builder.ThreadConfig.&lt;init&gt;(ThreadConfig.java:56)	at com.ymy.builder.Test.main(Test.java:6)</code></pre><p>我這裡給出的核心線程數：5，但是最大線程數給的2，所以會拋出最大線程數不能小於核心線程數！這種方式看著很完美，但有一點很不友好，當參數過多的時候容易出錯，為什麼這麼說呢？你仔細看這行代碼</p><pre><code>ThreadConfig config = new ThreadConfig("thread-1",5,2,5,10);</code></pre><p>除了第一個參數，其他參數都是int類型，看著好像沒啥大毛病，這是因為我的參數還不夠多，如果我這裡有10個參數需要傳遞，並且都是int類型，這時候就會存在一個問題，參數很可能會被寫錯，比如最大線程數寫到了隊列數中，而且有時候還不會報錯，只有在項目運行的時候才會出現某種讓人摸不著頭腦的bug，所以使用構造函數創建對象的時候不太適合參數過長，不但容易出錯，而且讓接手代碼的人也頭痛，代碼可讀性比較差，當然當參數只有一兩個的時候，構造函數的創建方式還是很不錯的。</p><h1 class=pgc-h-arrow-right>set方式構建對象</h1><p>既然構造函數會導致參數錯誤以及可讀性較差，那我們能不能使用構造函數+set方法來創建對象呢？我們可以嘗試一下，由於只有線程名是必傳，所以構造函數只給定線程名，其他屬性都通過set賦值，改造一下代碼。</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心線程默認值 */    private static final   Integer CORE_POOL_SIZE = 4;    private String threadName;    /** * 核心線程數 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大線程數 */    private Integer maxPoolSize;    /** * 隊列數 */    private Integer queueCapacity;    /** * 當線程空閒時間達到keepAliveTime，該線程會退出 */    private Integer keepAliveTime;    /** * 是否允許核心線程數空閒時退出 */    private boolean allowCoreThreadTimeout;        public ThreadConfig(String threadName) throws IllegalAccessException {        if(StringUtils.isEmpty(threadName)){            throw  new IllegalAccessException("線程名不能為空！");        }        this.threadName = threadName;    }    public void setCorePoolSize(Integer corePoolSize) throws IllegalAccessException {        if(null != corePoolSize ){            if( corePoolSize &lt;= 0){                throw  new IllegalAccessException("核心線程數不能小於等於0！");            }            this.corePoolSize = corePoolSize;        }    }    public void setMaxPoolSize(Integer maxPoolSize) throws IllegalAccessException {        if(null != maxPoolSize  ){            if(maxPoolSize &lt; this.corePoolSize){                throw  new IllegalAccessException("最大線程數不能小於核心線程數！");            }            this.maxPoolSize = corePoolSize;        }    }    public void setQueueCapacity(Integer queueCapacity) throws IllegalAccessException {        if(null != queueCapacity ){            if( queueCapacity &lt;= 0 ){                throw  new IllegalAccessException("隊列書不能小於等於0！");            }            this.queueCapacity = queueCapacity;        }    }    public void setKeepAliveTime(Integer keepAliveTime) throws IllegalAccessException {        if(null != keepAliveTime  ){            if( keepAliveTime &lt;= 0 ){                throw  new IllegalAccessException("空閒時間不能小於等於0！");            }            this.keepAliveTime = keepAliveTime;        }    }    public void setAllowCoreThreadTimeout(boolean allowCoreThreadTimeout) {        this.allowCoreThreadTimeout = allowCoreThreadTimeout;    }}</code></pre><p>改造完ThreadConfig之後我們創建對象的方式也會發生細微的變化，由之前構造函數傳遞一堆參數變成了一個參數，加上了set方法，初始值由set給定。</p><pre><code>package com.ymy.builder;public class Test {    public static void main(String[] args) throws IllegalAccessException {        ThreadConfig config = new ThreadConfig("thread-1");        config.setCorePoolSize(5);        config.setMaxPoolSize(10);        config.setQueueCapacity(2);        config.setKeepAliveTime(100);        config.setAllowCoreThreadTimeout(false);        System.out.println(config);    }}</code></pre><p>這種對象的創建方式可以有效的防止賦值屬性錯亂的問題，因為看上去一目瞭然，基本上不會出錯，代碼可讀性也很強，完美的解決了將所有參數都放在構造函數的缺陷，那為什麼還會出現建造者模式呢？可以仔細想一下，set方法這麼完美，建造者模式還有必要嗎？我覺得建造者模式的出現並不是偶然。</p><p>我們現在稍微修改一下需求：當corePoolSize（核心線程數）被賦值的時候，最大線程數也必須要賦值，這個時候你覺得set方法還能滿足嗎？我覺得應該是滿足不了了吧，這是一種情況，還有一種情況set也是滿足不了的，那就是我希望對象初始化的時候一次性將所有的屬性都賦值，之後將不能被修改，這一點也是set做不到的，set方法就是提供給調用者的，所以調用者可以通過set隨時修改ThreadConfig的屬性，如果處理不當，可能會造成某種安全隱患，這個時候你可能又想到，把corePoolSize、maxPoolSize也放到構造函數中不就解決了corePoolSize賦值的時候maxPoolSize也一定要賦值的要求嗎，確實是能解決這個問題，如果像這樣的參數很多呢？然後又有可能出現參數傳錯導致詭異bug，所這時候建造者模式就閃亮登場了。</p><h1 class=pgc-h-arrow-right>java實現建造者模式</h1><h2 class=pgc-h-arrow-right>第一種實現方式</h2><p>既然構造函數和set方法無法滿足我們的需求，那自然會有滿足我們需求的新技術出現，按照之前的需求，線程名必填、corePoolSize（核心線程數）被賦值的時候，最大線程數也必須要賦值，我們一起使用建造模式來實現一下這個對象的創建。</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心線程默認值 */    private static final   Integer CORE_POOL_SIZE = 4;    /** * 線程名 */    private String threadName;    /** * 核心線程數 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大線程數 */    private Integer maxPoolSize;    /** * 隊列數 */    private Integer queueCapacity;    /** * 當線程空閒時間達到keepAliveTime，該線程會退出 */    private Integer keepAliveTime;    /** * 是否允許核心線程數空閒時退出 */    private boolean allowCoreThreadTimeout;        private ThreadConfig(ThreadConfig.Builder builder) {        this.threadName = builder.threadName;        if(null != builder.corePoolSize){            this.corePoolSize = builder.corePoolSize;        }        this.maxPoolSize = builder.maxPoolSize;        this.queueCapacity = builder.queueCapacity;        this.keepAliveTime = builder.keepAliveTime;        this.allowCoreThreadTimeout = builder.allowCoreThreadTimeout;    }    public static class Builder {        /** * 線程名 */        private String threadName;        /** * 核心線程數 */        private Integer corePoolSize ;        /** * 最大線程數 */        private Integer maxPoolSize;        /** * 隊列數 */        private Integer queueCapacity;        /** * 當線程空閒時間達到keepAliveTime，該線程會退出 */        private Integer keepAliveTime;        /** * 是否允許核心線程數空閒時退出 */        private boolean allowCoreThreadTimeout;        public ThreadConfig build() throws IllegalAccessException { // 校驗邏輯放到這裡來做，包括必填項校驗、依賴關係校驗、約束條件校驗等            if (StringUtils.isEmpty(threadName)) {                throw new IllegalAccessException("線程名不能為空");            }           if(corePoolSize != null &amp;&amp; maxPoolSize == null){               throw new IllegalAccessException("最大線程數必傳");           }            return new ThreadConfig(this);        }        public ThreadConfig.Builder corePoolSize(int corePoolSize) {            if (corePoolSize &lt;= 0) {                throw new IllegalArgumentException("核心線程數不能小於等於0");            }            this.corePoolSize = corePoolSize;            return this;        }        public ThreadConfig.Builder threadName(String threadName) {            this.threadName = threadName;            return this;        }        public ThreadConfig.Builder maxPoolSize(int maxPoolSize) {            if (maxPoolSize &lt; this.corePoolSize) {                throw new IllegalArgumentException("最大線程數不能小於核心線程數");            }            this.maxPoolSize = maxPoolSize;            return this;        }        public ThreadConfig.Builder queueCapacity(int queueCapacity) {            if (queueCapacity &lt;= 0) {                throw new IllegalArgumentException("隊列不能小於等於0");            }            this.queueCapacity = queueCapacity;            return this;        }        public ThreadConfig.Builder keepAliveTime(int keepAliveTime) {            if (keepAliveTime &lt;= 0) {                throw new IllegalArgumentException("保持空閒線程可用的時間不能小於等於0");            }            this.keepAliveTime = keepAliveTime;            return this;        }        public ThreadConfig.Builder allowCoreThreadTimeout(boolean allowCoreThreadTimeout) {            this.allowCoreThreadTimeout = allowCoreThreadTimeout;            return this;        }    }}</code></pre><p>我們來測試，傳入核心線程數不傳最先線程數</p><pre><code>package com.ymy.builder;public class Test {    public static void main(String[] args) throws IllegalAccessException {        ThreadConfig config = new ThreadConfig.Builder()                .threadName("hello")                .corePoolSize(3)                .keepAliveTime(100)                .queueCapacity(2)                .allowCoreThreadTimeout(true)                .build();        System.out.println(config);    }}</code></pre><p>打印結果</p><pre><code>Exception in thread "main" java.lang.IllegalAccessException: 最大線程數必傳	at com.ymy.builder.ThreadConfig$Builder.build(ThreadConfig.java:89)	at com.ymy.builder.Test.main(Test.java:12)</code></pre><p>核心線程數不傳</p><pre><code> ThreadConfig config = new ThreadConfig.Builder()                .threadName("hello")                //.corePoolSize(3)                .keepAliveTime(100)                .queueCapacity(2)                .allowCoreThreadTimeout(true)                .build();        System.out.println(config);</code></pre><p>結果</p><pre><code>ThreadConfig(threadName=hello, corePoolSize=4, maxPoolSize=null, queueCapacity=2, keepAliveTime=100, allowCoreThreadTimeout=true)Process finished with exit code 0</code></pre><p>這就說明已經達到了我們的預期效果，並且賦值清晰，不容易出錯，代碼的可讀性也比較高，但是也有一點是不足的，那就是ThreadConfig類中會出現冗餘的數據Builder。</p><p>建造者模式的參數校驗放在了build()方法中，這樣做法的好處在於build是集中的處理參數問題，只有校驗通過之後才會給ThreadConfig對象實例化，為了對象的安全性，我們可以將ThreadConfig的構造函數設置成private，同時取消set方法，強制使用builder方式創建對象，這樣就大大的保證了對象的安全性。</p><h2 class=pgc-h-arrow-right>第二種方式</h2><p>上面那種方式看著是不是很爽，但是創建對象的時候還是需要new ThreadConfig.Builder()，我現在想直接ThreadConfig.Builder()就能創建對象，我不想看到new，能不能實現呢？相信java，他能，我們一起來改造一下代碼</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心線程默認值 */    private static final   Integer CORE_POOL_SIZE = 4;    /** * 線程名 */    private String threadName;    /** * 核心線程數 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大線程數 */    private Integer maxPoolSize;    /** * 隊列數 */    private Integer queueCapacity;    /** * 當線程空閒時間達到keepAliveTime，該線程會退出 */    private Integer keepAliveTime;    /** * 是否允許核心線程數空閒時退出 */    private boolean allowCoreThreadTimeout;    private ThreadConfig(ThreadConfig.Builder builder) {        this.threadName = builder.threadName;        if(null != builder.corePoolSize){            this.corePoolSize = builder.corePoolSize;        }        this.maxPoolSize = builder.maxPoolSize;        this.queueCapacity = builder.queueCapacity;        this.keepAliveTime = builder.keepAliveTime;        this.allowCoreThreadTimeout = builder.allowCoreThreadTimeout;    }    /** * 使用靜態方法替代new * @return */    public static Builder builder() {        return new Builder();    }    public static class Builder {        /** * 構造函數，可以不寫 */        Builder(){        }        /** * 線程名 */        private String threadName;        /** * 核心線程數 */        private Integer corePoolSize ;        /** * 最大線程數 */        private Integer maxPoolSize;        /** * 隊列數 */        private Integer queueCapacity;        /** * 當線程空閒時間達到keepAliveTime，該線程會退出 */        private Integer keepAliveTime;        /** * 是否允許核心線程數空閒時退出 */        private boolean allowCoreThreadTimeout;        public ThreadConfig build() throws IllegalAccessException { // 校驗邏輯放到這裡來做，包括必填項校驗、依賴關係校驗、約束條件校驗等            if (StringUtils.isEmpty(threadName)) {                throw new IllegalAccessException("線程名不能為空");            }           if(corePoolSize != null &amp;&amp; maxPoolSize == null){               throw new IllegalAccessException("最大線程數必傳");           }            return new ThreadConfig(this);        }        public ThreadConfig.Builder corePoolSize(int corePoolSize) {            if (corePoolSize &lt;= 0) {                throw new IllegalArgumentException("核心線程數不能小於等於0");            }            this.corePoolSize = corePoolSize;            return this;        }        public ThreadConfig.Builder threadName(String threadName) {            this.threadName = threadName;            return this;        }        public ThreadConfig.Builder maxPoolSize(int maxPoolSize) {            if (maxPoolSize &lt; this.corePoolSize) {                throw new IllegalArgumentException("最大線程數不能小於核心線程數");            }            this.maxPoolSize = maxPoolSize;            return this;        }        public ThreadConfig.Builder queueCapacity(int queueCapacity) {            if (queueCapacity &lt;= 0) {                throw new IllegalArgumentException("隊列不能小於等於0");            }            this.queueCapacity = queueCapacity;            return this;        }        public ThreadConfig.Builder keepAliveTime(int keepAliveTime) {            if (keepAliveTime &lt;= 0) {                throw new IllegalArgumentException("保持空閒線程可用的時間不能小於等於0");            }            this.keepAliveTime = keepAliveTime;            return this;        }        public ThreadConfig.Builder allowCoreThreadTimeout(boolean allowCoreThreadTimeout) {            this.allowCoreThreadTimeout = allowCoreThreadTimeout;            return this;        }    }}</code></pre><p>其實改動很小僅僅只是加了一個static Builder builder()，使用靜態方法替代new對象，這樣我們創建對象的時候就不需要new了，請看創建對象代碼</p><pre><code>ThreadConfig config =ThreadConfig.builder()                .threadName("hello")               // .corePoolSize(3)                .keepAliveTime(100)                .queueCapacity(2)                .allowCoreThreadTimeout(true)                .build();        System.out.println(config);</code></pre><p>是不是爽多了，看著真舒服，不過話說回來，你們看這種創建方式想不想lombok中給對象加了@Builder註解之後的創建方式？沒錯，就是一樣的，因為lombok中的@Builder就是建造者模式，只不過他的build並沒有我們這裡的條件判斷，他是直接將屬性返回了。</p><h1 class=pgc-h-arrow-right>建造者模式與構造函數的對比</h1><p>**構造函數：**適用於參數較少，邏輯簡單的對象創建，對於參數過多的對象創建可能會造成參數錯亂的問題而導致詭異bug。</p><p>**建造者模式：**適用於參數較多，邏輯判斷較複雜的對象創建，可以讓代碼簡潔明瞭，但是對象的代碼增加了，不但增加了很多冗餘字段，所以有時候表面看起來光鮮亮麗，內心卻是無比醜陋。</p><h1 class=pgc-h-arrow-right>建造者模式與工廠模式的對比</h1><p>對工廠模式還不太明白的朋友可以參考一下：工廠模式：你還在使用一堆的if/else創建對象嗎？我們知道工廠模式主要是創建一個類型多個實現的對象，比如發送短信驗證碼的處理方式有很多種情況，每種情況的處理方式都不相同，還有就是創建對象的時候需要經過很多的判斷，這種情況下我們就可以考慮使用工廠模式來創建對象。</p><p>如果對象的職責比較單一，沒有多層含義，僅僅只是創建條件複雜，參數過多等等，使用建造者模式創建對象是首選，雖然對象中含有冗餘代碼，但是對象的創建真的很絲滑。</p><h1 class=pgc-h-arrow-right>總結</h1><p>如果一個類中包含著大量的屬性，我們可以通過構造函數+set方法來進行對象創建，但對象如果包含一下幾點特性，那麼我推薦使用建造者模式。1.必填的字段很多，這樣會導致構造函數參數過長的問題。<br>2.如果屬性與屬性之間關聯性很強，比如設置了核心線程數就必須要設置最大線程數，這種情況下set方法是無法做到校驗的。<br>3.如果當前對象比較重要，我們希望對象被創建之後就不能被修改，所以這時候set方法就會被屏蔽，如果利用構造函數，又會出現字段過多問題。</p><p>當然了，我們不能為了用設計模式而用設計模式，對象一共就兩個屬性，我們也給他弄成建造者模式，這就有點大材小用，適得其反，一定要結合的實際的項目需求，不能盲目使用。</p><div class=pgc-img><img alt=「設計模式」建造者模式：你創建對象的方式有它絲滑嗎？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/24bf1fc955de499183243bc4f9fb6120><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>模式</a></li><li><a>設計</a></li><li><a>創建</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/210ccbc7.html alt=設計模式專題07-適配模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/61e5bbbccefd445ca47e5ac95ad5c655 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/210ccbc7.html title=設計模式專題07-適配模式>設計模式專題07-適配模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48a6b6a.html alt="5 PHP 設計模式系列「對象池模式（Object Pool）」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29c712d86aa04c48ad6b0d262ed8026e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48a6b6a.html title="5 PHP 設計模式系列「對象池模式（Object Pool）」">5 PHP 設計模式系列「對象池模式（Object Pool）」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/738616e.html alt=簡說設計模式之設計模式概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1b30f3e2a7f142c0b14470e6e23fa214 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/738616e.html title=簡說設計模式之設計模式概述>簡說設計模式之設計模式概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2463a2a.html alt=面向對象的可複用設計模式-裝飾模式（java代碼實現） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b27d2e0e6d6347d5aa5a0633d8867ea4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2463a2a.html title=面向對象的可複用設計模式-裝飾模式（java代碼實現）>面向對象的可複用設計模式-裝飾模式（java代碼實現）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1059237.html alt=面向對象的可複用設計模式之中介者模式（18/24） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4afbebaa300046e6be67c5085faaf5ac style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1059237.html title=面向對象的可複用設計模式之中介者模式（18/24）>面向對象的可複用設計模式之中介者模式（18/24）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a3ab9c.html alt=設計模式之對象池模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153421232504357f6330f7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a3ab9c.html title=設計模式之對象池模式>設計模式之對象池模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3756335.html alt=設計模式之空對象設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6ea14e17fa9b49ccaa5079bd6d256f1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3756335.html title=設計模式之空對象設計模式>設計模式之空對象設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d69059.html alt=設計模式實踐系列：面向對象經典的設計原則及設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d69059.html title=設計模式實踐系列：面向對象經典的設計原則及設計模式>設計模式實踐系列：面向對象經典的設計原則及設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a9b14d6.html alt=面向對象的可複用設計模式之裝飾模式（10/24） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/55017ba25c1a44e1a73201f0542b0858 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a9b14d6.html title=面向對象的可複用設計模式之裝飾模式（10/24）>面向對象的可複用設計模式之裝飾模式（10/24）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/298dfd0.html alt="JavaScript設計模式之適配器模式（Adaptor Pattern）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/eb26d1ff-cac4-452b-bd03-089b79157a6a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/298dfd0.html title="JavaScript設計模式之適配器模式（Adaptor Pattern）">JavaScript設計模式之適配器模式（Adaptor Pattern）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c5ca3c1.html alt=Java描述設計模式(07)：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3d0d9f42897848478e118ef916ba1624 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c5ca3c1.html title=Java描述設計模式(07)：適配器模式>Java描述設計模式(07)：適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc8c270.html alt=Java設計模式7：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4fb24e6568784c2bbc8b86a9a6f7027d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc8c270.html title=Java設計模式7：適配器模式>Java設計模式7：適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3bed020.html alt=Java設計模式之適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1a3bb08006b4da3b69b1e1c7fcee9fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3bed020.html title=Java設計模式之適配器模式>Java設計模式之適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/46f4759.html alt=Java設計模式（十四）：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5941000582d4f8ab6030 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/46f4759.html title=Java設計模式（十四）：適配器模式>Java設計模式（十四）：適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd56204.html alt=Java設計模式：適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15403119502118dec1fd1d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd56204.html title=Java設計模式：適配器模式>Java設計模式：適配器模式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>