<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>愛了愛了，這篇寄存器講的有點意思 | 极客快訊</title><meta property="og:title" content="愛了愛了，這篇寄存器講的有點意思 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1474850b301846588e8f1a90ce2fd818"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><meta property="article:published_time" content="2020-10-29T21:04:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:04+08:00"><meta name=Keywords content><meta name=description content="愛了愛了，這篇寄存器講的有點意思"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8684f0b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>愛了愛了，這篇寄存器講的有點意思</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>作 者：程序員cxuan</p><p>原文鏈接：https://mp.weixin.qq.com/s/Okpdf90VpbuO7XfI3N3WgQ</p></blockquote><p>下面我們就來介紹一下關於寄存器的相關內容。我們知道，<span style="color:#3594f7;--tt-darkmode-color: #3594F7">寄存器</span>是 CPU 內部的構造，它主要用於信息的存儲。除此之外，CPU 內部還有<span style="color:#3594f7;--tt-darkmode-color: #3594F7">運算器</span>，負責處理數據；<span style="color:#3594f7;--tt-darkmode-color: #3594F7">控制器</span>控制其他組件；<span style="color:#3594f7;--tt-darkmode-color: #3594F7">外部總線</span>連接 CPU 和各種部件，進行數據傳輸；<span style="color:#3594f7;--tt-darkmode-color: #3594F7">內部總線</span>負責 CPU 內部各種組件的數據處理。</p><p>那麼對於我們所瞭解的彙編語言來說，我們的主要關注點就是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">寄存器</span>。</p><p>為什麼會出現寄存器？因為我們知道，程序在內存中裝載，由 CPU 來運行，CPU 的主要職責就是用來處理數據。那麼這個過程勢必涉及到從存儲器中讀取和寫入數據，因為它涉及通過控制總線發送數據請求並進入存儲器存儲單元，通過同一通道獲取數據，這個過程非常的繁瑣並且會涉及到大量的內存佔用，而且有一些常用的內存頁存在，其實是沒有必要的，因此出現了寄存器，存儲在 CPU 內部。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">認識寄存器</span></strong></h1><p>寄存器的官方叫法有很多，Wiki 上面的叫法是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">Processing Register</span>， 也可以稱為<span style="color:#3594f7;--tt-darkmode-color: #3594F7">CPU Register</span>，計算機中經常有一個東西多種叫法的情況，反正你知道都說的是寄存器就可以了。</p><p>認識寄存器之前，我們首先先來看一下 CPU 內部的構造。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1474850b301846588e8f1a90ce2fd818><p class=pgc-img-caption></p></div><p>CPU 從邏輯上可以分為 3 個模塊，分別是控制單元、運算單元和存儲單元，這三部分由 CPU 內部總線連接起來。</p><p>幾乎所有的馮·諾伊曼型計算機的 CPU，其工作都可以分為5個階段：<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「取指令、指令譯碼、執行指令、訪存取數、結果寫回」</span></strong>。</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">取指令</span>階段是將內存中的指令讀取到 CPU 中寄存器的過程，程序寄存器用於存儲下一條指令所在的地址</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">指令譯碼</span>階段，在取指令完成後，立馬進入指令譯碼階段，在指令譯碼階段，指令譯碼器按照預定的指令格式，對取回的指令進行拆分和解釋，識別區分出不同的指令類別以及各種獲取操作數的方法。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">執行指令</span>階段，譯碼完成後，就需要執行這一條指令了，此階段的任務是完成指令所規定的各種操作，具體實現指令的功能。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">訪問取數</span>階段，根據指令的需要，有可能需要從內存中提取數據，此階段的任務是：根據指令地址碼，得到操作數在主存中的地址，並從主存中讀取該操作數用於運算。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">結果寫回</span>階段，作為最後一個階段，結果寫回（Write Back，WB）階段把執行指令階段的運行結果數據寫回到 CPU 的內部寄存器中，以便被後續的指令快速地存取；</li></ul><h1 class=pgc-h-arrow-right><strong>計算機架構中的寄存器</strong></h1><p>寄存器是一塊速度非常快的計算機內存，下面是現代計算機中具有存儲功能的部件比對，可以看到，寄存器的速度是最快的，同時也是造價最高昂的。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/625fd1d0501a4351914eff653751f9ee><p class=pgc-img-caption></p></div><p>我們以 intel 8086 處理器為例來進行探討，8086 處理器是 x86 架構的前身。在 8086 後面又衍生出來了 8088 。</p><p>在 8086 CPU 中，地址總線達到 20 根，因此最大尋址能力是 2^20 次冪也就是 1MB 的尋址能力，8088 也是如此。</p><p>在 8086 架構中，所有的內部寄存器、內部以及外部總線都是 16 位寬，可以存儲兩個字節，因為是完全的 16 位微處理器。8086 處理器有 14 個寄存器，每個寄存器都有一個特有的名稱，即</p><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES」</span></strong></p><p>這 14 個寄存器有可能進行具體的劃分，按照功能可以分為三種</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">通用寄存器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">控制寄存器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">段寄存器</span></li></ul><p>下面我們分別介紹一下這幾種寄存器</p><h1 class=pgc-h-arrow-right><strong>通用寄存器</strong></h1><p>通用寄存器主要有四種 ，即 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「AX、BX、CX、DX」</span></strong> 同樣的，這四個寄存器也是 16 位的，能存放兩個字節。AX、BX、CX、DX 這四個寄存器一般用來存放數據，也被稱為 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">數據寄存器</span>。它們的結構如下</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/234444186df348319db3e1db0d8e17ea><p class=pgc-img-caption></p></div><p>8086 CPU 的上一代寄存器是 8080 ，它是一類 8 位的 CPU，為了保證兼容性，8086 在 8080 上做了很小的修改，8086 中的通用寄存器 AX、BX、CX、DX 都可以獨立使用兩個 8 位寄存器來使用。</p><p>在細節方面，AX、BX、CX、DX 可以再向下進行劃分</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">AX(Accumulator Register)</span> ：累加寄存器，它主要用於輸入/輸出和大規模的指令運算。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">BX(Base Register)</span>：基址寄存器，用來存儲基礎訪問地址</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">CX(Count Register)</span>：計數寄存器，CX 寄存器在迭代的操作中會循環計數</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">DX(data Register)</span>：數據寄存器，它也用於輸入/輸出操作。它還與 AX 寄存器以及 DX 一起使用，用於涉及大數值的乘法和除法運算。</li></ul><p>這四種寄存器可以分為上半部分和下半部分，用作八個 8 位數據寄存器</p><ul><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「AX 寄存器可以分為兩個獨立的 8 位的 AH 和 AL 寄存器；」</span></strong></li><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「BX 寄存器可以分為兩個獨立的 8 位的 BH 和 BL 寄存器；」</span></strong></li><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「CX 寄存器可以分為兩個獨立的 8 位的 CH 和 CL 寄存器；」</span></strong></li><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「DX 寄存器可以分為兩個獨立的 8 位的 DH 和 DL 寄存器；」</span></strong></li></ul><p>除了上面 AX、BX、CX、DX 寄存器以外，其他寄存器均不可以分為兩個獨立的 8 位寄存器</p><p>如下圖所示。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4082f09df4a3418aa8be38696d328c0c><p class=pgc-img-caption></p></div><p>合起來就是</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e0bae8c7a392491db8220c1803b86ffd><p class=pgc-img-caption></p></div><p>AX 的低位（0 - 7）位構成了 AL 寄存器，高 8 位（8 - 15）位構成了 AH 寄存器。AH 和 AL 寄存器是可以使用的 8 位寄存器，其他同理。</p><p>在認識了寄存器之後，我們通過一個示例來看一下數據的具體存儲方式。</p><p>比如數據 19 ，它在 16 位存儲器中所存儲的表示如下</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8c0aaa6c24ca44f099f08712e10664d0><p class=pgc-img-caption></p></div><p>寄存器的存儲方式是先存儲低位，如果低位滿足不了就存儲高位，如果低位能夠滿足，高位用 0 補全，在其他低位能滿足的情況下，其餘位也用 0 補全。</p><p>8086 CPU 可以一次存儲兩種類型的數據</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">字節(byte)</span>：一個字節由 8 bit 組成，這是一種恆定不變的存儲方式</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">字(word)</span>：字是由指令集或處理器硬件作為單元處理的固定大小的數據，對於 intel 來說，一個字長就是兩個字節，字是計算機一個非常重要的特徵，針對不同的指令集架構來說，計算機一次處理的數據也是不同的。也就是說，針對不同指令集的機器，一次能處理不用的字長，有字、雙字（32位）、四字（64位）等。</li></ul><h1 class=pgc-h-arrow-right><strong>AX 寄存器</strong></h1><p>我們上面探討過，AX 的另外一個名字叫做累加寄存器或者簡稱為累加器，其可以分為 2 個獨立的 8 位寄存器 AH 和 AL；在編寫彙編程序中，AX 寄存器可以說是使用頻率最高的寄存器。</p><p>下面是幾段彙編代碼</p><pre><code>mov ax,20   /* 將 20 送入寄存器 AX*/mov ah,80   /* 將 80 送入寄存器 AH*/add ax,10   /* 將寄存器 AX 中的數值加上 8 */</code></pre><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">這裡注意下：上面代碼中出現的是 ax、ah ，而註釋中</span><span style="color:#595959;--tt-darkmode-color: #595959">確是</span><span style="color:#595959;--tt-darkmode-color: #595959"> AX、AH ，其實含義是一樣的，不區分大小寫。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>AX 相比於其他通用寄存器來說，有一點比較特殊，AX 具有一種特殊功能的使用，那就是使用 DIV 和 MUL 指令式使用。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">DIV 是 8086 CPU 中的</span><span style="color:#3594f7;--tt-darkmode-color: #3594F7">除法</span>指令。</p><p><span style="color:#595959;--tt-darkmode-color: #595959">MUL 是 8086 CPU 中的</span><span style="color:#3594f7;--tt-darkmode-color: #3594F7">乘法</span>指令。</p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>BX 寄存器</strong></h1><p>BX 被稱為數據寄存器，即表明其能夠暫存一般數據。同樣為了適應以前的 8 位 CPU ，而可以將 BX 當做兩個獨立的 8 位寄存器使用，即有 BH 和 BL。BX 除了具有暫存數據的功能外，還用於 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">尋址</span>，即尋找物理內存地址。BX 寄存器中存放的數據一般是用來作為<span style="color:#3594f7;--tt-darkmode-color: #3594F7">偏移地址</span> 使用的，因為偏移地址當然是在基址地址上的偏移了。偏移地址是在段寄存器中存儲的，關於段寄存器的介紹，我們後面再說。</p><h1 class=pgc-h-arrow-right><strong>CX 寄存器</strong></h1><p>CX 也是數據寄存器，能夠暫存一般性數據。同樣為了適應以前的 8 位 CPU ，而可以將 CX 當做兩個獨立的 8 位寄存器使用，即有 CH 和 CL。除此之外，CX 也是有其專門的用途的，CX 中的 C 被翻譯為 Counting 也就是計數器的功能。當在彙編指令中使用循環 LOOP 指令時，可以通過 CX 來指定需要循環的次數，每次執行循環 LOOP 時候，CPU 會做兩件事</p><ul><li>一件事是計數器自動減 1</li><li>還有一件就是判斷 CX 中的值，如果 CX 中的值為 0 則會跳出循環，而繼續執行循環下面的指令，當然如果 CX 中的值不為 0 ，則會繼續執行循環中所指定的指令 。</li></ul><h1 class=pgc-h-arrow-right><strong>DX 寄存器</strong></h1><p>DX 也是數據寄存器，能夠暫存一般性數據。同樣為了適應以前的 8 位 CPU ，DX 的用途其實在前面介紹 AX 寄存器時便已經有所介紹了，那就是支持 MUL 和 DIV 指令。同時也支持數值溢出等。</p><h1 class=pgc-h-arrow-right><strong>段寄存器</strong></h1><p>CPU 包含四個段寄存器，用作程序指令，數據或棧的基礎位置。實際上，對 IBM PC 上所有內存的引用都包含一個段寄存器作為基本位置。</p><p>段寄存器主要包含</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">CS(Code Segment)</span> ：代碼寄存器，程序代碼的基礎位置</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">DS(Data Segment)</span>：數據寄存器，變量的基本位置</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">SS(Stack Segment)</span>：棧寄存器，棧的基礎位置</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">ES(Extra Segment)</span>：其他寄存器，內存中變量的其他基本位置。</li></ul><h1 class=pgc-h-arrow-right><strong>索引寄存器</strong></h1><p>索引寄存器主要包含段地址的偏移量，索引寄存器主要分為</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">BP(Base Pointer)</span>：基礎指針，它是棧寄存器上的偏移量，用來定位棧上變量</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">SP(Stack Pointer)</span>: 棧指針，它是棧寄存器上的偏移量，用來定位棧頂</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">SI(Source Index)</span>: 變址寄存器，用來拷貝源字符串</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">DI(Destination Index)</span>: 目標變址寄存器，用來複制到目標字符串</li></ul><h1 class=pgc-h-arrow-right><strong>狀態和控制寄存器</strong></h1><p>就剩下兩種寄存器還沒聊了，這兩種寄存器是指令指針寄存器和標誌寄存器：</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">IP(Instruction Pointer)</span>：指令指針寄存器，它是從 Code Segment 代碼寄存器處的偏移來存儲執行的下一條指令</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">FLAG</span> : Flag 寄存器用於存儲當前進程的狀態，這些狀態有</li><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">位置 (Direction)：用於數據塊的傳輸方向，是向上傳輸還是向下傳輸</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">中斷標誌位 (Interrupt) ：1 - 允許；0 - 禁止</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">陷入位 (Trap) ：確定每條指令執行完成後，CPU 是否應該停止。1 - 開啟，0 - 關閉</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">進位 (Carry) : 設置最後一個無符號算術運算是否帶有進位</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">溢出 (Overflow) : 設置最後一個有符號運算是否溢出</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">符號 (Sign) : 如果最後一次算術運算為負，則設置 1 =負，0 =正</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">零位 (Zero) : 如果最後一次算術運算結果為零，1 = 零</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">輔助進位 (Aux Carry) ：用於第三位到第四位的進位</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">奇偶校驗 (Parity) : 用於奇偶校驗</span></li></ul></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">物理地址</span></strong></h1><p>我們大家都知道， CPU 訪問內存時，需要知道訪問內存的具體地址，內存單元是內存的基本單位，每一個內存單元在內存中都有唯一的地址，這個地址即是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">物理地址</span>。而 CPU 和內存之間的交互有三條總線，即數據總線、控制總線和地址總線。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f0db68e6684d48dcb7b60c7969bc720f><p class=pgc-img-caption></p></div><p>CPU 通過地址總線將物理地址送入存儲器，那麼 CPU 是如何形成的物理地址呢？這將是我們接下來的討論重點。</p><p>現在，我們先來討論一下和 8086 CPU 有關的結構問題。</p><p>cxuan 和你聊了這麼久，你應該知道 8086 CPU 是 16 位的 CPU 了，那麼，什麼是 16 位的 CPU 呢？</p><p>你可能大致聽過這個回答，16 位 CPU 指的是 CPU 一次能處理的數據是 16 位的，能回答這個問題代表你的底層還不錯，但是不夠全面，其實，16 位的 CPU 指的是</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">CPU 內部的運算器一次最多能處理 16 位的數據</span></li></ul><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">運算器其實就是 ALU，運算控制單元，它是 CPU 內部的三大核心器件之一，主要負責數據的運算。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">寄存器的最大寬度為 16 位</span></li></ul><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">這個寄存器的最大寬度值就是通用寄存器能處理的二進制數的最大位數</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">寄存器和運算器之間的通路為 16 位</span></li></ul><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">這個指的是寄存器和運算器之間的總線，一次能傳輸 16 位的數據</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>好了，現在你應該知道為什麼叫做 16 位 CPU 了吧。</p><p>在你知道上面這個問題的答案之後，我們下面就來聊一聊如何計算物理地址。</p><p>8086 CPU 有 20 位地址總線，每一條總線都可以傳輸一位的地址，所以 8086 CPU 可以傳送 20 位地址，也就是說，8086 CPU 可以達到 2^20 次冪的尋址能力，也就是 1MB。8086 CPU 又是 16 位的結構，從 8086 CPU 的結構看，它只能傳輸 16 位的地址，也就是 2^16 次冪也就是 64 KB，那麼它如何達到 1MB 的尋址能力呢？</p><p>原來，8086 CPU 的內部採用兩個 16 位地址合成的方式來傳輸一個 20 位的物理地址，如下圖所示</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1c89a68cdb3649dda389b376107d0d51><p class=pgc-img-caption></p></div><p>敘述一下上圖描述的過程</p><p>CPU 相關組件提供兩個地址：段地址和偏移地址，這兩個地址都是 16 位的，他們經由<span style="color:#3594f7;--tt-darkmode-color: #3594F7">地址加法器</span>變為 20 位的物理地址，這個地址即是輸入輸出控制電路傳遞給內存的物理地址，由此完成物理地址的轉換。</p><p>地址加法器採用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「物理地址 = 段地址 * 16 + 偏移地址」</span></strong> 的方法用段地址和偏移地址合成物理地址。</p><p>下面是地址加法器的工作流程</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d61233c1cfd4caa9689fc612ca96b2b><p class=pgc-img-caption></p></div><p>其實段地址 * 16 ，就是左移 4 位。在上面的敘述中，物理地址 = 段地址 * 16 + 偏移地址，其實就是<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「基礎地址 + 偏移地址 = 物理地址」</span></strong> 尋址模式的一種具體實現方案。基礎地址其實就等於段地址 * 16。</p><p>你可能不太清楚 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">段</span> 的概念，下面我們就來探討一下。</p><h1 class=pgc-h-arrow-right><strong>什麼是段</strong></h1><p>段這個概念經常出現在操作系統中，比如在內存管理中，操作系統會把不同的數據分成 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">段</span>來存儲，比如 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「代碼段、數據段、bss 段、rodata 段」</span></strong> 等。</p><p>但是這些的劃分並不是內存乾的，cxuan 告訴你是誰幹的，這其實是幕後 Boss CPU 搞的，內存當作了聲討的對象。</p><p>其實，內存沒有進行分段，分段完全是由 CPU 搞的，上面聊過的通過基礎地址 + 偏移地址 = 物理地址的方式給出內存單元的物理地址，使得我們可以分段管理 CPU。</p><p>如圖所示</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9753d65d17b346658971030267256c57><p class=pgc-img-caption></p></div><p>這是兩個 16 KB 的程序分別被裝載進內存的示意圖，可以看到，這兩個程序的段地址的大小都是 16380。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">這裡需要注意一點， 8086 CPU 段地址的計算方式是段地址 * 16，所以，16 位的尋址能力是 2^16 次方，所以一個段的長度是 64 KB。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>段寄存器</strong></h1><p>cxuan 在上面只是簡單為你介紹了一下段寄存器的概念，介紹的有些淺，而且介紹段寄存器不介紹段也有<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「不知廬山真面目」</span></strong>的感覺，現在為你詳細的介紹一下，相信看完上面的段的概念之後，段寄存器也是手到擒來。</p><p>我們在合成物理地址的那張圖提到了 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">相關部件</span> 的概念，這個相關部件其實就是<span style="color:#3594f7;--tt-darkmode-color: #3594F7">段寄存器</span>，即 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「CS、DS、SS、ES」</span></strong> 。8086 的 CPU 在訪問內存時，由這四個寄存器提供內存單元的段地址。</p><h1 class=pgc-h-arrow-right><strong>CS 寄存器</strong></h1><p>要聊 CS 寄存器，那麼 IP 寄存器是你繞不過去的曾經。CS 和 IP 都是 8086 CPU 非常重要的寄存器，它們指出了 CPU 當前需要讀取指令的地址。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">CS 的全稱是 Code Segment，即代碼寄存器；而 IP 的全稱是 Instruction Pointer ，即指令指針。現在知道這兩個為什麼一起出現了吧！</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>在 8086 CPU 中，由 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">CS:IP</span> 指向的內容當作指令執行。如下圖所示</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e2da2cfc5d434875a23ec311bebbb7d1><p class=pgc-img-caption></p></div><p>說明一下上圖</p><p>在 CPU 內部，由 CS、IP 提供段地址，由加法器負責轉換為物理地址，輸入輸出控制電路負責輸入/輸出數據，指令緩衝器負責緩衝指令，指令執行器負責執行指令。在內存中有一段連續存儲的區域，區域內部存儲的是機器碼、外面是地址和彙編指令。</p><p>上面這幅圖的段地址和偏移地址分別是 2000 和 0000，當這兩個地址進入地址加法器後，會由地址加法器負責將這兩個地址轉換為物理地址</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8abee60606464c2fa5a19fc95f001d39><p class=pgc-img-caption></p></div><p>然後地址加法器負責將指令輸送到輸入輸出控制電路中</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/082d8e4e74be4f7cb5ea5f29f6df73fc><p class=pgc-img-caption></p></div><p>輸入輸出控制電路將 20 位的地址總線送到內存中。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b120b56cf19d4614b2928ac8dfc59c01><p class=pgc-img-caption></p></div><p>然後取出對應的數據，也就是 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「B8、23、01」</span></strong>，圖中的 B8、BB 都是操作數。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ef6953aa7fb4f31a8acb099367118d3><p class=pgc-img-caption></p></div><p>控制輸入/輸出電路會將 B8 23 01 送入指令緩存器中。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c699f420522f4c53966c390b4fd807da><p class=pgc-img-caption></p></div><p>此時這個指令就已經具備執行條件，此時 IP 也就是指令指針會自動增加。我們上面說到 IP 其實就是從 Code Segment 也就是 CS 處偏移的地址，也就是偏移地址。它會知道下一個需要讀取指令的地址，如下圖所示</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cadd4be973e749738dee7b057fb43bd4><p class=pgc-img-caption></p></div><p>在這之後，指令執行執行取出的 B8 23 01 這條指令。</p><p>然後下面再把 2000 和 0003 送到地址加法器中再進行後續指令的讀取。後面的指令讀取過程和我們上面探討的如出一轍，這裡 cxuan 就不再贅述啦。</p><p>通過對上面的描述，我們能總結一下 8086 CPU 的工作過程</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">段寄存器提供段地址和偏移地址給地址加法器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">由地址加法器計算出物理地址通過輸入輸出控制電路將物理地址送到內存中</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">提取物理地址對應的指令，經由控制電路取回並送到指令緩存器中</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">IP 繼續指向下一條指令的地址，同時指令執行器執行指令緩衝器中的指令</span></li></ul><h1 class=pgc-h-arrow-right><strong>什麼是 Code Segment</strong></h1><p>Code Segment 即代碼段，它就是我們上面聊到就是 CS 寄存器中存儲的基礎地址，也就是段地址，段地址其本質上就是一組內存單元的地址，例如上面的 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「mov ax,0123H 、mov bx, 0003H」</span></strong>。我們可以將長度為 N 的一組代碼，存放在一組連續地址、其實地址為 16 的倍數的內存單元中，我們可以認為，這段內存就是用來存放代碼的。</p><h1 class=pgc-h-arrow-right><strong>DS 寄存器</strong></h1><p>CPU 在讀寫一個內存單元的時候，需要知道這個內存單元的地址。在 8086 CPU 中，有一個 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">DS 寄存器</span>，通常用來存放訪問數據的段地址。如果你想要讀取一個 10000H 的數據，你可能會需要下面這段代碼</p><pre><code>mov bx,10000Hmov ds,bxmov a1,[0]</code></pre><p>上面這三條指令就把 10000H 讀取到了 a1 中。</p><p>在上面彙編代碼中，mov 指令有兩種傳送方式</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">一種是把數據直接送入寄存器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">一種是將一個寄存器的內容送入另一個寄存器</span></li></ul><p>但是不僅僅如此，mov 指令還具有下面這幾種表達方式</p><p><span style="color:#595959;--tt-darkmode-color: #8D8D8D"><span style="background-color:#f0f0f0;--tt-darkmode-bgcolor: #212121">描述舉例</span></span><span style="color:#595959;--tt-darkmode-color: #595959">mov 寄存器，數據比如：mov ax,8</span><span style="color:#595959;--tt-darkmode-color: #8D8D8D"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">mov 寄存器，寄存器比如：mov ax,bx</span></span><span style="color:#595959;--tt-darkmode-color: #595959">mov 寄存器，內存單元比如：mov ax,[0]</span><span style="color:#595959;--tt-darkmode-color: #8D8D8D"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">mov 內存單元，寄存器比如：mov[0], ax</span></span><span style="color:#595959;--tt-darkmode-color: #595959">mov 段寄存器，寄存器比如：mov ds,ax</span></p><h1 class=pgc-h-arrow-right><strong>棧</strong></h1><p>棧我相信大部分小夥伴已經非常熟悉了，<span style="color:#3594f7;--tt-darkmode-color: #3594F7">棧</span>是一種具有特殊的訪問方式的存儲空間。它的特殊性就在於，先進入棧的元素，最後才出去，也就是我們常說的 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">先入後出</span>。</p><p>它就像一個大的收納箱，你可以往裡面放相同類型的東西，比如書，最先放進收納箱的書在最下面，最後放進收納箱的書在最上面，如果你想拿書的話， 必須從最上面開始取，否則是無法取出最下面的書籍的。</p><p>棧的數據結構就是這樣，你把書籍壓入收納箱的操作叫做<span style="color:#3594f7;--tt-darkmode-color: #3594F7">壓入（push）</span>，你把書籍從收納箱取出的操作叫做<span style="color:#3594f7;--tt-darkmode-color: #3594F7">彈出（pop）</span>，它的模型圖大概是這樣</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47de7857886a4a47a3fc01493ce57667><p class=pgc-img-caption></p></div><p>入棧相當於是增加操作，出棧相當於是刪除操作，只不過叫法不一樣。棧和內存不同，它不需要指定元素的地址。它的大概使用如下</p><pre><code>// 壓入數據Push(123);Push(456);Push(789);// 彈出數據j = Pop();k = Pop();l = Pop();</code></pre><p>在棧中，LIFO 方式表示棧的數組中所保存的最後面的數據（Last In）會被最先讀取出來（First Out）。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f9680889d7b4eeaa9762636eba98f16><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>棧和 SS 寄存器</strong></h1><p>下面我們就通過一段彙編代碼來描述一下棧的壓入彈出的過程</p><p>8086 CPU 提供入棧和出棧指令，最基本的兩個是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">PUSH(入棧)</span> 和 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">POP(出棧)</span>。比如 push ax 會把 ax 寄存器中的數據壓入棧中，pop ax 表示從棧頂取出數據送入 ax 寄存器中。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">這裡注意一點：8086 CPU 中的入棧和出棧都是以字為單位進行的。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>我這裡首先有一個初始的棧，沒有任何指令和數據。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f07ec310075940d887687ba7ecade20d><p class=pgc-img-caption></p></div><p>然後我們向棧中 push 數據後，棧中數據如下</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a818eab98cb4ee49fc0e2ee8db07a92><p class=pgc-img-caption></p></div><p>涉及的指令有</p><pre><code>mov ax,2345Hpush ax</code></pre><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">注意，數據會用兩個單元存放，高地址單元存放高 8 位地址，低地址單元存放低 8 位。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>再向棧中 push 數據</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a10a908953574ac38edc75a01232d8fc><p class=pgc-img-caption></p></div><p>其中涉及的指令有</p><pre><code>mov bx,0132Hpush bx</code></pre><p>現在棧中有兩條數據，現在我們執行出棧操作</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f50359ff0364a4d859c169f97a782c7><p class=pgc-img-caption></p></div><p>其中涉及的指令有</p><pre><code>pop ax/* ax = 0132H */</code></pre><p>再繼續取出數據</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77e958bde3d04b34b84e554c062d6dc5><p class=pgc-img-caption></p></div><p>涉及的指令有</p><pre><code>pop bx/* bx = */</code></pre><p>完整的 push 和 pop 過程如下</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b5f1f6c92fc0418eafb26304cf449a85><p class=pgc-img-caption></p></div><p>現在 cxuan 問你一個問題，我們上面描述的是 10000H ~ 1000FH 這段空間來作為 push 和 pop 指令的存取單元。但是，你怎麼知道這個棧單元就是 10000H ~ 1000FH 呢？也就是說，你如何選擇指定的棧單元進行存取？</p><p>事實上，8086 CPU 有一組關於棧的寄存器 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">SS</span> 和 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">SP</span>。SS 是段寄存器，它存儲的是棧的基礎位置，也就是棧頂的位置，而 SP 是棧指針，它存儲的是偏移地址。在任意時刻，<span style="color:#3594f7;--tt-darkmode-color: #3594F7">SS:SP</span> 都指向棧頂元素。push 和 pop 指令執行時，CPU 從 SS 和 SP 中得到棧頂的地址。</p><p>現在，我們可以完整的描述一下 push 和 pop 過程了，下面 cxuan 就給你推導一下這個過程。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e7e0820abb404a09a78e6e70ead4724d><p class=pgc-img-caption></p></div><p>上面這個過程主要涉及到的關鍵變化如下。</p><p>當使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「PUSH」</span></strong> 指令向棧中壓入 1 個字節單元時，SP = SP - 1；即棧頂元素會發生變化；</p><p>而當使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「PUSH」</span></strong> 指令向棧中壓入 2 個字節的字單元時，SP = SP – 2 ；即棧頂元素也要發生變化；</p><p>當使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「POP」</span></strong> 指令從棧中彈出 1 個字節單元時， SP = SP + 1；即棧頂元素會發生變化；</p><p>當使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「POP」</span></strong> 指令從棧中彈出 2 個字節單元的字單元時， SP = SP + 2 ；即棧頂元素會發生變化；</p><h1 class=pgc-h-arrow-right><strong>棧頂越界問題</strong></h1><p>現在我們知道，8086 CPU 可以使用 SS 和 SP 指示棧頂的地址，並且提供 PUSH 和 POP 指令實現入棧和出棧，所以，你現在知道了如何能夠找到棧頂位置，但是你如何能保證棧頂的位置不會越界呢？棧頂越界會產生什麼影響呢？</p><p>比如如下是一個棧頂越界的示意圖</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6356fba34ef840ee89a06cff7fd00da4><p class=pgc-img-caption></p></div><p>第一開始，SS：SP 寄存器指向了棧頂，然後向棧空間 push 一定數量的元素後，SS:SP 位於棧空間頂部，此時再向棧空間內部 push 元素，就會出現棧頂越界問題。</p><p>棧頂越界是危險的，因為我們既然將一塊區域空間安排為棧，那麼在棧空間外部也可能存放了其他指令和數據，這些指令和數據有可能是其他程序的，所以如此操作會讓計算機<span style="color:#3594f7;--tt-darkmode-color: #3594F7">懵逼</span>。</p><p>我們希望 8086 CPU 能自己解決問題，畢竟 8086 CPU 已經是個成熟的 CPU 了，要學會自己解決問題了。</p><div class=pgc-img><img alt=愛了愛了，這篇寄存器講的有點意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb9b26618e524a42a06e9b4ff16fbd3f><p class=pgc-img-caption></p></div><p>然鵝（故意的），這對於 8086 CPU 來說，這可能是它一輩子的 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">夙願</span> 了，真實情況是，8086 CPU 不會保證棧頂越界問題，也就是說 8086 CPU 只會告訴你棧頂在哪，並不會知道棧空間有多大，所以需要程序員自己手動去保證。。。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>愛了</a></li><li><a>這篇</a></li><li><a>講的</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/647d835d.html alt=真正“零基礎”的水電改造，看完這篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/fbeb6fb2-d305-4fd6-a231-0574538df212 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/647d835d.html title=真正“零基礎”的水電改造，看完這篇就夠了>真正“零基礎”的水電改造，看完這篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3136e082.html alt="開學防護看這篇，1 萬份口罩等防護裝備，9.9 元秒" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S71cGv9EsUW6QK style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3136e082.html title="開學防護看這篇，1 萬份口罩等防護裝備，9.9 元秒">開學防護看這篇，1 萬份口罩等防護裝備，9.9 元秒</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d028021.html alt=如何更好的使用Java異常，看這篇就對了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d68c79ce68d041fe814db22f4dbe74bc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d028021.html title=如何更好的使用Java異常，看這篇就對了>如何更好的使用Java異常，看這篇就對了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f2fa7b83.html alt="看完這篇Exception 和 Error，和面試官扯皮就沒問題了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9bb7006f740478c8f6ce97dce25a688 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f2fa7b83.html title="看完這篇Exception 和 Error，和面試官扯皮就沒問題了">看完這篇Exception 和 Error，和面試官扯皮就沒問題了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b9c4462.html alt=當紅時做了第三者，三段感情都破碎，如今不敢愛了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/74e8101049e0402f87cb5ee10207430d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b9c4462.html title=當紅時做了第三者，三段感情都破碎，如今不敢愛了>當紅時做了第三者，三段感情都破碎，如今不敢愛了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63721d0a.html alt=看完這篇乾貨分享，讓滑坡監測更輕鬆 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25931a2b682d4ad2bf98026edfd1cb64 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63721d0a.html title=看完這篇乾貨分享，讓滑坡監測更輕鬆>看完這篇乾貨分享，讓滑坡監測更輕鬆</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/211c4f82.html alt=愛了！macOS新專利曝出貼心小功能：閒置窗口自動關閉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RY9MRH59bRErSr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/211c4f82.html title=愛了！macOS新專利曝出貼心小功能：閒置窗口自動關閉>愛了！macOS新專利曝出貼心小功能：閒置窗口自動關閉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9dab105f.html alt=不同的皺紋護理方法，這篇統統告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/297e9d41def741dd94c4fa78c39cadaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9dab105f.html title=不同的皺紋護理方法，這篇統統告訴你>不同的皺紋護理方法，這篇統統告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c91b9b3.html alt=【攻略分享】搬家9次，良心整理出這篇搬家技巧（內附搬家神器） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f11d3f579b1c4e25ae756fd81c4c7b65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c91b9b3.html title=【攻略分享】搬家9次，良心整理出這篇搬家技巧（內附搬家神器）>【攻略分享】搬家9次，良心整理出這篇搬家技巧（內附搬家神器）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f615acc6.html alt=搬家5次，整理出的這篇良心搬家技巧，你應該收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c7cb17415a4640a19f01cb736489950c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f615acc6.html title=搬家5次，整理出的這篇良心搬家技巧，你應該收藏>搬家5次，整理出的這篇良心搬家技巧，你應該收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b6526c7.html alt=搬家6次，良心整理出的這篇搬家攻略 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/52a57683-0d8c-4853-954c-5e1d9b62634f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b6526c7.html title=搬家6次，良心整理出的這篇搬家攻略>搬家6次，良心整理出的這篇搬家攻略</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c436c7e9.html alt=智能門鎖如何選？看完這篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ea74dbcd9a8245d59c662e7c38b2799b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c436c7e9.html title=智能門鎖如何選？看完這篇就夠了>智能門鎖如何選？看完這篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e896d220.html alt=差速器和變速箱，功能一樣嗎？看了這篇不再傻傻分不清 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/863d559592d04f168a6567fd5cd54d3c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e896d220.html title=差速器和變速箱，功能一樣嗎？看了這篇不再傻傻分不清>差速器和變速箱，功能一樣嗎？看了這篇不再傻傻分不清</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2389dc8c.html alt=欄杆的4大款式，5大分類！看完這篇，選材時就有數了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e2bbe70bd5a74b9c8dd318d465aaa6bc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2389dc8c.html title=欄杆的4大款式，5大分類！看完這篇，選材時就有數了>欄杆的4大款式，5大分類！看完這篇，選材時就有數了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6939e5f.html alt=看了這篇就知道如何開發一個優秀的API class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6939e5f.html title=看了這篇就知道如何開發一個優秀的API>看了這篇就知道如何開發一個優秀的API</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>