<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JavaScript 進階教程(1)--面向對象編程 | 极客快訊</title><meta property="og:title" content="JavaScript 進階教程(1)--面向對象編程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/891f87f008614e3fb61e0c5721b13558"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><meta property="article:published_time" content="2020-10-29T21:10:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:38+08:00"><meta name=Keywords content><meta name=description content="JavaScript 進階教程(1)--面向對象編程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8a18904e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JavaScript 進階教程(1)--面向對象編程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>1 學習目標</strong></h1><blockquote><p>理解面向對象開發思想</p><p>掌握 JavaScript 面向對象開發相關模式</p></blockquote><h1 class=pgc-h-arrow-right><strong>2 </strong>面向對象介紹</h1><div class=pgc-img><img alt="JavaScript 進階教程(1)--面向對象編程" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/891f87f008614e3fb61e0c5721b13558><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2.1 什麼是對象</h1><blockquote><p>Everything is object （一切皆對象）</p></blockquote><div class=pgc-img><img alt="JavaScript 進階教程(1)--面向對象編程" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/114d6b385bcf4a80a38c67ff5da0bc75><p class=pgc-img-caption></p></div><p style=text-align:start><strong>我們可以從兩個層次來理解對象：</strong></p><p style=text-align:start><strong>(1) 對象是單個事物的抽象。</strong></p><p style=text-align:start>一本書、一輛汽車、一個人都可以是對象，一個數據庫、一張網頁、一個與遠程服務器的連接也可以是對象。當實物被抽象成對象，實物之間的關係就變成了對象之間的關係，從而就可以模擬現實情況，針對對象進行編程。</p><p style=text-align:start><strong>(2) 對象是一個容器，封裝了屬性（property）和方法（method）。</strong></p><p style=text-align:start>屬性是對象的狀態，方法是對象的行為（完成某種任務）。比如，我們可以把動物抽象為animal對象，使用“屬性”記錄具體是哪一種動物，使用“方法”表示動物的某種行為（奔跑、捕獵、休息等等）。</p><p style=text-align:start>在實際開發中，對象是一個抽象的概念，可以將其簡單理解為：<strong>數據集或功能集</strong>。ECMAScript-262 把對象定義為：<strong>無序屬性的集合，其屬性可以包含基本值、對象或者函數</strong>。 嚴格來講，這就相當於說對象是一組沒有特定順序的值。對象的每個屬性或方法都有一個名字，而每個名字都 映射到一個值。</p><blockquote><p>提示：每個對象都是基於一個引用類型創建的，這些類型可以是系統內置的原生類型，也可以是開發人員自定義的類型。</p></blockquote><h1 class=pgc-h-arrow-right><strong>2.2 什麼是面向對象</strong></h1><blockquote><p>面向對象不是新的東西，它只是過程式代碼的一種高度封裝，目的在於提高代碼的開發效率和可維護性。</p></blockquote><div class=pgc-img><img alt="JavaScript 進階教程(1)--面向對象編程" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eab0ca1b0c24037ba8a4f9c65da6a13><p class=pgc-img-caption></p></div><p style=text-align:start><strong>面向對象編程 —— Object Oriented Programming，簡稱 OOP ，是一種編程開發思想。 它將真實世界各種複雜的關係，抽象為一個個對象，然後由對象之間的分工與合作，完成對真實世界的模擬。</strong></p><p style=text-align:start>在面向對象程序開發思想中，每一個對象都是功能中心，具有明確分工，可以完成接收信息、處理數據、發出信息等任務。 因此，面向對象編程具有靈活、代碼可複用、高度模塊化等特點，容易維護和開發，比起由一系列函數或指令組成的傳統的過程式編程（procedural programming），更適合多人合作的大型軟件項目。</p><p style=text-align:start><strong>面向對象與面向過程區別：</strong></p><ul><li>面向過程就是親力親為，事無鉅細，面面俱到，步步緊跟，有條不紊。</li><li>面向對象就是找一個對象，指揮得結果。</li><li>面向對象將執行者轉變成指揮者。</li><li>面向對象不是面向過程的替代，而是面向過程的封裝。</li></ul><p style=text-align:start><strong>面向對象的特性：</strong></p><ul><li>封裝性</li><li>繼承性</li><li>多態性</li></ul><p style=text-align:start>擴展閱讀：</p><ul><li>知乎：什麼是面向對象編程思想？</li></ul><h1 class=pgc-h-arrow-right><strong>2.3 JavaScript 中面向對象的基本體現</strong></h1><p style=text-align:start><strong>在 JavaScript 中，所有數據類型都可以視為對象，當然也可以自定義對象。 自定義的對象數據類型就是面向對象中的類（ Class ）的概念。</strong></p><p style=text-align:start>我們以一個例子來說明面向過程和麵向對象在程序流程上的不同之處。</p><p style=text-align:start>假設我們要處理學生的成績表，為了表示一個學生的成績，面向過程的程序可以用一個對象表示：</p><pre><code>var std1 = { name: '張三', score: 98 }var std2 = { name: '李四', score: 81 }</code></pre><p style=text-align:start>而處理學生成績可以通過函數實現，比如打印學生的成績：</p><pre><code>function printScore (student) {  console.log('姓名：' + student.name + '  ' + '成績：' + student.score)}</code></pre><p style=text-align:start>如果採用面向對象的程序設計思想，我們首先思考的不是程序的執行流程， 而是 Student 這種數據類型應該被視為一個對象，這個對象擁有 name 和 score 這兩個屬性（Property）。 如果要打印一個學生的成績，首先必須創建出這個學生對應的對象，然後，給對象發一個 printScore 消息，讓對象自己把自己的數據打印出來。</p><p style=text-align:start>抽象數據行為模板（Class）：</p><pre><code>function Student (name, score) {  this.name = name  this.score = score} Student.prototype.printScore = function () {  console.log('姓名：' + this.name + '  ' + '成績：' + this.score)}</code></pre><p style=text-align:start>根據模板創建具體實例對象（Instance）：</p><pre><code>var std1 = new Student('張三', 98)var std2 = new Student('李四', 81)</code></pre><p style=text-align:start>實例對象具有自己的具體行為（給對象發消息）：</p><pre><code>std1.printScore() // =&gt; 姓名：張三  成績：98std2.printScore() // =&gt; 姓名：李四  成績 81</code></pre><p style=text-align:start>面向對象的設計思想是從自然界中來的，因為在自然界中，類（Class）和實例（Instance）的概念是很自然的。 Class 是一種抽象概念，比如我們定義的 Class——Student ，是指學生這個概念， 而實例（Instance）則是一個個具體的 Student ，比如， 張三 和 李四 是兩個具體的 Student 。</p><p style=text-align:start><strong>面向對象的設計思想是：</strong></p><ul><li>抽象出 Class</li><li>根據 Class 創建 Instance</li><li>指揮 Instance 得結果</li></ul><p style=text-align:start>面向對象的抽象程度比函數要高，因為一個 Class 既包含數據，又包含操作數據的方法。</p><h1 class=pgc-h-arrow-right><strong>3 JavaScript 如何創建對象</strong></h1><h1 class=pgc-h-arrow-right><strong>3.1 字面量方式</strong></h1><p style=text-align:start>我們可以直接通過 new Object() 創建：</p><pre><code>var person = new Object()person.name = '張三'person.age = 18person.sayName = function () {  console.log(this.name)}</code></pre><p style=text-align:start>每次創建通過 new Object() 比較麻煩，所以可以通過它的簡寫形式對象字面量來創建：</p><pre><code>var person = {  name: '張三',  age: 18,  sayName: function () {    console.log(this.name)  }}</code></pre><p style=text-align:start>上面的寫法是沒有問題的，但是假如我們要生成兩個 person 實例對象呢？</p><pre><code>var person1 = {  name: '張三',  age: 18,  sayName: function () {    console.log(this.name)  }}​var person2 = {  name: '李四',  age: 16,  sayName: function () {    console.log(this.name)  }}</code></pre><p style=text-align:start>通過上面的代碼我們不難看出，這樣寫的代碼太過冗餘，重複性太高。</p><h1 class=pgc-h-arrow-right><strong>3.2 簡單方式的改進：工廠函數</strong></h1><p style=text-align:start>我們可以寫一個函數，解決上邊代碼重複的問題：</p><pre><code>function createPerson (name, age) {  return {    name: name,    age: age,    sayName: function () {      console.log(this.name)    }  }}</code></pre><p style=text-align:start><strong>生成實例對象：</strong></p><pre><code>var p1 = createPerson('張三', 18)var p2 = createPerson('李四', 18)</code></pre><p style=text-align:start>這樣封裝比上邊的方式好多了，通過工廠模式我們解決了創建多個相似對象代碼冗餘的問題， 但卻沒有解決對象識別的問題（即怎樣知道一個對象的類型）。</p><h1 class=pgc-h-arrow-right><strong>3.3 更優雅的工廠函數：構造函數</strong></h1><p style=text-align:start>一種更優雅的工廠函數就是下面這樣，構造函數：</p><pre><code>function Person (name, age) {  this.name = name  this.age = age  this.sayName = function () {    console.log(this.name)  }}​var p1 = new Person('張三', 18)p1.sayName() // =&gt; 張三​var p2 = new Person('李四', 23)p2.sayName() // =&gt; 李四</code></pre><p style=text-align:start>在上面的示例中，Person() 函數取代了 createPerson() 函數，但是實現效果是一樣的。 這是為什麼呢？</p><p style=text-align:start><strong>我們注意到，Person() 中的代碼與 createPerson() 有以下幾點不同之處：</strong></p><ol start=1><li>沒有顯示的創建對象</li><li>直接將屬性和方法賦給了 this 對象</li><li>沒有 return 語句</li><li>函數名使用的是大寫的 Person</li></ol><h1 class=pgc-h-arrow-right><strong>3.4 構造函數代碼執行過程</strong></h1><p style=text-align:start><strong>要創建 Person 實例，則必須使用 new 操作符。 以這種方式調用構造函數會經歷以下 4 個步驟：</strong></p><ol start=1><li>創建一個新對象。</li><li>將構造函數的作用域賦給新對象（因此 this 就指向了這個新對象）。</li><li>執行構造函數中的代碼。</li><li>返回新對象。</li></ol><p style=text-align:start>下面是具體的偽代碼：</p><pre><code>function Person (name, age) {  // 當使用 new 操作符調用 Person() 的時候，實際上這裡會先創建一個對象  // var instance = {}  // 然後讓內部的 this 指向 instance 對象  // this = instance  // 接下來所有針對 this 的操作實際上操作的就是 instance​  this.name = name  this.age = age  this.sayName = function () {    console.log(this.name)  }​  // 在函數的結尾處會將 this 返回，也就是 instance  // return this}</code></pre><h1 class=pgc-h-arrow-right><strong>3.5 </strong>構造函數和實例對象的關係</h1><p style=text-align:start>使用構造函數的好處不僅僅在於代碼的簡潔性，更重要的是我們可以識別對象的具體類型了。 在每一個實例對象中的_<em>proto_</em>中同時有一個 constructor 屬性，該屬性指向創建該實例的構造函數：</p><pre><code>console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true</code></pre><p style=text-align:start>對象的 constructor 屬性最初是用來標識對象類型的， 但是，如果要檢測對象的類型，還是使用 instanceof 操作符更可靠一些：</p><pre><code>console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true</code></pre><p style=text-align:start><strong>總結：</strong></p><p style=text-align:start>1 構造函數是根據具體的事物抽象出來的抽象模板。</p><p style=text-align:start>2 實例對象是根據抽象的構造函數模板得到的具體實例對象。</p><p style=text-align:start>3 每一個實例對象都具有一個 constructor 屬性，指向創建該實例的構造函數。（ 此處constructor 是實例的屬性的說法不嚴謹，具體後面的原型會講到）</p><p style=text-align:start>4 可以通過實例的 constructor 屬性判斷實例和構造函數之間的關係。（這種方式不嚴謹，推薦使用 instanceof 操作符，後面學原型會解釋為什麼）</p><h1 class=pgc-h-arrow-right><strong>3.6 </strong>構造函數的問題</h1><p style=text-align:start>使用構造函數帶來的最大的好處就是創建對象更方便了，但是其本身也存在一個浪費內存的問題：</p><pre><code>function Person (name, age) {  this.name = name  this.age = age  this.type = '學生'  this.sayHello = function () {    console.log('hello ' + this.name)  }}​var p1 = new Person('王五', 18)var p2 = new Person('李四', 16)</code></pre><p style=text-align:start>上邊的代碼，從表面看上好像沒什麼問題，但是實際上這樣做，有一個很大的弊端。 那就是對於每一個實例對象，type 和 sayHello 都是一模一樣的內容， 每一次生成一個實例，都必須為重複的內容，多佔用一些內存，如果實例對象很多，會造成極大的內存浪費。</p><pre><code>console.log(p1.sayHello === p2.sayHello) // =&gt; false</code></pre><p style=text-align:start>對於這種問題我們可以把需要共享的函數定義到構造函數外部：</p><pre><code>function sayHello = function () {  console.log('hello ' + this.name)}​function Person (name, age) {  this.name = name  this.age = age  this.type = '學生'  this.sayHello = sayHello}​var p1 = new Person('王五', 18)var p2 = new Person('李四', 16)​console.log(p1.sayHello === p2.sayHello) // =&gt; true</code></pre><p style=text-align:start>這樣確實可以了，但是如果有多個需要共享的函數的話就會造成全局命名空間衝突的問題。如何解決這個問題呢？你肯定想到了可以把多個函數放到一個對象中用來避免全局命名空間衝突的問題：</p><pre><code>var fns = {  sayHello: function () {    console.log('hello ' + this.name)  },  sayAge: function () {    console.log(this.age)  }}​function Person (name, age) {  this.name = name  this.age = age  this.type = '學生'  this.sayHello = fns.sayHello  this.sayAge = fns.sayAge}​var p1 = new Person('王五', 18)var p2 = new Person('李四', 16)​console.log(p1.sayHello === p2.sayHello) // =&gt; trueconsole.log(p1.sayAge === p2.sayAge) // =&gt; true</code></pre><p style=text-align:start>至此，我們利用自己的方式基本上解決了構造函數的內存浪費問題。 但是代碼看起來還是那麼的格格不入，那有沒有更好的方式呢？</p><h1 class=pgc-h-arrow-right><strong>4</strong> 原型</h1><h1 class=pgc-h-arrow-right><strong>4.1 更好的解決方案： prototype</strong></h1><p style=text-align:start><strong>Javascript 規定，每一個構造函數都有一個 prototype 屬性，指向另一個對象。 這個對象的所有屬性和方法，都會被構造函數的實例繼承。</strong></p><p style=text-align:start>這也就意味著，我們可以把所有對象實例需要共享的屬性和方法直接定義在 prototype 對象上。</p><pre><code>function Person (name, age) {  this.name = name  this.age = age}​console.log(Person.prototype)​Person.prototype.type = '學生'​Person.prototype.sayName = function () {  console.log(this.name)}​var p1 = new Person(...)var p2 = new Person(...)​console.log(p1.sayName === p2.sayName) // =&gt; true</code></pre><p style=text-align:start>這時所有實例的 <strong>type 屬性和 sayName() 方法</strong>， 其實都是同一個內存地址，指向 prototype 對象，因此就提高了運行效率。</p><p><strong>構造函數、實例、原型三者之間的關係：</strong></p><div class=pgc-img><img alt="JavaScript 進階教程(1)--面向對象編程" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/743a6f1e232d4ce099d2f4f8c96d64a6><p class=pgc-img-caption></p></div><p style=text-align:start></p><p style=text-align:start>任何函數都有一個 <strong>prototype </strong>屬性，該屬性是一個對象。</p><pre><code>function F () {}console.log(F.prototype) // =&gt; object​F.prototype.sayHi = function () {  console.log('hi!')}</code></pre><p style=text-align:start>構造函數的 <strong>prototype</strong> 對象默認都有一個<strong> constructor</strong> 屬性，指向<strong> prototype</strong> 對象所在函數。</p><pre><code>console.log(F.constructor === F) // =&gt; true</code></pre><p style=text-align:start>通過構造函數得到的實例對象內部會包含一個指向構造函數的 prototype 對象的指針 __proto__。</p><pre><code>var instance = new F()console.log(instance.__proto__ === F.prototype) // =&gt; true</code></pre><p style=text-align:start><strong>`__proto__` 是非標準屬性。</strong></p><p style=text-align:start>實例對象可以直接訪問原型對象成員：</p><pre><code>instance.sayHi() // =&gt; hi!</code></pre><p style=text-align:start><strong>總結：</strong></p><ol start=1><li>任何函數都具有一個 prototype 屬性，該屬性是一個對象。</li><li>構造函數的 prototype 對象默認都有一個 constructor 屬性，指向 prototype 對象所在函數。</li><li>通過構造函數得到的實例對象內部會包含一個指向構造函數的 prototype 對象的指針 __proto__。</li><li>所有實例都直接或間接繼承了原型對象的成員。</li></ol><h1 class=pgc-h-arrow-right><strong>4.2 屬性成員的搜索原則：原型鏈</strong></h1><p style=text-align:start>瞭解了 <strong>構造函數-實例-原型對象</strong> 三者之間的關係後，接下來我們來解釋一下為什麼實例對象可以訪問原型對象中的成員。</p><p style=text-align:start><strong>每當代碼讀取某個對象的某個屬性時，都會執行一次搜索，目標是具有給定名字的屬性。</strong></p><ol start=1><li>搜索首先從對象實例本身開始。</li><li>如果在實例中找到了具有給定名字的屬性，則返回該屬性的值。</li><li>如果沒有找到，則繼續搜索指針指向的原型對象，在原型對象中查找具有給定名字的屬性。</li><li>如果在原型對象中找到了這個屬性，則返回該屬性的值。</li></ol><p style=text-align:start><strong>也就是說，在我們調用 person1.sayName() 的時候，會先後執行兩次搜索：</strong></p><ol start=1><li>首先，解析器會問：“實例 person1 有 sayName 屬性嗎？”答：“沒有。</li><li>然後，它繼續搜索，再問：“ person1 的原型有 sayName 屬性嗎？”答：“有。</li><li>於是，它就讀取那個保存在原型對象中的函數。</li><li>當我們調用 person2.sayName() 時，將會重現相同的搜索過程，得到相同的結果。</li></ol><p style=text-align:start>這就是多個對象實例共享原型所保存的屬性和方法的基本原理。</p><p style=text-align:start><strong>總結：</strong></p><ol start=1><li>先在自己身上找，找到即返回。</li><li>自己身上找不到，則沿著原型鏈向上查找，找到即返回。</li><li>如果一直到原型鏈的末端還沒有找到，則返回 undefined。</li></ol><h1 class=pgc-h-arrow-right><strong>4.3 實例對象讀寫原型對象成員</strong></h1><p style=text-align:start><strong>讀取：</strong></p><ol start=1><li>先在自己身上找，找到即返回。</li><li>自己身上找不到，則沿著原型鏈向上查找，找到即返回。</li><li>如果一直到原型鏈的末端還沒有找到，則返回 undefined。</li></ol><p style=text-align:start><strong>值類型成員寫入（實例對象.值類型成員 = xx）：</strong></p><ol start=1><li>當實例期望重寫原型對象中的某個普通數據成員時實際上會把該成員添加到自己身上。</li><li>也就是說該行為實際上會屏蔽掉對原型對象成員的訪問。</li></ol><p style=text-align:start><strong>引用類型成員寫入（實例對象.引用類型成員 = xx）：</strong>同上。</p><p style=text-align:start><strong>複雜類型修改（實例對象.成員.xx = xx）：</strong></p><ol start=1><li>同樣會先在自己身上找該成員，如果自己身上找到則直接修改。</li><li>如果自己身上找不到，則沿著原型鏈繼續查找，如果找到則修改。</li><li>如果一直到原型鏈的末端還沒有找到該成員，則報錯（實例對象.undefined.xx = xx）。</li></ol><h1 class=pgc-h-arrow-right><strong>4.4 </strong>更簡單的原型語法</h1><p style=text-align:start>我們注意到，前面例子中每添加一個屬性和方法就要敲一遍 Person.prototype 。 <strong>為減少不必要的輸入，更常見的做法是用一個包含所有屬性和方法的對象字面量來重寫整個原型對象：</strong></p><pre><code>function Person (name, age) {  this.name = name  this.age = age}​Person.prototype = {  type: '學生',  sayHello: function () {    console.log('我叫' + this.name + '，我今年' + this.age + '歲了')  }}</code></pre><p style=text-align:start>在該示例中，我們將 Person.prototype 重置到了一個新的對象。 這樣做的好處就是為 Person.prototype 添加成員簡單了，但是也會帶來一個問題，那就是原型對象丟失了 constructor 成員。</p><p style=text-align:start><strong>所以，我們為了保持 constructor 的指向正確，建議的寫法是</strong>：</p><pre><code>function Person (name, age) {  this.name = name  this.age = age} Person.prototype = {  constructor: Person, // =&gt; 手動將 constructor 指向正確的構造函數  type: '學生',  sayHello: function () {    console.log('我叫' + this.name + '，我今年' + this.age + '歲了')  }}</code></pre><h1 class=pgc-h-arrow-right><strong>4.5 </strong>原生對象的原型</h1><p style=text-align:start>所有函數都有 prototype 屬性對象。</p><blockquote><p>Object.prototypeFunction.prototypeArray.prototypeString.prototypeNumber.prototypeDate.prototype...</p></blockquote><p style=text-align:start>為數組對象和字符串對象擴展原型方法：</p><pre><code>//為內置對象添加原型方法//我們在系統的對象的原型中添加方法,相當於在改變源碼//我希望字符串中有一個倒序字符串的方法String.prototype.myReverse = function() {	for (var i = this.length - 1; i &gt;= 0; i--) {		console.log(this[i]);	}};var str = "abcdefg";str.myReverse();  //為Array內置對象的原型對象中添加方法Array.prototype.mySort = function() {	for (var i = 0; i &lt; this.length - 1; i++) {		for (var j = 0; j &lt; this.length - 1 - i; j++) {			if (this[j] &lt; this[j + 1]) {				var temp = this[j];				this[j] = this[j + 1];				this[j + 1] = temp;			} //end if		} // end for	} //end for}; var arr = [100, 3, 56, 78, 23, 10];arr.mySort();console.log(arr);  String.prototype.sayHi = function() {	console.log(this + "哈哈,我又變帥了");}; //字符串就有了打招呼的方法var str2 = "小楊";str2.sayHi();</code></pre><h1 class=pgc-h-arrow-right><strong>4.6 </strong>原型對象的一些問題</h1><ul><li>共享數組</li><li>共享對象</li></ul><p style=text-align:start>如果真的希望可以被實例對象之間共享和修改這些共享數據那就不是問題。但是如果不希望實例之間共享和修改這些共享數據則會出現問題。一個更好的建議是，最好不要讓實例之間互相共享數組或者對象成員，一旦修改的話會導致數據的走向很不明確而且難以維護。</p><p style=text-align:start><strong>原型對象使用建議：</strong></p><ol start=1><li>私有成員（一般就是非函數成員）放到構造函數中。</li><li>共享成員（一般就是函數）放到原型對象中。</li><li>如果重置了 prototype 記得修正 constructor 的指向。</li></ol><p>轉自：https://blog.csdn.net/qq_23853743/article/details/108034430?utm_medium=distribute.pc_feed.none-task-blog-personrec_tag-7.nonecase&depth_1-utm_source=distribute.pc_feed.none-task-blog-personrec_tag-7.nonecase&request_id=5f439671cea070620e93ed01</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JavaScript</a></li><li><a>進階</a></li><li><a>--</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbb4fd63.html alt="Mysql --09 Innodb核心特性——事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/47618d6931fd4518a4d78c0e13623b98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbb4fd63.html title="Mysql --09 Innodb核心特性——事務">Mysql --09 Innodb核心特性——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47facbb9.html alt=SVHACKS--偽隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/10b87c79-8837-4bfd-9418-b994acbf0174 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47facbb9.html title=SVHACKS--偽隨機數>SVHACKS--偽隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c20adbc.html alt="質量管理體系程序文件--  生產過程控制程序" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c20adbc.html title="質量管理體系程序文件--  生產過程控制程序">質量管理體系程序文件-- 生產過程控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12e745a4.html alt=質量管理體系程序文件--內部審核控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12e745a4.html title=質量管理體系程序文件--內部審核控制程序>質量管理體系程序文件--內部審核控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57366d64.html alt=質量管理體系程序文件--基礎設施控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57366d64.html title=質量管理體系程序文件--基礎設施控制程序>質量管理體系程序文件--基礎設施控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c010b17.html alt=質量管理體系程序文件--物料和產品放行過程控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f8a3a54748fb4d4ea52783ea420dc6f6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c010b17.html title=質量管理體系程序文件--物料和產品放行過程控制程序>質量管理體系程序文件--物料和產品放行過程控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a42b5105.html alt=質量管理體系程序文件--產品監視和測量控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a42b5105.html title=質量管理體系程序文件--產品監視和測量控制程序>質量管理體系程序文件--產品監視和測量控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c7178fa4.html alt=質量管理體系程序文件--風險和機遇的應對控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f959e319ab5e47e08c057dda9078ac9d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c7178fa4.html title=質量管理體系程序文件--風險和機遇的應對控制程序>質量管理體系程序文件--風險和機遇的應對控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6886516f.html alt=軸承裝配知識（6）--軸承遊隙的檢測 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b4d747de6afc45b588528f682acf6612 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6886516f.html title=軸承裝配知識（6）--軸承遊隙的檢測>軸承裝配知識（6）--軸承遊隙的檢測</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19a27cf4.html alt=軸承裝配知識（8）--軸承成品旋轉精度的檢測 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/966406d6846243f5b155b346eab483c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19a27cf4.html title=軸承裝配知識（8）--軸承成品旋轉精度的檢測>軸承裝配知識（8）--軸承成品旋轉精度的檢測</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html alt=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a646cf102cf74b4a953855ebedbc7d29 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html title=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程>PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html alt=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cce9b3fb23ce41b88311823510e419da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html title=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。>PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/637cf111.html alt=PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/bc66832213514f2996f2e48c9e9cc747 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/637cf111.html title=PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西>PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3b6719c.html alt=PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/423ce7eefc5d433f86a14589b1ba0043 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3b6719c.html title=PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器>PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe9184d7.html alt=PHP進階教程-實現一個簡單的MySQL連接池 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/aa2df096a4274ba1b5c8540bcb5b5c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe9184d7.html title=PHP進階教程-實現一個簡單的MySQL連接池>PHP進階教程-實現一個簡單的MySQL連接池</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>