<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 | 极客快訊</title><meta property="og:title" content="「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/ea11259e-5098-451f-b989-4e3169a16a1c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a3d9e7a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a3d9e7a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a3d9e7a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a3d9e7a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a3d9e7a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a3d9e7a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a3d9e7a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a3d9e7a.html><meta property="article:published_time" content="2020-11-14T21:07:13+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:13+08:00"><meta name=Keywords content><meta name=description content="「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8a3d9e7a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/ea11259e-5098-451f-b989-4e3169a16a1c><p class=pgc-img-caption>字符串是不可變的</p></div><p><br></p><p>字符串是不可變的，也就是說當字符串的內容發生改變的時候，會創建一個新的String對象；但是如果內容沒有發生改變的時候，String類的方法會返回原字符串對象的引用。</p><p>而正則表達式往往都和字符串相關，而且很多String對象中的方法都可以使用正則表達式來作為參數，比如：replace();方法，split();方法等，這些方法因為支持正則表達式，便可以以少量代碼完成很多靈活強大的功能，比如：字符檢索、替換、篩選等。那麼廢話不多說，便開始來進入正則表達式的介紹吧！</p><p><br></p><div class=pgc-img><img alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/c34ead0a-d524-4761-aa21-f1bb4c9f2d05><p class=pgc-img-caption>格式化輸出</p></div><h1 class=pgc-h-center-line>格式化輸出</h1><p>在C語言中，有著printf()方法用於格式化輸出，不僅使用簡單，而且功能很強大，可以做各種格式的打印輸出。比如：</p><pre><code>printf("var x is %d \n", x);</code></pre><p>在printf();方法的第一個參數為字符串，在字符串中使用了佔位符"%d"，表示此處是一個整數型的變量值；而字符串之後的參數，便是對字符串中的佔位符的填充，參數可以有多個；在本例中：是把變量x的值填充到"%d"的位置，如果變量x的值是13，那麼上述代碼最後的打印效果就是：</p><pre><code>var x is 13 </code></pre><p><br></p><p><strong>Java 中的格式化輸出</strong></p><p><strong>1.printf();</strong></p><p>在早期的Java 版本中，是沒有格式化輸出的，但是從Java 5 開始，Java 也提供了格式化輸出這一項功能，方法名稱也叫printf();，該方法的調用和C語言中的printf方法大同小異，代碼案例如下：</p><pre><code>int x = 13;// 傳統的輸出打印System.out.println("var x is " + x);// 使用printf(); 格式化打印輸出System.out.printf("var x is %d \n", x);</code></pre><p>雖然方法名稱和C語言中的printf();方法一樣，但兩者還是有很多不同之處，其中，最大的一個不同之處便是：在C語言中的prtinf();方法中，不能使用 "+" 來做字符串連接；</p><p><br></p><p><strong>2.format();</strong></p><p>同樣在Java 5中引入的格式化方法還有：format();，format();方法和printf();方法的使用都是一樣的，參數都是一個格式化的字符串加上一個或者多個的字符串佔位符填充，代碼案例如下：</p><pre><code>int x = 13;// 使用format(); 格式化打印輸出System.out.format("var x is %d \n", x);</code></pre><p><br></p><p><strong>3.String.format();</strong></p><p>在String類中，有一個靜態方法String.format();，也能用於格式化字符串，它能接受和<strong>printf();</strong>、<strong>format();</strong>這兩個方法一樣的參數，在完成字符串格式化後，返回格式化後的字符串；案例代碼如下：</p><pre><code>int x = 13;String format = String.format("var x is %d \n", x);System.out.println(format);</code></pre><p>不同於<strong>printf();</strong>、<strong>format();</strong>這兩個方法的是，String.format()方法返回的是一個String對象，<strong>printf();</strong>、<strong>format();</strong>返回的是一個PrintStream對象，可直接用於打印輸出。</p><p><br></p><p><strong>4.Formatter類</strong></p><p><strong>無論是printf();</strong>方法，還是<strong>format();</strong>方法，亦或者<strong>String.format();</strong>方法，他們的內部都是調用<strong>java.util.Formatter類</strong>的format方法來做格式化的；故，可以把<strong>Formatter類</strong>看作一個翻譯器，負責將佔位符字符串與數據翻譯成想要的結果。</p><p>由於底層都是使用Formatter類來做格式化處理的，所以我們也可以直接使用<strong>Formatter類</strong>來做格式化處理，直接調用Formatter類的format方法<strong>，</strong>案例代碼如下：</p><pre><code>import java.math.*;import java.util.*;// Formatter類 案例public class FormatterDemo {    public static void main(String []args) {		        Formatter formatter = new Formatter(System.out);        char c = 'a';        formatter.format("c : %c\n", c);        int i = 13;        formatter.format("i : %d\n", i);        BigInteger bigInt = new BigInteger(10000000000000");        formatter.format("bigInt : %d \n", bigInt);		    }}</code></pre><p>在格式化的字符串中，不同的佔位符都有著各自的意義，表示著不同類型的數據類型：</p><pre><code>% ： 表示字符“%”, 在格式化的字符串中表示佔位符d ： 十進制的整數類型c ： 表示Unicde字符b： 表示Boolean 類型的值s： 表示String 類型的值f： 表示十進制的浮點數（包括float、double類型的數據）e： 表示科學計數的浮點數x： 表示十六進制的整數h： 表示十六進制的散列碼</code></pre><p>在上述的案例中，“%d”表示的就是十進制的整數類型的佔位符，“%c”表示的就是Unicode字符類型的佔位符，其他的佔位符根據相同的格式使用即可。</p><p><br></p><div class=pgc-img><img alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/9393a0b8-25ed-4d64-a97d-efdc1683cd1f><p class=pgc-img-caption>正則表達式</p></div><h1 class=pgc-h-center-line>正則表達式</h1><p><strong>正則表達式</strong>（英文：Regular Expression，在代碼中常簡寫為regex、regexp或RE），是對字符串（包括普通字符和特殊字符）操作的一種邏輯公式，用事先定義好的一些特定字符、及這些特定字符的組合，組成一個“規則字符串”，這個“規則字符串”用來表達對字符串的一種過濾邏輯。</p><p>正則表達式是一種文本模式，是一種強大且靈活的文本處理工具；通過正則表達式，可以構建複雜的文本模式，對輸入的字符串進行過濾和搜索，解決字符串處理的相關問題，比如：匹配、分隔、替換、編輯和驗證等。</p><p>一般地，正則表達式被定義為以某種方式描述字符串，比如要在一段文本中查找數字，正則表達式就為"\\d+"，前一個反斜槓“\”表示轉義，剩下的“\d”表示一個數字，“+表示一個或者多個”；</p><pre><code>public static void main(String[] args) {				System.out.println("7897979".matches("\\d+"));}</code></pre><p>案例運行結果為：true。</p><p>對比其他語言中的正則表達式，Java 語言對反斜槓“\”的處理會有所不同，正則表達式：“\\”，表示的就是一個普通的反斜槓，也是同樣的道理，前一個反斜槓“\”表示轉義；如果想要表示“\\”，正則表達式就得是“\\\\”。</p><p><br></p><p><strong>正則表達式字符</strong></p><p>在JDK文檔中的java.util.regex.Pattern的文檔中，詳細介紹了Java 中的正則表達式字符，下面是一些常用的：</p><p><strong>1.字符</strong></p><pre><code>x                      字符xhh                 十六進制值為0xhh的字符\uhhhh             十六進制表示為0xhhhh的Unicode字符\t                       製表符Tab\n                      換行符\r                       回車\f                       換頁\e                      轉義（Escape）</code></pre><p><br></p><p><strong>2.字符類</strong></p><pre><code>.                                任意字符[abc]                         包含a、b、c的任意字符，與（a|b|c）作用相同[^abc]                       除了a、b、c的之外的任意字符[a-zA-Z]                    從a-z或者A-Z的任意字符[abc[hij]]                   包含a、b、c、h、i、j的任意字符，與（a|b|c|h|i|j）作用相同[a-z&amp;&amp;[hij]]             從a-z中的包含h、i、j的任意字符\s                             空白字符（包括空格、tab、換行、換頁、回車）\S                            非空白字符，與[^\s]作用相同\d                            數字[0-9]\D                            非數字[^0-9]\w                           詞字符[a-zA-Z0-9]\W                          詞字符[^\w]</code></pre><p><strong>3.邏輯操作符</strong></p><pre><code>XY                        X在Y之後X|Y                       X或Y(X)                       捕獲組（capturing group），可在表達式中用\i引用第i個捕獲組</code></pre><p><br></p><p><strong>4.邊界匹配符</strong></p><pre><code>^                        每行的開頭$                        每行的結尾\b                      詞字符的邊界\B                      非此字符的邊界\G                      前一個匹配的結束</code></pre><p><br></p><p>下面就通過一個案例展示上述正則表達式字符的使用：</p><pre><code>// 寫出能匹配字符 "laofu13"的正則表達式public class RegexDemo {		public static void main(String[] args) {    		String regex = "([a-z]+[\\d]+)";        System.out.println("laofu13".matches(regex));    }}</code></pre><p>由於上述的正則表達式字符表示的都只是單個字符，因此，如果要匹配多個字符，就要使用"+"來表示一個或多個字符。</p><p><br></p><p><strong>正則表達式量詞</strong></p><ul><li>貪婪型：除非有特殊的選項設置，否則貪婪型的表達式會對文本做儘可能多的匹配；就算文本的開頭就能被表達式匹配，貪婪型的表達式依然會繼續往下匹配；</li><li>勉強型：此種量詞也稱懶惰的、非貪婪型的，勉強型的表達式會對文本做最少的匹配；</li><li>佔有型：此種量詞是Java 語言專有的。正則表達式在匹配時，會產生很多的狀態，以便在匹配失敗時可以回溯；佔有型的表達式不保存這些狀態，因此可以防止回溯，可以保證表達式有效執行。</li></ul><div class=pgc-img><img alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b419384bc84b4381bdceec4b0ffb0a63><p class=pgc-img-caption>正則表達式量詞</p></div><p>在上述的正則表達式量詞中，"+"表示一個或者多個，"*"表示零個或者多個，"?"表示一個或者零個。</p><p><br></p><p><strong>正則表達式中的字符序列</strong></p><p>在Java 中的CharSequence類是用來表示字符序列的，在字符序列中定義了一些用於操作字符序列的api，而Java 中大部分與字符串相關的類都實現了CharSequence接口，所以正則表達式操作都能接受CharSequence類型的參數。</p><p><br></p><p><strong>split() 方法</strong></p><p>String類中的split();方法可用於拆分字符串為字符串數組，split();方法能接受正則表達式參數，把字符串從匹配正則表達式的地方拆分開。代碼案例如下：</p><pre><code>public class SplitDemo {    	public static void main(String[] args) {    		String str = "laofu13老夫";      	String strArray = str.split("\\d+");      	System.out.println(Arrays.toString(strArray));    }}</code></pre><p>代碼案例運行結果如下：</p><pre><code>[laofu, 老夫]</code></pre><p>字符串拆分成功。此外，split();方法還有另一個重載方法：</p><pre><code>String[] split(CharSequence input, int limit);// 方法的limit參數用於限制分割成字符串的數量，但如果不傳limit參數，將不會做限制</code></pre><p><br></p><h1 class=pgc-h-center-line>Pattern 和 Matcher</h1><p>Pattern 類和 Matcher類是Java 中用於構建正則表達式對象的，進行正則匹配的類；儘管String類也支持正則表達式，但畢竟功能有限，Pattern 類和 Matcher類了功能更加強大的正則，而且是專為正則表達式提供的。</p><p>在JDK API文檔中提供了這兩個類的調用示例：</p><pre><code> Pattern p = Pattern.compile("a*b"); Matcher m = p.matcher("aaaaab"); boolean b = m.matches();</code></pre><p>最後的boolean類型的b表示的就是匹配結果。根據文檔中代碼示例，就可以編寫自定義的正則表達式案例：<strong>字符串"laofu13lafulaofufulao"中，"fu"至少出現一次的位置是哪幾個？</strong></p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;// 正則表達式案例public class RegexDemo {    public static void main(String[] args) {        String str = "laofu13lafulaofufulao";        Pattern pattern = Pattern.compile("(fu){1,}");        Matcher matcher = pattern.matcher(str);        while (matcher.find()) {            System.out.println("Match \"" + matcher.group() + "\" at positions " +                                matcher.start() + "-" + (matcher.end() - 1));        }    }}</code></pre><p>案例運行結果如下：</p><pre><code>Match "fu" at positions 3-4Match "fu" at positions 9-10Match "fufu" at positions 14-17</code></pre><p>Pattern.compile();方法能根據正則表達式生成Pattern對象；Pattern對象的matcher方法接收要檢索的字符串作為參數，生成一個Matcher對象；Matcher對象會做最終的正則匹配。在Pattern對象中也提供了split();方法和matches();方法，實現效果和String類中的同名方法是一樣的。</p><p><br></p><p><strong>find();方法</strong></p><p>find();方法用於在字符串中查找正則匹配，如果有匹配，返回true，否則返回false；find();方法還支持傳入一個int類型的參數，如果未傳入，find();方法會像迭代器那樣依次往前檢索字符串；如果傳入了該參數，就可以用於<strong>不斷重新設置字符串檢索的起點</strong>。則上述的正則表達式案例就可以稍作修改以實現起始位置的重新設置：</p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;// 正則表達式案例public class RegexDemo {    public static void main(String[] args) {        String str = "laofu13lafulaofufulao";        Pattern pattern = Pattern.compile("(fu){1,}");        Matcher matcher = pattern.matcher(str);      	// 檢索過程中會不斷重新設置搜索的起始位置      	int i = 1;        while (matcher.find(i)) {            System.out.println("Match \"" + matcher.group() + "\" at positions " +                                matcher.start() + "-" + (matcher.end() - 1));          	i++;        }    }}</code></pre><p>作修改後的案例運行結果如下：</p><pre><code>Match "fu" at positions 3-4Match "fu" at positions 3-4Match "fu" at positions 3-4Match "fu" at positions 9-10Match "fu" at positions 9-10Match "fu" at positions 9-10Match "fu" at positions 9-10Match "fu" at positions 9-10Match "fu" at positions 9-10Match "fufu" at positions 14-17Match "fufu" at positions 14-17Match "fufu" at positions 14-17Match "fufu" at positions 14-17Match "fufu" at positions 14-17Match "fu" at positions 16-17Match "fu" at positions 16-17</code></pre><p>由於循環是從0開始的，然後每次檢索都會自增1，也就是說檢索其實是從字符串第一個字符開始的，然後依次每個字符進行檢索，一旦匹配成功，find();方法便會返回true。</p><p>第一個匹配的"fu"字符串前有3個字符，所以從前3個字符的位置開始匹配的，匹配到的都是索引位置為3-4的"fu"；</p><p>第二個匹配的"fu"字符串和第一個匹配的"fu"字符串之間有6個字符，所以第二個匹配的"fu"字符串，會6次匹配到索引位置為9-10的"fu"；</p><p>以此類推。</p><p><br></p><p><strong>組（group）</strong></p><p>正則表達式中的“組”用一對括號劃分，一對括號就是一個組。組號為0表示整個正則表達式，組1表示被第一對括號包圍的表達式，組2便是被第二對括號包圍的表達式，以此類推。比如有以下的正則表達式：</p><pre><code>A(B(C))D</code></pre><p>在上述表達式中，組0是ABCD，組1是BC，組2是C。Matcher對象中也提供了一系列針對組操作的方法：</p><pre><code>int groupCount(); // 返回該匹配模式中的分組數量，但是第0組不算在其中String group();// 返回前一次匹配操作的整個匹配String group(int i);// 返回前一次匹配操作的指定組號的匹配，如果沒有匹配，返回nullint start(int group);// 返回前一次匹配操作中匹配到的組的起始索引int end(int group);// 返回前一次匹配操作中匹配到的組的最後一個字符索引+1的值</code></pre><p><br></p><p>案例代碼如下：</p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;// 正則表達式分組案例public class RegexGroupDemo {    		public static void main(String[] args) {      		String str = "laofu is 13 also dasheng.\n" +            									"hello world hello Java hello\n";        	Pattern pattern = Pattern.compile("(\\S+)\\s+(\\S+)\\s+");          Matcher matcher = pattern.matcher(str);        	while (matcher.find()) {          		for (int i = 0; i &lt; matcher.groupCount(); i++) {              		System.out.print("[" + matcher.group(i) + "]");              }            	System.out.println();          }      }}</code></pre><p>案例代碼運行結果如下：</p><pre><code>[laofu is ][laofu][13 also ][13][dasheng.hello ][dasheng.][world hello ][world][Java hello][Java]</code></pre><p><br></p><p><strong>reset();方法</strong></p><p>通過Matcher對象的reset();方法，可重新設置Matcher對象檢索的字符序列；</p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;// 正則表達式reset();案例public class ResetDemo {    public static void main(String[] args) {        String str = "laofu13lafulaofufulao";        Pattern pattern = Pattern.compile("(fu){1,}");        Matcher matcher = pattern.matcher(str);        while (matcher.find()) {            System.out.println("Match \"" + matcher.group() + "\" at positions " +                                matcher.start() + "-" + (matcher.end() - 1));        }      	System.out.println("重新設置檢索的字符序列 ：" );      	// 重新設置檢索的字符序列      	matcher.reset("13lafu4fu59fulao");      	// 重新匹配字符序列      	while (matcher.find()) {            	System.out.println("Match \"" + matcher.group() + "\" at positions " +                                matcher.start() + "-" + (matcher.end() - 1));        }    }}</code></pre><p>案例運行如下：</p><pre><code>Match "fu" at positions 3-4Match "fu" at positions 9-10Match "fufu" at positions 14-17重新設置檢索的字符序列 ：Match "fu" at positions 4-5Match "fu" at positions 7-8Match "fu" at positions 11-12</code></pre><p><br></p><p><strong>replace(); 方法</strong></p><p>String類中提供了多個替換方法用於將匹配正則表達式的內容替換為指定的字符序列，比如：</p><pre><code>String	replace(CharSequence target, CharSequence replacement);// 用指定的字符序列替換字符串中每一個匹配的目標字符序列為指定的內容String	replaceAll(String regex, String replacement);// 替換字符串中所有匹配正則表達式的內容為指定的字符序列String	replaceFirst(String regex, String replacement)// 替換字符串中第一個匹配正則表達式的內容為指定的字符序列</code></pre><p>上述這些方法都是String類中提供的，用於直接操作字符串，要麼替換第一個，要麼替換全部；而在Matcher對象中提供了一個可以執行漸進式替換的方法：appendReplacement(StringBuffer sbuf, String replacement);，此方法允許調其他的方法來處理replacement，從而可以完成更強大、靈活的字符串操作；案例如下：</p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;// 正則表達式appendReplacement();案例public class AppendReplacementDemo {    public static void main(String[] args) {        String str = "laofu13lafulaofufulao";        Pattern pattern = Pattern.compile("(fu){1,}");        Matcher matcher = pattern.matcher(str);      	// 完成相關操作後的字符串對象      	StringBuffer sbuf = new StringBuffer();        while (matcher.find()) {						            matcher.appendReplacement(sbuf, appendReplacement);        }      	//       	System.out.println(sbuf);    }}</code></pre><p>案例中使用的appendTail();方法作用是把餘下未匹配的字符複製到sbuf中，所以案例最終的運行結果中，把字符串中匹配的內容替換為全大寫的內容。詳情如下：</p><pre><code>laoFU13laFUlaoFUFUlao</code></pre><p><br></p><div class=pgc-img><img alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/406035c8-eebd-45b4-b1a5-af09e642ffe9><p class=pgc-img-caption>Pattern 標記</p></div><h1 class=pgc-h-center-line>Pattern 標記</h1><p>Pattern 類中的compile();方法還有一個重載版本：</p><pre><code>static Pattern	compile(String regex, int flags)；</code></pre><p>該方法除了正則表達式regex外，還接受一個flag標記，可以對匹配結果做調整；flag標記有如下的可選項：</p><pre><code>static int	CANON_EQ// 啟用規範對等static int	CASE_INSENSITIVE// 忽略大小寫// 也可以通過嵌入式標誌表達式(?i)啟用該模式static int	COMMENTS// 空格符和註釋會被忽略// 也可以通過嵌入式標誌表達式(?x)啟用該模式static int	DOTALL// "."會匹配所有字符// 也可以通過嵌入式標誌表達式(?s)啟用該模式static int	LITERAL// 啟用模式的字面解析static int	MULTILINE// ^匹配一行的開始，$匹配一行的結束// 也可以通過嵌入式標誌表達式(?m)啟用該模式static int	UNICODE_CASE// 在這個模式下，如果你還啟用了CASE_INSENSITIVE標誌，// 那麼它會對Unicode字符進行大小寫不明感的匹配。// 也可以通過嵌入式標誌表達式(?u)啟用該模式static int	UNICODE_CHARACTER_CLASS// 啟用Unicode版本的Predefined字符類和POSIX字符類。static int	UNIX_LINES// 在.、^和$行為中，值識別終結符\n// 也可以通過嵌入式標誌表達式(?d)啟用該模式</code></pre><p>在方法中，可以同時使用多個flag標記，多個flag標記之間使用"|"分隔：</p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;// 正則表達式 flag標記案例public class FlagsDemo {    public static void main(String[] args) {        String str = "laofu13\nlaofu\nLaofufu\nLAO";        Pattern pattern = Pattern.compile("^lao",                                           Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);        Matcher matcher = pattern.matcher(str);      	// 完成相關操作後的字符串對象      	StringBuffer sbuf = new StringBuffer();        while (matcher.find()) {						            System.out.println(matcher.group());        }    }}</code></pre><p>案例運行結果中匹配到了所有忽略大小寫的，以lao開頭的行的內容，詳情如下：</p><pre><code>laolaoLaoLAO</code></pre><p><br></p><h1 class=pgc-h-center-line>掃描輸入</h1><p><strong>Scanner 定界符</strong></p><p>在默認情況下，<strong>Scanner</strong>會根據空白字符對輸入內容進行分詞，但是也能使用正則表達式自定義分界符：</p><pre><code>import java.util.regex.Matcher;import java.util.regex.Pattern;import java.util.Scanner;// Scanner 定界符案例public class DelimiterDemo {    public static void main(String[] args) {        Scanner sc = new Scanner("13, laofu, ds, hello");        // 設置定界符        sc.useDelimiter("\\s*,\\s*");        while (sc.hasNext()) {          System.out.println(sc.next());        }    }}</code></pre><p>案例中，使用useDelimiter();方法來設置定界符，就這樣，Scanner中的輸入被我們定義的定界符一一拆分開了：</p><pre><code>13laofudshello</code></pre><p><br></p><p><strong>掃描輸入</strong></p><p>除了設置定界符之外，還可以在Scanner中使用正則表達式來掃描輸入，篩選出特定的內容：</p><pre><code>import java.util.regex.*;import java.util.*;// Scanner 掃描輸入案例public class ScannerRegexDemo {    public static void main(String[] args) {			  String data = "13.14.13.14@02/02/2020\n" +                     "15.16.15.16@02/03/2020\n" +                     "17.18.17.18@02/05/2020\n" +                    "[以上這些ip地址需要注意！]";        Scanner sc = new Scanner(data);        String pattern = "(\\d+[.]\\d+[.]\\d+[.]\\d+)@(\\d{2}/\\d{2}/\\d{4})";        while (sc.hasNext(pattern)) {          sc.next(pattern);          MatchResult match = sc.match();          String ip = match.group(1);          String date = match.group(2);          System.out.format("ip: %s, date: %s \n", ip, date);        }    }}</code></pre><p>案例運行結果如下：</p><pre><code>ip: 13.14.13.14, date: 02/02/2020 ip: 15.16.15.16, date: 02/03/2020 ip: 17.18.17.18, date: 02/05/2020 </code></pre><p>案例中，Scanner 和 正則表達式配合使用，構建出了強大、靈活的字符串分詞工具，而且使用簡單，上手簡單，以少量代碼便可完成強大的功能。</p><h1 class=pgc-h-center-line>小結</h1><ol start=1><li><strong>格式化輸出</strong>，以多種不同的格式化輸出的案例引出正則表達式；</li><li><strong>正則表達式</strong>，詳述正則表達式語法，每一個字符、字符類所表示的含義，以及相關的邏輯操作符；通過多個案例，從0開始，一步步構建強大的正則表達式及其相關操作；</li><li><strong>Pattern 和 Matcher</strong>，Pattern 和 Matcher兩個類是Java 正則表達式對象的核心，通過這兩個類便可完成正則表達式對象的構建，然後調用對象中的方法來完成對正則表達式的操作；</li><li><strong>Pattern 標記，</strong>藉由Pattern 類中提供的flag，可對正則表達式的匹配結果做調整，比如排序；</li><li><strong>掃描輸入，</strong>正則表達式還可以應用在掃描輸入中，設置定界符來完成特定輸入的格式化，Scanner 和 正則表達式配合使用，構建出了強大、靈活的字符串分詞工具。</li></ol><p>完結，老夫雖不正經，但老夫一身的才華！關注我，收穫更多編程基礎知識。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JAVA</a></li><li><a>輸出</a></li><li><a>描輸入</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/566b8be3.html alt=動力輸出傳動齒輪失效淺析及整改措施 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/48044ceae6a54a43865a9a93497a0dfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/566b8be3.html title=動力輸出傳動齒輪失效淺析及整改措施>動力輸出傳動齒輪失效淺析及整改措施</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html alt=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15310942260931dda577a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html title=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點>JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09897862.html alt=說說功放輸出功率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c37a6b568da44ec1906328d56fbe6a2f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09897862.html title=說說功放輸出功率>說說功放輸出功率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ed63538.html alt=合肥研究院在改善離軸積分腔輸出光譜信號方面獲進展 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Ret3lwW8K4IJAL style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ed63538.html title=合肥研究院在改善離軸積分腔輸出光譜信號方面獲進展>合肥研究院在改善離軸積分腔輸出光譜信號方面獲進展</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07beccda.html alt=PHP輸出緩衝區詳細教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07beccda.html title=PHP輸出緩衝區詳細教程>PHP輸出緩衝區詳細教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9753c7b3.html alt="動力輸出平順 試駕奇瑞全新瑞虎7 1.5T車型" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d9f3082ab6294e819f60d8c0e881815c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9753c7b3.html title="動力輸出平順 試駕奇瑞全新瑞虎7 1.5T車型">動力輸出平順 試駕奇瑞全新瑞虎7 1.5T車型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae042690.html alt=動力輸出平順性的主要影響因素有哪些？你可能被老司機套路了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2f1d6b53d5204b1eada53d9a7f6f727e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae042690.html title=動力輸出平順性的主要影響因素有哪些？你可能被老司機套路了>動力輸出平順性的主要影響因素有哪些？你可能被老司機套路了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html alt=JAVA入門到大神（玩轉正則表達式） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html title=JAVA入門到大神（玩轉正則表達式）>JAVA入門到大神（玩轉正則表達式）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html alt=給JAVA開發人員的正則表達式入門課 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html title=給JAVA開發人員的正則表達式入門課>給JAVA開發人員的正則表達式入門課</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html alt=JAVA怎麼處理異常 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/6cf507ab-d41c-4bb0-bef0-6def0eb1fef8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html title=JAVA怎麼處理異常>JAVA怎麼處理異常</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3e39d2f.html alt=計算機輸入輸出系統的概論-I/O設備編址 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/2fabdb4c-7e98-4e78-aee6-f04dab55e4d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3e39d2f.html title=計算機輸入輸出系統的概論-I/O設備編址>計算機輸入輸出系統的概論-I/O設備編址</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html alt=JAVA應用程序開發之集合類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aa9e1fe1752a4a1886a691485e0e1373 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html title=JAVA應用程序開發之集合類>JAVA應用程序開發之集合類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html alt=小白學JAVA之——List接口的實現類——ArrayList class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b14b6a69b8354d53a35156eaa365395e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html title=小白學JAVA之——List接口的實現類——ArrayList>小白學JAVA之——List接口的實現類——ArrayList</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8fbe992.html alt=把輸入/輸出接口視為存儲單元，與存儲器統一編址 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1526536447865be6f7e7065 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8fbe992.html title=把輸入/輸出接口視為存儲單元，與存儲器統一編址>把輸入/輸出接口視為存儲單元，與存儲器統一編址</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>