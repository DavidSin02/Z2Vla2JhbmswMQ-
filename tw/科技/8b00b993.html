<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>《深入精通Mysql（一）》Mysql整體架構和sql執行過程 | 极客快訊</title><meta property="og:title" content="《深入精通Mysql（一）》Mysql整體架構和sql執行過程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/3a03943b7e3c456fb535e18f902470e4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b00b993.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b00b993.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8b00b993.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b00b993.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b00b993.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8b00b993.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8b00b993.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b00b993.html><meta property="article:published_time" content="2020-10-29T21:09:08+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:08+08:00"><meta name=Keywords content><meta name=description content="《深入精通Mysql（一）》Mysql整體架構和sql執行過程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8b00b993.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>《深入精通Mysql（一）》Mysql整體架構和sql執行過程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=pgc-h-arrow-right>MySQL 的工作流程</h2><h2 class=pgc-h-arrow-right>1.一條查詢 SQL 語句是如何執行的</h2><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3a03943b7e3c456fb535e18f902470e4><p class=pgc-img-caption></p></div><p>我們的程序或者工具要操作數據庫，第一步要做什麼事情？</p><p><strong>跟數據庫建立連接。</strong></p><h2 class=pgc-h-arrow-right>1.1. 通信協議</h2><p>首先，MySQL 必須要運行一個服務，監聽默認的 3306 端口。</p><p>在我們開發系統跟第三方對接的時候，必須要弄清楚的有兩件事。</p><p>第一個就是通信協議，比如我們是用 HTTP 還是 WebService 還是 TCP？</p><p>第二個是消息格式，比如我們用 XML 格式，還是 JSON 格式，還是定長格式？報文頭長度多少，包含什麼內容，每個字段的詳細含義。比如我們之前跟銀聯對接，銀聯的銀行卡聯網規範，約定了一種比較複雜的通訊協議叫做：四進四出單工異步長連接（為了保證穩定性和性能）。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1cf10537f74846348e43363e81da68a4><p class=pgc-img-caption></p></div><p><strong>MySQL 是支持多種通信協議的，可以使用同步/異步的方式，支持長連接/短連接。這裡我們拆分來看。第一個是通信類型</strong></p><p><strong>通信類型： 同步或者異步</strong></p><p>同步通信的特點：</p><p>1、同步通信依賴於被調用方，受限於被調用方的性能。也就是說，應用操作數據庫，線程會阻塞，等待數據庫的返回。</p><p>2、一般只能做到一對一，很難做到一對多的通信。</p><p>異步跟同步相反：</p><p>1、異步可以避免應用阻塞等待，但是不能節省 SQL 執行的時間。</p><p>2、如果異步存在併發，每一個 SQL 的執行都要單獨建立一個連接，避免數據混亂。但是這樣會給服務端帶來巨大的壓力（一個連接就會創建一個線程，線程間切換會佔用大量 CPU 資源）。另外異步通信還帶來了編碼的複雜度，所以一般不建議使用。如果要異步，必須使用連接池，排隊從連接池獲取連接而不是創建新連接。</p><p>一般來說我們連接數據庫都是<strong>同步連接</strong>。</p><p><strong>連接方式： 長連接或者短連接</strong></p><p>MySQL 既支持短連接，也支持長連接。短連接就是操作完畢以後，馬上 close 掉。長連接可以保持打開，減少服務端創建和釋放連接的消耗，後面的程序訪問的時候還可以使用這個連接。一般我們會在連接池中使用長連接。</p><p>保持長連接會消耗內存。長時間不活動的連接，MySQL 服務器會斷開。</p><pre><code>show global variables like 'wait_timeout'; -- 非交互式超時時間， 如 JDBC 程序show global variables like 'interactive_timeout'; -- 交互式超時時間， 如數據庫工具</code></pre><p>默認都是 28800 秒，8 小時。</p><blockquote><p>我們怎麼查看 MySQL 當前有多少個連接？</p></blockquote><p>可以用 show status 命令：</p><pre><code>show global status like 'Thread%';</code></pre><p>Threads_cached：緩存中的線程連接數。</p><p>Threads_connected：當前打開的連接數。</p><p>Threads_created：為處理連接創建的線程數。</p><p>Threads_running：非睡眠狀態的連接數，通常指併發連接數。</p><p>每產生一個連接或者一個會話，在服務端就會創建一個線程來處理。反過來，如果要殺死會話，就是 Kill 線程。</p><p><br></p><blockquote><p>有了連接數，怎麼知道當前連接的狀態？<br>也可以使用 <strong>SHOW PROCESSLIST;</strong> （root 用戶）查看 SQL 的執行狀態。</p></blockquote><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b630dc9a314d4b3f92deba3a1ee222ba><p class=pgc-img-caption></p></div><p><strong>一些常見的狀態：</strong></p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ffa30e6451c446ef9d5665de9484b302><p class=pgc-img-caption></p></div><blockquote><p>MySQL 服務允許的最大連接數是多少呢？</p></blockquote><p>在 5.7 版本中默認是 151 個，最大可以設置成 16384（2^14）。</p><pre><code>show variables like 'max_connections';</code></pre><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b0e1d2f2ebfb426083f4348b02a96373><p class=pgc-img-caption></p></div><p><br></p><p>show 的參數說明：</p><p>1、級別：會話 session 級別（默認）；全局 global 級別</p><p>2、動態修改：set，重啟後失效；永久生效，修改配置文件/etc/my.conf</p><pre><code>set global max_connections = 1000;</code></pre><p><strong>通信協議</strong></p><p>MySQL 支持哪些通信協議呢？</p><p>第一種是 Unix Socket。</p><p>比如我們在 Linux 服務器上，如果沒有指定-h 參數，它就用 socket 方式登錄（省略了-S /var/lib/mysql/mysql.sock）。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/81b74036197841599ecfbe431aaafdde><p class=pgc-img-caption></p></div><p>它不用通過網絡協議，也可以連接到 MySQL 的服務器，它需要用到服務器上的一個物理文件（/var/lib/mysql/mysql.sock）。</p><pre><code>select @@socket;</code></pre><p>如果指定-h 參數，就會用第二種方式，TCP/IP 協議。</p><pre><code>mysql -h192.168.8.211 -uroot -p123456</code></pre><p>我 們 的 編 程 語 言 的 連 接 模 塊 都 是 用 TCP 協 議 連 接 到 MySQL 服 務 器 的 ， 比 如</p><p>mysql-connector-java-x.x.xx.jar。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19e955bc6093446686034167129719f7><p class=pgc-img-caption></p></div><p>另外還有命名管道（Named Pipes）和內存共享（Share Memory）的方式，這兩種通信方式只能在 Windows 上面使用，一般用得比較少。</p><p><strong>1.1.2.通信方式</strong></p><p>第二個是通信方式。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/db1c40af960a417dad1e5494384245c6><p class=pgc-img-caption></p></div><p><strong>單工：</strong></p><p>在兩臺計算機通信的時候，數據的傳輸是單向的。生活中的類比：遙控器。</p><p><strong>半雙工：</strong></p><p>在兩臺計算機之間，數據傳輸是雙向的，你可以給我發送，我也可以給你發送，</p><p>但是在這個通訊連接裡面，同一時間只能有一臺服務器在發送數據，也就是你要給我發</p><p>的話，也必須等我發給你完了之後才能給我發。生活中的類比：對講機。</p><p><strong>全雙工：</strong></p><p>數據的傳輸是雙向的，並且可以同時傳輸。生活中的類比：打電話。</p><blockquote><p>MySQL 使用了半雙工的通信方式？</p></blockquote><p>要麼是客戶端向服務端發送數據，要麼是服務端向客戶端發送數據，這兩個動作不能同時發生。所以客戶端發送 SQL 語句給服務端的時候，（在一次連接裡面）數據是不能分成小塊發送的，不管你的 SQL 語句有多大，都是一次性發送。</p><p>比如我們用 MyBatis 動態 SQL 生成了一個批量插入的語句，插入 10 萬條數據，values後面跟了一長串的內容，或者 where 條件 in 裡面的值太多，會出現問題。</p><p>這個時候我們必須要調整 MySQL 服務器配置 max_allowed_packet 參數的值（默認是 4M），把它調大，否則就會報錯。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/baf973e6d89942c0b2530aa1cd892ada><p class=pgc-img-caption></p></div><p>另一方面，對於服務端來說，也是一次性發送所有的數據，不能因為你已經取到了想要的數據就中斷操作，這個時候會對網絡和內存產生大量消耗。</p><p>所以，我們一定要在程序裡面避免不帶 limit 的這種操作，比如一次把所有滿足條件的數據全部查出來，一定要先 count 一下。如果數據量的話，可以分批查詢。</p><blockquote><p>執行一條查詢語句，客戶端跟服務端建立連接之後呢？下一步要做什麼？</p></blockquote><h2 class=pgc-h-arrow-right>1.2. 查詢緩存</h2><p>MySQL 內部自帶了一個緩存模塊。</p><p>緩存的作用我們應該很清楚了，把數據以 KV 的形式放到內存裡面，可以加快數據的讀取速度，也可以減少服務器處理的時間。但是 MySQL 的緩存我們好像比較陌生，從來沒有去配置過，也不知道它什麼時候生效？</p><p>比如 user_innodb 有 500 萬行數據，沒有索引。我們在沒有索引的字段上執行同樣的查詢，大家覺得第二次會快嗎？</p><pre><code>select * from user_innodb where name='javaHuang';</code></pre><p>為何緩存沒有生效，為什麼？MySQL 的緩存默認是關閉的。</p><pre><code>show variables like 'query_cache%';</code></pre><p>默認關閉的意思就是不推薦使用，為什麼 MySQL 不推薦使用它自帶的緩存呢？</p><p>主要是因為 MySQL 自帶的緩存的應用場景有限，第一個是它要求 SQL 語句必須一模一樣，中間多一個空格，字母大小寫不同都被認為是不同的的 SQL。</p><p>第二個是表裡面任何一條數據發生變化的時候，這張表所有緩存都會失效，所以對於有大量數據更新的應用，也不適合。</p><p>所以緩存這一塊，我們還是交給 ORM 框架（比如 MyBatis 默認開啟了一級緩存），或者獨立的緩存服務，比如 Redis 來處理更合適。</p><p>在 MySQL 8.0 中，查詢緩存已經被移除了。</p><h2 class=pgc-h-arrow-right>1.3. 語法解析和預處理(Parser & Preprocessor)</h2><p>我們沒有使用緩存的話，就會跳過緩存的模塊，下一步我們要做什麼呢？</p><p>OK，這裡我會有一個疑問，為什麼我的一條 SQL 語句能夠被識別呢？假如我隨便執行一個字符串 penyuyan，服務器報了一個 1064 的錯：</p><p>[Err] 1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for theright syntax to use near 'penyuyan' at line 1</p><p>它是怎麼知道我輸入的內容是錯誤的？</p><p>這個就是 MySQL 的 Parser 解析器和 Preprocessor 預處理模塊。</p><p>這一步主要做的事情是對語句基於 SQL 語法進行詞法和語法分析和語義的解析。</p><p><strong>1.3.1.詞法解析</strong></p><p>詞法分析就是把一個完整的 SQL 語句打碎成一個個的單詞。</p><p>比如一個簡單的 SQL 語句：</p><pre><code>select name from user where id = 1;</code></pre><p>它會打碎成 8 個符號，每個符號是什麼類型，從哪裡開始到哪裡結束。</p><p><strong>1.3.2.語法解析</strong></p><p>第二步就是語法分析，語法分析會對 SQL 做一些語法檢查，比如單引號有沒有閉合，然後根據 MySQL 定義的語法規則，根據 SQL 語句生成一個數據結構。這個數據結構我們把它叫做解析樹（select_lex）。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/28a7772a71914aef9e53ee78e9d78313><p class=pgc-img-caption></p></div><p>任何數據庫的中間件，比如 Mycat，Sharding-JDBC（用到了 Druid Parser），都必須要有詞法和語法分析功能，在市面上也有很多的開源的詞法解析的工具（比如 LEX，Yacc）。</p><p><strong>1.3.3.預處理器</strong></p><p>問題：如果我寫了一個詞法和語法都正確的 SQL，但是表名或者字段不存在，會在哪裡報錯？是在數據庫的執行層還是解析器？比如：</p><pre><code>select * from penyuyan;</code></pre><p>解析器可以分析語法，但是它怎麼知道數據庫裡面有什麼表，表裡面有什麼字段呢？</p><p>實際上還是在解析的時候報錯，解析 SQL 的環節裡面有個預處理器。</p><p>它會檢查生成的解析樹，解決解析器無法解析的語義。比如，它會檢查表和列名是否存在，檢查名字和別名，保證沒有歧義。</p><p>預處理之後得到一個新的解析樹。</p><h2 class=pgc-h-arrow-right>1.4. 查詢優化（ Query Optimizer） 與查詢執行計劃</h2><p><strong>1.4.2. 優化器可以做什麼？</strong></p><p>MySQL 的優化器能處理哪些優化類型呢？</p><p>舉兩個簡單的例子：</p><p>1、當我們對多張表進行關聯查詢的時候，以哪個表的數據作為基準表。</p><p>2、有多個索引可以使用的時候，選擇哪個索引。</p><p>實際上，對於每一種數據庫來說，優化器的模塊都是必不可少的，他們通過複雜的算法實現儘可能優化查詢效率的目標。</p><blockquote><p>如果對於優化器的細節感興趣，可以看看《數據庫查詢優化器的藝術-原理解析與SQL性能優化》。</p></blockquote><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eb889fe9c774ab9b148bd610ec637df><p class=pgc-img-caption></p></div><p>但是優化器也不是萬能的，並不是再垃圾的 SQL 語句都能自動優化，也不是每次都能選擇到最優的執行計劃，大家在編寫 SQL 語句的時候還是要注意。</p><p>如果我們想知道優化器是怎麼工作的，它生成了幾種執行計劃，每種執行計劃的 cost是多少，應該怎麼做？</p><p><strong>1.4.3.優化器是怎麼得到執行計劃的？</strong></p><p>首先我們要啟用優化器的追蹤（默認是關閉的）：</p><pre><code>SHOW VARIABLES LIKE 'optimizer_trace';set optimizer_trace='enabled=on';</code></pre><p>注意開啟這開關是會消耗性能的，因為它要把優化分析的結果寫到表裡面，所以不要輕易開啟，或者查看完之後關閉它（改成 off）。</p><p>注意：參數分為 session 和 global 級別。</p><p>接著我們執行一個 SQL 語句，優化器會生成執行計劃：</p><pre><code>select t.tcid from teacher t,teacher_contact tc where t.tcid = tc.tcid;</code></pre><p>這個時候優化器分析的過程已經記錄到系統表裡面了，我們可以查詢：</p><pre><code>select * from information_schema.optimizer_trace\G</code></pre><p>它是一個 JSON 類型的數據，主要分成三部分，準備階段、優化階段和執行階段。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/65ebe7c6225743b99b213310dcb30a5a><p class=pgc-img-caption></p></div><p>expanded_query 是優化後的 SQL 語句。</p><p>considered_execution_plans 裡面列出了所有的執行計劃。</p><p>分析完記得關掉它：</p><pre><code>set optimizer_trace="enabled=off";SHOW VARIABLES LIKE 'optimizer_trace';</code></pre><p><strong>1.4.4. 優化器得到的結果</strong></p><p>優化完之後，得到一個什麼東西呢？</p><p>優化器最終會把解析樹變成一個查詢執行計劃，查詢執行計劃是一個數據結構。</p><p>當然，這個執行計劃是不是一定是最優的執行計劃呢？不一定，因為 MySQL 也有可能覆蓋不到所有的執行計劃。</p><p>我們怎麼查看 MySQL 的執行計劃呢？比如多張表關聯查詢，先查詢哪張表？在執行查詢的時候可能用到哪些索引，實際上用到了什麼索引？</p><p>MySQL 提供了一個執行計劃的工具。我們在 SQL 語句前面加上 EXPLAIN，就可以看到執行計劃的信息。</p><pre><code>EXPLAIN select name from user where id=1</code></pre><p>注意 Explain 的結果也不一定最終執行的方式。</p><h2 class=pgc-h-arrow-right>1.5. 存儲引擎</h2><blockquote><p>得到執行計劃以後，SQL 語句是不是終於可以執行了？</p></blockquote><p>問題又來了：</p><p>1、從邏輯的角度來說，我們的數據是放在哪裡的，或者說放在一個什麼結構裡面？</p><p>2、執行計劃在哪裡執行？是誰去執行？</p><p><strong>1.5.1. 存儲引擎基本介紹</strong></p><p>我們先回答第一個問題：在關係型數據庫裡面，數據是放在什麼結構裡面的？（放在表 Table 裡面的）</p><p>我們可以把這個表理解成 Excel 電子表格的形式。所以我們的表在存儲數據的同時，還要組織數據的存儲結構，這個存儲結構就是由我們的存儲引擎決定的，所以我們也可以把存儲引擎叫做表類型。</p><p>在 MySQL 裡面，支持多種存儲引擎，他們是可以替換的，所以叫做插件式的存儲引擎。為什麼要搞這麼多存儲引擎呢？一種還不夠用嗎？</p><p>這個問題先留著。</p><p><strong>1.5.2. 查看存儲引擎</strong></p><p>比如我們數據庫裡面已經存在的表，我們怎麼查看它們的存儲引擎呢？</p><pre><code>show table status from `ToBeTopJavaer`;</code></pre><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f3ff5bd9ee4b42c9bb4104d806126348><p class=pgc-img-caption></p></div><p>或者通過 DDL 建表語句來查看。</p><p>在 MySQL 裡面，我們創建的每一張表都可以指定它的存儲引擎，而不是一個數據庫只能使用一個存儲引擎。存儲引擎的使用是以表為單位的。而且，創建表之後還可以修改存儲引擎。</p><p>我們說一張表使用的存儲引擎決定我們存儲數據的結構，那在服務器上它們是怎麼存儲的呢？我們先要找到數據庫存放數據的路徑：</p><pre><code>show variables like 'datadir';</code></pre><p>默認情況下，每個數據庫有一個自己文件夾，以 ToBeTopJavaer數據庫為例。</p><p>任何一個存儲引擎都有一個 frm 文件，這個是表結構定義文件。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4de6db640fc942188212be3b76e70217><p class=pgc-img-caption></p></div><p>不同的存儲引擎存放數據的方式不一樣，產生的文件也不一樣，innodb 是 1 個，memory 沒有，myisam 是兩個。</p><blockquote><p>這些存儲引擎的差別在哪呢？</p></blockquote><p><strong>1.5.3. 存儲引擎比較</strong></p><p><strong>常見存儲引擎</strong></p><p>MyISAM 和 InnoDB 是我們用得最多的兩個存儲引擎，在 MySQL 5.5 版本之前，默認的存儲引擎是 MyISAM，它是 MySQL 自帶的。我們創建表的時候不指定存儲引擎，它就會使用 MyISAM 作為存儲引擎。</p><p>MyISAM 的前身是 ISAM（Indexed Sequential Access Method：利用索引，順序存取數據的方法）。</p><p>5.5 版本之後默認的存儲引擎改成了 InnoDB，它是第三方公司為 MySQL 開發的。</p><p>為什麼要改呢？最主要的原因還是 InnoDB 支持事務，支持行級別的鎖，對於業務一致性要求高的場景來說更適合。</p><p>這個裡面又有 Oracle 和 MySQL 公司的一段恩怨情仇。</p><p>InnoDB 本來是 InnobaseOy 公司開發的，它和 MySQL AB 公司合作開源了 InnoDB的代碼。但是沒想到 MySQL 的競爭對手 Oracle 把 InnobaseOy 收購了。後來 08 年 Sun 公司（開發 Java 語言的 Sun）收購了 MySQL AB，09 年 Sun 公司又被 Oracle 收購了，所以 MySQL，InnoDB 又是一家了。有人覺得 MySQL 越來越像Oracle，其實也是這個原因。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/87d3c381236e4461abe978207b018720><p class=pgc-img-caption></p></div><blockquote><p>那麼除了這兩個我們最熟悉的存儲引擎，數據庫還支持其他哪些常用的存儲引擎呢？</p></blockquote><p><strong>數據庫支持的存儲引擎</strong></p><p>我們可以用這個命令查看數據庫對存儲引擎的支持情況：</p><pre><code>show engines ;</code></pre><p>其中有存儲引擎的描述和對事務、XA 協議和 Savepoints 的支持。XA 協議用來實現分佈式事務（分為本地資源管理器，事務管理器）。</p><p>Savepoints 用來實現子事務（嵌套事務）。創建了一個 Savepoints 之後，事務就可以回滾到這個點，不會影響到創建 Savepoints 之前的操作。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/745cf8b74256402583722de70dad5ea3><p class=pgc-img-caption></p></div><blockquote><p>這些數據庫支持的存儲引擎，分別有什麼特性呢？</p></blockquote><p>MyISAM（ 3 個文件）</p><p>These tables have a small footprint. Table-level locking limits the performance in read/write workloads, so it is often used in read-only or read-mostly workloads in Web and data warehousing configurations.</p><p>應用範圍比較小。表級鎖定限制了讀/寫的性能，因此在 Web 和數據倉庫配置中，它通常用於只讀或以讀為主的工作。</p><p><strong>特點：</strong></p><p>1.支持表級別的鎖（插入和更新會鎖表）。不支持事務。</p><p>2.擁有較高的插入（insert）和查詢（select）速度。</p><p>3.存儲了表的行數（count 速度更快）。</p><p>（怎麼快速向數據庫插入 100 萬條數據？我們有一種先用 MyISAM 插入數據，然後修改存儲引擎為 InnoDB 的操作。）</p><p>適合：只讀之類的數據分析的項目。</p><p><strong>InnoDB（ 2 個文件）</strong></p><p>The default storage engine in MySQL 5.7. InnoDB is a transaction-safe (ACID compliant) storage engine for MySQL that has commit, rollback, and crash-recovery capabilities to protect user data. InnoDB row-level locking (without escalation to coarser granularity locks) and Oracle-style consistent nonlocking reads increase multi-user concurrency and performance.</p><p>InnoDB stores user data in clustered indexes to reduce I/O for common queries based on primary keys. To maintain data integrity, InnoDB also supports FOREIGN KEY referential-integrity constraints.</p><p>mysql 5.7 中的默認存儲引擎。InnoDB 是一個事務安全（與 ACID 兼容）的 MySQL存儲引擎，它具有提交、回滾和崩潰恢復功能來保護用戶數據。InnoDB 行級鎖（不升級為更粗粒度的鎖）和 Oracle 風格的一致非鎖讀提高了多用戶併發性和性能。InnoDB 將用戶數據存儲在聚集索引中，以減少基於主鍵的常見查詢的 I/O。為了保持數據完整性，InnoDB 還支持外鍵引用完整性約束。</p><p>特點：</p><p>1.支持事務，支持外鍵，因此數據的完整性、一致性更高。</p><p>2.支持行級別的鎖和表級別的鎖。</p><p>3.支持讀寫併發，寫不阻塞讀（MVCC）。</p><p>4.特殊的索引存放方式，可以減少 IO，提升查詢效率。</p><p><strong>適合：經常更新的表，存在併發讀寫或者有事務處理的業務系統。</strong></p><p><strong>Memory（ 1 個文件）</strong></p><p>Stores all data in RAM, for fast access in environments that require quick lookups of non-critical data. This engine was formerly known as the HEAP engine. Its use cases are decreasing; InnoDB with its buffer pool memory area provides a general-purpose and durable way to keep most or all data in memory, and NDBCLUSTER provides fast key-value lookups for huge distributed data sets.</p><p>將所有數據存儲在 RAM 中，以便在需要快速查找非關鍵數據的環境中快速訪問。這個引擎以前被稱為堆引擎。其使用案例正在減少；InnoDB 及其緩衝池內存區域提供了一種通用、持久的方法來將大部分或所有數據保存在內存中，而 ndbcluster 為大型分佈式數據集提供了快速的鍵值查找。</p><p>特點：</p><p>1.把數據放在內存裡面，讀寫的速度很快，但是數據庫重啟或者崩潰，數據會全部消</p><p>失。只適合做臨時表。</p><p>2.將表中的數據存儲到內存中。</p><p><strong>CSV（ 3 個文件）</strong></p><p>Its tables are really text files with comma-separated values. CSV tables let you import or dump data in CSV format, to exchange data with scripts and applications that read and write that same format. Because CSV tables are not indexed, you typically keep the data in InnoDB tables during normal operation, and only use CSV tables during the import or export stage.</p><p>它的表實際上是帶有逗號分隔值的文本文件。csv表允許以csv格式導入或轉儲數據，以便與讀寫相同格式的腳本和應用程序交換數據。因為 csv 表沒有索引，所以通常在正常操作期間將數據保存在 innodb 表中，並且只在導入或導出階段使用 csv 表。</p><p>特點：不允許空行，不支持索引。格式通用，可以直接編輯，適合在不同數據庫之間導入導出。</p><p><strong>Archive（ 2 個文件）</strong></p><p>These compact, unindexed tables are intended for storing and retrieving large amounts of seldom-referenced historical,archived, or security audit information.</p><p>這些緊湊的未索引的表用於存儲和檢索大量很少引用的歷史、存檔或安全審計信息。</p><p>特點：不支持索引，不支持 update delete。</p><p>這是 MySQL 裡面常見的一些存儲引擎，我們看到了，不同的存儲引擎提供的特性都不一樣，它們有不同的存儲機制、索引方式、鎖定水平等功能。</p><p>我們在不同的業務場景中對數據操作的要求不同，就可以選擇不同的存儲引擎來滿足我們的需求，這個就是 MySQL 支持這麼多存儲引擎的原因。</p><p><strong>1.5.4. 如何選擇存儲引擎？</strong></p><p>如果對數據一致性要求比較高，需要事務支持，可以選擇 InnoDB。</p><p>如果數據查詢多更新少，對查詢性能要求比較高，可以選擇 MyISAM。</p><p>如果需要一個用於查詢的臨時表，可以選擇 Memory。</p><p>如果所有的存儲引擎都不能滿足你的需求，並且技術能力足夠，可以根據官網內部手冊用 C 語言開發一個存儲引擎：https://dev.mysql.com/doc/internals/en/custom-eng</p><h2 class=pgc-h-arrow-right>1.6. 執行引擎（ Query Execution Engine） ， 返回結果</h2><p>OK，存儲引擎分析完了，它是我們存儲數據的形式，繼續第二個問題，是誰使用執行計劃去操作存儲引擎呢？</p><p>這就是我們的執行引擎，它利用存儲引擎提供的相應的 API 來完成操作。</p><p>為什麼我們修改了表的存儲引擎，操作方式不需要做任何改變？因為不同功能的存儲引擎實現的 API 是相同的。</p><p>最後把數據返回給客戶端，即使沒有結果也要返回。</p><h2 class=pgc-h-arrow-right>2. MySQL 體系結構總結</h2><p>基於上面分析的流程，我們一起來梳理一下 MySQL 的內部模塊。</p><h2 class=pgc-h-arrow-right>2.1. 模塊詳解</h2><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/112b1e7ebecb4d1581370d91644d66c6><p class=pgc-img-caption></p></div><p>1、 Connector：用來支持各種語言和 SQL 的交互，比如 PHP，Python，Java 的JDBC；</p><p>2、 Management Serveices & Utilities：系統管理和控制工具，包括備份恢復、MySQL 複製、集群等等；</p><p>3、 Connection Pool：連接池，管理需要緩衝的資源，包括用戶密碼權限線程等等；</p><p>4、 SQL Interface：用來接收用戶的 SQL 命令，返回用戶需要的查詢結果</p><p>5、 Parser：用來解析 SQL 語句；</p><p>6、 Optimizer：查詢優化器；</p><p>7、 Cache and Buffer：查詢緩存，除了行記錄的緩存之外，還有表緩存，Key 緩存，權限緩存等等；</p><p>8、 Pluggable Storage Engines：插件式存儲引擎，它提供 API 給服務層使用，跟具體的文件打交道。</p><h2 class=pgc-h-arrow-right>2.2. 架構分層</h2><p>總體上，我們可以把 MySQL 分成三層，跟客戶端對接的連接層，真正執行操作的服務層，和跟硬件打交道的存儲引擎層（參考 MyBatis：接口、核心、基礎）。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5805d028854e43f390df57cb315c2d3c><p class=pgc-img-caption></p></div><p><strong>2.1.1.連接層</strong></p><p>我們的客戶端要連接到 MySQL 服務器 3306 端口，必須要跟服務端建立連接，那麼管理所有的連接，驗證客戶端的身份和權限，這些功能就在連接層完成。</p><p><strong>2.1.2.服務層</strong></p><p>連接層會把 SQL 語句交給服務層，這裡面又包含一系列的流程：</p><p>比如查詢緩存的判斷、根據 SQL 調用相應的接口，對我們的 SQL 語句進行詞法和語法的解析（比如關鍵字怎麼識別，別名怎麼識別，語法有沒有錯誤等等）。然後就是優化器，MySQL 底層會根據一定的規則對我們的 SQL 語句進行優化，最後再交給執行器去執行。</p><p><strong>2.1.3.存儲引擎</strong></p><p>存儲引擎就是我們的數據真正存放的地方，在 MySQL 裡面支持不同的存儲引擎。再往下就是內存或者磁盤。</p><h2 class=pgc-h-arrow-right>3. 一條更新 SQL 是如何執行的？</h2><blockquote><p>講完了查詢流程，我們是不是再講講更新流程、插入流程和刪除流程？</p></blockquote><p>在數據庫裡面，我們說的 update 操作其實包括了更新、插入和刪除。如果大家有看過 MyBatis 的源碼，應該知道 Executor 裡面也只有 doQuery()和 doUpdate()的方法，沒有 doDelete()和 doInsert()。</p><blockquote><p>更新流程和查詢流程有什麼不同呢？</p></blockquote><p>基本流程也是一致的，也就是說，它也要經過解析器、優化器的處理，最後交給執行器。</p><p>區別就在於拿到符合條件的數據之後的操作。</p><p>3.1. 緩衝池 Buffer Pool</p><p>首先，InnnoDB 的數據都是放在磁盤上的，InnoDB 操作數據有一個最小的邏輯單位，叫做頁（索引頁和數據頁）。我們對於數據的操作，不是每次都直接操作磁盤，因為磁盤的速度太慢了。InnoDB 使用了一種緩衝池的技術，也就是把磁盤讀到的頁放到一塊內存區域裡面。這個內存區域就叫 Buffer Pool。下一次讀取相同的頁，先判斷是不是在緩衝池裡。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6f56131c39494c77a76569c4eb8f58cc><p class=pgc-img-caption></p></div><p>下一次讀取相同的頁，先判斷是不是在緩衝池裡面，如果是，就直接讀取，不用再次訪問磁盤。</p><p>修改數據的時候，先修改緩衝池裡面的頁。內存的數據頁和磁盤數據不一致的時候，我們把它叫做髒頁。InnoDB 裡面有專門的後臺線程把 Buffer Pool 的數據寫入到磁盤，每隔一段時間就一次性地把多個修改寫入磁盤，這個動作就叫做刷髒。</p><p>Buffer Pool 是 InnoDB 裡面非常重要的一個結構，它的內部又分成幾塊區域。這裡我們趁機到官網來認識一下 InnoDB 的內存結構和磁盤結構。</p><h2 class=pgc-h-arrow-right>3.2. InnoDB 內存結構和磁盤結構</h2><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5f59c08371aa40509f9655c8db1f3ffe><p class=pgc-img-caption></p></div><p><strong>3.3.1.內存結構</strong></p><p>Buffer Pool 主要分為 3 個部分： Buffer Pool、Change Buffer、Adaptive Hash Index，另外還有一個（redo）log buffer。</p><p><strong>1、 Buffer Pool</strong></p><p>Buffer Pool 緩存的是頁面信息，包括數據頁、索引頁。</p><p>查看服務器狀態，裡面有很多跟 Buffer Pool 相關的信息：</p><pre><code>SHOW STATUS LIKE '%innodb_buffer_pool%';</code></pre><p>這些狀態都可以在官網查到詳細的含義，用搜索功能。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c3c5ffb823d4af68f5275c1d832f500><p class=pgc-img-caption></p></div><p>Buffer Pool 默認大小是 128M（134217728 字節），可以調整。</p><p>查看參數（系統變量）：</p><pre><code>SHOW VARIABLES like '%innodb_buffer_pool%';</code></pre><p>這些參數都可以在官網查到詳細的含義，用搜索功能。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/84ffb95d137643aa8319289e9943a757><p class=pgc-img-caption></p></div><p>內存的緩衝池寫滿了怎麼辦？（Redis 設置的內存滿了怎麼辦？）InnoDB 用 LRU算法來管理緩衝池（鏈表實現，不是傳統的 LRU，分成了 young 和 old），經過淘汰的數據就是熱點數據。</p><p>內存緩衝區對於提升讀寫性能有很大的作用。思考一個問題：</p><p>當需要更新一個數據頁時，如果數據頁在 Buffer Pool 中存在，那麼就直接更新好了。否則的話就需要從磁盤加載到內存，再對內存的數據頁進行操作。也就是說，如果沒有命中緩衝池，至少要產生一次磁盤 IO，有沒有優化的方式呢？</p><p><strong>2、 Change Buffer 寫緩衝</strong></p><p>如果這個數據頁不是唯一索引，不存在數據重複的情況，也就不需要從磁盤加載索引頁判斷數據是不是重複（唯一性檢查）。這種情況下可以先把修改記錄在內存的緩衝池中，從而提升更新語句（Insert、Delete、Update）的執行速度。</p><p>這一塊區域就是 Change Buffer。5.5 之前叫 Insert Buffer 插入緩衝，現在也能支持 delete 和 update。</p><p>最後把 Change Buffer 記錄到數據頁的操作叫做 merge。什麼時候發生 merge？有幾種情況：在訪問這個數據頁的時候，或者通過後臺線程、或者數據庫 shut down、redo log 寫滿時觸發。</p><p>如果數據庫大部分索引都是非唯一索引，並且業務是寫多讀少，不會在寫數據後立刻讀取，就可以使用 Change Buffer（寫緩衝）。寫多讀少的業務，調大這個值：</p><pre><code>SHOW VARIABLES LIKE 'innodb_change_buffer_max_size';</code></pre><p>代表 Change Buffer 佔 Buffer Pool 的比例，默認 25%。</p><p><strong>3、 Adaptive Hash Index</strong></p><p>索引應該是放在磁盤的，為什麼要專門把一種哈希的索引放到內存？好好思考。</p><p><strong>4、 （ redo） Log Buffer</strong></p><p>思考一個問題：如果 Buffer Pool 裡面的髒頁還沒有刷入磁盤時，數據庫宕機或者重啟，這些數據丟失。如果寫操作寫到一半，甚至可能會破壞數據文件導致數據庫不可用。</p><p>為了避免這個問題，InnoDB 把所有對頁面的修改操作專門寫入一個日誌文件，並且在數據庫啟動時從這個文件進行恢復操作（實現 crash-safe）——用它來實現事務的持久性。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d3b0ab69091d46fb8b9e543efb4cc483><p class=pgc-img-caption></p></div><p>這個文件就是磁盤的 redo log（叫做重做日誌），對應於/var/lib/mysql/目錄下的ib_logfile0 和 ib_logfile1，每個 48M。</p><p>這 種 日 志 和 磁 盤 配 合 的 整 個 過 程 ， 其 實 就 是 MySQL 裡 的 WAL 技 術（Write-Ahead Logging），它的關鍵點就是先寫日誌，再寫磁盤。</p><pre><code>show variables like 'innodb_log%';</code></pre><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c16aa5b390144d1e8c3ad9abd90f2b30><p class=pgc-img-caption></p></div><p>問題：</p><p>同樣是寫磁盤，為什麼不直接寫到 db file 裡面去？為什麼先寫日誌再寫磁盤？</p><p>我們先來了解一下隨機 I/O 和順序 I/O 的概念。</p><p>磁盤的最小組成單元是扇區，通常是 512 個字節。</p><p>操作系統和內存打交道，最小的單位是頁 Page。</p><p>操作系統和磁盤打交道，讀寫磁盤，最小的單位是塊 Block。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4315b38c40be4faca34faa8d11360d39><p class=pgc-img-caption></p></div><p>如果我們所需要的數據是隨機分散在不同頁的不同扇區中，那麼找到相應的數據需要等到磁臂旋轉到指定的頁，然後盤片尋找到對應的扇區，才能找到我們所需要的一塊數據，一次進行此過程直到找完所有數據，這個就是隨機 IO，讀取數據速度較慢。</p><p>假設我們已經找到了第一塊數據，並且其他所需的數據就在這一塊數據後邊，那麼就不需要重新尋址，可以依次拿到我們所需的數據，這個就叫順序 IO。</p><p>刷盤是隨機 I/O，而記錄日誌是順序 I/O，順序 I/O 效率更高。因此先把修改寫入日誌，可以延遲刷盤時機，進而提升系統吞吐。</p><p>當然 redo log 也不是每一次都直接寫入磁盤，在 Buffer Pool 裡面有一塊內存區域（Log Buffer）專門用來保存即將要寫入日誌文件的數據，默認 16M，它一樣可以節省磁盤 IO。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b59c4dd0dce49fcb6575b1a11414e0a><p class=pgc-img-caption></p></div><pre><code>SHOW VARIABLES LIKE 'innodb_log_buffer_size';</code></pre><p>需要注意：redo log 的內容主要是用於崩潰恢復。磁盤的數據文件，數據來自 buffer pool。redo log 寫入磁盤，不是寫入數據文件。</p><blockquote><p>那麼，Log Buffer 什麼時候寫入 log file？</p></blockquote><p>在我們寫入數據到磁盤的時候，操作系統本身是有緩存的。flush 就是把操作系統緩衝區寫入到磁盤。</p><p>log buffer 寫入磁盤的時機，由一個參數控制，默認是 1。</p><pre><code>SHOW VARIABLES LIKE 'innodb_flush_log_at_trx_commit';</code></pre><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be20c5999b494493ae56983db3c98d87><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/372bc0fce6834d4b93eba3319f8589c1><p class=pgc-img-caption></p></div><blockquote><p>這是內存結構的第 4 塊內容，redo log，它又分成內存和磁盤兩部分。redo log 有什麼特點？</p></blockquote><p>1、redo log 是 InnoDB 存儲引擎實現的，並不是所有存儲引擎都有。</p><p>2、不是記錄數據頁更新之後的狀態，而是記錄這個頁做了什麼改動，屬於物理日誌。</p><p>3、redo log 的大小是固定的，前面的內容會被覆蓋。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/19c84e63ddb14032af6fe679622b8e2f><p class=pgc-img-caption></p></div><p>check point 是當前要覆蓋的位置。如果 write pos 跟 check point 重疊，說明 redo log 已經寫滿，這時候需要同步 redo log 到磁盤中。</p><p>這是 MySQL 的內存結構，總結一下，分為：</p><p><strong>Buffer pool、change buffer、Adaptive Hash Index、 log buffer。</strong></p><p>磁盤結構裡面主要是各種各樣的表空間，叫做 <strong>Table space</strong>。</p><p><strong>3.3.2.磁盤結構</strong></p><p>表空間可以看做是 InnoDB 存儲引擎邏輯結構的最高層，所有的數據都存放在表空間中。InnoDB 的表空間分為 5 大類。</p><p><strong>系統表空間 system tablespace</strong></p><p>在默認情況下 InnoDB 存儲引擎有一個共享表空間（對應文件/var/lib/mysql/ibdata1），也叫系統表空間。</p><p>InnoDB 系統表空間包含 InnoDB 數據字典和雙寫緩衝區，Change Buffer 和 Undo Logs），如果沒有指定 file-per-table，也包含用戶創建的表和索引數據。</p><p>1、undo 在後面介紹，因為有獨立的表空間。</p><p>2、數據字典：由內部系統表組成，存儲表和索引的元數據（定義信息）。</p><p>3、雙寫緩衝（InnoDB 的一大特性）：</p><p>InnoDB 的頁和操作系統的頁大小不一致，InnoDB 頁大小一般為 16K，操作系統頁大小為 4K，InnoDB 的頁寫入到磁盤時，一個頁需要分 4 次寫。</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/330ccced97fd465694077ff421230128><p class=pgc-img-caption></p></div><p>如果存儲引擎正在寫入頁的數據到磁盤時發生了宕機，可能出現頁只寫了一部分的情況，比如只寫了 4K，就宕機了，這種情況叫做部分寫失效（partial page write），可能會導致數據丟失。</p><pre><code>show variables like 'innodb_doublewrite';</code></pre><p>我們不是有 redo log 嗎？但是有個問題，如果這個頁本身已經損壞了，用它來做崩潰恢復是沒有意義的。所以在對於應用 redo log 之前，需要一個頁的副本。如果出現了寫入失效，就用頁的副本來還原這個頁，然後再應用 redo log。這個頁的副本就是 double write，InnoDB 的雙寫技術。通過它實現了數據頁的可靠性。</p><p>跟 redo log 一樣，double write 由兩部分組成，一部分是內存的 double write，一個部分是磁盤上的 double write。因為 double write 是順序寫入的，不會帶來很大的開銷。</p><p>在默認情況下，所有的表共享一個系統表空間，這個文件會越來越大，而且它的空間不會收縮。</p><p><strong>獨佔表空間 file-per-table tablespaces</strong></p><p>我們可以讓每張表獨佔一個表空間。這個開關通過 innodb_file_per_table 設置，默認開啟。</p><pre><code>SHOW VARIABLES LIKE 'innodb_file_per_table';</code></pre><p>開啟後，則每張表會開闢一個表空間，這個文件就是數據目錄下的 ibd 文件（例如/var/lib/mysql/gupao/user_innodb.ibd），存放表的索引和數據。</p><p>但是其他類的數據，如回滾（undo）信息，插入緩衝索引頁、系統事務信息，二次寫緩衝（Double write buffer）等還是存放在原來的共享表空間內。</p><p><strong>通用表空間 general tablespaces</strong></p><p>通用表空間也是一種共享的表空間，跟 ibdata1 類似。</p><p>可以創建一個通用的表空間，用來存儲不同數據庫的表，數據路徑和文件可以自定義。語法：</p><pre><code>create tablespace ts2673 add datafile '/var/lib/mysql/ts2673.ibd' file_block_size=16K engine=innodb;</code></pre><p>在創建表的時候可以指定表空間，用 ALTER 修改表空間可以轉移表空間。</p><pre><code>create table t2673(id integer) tablespace ts2673;</code></pre><p>不同表空間的數據是可以移動的。</p><p>刪除表空間需要先刪除裡面的所有表：</p><pre><code>drop table t2673;drop tablespace ts2673;</code></pre><p><strong>臨時表空間 temporary tablespaces</strong></p><p>存儲臨時表的數據，包括用戶創建的臨時表，和磁盤的內部臨時表。對應數據目錄下的 ibtmp1 文件。當數據服務器正常關閉時，該表空間被刪除，下次重新產生。</p><p><strong>Redo log</strong></p><p>磁盤結構裡面的 redo log，在前面已經介紹過了。</p><p><strong>undo log tablespace</strong></p><p>undo log（撤銷日誌或回滾日誌）記錄了事務發生之前的數據狀態（不包括 select）。如果修改數據時出現異常，可以用 undo log 來實現回滾操作（保持原子性）。</p><p>在執行 undo 的時候，僅僅是將數據從邏輯上恢復至事務之前的狀態，而不是從物理頁面上操作實現的，屬於邏輯格式的日誌。</p><p>redo Log 和 undo Log 與事務密切相關，統稱為事務日誌。</p><p>undo Log 的數據默認在系統表空間 ibdata1 文件中，因為共享表空間不會自動收縮，也可以單獨創建一個 undo 表空間。</p><pre><code>show global variables like '%undo%';</code></pre><p>有了這些日誌之後，我們來總結一下一個更新操作的流程，這是一個簡化的過程。</p><p>name 原值是 javaHuang。</p><pre><code>update user set name = 'penyuyan' where id=1;</code></pre><p>1、事務開始，從內存或磁盤取到這條數據，返回給 Server 的執行器；</p><p>2、執行器修改這一行數據的值為 penyuyan；</p><p>3、記錄 name=qingshan 到 undo log；</p><p>4、記錄 name=penyuyan 到 redo log；</p><p>5、調用存儲引擎接口，在內存（Buffer Pool）中修改 name=penyuyan；</p><p>6、事務提交。</p><p>內存和磁盤之間，工作著很多後臺線程。</p><p><strong>3.3.3.後臺線程</strong></p><p>（供瞭解）</p><p>後臺線程的主要作用是負責刷新內存池中的數據和把修改的數據頁刷新到磁盤。後臺線程分為：master thread，IO thread，purge thread，page cleaner thread。</p><p>master thread 負責刷新緩存數據到磁盤並協調調度其它後臺進程。</p><p>IO thread 分為 insert buffer、log、read、write 進程。分別用來處理 insert buffer、重做日誌、讀寫請求的 IO 回調。</p><p>purge thread 用來回收 undo 頁。</p><p>page cleaner thread 用來刷新髒頁。</p><p>除了 InnoDB 架構中的日誌文件，MySQL 的 Server 層也有一個日誌文件，叫做binlog，它可以被所有的存儲引擎使用。</p><h2 class=pgc-h-arrow-right>3.3. Binlog</h2><p>binlog 以事件的形式記錄了所有的 DDL 和 DML 語句（因為它記錄的是操作而不是數據值，屬於邏輯日誌），可以用來做主從複製和數據恢復。</p><p>跟 redo log 不一樣，它的文件內容是可以追加的，沒有固定大小限制。</p><p>在開啟了 binlog 功能的情況下，我們可以把 binlog 導出成 SQL 語句，把所有的操作重放一遍，來實現數據的恢復。</p><p>binlog 的另一個功能就是用來實現主從複製，它的原理就是從服務器讀取主服務器的 binlog，然後執行一遍。</p><p>配置方式和主從複製的實現原理在後續會有專文詳解。</p><p>有了這兩個日誌之後，我們來看一下一條更新語句是怎麼執行的：</p><div class=pgc-img><img alt=《深入精通Mysql（一）》Mysql整體架構和sql執行過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/84149efc53b2495daeac38ae2eeca919><p class=pgc-img-caption></p></div><p>例如一條語句：update teacher set name='盆魚宴' where id=1;</p><p>1、先查詢到這條數據，如果有緩存，也會用到緩存。</p><p>2、把 name 改成盆魚宴，然後調用引擎的 API 接口，寫入這一行數據到內存，同時記錄 redo log。這時 redo log 進入 prepare 狀態，然後告訴執行器，執行完成了，可以隨時提交。</p><p>3、執行器收到通知後記錄 binlog，然後調用存儲引擎接口，設置 redo log為 commit狀態。</p><p>4、更新完成。</p><p><strong>這張圖片的重點：</strong></p><p>1、先記錄到內存，再寫日誌文件。</p><p>2、記錄 redo log 分為兩個階段。</p><p>3、存儲引擎和 Server 記錄不同的日誌。</p><p>4、先記錄 redo，再記錄 binlog。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Mysql</a></li><li><a>整體</a></li><li><a>架構</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html alt=Kafka整體架構圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/05ae540358854cb3ba0aa4577709330d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html title=Kafka整體架構圖解>Kafka整體架構圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html alt=MyBatis整體架構分析：基礎支持層、核心處理層和接口層 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d6a0b300b114d07b2f3fe66d7ef7005 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html title=MyBatis整體架構分析：基礎支持層、核心處理層和接口層>MyBatis整體架構分析：基礎支持層、核心處理層和接口層</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html alt=K8S整體架構解析，簡單明瞭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/37380f3294a54bbf8c6bec1de3e08ba0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html title=K8S整體架構解析，簡單明瞭>K8S整體架構解析，簡單明瞭</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html alt=支付系統：整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1d94fa40459462fa825d407a1904c7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html title=支付系統：整體架構>支付系統：整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2123c3c.html alt=橋樑蓋樑計算“整體圖式法”不明白？這篇詳解能幫你！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15380322769483d1101ea07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2123c3c.html title=橋樑蓋樑計算“整體圖式法”不明白？這篇詳解能幫你！>橋樑蓋樑計算“整體圖式法”不明白？這篇詳解能幫你！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05253828.html alt=泉州酒店坍塌事故分析：結構如何從局部失穩到整體失穩？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c6578f894a647f7abbfeb9d80c550da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05253828.html title=泉州酒店坍塌事故分析：結構如何從局部失穩到整體失穩？>泉州酒店坍塌事故分析：結構如何從局部失穩到整體失穩？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html alt=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0670cbc9828449c782ac323a238b99e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html title=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效>朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42a7eb8a.html alt=“整體驅動橋殼體”有望國內率先量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RAZAR125NY4yo4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42a7eb8a.html title=“整體驅動橋殼體”有望國內率先量產>“整體驅動橋殼體”有望國內率先量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html alt=Mysql事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html title=Mysql事務>Mysql事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html alt=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/470f515e8fe44c6184b07227fdb51333 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html title=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）>《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbb4fd63.html alt="Mysql --09 Innodb核心特性——事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/47618d6931fd4518a4d78c0e13623b98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbb4fd63.html title="Mysql --09 Innodb核心特性——事務">Mysql --09 Innodb核心特性——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b55df2d7.html alt=【看點】整體技術達到國際先進水平——青島海佳HW-8010型高速高密噴水織機通過科技成果鑑定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RDVYAVcGehzkiX style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b55df2d7.html title=【看點】整體技術達到國際先進水平——青島海佳HW-8010型高速高密噴水織機通過科技成果鑑定>【看點】整體技術達到國際先進水平——青島海佳HW-8010型高速高密噴水織機通過科技成果鑑定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html alt=活動文件櫃的架構是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/104d3629a97947b19d62b03dc3b8d82f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html title=活動文件櫃的架構是什麼>活動文件櫃的架構是什麼</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>