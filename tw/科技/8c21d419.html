<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入理解 Java 併發核心機制，看完後好爽 | 极客快訊</title><meta property="og:title" content="深入理解 Java 併發核心機制，看完後好爽 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c21d419.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c21d419.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8c21d419.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c21d419.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c21d419.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8c21d419.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8c21d419.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c21d419.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="深入理解 Java 併發核心機制，看完後好爽"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8c21d419.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入理解 Java 併發核心機制，看完後好爽</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>點擊上方☝Java編程技術樂園，輕鬆關注！及時獲取有趣有料的技術文章</p><h2 class=pgc-h-arrow-right><br></h2><h2 class=pgc-h-arrow-right>一、J.U.C 簡介</h2><p>Java 的 java.util.concurrent 包（簡稱 J.U.C）中提供了大量併發工具類，是 Java 併發能力的主要體現（注意，不是全部，有部分併發能力的支持在其他包中）。從功能上，大致可以分為：</p><ul class=list-paddingleft-2><li>原子類 - 如：AtomicInteger、AtomicIntegerArray、AtomicReference、AtomicStampedReference 等。</li><li>鎖 - 如：ReentrantLock、ReentrantReadWriteLock 等。</li><li>併發容器 - 如：ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet 等。</li><li>阻塞隊列 - 如：ArrayBlockingQueue、LinkedBlockingQueue 等。</li><li>非阻塞隊列 - 如： ConcurrentLinkedQueue 、LinkedTransferQueue 等。</li><li>Executor 框架（線程池）- 如：ThreadPoolExecutor、Executors 等。</li></ul><p>我個人理解，Java 併發框架可以分為以下層次。</p><div class=pgc-img><img alt="深入理解 Java 併發核心機制，看完後好爽" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862><p class=pgc-img-caption></p></div><p>由 Java 併發框架圖不難看出，J.U.C 包中的工具類是基於 synchronized、volatile、CAS、ThreadLocal 這樣的併發核心機制打造的。所以，要想深入理解 J.U.C 工具類的特性、為什麼具有這樣那樣的特性，就必須先理解這些核心機制。</p><h2 class=pgc-h-arrow-right>二、synchronized</h2><blockquote><p>synchronized 是 Java 中的關鍵字，是 <strong>利用鎖的機制來實現互斥同步的</strong>。</p><p><strong>synchronized 可以保證在同一個時刻，只有一個線程可以執行某個方法或者某個代碼塊</strong>。</p><p>如果不需要 Lock 、ReadWriteLock 所提供的高級同步特性，應該優先考慮使用 synchronized ，理由如下：</p><p>Java 1.6 以後，synchronized 做了大量的優化，其性能已經與 Lock 、ReadWriteLock 基本上持平。從趨勢來看，Java 未來仍將繼續優化 synchronized ，而不是 ReentrantLock 。</p><p>ReentrantLock 是 Oracle JDK 的 API，在其他版本的 JDK 中不一定支持；而 synchronized 是 JVM 的內置特性，所有 JDK 版本都提供支持。</p></blockquote><h3 class=pgc-h-arrow-right>synchronized 的用法</h3><p>synchronized 有 3 種應用方式：</p><ul class=list-paddingleft-2><li><strong>同步實例方法</strong> - 對於普通同步方法，鎖是當前實例對象</li><li><strong>同步靜態方法</strong> - 對於靜態同步方法，鎖是當前類的 Class 對象</li><li><strong>同步代碼塊</strong> - 對於同步方法塊，鎖是 synchonized 括號裡配置的對象</li></ul><blockquote><p>說明：</p><p>類似 Vector、Hashtable 這類同步類，就是使用 synchonized 修飾其重要方法，來保證其線程安全。</p><p>事實上，這類同步容器也非絕對的線程安全，當執行迭代器遍歷，根據條件刪除元素這種場景下，就可能出現線程不安全的情況。此外，Java 1.6 針對 synchonized 進行優化前，由於阻塞，其性能不高。</p><p>綜上，這類同步容器，在現代 Java 程序中，已經漸漸不用了。</p></blockquote><h4 class=pgc-h-arrow-right>同步實例方法</h4><p>❌ 錯誤示例 - 未同步的示例</p><pre><code>public class NoSynchronizedDemo implements Runnable {    public static final int MAX = 100000;    private static int count = 0;    public static void main(String[] args) throws InterruptedException {        NoSynchronizedDemo instance = new NoSynchronizedDemo();        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    }    @Override    public void run() {        for (int i = 0; i &lt; MAX; i++) {            increase();        }    }    public void increase() {        count++;    }}// 輸出結果: 小於 200000 的隨機數字</code></pre><p>Java 實例方法同步是同步在擁有該方法的對象上。這樣，每個實例其方法同步都同步在不同的對象上，即該方法所屬的實例。只有一個線程能夠在實例方法同步塊中運行。如果有多個實例存在，那麼一個線程一次可以在一個實例同步塊中執行操作。一個實例一個線程。</p><pre><code>public class SynchronizedDemo implements Runnable {    private static final int MAX = 100000;    private static int count = 0;    public static void main(String[] args) throws InterruptedException {        SynchronizedDemo instance = new SynchronizedDemo();        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    }    @Override    public void run() {        for (int i = 0; i &lt; MAX; i++) {            increase();        }    }    /**     * synchronized 修飾普通方法     */    public synchronized void increase() {        count++;    }}</code></pre><h4 class=pgc-h-arrow-right>同步靜態方法</h4><p>靜態方法的同步是指同步在該方法所在的類對象上。因為在 JVM 中一個類只能對應一個類對象，所以同時只允許一個線程執行同一個類中的靜態同步方法。</p><p>對於不同類中的靜態同步方法，一個線程可以執行每個類中的靜態同步方法而無需等待。不管類中的那個靜態同步方法被調用，一個類只能由一個線程同時執行。</p><pre><code>public class SynchronizedDemo2 implements Runnable {    private static final int MAX = 100000;    private static int count = 0;    public static void main(String[] args) throws InterruptedException {        SynchronizedDemo2 instance = new SynchronizedDemo2();        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    }    @Override    public void run() {        for (int i = 0; i &lt; MAX; i++) {            increase();        }    }    /**     * synchronized 修飾靜態方法     */    public synchronized static void increase() {        count++;    }}</code></pre><h4 class=pgc-h-arrow-right>同步代碼塊</h4><p>有時你不需要同步整個方法，而是同步方法中的一部分。Java 可以對方法的一部分進行同步。</p><p>注意 Java 同步塊構造器用括號將對象括起來。在上例中，使用了 this，即為調用 add 方法的實例本身。在同步構造器中用括號括起來的對象叫做監視器對象。上述代碼使用監視器對象同步，同步實例方法使用調用方法本身的實例作為監視器對象。</p><p>一次只有一個線程能夠在同步於同一個監視器對象的 Java 方法內執行。</p><pre><code>public class SynchronizedDemo3 implements Runnable {    private static final int MAX = 100000;    private static int count = 0;    public static void main(String[] args) throws InterruptedException {        SynchronizedDemo3 instance = new SynchronizedDemo3();        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        t1.join();        t2.join();        System.out.println(count);    }    @Override    public void run() {        for (int i = 0; i &lt; MAX; i++) {            increase();        }    }    /**     * synchronized 修飾代碼塊     */    public static void increase() {        synchronized (SynchronizedDemo3.class) {            count++;        }    }}</code></pre><h3 class=pgc-h-arrow-right>synchronized 的原理</h3><p>synchronized 經過編譯後，會在同步塊的前後分別形成 monitorenter 和 monitorexit 這兩個字節碼指令，這兩個字節碼指令都需要一個引用類型的參數來指明要鎖定和解鎖的對象。如果 synchronized 明確制定了對象參數，那就是這個對象的引用；如果沒有明確指定，那就根據 synchronized 修飾的是實例方法還是靜態方法，去對對應的對象實例或 Class 對象來作為鎖對象。</p><p>synchronized 同步塊對同一線程來說是可重入的，不會出現鎖死問題。</p><p>synchronized 同步塊是互斥的，即已進入的線程執行完成前，會阻塞其他試圖進入的線程。</p><h4 class=pgc-h-arrow-right>鎖的機制</h4><p>鎖具備以下兩種特性：</p><ul class=list-paddingleft-2><li><strong>互斥性</strong>：即在同一時間只允許一個線程持有某個對象鎖，通過這種特性來實現多線程中的協調機制，這樣在同一時間只有一個線程對需同步的代碼塊(複合操作)進行訪問。互斥性我們也往往稱為操作的原子性。</li><li><strong>可見性</strong>：必須確保在鎖被釋放之前，對共享變量所做的修改，對於隨後獲得該鎖的另一個線程是可見的（即在獲得鎖時應獲得最新共享變量的值），否則另一個線程可能是在本地緩存的某個副本上繼續操作從而引起不一致。</li></ul><h4 class=pgc-h-arrow-right>鎖類型</h4><ul class=list-paddingleft-2><li><strong>對象鎖</strong> - 在 Java 中，每個對象都會有一個 monitor 對象，這個對象其實就是 Java 對象的鎖，通常會被稱為“內置鎖”或“對象鎖”。類的對象可以有多個，所以每個對象有其獨立的對象鎖，互不干擾。</li><li><strong>類鎖</strong> - 在 Java 中，針對每個類也有一個鎖，可以稱為“類鎖”，類鎖實際上是通過對象鎖實現的，即類的 Class 對象鎖。每個類只有一個 Class 對象，所以每個類只有一個類鎖。</li></ul><h3 class=pgc-h-arrow-right>synchronized 的優化</h3><blockquote><p>Java 1.6 以後，synchronized 做了大量的優化，其性能已經與 Lock 、ReadWriteLock 基本上持平。</p></blockquote><h4 class=pgc-h-arrow-right>自旋鎖</h4><p>互斥同步進入阻塞狀態的開銷都很大，應該儘量避免。在許多應用中，共享數據的鎖定狀態只會持續很短的一段時間。自旋鎖的思想是讓一個線程在請求一個共享數據的鎖時執行忙循環（自旋）一段時間，如果在這段時間內能獲得鎖，就可以避免進入阻塞狀態。</p><p>自旋鎖雖然能避免進入阻塞狀態從而減少開銷，但是它需要進行忙循環操作佔用 CPU 時間，它只適用於共享數據的鎖定狀態很短的場景。</p><p>在 Java 1.6 中引入了自適應的自旋鎖。自適應意味著自旋的次數不再固定了，而是由前一次在同一個鎖上的自旋次數及鎖的擁有者的狀態來決定。</p><h4 class=pgc-h-arrow-right>鎖消除</h4><p><strong>鎖消除是指對於被檢測出不可能存在競爭的共享數據的鎖進行消除</strong>。</p><p>鎖消除主要是通過逃逸分析來支持，如果堆上的共享數據不可能逃逸出去被其它線程訪問到，那麼就可以把它們當成私有數據對待，也就可以將它們的鎖進行消除。</p><p>對於一些看起來沒有加鎖的代碼，其實隱式的加了很多鎖。例如下面的字符串拼接代碼就隱式加了鎖：</p><pre><code>public static String concatString(String s1, String s2, String s3) {    return s1 + s2 + s3;}</code></pre><p>String 是一個不可變的類，編譯器會對 String 的拼接自動優化。在 Java 1.5 之前，會轉化為 StringBuffer 對象的連續 append() 操作：</p><pre><code>public static String concatString(String s1, String s2, String s3) {    StringBuffer sb = new StringBuffer();    sb.append(s1);    sb.append(s2);    sb.append(s3);    return sb.toString();}</code></pre><p><br></p><p>每個 append() 方法中都有一個同步塊。虛擬機觀察變量 sb，很快就會發現它的動態作用域被限制在 concatString() 方法內部。也就是說，sb 的所有引用永遠不會逃逸到 concatString() 方法之外，其他線程無法訪問到它，因此可以進行消除。</p><h4 class=pgc-h-arrow-right>鎖粗化</h4><p>如果<strong>一系列的連續操作都對同一個對象反覆加鎖和解鎖</strong>，頻繁的加鎖操作就會導致性能損耗。</p><p>上一節的示例代碼中連續的 append() 方法就屬於這類情況。如果<strong>虛擬機探測到由這樣的一串零碎的操作都對同一個對象加鎖，將會把加鎖的範圍擴展（粗化）到整個操作序列的外部</strong>。對於上一節的示例代碼就是擴展到第一個 append() 操作之前直至最後一個 append() 操作之後，這樣只需要加鎖一次就可以了。</p><h4 class=pgc-h-arrow-right>輕量級鎖</h4><p>Java 1.6 引入了偏向鎖和輕量級鎖，從而讓鎖擁有了四個狀態：</p><ul class=list-paddingleft-2><li><strong>無鎖狀態（unlocked）</strong></li><li><strong>偏向鎖狀態（biasble）</strong></li><li><strong>輕量級鎖狀態（lightweight locked）</strong></li><li><strong>重量級鎖狀態（inflated）</strong></li></ul><p><strong>輕量級鎖</strong>是相對於傳統的重量級鎖而言，它 <strong>使用 CAS 操作來避免重量級鎖使用互斥量的開銷</strong>。對於絕大部分的鎖，在整個同步週期內都是不存在競爭的，因此也就不需要都使用互斥量進行同步，可以先採用 CAS 操作進行同步，如果 CAS 失敗了再改用互斥量進行同步。</p><p>當嘗試獲取一個鎖對象時，如果鎖對象標記為 0 01，說明鎖對象的鎖未鎖定（unlocked）狀態。此時虛擬機在當前線程的虛擬機棧中創建 Lock Record，然後使用 CAS 操作將對象的 Mark Word 更新為 Lock Record 指針。如果 CAS 操作成功了，那麼線程就獲取了該對象上的鎖，並且對象的 Mark Word 的鎖標記變為 00，表示該對象處於輕量級鎖狀態。</p><h4 class=pgc-h-arrow-right>偏向鎖</h4><p>偏向鎖的思想是偏向於<strong>讓第一個獲取鎖對象的線程，這個線程在之後獲取該鎖就不再需要進行同步操作，甚至連 CAS 操作也不再需要</strong>。</p><h2 class=pgc-h-arrow-right>三、volatile</h2><h3 class=pgc-h-arrow-right>volatile 的要點</h3><p>volatile 是輕量級的 synchronized，它在多處理器開發中保證了共享變量的“可見性”。</p><p>可見性的意思是當一個線程修改一個共享變量時，另外一個線程能讀到這個修改的值。</p><p>一旦一個共享變量（類的成員變量、類的靜態成員變量）被 volatile 修飾之後，那麼就具備了兩層語義：</p><ol start=1><li>保證了不同線程對這個變量進行操作時的可見性，即一個線程修改了某個變量的值，這新值對其他線程來說是立即可見的。</li><li>禁止進行指令重排序。</li></ol><p>如果一個字段被聲明成 volatile，Java 線程內存模型確保所有線程看到這個變量的值是一致的。</p><h3 class=pgc-h-arrow-right>volatile 的用法</h3><p>如果 volatile 變量修飾符使用恰當的話，它比 synchronized 的使用和執行成本更低，因為它不會引起線程上下文的切換和調度。但是，volatile 無法替代 synchronized ，因為 volatile 無法保證操作的原子性。</p><p>通常來說，<strong>使用 volatile 必須具備以下 2 個條件</strong>：</p><ul class=list-paddingleft-2><li>對變量的寫操作不依賴於當前值</li><li>該變量沒有包含在具有其他變量的不變式中</li></ul><p>示例：狀態標記量</p><pre><code>volatile boolean flag = false;while(!flag) {    doSomething();}public void setFlag() {    flag = true;}</code></pre><p>示例：雙重鎖實現線程安全的單例類</p><pre><code>class Singleton {    private volatile static Singleton instance = null;    private Singleton() {}    public static Singleton getInstance() {        if(instance==null) {            synchronized (Singleton.class) {                if(instance==null)                    instance = new Singleton();            }        }        return instance;    }}</code></pre><h3 class=pgc-h-arrow-right>volatile 的原理</h3><p>觀察加入 volatile 關鍵字和沒有加入 volatile 關鍵字時所生成的彙編代碼發現，<strong>加入 volatile 關鍵字時，會多出一個 lock 前綴指令</strong>。</p><p><strong>lock 前綴指令實際上相當於一個內存屏障</strong>（也成內存柵欄），內存屏障會提供 3 個功能：</p><ul class=list-paddingleft-2><li>它確保指令重排序時不會把其後面的指令排到內存屏障之前的位置，也不會把前面的指令排到內存屏障的後面；即在執行到內存屏障這句指令時，在它前面的操作已經全部完成；</li><li>它會強制將對緩存的修改操作立即寫入主存；</li><li>如果是寫操作，它會導致其他 CPU 中對應的緩存行無效。</li></ul><h2 class=pgc-h-arrow-right>四、CAS</h2><h3 class=pgc-h-arrow-right>CAS 的要點</h3><p>互斥同步是最常見的併發正確性保障手段。</p><p><strong>互斥同步最主要的問題是線程阻塞和喚醒所帶來的性能問題</strong>，因此互斥同步也被稱為阻塞同步。互斥同步屬於一種悲觀的併發策略，總是認為只要不去做正確的同步措施，那就肯定會出現問題。無論共享數據是否真的會出現競爭，它都要進行加鎖（這裡討論的是概念模型，實際上虛擬機會優化掉很大一部分不必要的加鎖）、用戶態核心態轉換、維護鎖計數器和檢查是否有被阻塞的線程需要喚醒等操作。</p><p>隨著硬件指令集的發展，我們可以使用基於衝突檢測的樂觀併發策略：先進行操作，如果沒有其它線程爭用共享數據，那操作就成功了，否則採取補償措施（不斷地重試，直到成功為止）。這種樂觀的併發策略的許多實現都不需要將線程阻塞，因此這種同步操作稱為非阻塞同步。</p><p>為什麼說樂觀鎖需要 <strong>硬件指令集的發展</strong> 才能進行？因為需要操作和衝突檢測這兩個步驟具備原子性。而這點是由硬件來完成，如果再使用互斥同步來保證就失去意義了。硬件支持的原子性操作最典型的是：CAS。</p><p><strong>CAS（Compare and Swap）</strong>，字面意思為<strong>比較並交換</strong>。CAS 有 3 個操作數，分別是：內存值 V，舊的預期值 A，要修改的新值 B。當且僅當預期值 A 和內存值 V 相同時，將內存值 V 修改為 B，否則什麼都不做。</p><h3 class=pgc-h-arrow-right>CAS 的原理</h3><p>Java 是如何實現 CAS ?</p><p>Java 主要利用 Unsafe 這個類提供的 CAS 操作。</p><p>Unsafe 的 CAS 依賴的是 JV M 針對不同的操作系統實現的 Atomic::cmpxchg 指令。</p><p>Atomic::cmpxchg 的實現使用了彙編的 CAS 操作，並使用 CPU 提供的 lock 信號保證其原子性。</p><h3 class=pgc-h-arrow-right>CAS 的應用</h3><h4 class=pgc-h-arrow-right>原子類</h4><blockquote><p>原子類是 CAS 在 Java 中最典型的應用。</p></blockquote><p>我們先來看一個常見的代碼片段。</p><pre><code>if(a==b) {    a++;}</code></pre><p>如果 a++ 執行前， a 的值被修改了怎麼辦？還能得到預期值嗎？出現該問題的原因是在併發環境下，以上代碼片段不是原子操作，隨時可能被其他線程所篡改。</p><p>解決這種問題的最經典方式是應用原子類的 incrementAndGet 方法。</p><pre><code>public class AtomicIntegerDemo {    public static void main(String[] args) throws InterruptedException {        ExecutorService executorService = Executors.newFixedThreadPool(3);        final AtomicInteger count = new AtomicInteger(0);        for (int i = 0; i &lt; 10; i++) {            executorService.execute(new Runnable() {                @Override                public void run() {                    count.incrementAndGet();                }            });        }        executorService.shutdown();        executorService.awaitTermination(3, TimeUnit.SECONDS);        System.out.println("Final Count is : " + count.get());    }}</code></pre><p>J.U.C 包中提供了 AtomicBoolean、AtomicInteger、AtomicLong 分別針對 Boolean、Integer、Long 執行原子操作，操作和上面的示例大體相似，不做贅述。</p><h4 class=pgc-h-arrow-right>自旋鎖</h4><p>利用原子類（本質上是 CAS），可以實現自旋鎖。</p><p>所謂自旋鎖，是指線程反覆檢查鎖變量是否可用，直到成功為止。由於線程在這一過程中保持執行，因此是一種忙等待。一旦獲取了自旋鎖，線程會一直保持該鎖，直至顯式釋放自旋鎖。</p><p>示例：非線程安全示例</p><pre><code>public class AtomicReferenceDemo {    private static int ticket = 10;    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 5; i++) {            executorService.execute(new MyThread());        }        executorService.shutdown();    }    static class MyThread implements Runnable {        @Override        public void run() {            while (ticket &gt; 0) {                System.out.println(Thread.currentThread().getName() + " 賣出了第 " + ticket + " 張票");                ticket--;            }        }    }}</code></pre><p>輸出結果：</p><pre><code>pool-1-thread-2 賣出了第 10 張票pool-1-thread-1 賣出了第 10 張票pool-1-thread-3 賣出了第 10 張票pool-1-thread-1 賣出了第 8 張票pool-1-thread-2 賣出了第 9 張票pool-1-thread-1 賣出了第 6 張票pool-1-thread-3 賣出了第 7 張票pool-1-thread-1 賣出了第 4 張票pool-1-thread-2 賣出了第 5 張票pool-1-thread-1 賣出了第 2 張票pool-1-thread-3 賣出了第 3 張票pool-1-thread-2 賣出了第 1 張票</code></pre><p>很明顯，出現了重複售票的情況。</p><p>示例：使用自旋鎖來保證線程安全</p><p>可以通過自旋鎖這種非阻塞同步來保證線程安全，下面使用 AtomicReference 來實現一個自旋鎖。</p><pre><code>public class AtomicReferenceDemo2 {    private static int ticket = 10;    public static void main(String[] args) {        threadSafeDemo();    }    private static void threadSafeDemo() {        SpinLock lock = new SpinLock();        ExecutorService executorService = Executors.newFixedThreadPool(3);        for (int i = 0; i &lt; 5; i++) {            executorService.execute(new MyThread(lock));        }        executorService.shutdown();    }    static class SpinLock {        private AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();        public void lock() {            Thread current = Thread.currentThread();            while (!atomicReference.compareAndSet(null, current)) {}        }        public void unlock() {            Thread current = Thread.currentThread();            atomicReference.compareAndSet(current, null);        }    }    static class MyThread implements Runnable {        private SpinLock lock;        public MyThread(SpinLock lock) {            this.lock = lock;        }        @Override        public void run() {            while (ticket &gt; 0) {                lock.lock();                if (ticket &gt; 0) {                    System.out.println(Thread.currentThread().getName() + " 賣出了第 " + ticket + " 張票");                    ticket--;                }                lock.unlock();            }        }    }}</code></pre><p>輸出結果：</p><pre><code>pool-1-thread-2 賣出了第 10 張票pool-1-thread-1 賣出了第 9 張票pool-1-thread-3 賣出了第 8 張票pool-1-thread-2 賣出了第 7 張票pool-1-thread-3 賣出了第 6 張票pool-1-thread-1 賣出了第 5 張票pool-1-thread-2 賣出了第 4 張票pool-1-thread-1 賣出了第 3 張票pool-1-thread-3 賣出了第 2 張票pool-1-thread-1 賣出了第 1 張票</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right>CAS 的問題</h3><p>一般情況下，CAS 比鎖性能更高。因為 CAS 是一種非阻塞算法，所以其避免了線程阻塞和喚醒的等待時間。</p><p>但是，CAS 也有一些問題。</p><h4 class=pgc-h-arrow-right>ABA 問題</h4><p>如果一個變量初次讀取的時候是 A 值，它的值被改成了 B，後來又被改回為 A，那 CAS 操作就會誤認為它從來沒有被改變過。</p><p>J.U.C 包提供了一個帶有標記的原子引用類 AtomicStampedReference 來解決這個問題，它可以通過控制變量值的版本來保證 CAS 的正確性。大部分情況下 ABA 問題不會影響程序併發的正確性，如果需要解決 ABA 問題，改用傳統的互斥同步可能會比原子類更高效。</p><h4 class=pgc-h-arrow-right>循環時間長開銷大</h4><p>自旋 CAS （不斷嘗試，直到成功為止）如果長時間不成功，會給 CPU 帶來非常大的執行開銷。</p><p>如果 JVM 能支持處理器提供的 pause 指令那麼效率會有一定的提升，pause 指令有兩個作用：</p><ul class=list-paddingleft-2><li>它可以延遲流水線執行指令（de-pipeline）,使 CPU 不會消耗過多的執行資源，延遲的時間取決於具體實現的版本，在一些處理器上延遲時間是零。</li><li>它可以避免在退出循環的時候因內存順序衝突（memory order violation）而引起 CPU 流水線被清空（CPU pipeline flush），從而提高 CPU 的執行效率。</li></ul><p>比較花費 CPU 資源，即使沒有任何用也會做一些無用功。</p><h4 class=pgc-h-arrow-right>只能保證一個共享變量的原子性</h4><p>當對一個共享變量執行操作時，我們可以使用循環 CAS 的方式來保證原子操作，但是對多個共享變量操作時，循環 CAS 就無法保證操作的原子性，這個時候就可以用鎖。</p><p>或者有一個取巧的辦法，就是把多個共享變量合併成一個共享變量來操作。比如有兩個共享變量 i ＝ 2, j = a，合併一下 ij=2a，然後用 CAS 來操作 ij。從 Java 1.5 開始 JDK 提供了 AtomicReference 類來保證引用對象之間的原子性，你可以把多個變量放在一個對象裡來進行 CAS 操作。</p><h2 class=pgc-h-arrow-right>五、ThreadLocal</h2><blockquote><p><strong>ThreadLocal 是一個存儲線程本地副本的工具類</strong>。</p><p>要保證線程安全，不一定非要進行同步。同步只是保證共享數據爭用時的正確性，如果一個方法本來就不涉及共享數據，那麼自然無須同步。</p><p>Java 中的 <strong>無同步方案</strong> 有：</p><p><strong>可重入代碼</strong> - 也叫純代碼。如果一個方法，它的 <strong>返回結果是可以預測的</strong>，即只要輸入了相同的數據，就能返回相同的結果，那它就滿足可重入性，當然也是線程安全的。</p><p><strong>線程本地存儲</strong> - 使用 <strong>ThreadLocal 為共享變量在每個線程中都創建了一個本地副本</strong>，這個副本只能被當前線程訪問，其他線程無法訪問，那麼自然是線程安全的。</p></blockquote><h3 class=pgc-h-arrow-right>ThreadLocal 的用法</h3><p>ThreadLocal 的方法：</p><pre><code>public class ThreadLocal&lt;T&gt; {    public T get() {}    public void set(T value) {}    public void remove() {}    public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {}}</code></pre><blockquote><p>說明：</p><p>get - 用於獲取 ThreadLocal 在當前線程中保存的變量副本。</p><p>set - 用於設置當前線程中變量的副本。</p><p>remove - 用於刪除當前線程中變量的副本。如果此線程局部變量隨後被當前線程讀取，則其值將通過調用其 initialValue 方法重新初始化，除非其值由中間線程中的當前線程設置。這可能會導致當前線程中多次調用 initialValue 方法。</p><p>initialValue - 為 ThreadLocal 設置默認的 get 初始值，需要重寫 initialValue 方法 。</p></blockquote><p>ThreadLocal 常用於防止對可變的單例（Singleton）變量或全局變量進行共享。典型應用場景有：管理數據庫連接、Session。</p><p>示例 - 數據庫連接</p><pre><code>private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() {    @Override    public Connection initialValue() {        return DriverManager.getConnection(DB_URL);    }};public static Connection getConnection() {    return connectionHolder.get();}</code></pre><p>示例 - Session 管理</p><pre><code>private static final ThreadLocal&lt;Session&gt; sessionHolder = new ThreadLocal&lt;&gt;();public static Session getSession() {    Session session = (Session) sessionHolder.get();    try {        if (session == null) {            session = createSession();            sessionHolder.set(session);        }    } catch (Exception e) {        e.printStackTrace();    }    return session;}</code></pre><p>示例 - 完整使用示例</p><pre><code>public class ThreadLocalDemo {    private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;() {        @Override        protected Integer initialValue() {            return 0;        }    };    public static void main(String[] args) {        ExecutorService executorService = Executors.newFixedThreadPool(10);        for (int i = 0; i &lt; 10; i++) {            executorService.execute(new MyThread());        }        executorService.shutdown();    }    static class MyThread implements Runnable {        @Override        public void run() {            int count = threadLocal.get();            for (int i = 0; i &lt; 10; i++) {                try {                    count++;                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            threadLocal.set(count);            threadLocal.remove();            System.out.println(Thread.currentThread().getName() + " : " + count);        }    }}</code></pre><p>全部輸出 count = 10</p><h3 class=pgc-h-arrow-right>ThreadLocal 的原理</h3><h4 class=pgc-h-arrow-right>存儲結構</h4><p>Thread 類中維護著一個 ThreadLocal.ThreadLocalMap 類型的成員 threadLocals。這個成員就是用來存儲線程獨佔的變量副本。</p><p>ThreadLocalMap 是 ThreadLocal 的內部類，它維護著一個 Entry 數組， Entry 用於保存鍵值對，其 key 是 ThreadLocal 對象，value 是傳遞進來的對象（變量副本）。</p><h4 class=pgc-h-arrow-right>如何解決 Hash 衝突</h4><p>ThreadLocalMap 雖然是類似 Map 結構的數據結構，但它並沒有實現 Map 接口。它不支持 Map 接口中的 next 方法，這意味著 ThreadLocalMap 中解決 Hash 衝突的方式並非 <strong>拉鍊表</strong> 方式。</p><p>實際上，<strong>ThreadLocalMap 採用線性探測的方式來解決 Hash 衝突</strong>。所謂線性探測，就是根據初始 key 的 hashcode 值確定元素在 table 數組中的位置，如果發現這個位置上已經被其他的 key 值佔用，則利用固定的算法尋找一定步長的下個位置，依次判斷，直至找到能夠存放的位置。</p><h4 class=pgc-h-arrow-right>內存洩漏問題</h4><p>ThreadLocalMap 的 Entry 繼承了 WeakReference，所以它的 key （ThreadLocal 對象）是弱引用，而 value （變量副本）是強引用。</p><ul class=list-paddingleft-2><li>如果 ThreadLocal 對象沒有外部強引用來引用它，那麼 ThreadLocal 對象會在下次 GC 時被回收。</li><li>此時，Entry 中的 key 已經被回收，但是 value 由於是強引用不會被垃圾收集器回收。如果創建 ThreadLocal 的線程一直持續運行，那麼 value 就會一直得不到回收，產生內存洩露。</li></ul><p>那麼如何避免內存洩漏呢？方法就是：<strong>使用 ThreadLocal 的 set 方法後，顯示的調用 remove 方法</strong> 。</p><pre><code>ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal();try {    threadLocal.set("xxx");    // ...} finally {    threadLocal.remove();}</code></pre><h2 class=pgc-h-arrow-right>參考資料</h2><ul class=list-paddingleft-2><li>《Java 併發編程實戰》</li><li>《Java 併發編程的藝術》</li><li>《深入理解 Java 虛擬機》</li><li>Java 併發編程：volatile 關鍵字解析</li><li>Java 併發編程：synchronized</li><li>深入理解 Java 併發之 synchronized 實現原理</li><li>Java CAS 完全解讀</li><li>Java 中 CAS 詳解</li><li>ThreadLocal 終極篇</li><li>synchronized 實現原理及鎖優化</li><li>Non-blocking Algorithms</li></ul><blockquote><p>原文地址：https://dwz.cn/gteUEku0</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>好爽</a></li><li><a>Java</a></li><li><a>機制</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ba13aa.html alt=深度分析：理解Java中的多態機制，一篇直接幫你掌握 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/8a2dcdde-0235-4f88-aac0-d3a45f6d83d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ba13aa.html title=深度分析：理解Java中的多態機制，一篇直接幫你掌握>深度分析：理解Java中的多態機制，一篇直接幫你掌握</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html alt=事務機制和鎖機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5a547c8c402142cca7ed81d05fe0e3e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html title=事務機制和鎖機制>事務機制和鎖機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html alt=連mysql鎖的機制都不瞭解，怎麼做架構師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html title=連mysql鎖的機制都不瞭解，怎麼做架構師>連mysql鎖的機制都不瞭解，怎麼做架構師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>