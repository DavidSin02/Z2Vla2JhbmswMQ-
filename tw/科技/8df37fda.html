<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>新手編程導論（九） | 极客快訊</title><meta property="og:title" content="新手編程導論（九） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/0bf11efddc9d41d1908a368d1c11824c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8df37fda.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8df37fda.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8df37fda.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8df37fda.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8df37fda.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8df37fda.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8df37fda.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8df37fda.html><meta property="article:published_time" content="2020-10-29T21:10:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:38+08:00"><meta name=Keywords content><meta name=description content="新手編程導論（九）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8df37fda.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>新手編程導論（九）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>第8章 抽象之設計和領域邏輯<br>8.1 大設計</strong>範意上的設計是廣泛的,不僅限於計算機的,也不限於軟工抽象,軟件的設計哲學是可以用來解釋一切的,因為它是真正的哲學,而真正的哲學並不僅適用軟件開發(軟工和計算機是二個完全不同的抽象,雖然沒有人提出過計算機抽象到底是什麼,軟工抽象到底裡面有哪些抽象存在,我們僅能站在某個或某些維度上給出一個描述性的概念而不是有限集,這也就夠了,如果能站在一個大全的維度上說明到軟工的全部抽象,雖然這是不可能的,但我們還是給得出的這個結果取個名字,叫範式,範式在意義上是大全而的抽象,然而人類的範式總表現為某些維度上的產物(只是我們在一本無論多麼長的書裡都寫不完而已,如果有那麼一種生命力和那麼一本書存在,我們也堅信任何一個道理都不可能寫完)。<br>設計並不僅僅面向於創新,有時是形式的重組,而不是內容的創新,應用形式的改觀,設計出的產品,要源端是面向人的,因此要提供足夠簡單的使用和訪問形式,在目標端是要達到足夠豐富的應用邏輯(比如XML統一文檔交換,但可由node,root這些形式導致足夠豐富的深層功能,深層這裡是指上層),因此越複雜越大而全越好(但是如果沒有足夠人力,我們應考慮設計出別人想不到的商機),應用形式和應用邏輯作為設計中應主要考慮到的問題,有很多人想到用一種形式來統一既存的東西,比如在jvm搭建Windows和其它一切軟件,然而這是多麼無聊的事啊?<br>明白了原理跟實踐,細節與思想之間的關係,我們就會有選擇性地去學習細節,,一定要研究細節，因為細節是重要的，你得用這種技術細節實現某個東西,不一定要研究細節，還是因為你要不要用到它，然而思想是重要的,明白了這個思想,你就明白有些知識是技術細節,有些思想卻是根本,當然,沒到考慮思想的水平,技術細節永遠也還是重要的,不要企圖去鑽研一切細節,因為很無聊,除非你是在滿足自己,一生學習細節,這又是多少無聊的事<br>明白了抽象,我們明白一個東西,應做個明確這個東西的抽象所屬,即它所在的人類範式.<br>在設計軟件時,我們主要用UML工具,但是這東西是靜態語言用的<br><strong>8.1 什麼是設計</strong>我們必須明白，設計這個詞是一個表示人類活動的詞，比如有建築設計，藝術設計，，而程序設計只是一種。它可以解讀為用程序設計語言提供的基本語法和高級語法，以及獨立於程序設計語言但跟語言有關的那些手段（比如Corba,設計模式），來進行對方案域到目標應用域的一個邏輯映射（一種能產生最終產品但並不以產生最終產品為終止條件的人類活動過程，它包括選擇語言的考慮，應用設計，模型抽象，維護各個部分的整個綜合過程，也即設計等於軟工）。故涉及到不止程序設計語言一個方面。下面我們將就這些方面一一進行解說。<br>因為程序設計是人的活動，所以它首先是一種對人類活動本身的設計。設計模型的目的正是在於規範程序設計的各個過程。使開發過程可控化，這就是程序設計模型要解決的問題(XP編程啊，瀑布模型啊)。<br>再次，設計需要對代碼邏輯的控制，因為是由人來寫代碼而且也是由人來維護代碼的，所以選擇一種能切合人類層次又靠近語言支持的方式是必要的，過程式使人類能以發號施令的方式寫計算機邏輯。面向對象單方面站在人類抽象的角度將計算機邏輯封裝為一個一個的對象。並不需要考慮對計算機的實現過程(當然在每個class內部也可以有過程式)，相對面向過程來說，面向對象是更抽象的。當然，這些都是大的代碼邏輯控制手段，和高級語法機制，小的可以小到“流程控制，循環”這樣的課題。<br>在語言選擇方面，如果是通用編譯型語言，因為類型是語言表達客觀事物或客觀邏輯事物的機制（使之成為語言的數據使語言成為一個DSL），所以代碼邏輯的抽象首先是一種類型抽象的過程，C++中有OC（面向類化），模板範型這樣的對類型進行抽象的機制，如果是通用腳本解釋型語言，它將類型動態化，這樣就能更好地表達領域詞彙，DSL抽象。相比通用編譯型語言來說，這二者都存在設計的抽象和實現（因為都存在類型），但顯然腳本語言更靠近實現，，這二者的唯一的區別在於，編譯型語言用了嚴格類型的抽象來表達DSL邏輯，而腳本型語言採用了活動類型的方式來抽象DSL邏輯。<br>程序設計還是一種對應用的抽象過程，因為任何軟件的編制在於解決目標問題，面向一個目標領域，無論是架構師還是程序員方面，都需要面對程序設計要解決的問題和領域進行抽象，，提供一個科學組織的抽象框架以更好利用複用或更下一步的抽象，軟件產品的用戶有三，最終用戶，最終腳本用戶，程序員用戶。其中，2，3是能有機會進入到程序邏輯內部的用戶。如果是寫代碼的那個人來維護程序，實際上就是下一步的抽象，下一步的抽象和複用不過一個詞說法的二個方面。<br>然而，雖然抽象過程並不需要預先考慮軟件複用能力，但是科學組織了的，鬆偶合，緊實現的抽象過程顯然可以為整個設計中的所有階段帶來好處。<br>綜上所述，無論如何，設計的最終目的是使軟件產品具有更強大的生命力，對其內要做到科學抽象和組織，對其外要做到利用複用，易於重構。<br>什麼是重構呢，重構並非重寫，重構是面向為已有系統增加新功能或完善已有功能的需求下，在原有系統已經存在的情況下，變更其設計方式（注意設計這個詞），修補式地加進一些新的設計元素或去掉一些舊的設計元素(故往往用到設計模式，因為設計模式可以很好解決此類問題，所以在介紹設計模式的一本書裡，總是會有這樣的問題和需求發生在先，然而才導出一個個的設計模式)，重構往往是解決代碼維護問題的一個重要方面，當然，正如上面提到的，軟件產品在最初被設計和產生時也要考慮到一個科學設計的過程，這樣才有利於後來產生新需求和新問題的重構過程。<br>這裡首先有一個實現與抽象的區別所在(人們往往把設計和實現對立而模糊了對實現的理解，其實，抽象和實現才是一對對立體，找準了這個才能正確地理解實現，就像對腳本語言的理解，如果你一開始知道它是系統編程語言的對立體，那麼你就不會產生腳本語言是不是一定是解釋語言這樣的疑問，因為它一開始是非系統編程語言，其使用解釋或編譯是它第二個要解決的問題所在)，但設計和實現無法分界，這首先是因為語言沒能為它們提供一個有效區分的機制（Delphi 的單元文件pas中有接口和實現這樣的關鍵字，C++默認將h文件和cpp文件分開，然而這都不是嚴格的抽象與實現分開的機制和行之有效的方法，這根本是因為這二者根本就是具體問題具體分析的事，無法在形式上進行區別，但提供h,cpp這樣的機制也並非錯誤無效的方法---請參照選讀中的“形式主義”），OC可用於設計中的抽象，也可以用於在先前設計抽象基礎上進行的下一層抽象（實現）。<br>那麼是不是可以將抽象分層呢，一部分是DSL類，一部分是字串這樣的計算機實現類，將前部分看成設計，後一部分看成實現，，但實際上這樣也是不行的。因為無法精確給每一種這樣的抽象分層，而且即使分層，也是有很大侷限性的。<br>比如在庫的設計和利用庫進行實現這二個過程中，都可以寫函數（以過程範式編碼），顯然地，庫的設計是高度面向複用的，而實現是一種函數調用，然而為什麼庫的設計中的函數才是設計，而實現中包括了函數調用的函數體就不是設計呢？他們同樣是有函數原型的接口的啊。這就說明了語言本身並不能嚴格化這個區別。能嚴格化的就是具體問題中的具體區別方法。<br>這就說明，存在接口的地方就存在設計（因為可供再被可複用，而設計的一個意思就是為二層用戶提供複用邏輯考慮的過程，比如接口，我們在比較大的層次舉個例子吧，比如用C實現的工具庫和抽象庫）。我們應該嚴格在源程序中標誌出哪些接口是作為最終工具使用的接口，哪些是能再供抽象使用的接口。<br>因為抽象最終要形成源程序，要在源程序中反應出來，而源程序是由自己或別人查看的，所以說抽象對設計是至關重要的，因為抽象是擇其事物一方面或某維度進行抽象，所以設計不必大而全，那些“理想”靠近現實事物模型的抽象反而不是最好的抽象（比如嚴格用OO設計一個遊戲的圖形世界，把每一個樹葉都封裝為對象，還把導演，這樣的概念抽象出來），因為這樣的抽象往往太大了，或不必要帶了太多錯誤的臆想。抽象只能是現實事物的一個或某些方面的變形。甚至帶有邏輯模型抽象，而不全是實體抽象。<br><strong>8.2 編程能力，代碼控制能力，複用與接口，輪子發明與使用</strong>你應該知道，真正的編程能力不是使用輪子的能力（即不是複用能力），而是將現實問題用編程語言來解決的能力(這就需要你具備設計能力，即很強的代碼控制能力，能把現實問題抽象為代碼而不僅僅滿足於使用別人現成的庫)雖然複用能力與設計能力都貌似語言能力，從語言的眼光來看，複用能力是屬於設計能力的，但實際上他們還有很大不同的要求有不同的語言能力，有些人具備在不懂STL原理的基礎上使用STL的能力，但它們就是不能用STL來實現一個STL。。這就是上述二種能力的根本區別的證明。<br>（往往我們把複用能力當成編碼實踐能力，把設計能力當成廣義的編程能力）。<br>有時難以理解的絕對不是代碼本身(語言的語法和語句有限)，難理解的代碼是其中體現出來的設計元素和應用元素..也就是所謂的算法和設計,,有時是設計模式，有時是現實問題模型的相關抽象(其實算法和數據結構也是計算機開發中歷史形成的抽象，，即某個“現實問題”，但一般將它們獨立出來)。<br>要知道，程序的編制者跟程序的使用者有時是不一樣的，這集中體現在C++的模板的複用上，C++的模板是用來書寫高抽象庫的好工具，然而類型的泛化意味著通用，因為像STL一樣的東西意味著它能並適合於提供某種抽象上的規範（接口），，我們使用STL就不必處處屈就通用了。我們只需要“使用”，（我們實際上也不必提供太多的輪子方面的東西因為我們正是使用輪子，因此只需開發出使用這些規範的實踐，實例），就跟遊戲引擎和遊戲的區別一樣（面向通用的庫或面向實現特化的庫都有）。。因此這二者涉及到的模板編程技術是有高有低的。會複用並不一定會寫。當然，理解stl庫的實現過程中使用到的模板理念顯然可以幫助我們複用這些規範（接口）進行實例化（使用接口）的過程。<br>實際上，數據結構，設計模式，現實問題這三個東西跟任何一門程序設計語言都沒有關係，因為任何一門馮氏模型決定下的開發語言都滿足這些東西，，而且計算機界的一切軟硬基礎都是算法加數據結構的集中體現（再往人類的軟工一點，就有設計模式了），我們編程往往涉及三個能力<br>1， 語言語法的，比如流程控制，數組，IO，字串，<br>2， 數據結構和算法的。<br>3， 設計模式的<br>4， 現實問題的。<br>用某種語言來編程，體現的代碼控制能力只有1是必要的，然而具備了1並不意味著你就能定出某種數據結構，或設計模式，，或抽象出某個現實問題，，因為那根本是另一些領域需要你掌握的東西（而不僅僅是語言能力）。所以你彙編碼能力並不意味你有編程解決現實問題的能力。你有編碼能力所以一定有複用能力，但你不一定有實現這些輪子的能力（以及閱讀這些代碼時認識到這些輪子設計的能力，這樣你閱讀代碼的能力和眼光也會受到限制，只限於簡單的複用能力，因為複用能力只要求你擁有接口複用能力，，真正的邏輯不只是接口間的簡單複用，而是接口間複合形成什麼樣的抽象以及如何邏輯上形成這樣抽象，這就不僅僅是接口複合作用了）。<br>所以真正的編程能力在於2，3，4，加1編碼能力,,所組成的綜合編程能力;<br><strong>8.3 OO,模板，設計模式與設計</strong>設計即邏輯的邏輯，而且是面向人的控制邏輯的抽象即設計的第四種意思是讓抽象以人.需要的方式進行組織，即人影響抽象的能力，<br>實際上設計無所不在，從你寫第一行控制流程代碼開始，你就在設計了，只不過是隱式的，機器並不會流程控制，是語言賦於你能以人類看得明白的流程設計邏輯向機器發令的。如果說流程控制設計是細小的，那麼OO是一種顯式化的設計，當你用OO來寫代碼時你就在設計，雖然你寫的是實現，設計與實現間無明顯分界，，，你照樣是在設計，因為你用到了OO的三重思想，繼承，泛化，封裝，，這就是控制邏輯的邏輯，，是設計因素。。一句話，設計無所在不在，即使在C那樣的緊實現的語言中也存在設計。。<br>所以存在三種設計方式在C++中，OO，模板和LOKI。<br>模板的能力在於抽象類型，所以設計的一種意思是類型控制和抽象能力（動態類型更側重實現談化設計所以它首先去掉強類型，而提供弱類型或無類型或動態類型），模板只能只做類型控制，然而LOKI可以做到控制邏輯級。這就是單純的模板用於設計和LOKI用於設計時的區別。。<br>在抽象類型作為設計手段的方法上，OO和模板是差不多的，然而不同的是模板是“泛化”類型OO是純粹只用“類型化”來實現設計（對即邏輯的抽象邏輯，我們知道，實現中也離不開設計，設計庫的設計就更離不開設計了），，所以OO的設計手段不足，而設計模式是一種新的設計理念，語言並不直接支持，，C++用STL作為語言的數據抽象，，用LOKI作為語言的設計能力（OO，模板相比來說是小規模的設計手段）。<br>注意，OO的類型化絕對不能說成對象化，OO定義成面對對象是極其錯誤的譯法，，OO是用於設計的，，所以O這個字眼只能是“類型化”的“類型”，而不能譯成對象，，因為對象是實現裡面，不是OO設計的原義所在。<br>設計的唯一特徵是站在高階的泛，這就成為區別實現與設計的根本，而不是大小問題的邏輯包含互飾關係（因為這樣的話，設計與實現只有模糊分界），而泛成為區別這二者清楚的界限。<br>為什麼template僅有type as type一項就足於跟OO匹敵呢，因為類型就是語言的一切，提供關於類型的機制就是一門語言的設計能力的一切。。<br>動態類型語言也有類型，，不過它的類型不需要一個設計期的type來確定指定而已，，其本質也是某類型的某個value.<br>而動態類型沒有type，所以沒有對數據的泛化，也即無法抽象數據，也就無法抽象代碼和控制（設計裡的）邏輯，所以無法設計（設計的一種意思是類型控制和抽象能力，，動態類型語言不存在對類型的抽象，所以至少這種意思的設計在動態類型語言是不存在，因為動態類型是DSL語言不是通用語言無需考慮類型及類型抽象上的設計）。它只能在線控制邏輯的運作。<br>所以動態類型語言是實現語言。。應該稱動態類型語言為在線類型語言。模板是離線類型語言。<br>我們知道設計是複用導向的，最終用戶（領域內用戶，腳本用戶）和程序員用戶（本語言內的複用,語言非通用的）是二級不同的面向級，前者用動態實現語言即腳本語言，而後者用靜態語言為宜。<br>解決可複用銀彈問題的根本可以改造開發模型，，也可以將設計邏輯儘量多地沿伸到實現，而且是腳本用戶級。因為此時沒有編程工作，只有配置工作，銀彈問題根本不存在<br><strong>8.4 設計能力和程序員能力模型</strong>設計能力第一個是結合了數據抽象和代碼抽象以及語言映射能力到現實問題的解法的能力，第二個是構架架構的能力（提出一種規範一種抽象模型，就像Java規範和七層模型一樣，相比第一種設計能力來說，這是高級的能力）。<br>設計還有一個方面是面向複用的工程設計。就是開發庫的設計意義所在，<br>理解設計對理解C++新思維那樣書裡的觀點有效。<br>馮氏模型的侷限和優點同時體現在數據結構和設計模式上，它使人無論如何都要最小在這二種子抽象上工作，，優點是，統一了開發抽象，，這也使軟件邏輯變得統一。這對軟工是尤為重要的。<br>程序員的能力模型，語言30%,數據結構50%,對現實事實的抽象理解能力10%,,設計模式能力10%。。 ==100%。<br>真正的編程能力是設計能力！！對思維模型的學習！！而非對細節，對平臺編程！！事物的OO解只是事物解空間中的一種而已！！<br><strong>8.4 自上而下設計和自下而上設計</strong>基本概念<br>抽象在軟件開發中的重要性是不言而喻的。如果一個系統有了正確的抽象，那麼這個系統就更容易理解，更容易維護，開發起來也更為高效，最為重要的是也更容易把事情作對。Grady Booch甚至認為抽象是應對軟件複雜性最為有效的手段。在面臨一個複雜的系統時，往往只要再提升一層抽象層次（當然要是正確的抽象），那麼該系統就會立即變得清晰、簡單，理解、開發、維護起來也更為容易一些。不過，值得注意的是，雖然有了一個正確的抽象後，可以大大降低理解、開發和維護的難度，但是要想得到一個正確、合適的抽象卻是非常困難的。<br>提起代碼自動生成，可能大多數人立即會想到這樣一種情形：只要獲取了系統的需求，那麼就會自動地從這些需求生成系統的代碼。這種想法固然很好，但是在目前的科學發展水平（這種技術不單是軟件技術的問題，它還和人思維的生物基礎有密切關係）下卻還無法實現。需求和能夠自動轉化為代碼的精確的形式化規範之間有一個巨大的鴻溝，目前這項轉換工作還只能由人來獨立地完成。因此，這種技術在目前來說只能是一個神話。我們在本文中所指的代碼自動生成是針對比較侷限的領域而言的，即需求已經被正確的理解並由人轉化為解決方案領域中的抽象模型。代碼自動生成並不是為了替代人去完成系統的軟件開發的，它只是一種支援抽象的工具而已。</p><p><strong>領域特定語言（DSL）</strong>其實，大家在每天的軟件開發中都在不經意的使用著這項工具。當我們在使用面嚮對象語言進行軟件開發時，其實我們是在一種抽象的層面上進行工作。有了這層抽象，我們所編寫的軟件就會更有表現力，更為簡潔。比如：當我們寫下下面的代碼行時：class Cat extends Animal。我們想表達的是Cat is a Animal，面嚮對象語言為我們提供了強有力的支持。而這個抽象的實現細節則由編譯器來完成，我們無需關心。這樣我們就能夠在一個更高、更直接、更易於理解抽象的層面進行開發和交流，同時也大大降低了出現錯誤的機會。當我們使用支持泛型或者AOP的語言進行軟件開發時，其實我們是在另外一種抽象層面上工作。比如：當我們寫下如下代碼時：<br>template<br>T Add(T, T)<br>我們想表達的是求兩個類型為T的變量之和，而不管T到底是什麼具體類型。想想看，如果語言不支持這種表達規範，我們要寫多少個雷同的Add方法。有了這種表達規範，我們就可以直接、簡潔地表達出我們的意圖，而具體的轉換工作就有編譯器代勞了。還有，如果我們在支持AOP的環境中進行軟件開發，那麼我們只要使用該環境提供的AOP語言規範定義出我們希望的橫切關係（其實就是一種抽象），剩餘代碼的編寫和插入工作就由該環境幫我們自動完成了。雖然編譯器或者開發環境在底層生成的實際上也是大量重複的代碼，但是這些代碼的抽象規範卻只有一份，而人們開發、維護、溝通所基於的正是這唯一的一份抽象規範，底層的重複實現細節對開發者來說是不可見的，並且是自動和抽象規範保持一致的。可以說，在開發者的頭腦中，是沒有重複的。從而有力的支持了“once and only once”和DRY原則。試想，如果語言種沒有提供這種描述規範，那麼我們要編寫多少晦澀、難懂、重複的代碼才能描繪我們想要表達的概念。<br>上面提到的抽象是一些比較通用的機制，因此一般都是語言內置支持的。也正是其通用性使其有效性範圍受到了限制。一般來說，上面的一些抽象機制是僅僅針對開發者群體而言的，並且使用這些抽象機制進行的表達也是由編譯器來自動生成底層執行代碼的。但是，還有一種抽象表達更為重要，它的作用是在開發者和客戶之間進行溝通、交流。說它重要是因為它和所要開發的系統是否能夠真正滿足客戶需要密切相關。這種抽象表達更貼近具體的問題領域，因此也稱為領域相關語言（Domain-Specific Language（DSL））。比如，如果我們開發的是一個金融系統，那麼如果我們能夠使用一套金融術語及其關係來刻畫金融領域中的一些業務邏輯，那麼不但表達起來會簡潔、直接得多，更重要的是客戶也更容易理解，和客戶溝通起來也更為容易。再如，如果我們要開發一個科學計算系統，那麼如果我們擁有了一套描述科學計算領域的詞彙，那麼在表達該系統時不但會容易、自然很多，而且也更加高效。有了這套DSL之後，剩下的工作就是要自己實現一個編譯/解釋器，來把DSL自動生成為目標語言。由於這個DSL一般都侷限於某個特定領域，因此其編譯/解釋器實現起來也不會有多大困難。<br>敏銳的讀者一定會發現，我們在前面列舉的支持面向對象（OO）、泛型（GP）或者面向方面（AOP）的語言，其實也是DSL的一種。只不過它們所針對的是更為通用的，和軟件要面臨的實際問題領域無關的領域。它們的作用是為了提高一些通用問題描述的抽象層次，並且也為構建更貼近問題領域的抽象提供了基礎。<br>自上而下 還是 自下而上？<br>寫到這裡我突然想起一個非常有趣的問題，那就是大家常常爭論的自上而下開發和自下而上開發。一般認為，自上而下的開發方法更具目的性一些，也更為自然一些。其實自上而下的方法是有很大風險的，一是往往很多預先的設想很可能本身就是錯的，一是這些預先設想落實到底層時要麼無法實現，要麼無法很好地適配。其結果就是生成一個具有大量冗餘、醜陋粘合層代碼的系統。而採用DSL思想的自下而上方法則具有很多你可能沒有想到的好處。你可以先實現一些DSL中的單個單詞，然後再實現一些更大的單元，並試著把這些元素組合為更大的領域邏輯，按照這種方法實現起來的系統往往更加簡潔、清楚、乾淨，甚至更加易於重用。一般來說，如果你想採用DSL的開發方式，動態語言大有用武之地（Python、Ruby都是不錯的選擇，在www.martinfowler.com/bliki中，Martin Fowler對動態語言和DSL的關係進行了深入、有趣的描述）。<br>自下而上的做法實際上是在改變、擴充開發語言，使其適合於所面臨的問題領域。當你進行軟件系統的開發時，你不僅僅只是把你所構思的程序直接映射到實現語言，同時你還不斷對語言進行增強，使其更加貼近你所構思的程序，並且表達起來能夠更加簡單、更加直接。比如：你會想語言中如果有了這個操作符，表達起來就更加清楚、簡潔了，那麼你就去構建它。這樣，語言和程序就會一同演化，直到二者能夠形成一種完美的匹配關係。最後，你的程序看起來就會像是用專門為它設計的語言開發的。而當語言和程序能夠很好地相互適合時，所編寫的代碼也就會更清晰、更少、更有效。<br>值得注意的是，自下而上設計相對於自上而下設計來說，並不意味著用不同的順序來編寫同樣的程序。當採用自下而上設計時，常常會得到一個和自上而下設計不同的程序。所得到的不會是一個單一的單片機（monolithic）程序，而是一個具有更多抽象操作符的更“大”的語言和一個用該語言編寫的更“小”的程序。此外，這個語言的抽象操作符也很容易在其他的類似的程序中得以重用，所編寫程序也更加易讀、更加易於理解。<br>還有一點值得提出，那就是自下而上的開發方法可以儘快地得到來自代碼的反饋，可以及時進行重構。我們大家可能都已經知道，設計模式一般是重構的目標，這裡我想特別指出的是：DSL往往也是很好的重構目標。<br>抽象、庫和DSL<br>C++之父Bjarne Stroustrup經常強調的“用庫來擴充語言，用庫來進行思考”（ http://www.artima.com/intv/elegance.html有近期對Bjarne Stroustrup的採訪，他再次強調了這個問題），其實就是在強調DSL以及自下向上開發的重要性。庫就是DSL的一種形式，Bjarne Stroustrup所列舉的科學計算庫的例子就是科學計算領域的DSL。構建庫的過程其實就是在朝著更加貼近問題領域抽象的方向邁進。明白了這一點，我們就不難理解Bjarne Stroustrup一直強調的泛型在構建一個優雅、高效庫的方面的重要性了，因為泛型為構建這種抽象提供了一個堅實的基礎。<br>不僅C++如此，其他一些語言（比如：Java）也擁有眾多的庫。這些庫在我們進行軟件開發時，為我們提供了強大的支持。不過，這些庫往往都只實現了它所針對領域的一些通用基礎性的問題。因此，在某些特定問題上，可能無法直接地使用這些庫來進行表達。此時，你就應該考慮建立一個特定於自己問題的特定庫了。<br><strong>結論</strong>作為開發者的我們，該如何做呢？正如本文開始所說的，抽象固然很好，但是要找出適合於自己手邊問題的抽象是一件很困難的事。它應該是一個不斷從代碼編寫中得到反饋，然後再修正，接著再編寫代碼的循環反饋的過程，這也是我為何認為自下而上開發更為有效的原因。我們不應該侷限於僅僅會使用某一種工具，某一種開發環境，而應該多想想這些工具、開發環境背後蘊涵的思想。我們應該注重於培養自己發掘抽象的能力，這方面能力的培養既需要很好的和客戶溝通的能力，同時還需要有堅實、高超的軟件能力。<br>此外，近期熱的不能再熱的技術MDA，其核心思想其實就是DSL，不過我對於其試圖使用一種語言來刻畫所有領域模型的做法並不看好。與其使用它，倒不如逐步演化出一個特定於自己問題領域的Mini DSL和一個DSL編譯/解釋器，並基於這個DSL來進行開發，這樣或許更為直接一些，更為輕便一些，更為清晰一些、更為有效一些，更加具有針對性一些，也更為經濟一些<br><strong>8.5 大中型軟件和複用與邏輯達成</strong>我們知道一個庫的發佈總是帶一個samples目錄，然而那是小例子，，大中型程序是怎麼開發出來的呢，，你該如何著手寫一個大型的程序呢？一般來說是找輪子和寫實現。<br>如果開發中存在造輪子的工作，那麼很多邏輯都在這裡面，，就拿開發遊戲引擎來說吧，引擎部分總是要考慮進很多邏輯，有時是複用別人的庫，有時是很多預考慮的邏輯，有時是設計模式方面的邏輯，考慮OGRE就知道了。<br>就複用邏輯（比如一個使用了OGRE的遊戲的實際代碼）來說，，它往往是OGRE中的samples演示小程序，如果是一個用yake寫成的大型遊戲，那麼起碼可能還存在造其它輪子的過程（比如你還用到數據結構，而不想用STL，那麼你需要自己設計—這是在造輪子了，或直接複用GLIBC），，邏輯間的大量複合，和與其它維度上邏輯的結合（比如不僅是圖形方面的，還有網絡方面的代碼等），就會構成一個大型軟件了。<br>然而幸好有一個YAKE的程序考慮進了幾乎你能用到的很多庫，，當然如果你想用其它的庫替代，或者加進其它的庫邏輯，或者自己在複用中會想到自己開發自己的庫邏輯，也是完全可行的。但是我們一般不改造YAKE（因為如果它不提供SRC我們就無法改造，其它很多庫都是這樣的）。而是拔插使用其內組件庫。。<br>所以大中型軟件的形成，，有的是庫邏輯和實現邏輯，即設計能力，，有的是複用邏輯。。即編碼能力。。因此那些說程序員是簡單的複用員的人是可笑的，，因為一個程序員在編程中總會涉及到設計能力（即那麼比如設計一種數據結構庫的能力）。。。<br>所以什麼是設計能力就出來了，它泛指一種真正的編程能力，即將現實問題映射為語言邏輯的能力，（找輪子是作設計的一個步驟，），那麼設計能力要求你有什麼樣的能力呢，，當然，現實問題的模型你是要清楚的，而且語言邏輯也是你要清楚的，複用的庫你要從語言的觀點去搞清每一個接口的真正意思（無論用什麼語言，，數據結構，設計模式和語言本身這三者的邏輯是不變的，，其它的就是具體問題映射到語言的能力了），在整個設計過程中（映射中），，你必須清楚每一個步驟，，因為軟件設計真的不像拼零件（強烈鄙視這種用在小打小鬧模式上的接口拼起來的軟件上），，大型的軟件接口太多，，你必須熟悉每一個功能模塊，，和預見每一個功能接口。。這種細節的無限性決定了軟件的複雜性和設計實現時的清楚性，，否則就是編譯不過，不成軟件。。那意味著項目失敗<br>架構師的能力就是設計能力，，，程序員的能力就是編碼能力（然而在每個小問題上每個小模塊上也存在設計，所以程序員也是一個設計師，不過他不直接面對複雜的大系統而已）<br><strong>8.6 通用設計與專門設計</strong>像C++，C這樣的語言都是被設計為通用的，要通用，因此往往基於某種靠近計算機底層的離散形式,而DSL實現特定領域事情的語言,(相對C++,C來說)不強大，不深入底層，不能控制計算機幹任何通用事情,因此往往基於高層模型,,<br>因此,C++,C這樣的語言必須要涉及到彙編原理裡面的東東,而DSL可以以任何高層的形式被體現,比如不需要編譯的UML圖都是,POWERPOINT代碼都是DSL,根本不需要編譯器這樣的圖靈完備裝備<br>這就是腳本語言比不上編譯語言這樣的語言對計算機編程方面的功能強大.因為腳本語言的虛擬機往往是高級機器,根本不像我們的硬件機器那麼底級,圖靈模型對應我們的硬件機器和架構,而虛擬機往往跟硬件架構差別過大,因此腳本語言和系統語言是為二個不同的機器設計他們乾的事,,,,而一般虛擬機作了高級邏輯,比如GC等,而X86不可能在硬件架構級就用了GC,如果CPU芯片可以用硬件加速的方法直接支持語言的垃圾回收機制就好了,這要求語言跟CPU一一對應,,而且OS也提供了大局方面的GC(並不僅僅針對某個語言,比如WINDOWS的操作系統級的資源釋放)<br>C跟C++到底有什麼區別呢,我覺得第一個加號是一種理念上的疊加,第二個加才是語言要素上的改變,C跟計算機離散和底層接近,解決的問題是如何實現,專注於計算機對問題的實現,因為C語言就是機器的觀點<br>C++跟人接近,解決的是如何更好地複用,關注於問題本身,脫離了實現邏輯如平臺邏輯,人們如何更好地寫代碼服務工業化,OO就是人類的觀點,C是實現域擴展,C++則完成了一個從實現域到問題域的一個維度變換而已，<br>C和C++解決問題時,,站在二個根本不同的維度而已.<br><strong>8.7 具象與抽象</strong>抽象源於一個簡單的事實，把事物從邏輯上分開，這樣就會解偶它們之間的聯繫。<br>抽象要適中，不能抽象得太像了，為程序員複用的相對低階接口變成了為腳本程序員的高階接口。<br>複用由二次開發的程序員決定（這個事實決定了你將向它們提供什麼大層次上的功能比如ogre的複合模式，大的邏輯或小的接口），所以複用是程序員面向的，純dp的設計方案要求二次開發的程序員也要了解DP。<br>對api的調用在此設計的最下層，由二次複用者提供。（即數據由它們提供，代碼邏輯由我設計）<br>其實你可以將複用抬高到場景這樣的層次（這就是領域邏輯，當然設計也可不深入到這麼高的境界，這就是代碼模式，設計模式和現實模式之間的整合設計所在），這是由複用面向決定的即需求決定的。而不僅僅是單方面的設計。<br>首先來對遊戲進行劃分。<br><strong>8.7 架構與應用</strong>因為功能是邏輯疊成的產物,越到底層,它對高層的邏輯依賴應儘量少，因為高層往往是應用邏輯，而底層往往是功能邏輯和業務邏輯(高層和低層通過一個隔離層意義上的邏輯來達到功能上的完成但又不致於增加這二個層次上的複雜性，使得在這二個層上的工作可以分別完成)，因此底層核心架構應儘量簡小精短（比如linux的core，但其中的應用可以無邊無際），但是簡小的同時卻要提供最大程序上，或全部程序上的可擴展性，這樣在完成了整個core後，後面的功能慢慢趨向應用時，就可以不致於改變到core,也即這個core可適應一切小，中，型的平臺，不必做重複工作．或者即使需要被改變時，涉及到這個core的修改量也儘量小．<br>對底層的邏輯應儘量提供迂迴用的接口,迂迴即抽象,增加了迂迴即增加了另種一種維度上的抽象可能性,而維度永遠無窮無盡,因此抽象以任何一種姿態被創建都可以是一種新的抽象,我們用代碼的形式表達我們所需要的功能,即用計算機能處理代碼的本質維度摸擬人的思想功用的維度,這就是"原語設計"的概念所在<br>邏輯的抽象粒度永遠有它關於具體的複雜性，我們不能定義一個具體的邏輯塊，指明它為core或者還是應屬於core，但是正如這句話說過的，問題有它自身的複雜性，因此我們應具體問題具體分析<br>這是哲學所指明的，哲學不是人的東西（雖然它是人發現的），?<br>底層完成了（底層往往是一些首先要解決的邏輯或者在設計意義上具有優先產生其它事物的概念體），其上的應用可以無邊無際，但應用應儘量追求形式簡單，一個合理的架構和其上發展的應用對於人來說應越來越簡單,,,這才是合理的,我們不能掌握的複雜度應儘量隔離.因此我選用沒有歷史複雜性的open jdk,gnu c,擁護開源的linux</p><p><strong>8.8 應用與設計</strong>應用越來越接近人了,比如web2.0,3.0的出現,這是指軟件產品的應用,實際上在軟件被作為產品被產生出來時也作了靠近人的調整,編程領域的三個東西,問題域,方案域,人都在相互影響,這種影響產生了一些技術,導致了一些編程的變革,並最終與人們的觀念結合,比如OO,比如設計模式,這也將導致架構變成軟件的功能性"實現"要考慮的,在某個維度上加深了複雜度,然而卻在另外一些維度上提供了簡單的形式和更有效的應用<br>互聯網的最初靈感來自對學術自由和開放的嚮往，而現在它已成為由企業和運營商控制的商業平臺。企業應用與網絡的發展密不可分,這二者相互發展,成為影響軟件工程界的二大主力<br>多維這個字眼本身就提倡從多個方面(可見多維就是多方面,當我站在某個維度為我自己說話時,我將同時失去另外其它的維度)<br>某些東西越來越統一和規範了,這加大了學習的門檻,比如xml出現,就統一了文檔交互的格式,並導致了很多邏輯知識,產生了一些新的邏輯,需要被學習,但這是合理的,因為形式更加簡單了統一了,並改變了一些應用的形式,比如軟件分發delopy的統一形式等,<br>另外一趨勢,應用越來越分佈了和趨向web,這實際上是很多年前某些大公司的戰略,總有那麼一群人(有些人研究應用形成架構,有些人研究編程低層形成架構和思想),先知先覺地認識到一些東西,比如.net的出現,網上的資源服務器越來越變成一般應用服務器,富客戶端的flex,silverlight等等,只是它們是慢慢被民間所識所學習.<br>一切技術都是面向被應用,因此人無論如何都是主導.將反過來最終影響技術的被利用形式而隱藏了低層實現,一些離最終應用跨度太大的低層實現不必知道其原理,靠近人的一端要提供儘量簡單的形式,比如xml,比如oo,面向機器的一端永遠有它的實現.<br><strong>8.9 與軟件有關的哲學 聯繫</strong>範意上的設計是廣泛的,不僅限於計算機的,也不限於軟工抽象(軟工和計算機是二個完全不同的抽象,雖然沒有人提出過計算機抽象到底是什麼,軟工抽象到底裡面有哪些抽象存在,我們僅能站在某個或某些維度上給出一個描述性的概念而不是有限集,如果能站在一個大全的維度上說明到軟工的全部抽象,雖然這是不可能的,但我們還是給得出的這個結果取個名字,叫範式,範式總是某些維度上的產物而不是大全的維度產生,學習計算機的很多哲學思維可以解決其它域的哲學),設計並不僅僅面向於創新,有時是形式的重組,而不是內容的創新,應用形式的改觀,設計出的產品,要源端是面向人的,因此要提供足夠簡單的使用和訪問形式,在目標端是要達到足夠豐富的應用邏輯(比如XML統一文檔交換,但可由node,root這些形式導致足夠豐富的深層功能,深層這裡是指上層),因此越複雜越大而全越好(但是如果沒有足夠人力,我們應考慮設計出別人想不到的商機),應用形式和應用邏輯作為設計中應主要考慮到的問題,<br>在設計軟件時,我們主要用UML工具,但是這東西是靜態語言用的<br>.<br><strong>8.10 與軟工有關的哲學 唯物主義</strong>沒有絕對科學的東西科學,維度給了我們一切答案,永遠有更偏更僻的維度存在,因此拿唯物主義來說,如果它僅僅是表達那麼一種"理"(它僅僅只需要說明這點),而沒有宣揚它是正確的(實際上唯物論本身站在另外一些唯度上看就是片面的,而片面就是一定程序上的不正確),那麼唯物論在這個維度上就算是做到科學了<br>唯物主義表明事物是不以人的意志為轉移的,但是這裡面的最基礎的一個說法都不科學,什麼是事物?哲學都沒有從一種形式上去說明這個問題(就像字典內對"強間"應如何定義呢,法律範式內應如何對這個詞進行界定呢)<br>當然我們討論問題時並不需要把所有涉及到的邏輯都拿來解釋一通,但是作為哲學維度的"事物"是應該被深入和專門界定的,而且"事物"這個字眼本身就是不嚴格的,而對象對象中的OO中的O,在計算機內存中,它是一個運行單元,在表達出的思想所指時,它又是不可形式化的.(在內存中總是那種形式,然而卻可以產生不同的邏輯,這就是形式與邏輯的關係)<br>如果我們曾把生命中一段時間用於考慮這些哲學知識,那麼我們就會與常人"分裂",正如寫小說的人如果想說出與眾不同的小說故事到達到無人深入之境,就必定要付出和得到一些靈魂,,產生排拆他人的想法,但是要知道,世俗的維度是我們生活所在的維度集,我們如果能認識到這種客觀性,並尊重它,那麼我們就不會分裂,<br>人只能是簡單的,人只能是一個行者,在有生之年接受有限的知識,進行自認為或世俗認為正確的觀點和作法並行動.而不可能永遠是一個哲學者,沒有人有足夠的生命力來最終解釋自己,得到的解釋也只能在一個維度上成立而在另外一個維度顯得可笑,,選擇需要學習的人類知識去學,不要做一個大而全的學習者,在利用所得知識進行設計自己的應用時,應根據經濟學所指,做別人沒有的東西,才會顯得有優勢,你不必在任何一個方面都出色,但一定要在一個方面最出色(實踐要達到"別無它,唯手熟而這樣的境界"),這就是你的資源優勢,可以轉化為經濟優勢<br>邏輯<br>很多邏輯的意思都是不可言傳的或者難以言傳的，所以要看別人的代碼時，除非別人在類文件形式的邏輯，組件形式邏輯的命名上直接讓你明白很多信息，?否則你就不能有效地明白作者寫這些程序時的想法，所以讀人家的程序是難的，因此雖然你是面向源程序形式，但你其實是在求索別人的思想，更要命的是，你明白了這個類文件是什麼意思，你還不能很有效地告訴別人這個類寫了什麼東西，，體現了什麼邏輯，這是感覺是窒息的<br>軟件的本質就是一種邏輯的疊成物，，某某牛人說過，一切問題和功能的達成都是邏輯！！軟件的眼光裡，一切皆邏輯，，在這個軟工年代，最終的產品是多人合作代碼的產物，因此相互之間能明白對方的源程序裡到底能提供什麼功能是重要的，，在以前的程序=＂數據結構+算法＂的年代，程序員之間很容易在這方面獲得溝通，而在現在這個軟工年代，程序=數據結構+算法+架構＂的年代，你還得明白人家程序邏輯是如何組織的，哪些是功能級的實現，哪些是架構級思想級的東西（這些東西為了以後的可擴展而存在，雖然一定維度上也可以稱為功能級的實現）,,<br>所以邏輯該如何命名，，我們只能滿足於用特定的，固定的形式去描述性地表達它們，比如用類文件的名字，組件的名字，，設計模式的中間用詞，等等.<br><strong>8.11 真正的設計模式</strong>我討厭在講授一些思想的時候提供大量的代碼，因為我覺得接受思想的過程應該是一種快樂的如同閱讀一本小說的過程，而不是花大量腦力研究某個細節的過程<br>而且這個世界，往往知識都只是相互轉載，國內沒有多少人會像那些歐美大師特立獨立發明一些新的思想和論述，而我願意寫出我的一些思想與你們共享<br>每一個設計模式中都出現了一些角色，然而使用某個設計模式的個體(Client)不屬於設計模式的某個角色,而只是使用這個設計模式的客戶，，設計模式的目的就是為客戶提供一個好的對現有對象的訪問方法,設計模式是一種高於任何成碼的思想和經驗模式，因此不能直接用某個工具建模下來，在使用設計模式的過程中，，，總會產生一些新的抽象(而且有時不只一層抽象),,這些抽象隔離和解偶了客戶(Client)與現有代碼之間的關係，，，在它們中間作為中間抽象出現，而所謂抽象，，往往都以一個類的方式存在，(因為JAVA中一個類默認只承擔一項責任或實現一個對象數據描述，因此一個抽象往往就是一個類，當然，抽象有時以方法的形式存在，某個設計模式也會以方法的形式存在，比如工廠“方法”模式，一般來說，設計模式都會形成某幾個抽象類，對應該設計模式中的幾個角色Actor)，，<br>設計模式終歸是一種迂迴的方法(因為增加了抽象所以代碼變得有點難於理解而且類層次增加這變得運行時變慢了一點)，，然而這種方法成全了一種好處，，那就是：它部分或完全都解偶了使用者與現有代碼之間(實際上設計模式可用在開發的各個階段)的關係，，，這使得以後的對軟件的維護工作和修改需求變得易管理和易實現，使軟件不致於由於當初設計上的欠缺而變得難於修改而瀕於死去.<br><strong>8.12 設計模式與數據結構</strong>對於設計模式，一般有下面幾種理解： 重構時的設計模式。修補式的設計模式(client角色濃重) 大設計時的設計模式。全新式的設計模式（可以沒有client角色在某一套模式中）<br>其實。不妨把設計模式稱為抽象模式更好(我們知道抽象問題領域是設計中的一個重要步驟)，，因為它更多地跟著眼於解決具體事物有關（就跟數據結構一樣，不是跟具體語言有關，不是屬於某種代碼結構。）正如數據結構是擇“數據”這個維度來抽象對現實事物映射到計算機解法的做法一樣，設計模式是擇“模式中的各個角色和關係”來映射對現實事物的模型，從而求得一個現實問題到計算機的解法一樣（就目前所提出的一些設計模式來看，他們都是抽象現實事物模型的初步組件，一般有傾向於用面嚮對象語言來實現的趨勢比如四人幫那書）。數據結構和設計模式都不會跟某種語言和語言機制有關，跟“面向對象”這樣的代碼抽象有本質上的差別，是實現模式，實現結構，而不是代碼結構。著眼於如何解決和抽象問題，而不是如何抽象代碼以進行更好能被複用這樣的軟工目的（當然，這二者是不分家的）。<br>我在《OO為什麼不是銀彈-過度抽象的利與弊》中談到，OO並不是銀彈，銀彈是那些能統一人類思想，形成契約文化，經驗的東西（比如我們寫小說的那些套路），而不是簡單的class這種面向複用的小技倆。 設計模式正是上述所謂“契約文化，經驗”之類的初步體現（不可否認，我們所看到的設計模式跟具體現實事物還是有很大距離的），等到有一天，所有的問題都用設計模式來抽象的時候，成千上萬的設計模式會被提出來。人們會傾向於用大大小小的設計模式來解決問題。那麼設計模式就會到達它的顛峰。<br>然而對於程序員來說不利的是，數據結構已經被很好地映射到C語言中，而設計模式幾乎在C語言中找不到它的影子。這正是它不成熟的地方。也許有一天會有一套“設計模式”專用語言出現。<br><strong>8.12 設計模式之基礎</strong>研究數據結構我們目的從來不是那些底層的東西，，而是抽象的比如優先隊列，多重集等。<br>四人幫的那本書是基於面向對象來談設計模式的，因此它先提出一些面向對象的知識，比如一個類的class和type(interface)的區別，提倡對接口編程而不是對class定義即實現編程，提倡對象的組合而不是繼承。而且它稍後提到的諸多設計模式中，都有對象，職責，請求，之說，這些都是OO裡面的知識。。<br>不要小看了這裡的對象組合它實際上是對接口編程的小化說法<br><strong>8.12 真正的開閉原則</strong>我們應該對擴展開放，的同時(注意這三個字),,,保證對修改的關閉(一個工程，應該在設計時就要考慮到將來修改的需要，而且要保證未來修改時能儘量降低工作量，對於一個真正的工程級的規模，人力管理工程應該儘量簡化)，<br>幾乎沒有接確過設計模式的人(除了完全外行和真正的編程高手外)看到這句話都會感到疑惑,而且會產生一個很普遍的疑問：不修改何來擴展？<br>高手與低手的差別就在於這裡，高手往往看重的思想(即設計能力，，，識別架構和建立構架的能力，但是因為計算機能理解的設計只能是多範型設計，因此高手著重的這種思想往往也是受計算機實現的限制的設計)，而低手考慮問題的第一切入點就是源碼本身，因此產生“不修改源碼何來功能擴展”的疑問也就很自然了<br>而其實，在高手的眼裡，只要定義一些抽象，產生一些迂迴就可以解決問題了,這些迂迴(實際上就是產生一些高層邏輯，這些邏輯就是具體某個設計模式中的某些角色Acotr)可以讓我們clients通過這些高層迂迴避免直接接確到低層的實現（雖然我們client無論如何最終是要進入到具體實現的，但我們可以不直接而間接迂迴地進入啊！！這些低層的實現就是現有代碼了，是實現部分(可能是某個你要使用到的第三方庫代碼)，我們經常要對實現部分修改，或者說對現有代碼的修改,而要求要有最少的工作量，而一個沒有定義抽象或者沒有定義好合理抽象的工程要涉及到很多修改工作），而這，，真真實實就是解偶的意義所在。。<br>我們再來說這些邏輯，其實這些邏輯都可以稱為中間邏輯，，然而這些邏輯的地位又是不同的，，有與具體實現接近的那一端的邏輯，，這些邏輯也是高層邏輯，，但是把與接近client使用者的邏輯看作為相對更高層的邏輯。。<br>說個故事吧！<br>《西遊記》大鬧天空時，要求當天庭大官，太白金星向玉皇獻記說讓孫悟空當弼馬溫，太白金星的智慧就體現了開閉原則，一方面，在孫悟空方面，太白向孫悟空說明玉皇已同意他上天(對擴展開放)，，另一方面實際上只是給了他一個放馬的差，實際上按天庭規則(系統原有結構)孫悟空是不能上天的(),然而迫於孫悟空的力量(修改的需要),太白只是稍微迂迴了彎子(增加了一層抽象)，就暫時平息了玉皇(玉皇本人不知道如何擴展這個需求，因為這是與天規相背的)和孫悟空二邊.<br><strong>8.13 真正的通米特原則</strong>之所以不稱通米特原則為通米特法則是因為在設計模式領域內實在不存在一個法則之說，<br>通米特法則也稱為最小知識原則，一個事物對另外一個事物知道得越少，那麼它本身就越安全(這可以聯繫武俠小說裡小人物碰巧目睹了對殺手殺人的整個過程，那麼這個小人物就會有殺身之禍，)，<br>這裡的安全是指對修改關閉<br>實際上無論對象組合還是繼承都會造成類與類之間的引用，都會造成不可複用的問題，然而，相比繼承來說，組合可以極大地減少這種複用的偶合程序，而繼承壓根就是不可分離的，因為本質上組合是一種Has-A的關係(組合對象與被組合對象)，而繼承關係是一種Is-A的關係(基類與繼承類，或稱父類與子類，注意這二個概念還是有點區別的，一般說到父與子關係時就是指父對象與子對象，而說到基類與繼承類時往往描述類與類之間關係的用詞~~)<br>還有一種關係是Link-A的關係，這種情況下的不可複用性按情況下來定，，Is-A的準確意思是什麼呢（這裡的意思指語義）？如B is a A,,那麼“B是一個A”，，可能是一個A，但是不一定必定是一個A.而且如果B是一個A，，那麼反過來就不能成立（子類化，雖然站在類型轉換的場合下可以但是現實生活中這樣理解不通）<br>一個代碼的修改量應只取決於它最低層的實現，如果某個低層引用了過多高層邏輯接口的實現，那麼這隻能說明，對這個實現的解偶還沒有規劃到家，理想的情況是，應該只讓這個實現的修改不觸動到任何間接使用它的高層邏輯！！(因為自頂向下的引用對於頂來說，如果底部被修改頂部是不用作任何改變的，而如果是自底向頂引用，那麼當底發生改變時，一定要涉及到頂部也要改變，，而這就是不恰當的高層抽象，違背了好萊塢原則和通米特原則)</p><p><strong>8.14 真正的好萊鎢原則</strong>好萊塢原則（不要給我打電話，我會打電話給你們）強調高層對低層的主動作用，即低層應該只管好自己的工作（具體實現），而高層自有它自己的工作（這就是管理低層的邏輯們，或者說從client到具體實現的一系列中間邏輯），在不需要到某個低層的時候，高層並不會調用到這個具體低層，低層永遠不需要向高層作出表示，，說它需要被調用，，(即在所有的處於使用者與現有代碼的中間的,用於隔離和解偶二者的,那些中間邏輯中，低層邏輯永遠不要涉入高層的實現，而只要高層通過某個邏輯去涉入低層的實現，也即低層應不要調用高層，只有高層才會去調用低層，這才是合理的，我們應儘量避免向上調用和相互調用).<br><strong>8.15 真正的策略模式</strong>Open和close一點也不矛盾，當它用在同一個架構上，open指出這個架構的可擴展性，而close指出這個構架的內斂性，open是相對高層來說的，，而colse是相對內部實現來說的，，，一個構架應對高層open,而對內部實現close,,,<br>策略模式將可變的行為集封裝起來，這符合OO封裝“可變部分”的原則，可變部分就是實現，我們修改一個軟件直接修改的就是實現，而非抽象(實際上也不應該也沒有必要對抽象進行修改，如果你的工程存在對抽象的修改，那就只能說明，當初在定義抽象的時候壓根定義的抽象就是不合理的抽象,真正合理的抽象將使用者客戶和現有代碼極大地解偶，這使得以後的修改工作只需在低端實現進行而無須觸動高端).<br><strong>8.16 真正的觀察者模式</strong>好萊塢原則指出，類之間應儘量避免低層(實現)向高層(抽象,邏輯)的引用，<br>觀察者模式中，觀察者，被觀察者，一個被觀察者管理諸多對象(觀察者)，這些觀察者通過<br>.<br><strong>8.17 真正的裝飾模式</strong>裝飾模式就像是一個用類來修飾類的機制(這就添加了新的職責到被修飾的類，，這裡說的修飾本質是什麼呢？就是類的組合，讓一個類被修飾者成為修飾者的一個實例變量)，，，這要求修飾類(可能是多個)和被修飾的類有一致的接口(也即它們同共都曾實現implent了某個接口，或者繼承了某個有接口作用的抽象類extend,,這樣一來，就可以在動態運行時用一方代替另一方，然而客戶並不會知曉其發生過內部的替換)<br>裝飾模式可以讓很多具有對等地位而且擁有共同接口的類進行有窮互飾，這樣可疊合多個類進行某個共同的接口作用,並獲得最終的修飾過的這個成員作用<br>.<br><strong>8.18 真正的單例模式</strong>某些只能夠擁有一個實例的類對象必須通過某些方法來保證它在程序運行期只有一個單例，而且，更重要的，，必須提供一個全局域訪問入口，這個入口必須是類層的，，<br>通過這個全局域訪問點，你可以直接調用類的某個機<br>因為它的產生實例的構造函數是私有的，只能從類的內部去產生和獲取這個實例,換言之，你不可以通過繼承或組合的方法去獲得一個實例，而且這個方法往往被定義為fina,,也就是C++語言中的CONST,即子類不能覆蓋它，<br>因此，可以用類方法(也即靜態方法)，這種方法下，從繼承<br><strong>.<br>8.19 真正的迭代器模式</strong>如果你知道什麼叫遞歸和遞推，那麼迭代器本身這個概念你是很容易理解的，迭代器跟集合(集合就是通俗意義上的對象集合，雖然存在很多不同質的集合，比如用數據結構表達的對象集，或者用函數索引的hash集，但是只要是集合，它的內在總有一些對象及對象邏輯，對象邏輯就是操作這些對象的根據，比如遍歷算法，而至於本象本身，可以是無意義的對象，或者同性質的內存節點，或者離散的東東，然而上面說了，這些集合內部必有一種方法作為邏輯可用來遍歷他們各自內部的對象，)的關係就是：無論是什麼集合，它都可以把一種抽象抽象歸納出來，就是遍歷它們各自內部對象的算法<br>所以，對抽象的提取，往往是找相同的部分，把這些相同的部分提到高層，而用這處抽象來封裝可變的部分(這裡指各個集合內置的不同的遍歷算法),這樣就形成了一個所有集合能共享的遍歷接口(當然這個接口並不為集合所用，集合自有它們自己的遍歷算法，而是為client所用，不同的client都能面向和共享一個共同的,使者這些集合來進行遍歷集合的算法，而不必管這些集合自身具體是如何遍歷它們自身的元素的)<br>.<br><strong>8.20 真正的工廠模式</strong>工廠模式用來實例化對象，，，可被形象理解為一個封裝了專門用來產生對象的某種邏輯(這種邏輯可以是一個方法的形式存在-這就是工廠方法模式，也可以是一個類的形式存在-這就是簡單工廠模式),因為大凡產生對象的過程都是低層的(調用New方法實際創建實例對象，屬於實現)，它壓根就不應該跟高層(這裡的高層指的是需要引用那些實例或間接引用到那些實例的抽象或更高層抽象，由於一個類只能負責一種責任，一個抽象只能被作為一個類，因此當有多個抽象存在時，有必要將它們按職責分成不同的抽象層次，形成不同的層次類放在一起.<br>這個道理就像：我們生產出一系列的東西(我們當然可以把這個產生過程直接放置到某個未來應用中-這個未來應用要使用到產生過程中產生的對象，這樣一來所謂的“某個具體未來應用”就會跟產生對象過程直接掛鉤，因此我們把產生對象的過程獨立出來，歸納它為專門的產生對象實例的過程，而應用這些對象的一些應用--雖然不知道未來會有多少應用會存在，而這個“不知道”的說法，本身就反應了它符合未來的擴展性--放置到另外一層去)，然而會有其它一系列<br>.<br><strong>8.21 真正的門面模式</strong>門面模式也稱為外觀模式，它提供一個易使用的接口作為它的外觀，只是為了使現有代碼client和要使用到的對象集(往往是多個具有不同行為不同接口的對象)通過這個接口(製造出的目標接口)能被更簡單地使用而已，也即打包某些對象行為(並透露出一個基於高層應用邏輯上的接口),常跟適配器模式放在一起被討論，因為它們都是為了提供接口而存在的，，適配器模式是轉換接口為了“能夠被使用”，而門面模式是簡化接口為了“更好地被使用”(讓被適配對象被client被使用，通過一個目標接口-注意這後半部分的說法才最最重要的)<br>.<br><strong>8.22 真正的命令模式</strong>將命令本身封裝起來作為一個對象，讓它的調用者(注意這個調用者不是客戶Client,Client是模式之外的使用者，而是命令模式中的一員Actor，是這個命令模式抽象層中的一層)和命令對象通過對象組合的方法<br><strong>8.23 真正的模板方法模式</strong>模板方法用一套模式作為定義方法和行為的大致框架(注意是大致，而不是全部，這個機制就允許掛鉤，和一些需要它的繼承子類實現的抽象方法),這跟策略有一點相似之處，因為他們都封裝了作為可變部分的行為，然而它們之間還是有差別的，<br>然而，模板方法使用繼承模式，而不對象組合模式，模板方法因為是一個抽象方法，因此如果有子類繼承它，那麼這個子類必須要實現這個抽象方法<br><strong>8.24 真正的適配器模式</strong>Adapter，不是接口的意思，它更準確的意義應該是適配，真正的“接口”在不同的應用場景下有不同的意義，現例舉如下：<br>1,Java的一種機制，這種interface語法是一套抽象機制，如果實現<br>2,接口類，這些接口類往往是抽象類，<br>3，二進制複用的接口,比如COM,也就是構件接口<br>4,接口方法，某個class非private的方法（無論是抽象的還是帶有實現的都可以稱得上是一個接口,一般是指抽象的成員方法）API都可以是一種接口<br>5,邏輯模型，通俗意義上的“抽取歸納”某個接口，或者說是高層入口，通過這個高層入口，所有的<br>以上只是為了不跟OO中的接口相混淆，所以強行把適配器模式說成是適配，，其實適配就是適配二個擁有不同接口對象的接口對象(也即這個產生的目標對象“接口對象”也是一個接口，)<br><strong>8.25 業務與邏輯分開</strong>業務就是你做軟工的設計階段時,所要明確的"邏輯本身",界面就是"表現此邏輯的應用形式"(面向用戶的一端),也即邏輯是"我們要搞清的問題"(面向低層的一端),要解決和麵向的問題領域,這個所謂的"問題"是嚴格的,它決定了我們在編碼要體現什麼樣什麼維度上的功能.因此在設計中,"搞清你要實現的問題"永遠是重要的<br>另外一個概念是數據,數據處理邏輯要做成獨立於界面和邏輯的,此時要提出一個架構,進行新舊系統的分合與整離,讓應用統一於某種低層邏輯或界面形式,或由這種架構創建新的應用.<br>現在的網頁,即使它用到xml做數據源,也是不完全的"業務與界面分開",我們應保證"如果一個頁面被刷新,那麼那些不與數據相關的界面元素根本無須變動",這就是徹底的分開<br>這種理念可以讓網頁反映速度提高很多倍,,應用的多元化絕對是可以被統一的,只要你能提出一種合理的架構,架構的提出不僅是一種IT觀念改革(對某個抽象有了新的認識),而且是一種極大創新的活動(人們可以由此發展出很多改變了形式的應用).<br>多少人明白domain這個詞的意義呢,如果泛化起來,會是什麼意義,任何問題求本溯源就是一個世界,一個領<br>域)其實domain這個詞是在原語領域描述事物分類的,每個事物都有一個name,受某個domain類name來管理,因此,以什麼粒度以什麼元meta來分類事物並命名以產生一個命名機制呢,就是domain name這個詞的由來,(元是老子提出來的,古人希望把世界的本質用元這個形式形式化下來)<br>Java的源程序文件夾也是這樣,你難得找到一種命名為你的所有大大小小的邏輯命名並人為區別,所以sun找了一個domainname形式,,分類學與命名學是對軟工尤為有意義的,,只有sun意識到了它<br><strong>8.26 架構不是功能的要求，但卻是工程的要求</strong>所有的術語都可以被重新定義，，遊戲是什麼，，其實火星人可能也在玩一種叫＂遊戲＂的東西，，我們的ＢＢＳ論壇也可以和魔獸世界一樣被歸為網絡遊戲，，，這就是重新看待一個領域的抽象，，給一個術語重新格定它的含義的範圍，如果性質相同或相似，，就整合它們，再發展形成一個架構，將它們發展成此架構下的分支實現，，比如facebook,它以技術的形式統一了很多web2.0的應用，，，這就是說，應用這個東西，，是可以以技術的形式被統一的，，，從架構web2.0的眼光來看，，blog,視頻點插，，，諸多web2.0應用，，都可以被看作為web2.0,,,<br>這種分離與整合現象其實在ＩＴ界每天都在發生，，以上facebook是個例子，還有adobe的Java developer ide? ecillpe??,Java?平臺開發庫將內存流，網絡，本地文件都看成＂流＂，，這就是對一個術語重新進行定義，格定它的範圍，，而這是合理的，，因為我們對一個術語的定義本來就是歷史現象，當歷史發展了，，一個術語要麼被增加新的內容（量變），要麼被完全演變，，成為一個新的術語（獨立發展成一個新東西，雖然原來的那個術語也有效）<br>?我們所看到的概念，，如果重新被設計，，會產生很多新的抽象(在另外的維度上甚至會產生更多抽象，只不過我們是人，有限的生命不能允許我們同時或異時站在多個維度去想東西)，，和由此而生很多應用,,這就是sun所玩的遊戲，，比如它提出一個"xml",,實際上xml的最高境界就是＂文檔互換的標準＂，，由於xml的成功流行，這由於它是符合應用的，它就成了標準，實際上如果隨著歷史發展，xml就會過時(Ｊnos出現了)，，xml只不過是人類知識的臨時品，，，總會有它的代替品出現，xml相對"文檔交互的標準"這個說法是個實現，而＂文檔交互標準＂這個說法是個思想，一種思想反映在ＩＴ界，可以用代碼實現（細節級的），，也可以用構架來形成一個觀念上的應用規範，，比如ＸＭＬ規範，，這種思想一定要理解，<br>火星人也把他們玩的一種東西稱為＂遊戲＂，，任何到現在為止我們能耳聽目見的東西，，其實都不像我們想象的一樣簡單，，當你學習西紅柿的單詞時，如果你不能瞭解到它其實是一種外來詞，，這種現象，，這種對一個術語的＂歷史抽象＂，，那麼你就不能有效地學習它，只能說片面瞭解了它，，而這對學習是不利的?<br><strong>8.27 你需不需要一個庫</strong>IT開發中,,只有屬於底層開發的,,,一般才稱為開發,,發明輪子,,,而複用成風的今天,JAVA這樣的語言體現的是一種高級邏輯配置式的開發,當然也算開發，，所謂庫，是一種面向通用和複用的中間邏輯，，接口邏輯，而非終極的應用邏輯本身，，，庫面向應用複用提供接口，而應用邏輯面向應用本身．語言的功能和可複用性，，一個很重要的方面是除了語言自帶庫之外，還有沒有第三方為它開發大量的開源庫<br>所以,如果你不是專門為了通用的目的考慮,就根本不需要開發一個庫</p><p><strong>8.28 可複用與可移殖的區別</strong>在相關書籍中，存在很多相似但其實有很大區別的概念，比如可移殖與可複用，接口與實現，接口與抽象，下面試區別之。<br>在一個大型軟件系統中，抽象是分層次的，，粗略地來說，有的抽象是系統平臺相關的抽象，有的是對於目標問題領域的抽象。注意這個區別只是粗略的絕不是精確的（所以也可說是無層次的）。<br>設計中經常將實現和抽象分開並各自集中，如果抽象中過多地混入了細節考慮（即有硬編碼和實現出入的地方），那麼它必將在以後的擴展過程中產生麻煩，因為對於一個龐大的軟件，其內部邏輯複雜，牽一髮而動全身，語言給於實現和抽象形式上的劃分方法只有頭文件和CPP文件這樣的初級方法。實現和抽象的分離從來都高度掌握在源程序的作者手中，我們知道，抽象不全是為目標領域作抽象，有一部分抽象是為接口作抽象，也就是為可複用的有效形式作抽象，即接口是抽象的一個部分，是抽象的簡單形態，，其目的是為了給使用它的客戶提供一個複用（或實現）的原型和規範，比如庫，函數API，這裡的客戶是程序員用戶用戶。（但是像虛函數那樣的語言內接口，又不完全是為了面向人的複用，而是為了面向程序內邏輯客戶的實現。這個客戶跟據這個接口產生出一個關於這個接口的model），如果不是庫，則不需要提供接口設計，而實現是未端抽象（這就要求設計者具有良好的對系統的可複用考慮的設計能力）。更多的關於接口與實現的區別在文尾有述。<br>在一個複雜的軟件系統中，可移殖邏輯主要集中在那些與系統編程相關的邏輯中，而不是對於問題的領域設計邏輯（雖然如果對問題的領域設計，，抽象得不得體的話，這樣同樣會導致不可複用問題，但決不會產生不可移殖問題）。比如對某語言密切有關的字串邏輯的依賴，對某平臺密切有關的某個socket..鑑於對不可移殖問題的考慮，，我們往往將它與領域邏輯分開。所以可移殖問題只是可複用問題的一部分，二者絕不是同一意思。<br>所以，應該怎麼樣做呢？這樣才能同時達到可複用，又最大程度地可移殖。(當然，只能是最大程度地這樣。)<br>編程涉及平臺支持和目標領域問題。一個用編程語言寫就的，用OS運行的，“軟件系統”中，必將大量存在這樣的“平臺編程邏輯實現”，相比之下領域邏輯少得多，(我們將由領域邏輯主導實現邏輯。)。<br>一種方法就是廣為談到的“抽象與實現分開”，我們需要將各個“實現”按文件物理地分開放置（此文件將會是引用的未端，不被“設計”直接作為頭文件引用，而是作為最終可用可棄的實現未端，由它引用目標領域邏輯）。當然這個過程中，我們應注意模塊化（所有的編程範式都是模塊化的），然而正如上述所說，模塊化不能複合，不能高下相互引用，比如“設計”引用“實現”<br>。（因為設計中有自上而下和自下而下，故也不存在各個模塊之間平等不相互引用的情況）但是如果不考慮最終軟件系統的實現的話，光就設計來說，確實也存在各個設計模塊之間平等絕不相互引用的情況存在。<br>除了上述不可複用問題來源於不可移殖之外，還存在以下幾點不可複用問題產生的源頭：<br>解決不可複用問題的方法是增加迂迴（一層抽象接口），將實現逼回底層，這個動作出現在二個過程中1，對於目標領域的抽象過程中，2，對於重構時的過程中。<br>然而，所謂的迂迴，其實也是系統中的抽象，，也會對可複用產生障礙，一定意義來說，系統中抽象層次過多，，或數量過大，都會直接對可複用性產生麻煩，這為了解決不可複用問題而設計的另一層抽象正加大了某種程度上的不可複用性。所以是一種以毒攻毒的方法。解決問題的方法正是產生問題方法的來源。<br>不幸的是，語言機制也會造成不可複用，比如模塊就沒有函數來得可複用性強，然而複用從來都是相對的，存在一個比較時所採用的最小考慮單元，僅在C++語言內部而言，模塊是可複用性很高的，在所有語言面前，函數接口和過程式開發無疑是複用性最大的。。這就是linux之父跟別人爭吵的源頭所在。這也就是說，C++的抽象性能反而帶來了不好的地方，越抽象的東西越會阻礙可複用性。<br>當然，最後，抽象的方法不同，產生的抽象結果不一，由此產生的不可複用問題是最嚴重的。因為複用者一需要理解你的設計抽象，，在理解了之後，才能進行復用。如果你的抽象過於複雜，複用者不會有太多興趣。<br>編程能力就是學會如何面向可複用考慮去進行抽象。當我們設計自己的系統時，為了提高它的最大可複用性，我們將它設計為與語言無關，與OS無關，與複用的庫無關。這種工作是相當難的。設計中的目標問題抽象永遠是自己的。那麼如何將這些如上的“實現”逼到未端呢？<br>首先，要想做到與語言無關，就要用那些最初步的語法機制和開發範式，比如函數過程式。三種控制結構（事實證明它們可以產生一切邏輯）。或者自己開發一套自己的語言，在自己的語言領域之內作“固步自封的複用”。但我們知道，這（當其它語言不存在）實際剛好阻礙了其它語言對其的複用。<br>其次，要做到與OS無關，當OS不存在吧，不要引用OS的任何東西，，，照樣是在自己的語言的基礎上發展自己的GUI庫，等(這實際上也是很多語言提出可移殖理念最初的出發點)，一系統的系統平臺相關的庫。<br>要做到與可複用庫無關，只有自己開發功能相當的庫了。即一切輪子自造，包括語言。然而你可以改造語言，卻不能改造英語編程語言，那是一個未知領域，你更不可能在馮氏模型之外發展這樣的語言，你不能改造PC模型，也不要指望改造OS，更不要指望改造電腦的能源為光腦。<br>所以，一切好自為之吧。既然輪子的創造是一個無底洞，，何不直接就複用別人的庫呢，用大家都用的語言呢？更重要的，作大家都在做的領域設計方案。這樣別人才能理解你的設計。<br>接口是實現的原型，，一般談到實現，就是一個複雜系統中的終極未端邏輯，意指其不必為複用留有餘地(因為複用就是利用接口作進一步的抽象，複用跟接口密切相關，所以實現也指不必為接口設計作餘地)，一般談到接口，意指為下一步的抽象提供統一的原型和形式，即為如何複用提供設計，<br><strong>8.28 再談可複用</strong>可複用問題的由來一是實現的不能可複用(還記得在C語言中寫上大量的預處理代理來實現跨平臺邏輯嗎?)，二是架構邏輯的不可複用，，，，實現指的就是跟計算機離散相關的平臺邏輯，，架構就是人為為程序的可擴展性加上的設計邏輯，，大多數是OO之後的東西，，我覺得提出二門語言，一門C，一門類RUBY的腳本語言來進行程序的編寫,,,,在底層用C,在高層用OO腳本,這樣的辦法很好...因為你在低層不需要架構,,而只要在高層考慮架構問題.,,這樣一來,可複用性就是二個階段的事,前一階段只管實現,不考慮設計,,這種過程是承接性的,只要先實現了,才能被設計得架構上更科學.<br><strong>8.29 真正的可複用</strong>可複用到底追求一種什麼樣的效果，又能最終達到什麼樣的效果？運行期的效率或重構期的不可複用和窄擴問題（這是二個並非絕對統一的東西），一切都可歸究到設計期的問題。<br>編程界的可複用主要是面向對象和構件複用和設計模式和設計複用，庫也是語言內部的可複用(就跟你擁有庫的源文件一樣.因為有頭文件也是一樣的，因為你還至少清楚庫的構架,這也就跟理解並應用一個庫只需瞭解其API就行了但不需要了解其SRC級的實現一個道理.ode的頭文件集卻是一個例外),COM的複用就是純粹的二進制的複用，因為有真正的接口的隔離作用(此時你根本不知道庫的構架)，在庫定義的接口中，你必須透過接口才能深入接口更下面的邏輯(可能是另一個庫的實現)，因此接口一方面提供了方便性，另一方面也增加了屏蔽性，這是一對矛盾,接口的定義是為了引入某種架構或橋接二種架構使其配合工作，而這種機制在提供了方便性的同時也增加了理解和使用該接口的複雜性和運行時空的代價。<br>用OO來表達世界的觀點,,,物體可以組成世界（所有其它的東西，比如物體之間的關係也是另一種意義的物件），，，因此編程抽象了OO,那麼編程就可以用來用計算機模擬世界，這種思想是成立的。<br>庫的組合=功能的組合(類庫設計是一種跟語言同級的設計)，當然這種邏輯在使用同一種語言下是成立的(不同語言時也可以用Swig等技術來改造或Bind)，然而庫作為中間邏輯的封裝者(庫讓你跳過庫的實現即中間邏輯這些細節而直接面向大邏輯大架構編程,只要引用它們就可以在自己的程序中實現它們)，可以一直細化接近最終實現,誠然單邏輯的一個類也可以被封裝為一個庫但是往往不樣做，一個庫封裝了一套互飾的中間邏輯的有機組合，,這裡的中間二字是相對最後的應用邏輯來說的，往往把最終的應用邏輯稱為實現，這就是一種實現邏輯了而不再是中間邏輯了(這就是說庫可以是一種內含高抽象的架構邏輯或具體的工具函數的實現邏輯，或基於其它庫之上的架構邏輯或實現邏輯)，庫可以直接深入到實現細節，但是我們要控制這種過程，一方面是中間邏輯與最終應用邏輯不可精確定界，另一方面是因為設計與封裝是個無底洞，不必做這種深入，第三方面是有其它的庫可以plug進來然後在這些“輪子”上實現（庫應只提供BaseGeneric這個庫構架(此時庫本身是一組架構邏輯而非實現集)和對一些其它外來支持庫的引入接口(一般接口需實現，邏輯需繼承,此時其它庫可按需進行plug in 或者out)，這就是庫引用庫，這種情況下有一些未端的實現是不應該加入中間封裝的,比較好的作法是用一個庫定義架構和基本工具函數集，以及對其它未端工具庫的接口邏輯(此時先前定義的那個庫就是主庫，其它的庫是可選的輔庫,比如Yake的實現就是這樣），實現就是最後一節提到的幾個Demo(作為基礎的邏輯已經被庫封裝起來，其它的就是實現了)<br>像Yake,它提供了一個Base core和很多構架上的接口邏輯，每個接口邏輯都實現了一個對外來庫的引用，Base core是工具函數集(也有一些接口邏輯),這是Yake的主體部分,而接口邏輯(Yake也在這裡實現了一些工具函數庫比如)和對其它庫的引用邏輯(也是一些Adapter)才是Yake的重要部分(Yake包括它的base和對其它庫的引入邏輯這二大部分,當然還有它的一些工具實現，這樣算起來Yake有三大部分).<br>接口是可複用中一個很重要的概念。<br><strong>8.30 你能理解XP編程嗎</strong>大設計是一種動用一切資源，從整個思想領域去設計計算機應用的過短，，這完全是一種預設計，編碼過程變成了純粹的被設計預見的集成的一個過程，，這種設計往往首先從思想出發，，完全不考慮計算機實現，語言機制對應用的限制或表達能力，，，提出一種標準和理想模型，把思維過程出現的任何一個過程都作為設計的一部分，設計過程中任何動作都不跟計算機和程序語言相關，，最後僅留一點餘地作為編碼，在編碼時考慮其跟計算機實現和語言機制實現的結合，編碼的地位很低很終端。。<br>XP編程出來的時候，，人們大呼設計已死，，因為這種邊設計邊編碼（在編碼中形成設計）的方法大大忽略了設計超越“編碼”的“預”，，設計變成了跟編碼並行的過程。。<br>實際上，該如何處理設計呢？？比如設計遊戲。。<br>我們知道設計是無底的，這種無底性決定了我們應有限地把思維中出現的理想設計和想法體現到計算機邏輯和語言機制能表達的邏輯中，，，而且應儘早地這樣做，，任何應用領的邏輯都要最終被轉化成計算機邏輯和語言邏輯。。也即，我們不必做超級設計和完美設計。。<br>遊戲是什麼呢？如何設計一個遊戲呢，，遊戲這個字眼可以無限被放大（應用領域可以無限深化），WEB論壇可以是文字遊戲，3D遊戲也是遊戲，，網遊也是遊戲，，是不是要在你的設計中體現這所有的元素呢(一個具體的設計總是針對某個應用域尋求它在計算機和語言域的對應，如果你知道算法和數據結構你就深刻理解這個說法了，我們總是向語言和OS中尋找某種可能適應我們問題的數據結構，即使再通用的邏輯，比如庫的設計，我們也不應)，並用一種“設計模式”中的模式來組織這所有的元素呢，，不能，，而且不應該。。你不可能在有生之年把它們(設計中出現的需要組織的邏輯們)的地位作一個組織或你自認為合理的排列。。<br>你可能會說我不直接提供這些無素的實現，，不直接在設計中體現這些，我只需預見它們，，並在設計中為他們預留接口，，但這樣也是不行的<br>那麼最後出來了，，什麼是XP編程<br>預設計，大設計是一種“一次性設計”，企圖把應用設計中的大大小小所有過程整合到一個大設計中，，，這樣的代價當實際編程開始時如果遇到不能前進的錯誤會損失很大，而且設計本身花費精力也不少<br>而XP編程先是提出一個不夠完美的框架(針對某個應用，有應用本身和它產生大大小小的其它應用問題，這不夠完美的框架是針對整個應用本身來說的)，或者不提出思想模型，，，它並不試圖分析整個應用，，以及對它們的設計（因為它相信設計不可能是一種大而全的，只能具體問題具體分析設計，人們不應把所有可預見或在後來出現的問題整合到同一個設計中），，並不著手預見可能出現的問題和對它們的大大小小的設計過程，當具體應用問題中的大大小小問題出現時，就著手一個即時設計(比如設計遊戲時，這是個具體的大的應用問題，針對遊戲本身可提出一個不夠完美的框架，，當在他下面遇到有很多小問題，，比如網遊時間同步，，我就看語言中提供了什麼線程和語言機制，或者如上面說的數據結構或算法，來進行一個小設計)<br>這就是XP編程的全部意義所在。。</p><p><strong>8.31 構件與接口，軟工</strong><br>UML,IDL,MDA,COM.CORBA,WEBSERVEICE,XML軟工新潮流<br>關於接口,也發展出一種語言叫IDL,,語言跟應用的關係是什麼呢??因為語言可以接上計算機處理跟人們的應用需要之間的接口,,所以語言和編寫語言下的程序成為擴展計算機也擴展自己的手段,,甚至還有DSL為了解決特定問題而產生的一種語言,語言的實現即編譯器,語言規範等,,<br>而MDA是不同的概念,MDA是給定一個領域的描述,,然後寫出一個依賴於接口的xml格式的web services.<br>這直接促成了構件的產生,,,在SOA中,因為要集成新老系統,當構件作為一種比對象還要大的軟工邏輯粒度時,,它們共同需要都需要接口,,但是構件<br>不要小看了這個構件？？它幾乎可以是一場軟工變革，跟OO有相平之處<br></p><div class=pgc-img><img alt=新手編程導論（九） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0bf11efddc9d41d1908a368d1c11824c><p class=pgc-img-caption></p></div><p><br>編程與範型（設計）<br>初始OO,我不過認為那是一種編程語言支持的工具，，真正懂得它時，我發現我走入另一個迷惑，一個更深的迷惑，，如果OO是一種思想，，，所以我要怎麼用語言去聯繫它？<br><strong>8.32 設計方法論</strong><br>“在原語空間內進行設計”前應該是現實世界問題域，在“產生最終類文件”後應該是編程域的OO解(或其它範型解)，即設計的FrontEnd面向的是用戶，設計的BackEnd面向的最終是計算機，這中間的“原語空間設計”，“多範型表達設計”，“ROSE工具實作範型”都是“設計演化”，即設計是一種從用戶到機器的抽象過程（它包括前面提到的三個主要過程,原語設計是從上到下，泛型設計是從下到上,明白這個道理有什麼用呢？這至少可以解釋為什麼好的架構可以擴展出足夠豐富的未端實現，因為從架構設計到功能實現是互通的，這二者不是矛盾的相反是統一的，明白這個道理還有什麼用呢，這也可以解釋為什麼Yake的BaseGeneric不是包含架構邏輯的Generic,而是一組與平臺native本地有關的DLL引入邏輯，數學函數，Logging機制什麼的，這是因為需要先提供這樣一些實現，才能獨立平臺，而這是Yake首先要解決的問題，因此只能把這層邏輯放到最低層再慢慢發展其它抽象，另外，YAKE使用的庫中，比如OGRE和ODE就用到了數學函數（並非所有的問題都能靠提供架構和中間抽象來達成並解決，因為有些問題不是要不要封裝和不封裝的問題，而是能不能實現的問題(能不能用OO來表達跟能不能在算法等級實現是二個不同領域的問題，一個是軟件的設計，一個是算法，前面提到了這二者之間的區別)，比如一種算法，什麼是架構什麼是實現，這裡是一個很好的區分例子），底層必須先解決並提供這些抽象，以我來看，Yake真正的主體不是BaseGeneric,它是基礎而不是主體，它的主體是對其它庫的引入邏輯，這才是Yake的架構邏輯,因此說，架構邏輯有時僅僅是被體現，而沒有並封裝成DLL，也即，架構是否被體現與它是不是要被封裝成為一個庫是沒有必然關係的，哪些沒有表現為庫的中間邏輯也可以是架構邏輯，明白這個還有什麼用呢？原語設計是不受限的面向用戶的設計，然而當進入多範型設計時慢慢轉入用計算機的觀點來看待設計，因此像Yake這種與平臺息息相關的表現邏輯必須在底層就解決平臺抽象和數學抽象，而LogicGeneric就根本不用考慮這些，因此多範型設計相比原語設計來說，它是從下到上的），而實現是一種從機器到用戶的過程(實際上我在這過多強調設計與實現的差別是不對的，因為這二者無法精確定界，然而如果所有中間邏輯都被封裝為庫，這二者差別就很明顯, 庫作為中間邏輯可以參與進來以縮小這二個過程差距，把應用架構稱為設計，把中間邏輯封裝為庫(架構也可以表現為庫)，實際上在這裡，中間邏輯與最終實現才是對立的說法的二方，設計與編碼才是另外二個對立物(設計就是原語設計而編碼就是多範型設計)，<br>設計演化（從問題到類），，實現演化（從類到問題），，前者是從人到機器，後者是從機器到人<br></p><div class=pgc-img><img alt=新手編程導論（九） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf45622811084954bb953f2b2f46c75e><p class=pgc-img-caption></p></div><p><br>邏輯互飾構成的邏輯的巨集組合，就是一個越來越接近應用總邏輯的大邏輯，(上下互飾就是誰更接近應用邏輯的道理,至於最終應用邏輯前面的邏輯，都可稱為相對的中間邏輯)<br>然而設計與中間邏輯不是沒有關係，把庫外的未端邏輯稱為實現，在這種說法下，基於庫之上的實現跟設計共享同一些中間邏輯，庫使這二者有機結合不產生縫隙，當然作為泛義的庫是縮小任何二個架構之間差距的機制)，其實在“ROSE工具實作範型”之後還存在一個“設計載體與設計方法”，即UML圖，或卡片啊(設計載體)，設計方法主要是“找事物的共同點與不同點(就是多範型設計那本書的作者提到的)”，還有就是UML教學中出現的“給出一個句子，找出主語謂語等”(其實這些方法歸納開來就是做列舉題和判斷題，列舉出一些細節，再判斷它應屬於那個接口中,這在第四部分“確定GameGeneric應提供什麼樣的高階接口”那一節有清析的講解)<br>實際上我的思想和說法比他們還要超前和規範一點，原語設計三種思想（抽象，原語，組合）就包括上述的說法(找事物的不變點就是指抽象出事物的本質,這是設計過程中一個很重要的能力)<br>在觀察者模式中，<br><strong>8.33 真正的interface</strong><br>正如對象的索引才是真正的對象一樣(C++中提倡使用引用優於指針)，對接口編程才是真正的編程工作，一個程序員大部分情況下只是一個接口粘合者(因為我們不需要重新發明輪子，發明輪子-中間邏輯的工作才是真正的對實現進行編程),發佈時我們也是發佈接口庫和其說明文檔，大多數情況下,我們都是利用第三方代碼庫編程（這是語言之外的接口，程序員也在語言內部編制函數等接口）<br>接口設計是一個編程工作中常常要考慮到的問題,要考慮提供這個接口的實現會在什麼地方會用到(因此它跟需求分析密切相關)，以此來設計接口的參數信息,一個接口不單單是一個函數，雖然函數的聲明部分在大部分意義下作為接口的意義,,,,<br>所以delphi的單元中有實現和接口這二個字,,,接口的集大成者是COM，所以borland以它的IDE很好地支持接口而著名<br>這是語言之外的，<br>設計一個面向需要程序設計語言永遠是不可行的，需要永遠是可變的，程序設計語言只能遵守一個固有模式而提出，有固有模式去表達和創立新東西(面向對象就很不錯)，編程是人的動作，人力對工程（一個大軟件就是一個工程）的控制應該儘量簡化，<br>特別是要掌握對象(或稱工件與產品)與接口-組件（對象接口與組件接口是不一樣的）概念所在，前者是語言內部的，後者是語言外部的<br>在內部<br>純數據對象稱為死對象,(可用但無用)純實現對象稱為工具對象，不可用<br>在外部<br>純接口對象稱為抽象對象,(可用但無用)純實現對象稱為工具對象，不可用<br>面向接口，(一個一個的接口，函數稱為函數接口)接口歸接口，實現歸實現,實現不是函數<br>軟件就是包裝器,就是一大堆接口的有機組合,不提供繼承機制<br>一個類型的數據可以獨立構成一個數據結構<br>對數據結構的描述包括它的類型，它的結構，它的存取規則<br>軟件設計是一種什麼樣的過程？<br>軟件就是對象組合,這些對象通過他們的接口按一定邏輯組合成可工作實體<br>在語言內部的繼承是對象，在語言外部的繼承是組件<br>對象的概念，包括函數對象，變量對象，數據也是對象(作為一個元出現在一個特定的數據結構裡)，因此數據結構也是對象，操作實現也是對象，實現稱為處理器，數據或實現的組合也可稱為對象,注意，對象的組合只能是被稱為對象組合，只有那些能在一起工作的對象組合(compent view)才能稱為軟件，這裡引入工作邏輯的概念(就是ROSE中的logic view)<br>在內部<br>純數據對象稱為死對象,(可用但無用)純實現對象稱為工具對象，不可用<br>在外部<br>純接口對象稱為抽象對象,(可用但無用)純實現對象稱為工具對象，不能由它派生出實例<br>面向接口，(一個一個的接口，函數稱為函數接口)接口歸接口，實現歸實現,實現不是函數<br>軟件就是包裝器,就是一大堆接口的有機組合,不提供繼承機制<br>一個類型的數據可以獨立構成一個數據結構<br>對數據結構的描述包括它的類型，它的結構，它的存取規則<br>數據是對象，邏輯也是對象，操作也是對象，一切皆對象的概念，在機器內部一切皆比特，在用戶眼中，一切皆對象，因此數據庫的數據二字是有通用意義的，，，因此會有面向對象的數據庫<br>至此只是軟件內部，那麼在軟件外部有develpoment view<br>數據組合接口形成一個數據結構<br>對象和(包括接口和實現)構成一個組件DLL或LIB,一組對象和一組接口就是一個DLL(稱為一個產品)，需要一個調用協義接口<br>.<br><strong>8.34 真正的對接口進行編程</strong><br>不存在一個“對接口編程”的真實過程(雖然這是一種過程定義)，我們只是說，要為”實現”定義一系列使用它的接口(這樣實現才能更好地被使用和被修改)，，這種行為才是對接口編程行為,而接口本身是什麼還是沒有說哈哈<br>一個為未來擴展而寫出的工程中，大部分代碼只是框架(抽象的思想模型，也就是為了擴展需要--也是為了使用需要，而定義的一層又一層的抽象),真正的實現部分(調用API啊，用某個算法啊,某個完全具體工作的實體對象，或某個完成某個業務過程的會話對象)很分散，而且分散得很有規律性(因為被抽象接口經過了再組織，所以變得有規律地分散),,這樣的分散機制就像把真正的實現逼到最尾端，而最高層往往是使用這些尾端要如何被使用的應用邏輯--被抽象成了一個或某些使用的統一接口形式，而且是高級邏輯，(即接口實際上是關於如何使用這些實現的隔離層,,中間層)<br>這樣抽象也稱為為客戶調用(或使用)的協議定義<br>很多時候，在一個工程中，所有的實現都可以由一個Demo直接寫出來(寫成CONSOLE形式,也可以是一些對象集上面說了)，然而,真正形成產品時，我們需要再組織這些實現，讓它們最終形成的產品出現(因為一個真正的產品，必須要考慮到未來修改的需要啊)這往往是一個比寫實現還要難的過程，因為我們在寫“如何使用這些實現，如何把這些實現分散封裝到未端”的接口邏輯，而這個邏輯，往往有時比寫實現本身還要難！！<br><strong>8.35 實踐方法之極限編程</strong><br>極限方法只是敏捷開發中的一種,,,軟工指明軟件開發不只是軟件本身,,而是軟件跟人的關係,,因此這出現了設計與編碼,,,設計與編碼是軟工的二大主體,,,,好了,,實踐方法的出現就是為了解決這二者之間的矛盾<br>?開放的標準使我們的規範保持中立，所有人都可以接受，而不受某一個開發商的控制，而開源可以使我們得到大家都接受的一個實現，而不受某個開發商的控制，這兩者的結合非常有力。這個實現你可以不使用它<br>開發中的分佈要求,產生了二個複雜度,1網絡開發,2軟件要獨立於平臺和硬件架構,,這就是WEB的特徵<br>.<br><strong>8.36 設計模式複用與框架複用</strong><br>設計模式是可複用策略,,是思想級的,,但不是不可以用代碼來表現(編程即換維重現,即將思想級的東西轉變為語言級的東西),,軟件設計的終極目標就是符合軟工，擴展軟件的可擴展能力和生命力，，設計模式就是服務這個的,,設計模式因此有一些原則，比如LOC，控制反轉原則，不重複自身原則,,這就是設計模式對於軟工，所要達到的目的,常見的設計模式有哪些呢？，比如MVC，工廠方法,工廠,單件等，，MVC可以說是一種框架，，也可以說是一種設計模式，，因為MVC是設計模式的組合,,它被作為一種框架時，比如 strcut,spring，也是成立的,,可以說現在的一些WEB開發框架比如STRUCT，SPRING，ROR都是設計模式的實作品，而設計模式是一種思想,,設計模式這種思想，這種設計目標和設計手段，，被體現在代碼上，，就是用了設計模式的軟件，，或用了設計模式的可複用框架,,比如設計模式表現為一種補丁時， 什麼時候表現為補丁？就是老總說，某某公司要求我們開發一個軟件，但是這個公司提供了一個庫，要讓我們現有的代碼，用一種方法能使它跟這個庫協同工作，，因此要利用到設計模式,,就是現有代碼，，跟可複用的別人的庫，，，，在這二者之間用設計模式進行連接，，，，發展出一種可運行的邏輯,,而非補丁式的設計模式的應用，則是在產品沒有出來之前，，不需要適配既存可複用庫和要寫出的代碼這二者，，採用的一種預先的，，大而全的設計方法,,非補丁式的設計模式，，是一種真正的設計，，，此時模式二字反而可刪掉,,是一種預先想到可能想到的所有擴展能力，，決定採用什麼設計模式來編碼，，在這編碼之前 ，，決定採用什麼設計模式，或採用什麼別的方法，，，這就是真正的設計,,預先的，，如果可能，儘量大而全地考慮,,,當然設計不僅是面向可複用，，還面向應用設計，，如何設計應用，，如何設計用戶界面，如何分析業務邏輯以便於擴展出關於這個業務邏輯的新邏輯,,不僅是在設計如何編碼了，還在於調動計算機資源的能力、思維的建模能力、分解和搭架能力,,很多人以為設計模式是補丁其實是很狹隘的東西,,其實設計模式本來就不是編碼，，，只是當人們站在編碼角度來理解設計模式時，，他立馬就錯了,,設計模式是一種流於建築和軟件界，通用的可複用策略,,是思想級的，雖然它不是不可以在代碼上被表而而已<br>引用給了我們什麼.</p><div class=pgc-img><img alt=新手編程導論（九） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8436f17dfa2e4c6894676051679f5ed8><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編程</a></li><li><a>導論</a></li><li><a>新手</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/45de4a01.html alt=新手編程導論(十) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f9ae9dd10f344864b55d78ae3b54dec5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45de4a01.html title=新手編程導論(十)>新手編程導論(十)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a86cb2c2.html alt=新手編程導論（七） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ce280dbe328491f8bc043512295d4d3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a86cb2c2.html title=新手編程導論（七）>新手編程導論（七）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html alt=「編程基礎」PHP基礎教程（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17685aad04c54d02928724fb99fea026 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html title=「編程基礎」PHP基礎教程（二）>「編程基礎」PHP基礎教程（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html alt=「編程基礎」PHP基礎教程（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/355d0f0c0f274bdfaeb90747dbd918fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html title=「編程基礎」PHP基礎教程（一）>「編程基礎」PHP基礎教程（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html alt=零基礎如何學PHP編程語言？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html title=零基礎如何學PHP編程語言？>零基礎如何學PHP編程語言？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html alt=遊戲引擎編程需要哪些基本數學知識？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f6ca97249fa468db6982c44a024979d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html title=遊戲引擎編程需要哪些基本數學知識？>遊戲引擎編程需要哪些基本數學知識？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html alt=UG編程獨當一面，如何提高鑽孔精度方法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532093430052c29be7656f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html title=UG編程獨當一面，如何提高鑽孔精度方法？>UG編程獨當一面，如何提高鑽孔精度方法？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html alt=Java高級編程基礎：如何理解進程、線程與併發編程的關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/426d60ae-7dd7-4ab4-90bd-4dfeb286a68b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html title=Java高級編程基礎：如何理解進程、線程與併發編程的關係>Java高級編程基礎：如何理解進程、線程與併發編程的關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html alt=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3058ca03-deee-4287-a38c-9163687a0673 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html title=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上>C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html alt=java流式編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/92118583492140e3b610df69c711fd87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html title=java流式編程思想>java流式編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html alt=盤點那些爭議最大的編程觀點，看看你有什麼見解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/501956d4daa845caa468124f22bb35f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html title=盤點那些爭議最大的編程觀點，看看你有什麼見解>盤點那些爭議最大的編程觀點，看看你有什麼見解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>