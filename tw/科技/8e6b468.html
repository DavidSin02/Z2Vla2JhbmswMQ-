<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗 | 极客快訊</title><meta property="og:title" content="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/5856d59cc4974cb9aa41181fb439c28c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8e6b468.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1）實驗平臺：正點原子stm32mini 開發板</p><p>2）<strong>摘自《正點原子STM32 不完全手冊(HAL 庫版)》</strong>關注官方微信號公眾號，獲取更多資料：正點原子</p><div class=pgc-img><img alt="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5856d59cc4974cb9aa41181fb439c28c><p class=pgc-img-caption></p></div><p><strong>第十二章 定時器中斷實驗</strong></p><p>這一章，我們將向大家介紹如何使用 STM32 的通用定時器，STM32 的定時器功能十分強</p><p>大，有 TIME1 和 TIME8 等高級定時器，也有 TIME2~TIME5 等通用定時器，還有 TIME6 和</p><p>TIME7 等基本定時器。在《STM32 參考手冊》裡面，定時器的介紹佔了 1/5 的篇幅，足見其重</p><p>要性。在本章中，我們將使用 TIM3 的定時器中斷來控制 DS1 的翻轉，在主函數用 DS0 的翻轉</p><p>來提示程序正在運行。本章，我們選擇難度適中的通用定時器來介紹，本章將分為如下幾個部</p><p>分：</p><p>12.1 STM32 通用定時器簡介</p><p>12.2 硬件設計</p><p>12.3 軟件設計</p><p>12.4 下載驗證</p><p><strong>12.1 STM32 通用定時器簡介</strong></p><p>STM32 的通用定時器是一個通過可編程預分頻器（PSC）驅動的 16 位自動裝載計數器（CNT）</p><p>構成。STM32 的通用定時器可以被用於：測量輸入信號的脈衝長度(輸入捕獲)或者產生輸出波</p><p>形(輸出比較和 PWM)等。 使用定時器預分頻器和 RCC 時鐘控制器預分頻器，脈衝長度和波形</p><p>週期可以在幾個微秒到幾個毫秒間調整。STM32 的每個通用定時器都是完全獨立的，沒有互相</p><p>共享的任何資源。</p><p>STM3 的通用 TIMx (TIM2、TIM3、TIM4 和 TIM5)定時器功能包括：</p><p>1)16 位向上、向下、向上/向下自動裝載計數器（TIMx_CNT）。</p><p>2)16 位可編程(可以實時修改)預分頻器(TIMx_PSC)，計數器時鐘頻率的分頻係數為 1～</p><p>65535 之間的任意數值。</p><p>3）4 個獨立通道（TIMx_CH1~4），這些通道可以用來作為：</p><p>A．輸入捕獲</p><p>B．輸出比較</p><p>C．PWM 生成(邊緣或中間對齊模式)</p><p>D．單脈衝模式輸出</p><p>4）可使用外部信號（TIMx_ETR）控制定時器和定時器互連（可以用 1 個定時器控制另外</p><p>一個定時器）的同步電路。</p><p>5）如下事件發生時產生中斷/DMA：</p><p>A．更新：計數器向上溢出/向下溢出，計數器初始化(通過軟件或者內部/外部觸發)</p><p>B．觸發事件(計數器啟動、停止、初始化或者由內部/外部觸發計數)</p><p>C．輸入捕獲</p><p>D．輸出比較</p><p>E．支持針對定位的增量(正交)編碼器和霍爾傳感器電路</p><p>F．觸發輸入作為外部時鐘或者按週期的電流管理</p><p>由於 STM32 通用定時器比較複雜，這裡我們不再多介紹，請大家直接參考《STM32 參考</p><p>手冊》第 253 頁，通用定時器一章。下面我們介紹一下與我們這章的實驗密切相關的幾個通用</p><p>定時器的寄存器。</p><p>首先是控制寄存器 1（TIMx_CR1），該寄存器的各位描述如圖 12.1.1 所示：</p><p><br></p><div class=pgc-img><img alt="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee8d1ce9a54f46348c8561a3aeedd7d8><p class=pgc-img-caption>圖 12.1.1 TIMx_CR1 寄存器各位描述</p></div><p>在本實驗中，我們只用到了 TIMx_CR1 的最低位（位 0），也就是計數器使能位，該位必須</p><p>置 1，才能讓定時器開始計數。接下來介紹第二個與我們這章密切相關的寄存器：DMA/中斷使</p><p>能寄存器（TIMx_DIER）。該寄存器是一個 16 位的寄存器，其各位描述如圖 12.1.2 所示：</p><p><br></p><div class=pgc-img><img alt="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/095d35ac2f15476f94ff2b37a6793d39><p class=pgc-img-caption>圖 12.1.2 TIMx_ DIER 寄存器各位描述</p></div><p>這裡我們同樣僅關心它的最低位，該位是更新中斷允許位，本章用到的是定時器的更新中</p><p>斷，所以該位要設置為 1，來允許由於更新事件所產生的中斷。</p><p>接下來我們看第三個與我們這章有關的寄存器：預分頻寄存器（TIMx_PSC）。該寄存器用</p><p>設置對時鐘進行分頻，然後提供給計數器，作為計數器的時鐘。該寄存器的各位描述如圖 12.1.3</p><p>所示：</p><p><br></p><div class=pgc-img><img alt="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a4e8dd219754c63b5cabf23d5676c7b><p class=pgc-img-caption>圖 12.1.3 TIMx_ PSC 寄存器各位描述</p></div><p>這裡，定時器的時鐘來源有 4 個：</p><p>1）內部時鐘（CK_INT）</p><p>2）外部時鐘模式 1：外部輸入腳（TIx）</p><p>3）外部時鐘模式 2：外部觸發輸入（ETR）</p><p>4）內部觸發輸入（ITRx）：使用 A 定時器作為 B 定時器的預分頻器（A 為 B 提供時鐘）。</p><p>這些時鐘，具體選擇哪個可以通過 TIMx_SMCR 寄存器的相關位來設置。這裡的 CK_INT</p><p>時鐘是從 APB1倍頻的來的，STM32 中除非APB1 的時鐘分頻數設置為 1，否則通用定時器TIMx</p><p>的時鐘是 APB1 時鐘的 2 倍，當 APB1 的時鐘不分頻的時候，通用定時器 TIMx 的時鐘就等於</p><p>APB1 的時鐘。這裡還要注意的就是高級定時器的時鐘不是來自 APB1，而是來自 APB2 的。</p><p>這裡順帶介紹一下 TIMx_CNT 寄存器，該寄存器是定時器的計數器，該寄存器存儲了當前</p><p>定時器的計數值。</p><p>接著我們介紹自動重裝載寄存器（TIMx_ARR），該寄存器在物理上實際對應著 2 個寄存器。</p><p>一個是程序員可以直接操作的，另外一個是程序員看不到的，這個看不到的寄存器在《STM32</p><p>參考手冊》裡面被叫做影子寄存器。事實上真正起作用的是影子寄存器。根據 TIMx_CR1 寄存</p><p>器中 APRE 位的設置：APRE=0 時，預裝載寄存器的內容可以隨時傳送到影子寄存器，此時 2</p><p>者是連通的；而 APRE=1 時，在每一次更新事件（UEV）時，才把預裝在寄存器的內容傳送到</p><p>影子寄存器。</p><p>自動重裝載寄存器的各位描述如圖 12.1.4 所示：</p><div class=pgc-img><img alt="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5580ff8964f64acc99a56e5059d0d101><p class=pgc-img-caption>圖 12.1.4 TIMx_ ARR 寄存器各位描述</p></div><p>最後，我們要介紹的寄存器是：狀態寄存器（TIMx_SR）。該寄存器用來標記當前與定時</p><p>器相關的各種事件/中斷是否發生。該寄存器的各位描述如圖 12.1.5 所示：</p><div class=pgc-img><img alt="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/678c64bd30c94a5080d31fb76bc1c676><p class=pgc-img-caption>圖 12.1.5 TIMx_ SR 寄存器各位描述</p></div><p><br></p><p>TIMx_ SR 寄存器，我們同樣只用到了最低位，當計數器 CNT 被重新初始化的時候，產生</p><p>更新中斷標記，通過這個中斷標誌位，就可以知道產生中斷的類型。</p><p>關於這些位的詳細描述，請參考《STM32 參考手冊》第 282 頁。</p><p>只要對以上幾個寄存器進行簡單的設置，我們就可以使用通用定時器了，並且可以產生中</p><p>斷。</p><p>這一章，我們將使用定時器產生中斷，然後在中斷服務函數裡面翻轉 DS1 上的電平，來指</p><p>示定時器中斷的產生。接下來我們以通用定時器 TIM3 為實例，來說明要經過哪些步驟，才能</p><p>達到這個要求，併產生中斷。這裡我們就對每個步驟通過庫函數的實現方式來描述。首先要提</p><p>到 的 是 ， 定 時 器 相 關 的 庫 函 數 主 要 集 中 在 HAL 庫 文 件 stm32f1xx_hal_tim.h 和</p><p>stm32f1xx_hal_tim.c 文件中。定時器配置步驟如下：</p><p><strong>1）TIM3 時鐘使能。</strong></p><p>HAL 中定時器使能是通過宏定義標識符來實現對相關寄存器操作的，方法如下：</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 時鐘</p><p><strong>2）初始化定時器參數,設置自動重裝值，分頻係數，計數方式等。</strong></p><p>在 HAL 庫中，定時器的初始化參數是通過定時器初始化函數 HAL_TIM_Base_Init 實現的：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim);</p><p>該函數只有一個入口參數，就是 TIM_HandleTypeDef 類型結構體指針，結構體類型為下面</p><p>我們看看這個結構體的定義：</p><p>typedef struct</p><p>{</p><p>TIM_TypeDef *Instance;</p><p>TIM_Base_InitTypeDef Init;</p><p>HAL_TIM_ActiveChannel</p><p>Channel;</p><p>DMA_HandleTypeDef</p><p>*hdma[7];</p><p>HAL_LockTypeDef Lock;</p><p>__IO HAL_TIM_StateTypeDef State;</p><p>}TIM_HandleTypeDef;</p><p>第一個參數 Instance 是寄存器基地址。和串口，看門狗等外設一樣，一般外設的初始化結</p><p>構體定義的第一個成員變量都是寄存器基地址。這在HAL中都定義好了，比如要初始化串口1，</p><p>那麼 Instance 的值設置為 TIM1 即可。</p><p>第二個參數 Init 為真正的初始化結構體 TIM_Base_InitTypeDef 類型。該結構體定義如下：</p><p>typedef struct</p><p>{</p><p>uint32_t Prescaler;</p><p>//預分頻係數</p><p>uint32_t CounterMode; //計數方式</p><p>uint32_t Period;</p><p>//自動裝載值 ARR</p><p>uint32_t ClockDivision; //時鐘分頻因子</p><p>uint32_t RepetitionCounter;</p><p>} TIM_Base_InitTypeDef;</p><p>該初始化結構體中，參數 Prescaler 是用來設置分頻係數的，剛才上面有講解。參數</p><p>CounterMode 是用來設置計數方式，可以設置為向上計數，向下計數方式還有中央對齊計數方</p><p>式 ， 比 較 常 用 的 是 向 上 計 數 模 式 TIM_CounterMode_Up 和 向 下 計 數 模 式</p><p>TIM_CounterMode_Down。參數 Period 是設置自動重載計數週期值。參數 ClockDivision 是用來</p><p>設置時鐘分頻因子，也就是定時器時鐘頻率 CK_INT 與數字濾波器所使用的採樣時鐘之間的分</p><p>頻比。參數 RepetitionCounter 用來設置重複計數器寄存器的值，用在高級定時器中。</p><p>第三個參數 Channel 用來設置活躍通道。前面我們講解過，每個定時器最多有四個通道可</p><p>以用來做輸出比較，輸入捕獲等功能之用。這裡的 Channel 就是用來設置活躍通道的，取值範</p><p>圍為：HAL_TIM_ACTIVE_CHANNEL_1~ HAL_TIM_ACTIVE_CHANNEL_4。</p><p>第四個 hdma 是定時器的 DMA 功能時用到，為了簡單起見，我們暫時不講解太複雜。</p><p>第五個參數 Lock 和 State，是狀態過程標識符，是 HAL 庫用來記錄和標誌定時器處理過程。</p><p>定時器初始化範例如下：</p><p>TIM_HandleTypeDef TIM3_Handler;</p><p>//定時器句柄</p><p>TIM3_Handler.Instance=TIM3; //通用定時器 3</p><p>TIM3_Handler.Init.Prescaler= 7199;</p><p>//分頻係數</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;</p><p>//向上計數器</p><p>TIM3_Handler.Init.Period=4999;</p><p>//自動裝載值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//時鐘分頻因子</p><p>HAL_TIM_Base_Init(&TIM3_Handler);</p><p><strong>3）使能定時器更新中斷，使能定時器</strong></p><p>HAL 庫 中 ， 使 能 定 時 器 更 新 中 斷 和 使 能 定 時 器 兩 個 操 作 可 以 在 函 數</p><p>HAL_TIM_Base_Start_IT()中一次完成的，該函數聲明如下：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim);</p><p>該 函 數 非 常 好 理 解 ， 只 有 一 個 入 口 參 數 。 調 用 該 定 時 器 之 後 ， 會 首 先 調 用</p><p>__HAL_TIM_ENABLE_IT 宏定義使能更新中斷，然後調用宏定義__HAL_TIM_ENABLE 使能</p><p>相應的定時器。這裡我們分別列出單獨使能/關閉定時器中斷和使能/關閉定時器方法：</p><p>__HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);//使能句柄指定的定時器更新中斷</p><p>__HAL_TIM_DISABLE_IT (htim, TIM_IT_UPDATE);//關閉句柄指定的定時器更新中斷</p><p>__HAL_TIM_ENABLE(htim);//使能句柄 htim 指定的定時器</p><p>__HAL_TIM_DISABLE(htim);//關閉句柄 htim 指定的定時器</p><p><strong>4）TIM3 中斷優先級設置。</strong></p><p>在定時器中斷使能之後，因為要產生中斷，必不可少的要設置 NVIC 相關寄存器，設置中</p><p>斷優先級。之前多次講解到中斷優先級的設置，這裡就不重複講解。</p><p>和串口等其他外設一樣，HAL 庫為定時器初始化定義了回調函數 HAL_TIM_Base_MspInit。<strong>ALIENTEK MiniSTM32</strong></p><p><strong>V3.0 開發板教程</strong></p><p>183</p><p><strong>STM32 不完全手</strong></p><p>一般情況下，與 MCU 有關的時鐘使能，以及中斷優先級配置我們都會放在該回調函數內部。</p><p>函數聲明如下：</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim);</p><p>對於回調函數，這裡我們就不做過多講解，大家只需要重寫這個函數即可。</p><p><strong>5）編寫中斷服務函數。</strong></p><p>在最後，還是要編寫定時器中斷服務函數，通過該函數來處理定時器產生的相關中斷。通</p><p>常情況下，在中斷產生後，通過狀態寄存器的值來判斷此次產生的中斷屬於什麼類型。然後執</p><p>行相關的操作，我們這裡使用的是更新（溢出）中斷，所以在狀態寄存器 SR 的最低位。在處</p><p>理完中斷之後應該向 TIM3_SR 的最低位寫 0，來清除該中斷標誌。</p><p>跟串口一樣，對於定時器中斷，HAL 庫同樣為我們封裝了處理過程。這裡我們以定時器 3</p><p>的更新中斷為例來講解。</p><p>首先，中斷服務函數是不變的，定時器 3 的中斷服務函數為：</p><p>TIM3_IRQHandler();</p><p>一般情況下我們是在中斷服務函數內部編寫中斷控制邏輯。但是 HAL 庫為我們定義了 新</p><p>的定時器中斷共用處理函數 HAL_TIM_IRQHandler，在每個定時器的中斷服務函數內部，我們</p><p>會調用該函數。該函數聲明如下：</p><p>void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim);</p><p>而函數 HAL_TIM_IRQHandler 內部，會對相應的中斷標誌位進行詳細判斷，判斷確定中斷</p><p>來源後，會自動清掉該中斷標誌位，同時調用不同類型中斷的回調函數。所以我們的中斷控制</p><p>邏輯只用編寫在中斷回調函數中，並且中斷回調函數中不需要清中斷標誌位。</p><p>比如定時器更新中斷回調函數為：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);</p><p>跟串口中斷回調函數一樣，我們只需要重寫該函數即可。對於其他類型中斷，HAL 庫同樣</p><p>提供了幾個不同的回調函數，這裡我們列出常用的幾個回調函數：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);//更新中斷</p><p>void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim);//輸出比較</p><p>void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim);//輸入捕獲</p><p>void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim);//觸發中斷</p><p>對於這些回調函數的使用方法我們在後面用到的時候會給大家詳細講解。</p><p>通過以上幾個步驟，我們就可以達到我們的目的了，使用通用定時器的更新中斷，來控制</p><p>DS1 的亮滅。</p><p><strong>12.2 硬件設計</strong></p><p>本實驗用到的硬件資源有：</p><p>1） 指示燈 DS0 和 DS1</p><p>2） 定時器 TIM3</p><p>本章將通過 TIM3 的中斷來控制 DS1 的亮滅，DS0 和 DS1 的電路在前面已經有介紹了。而</p><p>TIM3 屬於 STM32 的內部資源，只需要軟件設置即可正常工作。</p><p><strong>12.3 軟件設計</strong></p><p>打開我們光盤實驗 7 定時器中斷實驗可以看到，我們的工程中的 HARDWARE 下面比以前</p><p>多了一個 time.c 文件（包括頭文件 time.h），這兩個文件是我們自己編寫。同時還引入了定時器</p><p>相關的 HAL 庫函數文件 stm32f1xx_hal_tim.c 和頭文件 stm32f1xx_hal_tim.h。下面我們來看看我</p><p>們的 time.c 文件。timer.c 文件代碼如下：</p><p>#include "timer.h"</p><p>#include "led.h"</p><p>TIM_HandleTypeDef TIM3_Handler; //定時器句柄</p><p>//通用定時器 3 中斷初始化</p><p>//arr：自動重裝值。</p><p>//psc：時鐘預分頻數</p><p>//定時器溢出時間計算方法:Tout=((arr+1)*(psc+1))/Ft us.</p><p>//Ft=定時器工作頻率,單位:Mhz</p><p>//這裡使用的是定時器 3!</p><p>void TIM3_Init(u16 arr,u16 psc)</p><p>{</p><p>TIM3_Handler.Instance=TIM3;</p><p>//通用定時器 3</p><p>TIM3_Handler.Init.Prescaler=psc;</p><p>//分頻係數</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP; //向上計數器</p><p>TIM3_Handler.Init.Period=arr;</p><p>//自動裝載值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//時鐘分頻因子</p><p>HAL_TIM_Base_Init(&TIM3_Handler);</p><p>HAL_TIM_Base_Start_IT(&TIM3_Handler);</p><p>//使能定時器 3 和定時器 3 更新中斷：TIM_IT_UPDATE</p><p>}</p><p>//定時器底冊驅動，開啟時鐘，設置中斷優先級</p><p>//此函數會被 HAL_TIM_Base_Init()函數調用</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim->Instance==TIM3)</p><p>{</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 時鐘</p><p>HAL_NVIC_SetPriority(TIM3_IRQn,1,3);</p><p>//設置中斷優先級，搶佔優先級 1，子優先級 3</p><p>HAL_NVIC_EnableIRQ(TIM3_IRQn); //開啟 ITM3 中斷</p><p>}</p><p>}</p><p>//定時器 3 中斷服務函數</p><p>void TIM3_IRQHandler(void)</p><p>{</p><p>HAL_TIM_IRQHandler(&TIM3_Handler);</p><p>}</p><p>//回調函數，定時器中斷服務函數調用</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim==(&TIM3_Handler))</p><p>{</p><p>LED1=!LED1; //LED1 反轉</p><p>}</p><p>}</p><p>該文件下包含一箇中斷服務函數和一個定時器 3 中斷初始化函數，中斷服務函數比較簡單，</p><p>在每次中斷後，判斷 TIM3 的中斷類型，如果中斷類型正確，則執行 LED1（DS1）的取反。</p><p>TIM3_Int_Init 函數就是執行我們上面介紹的那 5 個步驟，使得 TIM3 開始工作，並開啟中</p><p>斷。該函數的 2 個參數用來設置 TIM3 的溢出時間。因為我們在 Stm32_Clock_Init 函數裡面已</p><p>經初始化 APB1 的時鐘為 2 分頻，所以 APB1 的時鐘為 36M，而從 STM32F1 的內部時鐘樹圖</p><p>（圖 5.2.2.1）得知：當 APB1 的時鐘分頻數為 1 的時候，TIM2~7 的時鐘為 APB1 的時鐘，而</p><p>如果 APB1 的時鐘分頻數不為 1，那麼 TIM2~7 的時鐘頻率將為 APB1 時鐘的兩倍。因此，TIM3</p><p>的時鐘為 72M，再根據我們設計的 arr 和 psc 的值，就可以計算中斷時間了。計算公式如下：</p><p>Tout= ((arr+1)*(psc+1))/Tclk；</p><p>其中：</p><p>Tclk：TIM3 的輸入時鐘頻率（單位為 Mhz）。</p><p>Tout：TIM3 溢出時間（單位為 us）。</p><p>我們將 timer.c 文件保存，然後加入到 HARDWARE 組下。接下來，在 timer.h 文件裡，我</p><p>們輸入如下代碼：</p><p>#ifndef __TIMER_H</p><p>#define __TIMER_H</p><p>#include "sys.h"</p><p>extern TIM_HandleTypeDef TIM3_Handler; //定時器句柄</p><p>void TIM3_Int_Init(u16 arr,u16 psc);</p><p>#endif</p><p>此部分代碼十分簡單，這裡不做介紹。</p><p>最後，我們在主程序裡面輸入如下代碼：</p><p>int main(void)</p><p>{</p><p>HAL_Init();</p><p>//初始化 HAL 庫</p><p>Stm32_Clock_Init(RCC_PLL_MUL9); //設置時鐘,72M</p><p>delay_init(72);</p><p>//初始化延時函數</p><p>uart_init(115200);</p><p>//初始化串口</p><p>LED_Init();</p><p>//初始化 LED</p><p>KEY_Init();</p><p>//初始化按鍵</p><p>TIM3_Init(5000-1,7200-1);</p><p>//定時器 3 初始化，定時器時鐘為 72M，</p><p>//分頻係數為 7200-1，所以定時器 3 的頻率為 72M/7200=10K，自動重裝載為 5000-1，</p><p>//那麼定時器週期就是 500ms</p><p>while(1)</p><p>{</p><p>LED0=!LED0;</p><p>delay_ms(200);</p><p>}</p><p>}</p><p>這裡的代碼和之前大同小異，此段代碼對 TIM3 進行初始化之後，進入死循環等待 TIM3</p><p>溢出中斷，當 TIM3_CNT 的值等於 TIM3_ARR 的值的時候，就會產生 TIM3 的更新中斷，然</p><p>後在中斷裡面取反 LED1，TIM3_CNT 再從 0 開始計數。</p><p>這裡定時器定時時長 500ms 是這樣計算出來的，定時器的時鐘為 72Mhz，分頻係數為 7200,</p><p>所以分頻後的計數頻率為 72Mhz/7200=10KHz,然後計數到 5000，所以時長為 5000/10000=0.5s，</p><p>也就是 500ms。</p><p><strong>12.4 下載驗證</strong></p><p>在完成軟件設計之後，我們將編譯好的文件下載到 MiniSTM32 開發板上，觀看其運行結果</p><p>是否與我們編寫的一致。如果沒有錯誤，我們將看 DS0 不停閃爍（每 400ms 閃爍一次），而 DS1</p><p>也是不停的閃爍，但是閃爍時間較 DS0 慢（1s 一次）。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>正點</a></li><li><a>STM32Mini</a></li><li><a>板資料</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html alt="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html title="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器">「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html alt="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html title="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器">「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html title=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示>正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html title="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗">正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html alt=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html title=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗>正點原子開拓者NiosII資料連載第二十六章高速示波器實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cbd5c1.html alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cbd5c1.html title=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗>正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html alt="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html title="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理">正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebbd53b.html alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebbd53b.html title="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗">「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/258b34f.html alt="「正點原子NANO STM32開發板資料連載」第十章 外部中斷實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/258b34f.html title="「正點原子NANO STM32開發板資料連載」第十章 外部中斷實驗">「正點原子NANO STM32開發板資料連載」第十章 外部中斷實驗</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>