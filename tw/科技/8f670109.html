<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~ | 极客快訊</title><meta property="og:title" content="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8f670109.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8f670109.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8f670109.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8f670109.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8f670109.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8f670109.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8f670109.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8f670109.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8f670109.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p><strong>數據結構與算法：</strong></p><p>不知道你有沒有這種困惑，雖然刷了很多算法題，當我去面試的時候，面試官讓你手寫一個算法，可能你對此算法很熟悉，知道實現思路，但是總是不知道該在什麼地方寫，而且很多邊界條件想不全面，一緊張，代碼寫的亂七八糟。如果遇到沒有做過的算法題，思路也不知道從何尋找。面試吃了虧之後，我就慢慢的做出總結，開始分類的把數據結構所有的題型和解題思路每週刷題做出的系統性總結在下面。</p><p>二叉樹題目共有 11 題，我把這 11 題書中對實現方法和思路有詳細的講解，但是對於個人來說，以後遇到陌生的二叉樹的題目怎麼進行解決，通過對 11 個題的分析、整理，得出以下幾個步驟，首先先來看這 11 個二叉樹經典算法題。</p><div class=pgc-img><img alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>11 道精華二叉樹面試題</h1><p><strong>一、面試題：重建二叉樹</strong></p><p><strong>1、思路</strong></p><p>根據前、中序遍歷的特點，（根左右、左根右），先根據前序遍歷確定根節點，然後在中序遍歷知道該根節點的左右樹的數量，反推出前序遍歷中左子樹的結點有哪些。根據該思路進行遞歸即可完成二叉樹的重建。</p><p><strong>2、 測試用例</strong></p><ul><li>完全二叉樹、非完全二叉樹 —— 普通測試。</li><li>只有左子節點二叉樹，只有右子節點、只有一個結點的二叉樹 —— 特殊二叉樹測試。</li><li>空樹、前序和中序不匹配 —— 輸入測試。</li></ul><p><strong>3、代碼實現</strong></p><pre><code> 1 // 定義結點 2 // class TreeNode{ 3 //     constructor(data){ 4 //         this.data = data; 5 //         this.left = null; 6 //         this.right = null; 7 //     }  8 // } 910 // 參數：前序遍歷數組 ~ 中序遍歷數組11 const reConstructBinaryTree = (pre, vin)=&gt;{12    // 判斷前序數組和中序數組是否為空13    if(!pre || pre.length === 0 || !vin || vin.length === 0){14        return;15    }16    // 新建二叉樹的根節點17    var treeNode = {18        val: pre[0]19    }20    // 查找中序遍歷中的根節點21    for(var i = 0; i &lt; pre.length; i++) {22        if (vin[i] === pre[0]) {23            // 將左子樹的前中序遍歷分割開24            treeNode.left = reConstructBinaryTree(pre.slice(1, i+1), vin.slice(0, i));25            // 將右子樹的前中序遍歷分割開26            treeNode.right = reConstructBinaryTree(pre.slice(i+1),vin.slice(i+1));27        }28    }29    // 返回該根節點30    return treeNode;31 }3233 let pre = [1,2,4,7,3,5,6,8]; // 前序遍歷34 let vin = [4,7,2,1,5,3,8,6]; // 中序遍歷 35 console.log(reConstructBinaryTree(pre,vin));</code></pre><p><strong>二、二叉樹的下一節點</strong></p><p><strong>面試題：二叉樹的下一節點</strong></p><blockquote class=pgc-blockquote-abstract><p>給定一個二叉樹的節點，如何找出中序遍歷的下一節點。有兩個指向左右子樹的指針，還有一個指向父節點的指針。</p></blockquote><p>一、思路</p><p>求中序遍歷的下一節點，就要分各種情況（明確中序遍歷下一結點在二叉樹中的位置有哪些），然後對某種情況詳細分析。</p><p>下一結點可能存在的情況：</p><ul><li>有右子節點右子節點有無左子節點無 —— 右子節點就是當前結點下一節有 —— 遞歸尋找右子節點的左子節點就是下一節點</li><li>無右子節點無父節點 —— 無下一結點有父節點當前結點作為父節點的左子節點 —— 下一結點為父節點當前結點作為父節點的右子節點 —— 向父節點遞歸尋找作為左子節點的結點就是下一節點</li></ul><p>二、測試用例</p><ul><li>普通測試 —— 完全二叉樹、非完全二叉樹</li><li>特殊測試 —— 只要左子節點的二叉樹、只有右子節點的二叉樹、只有一個結點</li><li>輸入測試 —— 空節點</li></ul><p>三、代碼實現</p><pre><code> const getNextNode = (pNode)=&gt;{     // 判斷該結點是否為 null     if(pNode == null){         return;     }     // 當前結點有右子樹且左子樹     if(pNode.right !== null){         pNode = pNode.right;         // 判斷右子樹是否有左子樹         while(pNode.left !== null){             pNode = pNode.left;         }         return pNode;     }else{         // 判斷當前結點是否存在父節點(如果為空,沒有下一結點)         while(pNode.next !== null){             if(pNode == pNode.next.left){                 return pNode.next;             }else{                 pNode = pNode.next;             }         }         // 沒有下一結點         return null;     } }</code></pre><p><strong>三、樹的子結構</strong></p><p><strong>面試題：樹的子結構</strong></p><blockquote class=pgc-blockquote-abstract><p>輸入兩棵二叉樹 A 和 B，判斷 B 是不是 A 的子結構。</p></blockquote><p>一、思路</p><p>通過判斷兩棵樹的根節點否相同，如果相同，則遞歸判斷樹剩餘的結點是否相同。如果不相同，則遞歸樹的左右子節點進行對比找到相同的根節點。</p><p>二、測試用例</p><ul><li>是子結構、不是子結構 —— 普通測試。</li><li>只有左子節點、只有右子節點、只有一個結點 —— 特殊測試。</li><li>空樹 —— 輸入測試。</li></ul><p>三、代碼實現</p><pre><code>const TreeConstrutor = (nodeA, nodeB)=&gt;{    const result = false;    // 判斷輸入是否為 null    // nodeA 為 null 不會有子結構    if(nodeA == null){       return false;     }    // 如果 nodeB 為 null,代表所有子結構比較完成    if(nodeB == null){       return true;     }        // 如果根節點相同，則進行子結構全部的驗證,返回驗證的結果    if(nodeA.data === nodeB.data){       result = match(nodeA, nodeB)    }        // 如果根節點不相同，繼續遞歸遍歷查找相同的根節點    return TreeConstrutor(nodeA.left, nodeB) || TreeConstrutor(nodeA.right, nodeB)}// 匹配根節點相同的子結構const match = (nodeA, nodeB)=&gt;{     if(nodeA == null){       return false;     }     if(nodeB == null){       return true;     }    // 判斷匹配的當前結點是否相同     if(nodeA.data == nodeB.data){         // 遞歸匹配其他子節點    	return match(nodeA.left, nodeB.left) &amp;&amp; match(nodeA.right, nodeB.right);     }        // 如果不相同    return false;}</code></pre><p><strong>四、二叉樹的鏡像</strong></p><p><strong>面試題二十七</strong></p><blockquote class=pgc-blockquote-abstract><p>請完成一個函數，如果一個二叉樹，該函數輸出它的鏡像。</p></blockquote><p>一、思路</p><p>根節點的左右子節點相互交換，繼續遞歸遍歷，將子節點的左右結點進行交換，知道遇到葉子節點。</p><p>二、測試用例</p><ul><li>普通二叉樹 —— 普通測試</li><li>只有左子節點、只有右子節點、只有一個結點 —— 特殊測試</li><li>空樹 —— 輸入測試</li></ul><p>三、代碼實現</p><pre><code>const insert = (root)=&gt;{	// 判斷根節點是否為 null    if(root == null){     	return;      }        // 進行結點交換    Let tempNode = root.left;    root.left = root.right;    root.right = tempNode;        // 遞歸遍歷剩餘的子節點    insert(root.left);    insert(root.right);        // 返回根節點    return root;}</code></pre><p><strong>五、對稱二叉樹</strong></p><p><strong>面試題二十八</strong></p><blockquote class=pgc-blockquote-abstract><p>請實現一個函數，用來判斷一棵二叉樹是不是對稱的。如果一棵二叉樹和它的鏡像一樣，那麼它是對稱的。</p></blockquote><p>一、思路</p><p>1、首先，觀察一個對稱的二叉樹有什麼特點？</p><ul><li>結構上：在結構上實對稱的，某一節點的左子節點和某一節點的右子節點對稱。</li><li>規律上：我們如果進行前序遍歷（根、左、右），然後對前序遍歷進行改進（根、右、左），如果是對稱的二叉樹，他們的遍歷結果是相同的。</li></ul><p>2、考慮其他情況</p><ul><li>結點數量不對稱</li><li>結點值不對稱</li></ul><p>二、測試用例</p><ul><li>對稱二叉樹、不對稱二叉樹（結點數量不對稱、結點結構不對稱） —— 普通測試</li><li>所有結點值都相同的二叉樹 —— 特殊測試</li><li>空二叉樹 —— 輸入測試</li></ul><p>三、代碼編寫</p><pre><code>var isSymmetric = (root)=&gt;{    // 判斷二叉樹是否為 null —— 輸入測試，                                                     	  if(root == null){         return true;    }		// 判斷輸入的二叉樹,從根節點開始判斷是否是對稱二叉樹	var Symmetric = (lNode, rNode)=&gt;{        // 判斷左右結點是否都為 null        if(lNode == null &amp;&amp; rNode == null){           return true;         }         // 判斷其中一個為 null 另一個不是 null        if(lNode == null &amp;&amp; rNode !== null){           return false;         }        if(lNode !== null &amp;&amp; rNode == null){           return false;         }        // 判斷兩個結點的值是否相同        if(lNode.val !== rNode.val){           return false;        }        // 如果相同，繼續遞歸判斷其他的結點        return Symmetric(lNode.left,rNode.right) &amp;&amp; Symmetric(lNode.right,rNode.left)    }        Symmetric(root.left,root.right)}</code></pre><p><strong>六、從上到下打印二叉樹</strong></p><p><strong>面試題三十二</strong></p><blockquote class=pgc-blockquote-abstract><p>從上到下打印出二叉樹的每個節點，同一層的節點按照從左到右的順序打印。（按層遍歷二叉樹）</p></blockquote><p>一、思路</p><p>從根節點開始按層遍歷打印結點（自左往右），下一層的遍歷是上一層的字節點，但是我們發現想要獲取到上層結點的子節點時，上層的父節點已經遍歷過去可，想要在獲取到，必須存儲父節點。然後下層遍歷的時候，自左往右取出父節點，依次打印子節點。</p><p>上方的解題思路中父節點的存儲和遍歷讓我們想到一個熟悉的數據結構，對了，“先進先出”的思想，那就是隊列。在遍歷上一層結點的時候，先打印結點值，然後判斷是夠存在左右子樹，如果存在，將給結點入隊，直到該層的結點全部遍歷完成。然後隊列出隊，分別打印結點，循環此步驟。</p><p>二、測試用例</p><ul><li>完全二叉樹、非完全二叉樹 —— 普通測試</li><li>只有左、右子節點的二叉樹、只有一個節點的二叉樹 —— 特殊測試</li><li>空樹 —— 輸入測試</li></ul><p>三、代碼編寫</p><ul><li>參數：樹的根節點。</li><li>判斷是否為空。</li><li>打印結點值,判斷該結點是否存在子節點，如果存在就入隊。</li><li>出隊，打印結點</li><li>循環上述步驟</li></ul><pre><code>var levelOrder = function(root) {    let result = []; // 存放遍歷的結果  	// 判斷根節點是否為 null	if(root == null){      return [];    }    // 聲明一個隊列    let queue = [];    queue.push(root)          // 出隊，打印結結點、判斷是否存在子節點    while(queue.length !== 0){        let temp = [];             // 存儲每層的結點        let len = queue.length;        for(let j = 0;j &lt; len;j++){            // 出隊            let tempNode = queue.shift();             // 存儲結點值            temp.push(tempNode.val)		              // 判斷出隊的根節點是否有子節點            if(tempVal.left !== null){               queue.push(tempVal.left)            }            if(tempVal.right !== null){               queue.push(tempVal.left)            }        }        //存儲每層的遍歷的結點值        result.push(temp);    }    // 返回結果集    return result;  }</code></pre><p><strong>七、二叉樹的後序遍歷序列</strong></p><p><strong>面試題三十三</strong></p><blockquote class=pgc-blockquote-abstract><p>輸入一個整數數組，判斷該數組是不是某二叉搜索樹的後續遍歷。如果是返回 true，如果不是返回 false。假設輸入的任意兩個數字互不相同。</p></blockquote><p>一、思路</p><p><strong>根據後續遍歷的規律和二叉樹具備的特點</strong>，可以找到的規律就是（左、右、根）序列的最後一個數為根節點，又根據二叉樹的特點，左子節點小於根節點，右子節點大於根節點，分離出左右子節點，根據上邊的規律，<strong>遞歸</strong>剩下的序列。</p><p>二、測試用例</p><ul><li>完全二叉樹、不完全二叉樹 —— 普通測試</li><li>只有左子節點的二叉樹、只有右子節點的二叉樹、只有一個節點的二叉樹 —— 特殊測試</li><li>空樹 —— 輸入測試</li></ul><p>三、代碼編寫</p><ul><li>參數：數組</li><li>判斷數組是否為空</li><li>取數組的最後一個元素作為對比的根節點</li><li>根據根節點值的大小分割數組（分割數組的同時判斷是否都滿足小於根節點的要求）</li><li>判斷分割數組是否是空</li><li>遞歸上方的步驟</li></ul><pre><code>const isPostorder = (arr)=&gt;{  	// 判斷數組是否為 null    if(arr.length == 0){    	return true;       }        // 取數組最後一個數字為根節點    let rootVal = arr[arr.length - 1];         // 搜索小於根節點的值,並記錄該結點的下標(除根節點外)    let i = 0;    for(;i &lt; arr.length - 1;i++){        if(arr[i] &gt; rootVal){           break        }    }        // 搜索大於根節點的值（除根節點外）    let j = 0;    for(;j &lt; arr.length - 1; j++){        if(rootVal &gt; arr[j]){           return false;        }    }        // 遞歸判斷左子節點的值（先判斷左子節點是夠有值），默認返回 true     let left = true     if(i &gt; 0){         left = isPostorder(arr.slice(0, i))     }     // 如果右子樹不為空，判斷右子樹為二叉搜索樹    let right = true    if(i &lt; arr.length - 1){        right = isPostorder(arr.slice(i,arr.length - 1))    }    return (left &amp;&amp; right)}</code></pre><p><strong>八、二叉樹和為某一值路徑</strong></p><p><strong>面試題三十四</strong></p><p>輸入一棵二叉樹和一個整數，打印出二叉樹中節點值的和為輸出整數的所有路徑。從樹的根節點開始往下一直到葉子節點所經過的節點形成一條路徑。</p><p>一、思路</p><p>1、找規律：**需要遍歷樹的所有結點：我們會想到前、中、後遍歷</p><p>​ : 需要存儲遍歷過的路徑（節點值）：我們想到用數組存儲</p><p>2、算法思想：**前序遍歷（根、左、右）的特點，從根到葉子節點，會從樹自左向右依次遍歷二叉樹，所有可能的路徑都會遍歷到，所以使用前序遍歷更佳。</p><p>每遍歷一個結點就將其累加，然後判斷累加的值是否等於目標值且子節點為葉子節點。如果是，則打印輸出該路徑；如果不是，則回退到上一父節點，此時數組中的數據結點進行刪除，然後不斷的遍歷下一子節點，遞歸。</p><p>**3、綜上所述，**存儲結點路徑的時候，涉及到累加結點和刪除節點，我們可以將其抽象成入棧和出棧。然後遍歷二叉樹的所有路徑可以用到遞歸的過程，讓出棧和入棧與遞歸的狀態達成一致，這到題就不難了。</p><p>二、測試用例</p><ul><li>完全二叉樹、非完全二叉樹（有一條路徑滿足、有多條路徑滿足、都不滿足）—— <strong>普通測試</strong>。</li><li>只有左子節點的二叉樹、只有右子節點的二叉樹、只有一個結點的二叉樹 —— <strong>特殊測試</strong>。</li><li>空二叉樹、輸入負數 —— <strong>輸入測試</strong>。</li></ul><p>三、代碼編寫</p><ul><li>參數：二叉樹、目標值</li><li>判斷二叉樹是否為空和目標是是否是負數</li><li>開始進行遞歸遍歷二叉樹進行查找滿足條件的路徑</li><li>將當前遞歸的根節點進行累加</li><li>同時該結點入棧</li></ul><pre><code>const treeSum = (root, targetSum)=&gt;{      // 判斷輸入的二叉樹和整數      if(root == null || targetSum &lt; 0){          return false;      }            // 開始進行遞歸遍歷二叉樹進行查找滿足條件的路徑      let result = [];    // 存放最後滿足條件的路徑      let pathStack = []; // 儲存當前路徑的棧      let currentSum = 0; // 當前累加的結果值	        // 進行路徑查找      FindPath(root, targetSum, currentSum, pathStack, result);            // 返回結果      return result;  }    const FindPath = (root, targetSum, currentSum, pathStack, result)=&gt;{		// 將當前跟根節點進行累加      	currentSum = currentSum + root.val;      	        // 存儲棧中        pathStack.push(root.val);              // 判斷目標值是否相等且是否為葉子節點      	if(currentSum == targetSum &amp;&amp; root.left == null &amp;&amp; root.right == null){            // 打印路徑            result.push(pathStack.slice(0))        }              // 如果左子節點不為空        if(root.left !== null){            FindPath(root.left, targetSum, currentSum, pathStack, result);        }        // 如果當前結點還有右子樹，繼續遍歷        if(root.right !== null){            FindPath(root.right, targetSum, currentSum, pathStack, result);        }              // 該路徑遍歷到葉子節點，還沒有滿足條件，則退回到父節點，進行下一結點的累加判斷        pathStack.pop();  }</code></pre><p><strong>九、序列化二叉樹</strong></p><blockquote class=pgc-blockquote-abstract><p>請實現兩個函數，分別用來序列化二叉樹和反序列化二叉樹。</p></blockquote><p>一、思路</p><p>1、序列化：遍歷二叉樹，遇到葉子節點，將其轉化為 $ 表示。</p><p>2、反序列化：根據前序遍歷的特點（根、左、右），進行二叉樹的還原。</p><p>二、測試用例</p><ul><li>完全二叉樹、非完全二叉樹 —— 普通測試</li><li>只有左子節點、只有右子節點、只有一個節點 —— 特殊測試</li><li>空數組、空樹 —— 輸入測試</li></ul><p>三、代碼編寫</p><ul><li>序列化:</li></ul><pre><code>let result = [];var serialize = function(root) {    // 判空    if(root == null){        result.push('$');        return;    }    // 前序遍歷    result.push(root.val)    serialize(root.left)    serialize(root.right)    // 打印    console.log(result)};serialize(symmetricalTree);</code></pre><ul><li>反序列化:</li></ul><pre><code>// 反序列化二叉樹var deserialize = function(arr) {    // 判空    if(arr.length == 0){        return null;    }    // 出棧隊判斷    let node = null;    const val = arr.shift();    if(val !== '$'){        node = {            val: val        };        node.left = deserialize(arr);        node.right = deserialize(arr);    }    return node;};let str = '8,6,5,$,$,7,$,$,6,7,$,$,5,$,$';console.log(deserialize(str.split(',')));</code></pre><p><strong>十、二叉樹的第 K 大節點</strong></p><blockquote class=pgc-blockquote-abstract><p>給定一棵二叉搜索樹，請找出其中的第 K 大節點。</p></blockquote><p>一、思路</p><p>要想找到第 K 大結點必要要知道排序，二叉樹的前、中、後遍歷中的中序遍歷就是從小到大排序。然後遍歷的同時計數找到第 K 大節點。</p><p>二、測試用例</p><ul><li>完全二叉樹、非完全二叉樹 —— 普通測試</li><li>只有左子節點的二叉樹、只有右子節點的二叉樹、只有一個節點的二叉樹 —— 特殊測試</li><li>K 的範圍、空樹 —— 輸入測試</li></ul><p>三、代碼編寫</p><pre><code>// 求二叉樹中第 K 大節點var kthTallest = function(root, k) {  let res = []  // 遍歷  const inorder = (root) =&gt; {    if (root) {      inorder(root.left);      res.push(root.val);      inorder(root.right);    }  }  // 調用  inorder(root);  return res[res.length - k]};</code></pre><p><strong>十一、二叉樹的深度</strong></p><p><strong>面試題五十五</strong></p><blockquote class=pgc-blockquote-abstract><p>輸入一棵二叉樹的根節點，求該樹的深度。從根節點到葉子節點依次經過的節點（包含根、葉子節點）形成樹的一條路徑，最長路徑的長度樹的深度。</p></blockquote><p>一、思路</p><p>1、思路一：按層遍歷，對按層遍歷的算法進行改進，每遍歷一次層進行加一。</p><p>2、思路二：尋找最長路徑，藉助遍歷最長路徑的設計思路記性改進。只需記錄兩個子樹最深的結點為主。</p><p>二、測試用例</p><ul><li>完全二叉樹、非完全二叉樹 —— 普通測試</li><li>只有左子節點、只有右子節點、只有一個結點二叉樹 —— 特殊測試</li><li>空樹 —— 輸入測試</li></ul><p>三、代碼編寫</p><pre><code>var maxDepth = function(root) {    // 如果根節點為 null     if(root === null) return 0;    	// 遞歸左子樹    let depthLeft  = maxDepth(root.left);        // 遞歸右子樹    let depthRight  = maxDepth(root.right);    	// 將子問題合併求總問題    return Math.max(depthLeft,depthRight) + 1;};</code></pre><div class=pgc-img><img alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7a79b22af4564ae986cdd06e57593d32><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>總結</h1><p>通過以上十一個題，不是做過之後就記住了這麼簡單，而是通過以上二叉樹題型的總結歸納，能不能舉一反三，總結出二叉樹面試題的解題思路，以後遇到二叉樹相面試題能不能通過上邊總結出來的步驟進行思考獨立解決，這是這篇文章的重點。下面就分別通過解題思路、測試用例以及編寫代碼進行深入總結。</p><p>一、解題思路總結</p><p>1、根據樹前（根左右）、中（左根右）、後（左右根）序遍歷的規律來解決問題。</p><blockquote class=pgc-blockquote-abstract><p>通過二叉樹的遍歷來找到規律，從而找到解題思路。</p></blockquote><ul><li>重建二叉樹</li><li>根據前、中序遍歷，找到二叉樹的根節點和左右子樹的規律，然後遞歸構建二叉樹。</li><li>二叉樹的下一節點</li><li>根據中序遍歷，找出包含任何節點的一下節點的所有可能情況，然後根據情況分別進行判斷。</li><li>二叉樹的後續遍歷序列</li><li>通過中序遍歷找到打印二叉樹結點的規律，可以判斷此後續遍歷是否為二叉樹。</li><li>二叉樹和為某一值的路徑</li><li>選擇二叉樹的遍歷，對每個節點進行存儲判斷，然後根據二叉樹葉子節點的特點，進行對問題的解決。</li><li>二叉樹的第 K 大結點</li><li>中序遍歷的結果是從小到大，然後倒數找到第 K 大數據。</li><li>序列化二叉樹</li><li>遍歷二叉樹，遇到 null 轉化為特殊符號。</li></ul><h4 class=pgc-h-arrow-right>2、根據樹的結構尋找規律來解決問題</h4><blockquote class=pgc-blockquote-abstract><p>通過二叉樹的特點：左子節點小於父節點、右子節點大於父節點、樹的節點可以進行遞歸等，以上特點又是更好的幫我們解決思路。</p></blockquote><ul><li>樹的子結構</li><li>根據子結構和主體樹的特點，對其樹的結構進行分析，可以找到解題的思路。</li><li>鏡像二叉樹</li><li>觀察鏡像二叉樹的左右子節點交換特點，可以找到解題思路。</li><li>對稱二叉樹</li><li>觀察對稱二叉樹有什麼特點，在結構上和遍歷上尋找特點和規律，可以找到解題思路。</li><li>按層遍歷二叉樹</li><li>根據二叉樹每層節點的結構關係（父子關係），可以進行每層遍歷，通過上層找到下層的遍歷結點。</li><li>反序列化二叉樹</li><li>根據遍歷的規律和二叉樹的規律，將遍歷結果生成一棵二叉樹。</li></ul><h3 class=pgc-h-arrow-right>二、測試用例</h3><p>通過以上題目中，我將測試用例分為三大種，測試代碼的時候，在這三大種進行想就可以了。</p><ul><li><strong>普通測試</strong></li><li><strong>特殊測試</strong></li><li><strong>輸入測試</strong></li></ul><p>1、普通測試</p><p>普通測試從兩個方面去想，第一個方面就是問題的本身，比如對稱二叉樹的判斷，普通測試就是分別輸入一個對稱二叉樹和非對稱二叉樹進行測試。第二個方面就是問題本身沒有什麼可以找到的測試，比如按層遍歷二叉樹，它的普通測試就是分別輸入完全二叉樹（普通二叉樹也可以），非完全二叉樹進行測試。</p><p>2、特殊測試</p><p>特殊測試強調的是樹的特殊性，特殊的二叉樹就那麼幾個，比如：只有左子節點的二叉樹、只有右子節點的二叉樹、只有一個節點的二叉樹、沒有結點的二叉樹。</p><p>3、輸入測試</p><p>輸入測試，顧名思義，要對用戶輸入的參數進行判斷，比如，你輸入一棵樹，要判斷是否為空。再比如，求最大 K 結點，對 K 的取值範圍進行判斷。</p><p>三、代碼編寫</p><p>將二叉樹的解題思路轉化為代碼除了熟練最基本的二叉樹的增、刪、改、查之外，最重要的就是二叉樹的遞歸，因為二叉樹的結構決定了用遞歸解決二叉樹問題更加簡便。但是遞歸的書寫並不僅簡單，因為它有遞和歸的過程，大腦並不能更好的去處理這些，可以去看之前總結遞歸的文章《數據結構與算法之遞歸系列》。</p><p>書寫二叉樹遞歸問題有一點特別重要，不要嘗試的去想那個遞歸的過程，而是先去尋找到遞歸的終止條件，然後對每次遞歸的結果進行判斷，然後讓他遞歸去吧，再次強調千萬別去思考過程。</p><p><strong>（這是小編整理的關於二叉樹的面試，希望大家會喜歡！）</strong></p><p><strong>關注小編將為您持續發送面試小技巧哦~~~</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>樹有</a></li><li><a>11</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b49531fd.html alt=都說“雙11”收貨快，為啥我的收不到？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rhwm3QKEJB5JPn style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b49531fd.html title=都說“雙11”收貨快，為啥我的收不到？>都說“雙11”收貨快，為啥我的收不到？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5db1bf59.html alt=沂源縣12月11日局地停電信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RBRHlOr2QW3xVM style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5db1bf59.html title=沂源縣12月11日局地停電信息>沂源縣12月11日局地停電信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/048e9c4a.html alt=最後階段？11月中旬期限再度逼近，脫歐談判最後關口再次觸礁 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f3d53f7d-c2bd-40a1-b95c-bc23fee38c24 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/048e9c4a.html title=最後階段？11月中旬期限再度逼近，脫歐談判最後關口再次觸礁>最後階段？11月中旬期限再度逼近，脫歐談判最後關口再次觸礁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/780002e1.html alt=11個電路原理圖+實物接線圖，電工入門怎麼能看不懂，純乾貨！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/152553256769811fb092fbb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/780002e1.html title=11個電路原理圖+實物接線圖，電工入門怎麼能看不懂，純乾貨！>11個電路原理圖+實物接線圖，電工入門怎麼能看不懂，純乾貨！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5816b99.html alt=貼磚11條工藝規範標準，施工驗收讓你再也不被忽悠 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/06192ec9d2204ab09bd01ee56ad72627 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5816b99.html title=貼磚11條工藝規範標準，施工驗收讓你再也不被忽悠>貼磚11條工藝規範標準，施工驗收讓你再也不被忽悠</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03ac1cd8.html alt=11個最實用的Excel求和公式，各類求和情況都有模板了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535796946527b7df391e10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03ac1cd8.html title=11個最實用的Excel求和公式，各類求和情況都有模板了！>11個最實用的Excel求和公式，各類求和情況都有模板了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>