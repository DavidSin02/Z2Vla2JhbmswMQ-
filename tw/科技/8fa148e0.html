<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基於CDC技術的ElasticSearch索引同步機制 | 极客快訊</title><meta property="og:title" content="基於CDC技術的ElasticSearch索引同步機制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/SDAIrbpCGdpuDg"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fa148e0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fa148e0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8fa148e0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fa148e0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fa148e0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8fa148e0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8fa148e0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fa148e0.html><meta property="article:published_time" content="2020-10-29T21:09:58+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:58+08:00"><meta name=Keywords content><meta name=description content="基於CDC技術的ElasticSearch索引同步機制"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8fa148e0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基於CDC技術的ElasticSearch索引同步機制</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Flink 從入門到精通 系列文章</p><p></p><h1 toutiao-origin=h3>概述</h1><p>ElasticSearch作為一個基於Lucene的搜索引擎被廣泛應用於各種應用系統，比如電商、新聞類、諮詢類網站。在使用ElasticSearch開發應用的過程中，一個非常重要的過程是將數據導入到ElasticSearch索引中建立文檔。在一開始系統規模比較小時，我們可以使用logstash來同步索引。logstash的好處是開方量少，只要進行編寫簡單的索引模板和同步sql，就能快速搭建索引同步程序。但是隨著應用數據規模的變大，索引變化變得非常頻繁。logstash的缺點也隨著暴露，包括：</p><p>（1）不支持刪除，只能通過修改字段屬性軟刪除，隨著應用使用時間的增長，ElasticSearch中會留存大量的無用數據，拖慢搜索速度。（2）sql分頁效率低，sql查詢慢。logstash的分頁邏輯是先有一個大的子查詢，然後再從子查詢中分頁獲取數據，因此效率低下，當數據庫數據量大時，一個分頁查詢就需要幾百秒。同步幾千萬數據可能需要1天時間。</p><p>因此我們決定放棄使用logstash，而改用使用canal來搭建基於CDC技術的ElasticSearch索引同步機制。</p><p></p><h1 toutiao-origin=h3><strong toutiao-origin=h1>系統架構設計</strong></h1><img alt=基於CDC技術的ElasticSearch索引同步機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SDAIrbpCGdpuDg><p>如圖所示，索引同步系統由幾個部分組成，下面分點介紹。</p><p>（1）數據庫</p><p>原始數據數據庫</p><p>（2）Canal</p><p>Canal是阿里雲開源的MySql數據庫增量數據訂閱和消費工具。它的實現原理是將自己偽裝為一個MySQL slave，向MySql ma ster發送dump協議；MySQL master收到dump請求，開始推送binary log給slave，canal解析binary log對象。</p><p>（3）Canal Client</p><p>Canal Client是自己實現的程序，通過從Canal Server中獲取經過Canal解析之後的數據庫binlog日誌，做相應的業務邏輯處理。在本文介紹的基於CDC的索引同步系統中，Canal Client訂閱搜索相關的數據庫表的binlog日誌，如果跟數據搜索相關的數據發生變化時，就向Rabbit發一條消息，表明數據發生變化了，通知同步Worker從MySQL同步數據到ES。</p><p>（4）RabbitMQ</p><p>消息隊列，也可以選用Kafaka等其他消息隊列，根據具體業務確定。</p><p>（5）索引同步Worker</p><p>Worker從消息隊列中消費數據，根據消息從MySQL獲取相應的數據並同步到ElasticSearch中。</p><p></p><h1 toutiao-origin=h3><strong toutiao-origin=h1>Canal Client實現</strong></h1><p>Canal Client從Canal Server中獲取binlog日誌，並根據業務需求進行處理。以下通過一些關鍵代碼介紹Canal Client的實現。</p><p>（1）在pom中添加Canal client的依賴。</p><pre><code>&lt;dependency&gt;<br>&lt;groupId&gt;com.alibaba.otter&lt;/groupId&gt;<br>&lt;artifactId&gt;canal.client&lt;/artifactId&gt;<br>&lt;version&gt;1.1.0&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre><p>（2）初始化Canal連接</p><p>CanalConfig包含了Canal的配置信息。CanalConnector為canal-client包中的類，我們通過這個類來連接server，獲取binlog，關閉server。該服務基於SpringBoot。因此init會在CanalClientInitializer bean被創建時被調用，preDestory會在服務關閉，CanClientInitializer被銷燬時被調用。</p><pre><code>@Component<br>@Slf4j<br>public class CanalClientInitializer {<br><br><br>CanalConfig canalConfig;<br><br>CanalConnector connector;<br><br>CanalDataProcessor canalDataProcessor;<br><br><br>public CanalClientInitializer(@Autowired CanalConfig canalConfig, @Autowired CanalDataProcessor canalDataProcessor) {<br>this.canalConfig = canalConfig;<br>this.canalDataProcessor = canalDataProcessor;<br>}<br><br><br>@PostConstruct<br>public void init throws InterruptedException {<br>connector = CanalConnectors.newSingleConnector(new InetSocketAddress(canalConfig.getIp, canalConfig.getPort), canalConfig.getDestination, "", "");<br>//建立連接<br>connector.connect;<br>//訂閱相關的表<br>connector.subscribe(canalConfig.getSyncTable);<br>canalDataProcessor.process(connector);<br>}<br><br><br>@PreDestroy<br>public void<strong class=highlight-text toutiao-origin=span>preDestroy</strong> {<br>log.info("stop the canal client");<br>canalDataProcessor.stopProcess;<br>}<br><br>}<br></code></pre><p>（3）CanalDataProcessor獲取並處理binlog</p><pre><code>@Component<br>@Slf4j<br>public class CanalDataProcessor {<br><br><br>boolean isRunning;<br><br>RabbitTemplate rabbitTemplate;<br><br>TableChangeProcessor tableChangeProcessor;<br><br>public CanalDataProcessor(@Autowired RabbitTemplate rabbitTemplate, @Autowired TableChangeProcessor processor) {<br>this.rabbitTemplate = rabbitTemplate;<br>this.tableChangeProcessor = processor;<br>}<br><br>@Async<br>public void process(CanalConnector connector) throws InterruptedException {<br>isRunning = true;<br>while (isRunning) {<br>try {<br>//獲取消息<br>Message message = connector.getWithoutAck(100, 10L, TimeUnit.SECONDS);<br>//業務處理邏輯<br>processMessage(message);<br>//消息被成功執行，向Canal Server發送ack消息通知server該message已經被處理完成<br>connector.ack(message.getId);<br>} catch (Exception e) {<br>log.error("wtf", e);<br>//當消息沒被成功處理完成時進行回滾，下次能夠重新獲取該Message<br>connector.rollback;<br>Thread.sleep(1000);<br>}<br>}<br>connector.disconnect;<br>}<br><br><br>public void<strong class=highlight-text toutiao-origin=span>stopProcess</strong> {<br>isRunning = false;<br>}<br><br><br>private void processMessage(Message message) {<br>for(Entry entry : message.getEntries) {<br>try {<br>tableChangeProcessor.process(entry);<br>} catch (Exception e) {<br>log.error("wtf", e);<br>continue;<br>}<br>}<br>}<br>}<br></code></pre><p>（4）TableChangeProcessor</p><p>TableChangeProcessor中為具體的業務邏輯，處理Message，獲取跟搜索相關的數據變化，發送相應的消息到消息隊列中。注意點 （1）忽略搜索無關的數據字段變化，避免不必要的索引更新，降低服務器壓力。如Products表中有一個product_weight表示商品重量發生了變化，但其實商品重量跟搜索無關，那就不要關心這個變化。</p><p>（2）對於搜索中不會出現的數據，不要寫入到ES中，比如電商商品中的下架商品，另外，如果商品被下架，則要進行監聽通知索引同步Worker從es中刪除索引文檔。這樣能夠降低ES中總的索引文檔數量，提升搜索效率。</p><p>（3）要考慮Rabbit掛掉或者隊列寫滿，消息無法寫入的情況；首先應該在Rabbit發送消息時添加重試，其次應該在重試幾次還是失敗的情況下拋出異常，canal消息流回滾，下次還是能夠獲取到這個數據變化的Canal消息，避免數據變動的丟失。</p><p>（4）注意目前Canal只支持單Client。如果要實現高可用，則需要依賴於ZooKeeper，一個Client作為工作Client，其餘Client作為冷備，當工作Client掛掉時，冷備Client監聽到ZooKeeper數據變化，搶佔鎖成為工作Client。</p><p></p><h1 toutiao-origin=h3><strong toutiao-origin=h1>Canal Worker實現</strong></h1><p>索引同步Worker從消息隊列中獲取Canal Client發送的跟搜索相關的數據庫變化消息。舉個例子，比如商品表中跟搜索相關的字段發生了變化，Canal Client會發送以下一條數據：</p><pre><code>{<br>"change_id": "694212527059369984",<br>"change_type": 1, //商品發生變化<br>"change_time": "1600741397"<br>}<br></code></pre><p>在Worker中監聽隊列消息：</p><pre><code>@Component<br>@Slf4j<br>public class ProductChangeQueueListener {<br><br>@Autowired<br>@Qualifier("snake")<br>ObjectMapper om;<br><br>@Autowired<br>ChangeEventHandlerFactory changeEventHandlerFactory;<br><br>@RabbitListener(queues = RabbitConfig.PRODUCT_QUEUE_NAME, containerFactory = "customRabbitListenerContainerFactory")<br>public void onChange(Message message) {<br><br>ChangeEvent event = parse(message);<br>if(event == ) {<br>return;<br>}<br><br>changeEventHandlerFactory.handle(event);<br>}<br><br>private ChangeEvent parse(Message message) {<br>ChangeEvent event = ;<br>try {<br>event = om.readValue(new String(message.getBody), ChangeEvent.class);<br>} catch (Exception e) {<br>log.error("同步失敗，解析失敗", e);<br>}<br>return event;<br>}<br><br><br>}<br></code></pre><p>ChangeEventHandlerFactory為事件處理器的工廠類。以下為一個事件處理器的實現。它監聽changeType為CHANGE_TYPE_OUT_PRODUCT的事件，從數據庫中獲取到變動的數據，構建ES的IndexRequest，並將Request存入到RequestBulkBuffer中，等待批量同步到ES中。有些同學可能會有疑問，為何不直接從Canal中獲取數據，主要原因是Canal中只包含了單表數據，但是索引文檔可能包含了多表的數據，因此還需要從MySQL獲取數據。如果索引文檔中只包含單表數據，可以考慮在ChangeEvent中包含修改之後的數據，索引同步Woker就不用再從MySql中再獲取一遍數據，提升Worker工作效率。</p><pre><code>@Component<br>@Slf4j<br>public class OutProductEventHandler implements ChangeEventHandler {<br><br>@Autowired<br>ProductDao productDao;<br><br>@Autowired<br>RequestBulkBuffer buffer;<br><br><br>@Autowired<br>OutProductChangeRequestBuilder builder;<br><br>@Override<br>@Retryable<br>public boolean handle(ChangeEvent changeEvent) {<br>if (!match(changeEvent)) {<br>return false;<br>}<br><br>Tuple dataTuple = productDao.getProductWithStore(changeEvent.getChangeId);<br>if (dataTuple == ) {<br>return true;<br>}<br>Product product = dataTuple.get(QProduct.product);<br>Store store = dataTuple.get(QStore.store);<br><br>IndexRequest request = ;<br>try {<br>request = builder.convertToUpdateQuery(getTimestampNow, product, store);<br>} catch (Exception e) {<br>log.error("wtf", e);<br>}<br>if (request == ) {<br>return true;<br>}<br>buffer.add(request);<br>return true;<br><br>}<br><br>@Override<br>public boolean match(ChangeEvent changeEvent) {<br>return ChangeEvent.CHANGE_TYPE_OUT_PRODUCT == changeEvent.getChangeType;<br>}<br>}<br></code></pre><p>在上面的OutProductEventHandler類中，我們並不直接在該類中使用RestHighLevelClient將文檔更新到ES索引，而是將IndexRequest暫存到RequestBulkBuffer中。RestBulkBuffer使用CircularFifoBuffer作為存儲數據結構。</p><pre><code>@Component<br>public class RequestBulkBuffer {<br><br>CircularFifoBuffer buffer;<br><br>public RequestBulkBuffer(CircularFifoBuffer buffer) {<br>this.buffer = buffer;<br>}<br><br><br>public void add(DocWriteRequest&lt;?&gt; request) {<br>buffer.add(request);<br>}<br><br>}<br></code></pre><p>CircularFifoBuffer是一個經過改造的環形隊列實現。允許多線程寫，在我們這個應用場景中只支持也只需支持單線程讀->處理->移除處理完的數據。當環形隊列緩存滿時，藉助於semaphore，寫入線程將會被阻塞，在後面的Worker如何防止數據丟失中，我們來闡述為什麼要這麼做。</p><pre><code>/**<br>* 允許多線程寫<br>* 只允許單線程-&gt;讀-&gt;處理-&gt;移除<br>*/<br>public class CircularFifoBuffer {<br><br>private Logger logger = LoggerFactory.getLogger(CircularFifoBuffer.class.getName);<br><br><br>private transient Object elements;<br><br>private transient int start = 0;<br>private transient int end = 0;<br><br>private transient boolean full = false;<br><br>private final int maxElements;<br><br>private ReentrantLock addLock;<br><br>private Semaphore semaphore;<br><br>public CircularFifoBuffer(int size) {<br>if (size &lt;= 0) {<br>throw new IllegalArgumentException("The size must be greater than 0");<br>}<br>elements = new Object[size];<br>maxElements = elements.length;<br>addLock = new ReentrantLock;<br>semaphore = new Semaphore(size);<br>}<br><br><br>public int<strong class=highlight-text toutiao-origin=span>size</strong> {<br>int size = 0;<br><br>if (end &lt; start) {<br>size = maxElements - start + end;<br>} else if (end == start) {<br>size = (full ? maxElements : 0);<br>} else {<br>size = end - start;<br>}<br><br>return size;<br>}<br><br>public boolean<strong class=highlight-text toutiao-origin=span>isEmpty</strong> {<br>return size == 0;<br>}<br><br>public boolean<strong class=highlight-text toutiao-origin=span>isFull</strong> {<br>return size == maxElements;<br>}<br><br>public int<strong class=highlight-text toutiao-origin=span>maxSize</strong> {<br>return maxElements;<br>}<br><br>public void<strong class=highlight-text toutiao-origin=span>clear</strong> {<br>full = false;<br>start = 0;<br>end = 0;<br>Arrays.fill(elements, );<br>}<br><br>public boolean add(Object element) {<br>if ( == element) {<br>throw new PointerException("Attempted to add object to buffer");<br>}<br><br>addLock.lock;<br>try {<br>semaphore.acquire;<br>} catch (Exception e) {<br>logger.error("RingBuffer", "線程退出，添加失敗");<br>return false;<br>}<br><br>elements[end++] = element;<br><br><br>if (end &gt;= maxElements) {<br>end = 0;<br>}<br><br>if (end == start) {<br>full = true;<br>}<br><br>addLock.unlock;<br><br>return true;<br><br>}<br><br>public Object<strong class=highlight-text toutiao-origin=span>get</strong> {<br>if (isEmpty) {<br>return ;<br>}<br><br>return elements[start];<br>}<br><br><br>public Object<strong class=highlight-text toutiao-origin=span>remove</strong> {<br>if (isEmpty) {<br>return ;<br>}<br><br>Object element = elements[start];<br>if( != element) {<br>elements[start++] = ;<br>if (start &gt;= maxElements) {<br>start = 0;<br>}<br>full = false;<br>semaphore.release;<br>}<br>return element;<br>}<br><br><br>/**<br>* @param size the max size of elements will return<br>*/<br>public Object get(int size) {<br>int queueSize = size;<br>if (queueSize == 0) { //empty<br>return new Object[0];<br>}<br>int realFetchSize = queueSize &gt;= size ? size : queueSize;<br>if (end &gt; start) {<br>return Arrays.copyOfRange(elements, start, start + realFetchSize);<br>} else {<br>if (maxElements - start &gt;= realFetchSize) {<br>return Arrays.copyOfRange(elements, start, start + realFetchSize);<br>} else {<br>return ArrayUtils.addAll(<br>Arrays.copyOfRange(elements, start, maxElements),<br>Arrays.copyOfRange(elements, 0, realFetchSize - (maxElements - start))<br>);<br>}<br>}<br>}<br><br><br>public Object<strong class=highlight-text toutiao-origin=span>getAll</strong> {<br>return get(size);<br>}<br><br><br><br>public Object remove(int size) {<br>if(isEmpty) {<br>return new Object[0];<br>}<br>int queueSize = size;<br>int realFetchSize = queueSize &gt;= size ? size : queueSize;<br>Object  retArr = new Object[realFetchSize];<br>for(int i=0;i&lt;realFetchSize;i++) {<br>retArr[i] = remove;<br>}<br><br>return retArr;<br>}<br><br>}<br></code></pre><p>下面這個類為緩存的消費者，它循環從buffer中獲取一定數據的數據，並使用RestHighLevelClient將數據批量同步到ES。在Worker啟動時，會創建一個線程調用startConsume，在服務關閉時該線程結束。</p><pre><code>@Slf4j<br>public class RequestBulkConsumer {<br>private static final int DEFAULT_BULK_SIZE = 2000;<br><br>private CircularFifoBuffer buffer;<br>private EsBulkRequestService service;<br><br>private boolean isRunning = false;<br>private int bulkSize = DEFAULT_BULK_SIZE;<br><br>public RequestBulkConsumer(CircularFifoBuffer buffer, RestHighLevelClient client) {<br>this.buffer = buffer;<br>this.service = new EsBulkRequestService(client);<br>}<br><br>public void setBulkSize(int size) {<br>this.bulkSize = size;<br>}<br><br>public int<strong class=highlight-text toutiao-origin=span>getBulkSize</strong> {<br>return bulkSize;<br>}<br><br>public boolean<strong class=highlight-text toutiao-origin=span>isRunning</strong> {<br>return isRunning;<br>}<br><br><br>public void<strong class=highlight-text toutiao-origin=span>startConsume</strong> {<br>if(isRunning) {<br>return;<br>}<br>isRunning = true;<br>while(true) {<br>if(!isRunning) {<br>break;<br>}<br><br>Object  items = buffer.get(bulkSize);<br>if(items.length == 0) {<br>try {<br>Thread.sleep(1000);<br>} catch (InterruptedException e) {<br>break;<br>}<br>} else {<br>List&lt;DocWriteRequest&lt;?&gt;&gt; requests = convert(items);<br>try {<br>BulkResponse response = service.request(requests);<br>processResponse(response);<br>buffer.remove(items.length);<br>if (items.length &lt; bulkSize) {<br>Thread.sleep(3000);<br>}<br>} catch (InterruptedException e) {<br>break;<br>} catch (IOException e) {<br>log.error("wtf", e);<br>} catch (Exception e) {<br>log.error("wtf", e);<br>buffer.remove(items.length);<br>}<br>}<br>}<br>}<br><br><br>private List&lt;DocWriteRequest&lt;?&gt;&gt; convert(Object [] items) {<br>return Stream.of(items)<br>.map(i -&gt; {<br>if(i instanceof DocWriteRequest) {<br>return (DocWriteRequest&lt;?&gt;) i;<br>} else {<br>return ;<br>}<br>})<br>.filter(Objects::non)<br>.collect(Collectors.toList);<br>}<br><br>public void<strong class=highlight-text toutiao-origin=span>stop</strong> {<br>isRunning = false;<br>}<br><br><br>private void processResponse(BulkResponse bulkResponse) {<br>BulkItemResponse  itemResponseArr = bulkResponse.getItems;<br>for(BulkItemResponse resp : itemResponseArr) {<br>DocWriteResponse docWriteResponse = resp.getResponse;<br>if(docWriteResponse instanceof IndexResponse) {<br>IndexResponse indexResponse = (IndexResponse) docWriteResponse;<br>if(indexResponse.getResult != Result.CREATED &amp;&amp; indexResponse.getResult != Result.UPDATED) {<br>if(indexResponse.status == RestStatus.CONFLICT) {<br>continue;<br>} else {<br>log.error("索引更新失敗: {}, {}", indexResponse.getId, resp.getFailureMessage);<br>}<br>}<br>} else if(docWriteResponse instanceof DeleteResponse) {<br>DeleteResponse deleteResponse = (DeleteResponse) docWriteResponse;<br>if(deleteResponse.getResult != Result.DELETED) {<br>log.error("索引刪除失敗: {}, {}", deleteResponse.getId, resp.getFailureMessage);<br>}<br>}<br>}<br>}<br>}<br><br></code></pre><p>以下為Worker的主要幾個類的代碼。在索引同步系統中，高可用並不是最重要的，因為我們的搜索本身是一個準實時系統，只需要保證最終一致性就可以了，我們主要需要避免的是數據變更的丟失。以下說明在Worker中是如何避免數據丟失的。</p><p></p><h1 toutiao-origin=h3><strong toutiao-origin=h1>避免數據丟失</strong></h1><p>（1）如果Rabbit掛掉，沒關係，Canal Client那邊在Rabbit掛掉期間無法消費binlog，會等待Rabbit重啟之後再處理數據變化。Worker只要能做到Rabbit重啟之後重連就行。</p><p>（2）如果MySQL掛掉，則Worker無法從數據庫中獲取數據，則消息處理失敗，消息會堆積在Rabbit中。等MySQL重新上線之後，消息重新開始處理，數據也不會丟失。</p><p>（3）如果ES掛掉，則批量處理線程消費buffer中的數據時會失敗，buffer會被生產者填滿，由於CircularFifoBuffer在被填滿時使用了信號量阻塞生產者線程，消息又會被堆積在Rabbit中，等待ES重新上線之後，消息重新開始處理，數據也不會丟失。</p><p>（4）如果Rabbit隊列被寫滿，emmm，設置好在內存被佔滿時將消息寫入硬盤然後搞一個大一點的硬盤吧，Rabbit默認應該就是這麼做的。然後做好預警，當消息達到一定量時抓緊處理，一般來說可能性不是很大。</p><p>（5）版本衝突，如果商品表中某一條數據如商品A在同一秒內變化了兩次，消息隊列中有連續兩條消息，又由於這兩條消息可能在兩個線程中被消費，由於網絡，計算機性能等原因，先變的數據後被寫入ES中，導致ES中數據和MySql數據不一致。因此我們在更新索引時使用ES的外部版本號。使用從MySQL中取數據時的時間戳作為版本號，只有當時間戳比當前版本號大或相等時才能變更文檔，否則ES會報版本衝突錯誤。</p><pre><code> private IndexRequest convertToUpdateQuery(Long timestamp, OutStoreProduct outStoreProduct) throws JsonProcessingException {<br>IndexRequest indexRequest = new IndexRequest(indexName, "doc", outStoreProduct.getId);<br>if(StringUtils.isEmpty(outStoreProduct.getTooEbaoProductId)) {<br>log.error("商品 {} 的ebaoProductId為空，無法同步", outStoreProduct.getId);<br>return ;<br>}<br>indexRequest.source(om.writeValueAsString(outStoreProduct), XContentType.JSON)<br>.versionType(VersionType.EXTERNAL_GTE)<br>.version(timestamp)<br>.routing(outStoreProduct.getTooEbaoProductId);<br>return indexRequest;<br>}<br></code></pre><p></p><h1 toutiao-origin=h3><strong toutiao-origin=h1>關於全量同步</strong></h1><p>以上只是實現了增量同步，在索引初始化時，我們需要做全量同步操作，將數據從數據庫初始化到ES索引中。我們可以在Worker中寫一個接口，該接口實現邏輯分批將數據同步任務發到消息隊列中，其它worker收到消息後完成對應任務。比如我們可以發佈每一個門店的數據同步任務，worker每收到一個消息，同步一個門店的數據。</p><p></p><h1 toutiao-origin=h3><strong toutiao-origin=h1>總結</strong></h1><p>綜上，本系統是一個近實時的能夠保證ES和MySQL數據一致性的高效索引同步系統。</p><blockquote><p>作者：Tango2100 鏈接：https://juejin.im/post/6875591758802059278</p></blockquote><pre><br><div><img alt=基於CDC技術的ElasticSearch索引同步機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RdIEj9hARSR1DD></div><br><div><ul><li><p>基於 Apache Flink 的實時監控告警系統</p></li><li><p>關於數據中臺的深度思考與總結（乾乾貨）</p></li><li><p>日誌收集Agent，陰暗潮溼的地底世界</p></li><li><p>2020 繼續踏踏實實的做好自己</p></li></ul></div></pre><img alt=基於CDC技術的ElasticSearch索引同步機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S0FUMtl41NrEMK><img alt=基於CDC技術的ElasticSearch索引同步機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S0FUNTDJBxRdKz><pre><div><div><div><div><div><p>公眾號(<strong class=highlight-text toutiao-origin=span>zhisheng</strong>)裡回覆 面經、ClickHouse、ES、Flink、<strong class=highlight-text toutiao-origin=span>Spring、Java、Kafka、監控 </strong>等關鍵字可以查看更多關鍵字對應的文章。</p></div></div></div></div></div></pre><pre><div><div><div><div><div><div><div><div><div><div><div><div><div><div><p><strong toutiao-origin=span>👇</strong></p></div></div></div></div></div></div></div></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>CDC</a></li><li><a>技術</a></li><li><a>ElasticSearch</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html alt="技術帖 | 3分鐘搞定各種測試分析技術" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f055e0a4477240088de2abb7cd696cfa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html title="技術帖 | 3分鐘搞定各種測試分析技術">技術帖 | 3分鐘搞定各種測試分析技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d0ddee5.html alt=建築房屋結構平衡技術要求，你都會知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e7d0001715d878ed66c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d0ddee5.html title=建築房屋結構平衡技術要求，你都會知道嗎？>建築房屋結構平衡技術要求，你都會知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47c8cac0.html alt=新《裝配式混凝土建築技術標準》有哪些改變？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1540524372015dc56ec3fb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47c8cac0.html title=新《裝配式混凝土建築技術標準》有哪些改變？>新《裝配式混凝土建築技術標準》有哪些改變？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6c2fc2b.html alt=鈦合金精密鑄造技術發展現狀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SCynkUUBbHN8CF style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6c2fc2b.html title=鈦合金精密鑄造技術發展現狀>鈦合金精密鑄造技術發展現狀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2e8af08.html alt=傾斜航攝技術小知識——航線設計篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RS1ucOiDvLRlVt style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2e8af08.html title=傾斜航攝技術小知識——航線設計篇>傾斜航攝技術小知識——航線設計篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d597da51.html alt=黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1528429551298e033646798 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d597da51.html title=黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量>黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdb604f6.html alt=《雷神4：愛與雷》將採用“虛擬製作”技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/83a320a69b0f44e3baf7db07faac3c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdb604f6.html title=《雷神4：愛與雷》將採用“虛擬製作”技術>《雷神4：愛與雷》將採用“虛擬製作”技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cd5b6b6.html alt=虛擬現實技術在智能製造領域具有重要的應用價值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ed327880d3b4c5384619f21d6c81823 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cd5b6b6.html title=虛擬現實技術在智能製造領域具有重要的應用價值>虛擬現實技術在智能製造領域具有重要的應用價值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a2b0c81.html alt="虛擬製造的基石：數值模擬技術 | 加快實現工業數字化" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2f2c32f4bd734f9face045546d45a665 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a2b0c81.html title="虛擬製造的基石：數值模擬技術 | 加快實現工業數字化">虛擬製造的基石：數值模擬技術 | 加快實現工業數字化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ee69f5ac.html alt=基於機器視覺技術快速準確地確定收穫後幹大豆種子的品質 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/519b968bf69146fda9bf55f89779d373 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ee69f5ac.html title=基於機器視覺技術快速準確地確定收穫後幹大豆種子的品質>基於機器視覺技術快速準確地確定收穫後幹大豆種子的品質</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e203d547.html alt=和你一起的軍訓，下雨也甜蜜｜四川託普信息技術職業學院軍訓記 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4cd61c2a490f48ebb0aa74d30ec8766b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e203d547.html title=和你一起的軍訓，下雨也甜蜜｜四川託普信息技術職業學院軍訓記>和你一起的軍訓，下雨也甜蜜｜四川託普信息技術職業學院軍訓記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/916c8d26.html alt=鍋爐專業技術問答100條 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/916c8d26.html title=鍋爐專業技術問答100條>鍋爐專業技術問答100條</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0efa050d.html alt=「技術」差速器總成結構與性能參數分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa9c698160c045c8a64c08dac6018a30 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0efa050d.html title=「技術」差速器總成結構與性能參數分析>「技術」差速器總成結構與性能參數分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4db7ced8.html alt="技術 | 水泥磨主減速機高速軸軸承更換" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a1cfa2b9a4e74251a6b1114ba246a08f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4db7ced8.html title="技術 | 水泥磨主減速機高速軸軸承更換">技術 | 水泥磨主減速機高速軸軸承更換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/592a3506.html alt=鍋爐技術問答巡檢必看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/9e74752d-8d81-484a-9349-961881c64498 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/592a3506.html title=鍋爐技術問答巡檢必看>鍋爐技術問答巡檢必看</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>