<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux中斷處理 | 极客快訊</title><meta property="og:title" content="Linux中斷處理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/59a9811eea6b458e9c75fc84249c8beb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fc4961a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fc4961a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8fc4961a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fc4961a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fc4961a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8fc4961a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8fc4961a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8fc4961a.html><meta property="article:published_time" content="2020-10-29T21:09:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:37+08:00"><meta name=Keywords content><meta name=description content="Linux中斷處理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/8fc4961a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux中斷處理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1>中斷處理 - 上半部（硬中斷）</h1><p>由於 APIC中斷控制器 有點小複雜，所以本文主要通過 8259A中斷控制器 來介紹Linux對中斷的處理過程。</p><h1>中斷處理相關結構</h1><p>前面說過，8259A中斷控制器 由兩片 8259A 風格的外部芯片以 級聯 的方式連接在一起，每個芯片可處理多達 8 個不同的 IRQ（中斷請求），所以可用 IRQ 線的個數達到 15 個。如下圖：</p><div class=pgc-img><img alt=Linux中斷處理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/59a9811eea6b458e9c75fc84249c8beb><p class=pgc-img-caption></p></div><p>在內核中每條IRQ線由結構體 irq_desc_t 來描述，irq_desc_t 定義如下：</p><pre>typedef struct { unsigned int status; /* IRQ status */ hw_irq_controller *handler; struct irqaction *action; /* IRQ action list */ unsigned int depth; /* nested irq disables */ spinlock_t lock;} irq_desc_t;</pre><p>下面介紹一下 irq_desc_t 結構各個字段的作用：</p><ul class=list-paddingleft-2><li>status: IRQ線的狀態。</li><li>handler: 類型為 hw_interrupt_type 結構，表示IRQ線對應的硬件相關處理函數，比如 8259A中斷控制器 接收到一箇中斷信號時，需要發送一個確認信號才會繼續接收中斷信號的，發送確認信號的函數就是 hw_interrupt_type 中的 ack 函數。</li><li>action: 類型為 irqaction 結構，中斷信號的處理入口。由於一條IRQ線可以被多個硬件共享，所以 action 是一個鏈表，每個 action 代表一個硬件的中斷處理入口。</li><li>depth: 防止多次開啟和關閉IRQ線。</li><li>lock: 防止多核CPU同時對IRQ進行操作的自旋鎖。</li></ul><p>hw_interrupt_type 這個結構與硬件相關，這裡就不作介紹了，我們來看看 irqaction 這個結構：</p><pre>struct irqaction { void (*handler)(int, void *, struct pt_regs *); unsigned long flags; unsigned long mask; const char *name; void *dev_id; struct irqaction *next;};</pre><p>下面說說 irqaction 結構各個字段的作用：</p><ul class=list-paddingleft-2><li>handler: 中斷處理的入口函數，handler 的第一個參數是中斷號，第二個參數是設備對應的ID，第三個參數是中斷髮生時由內核保存的各個寄存器的值。</li><li>flags: 標誌位，用於表示 irqaction 的一些行為，例如是否能夠與其他硬件共享IRQ線。</li><li>name: 用於保存中斷處理的名字。</li><li>dev_id: 設備ID。</li><li>next: 每個硬件的中斷處理入口對應一個 irqaction 結構，由於多個硬件可以共享同一條IRQ線，所以這裡通過 next 字段來連接不同的硬件中斷處理入口。</li></ul><p>irq_desc_t 結構關係如下圖：</p><div class=pgc-img><img alt=Linux中斷處理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ad4d87322e46480498dcf8d18c93ca1d><p class=pgc-img-caption></p></div><h1>註冊中斷處理入口</h1><p>在內核中，可以通過 setup_irq() 函數來註冊一箇中斷處理入口。setup_irq() 函數代碼如下：</p><pre>int setup_irq(unsigned int irq, struct irqaction * new){ int shared = 0; unsigned long flags; struct irqaction *old, **p; irq_desc_t *desc = irq_desc + irq; ... spin_lock_irqsave(&amp;desc-&gt;lock,flags); p = &amp;desc-&gt;action; if ((old = *p) != NULL) { if (!(old-&gt;flags &amp; new-&gt;flags &amp; SA_SHIRQ)) { spin_unlock_irqrestore(&amp;desc-&gt;lock,flags); return -EBUSY; } do { p = &amp;old-&gt;next; old = *p; } while (old); shared = 1; } *p = new; if (!shared) { desc-&gt;depth = 0; desc-&gt;status &amp;= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING); desc-&gt;handler-&gt;startup(irq); } spin_unlock_irqrestore(&amp;desc-&gt;lock,flags); register_irq_proc(irq); // 註冊proc文件系統 return 0;}</pre><p>setup_irq() 函數比較簡單，就是通過 irq 號來查找對應的 irq_desc_t 結構，並把新的 irqaction 連接到 irq_desc_t 結構的 action 鏈表中。要注意的是，如果設備不支持共享IRQ線（也即是 flags 字段沒有設置 SA_SHIRQ 標誌），那麼就返回 EBUSY 錯誤。</p><p>我們看看 時鐘中斷處理入口 的註冊實例：</p><pre>static struct irqaction irq0 = { timer_interrupt, SA_INTERRUPT, 0, "timer", NULL, NULL};void __init time_init(void){ ... setup_irq(0, &amp;irq0);}</pre><p>可以看到，時鐘中斷處理入口的IRQ號為0，處理函數為 timer_interrupt()，並且不支持共享IRQ線（flags 字段沒有設置 SA_SHIRQ 標誌）。</p><h1>處理中斷請求</h1><p>當一箇中斷髮生時，中斷控制層會發送信號給CPU，CPU收到信號會中斷當前的執行，轉而執行中斷處理過程。中斷處理過程首先會保存寄存器的值到棧中，然後調用 do_IRQ() 函數進行進一步的處理，do_IRQ() 函數代碼如下：</p><pre>asmlinkage unsigned int do_IRQ(struct pt_regs regs){ int irq = regs.orig_eax &amp; 0xff; /* 獲取IRQ號 */ int cpu = smp_processor_id(); irq_desc_t *desc = irq_desc + irq; struct irqaction * action; unsigned int status; kstat.irqs[cpu][irq]++; spin_lock(&amp;desc-&gt;lock); desc-&gt;handler-&gt;ack(irq); status = desc-&gt;status &amp; ~(IRQ_REPLAY | IRQ_WAITING); status |= IRQ_PENDING; /* we _want_ to handle it */ action = NULL; if (!(status &amp; (IRQ_DISABLED | IRQ_INPROGRESS))) { // 當前IRQ不在處理中 action = desc-&gt;action; // 獲取 action 鏈表 status &amp;= ~IRQ_PENDING; // 去除IRQ_PENDING標誌, 這個標誌用於記錄是否在處理IRQ請求的時候又發生了中斷 status |= IRQ_INPROGRESS; // 設置IRQ_INPROGRESS標誌, 表示正在處理IRQ } desc-&gt;status = status; if (!action) // 如果上一次IRQ還沒完成, 直接退出 goto out; for (;;) { spin_unlock(&amp;desc-&gt;lock); handle_IRQ_event(irq, ®s, action); // 處理IRQ請求 spin_lock(&amp;desc-&gt;lock);  if (!(desc-&gt;status &amp; IRQ_PENDING)) // 如果在處理IRQ請求的時候又發生了中斷, 繼續處理IRQ請求 break; desc-&gt;status &amp;= ~IRQ_PENDING; } desc-&gt;status &amp;= ~IRQ_INPROGRESS;out: desc-&gt;handler-&gt;end(irq); spin_unlock(&amp;desc-&gt;lock); if (softirq_active(cpu) &amp; softirq_mask(cpu)) do_softirq(); // 中斷下半部處理 return 1;}</pre><p>do_IRQ() 函數首先通過IRQ號獲取到其對應的 irq_desc_t 結構，注意的是同一個中斷有可能發生多次，所以要判斷當前IRQ是否正在被處理當中（判斷 irq_desc_t 結構的 status 字段是否設置了 IRQ_INPROGRESS 標誌），如果不是處理當前，那麼就獲取到 action 鏈表，然後通過調用 handle_IRQ_event() 函數來執行 action 鏈表中的中斷處理函數。</p><p>如果在處理中斷的過程中又發生了相同的中斷（irq_desc_t 結構的 status 字段被設置了 IRQ_INPROGRESS 標誌），那麼就繼續對中斷進行處理。處理完中斷後，調用 do_softirq() 函數來對中斷下半部進行處理（下面會說）。</p><p>接下來看看 handle_IRQ_event() 函數的實現：</p><pre>int handle_IRQ_event(unsigned int irq, struct pt_regs * regs, struct irqaction * action){ int status; int cpu = smp_processor_id(); irq_enter(cpu, irq); status = 1; /* Force the "do bottom halves" bit */ if (!(action-&gt;flags &amp; SA_INTERRUPT)) // 如果中斷處理能夠在打開中斷的情況下執行, 那麼就打開中斷 __sti(); do { status |= action-&gt;flags; action-&gt;handler(irq, action-&gt;dev_id, regs); action = action-&gt;next; } while (action); if (status &amp; SA_SAMPLE_RANDOM) add_interrupt_randomness(irq); __cli(); irq_exit(cpu, irq); return status;}</pre><p>handle_IRQ_event() 函數非常簡單，就是遍歷 action 鏈表並且執行其中的處理函數，比如對於 時鐘中斷 就是調用 timer_interrupt() 函數。這裡要注意的是，如果中斷處理過程能夠開啟中斷的，那麼就把中斷打開（因為CPU接收到中斷信號時會關閉中斷）。</p><h1>中斷處理 - 下半部（軟中斷）</h1><p>由於中斷處理一般在關閉中斷的情況下執行，所以中斷處理不能太耗時，否則後續發生的中斷就不能實時地被處理。鑑於這個原因，Linux把中斷處理分為兩個部分，上半部 和 下半部，上半部 在前面已經介紹過，接下來就介紹一下 下半部 的執行。</p><p>一般中斷 上半部 只會做一些最基礎的操作（比如從網卡中複製數據到緩存中），然後對要執行的中斷 下半部 進行標識，標識完調用 do_softirq() 函數進行處理。</p><h1>softirq機制</h1><p>中斷下半部 由 softirq（軟中斷） 機制來實現的，在Linux內核中，有一個名為 softirq_vec 的數組，如下：</p><pre>static struct softirq_action softirq_vec[32];</pre><p>其類型為 softirq_action 結構，定義如下：</p><pre>struct softirq_action{ void (*action)(struct softirq_action *); void *data;};</pre><p>softirq_vec 數組是 softirq 機制的核心，softirq_vec 數組每個元素代表一種softirq。但在Linux中只定義了四種softirq，如下：</p><pre>enum{ HI_SOFTIRQ=0, NET_TX_SOFTIRQ, NET_RX_SOFTIRQ, TASKLET_SOFTIRQ};</pre><p>HI_SOFTIRQ 是高優先級tasklet，而 TASKLET_SOFTIRQ 是普通tasklet，tasklet是基於softirq機制的一種任務隊列（下面會介紹）。NET_TX_SOFTIRQ 和 NET_RX_SOFTIRQ 特定用於網絡子模塊的軟中斷（不作介紹）。</p><h1>註冊softirq處理函數</h1><p>要註冊一個softirq處理函數，可以通過 open_softirq() 函數來進行，代碼如下：</p><pre>void open_softirq(int nr, void (*action)(struct softirq_action*), void *data){ unsigned long flags; int i; spin_lock_irqsave(&amp;softirq_mask_lock, flags); softirq_vec[nr].data = data; softirq_vec[nr].action = action; for (i=0; i&lt;NR_CPUS; i++) softirq_mask(i) |= (1&lt;&lt;nr); spin_unlock_irqrestore(&amp;softirq_mask_lock, flags);}</pre><p>open_softirq() 函數的主要工作就是向 softirq_vec 數組添加一個softirq處理函數。</p><p>Linux在系統初始化時註冊了兩種softirq處理函數，分別為 TASKLET_SOFTIRQ 和 HI_SOFTIRQ：</p><pre>void __init softirq_init(){ ... open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL); open_softirq(HI_SOFTIRQ, tasklet_hi_action, NULL);}</pre><h1>處理softirq</h1><p>處理softirq是通過 do_softirq() 函數實現，代碼如下：</p><pre>asmlinkage void do_softirq(){ int cpu = smp_processor_id(); __u32 active, mask; if (in_interrupt()) return; local_bh_disable(); local_irq_disable(); mask = softirq_mask(cpu); active = softirq_active(cpu) &amp; mask; if (active) { struct softirq_action *h;restart: softirq_active(cpu) &amp;= ~active; local_irq_enable(); h = softirq_vec; mask &amp;= ~active; do { if (active &amp; 1) h-&gt;action(h); h++; active &gt;&gt;= 1; } while (active); local_irq_disable(); active = softirq_active(cpu); if ((active &amp;= mask) != 0) goto retry; } local_bh_enable(); return;retry: goto restart;}</pre><p>前面說了 softirq_vec 數組有32個元素，每個元素對應一種類型的softirq，那麼Linux怎麼知道哪種softirq需要被執行呢？在Linux中，每個CPU都有一個類型為 irq_cpustat_t 結構的變量，irq_cpustat_t 結構定義如下：</p><pre>typedef struct { unsigned int __softirq_active; unsigned int __softirq_mask; ...} irq_cpustat_t;</pre><p>其中 __softirq_active 字段表示有哪種softirq觸發了（int類型有32個位，每一個位代表一種softirq），而 __softirq_mask 字段表示哪種softirq被屏蔽了。Linux通過 __softirq_active 這個字段得知哪種softirq需要執行（只需要把對應位設置為1）。</p><p>所以，do_softirq() 函數首先通過 softirq_mask(cpu) 來獲取當前CPU對應被屏蔽的softirq，而 softirq_active(cpu) & mask 就是獲取需要執行的softirq，然後就通過對比 __softirq_active 字段的各個位來判斷是否要執行該類型的softirq。</p><h1>tasklet機制</h1><p>前面說了，tasklet機制是基於softirq機制的，tasklet機制其實就是一個任務隊列，然後通過softirq執行。在Linux內核中有兩種tasklet，一種是高優先級tasklet，一種是普通tasklet。這兩種tasklet的實現基本一致，唯一不同的就是執行的優先級，高優先級tasklet會先於普通tasklet執行。</p><p>tasklet本質是一個隊列，通過結構體 tasklet_head 存儲，並且每個CPU有一個這樣的隊列，我們來看看結構體 tasklet_head 的定義：</p><pre>struct tasklet_head{ struct tasklet_struct *list;};struct tasklet_struct{ struct tasklet_struct *next; unsigned long state; atomic_t count; void (*func)(unsigned long); unsigned long data;};</pre><p>從 tasklet_head 的定義可以知道，tasklet_head 結構是 tasklet_struct 結構隊列的頭部，而 tasklet_struct 結構的 func 字段正式任務要執行的函數指針。Linux定義了兩種的tasklet隊列，分別為 tasklet_vec 和 tasklet_hi_vec，定義如下：</p><pre>struct tasklet_head tasklet_vec[NR_CPUS];struct tasklet_head tasklet_hi_vec[NR_CPUS];</pre><p>可以看出，tasklet_vec 和 tasklet_hi_vec 都是數組，數組的元素個數為CPU的核心數，也就是每個CPU核心都有一個高優先級tasklet隊列和一個普通tasklet隊列。</p><h1>調度tasklet</h1><p>如果我們有一個tasklet需要執行，那麼高優先級tasklet可以通過 tasklet_hi_schedule() 函數調度，而普通tasklet可以通過 tasklet_schedule() 調度。這兩個函數基本一樣，所以我們只分析其中一個：</p><pre>static inline void tasklet_hi_schedule(struct tasklet_struct *t){ if (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) { int cpu = smp_processor_id(); unsigned long flags; local_irq_save(flags); t-&gt;next = tasklet_hi_vec[cpu].list; tasklet_hi_vec[cpu].list = t; __cpu_raise_softirq(cpu, HI_SOFTIRQ); local_irq_restore(flags); }}</pre><p>函數參數的類型是 tasklet_struct 結構的指針，表示需要執行的tasklet結構。tasklet_hi_schedule() 函數首先判斷這個tasklet是否已經被添加到隊列中，如果不是就添加到 tasklet_hi_vec 隊列中，並且通過調用 __cpu_raise_softirq(cpu, HI_SOFTIRQ) 來告訴softirq需要執行 HI_SOFTIRQ 類型的softirq，我們來看看 __cpu_raise_softirq() 函數的實現：</p><pre>static inline void __cpu_raise_softirq(int cpu, int nr){ softirq_active(cpu) |= (1&lt;&lt;nr);}</pre><p>可以看出，__cpu_raise_softirq() 函數就是把 irq_cpustat_t 結構的 __softirq_active 字段的 nr位 設置為1。對於 tasklet_hi_schedule() 函數就是把 HI_SOFTIRQ 位（0位）設置為1。</p><p>前面我們也介紹過，Linux在初始化時會註冊兩種softirq，TASKLET_SOFTIRQ 和 HI_SOFTIRQ：</p><pre>void __init softirq_init(){ ... open_softirq(TASKLET_SOFTIRQ, tasklet_action, NULL); open_softirq(HI_SOFTIRQ, tasklet_hi_action, NULL);}</pre><p>所以當把 irq_cpustat_t 結構的 __softirq_active 字段的 HI_SOFTIRQ 位（0位）設置為1時，softirq機制就會執行 tasklet_hi_action() 函數，我們來看看 tasklet_hi_action() 函數的實現：</p><pre>static void tasklet_hi_action(struct softirq_action *a){ int cpu = smp_processor_id(); struct tasklet_struct *list; local_irq_disable(); list = tasklet_hi_vec[cpu].list; tasklet_hi_vec[cpu].list = NULL; local_irq_enable(); while (list != NULL) { struct tasklet_struct *t = list; list = list-&gt;next; if (tasklet_trylock(t)) { if (atomic_read(&amp;t-&gt;count) == 0) { clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state); t-&gt;func(t-&gt;data); // 調用tasklet處理函數 tasklet_unlock(t); continue; } tasklet_unlock(t); } ... }}</pre><p>tasklet_hi_action() 函數非常簡單，就是遍歷 tasklet_hi_vec 隊列並且執行其中tasklet的處理函數。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>中斷</a></li><li><a>處理</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5872af9.html alt=Linux中斷機制：硬件處理，初始化和中斷處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534258428582a2d6399914 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5872af9.html title=Linux中斷機制：硬件處理，初始化和中斷處理>Linux中斷機制：硬件處理，初始化和中斷處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac9fd9af.html alt=Linux操作系統：中斷處理過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17704512f67548ca96fd8fd620faef19 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac9fd9af.html title=Linux操作系統：中斷處理過程>Linux操作系統：中斷處理過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f41535b.html alt=linux中斷處理原理分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/669c7a39bbff469299275a067db11edd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f41535b.html title=linux中斷處理原理分析>linux中斷處理原理分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/70eb09f7.html alt=三菱PLC的中斷處理，如何正確的理解中斷的功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f513a0c7db0c4af6b20dc932e0294eb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/70eb09f7.html title=三菱PLC的中斷處理，如何正確的理解中斷的功能>三菱PLC的中斷處理，如何正確的理解中斷的功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbfe10e6.html alt=中斷處理流程（硬件層，系統層） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/tos-cn-i-0022/e84364f92a864e78b26ea1b63caf964e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbfe10e6.html title=中斷處理流程（硬件層，系統層）>中斷處理流程（硬件層，系統層）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acbd1b34.html alt=詳解Linux內核申請中斷和釋放中斷的過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73334d5bcc9a4ada9e92b448b4d66b16 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acbd1b34.html title=詳解Linux內核申請中斷和釋放中斷的過程>詳解Linux內核申請中斷和釋放中斷的過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfdf682.html alt=在Linux設備樹(DTS)中指定中斷_在代碼中獲得中斷 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c85dbbf616b54b239fd837785985e9dd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfdf682.html title=在Linux設備樹(DTS)中指定中斷_在代碼中獲得中斷>在Linux設備樹(DTS)中指定中斷_在代碼中獲得中斷</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/643fc46.html alt=Linux操作系統：中斷類型和中斷的作用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0d24b57cc77a4ca58d3bba53a1990e63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/643fc46.html title=Linux操作系統：中斷類型和中斷的作用>Linux操作系統：中斷類型和中斷的作用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/74a7661.html alt=Linux操作系統：中斷優先級和多重中斷 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f6752484caba4c3b9ae17d93cae63802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/74a7661.html title=Linux操作系統：中斷優先級和多重中斷>Linux操作系統：中斷優先級和多重中斷</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/160af1cf.html alt=牆面基層處理有哪些基本步驟 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZdKr6O1pG4jKu style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/160af1cf.html title=牆面基層處理有哪些基本步驟>牆面基層處理有哪些基本步驟</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>