<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux kernel中常見的宏整理 | 极客快訊</title><meta property="og:title" content="Linux kernel中常見的宏整理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/907ac78.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><meta property="article:published_time" content="2020-10-29T21:04:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:55+08:00"><meta name=Keywords content><meta name=description content="Linux kernel中常見的宏整理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/907ac78.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux kernel中常見的宏整理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>0x00 宏的基本知識</h1><pre>// object-like#define 宏名 替換列表 換行符//function-like#define 宏名 ([標識符列表]) 替換列表 換行符</pre><p>替換列表和標識符列表都是將字符串 token 化以後的列表。區別在於標識符列表使用,作為不同參數之間的分割符。每一個參數都是一個 token 化的列表。在宏中空白符只起到分割 token 的作用，空白符的多少對於預處理器是沒有意義的。</p><p>宏的一些奇技淫巧：</p><p>https://gaomf.cn/2017/10/06/C_Macro/</p><p>以下是整理的一些linux kernel中的常見宏，由於不同體系架構，或者不同模塊的宏定義不同，只挑選了其中容易看懂的宏作為記錄，實現的功能大體一樣。</p><h1 class=pgc-h-arrow-right>Linux內核中do{...}while(0)意義：</h1><ul><li>輔助定義複雜的宏，避免引用的時候出錯，如果不用{}，if後面的語句只有第一條進行了判斷。同時避免宏展開後“;”造成編譯不通過.</li><li>避免使用goto，對程序流進行統一的控制，使用break跳出</li><li>避免空宏引起的warning</li><li>定義一個單獨的函數塊來實現複雜的操作</li></ul><h1 class=pgc-h-arrow-right>0x01 常見宏整理</h1><h1 class=pgc-h-arrow-right>__CONCAT宏</h1><p>"##"用於粘貼兩個參數，"#"用於替換參數：</p><pre>#define __CONCAT(a, b) a ## b</pre><h1 class=pgc-h-arrow-right>BUG_ON(condition)</h1><p>條件為真，產生崩潰， 原理：未定義的異常。</p><p>相對應的有 WARN_ON：</p><pre>#define BUG() assert(0)#define BUG_ON(x) assert(!(x)) /* Does it make sense to treat warnings as errors? */#define WARN() BUG()#define WARN_ON(x) (BUG_ON(x), false)</pre><h1 class=pgc-h-arrow-right>BUILD_BUG_ON宏</h1><pre>#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))</pre><ol start=1><li>condition為真時，sizeof(char[-1])，產生錯誤，編譯不通過</li><li>condition為假時，sizeof(char[1])，編譯通過</li></ol><p>檢查表達式e是否為0，為0編譯通過且返回0；如果不為0，則編譯不通過。</p><pre>struct { int : –!!(0); } -=&gt; struct { int : 0; }</pre><p>如果e為0，則該結構體擁有一個int型的數據域，並且規定它所佔的位的個數為0。</p><pre>struct { int : –!!(1); } -=&gt; struct { int : –1; }</pre><p>如果e非0，結構體的int型數據域的位域將變為一個負數，產生語法的錯誤。</p><p>typeof獲得x的變量類型，根據傳入參數類型的不同，產生不同的行為，實現“編譯時多態”。實際typeof是在預編譯時處理，最後實際轉化為數據類型被編譯器處理。</p><p>所以其中的表達式在運行時是不會被執行的，比如typeof(fun())，fun()函數是不會被執行的，typeof只是在編譯時分析得到了fun()的返回值而已。</p><p>typeof還有一些侷限性，其中的變量是不能包含存儲類說明符的，如static、extern這類都是不行的。</p><h1 class=pgc-h-arrow-right>typecheck宏</h1><p>宏typecheck用於檢查x是否為type類型，如果不是會拋出（warning: comparison of distinct pointer types lacks a cast），typecheck_fn用於檢查函數function是否為type類型，不一致跑出（warning: initialization from incompatible pointer type）。</p><pre>/* * Check at compile time that something is of a particular type. * Always evaluates to 1 so you may use it easily in comparisons. */#define typecheck(type,x) \({ type __dummy; \    typeof(x) __dummy2; \    (void)(&amp;__dummy == &amp;__dummy2); \    1; \})/*GCC的一個擴展特性，形如({ ... })這樣的代碼塊會被視為一條語句，* 其計算結果是{ ... }中最後一條語句的計算結果。* 所以上述會返回1*//* * Check at compile time that &#39;function&#39; is a certain type, or is a pointer * to that type (needs to use typedef for the function type.) */#define typecheck_fn(type,function) \({ typeof(type) __tmp = function; \    (void)__tmp; \})</pre><h1 class=pgc-h-arrow-right>min宏</h1><p>通過type進行隱式轉換安全通過編譯，否則會跑出warning：</p><pre>#define min(x, y) __careful_cmp(x, y, &lt;)#define __cmp(x, y, op) ((x) op (y) ? (x) : (y))#define __safe_cmp(x, y) \        (__typecheck(x, y) &amp;&amp; __no_side_effects(x, y))#define __no_side_effects(x, y) \        (__is_constexpr(x) &amp;&amp; __is_constexpr(y)) #define __cmp_once(x, y, unique_x, unique_y, op) ({ \        typeof(x) unique_x = (x); \        typeof(y) unique_y = (y); \        __cmp(unique_x, unique_y, op); })/*重新賦值為了防止x++這種重複+1 */#define __careful_cmp(x, y, op) \    __builtin_choose_expr(__safe_cmp(x, y), \ //比較x, y的類型        __cmp(x, y, op), \ //x,y類型一樣時        __cmp_once(x, y, __UNIQUE_ID(__x), __UNIQUE_ID(__y), op))          //x, y類型不同時</pre><p>__UNIQUE_ID保證變量唯一。</p><h1 class=pgc-h-arrow-right>__is_constexpr宏</h1><p>判斷x是否為整數常量表達式：</p><pre>/* * This returns a constant expression while determining if an argument is * a constant expression, most importantly without evaluating the argument. * Glory to Martin Uecker &lt;Martin.Uecker@med.uni-goettingen.de&gt; */#define __is_constexpr(x) \    (sizeof(int) == sizeof(*(8 ? ((void *)((long)(x) * 0l)) : (int *)8)))</pre><p>如果x是常量表達式，則(void )((long)(x) 0l)是一個空指針常量，就會使用第三個操作數即((int *)8)的類型。如果不是常量表達式，則會使用第二個操作數void類型。</p><p>所以會出現以下兩種情況：</p><pre>sizeof(int) == sizeof(*((int *) (NULL))) // if `x` was an integer constant expressionsizeof(int) == sizeof(*((void *)(....))) // otherwise</pre><p>因為sizeof(void) = 1，所以如果x是整數常量表達式，則宏的結果為1，否則為0。</p><p>https://stackoverflow.com/questions/49481217/linux-kernels-is-constexpr-macro</p><p>描述：此函數為GNU擴展，用來判斷兩個類型是否相同，如果type_a與 type_b相同的話，就會返回1，否則的話，返回0。</p><pre>int __builtin_choose_expr(exp, e1, e2);</pre><h1 class=pgc-h-arrow-right>max宏</h1><p>同min 宏。</p><h1 class=pgc-h-arrow-right>roundup宏</h1><p>返回一個能夠整除y並且大於x，最接近x的值，向上取整，可用於地址的內存對齊：</p><pre>#define roundup(x, y) ( \{ \    const typeof(y) __y = y; \    (((x) + (__y - 1)) / __y) * __y; \} \)</pre><h1 class=pgc-h-arrow-right>clamp 宏</h1><p>判斷val是否在lo和hi的範圍內，如果小於lo，返回lo，如果大於hi則返回hi，如果在lo和hi之間就返回val：</p><pre>/** * clamp - return a value clamped to a given range with strict typechecking * @val: current value * @lo: lowest allowable value * @hi: highest allowable value * * This macro does strict typechecking of @lo/@hi to make sure they are of the * same type as @val. See the unnecessary pointer comparisons. */#define clamp(val, lo, hi) min((typeof(val))max(val, lo), hi)</pre><h1 class=pgc-h-arrow-right>abs宏</h1><p>取絕對值：</p><pre>/** * abs - return absolute value of an argument * @x: the value. If it is unsigned type, it is converted to signed type first. * char is treated as if it was signed (regardless of whether it really is) * but the macro&#39;s return type is preserved as char. * * Return: an absolute value of x. */#define abs(x) __abs_choose_expr(x, long long, \        __abs_choose_expr(x, long, \        __abs_choose_expr(x, int, \        __abs_choose_expr(x, short, \        __abs_choose_expr(x, char, \        __builtin_choose_expr( \            __builtin_types_compatible_p(typeof(x), char), \            (char)({ signed char __x = (x); __x&lt;0?-__x:__x; }), \            ((void)0))))))) #define __abs_choose_expr(x, type, other) __builtin_choose_expr( \    __builtin_types_compatible_p(typeof(x), signed type) || \    __builtin_types_compatible_p(typeof(x), unsigned type), \    ({ signed type __x = (x); __x &lt; 0 ? -__x : __x; }), other)</pre><h1 class=pgc-h-arrow-right>swap 宏</h1><p>利用typeof獲取要交換變量的類型：</p><pre>/* * swap - swap value of @a and @b */#define swap(a, b) \    do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)</pre><h1 class=pgc-h-arrow-right>container_of宏</h1><p>根據一個結構體變量中的成員變量來獲取整個結構體變量的指針。</p><pre>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)/*結構體地址為0，將member地址轉成size_t類型作為偏移/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */#define container_of(ptr, type, member) ({ \    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ //*__mptr保存該member變量的指針    (type *)( (char *)__mptr - offsetof(type,member) );}) //變量指針減去自身偏移得到指向結構體的指針</pre><h3 class=pgc-h-arrow-right>likely和unlikely宏</h3><p>把分支預測的信息提供給編譯器，以降低因為指令跳轉帶來的分支下降：</p><pre>#define likely(x) __builtin_exp ect(!!(x), 1)#define unlikely(x) __builtin_exp ect(!!(x), 0)</pre><p>GCC的內建方法會判斷 EXP == C 是否成立，成立則將if分支中的執行語句緊跟放在彙編跳轉指令之後，否則將else分支中的執行語句緊跟彙編跳轉指令之後。</p><p>這樣cache在預取數據時就可以將分支後的執行語句放在cache中，提高cache的命中率。</p><h1 class=pgc-h-arrow-right>ALIGN對齊宏</h1><p>對齊是採用上對齊的方式，例如0x123以16對齊，結果是0x130，因為對齊常在分配內存時使用，所以分配的要比需要的大。</p><pre>#define ALIGN(x, a) __ALIGN_KERNEL((x), (a))#define __ALIGN_KERNEL(x, a) __ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)#define __ALIGN_KERNEL_MASK(x, mask) (((x) + (mask)) &amp; ~(mask))#define __ALIGN_MASK(x, mask) __ALIGN_KERNEL_MASK((x), (mask))</pre><h1 class=pgc-h-arrow-right>__get_unaligned_le(ptr)宏</h1><p>獲取未對齊的數據，主要是識別數據大小：</p><pre>#define __get_unaligned_le(ptr) ((__force typeof(*(ptr)))({ \    __builtin_choose_expr(sizeof(*(ptr)) == 1, *(ptr), \    __builtin_choose_expr(sizeof(*(ptr)) == 2, get_unaligned_le16((ptr)), \    __builtin_choose_expr(sizeof(*(ptr)) == 4, get_unaligned_le32((ptr)), \    __builtin_choose_expr(sizeof(*(ptr)) == 8, get_unaligned_le64((ptr)), \    __bad_unaligned_access_size())))); \ }))  static inline u32 get_unaligned_be32(const void *p){    return __get_unaligned_cpu32((const u8 *)p);} static inline u32 __get_unaligned_cpu32(const void *p){    const struct __una_u32 *ptr = (const struct __una_u32 *)p;    return ptr-&gt;x;} struct __una_u16 { u16 x; } __packed;struct __una_u32 { u32 x; } __packed;struct __una_u64 { u64 x; } __packed;</pre><p>編譯器默認會對結構體採用字節對齊的方式，__packed關鍵字可以取消字節對齊，採用1字節對齊。</p><h1 class=pgc-h-arrow-right>__put_unaligned_le宏</h1><p>寫入未對齊的數據。</p><pre>#define __put_unaligned_le(val, ptr) ({ \    void *__gu_p = (ptr); \    switch (sizeof(*(ptr))) { \    case 1: \        *(u8 *)__gu_p = (__force u8)(val); \        break; \    case 2: \        put_unaligned_le16((__force u16)(val), __gu_p); \        break; \    case 4: \        put_unaligned_le32((__force u32)(val), __gu_p); \        break; \    case 8: \        put_unaligned_le64((__force u64)(val), __gu_p); \        break; \    default: \        __bad_unaligned_access_size(); \        break; \    } \    (void)0; })  static inline void put_unaligned_be32(u32 val, void *p){    __put_unaligned_cpu32(val, p);} static inline void __put_unaligned_cpu32(u32 val, void *p){    struct __una_u32 *ptr = (struct __una_u32 *)p;    ptr-&gt;x = val;}</pre><h1 class=pgc-h-arrow-right>ACCESS_ONCE 宏</h1><p>訪問目標地址一次，先取得x的地址，然後把這個地址轉換成一個指向這個地址類型的指針，然後再取得這個指針所指向的內容，達到了訪問一次的目的。volatile表示不進行優化，強制訪問一次。</p><p>在一些併發的場景中對變量進行優化有可能導致錯誤，需要時刻得到變量的最新值，所以用volatile強制訪問一次進行更新。</p><p>使用 ACCESS_ONCE() 的兩個條件是：</p><ul><li>在無鎖的情況下訪問全局變量</li><li>對該變量的訪問可能被編譯器優化成合併成一次或者拆分成多次</li></ul><pre>#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</pre><p>https://blog.csdn.net/ganggexiongqi/article/details/24603363</p><h1 class=pgc-h-arrow-right>ACCESS_OK宏</h1><p>CVE-2017-5123（waitid系統調用）,檢查指針是不是屬於用戶空間的，x86架構下ACCESS_OK宏的實現：</p><pre>/** * access_ok: - Checks if a user space pointer is valid * @addr: User space pointer to start of block to check * @size: Size of block to check * * Context: User context only. This function may sleep if pagefaults are * enabled. * * Checks if a pointer to a block of memory in user space is valid. * * Returns true (nonzero) if the memory block may be valid, false (zero) * if it is definitely invalid. * * Note that, depending on architecture, this function probably just * checks that the pointer is in the user space range - after calling * this function, memory access functions may still return -EFAULT. */#define access_ok(addr, size) \({ \    WARN_ON_IN_IRQ(); \    likely(!__range_not_ok(addr, size, user_addr_max())); \})/*__range_not_ok返回0才能驗證通過 #define __range_not_ok(addr, size, limit) \({ \    __chk_user_ptr(addr); \    __chk_range_not_ok((unsigned long __force)(addr), size, limit); \}) /* * Test whether a block of memory is a valid user space address. * Returns 0 if the range is valid, nonzero otherwise. */static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, unsigned long limit){    /*     * If we have used &#34;sizeof()&#34; for the size,     * we know it won&#39;t overflow the limit (but     * it might overflow the &#39;addr&#39;, so it&#39;s     * important to subtract the size from the     * limit, not add it to the address).     */    if (__builtin_constant_p(size))        return unlikely(addr &gt; limit - size);    /*__builtin_constant_p判斷編譯時是否為常數，如果是則返回1 */    /* Arbitrary sizes? Be careful about overflow */    addr += size;    if (unlikely(addr &lt; size))        return true;    return unlikely(addr &gt; limit);}</pre><h1 class=pgc-h-arrow-right>mdelay宏</h1><p>忙等待函數，在延遲過程中無法運行其他任務，會佔用CPU時間，延遲時間是準確的。</p><p>msleep是休眠函數，它不涉及忙等待．用msleep（200）的時候實際上延遲的時間，大部分時候是要多於200ms，是個不定的時間值。</p><pre>#define MAX_UDELAY_MS 5#define mdelay(n) (\ /*延遲毫秒級*/    (__builtin_constant_p(n) &amp;&amp; (n)&lt;=MAX_UDELAY_MS) ? udelay((n)*1000) : \    ({unsigned long __ms=(n); while (__ms--) udelay(1000);})) static void udelay(int loops) /*延遲微秒級 */{    while (loops--)        io_delay(); /* Approximately 1 us */} static inline void io_delay(void){    const u16 DELAY_PORT = 0x80;    asm volatile(&#34;outb %%al,%0&#34; : : &#34;dN&#34; (DELAY_PORT));}/*對 I/O 端口 0x80 寫入任何的字節都將得到 1 us 的延時*/</pre><h3 class=pgc-h-arrow-right>系統調用宏</h3><p>linux 內核中最常見的宏使用之一，系統調用：</p><pre>#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)/*…：省略號代表可變的部分，用__VA_AEGS__ 代表省略的變長部分*/#define SYSCALL_DEFINE_MAXARGS    6  /*系統調用最多可以帶6個參數*/</pre><p>以open系統調用為例：</p><p>SYSCALL_DEFINE</p><p>後面跟系統調用所帶的參數個數n，第一個參數為系統調用的名字，然後接2*n個參數，每一對指明系統調用的參數類型及名字。</p><pre>SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode){    if (force_o_largefile())        flags |= O_LARGEFILE;     return do_sys_open(AT_FDCWD, filename, flags, mode);}SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)展開之後是：SYSCALL_DEFINEx(3, _open, __VA_ARGS__)</pre><p>再次展開為：</p><pre>__SYSCALL_DEFINEx(3, _open, __VA_ARGS__)#define __SYSCALL_DEFINEx(x, name, ...) \    asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) \</pre><p>最後展開為：</p><pre>asmlinkage long sys_open(__MAP(3,__SC_DECL,__VA_ARGS__)) #define __MAP0(m,...)#define __MAP1(m,t,a) m(t,a)#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)#define __MAP(n,...) __MAP##n(__VA_ARGS__) #define __SC_DECL(t, a) t a __MAP(3,__SC_DECL,__VA_ARGS__)--&gt;__MAP3(__SC_DECL,const char __user *, filename, int, flags, umode_t, mode)--&gt;__SC_DECL(const char __user *, filename), __MAP2(__SC_DECL,__VA_ARGS__)--&gt;const char __user * filename,__SC_DECL(int, flags),__MAP1(__SC_DECL,__VA_ARGS__)--&gt;const char __user * filename, int flags, __SC_DECL(umode_t, mode)--&gt;const char __user * filename, int flags, umode_t mode</pre><p>最後調用asmlinkage long sys_open(const char __user *filename,int flags, umode_t mode);</p><p>為什麼要將系統調用定義成宏？CVE-2009-0029，CVE-2010-3301，Linux 2.6.28及以前版本的內核中，將系統調用中32位參數傳入64位的寄存器時無法作符號擴展，可能導致系統崩潰或提權漏洞。</p><p>內核開發者通過將系統調用的所有輸入參數都先轉化成long類型（64位），再強制轉化到相應的類型來規避這個漏洞。</p><pre>asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__)) \{ \        long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\        __MAP(x,__SC_TEST,__VA_ARGS__); \        __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__)); \        return ret; \} \  #define __TYPE_AS(t, v) __same_type((__force t)0, v) /*判斷t和v是否是同一個類型*/#define __TYPE_IS_L(t) (__TYPE_AS(t, 0L)) /*判斷t是否是long 類型,是返回1*/#define __TYPE_IS_UL(t) (__TYPE_AS(t, 0UL)) /*判斷t是否是unsigned long 類型,是返回1*/#define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))/*是long類型就返回1*/#define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a/*將參數轉換成long類型*/#define __SC_CAST(t, a) (__force t) a /*轉成成原來的類型*/# define __force __attribute__((force))</pre><p>表示所定義的變量類型可以做強制類型轉換</p><h1 class=pgc-h-arrow-right>barrier()宏</h1><p>內存屏障，該語句不產生任何代碼，但是執行後刷新寄存器對變量的分配。</p><pre>/* Optimization barrier *//* The &#34;volatile&#34; is due to gcc bugs */#define barrier() __asm__ __volatile__(&#34;&#34;: : :&#34;memory&#34;)</pre><p>執行該語句後cpu中的寄存器和cache中已緩存的數據將作廢，重新讀取內存中的數據。這就阻止了cpu將寄存器和cache中的數據用於去優化指令，而避免去訪問內存。例如：</p><pre>int a = 5, b = 6;barrier();a = b;</pre><p>第三行中，GCC不會用存放b的寄存器給a賦值，而是invalidate b 的cache line，重新讀取內存中的b值給a賦值。</p><p>另外的內存屏障宏定義：</p><ul><li>mfence：在mfence指令前的讀寫操作當必須在mfence指令後的讀寫操作前完成。</li><li>lfence：在lfence指令前的讀操作當必須在lfence指令後的讀操作前完成，不影響寫操作</li><li>sfence：在sfence指令前的寫操作當必須在sfence指令後的寫操作前完成，不影響讀操作</li><li>lock 前綴（或cpuid、xchg等指令）使得本CPU的Cache寫入內存，該寫入動作也會引起別的CPU invalidate其Cache。用來修飾當前指令操作的內存只能由當前CPU使用</li></ul><p>內存對於緩存更新策略，要區分Write-Through和Write-Back兩種策略。前者更新內容直接寫內存並不同時更新Cache，但要置Cache失效，後者先更新Cache，隨後異步更新內存。通常X86 CPU更新內存都使用Write-Back策略。</p><h1 class=pgc-h-arrow-right>#ifdef ASSEMBLY宏</h1><p>一些常量宏同時在彙編和C中使用，然而，我們不能像註釋C的常量宏那樣加一個“UL”或其他後綴。所以我們需要使用以下的宏解決這個問題。</p><p>例如調用：#define DEMO_MACRO _AT(1， UL)：在C中會被解釋為 #define DEMO_MACRO 1UL； 而在彙編中什麼都不做，就是：#define DEMO_MACRO 1</p><pre>#ifdef __ASSEMBLY__#define _AC(X,Y) X#define _AT(T,X) X#else#define __AC(X,Y) (X##Y)#define _AC(X,Y) __AC(X,Y)#define _AT(T,X) ((T)(X))#endif #define _UL(x) (_AC(x, UL))#define _ULL(x) (_AC(x, ULL))</pre><h1 class=pgc-h-arrow-right>force_o_largefile宏</h1><p>判斷是否支持大文件。</p><p>#define force_o_largefile()<br>(personality(current->personality) != PER_LINUX32)</p><p>PER_LINUX32 = 0x0008, PER_MASK = 0x00ff, /*，</p><ul><li>Return the base personality without flags. */ #define personality(pers) (pers & PER_MASK)</li></ul><p>邏輯地址和物理地址互相轉換</p><pre>#define __pa(x) __virt_to_phys((unsigned long)(x))#define __va(x) ((void *)__phys_to_virt((unsigned long)(x)))</pre><h1 class=pgc-h-arrow-right>錯誤碼相關的宏</h1><p>linux 內核的一些錯誤碼，以它們的負數來作為函數返回值，簡單地使用大於等於-4095的虛擬地址來分別表示相應的錯誤碼。</p><p>在32位系統上，-4095轉換成unsigned long類型的值為0xFFFFF001，也就是說地址區間[0xFFFFF001, 0xFFFFFFFF]被分別用來表示錯誤碼從-4095到-1。</p><p>判斷一個函數返回的指針到底是有效地址還是錯誤碼：</p><pre>#define MAX_ERRNO 4095 #define IS_ERR_VALUE(x) unlikely((x) &gt;= (unsigned long)-MAX_ERRNO) static inline long __must_check IS_ERR(const void *ptr){    return IS_ERR_VALUE((unsigned long)ptr);}</pre><p>錯誤碼與相應地址的互換：</p><pre>static inline void * __must_check ERR_PTR(long error){    return (void *) error;}</pre><p>長整型轉化為指針</p><pre>static inline long __must_check PTR_ERR(const void *ptr){    return (long) ptr;}</pre><p>指針轉化為長整型</p><h1 class=pgc-h-arrow-right>額外有意思的宏</h1><p>遞歸宏，顛倒字節：</p><pre>#define BSWAP_8(x) ((x) &amp; 0xff)#define BSWAP_16(x) ((BSWAP_8(x) &lt;&lt; 8) | BSWAP_8((x) &gt;&gt; 8))#define BSWAP_32(x) ((BSWAP_16(x) &lt;&lt; 16) | BSWAP_16((x) &gt;&gt; 16))#define BSWAP_64(x) ((BSWAP_32(x) &lt;&lt; 32) | BSWAP_32((x) &gt;&gt; 32))</pre><p>交換宏，不需要額外定義變量</p><pre>#define swap(a, b) \(((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))</pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>kernel</a></li><li><a>中常</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c59c4d5.html alt="Linux kernel的中斷子系統之（一）：綜述" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02dc0d76247f44929c552cb097f9e3a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c59c4d5.html title="Linux kernel的中斷子系統之（一）：綜述">Linux kernel的中斷子系統之（一）：綜述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95bc1c3b.html alt=施工中常見8種鋼筋分類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ee33c2f5893849fbb7ed9dd98f7cba72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95bc1c3b.html title=施工中常見8種鋼筋分類>施工中常見8種鋼筋分類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b15bfb03.html alt=施工中常見的鋼筋你需要知道的知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e912e61511874e9db8e79597811ebabd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b15bfb03.html title=施工中常見的鋼筋你需要知道的知識>施工中常見的鋼筋你需要知道的知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/61d128bc.html alt=岩土工程中常見的“問題土” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8803daf3aacd493fb1c4c99d8aebda28 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/61d128bc.html title=岩土工程中常見的“問題土”>岩土工程中常見的“問題土”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html alt=Linux系統常用命令大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html title=Linux系統常用命令大全>Linux系統常用命令大全</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>