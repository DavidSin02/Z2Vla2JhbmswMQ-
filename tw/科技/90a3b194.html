<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring：AOP 面向切面編程 | 极客快訊</title><meta property="og:title" content="Spring：AOP 面向切面編程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Spring：AOP 面向切面編程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/90a3b194.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring：AOP 面向切面編程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="Spring：AOP 面向切面編程" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>轉賬案例</h1><p>需求：使用 spring 框架整合 DBUtils 技術，實現用戶轉賬功能</p><h1 class=pgc-h-arrow-right><strong>基礎功能</strong></h1><p>步驟分析：</p><ol start=1><li>創建 java 項目，導入座標</li><li>編寫 Account 實體類</li><li>編寫 AccountDao 接口和實現類</li><li>編寫 AccountService 接口和實現類</li><li>編寫 spring 核心配置文件</li><li>編寫測試代碼</li></ol><h1 class=pgc-h-arrow-right><strong>創建 java 項目，導入座標</strong></h1><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.15&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;        &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;        &lt;version&gt;1.6&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.13&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>編寫 AccountDao 接口和實現類</strong></h1><pre><code>public interface AccountDao {    /**     * 轉出操作     * @param outUser     * @param money     */    void out(String outUser,Double money);​    /**     * 轉入操作     * @param inUser     * @param money     */    void in(String inUser,Double money);}@Repository("AccountDao")public class AccountDaoImpl implements AccountDao {    @Autowired    private QueryRunner queryRunner;​    @Override    public void out(String outUser, Double money) {        String sql = "update account set money = money - ? where name = ?";        try {            queryRunner.update(sql, money, outUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }​    @Override    public void in(String inUser, Double money) {        String sql = "update account set money = money + ? where name = ?";        try {            queryRunner.update(sql, money, inUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>編寫 AccountService 接口和實現類</strong></h1><pre><code>public interface AccountService {        /**         * 轉賬方法         */        void transfer(String outUser,String inUser,Double money);}@Service("accountService")public class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    /**     * 轉賬方法     */    @Override    public void transfer(String outUser, String inUser, Double money) {        // 編寫了事務相關代碼        // 調用了減錢方法        accountDao.out(outUser,money);        // 模擬出錯        // int i= 1/0;        // 調用了加錢方法        accountDao.in(inUser,money);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>編寫 spring 核心配置文件</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="       	http://www.springframework.org/schema/beans		http://www.springframework.org/schema/beans/spring-beans.xsd       	http://www.springframework.org/schema/context		http://www.springframework.org/schema/context/spring-context.xsd		http://www.springframework.org/schema/aop		http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;    &lt;!-- 開啟註解掃描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;    &lt;!-- 引入 properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;    &lt;!-- 配置 DataSource --&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;        &lt;property name="url" value="${jdbc.url}"/&gt;        &lt;property name="username" value="${jdbc.username}"/&gt;        &lt;property name="password" value="${jdbc.password}"/&gt;    &lt;/bean&gt;    &lt;!-- 配置 queryRunner --&gt;    &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner"&gt;        &lt;constructor-arg name="ds" ref="dataSource"/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>編寫測試代碼</strong></h1><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration({"classpath:applicationContext.xml"})public class AccountServiceTest {    @Autowired    private AccountService accountService;    @Test    public void testTransfer() {        accountService.transfer("tom", "jerry", 100d);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>問題分析</strong></h1><p>上面的代碼事務在 Dao 層，轉出轉入操作都是一個獨立的事務，但實際開發，應該把業務邏輯控制在一個事務中，所以應該將事務挪到 Service 層。</p><h1 class=pgc-h-arrow-right><strong>傳統事務</strong></h1><p>步驟分析：</p><ol start=1><li>編寫線程綁定工具類</li><li>編寫事務管理器</li><li>修改 service 層代碼</li><li>修改 dao 層代碼</li></ol><h1 class=pgc-h-arrow-right><strong>編寫線程綁定工具類</strong></h1><pre><code>@Componentpublic class ConnectionUtils {    @Autowired    private DataSource dataSource;​    private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;();​    /**     * 獲取當前線程上綁定連接：如果獲取到的連接為空，那麼就要從數據源中獲取連接，並且放到 ThreadLocal 中（綁定到當前線程）     */    public Connection getThreadConnection() {        // 1.先從 ThreadLocal 上獲取連接        Connection connection = threadLocal.get();        // 2.判斷當前線程中是否是有 Connection        if(connection == null){            // 3.從數據源中獲取一個連接，並且存入 ThreadLocal 中            try {                // 不為 null                connection = dataSource.getConnection();                threadLocal.set(connection);            } catch (SQLException e) {                e.printStackTrace();            }        }        return  connection;    }​    /**     * 解除當前線程的連接綁定     */    public void  removeThreadConnection(){        threadLocal.remove();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>編寫事務管理器</strong></h1><pre><code>@Component("transactionManager")public class TransactionManager {    @Autowired    private ConnectionUtils connectionUtils;​    /**     * 開啟事務     */    public void beginTransaction(){        // 獲取 connection 對象        Connection connection = connectionUtils.getThreadConnection();        try {            // 開啟了一個手動事務            connection.setAutoCommit(false);        } catch (SQLException e) {            e.printStackTrace();        }    }​    /**     * 提交事務     */    public void commit(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.commit();        } catch (SQLException e) {            e.printStackTrace();        }    }​    /**     * 回滾事務     */    public void rollback(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.rollback();        } catch (SQLException e) {            e.printStackTrace();        }    }​    /**     * 釋放資源     */    public void release(){        // 將手動事務改回成自動提交事務        Connection connection = connectionUtils.getThreadConnection();        try {            connection.setAutoCommit(true);            // 將連接歸還到連接池            connectionUtils.getThreadConnection().close();            // 解除線程綁定            connectionUtils.removeThreadConnection();        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>修改 service 層代碼</strong></h1><pre><code>@Service("accountService")public class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    @Autowired    private TransactionManager transactionManager;    @Override    public void transfer(String outUser, String inUser, Double money) {        try {            // 1.開啟事務            transactionManager.beginTransaction();            // 2.業務操作            // 編寫了事務相關代碼            // 調用了減錢方法            accountDao.out(outUser, money);            // 模擬出錯            // int i= 1/0;            // 調用了加錢方法            accountDao.in(inUser, money);            // 3.提交事務            transactionManager.commit();        } catch (Exception e) {            // 4.回滾事務            transactionManager.rollback();            e.printStackTrace();        } finally {            // 5.釋放資源            transactionManager.release();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>修改 Dao 層代碼</strong></h1><pre><code>@Repository("AccountDao")public class AccountDaoImpl implements AccountDao {    @Autowired    private QueryRunner queryRunner;    @Autowired    private ConnectionUtils connectionUtils;    /**     * 轉出操作     */    @Override    public void out(String outUser, Double money) {        String sql = "update account set money = money - ? where name = ?";        try {            queryRunner.update(connectionUtils.getThreadConnection(), sql, money, outUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }    /**     * 轉入操作     */    @Override    public void in(String inUser, Double money) {        String sql = "update account set money = money + ? where name = ?";        try {            queryRunner.update(connectionUtils.getThreadConnection(), sql, money, inUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>問題分析</strong></h1><p>上面代碼，通過對業務層改造，已經可以實現事務控制了，但是由於添加了事務控制，也產生了一個新的問題： 業務層方法變得臃腫了，裡面充斥著很多重複代碼。並且業務層方法和事務控制方法耦合了，違背了面向對象的開發思想。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>Proxy 優化轉賬案例</strong></h1><p>可以將業務代碼和事務代碼進行拆分，通過動態代理的方式，對業務方法進行事務的增強。這樣就不會對業務層產生影響，解決了耦合性的問題。</p><p>常用的動態代理技術：</p><ul><li>JDK 代理，基於接口的動態代理技術 - 利用攔截器（必須實現 invocationHandler）加上反射機制生成一個代理接口的匿名類，在調用具體方法前調用 InvokeHandler 來處理，從而實現方法增強</li><li>CGLIB 代理，基於父類的動態代理技術 - 動態生成一個要代理的子類，子類重寫要代理的類的所有不是 final 的方法；在子類中採用方法攔截技術攔截所有的父類方法的調用，順勢織入橫切邏輯，對方法進行增強</li></ul><h1 class=pgc-h-arrow-right><strong>JDK 動態代理方式</strong></h1><p>去掉 AccountServiceImpl 的事務控制代碼</p><pre><code>@Service("accountService")public class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    @Override    public void transfer(String outUser, String inUser, Double money) {        accountDao.out(outUser, money);        // 模擬出錯        int i= 1/0;        accountDao.in(inUser, money);    }}</code></pre><p>JDK 工廠類</p><pre><code>@Componentpublic class JDKProxyFactory {    @Autowired    private AccountService accountService;    @Autowired    private TransactionManager transactionManager;    /**     * 採用 JDK 動態代理技術來生成目標類的代理對象     * ClassLoader loader : 類加載器：藉助被代理對象獲取到類加載器     * Class&lt;?&gt;[] interfaces ： 被代理類所需要實現的全部接口     * InvocationHandler h ： 當代理對象調用接口中的任意方法時，那麼都會執行 InvocationHandler 中 invoke 方法     */    public AccountService createAccountServiceJdkProxy() {        return (AccountService) Proxy.newProxyInstance(                accountService.getClass().getClassLoader(),                accountService.getClass().getInterfaces(),                new InvocationHandler() {                    /**                     * @param proxy 當前的代理對象引用                     * @param method 被調用的目標方法的引用                     * @param args 被調用的目標方法所用到的參數                     */                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) {                        try {                            if ("transfer".equalsIgnoreCase(method.getName())) {                                System.out.println("JDK Proxy: Pre-Enhance ...");                                transactionManager.beginTransaction();                                method.invoke(accountService, args);                                System.out.println("JDK Proxy: Post-Enhance ...");                                transactionManager.commit();                            } else {                                method.invoke(accountService, args);                            }                        } catch (Exception e) {                            transactionManager.rollback();                            e.printStackTrace();                        } finally {                            transactionManager.release();                        }                        return null;                    }                });    }}</code></pre><p>測試代碼</p><pre><code>@Autowiredprivate JDKProxyFactory jdkProxyFactory;@Testpublic void testTransferProxyJDK(){    // 當前返回的實際上是 AccountService 的代理對象 proxy    AccountService accountServiceJDKProxy = jdkProxyFactory.createAccountServiceJDKProxy();    // 代理對象 proxy 調用接口中的任意方法時，都會執行底層的 invoke 方法    accountServiceJDKProxy.transfer("tom", "jerry", 100d);}</code></pre><h1 class=pgc-h-arrow-right><strong>CGLIB 動態代理方式</strong></h1><p>CGLIB 工廠類</p><pre><code>@Componentpublic class CglibProxyFactory {    @Autowired    private AccountService accountService;    @Autowired    private TransactionManager transactionManager;    /**     * 編寫 cglib 對應的 API 來生成代理對象進行返回     * 參數 1 ： 目標類的字節碼對象     * 參數 2：  動作類，當代理對象調用目標對象中原方法時，那麼會執行 intercept 方法     */    public AccountService createAccountServiceCglibProxy() {        return (AccountService) Enhancer.create(accountService.getClass(), new MethodInterceptor() {            /**             * @param o 代表生成的代理對象             * @param method 調用目標方法的引用             * @param objects 方法入參             * @param methodProxy 代理方法             */            @Override            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) {                try {                    System.out.println("CGLIB Proxy: Pre-Enhance ...");                    // 手動開啟事務：調用事務管理器類中的開啟事務方法                    transactionManager.beginTransaction();                    method.invoke(accountService, objects);                    System.out.println("CGLIB Proxy: Post-Enhance ...");                    transactionManager.commit();                } catch (Exception e) {                    // 手動回滾事務                    transactionManager.rollback();                    e.printStackTrace();                } finally {                    // 手動釋放資源                    transactionManager.release();                }                return null;            }        });    }}</code></pre><p>測試代碼</p><pre><code>@Autowiredprivate CglibProxyFactory cglibProxyFactory;@Testpublic void testTransferProxyCglib(){    AccountService accountServiceCglibProxy = cglibProxyFactory.createAccountServiceCglibProxy();    accountServiceCglibProxy.transfer("tom","jerry",100d);}</code></pre><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right><strong>初識 AOP</strong></h1><h1 class=pgc-h-arrow-right><strong>什麼是 AOP</strong></h1><p>AOP 為 Aspect Oriented Programming 的縮寫，意思為面向切面編程。</p><p>AOP 是 OOP（面向對象編程） 的延續，是軟件開發中的一個熱點，也是 Spring 框架中的一個重要內容，利用 AOP 可以對業務邏輯的各個部分進行隔離，從而使得業務邏輯各部分之間的耦合度降低，提高程序的可重用性，同時提高了開發的效率。</p><p>優勢：</p><ol start=1><li>在程序運行期間，在不修改源碼的情況下對方法進行功能增強</li><li>邏輯清晰，開發核心業務的時候，不必關注增強業務的代碼</li><li>減少重複代碼，提高開發效率，便於後期維護</li></ol><h1 class=pgc-h-arrow-right><strong>AOP 底層實現</strong></h1><p>實際上，AOP 的底層是通過 Spring 提供的的動態代理技術實現的。在運行期間，Spring 通過動態代理技術動態的生成代理對象，代理對象方法執行時進行增強功能的介入，在去調用目標對象的方法，從而完成功能的增強。</p><h1 class=pgc-h-arrow-right><strong>AOP 相關術語</strong></h1><p>Spring 的 AOP 實現底層就是對上面的動態代理的代碼進行了封裝，封裝後我們只需要對需要關注的部分進行代碼編寫，並通過配置的方式完成指定目標的方法增強。</p><p>在正式講解 AOP 的操作之前，我們必須理解 AOP 的相關術語，常用的術語如下：</p><pre><code>* Target（目標對象）：代理的目標對象；被代理類* Proxy（代理）：一個類被 AOP 織入增強後，就產生一個結果代理類；生成代理對象* Joinpoint（連接點）：所謂連接點是指那些可以被攔截到的點；在 spring 中，這些點指的是方法，因為 spring 只支持方法類型的連接點；可以被攔截增強的方法* Pointcut（切入點）：所謂切入點是指我們要對哪些 Joinpoint 進行攔截的定義；即真正被攔截增強的方法* Advice（通知/ 增強）：所謂通知是指攔截到 Joinpoint 之後所要做的事情就是通知分類：前置通知、後置通知、異常通知、最終通知、環繞通知 - 一種可以通過代碼的方式來手動控制的類型；即增強的業務邏輯* Aspect（切面）：是切入點和通知（引介）的結合* Weaving（織入）：是指把增強應用到目標對象來創建新的代理對象的過程。Spring 採用動態代理織入，而 AspectJ 採用編譯期織入和類裝載期織入</code></pre><h1 class=pgc-h-arrow-right><strong>AOP 開發明確事項</strong></h1><h1 class=pgc-h-arrow-right><strong>開發階段</strong></h1><ol start=1><li>編寫核心業務代碼（目標類的目標方法） 切入點</li><li>把公用代碼抽取出來，製作成通知（增強功能方法） 通知</li><li>在配置文件中，聲明切入點與通知間的關係，即切面</li></ol><h1 class=pgc-h-arrow-right><strong>運行階段（Spring 框架自動完成）</strong></h1><p>Spring 框架監控切入點方法的執行。一旦監控到切入點方法被運行，使用代理機制，動態創建目標對象的代理對象，根據通知類別，在代理對象的對應位置，將通知對應的功能織入，完成完整的代碼邏輯運行。</p><h1 class=pgc-h-arrow-right><strong>底層代理實現</strong></h1><p>在 Spring 中，框架會根據目標類是否實現了接口來決定採用哪種動態代理的方式：</p><ul><li>當 bean 實現接口時，會用 JDK 代理模式</li><li>當 bean 沒有實現接口，用 cglib 實現（ 可以強制使用 cglib（在 spring 配置中加入 &lt;aop:aspectj-autoproxy proxy-target-class=”true”/>）</li></ul><h1 class=pgc-h-arrow-right><strong>小結</strong></h1><pre><code>* aop - 面向切面編程* aop 底層實現：基於 JDK 的動態代理和基於 Cglib 的動態代理* aop 的重點概念：    Pointcut（切入點）：真正被增強的方法    Advice（通知/ 增強）：封裝增強業務邏輯的方法    Aspect（切面）：切點 + 通知    Weaving（織入）：將切點與通知結合，產生代理對象的過程</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>基於 XML 的 AOP 開發</strong></h1><h1 class=pgc-h-arrow-right><strong>快速入門</strong></h1><p>快速入門：</p><ol start=1><li>創建 java 項目，導入 AOP 相關座標</li><li>創建目標接口和目標實現類（定義切入點）</li><li>創建通知類及方法（定義通知）</li><li>將目標類和通知類對象創建權交給 spring</li><li>在核心配置文件中配置織入關係，及切面</li><li>編寫測試代碼</li></ol><h1 class=pgc-h-arrow-right><strong>創建 java 項目，導入 AOP 相關座標</strong></h1><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;    &lt;java.version&gt;1.11&lt;/java.version&gt;    &lt;maven.compiler.source&gt;1.11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.11&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- 導入 spring 的 context 座標，context 依賴 aop --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- aspectj 的織入（切點表達式需要用到該 jar 包） --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.13&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring 整合 junit --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>創建目標接口和目標實現類</strong></h1><pre><code>public interface AccountService {    /**     * 目標方法：（切入點：要進行攔截增強的方法）     */    void transfer();}public class AccountServiceImpl implements AccountService {    @Override    public void transfer() {        System.out.println("轉賬方法執行了....");        //int i = 1/0;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>創建通知類</strong></h1><pre><code>public class MyAdvice {    public void before(){        System.out.println("前置通知執行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>將目標類和通知類對象創建權交給 spring</strong></h1><pre><code>&lt;!-- 目標類交給 IOC 容器 --&gt;&lt;bean id="accountServcie" class="com.renda.service.impl.AccountServiceImpl"/&gt;&lt;!-- 通知類交給 IOC 容器 --&gt;&lt;bean id="myAdvice" class="com.renda.advice.MyAdvice"/&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>在核心配置文件中配置織入關係，及切面</strong></h1><p>導入 AOP 命名空間</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;        &lt;bean id="accountServcie" class="com.renda.service.impl.AccountServiceImpl"/&gt;        &lt;bean id="myAdvice" class="com.renda.advice.MyAdvice"/&gt;        &lt;aop:config&gt;        &lt;aop:aspect ref="myAdvice"&gt;            &lt;aop:before method="before" pointcut="execution(public void com.renda.service.impl.AccountServiceImpl.transfer())"/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;​&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>編寫測試代碼</strong></h1><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration({"classpath:applicationContext.xml"})public class AccountServiceTest {    @Autowired    private AccountService accountService;​    @Test    public void testTransfer() {        accountService.transfer();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>XML 配置 AOP 詳解</strong></h1><h1 class=pgc-h-arrow-right><strong>切點表達式</strong></h1><p>表達式語法：</p><ul><li>訪問修飾符可以省略</li><li>返回值類型、包名、類名、方法名可以使用星號 * 代替，代表任意</li><li>包名與類名之間一個點 . 代表當前包下的類，兩個點 .. 表示當前包及其子包下的類</li><li>參數列表可以使用兩個點 .. 表示任意個數，任意類型的參數列表</li></ul><p>例子：</p><pre><code>- execution([修飾符] 返回值類型 包名.類名.方法名(參數))execution(public void com.renda.service.impl.AccountServiceImpl.transfer(java.lang.String))- 訪問修飾符可以省略execution(void com.renda.service.impl.AccountServiceImpl.transfer(java.lang.String))- 返回值類型、包名、類名、方法名可以使用星號 * 代替，代表任意execution(* *.*.*.*.*.*())- 包名與類名之間一個點 . 代表當前包下的類，兩個點 .. 表示當前包及其子包下的類execution(* *..*.*())- 參數列表可以使用兩個點 .. 表示任意個數，任意類型的參數列表execution(* *..*.*(..))</code></pre><p>切點表達式抽取：當多個增強的切點表達式相同時，可以將切點表達式進行抽取，在增強中使用 pointcut-ref 屬性代替 pointcut 屬性來引用抽取後的切點表達式。</p><pre><code>public class MyAdvice {    public void before(){        System.out.println("前置通知執行了....");    }    public void afterReturning(){        System.out.println("後置通知執行了....");    }    public void afterThrowing(){        System.out.println("異常通知執行了....");    }    public void after(){        System.out.println("最終通知執行了....");    }    /**     * @param pjp Proceeding JoinPoint - 正在執行的連接點：切點     */    public Object around(ProceedingJoinPoint pjp){        Object proceed = null;        try {            System.out.println("前置通知執行了");            // 切點方法執行            proceed = pjp.proceed();            System.out.println("後置通知執行了");        } catch (Throwable throwable) {            throwable.printStackTrace();            System.out.println("異常通知執行了");        }finally {            System.out.println("最終通知執行了");        }        return proceed;    }}&lt;aop:config&gt;    &lt;!-- 抽取的切點表達式 --&gt;    &lt;aop:pointcut id="myPointcut" expression="execution(* com.renda.service.impl.AccountServiceImpl.*(..))"/&gt;    &lt;!-- 配置切面：切入點 + 通知 --&gt;    &lt;aop:aspect ref="myAdvice"&gt;        &lt;aop:before method="before" pointcut-ref="myPointcut"/&gt;        &lt;aop:after-returning method="afterReturning" pointcut-ref="myPointcut"/&gt;        &lt;aop:after-throwing method="afterThrowing" pointcut-ref="myPointcut"/&gt;        &lt;aop:after method="after" pointcut-ref="myPointcut"/&gt;        &lt;!-- &lt;aop:around method="around" pointcut-ref="myPointcut"/&gt; --&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>通知類型</strong></h1><p>通知的配置語法：</p><pre><code>&lt;aop:通知類型 method=“通知類中方法名” pointcut=“切點表達式"&gt;&lt;/aop:通知類型&gt;</code></pre><ul><li>前置通知 &lt;aop:before> - 用於配置前置通知。指定增強的方法在切入點方法之前執行</li><li>後置通知 &lt;aop:afterReturning> - 用於配置後置通知。指定增強的方法在切入點方法之後執行</li><li>異常通知 &lt;aop:afterThrowing> - 用於配置異常通知；指定增強的方法出現異常後執行</li><li>最終通知 &lt;aop:after> - 用於配置最終通知；無論切入點方法執行時是否有異常，都會執行</li><li>環繞通知 &lt;aop:around> - 用於配置環繞通知；開發者可以手動控制增強代碼在什麼時候執行</li></ul><p>注意：通常情況下，環繞通知都是獨立使用的</p><h1 class=pgc-h-arrow-right><strong>小結</strong></h1><pre><code>* aop 織入的配置    &lt;aop:config&gt;        &lt;aop:aspect ref=“通知類”&gt;        &lt;aop:before method=“通知方法名稱” pointcut=“切點表達式"&gt;&lt;/aop:before&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;                                                        * 通知的類型    前置通知、後置通知、異常通知、最終通知    環繞通知    * 切點表達式    execution([修飾符] 返回值類型 包名.類名.方法名(參數))</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>基於註解的 AOP 開發</strong></h1><h1 class=pgc-h-arrow-right><strong>快速入門</strong></h1><p>步驟分析：</p><ol start=1><li>創建 java 項目，導入 AOP 相關座標</li><li>創建目標接口和目標實現類（定義切入點）</li><li>創建通知類（定義通知）</li><li>將目標類和通知類對象創建權交給 spring</li><li>在通知類中使用註解配置織入關係，升級為切面類</li><li>在配置文件中開啟組件掃描和 AOP 的自動代理</li><li>編寫測試代碼</li></ol><h1 class=pgc-h-arrow-right><strong>創建 java 項目，導入 AOP 相關座標</strong></h1><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;    &lt;java.version&gt;1.11&lt;/java.version&gt;    &lt;maven.compiler.source&gt;1.11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.11&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- 導入 spring 的 context 座標，context 依賴 aop --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- aspectj 的織入 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.13&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring 整合 junit --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>創建目標接口和目標實現類</strong></h1><pre><code>public interface AccountService {    void transfer();}public class AccountServiceImpl implements AccountService {    @Override    public void transfer() {        System.out.println("轉賬方法執行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>創建通知類</strong></h1><pre><code>public class MyAdvice {    public void before(){        System.out.println("前置通知執行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>將目標類和通知類對象創建權交給 spring</strong></h1><pre><code>@Servicepublic class AccountServiceImpl implements AccountService {    @Override    public void transfer() {        System.out.println("轉賬方法執行了....");    }}@Componentpublic class MyAdvice {    ...}</code></pre><h1 class=pgc-h-arrow-right><strong>在通知類中使用註解配置織入關係，升級為切面類</strong></h1><pre><code>@Component@Aspect // 升級為切面類：配置切入點和通知的關係public class MyAdvice {    @Before("execution(* com.renda.service.impl.AccountServiceImpl.*(..))")    public void before(){        System.out.println("前置通知執行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>在配置文件中開啟組件掃描和 AOP 的自動代理</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:context="http://www.springframework.org/schema/context"       xsi:schemaLocation="http://www.springframework.org/schema/beans		http://www.springframework.org/schema/beans/spring-beans.xsd		http://www.springframework.org/schema/aop		http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;    &lt;!-- 開啟 IOC 註解掃描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;    &lt;!-- aop 的自動代理：採用動態代理完成織入增強，並且生成代理；proxy-target-class="true" 表示強制使用 cglib 動態代理--&gt;    &lt;aop:aspectj-autoproxy proxy-target-class="false"/&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>編寫測試代碼</strong></h1><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class AccountServiceTest {    @Autowired    private AccountService accountService;    @Test    public void testTransfer(){        accountService.transfer();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>註解配置 AOP 詳解</strong></h1><h1 class=pgc-h-arrow-right><strong>切點表達式</strong></h1><p>切點表達式的抽取</p><pre><code>@Component@Aspect // 升級為切面類：配置切入點和通知的關係public class MyAdvice {    @Pointcut("execution(* com.renda.service.impl.AccountServiceImpl.*(..))")    public void myPoint(){    }    @Before("MyAdvice.myPoint()")    public void before(){        System.out.println("前置通知執行了....");    }    @AfterReturning("MyAdvice.myPoint()")    public void afterReturning(){        System.out.println("後置通知執行了....");    }    @AfterThrowing("MyAdvice.myPoint()")    public void afterThrowing(){        System.out.println("異常通知執行了....");    }    @After("MyAdvice.myPoint()")    public void after(){        System.out.println("最終通知執行了....");    }    /**     * @param pjp Proceeding JoinPoint - 正在執行的連接點：切點     */    public Object around(ProceedingJoinPoint pjp){        Object proceed = null;        try {            System.out.println("前置通知執行了");            // 切點方法執行            proceed = pjp.proceed();            System.out.println("後置通知執行了");        } catch (Throwable throwable) {            throwable.printStackTrace();            System.out.println("異常通知執行了");        }finally {            System.out.println("最終通知執行了");        }        return proceed;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>通知類型</strong></h1><p>通知的配置語法：@通知註解(“切點表達式")</p><ul><li>前置通知 @Before - 用於配置前置通知；指定增強的方法在切入點方法之前執行</li><li>後置通知 @AfterReturning - 用於配置後置通知；指定增強的方法在切入點方法之後執行</li><li>異常通知 @AfterThrowing - 用於配置異常通知；指定增強的方法出現異常後執行</li><li>最終通知 @After - 用於配置最終通知；無論切入點方法執行時是否有異常，都會執行</li><li>環繞通知 @Around - 用於配置環繞通知；開發者可以手動控制增強代碼在什麼時候執行</li></ul><h1 class=pgc-h-arrow-right><strong>注意</strong></h1><p>當前四個通知組合在一起時，出現一個 Spring 的執行順序的 Bug，錯誤的執行順序如下：</p><pre><code>@Before -&gt; @After -&gt; @AfterReturning（如果有異常：@AfterThrowing）</code></pre><p>如果單獨使用環繞通知 @Around 註解則不會有這個 Bug，執行順序如下：</p><pre><code>@Before -&gt; @AfterReturning（如果有異常：@AfterThrowing）-&gt; @After</code></pre><h1 class=pgc-h-arrow-right><strong>純註解配置</strong></h1><p>去掉 applicationContext.xml 配置文件，增加 SpringConfig 配置類</p><pre><code>@Configuration@ComponentScan("com.renda")@EnableAspectJAutoProxy // 開啟 AOP 的自動代理，替代 xml 配置的 &lt;aop:aspectj-autoproxy /&gt;public class SpringConfig {}</code></pre><p>修改測試類</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTest {​    @Autowired    private AccountService accountService;​    @Test    public void testTransfer(){        accountService.transfer();    }​}</code></pre><h1 class=pgc-h-arrow-right><strong>知識小結</strong></h1><pre><code>* 使用 @Aspect 註解，標註切面類* 使用 @Before 等註解，標註通知方法* 使用 @Pointcut 註解，抽取切點表達式* 配置 aop 自動代理 &lt;aop:aspectj-autoproxy/&gt; 或 @EnableAspectJAutoProxy</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>AOP 優化轉賬案例</strong></h1><p>依然使用前面的轉賬案例，將兩個代理工廠對象直接刪除，改為 spring 的 AOP 思想來實現</p><h1 class=pgc-h-arrow-right><strong>xml 配置實現</strong></h1><h1 class=pgc-h-arrow-right><strong>配置文件</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="       	http://www.springframework.org/schema/beans		http://www.springframework.org/schema/beans/spring-beans.xsd       	http://www.springframework.org/schema/context		http://www.springframework.org/schema/context/spring-context.xsd		http://www.springframework.org/schema/aop		http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;    &lt;!-- 開啟註解掃描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;    &lt;!-- 引入 properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;    &lt;!-- 配置 DataSource --&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;        &lt;property name="url" value="${jdbc.url}"/&gt;        &lt;property name="username" value="${jdbc.username}"/&gt;        &lt;property name="password" value="${jdbc.password}"/&gt;    &lt;/bean&gt;    &lt;!-- 配置 queryRunner --&gt;    &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner"&gt;        &lt;constructor-arg name="ds" ref="dataSource"/&gt;    &lt;/bean&gt;    &lt;!-- AOP 配置 --&gt;      &lt;aop:config&gt;          &lt;!-- 1.切點表達式 --&gt;          &lt;aop:pointcut id="myPointcut" expression="execution(* com.renda.service.impl.AccountServiceImpl.*(..))"/&gt;          &lt;!-- 2.切面配置 --&gt;          &lt;aop:aspect ref="transactionManager"&gt;              &lt;aop:before method="beginTransaction" pointcut-ref="myPointcut"/&gt;              &lt;aop:after-returning method="commit"  pointcut-ref="myPointcut"/&gt;              &lt;aop:after-throwing method="rollback" pointcut-ref="myPointcut"/&gt;              &lt;aop:after method="release" pointcut-ref="myPointcut"/&gt;          &lt;/aop:aspect&gt;      &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>事務管理器（通知）</strong></h1><pre><code>package com.renda.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.sql.Connection;import java.sql.SQLException;/** * 事務管理器工具類：包含：開啟事務、提交事務、回滾事務、釋放資源 *      Spring AOP 的通知類 * * @author Renda Zhang * @create 2020-09-04 15:31 */@Component("transactionManager")public class TransactionManager {    @Autowired    private ConnectionUtils connectionUtils;    /**     * 開啟事務     */    public void beginTransaction(){        // 獲取 connection 對象        Connection connection = connectionUtils.getThreadConnection();        try {            // 開啟了一個手動事務            connection.setAutoCommit(false);            System.out.println("開啟事務");        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 提交事務     */    public void commit(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.commit();            System.out.println("提交事務");        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 回滾事務     */    public void rollback(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.rollback();            System.out.println("回滾事務");        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 釋放資源     */    public void release(){        // 將手動事務改回成自動提交事務        Connection connection = connectionUtils.getThreadConnection();        try {            connection.setAutoCommit(true);            // 將連接歸還到連接池            connectionUtils.getThreadConnection().close();            // 解除線程綁定            connectionUtils.removeThreadConnection();            System.out.println("釋放資源");        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>註解配置實現</strong></h1><h1 class=pgc-h-arrow-right><strong>配置文件</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;​    &lt;!-- 開啟註解掃描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;​    &lt;!-- 引入 properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;​    &lt;!-- 配置 DataSource --&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;        &lt;property name="url" value="${jdbc.url}"/&gt;        &lt;property name="username" value="${jdbc.username}"/&gt;        &lt;property name="password" value="${jdbc.password}"/&gt;    &lt;/bean&gt;​    &lt;!-- 配置 queryRunner --&gt;    &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner"&gt;        &lt;constructor-arg name="ds" ref="dataSource"/&gt;    &lt;/bean&gt;​    &lt;!-- 開啟 AOP 的自動代理 --&gt;    &lt;aop:aspectj-autoproxy/&gt;​&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>事務管理器（通知）</strong></h1><pre><code>@Component("transactionManager")@Aspect // 表明該類為切面類public class TransactionManager {    @Autowired    private ConnectionUtils connectionUtils;​    @Around("execution(* com.renda.service.impl.AccountServiceImpl.*(..))")    public Object around(ProceedingJoinPoint pjp) throws SQLException {        Object proceed = null;​        try {            // 開啟手動事務            System.out.println("開啟事務");            connectionUtils.getThreadConnection().setAutoCommit(false);​            // 切入點方法執行            proceed = pjp.proceed();​            // 手動提交事務            System.out.println("提交事務");            connectionUtils.getThreadConnection().commit();        } catch (Throwable throwable) {            throwable.printStackTrace();            // 手動回滾事務            System.out.println("回滾事務");            connectionUtils.getThreadConnection().rollback();        } finally {            System.out.println("釋放資源");            // 將手動事務恢復成自動事務            connectionUtils.getThreadConnection().setAutoCommit(true);            // 將連接歸還到連接池            connectionUtils.getThreadConnection().close();            // 解除線程綁定            connectionUtils.removeThreadConnection();        }​        return proceed;    }}</code></pre><blockquote class=pgc-blockquote-abstract><p>想了解更多，歡迎關注我的微信公眾號：Renda_Zhang</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>AOP</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面編程AOP的初步瞭解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面編程AOP的初步瞭解>Spring面向切面編程AOP的初步瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面編程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面編程需要知道的事">Spring AOP 面向切面編程需要知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html alt=Spring—面向切面編程（AOP）詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html title=Spring—面向切面編程（AOP）詳解>Spring—面向切面編程（AOP）詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用註解方式配置Spring中的面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用註解方式配置Spring中的面向切面編程AOP>使用註解方式配置Spring中的面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html alt="Spring AOP簡介與底層實現機制——動態代理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/413780d1-cf47-4038-9471-b686d97aa99b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html title="Spring AOP簡介與底層實現機制——動態代理">Spring AOP簡介與底層實現機制——動態代理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html alt=Spring框架AOP技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/760bf32faca443cb8e28ed0b9bc20205 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html title=Spring框架AOP技術>Spring框架AOP技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html alt=小實例理解Spring中的AOP----面向切面編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35942664cec244f88d6a0f7b1e7067cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html title=小實例理解Spring中的AOP----面向切面編程>小實例理解Spring中的AOP----面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a7b6ff44.html alt=談談AOP（面向切面編程） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534580818763e7a06b5c87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a7b6ff44.html title=談談AOP（面向切面編程）>談談AOP（面向切面編程）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82a2f71a.html alt=面向切面編程（AOP）中的術語你能說出幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/5436586b-f08f-4845-b15a-7da897dc9b16 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82a2f71a.html title=面向切面編程（AOP）中的術語你能說出幾個？>面向切面編程（AOP）中的術語你能說出幾個？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ef619f7.html alt=Autofac的AOP面向切面編程研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15b5a9a952f84c688e4f9a33c0fe0f13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ef619f7.html title=Autofac的AOP面向切面編程研究>Autofac的AOP面向切面編程研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html alt="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html title="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現">Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html alt="Spring學習（4）：Spring AOP" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/be8a179a4a8040648c1fb5a0532cc84b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html title="Spring學習（4）：Spring AOP">Spring學習（4）：Spring AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html alt=Spring面向切面編程的AOP的事務增強完整版的配置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html title=Spring面向切面編程的AOP的事務增強完整版的配置>Spring面向切面編程的AOP的事務增強完整版的配置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d826c93.html alt=spring框架之AOP面向切面編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9b61c468edc241dda89e2ac1e5fabd74 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d826c93.html title=spring框架之AOP面向切面編程>spring框架之AOP面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d371c81c.html alt=一招學會面向切面編程(AOP) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d371c81c.html title=一招學會面向切面編程(AOP)>一招學會面向切面編程(AOP)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>