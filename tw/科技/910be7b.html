<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「西法帶你學算法」一次搞定前綴和 | 极客快訊</title><meta property="og:title" content="「西法帶你學算法」一次搞定前綴和 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e39e97ee415f4d9ea5b5ceade6cec4e0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/910be7b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/910be7b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/910be7b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/910be7b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/910be7b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/910be7b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/910be7b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/910be7b.html><meta property="article:published_time" content="2020-10-29T20:50:35+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:35+08:00"><meta name=Keywords content><meta name=description content="「西法帶你學算法」一次搞定前綴和"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/910be7b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「西法帶你學算法」一次搞定前綴和</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>我花了幾天時間，從力扣中精選了五道相同思想的題目，來幫助大家解套，如果覺得文章對你有用，記得點贊分享，讓我看到你的認可，有動力繼續做下去。</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">467. 環繞字符串中唯一的</span><span style="color:#595959;--tt-darkmode-color: #595959">子</span><span style="color:#595959;--tt-darkmode-color: #595959">字符串[1]</span>(中等)</li><li><span style="color:#595959;--tt-darkmode-color: #595959">795. 區間子數組個數[2]</span>(中等)</li><li><span style="color:#595959;--tt-darkmode-color: #595959">904. 水果成籃[3]</span>(中等)</li><li><span style="color:#595959;--tt-darkmode-color: #595959">992. K 個不同整數的子數組[4]</span>（困難）</li><li><span style="color:#595959;--tt-darkmode-color: #595959">1109. 航班預訂統計[5]</span>(中等)</li></ul><p>前四道題都是滑動窗口的子類型，我們知道滑動窗口適合在題目要求連續的情況下使用， 而<span style="color:#595959;--tt-darkmode-color: #595959">前綴和[6]</span>也是如此。二者在連續問題中，對於<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「優化時間複雜度」</span></strong>有著很重要的意義。 因此如果一道題你可以用暴力解決出來，而且題目恰好有連續的限制， 那麼滑動窗口和前綴和等技巧就應該被想到。</p><p>除了這幾道題， 還有很多題目都是類似的套路， 大家可以在學習過程中進行體會。今天我們就來一起學習一下。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">前菜</span></strong></h1><p>我們從一個簡單的問題入手，識別一下這種題的基本形式和套路，為之後的四道題打基礎。當你瞭解了這個套路之後， 之後做這種題就可以直接套。</p><p>需要注意的是這四道題的前置知識都是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">滑動窗口</span>， 不熟悉的同學可以先看下我之前寫的 <span style="color:#595959;--tt-darkmode-color: #595959">滑動窗口專題（思路 + 模板）[7]</span></p><h1 class=pgc-h-arrow-right><strong>母題 0</strong></h1><p>有 N 個的正整數放到數組 A 裡，現在要求一個新的數組 B，新數組的第 i 個數 B[i]是原數組 A 第 0 到第 i 個數的和。</p><p>這道題可以使用前綴和來解決。 前綴和是一種重要的預處理，能大大降低查詢的時間複雜度。我們可以簡單理解為“數列的前 n 項的和”。這個概念其實很容易理解，即一個數組中，第 n 位存儲的是數組前 n 個數字的和。</p><p>對 [1,2,3,4,5,6] 來說，其前綴和可以是 pre=[1,3,6,10,15,21]。我們可以使用公式 pre[]=pre[−1]+nums[]得到每一位前綴和的值，從而通過前綴和進行相應的計算和解題。其實前綴和的概念很簡單，但困難的是如何在題目中使用前綴和以及如何使用前綴和的關係來進行解題。</p><h1 class=pgc-h-arrow-right><strong>母題 1</strong></h1><p>如果讓你求一個數組的連續子數組總個數，你會如何求？其中連續指的是數組的索引連續。 比如 [1,3,4]，其連續子數組有：<span style="color:#3594f7;--tt-darkmode-color: #3594F7">[1], [3], [4], [1,3], [3,4] , [1,3,4]</span>，你需要返回 6。</p><p>一種思路是總的連續子數組個數等於：<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「以索引為 0 結尾的子數組個數 + 以索引為 1 結尾的子數組個數 + ... + 以索引為 n - 1 結尾的子數組個數」</span></strong>，這無疑是完備的。</p><div class=pgc-img><img alt=「西法帶你學算法」一次搞定前綴和 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e39e97ee415f4d9ea5b5ceade6cec4e0><p class=pgc-img-caption></p></div><p>同時<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「利用母題 0 的前綴和思路， 邊遍歷邊求和。」</span></strong></p><p>參考代碼(JS)：</p><pre><code>function countSubArray(nums) {  let ans = 0;  let pre = 0;  for (_ in nums) {    pre += 1;    ans += pre;  }  return ans;}</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「複雜度分析」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，其中 N 為數組長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：</span></li></ul><p>而由於以索引為 i 結尾的子數組個數就是 i + 1，因此這道題可以直接用等差數列求和公式 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">(1 + n) * n / 2</span>，其中 n 數組長度。</p><h1 class=pgc-h-arrow-right><strong>母題 2</strong></h1><p>我繼續修改下題目， 如果讓你求一個數組相鄰差為 1 連續子數組的總個數呢？其實就是<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「索引差 1 的同時，值也差 1。」</span></strong></p><p>和上面思路類似，無非就是增加差值的判斷。</p><p>參考代碼(JS)：</p><pre><code>function countSubArray(nums) {  let ans = 1;  let pre = 1;  for (let i = 1; i &lt; nums.length; i++) {    if (nums[i] - nums[i - 1] == 1) {      pre += 1;    } else {      pre = 0;    }    ans += pre;  }  return ans;}</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「複雜度分析」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，其中 N 為數組長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：</span></li></ul><p>如果我值差只要大於 1 就行呢？其實改下符號就行了，這不就是求上升子序列個數麼？這裡不再繼續贅述， 大家可以自己試試。</p><h1 class=pgc-h-arrow-right><strong>母題 3</strong></h1><p>我們繼續擴展。</p><p>如果我讓你求出不大於 k 的子數組的個數呢？不大於 k 指的是子數組的全部元素都不大於 k。 比如 [1,3,4] 子數組有 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">[1], [3], [4], [1,3], [3,4] , [1,3,4]</span>，不大於 3 的子數組有 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">[1], [3], [1,3]</span> ，那麼 [1,3,4] 不大於 3 的子數組個數就是 3。 實現函數 atMostK(k, nums)。</p><p>參考代碼（JS）:</p><pre><code>function countSubArray(k, nums) {  let ans = 0;  let pre = 0;  for (let i = 0; i &lt; nums.length; i++) {    if (nums[i] &lt;= k) {      pre += 1;    } else {      pre = 0;    }    ans += pre;  }  return ans;}</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「複雜度分析」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，其中 N 為數組長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：</span></li></ul><h1 class=pgc-h-arrow-right><strong>母題 4</strong></h1><p>如果我讓你求出子數組最大值剛好是 k 的子數組的個數呢？ 比如 [1,3,4] 子數組有 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">[1], [3], [4], [1,3], [3,4] , [1,3,4]</span>，子數組最大值剛好是 3 的子數組有 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">[3], [1,3]</span> ，那麼 [1,3,4] 子數組最大值剛好是 3 的子數組個數就是 2。實現函數 exactK(k, nums)。</p><p>實際上是 exactK 可以直接利用 atMostK，即 atMostK(k) - atMostK(k - 1)，原因見下方母題 5 部分。</p><h1 class=pgc-h-arrow-right><strong>母題 5</strong></h1><p>如果我讓你求出子數組最大值剛好是 介於 k1 和 k2 的子數組的個數呢？實現函數 betweenK(k1, k2, nums)。</p><p>實際上是 betweenK 可以直接利用 atMostK，即 atMostK(k1, nums) - atMostK(k2 - 1, nums)，其中 k1 > k2。前提是值是離散的， 比如上面我出的題都是整數。 因此我可以直接 減 1，因為 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「1 是兩個整數最小的間隔」</span></strong>。</p><div class=pgc-img><img alt=「西法帶你學算法」一次搞定前綴和 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f99b4e02b8404f41993fedcf0d2088b2><p class=pgc-img-caption></p></div><p>如上，<span style="color:#3594f7;--tt-darkmode-color: #3594F7">小於等於 10 的區域</span>減去 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">小於 5 的區域</span>就是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">大於等於 5 且小於等於 10 的區域</span>。</p><p>注意我說的是小於 5， 不是小於等於 5。 由於整數是離散的，最小間隔是 1。因此小於 5 在這裡就等價於 小於等於 4。這就是 betweenK(k1, k2, nums) = atMostK(k1) - atMostK(k2 - 1) 的原因。</p><p>因此不難看出 exactK 其實就是 betweenK 的特殊形式。 當 k1 == k2 的時候， betweenK 等價於 exactK。</p><p>因此 atMostK 就是靈魂方法，一定要掌握，不明白建議多看幾遍。</p><p>有了上面的鋪墊， 我們來看下第一道題。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">467. 環繞字符串中唯一的子字符串（中等）</span></strong></h1><h1 class=pgc-h-arrow-right><strong>題目描述</strong></h1><pre><code>把字符串 s 看作是“abcdefghijklmnopqrstuvwxyz”的無限環繞字符串，所以 s 看起來是這樣的："...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". 現在我們有了另一個字符串 p 。你需要的是找出 s 中有多少個唯一的 p 的非空子串，尤其是當你的輸入是字符串 p ，你需要輸出字符串 s 中 p 的不同的非空子串的數目。 注意: p 僅由小寫的英文字母組成，p 的大小可能超過 10000。 示例 1:輸入: "a"輸出: 1解釋: 字符串 S 中只有一個"a"子字符。 示例 2:輸入: "cac"輸出: 2解釋: 字符串 S 中的字符串“cac”只有兩個子串“a”、“c”。. 示例 3:輸入: "zab"輸出: 6解釋: 在字符串 S 中有六個子串“z”、“a”、“b”、“za”、“ab”、“zab”。. </code></pre><h1 class=pgc-h-arrow-right><strong>前置知識</strong></h1><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">滑動窗口</span></li></ul><h1 class=pgc-h-arrow-right><strong>思路</strong></h1><p>題目是讓我們找 p 在 s 中出現的非空子串數目，而 s 是固定的一個無限循環字符串。由於 p 的數據範圍是 10^5 ，因此暴力找出所有子串就需要 10^10 次操作了，應該會超時。而且題目很多信息都沒用到，肯定不對。</p><p>仔細看下題目發現，這不就是母題 2 的變種麼？話不多說， 直接上代碼，看看有多像。</p><blockquote class=pgc-blockquote-abstract><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">為了減少判斷， 我這裡用了一個黑科技， p 前面加了個 </span><span style="color:#3594f7;--tt-darkmode-color: #3594F7">^</span>。</p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><pre><code>class Solution:    def findSubstringInWraproundString(self, p: str) -&gt; int:        p = '^' + p        w = 1        ans = 0        for i in range(1,len(p)):            if ord(p[i])-ord(p[i-1]) == 1 or ord(p[i])-ord(p[i-1]) == -25:                w += 1            else:                w = 1            ans += w        return ans</code></pre><p>如上代碼是有問題。 比如 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">cac</span>會被計算為 3，實際上應該是 2。根本原因在於 c 被錯誤地計算了兩次。因此一個簡單的思路就是用 set 記錄一下訪問過的子字符串即可。比如：</p><pre><code>{    c,    abc,    ab,    abcd}</code></pre><p>而由於 set 中的元素一定是連續的，因此上面的數據也可以用 hashmap 存：</p><pre><code>{    c: 3    d: 4    b: 1}</code></pre><p>含義是：</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">以 b 結尾的子串最大長度為 1，也就是 b。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">以 c 結尾的子串最大長度為 3，也就是 abc。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">以 d 結尾的子串最大長度為 4，也就是 abcd。</span></li></ul><p>至於 c ，是沒有必要存的。我們可以通過母題 2 的方式算出來。</p><p>具體算法：</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">定義一個 len_mapper。key 是 字母， value 是 長度。 含義是以 key 結尾的最長連續子串的長度。</span></li></ul><blockquote class=pgc-blockquote-abstract><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">關鍵字是：最長</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">用一個變量 w 記錄連續子串的長度，遍歷過程根據 w 的值更新 len_mapper</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">返回 len_mapper 中所有 value 的和。</span></li></ul><p>比如: abc，此時的 len_mapper 為:</p><pre><code>{    c: 3    b: 2    a: 1}</code></pre><p>再比如：abcab，此時的 len_mapper 依舊。</p><p>再比如: abcazabc，此時的 len_mapper：</p><pre><code>{    c: 4    b: 3    a: 2    z: 1}</code></pre><p>這就得到了去重的目的。這種算法是不重不漏的，因為最長的連續子串一定是包含了比它短的連續子串，這個思想和 <span style="color:#595959;--tt-darkmode-color: #595959">1297. 子串的最大出現次數[8]</span> 剪枝的方法有異曲同工之妙。</p><h1 class=pgc-h-arrow-right><strong>代碼（Python）</strong></h1><pre><code>class Solution:    def findSubstringInWraproundString(self, p: str) -&gt; int:        p = '^' + p        len_mapper = collections.defaultdict(lambda: 0)        w = 1        for i in range(1,len(p)):            if ord(p[i])-ord(p[i-1]) == 1 or ord(p[i])-ord(p[i-1]) == -25:                w += 1            else:                w = 1            len_mapper[p[i]] = max(len_mapper[p[i]], w)        return sum(len_mapper.values())</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「複雜度分析」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，其中 為字符串 p 的長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：由於最多存儲 26 個字母， 因此空間實際上是常數，故空間複雜度為 。</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">795. 區間</span></strong><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">子</span></strong><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">數組個數（中等）</span></strong></h1><h1 class=pgc-h-arrow-right><strong>題目描述</strong></h1><pre><code>給定一個元素都是正整數的數組 A ，正整數 L  以及  R (L &lt;= R)。求連續、非空且其中最大元素滿足大於等於 L  小於等於 R 的子數組個數。例如 :輸入:A = [2, 1, 4, 3]L = 2R = 3輸出: 3解釋: 滿足條件的子數組: [2], [2, 1], [3].注意:L, R  和  A[i] 都是整數，範圍在  [0, 10^9]。數組  A  的長度範圍在[1, 50000]。</code></pre><h1 class=pgc-h-arrow-right><strong>前置知識</strong></h1><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">滑動窗口</span></li></ul><h1 class=pgc-h-arrow-right><strong>思路</strong></h1><p>由母題 5，我們知道 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「betweenK 可以直接利用 atMostK，即 atMostK(k1) - atMostK(k2 - 1)，其中 k1 > k2」</span></strong>。</p><p>由母題 2，我們知道如何求滿足一定條件（這裡是元素都小於等於 R）子數組的個數。</p><p>這兩個結合一下， 就可以解決。</p><h1 class=pgc-h-arrow-right><strong>代碼（Python）</strong></h1><blockquote class=pgc-blockquote-abstract><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">代碼是不是很像</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><pre><code>class Solution:    def numSubarrayBoundedMax(self, A: List[int], L: int, R: int) -&gt; int:        def notGreater(R):            ans = cnt = 0            for a in A:                if a &lt;= R: cnt += 1                else: cnt = 0                ans += cnt            return  ans        return notGreater(R) - notGreater(L - 1)</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「</span></strong><em><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">複雜度分析</span></strong></em><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，其中 為數組長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：。</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">904. 水果成籃（中等）</span></strong></h1><h1 class=pgc-h-arrow-right><strong>題目描述</strong></h1><pre><code>在一排樹中，第 i 棵樹產生 tree[i] 型的水果。你可以從你選擇的任何樹開始，然後重複執行以下步驟：把這棵樹上的水果放進你的籃子裡。如果你做不到，就停下來。移動到當前樹右側的下一棵樹。如果右邊沒有樹，就停下來。請注意，在選擇一顆樹後，你沒有任何選擇：你必須執行步驟 1，然後執行步驟 2，然後返回步驟 1，然後執行步驟 2，依此類推，直至停止。你有兩個籃子，每個籃子可以攜帶任何數量的水果，但你希望每個籃子只攜帶一種類型的水果。用這個程序你能收集的水果樹的最大總量是多少？ 示例 1：輸入：[1,2,1]輸出：3解釋：我們可以收集 [1,2,1]。示例 2：輸入：[0,1,2,2]輸出：3解釋：我們可以收集 [1,2,2]如果我們從第一棵樹開始，我們將只能收集到 [0, 1]。示例 3：輸入：[1,2,3,2,2]輸出：4解釋：我們可以收集 [2,3,2,2]如果我們從第一棵樹開始，我們將只能收集到 [1, 2]。示例 4：輸入：[3,3,3,1,2,1,1,2,3,3,4]輸出：5解釋：我們可以收集 [1,2,1,1,2]如果我們從第一棵樹或第八棵樹開始，我們將只能收集到 4 棵水果樹。 提示：1 &lt;= tree.length &lt;= 400000 &lt;= tree[i] &lt; tree.length</code></pre><h1 class=pgc-h-arrow-right><strong>前置知識</strong></h1><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">滑動窗口</span></li></ul><h1 class=pgc-h-arrow-right><strong>思路</strong></h1><p>題目花裡胡哨的。我們來抽象一下，就是給你一個數組， 讓你<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「選定一個子數組， 這個子數組最多隻有兩種數字」</span></strong>，這個選定的子數組最大可以是多少。</p><p>這不就和母題 3 一樣麼？只不過 k 變成了固定值 2。另外由於題目要求整個窗口最多兩種數字，我們用哈希表存一下不就好了嗎？</p><blockquote class=pgc-blockquote-abstract><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">set 是不行了的。 因此我們不但需要知道幾個數字在窗口， 我們還要知道每個數字出現的次數，這樣才可以使用滑動窗口優化時間複雜度。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>代碼（Python）</strong></h1><pre><code>class Solution:    def totalFruit(self, tree: List[int]) -&gt; int:        def atMostK(k, nums):            i = ans = 0            win = defaultdict(lambda: 0)            for j in range(len(nums)):                if win[nums[j]] == 0: k -= 1                win[nums[j]] += 1                while k &lt; 0:                    win[nums[i]] -= 1                    if win[nums[i]] == 0: k += 1                    i += 1                ans = max(ans, j - i + 1)            return ans        return atMostK(2, tree)</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「複雜度分析」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，其中 為數組長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：。</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">992. K 個不同整數的子數組（困難）</span></strong></h1><h1 class=pgc-h-arrow-right><strong>題目描述</strong></h1><pre><code>給定一個正整數數組 A，如果 A 的某個子數組中不同整數的個數恰好為 K，則稱 A 的這個連續、不一定獨立的子數組為好子數組。（例如，[1,2,3,1,2] 中有 3 個不同的整數：1，2，以及 3。）返回 A 中好子數組的數目。 示例 1：輸入：A = [1,2,1,2,3], K = 2輸出：7解釋：恰好由 2 個不同整數組成的子數組：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].示例 2：輸入：A = [1,2,1,3,4], K = 3輸出：3解釋：恰好由 3 個不同整數組成的子數組：[1,2,1,3], [2,1,3], [1,3,4]. 提示：1 &lt;= A.length &lt;= 200001 &lt;= A[i] &lt;= A.length1 &lt;= K &lt;= A.length</code></pre><h1 class=pgc-h-arrow-right><strong>前置知識</strong></h1><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">滑動窗口</span></li></ul><h1 class=pgc-h-arrow-right><strong>思路</strong></h1><p>由母題 5，知：exactK = atMostK(k) - atMostK(k - 1)， 因此答案便呼之欲出了。其他部分和上面的題目 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">904. 水果成籃</span> 一樣。</p><blockquote class=pgc-blockquote-abstract><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">實際上和所有的滑動窗口題目都差不多。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>代碼（Python）</strong></h1><pre><code>class Solution:    def subarraysWithKDistinct(self, A, K):        return self.atMostK(A, K) - self.atMostK(A, K - 1)    def atMostK(self, A, K):        counter = collections.Counter()        res = i = 0        for j in range(len(A)):            if counter[A[j]] == 0:                K -= 1            counter[A[j]] += 1            while K &lt; 0:                counter[A[i]] -= 1                if counter[A[i]] == 0:                    K += 1                i += 1            res += j - i + 1        return res</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「複雜度分析」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，中 為數組長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：。</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">1109. 航班預訂統計（中等）</span></strong></h1><h1 class=pgc-h-arrow-right><strong>題目描述</strong></h1><pre><code>這裡有  n  個航班，它們分別從 1 到 n 進行編號。我們這兒有一份航班預訂表，表中第  i  條預訂記錄  bookings[i] = [i, j, k]  意味著我們在從  i  到  j  的每個航班上預訂了 k 個座位。請你返回一個長度為 n 的數組  answer，按航班編號順序返回每個航班上預訂的座位數。示例：輸入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5輸出：[10,55,45,25,25]提示：1 &lt;= bookings.length &lt;= 200001 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 200001 &lt;= bookings[i][2] &lt;= 10000</code></pre><h1 class=pgc-h-arrow-right><strong>前置知識</strong></h1><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">前綴和</span></li></ul><h1 class=pgc-h-arrow-right><strong>思路</strong></h1><p>這道題的題目描述不是很清楚。我簡單分析一下題目：</p><p>[i, j, k] 其實代表的是 第 i 站上來了 k 個人， 一直到 第 j 站都在飛機上，到第 j + 1 就不在飛機上了。所以第 i 站到第 j 站的<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「每一站」</span></strong>都會因此多 k 個人。</p><p>理解了題目只會不難寫出下面的代碼。</p><pre><code>class Solution:    def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]:        counter = [0] * n        for i, j, k in bookings:            while i &lt;= j:                counter[i - 1] += k                i += 1        return counter</code></pre><p>如上的代碼複雜度太高，無法通過全部的測試用例。</p><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「注意到裡層的 while 循環是連續的數組全部加上一個數字，不難想到可以利用母題 0 的前綴和思路優化。」</span></strong></p><div class=pgc-img><img alt=「西法帶你學算法」一次搞定前綴和 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d25ea30f3ba14c84a1ad1ba3581fe945><p class=pgc-img-caption></p></div><p>一種思路就是在 i 的位置 + k， 然後利用前綴和的技巧給 i 到 n 的元素都加上 k。但是題目需要加的是一個區間， j + 1 及其之後的元素會被多加一個 k。一個簡單的技巧就是給 j + 1 的元素減去 k，這樣正負就可以抵消。</p><div class=pgc-img><img alt=「西法帶你學算法」一次搞定前綴和 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/060de980632544cb859ca123268ad26a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>代碼（Python）</strong></h1><pre><code>class Solution:    def corpFlightBookings(self, bookings: List[List[int]], n: int) -&gt; List[int]:        counter = [0] * (n + 1)        for i, j, k in bookings:            counter[i - 1] += k            if j &lt; n: counter[j] -= k        for i in range(n + 1):            counter[i] += counter[i - 1]        return counter[:-1]</code></pre><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「複雜度分析」</span></strong></p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">時間複雜度：，中 為數組長度。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">空間複雜度：。</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">總結</span></strong></h1><p>這幾道題都是滑動窗口和前綴和的思路。力扣類似的題目還真不少，大家只有多留心，就會發現這個套路。</p><p>前綴和的技巧以及滑動窗口的技巧都比較固定，且有模板可套。 難點就在於我怎麼才能想到可以用這個技巧呢？</p><p>我這裡總結了兩點：</p><ol start=1><li><span style="color:#595959;--tt-darkmode-color: #595959">找關鍵字。比如題目中有連續，就應該條件反射想到滑動窗口和前綴和。比如題目求最大最小就想到動態規劃和貪心等等。想到之後，就可以和題目信息對比快速排除錯誤的算法，找到可行解。這個思考的時間會隨著你的題感增加而降低。</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">先寫出暴力解，然後找暴力解的瓶頸， 根據瓶頸就很容易知道應該用什麼數據結構和算法去優化。</span></li></ol><p>最後推薦幾道類似的題目， 供大家練習，一定要自己寫出來才行哦。</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">303. 區域和檢索 - 數組不可變[9]</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">1186.刪除一次得到子數組最大和[10]</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">1310. 子數組異或查詢[11]</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">1371. 每個元音包含偶數次的最長</span><span style="color:#595959;--tt-darkmode-color: #595959">子</span><span style="color:#595959;--tt-darkmode-color: #595959">字符串[12]</span></li></ul><p>大家對此有何看法，歡迎給我留言，我有時間都會一一查看回答。</p><p>更多算法套路可以訪問我的 LeetCode 題解倉庫：https://github.com/azl397985856/leetcode 。 目前已經 36K star 啦。</p><p>大家也可以關注我的公眾號《力扣加加》帶你啃下算法這塊硬骨頭。</p><h1 class=pgc-h-arrow-right><span style="color:#595959;--tt-darkmode-color: #595959">Reference</span></h1><p>[1]467. 環繞字符串中唯一的子字符串: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/</span></em></p><p>[2]795. 區間子數組個數: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/</span></em></p><p>[3]904. 水果成籃: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://leetcode-cn.com/problems/fruit-into-baskets/</span></em></p><p>[4]992. K 個不同整數的子數組: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://leetcode-cn.com/problems/subarrays-with-k-different-integers/</span></em></p><p>[5]1109. 航班預訂統計: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://leetcode-cn.com/problems/corporate-flight-bookings/</span></em></p><p>[6]</p><p>前綴和: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://oi-wiki.org/basic/prefix-sum/</span></em></p><p>[7]滑動窗口專題（思路 + 模板）: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md</span></em></p><p>[8]1297. 子串的最大出現次數: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://github.com/azl397985856/leetcode/issues/266</span></em></p><p>[9]303. 區域和檢索 - 數組不可變: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://leetcode-cn.com/problems/range-sum-query-immutable/description/</span></em></p><p>[10]</p><p>1186.刪除一次得到子數組最大和: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://lucifer.ren/blog/2019/12/11/leetcode-1186/</span></em></p><p>[11]1310. 子數組異或查詢: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/</span></em></p><p>[12]1371. 每個元音包含偶數次的最長子字符串: <em><span style="color:#595959;--tt-darkmode-color: #595959">https://github.com/azl397985856/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md</span></em></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>前綴</a></li><li><a>西法</a></li><li><a>搞定</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c0bfc933.html alt=非屏蔽線纜如何搞定EMC class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9c5d51ce26004738ad3d722b11ae7a6d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c0bfc933.html title=非屏蔽線纜如何搞定EMC>非屏蔽線纜如何搞定EMC</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/21474a0e.html alt=一張圖搞定對哈希表的理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a49c66caf9044e7b086f48696b04283 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/21474a0e.html title=一張圖搞定對哈希表的理解>一張圖搞定對哈希表的理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8f96678.html alt=岩土工程中常見的“問題土”，你能搞定麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/ff2cc239-91c3-4614-94aa-e4f389a0b20d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8f96678.html title=岩土工程中常見的“問題土”，你能搞定麼？>岩土工程中常見的“問題土”，你能搞定麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9de860d6.html alt=一張表格，搞定所有注塑缺陷 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6e8146a9bc2c4cfa848b205a2d2e26cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9de860d6.html title=一張表格，搞定所有注塑缺陷>一張表格，搞定所有注塑缺陷</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4e78a26.html alt=二叉樹的算法代碼，一篇文章全搞定！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4e78a26.html title=二叉樹的算法代碼，一篇文章全搞定！>二叉樹的算法代碼，一篇文章全搞定！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a014ea33.html alt=受吃雞熱影響？《H1Z1》去前綴更名“只為生存” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/322b00050a5571e578de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a014ea33.html title=受吃雞熱影響？《H1Z1》去前綴更名“只為生存”>受吃雞熱影響？《H1Z1》去前綴更名“只為生存”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51db726e.html alt=搞定所有擋土牆施工套路，看這一次就夠了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1521094135859ec6cbdf6c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51db726e.html title=搞定所有擋土牆施工套路，看這一次就夠了！>搞定所有擋土牆施工套路，看這一次就夠了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8156c7cb.html alt=最簡單的數據地圖製作，一共6步搞定！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/faed9b38af8a445886a4fe7aee80f0d6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8156c7cb.html title=最簡單的數據地圖製作，一共6步搞定！>最簡單的數據地圖製作，一共6步搞定！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c2f1cb7.html alt=最簡單的數據地圖製作，只要6步就搞定！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/28ab4789186d463ea7957d8653e498d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c2f1cb7.html title=最簡單的數據地圖製作，只要6步就搞定！>最簡單的數據地圖製作，只要6步就搞定！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea1654dd.html alt=告別加班，教你一招給表格數據添加前綴、後綴的辦法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/43607407-7017-4832-bbef-7919436ef0a8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea1654dd.html title=告別加班，教你一招給表格數據添加前綴、後綴的辦法>告別加班，教你一招給表格數據添加前綴、後綴的辦法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3858d36b.html alt=手機容量太小？幾百塊就能搞定何必多花一千多買大容量手機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/71290c5b2d3746cbbeca37f5386515fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3858d36b.html title=手機容量太小？幾百塊就能搞定何必多花一千多買大容量手機>手機容量太小？幾百塊就能搞定何必多花一千多買大容量手機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9a6017f.html alt=一文搞定分佈式文件系統FastDFS class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c4fc524877574c51905170a1f43effdb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9a6017f.html title=一文搞定分佈式文件系統FastDFS>一文搞定分佈式文件系統FastDFS</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd9b6420.html alt=一文搞定9大經典的算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/ac893ead-1741-4d35-bc74-d6df13d7de85 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd9b6420.html title=一文搞定9大經典的算法思想>一文搞定9大經典的算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a03ba41.html alt=一文搞定熱電偶和熱電阻 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153053914785113a5e5cae1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a03ba41.html title=一文搞定熱電偶和熱電阻>一文搞定熱電偶和熱電阻</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/a429df56.html alt=最有效的求解方法：三行代碼搞定任何線性方程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/edd4b9a7cac74db5974b38a81d5b7abd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/a429df56.html title=最有效的求解方法：三行代碼搞定任何線性方程>最有效的求解方法：三行代碼搞定任何線性方程</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>