<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java互聯網架構-P7架構師教你重新認識HashMap | 极客快訊</title><meta property="og:title" content="Java互聯網架構-P7架構師教你重新認識HashMap - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/dfic-imagehandler/9fd772ed-1884-405f-8e67-408800d5c62f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91645749.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91645749.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91645749.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91645749.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91645749.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91645749.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91645749.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91645749.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="Java互聯網架構-P7架構師教你重新認識HashMap"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/91645749.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java互聯網架構-P7架構師教你重新認識HashMap</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>歡迎關注頭條號：java小馬哥</strong></p><p><strong>週一至週日下午三點半！精品技術文章準時送上！！！</strong></p><p><strong>精品學習資料獲取通道，參見文末</strong></p><div class=pgc-img><img alt=Java互聯網架構-P7架構師教你重新認識HashMap onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/9fd772ed-1884-405f-8e67-408800d5c62f><p class=pgc-img-caption></p></div><h1>前言</h1><p>這次我和大家一起學習HashMap，HashMap我們在工作中經常會使用，而且面試中也很頻繁會問到，因為它裡面蘊含著很多知識點，可以很好的考察個人基礎。但一個這麼重要的東西，我為什麼沒有在一開始就去學習它呢，因為它是由多種基礎的數據結構和一些代碼設計思想組成的。我們要學習了這些基礎，再學習HashMap，這樣我們才能更好的去理解它。古人云：無慾速，無見小利。欲速則不達，見小利則大事不成。</p><h1>好戲開始</h1><p>1.</p><p>問：HashMap有用過嗎？您能給我說說他的主要用途嗎？</p><p>答：</p><ul><li>有用過，我在平常工作中經常會用到HashMap這種數據結構，HashMap是基於Map接口實現的一種鍵-值對&lt;key,value>的存儲結構，允許null值，同時非有序，非同步(即線程不安全)。HashMap的底層實現是數組 + 鏈表 + 紅黑樹（JDK1.8增加了紅黑樹部分）。它存儲和查找數據時，是根據鍵key的hashCode的值計算出具體的存儲位置。HashMap最多隻允許一條記錄的鍵key為null，HashMap增刪改查等常規操作都有不錯的執行效率，是ArrayList和LinkedList等數據結構的一種折中實現。</li></ul><p>示例代碼：</p><pre> // 創建一個HashMap，如果沒有指定初始大小，默認底層hash表數組的大小為16 HashMap&lt;String, String&gt; hashMap = new HashMap&lt;String, String&gt;(); // 往容器裡面添加元素 hashMap.put("小明", "好帥"); hashMap.put("老王", "坑爹貨"); hashMap.put("老鐵", "沒毛病"); hashMap.put("掘金", "好地方"); hashMap.put("王五", "別搞事"); // 獲取key為小明的元素 好帥 String element = hashMap.get("小明"); // value : 好帥 System.out.println(element); // 移除key為王五的元素 String removeElement = hashMap.remove("王五"); // value : 別搞事 System.out.println(removeElement); // 修改key為小明的元素的值value 為 其實有點醜 hashMap.replace("小明", "其實有點醜"); // {老鐵=沒毛病, 小明=其實有點醜, 老王=坑爹貨, 掘金=好地方} System.out.println(hashMap); // 通過put方法也可以達到修改對應元素的值的效果 hashMap.put("小明", "其實還可以啦,開玩笑的"); // {老鐵=沒毛病, 小明=其實還可以啦,開玩笑的, 老王=坑爹貨, 掘金=好地方} System.out.println(hashMap); // 判斷key為老王的元素是否存在(捉姦老王) boolean isExist = hashMap.containsKey("老王"); // true , 老王竟然來搞事 System.out.println(isExist); // 判斷是否有 value = "坑爹貨" 的人 boolean isHasSomeOne = hashMap.containsValue("坑爹貨"); // true 老王是坑爹貨 System.out.println(isHasSomeOne); // 查看這個容器裡面還有幾個傢伙 value : 4 System.out.println(hashMap.size());</pre><ul><li>HashMap的底層實現是數組 + 鏈表 + 紅黑樹（JDK1.8增加了紅黑樹部分），核心組成元素有：</li></ul><ol><li>int size;用於記錄HashMap實際存儲元素的個數；</li><li>float loadFactor;負載因子（默認是0.75，此屬性後面詳細解釋）。</li><li>int threshold;下一次擴容時的閾值，達到閾值便會觸發擴容機制resize（閾值 threshold = 容器容量 capacity * 負載因子 load factor）。也就是說，在容器定義好容量之後，負載因子越大，所能容納的鍵值對元素個數就越多。</li><li>Node&lt;K,V>[] table; 底層數組，充當哈希表的作用，用於存儲對應hash位置的元素Node&lt;K,V>，此數組長度總是2的N次冪。（具體原因後面詳細解釋）</li></ol><p>示例代碼：</p><pre>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable {····· /* ---------------- Fields -------------- */ /** * 哈希表，在第一次使用到時進行初始化，重置大小是必要的操作， * 當分配容量時，長度總是2的N次冪。 */ transient Node&lt;K,V&gt;[] table; /** * 實際存儲的key - value 鍵值對 個數 */ transient int size; /** * 下一次擴容時的閾值  * (閾值 threshold = 容器容量 capacity * 負載因子 load factor). * @serial */ int threshold; /** * 哈希表的負載因子 * * @serial */ final float loadFactor;·····}</pre><ul><li>其中Node&lt;K,V>[] table;哈希表存儲的核心元素是Node&lt;K,V>,Node&lt;K,V>包含：</li></ul><ol><li>final int hash;元素的哈希值，決定元素存儲在Node&lt;K,V>[] table;哈希表中的位置。由final修飾可知，當hash的值確定後，就不能再修改。</li><li>final K key; 鍵，由final修飾可知，當key的值確定後，就不能再修改。</li><li>V value; 值</li><li>Node&lt;K,V> next; 記錄下一個元素結點(單鏈表結構，用於解決hash衝突)</li></ol><p>示例代碼：</p><pre> /** * 定義HashMap存儲元素結點的底層實現 */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash;//元素的哈希值 由final修飾可知，當hash的值確定後，就不能再修改 final K key;// 鍵，由final修飾可知，當key的值確定後，就不能再修改 V value; // 值 Node&lt;K,V&gt; next; // 記錄下一個元素結點(單鏈表結構，用於解決hash衝突)  /** * Node結點構造方法 */ Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash;//元素的哈希值 this.key = key;// 鍵 this.value = value; // 值 this.next = next;// 記錄下一個元素結點 } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + "=" + value; } /** * 為Node重寫hashCode方法，值為：key的hashCode 異或 value的hashCode  * 運算作用就是將2個hashCode的二進制中，同一位置相同的值為0，不同的為1。 */ public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } /** * 修改某一元素的值 */ public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } /** * 為Node重寫equals方法 */ public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } }</pre><div class=pgc-img><img alt=Java互聯網架構-P7架構師教你重新認識HashMap onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5bab8489318646ad8a004c4791f92666><p class=pgc-img-caption></p></div><p>hashMap內存結構圖 - 圖片來自於《美團點評技術團隊文章》</p><p>2.</p><p>問：您能說說HashMap常用操作的底層實現原理嗎？如存儲put(K key, V value)，查找get(Object key)，刪除remove(Object key)，修改replace(K key, V value)等操作。</p><p>答：</p><ul><li>調用put(K key, V value)操作添加key-value鍵值對時，進行了如下操作：</li></ul><ol><li>判斷哈希表Node&lt;K,V>[] table是否為空或者null，是則執行resize()方法進行擴容。</li><li>根據插入的鍵值key的hash值，通過(n - 1) & hash當前元素的hash值 & hash表長度 - 1（實際就是 hash值 % hash表長度） 計算出存儲位置table[i]。如果存儲位置沒有元素存放，則將新增結點存儲在此位置table[i]。</li><li>如果存儲位置已經有鍵值對元素存在，則判斷該位置元素的hash值和key值是否和當前操作元素一致，一致則證明是修改value操作，覆蓋value即可。</li><li>當前存儲位置即有元素，又不和當前操作元素一致，則證明此位置table[i]已經發生了hash衝突，則通過判斷頭結點是否是treeNode，如果是treeNode則證明此位置的結構是紅黑樹，已紅黑樹的方式新增結點。</li><li>如果不是紅黑樹，則證明是單鏈表，將新增結點插入至鏈表的最後位置，隨後判斷當前鏈表長度是否 大於等於 8，是則將當前存儲位置的鏈表轉化為紅黑樹。遍歷過程中如果發現key已經存在，則直接覆蓋value。</li><li>插入成功後，判斷當前存儲鍵值對的數量 大於 閾值threshold 是則擴容。</li></ol><div class=pgc-img><img alt=Java互聯網架構-P7架構師教你重新認識HashMap onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3a0f73d74988459bb33f7cd97cf3caf3><p class=pgc-img-caption></p></div><p>hashMap put方法執行流程圖- 圖片來自於《美團點評技術團隊文章》</p><p>示例代碼：</p><pre> /** * 添加key-value鍵值對 * * @param key 鍵 * @param value 值 * @return 如果原本存在此key，則返回舊的value值，如果是新增的key-  * value，則返回nulll */ public V put(K key, V value) { //實際調用putVal方法進行添加 key-value 鍵值對操作 return putVal(hash(key), key, value, false, true); } /** * 根據key 鍵 的 hashCode 通過 “擾動函數” 生成對應的 hash值 * 經過此操作後，使每一個key對應的hash值生成的更均勻， * 減少元素之間的碰撞機率（後面詳細說明） */ static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } /** * 添加key-value鍵值對的實際調用方法（重點） * * @param hash key 鍵的hash值 * @param key 鍵 * @param value 值 * @param onlyIfAbsent 此值如果是true, 則如果此key已存在value，則不執 * 行修改操作  * @param evict 此值如果是false，哈希表是在初始化模式 * @return 返回原本的舊值, 如果是新增，則返回null */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // 用於記錄當前的hash表 Node&lt;K,V&gt;[] tab;  // 用於記錄當前的鏈表結點 Node&lt;K,V&gt; p;  // n用於記錄hash表的長度，i用於記錄當前操作索引index int n, i; // 當前hash表為空 if ((tab = table) == null || (n = tab.length) == 0) // 初始化hash表，並把初始化後的hash表長度值賦值給n n = (tab = resize()).length; // 1）通過 (n - 1) &amp; hash 當前元素的hash值 &amp; hash表長度 - 1 // 2）確定當前元素的存儲位置，此運算等價於 當前元素的hash值 % hash表的長度 // 3）計算出的存儲位置沒有元素存在 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 4) 則新建一個Node結點，在該位置存儲此元素 tab[i] = newNode(hash, key, value, null); else { // 當前存儲位置已經有元素存在了(不考慮是修改的情況的話，就代表發生hash衝突了) // 用於存放新增結點 Node&lt;K,V&gt; e;  // 用於臨時存在某個key值 K k; // 1)如果當前位置已存在元素的hash值和新增元素的hash值相等 // 2)並且key也相等，則證明是同一個key元素，想執行修改value操作 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p;// 將當前結點引用賦值給e else if (p instanceof TreeNode) // 如果當前結點是樹結點 // 則證明當前位置的鏈表已變成紅黑樹結構，則已紅黑樹結點結構新增元素 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else {// 排除上述情況，則證明已發生hash衝突，並hash衝突位置現時的結構是單鏈表結構 for (int binCount = 0; ; ++binCount) { //遍歷單鏈表，將新元素結點放置此鏈表的最後一位 if ((e = p.next) == null) { // 將新元素結點放在此鏈表的最後一位 p.next = newNode(hash, key, value, null); // 新增結點後，當前結點數量是否大於等於 閾值 8  if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st // 大於等於8則將鏈表轉換成紅黑樹 treeifyBin(tab, hash); break; } // 如果鏈表中已經存在對應的key，則覆蓋value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // 已存在對應key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) //如果允許修改，則修改value為新值 e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 當前存儲鍵值對的數量 大於 閾值 是則擴容 if (++size &gt; threshold) // 重置hash大小，將舊hash表的數據逐一複製到新的hash表中（後面詳細講解） resize(); afterNodeInsertion(evict); // 返回null，則證明是新增操作，而不是修改操作 return null; }</pre><ul><li>調用get(Object key)操作根據鍵key查找對應的key-value鍵值對時，進行了如下操作：</li></ul><ol><li>先調用 hash(key)方法計算出 key 的 hash值</li><li>根據查找的鍵值key的hash值，通過(n - 1) & hash當前元素的hash值 & hash表長度 - 1（實際就是 hash值 % hash表長度） 計算出存儲位置table[i]，判斷存儲位置是否有元素存在 。</li></ol><ul><li>如果存儲位置有元素存放，則首先比較頭結點元素，如果頭結點的key的hash值 和 要獲取的key的hash值相等，並且 頭結點的key本身 和要獲取的 key 相等，則返回該位置的頭結點。</li><li>如果存儲位置沒有元素存放，則返回null。</li></ul><ol><li>如果存儲位置有元素存放，但是頭結點元素不是要查找的元素，則需要遍歷該位置進行查找。</li><li>先判斷頭結點是否是treeNode，如果是treeNode則證明此位置的結構是紅黑樹，以紅色樹的方式遍歷查找該結點，沒有則返回null。</li><li>如果不是紅黑樹，則證明是單鏈表。遍歷單鏈表，逐一比較鏈表結點，鏈表結點的key的hash值 和 要獲取的key的hash值相等，並且 鏈表結點的key本身 和要獲取的 key 相等，則返回該結點，遍歷結束仍未找到對應key的結點，則返回null。</li></ol><p>示例代碼：</p><pre> /** * 返回指定 key 所映射的 value 值 * 或者 返回 null 如果容器裡不存在對應的key * * 更確切地講，如果此映射包含一個滿足 (key==null ? k==null :key.equals(k)) * 的從 k 鍵到 v 值的映射關係， * 則此方法返回 v；否則返回 null。（最多只能有一個這樣的映射關係。） * * 返回 null 值並不一定 表明該映射不包含該鍵的映射關係； * 也可能該映射將該鍵顯示地映射為 null。可使用containsKey操作來區分這兩種情況。  * * @see #put(Object, Object) */ public V get(Object key) { Node&lt;K,V&gt; e; // 1.先調用 hash(key)方法計算出 key 的 hash值 // 2.隨後調用getNode方法獲取對應key所映射的value值 return (e = getNode(hash(key), key)) == null ? null : e.value; } /** * 獲取哈希表結點的方法實現 * * @param hash key 鍵的hash值 * @param key 鍵 * @return 返回對應的結點，如果結點不存在，則返回null */ final Node&lt;K,V&gt; getNode(int hash, Object key) { // 用於記錄當前的hash表  Node&lt;K,V&gt;[] tab;  // first用於記錄對應hash位置的第一個結點，e充當工作結點的作用 Node&lt;K,V&gt; first, e;  // n用於記錄hash表的長度 int n;  // 用於臨時存放Key K k; // 通過 (n - 1) &amp; hash 當前元素的hash值 &amp; hash表長度 - 1 // 判斷當前元素的存儲位置是否有元素存在  if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {//元素存在的情況 // 如果頭結點的key的hash值 和 要獲取的key的hash值相等 // 並且 頭結點的key本身 和要獲取的 key 相等 if (first.hash == hash &amp;&amp; // always check first node 總是檢查頭結點 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) // 返回該位置的頭結點 return first; if ((e = first.next) != null) {// 頭結點不相等 if (first instanceof TreeNode) // 如果當前結點是樹結點 // 則證明當前位置的鏈表已變成紅黑樹結構 // 通過紅黑樹結點的方式獲取對應key結點 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do {// 當前位置不是紅黑樹，則證明是單鏈表 // 遍歷單鏈表，逐一比較鏈表結點 // 鏈表結點的key的hash值 和 要獲取的key的hash值相等 // 並且 鏈表結點的key本身 和要獲取的 key 相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 找到對應的結點則返回 return e; } while ((e = e.next) != null); } } // 通過上述查找均無找到，則返回null return null; }</pre><ul><li>調用remove(Object key)操作根據鍵key刪除對應的key-value鍵值對時，進行了如下操作：</li></ul><ol><li>先調用 hash(key)方法計算出 key 的 hash值</li><li>根據查找的鍵值key的hash值，通過(n - 1) & hash當前元素的hash值 & hash表長度 - 1（實際就是 hash值 % hash表長度） 計算出存儲位置table[i]，判斷存儲位置是否有元素存在 。</li></ol><ul><li>如果存儲位置有元素存放，則首先比較頭結點元素，如果頭結點的key的hash值 和 要獲取的key的hash值相等，並且 頭結點的key本身 和要獲取的 key 相等，則該位置的頭結點即為要刪除的結點，記錄此結點至變量node中。</li><li>如果存儲位置沒有元素存放，則沒有找到對應要刪除的結點，則返回null。</li></ul><ol><li>如果存儲位置有元素存放，但是頭結點元素不是要刪除的元素，則需要遍歷該位置進行查找。</li><li>先判斷頭結點是否是treeNode，如果是treeNode則證明此位置的結構是紅黑樹，以紅色樹的方式遍歷查找並刪除該結點，沒有則返回null。</li><li>如果不是紅黑樹，則證明是單鏈表。遍歷單鏈表，逐一比較鏈表結點，鏈表結點的key的hash值 和 要獲取的key的hash值相等，並且 鏈表結點的key本身 和要獲取的 key 相等，則此為要刪除的結點，記錄此結點至變量node中，遍歷結束仍未找到對應key的結點，則返回null。</li><li>如果找到要刪除的結點node，則判斷是否需要比較value也是否一致，如果value值一致或者不需要比較value值，則執行刪除結點操作，刪除操作根據不同的情況與結構進行不同的處理。</li></ol><ul><li>如果當前結點是樹結點，則證明當前位置的鏈表已變成紅黑樹結構，通過紅黑樹結點的方式刪除對應結點。</li><li>如果不是紅黑樹，則證明是單鏈表。如果要刪除的是頭結點，則當前存儲位置table[i]的頭結點指向刪除結點的下一個結點。</li><li>如果要刪除的結點不是頭結點，則將要刪除的結點的後繼結點node.next賦值給要刪除結點的前驅結點的next域，即p.next = node.next;。</li></ul><ol><li>HashMap當前存儲鍵值對的數量 - 1，並返回刪除結點。</li></ol><p>示例代碼：</p><pre> /** * 從此映射中移除指定鍵的映射關係（如果存在）。 * * @param key 其映射關係要從映射中移除的鍵 * @return 與 key 關聯的舊值；如果 key 沒有任何映射關係，則返回 null。 * （返回 null 還可能表示該映射之前將 null 與 key 關聯。） */ public V remove(Object key) { Node&lt;K,V&gt; e; // 1.先調用 hash(key)方法計算出 key 的 hash值 // 2.隨後調用removeNode方法刪除對應key所映射的結點 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } /** * 刪除哈希表結點的方法實現 * * @param hash 鍵的hash值 * @param key 鍵 * @param value 用於比較的value值，當matchValue 是 true時才有效, 否則忽略 * @param matchValue 如果是 true 只有當value相等時才會移除 * @param movable 如果是 false當執行移除操作時，不刪除其他結點 * @return 返回刪除結點node，不存在則返回null */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { // 用於記錄當前的hash表 Node&lt;K,V&gt;[] tab;  // 用於記錄當前的鏈表結點 Node&lt;K,V&gt; p;  // n用於記錄hash表的長度，index用於記錄當前操作索引index int n, index; // 通過 (n - 1) &amp; hash 當前元素的hash值 &amp; hash表長度 - 1 // 判斷當前元素的存儲位置是否有元素存在  if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) {// 元素存在的情況 // node 用於記錄找到的結點，e為工作結點 Node&lt;K,V&gt; node = null, e;  K k; V v; // 如果頭結點的key的hash值 和 要獲取的key的hash值相等 // 並且 頭結點的key本身 和要獲取的 key 相等 // 則證明此頭結點就是要刪除的結點 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 記錄要刪除的結點的引用地址至node中 node = p; else if ((e = p.next) != null) {// 頭結點不相等 if (p instanceof TreeNode)// 如果當前結點是樹結點 // 則證明當前位置的鏈表已變成紅黑樹結構 // 通過紅黑樹結點的方式獲取對應key結點 // 記錄要刪除的結點的引用地址至node中 node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else {// 當前位置不是紅黑樹，則證明是單鏈表 do { // 遍歷單鏈表，逐一比較鏈表結點 // 鏈表結點的key的hash值 和 要獲取的key的hash值相等 // 並且 鏈表結點的key本身 和要獲取的 key 相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { // 找到則記錄要刪除的結點的引用地址至node中，中斷遍歷 node = e; break; } p = e; } while ((e = e.next) != null); } } // 如果找到要刪除的結點，則判斷是否需要比較value也是否一致 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { // value值一致或者不需要比較value值，則執行刪除結點操作 if (node instanceof TreeNode) // 如果當前結點是樹結點 // 則證明當前位置的鏈表已變成紅黑樹結構 // 通過紅黑樹結點的方式刪除對應結點 ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) // node 和 p相等，則證明刪除的是頭結點 // 當前存儲位置的頭結點指向刪除結點的下一個結點 tab[index] = node.next; else // 刪除的不是頭結點 // p是刪除結點node的前驅結點，p的next改為記錄要刪除結點node的後繼結點 p.next = node.next; ++modCount; // 當前存儲鍵值對的數量 - 1 --size; afterNodeRemoval(node); // 返回刪除結點 return node; } } // 不存在要刪除的結點，則返回null return null; }</pre><ul><li>調用replace(K key, V value)操作根據鍵key查找對應的key-value鍵值對，隨後替換對應的值value，進行了如下操作：</li></ul><ol><li>先調用 hash(key)方法計算出 key 的 hash值</li><li>隨後調用getNode方法獲取對應key所映射的value值 。</li><li>記錄元素舊值，將新值賦值給元素，返回元素舊值，如果沒有找到元素，則返回null。</li></ol><p>示例代碼：</p><pre> /** * 替換指定 key 所映射的 value 值 * * @param key 對應要替換value值元素的key鍵 * @param value 要替換對應元素的新value值 * @return 返回原本的舊值，如果沒有找到key對應的元素，則返回null * @since 1.8 JDK1.8新增方法 */ public V replace(K key, V value) { Node&lt;K,V&gt; e; // 1.先調用 hash(key)方法計算出 key 的 hash值 // 2.隨後調用getNode方法獲取對應key所映射的value值 if ((e = getNode(hash(key), key)) != null) {// 如果找到對應的元素 // 元素舊值 V oldValue = e.value; // 將新值賦值給元素 e.value = value; afterNodeAccess(e); // 返回元素舊值 return oldValue; } // 沒有找到元素，則返回null return null; }</pre><p>3.</p><p>問 1：您上面說，存放一個元素時，先計算它的hash值確定它的存儲位置，然後再把這個元素放到對應的位置上，那萬一這個位置上面已經有元素存在呢，新增的這個元素怎麼辦？</p><p>問 2：hash衝突（或者叫hash碰撞）是什麼？為什麼會出現這種現象，如何解決hash衝突？</p><p>答：</p><ul><li>hash衝突： 當我們調用put(K key, V value)操作添加key-value鍵值對，這個key-value鍵值對存放在的位置是通過擾動函數(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)計算鍵key的hash值。隨後將 這個hash值 % 模上 哈希表Node&lt;K,V>[] table的長度 得到具體的存放位置。所以put(K key, V value)多個元素，是有可能計算出相同的存放位置。此現象就是hash衝突或者叫hash碰撞。</li><li>例子如下：</li><li>元素 A 的hash值 為 9，元素 B 的hash值 為 17。哈希表Node&lt;K,V>[] table的長度為8。則元素 A 的存放位置為9 % 8 = 1，元素 B 的存放位置為17 % 8 = 1。兩個元素的存放位置均為table[1]，發生了hash衝突。</li><li>hash衝突的避免：既然會發生hash衝突，我們就應該想辦法避免此現象的發生，解決這個問題最關鍵就是如果生成元素的hash值。Java是使用“擾動函數”生成元素的hash值。</li></ul><p>示例代碼：</p><p>/**</p><p>* JDK 7 的 hash方法</p><p>*/</p><p>final int hash(int h) {</p><p>h ^= k.hashCode();</p><p>h ^= (h >>> 20) ^ (h >>> 12);</p><p>return h ^ (h >>> 7) ^ (h >>> 4);</p><p>}</p><p>/**</p><p>* JDK 8 的 hash方法</p><p>*/</p><p>static final int hash(Object key) {</p><p>int h;</p><p>return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);</p><p>}</p><p>Java7做了4次16位右位移異或混合，Java 8中這步已經簡化了，只做一次16位右位移異或混合，而不是四次，但原理是不變的。例子如下：</p><div class=pgc-img><img alt=Java互聯網架構-P7架構師教你重新認識HashMap onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1e2dc0525fbd49c08fa88fc41eaac750><p class=pgc-img-caption></p></div><p>擾動函數執行例子 - 圖片來自於《知乎》</p><p>右位移16位，正好是32bit的一半，自己的高半區和低半區做異或，就是為了混合原始哈希碼的高位和低位，以此來加大低位的隨機性。而且混合後的低位摻雜了高位的部分特徵，這樣高位的信息也被變相保留下來。</p><p>上述擾動函數的解釋參考自：JDK 源碼中 HashMap 的 hash 方法原理是什麼？</p><ul><li>hash衝突解決：解決hash衝突的方法有很多，常見的有：開發定址法，</li><li>再散列法，鏈地址法，公共溢出區法（詳細說明請查看我的文章JAVA基礎-自問自答學hashCode和equals）。HashMap是使用鏈地址法解決hash衝突的，當有衝突元素放進來時，會將此元素插入至此位置鏈表的最後一位，形成單鏈表。但是由於是單鏈表的緣故，每當通過hash % length找到該位置的元素時，均需要從頭遍歷鏈表，通過逐一比較hash值，找到對應元素。如果此位置元素過多，造成鏈表過長，遍歷時間會大大增加，最壞情況下的時間複雜度為O(N)，造成查找效率過低。所以當存在位置的鏈表長度 大於等於 8 時，HashMap會將鏈表 轉變為 紅黑樹，紅黑樹最壞情況下的時間複雜度為O(logn)。以此提高查找效率。</li></ul><p>4.</p><p>問：HashMap的容量為什麼一定要是2的n次方？</p><p>答：</p><ul><li>因為調用put(K key, V value)操作添加key-value鍵值對時，具體確定此元素的位置是通過 hash值 % 模上 哈希表Node&lt;K,V>[] table的長度 hash % length 計算的。但是"模"運算的消耗相對較大，通過位運算h & (length-1)也可以得到取模後的存放位置，而位運算的運行效率高，但只有length的長度是2的n次方時，h & (length-1) 才等價於 h % length。</li><li>而且當數組長度為2的n次冪的時候，不同的key算出的index相同的機率較小，那麼數據在數組上分佈就比較均勻，也就是說碰撞的機率小，相對的，查詢的時候就不用遍歷某個位置上的鏈表，這樣查詢效率也就較高了。</li></ul><p>例子：</p><div class=pgc-img><img alt=Java互聯網架構-P7架構師教你重新認識HashMap onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/808a2cc831114efe8a7e48f67fbe2ca2><p class=pgc-img-caption></p></div><p>hash & (length-1)運算過程.jpg</p><ul><li>上圖中，左邊兩組的數組長度是16（2的4次方），右邊兩組的數組長度是15。兩組的hash值均為8和9。</li><li>當數組長度是15時，當它們和1110進行&與運算（相同為1，不同為0）時，計算的結果都是1000，所以他們都會存放在相同的位置table[8]中，這樣就發生了hash衝突，那麼查詢時就要遍歷鏈表，逐一比較hash值，降低了查詢的效率。</li><li>同時，我們可以發現，當數組長度為15的時候，hash值均會與14（1110）進行&與運算，那麼最後一位永遠是0，而0001，0011，0101，1001，1011，0111，1101這幾個位置永遠都不能存放元素了，空間浪費相當大，更糟的是這種情況中，數組可以使用的位置比數組長度小了很多，這意味著進一步增加了碰撞的機率，減慢了查詢的效率。</li><li>所以，HashMap的容量是2的n次方，有利於提高計算元素存放位置時的效率，也降低了hash衝突的機率。因此，我們使用HashMap存儲大量數據的時候，最好先預先指定容器的大小為2的n次方，即使我們不指定為2的n次方，HashMap也會把容器的大小設置成最接近設置數的2的n次方，如，設置HashMap的大小為 7 ，則HashMap會將容器大小設置成最接近7的一個2的n次方數，此值為 8 。</li></ul><p>上述回答參考自：深入理解HashMap</p><p>示例代碼：</p><pre> /** * 返回一個比指定數cap大的，並且大小是2的n次方的數 * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }</pre><p>5.</p><p>問：HashMap的負載因子是什麼，有什麼作用？</p><p>答：負載因子表示哈希表空間的使用程度（或者說是哈希表空間的利用率）。</p><ul><li>例子如下：</li><li>底層哈希表Node&lt;K,V>[] table的容量大小capacity為 16，負載因子load factor為 0.75，則當存儲的元素個數size = capacity 16 * load factor 0.75等於 12 時，則會觸發HashMap的擴容機制，調用resize()方法進行擴容。</li><li>當負載因子越大，則HashMap的裝載程度就越高。也就是能容納更多的元素，元素多了，發生hash碰撞的機率就會加大，從而鏈表就會拉長，此時的查詢效率就會降低。</li><li>當負載因子越小，則鏈表中的數據量就越稀疏，此時會對空間造成浪費，但是此時查詢效率高。</li><li>我們可以在創建HashMap 時根據實際需要適當地調整load factor 的值；如果程序比較關心空間開銷、內存比較緊張，可以適當地增加負載因子；如果程序比較關心時間開銷，內存比較寬裕則可以適當的減少負載因子。通常情況下，默認負載因子 (0.75) 在時間和空間成本上尋求一種折衷，程序員無需改變負載因子的值。</li><li>因此，如果我們在初始化HashMap時，就預估知道需要裝載key-value鍵值對的容量size，我們可以通過size / load factor 計算出我們需要初始化的容量大小initialCapacity，這樣就可以避免HashMap因為存放的元素達到閾值threshold而頻繁調用resize()方法進行擴容。從而保證了較好的性能。</li></ul><p>6.</p><p>問：您能說說HashMap和HashTable的區別嗎？</p><p>答：HashMap和HashTable有如下區別：</p><p>1）容器整體結構：</p><ul><li>HashMap的key和value都允許為null，HashMap遇到key為null的時候，調用putForNullKey方法進行處理，而對value沒有處理。</li><li>Hashtable的key和value都不允許為null。Hashtable遇到null，直接返回NullPointerException。</li></ul><p>2） 容量設定與擴容機制：</p><ul><li>HashMap默認初始化容量為 16，並且容器容量一定是2的n次方，擴容時，是以原容量 2倍 的方式 進行擴容。</li><li>Hashtable默認初始化容量為 11，擴容時，是以原容量 2倍 再加 1的方式進行擴容。即int newCapacity = (oldCapacity &lt;&lt; 1) + 1;。</li></ul><p>3） 散列分佈方式（計算存儲位置）：</p><ul><li>HashMap是先將key鍵的hashCode經過擾動函數擾動後得到hash值，然後再利用 hash & (length - 1)的方式代替取模，得到元素的存儲位置。</li><li>Hashtable則是除留餘數法進行計算存儲位置的（因為其默認容量也不是2的n次方。所以也無法用位運算替代模運算），int index = (hash & 0x7FFFFFFF) % tab.length;。</li><li>由於HashMap的容器容量一定是2的n次方，所以能使用hash & (length - 1)的方式代替取模的方式計算元素的位置提高運算效率，但Hashtable的容器容量不一定是2的n次方，所以不能使用此運算方式代替。</li></ul><p>4）線程安全（最重要）：</p><ul><li>HashMap 不是線程安全，如果想線程安全，可以通過調用synchronizedMap(Map&lt;K,V> m)使其線程安全。但是使用時的運行效率會下降，所以建議使用ConcurrentHashMap容器以此達到線程安全。</li><li>Hashtable則是線程安全的，每個操作方法前都有synchronized修飾使其同步，但運行效率也不高，所以還是建議使用ConcurrentHashMap容器以此達到線程安全。</li></ul><p>因此，Hashtable是一個遺留容器，如果我們不需要線程同步，則建議使用HashMap，如果需要線程同步，則建議使用ConcurrentHashMap。</p><p>此處不再對Hashtable的源碼進行逐一分析了，如果想深入瞭解的同學，可以參考此文章</p><p>Hashtable源碼剖析</p><p>7.</p><p>問：您說HashMap不是線程安全的，那如果多線程下，它是如何處理的？並且什麼情況下會發生線程不安全的情況？</p><p>答：</p><ul><li>HashMap不是線程安全的，如果多個線程同時對同一個HashMap更改數據的話，會導致數據不一致或者數據汙染。如果出現線程不安全的操作時，HashMap會儘可能的拋出ConcurrentModificationException防止數據異常，當我們在對一個HashMap進行遍歷時，在遍歷期間，我們是不能對HashMap進行添加，刪除等更改數據的操作的，否則也會拋出ConcurrentModificationException異常，此為fail-fast（快速失敗）機制。從源碼上分析，我們在put,remove等更改HashMap數據時，都會導致modCount的改變，當expectedModCount != modCount時，則拋出ConcurrentModificationException。如果想要線程安全，可以考慮使用ConcurrentHashMap。</li><li>而且，在多線程下操作HashMap，由於存在擴容機制，當HashMap調用resize()進行自動擴容時，可能會導致死循環的發生。</li></ul><p>由於時間關係，我暫不帶著大家一起去分析resize()方法導致死循環發生的現象造成原因了，遲點有空我會再補充上去，請見諒，大家可以參考如下文章：</p><p>Java 8系列之重新認識HashMap</p><p>談談HashMap線程不安全的體現</p><p>8.</p><p>問：我們在使用HashMap時，選取什麼對象作為key鍵比較好，為什麼？</p><p>答：</p><ul><li>可變對象：指創建後自身狀態能改變的對象。換句話說，可變對象是該對象在創建後它的哈希值可能被改變。</li><li>我們在使用HashMap時，最好選擇不可變對象作為key。例如String，Integer等不可變類型作為key是非常明智的。</li><li>如果key對象是可變的，那麼key的哈希值就可能改變。在HashMap中可變對象作為Key會造成數據丟失。因為我們再進行hash & (length - 1)取模運算計算位置查找對應元素時，位置可能已經發生改變，導致數據丟失。</li></ul><p>詳細例子說明請參考：危險！在HashMap中將可變對象用作Key</p><p>封面圖源網絡，侵權刪除）</p><p><strong>如有收穫，請幫忙轉發，您的鼓勵是作者最大的動力，謝謝！</strong></p><p><strong>一大波微服務、分佈式、高併發、高可用的原創系列文章正在路上,</strong></p><p><strong>歡迎關注頭條號：java小馬哥</strong></p><p><strong>週一至週日早九點半！下午三點半！精品技術文章準時送上！！！</strong></p><p><strong>十餘年BAT架構經驗傾囊相授</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>互聯</a></li><li><a>網架構</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbdef61f.html alt=Java互聯網架構-人情世故併發機制的底層實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/56890004e0cc27e42702 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbdef61f.html title=Java互聯網架構-人情世故併發機制的底層實現原理>Java互聯網架構-人情世故併發機制的底層實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>