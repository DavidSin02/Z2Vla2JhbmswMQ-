<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大道至簡：Java 代碼11個方面的精簡之道（示例品鑑） | 极客快訊</title><meta property="og:title" content="大道至簡：Java 代碼11個方面的精簡之道（示例品鑑） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/30747658a7ff4b3a8fc8989c80252571"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><meta property="article:published_time" content="2020-11-14T21:00:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:09+08:00"><meta name=Keywords content><meta name=description content="大道至簡：Java 代碼11個方面的精簡之道（示例品鑑）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/91b66dcd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大道至簡：Java 代碼11個方面的精簡之道（示例品鑑）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>作者： 常意(原名陳昌毅，地圖技術專家)</p><p>鏈接：https://mp.weixin.qq.com/s/A1Z8YZyqQsFqK1TA1dTl2Q</p></blockquote><h2 class=pgc-h-arrow-right><strong>前言</strong></h2><hr><p>古語有云：</p><blockquote><p>道為術之靈，術為道之體；以道統術，以術得道。</p></blockquote><p>其中：“道”指“規律、道理、理論”，“術”指“方法、技巧、技術”。意思是：“道”是“術”的靈魂，“術”是“道”的肉體；可以用“道”來統管“術”，也可以從“術”中獲得“道”。</p><p><br></p><p>在拜讀大佬“孤盡”的文章《Code Review是苦澀但有意思的修行》時，感受最深的一句話就是：“優質的代碼一定是少即是多的精兵原則”，這就是大佬的代碼精簡之“道”。</p><p><br></p><p>工匠追求“術”到極致，其實就是在尋“道”，且離悟“道”也就不遠了，亦或是已經得道，這就是“工匠精神”——一種追求“以術得道”的精神。如果一個工匠只滿足於“術”，不能追求“術”到極致去悟“道”，那只是一個靠“術”養家餬口的工匠而已。作者根據多年來的實踐探索，總結了大量的 Java 代碼精簡之“術”，試圖闡述出心中的 Java 代碼精簡之“道”。</p><p><br></p><div class=pgc-img><img alt="大道至簡：Java 代碼11個方面的精簡之道（示例品鑑）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/30747658a7ff4b3a8fc8989c80252571><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><strong>1.利用語法</strong></h2><hr><h3 class=pgc-h-arrow-right><strong>1.1.利用三元表達式</strong></h3><p><strong>普通：</strong></p><pre><code>String title;if (isMember(phone)) {  title = "會員";} else {   title = "遊客";}</code></pre><p><strong>精簡：</strong></p><pre><code>String title = isMember(phone) ? "會員" : "遊客";</code></pre><p>注意：對於包裝類型的算術計算，需要注意避免拆包時的空指針問題。</p><h3 class=pgc-h-arrow-right><strong>1.2.利用 for-each 語句</strong></h3><p>從 Java 5 起，提供了 for-each 循環，簡化了數組和集合的循環遍歷。 for-each 循環允許你無需保持傳統 for 循環中的索引就可以遍歷數組，或在使用迭代器時無需在 while 循環中調用 hasNext 方法和 next 方法就可以遍歷集合。</p><p><strong>普通：</strong></p><pre><code>double[] values = ...;for(int i = 0; i &lt; values.length; i++) {  double value = values[i];  // TODO: 處理value}List&lt;Double&gt; valueList = ...;Iterator&lt;Double&gt; iterator = valueList.iterator();while (iterator.hasNext()) {  Double value = iterator.next();   // TODO: 處理value}</code></pre><p><strong>精簡：</strong></p><pre><code>double[] values = ...;for(double value : values) {  // TODO: 處理value}List&lt;Double&gt; valueList = ...;for(Double value : valueList) {  // TODO: 處理value}</code></pre><h3 class=pgc-h-arrow-right><strong>1.3.利用 try-with-resource 語句</strong></h3><p>所有實現 Closeable 接口的“資源”，均可採用 try-with-resource 進行簡化。</p><p><strong>普通：</strong></p><pre><code>BufferedReader reader = null;try {  reader = new BufferedReader(new FileReader("cities.csv"));   String line;  while ((line = reader.readLine()) != null) {    // TODO: 處理line   }} catch (IOException e) {  log.error("讀取文件異常", e);} finally {   if (reader != null) {     try {      reader.close();    } catch (IOException e) {      log.error("關閉文件異常", e);    }  }}</code></pre><p><strong>精簡：</strong></p><pre><code>try (BufferedReader reader = new BufferedReader(new FileReader("test.txt"))) {  String line;  while ((line = reader.readLine()) != null) {    // TODO: 處理line  }} catch (IOException e) {  log.error("讀取文件異常", e);}</code></pre><h3 class=pgc-h-arrow-right><strong>1.4.利用 return 關鍵字</strong></h3><p>利用 return 關鍵字，可以提前函數返回，避免定義中間變量。</p><p><strong>普通：</strong></p><pre><code>public static boolean hasSuper(@NonNull List&lt;UserDO&gt; userList) {  boolean hasSuper = false;   for (UserDO user : userList) {    if (Boolean.TRUE.equals(user.getIsSuper())) {      hasSuper = true;       break;    }  }   return hasSuper;}</code></pre><p><strong>精簡：</strong></p><pre><code>public static boolean hasSuper(@NonNull List&lt;UserDO&gt; userList) {  for (UserDO user : userList) {    if (Boolean.TRUE.equals(user.getIsSuper())) {      return true;     }    }    return false;}</code></pre><h3 class=pgc-h-arrow-right><strong>1.5.利用 static 關鍵字</strong></h3><p>利用 static 關鍵字，可以把字段變成靜態字段，也可以把函數變為靜態函數，調用時就無需初始化類對象。</p><p><strong>普通：</strong></p><pre><code>public final class GisHelper {   public double distance(double lng1, double lat1, double lng2, double lat2) {    // 方法實現代碼   }}GisHelper gisHelper = new GisHelper();double distance = gisHelper.distance(116.178692D, 39.967115D, 116.410778D, 39.899721D);</code></pre><p><strong>精簡：</strong></p><pre><code>public final class GisHelper {  public static double distance(double lng1, double lat1, double lng2, double lat2) {    // 方法實現代碼  }}double distance = GisHelper.distance(116.178692D, 39.967115D, 116.410778D, 39.899721D);</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>1.6.利用 lambda 表達式</strong></h3><p>Java 8 發佈以後，lambda 表達式大量替代匿名內部類的使用，在簡化了代碼的同時，更突出了原有匿名內部類中真正有用的那部分代碼。</p><p><strong>普通：</strong></p><pre><code>new Thread(new Runnable() {            public void run() {  // 線程處理代碼}}).start();</code></pre><p><strong>精簡：</strong></p><pre><code>new Thread(() -&gt; {   // 線程處理代碼}).start();</code></pre><h3 class=pgc-h-arrow-right><strong>1.7.利用方法引用</strong></h3><p>方法引用（::），可以簡化 lambda 表達式，省略變量聲明和函數調用。</p><p><strong>普通：</strong></p><pre><code>Arrays.sort(nameArray, (a, b) -&gt; a.compareToIgnoreCase(b));List&lt;Long&gt; userIdList = userList.stream()  .map(user -&gt; user.getId())   .collect(Collectors.toList());</code></pre><p><br><strong>精簡：</strong></p><pre><code>Arrays.sort(nameArray, String::compareToIgnoreCase);List&lt;Long&gt; userIdList = userList.stream()  .map(UserDO::getId)  .collect(Collectors.toList());</code></pre><p><br></p><h3 class=pgc-h-arrow-right><strong>1.8.利用靜態導入</strong></h3><p>靜態導入（import static），當程序中大量使用同一靜態常量和函數時，可以簡化靜態常量和函數的引用。</p><p><strong>普通：</strong></p><pre><code>List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; Math.PI * Math.pow(r, 2)).collect(Collectors.toList());...</code></pre><p><strong>精簡：</strong></p><pre><code>import static java.lang.Math.PI;import static java.lang.Math.pow;import static java.util.stream.Collectors.toList;List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; PI * pow(r, 2)).collect(toList());...</code></pre><p>注意：靜態引入容易造成代碼閱讀困難，所以在實際項目中應該警慎使用。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>1.9.利用 unchecked 異常</strong></h3><p>Java 的異常分為兩類：Checked 異常和 Unchecked 異常。Unchecked 異常繼承了RuntimeException ，特點是代碼不需要處理它們也能通過編譯，所以它們稱作 Unchecked 異常。利用 Unchecked 異常，可以避免不必要的 try-catch 和 throws 異常處理。</p><p><br></p><p><strong>普通：</strong></p><pre><code>@Servicepublic class UserService {  public void createUser(UserCreateVO create, OpUserVO user) throws BusinessException {    checkOperatorUser(user);     ...  }    private void checkOperatorUser(OpUserVO user) throws BusinessException {      if (!hasPermission(user)) {         throw new BusinessException("用戶無操作權限");       }       ...      }      ...    }           @RestController      @RequestMapping("/user")      public class UserController {         @Autowired    private UserService userService;                @PostMapping("/createUser")         public Result&lt;Void&gt; createUser(@RequestBody @Valid UserCreateVO create, OpUserVO user) throws BusinessException {          userService.createUser(create, user);          return Result.success();        }       ...    }</code></pre><p><strong>精簡：</strong></p><pre><code>@Servicepublic class UserService {   public void createUser(UserCreateVO create, OpUserVO user) {    checkOperatorUser(user);     ...  }    private void checkOperatorUser(OpUserVO user) {      if (!hasPermission(user)) {        throw new BusinessRuntimeException("用戶無操作權限");      }       ...     }         ... }              @RestController@RequestMapping("/user")      public class UserController {         @Autowired        private UserService userService;         @PostMapping("/createUser")         public Result&lt;Void&gt; createUser(@RequestBody @Valid UserCreateVO create, OpUserVO user) {          userService.createUser(create, user);          return Result.success();        }      ...    }</code></pre><p><br></p><h2 class=pgc-h-arrow-right><strong>2.利用註解</strong></h2><hr><p><strong>2.1.利用 Lombok 註解</strong></p><p>Lombok 提供了一組有用的註解，可以用來消除Java類中的大量樣板代碼。</p><p><strong>普通：</strong></p><pre><code>public class UserVO {  private Long id;  private String name;  public Long getId() {     return this.id;   }  public void setId(Long id) {    this.id = id;  }   public String getName() {     return this.name;   }  public void setName(String name) {     this.name = name;   }   ...}</code></pre><p><strong>精簡：</strong></p><pre><code>@Getter@Setter@ToStringpublic class UserVO {  private Long id;  private String name;   ...}</code></pre><h3 class=pgc-h-arrow-right><strong>2.2.利用 Validation 註解</strong></h3><p><strong>普通：</strong></p><pre><code>  @Getter@Setter@ToStringpublic class UserCreateVO {  @NotBlank(message = "用戶名稱不能為空")  private String name;   @NotNull(message = "公司標識不能為空")  private Long companyId;   ...}@Service@Validatedpublicclass UserService {  public Long createUser(@Valid UserCreateVO create) {    // TODO: 創建用戶    return null;  }}</code></pre><p><strong>精簡：</strong></p><pre><code>@Getter@Setter@ToStringpublic class UserCreateVO {  @NotBlank(message = "用戶名稱不能為空")  private String name;   @NotNull(message = "公司標識不能為空")  private Long companyId;   ...}@Service@Validatedpublic class UserService {    public Long createUser(@Valid UserCreateVO create) {        // TODO: 創建用戶        return null;    }}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>2.3.利用 @NonNull 註解</strong></h3><p><br></p><p>Spring 的 @NonNull 註解，用於標註參數或返回值非空，適用於項目內部團隊協作。只要實現方和調用方遵循規範，可以避免不必要的空值判斷，這充分體現了阿里的“新六脈神劍”提倡的“因為信任，所以簡單”。</p><p><strong>普通：</strong></p><pre><code>public List&lt;UserVO&gt; queryCompanyUser(Long companyId) {  // 檢查公司標識  if (companyId == null) {    return null;  }   // 查詢返回用戶  List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);   return userList.stream().map(this::transUser).collect(Collectors.toList());}Long companyId = 1L;List&lt;UserVO&gt; userList = queryCompanyUser(companyId);if (CollectionUtils.isNotEmpty(userList)) {  for (UserVO user : userList) {    // TODO: 處理公司用戶  }}</code></pre><p><strong>精簡：</strong></p><pre><code>public @NonNull List&lt;UserVO&gt; queryCompanyUser(@NonNull Long companyId) {  List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);  return userList.stream().map(this::transUser).collect(Collectors.toList());}Long companyId = 1L;List&lt;UserVO&gt; userList = queryCompanyUser(companyId);for (UserVO user : userList) {  // TODO: 處理公司用戶}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>2.4.利用註解特性</strong></h3><p>註解有以下特性可用於精簡註解聲明：</p><p>1、當註解屬性值跟默認值一致時，可以刪除該屬性賦值；</p><p>2、當註解只有value屬性時，可以去掉value進行簡寫；</p><p>3、當註解屬性組合等於另一個特定註解時，直接採用該特定註解。</p><p><br></p><p><strong>普通：</strong></p><pre><code>@Lazy(true);@Service(value = "userService")@RequestMapping(path = "/getUser", method = RequestMethod.GET)</code></pre><pre><code></code></pre><p><strong>精簡：</strong></p><pre><code>@Lazy@Service("userService")@GetMapping("/getUser")</code></pre><h2 class=pgc-h-arrow-right><strong>3.利用泛型</strong></h2><hr><p><strong>3.1.泛型接口</strong></p><p>在 Java 沒有引入泛型前，都是採用 Object 表示通用對象，最大的問題就是類型無法強校驗並且需要強制類型轉換。</p><p><strong>普通：</strong></p><pre><code>public interface Comparable {  public int compareTo(Object other);}@Getter@Setter@ToStringpublic class UserVO implements Comparable {  private Long id;   @Override    public int compareTo(Object other) {    UserVO user = (UserVO)other;    return Long.compare(this.id, user.id);  }}</code></pre><p><strong>精簡：</strong></p><pre><code>public interface Comparable&lt;T&gt; {  public int compareTo(T other);}@Getter@Setter@ToStringpublic class UserVO implements Comparable&lt;UserVO&gt; {  private Long id;  @Override  public int compareTo(UserVO other) {    return Long.compare(this.id, other.id);  }}</code></pre><p><br></p><h3 class=pgc-h-arrow-right><strong>3.2.泛型類</strong></h3><p><strong>普通：</strong></p><pre><code>@Getter@Setter@ToStringpublic class IntPoint {  private Integer x;  private Integer y;}@Getter@Setter@ToStringpublic class DoublePoint {  private Double x;  private Double y;}</code></pre><p><strong>精簡：</strong></p><pre><code>@Getter@Setter@ToStringpublic class Point&lt;T extends Number&gt; {  private T x;  private T y;}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>3.3.泛型方法</strong></h3><p><strong>普通：</strong></p><pre><code>public static Map&lt;String, Integer&gt; newHashMap(String[] keys, Integer[] values) {  // 檢查參數非空   if (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {    return Collections.emptyMap();   }     // 轉化哈希映射   Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();   int length = Math.min(keys.length, values.length);   for (int i = 0; i &lt; length; i++) {     map.put(keys[i], values[i]);  }  return map;}...</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>public static &lt;K, V&gt; Map&lt;K, V&gt; newHashMap(K[] keys, V[] values) {   // 檢查參數非空   if (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {    return Collections.emptyMap();  }     // 轉化哈希映射  Map&lt;K, V&gt; map = new HashMap&lt;&gt;();  int length = Math.min(keys.length, values.length);   for (int i = 0; i &lt; length; i++) {    map.put(keys[i], values[i]);  }   return map;}</code></pre><h2 class=pgc-h-arrow-right><strong>4.利用自身方法</strong></h2><hr><p><strong>4.1.利用構造方法</strong></p><p>構造方法，可以簡化對象的初始化和設置屬性操作。對於屬性字段較少的類，可以自定義構造方法。</p><p><strong>普通：</strong></p><pre><code>@Getter@Setter@ToStringpublic class PageDataVO&lt;T&gt; {  private Long totalCount;  private List&lt;T&gt; dataList;}PageDataVO&lt;UserVO&gt; pageData = new PageDataVO&lt;&gt;();pageData.setTotalCount(totalCount);pageData.setDataList(userList);return pageData;</code></pre><p><strong>精簡：</strong></p><pre><code>@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class PageDataVO&lt;T&gt; {  private Long totalCount;  private List&lt;T&gt; dataList;}return new PageDataVO&lt;&gt;(totalCount, userList);</code></pre><p>注意：如果屬性字段被替換時，存在構造函數初始化賦值問題。比如把屬性字段title替換為 nickname ，由於構造函數的參數個數和類型不變，原有構造函數初始化語句不會報錯，導致把原title值賦值給 nickname 。如果採用 Setter 方法賦值，編譯器會提示錯誤並要求修復。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>4.2.利用 Set 的 add 方法</strong></h3><p>利用 Set 的 add 方法的返回值，可以直接知道該值是否已經存在，可以避免調用 contains 方法判斷存在。</p><p><strong>普通：</strong></p><p>以下案例是進行用戶去重轉化操作，需要先調用 contains 方法判斷存在，後調用add方法進行添加。</p><pre><code>Set&lt;Long&gt; userIdSet = new HashSet&lt;&gt;();List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;();for (UserDO userDO : userDOList) {   if (!userIdSet.contains(userDO.getId())) {    userIdSet.add(userDO.getId());    userVOList.add(transUser(userDO));  }}</code></pre><p><strong>精簡：</strong></p><pre><code>SSet&lt;Long&gt; userIdSet = new HashSet&lt;&gt;();List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;();for (UserDO userDO : userDOList) {  if (userIdSet.add(userDO.getId())) {    userVOList.add(transUser(userDO));  }}</code></pre><h3 class=pgc-h-arrow-right><strong>4.3.利用 Map 的 computeIfAbsent 方法</strong></h3><p>利用 Map 的 computeIfAbsent 方法，可以保證獲取到的對象非空，從而避免了不必要的空判斷和重新設置值。</p><p><strong>普通：</strong></p><pre><code>Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = new HashMap&lt;&gt;();for (UserDO userDO : userDOList) {  Long roleId = userDO.getRoleId();  List&lt;UserDO&gt; userList = roleUserMap.get(roleId);  if (Objects.isNull(userList)) {     userList = new ArrayList&lt;&gt;();    roleUserMap.put(roleId, userList);  }   userList.add(userDO);}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = new HashMap&lt;&gt;();for (UserDO userDO : userDOList) {   roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; new ArrayList&lt;&gt;())    .add(userDO);}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>4.4.利用鏈式編程</strong></h3><p>鏈式編程，也叫級聯式編程，調用對象的函數時返回一個this對象指向對象本身，達到鏈式效果，可以級聯調用。鏈式編程的優點是：編程性強、可讀性強、代碼簡潔。</p><p><strong>普通：</strong></p><pre><code>StringBuilder builder = new StringBuilder(96);builder.append("select id, name from ");builder.append(T_USER);builder.append(" where id = ");builder.append(userId);builder.append(";");</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>StringBuilder builder = new StringBuilder(96);builder.append("select id, name from ")  .append(T_USER)  .append(" where id = ")  .append(userId)  .append(";");</code></pre><h2 class=pgc-h-arrow-right><strong>5.利用工具方法</strong></h2><hr><p><strong>5.1.避免空值判斷</strong></p><p><br></p><p><strong>普通：</strong></p><pre><code>if (userList != null &amp;&amp; !userList.isEmpty()) {  // TODO: 處理代碼}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>if (CollectionUtils.isNotEmpty(userList)) {    // TODO: 處理代碼}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>5.2.避免條件判斷</strong></h3><p><strong>普通：</strong></p><pre><code>double result;if (value &lt;= MIN_LIMIT) {  result = MIN_LIMIT;} else {  result = value;}</code></pre><p><strong>精簡：</strong></p><pre><code>double result = Math.max(MIN_LIMIT, value);</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>5.3.簡化賦值語句</strong></h3><p><strong>普通：</strong></p><pre><code>public static final List&lt;String&gt; ANIMAL_LIST;static {  List&lt;String&gt; animalList = new ArrayList&lt;&gt;();  animalList.add("dog");  animalList.add("cat");  animalList.add("tiger");  ANIMAL_LIST = Collections.unmodifiableList(animalList);}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>// JDK流派public static final List&lt;String&gt; ANIMAL_LIST = Arrays.asList("dog", "cat", "tiger");// Guava流派public static final List&lt;String&gt; ANIMAL_LIST = ImmutableList.of("dog", "cat", "tiger");</code></pre><p>注意：Arrays.asList 返回的 List 並不是 ArrayList ，不支持 add 等變更操作。</p><h3 class=pgc-h-arrow-right><strong>5.4.簡化數據拷貝</strong></h3><p><strong>普通：</strong></p><pre><code>UserVO userVO = new UserVO();userVO.setId(userDO.getId());userVO.setName(userDO.getName());...userVO.setDescription(userDO.getDescription());userVOList.add(userVO);</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>UserVO userVO = new UserVO();BeanUtils.copyProperties(userDO, userVO);userVOList.add(userVO);</code></pre><p><br></p><p><strong>反例：</strong></p><pre><code>List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO.class);</code></pre><p>精簡代碼，但不能以過大的性能損失為代價。例子是淺層拷貝，用不著 JSON 這樣重量級的武器。</p><p><br></p><h2 class=pgc-h-arrow-right>5.5.簡化異常斷言</h2><p><br></p><p><strong>普通：</strong></p><pre><code>if (Objects.isNull(userId)) {    throw new IllegalArgumentException("用戶標識不能為空");}</code></pre><p><strong>精簡：</strong></p><pre><code>Assert.notNull(userId, "用戶標識不能為空");</code></pre><p>注意：可能有些插件不認同這種判斷，導致使用該對象時會有空指針警告。</p><h3 class=pgc-h-arrow-right><strong>5.6.簡化測試用例</strong></h3><p>把測試用例數據以 JSON 格式存入文件中，通過 JSON 的 parseObject 和 parseArray 方法解析成對象。雖然執行效率上有所下降，但可以減少大量的賦值語句，從而精簡了測試代碼。</p><p><strong>普通：</strong></p><pre><code>@Testpublic void testCreateUser() {  UserCreateVO userCreate = new UserCreateVO();   userCreate.setName("Changyi");  userCreate.setTitle("Developer");  userCreate.setCompany("AMAP");   ...      Long userId  = userService.createUser(OPERATOR, userCreate);   Assert.assertNotNull(userId, "創建用戶失敗");}</code></pre><p><br><strong>精簡：</strong></p><pre><code>@Testpublic void testCreateUser() {  String jsonText = ResourceHelper.getResourceAsString(getClass(), "createUser.json");   UserCreateVO userCreate = JSON.parseObject(jsonText, UserCreateVO.class);   Long userId  = userService.createUser(OPERATOR, userCreate);  Assert.assertNotNull(userId, "創建用戶失敗");}</code></pre><p>建議：JSON 文件名最好以被測試的方法命名，如果有多個版本可以用數字後綴表示。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>5.7.簡化算法實現</strong></h3><p>一些常規算法，已有現成的工具方法，我們就沒有必要自己實現了。</p><p><strong>普通：</strong></p><pre><code>int totalSize = valueList.size();List&lt;List&lt;Integer&gt;&gt; partitionList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; totalSize; i += PARTITION_SIZE) {  partitionList.add(valueList.subList(i, Math.min(i + PARTITION_SIZE, totalSize)));}</code></pre><p><strong>精簡：</strong></p><pre><code>List&lt;List&lt;Integer&gt;&gt; partitionList = ListUtils.partition(valueList, PARTITION_SIZE);</code></pre><p><br></p><h2 class=pgc-h-arrow-right>5.8.封裝工具方法</h2><p><br></p><p>一些特殊算法，沒有現成的工具方法，我們就只好自己親自實現了。</p><p><strong>普通：</strong></p><p>比如，SQL 設置參數值的方法就比較難用，setLong 方法不能設置參數值為 null 。</p><pre><code> // 設置參數值if (Objects.nonNull(user.getId())) {  statement.setLong(1, user.getId());} else {  statement.setNull(1, Types.BIGINT);}...</code></pre><p><br></p><p><strong>精簡：</strong></p><p>我們可以封裝為一個工具類 SqlHelper ，簡化設置參數值的代碼。</p><pre><code>/** SQL輔助類 */public final class SqlHelper {    /** 設置長整數值 */    public static void setLong(PreparedStatement statement, int index, Long value) throws SQLException {        if (Objects.nonNull(value)) {            statement.setLong(index, value.longValue());        } else {            statement.setNull(index, Types.BIGINT);        }    }    ...} // 設置參數值SqlHelper.setLong(statement, 1, user.getId());</code></pre><p><br></p><h2 class=pgc-h-arrow-right><strong>6.利用數據結構</strong></h2><hr><p><strong>6.1.利用數組簡化</strong></p><p>對於固定上下限範圍的 if-else 語句，可以用數組+循環來簡化。</p><p><strong>普通：</strong></p><pre><code>public static int getGrade(double score) {  if (score &gt;= 90.0D) {    return 1;  }  if (score &gt;= 80.0D) {    return 2;  }   if (score &gt;= 60.0D) {    return 3;   }  if (score &gt;= 30.0D) {    return 4;  }  return 5;}</code></pre><p><strong>精簡：</strong></p><pre><code>private static final double[] SCORE_RANGES = new double[] {90.0D, 80.0D, 60.0D, 30.0D};public static int getGrade(double score) {  for (int i = 0; i &lt; SCORE_RANGES.length; i++) {    if (score &gt;= SCORE_RANGES[i]) {      return i + 1;     }   }  return SCORE_RANGES.length + 1;}</code></pre><p><br></p><p>思考：上面的案例返回值是遞增的，所以用數組簡化是沒有問題的。但是，如果返回值不是遞增的，能否用數組進行簡化呢？答案是可以的，請自行思考解決。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>6.2.利用 Map 簡化</strong></h3><p>對於映射關係的 if-else 語句，可以用Map來簡化。此外，此規則同樣適用於簡化映射關係的 switch 語句。</p><p><strong>普通：</strong></p><pre><code>public static String getBiologyClass(String name) {  switch (name) {    case "dog" :       return "animal";     case "cat" :        return "animal";      case "lavender" :       return "plant";       ...       default :       return null;  }}</code></pre><p><br><strong>精簡：</strong></p><pre><code>private static final Map&lt;String, String&gt; BIOLOGY_CLASS_MAP  = ImmutableMap.&lt;String, String&gt;builder()   .put("dog", "animal")  .put("cat", "animal")  .put("lavender", "plant")   ...     .build();public static String getBiologyClass(String name) {  return BIOLOGY_CLASS_MAP.get(name);}</code></pre><p>已經把方法簡化為一行代碼，其實都沒有封裝方法的必要了。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>6.3.利用容器類簡化</strong></h3><p>Java 不像 Python 和 Go ，方法不支持返回多個對象。如果需要返回多個對象，就必須自定義類，或者利用容器類。常見的容器類有 Apache 的 Pair 類和 Triple 類， Pair 類支持返回 2 個對象， Triple 類支持返回 3 個對象。</p><p><strong>普通：</strong></p><pre><code>@Setter@Getter@ToString@AllArgsConstructorpublic static class PointAndDistance {  private Point point;  private Double distance;}public static PointAndDistance getNearest(Point point, Point[] points) {  // 計算最近點和距離  ...    // 返回最近點和距離  return new PointAndDistance(nearestPoint, nearestDistance);}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>public static Pair&lt;Point, Double&gt; getNearest(Point point, Point[] points) {  // 計算最近點和距離  ...   // 返回最近點和距離  return ImmutablePair.of(nearestPoint, nearestDistance);}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>6.4.利用 ThreadLocal 簡化</strong></h3><p>ThreadLocal 提供了線程專有對象，可以在整個線程生命週期中隨時取用，極大地方便了一些邏輯的實現。用 ThreadLocal 保存線程上下文對象，可以避免不必要的參數傳遞。</p><p><strong>普通：</strong></p><p>由於 DateFormat 的 format 方法線程非安全（建議使用替代方法），在線程中頻繁初始化 DateFormat 性能太低，如果考慮重用只能用參數傳入 DateFormat 。例子如下：</p><pre><code>public static String formatDate(Date date, DateFormat format) {  return format.format(date);}public static List&lt;String&gt; getDateList(Date minDate, Date maxDate, DateFormat format) {  List&lt;String&gt; dateList = new ArrayList&lt;&gt;();  Calendar calendar = Calendar.getInstance();  calendar.setTime(minDate);  String currDate = formatDate(calendar.getTime(), format);  String maxsDate = formatDate(maxDate, format);  while (currDate.compareTo(maxsDate) &lt;= 0) {    dateList.add(currDate);    calendar.add(Calendar.DATE, 1);    currDate = formatDate(calendar.getTime(), format);   }  return dateList;}</code></pre><p><br><strong>精簡：</strong></p><p>可能你會覺得以下的代碼量反而多了，如果調用工具方法的地方比較多，就可以省下一大堆 DateFormat 初始化和傳入參數的代碼。</p><pre><code>private static final ThreadLocal&lt;DateFormat&gt; LOCAL_DATE_FORMAT = new ThreadLocal&lt;DateFormat&gt;() {  @Override  protected DateFormat initialValue() {     return new SimpleDateFormat("yyyyMMdd");  }};public static String formatDate(Date date) {    return LOCAL_DATE_FORMAT.get().format(date);}public static List&lt;String&gt; getDateList(Date minDate, Date maxDate) {    List&lt;String&gt; dateList = new ArrayList&lt;&gt;();    Calendar calendar = Calendar.getInstance();    calendar.setTime(minDate);    String currDate = formatDate(calendar.getTime());    String maxsDate = formatDate(maxDate);    while (currDate.compareTo(maxsDate) &lt;= 0) {        dateList.add(currDate);        calendar.add(Calendar.DATE, 1);        currDate = formatDate(calendar.getTime());    }    return dateList;}</code></pre><p>注意：ThreadLocal 有一定的內存洩露的風險，儘量在業務代碼結束前調用 remove 方法進行數據清除。</p><p><br></p><h2 class=pgc-h-arrow-right><strong>7.利用 Optional</strong></h2><hr><p>在 Java 8 裡，引入了一個 Optional 類，該類是一個可以為 null 的容器對象。</p><h3 class=pgc-h-arrow-right><strong>7.1.保證值存在</strong></h3><p><br></p><p><strong>普通：</strong></p><pre><code>Integer thisValue;if (Objects.nonNull(value)) {  thisValue = value;} else {  thisValue = DEFAULT_VALUE;}</code></pre><p><strong>精簡：</strong></p><pre><code>Integer thisValue = Optional.ofNullable(value).orElse(DEFAULT_VALUE);</code></pre><p><br></p><h3 class=pgc-h-arrow-right><strong>7.2.保證值合法</strong></h3><p><strong>普通：</strong></p><pre><code>Integer thisValue;if (Objects.nonNull(value) &amp;&amp; value.compareTo(MAX_VALUE) &lt;= 0) {  thisValue = value;} else {  thisValue = MAX_VALUE;}</code></pre><p><br><strong>精簡：</strong></p><pre><code>Integer thisValue = Optional.ofNullable(value)  .filter(tempValue -&gt; tempValue.compareTo(MAX_VALUE) &lt;= 0).orElse(MAX_VALUE);</code></pre><p>7.3.避免空判斷</p><p><strong>普通：</strong></p><pre><code>String zipcode = null;if (Objects.nonNull(user)) {  Address address = user.getAddress();  if (Objects.nonNull(address)) {    Country country = address.getCountry();    if (Objects.nonNull(country)) {      zipcode = country.getZipcode();     }  }}</code></pre><p><br><strong>精簡：</strong></p><pre><code>tring zipcode = Optional.ofNullable(user).map(User::getAddress)  .map(Address::getCountry).map(Country::getZipcode).orElse(null);</code></pre><h2 class=pgc-h-arrow-right><strong>8.利用 Stream</strong></h2><hr><p>流（Stream）是Java 8的新成員，允許你以聲明式處理數據集合，可以看成為一個遍歷數據集的高級迭代器。流主要有三部分構成：獲取一個數據源→數據轉換→執行操作獲取想要的結果。每次轉換原有 Stream 對象不改變，返回一個新的 Stream 對象，這就允許對其操作可以像鏈條一樣排列，形成了一個管道。流（Stream）提供的功能非常有用，主要包括匹配、過濾、彙總、轉化、分組、分組彙總等功能。</p><h3 class=pgc-h-arrow-right><strong>8.1.匹配集合數據</strong></h3><p><strong>普通：</strong></p><pre><code>boolean isFound = false;for (UserDO user : userList) {   if (Objects.equals(user.getId(), userId)) {    isFound = true;    break;  }}</code></pre><p><strong>精簡：</strong></p><pre><code>boolean isFound = userList.stream()  .anyMatch(user -&gt; Objects.equals(user.getId(), userId));</code></pre><h2 class=pgc-h-arrow-right><br>8.2.過濾集合數據</h2><p><strong>普通：</strong></p><pre><code>List&lt;UserDO&gt; resultList = new ArrayList&lt;&gt;();for (UserDO user : userList) {  if (Boolean.TRUE.equals(user.getIsSuper())) {    resultList.add(user);  }}</code></pre><p><br><strong>精簡：</strong></p><pre><code>List&lt;UserDO&gt; resultList = userList.stream()   .filter(user -&gt; Boolean.TRUE.equals(user.getIsSuper()))  .collect(Collectors.toList());</code></pre><h2 class=pgc-h-arrow-right><br>8.3.彙總集合數據</h2><p><strong>普通：</strong></p><pre><code>double total = 0.0D;for (Account account : accountList) {  total += account.getBalance();}</code></pre><p><br><strong>精簡：</strong></p><pre><code>double total = accountList.stream().mapToDouble(Account::getBalance).sum();</code></pre><p><br></p><h2 class=pgc-h-arrow-right>8.4.轉化集合數據</h2><p><br></p><p><strong>普通：</strong></p><pre><code>List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;();for (UserDO userDO : userDOList) {  userVOList.add(transUser(userDO));}</code></pre><p><br><strong>精簡：</strong></p><pre><code>List&lt;UserVO&gt; userVOList = userDOList.stream()  .map(this::transUser).collect(Collectors.toList());</code></pre><h3 class=pgc-h-arrow-right><strong>8.5.分組集合數據</strong></h3><p><strong>普通：</strong></p><pre><code>Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = new HashMap&lt;&gt;();for (UserDO userDO : userDOList) {  roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; new ArrayList&lt;&gt;())    .add(userDO);}</code></pre><p><br><strong>精簡：</strong></p><p>Map&lt;Long, List&lt;UserDO>> roleUserMap = userDOList.stream()<br>.collect(Collectors.groupingBy(UserDO::getRoleId));</p><h2 class=pgc-h-arrow-right><br>8.6.分組彙總集合</h2><p><strong>普通：</strong></p><pre><code>Map&lt;Long, Double&gt; roleTotalMap = new HashMap&lt;&gt;();for (Account account : accountList) {  Long roleId = account.getRoleId();   Double total = Optional.ofNullable(roleTotalMap.get(roleId)).orElse(0.0D);  roleTotalMap.put(roleId, total + account.getBalance());}</code></pre><p><br><strong>精簡：</strong></p><pre><code>roleTotalMap = accountList.stream()  .collect(Collectors.groupingBy(Account::getRoleId, Collectors.summingDouble(Account::getBalance)));</code></pre><p><br></p><h2 class=pgc-h-arrow-right>8.7.生成範圍集合</h2><p><br></p><p>Python 的 range 非常方便，Stream 也提供了類似的方法。</p><p><strong>普通：</strong></p><pre><code>int[] array1 = new int[N];for (int i = 0; i &lt; N; i++) {  array1[i] = i + 1;}int[] array2 = new int[N];array2[0] = 1;for (int i = 1; i &lt; N; i++) {  array2[i] = array2[i - 1] * 2;}</code></pre><p><br><strong>精簡：</strong></p><pre><code>int[] array1 = IntStream.rangeClosed(1, N).toArray();int[] array2 = IntStream.iterate(1, n -&gt; n * 2).limit(N).toArray();</code></pre><h2 class=pgc-h-arrow-right><strong>9.利用程序結構</strong></h2><hr><h3 class=pgc-h-arrow-right><strong>9.1.返回條件表達式</strong></h3><p>條件表達式判斷返回布爾值，條件表達式本身就是結果。</p><p><strong>普通：</strong></p><pre><code>public boolean isSuper(Long userId)    UserDO user = userDAO.get(userId);if (Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper())) {  return true; } return false;}</code></pre><p><br><strong>精簡：</strong></p><pre><code>public boolean isSuper(Long userId){  UserDO user = userDAO.get(userId);   return Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper());}</code></pre><h2 class=pgc-h-arrow-right><br>9.2.最小化條件作用域</h2><p>最小化條件作用域，儘量提出公共處理代碼。</p><p><strong>普通：</strong></p><pre><code>Result result = summaryService.reportWorkDaily(workDaily);if (result.isSuccess()) {  String message = "上報工作日報成功";   dingtalkService.sendMessage(user.getPhone(), message);} else {  String message = "上報工作日報失敗:" + result.getMessage();  log.warn(message);  dingtalkService.sendMessage(user.getPhone(), message);}</code></pre><p><br><strong>精簡：</strong></p><pre><code>String message;Result result = summaryService.reportWorkDaily(workDaily);if (result.isSuccess()) {  message = "上報工作日報成功";} else {  message = "上報工作日報失敗:" + result.getMessage();  log.warn(message);}dingtalkService.sendMessage(user.getPhone(), message);}</code></pre><h3 class=pgc-h-arrow-right><strong>9.3.調整表達式位置</strong></h3><p>調整表達式位置，在邏輯不變的前提下，讓代碼變得更簡潔。</p><p><strong>普通1：</strong></p><pre><code>String line = readLine();while (Objects.nonNull(line)) {    ... // 處理邏輯代碼    line = readLine();}</code></pre><p><strong>普通2：</strong></p><pre><code>for (String line = readLine(); Objects.nonNull(line); line = readLine()) {    ... // 處理邏輯代碼}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>String line;while (Objects.nonNull(line = readLine())) {    ... // 處理邏輯代碼}</code></pre><p>注意：有些規範可能不建議這種精簡寫法。</p><h3 class=pgc-h-arrow-right><strong>9.4.利用非空對象</strong></h3><p>在比較對象時，交換對象位置，利用非空對象，可以避免空指針判斷。</p><p><strong>普通：</strong></p><pre><code>private static final int MAX_VALUE = 1000;boolean isMax = (value != null &amp;&amp; value.equals(MAX_VALUE));boolean isTrue = (result != null &amp;&amp; result.equals(Boolean.TRUE));</code></pre><p><strong>精簡：</strong></p><pre><code>private static final Integer MAX_VALUE = 1000;boolean isMax = MAX_VALUE.equals(value);boolean isTrue = Boolean.TRUE.equals(result);</code></pre><h2 class=pgc-h-arrow-right><strong>10.利用設計模式</strong></h2><hr><p><strong>10.1.模板方法模式</strong></p><p>模板方法模式（Template Method Pattern）定義一個固定的算法框架，而將算法的一些步驟放到子類中實現，使得子類可以在不改變算法框架的情況下重定義該算法的某些步驟。</p><p><strong>普通：</strong></p><pre><code>@Repositorypublic class UserValue {  /** 值操作 */  @Resource(name = "stringRedisTemplate")   private ValueOperations&lt;String, String&gt; valueOperations;/** 值模式 */private static final String KEY_FORMAT = "Value:User:%s";/** 設置值 */public void set(Long id, UserDO value) {  String key = String.format(KEY_FORMAT, id);  valueOperations.set(key, JSON.toJSONString(value));} /** 獲取值 */ public UserDO get(Long id) {   String key = String.format(KEY_FORMAT, id);  String value = valueOperations.get(key);  return JSON.parseObject(value, UserDO.class); } ...}@Repositorypublic class RoleValue {  /** 值操作 */  @Resource(name = "stringRedisTemplate")  private ValueOperations&lt;String, String&gt; valueOperations;/** 值模式 */private static final String KEY_FORMAT = "Value:Role:%s";/** 設置值 */ public void set(Long id, RoleDO value) {  String key = String.format(KEY_FORMAT, id);  valueOperations.set(key, JSON.toJSONString(value));} /** 獲取值 */ public RoleDO get(Long id) {  String key = String.format(KEY_FORMAT, id);   String value = valueOperations.get(key);  return JSON.parseObject(value, RoleDO.class);}...}</code></pre><p><br><strong>精簡：</strong></p><pre><code>public abstract class AbstractDynamicValue&lt;I, V&gt; {  /** 值操作 */  @Resource(name = "stringRedisTemplate")  private ValueOperations&lt;String, String&gt; valueOperations; /** 設置值 */ public void set(I id, V value) {  valueOperations.set(getKey(id), JSON.toJSONString(value));}/** 獲取值 */public V get(I id) {  return JSON.parseObject(valueOperations.get(getKey(id)), getValueClass());}... /** 獲取主鍵 */ protected abstract String getKey(I id);/** 獲取值類 */protected abstract Class&lt;V&gt; getValueClass();}@Repositorypublic class UserValue extends AbstractValue&lt;Long, UserDO&gt; {    /** 獲取主鍵 */    @Override    protected String getKey(Long id) {        return String.format("Value:User:%s", id);    }    /** 獲取值類 */    @Override    protected Class&lt;UserDO&gt; getValueClass() {        return UserDO.class;    }}@Repositorypublic class RoleValue extends AbstractValue&lt;Long, RoleDO&gt; {    /** 獲取主鍵 */    @Override    protected String getKey(Long id) {        return String.format("Value:Role:%s", id);    }    /** 獲取值類 */    @Override    protected Class&lt;RoleDO&gt; getValueClass() {        return RoleDO.class;    }}</code></pre><h3 class=pgc-h-arrow-right><strong>10.2.建造者模式</strong></h3><p>建造者模式（Builder Pattern）將一個複雜對象的構造與它的表示分離，使同樣的構建過程可以創建不同的表示，這樣的設計模式被稱為建造者模式。</p><p><strong>普通：</strong></p><pre><code>public interface DataHandler&lt;T&gt; {   /** 解析數據 */  public T parseData(Record record); /** 存儲數據 */public boolean storeData(List&lt;T&gt; dataList);}public &lt;T&gt; long executeFetch(String tableName, int batchSize, DataHandler&lt;T&gt; dataHandler) throws Exception {  // 構建下載會話  DownloadSession session = buildSession(tableName);  // 獲取數據數量  long recordCount = session.getRecordCount();  if (recordCount == 0) {    return 0;  }  // 進行數據讀取  long fetchCount = 0L;   try (RecordReader reader = session.openRecordReader(0L, recordCount, true)) {    // 依次讀取數據    Record record;     List&lt;T&gt; dataList = new ArrayList&lt;&gt;(batchSize);     while ((record = reader.read()) != null) {      // 解析添加數據      T data = dataHandler.parseData(record);      if (Objects.nonNull(data)) {         dataList.add(data);        }       // 批量存儲數據        if (dataList.size() == batchSize) {        boolean isContinue = dataHandler.storeData(dataList);         fetchCount += batchSize;         dataList.clear();          if (!isContinue) {          break;         }        }     }     // 存儲剩餘數據    if (CollectionUtils.isNotEmpty(dataList)) {      dataHandler.storeData(dataList);      fetchCount += dataList.size();       dataList.clear();    }  }   // 返回獲取數量  return fetchCount;}// 使用案例long fetchCount = odpsService.executeFetch("user", 5000, new DataHandler() {                                           /** 解析數據 */                    @Override                   public T parseData(Record record) {                      UserDO user = new UserDO();                      user.setId(record.getBigint("id"));                      user.setName(record.getString("name"));                      return user;                    }                    /** 存儲數據 */                    @Override                    public boolean storeData(List&lt;T&gt; dataList) {                        userDAO.batchInsert(dataList);                        return true;                    }});</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>public &lt;T&gt; long executeFetch(String tableName, int batchSize, Function&lt;Record, T&gt; dataParser, Function&lt;List&lt;T&gt;, Boolean&gt; dataStorage) throws Exception {    // 構建下載會話    DownloadSession session = buildSession(tableName);    // 獲取數據數量    long recordCount = session.getRecordCount();    if (recordCount == 0) {        return 0;    }    // 進行數據讀取    long fetchCount = 0L;    try (RecordReader reader = session.openRecordReader(0L, recordCount, true)) {        // 依次讀取數據        Record record;        List&lt;T&gt; dataList = new ArrayList&lt;&gt;(batchSize);        while ((record = reader.read()) != null) {            // 解析添加數據            T data = dataParser.apply(record);            if (Objects.nonNull(data)) {                dataList.add(data);            }            // 批量存儲數據            if (dataList.size() == batchSize) {                Boolean isContinue = dataStorage.apply(dataList);                fetchCount += batchSize;                dataList.clear();                if (!Boolean.TRUE.equals(isContinue)) {                    break;                }            }        }        // 存儲剩餘數據        if (CollectionUtils.isNotEmpty(dataList)) {            dataStorage.apply(dataList);            fetchCount += dataList.size();            dataList.clear();        }    }    // 返回獲取數量    return fetchCount;} // 使用案例long fetchCount = odpsService.executeFetch("user", 5000, record -&gt; {        UserDO user = new UserDO();        user.setId(record.getBigint("id"));        user.setName(record.getString("name"));        return user;    }, dataList -&gt; {        userDAO.batchInsert(dataList);        return true;    });</code></pre><p><br></p><p>普通的建造者模式，實現時需要定義 DataHandler 接口，調用時需要實現 DataHandler 匿名內部類，代碼較多較繁瑣。而精簡後的建造者模式，充分利用了函數式編程，實現時無需定義接口，直接使用 Function 接口；調用時無需實現匿名內部類，直接採用 lambda 表達式，代碼較少較簡潔。</p><h3 class=pgc-h-arrow-right><strong>10.3.代理模式</strong></h3><p>Spring 中最重要的代理模式就是 AOP (Aspect-Oriented Programming，面向切面的編程)，是使用 JDK 動態代理和 CGLIB 動態代理技術來實現的。</p><p><strong>普通：</strong></p><pre><code>@Slf4j@RestController@RequestMapping("/user")public class UserController {    /** 用戶服務 */    @Autowired    private UserService userService;    /** 查詢用戶 */    @PostMapping("/queryUser")    public Result&lt;?&gt; queryUser(@RequestBody @Valid UserQueryVO query) {        try {            PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);            return Result.success(pageData);        } catch (Exception e) {            log.error(e.getMessage(), e);            return Result.failure(e.getMessage());        }    }    ...}</code></pre><p><br></p><p><strong>精簡1：</strong></p><p><br></p><p>基於 @ControllerAdvice 的異常處理：</p><pre><code>@RestController@RequestMapping("/user")public class UserController {    /** 用戶服務 */    @Autowired    private UserService userService;    /** 查詢用戶 */    @PostMapping("/queryUser")    public Result&lt;PageDataVO&lt;UserVO&gt;&gt; queryUser(@RequestBody @Valid UserQueryVO query) {        PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);        return Result.success(pageData);    }    ...}@Slf4j@ControllerAdvicepublic class GlobalControllerAdvice {    /** 處理異常 */    @ResponseBody    @ExceptionHandler(Exception.class)    public Result&lt;Void&gt; handleException(Exception e) {        log.error(e.getMessage(), e);        return Result.failure(e.getMessage());    }}</code></pre><p><br></p><p><strong>精簡2：</strong></p><p><br></p><p>基於 AOP 的異常處理：</p><pre><code>// UserController代碼同"精簡1"@Slf4j@Aspectpublic class WebExceptionAspect {    /** 點切面 */    @Pointcut("@annotation(org.springframework.web.bind.annotation.RequestMapping)")    private void webPointcut() {}    /** 處理異常 */    @AfterThrowing(pointcut = "webPointcut()", throwing = "e")    public void handleException(Exception e) {        Result&lt;Void&gt; result = Result.failure(e.getMessage());        writeContent(JSON.toJSONString(result));    }    ...}</code></pre><p><br></p><h2 class=pgc-h-arrow-right><strong>11.利用刪除代碼</strong></h2><hr><p>“少即是多”，“少”不是空白而是精簡，“多”不是擁擠而是完美。刪除多餘的代碼，才能使代碼更精簡更完美。</p><h3 class=pgc-h-arrow-right><strong>11.1.刪除已廢棄的代碼</strong></h3><p>刪除項目中的已廢棄的包、類、字段、方法、變量、常量、導入、註解、註釋、已註釋代碼、Maven包導入、MyBatis的SQL語句、屬性配置字段等，可以精簡項目代碼便於維護。</p><p><strong>普通：</strong></p><pre><code>import lombok.extern.slf4j.Slf4j;@Slf4j@Servicepublic class ProductService {    @Value("discardRate")    private double discardRate;    ...    private ProductVO transProductDO(ProductDO productDO) {        ProductVO productVO = new ProductVO();        BeanUtils.copyProperties(productDO, productVO);        // productVO.setPrice(getDiscardPrice(productDO.getPrice()));        return productVO;    }    private BigDecimal getDiscardPrice(BigDecimal originalPrice) {        ...    }}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>@Servicepublic class ProductService {    ...    private ProductVO transProductDO(ProductDO productDO) {        ProductVO productVO = new ProductVO();        BeanUtils.copyProperties(productDO, productVO);        return productVO;    }}11.2.刪除接口方法的public對於接口(interface)，所有的字段和方法都是public的，可以不用顯式聲明為public。普通：public interface UserDAO {    public Long countUser(@Param("query") UserQuery query);    public List&lt;UserDO&gt; queryUser(@Param("query") UserQuery query);}</code></pre><pre><code></code></pre><h3 class=pgc-h-arrow-right><strong>11.2.刪除接口方法的public</strong></h3><p>對於接口(interface)，所有的字段和方法都是 public 的，可以不用顯式聲明為 public 。</p><p><strong>普通：</strong></p><pre><code>public interface UserDAO {    public Long countUser(@Param("query") UserQuery query);    public List&lt;UserDO&gt; queryUser(@Param("query") UserQuery query);}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>public interface UserDAO {    Long countUser(@Param("query") UserQuery query);    List&lt;UserDO&gt; queryUser(@Param("query") UserQuery query);}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.3.刪除枚舉構造方法的 private</strong></h3><p>對於枚舉(menu)，構造方法都是 private 的，可以不用顯式聲明為 private 。</p><p><strong>普通：</strong></p><pre><code>public enum UserStatus {    DISABLED(0, "禁用"),    ENABLED(1, "啟用");  private final Integer value;    private final String desc;    private UserStatus(Integer value, String desc) {        this.value = value;        this.desc = desc;    }    ...}</code></pre><p><strong>精簡：</strong></p><pre><code>public enum UserStatus {    DISABLED(0, "禁用"),    ENABLED(1, "啟用");    private final Integer value;    private final String desc;    UserStatus(Integer value, String desc) {        this.value = value;        this.desc = desc;    }    ...}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.4.刪除 final 類方法的 final</strong></h3><p>對於 final 類，不能被子類繼承，所以其方法不會被覆蓋，沒有必要添加 final 修飾。</p><p><strong>普通：</strong></p><pre><code>public final Rectangle implements Shape {    ...    @Override    public final double getArea() {        return width * height;    }}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>public final Rectangle implements Shape {    ...    @Override    public double getArea() {        return width * height;    }}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.5.刪除基類 implements 的接口</strong></h3><p>如果基類已 implements 某接口，子類沒有必要再 implements 該接口，只需要直接實現接口方法即可。</p><p><br></p><p><strong>普通：</strong></p><pre><code>public interface Shape {    ...    double getArea();}public abstract AbstractShape implements Shape {    ...}public final Rectangle extends AbstractShape implements Shape {    ...    @Override    public double getArea() {        return width * height;    }}</code></pre><p><strong>精簡：</strong></p><pre><code>...public final Rectangle extends AbstractShape {    ...    @Override    public double getArea() {        return width * height;    }}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.6.刪除不必要的變量</strong></h3><p>不必要的變量，只會讓代碼看起來更繁瑣。</p><p><strong>普通：</strong></p><pre><code>public Boolean existsUser(Long userId) {    Boolean exists = userDAO.exists(userId);    return exists;}</code></pre><p><br></p><p><strong>精簡：</strong></p><pre><code>public Boolean existsUser(Long userId) {    return userDAO.exists(userId);}</code></pre><h2 class=pgc-h-arrow-right><strong>後記</strong></h2><hr><p><br></p><p>古語又云：</p><blockquote><p>有道無術，術尚可求也；有術無道，止於術。</p></blockquote><p>意思是：有“道”而無“術”，“術”還可以逐漸獲得；有“術”而無“道”，就可能止步於“術”了。所以，我們不要僅滿足於從實踐中總結“術”，因為“道”的表現形式是多變的；而應該上升到“道”的高度，因為“術”背後的道理是相通的。當遇到新的事物時，我們可以從理論中找到“道”、從實踐中找出“術”，嘗試著去認知新的事物。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>示例</a></li><li><a>至簡</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/48f7c5e6.html alt=Java工具類教程：詳解正則表達式及應用示例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/4002000140fde581089b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48f7c5e6.html title=Java工具類教程：詳解正則表達式及應用示例>Java工具類教程：詳解正則表達式及應用示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/115806c0.html alt=Java正則表達式教程及示例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/07559bf8adcd496d8267aad619be8a94 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/115806c0.html title=Java正則表達式教程及示例>Java正則表達式教程及示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/971dc36b.html alt="Java集合 - TreeSet詳解和使用示例" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f01f6ccf89994943be8d054a21c1a3fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/971dc36b.html title="Java集合 - TreeSet詳解和使用示例">Java集合 - TreeSet詳解和使用示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>