<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring學習（4）：Spring AOP | 极客快訊</title><meta property="og:title" content="Spring學習（4）：Spring AOP - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/be8a179a4a8040648c1fb5a0532cc84b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92488c35.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92488c35.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/92488c35.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92488c35.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92488c35.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/92488c35.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/92488c35.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92488c35.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Spring學習（4）：Spring AOP"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/92488c35.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring學習（4）：Spring AOP</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h3 class=line>Spring AOP說明</h3><p>AOP（Aspect Oriented Pragraming）面向切面編程，AOP採用橫向抽取機制，取代了傳統縱向繼承體系的重複性代碼（性能監視、事務管理、安全檢查、緩存）。</p><p>所謂的傳統縱向繼承體系是指當你需要實現某個功能的時候需要去繼承某個類，而橫向抽取機制則是通過使用動態代理機制產生一個與之同級的對象，然後在代理對象中進行功能增強。</p><p>Spring AOP使用純Java實現，不需要專門的編譯過程和類加載器，在運行期通過代理方式向目標類織入增強代碼。</p><h3 class=line>Spring的AOP代理</h3><p>JDK動態代理:對實現了接口的類生成代理CGLib代理機制:對類生成代理</p><h3 class=line>AOP相關術語</h3><p><strong>Joinpoint(連接點):</strong>所謂連接點是指那些被攔截到的點。在spring中,這些點指的是方法,因為spring只支持方法類型的連接點；<strong>Pointcut(切入點):</strong>所謂切入點是指我們要對哪些Joinpoint進行攔截的定義；<strong>Advice(通知/增強):</strong>所謂通知是指攔截到Joinpoint之後所要做的事情就是通知。通知分為前置通知，後置通知，異常通知，最終通知，環繞通知(切面要完成的功能)；<strong>Introduction(引介):</strong>引介是一種特殊的通知在不修改類代碼的前提下, Introduction可以在運行期為類動態地添加一些方法或Field；<strong>Target(目標對象):</strong>代理的目標對象；<strong>Weaving(織入):</strong>是指把增強應用到目標對象來創建新的代理對象的過程。spring採用動態代理織入，而AspectJ採用編譯期織入和類裝載期織入；<strong>Proxy（代理）:</strong>一個類被AOP織入增強後，就產生一個結果代理類；<strong>Aspect(切面) :</strong>是切入點和通知（引介）的結合。</p><div class=pgc-img><img alt="Spring學習（4）：Spring AOP" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/be8a179a4a8040648c1fb5a0532cc84b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="Spring學習（4）：Spring AOP" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/229735938bf44e95a4216e2374199024><p class=pgc-img-caption></p></div><h1 class=line>AOP的底層實現</h1><p>前面說過AOP代理有兩種，一種是JDK動態代理，用於對實現了接口的類生成代理；另一種是CGLib代理機制，用於對類生成代理。</p><h3 class=line>JDK動態代理</h3><p>新建一個Maven項目，名稱為SpringAOP，導入Junit依賴。新建com/envy/aop/demo文件夾，新建接口文件UserDao.java，裡面的代碼為：</p><pre><code>public interface UserDao {    public void add();    public void update();}</code></pre><p>以及實現類UserDaoImpl.java文件：</p><pre><code>public class UserDaoImpl implements UserDao {    public void add() {        System.out.println("this is add method");    }    public void update() {        System.out.println("this is update method");    }}</code></pre><p>接著新建com/envy/aop/test文件夾，新建測試文件AopTest.java，裡面的代碼為：</p><pre><code>public class AopTest {    @Test    public void testOne(){        UserDao userDao = new UserDaoImpl();        userDao.add();        userDao.update();    }}</code></pre><p>運行結果：</p><pre><code>this is add methodthis is update method</code></pre><p>上述是傳統的編程方式，接下來是使用JDK動態代理模式的相關步驟，JDK動態代理模式用於對實現了接口的類生成代理，而此處的UserDao本身就是一個接口。</p><p>新建MyJDKProxy.java文件，裡面代碼為：</p><pre><code>public class MyJDKProxy implements InvocationHandler {    private UserDao userDao;    public MyJDKProxy(UserDao userDao){        this.userDao=userDao;    }    public Object createProxy(){        Object proxy= Proxy.newProxyInstance(userDao.getClass().getClassLoader(),userDao.getClass().getInterfaces(),this);        return proxy;    }    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        if("add".equals(method.getName())){            //一些增強功能，如權限校驗            System.out.println("開始權限校驗操作");            return method.invoke(proxy,args);        }        return method.invoke(userDao,args);    }}</code></pre><p>接著新建testTwo方法，裡面代碼為：</p><pre><code>    @Test    public void testTwo(){        UserDao userDao = new UserDaoImpl();        UserDao proxy = (UserDao) new MyJDKProxy(userDao).createProxy();        proxy.add();        proxy.update();    }</code></pre><p>運行結果：</p><pre><code>Start permission verificationthis is add methodthis is update method</code></pre><h3 class=line>CGLIB動態代理</h3><p>CGLIB(Code Generation Library)是一個開源項目！是一個強大的，高性能，高質量的Code生成類庫，它可以在運行期擴展Java類與實現Java接口。 Hibernate支持它來實現PO(Persistent Object 持久化對象)字節碼的動態生成(Hibernate實際使用Javassist生成代理，該代理對象就是持久化類的子類的實例)，現在做cglib的開發，可以不用直接引入cglib的包，因為spring核心中已經集成了cglib。</p><p>CGLIB生成代理機制：其實生成了一個真實對象的子類。</p><p>新建ProductDao.java文件，裡面的代碼為：</p><pre><code>public class ProductDao {    public void add(){        System.out.println("add product");    }    public void update(){        System.out.println("update product");    }}</code></pre><p>接著新建測試方法testThree，裡面的代碼為：</p><pre><code>    @Test    public void testThree(){        ProductDao productDao = new ProductDao();        productDao.add();        productDao.update();    }</code></pre><p>運行結果：</p><pre><code>add productupdate product</code></pre><p>上述是傳統的編程方式，接下來是使用CGLIB動態代理模式的相關步驟，CGLIB動態代理模式用於對類生成代理，而此處的ProductDao本身就是一個類。</p><p>新建MyCGLibProxy.java文件，裡面代碼為：</p><pre><code>public class MyCGLibProxy implements MethodInterceptor {    private ProductDao productDao;    public MyCGLibProxy(ProductDao productDao){        this.productDao=productDao;    }    public Object createProxy(){        //1、設置核心類        Enhancer enhancer = new Enhancer();        //2、設置父類        enhancer.setSuperclass(productDao.getClass());        //3、設置回調        enhancer.setCallback(this);        //4、生成代理        Object proxy = enhancer.create();        return proxy;    }    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        if("add".equals(method.getName())){            //一些增強功能，如權限校驗            System.out.println("Start permission verification");            return methodProxy.invokeSuper(proxy,args);        }        return methodProxy.invokeSuper(proxy,args);    }}</code></pre><p>接著新建testFour方法，裡面代碼為：</p><pre><code>    @Test    public void testFour(){        ProductDao productDao = new ProductDao();        ProductDao proxy = (ProductDao) new MyCGLibProxy(productDao).createProxy();        proxy.add();        proxy.update();    }</code></pre><p>運行結果：</p><pre><code>Start permission verificationadd productupdate product</code></pre><p>代理知識總結：1、Spring在運行期生成動態代理對象，不需要使用特殊的編譯器；2、SpringAOP的底層就是通過JDK動態代理或CGLib動態代理技術為目標Bean執行橫向織入。</p><p>若目標對象實現了若干接口，Spring使用JDK的java.lang.reflect.Proxy類代理；若目標對象沒有實現任何接口，Spring使用CGLIB庫生成目標對象的子類。在程序中應優先對接口創建代理，便於程序解耦維護。標記為final的方法不能被代理，因為該方法不能被重寫。因此JDK動態代理是針對接口生成子類，接口中的方法不能使用final來修飾；CGLIb是針對目標類生成子類，類或者方法不能使用final來修飾。</p><p><strong>Spring只支持方法連接點，不支持屬性連接點。</strong></p><h1 class=line>Spring中的AOP</h1><h3 class=line>SpringAOP增強類型</h3><p>AOP不是由Spring定義，而是AOP聯盟組織來定義的。Spring按照通知Advice在目標類方法的連接點位置，可以分為5個位置：前置通知：org.springframework.aop.MethodBeforeAdvice:在目標方法執行前實施增強；後置通知：org.springframework.aop.AfterReturningAdvice:在目標方法執行後實施增強；環繞通知：org.aopalliance.intercept.MethodInterceptor:在目標方法執行前後實施增強；異常拋出通知：org.springframework.aop.ThrowsAdvice:在方法拋出異常後實施增強；引介通知：org.springframework.aop.IntroductionInterceptor(不研究):在目標類中添加一些新的方法和屬性。</p><h3 class=line>SpringAOP切面類型</h3><p>Advisor（Spring中傳統切面）就是對PointCut應用Advice。（通常所說的Advisor是指只有一個Point和一個Advice，而Aspect是具有多個切點和多個通知的組合）；Advisor :代表一般切面，Advice本身就是一個切面，對目標類所有方法進行攔截 （沒有切點）；PointcutAdvisor :代表具有切點的切面，可以指定攔截目標類哪些方法；IntroductionAdvisor : 代表引介切面，針對引介通知而使用切面（不要求掌握）。</p><h1 class=line>SpringAOP的開發</h1><h3 class=line>針對所有方法的增強(不帶切點的切面)</h3><p>此處演示針對所有方法的增強也就是不帶切點的切面，相應的操作步驟如下：</p><p>第一步：導入相應的包。首先在pom.xml文件中引入spring-aop，spring-test和com.springsource.org.aopalliance：</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;aopalliance&lt;/groupId&gt;            &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;            &lt;version&gt;1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>第二步：編寫被代理對象。新建com.envy.aop.student包，接著在裡面新建接口StudentDao.java文件，裡面代碼為：</p><pre><code>public interface StudentDao {    public void add();    public void update();}</code></pre><p>以及它的實現類StudentDaoImpl.java：</p><pre><code>public class StudentDaoImpl implements StudentDao {    public void add() {        System.out.println("this is add method");    }    public void update() {        System.out.println("this is update method");    }}</code></pre><p>第三步，編寫增強的代碼。此處僅僅以前置通知為例演示如何編寫增強代碼（前置通知：org.springframework.aop.MethodBeforeAdvice:在目標方法執行前實施增強）。新建MyBeforeAdvice.java文件：</p><pre><code>public class MyBeforeAdvice implements MethodBeforeAdvice {    public void before(Method method, Object[] objects, Object o) throws Throwable {        System.out.println("前置增強的方法");    }}</code></pre><p>第四步，生成代理(配置生成代理)。新建applicationContext.xml文件，裡面的代碼如下：</p><pre><code>  &lt;!-- 不帶有切點的切面 --&gt;    &lt;!--  配置目標類(目標對象，即需要給哪個類進行增強) --&gt;    &lt;bean id="studentDao" class="com.envy.aop.student.StudentDaoImpl"/&gt;    &lt;!-- 前置通知類型 --&gt;    &lt;bean id="myBeforeAdvice" class="com.envy.aop.student.MyBeforeAdvice"/&gt;    &lt;!-- SpringAOP產生代理對象 --&gt;    &lt;bean id="studentDaoProxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;        &lt;!-- 配置目標類(目標對象，即需要給哪個類進行增強) --&gt;        &lt;property name="target" ref="studentDao"/&gt;        &lt;!-- 實現的接口 --&gt;        &lt;property name="proxyInterfaces" value="com.envy.aop.student.StudentDao"/&gt;        &lt;!-- 採用攔截的名稱 --&gt;        &lt;property name="interceptorNames" value="myBeforeAdvice"/&gt;        &lt;!-- 是否強制使用CGLib，true是，false則是JDK --&gt;        &lt;property name="optimize" value="true"/&gt;    &lt;/bean&gt;</code></pre><p>第五步，注入測試。新建SpringAOPAdvisor.java測試文件，裡面的代碼為：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class SpringAOPAdvisor {//    @Resource(name="studentDao")  //這是不使用AOP代理對象    @Resource(name="studentDaoProxy")    private StudentDao studentDao;    @Test    public void testOne(){        studentDao.add();        studentDao.update();    }}</code></pre><p>運行結果：</p><pre><code>前置增強的方法this is add method前置增強的方法this is update method</code></pre><p>在第四步，生成代理對象時我們在applicationContext.xml文件中配置了一些屬性。其實就是生成代理Spring基於ProxyFactoryBean類，底層自動選擇使用JDK的動態代理還是CGLIB的代理。下面是其中的幾個屬性介紹:target :代理的目標對象；proxyInterfaces :代理要實現的接口，如果多個接口可以使用以下格式賦值:</p><pre><code>&lt;list&gt;　　&lt;value&gt;&lt;/value&gt;　　　　....&lt;/list&gt;</code></pre><p>proxyTargetClass :是否對類代理而不是接口，設置為true時，使用CGLib代理；interceptorNames :需要織入目標的Advice；singleton :返回代理是否為單實例，默認為單例。optimize :當設置為true時，強制使用CGLib。</p><p><br></p><div class=pgc-img><img alt="Spring學習（4）：Spring AOP" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d11fe2dabf84b89a74231a746dfe34d><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>學習</a></li><li><a>AOP</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html alt="Spring AOP簡介與底層實現機制——動態代理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/413780d1-cf47-4038-9471-b686d97aa99b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html title="Spring AOP簡介與底層實現機制——動態代理">Spring AOP簡介與底層實現機制——動態代理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b564e1e.html alt="Spring boot學習（六）Spring boot實現AOP記錄操作日誌" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6824f504d2264a748492cd7ceb6732ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b564e1e.html title="Spring boot學習（六）Spring boot實現AOP記錄操作日誌">Spring boot學習（六）Spring boot實現AOP記錄操作日誌</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html alt=Spring框架AOP技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/760bf32faca443cb8e28ed0b9bc20205 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html title=Spring框架AOP技術>Spring框架AOP技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面編程AOP的初步瞭解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面編程AOP的初步瞭解>Spring面向切面編程AOP的初步瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html alt=小實例理解Spring中的AOP----面向切面編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35942664cec244f88d6a0f7b1e7067cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html title=小實例理解Spring中的AOP----面向切面編程>小實例理解Spring中的AOP----面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面編程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面編程需要知道的事">Spring AOP 面向切面編程需要知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html alt="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html title="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現">Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html alt=Spring—面向切面編程（AOP）詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html title=Spring—面向切面編程（AOP）詳解>Spring—面向切面編程（AOP）詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html alt="Spring：AOP 面向切面編程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html title="Spring：AOP 面向切面編程">Spring：AOP 面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用註解方式配置Spring中的面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用註解方式配置Spring中的面向切面編程AOP>使用註解方式配置Spring中的面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ef7083e.html alt="溫故知新——Spring AOP（一）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ef7083e.html title="溫故知新——Spring AOP（一）">溫故知新——Spring AOP（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/430ad617.html alt=理解Spring：AOP的原理及手動實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8435d8c955b34ce68d6e3765409ff14f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/430ad617.html title=理解Spring：AOP的原理及手動實現>理解Spring：AOP的原理及手動實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0013439.html alt="關於Spring AOP的靈魂十問" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f76928765e9444fd8b608eab1ae51b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0013439.html title="關於Spring AOP的靈魂十問">關於Spring AOP的靈魂十問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55b5b18.html alt=Spring學習總結（3）——Spring配置文件詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/43600001bb8d069efbc5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55b5b18.html title=Spring學習總結（3）——Spring配置文件詳解>Spring學習總結（3）——Spring配置文件詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html alt=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13adbab9c7f94c7fa81d49a98861b051 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html title=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式>機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>