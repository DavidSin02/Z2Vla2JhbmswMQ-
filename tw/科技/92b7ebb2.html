<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏 | 极客快訊</title><meta property="og:title" content="大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9c9227424d8f4b52958e32ec1ffdb116"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92b7ebb2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92b7ebb2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/92b7ebb2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92b7ebb2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92b7ebb2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/92b7ebb2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/92b7ebb2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/92b7ebb2.html><meta property="article:published_time" content="2020-11-14T21:02:46+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:46+08:00"><meta name=Keywords content><meta name=description content="大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/92b7ebb2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>我們先通過一個簡單的批量處理WordCount的程序，來了解一下，在編程API層面的基本使用方法，以及Flink是如何基於Pipeline風格的API實現一個完整的應用程序的，還有就是每一步操作的底層，都是如何進行轉換的。WordCount程序代碼，示例如下所示：</p><pre><code>final MultipleParameterTool params = MultipleParameterTool.fromArgs(args);final ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();env.getConfig().setGlobalJobParameters(params); // get input dataDataSet&lt;String&gt; text = env.readTextFile(input);DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; counts =        // split up the lines in pairs (2-tuples) containing: (word,1)        text.flatMap(new Tokenizer())        // group by the tuple field "0" and sum up tuple field "1"        .groupBy(0)        .sum(1);counts.writeAsCsv(params.get("output"), "\n", " ");// execute programenv.execute("WordCount Example");</code></pre><p>上述WordCount示例程序，它在用戶編程API使用的層面來看是呈線性的，對應一個計算DAG，我們以它為例因為線性比較簡單，更容易理解和說明。通過查看Flink源碼可以看到，上面程序通過調用ExecutionEnvironment的readTextFile()、flatMap()、groupBy()、sum()、writeAsCsv()方法，生成了一個計算Job DAG。這個Job可以通過下圖來展示Flink在High-Level API層面是如何映射到我們所說的Operator組件的，如圖所示：</p><div class=pgc-img><img alt=大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9c9227424d8f4b52958e32ec1ffdb116><p class=pgc-img-caption></p></div><p>上圖中，第一層藍色方框表示通過用戶編程API調用方法後，轉換成的各個DataSet對象，它們表示每經過一個轉換操作，都由一個DataSet生成另一個DataSet。除了DataSink和UnsortedGrouping以外，這些DataSet都是位於org.apache.flink.api.java.operators包下面的實現類。第二層的黑色方框表示，為了能夠進一步校驗用戶編寫的Batch Job程序的規範性，以及獲取更多有關Dataflow的信息，又抽象出了一層Operator設計，這一層Operator位於org.apache.flink.api.common.operators包下面。從左右向右箭頭表示，用戶程序對輸入數據集進行轉換操作的順序；從右向左箭頭表示，每經過一次轉換操作生成一個新的DataSet，它內部都會維護一個指針用來指向上一個DataSet，這方便了對各個轉換操作新生成生成DataSet的順序進行跟蹤。其實，Flink在構建JobGraph的過程中，就是從後向前進行遍歷，不斷對Job的DAG圖中各個Operator進行增強和優化。下面我們會對這兩層進行詳細解釋說明。有關DataSet類的設計，如下圖所示：</p><div class=pgc-img><img alt=大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1346c393ae964d29bcd6088043e89750><p class=pgc-img-caption></p></div><p>圖中各個Operator的具體實現類，是構建DAG圖最原始的表示形式，他們內部直接封裝了通過編程API傳入的函數，或者Flink內部為完成DAG而實現的內置函數。我們以flatMap為例，調用flatMap()會創建名為FlatMapOperator的DataSet，具體實現代碼如下所示：</p><pre><code>public &lt;R&gt; FlatMapOperator&lt;T, R&gt; flatMap(FlatMapFunction&lt;T, R&gt; flatMapper) {    if (flatMapper == null) {        throw new NullPointerException("FlatMap function must not be null.");    }     String callLocation = Utils.getCallLocationName();    TypeInformation&lt;R&gt; resultType = TypeExtractor.getFlatMapReturnTypes(flatMapper, getType(), callLocation, true);    return new FlatMapOperator&lt;&gt;(this, resultType, clean(flatMapper), callLocation);}</code></pre><p>代碼中的FlatMapFunction就是用戶編寫Flink程序時，傳入給flatMap()方法的函數實現，這個函數會被設置為FlatMapOperator對象的一個function屬性的值。當我們編寫的Flink批量處理程序中，最後會調用ExecutionEnvironment.execute()，在該方法中會對最原始的由Operator構建好的DAG圖進行處理，處理的基本流程簡要描述如下所示：</p><ol start=1><li>創建一個Plan，它是Pipeline接口的具體實現類，表示了從DataSink到DataSource實現連通的數據流DAG圖。</li><li>根據輸入配置，獲取到對應的PipelineExecutor，用來將實現的Job提交到執行引擎進行計算處理。</li><li>將Plan進一步進行優化，編譯生成OptimizedPlan，它表示了對應的執行計劃，通過抽象的數據結構PlanNode和Channel來更加精確描述程序如何被執行。</li><li>最後，根據OptimizedPlan生成最終的JobGraph，從而提交到集群JobManager進行真正執行。</li></ol><p>這裡，我們不會非常深入地說明各個步驟涉及到的細節，但是會從更高Level來理解生成JobGraph的過程中，都做了哪些處理。</p><p><strong>生成Plan</strong></p><p>在生成Plan的過程中，就涉及到上面WordCount數據流DAG圖中展示的第二層構成DAG的基本元素Operator，它們是位於org.apache.flink.api.common.operators包下面實現類，我們先看看這個Operator類體系的繼承關係，如下圖所示：</p><div class=pgc-img><img alt=大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c0c61514b7d3450583c14f232fc92541><p class=pgc-img-caption></p></div><p>上面類圖中，大多數Operator實現類名稱都帶有一個Base的後綴，大部分都與org.apache.flink.api.java包下面的Operator實現類有一個對應關係，比如，FlatMapOperator對應FlatMapOperatorBase，DataSource對應DataSourceBase、AggregateOperator對應GroupReduceOperatorBase等等，不再一一列舉。在DataSet的具體實現類中，每個類都有一個translateToDataFlow()方法，能夠將該Operator的輸入DataSet轉換成一個org.apache.flink.api.common.operators.Operator，所以在從DataSink到DataSource遞歸遍歷過程中，都會進行該轉換操作。另外，還會根據用戶編寫程序中設置的各種參數，包括Flink默認的一些參數值等等，都配置到基於org.apache.flink.api.common.operators.Operator的具體對象上。下面是核心的處理代碼：</p><pre><code>public Plan translateToPlan(List&lt;DataSink&lt;?&gt;&gt; sinks, String jobName) {    List&lt;GenericDataSinkBase&lt;?&gt;&gt; planSinks = new ArrayList&lt;&gt;();     for (DataSink&lt;?&gt; sink : sinks) {        planSinks.add(translate(sink));    }     Plan p = new Plan(planSinks);    p.setJobName(jobName);    return p;}</code></pre><p>其中，參數sinks是在ExecutionEnvironment中管理的最原始Flink程序DAG，對於上面的WordCount例子，實際只有一個DataSink。上面的translate(sink)方法調用，對最初構建好的整個DAG進行翻譯處理，它是一個遞歸處理過程，代碼如下所示：</p><pre><code>private &lt;T&gt; GenericDataSinkBase&lt;T&gt; translate(DataSink&lt;T&gt; sink) {    // translate the input recursively    Operator&lt;T&gt; input = translate(sink.getDataSet());    // translate the sink itself and connect it to the input    GenericDataSinkBase&lt;T&gt; translatedSink = sink.translateToDataFlow(input);    translatedSink.setResources(sink.getMinResources(), sink.getPreferredResources());    return translatedSink;}</code></pre><p>上面translate(sink.getDataSet())方法調用中，對各種不同類型的Operator進行翻譯處理，因為每個Operator的特點以及行為本身就不同，所以translate()方法中分別進行了不同的處理，實現如下代碼所示：</p><pre><code>private &lt;T&gt; Operator&lt;T&gt; translate(DataSet&lt;T&gt; dataSet) {    while (dataSet instanceof NoOpOperator) {        dataSet = ((NoOpOperator&lt;T&gt;) dataSet).getInput();    }     // check if we have already translated that data set (operation or source)    Operator&lt;?&gt; previous = this.translated.get(dataSet);    if (previous != null) {        // Union operators may only have a single output.        // We ensure this by not reusing previously created union operators.        // The optimizer will merge subsequent binary unions into one n-ary union.        if (!(dataSet instanceof UnionOperator)) {            // all other operators are reused.            @SuppressWarnings("unchecked")            Operator&lt;T&gt; typedPrevious = (Operator&lt;T&gt;) previous;            return typedPrevious;        }    }     Operator&lt;T&gt; dataFlowOp;    if (dataSet instanceof DataSource) {        DataSource&lt;T&gt; dataSource = (DataSource&lt;T&gt;) dataSet;        dataFlowOp = dataSource.translateToDataFlow();        dataFlowOp.setResources(dataSource.getMinResources(), dataSource.getPreferredResources());    }    else if (dataSet instanceof SingleInputOperator) {        SingleInputOperator&lt;?, ?, ?&gt; singleInputOperator = (SingleInputOperator&lt;?, ?, ?&gt;) dataSet;        dataFlowOp = translateSingleInputOperator(singleInputOperator);        dataFlowOp.setResources(singleInputOperator.getMinResources(), singleInputOperator.getPreferredResources());    }    else if (dataSet instanceof TwoInputOperator) {        TwoInputOperator&lt;?, ?, ?, ?&gt; twoInputOperator = (TwoInputOperator&lt;?, ?, ?, ?&gt;) dataSet;        dataFlowOp = translateTwoInputOperator(twoInputOperator);        dataFlowOp.setResources(twoInputOperator.getMinResources(), twoInputOperator.getPreferredResources());    }    else if (dataSet instanceof BulkIterationResultSet) {        BulkIterationResultSet&lt;?&gt; bulkIterationResultSet = (BulkIterationResultSet&lt;?&gt;) dataSet;        dataFlowOp = translateBulkIteration(bulkIterationResultSet);        dataFlowOp.setResources(bulkIterationResultSet.getIterationHead().getMinResources(),                bulkIterationResultSet.getIterationHead().getPreferredResources());    }    else if (dataSet instanceof DeltaIterationResultSet) {        DeltaIterationResultSet&lt;?, ?&gt; deltaIterationResultSet = (DeltaIterationResultSet&lt;?, ?&gt;) dataSet;        dataFlowOp = translateDeltaIteration(deltaIterationResultSet);        dataFlowOp.setResources(deltaIterationResultSet.getIterationHead().getMinResources(),                deltaIterationResultSet.getIterationHead().getPreferredResources());    }    else if (dataSet instanceof DeltaIteration.SolutionSetPlaceHolder || dataSet instanceof DeltaIteration.WorksetPlaceHolder) {        throw new InvalidProgramException("A data set that is part of a delta iteration was used as a sink or action."            + " Did you forget to close the iteration?");    }    else {        throw new RuntimeException("Error while creating the data flow plan for the program: Unknown operator or data set type: " + dataSet);    }     this.translated.put(dataSet, dataFlowOp);    // take care of broadcast variables    translateBcVariables(dataSet, dataFlowOp);    return dataFlowOp;}</code></pre><p>上面translateSingleInputOperator()、translateTwoInputOperator()等方法中，會遞歸調用該translate()方法來對某個Operator進行翻譯處理。我們以前面給出的WordCount程序為例，就會對DataSource→FlatMapOperator→UnsortedGrouping→AggregateOperator→DataSink進行從後至前的遍歷，最終翻譯成GenericDataSourceBase→FlatMapOperatorBase→GroupReduceOperatorBase→GenericDataSinkBase。這樣，我們便得到了最基本的Plan。</p><p><strong>生成OptimizedPlan</strong></p><p>通過上一步生成的Plan，我們還無法精確地知道如何真正運行某個Operator。所以接下來，生成的OptimizedPlan能夠做到如下事情：</p><ul><li>基於用戶的程序生成Plan，更進一步生成更精確描述用戶程序執行的OptimizedPlan。</li><li>OptimizedPlan能夠精確地描述程序如何物理地執行。</li><li>Operator使用何種策略執行，比如，是Hash Join還是Sort Merge Join。</li><li>Operator之間進行數據交換的策略，是Local Pipe Forward、Shuffle，還是Broadcast。</li><li>Operator之間使用的數據交換模式，是Pipelined還是Batch。</li><li>在什麼地方緩存中間結果。</li></ul><p>這裡，我們不再更詳細地去分析，後面會對單獨寫文章進行深入分析。現在可以查看對應代碼來了解，核心代碼如下所示：</p><pre><code>GraphCreatingVisitor graphCreator = new GraphCreatingVisitor(defaultParallelism, defaultDataExchangeMode);program.accept(graphCreator); // if we have a plan with multiple data sinks, add logical optimizer nodes that have two data-sinks as children// each until we have only a single root node. This allows to transparently deal with the nodes with// multiple outputsOptimizerNode rootNode;if (graphCreator.getSinks().size() == 1) {    rootNode = graphCreator.getSinks().get(0);}else if (graphCreator.getSinks().size() &gt; 1) {    Iterator&lt;DataSinkNode&gt; iter = graphCreator.getSinks().iterator();    rootNode = iter.next();    while (iter.hasNext()) {        rootNode = new SinkJoiner(rootNode, iter.next());    }}else {    throw new CompilerException("Bug: The optimizer plan representation has no sinks.");} // now that we have all nodes created and recorded which ones consume memory, tell the nodes their minimal// guaranteed memory, for further cost estimations. We assume an equal distribution of memory among consumer tasksrootNode.accept(new IdAndEstimatesVisitor(this.statistics)); // We need to enforce that union nodes always forward their output to their successor.// Any partitioning must be either pushed before or done after the union, but not on the union's output.UnionParallelismAndForwardEnforcer unionEnforcer = new UnionParallelismAndForwardEnforcer();rootNode.accept(unionEnforcer); // We are dealing with operator DAGs, rather than operator trees.// That requires us to deviate at some points from the classical DB optimizer algorithms.// This step builds auxiliary structures to help track branches and joins in the DAGBranchesVisitor branchingVisitor = new BranchesVisitor();rootNode.accept(branchingVisitor); // Propagate the interesting properties top-down through the graphInterestingPropertyVisitor propsVisitor = new InterestingPropertyVisitor(this.costEstimator);rootNode.accept(propsVisitor); // perform a sanity check: the root may not have any unclosed branchesif (rootNode.getOpenBranches() != null &amp;&amp; rootNode.getOpenBranches().size() &gt; 0) {    throw new CompilerException("Bug: Logic for branching plans (non-tree plans) has an error, and does not " +            "track the re-joining of branches correctly.");} // the final step is now to generate the actual plan alternativesList&lt;PlanNode&gt; bestPlan = rootNode.getAlternativePlans(this.costEstimator);if (bestPlan.size() != 1) {    throw new CompilerException("Error in compiler: more than one best plan was created!");} // check if the best plan's root is a data sink (single sink plan)// if so, directly take it. if it is a sink joiner node, get its contained sinksPlanNode bestPlanRoot = bestPlan.get(0);List&lt;SinkPlanNode&gt; bestPlanSinks = new ArrayList&lt;SinkPlanNode&gt;(4); if (bestPlanRoot instanceof SinkPlanNode) {    bestPlanSinks.add((SinkPlanNode) bestPlanRoot);} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {    ((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks);} // finalize the planOptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program);plan.accept(new BinaryUnionReplacer());plan.accept(new RangePartitionRewriter(plan)); // post pass the plan. this is the phase where the serialization and comparator code is setpostPasser.postPass(plan);</code></pre><p>這裡需要說的是，經過上面代碼的處理，首先會將Plan生成一箇中間結構的Plan，主要是通過GraphCreatingVisitor來進行處理的，DAG圖以OptimizerNode為基本節點進行抽象構建，對應的類及其繼承關係如下圖所示：</p><div class=pgc-img><img alt=大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c701d403f5af48f5bb38533054b76334><p class=pgc-img-caption></p></div><p>優化器（Optimizer）會使用每個OptimizerNode提供的信息來構建DAG，稱為Optimizer DAG，從而完成如下處理工作：</p><ul><li>評估每個Operator處理的數據量的大小，以及Key/Value數據的數量。</li><li>確定在DAG的什麼位置進行Split（分支）或者Join（合併）處理操作。</li><li>使用DagConnection數據接口來描述Operator之間如何進行連接，包括Broadcast連接、Incoming連接和Outgoing連接。</li><li>選擇合適的屬性，從而不斷迭代優化候選計劃（Candidate Plan）。</li></ul><p>然後，根據上面基於OptimizerNode的DAG，又進行優化處理，最終得到了以PlanNode為基本節點抽象的DAG圖，PlanNode類及其繼承關係如下圖所示：</p><div class=pgc-img><img alt=大數據專家，對Flink批處理生成JobGraph流程深入分析，值得收藏 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4dd907b1283c449f952d73fe4b822d28><p class=pgc-img-caption></p></div><p>每個PlanNode並不是和之前翻譯過程中生成的一些數據結構沒關係，它們內部都有一個OptimizerNode的引用，從而能訪問到OptimizerNode內部的信息。PlanNode主要抽象了DAG圖中各個Operator之間如何進行數據交換，以及數據交換策略，最終得到一個唯一的最佳Plan，對應代碼片段如下所示：</p><pre><code>List&lt;PlanNode&gt; bestPlan = rootNode.getAlternativePlans(this.costEstimator);if (bestPlan.size() != 1) {    throw new CompilerException("Error in compiler: more than one best plan was created!");} // check if the best plan's root is a data sink (single sink plan)// if so, directly take it. if it is a sink joiner node, get its contained sinksPlanNode bestPlanRoot = bestPlan.get(0);List&lt;SinkPlanNode&gt; bestPlanSinks = new ArrayList&lt;SinkPlanNode&gt;(4);if (bestPlanRoot instanceof SinkPlanNode) {    bestPlanSinks.add((SinkPlanNode) bestPlanRoot);} else if (bestPlanRoot instanceof SinkJoinerPlanNode) {    ((SinkJoinerPlanNode) bestPlanRoot).getDataSinks(bestPlanSinks);} // finalize the planOptimizedPlan plan = new PlanFinalizer().createFinalPlan(bestPlanSinks, program.getJobName(), program);plan.accept(new BinaryUnionReplacer()); plan.accept(new RangePartitionRewriter(plan)); // post pass the plan. this is the phase where the serialization and comparator code is setpostPasser.postPass(plan);</code></pre><p>到此為止，已經生成了一個OptimizedPlan，通過OptimizedPlan就可以生成我們需要的JobGraph了。</p><p><strong>生成JobGraph</strong></p><p>JobGraph是JobManager能夠接收的Job的數據結構，是一種Low-Level的數據流DAG表現形式，它定義了Job範圍內（Job-wide）的一些設置。生成JobGraph的主流程，代碼如下所示：</p><pre><code>private JobGraph compilePlan(Plan plan, Configuration optimizerConfiguration) {    Optimizer optimizer = new Optimizer(new DataStatistics(), optimizerConfiguration);    OptimizedPlan optimizedPlan = optimizer.compile(plan);    JobGraphGenerator jobGraphGenerator = new JobGraphGenerator(optimizerConfiguration);    return jobGraphGenerator.compileJobGraph(optimizedPlan, plan.getJobId());}</code></pre><p>組成JobGraph計算圖拓撲中，最核心的兩個數據結構為JobVertex和IntermediateDataSet。其中，JobVertex是對計算邏輯單元的抽象，它通過設置invokableClassName屬性來表示，它必須是AbstractInvokable類的具體實現類，能夠直接在TaskManager上通過反射生成AbstractInvokable對象，然後調用其invoke()方法執行該Task對應的處理邏輯，比如，批處理Job使用的是具體實現BatchTask。IntermediateDataSet是一個Operator執行後產生的中間結果集的抽象，也包括一個DataSource對應的數據集，它能夠被其他Operator讀取、物化（Materialized），甚至丟棄。</p><p>本文作者來自時延軍，原文點擊瞭解更多↓↓↓</p><p><strong>感謝大家支持，多多轉發關注不迷路~~~~~</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>大數據</a></li><li><a>專家</a></li><li><a>Flink</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c08f7fcf.html alt=寶信軟件：公司聚焦大數據、人工智能、虛擬製造等七大關鍵技術的研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c08f7fcf.html title=寶信軟件：公司聚焦大數據、人工智能、虛擬製造等七大關鍵技術的研究>寶信軟件：公司聚焦大數據、人工智能、虛擬製造等七大關鍵技術的研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/848a087b.html alt="「百位專家談中國製度」國家監察體制改革：以法律為硬槓槓 扎牢制度的籠子" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/848a087b.html title="「百位專家談中國製度」國家監察體制改革：以法律為硬槓槓 扎牢制度的籠子">「百位專家談中國製度」國家監察體制改革：以法律為硬槓槓 扎牢制度的籠子</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385506dd.html alt=專家：買房時一定要分清層高和淨高，最佳層高？購房者入住不後悔 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/b7b94ebb-4938-423d-8106-e3b030bcd12e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385506dd.html title=專家：買房時一定要分清層高和淨高，最佳層高？購房者入住不後悔>專家：買房時一定要分清層高和淨高，最佳層高？購房者入住不後悔</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6209a18d.html alt=日本自然養生專家推薦：身體柔軟壽命長！身體變軟的四個祕訣！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/18aa0007361f7b6ea86d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6209a18d.html title=日本自然養生專家推薦：身體柔軟壽命長！身體變軟的四個祕訣！>日本自然養生專家推薦：身體柔軟壽命長！身體變軟的四個祕訣！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/413f46d7.html alt=這類房子值得警惕？專家：謹慎購買 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/91932a47-8406-4bcf-a396-832cae0f8574 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/413f46d7.html title=這類房子值得警惕？專家：謹慎購買>這類房子值得警惕？專家：謹慎購買</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed99f279.html alt=美軍航母完成159天部署，返回日本橫須賀，專家：威脅不會消停 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1f3b65702078424186c654edf8612984 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed99f279.html title=美軍航母完成159天部署，返回日本橫須賀，專家：威脅不會消停>美軍航母完成159天部署，返回日本橫須賀，專家：威脅不會消停</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4740e709.html alt=美軍航母返回日本，重型無人機戰鬥逼近，專家：丟掉幻想準備打仗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/fde62c4d13084f6a93cd6928c979e424 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4740e709.html title=美軍航母返回日本，重型無人機戰鬥逼近，專家：丟掉幻想準備打仗>美軍航母返回日本，重型無人機戰鬥逼近，專家：丟掉幻想準備打仗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91d64d87.html alt=專家點評Nature丨你的情緒信號或可印記到組蛋白上——首次報道組蛋白五羥色胺化修飾及其生物學功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RLEDa3yDZw3fDG style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91d64d87.html title=專家點評Nature丨你的情緒信號或可印記到組蛋白上——首次報道組蛋白五羥色胺化修飾及其生物學功能>專家點評Nature丨你的情緒信號或可印記到組蛋白上——首次報道組蛋白五羥色胺化修飾及其生物學功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/40f2728c.html alt="青島華仁立交橋變形了？專家迴應：橋樑正常 僅為視覺誤差" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S5bxGnIByoLBnf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/40f2728c.html title="青島華仁立交橋變形了？專家迴應：橋樑正常 僅為視覺誤差">青島華仁立交橋變形了？專家迴應：橋樑正常 僅為視覺誤差</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a7ad4761.html alt=大數據統計：80%癌症術後3年復發轉移，療法替癌患擋過“生死劫” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/401e795037ab41d5a2481e58bccf0d23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a7ad4761.html title=大數據統計：80%癌症術後3年復發轉移，療法替癌患擋過“生死劫”>大數據統計：80%癌症術後3年復發轉移，療法替癌患擋過“生死劫”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/85f1b34e.html alt=【專家建言】關於對當前危機的研判及對策建議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fc020dcaf8a444cc9a1285abae2f57b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/85f1b34e.html title=【專家建言】關於對當前危機的研判及對策建議>【專家建言】關於對當前危機的研判及對策建議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/70f3ad5e.html alt=骨科專家詳解：力學刺激與半月板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9e4f8f70a5ee4c75b501abe66ff2f3b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/70f3ad5e.html title=骨科專家詳解：力學刺激與半月板>骨科專家詳解：力學刺激與半月板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35db2356.html alt="大數據深度學習的新利器: 快速神經網絡訓練:P-network" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d172925963f2465aa131058c05cd72f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35db2356.html title="大數據深度學習的新利器: 快速神經網絡訓練:P-network">大數據深度學習的新利器: 快速神經網絡訓練:P-network</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04338c15.html alt="平臺與商家連麥演戲賣次品 專家建議適時修改廣告法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04338c15.html title="平臺與商家連麥演戲賣次品 專家建議適時修改廣告法">平臺與商家連麥演戲賣次品 專家建議適時修改廣告法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2509e623.html alt=什麼是大數據知識工程？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/85164f0582334f6abca0e4421db5dbd1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2509e623.html title=什麼是大數據知識工程？>什麼是大數據知識工程？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>