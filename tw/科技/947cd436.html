<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring Security OAuth2 入門 | 极客快訊</title><meta property="og:title" content="Spring Security OAuth2 入門 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/30b7584056744a0eb2d53d1f039f7bb7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/947cd436.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><meta property="article:published_time" content="2020-11-14T21:00:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:29+08:00"><meta name=Keywords content><meta name=description content="Spring Security OAuth2 入門"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/947cd436.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring Security OAuth2 入門</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><ul><li>1. 概述</li><li>2. 引入 Spring Security OAuth2 依賴</li><li>3. 配置資源服務器</li><li>4. 配置授權服務器</li><li class=ql-indent-1>4.1 授權碼模式</li><li>Spring Security Setting</li><li class=ql-indent-1>4.2 密碼模式</li><li class=ql-indent-1>4.3 簡化模式</li><li class=ql-indent-1>4.4 客戶端模式</li><li class=ql-indent-1>4.5 如何選擇？</li><li class=ql-indent-1>4.6 為什麼有 Client 編號和密碼</li><li>5. 刷新令牌</li><li class=ql-indent-1>5.1 獲取刷新令牌</li><li class=ql-indent-1>5.2 “刷新”訪問令牌</li><li class=ql-indent-1>5.3 為什麼需要有刷新令牌</li><li>6. 刪除令牌</li><li class=ql-indent-1>6.1 刪除訪問令牌</li><li class=ql-indent-1>6.2 刪除刷新令牌</li><li class=ql-indent-1>6.3 RFC7009 - OAuth2 Token Revocation</li><li>7. 令牌元數據</li><li>666. 彩蛋</li></ul><hr><h1><strong>1. 概述</strong></h1><p>本文，我們來入門 Spring Security OAuth2.0 的使用。通過本文，希望你對 OAuth2.0 有一次身臨其境的感受。</p><p>另外，這是一篇入門的文章，所以實際場景下，需要做一些微調。當然，需要微調的地方，筆者會在示例中說明，以免誤導。</p><p>如果你是 OAuth2.0 的萌新，建議先通讀阮一峰大神的 《理解OAuth 2.0》。因為，本文不會去闡述 OAuth2.0 概念部分的內容。或者，也可以看看 《OAuth 2.0最簡嚮導》 ，比較生動形象。</p><p>閱讀完本文後，你想要更加深入的理解 OAuth2.0 ，可以閱讀如下兩本書籍：</p><ul><li>《OAuth2 in Action》 重原理</li><li>《OAuth2 2.0 Cookbook》 重實踐，基於 Spring Security OAuth2 。</li></ul><p>閱讀完本文後，你想要了解源碼，可以閱讀老徐的兩篇文章：</p><ul><li>《Re：從零開始的Spring Security OAuth2（二）》</li><li>《Re：從零開始的Spring Security OAuth2（三）》</li></ul><hr><p>OK，一波安利之後，我們來一起進入正文。對於 Spring Security OAuth2 的配置，大體來說，就是<strong>兩步</strong>：</p><ol><li>配置授權服務器( AuthorizationServer )</li><li>配置資源服務器( ResourceServer )</li></ol><h1><strong>2. 引入 Spring Security OAuth2 依賴</strong></h1><p>在 pom.xml 文件中，引入如下:</p><pre>&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.16.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- for Spring MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- for Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- for OAuth 2.0 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;</pre><p>因為，我們使用的是 SpringBoot 的版本為 1.5.16.RELEASE ，所以使用的 Spring Security 的版本為 4.2.8.RELEASE ，Spring Security OAuth2 的版本為 2.2.0.15.RELEASE 。</p><h1><strong>3. 配置資源服務器</strong></h1><p>一般情況下，資源服務器指的是，我們提供 API 的應用或服務。例如，訂單服務、商品服務。<strong>考慮到讓整個示例更加簡單，本文先將它和授權服務器放在一個 Maven 項目中</strong>。</p><p>① 創建一個 Controller 類</p><pre>/** * 示例模塊 Controller */@RestController@RequestMapping("/api/example")public class ExampleController { @RequestMapping("/hello") public String hello() { return "world"; }}</pre><ul><li>非常簡單，這是一個示例模塊的 Controller ，提供 /api/example/hello 接口。</li></ul><p>② 配置資源服務器</p><pre>// 資源服務配置@Configuration@EnableResourceServerpublic class OAuth2ResourceServer extends ResourceServerConfigurerAdapter { @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // 對 "/api/**" 開啟認證 .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers("/api/**"); }}</pre><ul><li>@Configuration 註解，保證 OAuth2ResourceServer 能夠被 SpringBoot 掃描到配置。</li><li>@EnableResourceServer 註解，開啟資源服務器。</li><li>繼承( extends ) ResourceServerConfigurerAdapter 類，並覆寫 #configure(HttpSecurity http) 方法，配置對 HTTP 請求中，匹配 /api/**" 路徑，開啟認證的驗證。</li></ul><h1><strong>4. 配置授權服務器</strong></h1><p>在 OAuth2.0 中，定義了<strong>四種</strong>授權模式：</p><ul><li>授權碼模式( authorization code )</li><li>密碼模式( resource owner password credentials )</li><li>簡化模式( implicit )</li><li>客戶端模式( client credentials )</li></ul><p>所以，筆者在 SpringBoot-Labs/lab-02 目錄下，每一種方式，都提供了一個 Maven 項目示例。</p><p><strong>4.1 授權碼模式</strong></p><p>Maven 項目結構如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30b7584056744a0eb2d53d1f039f7bb7><p class=pgc-img-caption></p></div><p>Maven 項目結構</p><p>對應 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-02/authorization-code-server</p><p>① 配置授權服務器</p><pre>// 授權服務器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() // &lt;1&gt; // &lt;2&gt; begin ... .withClient("clientapp").secret("112233") // Client 賬號、密碼。 .redirectUris("http://localhost:9001/callback") // 配置回調地址，選填。 .authorizedGrantTypes("authorization_code") // 授權碼模式 .scopes("read_userinfo", "read_contacts") // 可授權的 Scope // &lt;2&gt; end ...// .and().withClient() // 可以繼續配置新的 Client // &lt;3&gt; ; }}</pre><ul><li>@Configuration 註解，保證 OAuth2AuthorizationServer 能夠被 SpringBoot 掃描到配置。</li><li>@EnableAuthorizationServer 註解，開啟授權服務器。</li><li>&lt;1> 處，基於內存，為了方便測試。實際情況下，最好放入<strong>數據庫</strong>中，方便管理。</li><li>&lt;2> 處，創建一個 Client 配置。</li><li>&lt;3> 處，可以使用 #and() 方法，繼續添加另外的 Client 配置。</li></ul><p>② 配置登陸賬號</p><p>創建 application.properties 文件，並配置如下：</p><pre># Spring Security Settingsecurity.user.name=yunaisecurity.user.password=1024</pre><ul><li>這裡配置了一個賬號為 "yunai" ，密碼為 "1024" 的登陸賬戶。</li><li>實際生產環境下，登陸賬號的數據，肯定是放在<strong>數據庫</strong>中。</li></ul><p>③ 啟動項目</p><pre>@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }}</pre><p>啟動項目</p><p>④ 獲取授權碼</p><p>4.1 瀏覽器打開 http://localhost:8080/oauth/authorize?client_id=clientapp&redirect_uri=http://localhost:9001/callback&response_type=code&scope=read_userinfo</p><ul><li>client_id 參數，<strong>必傳</strong>，為我們在 OAuth2AuthorizationServer 中配置的 Client 的編號。</li><li>redirect_url 參數，<strong>可選</strong>，回調地址。當然，如果 client_id 對應的 Client 未配置 redirectUris 屬性，會報錯。</li><li>response_type 參數，<strong>必傳</strong>，返回結果為<strong>授權碼</strong>。</li><li>scope 參數，<strong>可選</strong>，申請授權的 Scope 。如果多個，使用逗號分隔。</li><li>state 參數，<strong>可選</strong>，表示客戶端的當前狀態，可以指定任意值，認證服務器會原封不動地返回這個值。</li><li class=ql-indent-1><em>未在上述 URL 中體現出來</em>。</li></ul><p>4.2 瀏覽器打開後，效果如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2c0398b6bfa446ad8f35c8a8cff08e0c><p class=pgc-img-caption></p></div><p>瀏覽器</p><ul><li>輸入在 「② 配置登陸賬號」 中配置的登陸賬號 "yunai" / "1024" 。</li><li>實際生產情況下，我們以 QQ 三方登陸作為例子，如下圖：</li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0e54b12c8993489e9b338e0ec9cdbfbb><p class=pgc-img-caption></p></div><ul><li>QQ 示例</li></ul><p>4.3 登陸成功，選擇允許所有申請的 Scope ，點擊【Authorize】按鈕，確認授權。如下圖：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d74dc322da1462fa716502d32d37942><p class=pgc-img-caption></p></div><p>Authorize</p><p>4.4 授權完成，回調 redirect_uri 地址。如下圖所示：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/583e98bb10534b13b4b33a404d7d6a91><p class=pgc-img-caption></p></div><p>回調地址</p><ul><li>code 參數，就是返回的授權碼。</li></ul><p>⑤ 獲取訪問令牌</p><pre>curl -X POST --user clientapp:112233 http://localhost:8080/oauth/token -H "content-type: application/x-www-form-urlencoded" -d "code=UydkmV&amp;grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9001%2Fcallback&amp;scope=read_userinfo"</pre><ul><li>--user clientapp:112233 處，填寫我們在 OAuth2AuthorizationServer 中配置的 Client 的編號和密碼。</li><li>code=UydkmV 處，填寫在 「④ 獲取授權碼」 中獲取的授權碼( code ) 。</li></ul><p>返回結果示例如下：</p><pre>{ "access_token": "e60e41f2-2ad0-4c79-97d5-49af38e5c2e8",  "token_type": "bearer",  "expires_in": 43199,  "scope": "read_userinfo"}</pre><ul><li>access_token 屬性，訪問令牌。<strong>非空</strong>。</li><li>token_type 屬性，令牌類型，可以是 "bearer" 或 "mac" 類型。<strong>非空</strong>。</li><li>expires_in 屬性，過期時間，單位為秒。一般情況下，非空。</li><li>scope 屬性，權限範圍。如果與 Client 申請的範圍一致，此項可省略。</li><li>refresh_token 屬性，刷新令牌，用來獲取下一次的訪問令牌。</li><li class=ql-indent-1>在授權碼模式下，<strong>允許為空</strong>。</li></ul><p>可能有部分胖友是 Windows 電腦，可以參考 《windows（64位）下使用 curl 命令》 來安裝一個 curl 命令。</p><p>當然，如果胖友使用 Postman ，可以參看如下兩圖：</p><ul><li><br></li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ac0e54ab22eb41ddae5c3dc910be6adb><p class=pgc-img-caption></p></div><ul><li>圖 1</li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/db6f5dd8b9654d82978837aa59292829><p class=pgc-img-caption></p></div><ul><li>圖 2</li></ul><p>⑥ 調用資源服務器的 API</p><pre>curl -X GET http://localhost:8080/api/example/hello -H "authorization: Bearer e60e41f2-2ad0-4c79-97d5-49af38e5c2e8"</pre><ul><li>authorization: Bearer e60e41f2-2ad0-4c79-97d5-49af38e5c2e8 處，填寫指定的訪問令牌類型和訪問令牌。例如此處分別為，"Bearer"、"e60e41f2-2ad0-4c79-97d5-49af38e5c2e8" 。</li></ul><p>如果胖友使用 Postman ，可以參看如下圖：</p><ul><li><br></li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1cf8acd198fa4fa0a6879e1f7fe0a231><p class=pgc-img-caption></p></div><ul><li>圖</li></ul><p><strong>4.2 密碼模式</strong></p><p>Maven 項目結構如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/805fda53fe80438d9185ed53ec3f9ee1><p class=pgc-img-caption></p></div><p>Maven 項目結構</p><p>對應 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/f8d701cbd9b2a4f2cee3a7f2186148bcdf859895/lab-02/resource-owner-password-credentials-server</p><p>① 配置授權服務器</p><pre>// 授權服務器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { // 用戶認證 @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 賬號、密碼。 .authorizedGrantTypes("password") // 密碼模式 .scopes("read_userinfo", "read_contacts") // 可授權的 Scope// .and().withClient() // 可以繼續配置新的 Client ; }}</pre><ul><li>配置 Client 的方式，和【授權碼模式】基本一致。差別在於：</li><li class=ql-indent-1>無需配置 `redirectUris` 屬性，因為不需要回調地址。</li><li class=ql-indent-1>配置授權模式為【<strong>密碼模式</strong>】。</li><li>另外，需要引入 <strong>AuthenticationManager</strong> 來支持【密碼模式】，否則會報 "Resolved [error="unsupported_grant_type", error_description="Unsupported grant type: password"]" 異常。</li></ul><p>② 配置登陸賬號</p><p>和【授權碼模式】<strong>一致</strong>。</p><p>③ 啟動項目</p><p>和【授權碼模式】<strong>一致</strong>。</p><p>④ 獲取訪問令牌</p><pre>curl -X POST --user clientapp:112233 http://localhost:8080/oauth/token -H "accept: application/json" -H "content-type: application/x-www-form-urlencoded" -d "grant_type=password&amp;username=yunai&amp;password=1024&amp;scope=read_userinfo"</pre><ul><li>和【授權碼模式】差異比較大。</li><li>直接請求 oauth/token 接口，獲得訪問令牌。</li><li>請求參數帶上了 username 和 password ，就用戶的登陸賬號和密碼。</li><li>請求參數 grant_type 為 password ，表示【密碼模式】。</li></ul><p>返回結果示例如下：</p><pre>{ "access_token": "68de6eb9-5672-4e47-a3e6-110404285ba9", "token_type": "bearer", "expires_in": 43199, "scope": "read_userinfo"}</pre><ul><li>和【授權碼模式】一致。</li></ul><p>⑤ 調用資源服務器的 API</p><p>和【授權碼模式】<strong>一致</strong>。</p><p><strong>4.3 簡化模式</strong></p><p>Maven 項目結構如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/07b3cdb156354222bf76ff9c252080e4><p class=pgc-img-caption></p></div><p>Maven 項目結構</p><p>對應 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/f8d701cbd9b2a4f2cee3a7f2186148bcdf859895/lab-02/implicit-server</p><p>① 配置授權服務器</p><pre>// 授權服務器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 賬號、密碼。 .redirectUris("http://localhost:9001/callback") // 配置回調地址，選填。 .authorizedGrantTypes("implicit") // 授權碼模式 .scopes("read_userinfo", "read_contacts") // 可授權的 Scope// .and().withClient() // 可以繼續配置新的 Client ; }}</pre><ul><li>和【授權碼模式】基本一致。差別<strong>僅僅</strong>在於：配置授權模式為【簡化模式】。</li></ul><blockquote><p>FROM 《理解 OAuth 2.0》</p><p>簡化模式（implicit grant type）不通過第三方應用程序的服務器，直接在瀏覽器中向認證服務器申請令牌，跳過了"授權碼"這個步驟，因此得名。所有步驟在瀏覽器中完成，令牌對訪問者是可見的，且客戶端不需要認證。</p></blockquote><p>② 配置登陸賬號</p><p>和【授權碼模式】一致。</p><p>③ 啟動項目</p><p>和【授權碼模式】一致。</p><p>④ 獲取授權碼</p><p>4.1 瀏覽器打開 http://localhost:8080/oauth/authorize?client_id=clientapp&redirect_uri=http://localhost:9001/callback&response_type=implicit&scope=read_userinfo</p><ul><li>和【授權碼模式】基本一致。差別<strong>僅僅</strong>在於：請求參數 response_type 為 "implicit" 簡化模式。</li></ul><p>4.2 瀏覽器打開後，效果如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e12f36b8e90249cfb2ae9ea547800601><p class=pgc-img-caption></p></div><p>瀏覽器</p><ul><li>和【授權碼模式】基本一致，輸入在 「② 配置登陸賬號」 中配置的登陸賬號 "yunai" / "1024" 。</li></ul><p>4.3 登陸成功，直接授權完成，回調 redirect_uri 地址。如下圖所示：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0fd5174469084e718cfe845c9131b93e><p class=pgc-img-caption></p></div><p>瀏覽器</p><ul><li>和【授權碼模式】基本不一致的有<strong>兩點</strong>：</li><li class=ql-indent-1>登陸成功後，<strong>無需</strong>選擇允許所有申請的 Scope ，直接授權完成。</li><li class=ql-indent-1>返回的不是授權碼，而是<strong>訪問令牌</strong>。</li></ul><blockquote><p>總的來說，【簡化模式】是【授權碼模式】的簡化模式。</p></blockquote><p>⑤ 調用資源服務器的 API</p><p>和【授權碼模式】一致。</p><p><strong>4.4 客戶端模式</strong></p><p>Maven 項目結構如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/642724b17b7f416daebf5f9273ad8640><p class=pgc-img-caption></p></div><p>Maven 項目結構</p><p>對應 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/f8d701cbd9b2a4f2cee3a7f2186148bcdf859895/lab-02/client-credentials-server</p><p>① 配置授權服務器</p><p>和【密碼模式】一致。</p><p>② 配置登陸賬號</p><p>它<strong>無需</strong>配置登陸賬號。因為它沒有用戶的概念，直接與授權服務器交互，通過 Client 的編號( client_id )和密碼( client_secret )來保證安全性。</p><p>③ 啟動項目</p><p>和【密碼模式】一致。</p><p>④ 獲取訪問令牌</p><pre>curl -X POST "http://localhost:8080/oauth/token" --user clientapp:112233 -d "grant_type=client_credentials&amp;scope=read_contacts"</pre><ul><li>和【密碼模式】基本一致，差別如下：</li><li class=ql-indent-1>請求參數<strong>無需</strong>帶上了 `username` 和 `password` 。</li><li class=ql-indent-1>請求參數 `grant_type` 為 `client_credentials` ，表示【密碼模式】。</li></ul><p>返回結果示例如下：</p><pre>{ "access_token":"cb2bdfd8-18fa-4b8f-b525-10587bd672e8", "token_type":"bearer", "expires_in":43199, "scope":"read_contacts"}</pre><ul><li>和【密碼模式】一致。</li></ul><p>⑤ 調用資源服務器的 API</p><p>和【密碼模式】<strong>一致</strong>。</p><blockquote><p>總的來說，【客戶端模式】是【密碼模式】的簡化模式。</p></blockquote><p><strong>4.5 如何選擇？</strong></p><p>可能很多胖友，有跟筆者一樣的困惑。下面筆者引用楊波老師的一張圖，相信能解決我們的困擾。如下圖所示：</p><blockquote><p>FROM 《深度剖析 OAuth2 和微服務安全架構》</p></blockquote><div class=pgc-img><img alt="Spring Security OAuth2 入門" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7509a1cd750a40319046830196d1ef53><p class=pgc-img-caption></p></div><blockquote><p>授權類型選擇</p></blockquote><p>當然，對於<strong>黃框</strong>部分，對於筆者還是比較困惑的。筆者認為，第三方的單頁應用 SPA ，也是適合採用 Authorization Code Grant 授權模式的。例如，《微信網頁授權》 ：</p><blockquote><p>具體而言，網頁授權流程分為四步：</p><p>1、引導用戶進入授權頁面同意授權，獲取code</p><p>2、通過code換取網頁授權access_token（與基礎支持中的access_token不同）</p><p>3、如果需要，開發者可以刷新網頁授權access_token，避免過期</p><p>4、通過網頁授權access_token和openid獲取用戶基本信息（支持UnionID機制）</p></blockquote><p>所以，筆者猜測，之所以圖中畫的是 Implicit Grant 的原因是，受 Google 的 《OAuth 2.0 for Client-side Web Applications》 一文中，推薦使用了 Implicit Grant 。</p><p>當然，具體使用 Implicit Grant 還是 Authorization Code Grant 授權模式，沒有定論。筆者，偏向於使用 <strong>Authorization Code Grant</strong>，對於第三方客戶端的場景。</p><p><strong>4.6 為什麼有 Client 編號和密碼</strong></p><p>我們看到上述四種授權模式，無論是哪一種，最終調用授權服務器時，都會傳遞 Client 編號和密碼，這是為什麼呢？通過 Client 編號和密碼，授權服務器可以知道調用的來源以及正確性。這樣，即使“壞人”拿到 Access Token ，但是沒有 Client 編號和密碼，也不能和授權服務器發生<strong>有效</strong>的交互。</p><h1><strong>5. 刷新令牌</strong></h1><p>在 「4. 配置授權服務器」 中，我們一直沒有看到我們期盼的刷新令牌( refresh token )的身影。這是為什麼呢？因為我們在配置 Spring Security OAuth2 並未配置，獲取訪問令牌的同時，獲取刷新令牌。</p><p>那麼，怎麼配置開啟獲取刷新令牌的功能呢？我們來看看 「5.1 獲取刷新令牌」 。</p><p><strong>5.1 獲取刷新令牌</strong></p><p>因為【密碼模式】相對簡單，我們直接在原有程序上做改造。對應 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-02/authorization-code-server-with-refresh-token 。</p><blockquote><p>在步驟上，如果和原有【密碼模式】保持一致的地方，下文會進行省略，並標註“和原有<strong>一致</strong>”。</p></blockquote><p>① 配置授權服務器</p><pre>// 授權服務器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { // 用戶認證 @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 賬號、密碼。 .authorizedGrantTypes("password", "refresh_token") // 密碼模式 // &lt;1&gt; .scopes("read_userinfo", "read_contacts") // 可授權的 Scope// .and().withClient() // 可以繼續配置新的 Client ; }}</pre><ul><li>在 &lt;1> 處，我們很神奇的多配置了一個 "refresh_token" ，用於開啟獲取刷新令牌的功能。但是但是但是，OAuth2 的授權模式說好的是四種的麼，怎麼又出現了 "refresh_token" 這種授權模式？淡定，在 Spring Security OAtuh2 中，"refresh_token" 作為一種特殊的授權模式<strong>配置</strong>，用於開啟獲取刷新令牌的功能。所以，其它授權模式如果開啟獲取刷新令牌的功能，需要在 #authorizedGrantTypes(…) 設置時，多傳入 "refresh_token" 方法參數。</li></ul><p>② 配置登陸賬號</p><p>和原有<strong>一致</strong>。</p><p>③ 啟動項目</p><p>和原有<strong>一致</strong>。</p><p>④ 獲取訪問令牌</p><pre>curl -X POST --user clientapp:112233 http://localhost:8080/oauth/token -H "accept: application/json" -H "content-type: application/x-www-form-urlencoded" -d "grant_type=password&amp;username=yunai&amp;password=1024&amp;scope=read_userinfo"</pre><ul><li>和原有<strong>一致</strong>。</li></ul><p>返回結果示例如下：</p><pre>{ "access_token":"092a2286-04e7-4e7d-8c20-19fbe25865ff", "token_type":"bearer", "refresh_token":"afeeb083-997f-4ea8-9334-aab6c1696cca", "expires_in":43199, "scope":"read_userinfo"}</pre><ul><li>在原有的基礎上，<strong>多</strong>返回了 "refresh_token" 刷新令牌。美滋滋。</li></ul><p>⑤ 調用資源服務器的 API</p><p>和原有<strong>一致</strong>。</p><p><strong>5.2 “刷新”訪問令牌</strong></p><p>因為訪問訪問令牌會自動過期，通過使用刷新令牌，可以獲得<strong>新的</strong>訪問令牌。注意，訪問令牌獲取到的是<strong>新的</strong>，不是老的哈。這也是為什麼，在標題上，筆者對<strong>刷新</strong>加了雙引號。</p><pre>curl -i -X POST -u 'clientapp:112233' http://localhost:8080/oauth/token -H "accept: application/json" -d 'grant_type=refresh_token&amp;refresh_token=afeeb083-997f-4ea8-9334-aab6c1696cca'</pre><ul><li>調用接口還是 "oauth/token" ，差別在於傳入的請求參數 grant_type 為 "refresh_token"，使用刷新令牌。</li><li>請求參數 refresh_token 為上面獲取到的刷新令牌 "afeeb083-997f-4ea8-9334-aab6c1696cca" 。</li></ul><p>返回結果示例如下：</p><pre>{ "access_token":"507eb761-4b25-4159-b927-ef3eff5e7eff", "token_type":"bearer", "refresh_token":"afeeb083-997f-4ea8-9334-aab6c1696cca", "expires_in":43199, "scope":"read_userinfo"}</pre><ul><li>獲得的訪問令牌為 "507eb761-4b25-4159-b927-ef3eff5e7eff" ，是<strong>新的</strong>。並且，過期時間也變成<strong>新的</strong>。</li></ul><hr><p>筆者在看 OAuth2.0 的刷新令牌時，一直有個疑惑：刷新令牌是否有過期時間？答案是，<strong>有</strong>。但是，筆者不太確定，在 Spring Security OAuth2 中，如果不設置刷新令牌的過期時間，刷新時間是否<strong>無限長</strong>？當然，這個貌似也並不重要。因為，在實際使用中，我們肯定是需要顯示( 主動 )設置刷新令牌的過期時間，使用 ClientBuilder#refreshTokenValiditySeconds(int refreshTokenValiditySeconds) 方法，示例如下：</p><pre>@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 賬號、密碼。 .authorizedGrantTypes("password", "refresh_token") // 密碼模式 .scopes("read_userinfo", "read_contacts") // 可授權的 Scope .refreshTokenValiditySeconds(1200) // 1200 秒過期// .and().withClient() // 可以繼續配置新的 Client ;}</pre><p>刷新令牌過期時，返回結果示例如下：</p><pre>{ "error":"invalid_token", "error_description":"Invalid refresh token (expired): 7139d075-c4ea-48f0-9dbb-6f65fa6dbeb0"}</pre><ul><li>如果胖友要測試這個效果，可以把刷新令牌過期時間設置為 1 秒。</li></ul><p><strong>5.3 為什麼需要有刷新令牌</strong></p><p>出於<strong>安全性</strong>的考慮，訪問令牌的過期時間比較短，刷新令牌的過期時間比較長。這樣，如果訪問令牌即使被盜用走，那麼在一定的時間後，訪問令牌也能在較短的時間吼過期。當然，安全也是相對的，如果使用刷新令牌後，獲取到新的訪問令牌，訪問令牌<strong>後續</strong>又<strong>可能</strong>被盜用。</p><p>另外，刷新令牌是可選項，不一定會返回。</p><p>筆者整理了下，大家常用開放平臺的令牌過期時間，讓大家更好的理解：</p><ul><li>小米開放平臺</li><li class=ql-indent-1>《Access Token 生命週期》</li><li class=ql-indent-1>Access Token ：90 天有效期</li><li class=ql-indent-1>Refresh Token ：10 年有效期</li><li>微信開放平臺</li><li class=ql-indent-1>《網站應用微信登錄開發指南》</li><li class=ql-indent-1>Access Token ：2 小時有效期</li><li class=ql-indent-1>Refresh Token ：未知有效期</li><li>騰訊開放平臺</li><li class=ql-indent-1>《獲取 Access_Token》</li><li class=ql-indent-1>Access Token ：90 天有效期</li><li class=ql-indent-1>Refresh Token ：未知有效期</li></ul><h1><strong>6. 刪除令牌</strong></h1><p>實際在 OAuth2 時，有刪除訪問令牌和刷新令牌的需求。例如：用戶登出系統。雖然說，可以通過客戶端<strong>本地</strong>刪除令牌的方式實現。但是，考慮到真正的徹底的實現刪除令牌，必然服務端<strong>自身</strong>需要刪除令牌。</p><p>在 Spring Security OAuth2 中，並沒有提供內置的接口，所以需要自己去實現。筆者參看 《Spring Security OAuth2 – Simple Token Revocation》 文檔，實現刪除令牌的 API 接口。</p><p>因為【密碼模式】相對簡單，我們直接在原有程序上做改造。對應 GitHub 地址： 。注意，如下僅僅是 Demo ，實際生產環境下需要做改造。</p><p><strong>6.1 刪除訪問令牌</strong></p><p>① 新增刪除訪問令牌的 API 接口</p><pre>@Autowiredprivate ConsumerTokenServices tokenServices;@RequestMapping(method = RequestMethod.POST, value = "api/access_token/revoke")public String revokeToken(@RequestParam("token") String token) { tokenServices.revokeToken(token); return token;}</pre><ul><li>使用 ConsumerTokenServices#revokeToken(String tokenValue) 方法，刪除訪問令牌。</li></ul><p><strong>注意</strong>，實際生產環境下，授權服務器和資源服務器是不在一起的，所以此處僅僅是示例。主要是為了介紹 ConsumerTokenServices#revokeToken(String tokenValue) 方法的使用。</p><p>② 訪問刪除訪問令牌的 API 接口。</p><pre>curl -X POST http://localhost:8080/api/access_token/revoke -H "authorization: Bearer 23874e0b-a1d8-4337-9551-7b9be1ebaebe" -d "token=23874e0b-a1d8-4337-9551-7b9be1ebaebe"</pre><p>移除成功後，在使用當前訪問令牌，就會報如下錯誤：</p><pre>{ "error":"invalid_token", "error_description":"Invalid access token: 23874e0b-a1d8-4337-9551-7b9be1ebaebe"}</pre><hr><p>另外，也可以參考 https://github.com/geektime-geekbang/oauth2lab/blob/master/lab05/oauth-server/src/main/java/io/spring2go/config/RevokeTokenEndpoint.java 的實現。</p><p><strong>6.2 刪除刷新令牌</strong></p><p>① 新增刪除訪問令牌的 API 接口</p><pre>@Autowired(required = false) // &lt;1&gt;private TokenStore tokenStore;@RequestMapping(method = RequestMethod.POST, value = "api/refresh_token/revoke")public String revokeRefreshToken(@RequestParam("token") String token) { tokenStore.removeRefreshToken(new DefaultOAuth2RefreshToken(token)); return token;}</pre><ul><li>&lt;1> 處，使用了 required = false 的原因是，本示例並未顯示聲明 TokenStore Bean 對象交給 Spring 管理，所以無法注入。 所以 「6.2 刪除刷新令牌」 是一個無法<strong>跑通</strong>的示例。</li><li>重點在於，調用 TokenStore#removeRefreshToken(OAuth2RefreshToken token) 方法，刪除刷新令牌。</li></ul><p>② 訪問刪除刷新令牌的 API 接口。</p><pre>curl -X POST http://localhost:8080/api/refresh_token/revoke -H "authorization: Bearer 52e85411-ac1d-4844-bf03-cf5633e4eecd" -d "token=ead4734a-ca5c-45bf-ac25-9a92291a9fe1"</pre><p>移除成功後，在使用當前刷新令牌，就會報如下錯誤：</p><pre>{ "error":"invalid_token", "error_description":"Invalid refresh token: ead4734a-ca5c-45bf-ac25-9a92291a9fe1"}</pre><hr><p>另外，也可以參考 https://github.com/geektime-geekbang/oauth2lab/blob/master/lab05/oauth-server/src/main/java/io/spring2go/config/TokenController.java 的實現。</p><p><strong>6.3 RFC7009 - OAuth2 Token Revocation</strong></p><p>在 OAuth2 中，刪除令牌，標準的說法為 OAuth2 Token 撤銷，對應 RFC7009 。感興趣的胖友，可以看看。</p><blockquote><p>FROM 《OAuth2 Token 撤銷（RFC7009 - OAuth2 Token Revocation）》</p></blockquote><p>簡單來說，這個協議規定了一個Authorization server提供一個怎樣的API來供Client撤銷access_token或者refresh_token。</p><p>比如Client發起一個如下的請求：</p><blockquote><p><em>POST /revoke HTTP/1.1</em></p><p><em>Host: server.example.com</em></p><p><em>Content-Type: application/x-www-form-urlencoded</em></p><p><em>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</em></p><p><em>token=45ghiukldjahdnhzdauz&token_type_hint=refresh_token</em></p></blockquote><p>其中各項含義如下：</p><ol><li>/revoke：是Authorization Server需要提供的API地址，Client使用Post方式請求這個地址。</li><li>Content-Type: application/x-www-form-urlencoded：固定此格式。</li><li>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW：訪問受保護資源的授權憑證。</li><li>token：必選，可以是access_token或者refresh_token的內容。</li><li>token_type_hint：可選，表示token的類型，值為”access_token“或者"refresh_token"。</li></ol><p>如果撤銷成功，則返回一個HTTP status code為200的響應就可以了。</p><h1><strong>7. 令牌元數據</strong></h1><blockquote><p>FROM 《OAuth2 Token 元數據（RFC7662 - OAuth2 Token Introspection）》</p></blockquote><p>簡單的總結來說，這個規範是為OAuth2擴展了一個API接口（Introspection Endpoint），讓第三方Client可以查詢上面提到的那些信息（比如，access_token是否還有效，誰頒發的，頒發給誰的，scope又哪些等等的元數據信息）。</p><p>比如Client發起一個如下的請求：</p><blockquote><p><em>POST /introspect HTTP/1.1</em></p><p><em>Host: server.example.com</em></p><p><em>Accept: application/json</em></p><p><em>Content-Type: application/x-www-form-urlencoded</em></p><p><em>Authorization: Bearer 23410913-abewfq.123483</em></p><p><em>token=2YotnFZFEjr1zCsicMWpAA&token_type_hint=access_token</em></p></blockquote><p>看起來和上面的撤銷Token的請求差不多，其中各項含義如下：</p><ol><li>/introspect：是Authorization Server需要提供的API地址，Client使用Post方式請求這個地址。</li><li>Accept:application/json：表示Authorization Server需要返回一個JSON格式的數據。</li><li>Content-Type: application/x-www-form-urlencoded：固定此格式。</li><li>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW：訪問受保護資源的授權憑證。</li><li>token：必選，可以是access_token或者refresh_token的內容。</li><li>token_type_hint：可選，表示token的類型，值為”access_token“或者"refresh_token"。</li></ol><p>如果請求成功，則會返回如下的信息：</p><pre> 1 { 2 "active": true, 3 "client_id": "l238j323ds-23ij4", 4 "token_type":"access_token", 5 "username": "jdoe", 6 "scope": "read write dolphin", 7 "sub": "Z5O3upPC88QrAjx00dis", 8 "aud": "https://protected.example.net/resource", 9 "iss": "https://server.example.com/",10 "exp": 1419356238,11 "iat": 1419350238,12 "nbf": 1419350238,13 "jti": "abcdefg"14 "extension_field": "twenty-seven"15 }</pre><p>JSON各項屬性含義如下（其中有些信息是在JSON Web Token中定義的，參考鏈接有詳細的介紹）:</p><ol><li>active：必須的。表示token是否還是有效的。</li><li>client_id：可選的。表示token所屬的Client。比如上面的<strong>在線打印並且包郵的網站</strong>。</li><li>token_type：可選的。表示token的類型。對應傳遞的token_type_hint。</li><li>user_name：可選的。表示token的授權者的名字。比如上面的<strong>小明</strong>。</li><li>scope：可選的。和上篇5.1.1 Authorization Request中的可選參數scope對應，表示授權給Client訪問的範圍，比如是相冊，而不是小明的日誌以及其他受保護資源。</li><li>sub：可選的。token所屬的資源擁有者的唯一標識，JWT定義的。也就是小明的唯一標識符。</li><li>aud：可選的。token頒發給誰的，JWT定義的。</li><li>iss：可選的。token的頒發者，JWT定義的。</li><li>exp：可選的。token的過期時間，JWT定義的。</li><li>iat：可選的。iss頒發token的時間，JWT定義的。</li><li>nbf：可選的。token不會在這個時間之前被使用，JWT定義的。</li><li>jti：可選的。token的唯一標識，JWT定義的。</li><li>extension_field：可以自己擴展相關其他屬性。</li></ol><p>其中大量的信息都是可選的信息，而且可以自己擴展需要的屬性信息，從這些屬性中就可以解決我們上面提到的access_token對於Client不透明的問題。</p><p>我們注意到其中有很多屬於JWT定義的屬性，那麼這個JWT是什麼東西？它解決了什麼問題？感興趣的胖友，可以看看 《JSON Web Token (JWT)》 。</p><hr><p>對於令牌元數據 API 接口的實現，筆者這裡就暫時不提供。如果有需要的胖友，可以看看 TokenStore 的兩個 API ：</p><ul><li>#readAccessToken(String tokenValue) 方法，讀取指定的訪問令牌的信息。</li><li>#readRefreshToken(String tokenValue) 方法，讀取指定的刷新令牌的信息。</li></ul><h1><strong>666. 彩蛋</strong></h1><p>一萬個注意，本文僅僅是 Spring Security OAuth2 的入門文章。實際生產使用時，還需要做很多事情。例如：</p><ul><li>使用關係數據庫，<strong>持久化</strong>存儲 Client 和令牌信息。例如，使用 JdbcTokenStore 。</li><li>授權服務器和資源服務器分離。例如，使用 RemoteTokenServices 。</li><li>使用緩存服務器，提升 Client 和令牌信息的<strong>訪問</strong>速度。例如，使用 RedisTokenStore 。</li></ul><p>推薦閱讀文章：</p><ul><li>CatalpaFlat 《Spring Security OAuth2 深入解析》</li><li>小東子 《Spring Security OAuth2 開發指南》</li><li>聊聊架構 《輕鬆籌 1.6 億註冊用戶的 Passport 賬戶體系架構設計》</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>Security</a></li><li><a>OAuth2</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/426ce0a.html alt="使用 Spring Security 保護 Web 應用的安全" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/2ec6e597-bd62-4262-b0d9-f76be38ca833 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/426ce0a.html title="使用 Spring Security 保護 Web 應用的安全">使用 Spring Security 保護 Web 應用的安全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html alt=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/433259b5-1936-4cee-ab74-70aef36536ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html title=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理>（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html alt="Spring Boot 統一異常這樣處理和剖析，安否？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/95dd8dbd-33ff-4c32-a4b5-fd78e6126995 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html title="Spring Boot 統一異常這樣處理和剖析，安否？">Spring Boot 統一異常這樣處理和剖析，安否？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dcf7d4b4.html alt="Spring事務失效的 8 大原因，這次可以吊打面試官了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dcf7d4b4.html title="Spring事務失效的 8 大原因，這次可以吊打面試官了">Spring事務失效的 8 大原因，這次可以吊打面試官了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e83df1dd.html alt=Spring切面獲取不到request的參數值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0b6e5064b47940df843a25466066845d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e83df1dd.html title=Spring切面獲取不到request的參數值>Spring切面獲取不到request的參數值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html alt="Spring Boot中文參考指南（2.1.6）90、熱交換" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52221486045249f1a4a361d34e84016e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html title="Spring Boot中文參考指南（2.1.6）90、熱交換">Spring Boot中文參考指南（2.1.6）90、熱交換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html alt="Spring AOP簡介與底層實現機制——動態代理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/413780d1-cf47-4038-9471-b686d97aa99b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html title="Spring AOP簡介與底層實現機制——動態代理">Spring AOP簡介與底層實現機制——動態代理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b564e1e.html alt="Spring boot學習（六）Spring boot實現AOP記錄操作日誌" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6824f504d2264a748492cd7ceb6732ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b564e1e.html title="Spring boot學習（六）Spring boot實現AOP記錄操作日誌">Spring boot學習（六）Spring boot實現AOP記錄操作日誌</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/341006dc.html alt="SpringBoot系列（14）：Spring AOP裝逼指南之實現操作日誌記錄" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7bc702acb84d4284b4df028da09900db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/341006dc.html title="SpringBoot系列（14）：Spring AOP裝逼指南之實現操作日誌記錄">SpringBoot系列（14）：Spring AOP裝逼指南之實現操作日誌記錄</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html alt=Spring框架AOP技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/760bf32faca443cb8e28ed0b9bc20205 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html title=Spring框架AOP技術>Spring框架AOP技術</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>