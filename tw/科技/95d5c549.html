<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++實現二叉樹數據結構 | 极客快訊</title><meta property="og:title" content="C++實現二叉樹數據結構 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/feeddb3a-c96d-44b6-8672-b125cf06a33c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="C++實現二叉樹數據結構"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/95d5c549.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++實現二叉樹數據結構</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>本人從事在線教育c++十年工作經驗現在精心整理了一套從小白到項目實踐開發各種學習資料如果你想學想加入我們請關注我在私信回覆“編程”就可以領取學習資料！！！</p></blockquote><div class=pgc-img><img alt=C++實現二叉樹數據結構 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/feeddb3a-c96d-44b6-8672-b125cf06a33c><p class=pgc-img-caption></p></div><hr><p>本文使用C++實現二叉樹數據結構，與之前實現的向量、列表、棧和隊列不同，樹是一種分層結構，雖然樹是分層結構，但若附加某種約束，如遍歷次序，則樹結構也可以轉變成線性次序，因此樹屬於<strong>半線性結構</strong>。樹結構具有非常多的變種，在算法理論和實際應用中，各種樹結構扮演著最為關鍵的角色。</p><p>另外，<strong>任何有根有序的多叉樹，都能轉變成二叉樹</strong>，因此二叉樹數據結構具有非常重要的地位。</p><p><strong>兩種特殊的二叉樹:完全二叉樹、滿二叉樹</strong></p><p><strong>完全二叉樹: </strong>葉子結點只能出現在最底部的兩層，且最底層葉節點均處於次底層葉節點的左側。</p><p><strong>滿二叉樹: </strong>所有葉節點同處於最底層(非底層節點均為內部結點)。</p><p>二叉樹的實現和列表數據結構有很大的相似性，都需要為相互臨近的節點之間維護正確的指針指向。這裡二叉樹數據結構的實現包括binNode類和binTree類，前者主要描述單個二叉樹的結構和對其的操作，而binTree類主要描述整個二叉樹的結構和對其進行的操作。</p><p>binNode接口列表操作功能對象binNode()默認構造函數 binNode(T e, binNode* p, binNode *lc, binNode *rc, int h)構造函數，設置節點數據，父節點，孩子節點，高度 ~binNode()析構函數 insertAsLC(const T& e)作為本節點的左孩子插入二叉樹節點insertAsRC(const T& e)作為本節點的右孩子插入二叉樹節點succ()定位在中序遍歷中節點v的直接後續二叉樹節點重載運算符==相等判斷運算符二叉樹節點重載運算符&lt;小於運算符二叉樹節點</p><p>binTree接口列表操作功能對象binTree()默認構造函數 ~binTree()析構函數 size()返回二叉樹的規模二叉樹empty()判斷二叉樹是否為空二叉樹root()返回根節點的指針二叉樹insertAsRoot(const T& e)將指定元素作為根節點插入二叉樹insertAsLC(binNode&lt;T>* bn, const T& e)將指定元素插入作為指定節點的左孩子二叉樹insertAsRC(binNode&lt;T>* bn, const T& e)將指定元素插入作為指定節點的右孩子二叉樹attachAsLC(binNode&lt;T>* bn, binTree&lt;T>* &bt)將指定子樹插入作為指定節點的左孩子二叉樹attachAsRC(binNode&lt;T>* bn, binTree&lt;T>* &bt)將指定子樹插入作為指定節點的右孩子二叉樹updateHeight(binNode&lt;T>* bn)更新節點的高度二叉樹updateHeightAbove(binNode&lt;T>* bn)更新此節點祖先節點的高度(插入或刪除節點要執行更新)二叉樹removeAt(binNode&lt;T>* bn)刪除節點bn及其後代，並返回刪掉的二叉樹節點的總數二叉樹remove(binNode&lt;T>* bn)刪除以bn為根節點的子樹二叉樹secede(binNode&lt;T>* bn)子樹分離，將節點bn及其後代從二叉樹中分離出來，然後形成一個獨立的二叉樹二叉樹travPre_R(binNode&lt;T>* bn_r, void(*func)(T& bn))先序遍歷(遞歸版本:簡潔易懂)二叉樹travIn_R(binNode&lt;T>* bn_r, void(*func)(T& bn))中序遍歷(遞歸版本:簡潔易懂)二叉樹travPost_R(binNode&lt;T>* bn_r, void(*func)(T& bn))後序遍歷(遞歸版本:簡潔易懂)二叉樹visitAlongLeftBranch(binNode&lt;T>* bn, void(*func)(T& bn), stack&lt;binNode&lt;T>*> &s)沿著左輪廓線遍歷二叉樹travPre_I(binNode&lt;T>* bn_i, void(*func)(T& bn))先序遍歷(迭代版本:時間、空間複雜度低)二叉樹goAlongLeftBranch(binNode&lt;T>* bn, stack&lt;binNode&lt;T>*> &s)從當前節點開始，沿著左分支深入入棧二叉樹travIn_I(binNode&lt;T>* bn_i, void(*func)(T& bn))中序遍歷(迭代版本:時間、空間複雜度低)二叉樹gotoHLVFL(stack&lt;binNode&lt;T>*> &s)在以s棧頂節點為根的子樹中，找到最高左側可見節點二叉樹travPost_I(binNode&lt;T>* bn_i, void(*func)(T& bn))後序遍歷(迭代版本:時間、空間複雜度低)二叉樹travLevel(binNode&lt;T>* bn_i, void(*func)(T& bn))層次遍歷二叉樹</p><p>(1) binNode.h</p><pre>#pragma once#define stature(p) ((p)?(p)-&gt;height:-1) //宏定義不要忘記帶括號#define NULL 0template&lt;typename T&gt; struct binNode{	//成員變量	T data;	binNode&lt;T&gt; *parent, *lc, *rc; //指向父類，左孩子右孩子的指針	int height; //高度	//構造函數	binNode() :data(NULL), lc(nullptr), rc(nullptr), height(0) {}	binNode(T e, binNode* p = nullptr, binNode *lc = nullptr, binNode *rc = nullptr, int h = 0) :		data(e), parent(p), lc(lc), rc(rc), height(h) {}	//析構函數	~binNode() {} 	//成員函數	binNode&lt;T&gt;* insertAsLC(const T&amp; e); //作為本節點的左孩子插入	binNode&lt;T&gt;* insertAsRC(const T&amp; e); //作為本節點的右孩子插入	int size(); //返回以本節點為root的二叉樹的規模	binNode&lt;T&gt;* succ(); //定位在中序遍歷中節點v的直接後續	//重載運算符	bool operator==(const binNode&lt;T&gt;&amp; bn); //等於運算符	bool operator&lt;(const binNode&lt;T&gt;&amp; bn); //小於運算符}; template&lt;typename T&gt; binNode&lt;T&gt;* binNode&lt;T&gt;::insertAsLC(const T&amp; e){	return lc = new binNode&lt;T&gt;(e, this);} template&lt;typename T&gt; binNode&lt;T&gt;* binNode&lt;T&gt;::insertAsRC(const T&amp; e){	return rc = new binNode&lt;T&gt;(e, this);} template&lt;typename T&gt; int binNode&lt;T&gt;::size(){	int n = 0;	if (lc&amp;&amp;rc)		n = 1 + lc-&gt;size() + rc-&gt;size();	if (lc &amp;&amp; (!rc))		n = 1 + lc-&gt;size();	if ((!lc) &amp;&amp; rc)		n = 1 + rc-&gt;size();	if ((!lc) &amp;&amp; (!rc))		return 1; //遞歸基	return n;} template&lt;typename T&gt; bool binNode&lt;T&gt;::operator==(const binNode&lt;T&gt;&amp; bn){	return data == bn.data;} template&lt;typename T&gt; bool binNode&lt;T&gt;::operator&lt;(const binNode&lt;T&gt;&amp; bn){	return data &lt; bn.data;} template&lt;typename T&gt; binNode&lt;T&gt;* binNode&lt;T&gt;::succ(){	binNode&lt;T&gt;* s = this; //記錄後續的臨時變量	if (rc) //若有右孩子，則直接後繼一定在右子樹中的最左邊	{		s = rc;		while (s-&gt;lc) s = s-&gt;lc;	}	else //若沒有右孩子，則直接後繼是將當前節點包含在左子樹中的最低祖先	{		while ((s-&gt;parent-&gt;lc) != s)			s = s-&gt;parent;		s = s-&gt;parent;	}	return s;}</pre><p>(2) binTree.h</p><pre>#pragma once#include"binNode.h"#include"stack.h"#include"queue.h" #define max(a,b) (((a)&gt;=(b))?(a):(b)) template&lt;typename T&gt; class binTree{protected:	//成員變量	int _size; //二叉樹規模	binNode&lt;T&gt;* _root;//根節點指針 public:	//構造函數	binTree() :_size(0), _root(nullptr) {}		//析構函數	~binTree(); //刪除掉所有的子二叉樹		//成員函數	int size(); //返回二叉樹規模	bool empty(); //判斷二叉樹是否為空 	binNode&lt;T&gt;* root(); //返回根節點的指針	binNode&lt;T&gt;* insertAsRoot(const T&amp; e); //將指定元素插入作為根節點	binNode&lt;T&gt;* insertAsLC(binNode&lt;T&gt;* bn, const T&amp; e); //將指定元素插入作為指定節點的左孩子	binNode&lt;T&gt;* insertAsRC(binNode&lt;T&gt;* bn, const T&amp; e); //將指定元素插入作為指定節點的右孩子	binNode&lt;T&gt;* attachAsLC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt); //將指定子樹插入作為指定節點的左孩子	binNode&lt;T&gt;* attachAsRC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt); //將指定子樹插入作為指定節點的右孩子	int updateHeight(binNode&lt;T&gt;* bn); //更新節點的高度	void updateHeightAbove(binNode&lt;T&gt;* bn); //更新此節點祖先節點的高度(插入或刪除節點要執行更新) 	int removeAt(binNode&lt;T&gt;* bn); //刪除節點bn及其後代，並返回刪掉的二叉樹節點的總數	int remove(binNode&lt;T&gt;* bn); //刪除以bn為根節點的子樹	binTree&lt;T&gt;* secede(binNode&lt;T&gt;* bn); //子樹分離，將節點bn及其後代從二叉樹中分離出來，然後形成一個獨立的二叉樹 	void travPre_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)); //先序遍歷(遞歸版本:簡潔易懂)	void travIn_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)); //中序遍歷(遞歸版本:簡潔易懂)	void travPost_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)); //後序遍歷(遞歸版本:簡潔易懂) 	void visitAlongLeftBranch(binNode&lt;T&gt;* bn, void(*func)(T&amp; bn), stack&lt;binNode&lt;T&gt;*&gt; &amp;s); //沿著左輪廓線遍歷	void travPre_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn));//先序遍歷(迭代版本:時間、空間複雜度低)	void goAlongLeftBranch(binNode&lt;T&gt;* bn, stack&lt;binNode&lt;T&gt;*&gt; &amp;s); //從當前節點開始，沿著左分支深入入棧	void travIn_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn));//中序遍歷(迭代版本:時間、空間複雜度低)	void gotoHLVFL(stack&lt;binNode&lt;T&gt;*&gt; &amp;s); //在以s棧頂節點為根的子樹中，找到最高左側可見節點	void travPost_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn));//後序遍歷(迭代版本:時間、空間複雜度低) 	void travLevel(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)); //層次遍歷 }; template&lt;typename T&gt; binTree&lt;T&gt;::~binTree(){	if (_size)		remove(_root);} template&lt;typename T&gt; int binTree&lt;T&gt;::size(){	return _size;} template&lt;typename T&gt; bool binTree&lt;T&gt;::empty(){	return _root ? true : false;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::root(){	return _root;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::insertAsRoot(const T&amp; e){	if (_root) return nullptr;	_size = 1;	return	_root = new binNode&lt;T&gt;(e);} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::insertAsLC(binNode&lt;T&gt;* bn, const T&amp; e){	if (bn-&gt;lc) return nullptr; //若左孩子已經存在則返回	_size++;	bn-&gt;lc = new binNode&lt;T&gt;(e, bn);	updateHeightAbove(bn-&gt;lc);	return bn-&gt;lc;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::insertAsRC(binNode&lt;T&gt;* bn, const T&amp; e){	if (bn-&gt;rc) return nullptr; //若右孩子已經存在則返回	_size++;	bn-&gt;rc = new binNode&lt;T&gt;(e, bn);	updateHeightAbove(bn-&gt;rc);	return bn-&gt;rc;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::attachAsLC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt){	if (bn-&gt;lc) return nullptr;	bn-&gt;lc = bt-&gt;root();	bt-&gt;root()-&gt;parent = bn;	updateHeightAbove(bn-&gt;lc);	_size += bt-&gt;size();	//釋放bt	bt-&gt;_root = nullptr;	bt-&gt;_size = 0;	//release(bt);	bt = nullptr;	return bn-&gt;lc;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::attachAsRC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt){	if (bn-&gt;rc) return nullptr;	bn-&gt;rc = bt-&gt;root();	bt-&gt;root()-&gt;parent = bn;	updateHeightAbove(bn-&gt;rc);	_size += bt-&gt;size();	//釋放bt	bt-&gt;_root = nullptr;	bt-&gt;_size = 0;	bt = nullptr;	return bn-&gt;rc;} template&lt;typename T&gt; int binTree&lt;T&gt;::updateHeight(binNode&lt;T&gt;* bn){	return bn-&gt;height = (1 + max(stature(bn-&gt;lc), stature(bn-&gt;rc)));} template&lt;typename T&gt; void binTree&lt;T&gt;::updateHeightAbove(binNode&lt;T&gt;* bn){	while (bn)	{		updateHeight(bn);		bn = bn-&gt;parent;	}} template&lt;typename T&gt; int binTree&lt;T&gt;::removeAt(binNode&lt;T&gt;* bn){	int n = 0;	if (bn == nullptr) return 0;	n = 1 + removeAt(bn-&gt;lc) + removeAt(bn-&gt;rc);	delete bn;	return n;} template&lt;typename T&gt; int binTree&lt;T&gt;::remove(binNode&lt;T&gt;* bn) {	if (bn != _root)	{		((bn-&gt;parent-&gt;lc) == bn) ? (bn-&gt;parent-&gt;lc) = nullptr : (bn-&gt;parent-&gt;rc) = nullptr;	}	binNode&lt;T&gt;* bp = bn-&gt;parent;	int n = removeAt(bn);	updateHeightAbove(bp);	_size -= n;	return n;} template&lt;typename T&gt; binTree&lt;T&gt;* binTree&lt;T&gt;::secede(binNode&lt;T&gt;* bn){	//首先清除原二叉樹與待刪除子樹的關聯	if (bn != _root)	{		((bn-&gt;parent-&gt;lc) == bn) ? (bn-&gt;parent-&gt;lc) = nullptr : (bn-&gt;parent-&gt;rc) = nullptr;	}	//更新height	binNode&lt;T&gt;* bp = bn-&gt;parent;	updateHeightAbove(bp); 	//封裝成新二叉樹	binTree&lt;T&gt;* bt = new binTree&lt;T&gt;();	bt-&gt;_root = bn;	bn-&gt;parent = nullptr;	//更新size	bt-&gt;_size = bn-&gt;size();	_size -= bt-&gt;_size; 	//特殊情況處理	if (_root = bn)		_root = nullptr;	return bt;} template&lt;typename T&gt; void binTree&lt;T&gt;::travPre_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)){	if (!bn_r) return;	func(bn_r-&gt;data);	travPre_R(bn_r-&gt;lc, func);	travPre_R(bn_r-&gt;rc, func);}  template&lt;typename T&gt; void binTree&lt;T&gt;::travIn_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)){	if (!bn_r) return;	travIn_R(bn_r-&gt;lc, func);	func(bn_r-&gt;data);	travIn_R(bn_r-&gt;rc, func);}  template&lt;typename T&gt; void binTree&lt;T&gt;::travPost_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)){	if (!bn_r) return;	travPost_R(bn_r-&gt;lc, func);	travPost_R(bn_r-&gt;rc, func);	func(bn_r-&gt;data);} template&lt;typename T&gt; void binTree&lt;T&gt;::visitAlongLeftBranch(binNode&lt;T&gt;* bn, void(*func)(T&amp; bn), stack&lt;binNode&lt;T&gt;*&gt; &amp;s){	while (bn)	{		func(bn-&gt;data);		s.push(bn-&gt;rc); //右孩子入棧		bn = bn-&gt;lc; //沿著左邊沿遍歷	}} template&lt;typename T&gt; void binTree&lt;T&gt;::travPre_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	stack&lt;binNode&lt;T&gt;*&gt; S;	while (true)	{		visitAlongLeftBranch(bn_i, func, S); //遍歷且入棧		if (S.empty()) break;		bn_i = S.pop();	}} template&lt;typename T&gt; void binTree&lt;T&gt;::goAlongLeftBranch(binNode&lt;T&gt;* bn, stack&lt;binNode&lt;T&gt;*&gt; &amp;s){	while (bn)	{		s.push(bn);		bn = bn-&gt;lc;	}} template&lt;typename T&gt; void binTree&lt;T&gt;::travIn_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	stack&lt;binNode&lt;T&gt;*&gt; S;	while (true)	{		goAlongLeftBranch(bn_i, S);		if (S.empty()) break;		bn_i = S.pop();		func(bn_i-&gt;data);		bn_i = bn_i-&gt;rc;	}} template&lt;typename T&gt; void binTree&lt;T&gt;::gotoHLVFL(stack&lt;binNode&lt;T&gt;*&gt; &amp;s){	while (binNode&lt;T&gt;* bn_i = s.top())	{		if (bn_i-&gt;lc)		{			if (bn_i-&gt;rc)				s.push(bn_i-&gt;rc);			s.push(bn_i-&gt;lc);		}		else		{			s.push(bn_i-&gt;rc);		}	}	s.pop();} template&lt;typename T&gt; void binTree&lt;T&gt;::travPost_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	stack&lt;binNode&lt;T&gt;*&gt; S;	if (bn_i)		S.push(bn_i);	while (!S.empty())	{		if (S.top() != bn_i-&gt;parent)			gotoHLVFL(S);		bn_i = S.pop();		func(bn_i-&gt;data);	}}template&lt;typename T&gt; void binTree&lt;T&gt;::travLevel(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	queue&lt;binNode&lt;T&gt;*&gt; q;	q.enqueue(bn_i);	while (!q.empty()) //隊列非空	{		bn_i = q.dequeue();		func(bn_i-&gt;data);		if(bn_i-&gt;lc)			q.enqueue(bn_i-&gt;lc);		if(bn_i-&gt;rc)			q.enqueue(bn_i-&gt;rc);	}}</pre><blockquote><p>本人從事在線教育c++十年工作經驗現在精心整理了一套從小白到項目實踐開發各種學習資料如果你想學想加入我們請關注我在私信回覆“編程”就可以領取學習資料！！！</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>C++</a></li><li><a>實現</a></li><li><a>樹數據</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fde3f58.html alt=C++｜面向對象實現鏈表的創建、遍歷，結點的查找、插入、刪除 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/154010356552484b174b862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fde3f58.html title=C++｜面向對象實現鏈表的創建、遍歷，結點的查找、插入、刪除>C++｜面向對象實現鏈表的創建、遍歷，結點的查找、插入、刪除</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html alt="廣西鐵路出海大通道 全面實現電氣化運營" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html title="廣西鐵路出海大通道 全面實現電氣化運營">廣西鐵路出海大通道 全面實現電氣化運營</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html alt=C++哈希表是如何解決衝突的? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ac4410086e640ea82846bde1dd72c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html title=C++哈希表是如何解決衝突的?>C++哈希表是如何解決衝突的?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>