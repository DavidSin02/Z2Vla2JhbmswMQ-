<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從命名風格等方面解讀阿里巴巴 Java 代碼規範 | 极客快訊</title><meta property="og:title" content="從命名風格等方面解讀阿里巴巴 Java 代碼規範 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/48a7e246b4b54de0b14e01e211f2584f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/96d7b6c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/96d7b6c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/96d7b6c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/96d7b6c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/96d7b6c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/96d7b6c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/96d7b6c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/96d7b6c.html><meta property="article:published_time" content="2020-10-29T21:01:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:27+08:00"><meta name=Keywords content><meta name=description content="從命名風格等方面解讀阿里巴巴 Java 代碼規範"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/96d7b6c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從命名風格等方面解讀阿里巴巴 Java 代碼規範</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>前言</p><p>2017 年阿里雲棲大會，阿里發佈了針對 Java 程序員的《阿里巴巴 Java 開發手冊（終極版）》，這篇文檔作為阿里數千位 Java 程序員的經驗積累呈現給公眾，並隨之發佈了適用於 Eclipse 和 Intellim 的代碼檢查插件。為了能夠深入瞭解 Java 程序員編碼規範，也為了深入理解為什麼阿里這樣規定，是否規定有誤，本文以阿里發佈的這篇文檔作為分析起源，擴大範圍至業界其他公司的規範，例如谷歌、FaceBook、微軟、百度、華為，並搜索網絡上技術大牛發表的技術文章，深入理解每一條規範的設計背景和目標。</p><p>由於解讀文章僅有兩篇，所以按照阿里的篇幅權重分為上篇僅針對 Java 語言本身的編碼規約，下篇包含日誌管理、異常處理、單元測試、MySQL 規範、工程規範等方面內容進行解讀。本文是上篇，主要針對編碼規約部分進行解讀，由於篇幅限制，僅挑選一小部分進行解讀，如果需要全篇，請聯繫本文作者。</p><p>編碼規約</p><p>命名風格</p><p>下劃線或美元符號</p><p>阿里強制規定代碼中的命名均不能以下劃線或美元符號開始，也不能以下劃線或美元符號結束。</p><p>例如以下為錯誤，如清單 1 所示：</p><p>清單 1 錯誤示例</p><blockquote><p>_name/__name/$Object/name_/name$/Object$。</p></blockquote><p>我的理解</p><p>Oracle 官網建議不要使用$或者_開始變量命名，並且建議在命名中完全不要使用"$"字符，原文是"The convention,however,is to always begin your variable names with a letter,not '$' or '_'"。對於這一條，騰訊的看法是一樣的，百度認為雖然類名可以支持使用"$"符號，但只在系統生成中使用（如匿名類、代理類），編碼不能使用。</p><p>這類問題在 StackOverFlow 上有很多人提出，主流意見為人不需要過多關注，只需要關注原先的代碼是否存在"_"，如果存在就繼續保留，如果不存在則儘量避免使用。也有一位提出儘量不適用"_"的原因是低分辨率的顯示器，肉眼很難區分"_"（一個下劃線）和"__"（兩個下劃線）。</p><p>我個人覺得可能是由於受 C 語言的編碼規範所影響。因為在 C 語言裡面，系統頭文件裡將宏名、變量名、內部函數名用_開頭，因為當你#include 系統頭文件時，這些文件裡的名字都有了定義，如果與你用的名字衝突，就可能引起各種奇怪的現象。綜合各種信息，建議不要使用"_"、"$"、空格作為命名開始，以免不利於閱讀或者產生奇怪的問題。</p><p>類命名</p><p>阿里強制規定類名使用 UpperCamelCase 風格，必須遵從駝峰形式，但以下情形例外：DO/BO/DTO/VO/AO。</p><p>清單 2 類命名例子</p><blockquote><p>正例：MarcoPolo/UserDO/XmlService/TcpUdpDeal/TarPromotion</p><p>反例：macroPolo/UserDo/XMLService/TCPUDPD/TAPromotion</p></blockquote><p>我的理解</p><p>百度除了支持阿里的規範以外，規定雖然類型支持"$"符號，但只在系統生成中使用（如匿名類、代理類），編碼中不能使用。</p><p>對於類名，俄羅斯 Java 專家 Yegor Bugayenko 給出的建議是儘量採用現實生活中實體的抽象，如果類的名字以"-er"結尾，這是不建議的命名方式。他指出針對這一條有一個例外，那就是工具類，例如 StringUtils、FileUtils、IOUtils。對於接口名稱，不要使用 IRecord、IfaceEmployee、RedcordInterface，而是使用現實世界的實體命名。如清單 3 所示。</p><p>清單 3 示例</p><blockquote><p>Class SimpleUser implements User{};</p><p>Class DefaultRecord implements Record{};</p><p>Class Suffixed implements Name{};</p><p>Class Validated implements Content{};</p></blockquote><p>抽象類的命名</p><p>阿里強制規定抽象類命名使用 Abstratc 或 Base 開頭。</p><p>我的理解</p><p>Oracle 的抽象類和方法規範並沒有要求必須採用 Abstract 或者 Base 開頭命名，事實上官網上的示例沒有這種命名規範要求，如清單 4 所示。</p><p>清單 4 示例</p><blockquote><p>public abstract class GraphicObject{</p><p>//declare fields</p><p>//declare nonabstract methods</p><p>abstract void draw();</p><p>}</p></blockquote><p>我也查了一下 JDK，確實源碼裡很多類都是以這樣的方式命名的，例如抽象類 java.util.AbstractList。</p><p>Stackoverflow 上對於這個問題的解釋是，由於這些類不會被使用，一定會由其他的類繼承並實現內部細節，所以需要明白地告訴讀者這是一個抽象類，那以 Abstract 開頭比較合適。</p><p>Joshua Bloch的理解是支持以 Abstract 開頭。我的理解是不要以 Base 開頭命名，因為實際的基類也以 Base 開頭居多，這樣意義有多樣性，不夠直觀。</p><p>常量定義</p><p>避免魔法值的使用</p><p>阿里強制規定不允許任何魔法值（未經定義的常量）直接出現在代碼中，反例如清單 5 所示。</p><p>清單 5 反例</p><blockquote><p>String key = "Id#taobao_" + tradeId；</p><p>cache.put(key,value);</p></blockquote><p>我的理解</p><p>魔法值確實讓你很疑惑，比如你看下面這個例子：</p><p>int priceTable[] = new int[16];//這樣定義錯誤；這個 16 究竟代表什麼？</p><p>正確的定義方式是這樣的：</p><p>static final int PRICE_TABLE_MAX = 16; //這樣定義正確，通過使用完整英語單詞的常量名明確定義</p><p>int price Table[] = new int[PRICE_TABLE_MAX];</p><p>魔法值會讓代碼的可讀性大大降低，而且如果同樣的數值多次出現時，容易出現不清楚這些數值是否代表同樣的含義。另一方面，如果本來應該使用相同的數值，一旦用錯，也難以發現。因此可以採用以下兩點，極力避免使用魔法數值。</p><p>1. 不適用魔法數值，使用帶名字的 Static final 或者 enum 值；</p><p>2. 原則上 0 不用於魔法值，這是因為 0 經常被用作數組的最小下標或者變量初始化的缺省值。</p><p>變量值範圍</p><p>阿里推薦如果變量值僅在一個範圍內變化，且帶有名稱之外的延伸屬性，定義為枚舉類。下面這個正例中的數字就是延伸信息，表示星期幾。正例如清單 6 所示。</p><p>清單 6 正例</p><blockquote><p>public Enum {MONDAY(1),TUESDAY(2),WEDNESDAY(3),THURSDAY(4),FRIDAY(5),SATURDAY(6),SUNDAY(7);}</p></blockquote><p>我的理解</p><p>對於固定並且編譯時對象，如 Status、Type 等，應該採用 enum 而非自定義常量實現，enum 的好處是類型更清楚，不會再編譯時混淆。這是一個建議性的試用推薦，枚舉可以讓開發者在 IDE 下使用更方便，也更安全。另外就是枚舉類型是一種具有特殊約束的類類型，這些約束的存在使得枚舉類本身更加簡潔、安全、便捷。</p><p>代碼格式</p><p>大括號的使用約定</p><p>阿里強制規定如果是大括號為空，則簡潔地寫成{}即可，不需要換行；如果是非空代碼塊則：</p><p>1. 左大括號前不換行</p><p>2. 左大括號後換行</p><p>3. 右大括號前換行</p><p>4. 右大括號後還有 else 等代碼則不換行表示終止的右大括號後必須換行</p><p>我的理解</p><p>阿里的這條規定應該是參照了 SUN 公司 1997 年發佈的代碼規範（SUN 公司是 JAVA 的創始者），Google 也有類似的規定，大家都是遵循 K&R 風格（Kernighan 和 Ritchie），Kernighan 和 Ritchie 在《The C Programming Language》一書中推薦這種風格，JAVA 語言的大括號風格就是受到了 C 語言的編碼風格影響。</p><p>注意，SUN 公司認為方法名和大括號之間不應該有空格。</p><p>單行字符數限制</p><p>阿里強制規定單行字符數限制不超過 120 個，超出需要換行，換行時遵循如下原則：</p><p>1. 第二行相對第一行縮進 4 個空格，從第三行開始，不再繼續縮進，參考示例。</p><p>2. 運算符與下文一起換行。</p><p>3. 方法調用的點符號與下文一起換行。</p><p>4. 方法調用時，多個參數，需要換行時，在逗號後進行。</p><p>5. 在括號前不要換行，見反例。</p><p>如清單 7 所示。</p><p>清單 7 示例</p><blockquote><p>StringBuffer sb = new StringBuffer();</p><p>//超過 120 個字符的情況下，換行縮進 4 個空格，點號和方法名稱一起換行</p><p>sb.append("zi").append("xin")…</p><p>.append("huang")…</p><p>.append("huang")…</p><p>.append("huang")…</p><p>反例：</p><p>StringBuffer sb = new StringBuffer();</p><p>//超過 120 個字符的情況下，不要在括號前換行</p><p>sb.append("zi").append("xin").append</p><p>("huang");</p><p>//參數很多的方法調用可能超過 120 個字符，不要在逗號前換行</p><p>method(args1,args2,args3,….,argsX);</p></blockquote><p>我的理解</p><p>SUN 公司 1997 年的規範中指出單行不要超過 80 個字符，對於文檔裡面的代碼行，規定不要超過 70 個字符單行。當表達式不能在一行內顯示的時候，genuine 以下原則進行切分：</p><p>1. 在逗號後換行；</p><p>2. 在操作符號前換行；</p><p>3. 傾向於高級別的分割；</p><p>4. 儘量以描述完整作為換行標準；</p><p>5. 如果以下標準造成代碼閱讀困難，直接採用 8 個空格方式對第二行代碼留出空白。</p><p>示例代碼如清單 8 所示。</p><p>清單 8 示例</p><blockquote><p>function(longExpression1, longExpression2, longExpression3,</p><p>longExpression4, longExpression5);</p><p>var = function(longExpression1,</p><p>function2(longExpression2,</p><p>longExpression3));</p><p>longName1 = longName2 * (longName3 + longName4 – longName5)</p><p>+ 4 * longName6;//做法正確</p><p>longName1 = longName2 * (longName3 + longName4</p><p>– longName5) + 4 * longName6;//做法錯誤</p><p>if ((condition1 && condition2)</p><p>|| (condition3 && condition4)</p><p>|| !(condition5 && condition6) {</p><p>doSomethingAboutIt();</p><p>}//這種做法錯誤</p><p>if ((condition1 && condition2)</p><p>|| (condition3 && condition4)</p><p>|| !(condition5 && condition6) {</p><p>doSomethingAboutIt();</p><p>}//這種做法正確</p><p>if ((condition1 && condition2) || (condition3 && condition4)</p><p>|| !(condition5 && condition6) {</p><p>doSomethingAboutIt();</p><p>}//這種做法正確</p></blockquote><p>OOP 規約</p><p>靜態變量及方法調用</p><p>阿里強制規定代碼中避免通過一個類的對象引用訪問此類的靜態變量或靜態方法，暫時無謂增加編譯器解析成本，直接用類名來訪問即可。</p><p>我的理解</p><p>谷歌公司在代碼規範中指出必須直接使用類名對靜態成員進行引用，並同時舉例說明，如清單 9 所示。</p><p>清單 9 示例</p><blockquote><p>Foo aFoo = …;</p><p>Foo.aStaticMethod();//good</p><p>aFoo.aStaticMethod();//bad</p><p>somethingThatYieldsAFoo().aStaticMethod();//very bad</p></blockquote><p>SUN 公司 1997 年發佈的代碼規範也做了類似的要求。</p><p>為什麼需要這樣做呢？因為被 static 修飾過的變量或者方法都是隨著類的初始化產生的，在堆內存中有一塊專門的區域用來存放，後續直接用類名訪問即可，避免編譯成本的增加和實例對象存放空間的浪費。</p><p>StackOverflow 上也有人提出了相同的疑問，網友較為精闢的回覆是"這是由於生命週期決定的，靜態方法或者靜態變量不是以實例為基準的，而是以類為基準，所以直接用類訪問，否則違背了設計初衷"。那為什麼還保留了實例的訪問方式呢？可能是因為允許應用方無汙染修改吧。</p><p>可變參數編程</p><p>阿里強制規定相同參數類型、相同業務類型，才可以使用 Java 的可變參數，避免使用 Object，並且要求可變參數必須放置在參數列表的最後（提倡同學們儘量不用可變參數編程）。</p><p>我的理解</p><p>我們先來了解可變參數的使用方式：</p><p>1. 在方法中定義可變參數後，我們可以像操作數組一樣操作該參數。</p><p>2. 如果該方法除了可變參數還有其他的參數，可變參數必須放到最後。</p><p>3. 擁有可變參數的方法可以被重載，在被調用時，如果能匹配到參數定長的方法則優先調用參數定長的方法。</p><p>4. 可變參數可以兼容數組參數，但數組參數暫時無法兼容可變參數。</p><p>至於為什麼可變參數需要被放在最後一個，這是因為參數個數不定，所以當其後還有相同類型參數時，編譯器無法區分傳入的參數屬於前一個可變參數還是後邊的參數，所以只能讓可變參數位於最後一項。</p><p>可變參數編程有一些好處，例如反射、過程建設、格式化等。對於阿里同學提出的儘量不使用可變參數編程，我猜測的原因是不太可控，比如 Java8 推出 Lambda 表達式之後，可變參數編程遇到了實際的實現困難。</p><p>我們來看一個例子。假設我們想要實現以下功能，如清單 10 所示。</p><p>清單 10 實現功能</p><blockquote><p>test((arg0,arg1) -> me.call(arg0,arg1));</p><p>>test((arg0,arg1,arg2)->me.call(arg0,arg1,arg2));</p><p>…</p></blockquote><p>對應的實現定義接口的繼承關係，並且使用默認方法避免失敗，如清單 11 所示。</p><p>清單 11 實現方式代碼段 1</p><blockquote><p>interface VarArgsRunnable{</p><p>default void run(Object…arguments){</p><p>throw new UnsupportedOperationException("not possible");</p><p>}</p><p>default int getNumberOfArguments(){</p><p>throw new UnsupportedOperationException("unknown");</p><p>}</p><p>}</p><p>@FunctionalInterface</p><p>Interface VarArgsRunnable4 extends VarArgsRnnable {</p><p>@Override</p><p>default void run(Object…arguments){</p><p>assert(arguments.length == 4);</p><p>run(arguments[0], arguments[1], arguments[2], arguments[3]);</p><p>}</p><p>void run(Object arg0, Object arg1, Object arg2, Object arg3, Object arg4);</p><p>@Override</p><p>default int getNumberOfArguments(){</p><p>return 4;</p><p>}</p><p>}</p></blockquote><p>這樣我們就可以定義 11 個接口，從 VarArgsRnnable0 到 VarArgsRnnable10，並且覆蓋方法，調用方式如清單 12 所示。</p><p>清單 12 實現方式代碼段 2</p><blockquote><p>public void myMethod(VarArgsRnnable runnable,Object…arguments){</p><p>runnable.run(arguments);</p><p>}</p></blockquote><p>針對上述需求，我們也可以編寫代碼如清單 13 所示。</p><p>清單 13 實現方式 2 代碼段</p><blockquote><p>public class Java8VariableArgumentsDemo{</p><p>interface Invoker{</p><p>void invoke(Object…args);</p><p>}</p><p>public static void invokeInvoker(Invoker invoker,Object…args){</p><p>invoker.invoke(args);</p><p>}</p><p>public static void applyWithStillAndPrinting(Invoker invoker){</p><p>invoker.invoke("Still","Printing");</p><p>}</p><p>Public static void main(String[] args){</p><p>Invoker printer = new Invoker(){</p><p>Public void invoke(Object…args){</p><p>for(Object arg:args){</p><p>System.out.println(arg);</p><p>}</p><p>}</p><p>};</p><p>printer.invoke("I","am","printing");</p><p>invokeInvoker(printer, "Also","printing");</p><p>applyWithStillAndPrinting(printer);</p><p>applyWithStillAndPrinting((Object…args)->System.out.println("Not done"));</p><p>applyWithStillAndPrinting(printer::invoke);</p><p>}</p><p>}</p></blockquote><p>運行後輸出如清單 14 所示。</p><p>清單 14 實現方式 2 代碼段運行結果</p><blockquote><p>I</p><p>am</p><p>printing</p><p>Also</p><p>printing</p><p>Still</p><p>Printing</p><p>Not done</p><p>Still</p><p>Printing</p></blockquote><p>併發處理</p><p>單例模式需要保證線程安全</p><p>阿里強制要求獲取單例對象需要保證線程安全，其中的方法也要保證線程安全，並進一步說明資源驅動類、工具類、單例工廠類都需要注意。</p><p>我的理解</p><p>對於這一條規範是通識化規定，我這裡進一步講講如何做好針對單例對象的線程安全，主要有以下幾種方式：</p><p>1. 方法中申明 synchronized 關鍵字</p><p>出現非線程安全問題，是由於多個線程可以同時進入 getInstance()方法，那麼只需要對該方法進行 synchronized 鎖同步即可，如清單 15 所示。</p><p>清單 15 synchronized 關鍵字方式</p><blockquote><p>public class MySingleton{</p><p>private static MySingleton instance = null;</p><p>private MySingleton(){}</p><p>public synchronized static MySingleton getInstance(){</p><p>try{</p><p>if(instance != null){//懶漢式</p><p>}else{</p><p>//創建實例之前可能會有一些準備性的耗時工作</p><p>Thread.sleep(500);</p><p>Instance = new MySingleton();</p><p>}</p><p>}catch(InterruptedException e){</p><p>e.printStackTrace();</p><p>}</p><p>return instance;</p><p>}</p><p>}</p></blockquote><p>執行結果如清單 16 所示。</p><p>清單 16 synchronized 關鍵字方式運行結果</p><blockquote><p>174342932</p><p>174342932</p><p>174342932</p><p>174342932</p><p>174342932</p><p>174342932</p></blockquote><p>從執行結果上來看，多線程訪問的問題已經解決了，返回的是一個實例。但是這種實現方式的運行效率很低。我們接下來採用同步方法塊實現。</p><p>2. 同步方法塊實現</p><p>清單 17 同步方法塊方式</p><blockquote><p>public class MySingleton {</p><p>private static MySingleton instance = null;</p><p>private MySingleton(){}</p><p>//public synchronized static MySingleton getInstance() {</p><p>public static MySingleton getInstance() {</p><p>try {</p><p>synchronized (MySingleton.class) {</p><p>if(instance != null){//懶漢式</p><p>}else{</p><p>//創建實例之前可能會有一些準備性的耗時工作</p><p>Thread.sleep(300);</p><p>instance = new MySingleton();</p><p>}</p><p>}</p><p>} catch (InterruptedException e) {</p><p>e.printStackTrace();</p><p>}</p><p>return instance;</p><p>}</p><p>}</p></blockquote><p>這裡的實現能夠保證多線程併發下的線程安全性，但是這樣的實現將全部的代碼都被鎖上了，同樣的效率很低下。</p><p>3. 針對某些重要的代碼來進行單獨的同步</p><p>針對某些重要的代碼進行單獨的同步，而不是全部進行同步，可以極大的提高執行效率，代碼如清單 18 所示。</p><p>清單 18 單獨同步方式</p><blockquote><p>public class MySingleton {</p><p>private static MySingleton instance = null;</p><p>private MySingleton(){}</p><p>public static MySingleton getInstance() {</p><p>try {</p><p>if(instance != null){//懶漢式</p><p>}else{</p><p>//創建實例之前可能會有一些準備性的耗時工作</p><p>Thread.sleep(300);</p><p>synchronized (MySingleton.class) {</p><p>instance = new MySingleton();</p><p>}</p><p>}</p><p>}catch (InterruptedException e) {</p><p>e.printStackTrace();</p><p>}</p><p>return instance;</p><p>}</p><p>}</p></blockquote><p>從運行結果來看，這樣的方法進行代碼塊同步，代碼的運行效率是能夠得到提升，但是卻沒能保住線程的安全性。看來還得進一步考慮如何解決此問題。</p><p>4.雙檢查鎖機制（Double Check Locking）</p><p>為了達到線程安全，又能提高代碼執行效率，我們這裡可以採用 DCL 的雙檢查鎖機制來完成，代碼實現如清單 19 所示。</p><p>清單 19 雙檢查鎖機制</p><blockquote><p>public class MySingleton {</p><p>//使用 volatile 關鍵字保其可見性</p><p>volatile private static MySingleton instance = null;</p><p>private MySingleton(){}</p><p>public static MySingleton getInstance() {</p><p>try {</p><p>if(instance != null){//懶漢式</p><p>}else{</p><p>//創建實例之前可能會有一些準備性的耗時工作</p><p>Thread.sleep(300);</p><p>synchronized (MySingleton.class) {</p><p>if(instance == null){//二次檢查</p><p>instance = new MySingleton();</p><p>}</p><p>}</p><p>}</p><p>} catch (InterruptedException e) {</p><p>e.printStackTrace();</p><p>}</p><p>return instance;</p><p>}</p><p>}</p></blockquote><p>這裡在聲明變量時使用了 volatile 關鍵字來保證其線程間的可見性；在同步代碼塊中使用二次檢查，以保證其不被重複實例化。集合其二者，這種實現方式既保證了其高效性，也保證了其線程安全性。</p><p>5. 靜態內置類方式</p><p>DCL 解決了多線程併發下的線程安全問題，其實使用其他方式也可以達到同樣的效果，代碼實現如清單 20 所示。</p><p>清單 20 靜態內置類方式</p><blockquote><p>public class MySingleton {</p><p>//內部類</p><p>private static class MySingletonHandler{</p><p>private static MySingleton instance = new MySingleton();</p><p>}</p><p>private MySingleton(){}</p><p>public static MySingleton getInstance() {</p><p>return MySingletonHandler.instance;</p><p>}</p><p>}</p></blockquote><p>6. 序列化與反序列化方式</p><p>靜態內部類雖然保證了單例在多線程併發下的線程安全性，但是在遇到序列化對象時，默認的方式運行得到的結果就是多例的。</p><p>清單 21 序列化與反序列化</p><blockquote><p>import java.io.Serializable;</p><p>public class MySingleton implements Serializable {</p><p>private static final long serialVersionUID = 1L;</p><p>//內部類</p><p>private static class MySingletonHandler{</p><p>private static MySingleton instance = new MySingleton();</p><p>}</p><p>private MySingleton(){}</p><p>public static MySingleton getInstance() {</p><p>return MySingletonHandler.instance;</p><p>}</p><p>}</p></blockquote><p>7. 使用枚舉數據類型方式</p><p>枚舉 enum 和靜態代碼塊的特性相似，在使用枚舉時，構造方法會被自動調用，利用這一特性也可以實現單例。</p><p>清單 22 枚舉數據方式 1</p><blockquote><p>public enum EnumFactory{</p><p>singletonFactory;</p><p>private MySingleton instance;</p><p>private EnumFactory(){//枚舉類的構造方法在類加載是被實例化</p><p>instance = new MySingleton();</p><p>}</p><p>public MySingleton getInstance(){</p><p>return instance;</p><p>}</p><p>}</p><p>class MySingleton{//需要獲實現單例的類，比如數據庫連接 Connection</p><p>public MySingleton(){}</p><p>}</p></blockquote><p>這樣寫枚舉類被完全暴露了，據說違反了"職責單一原則"，我們可以按照下面的代碼改造。</p><p>清單 23 枚舉數據方式 2</p><blockquote><p>public class ClassFactory{</p><p>private enum MyEnumSingleton{</p><p>singletonFactory;</p><p>private MySingleton instance;</p><p>private MyEnumSingleton(){//枚舉類的構造方法在類加載是被實例化</p><p>instance = new MySingleton();</p><p>}</p><p>public MySingleton getInstance(){</p><p>return instance;</p><p>}</p><p>}</p><p>public static MySingleton getInstance(){</p><p>return MyEnumSingleton.singletonFactory.getInstance();</p><p>}</p><p>}</p></blockquote><p>class MySingleton{//需要獲實現單例的類，比如數據庫連接 Connection</p><p>public MySingleton(){}</p><p>}</p><p>控制語句</p><p>Switch 語句的使用</p><p>阿里強制規定在一個 switch 塊內，每個 case 要麼通過 break/return 等來終止，要麼註釋說明程序將繼續執行到哪一個 case 為止；在一個 switch 塊內，都必須包含一個 default 語句並且放在最後，即使它什麼代碼也沒有。</p><p>我的理解</p><p>首先理解前半部分，"每個 case 要麼通過 break/return 等來終止，要麼註釋說明程序將繼續執行到哪一個 case 為止"。因為這樣可以比較清楚地表達程序員的意圖，有效防止無故遺漏的 break 語句。我們來看一個示例，如清單 24 所示。</p><p>清單 24 synchronized 關鍵字方式運行結果</p><blockquote><p>switch(condition){</p><p>case ABC:</p><p>statements;</p><p>/*程序繼續執行直到 DEF 分支*/</p><p>case DEF:</p><p>statements;</p><p>break;</p><p>case XYZ:</p><p>statements;</p><p>break;</p><p>default:</p><p>statements;</p><p>break;</p><p>}</p></blockquote><p>上述示例中，每當一個 case 順著往下執行時（因為沒有 break 語句），通常應在 break 語句的位置添加註釋。上面的示例代碼中就包含了註釋"/*程序繼續執行直到 DEF 分支*/"（這一條也是 SUN 公司 1997 年代碼規範的要求）。</p><p>語法上來說，default 語句中的 break 是多餘的，但是如果後續添加額外的 case，可以避免找不到匹配 case 項的錯誤。</p><p>集合處理</p><p>集合轉數組處理</p><p>阿里強制規定使用集合轉數組的方法，必須使用集合的 toArray(T[] arrays)，傳入的是類型完全一樣的數組，大小就是 list.size()。使用 toArray 帶參方法，入參分配的數組空間不夠大時，toArray 方法內部將重新分配內存空間，並返回新數組地址；如果數組元素大於實際所需，下標為[list.size()]的數組元素將被置為 null，其它數組元素保持原值，因此最好將方法入參數組大小定義與集合元素個數一致。正例如清單 25 所示。</p><p>清單 25 正例</p><blockquote><p>List&lt;String> list = new ArrayList&lt;String>(2);</p><p>list.add("guan");</p><p>list.add("bao");</p><p>String[] array = new String[list.size()];</p><p>array = list.toArray(array);</p></blockquote><p>反例：直接使用 toArray 暫時無參方法存在問題，此方法返回值只能是 Object[]類，若強轉其他類型數組將出現 ClassCastException 錯誤。</p><p>我的理解</p><p>ArrayList 類的 toArray()源碼如清單所示，toArray()方法暫時無需傳入參數，可以直接將集合轉成 Object 數組進行返回，而且也只能返回 Object 類型。</p><p>清單 26 toArray()源碼</p><blockquote><p>Public Object[] toArray(){</p><p>Object aobj[] = new Object[size];</p><p>System.arraycopy(((Object)(elementData)),0,((Object)(aobj)),0,size);</p><p>return aobj;</p><p>}</p><p>public &lt;T> T[] toArray(T[] a){</p><p>if(a.length &lt; size)</p><p>// Make a new array of a's runtime type, but my contents:</p><p>return (T[]) Arrays.copyOf(elementData,size, a.getClass());</p><p>System.arraycopy(elementData,0,a,0,size);</p><p>if(a.length> a[size] = null;</p><p>return a;</p><p>}</p></blockquote><p>由源碼可知，不帶參數的 toArray()構造一個 Object 數組，然後進行數據拷貝，此時進行轉型就會產生 ClassCastException。原因是不能將 Object[]轉化為 Strng[]。Java 中的強制類型轉換隻是針對單個對象，想要將一種類型數組轉化為另一種類型數組是不可行的。</p><p>針對傳入參數的數組大小，測試大於 list、等於 list 和小於 list 三種情況，測試代碼如清單 27 所示。</p><p>清單 27 toArray()測試</p><blockquote><p>public static void main(String[] args){</p><p>List&lt;String> list = new ArrayList&lt;String>();</p><p>for(int i=0;i&lt;20;i++){</p><p>list.add("test");</p><p>}</p><p>long start = System.currentTimeMills();</p><p>for(int i=0;i&lt;10000000;i++){</p><p>String[] array = new String[list.size()];</p><p>Array = list.toArray(array);</p><p>}</p><p>System.out.println("數組長度等於 list 耗時："+(System.currentTimeMills()-start)+"ms");</p><p>start = System.currentTimeMills();</p><p>for(int i=0;i&lt;10000000;i++){</p><p>String[] array = new String[list.size()*2];</p><p>Array = list.toArray(array);</p><p>}</p><p>System.out.println("數組長度等於 list 耗時："+(System.currentTimeMills()-start)+"ms");</p><p>start = System.currentTimeMills();</p><p>for(int i=0;i&lt;10000000;i++){</p><p>String[] array = new String[0];</p><p>Array = list.toArray(array);</p><p>}</p><p>System.out.println("數組長度等於 list 耗時："+(System.currentTimeMills()-start)+"ms");</p><p>}</p></blockquote><p>清單運行後輸出結果如清單 28 所示。</p><p>清單 28 清單運行輸出</p><blockquote><p>數組長度等於 list 耗時：431ms</p><p>數組長度等於 list 耗時：509ms</p><p>數組長度等於 list 耗時：1943ms</p></blockquote><p>通過測試可知無論數據大小如何，數組轉換都可以成功，只是耗時不同，數組長度等於 list 時性能最優，因此強制方法入參數組大小與集合元素個數一致。</p><p>註釋規約</p><p>方法註釋要求</p><p>阿里強制要求方法內部單行註釋，在被註釋語句上方另起一行，使用//註釋。方法內部多行註釋使用/**/註釋，注意與代碼對照。</p><p>我的理解</p><p>百度規定方法註釋採用標準的 Javadoc 註釋規範，註釋中必須提供方法說明、參數說明及返回值和異常說明。騰訊規定採用 JavaDoc 文檔註釋，在方法定義之前應該對其進行註釋，包括方法的描述、輸入、輸出以及返回值說明、拋出異常說明、參考鏈接等。</p><p>其他</p><p>數據結構初始化大小</p><p>阿里推薦任何數據結構的構造或初始化，都應指定大小，避免數據結構暫時無限增長吃光內存。</p><p>我的理解</p><p>首先明確一點，阿里這裡指的大小具體是指數據結構的最大長度。大部分 Java 集合類在構造時指定的大小都是初始尺寸（initial Capacity），而不是尺寸上限（Capacity），只有幾種隊列除外，例如 ArrayBlockingQueue、LinkedBlockingQueue，它們在構造時可以指定隊列的最大長度。阿里推薦的目的是為了合理規劃內存，避免出現 OOM（Out of Memory）異常。</p><p>結束語</p><p>本文主要介紹了阿里巴巴針對命名風格、常量定義、代碼格式、OOP 規約、併發處理、控制語句、集合處理、註釋規約、其他這些關於編碼規約的要求。本文僅覆蓋了阿里代碼規範的少數內容，更多內容請諮詢本文作者。</p><div class=pgc-img><img alt="從命名風格等方面解讀阿里巴巴 Java 代碼規範" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48a7e246b4b54de0b14e01e211f2584f><p class=pgc-img-caption></p></div><p>參考資源</p><p>參考文檔《阿里巴巴 Java 開發手冊（又名阿里巴巴 Java 代碼規約）》。</p><p>參考 developerWorks 上的 Java 文章，瞭解更多 Java 知識。</p><p>參考書籍 《Effective Java Second Edition》Joshua Bloch。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>風格</a></li><li><a>解讀</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc3f9eb.html alt=解讀新規範——構建精細化橋樑之路 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9317d74f6fd541a6b6e1e5269a0a549c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc3f9eb.html title=解讀新規範——構建精細化橋樑之路>解讀新規範——構建精細化橋樑之路</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37ac5476.html alt=解讀：層絞式室外光纜 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7243ce84f5524f66b2fefb7a7e34ac7a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37ac5476.html title=解讀：層絞式室外光纜>解讀：層絞式室外光纜</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9104cf19.html alt=招商銀行掌上生活十元風暴解讀，輕鬆薅羊毛 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/92f29b3e14f7430889422d37a042e429 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9104cf19.html title=招商銀行掌上生活十元風暴解讀，輕鬆薅羊毛>招商銀行掌上生活十元風暴解讀，輕鬆薅羊毛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/deb995ba.html alt=技術解讀GKN、BOSCH和ZF三合一集成電驅動橋 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d0e167b08bf94dbfa698d5f87c552239 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/deb995ba.html title=技術解讀GKN、BOSCH和ZF三合一集成電驅動橋>技術解讀GKN、BOSCH和ZF三合一集成電驅動橋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html alt=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html title=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理>解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>