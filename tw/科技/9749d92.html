<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核 | 极客快訊</title><meta property="og:title" content="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/108e64968ca9453c9f0b9ea5b2818a66"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9749d92.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><meta property="article:published_time" content="2020-10-29T21:04:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:04+08:00"><meta name=Keywords content><meta name=description content="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9749d92.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>上一文 討論了FIR濾波器的結構以及使用Python從兩個方面（循環運算和矩陣運算）實現FIR，而文中提到的單片機，只需要按照循環運算的方法就可以實現FIR濾波器。</p><p>所以，單片機實現FIR濾波器並不複雜；奈何我手癢了，想捨棄掉FIR IP核，用Verilog自己寫一個FIR。不知道大家有沒有這樣手癢的感覺，如果有，跟隨這篇文章一起來，看完記得點贊。</p><p>本文內容涉及Verilog的語法：function，generate for，generate if， readmemb,readmemh；部分Python語法以及學習Verilog）及計算機數值表示規則。</p><hr><h3 class=pgc-h-arrow-right>設計思想</h3><p>首先需要把FIR最基本的結構實現，也就是每個FIR抽頭的數據與其抽頭係數相乘這個操作。由頂層文件對這個基本模塊進行多次調用。</p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/108e64968ca9453c9f0b9ea5b2818a66><p class=pgc-img-caption></p></div><p>由於FIR抽頭係數是中心對稱的，為了減少乘法在FPGA內的出現，每個基本結構同時會輸入兩個信號，也是關於中心對稱的。</p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63eb6b78c1284068853043555eec08d7><p class=pgc-img-caption></p></div><p><br></p><p>此外，為了防止後續相加的過程引起符號位溢出，FIR基本模塊需要對乘法結果進行符號位擴展。</p><p>擴展完成後，如果同時對這些（71個）加權結果相加，肯定會使得系統運行速率上不去，而且設計的比較死板。這裡需要引入流水線操作；何為流水線操作，簡單地說，本來你一個人承擔一桌菜，你需要洗菜，切菜，炒菜，裝盤，上桌，不僅十分麻煩而且很耽誤時間；這個時候有人過來幫你，一個人洗菜，一個人切菜，一個人炒菜，一個人裝盤，你負責上桌，雖然費了些人，但是每個人的任務都比較輕鬆所以做事速度也很快，這就是流水線操作，把一件很複雜的事情劃分成N個小事，雖然犧牲了面積但換取了系統運行時鐘的提升。</p><h3 class=pgc-h-arrow-right>前期準備</h3><p>除了Verilog模塊，我們還有幾樣東西需要準備。首先，需要將FIR抽頭係數定點化，上一文使用的FIR抽頭係數都是很小的浮點數，為此，我們直接對每個係數乘以2的15次冪，然後取整數，捨去小數位，設定FIR抽頭係數位寬為16bit；因為係數本身比較小，不擔心會溢出。注意，這裡抽頭係數的位寬儘量不超過信號位寬，否則可能會有問題。</p><p>為了方便多個模塊同時調用FIR係數，這裡使用Python直接將定點化的係數生成為function，輸入為index，需要第N階的FIR係數，就調用function，輸入參數為N，輸出為定點化的係數。</p><p><strong>所謂定點化，這裡使用的方法十分粗暴，直接對所有浮點數，乘以一個2的n次冪。然後對參數向下取整，捨棄小數位。</strong></p><p>FIR浮點係數轉化為定點數並生成function的代碼如下：</p><pre><code>def coef2function(filename, exp, gain):    # :param filename: FIR抽頭係數文件名    # :param exp:      浮點數轉定點數的位寬    # :param gain:     浮點數整體的增益，增益為power(2, gain)    # :return:    	coef = set_coef(filename)    	with open('fir_coef.v', 'w') as f:		f.write('function [{}:0] get_coef;\n'.format(exp-1))        		f.write('input [7:0] index;\n')        		f.write('case (index)\n')        		for i in range(len(coef)):                	f.write('{}: get_coef = {};\n'.format(i,int(np.floor(coef[i] * np.power(2,gain)))))        		f.write('default: get_coef = 0;\n')        		f.write('endcase\nendfunction')</code></pre><p>轉換生成的function示例如下：</p><pre><code>function [15:0] get_coef;input [7:0] index;case (index)0: get_coef = 0;1: get_coef = 0;2: get_coef = 2;3: get_coef = 10;...69: get_coef = 10;70: get_coef = 2;71: get_coef = 0;72: get_coef = 0;default: get_coef = 0;endcaseendfunction</code></pre><p>這樣，當多個基本模塊並行運行時，每個模塊的係數可以通過調用function獲取對應的參數。</p><p><br></p><p>仿真需要有信號源供FIR濾波，所以直接將仿真用的信號源定點化；<strong>因為Testbench中使用readmemh或者readmemb讀取txt文檔數據，只能讀取二進制或16進制數據，所以需要對數據進行二進制或16進制轉換。</strong></p><p>信號源選取上一文的信號源，由於該信號源最大值為3，設定信號源的位寬為16位，為防止數據溢出，信號源整體乘以2的12次冪，然後取整捨去小數位。為了方便後續轉二進制，這裡需要將數據由16bit有符號轉為16bit無符號；轉換的過程為，如果data[i]小於0，直接設定data[i] = 2^16 + data[i]。然後使用“{{:0>16b}}”.format(data[i])轉換為16bit二進制，存入cos.txt。</p><p>浮點數轉換定點數並轉換二進制數據存入txt轉換代碼如下：</p><pre><code>def float2fix_point(data, exp, gain, size):    # '''    # :param data: 信號源數據    # :param exp:  浮點數轉定點數的位寬    # :param gain: 浮點數整體乘以增益，增益為power(2,15)    # :param size: 轉換多少點數    # :return:    # '''    	if size &gt; len(data):          	print("error, size &gt; len(data)")        		return    	data = [int(np.floor(data[i] * np.power(2, gain) )) for i in range(size)]      fmt = '{{:0&gt;{}b}}'.format(exp)    	n = np.power(2, exp)    	for i in range(size):          	if data[i] &gt; (n //2 - 1):                	print("error")        		if data[i] &lt; 0:                	d = n + data[i]        		else:                	d = data[i]        		data[i] = fmt.format(d)    	np.savetxt('cos.txt', data, fmt='%s')</code></pre><p><br></p><h3 class=pgc-h-arrow-right>實現方法</h3><p>為了方便看示例代碼，這裡假定信號位寬DATA_BITS為16，係數位寬為COEF_BITS為16，擴展符號位寬EXTEND_BITS為5， 階數FIR_ORDER為72。</p><p>設計思路還是從底層開始設計，首先需要實現FIR的基本模塊。前面提到，為了節省乘法器，每個模塊輸入兩個信號和一個FIR抽頭係數，兩個參數相加，相加結果直接乘以係數，最後做符號位擴展，防止後續操作導致符號位溢出。</p><p>fir_base.v 主要代碼：</p><pre><code>reg signed [DATA_BITS + COEF_BITS - 1:0]  data_mult;// 因為FIR係數是中心對稱的，所以直接把中心對稱的數據相加乘以係數// 相加符號位擴展一位wire signed [DATA_BITS:0]  data_in ;assign data_in = {data_in_A[DATA_BITS-1], data_in_A} + {data_in_B[DATA_BITS-1], data_in_B};// 為了防止後續操作導致符號位溢出，這裡擴展符號位，設計位操作知識assign data_out = {{EXTEND_BITS{data_mult[DATA_BITS + COEF_BITS - 1]}},data_mult };always @(posedge clk or posedge rst) begin  	if (rst) begin      	// reset      	fir_busy  &lt;=  1'b0;    		data_mult  &lt;=   0 ;    		output_vld  &lt;=  1'b0;  	end    else if (en) begin          //如果coef為0，不需要計算直接得0      	data_mult  &lt;=  coef != 0 ? data_in * coef : 0;    		output_vld  &lt;=  1'b1;  	end    else begin      	data_mult  &lt;=  'd0;    		output_vld  &lt;=  1'b0;  	endend</code></pre><p><br></p><p>完成了基本模塊後，頂層模塊就是調用基本模塊，然後對運算結果進行相加操作。但這裡需要注意，頂層首先需要73個16bit的寄存器，用來保存傳入的信號並實現每時鐘週期上升沿，73個數據整體前移；學過數據結構的同學可以把這個想象成隊列結構，每次信號上升沿時，隊首信號出隊，隊尾補進新的信號。</p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8624f085473f4f98af066bf031f48ba2><p class=pgc-img-caption></p></div><p><br></p><p>實現方法如下：</p><pre><code>// FIR輸入數據暫存寄存器組reg signed 	[DATA_BITS-1:0]	data_tmp [FIR_ORDER:0] ;always @(posedge clk or posedge rst) begin	if (rst) begin		// reset		data_tmp[0] &lt;=	0;	end	else if (data_in_vld) begin		data_tmp[0] &lt;=	data_in;	endendgenerate	genvar j;    for (j = 1; j &lt;= FIR_ORDER; j = j + 1)	begin: fir_base	//這裡無法兼顧0，FIR_HALF_ORDER    always @(posedge clk or posedge rst) begin    if (rst) begin        // reset        data_tmp[j] &lt;=	0;    end    else if (data_in_vld) begin        data_tmp[j] &lt;=	data_tmp[j-1];    end	endendgenerate</code></pre><p><br></p><p>這裡實現了從0-72共73個寄存器，使用了Verilog的類似二維數組的寄存器定義用法。可以從代碼看到，0號data_tmp過於特殊，需要保存輸入的信號，而其他data_tmp直接使用generate for語法實現前面提到的“隊列”功能。generate for語法是可以綜合的，<strong>其中for循環的參數必須是常數</strong>，其作用就是直接在電路上覆制循環體的內容。對於像這樣需要規律性地賦值操作很方便，下面還會出現generate for語法。</p><p><br></p><p>寄存器組的問題解決後，需要與FIR參數進行乘加，這裡同樣適用generate for語句簡化設計：</p><pre><code>localparam FIR_HALF_ORDER = FIR_ORDER / 2;  //36wire signed [OUT_BITS-1:0]	data_out_tmp [FIR_HALF_ORDER:0] ;// FIR輸出數據後流水線相加的中間變量，多出部分變量，防止下一級相加過程中index越界reg signed 	[OUT_BITS-1:0]	dat_out_reg  [FIR_HALF_ORDER+4:0] ; 	//40-0always @(posedge clk or posedge rst) begin	if (rst) begin		// reset		dat_out_reg[FIR_HALF_ORDER] &lt;= 0;	end	else if (output_vld_tmp[FIR_HALF_ORDER]) begin		dat_out_reg[FIR_HALF_ORDER] &lt;= data_out_tmp[FIR_HALF_ORDER];	endendfir_base #(	.DATA_BITS(DATA_BITS),	.COEF_BITS(COEF_BITS),	.EXTEND_BITS(EXTEND_BITS)	)fir_inst_FIR_HALF_ORDER(	.clk		(clk),	.rst		(rst),    .en			(data_in_vld),    .data_in_A	(data_tmp[FIR_HALF_ORDER]),    .data_in_B	(12'd0),    .coef		(get_coef(FIR_HALF_ORDER)),    .fir_busy	(),    .data_out	(data_out_tmp[FIR_HALF_ORDER]),    .output_vld	(output_vld_tmp[FIR_HALF_ORDER])    );    generate	genvar j;	for (j = 1; j &lt; FIR_HALF_ORDER; j = j + 1)	begin: fir_base	fir_base	#(	.DATA_BITS(DATA_BITS),	.COEF_BITS(COEF_BITS),	.EXTEND_BITS(EXTEND_BITS)	)	fir_inst_NORMAL	(		.clk		(clk),		.rst		(rst),				.en			(data_in_vld),		.data_in_A	(data_tmp[j]),		.data_in_B	(data_tmp[FIR_ORDER-j]),		.coef		(get_coef(j)),				.fir_busy	(),		.data_out	(data_out_tmp[j]),		.output_vld	(output_vld_tmp[j])	);	always @(posedge clk or posedge rst) begin		if (rst) begin			// reset			dat_out_reg[j] &lt;= 0;		end		else if (output_vld_tmp[j]) begin			dat_out_reg[j] &lt;= data_out_tmp[j];		end	endendgenerate</code></pre><p>首先由於中心點（第36階）的係數是隻乘中心點，並不像其他係數可以傳入關於中心對稱的兩個信號。所以FIR_HALF_ORDER需要單獨例化。同樣，dat_out_reg也需要單獨複製；其他的信號在generate for循環體完成操作，由於0號係數在階數為偶數的情況下為0，這裡跳過0號係數直接從1號係數開始，所以for循環是從1 - FIR_HALF_ORDER。</p><p><br></p><p>加權結果出來後，需要對結果相加，為了提升系統運行速率，這裡採用三級流水線操作。每次進行4位數據相加傳遞給下一級流水線，所以示例代碼裡FIR最高階數為4 * 4 * 4 * 2 = 128。</p><p>流水線操作過程如下：</p><pre><code>// 流水線第一級相加，計算公式ceil(N/4)localparam FIR_ADD_ORDER_ONE = (FIR_HALF_ORDER + 3) / 4; //// 流水線第二級相加，計算公式ceil(N/4)localparam FIR_ADD_ORDER_TWO = (FIR_ADD_ORDER_ONE + 3) / 4; //3reg signed [OUT_BITS-1:0]	dat_out_A [FIR_ADD_ORDER_ONE+3:0] ;	//12-0reg signed [OUT_BITS-1:0]	dat_out_B [FIR_ADD_ORDER_TWO+3:0] ;	//6-0// 這些多餘的reg直接設為0就可以了always @ (posedge clk) begin	dat_out_reg[FIR_HALF_ORDER+1] = 0;	dat_out_reg[FIR_HALF_ORDER+2] = 0;	dat_out_reg[FIR_HALF_ORDER+3] = 0;	dat_out_reg[FIR_HALF_ORDER+4] = 0;	dat_out_A[FIR_ADD_ORDER_ONE] = 0;	dat_out_A[FIR_ADD_ORDER_ONE+1] = 0;	dat_out_A[FIR_ADD_ORDER_ONE+2] = 0;	dat_out_A[FIR_ADD_ORDER_ONE+3] = 0;	dat_out_B[FIR_ADD_ORDER_TWO] = 0;	dat_out_B[FIR_ADD_ORDER_TWO + 1] = 0;	dat_out_B[FIR_ADD_ORDER_TWO + 2] = 0;	dat_out_B[FIR_ADD_ORDER_TWO + 3] = 0;end// 判定所有FIR_BASE模塊完成轉換assign data_out_vld = (&amp;output_vld_tmp[FIR_HALF_ORDER:1] == 1'b1) ? 1'b1 : 1'b0;//最後一級流水線always @(posedge clk or posedge rst) begin	if (rst) begin		// reset		data_out 	&lt;=	0;	end	else if (data_out_vld) begin		data_out 	&lt;= dat_out_B[0] + dat_out_B[1] + dat_out_B[2] + dat_out_B[3];	endendgenerate	genvar j;	for (j = 1; j &lt; FIR_HALF_ORDER; j = j + 1)        	if (j &lt;= FIR_ADD_ORDER_ONE)	begin	//流水線相加 第一級	//注意j 的範圍是[1,FIR_HALF_ORDER]	//所以dat_out_A[j-1]		always @(posedge clk or posedge rst) begin			if (rst) begin				// reset				dat_out_A[j-1] &lt;= 0;			end			else begin				dat_out_A[j-1] &lt;= dat_out_reg[4*j-3] + dat_out_reg[4*j-2] + dat_out_reg[4*j-1] + dat_out_reg[4*j];			end		end	end        if (j &lt;= FIR_ADD_ORDER_TWO)	begin	// 流水線相加 第二級		always @(posedge clk or posedge rst) begin			if (rst) begin				// reset				dat_out_B[j-1] &lt;= 0;			end			else begin				dat_out_B[j-1] &lt;= dat_out_A[4*j - 4] + dat_out_A[4*j- 3] + dat_out_A[4*j - 2] + dat_out_A[4*j - 1];			end		end	endend	endgenerate</code></pre><p>這裡第一級，第二級流水線的循環次數採用ceil(N/4)的計算方式，也就是取比N/4大的最小整數。比如5/4 = 1.25,則ceil(1.25) = 2， 而ceil(1) = 1;</p><p>定義每級寄存器組時，會多定義4個寄存器組。並且這些寄存器永遠為0，這樣做的原因以第一級流水線相加舉例：</p><p>看第一級流水線，假定FIR_ORDER為70，FIR_HALF_ORDER為35，FIR_ADD_ORDER_ONE為9，當j為9時，dat_out_A[8] &lt;= dat_out_reg[33] + dat_out_reg[34] + dat_out_reg[35] + dat_out_reg[36];</p><p>而我們在前面設計中正好定義了dat_out_reg[36]，並且它永遠為0，不影響最終結果。</p><p>可以看到，第一級，第二級流水線使用generate for, if語句。如果if條件成立，if內部的電路會被描述。最後71個數據經過三級流水線相加，結果輸出。</p><p>如果想要提升FIR的最高運行頻率，可以把流水線級數增加，每級流水線相加改為2個或者3個。</p><p><strong>這個結構只適合FIR階數為偶數的情況，由於最近比較忙，沒有做更大的兼容性。</strong></p><h3 class=pgc-h-arrow-right>仿真結果與資源佔用對比</h3><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/939bcfc5e8874f8ba18ac00fb5a68756><p class=pgc-img-caption></p></div><p><br></p><p>VCS仿真結果</p><p><br></p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b180352ee9f9454d98a23c9192e31687><p class=pgc-img-caption></p></div><p><br></p><p>FIR濾波效果，Python</p><p><br></p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/11bf493f374a46a4a050c8b3f7b0ee2d><p class=pgc-img-caption></p></div><p><br></p><p>FIR濾波效果，Verilog</p><p><br></p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c42b12e17da40a1be905685f9582d53><p class=pgc-img-caption></p></div><p><br></p><p>FIR_IMPLE的資源佔用 Quartus II 13.1</p><p><br></p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0fe0cf61f9484b9191d67b9663f7898b><p class=pgc-img-caption></p></div><p><br></p><p>FIR IP核資源佔用，參數相同情況下，Quartus II 13.1</p><p><br></p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75661ddeb5c345ee80c499c245cfb907><p class=pgc-img-caption></p></div><p><br></p><p>FIR_IMPLE的Fmax Quartus II 13.1</p><p><br></p><div class=pgc-img><img alt="（探討濾波器）2. 手把手用Verilog實現FIR濾波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8fd958f5dea43fd87d8d84b427e8f59><p class=pgc-img-caption></p></div><p><br></p><p>FIR IP核，Fmax， Quartus II 13.1</p><p><br></p><h3 class=pgc-h-arrow-right>提升建議：</h3><p><strong>1. 提升最高運行速率，可以增多流水線操作</strong></p><p><strong>2. 可以修改部分代碼適配階數為奇數的情況</strong></p><p>歡迎關注留言點贊收藏我，一同探討FPGA/電子/硬件/軟件。關於本文所用的資源會在評論區給出</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>探討濾</a></li><li><a>波器</a></li><li><a>Verilog</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2875f9f1.html alt=自適應濾波器的作用、原理以及相關應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/d03f22fc-c0cd-4f5c-a8ea-c520967d03b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2875f9f1.html title=自適應濾波器的作用、原理以及相關應用>自適應濾波器的作用、原理以及相關應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/240ffe94.html alt=設計濾波器堵住開關電源噪聲的方法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535001817470e36894acdc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/240ffe94.html title=設計濾波器堵住開關電源噪聲的方法？>設計濾波器堵住開關電源噪聲的方法？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aeb3d5.html alt=W波段矩形波導濾波器的設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/65c1000caa652a370e3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aeb3d5.html title=W波段矩形波導濾波器的設計>W波段矩形波導濾波器的設計</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>