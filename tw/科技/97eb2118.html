<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spark內存管理之一：靜態內存管理 | 极客快訊</title><meta property="og:title" content="Spark內存管理之一：靜態內存管理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e107f03d487c4d4c85b72a1f8bcb4bb4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97eb2118.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97eb2118.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/97eb2118.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97eb2118.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97eb2118.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/97eb2118.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/97eb2118.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97eb2118.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="Spark內存管理之一：靜態內存管理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/97eb2118.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spark內存管理之一：靜態內存管理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>Spark內存管理簡介</strong></h1><p>Spark從1.6開始引入了動態內存管理模式，即執行內存和存儲內存之間可以相互搶佔</p><p>Spark提供了2種內存分配模式：</p><ul><li>靜態內存管理</li><li>統一內存管理</li></ul><p>本系列文章將分別對這兩種內存管理模式的優缺點以及設計原理進行分析（主要基於Spark 1.6.1的內存管理進行分析）</p><p>在本篇文章中，將先對靜態內存管理進行介紹</p><h1><strong>堆內內存</strong></h1><p>在Spark最初採用的靜態內存管理機制下，存儲內存、執行內存和其它內存的大小在Spark應用程序運行期間均為固定的，但用戶可以在應用程序啟動前進行配置，堆內內存的分配如下圖所示：</p><div class=pgc-img><img alt=Spark內存管理之一：靜態內存管理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e107f03d487c4d4c85b72a1f8bcb4bb4><p class=pgc-img-caption></p></div><p>默認情況下，spark內存管理採用unified模式，如果要開啟靜態內存管理模式，需要將spark.memory.useLegacyMode參數調為true（默認為false），1.6.1版本的官網配置如下所示：</p><div class=pgc-img><img alt=Spark內存管理之一：靜態內存管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/364b8b2872834f488baf8665ea5d81ad><p class=pgc-img-caption></p></div><p>將參數調整為true之後，就會進入到靜態內存管理中來，可以通過SparkEnv.scala中發現：</p><div class=pgc-img><img alt=Spark內存管理之一：靜態內存管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19f6a529d8b9489f916c6353a5659fb0><p class=pgc-img-caption></p></div><pre>如果spark.memory.useLegacyMode為true，就進入到StaticMemoryManager（靜態內存管理）；如果為false，就進入到UnifiedMemoryManager（統一內存管理）；同時我們可以發現該參數的默認值為false，即默認情況下就會調用統一內存管理類。</pre><h1><strong>Execution內存</strong></h1><p><strong>可用的Execution內存</strong></p><p>用於shuffle操作的內存，取決於join、sort、aggregation等過程頻繁的IO需要的Buffer臨時數據存儲</p><p>簡單來說，spark在shuffle write的過程中，每個executor會將數據寫到該executor的物理磁盤上，下一個stage的task會去上一個stage拉取其所需要處理的數據，並且是邊拉取邊進行處理的（和MapReduce的拉取合併數據基本一樣），這個時候就會用到一個aggregate的數據結構，比如hashmap這種邊拉取數據邊進行聚合。這部分內存就被稱為execution內存</p><p>從StaticMemoryManager.scala中的getMaxExecutionMemory方法中，我們可以發現：</p><div class=pgc-img><img alt=Spark內存管理之一：靜態內存管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c45bcb4b7914468b9b766d01a1a80c4f><p class=pgc-img-caption></p></div><p>每個executor分配給execution的內存為：</p><pre>ExecutionMemory = systemMaxMemory * memoryFraction * safetyFraction 默認情況下為：systemMaxMemory * 0.2 * 0.8 = 0.16 * systemMaxMemory 即默認為executor最大可用內存 * 0.16</pre><p>Execution內存再運行的時候會被分配給運行在JVM上的task；這裡不同的是，分配給每個task的內存並不是固定的，而是動態的；spark不是一上來就分配固定大小的內存塊給task，而是允許一個task佔據JVM所有execution內存</p><p>每個JVM上的task可以最多申請至多1/N的execution內存，其中N為active task的個數，由spark.executor.cores指定；如果task的申請沒有被批准，它會釋放一部分內存，並且下次申請的時候，它會申請更小的一部分內存</p><p><strong>注：</strong></p><ul><li>每個Executor單獨運行在一個JVM進程中，每個Task則是運行在Executor中的線程</li><li>spark.executor.cores設置的是每個executor的core數量</li><li>task的數量就是partition的數量</li><li>一般來說，一個core設置2~4個partition</li></ul><p><strong>注意：</strong></p><p>為了防止過多的spilling數據，只有當一個task分配到的內存達到execution內存1/2N的時候才會spill，如果目前空閒的內存達不到1/2N的時候，內存申請會被阻塞直到其它的task spill掉它們的內存；</p><p>如果不這樣限制，假設當前一個任務佔據了絕大部分內存，那麼新來的task會一直往硬盤spill數據，這樣就會導致比較嚴重的I/O問題；而我們做了一定程度的限制，會進行一定程度的阻塞等待，對於頻繁的小數據集的I/O會有一定的減緩</p><p>例子：某executor先啟動一個task A，並在task B啟動前快速佔用了所有可用的內存；在B啟用之後N變成了2，task B會阻塞直到task A spill，自己可以獲得1/2N=1/4的execution內存的時候；而一大task B獲取到了1/4的內存，A和B就都有可能spill了</p><h1><strong>預留內存</strong></h1><p>Spark之所以會有一個SafetyFraction這樣的參數，是為了避免潛在的OOM。例如，進行計算時，有一個提前未預料到的比較大的數據，會導致計算時間延長甚至OOM，safetyFraction為storage和execution都提供了額外的buffer以防止此類的數據傾斜；這部分內存叫作預留內存</p><p><strong>Storage內存</strong></p><p><strong>可用的Storage內存</strong></p><p>該部分內存用作對RDD的緩存（如調用cache、persist等方法），節點間傳輸的廣播變量</p><p>StaticMemoryManager.scala中的getMaxStorageMemory方法發現：</p><div class=pgc-img><img alt=Spark內存管理之一：靜態內存管理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3b681936e0024ccfa850a997045e42dd><p class=pgc-img-caption></p></div><p>最後為每個executor分配到的storage的內存：</p><pre>StorageMemory = systemMaxMemory * memoryFraction * safetyFraction 默認情況下為：systemMaxMemory * 0.6 * 0.9 = 0.54 * systemMaxMemory 即默認分配executor最大可用內存的0.54</pre><p><strong>預留內存</strong></p><p>同Execution內存中的預留部分</p><h1><strong>Unroll</strong></h1><p>Unroll是storage中比較特殊的一部分，它默認佔據storage總內存的20%</p><p>BlockManager是spark自己實現的內部分佈式文件系統，BlockManager接受數據（可能從本地或者其他節點）的時候是以iterator的形式，並且這些數據是有序列化和非序列化的，因此需要注意以下兩點：</p><ul><li>Iterator在物理內存上是不連續的，如果後續spark要把數據裝載進內存的話，就需要把這些數據放進一個array（物理上連續）</li><li>另外，序列化數據需要進行展開，如果直接展開序列化的數據，會造成OOM，所以BlockManager會逐漸的展開這個iterator，並逐漸檢查內存裡是否還有足夠的空間用來展開數據放進array裡</li></ul><p>StaticMemoryManager.scala中的maxUnrollMemory方法：</p><div class=pgc-img><img alt=Spark內存管理之一：靜態內存管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0d6dd177b73f4941a0c0f87784f50586><p class=pgc-img-caption></p></div><p>Unroll的優先級別還是比較高的，它使用的內存空間是可以從storage中借用的，如果在storage中沒有現存的數據block，它甚至可以佔據整個storage空間；如果storage中有數據block，它可以最大drop掉內存的數據是通過spark.storage.unrollFraction來控制的，通過源碼可知這部分的默認值為0.2</p><p><strong>注意：</strong></p><p>這個20%的空間並不是靜態保留的，而是通過drop掉內存中的數據block來分配的（動態的分配過程）；如果unroll失敗了，spark會把這部分數據evict到硬盤中去</p><h1><strong>eviction策略</strong></h1><p>在spark技術文檔中，eviction一詞經常出現，eviction並不是單純字面上驅逐的意思。說句題外話，spark通常被我們叫做內存計算框架，但是從嚴格意義上說，spark並不是內存計算的新技術；無論是cache還是persist這類算子，spark在內存安排上，絕大多數用的都是LRU策略（LRU可以說是一種算法，也可以算是一種原則，用來判斷如何從Cache中清除對象，而LRU就是“近期最少使用”原則，當Cache溢出時，最近最少使用的對象將被從Cache中清除）。即當內存不夠的時候，會evict掉最遠使用過的內存數據block；當evict的時候，spark會將該數據塊evict到硬盤，而不是單純的拋棄掉</p><p>無論是storage還是execution的內存空間，當內存區域的空間不夠用的時候，spark都會evict數據到硬盤</p><h1><strong>Other部分</strong></h1><p>這部分的內存用於程序本身運行所需要的內存，以及用戶定義的數據結構和創建的對象，此內存由上面兩部分：storage、execution決定的，默認為0.2</p><h1><strong>堆外內存</strong></h1><p>Spark1.6開始引入了Off-heap memory（詳見SPARK-11389）</p><p>堆外的空間分配較為簡單，只有存儲內存和執行內存，如圖所示：</p><div class=pgc-img><img alt=Spark內存管理之一：靜態內存管理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1254a62ae495409d901105b160eab356><p class=pgc-img-caption></p></div><p>可用的執行內存和存儲內存佔用的空間大小直接由參數 spark.memory.storageFraction 決定（默認為0.5），由於堆外內存佔用的空間可以被精確計算，所以無需再設定保險區域</p><h1><strong>侷限性</strong></h1><p>在Spark的設計文檔中，指出了靜態內存管理的侷限性：</p><p>沒有適用於所有應用的默認配置，通常需要開發人員針對不同的應用進行不同的參數進行配置：比如根據任務的執行邏輯，調整shuffle和storage的內存佔比來適應任務的需求</p><p>這樣需要開發人員具備較高的spark原理知識</p><p>那些不cache數據的應用在運行的時候只會佔用一小部分可用內存，而默認的內存配置中storage就用去了60%，造成了浪費</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>內存</a></li><li><a>Spark</a></li><li><a>靜態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html alt=動態網站和靜態網站有什麼區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6a06f21d115b4b93a7934a7075691503 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html title=動態網站和靜態網站有什麼區別>動態網站和靜態網站有什麼區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4d77858.html alt=動、靜態扭矩在汽車裝配緊固件中的應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/21327d489e004cc7bcd527476b85fe20 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4d77858.html title=動、靜態扭矩在汽車裝配緊固件中的應用>動、靜態扭矩在汽車裝配緊固件中的應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/504824bb.html alt=動/靜態測評福特銳界：銷量下滑真因分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4b668e90219f4f64b68c2340ecec2e96 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/504824bb.html title=動/靜態測評福特銳界：銷量下滑真因分析>動/靜態測評福特銳界：銷量下滑真因分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc721d71.html alt=單例模式VS靜態方法：你應該何去何從？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b3079753ad7344f68a7837c3bdd3e666 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc721d71.html title=單例模式VS靜態方法：你應該何去何從？>單例模式VS靜態方法：你應該何去何從？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/550e74eb.html alt=精品資源：共點力中的“靜態平衡”問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/dcba441875164a9cb4ba9fb600913828 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/550e74eb.html title=精品資源：共點力中的“靜態平衡”問題>精品資源：共點力中的“靜態平衡”問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html alt=內存屏障詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html title=內存屏障詳解>內存屏障詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html alt=C語言學習篇(3)-----內存編址和對齊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e039d89a145f4e258f5f6eb28d04809b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html title=C語言學習篇(3)-----內存編址和對齊>C語言學習篇(3)-----內存編址和對齊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html alt=內存按字節編址例題解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/87f6444a27d34916b6e72824f6e98572 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html title=內存按字節編址例題解析>內存按字節編址例題解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html alt="【歷史】內存的故事 (紀念DRAM量產50年)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RQUkuARBMJpAR2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html title="【歷史】內存的故事 (紀念DRAM量產50年)">【歷史】內存的故事 (紀念DRAM量產50年)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html alt=滲透測試——內存攻擊原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ae687b82fd824bafafb7c6792c260a98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html title=滲透測試——內存攻擊原理>滲透測試——內存攻擊原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/521cfbb3.html alt=端到端一致性，流系統Spark/Flink/Kafka/DataFlow對比總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e21d09c33a9447aba53883736c891f10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/521cfbb3.html title=端到端一致性，流系統Spark/Flink/Kafka/DataFlow對比總結>端到端一致性，流系統Spark/Flink/Kafka/DataFlow對比總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/172c1635.html alt=彙編程序設計：LCD1602靜態顯示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6a6da6f7cb234b5d87c4a787ccc4895a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/172c1635.html title=彙編程序設計：LCD1602靜態顯示>彙編程序設計：LCD1602靜態顯示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html alt=內存容量如何計算，瞭解一些基礎知識，你就懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d9065c724be64660aee58a3257a23534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html title=內存容量如何計算，瞭解一些基礎知識，你就懂了！>內存容量如何計算，瞭解一些基礎知識，你就懂了！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>