<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>全網最全，面試常問的HashMap知識點 | 极客快訊</title><meta property="og:title" content="全網最全，面試常問的HashMap知識點 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8beece4ad1a04af88b7903f4563b7863"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97f1e40e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97f1e40e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/97f1e40e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97f1e40e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97f1e40e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/97f1e40e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/97f1e40e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/97f1e40e.html><meta property="article:published_time" content="2020-10-29T21:09:21+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:21+08:00"><meta name=Keywords content><meta name=description content="全網最全，面試常問的HashMap知識點"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/97f1e40e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>全網最全，面試常問的HashMap知識點</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>引言</strong></p><p>其實我很早以前就想寫一篇關於HashMap的面試專題。對於JAVA求職者來說，HashMap可謂是集合類的重中之重，甚至你在複習的時候，其他集合類都不用看，專攻HashMap即可。</p><p>然而，鑑於網上大部分的關於HashMap的面試方向文章，煙哥看過後都不是太滿意。因此，斗膽嘗試也寫一篇關於HashMap的面試專題文章!</p><p><strong>正文</strong></p><p><strong>(1)HashMap的實現原理?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>你看過HashMap源碼嘛，知道原理嘛?</li><li>為什麼用數組+鏈表？</li><li>hash衝突你還知道哪些解決辦法？</li><li>我用LinkedList代替數組結構可以麼?</li><li>既然是可以的,為什麼HashMap不用LinkedList,而選用數組?</li></ul><p><em>你看過HashMap源碼嘛，知道原理嘛?</em></p><p>針對這個問題，嗯，當然是必須看過HashMap源碼。至於原理，下面那張圖很清楚了:</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全網最全，面試常問的HashMap知識點 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8beece4ad1a04af88b7903f4563b7863><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>HashMap採用Entry數組來存儲key-value對，每一個鍵值對組成了一個Entry實體，Entry類實際上是一個單向的鏈表結構，它具有Next指針，可以連接下一個Entry實體。</p><p>只是在JDK1.8中，鏈表長度大於8的時候，鏈表會轉成紅黑樹！</p><p><em>為什麼用數組+鏈表？</em></p><p>數組是用來確定桶的位置，利用元素的key的hash值對數組長度取模得到.</p><p>鏈表是用來解決hash衝突問題，當出現hash值一樣的情形，就在數組上的對應位置形成一條鏈表。ps:這裡的hash值並不是指hashcode，而是將hashcode高低十六位異或過的。至於為什麼要這麼做，繼續往下看。</p><p><em>hash衝突你還知道哪些解決辦法？</em></p><p>比較出名的有四種(1)開放定址法(2)鏈地址法(3)再哈希法(4)公共溢出區域法</p><p>ps:大家有興趣拓展的，自己去搜一下就懂了，這個就不拓展了！</p><p><em>我用LinkedList代替數組結構可以麼?</em></p><p>這裡我稍微說明一下，此題的意思是，源碼中是這樣的</p><pre>Entry[] table = new Entry[capacity];</pre><p>ps：Entry就是一個鏈表節點。</p><p>那我用下面這樣表示</p><pre>List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;(); </pre><p>是否可行?</p><p>答案很明顯，必須是可以的。</p><p><em>既然是可以的,為什麼HashMap不用LinkedList,而選用數組?</em></p><p>因為用數組效率最高！</p><p>在HashMap中，定位桶的位置是利用元素的key的哈希值對數組長度取模得到。此時，我們已得到桶的位置。顯然數組的查找效率比LinkedList大。</p><p><em>那ArrayList，底層也是數組，查找也快啊，為啥不用ArrayList?</em></p><p>(煙哥寫到這裡的時候，不禁覺得自己真有想法，自己把自己問死了，還好我靈機一動想出了答案)</p><p>因為採用基本數組結構，擴容機制可以自己定義，HashMap中數組擴容剛好是2的次冪，在做取模運算的效率高。</p><p>而ArrayList的擴容機制是1.5倍擴容，那ArrayList為什麼是1.5倍擴容這就不在本文說明了。</p><p><strong>(2)HashMap在什麼條件下擴容?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>HashMap在什麼條件下擴容?</li><li>為什麼擴容是2的n次冪?</li><li>為什麼為什麼要先高16位異或低16位再取模運算?</li></ul><p><em>HashMap在什麼條件下擴容?</em></p><p>如果bucket滿了(超過load factor*current capacity)，就要resize。</p><p>load factor為0.75，為了最大程度避免哈希衝突</p><p>current capacity為當前數組大小。</p><p><em>為什麼擴容是2的次冪?</em></p><p>HashMap為了存取高效，要儘量較少碰撞，就是要儘量把數據分配均勻，每個鏈表長度大致相同，這個實現就在把數據存到哪個鏈表中的算法；這個算法實際就是取模，hash%length。</p><p>但是，大家都知道這種運算不如位移運算快。</p><p>因此，源碼中做了優化hash&(length-1)。</p><p>也就是說hash%length==hash&(length-1)</p><p>那為什麼是2的n次方呢？</p><p>因為2的n次方實際就是1後面n個0，2的n次方-1，實際就是n個1。</p><p>例如長度為8時候，3&(8-1)=3 2&(8-1)=2 ，不同位置上，不碰撞。</p><p>而長度為5的時候，3&(5-1)=0 2&(5-1)=0，都在0上，出現碰撞了。</p><p>所以，保證容積是2的n次方，是為了保證在做(length-1)的時候，每一位都能&1 ，也就是和1111……1111111進行與運算。</p><p><em>為什麼為什麼要先高16位異或低16位再取模運算?</em></p><p>我先晒一下，jdk1.8裡的hash方法。1.7的比較複雜，咱就不看了。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全網最全，面試常問的HashMap知識點 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/785d67a3c44c4e9a87e5b3e1a55c8aab><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>hashmap這麼做，只是為了降低hash衝突的機率。</p><p>打個比方，當我們的length為16的時候，哈希碼(字符串“abcabcabcabcabc”的key對應的哈希碼)對(16-1)與操作，對於多個key生成的hashCode，只要哈希碼的後4位為0，不論不論高位怎麼變化，最終的結果均為0。</p><p>如下圖所示</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全網最全，面試常問的HashMap知識點 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/53826427e216409a92d0cd91452fd20d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>而加上高16位異或低16位的“擾動函數”後，結果如下</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全網最全，面試常問的HashMap知識點 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/59a69e76e55e462b9f7943293689cc99><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>可以看到: 擾動函數優化前：1954974080 % 16 = 1954974080 & (16 - 1) = 0 擾動函數優化後：1955003654 % 16 = 1955003654 & (16 - 1) = 6 很顯然，減少了碰撞的機率。</p><p><strong>(3)講講hashmap的get/put的過程?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>知道hashmap中put元素的過程是什麼樣麼?</li><li>知道hashmap中get元素的過程是什麼樣麼？</li><li>你還知道哪些hash算法？</li><li>說說String中hashcode的實現?(此題很多大廠問過)</li></ul><p><em>知道hashmap中put元素的過程是什麼樣麼?</em></p><p>對key的hashCode()做hash運算，計算index;</p><p>如果沒碰撞直接放到bucket裡；</p><p>如果碰撞了，以鏈表的形式存在buckets後；</p><p>如果碰撞導致鏈表過長(大於等於TREEIFY_THRESHOLD)，就把鏈表轉換成紅黑樹(JDK1.8中的改動)；</p><p>如果節點已經存在就替換old value(保證key的唯一性)</p><p>如果bucket滿了(超過load factor*current capacity)，就要resize。</p><p><em>知道hashmap中get元素的過程是什麼樣麼?</em></p><p>對key的hashCode()做hash運算，計算index;</p><p>如果在bucket裡的第一個節點裡直接命中，則直接返回；</p><p>如果有衝突，則通過key.equals(k)去查找對應的Entry;</p><ul><li>若為樹，則在樹中通過key.equals(k)查找，O(logn)；</li><li>若為鏈表，則在鏈表中通過key.equals(k)查找，O(n)。</li></ul><p><em>你還知道哪些hash算法？</em></p><p>先說一下hash算法幹嘛的，Hash函數是指把一個大範圍映射到一個小範圍。把大範圍映射到一個小範圍的目的往往是為了節省空間，使得數據容易保存。</p><p>比較出名的有MurmurHash、MD4、MD5等等</p><p><em>說說String中hashcode的實現?(此題頻率很高)</em></p><pre>public int hashCode() { int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) { char val[] = value; for (int i = 0; i &lt; value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h;}</pre><p>String類中的hashCode計算方法還是比較簡單的，就是以31為權，每一位為字符的ASCII值進行運算，用自然溢出來等效取模。</p><p>哈希計算公式可以計為<strong>s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1]</strong></p><p>那為什麼以31為質數呢?</p><p>主要是因為31是一個奇質數，所以31*i=32*i-i=(i&lt;&lt;5)-i，這種位移與減法結合的計算相比一般的運算快很多。</p><p><strong>(4)為什麼hashmap的在鏈表元素數量超過8時改為紅黑樹?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>知道jdk1.8中hashmap改了啥麼?</li><li>為什麼在解決hash衝突的時候，不直接用紅黑樹?而選擇先用鏈表，再轉紅黑樹?</li><li>我不用紅黑樹，用二叉查找樹可以麼?</li><li>那為什麼閥值是8呢?</li><li>當鏈表轉為紅黑樹後，什麼時候退化為鏈表?</li></ul><p><em>知道jdk1.8中hashmap改了啥麼?</em></p><ul><li>由<strong>數組+鏈表</strong>的結構改為<strong>數組+鏈表+紅黑樹</strong>。</li><li>優化了高位運算的hash算法：h^(h>>>16)</li><li>擴容後，元素要麼是在原位置，要麼是在原位置再移動2次冪的位置，且鏈表順序不變。</li></ul><p>最後一條是重點，因為最後一條的變動，hashmap在1.8中，不會在出現死循環問題。</p><p><em>為什麼在解決hash衝突的時候，不直接用紅黑樹?而選擇先用鏈表，再轉紅黑樹?</em></p><p>因為紅黑樹需要進行左旋，右旋，變色這些操作來保持平衡，而單鏈表不需要。</p><p>當元素小於8個當時候，此時做查詢操作，鏈表結構已經能保證查詢性能。當元素大於8個的時候，此時需要紅黑樹來加快查詢速度，但是新增節點的效率變慢了。</p><p>因此，如果一開始就用紅黑樹結構，元素太少，新增效率又比較慢，無疑這是浪費性能的。</p><p><em>我不用紅黑樹，用二叉查找樹可以麼?</em></p><p>可以。但是二叉查找樹在特殊情況下會變成一條線性結構（這就跟原來使用鏈表結構一樣了，造成很深的問題），遍歷查找會非常慢。</p><p><em>那為什麼閥值是8呢?</em></p><p>不知道，等jdk作者來回答。</p><p>這道題，網上能找到的答案都是扯淡。</p><p>我隨便貼一個牛客網的答案，如下圖所示</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全網最全，面試常問的HashMap知識點 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9612ca18915c4ef7b9f131e9e374c008><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>看出bug沒？交點是6.64？交點分明是4，好麼。</p><p>log4=2，4/2=2。</p><p>jdk作者選擇8，一定經過了嚴格的運算，覺得在長度為8的時候，與其保證鏈表結構的查找開銷，不如轉換為紅黑樹，改為維持其平衡開銷。</p><p><em>當鏈表轉為紅黑樹後，什麼時候退化為鏈表?</em></p><p>為6的時候退轉為鏈表。中間有個差值7可以防止鏈表和樹之間頻繁的轉換。假設一下，如果設計成鏈表個數超過8則鏈表轉換成樹結構，鏈表個數小於8則樹結構轉換成鏈表，如果一個HashMap不停的插入、刪除元素，鏈表個數在8左右徘徊，就會頻繁的發生樹轉鏈表、鏈表轉樹，效率會很低。</p><p><strong>(5)HashMap的併發問題?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>HashMap在併發編程環境下有什麼問題啊?</li><li>在jdk1.8中還有這些問題麼?</li><li>你一般怎麼解決這些問題的？</li></ul><p><em>HashMap在併發編程環境下有什麼問題啊?</em></p><ul><li>(1)多線程擴容，引起的死循環問題</li><li>(2)多線程put的時候可能導致元素丟失</li><li>(3)put非null元素後get出來的卻是null</li></ul><p><em>在jdk1.8中還有這些問題麼?</em></p><p>在jdk1.8中，死循環問題已經解決。其他兩個問題還是存在。</p><p><em>你一般怎麼解決這些問題的？</em></p><p>比如ConcurrentHashmap，Hashtable等線程安全等集合類。</p><p><strong>(6)你一般用什麼作為HashMap的key?</strong></p><p>此題可以組成如下連環炮來問</p><ul><li>健可以為Null值麼?</li><li>你一般用什麼作為HashMap的key?</li><li>我用可變類當HashMap的key有什麼問題?</li><li>如果讓你實現一個自定義的class作為HashMap的key該如何實現？</li></ul><p><em>健可以為Null值麼?</em></p><p>必須可以，key為null的時候，hash算法最後的值以0來計算，也就是放在數組的第一個位置。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全網最全，面試常問的HashMap知識點 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/785d67a3c44c4e9a87e5b3e1a55c8aab><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><em>你一般用什麼作為HashMap的key?</em></p><p>一般用Integer、String這種不可變類當HashMap當key，而且String最為常用。</p><ul><li>(1)因為字符串是不可變的，所以在它創建的時候hashcode就被緩存了，不需要重新計算。這就使得字符串很適合作為Map中的鍵，字符串的處理速度要快過其它的鍵對象。這就是HashMap中的鍵往往都使用字符串。</li><li>(2)因為獲取對象的時候要用到equals()和hashCode()方法，那麼鍵對象正確的重寫這兩個方法是非常重要的,這些類已經很規範的覆寫了hashCode()以及equals()方法。</li></ul><p><em>我用可變類當HashMap的key有什麼問題?</em></p><p>hashcode可能發生改變，導致put進去的值，無法get出，如下所示</p><pre>HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;();List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("hello");Object objectValue = new Object();changeMap.put(list, objectValue);System.out.println(changeMap.get(list));list.add("hello world");//hashcode發生了改變System.out.println(changeMap.get(list));</pre><p>輸出值如下</p><pre>java.lang.Object@74a14482null</pre><p><em>如果讓你實現一個自定義的class作為HashMap的key該如何實現？</em></p><p>此題考察兩個知識點</p><ul><li>重寫hashcode和equals方法注意什麼?</li><li>如何設計一個不變類</li></ul><p>針對問題一，記住下面四個原則即可</p><p>(1)兩個對象相等，hashcode一定相等</p><p>(2)兩個對象不等，hashcode不一定不等</p><p>(3)hashcode相等，兩個對象不一定相等</p><p>(4)hashcode不等，兩個對象一定不等</p><p>針對問題二，記住如何寫一個不可變類</p><p>(1)類添加final修飾符，保證類不被繼承。</p><p>如果類可以被繼承會破壞類的不可變性機制，只要繼承類覆蓋父類的方法並且繼承類可以改變成員變量值，那麼一旦子類以父類的形式出現時，不能保證當前類是否可變。</p><p>(2)保證所有成員變量必須私有，並且加上final修飾</p><p>通過這種方式保證成員變量不可改變。但只做到這一步還不夠，因為如果是對象成員變量有可能再外部改變其值。所以第4點彌補這個不足。</p><p>(3)不提供改變成員變量的方法，包括setter</p><p>避免通過其他接口改變成員變量的值，破壞不可變特性。</p><p>(4)通過構造器初始化所有成員，進行深拷貝(deep copy)</p><p>如果構造器傳入的對象直接賦值給成員變量，還是可以通過對傳入對象的修改進而導致改變內部變量的值。例如：</p><pre>public final class ImmutableDemo {  private final int[] myArray;  public ImmutableDemo(int[] array) {  this.myArray = array; // wrong  } }</pre><p>這種方式不能保證不可變性，myArray和array指向同一塊內存地址，用戶可以在ImmutableDemo之外通過修改array對象的值來改變myArray內部的值。</p><p>為了保證內部的值不被修改，可以採用深度copy來創建一個新內存保存傳入的值。正確做法：</p><pre>public final class MyImmutableDemo {  private final int[] myArray;  public MyImmutableDemo(int[] array) {  this.myArray = array.clone();  } }</pre><p>(5)在getter方法中，不要直接返回對象本身，而是克隆對象，並返回對象的拷貝</p><p>這種做法也是防止對象外洩，防止通過getter獲得內部可變成員對象後對成員變量直接操作，導致成員變量發生改變。</p><p><strong>總結</strong></p><p>這篇文章能概括大部分HashMap的面試題了，希望大家有所收穫！</p><p>原文：https://mp.weixin.qq.com/s/EZQHek-gl2SVnDRQs16nOw</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>全網</a></li><li><a>面試</a></li><li><a>常問</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html alt=全網流行的像素風插畫怎麼做？看這篇教程就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c6a523bb05004ed59ac7080c46f41e10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html title=全網流行的像素風插畫怎麼做？看這篇教程就夠了>全網流行的像素風插畫怎麼做？看這篇教程就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d65aa7b.html alt=全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/76ac70f31cde4c3f8b3f073b28660a91 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d65aa7b.html title=全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？>全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/abb4a186.html alt="這應該是全網講解JAVA 異常處理最全的文章了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b29b2b140f7e4922b0f2ecdff264f228 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/abb4a186.html title="這應該是全網講解JAVA 異常處理最全的文章了">這應該是全網講解JAVA 異常處理最全的文章了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html alt="不怕面試被問了！二叉樹算法大盤點 | 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html title="不怕面試被問了！二叉樹算法大盤點 | 原力計劃">不怕面試被問了！二叉樹算法大盤點 | 原力計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html title="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~">別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>