<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android屏幕適配方案 | 极客快訊</title><meta property="og:title" content="Android屏幕適配方案 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1536979578666979cb313e1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9829b890.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9829b890.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9829b890.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9829b890.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9829b890.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9829b890.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9829b890.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9829b890.html><meta property="article:published_time" content="2020-10-29T21:10:52+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:52+08:00"><meta name=Keywords content><meta name=description content="Android屏幕適配方案"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9829b890.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android屏幕適配方案</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>目錄介紹</p><ul><li>1.屏幕適配定義</li><li>2.相關重要的概念</li><li class=ql-indent-1>2.1 屏幕尺寸[<strong>物理尺寸</strong>]</li><li class=ql-indent-1>2.2 屏幕分辨率[<strong>px</strong>]</li><li class=ql-indent-1>2.3 屏幕像素密度[<strong>dpi</strong>]</li><li class=ql-indent-1>2.4 dp、dip、dpi、sp、px</li><li class=ql-indent-1>2.5 mdpi、hdpi、xdpi、xxdpi</li><li class=ql-indent-1>2.6 獲取屏幕分辨率[寬高]</li><li>3.Android屏幕適配出現的原因</li><li class=ql-indent-1>3.1 什麼是像素點</li><li class=ql-indent-1>3.2 dp與百分比</li><li>4.Android適配問題及本質</li><li class=ql-indent-1>4.1 尺寸適配</li><li class=ql-indent-1>4.2 代碼適配</li><li class=ql-indent-1>4.3 佈局適配</li><li class=ql-indent-1>4.4 權重適配</li><li class=ql-indent-1>4.5 圖片適配</li><li class=ql-indent-1>4.6 百分比適配</li><li>5.存在問題和困境</li><li class=ql-indent-1>5.1 通配符適配困境</li><li class=ql-indent-1>5.2 傳統dp適配困境</li><li>6.常用解決方案</li><li class=ql-indent-1>6.1 今日頭條適配方案</li><li class=ql-indent-1>6.2 鴻洋大神庫</li><li class=ql-indent-1>6.3 AndroidAutoSize</li></ul><p>1.屏幕適配定義</p><ul><li>使得某一元素在Android不同尺寸、不同分辨率的手機上具備相同的顯示效果</li></ul><p>2.相關重要的概念</p><p>2.1 屏幕尺寸[<strong>物理尺寸</strong>]</p><ul><li>含義：手機對角線的物理尺寸</li><li>單位：英寸（inch），1英寸=2.54cm</li><li>Android手機常見的尺寸有5寸、5.5寸、6寸等等</li></ul><p>2.2 屏幕分辨率[<strong>px</strong>]</p><ul><li>含義：手機在橫向、縱向上的像素點數總和</li><li>一般描述成屏幕的"寬x高”=AxB</li><li>含義：屏幕在橫向方向（寬度）上有A個像素點，在縱向方向 （高）有B個像素點</li><li>例子：1080x1920，即寬度方向上有1080個像素點，在高度方向上有1920個像素點</li><li>單位：px（pixel），1px=1像素點</li><li>Android手機常見的分辨率：720x1280、1080x1920等等</li></ul><p>2.3 屏幕像素密度[<strong>dpi</strong>]</p><ul><li>含義：每英寸的像素點數</li><li>單位：dpi（dots per ich）</li><li>假設設備內每英寸有160個像素，那麼該設備的屏幕像素密度=160dpi</li><li>屏幕像素密度與屏幕尺寸和屏幕分辨率有關，在單一變化條件下，屏幕尺寸越小、分辨率越高，像素密度越大，反之越小。</li><li>dpi計算公式：舉個例子：屏幕分辨率為：1920*1080，屏幕尺寸為5吋的話，那麼dpi為440</li></ul><div class=pgc-img><img alt=Android屏幕適配方案 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1536979578666979cb313e1><p class=pgc-img-caption></p></div><ul><li><br></li><li><strong>注意：dpi是根據屏幕真實的分辨率和尺寸來計算的，每個設備都可能不一樣的</strong></li></ul><p>2.4 dp[dip]、dpi、sp、px</p><ul><li>dp（dip）：px = dp * 密度比，都是Density Independent Pixels的縮寫，即密度無關像素</li><li>dpi：開方（寬度平方 + 高度平方） / 手機的尺寸；dpi是屏幕像素密度，假如一英寸裡面有160個像素，這個屏幕的像素密度就是160dpi</li><li>sp： 可以根據文字大小首選項進行放縮，是設置字體大小的御用單位。</li><li>px： 像素，px是比較熟悉，前面的分辨率就是用的像素為單位，大多數情況下，比如UI設計、Android原生API都會以px作為統一的計量單位，像素是獲取屏幕寬高等。</li><li>問題： dp和px如何換算呢？</li></ul><pre>px = density * dp;density = dpi / 160;px = dp * (dpi / 160);</pre><p>2.5 mdpi、hdpi、xdpi、xxdpi</p><ul><li>2.5.1 作用： mdpi、hdpi、xdpi、xxdpi用來修飾Android中的drawable文件夾及values文件夾，用來區分不同像素密度下的圖片和dimen值。</li></ul><pre>名稱像 素密度範圍ldpi 0dpi~120dpimdpi 120dpi~160dpihdpi 120dpi~160dpixdpi 160dpi~240dpixxdpi 240dpi~320dpixxxdpi 480dpi~640dpiAndroid項目後應該可以看到很多drawable文件夾，分別對應不同的dpidrawable-ldpi (dpi=120, density=0.75)drawable-mdpi (dpi=160, density=1)drawable-hdpi (dpi=240, density=1.5)drawable-xhdpi (dpi=320, density=2)drawable-xxhdpi (dpi=480, density=3)對於五種主流的像素密度（MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI）應按照 2:3:4:6:8 的比例進行縮放。</pre><ul><li>2.5.2 在進行開發的時候，我們需要把合適大小的圖片放在合適的文件夾裡面。下面以圖標設計為例進行介紹</li><li>2.5.3 在設計圖標時，對於五種主流的像素密度（MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI）應按照 2:3:4:6:8 的比例進行縮放。</li><li class=ql-indent-1>例如，一個啟動圖標的尺寸為48x48 dp，這表示在 MDPI 的屏幕上其實際尺寸應為 48x48 px，在 HDPI 的屏幕上其實際大小是 MDPI 的 1.5 倍 (72x72 px)，在 XDPI 的屏幕上其實際大小是 MDPI 的 2 倍 (96x96 px)，依此類推。</li><li>2.5.4 下圖為圖標的各個屏幕密度的對應尺寸：</li></ul><pre>屏幕密度 圖標尺寸mdpi 48X48pxhdpi 72X72pxxdpi 96X96pxxxdpi 144X144pxxxxdpi 192X192px</pre><p>2.6 DisplayMetrics解析</p><ul><li>DisplayMetrics解析</li><li>獲取屏幕分辨率信息的三種方法：</li></ul><pre>//第一種DisplayMetrics metrics = new DisplayMetrics();Display display = activity.getWindowManager().getDefaultDisplay();display.getMetrics(metrics);//第二種DisplayMetrics metrics= activity.getResources().getDisplayMetrics();//第三種Resources.getSystem().getDisplayMetrics();</pre><p>3.Android屏幕適配出現的原因</p><p>3.1 什麼是像素點</p><ul><li>屏幕分辨率是指在橫縱向上的像素點數，單位是px，1px=1個像素點。</li><li>一般以縱向像素<em>橫向像素，如1960</em>1080。 由於Android系統的開放性，任何用戶、開發者、OEM廠商、運營商都可以對Android進行定製，修改成他們想要的樣子。 屏幕尺寸這麼多，為了讓我們開發的程序能夠比較美觀的顯示在不同尺寸、分辨率、像素密度(這些概念我會在下面詳細講解)的設備上，那就要在開發的過程中進行處理，至於如何去進行處理，這就是我們今天的主題。</li></ul><p>3.2 dp與百分比 (網頁前端提供百分比，所以無需適配)</p><ul><li>只要記住一點dp是與像素無關的，在實際使用中1dp大約等於1/160inch</li><li>那麼dp究竟解決了適配上的什麼問題？可以看出1dp = 1/160inch；那麼它至少能解決一個問題，就是你在佈局文件寫某個View的寬和高為160dp*160dp，這個View在任何分辨率的屏幕中，顯示的尺寸大小是大約是一致的（可能不精確），大概是 1 inch * 1 inch。</li><li class=ql-indent-1>1.呈現效果仍舊會有差異，僅僅是相近而已</li></ul><ol><li class=ql-indent-1>當設備的物理尺寸存在差異的時候，dp就顯得無能為力了。為4.3寸屏幕準備的UI，運行在5.0寸的屏幕上，很可能在右側和下側存在大量的空白。而5.0寸的UI運行到4.3寸的設備上，很可能顯示不下。</li></ol><ul><li>一句話，總結下，dp能夠讓同一數值在不同的分辨率展示出大致相同的尺寸大小。但是當設備的尺寸差異較大的時候，就無能為力了。</li></ul><p>4.Android屏幕適配常見方法</p><p>4.1 適配常見方法</p><ul><li>尺寸適配</li><li>dimen適配</li><li>佈局適配</li><li>代碼適配</li><li>圖片適配</li></ul><p>4.2 尺寸適配</p><ul><li>4.2.1 佈局文件設置寬高</li><li>寬高設置參數：有的時候用dp，有的時候用px，大多數用dp</li><li>dp：dp（dip）：px = dp * 密度比，與屏幕像素有對應關係，設置成dp後，在不同分辨率的手機上有可能尺寸會不一樣 px：像素，比如小分辨率手機上一像素和大分辨率手機上一像素，所顯示的圖像是不一樣的 理解dp和px之間對應的關係，不同分辨率的手機用不同的dp值來適配</li><li>4.2.2 密度比</li><li>密度比是固定的，可以查詢文檔Develop—>API Guides—>Best Practices—>Supporting Multiple mdpi手機：160dpi 是基準線，1px = 1dp * 1，其他手機的密度比 = 自己的dpi/160</li><li>代碼獲取密度比：getResources().getDisplayMetrics().density</li></ul><pre>ldip：120px = 160dp * 0.75mdpi：160px = 160dp * 1hdpi：240px = 160dp * 1.5xhdpi：360px = 180dp * 2</pre><ul><li>4.2.3 dimen適配</li></ul><pre>1.在默認的values中的dimens文件下聲明(類似於Strings.xml) &lt;dimen name="activity_horizontal_margin"&gt;16dp&lt;/dimen&gt; &lt;dimen name="activity_vertical_margin"&gt;16dp&lt;/dimen&gt; &lt;dimen name="harlWidth"&gt;160dp&lt;/dimen&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;!-- values-hdpi 480X800 --&gt; &lt;dimen name="imagewidth"&gt;120dip&lt;/dimen&gt; &lt;/resources&gt;&lt;resources&gt; &lt;!-- values-hdpi-1280x800 --&gt; &lt;dimen name="imagewidth"&gt;220dip&lt;/dimen&gt; &lt;/resources&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;!-- values-hdpi 480X320 --&gt; &lt;dimen name="imagewidth"&gt;80dip&lt;/dimen&gt; &lt;/resources&gt;2.在佈局文件中引用&lt;TextView android:layout_width="@dimen/harlWidth" android:layout_height="wrap_content" android:background="#0ff" android:text="@string/hello_world" /&gt;3.新建需要適配的values-XXX(比如values-1280x720，注意規範大值在前)4.在新建values-1280x720中的dimens.xml文件中	* &lt;dimen name="harlWidth"&gt;180dp&lt;/dimen&gt;5.所有手機適配找對應的默認的dimens	* 思考：如何計算dpi？如何計算手機密度比？能夠用dp適配所有手機嗎？	* dp不能適配所有手機；	* 舉個例子：按鈕佔屏幕寬度一半，把寬度設置成160dp，120px和160px和240px可以佔屏幕一半，但是360px則小於屏幕一半；	* 如果把寬度設置成180dp，那麼360dp可以佔屏幕一半，但其他幾個又不行。	* 如果要適配所有手機的控件寬度為屏幕寬度的一半，該怎麼做呢？用dimen</pre><p>4.2 代碼適配</p><p>4.3 佈局適配，有可能在不同的手機佈局中，控件排列的位置不一樣</p><ul><li>1.位置不一樣</li><li class=ql-indent-1>不同的手機在運行的時候選擇不同的佈局(佈局名稱一樣，類似於dimens)，比如：</li><li>2.控件不一樣</li><li class=ql-indent-1>不能用佈局適配了；為什麼？</li><li class=ql-indent-1>佈局能夠實現界面效果，但是完成佈局後在代碼中，由於控件都不一樣，所以會找這兩套佈局的id，還要做判斷，根據不同的佈局做兩套代碼(如果頁面複雜，給控件設置參數等十分繁瑣)</li><li>3.適用場景</li><li class=ql-indent-1>不同的手機的控件的位置不一樣，發生了位置變化才會用到佈局適配，實際開發中用的很少</li></ul><p>4.4 權重適配</p><p>4.5 圖片適配</p><ul><li>1.圖片的查找順序</li><li class=ql-indent-1>注意：一般手機 ldpi&lt;drawable&lt;mdpi&lt;hdpi&lt;xhdpi&lt;xxhdpi 先找自己對應的文件夾，再找大分辨率，再找小分辨率</li><li class=ql-indent-1>注意：mdpi手機 ldpi&lt;mdpi&lt;drawable&lt;hdpi&lt;xhdpi&lt;xxhdpi 先找自己對應的文件夾，找drawable文件夾，再找大分辨率，再找小分辨率</li><li class=ql-indent-1>適配主流手機，1920 * 1080 1080 * 720 800 * 480，高清圖、背景圖（全屏展示）準備多套 。小圖片 準備一套高分辨率的；比如按鈕，圖標等</li><li class=ql-indent-1>為了是apk瘦身，有些圖片不要準備多套，Android分辨率種類太多了；即使適配主流手機，展示比較清楚的背景圖(比如：歡迎界面)，可以準備多套</li><li>2.在小分辨率展示高清圖，放到大分辨率會出現什麼情況呢？</li><li class=ql-indent-1>比如：你針對800<em>480分辨率手機做了背景圖圖片，正好完全展示；如果把它放到大分辨率1280</em>720上，會對圖片進行拉伸，會使像素點變大，可能會看到鋸齒或者模糊的東西</li></ul><p>5.存在問題和困境</p><p>5.1 通配符適配困境</p><p>5.2 傳統dp適配困境</p><ul><li>[<strong>摘自頭條</strong>]一般我們設計圖都是以固定的尺寸來設計的。比如以分辨率750px * 1334px來設計，以density為3來標註，也就是屏幕其實是350dp * 667dp。如果想在所有設備上顯示完全一致，其實是不現實的，因為屏幕高寬比不是固定的，各種寬高比層出不窮，寬高比不同，顯示完全一致就不可能了。但是通常下，我們只需要以寬或高一個維度去適配，比如我們Feed是上下滑動的，只需要保證在所有設備中寬的維度上顯示一致即可，再比如一個不支持上下滑動的頁面，那麼需要保證在高這個維度上都顯示一致，尤其不能存在某些設備上顯示不全的情況。同時考慮到現在基本都是以dp為單位去做的適配，如果新的方案不支持dp，那麼遷移成本也非常高。</li><li>因此，總結下大致需求如下：</li><li class=ql-indent-1><strong>支持以寬或者高一個維度去適配，保持該維度上和設計圖一致；注意是某一個維度</strong></li><li class=ql-indent-1>支持dp和sp單位，控制遷移成本到最小。</li></ul><p>6.常用適配框架</p><p>6.1 今日頭條適配方案</p><ul><li><strong>6.1.1 兼容突破口</strong></li><li>從dp和px的轉換公式 ：px = dp * density</li><li>可以看出，如果設計圖寬為360dp，想要保證在所有設備計算得出的px值都正好是屏幕寬度的話，我們只能修改 density 的值。</li></ul><pre>//在xml中使用何種尺寸單位（dp、sp、pt、in、mm）,最後在繪製時都會給我們轉成px!public static float applyDimension(int unit, float value, DisplayMetrics metrics) { switch (unit) { case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); } return 0;}</pre><ul><li><strong>6.1.2 頭條適配方案核心代碼</strong></li></ul><pre>public static void setCustomDensity(Activity activity, Application application) { DisplayMetrics displayMetrics = application.getResources().getDisplayMetrics(); if (sNoncompatDensity == 0) { // 系統的Density sNoncompatDensity = displayMetrics.density; // 系統的ScaledDensity sNoncompatScaledDensity = displayMetrics.scaledDensity; // 監聽在系統設置中切換字體 application.registerComponentCallbacks(new ComponentCallbacks() { @Override public void onConfigurationChanged(Configuration newConfig) { if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) { sNoncompatScaledDensity=application.getResources().getDisplayMetrics().scaledDensity; } } @Override public void onLowMemory() { } }); } // 公司UI尺寸是750px-1334px，此處以375dp的設計圖作為例子 float targetDensity=displayMetrics.widthPixels/375; float targetScaledDensity=targetDensity*(sNoncompatScaledDensity/sNoncompatDensity); int targetDensityDpi= (int) (160 * targetDensity); displayMetrics.density = targetDensity; displayMetrics.scaledDensity = targetScaledDensity; displayMetrics.densityDpi = targetDensityDpi; DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics(); activityDisplayMetrics.density = targetDensity; activityDisplayMetrics.scaledDensity = targetScaledDensity; activityDisplayMetrics.densityDpi = targetDensityDpi;}</pre><ul><li><strong>6.1.3 頭條適配方案注意事項</strong></li><li>寬度適配就已經完成啦，只需要在Activity中調用就行了，必須在setContentView()之前！</li><li>如果需要適配高度，頭條指出只要按照同樣的方法做高度適配就可以了！</li><li>實現思路：假設設計圖寬度是360dp，以寬維度來適配，那麼適配後的 density = 設備真實寬(單位px) / 360，接下來只需要把我們計算好的 density 在系統中修改下即可</li><li>遇到的問題：</li><li class=ql-indent-1>1.如果某個頁面不想適配該方案，該如何處理</li><li class=ql-indent-1>2.滾動頁面以寬為維度適配，而某些頁面則是以高為維度適配，這種情況怎麼辦？</li><li class=ql-indent-1>3.針對第三方庫有何更好的方案，比如支付寶支付彈窗，或者第三方客服聊天頁面如何處理適配</li><li><strong>6.1.4 頭條適配工具類，暫時只是用作測試項目</strong></li><li>關於該工具類，已經用於測試項目中，逐步完善，項目可以參考：https://github.com/yangchong211/YCVideoPlayer</li></ul><pre>public class ScreenDensityUtils { /* * 1.先在application中使用setup()方法初始化一下 * 2.手動在Activity中調用match()方法做適配，必須在setContentView()之前 * 3.建議使用dp做寬度適配，大多數時候寬度適配才是主流需要 * 4.個人覺得在寫佈局的時候，可以多用dp，如果是使用px，建議轉化成dp * 5.入侵性很低，不需要改動原來的代碼 */ /** * 屏幕適配的基準 */ private static final int MATCH_BASE_WIDTH = 0; private static final int MATCH_BASE_HEIGHT = 1; /** * 適配單位 */ private static final int MATCH_UNIT_DP = 0; private static final int MATCH_UNIT_PT = 1; // 適配信息 private static MatchInfo sMatchInfo; // Activity 的生命週期監測 private static Application.ActivityLifecycleCallbacks mActivityLifecycleCallback; private ScreenDensityUtils() { throw new UnsupportedOperationException("u can't instantiate me..."); } /** * 初始化 * @param application 需要在application中初始化 */ public static void setup(@NonNull final Application application) { /* //獲取屏幕分辨率信息的三種方法 //第一種 DisplayMetrics metrics = new DisplayMetrics(); Display display = activity.getWindowManager().getDefaultDisplay(); display.getMetrics(metrics); //第二種 DisplayMetrics metrics= activity.getResources().getDisplayMetrics(); //第三種 Resources.getSystem().getDisplayMetrics(); */ //注意這個是獲取系統的displayMetrics final DisplayMetrics displayMetrics = application.getResources().getDisplayMetrics(); if (sMatchInfo == null) { // 記錄系統的原始值 sMatchInfo = new MatchInfo(); sMatchInfo.setScreenWidth(displayMetrics.widthPixels); sMatchInfo.setScreenHeight(displayMetrics.heightPixels); sMatchInfo.setAppDensity(displayMetrics.density); sMatchInfo.setAppDensityDpi(displayMetrics.densityDpi); sMatchInfo.setAppScaledDensity(displayMetrics.scaledDensity); sMatchInfo.setAppXdpi(displayMetrics.xdpi); } // 添加字體變化的監聽 // 調用 Application#registerComponentCallbacks 註冊下 onConfigurationChanged 監聽即可。 application.registerComponentCallbacks(new ComponentCallbacks() { @Override public void onConfigurationChanged(Configuration newConfig) { // 字體改變後,將 appScaledDensity 重新賦值 if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) { float scaledDensity = displayMetrics.scaledDensity; sMatchInfo.setAppScaledDensity(scaledDensity); } } @Override public void onLowMemory() { } }); } /** * 在 application 中全局激活適配（也可單獨使用 match() 方法在指定頁面中配置適配） */ @RequiresApi(api = Build.VERSION_CODES.ICE_CREAM_SANDWICH) public static void register(@NonNull final Application application, final float designSize, final int matchBase, final int matchUnit) { if (mActivityLifecycleCallback == null) { mActivityLifecycleCallback = new Application.ActivityLifecycleCallbacks() { @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) { if (activity != null) { match(activity, designSize, matchBase, matchUnit); } } @Override public void onActivityStarted(Activity activity) { } @Override public void onActivityResumed(Activity activity) { } @Override public void onActivityPaused(Activity activity) { } @Override public void onActivityStopped(Activity activity) { } @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) { } @Override public void onActivityDestroyed(Activity activity) { } }; application.registerActivityLifecycleCallbacks(mActivityLifecycleCallback); } } /** * 全局取消所有的適配 */ @RequiresApi(api = Build.VERSION_CODES.ICE_CREAM_SANDWICH) public static void unregister(@NonNull final Application application, @NonNull int... matchUnit) { if (mActivityLifecycleCallback != null) { application.unregisterActivityLifecycleCallbacks(mActivityLifecycleCallback); mActivityLifecycleCallback = null; } for (int unit : matchUnit) { cancelMatch(application, unit); } } /** * 適配屏幕（放在 Activity 的 setContentView() 之前執行） * * @param context 上下文 * @param designSize 設計圖的尺寸 */ public static void match(@NonNull final Context context, final float designSize) { match(context, designSize, MATCH_BASE_WIDTH, MATCH_UNIT_DP); } /** * 適配屏幕（放在 Activity 的 setContentView() 之前執行） * * @param context 上下文 * @param designSize 設計圖的尺寸 * @param matchBase 適配基準 */ public static void match(@NonNull final Context context, final float designSize, int matchBase) { match(context, designSize, matchBase, MATCH_UNIT_DP); } /** * 適配屏幕（放在 Activity 的 setContentView() 之前執行） * * @param context 上下文 * @param designSize 設計圖的尺寸 * @param matchBase 適配基準 * @param matchUnit 使用的適配單位 */ private static void match(@NonNull final Context context, final float designSize, int matchBase, int matchUnit) { if (designSize == 0) { throw new UnsupportedOperationException("The designSize cannot be equal to 0"); } if (matchUnit == MATCH_UNIT_DP) { matchByDP(context, designSize, matchBase); } else if (matchUnit == MATCH_UNIT_PT) { matchByPT(context, designSize, matchBase); } } /** * 重置適配信息，取消適配 */ public static void cancelMatch(@NonNull final Context context) { cancelMatch(context, MATCH_UNIT_DP); cancelMatch(context, MATCH_UNIT_PT); } /** * 重置適配信息，取消適配 * * @param context 上下文 * @param matchUnit 需要取消適配的單位 */ private static void cancelMatch(@NonNull final Context context, int matchUnit) { if (sMatchInfo != null) { final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics(); if (matchUnit == MATCH_UNIT_DP) { if (displayMetrics.density != sMatchInfo.getAppDensity()) { displayMetrics.density = sMatchInfo.getAppDensity(); } if (displayMetrics.densityDpi != sMatchInfo.getAppDensityDpi()) { displayMetrics.densityDpi = (int) sMatchInfo.getAppDensityDpi(); } if (displayMetrics.scaledDensity != sMatchInfo.getAppScaledDensity()) { displayMetrics.scaledDensity = sMatchInfo.getAppScaledDensity(); } } else if (matchUnit == MATCH_UNIT_PT) { if (displayMetrics.xdpi != sMatchInfo.getAppXdpi()) { displayMetrics.xdpi = sMatchInfo.getAppXdpi(); } } } } public static MatchInfo getMatchInfo() { return sMatchInfo; } /** * 使用 dp 作為適配單位（適合在新項目中使用，在老項目中使用會對原來既有的 dp 值產生影響） * &lt;br&gt; * &lt;ul&gt; * dp 與 px 之間的換算: * &lt;li&gt; px = density * dp &lt;/li&gt; * &lt;li&gt; density = dpi / 160 &lt;/li&gt; * &lt;li&gt; px = dp * (dpi / 160) &lt;/li&gt; * &lt;/ul&gt; * * @param context 上下文 * @param designSize 設計圖的寬/高（單位: dp） * @param base 適配基準 */ private static void matchByDP(@NonNull final Context context, final float designSize, int base) { final float targetDensity; if (base == MATCH_BASE_WIDTH) { targetDensity = sMatchInfo.getScreenWidth() * 1f / designSize; } else if (base == MATCH_BASE_HEIGHT) { targetDensity = sMatchInfo.getScreenHeight() * 1f / designSize; } else { targetDensity = sMatchInfo.getScreenWidth() * 1f / designSize; } final int targetDensityDpi = (int) (targetDensity * 160); final float targetScaledDensity = targetDensity * (sMatchInfo.getAppScaledDensity() / sMatchInfo.getAppDensity()); final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics(); displayMetrics.density = targetDensity; displayMetrics.densityDpi = targetDensityDpi; displayMetrics.scaledDensity = targetScaledDensity; } /** * 使用 pt 作為適配單位（因為 pt 比較冷門，新老項目皆適合使用；也可作為 dp 適配的補充， * 在需要同時適配寬度和高度時，使用 pt 來適配 dp 未適配的寬度或高度） * &lt;br/&gt; * &lt;p&gt; pt 轉 px 算法: pt * metrics.xdpi * (1.0f/72) &lt;/p&gt; * * @param context 上下文 * @param designSize 設計圖的寬/高（單位: pt） * @param base 適配基準 */ private static void matchByPT(@NonNull final Context context, final float designSize, int base) { final float targetXdpi; if (base == MATCH_BASE_WIDTH) { targetXdpi = sMatchInfo.getScreenWidth() * 72f / designSize; } else if (base == MATCH_BASE_HEIGHT) { targetXdpi = sMatchInfo.getScreenHeight() * 72f / designSize; } else { targetXdpi = sMatchInfo.getScreenWidth() * 72f / designSize; } final DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics(); displayMetrics.xdpi = targetXdpi; } /** * 適配信息 */ private static class MatchInfo { private int screenWidth; private int screenHeight; private float appDensity; private float appDensityDpi; private float appScaledDensity; private float appXdpi; int getScreenWidth() { return screenWidth; } void setScreenWidth(int screenWidth) { this.screenWidth = screenWidth; } int getScreenHeight() { return screenHeight; } void setScreenHeight(int screenHeight) { this.screenHeight = screenHeight; } float getAppDensity() { return appDensity; } void setAppDensity(float appDensity) { this.appDensity = appDensity; } float getAppDensityDpi() { return appDensityDpi; } void setAppDensityDpi(float appDensityDpi) { this.appDensityDpi = appDensityDpi; } float getAppScaledDensity() { return appScaledDensity; } void setAppScaledDensity(float appScaledDensity) { this.appScaledDensity = appScaledDensity; } float getAppXdpi() { return appXdpi; } void setAppXdpi(float appXdpi) { this.appXdpi = appXdpi; } }}</pre><p>6.2 鴻洋大AutoLayout框架</p><ul><li>我記得上上一個公司的項目投資界就是用的這個屏幕適配庫……哈哈</li><li>該庫的想法非常好：對照設計圖，使用px編寫佈局，不影響預覽；繪製階段將對應設計圖的px數值計算轉換為當前屏幕下適配的大小；為簡化接入，inflate時自動將各Layout轉換為對應的AutoLayout，從而不需要在所有的xml中更改。但是同時該庫也存在以下等問題：</li><li class=ql-indent-1>擴展性較差。對於每一種ViewGroup都要對應編寫對應的AutoLayout進行擴展，對於各View的每個需要適配的屬性都要編寫代碼進行適配擴展；</li><li class=ql-indent-1>在onMeasure階段進行數值計算。消耗性能，並且這對於非LayoutParams中的屬性存在較多不合理之處。比如在onMeasure時對TextView的textSize進行換算並setTextSize，那麼玩家在代碼中動態設置的textSize都會失效，因為在每次onMesasure時都會重新被AutoLayout重新設置覆蓋。</li><li class=ql-indent-1>issue較多並且作者已不再維護。</li><li class=ql-indent-1>個人覺得AutoLayout的設計思想非常優秀，但是將LayoutParams與屬性作為切入口在mesure過程中進行轉換計算的方案存在效率與擴展性等方面的問題。那麼Android計算長度的收口在哪裡，能不能在Android計算長度時進行換算呢？如果能在Android計算長度時進行換算，那麼就不需要一系列多餘的計算以及適配，一切問題就都迎刃而解了</li></ul><p>6.3 AndroidAutoSize</p><ul><li>已經用於現在正式庫，代碼量多，且註釋也比較項目，作者更新很頻繁，極力維護並解決bug，非常不錯！</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Android</a></li><li><a>適配</a></li><li><a>屏幕</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e02acf09.html alt="Android 屏幕適配方案" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52ae2d768efe44fe8ee014686a45271d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e02acf09.html title="Android 屏幕適配方案">Android 屏幕適配方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/036cb180.html alt="首批適配！ColorOS正式發佈Android 11開發者測試版：暗色定時、超級省電" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S2cySEvGM5dtxu style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/036cb180.html title="首批適配！ColorOS正式發佈Android 11開發者測試版：暗色定時、超級省電">首批適配！ColorOS正式發佈Android 11開發者測試版：暗色定時、超級省電</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e72bded.html alt=屏幕適配的3個妙招 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f8894557db5648de83986330bfbce929 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e72bded.html title=屏幕適配的3個妙招>屏幕適配的3個妙招</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68317c0f.html alt="Android 屏幕繪製機制及硬件加速" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f1fda8c0a126491eade5670556b21f64 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68317c0f.html title="Android 屏幕繪製機制及硬件加速">Android 屏幕繪製機制及硬件加速</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c1058aa2.html alt="Android Q下ANGLE圖形引擎性能測試  「農步祥」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RXTy8D7HmsBWr1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c1058aa2.html title="Android Q下ANGLE圖形引擎性能測試  「農步祥」">Android Q下ANGLE圖形引擎性能測試 「農步祥」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ac13623.html alt="Android 11加入新功能：長期不用的APP自動關閉敏感權限" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rx4J9h84rlZBze style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ac13623.html title="Android 11加入新功能：長期不用的APP自動關閉敏感權限">Android 11加入新功能：長期不用的APP自動關閉敏感權限</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/192b9f57.html alt="Android版Firefox 81將引入可自動關閉舊標籤頁的選項" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SA9N6CXIS75NYa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/192b9f57.html title="Android版Firefox 81將引入可自動關閉舊標籤頁的選項">Android版Firefox 81將引入可自動關閉舊標籤頁的選項</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3073c3d.html alt="Android端Firefox 81可定時關閉不使用的標籤頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S9x6jJb18axAim style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3073c3d.html title="Android端Firefox 81可定時關閉不使用的標籤頁">Android端Firefox 81可定時關閉不使用的標籤頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/355ed5a4.html alt=在Android中的工具欄中添加菜單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3572ad9d9fb487d8927f703f18179a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/355ed5a4.html title=在Android中的工具欄中添加菜單>在Android中的工具欄中添加菜單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37aac89.html alt=【學習筆記】Android開發之kotlin語言（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ee3f9c8348ae4de58a5f62922d2042e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37aac89.html title=【學習筆記】Android開發之kotlin語言（一）>【學習筆記】Android開發之kotlin語言（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/514f2fe0.html alt=Android進階之路之網絡編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R6GseWQ6pTbxvr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/514f2fe0.html title=Android進階之路之網絡編程>Android進階之路之網絡編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d258b9eb.html alt="徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/e4fd87bc-b2e5-40e2-841d-2e3dc5f9a2b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d258b9eb.html title="徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動">徹底凍結Android 應用後臺活動 讓他們不耗電、不聯網、不啟動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68b758a4.html alt="訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RiF18Oh9i8jWPd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68b758a4.html title="訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎">訊飛輸入法Android V9.1.9465 重磅升級拼音手寫A.I.引擎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03a7881d.html alt="Android 11公開測試版正式發佈，新增了實用功能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/76a9b5ad-e27f-4cea-b8b9-2134bc133e5d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03a7881d.html title="Android 11公開測試版正式發佈，新增了實用功能">Android 11公開測試版正式發佈，新增了實用功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9e496dd.html alt="Android 11 beta升級方法，如何申請測試版更新？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ba850edc544843cab07cecf061a1ffde style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9e496dd.html title="Android 11 beta升級方法，如何申請測試版更新？">Android 11 beta升級方法，如何申請測試版更新？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>