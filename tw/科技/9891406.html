<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>程序員：深入理解JVM，從JVM層面來講Java多態 | 极客快訊</title><meta property="og:title" content="程序員：深入理解JVM，從JVM層面來講Java多態 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/dde11845-76d0-4452-af65-97e0e223c1cf"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9891406.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9891406.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9891406.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9891406.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9891406.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9891406.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9891406.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9891406.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="程序員：深入理解JVM，從JVM層面來講Java多態"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9891406.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>程序員：深入理解JVM，從JVM層面來講Java多態</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>先來個引子：下面是騰訊的一道面試題。</p><div class=pgc-img><img alt=程序員：深入理解JVM，從JVM層面來講Java多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/dde11845-76d0-4452-af65-97e0e223c1cf><p class=pgc-img-caption></p></div><p>對多態理解不夠深入的，多半都會答錯；如果能記住口訣：“變量多態看左邊，方法多態看右邊，靜態多態看左邊”的話，肯定就知道答案，但是JVM是如何確定具體調用哪個方法的，有小夥伴思考過嗎？</p><p>1、方法調用：</p><p>方法調用並不等於方法執行，方法調用階段唯一的任務就是確定被調用方法的版本（就是具體調用哪個方法），暫時還不涉及到方法內部的具體運行過程。Class文件的編譯過程中不包含傳統編譯中的連接步驟,一切方法調用在Class文件裡面存儲的都只是符號引用,而不是方法在實際運行時內存佈局中的入口地址。這個特性給Java帶來了更強大的動態拓展能力，也使得Java方法調用過程變得相對複雜起來，需要在類加載期間，甚至到運行時才能確定目標方法的直接引用。</p><p>2、解析：</p><p>所有方法調用中的目標方法在Class文件裡面都是一個常量池中的符號引用，在類加載的解析階段，會將其中的一部分符號引用轉換為直接引用（相當於指針）。這種解析能成立的前提是：方法在程序真正運行之前就有一個可確定的調用版本，並且這個方法的調用版本在運行期是不可改變的。換句話說，調用目標在程序代碼在編譯時就必須確定下來。這類方法的調用稱之為解析。</p><p>在Java語言中符合“編譯期可知，運行期不可變”這個要求的方法，主要包括靜態方法和私有方法兩大類，前者與類型直接關聯，後者在外部不可被訪問，這兩種方法各自的特點決定了它們都不可能通過繼承或別的方式重寫其他版本（static修飾的靜態方法可以重載，能被子類繼承，但不能被重寫），因此它們都適合在類加載階段進行解析。</p><p>與之對應的是，在JVM裡面提供了5條方法調用字節碼指令，分別如下：</p><p>invokestatic：調用靜態方法</p><p>invokespecial：調用實例構造器&lt;init>方法、私有方法和父類方法。</p><p>invokevirtual：調用所有的虛方法</p><p>invokeinterface：調用接口方法，會在運行時再確定一個實現此接口的對象。</p><p>invokedynamic：先在運行時動態解析出調用點限定符所引用的方法，然後再執行該方法，在此之前的4條調用指令，分派邏輯是固化在JVM內部的，而invokedynamic指令的分派邏輯是由用戶所設定的引導方法決定的。</p><p>只要能被invokestatic和invokespecial指令調用的方法，都可以在解析階段中唯一確定調用版本，符合這個條件的有：靜態方法、私有方法、實例構造器、父類方法。它們在類加載的時候就會把符號引用解析為該方法的直接引用。這些方法也稱為“非虛方法”。</p><p>代碼示例：</p><p>public class StaticResolution {</p><p>/**</p><p>* 此方法只能屬於StaticResolution類，沒有任何手段可以重寫或隱藏這個方法</p><p>*/</p><p>public static void sayHello() {</p><p>System.out.println("hello world");</p><p>}</p><p></p><p>public static void main(String[] args) {</p><p>StaticResolution.sayHello();</p><p>}</p><p>}</p><p>使用javac編譯，然後在編譯好的class文件所在目錄打開cmd輸入命令：</p><p>javap -c StaticResolution.class</p><p>可以查看該程序的字節碼：</p><div class=pgc-img><img alt=程序員：深入理解JVM，從JVM層面來講Java多態 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/dcd40f6c-d712-4465-b3e6-a9ad542e15f9><p class=pgc-img-caption></p></div><p>可以發現，的確是通過invokestatic命令來調用sayHello（）方法的。</p><p>Java中的非虛方法除了使用invokestatic、invokevirtual調用的方法之外還有一種，就是被final修飾的方法，雖然final方法是使用invokevirtual指令來調用的，但是由於它無法被覆蓋，沒有其他版本，所以也無須對方法接收者進行多態選擇，又或者說多態選擇的結果肯定是唯一的。在Java語言規範中明確說明了final方法是一種非虛方法。</p><p>解析調用一定是個靜態的過程，在編譯期間就完全確定，在類裝載的解析階段就會把涉及的符號引用全部轉變為可確定的直接引用，不會延遲到運行期再去完成。而分派調用則可能是靜態的也可能是動態的，根據分派依據的宗量數可分為單分派和多分派。這兩類分派方式的兩兩組合就構成了靜態單分派、靜態多分派、動態單分派、動態多分派這4種分派組合情況。</p><p>3、分派</p><p>1）靜態分派</p><p>先看一段代碼：</p><p>public class StaticDispatch {</p><p>static abstract class Human{</p><p>}</p><p>static class Man extends Human{}</p><p>static class Woman extends Human{}</p><p></p><p>public void sayHello(Human guy) {</p><p>System.out.println("hello human");</p><p>}</p><p></p><p>public void sayHello(Man guy) {</p><p>System.out.println("hello man");</p><p>}</p><p></p><p>public void sayHello(Woman guy) {</p><p>System.out.println("hello woman");</p><p>}</p><p></p><p>public static void main(String[] args) {</p><p>Human man = new Man();</p><p>Human woman = new Woman();</p><p>StaticDispatch dispatch = new StaticDispatch();</p><p>dispatch.sayHello(man);</p><p>dispatch.sayHello(woman);</p><p>}</p><p>}</p><p>輸出結果是什麼呢，很多人會想按照參數類型，肯定是輸出：</p><p>hello man</p><p>hello woman</p><p>然而事實卻是輸出：</p><p>hello human</p><p>hello human</p><p>為什麼會選擇參數類型是Human的重載呢？解答這個問題之前，先按如下代碼定義兩個重要的概念。</p><p>Human man = new Man();</p><p>我們把上面代碼中的“Human” 成為變量的靜態類型（Static Type），或者叫做外觀類型（Apparent Type），後面的“Man” 則稱為變量的實際類型（Actual Type），靜態類型和實際類型在程序中都可以發生變化，區別是靜態類型的變化僅僅在使用時發生，變量本身的靜態類型不會被改變，並且最終的靜態類型是在編譯期可知的；而實際類型變化的結果在運行期才可確定，編譯期在編譯程序的時候並不知道一個對象的實際類型是什麼，例如：</p><p>// 實際類型變化</p><p>Human man = new Man();</p><p>man=new Woman();</p><p>// 靜態類型變化</p><p>dispatch.sayHello((Man) man);</p><p>dispatch.sayHello((Woman) man);</p><p>main()中的兩次調用sayHello()，在方法接收者已經確定是對象“dispatch”的前提下，使用哪個重載版本，就完全取決於傳入參數的數量和數據類型。代碼中刻意定義了兩個靜態類型相同但實際類型不同的變量，但編譯器在重載時是通過參數的靜態類型而不是實際類型作為判定依據的。並且靜態類型是編譯器可知的，因此在編譯階段，Javac編譯器會根據參數的靜態類型決定使用哪個重載版本，所以選擇了sayHello（Human）作為調用目標，並把這個方法的符號引用寫到main（）方法裡的兩條invokevirtual指令的參數中。</p><p>所有依賴靜態類型來定位方法執行版本的分派動作成為靜態分派。靜態分派的典型應用是方法重載。靜態分派發生在編譯階段。因此確定靜態分派的動作實際上不是有虛擬機來執行。另外雖然編譯器能確定出方法的重載版本，但在很多情況下這個重載版本並不是“唯一的”，往往只能確定一個“更加合適”的版本。主要原因是字面量不需要定義，所以字面量沒有顯式的靜態類型，它的靜態類型只能通過語言上的規則去理解和推斷。下面演示一個經典代碼：</p><p>public class Overload {</p><p></p><p>public static void sayHello(Object arg) {</p><p>System.out.println("hello object");</p><p>}</p><p></p><p>public static void sayHello(int arg) {</p><p>System.out.println("hello int");</p><p>}</p><p></p><p>public static void sayHello(long arg) {</p><p>System.out.println("hello long");</p><p>}</p><p></p><p>public static void sayHello(Character arg) {</p><p>System.out.println("hello Character");</p><p>}</p><p></p><p>public static void sayHello(char arg) {</p><p>System.out.println("hello char");</p><p>}</p><p></p><p>public static void sayHello(char... arg) {</p><p>System.out.println("hello char...");</p><p>}</p><p></p><p>public static void sayHello(Serializable arg) {</p><p>System.out.println("hello Serializable");</p><p>}</p><p></p><p>public static void main(String[] args) {</p><p>sayHello('a');</p><p>}</p><p>}</p><p>輸出結果當然是：</p><p>hello char</p><p>因為‘a’是char類型，自然會尋找參數類型為char的方法，如果註釋掉sayHello（char arg）方法，那輸出將是：</p><p>hello int</p><p>這時發生了一次自動類型轉換，‘a’ 除了代表一個字符，還可以代表數字97（Unicode），因此參數類型為int的重載也是合適的。繼續註釋sayHello（int arg）方法，那輸出將是：</p><p>hello long</p><p>這時發生了兩次自動類型轉換，‘a’轉型為整數97之後，進一步轉型為長整型97L，匹配了參數類型為long的方法，如果還有參數類型為float，double等的重載方法，自動轉型還會發生多次，按照char > int > long > float > double 的順序轉型進行匹配。但是不會匹配byte和short類型的重載。因為char到byte和short的轉型是不安全的，繼續註釋掉sayHello（long arg）方法，輸出是：</p><p>hello Character</p><p>這時候發生了一次自動裝箱，‘a’被包裝為它的包裝類型java.lang.Character，所以匹配到sayHello(Character arg)，繼續註釋sayHello(Character arg)，輸出就會變為：</p><p>hello Serializable</p><p>這個輸出結果是因為java.lang.Character實現了Serializable接口，當自動裝箱後發現還是找不到包裝類，但是找到了包裝類實現的接口，所以又發生了一次自動轉型。char可以轉型為int，但是Character絕對不會轉型為Integer，它只能安全的轉型為它實現的接口或父類。Character還實現了Comparable接口，如果同時出現兩個參數分別為Serializable和Comparable的重載方法，那它們在此時的優先級是一樣的，但編譯器就無法確定自動轉型為哪種類型了，會提示編譯錯誤，比如</p><div class=pgc-img><img alt=程序員：深入理解JVM，從JVM層面來講Java多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72b431f4b5784cc395886baf61651635><p class=pgc-img-caption></p></div><p>需要調用的時候顯式的指定字面量的靜態類型sayHello((Comparable&lt;Character>)'a'); 才能編譯通過</p><p>繼續註釋sayHello(Serializable arg)，輸出為：</p><p>hello object</p><p>這時是char裝箱後轉型為父類了，如果有多個父類，那將在繼承關係中從下往上開始搜索，越接近上層優先級越低，即使方法調用傳入的參數為null，這個規則仍然使用。</p><p>繼續註釋掉sayHello(Object arg)，輸出為：</p><p>hello char...</p><p>由此可見，可變參數方法的重載優先級是最低的。這時候參數‘a’被當做數組，還可以選擇int類型、Character、Object類型等的可變參數重載來重新演示。</p><p>2）動態分派</p><p>動態分派與重寫有著密切聯繫，演示代碼：</p><p>public class DynamicDispatch {</p><p></p><p>static abstract class Human {</p><p>protected abstract void sayHello();</p><p>}</p><p></p><p>static class Man extends Human {</p><p></p><p>@Override</p><p>protected void sayHello() {</p><p>System.out.println("man say hello");</p><p>}</p><p>}</p><p></p><p>static class Woman extends Human {</p><p></p><p>@Override</p><p>protected void sayHello() {</p><p>System.out.println("woman say hello");</p><p>}</p><p>}</p><p></p><p>public static void main(String[] args) {</p><p>Human man = new Man();</p><p>Human woman = new Woman();</p><p>man.sayHello();</p><p>woman.sayHello();</p><p>man = new Woman();</p><p>man.sayHello();</p><p>}</p><p>}</p><p>運行結果：</p><p>man say hello</p><p>woman say hello</p><p>woman say hello</p><p>這個運行結果相信不會出乎任何人的意料，現在的問題還是和前面的一樣，虛擬機是如何知道要調用哪個方法的?顯然這裡不可能再根據靜態類型來決定，因為靜態類型同樣都是Human的兩個變量，man和woman在調用sayHello0方法時執行了不同的行為，並且變量man在兩次調用中執行了不同的方法。導致這個現象的原因很明顯，這兩個變量的實際類型不同，Java虛擬機</p><p>是如何根據實際類型來分派方法執行版本的呢?我們使用javap -c DynamicDispatch.class 命令輸出這段代碼的字節碼：</p><p>Compiled from "DynamicDispatch.java"</p><p>public class jvm.DynamicDispatch {</p><p>public jvm.DynamicDispatch();</p><p>Code:</p><p>0: aload_0</p><p>1: invokespecial #1 // Method java/lang/Object."&lt;init>":()V</p><p>4: return</p><p></p><p>public static void main(java.lang.String[]);</p><p>Code:</p><p>0: new #2 // class jvm/DynamicDispatch$Man</p><p>3: dup</p><p>4: invokespecial #3 // Method jvm/DynamicDispatch$Man."&lt;init>":()V</p><p>7: astore_1</p><p>8: new #4 // class jvm/DynamicDispatch$Woman</p><p>11: dup</p><p>12: invokespecial #5 // Method jvm/DynamicDispatch$Woman."&lt;init>":()V</p><p>15: astore_2</p><p>16: aload_1</p><p>17: invokevirtual #6 // Method jvm/DynamicDispatch$Human.sayHello:()V</p><p>20: aload_2</p><p>21: invokevirtual #6 // Method jvm/DynamicDispatch$Human.sayHello:()V</p><p>24: new #4 // class jvm/DynamicDispatch$Woman</p><p>27: dup</p><p>28: invokespecial #5 // Method jvm/DynamicDispatch$Woman."&lt;init>":()V</p><p>31: astore_1</p><p>32: aload_1</p><p>33: invokevirtual #6 // Method jvm/DynamicDispatch$Human.sayHello:()V</p><p>36: return</p><p>}</p><p>0-15行的字節碼是準備動作，作用是建立man和woman的內存空間、調用Man和Woman類型的實例構造器，將這兩個實例的引用存放在第1、2個局部變量表Slog之中，這個動作也對應了代碼中的這兩句：</p><p>Human man = new Man();</p><p>Human woman = new Woman();</p><p>接下來的16-21是關鍵部分，16、20兩句分別把剛剛創建的兩個對象的引用壓到棧頂，這兩個對象是將要執行的sayHello()方法的所有者，成為接收者；17和21句是方法調用指令，這兩條調用指令單從字節碼角度看，無論是指令（都是invokevirtual）還是參數（都是常量池中第22項的常量，註釋顯示了這個常量是Human.sayHello()的符號引用）完全一樣的，但是這兩句指令最終執行的目標方法並不相同。原因就需要從invokevirtual指令的多態查找過程說起，invokevirtual指令的運行時解析過程大致分為以下幾個步驟：</p><p>1）找到操作數棧頂的第一個元素所指向的對象的實際類型，記作C。</p><p>2)如果在類型C中找到與常量中的描述符和簡單名稱都相符的方法，則進行訪問權限</p><p>校驗，如果通過則返回這個方法的直接引用，查找過程結束;如果不通過，則返回java.lang.</p><p>IHlegalAccessError異常。</p><p>3)否則，按照繼承關係從下往上依次對C的各個父類進行第2步的搜索和驗證過程。</p><p>4)如果始終沒有找到合適的方法，則拋出java.lang.AbstractMethodError異常。</p><p>由於invokevirtual指令執行的第一步就是在運行期確定接收者的實際類型，所以兩次調</p><p>用中的invokevirtual指令把常量池中的類方法符號引用解柝到了不同的直接引用上，這個過</p><p>程就是Java語言中方法重寫的本質。我們把這種在運行期根據實際類型確定方法執行版本的</p><p>分派過程稱為動態分派。</p><p>再插入一個《Java編程思想》中的一個經典例子，加深理解：</p><p>public class Shape {</p><p></p><p>public void draw(){}</p><p></p><p>static class Circle extends Shape{</p><p>@Override</p><p>public void draw() {</p><p>System.out.println("Circle.draw()");</p><p>}</p><p>}</p><p></p><p>static class Square extends Shape {</p><p>@Override</p><p>public void draw() {</p><p>System.out.println("Square.draw()");</p><p>}</p><p>}</p><p></p><p>static class Triangle extends Shape {</p><p>@Override</p><p>public void draw() {</p><p>System.out.println("Triangle.draw()");</p><p>}</p><p>}</p><p></p><p>static class RandomShape{</p><p>private Random random = new Random(47);</p><p>public Shape next() {</p><p>switch (random.nextInt(3)) {</p><p>default:</p><p>case 0:</p><p>return new Circle();</p><p>case 1:</p><p>return new Square();</p><p>case 2:</p><p>return new Triangle();</p><p>}</p><p>}</p><p>}</p><p></p><p>private static RandomShape randomShape = new RandomShape();</p><p></p><p>public static void main(String[] args) {</p><p>Shape[] s = new Shape[9];</p><p>for (int i = 0; i &lt; s.length; i++) {</p><p>s[i] = randomShape.next();</p><p>}</p><p>for (Shape shape : s) {</p><p>shape.draw();</p><p>}</p><p>}</p><p>}</p><p>輸出結果：</p><p>Triangle.draw()</p><p>Triangle.draw()</p><p>Square.draw()</p><p>Triangle.draw()</p><p>Square.draw()</p><p>Triangle.draw()</p><p>Square.draw()</p><p>Triangle.draw()</p><p>Circle.draw()</p><p>上面的例子中，Shape類為所有的子類建立了一個公共方法，子類通過重寫這個方法，來為每種特殊形狀提供單獨的行為。</p><p>RandomShape類，其實像一個“工廠”，每次調用next（）方法時，它可以為隨機選擇的Shape對象產生一個引用。注意：向上轉型是發生在return語句中。每個return語句都取得一個指向某個Circle、Square、Triangle的引用，並將其以Shape類型從next（）方法中發送出去。所以無論我們在什麼時候調用next()方法，是絕不可能知道具體類型到底是什麼的，因為我們總是隻能獲得一個通用的Shape引用。</p><p>main()包含了一個Shape引用組成的數組，通過調用RandomShape.next()來填入數據。此時，我們只知道自己擁有一些Shape，除此之外不會知道更具體的情況（編譯器也不知道）。然而，當我們遍歷這個數組，併為每個數組元素調用draw()方法時，與類型有關的特定行為會神奇般的發生，從輸出結果不難看出。</p><p>3）JVM動態分派的實現</p><p>動態分派是非常頻繁的動作，而且動態分派的方法版本選擇過程需要運行時在類的方法元數據中搜索合適的目標方法，因此在虛擬機的實際實現中基於性能的考慮，大部分實現都不會真正的進行如此頻繁的搜索。最常見的“穩定優化”手段就是為類在方法區中建立一個虛方法表（Virtual Method Table,也稱為vtable，與此對應的在invokeinterface執行時也會用到接口方法表——Interface Method Table，簡稱itable），使用虛方法表索引來代替元數據查找以提高性能。</p><p>虛方法表存放著各個方法的實際入口地址。如果某個方法在子類中沒有被重寫，那子類的虛方法表裡面的地址入口和父類相同方法的地址入口是一致的，都指向父類的實際入口地址。如果子類重寫了這個方法，子類方法表中的地址將會替換為指向子類實現版本的入口地址。</p><p>為了程序實現的方便，具有相同簽名的方法，在父類、子類的虛方法表中都應當具有一樣的索引序號，這樣當類型轉換時，僅需要變更查找的方法表，就可以從不同的虛方法表中按索引轉換出所需的入口地址。</p><p>方法表一般在類加載的連接階段進行初始化，準備了類的變量初始值後，虛擬機會把該類的方法表也初始化完畢。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JVM</a></li><li><a>層面</a></li><li><a>來講</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5400247a.html alt=C#對於初學者來講，數據類型的種類是一把必備的利刃 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f421e70dc2e6402f99afdc234d1e2e30 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5400247a.html title=C#對於初學者來講，數據類型的種類是一把必備的利刃>C#對於初學者來講，數據類型的種類是一把必備的利刃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd1246b1.html alt=JVM—深入理解內存模型與垃圾收集機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/574c706db69f4c53802c093d6e7023d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd1246b1.html title=JVM—深入理解內存模型與垃圾收集機制>JVM—深入理解內存模型與垃圾收集機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d2b4ed3.html alt=從工業設計層面簡要分析當前的充電槍設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152091058463445a347c112 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d2b4ed3.html title=從工業設計層面簡要分析當前的充電槍設計>從工業設計層面簡要分析當前的充電槍設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/46cf3384.html alt=在某種意義上來講，螞蟻才是這個地球進化最完美的生物，沒有之一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531474184500e85d2340e2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/46cf3384.html title=在某種意義上來講，螞蟻才是這個地球進化最完美的生物，沒有之一>在某種意義上來講，螞蟻才是這個地球進化最完美的生物，沒有之一</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/d530a149.html alt=從神經學層面理解婆媳戰爭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/72e6f3a4fa074a52a69d5fa0f1527eab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/d530a149.html title=從神經學層面理解婆媳戰爭>從神經學層面理解婆媳戰爭</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/73292ba0.html alt=通俗的來講，核能到底是什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4d21881c36954a06bab5d1808eeba46c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/73292ba0.html title=通俗的來講，核能到底是什麼？>通俗的來講，核能到底是什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/f7d62bc5.html alt=鍾南山：戰勝疫情需要全球層面實現更緊密的合作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/f7d62bc5.html title=鍾南山：戰勝疫情需要全球層面實現更緊密的合作>鍾南山：戰勝疫情需要全球層面實現更緊密的合作</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/a050dfa0.html alt=JDK9的新特性：JVM的xlog class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/a050dfa0.html title=JDK9的新特性：JVM的xlog>JDK9的新特性：JVM的xlog</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e20aedae.html alt=互助問答第267期：控制公司層面的固定效應 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f9ed159bb60042e6b86262962d003b02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e20aedae.html title=互助問答第267期：控制公司層面的固定效應>互助問答第267期：控制公司層面的固定效應</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/881726ac.html alt=小星推薦—今天來講講電火花加工 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d1736cd2bd8246af8a62f3a72aaecc47 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/881726ac.html title=小星推薦—今天來講講電火花加工>小星推薦—今天來講講電火花加工</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/030e9343.html alt="JVM 垃圾收集器細節補充" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/97bc94b0a276433a809abd99b14bd724 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/030e9343.html title="JVM 垃圾收集器細節補充">JVM 垃圾收集器細節補充</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/59d7c87e.html alt=JVM/併發/MySQL/Java/網絡等一個都沒肝完，想擠BAT你說難不難？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/80833d07a23e4e4c8677376189188e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/59d7c87e.html title=JVM/併發/MySQL/Java/網絡等一個都沒肝完，想擠BAT你說難不難？>JVM/併發/MySQL/Java/網絡等一個都沒肝完，想擠BAT你說難不難？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3dc2d81.html alt=VXLAN幀格式以及數據和控制層面 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b1b51571e5164daca89143a89fbba022 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3dc2d81.html title=VXLAN幀格式以及數據和控制層面>VXLAN幀格式以及數據和控制層面</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/1d87788.html alt=從法律層面來說什麼是憲法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/079d6d6b-4333-4a9e-bf86-eb9f84b3f093 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/1d87788.html title=從法律層面來說什麼是憲法>從法律層面來說什麼是憲法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>