<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>網絡通信3：HTTP實現文本傳輸 | 极客快訊</title><meta property="og:title" content="網絡通信3：HTTP實現文本傳輸 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><meta property="article:published_time" content="2020-10-29T21:04:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:30+08:00"><meta name=Keywords content><meta name=description content="網絡通信3：HTTP實現文本傳輸"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9940ac4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>網絡通信3：HTTP實現文本傳輸</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>HTTP協議即超文本傳送協議(Hypertext Transfer Protocol )，是Web聯網的基礎，HTTP協議是建立在TCP協議之上的一種應用。由於HTTP在每次請求結束後都會主動釋放連接，因此HTTP連接是一種短連接。HTTP遵循請求（Request）/應答（Response）模型。所以一定需要實現請求(Gk8HttpRequest)。同時需要實現返回(Gk8HttpResponse)。在遊戲研發編程中HTTP請求類型常用的就是GET和POST。框架設計中就需要實現完成HTTP請求和返回的Gk8HttpClient類。HTTP不管是文本傳輸還是二進制傳輸Gk8HttpClient類都能兼容完成響應的功能。HTTP文本傳輸方便簡潔。實現輕量級通信的最佳方式。</p><p>libCurl作為是一個多協議的便於客戶端使用的URL傳輸庫，基於C語言，提供C語言的API接口。底層通信都是使用libCurl庫來完成。具體可找相關資料和參閱相關代碼。C語言封裝開發的優勢就是支持跨平臺。Windows平臺，安卓平臺，IOS平臺。跨平臺遷移代碼無需再次開發。一勞永逸的解決通信問題。為了方便開發時HTTP併發和回調。又實現了Gk8HttpServlet類(httpnet目錄中)。高度封裝的代碼目的就是易於理解便於使用。</p><p>C++實現網絡HTTP請求類：Gk8HttpRequest.h</p><pre><code>&nbsp;#ifndef __GK8HTTPREQUEST_H__&nbsp;#define __GK8HTTPREQUEST_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;Gk8BaseObj.h&#34;&nbsp;#include &#34;Gk8ByteMaker.h&#34;&nbsp;#include &#34;Gk8Str.h&#34;&nbsp;​&nbsp;typedef GK8_VOID (Gk8BaseObj::*HTTPREQUEST_CALLBACK_FUN)(GK8_LPVOID pHttpResponse);&nbsp;​&nbsp;class Gk8HttpRequest&nbsp;{&nbsp;public:&nbsp;    //[定義HTTP請求類型]&nbsp;    typedef enum&nbsp;    {&nbsp;        kHttpGet,&nbsp;        kHttpPost,&nbsp;        kHttpUnkown,&nbsp;    }HttpRequestType;&nbsp;​&nbsp;protected:&nbsp;    HttpRequestType m_eRequestType;         //[HTTP請求類型]&nbsp;    Gk8Str m_sHttpUrl;                      //[HTTP請求地址]&nbsp;    Gk8ByteMaker m_iRequestData;            //[HTTP請求數據]&nbsp;    Gk8BaseObj* m_pTarget;                  //[HTTP請求回調目標對象]&nbsp;    HTTPREQUEST_CALLBACK_FUN m_pSelector;   //[HTTP請求回調函數]&nbsp;public:&nbsp;    Gk8HttpRequest()&nbsp;    {&nbsp;        m_eRequestType=kHttpUnkown;&nbsp;        m_sHttpUrl.Empty();&nbsp;        m_iRequestData.Destroy();&nbsp;        m_pTarget=NULL;&nbsp;        m_pSelector=NULL;&nbsp;    };&nbsp;​&nbsp;    virtual ~Gk8HttpRequest()&nbsp;    {&nbsp;        ClearRequestData();&nbsp;    };&nbsp;    inline GK8_VOID ClearRequestData()&nbsp;    {&nbsp;        m_iRequestData.Destroy();&nbsp;    }&nbsp;    inline GK8_VOID SetRequestType(HttpRequestType eRequestType)&nbsp;    {&nbsp;        m_eRequestType=eRequestType;&nbsp;    };&nbsp;​&nbsp;    inline HttpRequestType GetRequestType()&nbsp;    {&nbsp;        return m_eRequestType;&nbsp;    };&nbsp;​&nbsp;    inline GK8_VOID SetHttpUrl(GK8_LPCSTR lpHttpUrl)&nbsp;    {&nbsp;        m_sHttpUrl=lpHttpUrl;&nbsp;    };&nbsp;​&nbsp;    inline GK8_LPCSTR GetHttpUrl()&nbsp;    {&nbsp;        return m_sHttpUrl;&nbsp;    };&nbsp;​&nbsp;    inline GK8_VOID SetRequestData(Gk8ByteMaker* pRequestData)&nbsp;    {&nbsp;        pRequestData-&gt;ShiftTo(m_iRequestData);&nbsp;    };&nbsp;​&nbsp;    inline Gk8ByteMaker* GetRequestData()&nbsp;    {&nbsp;        return &m_iRequestData;&nbsp;    }&nbsp;​&nbsp;    inline GK8_INT GetRequestDataSize()&nbsp;    {&nbsp;        return m_iRequestData.GetStreamSize();&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetResponseCallBack(Gk8BaseObj* pTarget,HTTPREQUEST_CALLBACK_FUN pSelector)&nbsp;    {&nbsp;        m_pTarget=pTarget;&nbsp;        m_pSelector=pSelector;&nbsp;    }&nbsp;​&nbsp;    inline Gk8BaseObj* GetTarget()&nbsp;    {&nbsp;        return m_pTarget;&nbsp;    }&nbsp;​&nbsp;    inline HTTPREQUEST_CALLBACK_FUN GetSelector()&nbsp;    {&nbsp;        return m_pSelector;&nbsp;    }&nbsp;};&nbsp;#endif</code></pre><p>C++實現網絡HTTP返回類：Gk8HttpResponse.h</p><pre><code>&nbsp;#ifndef __GK8HTTPRESPONSE_H__&nbsp;#define __GK8HTTPRESPONSE_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;Gk8HttpRequest.h&#34;&nbsp;​&nbsp;​&nbsp;class Gk8HttpResponse&nbsp;{&nbsp;protected:&nbsp;    Gk8HttpRequest* m_pHttpRequest;         //[HTTP請求類]&nbsp;    GK8_BOOL m_bSucceed;                    //[HTTP請求反饋成功]&nbsp;    Gk8ByteMaker m_iResponseData;           //[HTTP請求反饋數據]&nbsp;    GK8_INT m_nResponseCode;                //[HTTP請求反饋碼]&nbsp;    Gk8Str m_sErrorBuffer;                  //[HTTP請求錯誤信息]&nbsp;protected:&nbsp;    GK8_BOOL InitWithRequest(Gk8HttpRequest* pHttpRequest);&nbsp;​&nbsp;public:&nbsp;​&nbsp;    Gk8HttpResponse(Gk8HttpRequest* pHttpRequest)&nbsp;    {&nbsp;        m_pHttpRequest=pHttpRequest;&nbsp;        m_bSucceed=false;&nbsp;        m_iResponseData.Destroy();&nbsp;        m_sErrorBuffer.Empty();&nbsp;    }&nbsp;​&nbsp;    virtual ~Gk8HttpResponse()&nbsp;    {&nbsp;        if(m_pHttpRequest) delete m_pHttpRequest;&nbsp;        ClearResponseData();&nbsp;    }&nbsp;    inline GK8_VOID ClearResponseData()&nbsp;    {&nbsp;        m_iResponseData.Destroy();&nbsp;    }&nbsp;​&nbsp;    inline Gk8HttpRequest* GetHttpRequest()&nbsp;    {&nbsp;        return m_pHttpRequest;&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetSucceed(GK8_BOOL bSucceed)&nbsp;    {&nbsp;        m_bSucceed=bSucceed;&nbsp;    };&nbsp;​&nbsp;    inline GK8_BOOL IsSucceed()&nbsp;    {&nbsp;        return m_bSucceed;&nbsp;    };&nbsp;​&nbsp;    inline GK8_VOID SetResponseData(Gk8ByteMaker* pResponseData)&nbsp;    {&nbsp;        pResponseData-&gt;ShiftTo(m_iResponseData);&nbsp;    }&nbsp;​&nbsp;    inline Gk8ByteMaker* GetResponseData()&nbsp;    {&nbsp;        return &m_iResponseData;&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetResponseCode(GK8_INT nResponseCode)&nbsp;    {&nbsp;        m_nResponseCode=nResponseCode;&nbsp;    }&nbsp;​&nbsp;    inline GK8_INT GetResponseCode()&nbsp;    {&nbsp;        return m_nResponseCode;&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetErrorBuffer(GK8_LPCSTR lpErrorBuffer)&nbsp;    {&nbsp;        m_sErrorBuffer=lpErrorBuffer;&nbsp;    };&nbsp;​&nbsp;    inline GK8_LPCSTR GetErrorBuffer()&nbsp;    {&nbsp;        return m_sErrorBuffer;&nbsp;    }&nbsp;};&nbsp;​&nbsp;#endif</code></pre><p>C++實現HTTP通信類：Gk8HttpClient.h</p><pre><code>&nbsp;#ifndef __GK8HTTPCLIENT_H__&nbsp;#define __GK8HTTPCLIENT_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;Gk8HttpRequest.h&#34;&nbsp;#include &#34;Gk8HttpResponse.h&#34;&nbsp;​&nbsp;​&nbsp;class Gk8HttpClient&nbsp;{&nbsp;private:&nbsp;    GK8_INT m_nTimeOutForConnect;       //[連接超時時間]&nbsp;    GK8_INT m_nTimeOutForRead;          //[讀取超時時間]&nbsp;​&nbsp;private:&nbsp;    Gk8HttpClient();&nbsp;    virtual ~Gk8HttpClient();&nbsp;​&nbsp;    GK8_BOOL InitThreadSemphore();&nbsp;public:&nbsp;​&nbsp;    inline GK8_VOID SetTimeoutForConnect(GK8_INT nTimeOutForConnect){m_nTimeOutForConnect=nTimeOutForConnect;};&nbsp;    inline GK8_INT GetTimeoutForConnect(){return m_nTimeOutForConnect;}&nbsp;​&nbsp;    inline GK8_VOID SetTimeoutForRead(GK8_INT nTimeOutForRead){m_nTimeOutForRead=nTimeOutForRead;};&nbsp;    inline GK8_INT GetTimeoutForRead(){return m_nTimeOutForRead;};&nbsp;​&nbsp;    GK8_VOID Send(Gk8HttpRequest* pHttpRequest);&nbsp;​&nbsp;    GK8_VOID HttpClientTick();&nbsp;    static Gk8HttpClient* GetInstance();&nbsp;};&nbsp;#endif</code></pre><p>C++實現HTTP通信類：Gk8HttpClient.cpp</p><pre><code>&nbsp;&nbsp;#include &#34;Gk8HttpClient.h&#34;&nbsp;#include &#34;curl/curl.h&#34;&nbsp;#include &#34;Gk8OperSys.h&#34;&nbsp;#include &#34;Gk8SetMb.cpp&#34;&nbsp;​&nbsp;#include &lt;queue&gt;&nbsp;#include &lt;pthread.h&gt;&nbsp;#include &lt;semaphore.h&gt;&nbsp;#include &lt;errno.h&gt;&nbsp;#include &lt;fcntl.h&gt;&nbsp;​&nbsp;​&nbsp;static Gk8HttpClient* sg_pHttpClient=NULL;      //[靜態HTTP客戶端]&nbsp;​&nbsp;static GK8_BOOL sg_bHttpClientQuit=false;       //[退出HTTP]&nbsp;static sem_t* sg_pSem=NULL;                     //[信號量的數據類型]&nbsp;static GK8_INT sg_AsyncRequestCount=0;          //[同步請求數]&nbsp;​&nbsp;//[線程及互斥定義]&nbsp;static pthread_t sg_NetWorkThread;              //[HTTP線程]&nbsp;static pthread_mutex_t sg_RequestQueueMutex;    //[HTTP請求隊列互斥體]&nbsp;static pthread_mutex_t sg_ResponseQueueMutex;   //[HTTP響應隊列互斥體]&nbsp;​&nbsp;static Gk8SetMb&lt;Gk8HttpRequest*&gt; sg_iRequestQueue;      //[HTTP請求隊列]&nbsp;static Gk8SetMb&lt;Gk8HttpResponse*&gt; sg_iResponseQueue;    //[HTTP響應隊列]&nbsp;​&nbsp;​&nbsp;static GK8_CHAR sg_szErrorBuf[CURL_ERROR_SIZE];         //[錯誤信息]&nbsp;static Gk8Str sg_iErrorStr;&nbsp;​&nbsp;typedef size_t (*HTTPWRITE_CALLBACK)(GK8_LPVOID lpData,size_t nSize,size_t nMemBlock,GK8_LPVOID lpResponseData);&nbsp;​&nbsp;#if (GK8_TARGET_PLATFORM==GK8_PLATFORM_IOS)&nbsp;#define GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE 1&nbsp;#else&nbsp;#define GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE 0&nbsp;#endif&nbsp;​&nbsp;#if GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE&nbsp;#define GK8_ASYNC_HTTPREQUEST_SEMAPHORE &#34;Gk8HttpAsync&#34;&nbsp;#else&nbsp;static sem_t sg_iSem;&nbsp;#endif&nbsp;​&nbsp;​&nbsp;GK8_BOOL ConfigureCURL(CURL* pCurl);&nbsp;GK8_INT ProcessGetTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode);&nbsp;GK8_INT ProcessPostTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode);&nbsp;​&nbsp;​&nbsp;//[接收HTTP數據]&nbsp;size_t WriteHttpData(GK8_LPVOID lpData,size_t nSize,size_t nMemBlock,GK8_LPVOID lpResponseData)&nbsp;{&nbsp;    Gk8ByteMaker* pResponseData=(Gk8ByteMaker*)lpResponseData;&nbsp;    size_t nLength=nSize*nMemBlock;&nbsp;    pResponseData-&gt;WriteBuf(lpData,(GK8_INT)nLength);&nbsp;    return nLength;&nbsp;}&nbsp;​&nbsp;//[設置CURL超時屬性設置]&nbsp;GK8_BOOL ConfigureCURL(CURL* pCurl)&nbsp;{&nbsp;    if(!pCurl) return false;&nbsp;​&nbsp;    CURLcode nCurlCode=curl_easy_setopt(pCurl,CURLOPT_ERRORBUFFER,sg_szErrorBuf);&nbsp;    if(nCurlCode!=CURLE_OK) return false;&nbsp;​&nbsp;    nCurlCode=curl_easy_setopt(pCurl,CURLOPT_TIMEOUT,Gk8HttpClient::GetInstance()-&gt;GetTimeoutForRead());&nbsp;    if(nCurlCode!=CURLE_OK) return false;&nbsp;​&nbsp;    nCurlCode=curl_easy_setopt(pCurl,CURLOPT_CONNECTTIMEOUT,Gk8HttpClient::GetInstance()-&gt;GetTimeoutForConnect());&nbsp;    if(nCurlCode!=CURLE_OK) return false;&nbsp;    &nbsp;    curl_easy_setopt(pCurl,CURLOPT_SSL_VERIFYPEER,0L);&nbsp;    curl_easy_setopt(pCurl,CURLOPT_SSL_VERIFYHOST,0L);&nbsp;​&nbsp;    curl_easy_setopt(pCurl,CURLOPT_NOSIGNAL,1L);&nbsp;    return true;&nbsp;}&nbsp;​&nbsp;//[處理Get請求]&nbsp;GK8_INT ProcessGetTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode)&nbsp;{&nbsp;    CURLcode nCurlCode=CURL_LAST;&nbsp;    CURL* pCurl=curl_easy_init();&nbsp;    &nbsp;    do&nbsp;    {&nbsp;        if(!ConfigureCURL(pCurl)) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_URL,pHttpRequest-&gt;GetHttpUrl());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;        &nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEFUNCTION,lpCallBack);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEDATA,lpStream);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;        &nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_FOLLOWLOCATION,true);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_USERAGENT,&#34;libcurl-agent/1.0&#34;);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_perform(pCurl);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_getinfo(pCurl,CURLINFO_RESPONSE_CODE,lpResponseCode);&nbsp;        //[200:指示客服端的請求已經成功收到，解析，接受]&nbsp;        if(nCurlCode!=CURLE_OK||*lpResponseCode!=200)&nbsp;        {&nbsp;            nCurlCode=CURLE_HTTP_RETURNED_ERROR;&nbsp;        }&nbsp;    }while(0);&nbsp;    &nbsp;    if(pCurl) curl_easy_cleanup(pCurl);&nbsp;​&nbsp;    return (nCurlCode==CURLE_OK?0:1);&nbsp;}&nbsp;​&nbsp;//[處理POST請求:流的行事發出]&nbsp;GK8_INT ProcessPostTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode)&nbsp;{&nbsp;    CURLcode nCurlCode=CURL_LAST;&nbsp;    CURL* pCurl=curl_easy_init();&nbsp;​&nbsp;    do&nbsp;    {&nbsp;        if(!ConfigureCURL(pCurl)) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_URL,pHttpRequest-&gt;GetHttpUrl());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEFUNCTION,lpCallBack);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEDATA,lpStream);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_POST,1);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_POSTFIELDS,pHttpRequest-&gt;GetRequestData()-&gt;GetBuf());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_POSTFIELDSIZE,pHttpRequest-&gt;GetRequestDataSize());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_perform(pCurl);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_getinfo(pCurl,CURLINFO_RESPONSE_CODE,lpResponseCode);&nbsp;        &nbsp;        if(nCurlCode!=CURLE_OK||*lpResponseCode!=200)&nbsp;        {&nbsp;            nCurlCode=CURLE_HTTP_RETURNED_ERROR;&nbsp;        }&nbsp;    }while(0);&nbsp;    if(pCurl) curl_easy_cleanup(pCurl);&nbsp;​&nbsp;    return (nCurlCode==CURLE_OK?0:1);&nbsp;}&nbsp;​&nbsp;//[創建網絡線程]&nbsp;static GK8_LPVOID NetWorkThread(GK8_LPVOID lpData)&nbsp;{&nbsp;    Gk8HttpRequest* pHttpRequest=NULL;&nbsp;    Gk8HttpResponse* pHttpResponse=NULL;&nbsp;​&nbsp;    while(true)&nbsp;    {&nbsp;        //Wait for http request tasks from main thread&nbsp;        GK8_INT nSemWaitRet=sem_wait(sg_pSem);&nbsp;        if(nSemWaitRet&lt;0)&nbsp;        {&nbsp;            _GK8ERR&lt;&lt;&#34;HttpRequest async thread semaphore error:&#34;&lt;&lt;strerror(errno)&lt;&lt;CR;&nbsp;            break;&nbsp;        }&nbsp;​&nbsp;        if(sg_bHttpClientQuit) break;&nbsp;​&nbsp;        //[第一步:發送HTTP請求]&nbsp;        pHttpRequest=NULL;&nbsp;        pthread_mutex_lock(&sg_RequestQueueMutex);&nbsp;        if(0!=sg_iRequestQueue.GetSize())&nbsp;        {&nbsp;            pHttpRequest=sg_iRequestQueue.GetItemAt(0);&nbsp;            sg_iRequestQueue.RemoveItemAt(0);&nbsp;        }&nbsp;        pthread_mutex_unlock(&sg_RequestQueueMutex);&nbsp;​&nbsp;        if(NULL==pHttpRequest) continue;&nbsp;​&nbsp;        //[第二步:libCurl同步請求]&nbsp;        pHttpResponse=new Gk8HttpResponse(pHttpRequest);&nbsp;​&nbsp;        GK8_INT nResponseCode=-1;&nbsp;        GK8_INT nRetValue=0;&nbsp;​&nbsp;        switch(pHttpRequest-&gt;GetRequestType())&nbsp;        {&nbsp;            case Gk8HttpRequest::kHttpGet:&nbsp;                nRetValue=ProcessGetTask(pHttpRequest,WriteHttpData,pHttpResponse-&gt;GetResponseData(),&nResponseCode);&nbsp;                break;&nbsp;            case Gk8HttpRequest::kHttpPost:&nbsp;                nRetValue=ProcessPostTask(pHttpRequest,WriteHttpData,pHttpResponse-&gt;GetResponseData(),&nResponseCode);&nbsp;                break;&nbsp;            default:&nbsp;                _GK8ERR&lt;&lt;&#34;Gk8HttpClient:Unkown Request Type,Only GET And POST Are Supported&#34;&lt;&lt;CR;&nbsp;                break;&nbsp;        }&nbsp;        pHttpResponse-&gt;SetResponseCode(nResponseCode);&nbsp;        //[清除請求中的二進制數據]&nbsp;        pHttpRequest-&gt;ClearRequestData();&nbsp;​&nbsp;        if(nRetValue!=0)&nbsp;        {&nbsp;            pHttpResponse-&gt;SetSucceed(false);&nbsp;            sg_iErrorStr=sg_szErrorBuf;&nbsp;            pHttpResponse-&gt;SetErrorBuffer(sg_iErrorStr);&nbsp;        }else&nbsp;        {&nbsp;            pHttpResponse-&gt;SetSucceed(true);&nbsp;        }&nbsp;​&nbsp;        pthread_mutex_lock(&sg_ResponseQueueMutex);&nbsp;        sg_iResponseQueue.AddItem(pHttpResponse);&nbsp;        pthread_mutex_unlock(&sg_ResponseQueueMutex);&nbsp;    }&nbsp;​&nbsp;    sg_AsyncRequestCount-=sg_iRequestQueue.GetSize();&nbsp;    pthread_mutex_lock(&sg_RequestQueueMutex);&nbsp;    sg_iRequestQueue.Clear();&nbsp;    pthread_mutex_unlock(&sg_RequestQueueMutex);&nbsp;    &nbsp;    if(sg_pSem!=NULL)&nbsp;    {&nbsp;#if GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE&nbsp;        sem_unlink(GK8_ASYNC_HTTPREQUEST_SEMAPHORE);&nbsp;        sem_close(sg_pSem);&nbsp;#else&nbsp;        sem_destroy(sg_pSem);&nbsp;#endif&nbsp;        sg_pSem=NULL;&nbsp;​&nbsp;        pthread_mutex_destroy(&sg_RequestQueueMutex);&nbsp;        pthread_mutex_destroy(&sg_ResponseQueueMutex);&nbsp;​&nbsp;        //[依次刪除數據]&nbsp;        GK8_INT nIndex;&nbsp;        for(nIndex=0;nIndex&lt;sg_iRequestQueue.GetSize();nIndex++)&nbsp;        {&nbsp;            pHttpRequest=sg_iRequestQueue.GetItemAt(nIndex);&nbsp;            delete pHttpRequest;&nbsp;        }&nbsp;        for(nIndex=0;nIndex&lt;sg_iResponseQueue.GetSize();nIndex++)&nbsp;        {&nbsp;            pHttpResponse=sg_iResponseQueue.GetItemAt(nIndex);&nbsp;            delete pHttpResponse;&nbsp;        }&nbsp;        sg_iRequestQueue.Destroy();&nbsp;        sg_iResponseQueue.Destroy();&nbsp;    }&nbsp;    pthread_exit(NULL);&nbsp;    return 0;&nbsp;}&nbsp;​&nbsp;/////////////////////////////////////////////////////////////////&nbsp;Gk8HttpClient::Gk8HttpClient()&nbsp;:m_nTimeOutForRead(60)&nbsp;,m_nTimeOutForConnect(30)&nbsp;{&nbsp;​&nbsp;}&nbsp;​&nbsp;Gk8HttpClient::~Gk8HttpClient()&nbsp;{&nbsp;    sg_bHttpClientQuit=true;&nbsp;    if(sg_pSem!=NULL)&nbsp;    {&nbsp;        sem_post(sg_pSem);&nbsp;    }&nbsp;}&nbsp;​&nbsp;//[初始化線程]&nbsp;GK8_BOOL Gk8HttpClient::InitThreadSemphore()&nbsp;{&nbsp;    if(sg_pSem!=NULL)&nbsp;    {&nbsp;        return true;&nbsp;    }else&nbsp;    {&nbsp;#if GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE&nbsp;        sg_pSem=sem_open(GK8_ASYNC_HTTPREQUEST_SEMAPHORE,O_CREAT,0644,0);&nbsp;        if(sg_pSem==SEM_FAILED)&nbsp;        {&nbsp;            _GK8ERR&lt;&lt;&#34;Open HttpRequest Semaphore Failed&#34;&lt;&lt;CR;&nbsp;            sg_pSem=NULL;&nbsp;            return false;&nbsp;        }&nbsp;#else&nbsp;        GK8_INT nSemRet=sem_init(&sg_iSem,0,0);&nbsp;        if(nSemRet&lt;0)&nbsp;        {&nbsp;            _GK8ERR&lt;&lt;&#34;Init HttpRequest Semaphore Failed&#34;&lt;&lt;CR;&nbsp;            return false;&nbsp;        }&nbsp;        sg_pSem=&sg_iSem;&nbsp;#endif&nbsp;​&nbsp;        pthread_mutex_init(&sg_RequestQueueMutex,NULL);&nbsp;        pthread_mutex_init(&sg_ResponseQueueMutex,NULL);&nbsp;​&nbsp;        pthread_create(&sg_NetWorkThread,NULL,NetWorkThread,NULL);&nbsp;        pthread_detach(sg_NetWorkThread);&nbsp;​&nbsp;        sg_bHttpClientQuit=false;&nbsp;    }&nbsp;    return true;&nbsp;}&nbsp;​&nbsp;//[發送HTTP請求]&nbsp;GK8_VOID Gk8HttpClient::Send(Gk8HttpRequest* pHttpRequest)&nbsp;{&nbsp;    if(false==InitThreadSemphore()) return;&nbsp;    if(!pHttpRequest) return;&nbsp;​&nbsp;    ++sg_AsyncRequestCount;&nbsp;​&nbsp;    pthread_mutex_lock(&sg_RequestQueueMutex);&nbsp;    sg_iRequestQueue.AddItem(pHttpRequest);&nbsp;    pthread_mutex_unlock(&sg_RequestQueueMutex);&nbsp;​&nbsp;    sem_post(sg_pSem);&nbsp;}&nbsp;​&nbsp;//[獲取HTTP單例]&nbsp;Gk8HttpClient* Gk8HttpClient::GetInstance()&nbsp;{&nbsp;    if(sg_pHttpClient==NULL) sg_pHttpClient=new Gk8HttpClient();&nbsp;    return sg_pHttpClient;&nbsp;}&nbsp;​&nbsp;//[HTTP響應幀控制]&nbsp;GK8_VOID Gk8HttpClient::HttpClientTick()&nbsp;{&nbsp;    if(sg_pSem==NULL) return;&nbsp;​&nbsp;    Gk8HttpResponse* pHttpResponse=NULL;&nbsp;​&nbsp;    pthread_mutex_lock(&sg_ResponseQueueMutex);&nbsp;    if(sg_iResponseQueue.GetSize()&gt;0)&nbsp;    {&nbsp;        pHttpResponse=sg_iResponseQueue.GetItemAt(0);&nbsp;        sg_iResponseQueue.RemoveItemAt(0);&nbsp;    }&nbsp;    pthread_mutex_unlock(&sg_ResponseQueueMutex);&nbsp;    &nbsp;    if(pHttpResponse)&nbsp;    {&nbsp;        --sg_AsyncRequestCount;&nbsp;        Gk8HttpRequest* pHttpRequest=pHttpResponse-&gt;GetHttpRequest();&nbsp;        Gk8BaseObj* pTarget=pHttpRequest-&gt;GetTarget();&nbsp;        HTTPREQUEST_CALLBACK_FUN pSelector=pHttpRequest-&gt;GetSelector();&nbsp;​&nbsp;        //[回調處理:記錄數據]&nbsp;        if(pTarget&&pSelector)&nbsp;        {&nbsp;            (pTarget-&gt;*pSelector)(pHttpResponse);&nbsp;        }&nbsp;        //[銷燬請求數據]&nbsp;        delete pHttpResponse;&nbsp;    }&nbsp;}</code></pre><p>C++實現Servlet類：Gk8HttpServlet.h</p><pre><code>&nbsp;#ifndef __GK8HTTPSERVICE_H__&nbsp;#define __GK8HTTPSERVICE_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;curl/curl.h&#34;&nbsp;#include &#34;Gk8HttpClient.h&#34;&nbsp;#include &#34;Gk8HttpRequest.h&#34;&nbsp;#include &#34;Gk8HttpResponse.h&#34;&nbsp;​&nbsp;class Gk8HttpServlet:public Gk8BaseObj&nbsp;{&nbsp;    DECLARE_TOSPP_MAP;&nbsp;private:&nbsp;    Gk8Str m_sHttpUrl;              //[HTTP請求地址]&nbsp;    Gk8ByteMaker m_iRequestData;    //[HTTP請求數據]&nbsp;    Gk8Var m_iHttpCallVar;          //[HTTP回調信息]&nbsp;​&nbsp;    GK8_VOID ServletRequestCompleted(GK8_LPVOID lpHttpResponse);&nbsp;public:&nbsp;    Gk8HttpServlet();&nbsp;    ~Gk8HttpServlet();&nbsp;​&nbsp;    GK8_VOID TOSPPFUNC SendHttpMessage(GK8_LPCSTR lpHttpData,Gk8Var& iHttpCallVar);&nbsp;};&nbsp;#endif</code></pre><p>C++實現Servlet類：Gk8HttpServlet.cpp</p><pre><code>&nbsp;#include &#34;Gk8HttpServlet.h&#34;&nbsp;#include &#34;Gk8OperSys.h&#34;&nbsp;#include &#34;Gk8Helper.h&#34;&nbsp;​&nbsp;static Gk8Str sg_iReceiveMessageEvent(&#34;OnReceiveMessage&#34;);//[接收網絡信息]&nbsp;​&nbsp;#define HTTPSERVLET_FAIL        0       //[HTTP請求失敗]&nbsp;#define HTTPSERVLET_SUCC        1       //[HTTP請求成功]&nbsp;​&nbsp;/////////////////////////////////////////////CLASS-TOLUA////////////////////////////////////////////////////&nbsp;TOLUA_CLASS_COLLECT_FUNC(Gk8HttpServlet)&nbsp;​&nbsp;BEGIN_TOLUA_CLASS_FUNC(Gk8HttpServlet,NewObj)&nbsp;    if(!CheckToLuaFunParam(L,&#34;NewObj&#34;,Gk8Var()&lt;&lt;ISUSERTABLE(&#34;Gk8HttpServlet&#34;)&lt;&lt;ISVABOOLEAN&lt;&lt;ISNOOBJ)) return 0;&nbsp;    Gk8HttpServlet* pHttpServlet=(Gk8HttpServlet*)Mtolua_new((Gk8HttpServlet)());&nbsp;    tolua_pushusertype(L,(GK8_LPVOID)pHttpServlet,&#34;Gk8HttpServlet&#34;);&nbsp;    if(IFBOOLEAN(2)) tolua_register_gc(L,lua_gettop(L));&nbsp;END_TOLUA_CLASS_FUNC&nbsp;​&nbsp;BEGIN_TOLUA_CLASS_FUNC(Gk8HttpServlet,SendHttpMessage)&nbsp;    if(!CheckToLuaFunParam(L,&#34;SendHttpMessage&#34;,Gk8Var()&lt;&lt;ISUSERTYPE(&#34;Gk8HttpServlet&#34;)&lt;&lt;ISSTRING&lt;&lt;ISVAFUNCTION&lt;&lt;ISNOOBJ)) return 0;&nbsp;    //TOLUAGETOBJ(Gk8HttpServlet,1)-&gt;SendHttpMessage(TOLUAGETSTRING(2),TOLUAGETFUNEX(L,3,0));&nbsp;END_TOLUA_CLASS_FUNC&nbsp;​&nbsp;//[啟動註冊類的全部TOLUA函數]&nbsp;BEGIN_TOLUA_FUN_MAP(Gk8HttpServlet)&nbsp;    TOLUA_CLASS(Gk8HttpServlet,Gk8BaseObj,&#34;[網絡類]&#34;,&#34;[HTTP請求類]&#34;)&nbsp;    TOLUA_CLASS_FUNC(Gk8HttpServlet,NewObj,&#34;[Gk8HttpServlet* NewObj(GK8_BOOL ifLocal=false)?創建Gk8HttpServlet對象]&#34;)&nbsp;    TOLUA_CLASS_FUNC(Gk8HttpServlet,SendHttpMessage,&#34;[GK8_VOID SendHttpMessage(GK8_LPCSTR lpHttpData,iHttpCallVar)?發送HTTP請求,字符串模式]&#34;)&nbsp;END_TOLUA_FUN_MAP&nbsp;​&nbsp;/////////////////////////////////////////////CLASS-TOSPP////////////////////////////////////////////////////&nbsp;BEGIN_TOSPP_MAP(Gk8HttpServlet,Gk8BaseObj)&nbsp;    TOSPP_FUNC(Gk8HttpServlet,SendHttpMessage,&#39; &#39;,&#34;s&v&#34;,&#34;SendHttpMessage(lpHttpData,iHttpCallVar)&#34;)&nbsp;END_TOSPP_MAP()&nbsp;/////////////////////////////////////////////////////////////////////////////////////////////////&nbsp;​&nbsp;Gk8HttpServlet::Gk8HttpServlet()&nbsp;{&nbsp;​&nbsp;}&nbsp;​&nbsp;Gk8HttpServlet::~Gk8HttpServlet()&nbsp;{&nbsp;​&nbsp;}&nbsp;​&nbsp;//[發送HTTP請求注意編碼問題]&nbsp;GK8_VOID Gk8HttpServlet::SendHttpMessage(GK8_LPCSTR lpHttpData,Gk8Var& iHttpCallVar)&nbsp;{&nbsp;    m_sHttpUrl=lpHttpData;&nbsp;    //[註冊腳本回調消息]&nbsp;    m_iHttpCallVar=iHttpCallVar;&nbsp;    Gk8Var iEmptyVar;&nbsp;    if(m_iHttpCallVar.GetSize()==1 && m_iHttpCallVar[0].IfInt()) SetEvent(sg_iReceiveMessageEvent,m_iHttpCallVar[0],iEmptyVar);&nbsp;    Gk8HttpRequest* pHttpRequest=new Gk8HttpRequest();&nbsp;    pHttpRequest-&gt;SetRequestType(Gk8HttpRequest::kHttpGet);&nbsp;    pHttpRequest-&gt;SetHttpUrl(m_sHttpUrl);&nbsp;    pHttpRequest-&gt;SetResponseCallBack(this,(HTTPREQUEST_CALLBACK_FUN)&Gk8HttpServlet::ServletRequestCompleted);&nbsp;    pHttpRequest-&gt;SetRequestData(&m_iRequestData);&nbsp;​&nbsp;    Gk8HttpClient::GetInstance()-&gt;Send(pHttpRequest);&nbsp;}&nbsp;​&nbsp;//[HTTP請求信息回調]&nbsp;GK8_VOID Gk8HttpServlet::ServletRequestCompleted(GK8_LPVOID lpHttpResponse)&nbsp;{&nbsp;    Gk8HttpResponse* pHttpResponse=(Gk8HttpResponse*)lpHttpResponse;&nbsp;    if(!pHttpResponse) return;&nbsp;​&nbsp;    //[把服務器數據派遣到腳本中]&nbsp;    GK8_INT nFailCode=HTTPSERVLET_SUCC;&nbsp;    Gk8Str iResponstStr;&nbsp;    if(!pHttpResponse-&gt;IsSucceed())&nbsp;    {&nbsp;        _GK8ERR&lt;&lt;&#34;Gk8HttpServlet Response Failed Error Is &#34;&lt;&lt;pHttpResponse-&gt;GetErrorBuffer()&lt;&lt;CR;&nbsp;        iResponstStr=&#34;UnKown Error&#34;;&nbsp;        nFailCode=HTTPSERVLET_FAIL;&nbsp;    }else&nbsp;    {&nbsp;        Gk8ByteMaker* pResponseData=pHttpResponse-&gt;GetResponseData();&nbsp;        iResponstStr.BinToStr(pResponseData-&gt;GetBuf(),pResponseData-&gt;GetStreamSize());&nbsp;    }&nbsp;​&nbsp;    if(m_iHttpCallVar.GetSize()==1)&nbsp;    {&nbsp;        RunEventWithArgs(sg_iReceiveMessageEvent,iResponstStr);&nbsp;    }else&nbsp;    {&nbsp;        if(!m_iHttpCallVar[0].IfPtr()||!IfObjPtr(m_iHttpCallVar[0].GetPtr(),m_iHttpCallVar[0].GetPtrId())) return;&nbsp;​&nbsp;        Gk8Obj* pBindObj=m_iHttpCallVar[0].GetSafePtr();&nbsp;        Gk8Var iParamVar;&nbsp;        iParamVar&lt;&lt;nFailCode&lt;&lt;iResponstStr;&nbsp;        pBindObj-&gt;OnCall(m_iHttpCallVar[1],iParamVar);&nbsp;    }&nbsp;    //[直接刪除本身]&nbsp;    SafeDeleteObj(this);&nbsp;}</code></pre><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>網絡</a></li><li><a>HTTP</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c06e6a1.html alt=網絡中怎樣通過安全控制列表ACL實現安全控制，實現遠程登錄訪問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4bb8179f7be245e9bb3f154229247e66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c06e6a1.html title=網絡中怎樣通過安全控制列表ACL實現安全控制，實現遠程登錄訪問>網絡中怎樣通過安全控制列表ACL實現安全控制，實現遠程登錄訪問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/060195b.html alt="用 Ansible 實現網絡自動化" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153576827890540a4f9e152 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/060195b.html title="用 Ansible 實現網絡自動化">用 Ansible 實現網絡自動化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html alt=光纜——未來網絡主導 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e75c1afe12354a93bad8495ad1057693 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html title=光纜——未來網絡主導>光纜——未來網絡主導</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdc59733.html alt="網絡詞名場面是什麼意思 名場面是什麼梗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdc59733.html title="網絡詞名場面是什麼意思 名場面是什麼梗">網絡詞名場面是什麼意思 名場面是什麼梗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a002ca18.html alt=王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/26add5cdc08e4214800b25e21b623eb1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a002ca18.html title=王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯>王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad6f0929.html alt=谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/65c4000bda98898dcdbb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad6f0929.html title=谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼>谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8dce33e7.html alt=理解生成對抗網絡，一步一步推理得到GANs（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bee194d6fbec4d6f82e82998def3f7a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8dce33e7.html title=理解生成對抗網絡，一步一步推理得到GANs（一）>理解生成對抗網絡，一步一步推理得到GANs（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html alt=瞭解生成對抗網絡（GAN） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/634604de44ad4d17931ccc0bcf3e46ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html title=瞭解生成對抗網絡（GAN）>瞭解生成對抗網絡（GAN）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>