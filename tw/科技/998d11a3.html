<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>分佈式之 Nginx | 极客快訊</title><meta property="og:title" content="分佈式之 Nginx - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/aa7f1dd1-da97-43c9-be0a-b875735ea0d0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/998d11a3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/998d11a3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/998d11a3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/998d11a3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/998d11a3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/998d11a3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/998d11a3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/998d11a3.html><meta property="article:published_time" content="2020-11-14T21:01:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:37+08:00"><meta name=Keywords content><meta name=description content="分佈式之 Nginx"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/998d11a3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>分佈式之 Nginx</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/aa7f1dd1-da97-43c9-be0a-b875735ea0d0><p class=pgc-img-caption></p></div><p>本篇一句話總結：<strong>Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。</strong></p><p>正文開始：</p><p>什麼是Nginx？</p><p>為什麼選擇Nginx?</p><p>怎麼用Nginx？</p><p>上面這幾個問題，是每個剛接觸 Nginx 的人都想知道的。下面小兵綜合自己的理解和使用情況，在分佈式專題裡總結一篇關於 Nginx 的內容。全文看完，我們對 Nginx 也有一定的瞭解了。</p><p>什麼是Nginx?</p><p>總結一句話，就是：</p><p>Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。</p><p>從這句話我們可以知道Nginx的基本定位是Web服務器，然後Nginx還提供反向代理、負載均衡、動靜分離、HTTP緩存的功能。</p><p>什麼是Web服務器？</p><p>Web服務器是指駐留於因特網上某種類型計算機的程序，是可以向發出請求的瀏覽器提供文檔的程序。當Web瀏覽器（客戶端）連到Web服務器上併發送請求時，Web服務器將處理該請求並將文件反饋到該瀏覽器上，附帶的信息會告訴瀏覽器如何查看該文件（即文件類型）。Web服務器使用HTPP協議與客戶機瀏覽器進行信息交流，這就是人們常把它們稱為HTTP服務器的原因。Nginx最基本的功能便是作為Web服務器。目前最主流的三個Web服務器是Apache、 Nginx 、IIS。常用的還有Tomcat、WebLogic、JBoss、Jetty、Netty等。下面簡單介紹下幾個主流開源的Web服務器：</p><p>Apache是目前市場佔用量最高的web服務器，據最新數據統計，市場佔有率目前是50%左右。主要優勢在於一個是比較早出現的一個Http靜態資源服務器，可以作為Web服務器使用，用於處理靜態網頁，比如HTML、圖片、視頻、音頻等靜態文件，Apache穩定性良好，支持的模塊豐富。但是其不適宜高併發的請求。</p><p>Nginx是俄羅斯人編寫的一款高性能的HTTP和反向代理服務器，在高連接併發的情況下，它能夠支持高達50000個併發連接數的響應，但是內存、CPU等系統資源消耗卻很低，運行很穩定。目前Nginx在國內很多大型企業都有應用，據最新統計，Nginx的市場佔有率已經到33%左右了。雖然Apache的市場佔有率雖然仍然是最高的，但是是呈下降趨勢。而Nginx的勢頭很明顯。在Nginx的基礎上，淘寶還搞出了一個Web服務器Tengine。相信大公司的眼光是不會差的。</p><p>Tomcat是Apache的拓展，更實質的說是Java應用服務器。它主要用於解析servlet/JSP，能夠動態地生成資源，同時具備HTTP服務。Tomcat根據請求將動態的內容轉化為靜態的內容之後，通過 HTTP Server 分發到客戶端，對靜態頁的支持效率就沒有Apache高。單純的Tomcat性能有限，在很多地方表現有欠缺，如活動連接支持、靜態內容、大文件和HTTPS等。因此大多數公司都是Tomcat配合Apache或者Nginx一起使用。</p><p>為什麼選擇Nginx?</p><p>選擇Nginx的理由也很簡單：</p><p>第一，它可以支持每秒5W高併發連接；</p><p>第二，內存消耗少；</p><p>第三，成本低，如果採用F5、NetScaler等硬件負載均衡設備的話，需要大幾十萬。而Nginx是開源的，可以免費使用並且能用於商業用途</p><p>下面，我們先把Nginx下載回來，結合實例，一起來認識和理解“Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。”的含義。</p><p>Nginx安裝</p><p>（為寫本篇博客小兵準備了兩臺CentOS 7.x服務器，139.155.105.15用於安裝nginx，47.112.148.36用於部署tomcat應用。）</p><p><strong>一、安裝編譯工具及庫文件</strong></p><pre>yum -y install make gcc gcc-c++ libtool zlib zlib-devel openssl openssl-devel</pre><p><strong>二、安裝 PCRE</strong></p><p>2.1 下載pcre，下載完成後解壓：</p><pre>[root@VM_0_10_centos ~]# cd /usr/local/src/[root@VM_0_10_centos src]# wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz[root@VM_0_10_centos src]# tar zxvf pcre-8.35.tar.gz</pre><p>2.2 解壓後進入目錄並編譯安裝：</p><pre>[root@VM_0_10_centos src]# cd pcre-8.35/[root@VM_0_10_centos pcre-8.35]# ./configure[root@VM_0_10_centos pcre-8.35]# make &amp;&amp; make install</pre><p>2.3 查看pcre版本，出現版本號即安裝pcre成功</p><pre>[root@VM_0_10_centos pcre-8.35]# pcre-config --version8.35</pre><p><strong>三、安裝 Nginx</strong></p><p>3.1 下載nginx，下載完成後解壓：</p><pre>[root@VM_0_10_centos ~]# cd /usr/local/src/[root@VM_0_10_centos src]# wget http://nginx.org/download/nginx-1.6.2.tar.gz[root@VM_0_10_centos src]# tar zxvf nginx-1.6.2.tar.gz</pre><p>3.2 解壓後進入目錄並編譯安裝：</p><pre>[root@VM_0_10_centos src]# cd nginx-1.6.2/[root@VM_0_10_centos nginx-1.6.2]# ./configure[root@VM_0_10_centos nginx-1.6.2]# make &amp;&amp; make install</pre><p>3.3 查看nginx版本，出現版本號即安裝nginx成功。（默認安裝在/usr/local/nginx）</p><pre>[root@VM_0_10_centos nginx-1.6.2]# cd /usr/local/nginx/sbin/[root@VM_0_10_centos sbin]# ./nginx -vnginx version: nginx/1.6.2</pre><p>3.4 啟動並訪問</p><pre>[root@VM_0_10_centos sbin]# ./nginx</pre><p>nginx默認監聽的是80端口，所以在客戶端（瀏覽器）輸入服務器ip即可訪問nginx</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06ba2bdaeb1e4ac89c34fa886e93ee0a><p class=pgc-img-caption>Nginx默認首頁</p></div><pre>nginx相關命令：/usr/local/nginx/sbin/nginx -t # 檢查配置文件語法/usr/local/nginx/sbin/nginx -c #指定nginx.conf的文件。不指定時默認為NGINX_HOME/conf/nginx.conf/usr/local/nginx/sbin/nginx -s reload # 重新載入配置文件/usr/local/nginx/sbin/nginx -s reopen # 重啟 Nginx/usr/local/nginx/sbin/nginx -s stop # 停止 Nginx</pre><p><strong>Nginx配置文件</strong></p><p>我們說“Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存”。Nginx能提供這些功能，都是通過配置nginx.conf文件來實現，所以這個配置文件的重要性可想而知。我們查看 conf/nginx.conf 文件，去除註釋後得默認配置如下。可以看到nginx的核心配置可以是很簡潔的，最主要包括三個模塊：main、 events 、 http。每個模塊都可以根據自己的需要進行相應的配置，我們也可以添加自己的模塊。本篇對配置文件不做過多介紹，可參考常用nginx.conf配置文件解析和nginx配置參數詳細說明。</p><pre># 一、主模塊配置# nginx要開啟的工作進程數。Nginx有一個主線程和一個或多個工作線程。worker_processes 1; # 二、事件模塊配置events { # 單個worker進程打開的最大併發連接數 worker_connections 1024;} # 三、http模塊配置http { # include指在當前文件中包含另一個文件內容 include mime.types; # 設置文件使用默認的mine-type，默認是未知的類型 default_type application/octet-stream;  # 優化磁盤IO設置，指定nginx是否調用sendfile函數來輸出文件，普通應用設為on，下載等磁盤IO高的應用，可設為off sendfile on;  # 長連接的超時時長 keepalive_timeout 65;  # 虛擬主機 server { # 監聽80端口 listen 80; # 定義主機名，主機名可以有多個，名稱還可以使用正則表達式(~)或通配符 server_name localhost;  # 根據用戶請求的URI來匹配定義的某個location，匹配到時，此請求將被相應的location配置塊中的配置所處理 location / { # 定義服務器的默認網站根目錄位置 root html; # 定義首頁索引文件的名稱 index index.html index.htm; }  # 定義錯誤提示頁面 error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } }｝</pre><div class=tt-column-card data-content='{"new_thumb_url": "http://sf1-ttcdn-tos.pstatp.com/img/pgc-image/833e3310a8004610a0738885d3274f19", "title": "\u8f7b\u677e\u5165\u95e8WebRTC\u53ca\u5b9e\u6218\u63d0\u9ad8", "distribution_user_id": 1602082613542925, "price": 9.9, "column_id": "6725277425749459211", "share_price": 0, "author_description": "lee\u54e5\u8bf4\u67b6\u6784", "thumb_url": "http://p4.pstatp.com/large/pgc-image/833e3310a8004610a0738885d3274f19", "sold": 22}'></div><p><strong>Nginx用做Web服務器</strong></p><p>Nginx默認就是當作Web服務器來使用，我們能訪問到Nginx的默認首頁，就是Nginx作為Web服務器給瀏覽器響應返回了配置文件 nginx.conf 中配置的 html目錄下的index.html 文件。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2aced2b56e164e6fb0df110b9ff00311><p class=pgc-img-caption>Nginx默認首頁</p></div><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d83cdfe47a24c6bb0336d36e2c854d8><p class=pgc-img-caption>Nginx默認配置和默認首頁文件</p></div><p>本篇為了更方便直觀地介紹Nginx的功能，搞了個靜態頁面“偷寶網”，內容如下。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1e1eaf253c194de1af431064e4eb1207><p class=pgc-img-caption>訪問本地-偷寶網</p></div><p>然後我們把這個偷寶網放到nginx中，配置nginx.conf，讓其作為首頁。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9db03430a0ed4d06ab1fdf3b9a9ccbc8><p class=pgc-img-caption></p></div><p>然後檢查配置是否正確，並重新加載配置文件：</p><p>[root@VM_0_10_centos sbin]# /usr/local/nginx/sbin/nginx -t</p><p>[root@VM_0_10_centos sbin]# /usr/local/nginx/sbin/nginx -s reload</p><p>然後重新訪問：</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e09d778fd553435d8dbcaa43868dfb24><p class=pgc-img-caption></p></div><p>可以看到我們的靜態頁面已經部署在了nginx中。我們說的“<strong>Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。</strong>”，所以該句中的【<strong>Nginx是一款輕量級的Web 服務器</strong>】也就不難理解了。</p><pre>即Nginx用做Web服務器時的簡單配置如下：server { listen 80; server_name localhost; location / { root resource; index templates/index.html; }}</pre><p><strong>Nginx用做反向代理</strong></p><p>什麼是反向代理？什麼是正向代理？二者有何區別？找資料時經常可以看到說：</p><p>正向代理的代理對象是客戶端，反向代理的代理對象是服務端。</p><p>但光憑這一句話肯定是理解不了的，不理解的事情，我們就很容易忘記。在學習新知識時，我們對一些新接觸的概念得有自己的理解，爭取能用自己的話把自己的理解說出來，多思考多總結才有助於我們理解，只有理解了才便於我們的記憶。在工作中接到一項任務時也是，你得有自己的理解，按照自己的理解是要怎麼做，能不能做，需要什麼支援，有什麼風險，大概需要多少時間，你都得做到心裡有數，都要及時溝通及時糾正，這樣你才能讓人放心把事情交給你做，你慢慢地才能成長。說絕大部分工作問題，不來自於技能本身，而來自於溝通，還是很有道理的。關於如何學習與認知，這裡強烈推薦咱們毛主席的《實踐論》和《矛盾論》，偉人隨手的兩篇文章就如此驚豔不已，讓人拜服。好像又寫偏了，回到正文，下面我們舉例說明什麼是正向代理和反向代理，然後再看Nginx是如何實現反向代理的。</p><p>正向代理</p><p>舉個例子，A同學想去找馬雲爸爸借錢，可想而知，最後被保安打出來了。然後A同學經過打聽知道他的老師王老師是馬雲的同學，於是A同學找到王老師，託王老師幫忙去馬雲那借500萬過來，當然最後事成了。不過馬雲並不知道這錢是A同學借的，馬雲是借給王老師的，最後由王老師轉交給A同學。這裡的王老師在這個過程中扮演了一個非常關鍵的角色，就是代理，也可以說是正向代理，王老師代替A同學辦這件事，這個過程中，馬雲（服務端）不知道真正借錢的人（客戶端）是誰，這點非常關鍵。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4df7ff8bf7b24b86b74ab1d8da7c976f><p class=pgc-img-caption></p></div><p>再舉個例子，如今的網絡環境下，如果我們有需要去訪問國外的某些網站，此時你會發現位於國外的某網站我們通過瀏覽器是沒有辦法訪問的，此時大家可以通過連接一個VPN後進行訪問，VPN的方式主要是找到一個可以訪問國外網站的代理服務器，我們將請求發送給代理服務器，代理服務器去訪問國外的網站，然後將訪問到的數據傳回給我們。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/05da3a4982e54330bb858810575d44e6><p class=pgc-img-caption></p></div><p>上述這樣的代理模式稱為正向代理.</p><p>正向代理總結：客戶端非常明確要訪問的服務器地址；服務器只清楚請求來自哪個代理服務器，而不清楚來自哪個具體的客戶端；正向代理模式隱藏了真實客戶端信息，所以說正向代理的代理對象是客戶端。</p><p>反向代理</p><p>舉個栗子，我們很多人都用過淘寶，要知道每天同時連接到淘寶網站的訪問人數已經爆表，單個服務器遠遠不能滿足人民日益增長的購買慾望了，此時就出現了一個大家耳熟能詳的名詞：分佈式部署；也就是通過部署多臺服務器來解決訪問人數限制的問題；淘寶網站中大部分功能也是直接使用nginx進行反向代理實現的。如下圖：</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5e298468ad914d3bbedce5171cd93c24><p class=pgc-img-caption></p></div><p>上圖表示的是全國各地的用戶在淘寶客戶端發出請求，經過了Nginx 反向代理服務器，nginx服務器接收到之後，按照一定的規則分發給了後端的業務處理服務器進行處理。此時請求的來源也就是客戶端是明確的，但是請求具體是由哪臺服務器處理的並不明確。Nginx扮演的就是一個反向代理角色。</p><p>反向代理隱藏了真實的服務端，再如我們訪問 www.baidu.com 的時候，背後可能有成千上萬臺服務器為我們服務，但具體是哪一臺，你不知道，也不需要知道，你只需要知道反向代理服務器是誰就好了，www.baidu.com 就是我們的反向代理服務器，反向代理服務器會幫我們把請求轉發到提供真實計算的服務器那裡去。Nginx 就是性能非常好的反向代理服務器。</p><p>反向代理總結：代理服務器根據客戶端的請求，從其關聯的一組或多組後端服務器上獲取資源，然後再將這些資源返回給客戶端；客戶端只會得知反向代理的IP地址，而不知道真正提供服務的服務器地址。反向代理隱藏了服務器的信息，所以說反向代理的代理對象是服務端。</p><p>所以正向代理和反向代理一起使用就會像下圖這樣：</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/845d09d7d12c4572aed60b3c3a6dfd94><p class=pgc-img-caption></p></div><p>所以還是得出：</p><p>正向代理的代理對象是客戶端，即正向代理隱藏了客戶端的信息，代替客戶端去向服務器請求資源；</p><p>反向代理的代理對象是服務端，即反向代理隱藏了服務端的信息，代替服務端向客戶端返回資源。</p><p>然後我們看看Nginx是怎麼實現的反向代理。</p><p>既然要實現反向代理，那首先要有需要代理的服務端，所以我們先建一個基本的springboot項目，打成war包，發佈到該服務器的8081端口。（目標服務器可以跟nginx在同一臺機器，也可以是不同機器）</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d6663fc812a40b380584ae1dd3a1599><p class=pgc-img-caption></p></div><p>然後我們重新配置 nginx.conf 文件，只要簡單的配置 proxy_pass 就能夠實現反向代理，配置後重新加載nginx。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f16ab613f1e74d2b8f78196596b760b1><p class=pgc-img-caption></p></div><p>瀏覽器再次訪問nginx時，nginx就會將請求轉發至47.112.148.36:8081端口處理。但是對客戶端來說是不知道具體是由哪一臺服務器處理的，客戶端只知道nginx的ip，即nginx作為反向代理隱藏了服務端的信息。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cc7f1a5624f64ec1b2c657014fdbb4da><p class=pgc-img-caption></p></div><p>現在很多公司都是區分內外網的，從安全性考慮，我們要求外網暴露的端口越少越好。我們把nginx暴露給外網，只開放80和443端口，外網請求統一走nginx，nginx調用tomcat全部都走內網ip，這樣即使被黑客破解，他能拿到的也是一些靜態資源，服務器是安全的。</p><p>我們說的“Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。”，所以該句中的【Nginx用做反向代理】也就不難理解了。</p><p>即Nginx用做反向代理時的簡單配置如下：</p><pre>server { listen 80; server_name localhost; location / { proxy_pass http://47.112.148.36:8081; }}</pre><p><strong>Nginx用做負載均衡</strong></p><p>負載均衡，我們就得明白兩個概念，什麼是負載量？什麼是均衡？</p><p>客戶端向服務器發送的、nginx接收到的請求數量，就是我們說的負載量。</p><p>將請求數量按照一定的規則進行分發到不同的服務器處理的規則，就是一種均衡規則。</p><p>所以負載均衡就是：將服務器接收到的請求按照規則分發的過程。</p><p>負載均衡在實際項目操作過程中，有硬件負載均衡和軟件負載均衡兩種</p><p>硬件負載均衡也稱為硬負載，特點：造價昂貴成本較高，數據的穩定性安全性好。</p><p>更多的公司考慮到成本原因，會選擇使用軟件負載均衡，軟件負載均衡是利用現有的技術結合主機硬件實現的一種消息隊列分發機制。</p><p>nginx支持的負載均衡調度算法方式如下：</p><p>weight輪詢（默認）：接收到的請求按照順序逐一分配到不同的後端服務器，即使在使用過程中，某一臺後端服務器宕機，nginx會自動將該服務器剔除出隊列，請求受理情況不會受到任何影響。 這種方式下，可以給不同的後端服務器設置一個權重值（weight），用於調整不同的服務器上請求的分配率；權重數據越大，被分配到請求的機率越大；該權重值，主要是針對實際工作環境中不同的後端服務器硬件配置進行調整的。</p><p>ip_hash：每個請求按照發起客戶端的ip的hash結果進行匹配，這樣的算法下一個固定ip地址的客戶端總會訪問到同一個後端服務器，這也在一定程度上解決了集群部署環境下session共享的問題。</p><p>fair：智能調整調度算法，動態的根據後端服務器的請求處理到響應的時間進行均衡分配，響應時間短處理效率高的服務器分配到請求的概率高，響應時間長處理效率低的服務器分配到的請求少；結合了前兩者的優點的一種調度算法。但是需要注意的是nginx默認不支持fair算法，如果要使用這種調度算法，請安裝upstream_fair模塊</p><p>url_hash：按照訪問的url的hash結果分配請求，每個請求的url會指向後端固定的某個服務器，可以在nginx作為靜態服務器的情況下提高緩存效率。同樣要注意nginx默認不支持這種調度算法，要使用的話需要安裝nginx的hash軟件包。</p><p>然後我們看看Nginx是怎麼實現的負載均衡。</p><p>既然要實現負載均衡，那首先要有兩個以上的服務端，所以我們複用之前的tomcat，發佈到8082端口。（即需要修改tomcat的server.xml文件中的三個端口，另外為了測試效果，在頁面標識一下端口。）</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/85c900b62f554873bdd26882d37a6803><p class=pgc-img-caption></p></div><p>然後我們重新配置 nginx.conf 文件，只要簡單的配置 upstream模塊和修改 proxy_pass，就能夠實現反向代理，配置後重新加載nginx。（server後面可以配置相應屬性，如server 47.112.148.36:8081 down | weight=2 | backup | max_fails | fail_timeout 等 ;）</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/419023875aa643288faa67ff6766ed89><p class=pgc-img-caption></p></div><p>瀏覽器再次訪問nginx時，nginx就會根據負載均衡策略將請求轉發給 47.112.148.36:8082 的tomcat處理。但是對客戶端來說仍然是不知道具體是由哪一臺服務器處理的，客戶端只知道nginx的ip，即nginx作為反向代理隱藏了服務端的信息。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ecf9fafc8c8b4b16ba8e9e07ff7fb83b><p class=pgc-img-caption></p></div><p>再次訪問，nginx就會根據負載均衡策略將請求轉發給 47.112.148.36:8082 的tomcat處理。但是對客戶端來說仍然是不知道具體是由哪一臺服務器處理的，客戶端只知道nginx的ip，即nginx作為反向代理隱藏了服務端的信息。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/084af67cd1ab4915be62c194a37ef44b><p class=pgc-img-caption></p></div><p>總結一點，負載均衡不論是各種軟件或硬件上的解決方案，主要還是將大量的併發請求按照一定的規律分發給不同的服務器處理，從而減少某臺服務器的瞬時壓力，提高網站的抗併發能力。我們可以看到nginx在負載均衡方面是相當靈活的，通過配置一個nginx.conf文件就解決了大部分問題。服務器上只負責把nginx搭好，跑起來即可。而且它本身輕量級，不需要佔用服務器太多資源就可以達到較好的效果，毛子寫的這個nginx確實膩害。</p><p>我們說的“Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。”，所以該句中的【Nginx用做負載均衡】也就不難理解了。</p><p>即Nginx用做負載均衡時的簡單配置如下：</p><pre>upstream loadBalanceTest {  server 47.112.148.36:8081;  server 47.112.148.36:8082; }server { listen 80; server_name localhost; location / { proxy_pass http://loadBalanceTest;  }} #Nginx進行負載均衡時的failover（失效轉移）機制實現：Nginx可以通過設置max_fails（最大嘗試失敗次數）和fail_timeout（失效時間，在到達最大嘗試失敗次數後，在fail_timeout的時間範圍內節點被置為失效）對節點失敗的嘗試次數和失效時間進行設置upstream backend_servers { server localhost:7001 max_fails=3 fail_timeout=30s; # 下面兩行 "backup" 只有在上面 "7001" 服務器失敗後才會被訪問(此時兩臺服務器會採用同樣的權重進行負載均衡) server localhost:7002 max_fails=3 fail_timeout=30s backup; server localhost:7003 max_fails=3 fail_timeout=30s backup; # 如果為上面兩行 "backup" 設定懸殊的 "weight" 參數，可以控制 failover 的順序(比如設置只有 "7002" 宕機後才會訪問到 "7003") #server localhost:7002 max_fails=3 fail_timeout=30s backup weight=2000000000; #server localhost:7003 max_fails=3 fail_timeout=30s backup weight=1;} </pre><p><strong>Nginx用做動靜分離</strong></p><p>在用nginx做反向代理並訪問首頁時，是由tomcat處理並返回首頁，可以對比發現tomcat返回首頁的效率比nginx做web服務器時的效率慢得多，tomcat最大的優點是它能夠通過servlet技術來動態生成資源，實現服務端與客戶端的交互，但它對靜態資源的處理效率確實比nginx、apache等靜態web服務器差得多。所以，為了優化性能，提高訪問效率，可以讓 Tomcat 處理動態資源，讓 Nginx 處理靜態資源，就是我們所說的動靜分離。</p><p>然後我們看看Nginx是怎麼實現的動靜分離。</p><p>既然要實現動靜分離，那首先要有動態請求和靜態請求，所以在我們項目的index.html頁面，添加一個ajax請求，讓ajax訪問我們後臺的資源，相當於模擬一個動態請求。為了直觀感受tomcat中請求的變化情況，我們可以在項目中添加一個過濾器來查看所有進入tomcat的請求。相關代碼如下：</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bc32737d7a39427e8cfa8ee3a7b370ca><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9f0b460e442044a4a7ce2910d6a30c9c><p class=pgc-img-caption></p></div><p>未配置動靜分離前訪問nginx，可以看到所有的請求都是nginx交由tomcat來處理。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c56594cad1964a19bff2cf21113d8ec9><p class=pgc-img-caption></p></div><p>然後我們重新配置 nginx.conf 文件，只要簡單的配置 http 模塊，就能夠實現動靜分離，配置後重新加載nginx。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ecff7b1147394bccb5da22c0a670cb87><p class=pgc-img-caption></p></div><p>再次訪問，nginx就會根據配置來自己處理靜態請求，並根據負載均衡策略將動態請求轉發給後端的tomcat處理。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/478eb9f282624e1aaa8fff5c1cee73f8><p class=pgc-img-caption></p></div><p>我們說的“<strong>Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。</strong>”，所以該句中的【<strong>Nginx用做動靜分離</strong>】也就不難理解了。</p><p>即Nginx用做動靜分離時的簡單配置如下：</p><pre>location ~ .*\.(js|css|ico|png|jpg|jpeg|svg|gif|eot|ttf|woff)$ { root resource;}#注：nginx又做代理又處理靜態資源壓力也挺大的，所以一般由一臺nginx來專門做代理，另一臺nginx專門處理靜態資源。location ~ .*\.(js|css|ico|png|jpg|jpeg|svg|gif|eot|ttf|woff)$ { proxy_pass 47.112.148.36:80;}</pre><p><strong>Nginx用做Http緩存</strong></p><p>什麼是Http緩存？關於Http緩存可參考這裡徹底弄懂HTTP緩存機制及原理。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d42fa952e6da4bd5a1b4f3b9f71bc311><p class=pgc-img-caption>HTTP緩存機制</p></div><p>Nginx除了用做動靜分離的方式提高訪問效率外，也可以通過設置Http緩存（服務器緩存）的方式提高訪問效率。Http緩存主要針如css，js，圖片等更新頻率不大的靜態文件。我們知道未配置動靜分離和Http緩存前訪問nginx，nginx會把所有請求直接轉發到後端的tomcat來處理，配置了Http緩存後，理論上在緩存時間內訪問同一個靜態資源，Nginx可以直接把資源從緩存中取出並返回，不用再去請求後臺。然後我們看看Nginx是怎麼實現的Http緩存。</p><p>還是通過重新配置 nginx.conf 文件，只要簡單的配置 http 模塊，就能夠實現Http緩存，配置後重新加載nginx。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0e9046ce747c4135bef6818a263d5d1e><p class=pgc-img-caption></p></div><pre>以上的配置的含義：proxy_cache_path：緩存生成的目錄路徑levels：表示創建兩級目錄結構，緩存目錄的第一級目錄是1個字符，第二級目錄是2個字符；如果將所有文件放在一級目錄下的話，文件量很大，會導致文件訪問慢。keys_zone：設置存儲所有緩存key和相關信息的共享內存區，可在location中引用，1M大約能存儲8000個key。max_size：緩存區硬盤的 最大值。超出閒置數據將被清除。inactive：未被訪問文件在緩存中保留時間，本配置中如果60分鐘未被訪問則不論狀態是否為expired，緩存控制程序會刪掉文件。inactive默認是10分鐘。需要注意的是，inactive和expired配置項的含義是不同的，expired只是緩存過期，但不會被刪除，inactive是刪除指定時間內未被訪問的緩存文件。proxy_cache：在location中指定緩存區，對應keys_zone中設定的值。proxy_cache_valid：對不同的狀態碼設置緩存有效期。proxy_cache_valid不是唯一設置緩存時間的，還可以通過如下方式（優先級從上到下）。1)以秒為單位的“X-Accel-Expires”響應頭來設置響應緩存時間。2)如果沒有“X-Accel-Expires”，則可以根據“Cache-Control”、“Expires”來設置響應緩存時間。3)否則，使用proxy_cache_valid設置緩存時間。add_header：$upstream_cache_status是緩存響應狀態，我們把它添加到響應的頭部來觀察。其值如HIT：緩存命中，直接返回緩存中內容，不回源到後端；MISS：緩存未命中，回源到後端獲取最新的內容等等。* use_temp_path：如果為on，則內容首先被寫入臨時文件（proxy_temp_path ），然後重命名到proxy_cache_path指定的目錄；如果設置為off，則內容直接被寫入到proxy_cache_path指定的目錄，如果需要cache建議off，則該特性是1.7.10提供的。</pre><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4088ba547b5c493d99971838f010d548><p class=pgc-img-caption>Nginx緩存命中</p></div><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/193c02014faa457d909cdf08c8e49e34><p class=pgc-img-caption></p></div><p>可以看到Nginx的Http緩存確實生效了。</p><p>我們說的“<strong>Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。</strong>”，所以該句中的【<strong>Nginx用做HTTP緩存</strong>】也就不難理解了。</p><p>即Nginx用做HTTP緩存時的簡單配置如下：</p><pre>proxy_cache_path /usr/local/nginx/tmpcache levels=1:2 keys_zone=mycache:10m max_size=200m inactive=60m;server { listen 80; server_name localhost; location / { proxy_pass http://loadBalanceTest; proxy_cache mycache; proxy_cache_valid 200 304 30m; proxy_cache_valid any 10m; #add_header my_cache " cache test: $upstream_cache_status"; }}</pre><p>那麼，動靜分離和HTTP緩存哪個更能提高Web的訪問效率呢？可以自己操作試試。或者看看高併發壓力下nginx動靜分離、nginx代理緩存兩種模式的性能比較。</p><p>Nginx其它功能簡介</p><p>我們說“Nginx是一款輕量級的Web 服務器，也可以用做反向代理、負載均衡、動靜分離和 HTTP緩存。”，除了上面幾個最常見的功能之外，看看Nginx還能怎麼玩。（基於反向代理和負載均衡，能玩出很多花樣來的）</p><p>1. gzip壓縮作用</p><p>gzip壓縮作用：將響應報⽂發送⾄客戶端之前可以啟⽤壓縮功能，這能夠有效地節約帶寬，並提⾼響應⾄客戶端的速度,壓縮會消耗nginx的cpu性能。</p><p>常用配置：</p><p>gzip on #開啟gzip壓縮</p><p>gzip_min_length 1k; #最小壓縮大小，大於1k才壓縮</p><p>gzip_http_version 1.1 #/壓縮協議版本</p><p>gzip_comp_level 3 #壓縮級別，1-10，數字越大壓縮的越好，時間也越長</p><p>gzip_types #壓縮類型，根據/usr/local/nginx/conf/mime.types中定義，可以自己補;</p><p>gzip_disable "MSIE [1-6]\." #不壓縮，IE6對Gzip不怎麼友好，不給它Gzip了</p><p>使用實例：</p><pre>server {	listen 80;	server_name localhost;	location / {		gzip on;		gzip_http_version 1.1;		gzip_comp_level 3;		gzip_types text/plain application/json application/css application/xml application/x-javascript text/javascript image/jpeg image/gif image/png;	}}</pre><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e44d08860890461ea2db2905d06a5fcf><p class=pgc-img-caption></p></div><p><strong>2. Nginx 防盜鏈</strong></p><p>2.1 什麼是防盜鏈</p><p>比如http://www.dbspread.com/download/av123.rmvb 這個視頻下載地址被其他網站引用，比如在www.test.com的index.html引用xxx/av123.rmvb就叫盜鏈，我們要禁止這種引用就叫做防盜鏈</p><p>2.2 怎麼實現防盜鏈</p><p>在nginx的nginx.conf的server裡面配置如下代碼</p><pre>server { listen 80; server_name www.dbspread.com *.dbspread.com; location ~* \.(rmvb|jpg|png|swf|flv)$ { #rmvb|jpg|png|swf|flv表示對rmvb|jpg|png|swf|flv後綴的文件實行防盜鏈 valid_referers none blocked www.dbspread.com; #表示對www.dbspread.com此域名開通白名單，比如在www.test.com的index.html引用download/av123.rmvb,無效 root html/b; if ($invalid_referer) { #如果請求不是從www.dbspread.com白名單發出來的請求，直接重定向到403.html這個頁面或者返回403  #rewrite ^/ http://www.dbspread.com/403.html; return 403; } }}</pre><p><strong>3. Nginx 阻止dos攻擊、禁止代理訪問</strong></p><p>如何設置能限制某個IP某一時間段的訪問次數是一個讓人頭疼的問題，特別面對惡意的ddos攻擊的時候。其中CC攻擊（Challenge Collapsar）是DDOS（分佈式拒絕服務）的一種，也是一種常見的網站攻擊方法，攻擊者通過代理服務器或者肉雞向向受害主機不停地發大量數據包，造成對方服務器資源耗盡，一直到宕機崩潰。</p><p>cc攻擊一般就是使用有限的ip數對服務器頻繁發送數據來達到攻擊的目的，nginx可以通過HttpLimitReqModul和HttpLimitZoneModule配置來限制ip在同一時間段的訪問次數來防cc攻擊。</p><p>具體實現參考：nginx配置 阻止dos攻擊、禁止代理訪問</p><p>Nginx實現高可用</p><p>Nginx作為負載均衡器，所有請求都到了Nginx（對外服務的唯一入口，唯一公網IP），可見Nginx處於非常重點的位置，如果Nginx服務器宕機後端web服務將無法提供服務，或者當併發量真的非常大時，達到十萬級別時，一臺Nginx還是有極限的。所以必須要有應對方案才行。目前，Nginx實現高可用主要有以下兩種解決方案：</p><p>方案1：對Nginx進行主從備份保證服務高可用</p><p>主從備份，即建立一個備份機。目前Nginx進行主從備份的主流方案是通過Keepalived+Nginx實現雙機熱備，雙機熱備是指兩臺機器都在運行，但並不是兩臺機器都同時在提供服務。大概原理就是主服務器和備份機上都運行高可用（High Availability）監控程序，通過傳送諸如“I am alive”這樣的信息來監控對方的運行狀況（心跳檢測機制）。當備份機不能在一定的時間內收到這樣的信息時，它就接管主服務器的服務IP並繼續提供負載均衡服務；當備份管理器又從主管理器收到“I am alive”這樣的信息時，它就釋放服務IP地址，這樣的主服務器就開始再次提供負載均衡服務。Keepalived具體實現可參考這裡。</p><p>方案2：通過集群來分擔併發壓力</p><p>如果有多臺Nginx想實現負載均衡的話，可建立Nginx分佈式集群，方法如下：</p><p>1、每臺nginx都有公網地址，在域名處設置同個域名多個指向，最簡單實現輪洵。但故障切負會慢一點。</p><p>2、一臺公網nginx通過upstream功能，輪洵、ip、url多方式分發到內網多臺nginx。但公網的nginx如果down機的話，內網全段。</p><p>3、一對公網nginx加三個公網ip，通過keepalive實現高可用，再upstream到內網(就是我們剛剛上一節講的主從備份)。</p><p>一般來說，上面1、2、3種方法基本可以解決，建議用2或3；</p><p>如果併發量真的巨大的話，一般就要藉助硬件F5等設備做負載均衡，跟DNS、CDN等服務商合作做域名解析轉發、緩存配置，這也是目前大多數大廠的架構配置。</p><p><strong>Nginx原理簡介</strong></p><p>Nginx最初的設計是成為一個Http服務器，一個能夠解決C10K問題的服務器，即要能夠處理1w以上的連接。Nginx通過基於事件的處理機制解決C10K問題。下面我們看一下Nginx的架構。</p><div class=pgc-img><img alt="分佈式之 Nginx" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c94040f7db1d4fa495dc4ed87a0cfe70><p class=pgc-img-caption>Nginx架構</p></div><p>Nginx 啟動時，會生成兩種類型的 進程，一個 主進程（master），一個或多個工作進程（worker）。</p><p>主進程（master）充當整個進程組與用戶的交互接口，同時對進程進行監護。它不需要處理網絡事件，不負責業務的執行，只會通過管理worker進程來實現重啟服務、平滑升級、更換日誌文件、配置文件實時生效等功能。</p><p>在阻塞式的、一個連接/一個進程的模式中，每個連接需要大量的額外資源和開銷，並且上下文切換（從一個進程到另一個進程）非常頻繁。而 Nginx 服務器使用 master/worker 多進程模式，在類 unix 系統上，Nginx 可以配置多個 worker，每個worker進程上可以支持數以萬計的連接。這些worker進程從不會在網絡上停止，每個新連接都會創建一個文件描述符，並消耗工作進程中少量的額外內存，每一個連接的額外消耗都很少。可以說基於異步及非阻塞的事件驅動模型是 Nginx 得以獲得 高併發 、 高性能的關鍵因素 。</p><p>————————————————</p><p>版權聲明：本文為CSDN博主「抓娃小兵」的原創文章，遵循CC 4.0 by-sa版權協議，轉載請附上原文出處鏈接及本聲明。</p><p>原文鏈接：https://blog.csdn.net/HelloWorld_In_Java/article/details/96472794</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Nginx</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6be34d0.html alt="基於centos 7搭建Nginx網站服務器（包含虛擬web主機的配置）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9daf2ac49b19411bbcc19a263221d594 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6be34d0.html title="基於centos 7搭建Nginx網站服務器（包含虛擬web主機的配置）">基於centos 7搭建Nginx網站服務器（包含虛擬web主機的配置）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/528143dd.html alt=搞定Nginx高併發原理：多進程單線程和多路IO複用模型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/610f1711076040f6b29d18fee72b537c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/528143dd.html title=搞定Nginx高併發原理：多進程單線程和多路IO複用模型>搞定Nginx高併發原理：多進程單線程和多路IO複用模型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7636f65b.html alt=Nginx的Gzip功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ac34da666acc41b3af5c633421cd679b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7636f65b.html title=Nginx的Gzip功能>Nginx的Gzip功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/58581e74.html alt=15、Nginx-網頁壓縮傳輸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1524578491053344d5463c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/58581e74.html title=15、Nginx-網頁壓縮傳輸>15、Nginx-網頁壓縮傳輸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5699f35f.html alt=Nginx開啟Gzip壓縮與expire緩存提高頁面加載速度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5699f35f.html title=Nginx開啟Gzip壓縮與expire緩存提高頁面加載速度>Nginx開啟Gzip壓縮與expire緩存提高頁面加載速度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9476e8c8.html alt=Nginx開啟gzip壓縮演示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0bd17b5215234feeb7fdd0ddec855151 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9476e8c8.html title=Nginx開啟gzip壓縮演示>Nginx開啟gzip壓縮演示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/398a9b5e.html alt=精品推薦！Nginx的日誌文件、緩存、自動列目錄、壓縮等相關配置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3c72000101f59eee9921 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/398a9b5e.html title=精品推薦！Nginx的日誌文件、緩存、自動列目錄、壓縮等相關配置>精品推薦！Nginx的日誌文件、緩存、自動列目錄、壓縮等相關配置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ec86da1.html alt="Kubernetes 之 Nginx 動靜態 PV 持久存儲 下篇" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e3c3401f319c433f96f72c092a33c83d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ec86da1.html title="Kubernetes 之 Nginx 動靜態 PV 持久存儲 下篇">Kubernetes 之 Nginx 動靜態 PV 持久存儲 下篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/56b04966.html alt="Nginx 正向代理 & 反向代理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2cc5caaea19c471395136f1d20628d68 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/56b04966.html title="Nginx 正向代理 & 反向代理">Nginx 正向代理 & 反向代理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4e23d94.html alt=Nginx簡介及配置文件詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153570866559467f5003722 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4e23d94.html title=Nginx簡介及配置文件詳解>Nginx簡介及配置文件詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>