<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>併發編程從操作系統底層工作整體認識開始 | 极客快訊</title><meta property="og:title" content="併發編程從操作系統底層工作整體認識開始 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/957e9b9c6bac4abe878859bc4597e641"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99f63938.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99f63938.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/99f63938.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99f63938.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99f63938.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/99f63938.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/99f63938.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99f63938.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="併發編程從操作系統底層工作整體認識開始"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/99f63938.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>併發編程從操作系統底層工作整體認識開始</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/957e9b9c6bac4abe878859bc4597e641><p class=pgc-img-caption>作者公眾號：一角錢技術（org_yijiaoqian）</p></div><h1 class=pgc-h-arrow-right><span style="color:#773098;--tt-darkmode-color: #9940C3">前言</span></h1><p>在多線程、多處理器、分佈式環境的編程時代，併發是一個不可迴避的問題。既然併發問題擺在面前一個到無法迴避的坎，倒不如擁抱它，把它搞清楚，花一定的時間從操作系統底層原理到Java的基礎編程再到分佈式環境等幾個方面深入探索併發問題。先就從原理開始吧。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">計算機系統層次結構</span></strong></h1><h1 class=pgc-h-arrow-right><span style="color:#773098;--tt-darkmode-color: #9940C3">早期計算機系統的層次</span></h1><p>最早的計算機用機器語言編程，機器語言稱為第一代程序設計語言</p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a501f7420efc43bba601958d963c39cd><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">彙編語言編程</span></strong></h1><p>彙編語言編程</p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f41230f6668b47c8acb0b0ed09c02d72><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">現代（傳統）計算機系統的層次</span></strong></h1><p>現代計算機用高級語言編程</p><ul><li>第三代程序設計語言（3GL）為過程式 語言，編碼時需要描述實現過程，即“ 如何做”。</li><li>第四代程序設計語言（4GL） 為非過程 化語言，編碼時只需說明“做什麼”， 不需要描述具體的算法實現細節。</li></ul><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/871214c39a704e3abb1b31d0016ac4aa><p class=pgc-img-caption></p></div><p>語言處理系統包括：各種語言處理程序（如編譯、彙編、 鏈接）、運行時系統（如庫函數，調試、優化等功能）</p><p>操作系統包括人機交互界面、 提供服務功能的內核例程</p><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">可以看出：語言的發展是一 個不斷“抽象”的過程，因而，相應的計算機系統也不斷有新的層次出現。</span></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">計算機系統抽象層的轉換</span></strong></h1><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6a7ba9e9f6874be48b28e83d8b83c5ed><p class=pgc-img-caption></p></div><p>功能轉換：上層是下層的抽象，下層是上層的實現 底層為上層提供支撐環境！</p><h1 class=pgc-h-arrow-right><strong>計算機系統的不同用戶</strong></h1><ul><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">最終用戶</span></strong>工作在由應用程序提供的最上面的抽象層</li><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">系統管理員</span></strong>工作在由操作系統提供的抽象層</li><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">應用程序員</span></strong>工作在由語言處理系統（主要有編譯器和彙編器）的抽象層</li><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">語言處理系統</span></strong>建立在操作系統之上</li><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">系統程序員</span></strong>（實現系統軟件）工作在ISA層次，必須對ISA非常瞭解</li></ul><p>編譯器和彙編器的目標程序由機器級代碼組成</p><p>操作系統通過指令直接對硬件進行編程控制ISA處於軟件和硬件的交界面（接口）</p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3ba6f6b0d22c490facab29997445d798><p class=pgc-img-caption></p></div><p><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">ISA是對硬件的抽象所有軟件功能都建立在ISA之上</span></strong></p><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">指令集體系結構（ISA）</span></strong></h1><p>ISA指 Instruction Set Architecture，即指令集體系結構，有時簡稱為指令系統</p><ul><li>ISA是一種規約（Specification），它規定了如何使用硬件可執行的指令的集合，包括<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">指令格式、操作種類</span></strong>以及每種操作對應的 操作數的相應規定；指令可以接受的<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">操作數的類型</span></strong>；操作數所能存放的寄存器組的結構，包括每個<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">寄存器的名稱、編號、 長度和用途</span></strong>；操作數所能存放的<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">存儲空間的大小和編址方式；</span></strong>操作數在存儲空間存放時按照<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">大端還是小端方式存放；</span></strong>指令獲取操作數的方式，即<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">尋址方式</span></strong>；指令執行過程的控制方式，包括<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">程序計數器（PC）、條件碼定義</span></strong>等。</li><li>ISA在通用計算機系統中是必不可少的一個抽象層，沒有它，軟件無法使用計算機硬件！沒有它，一臺計算機不能稱為“通用計算機”</li></ul><h1 class=pgc-h-arrow-right><strong>ISA和計算機組成（微結構）之間的關係</strong></h1><p>ISA是計算機組成的抽象，不同ISA規定的指令集不同</p><ul><li>如，IA-32、MIPS、ARM等 計算機組成必須能夠實現ISA規定的功能</li><li>如提供GPR、標誌、運算電路等 同一種ISA可以有不同的計算機組成</li><li>如乘法指令可用ALU或乘法器實現</li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">現代計算機的原型</span></strong></h1><p>現代計算機模型是基於-<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">馮諾依曼計算機模型</span></strong></p><p>1946年，普林斯頓高等研究院（the Institute for Advance Study at Princeton，IAS ）開始設計“存儲程序”計算機，被稱為IAS計算機.</p><ul><li>馮·諾依曼結構最重要的思想是“<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">存儲程序(Stored-program)</span></strong>”</li><li>工作方式：任何要計算機完成的工作都要先被編寫成程序，然後將程序和原始數據送入主存並啟動執行。一旦程序被啟動，計算機應能在不需操作人員干預下，自動完成逐條取出指令和執行指令的任務。馮·諾依曼結構計算機也稱為馮·諾依曼機器（Von Neumann Machine）。幾乎現代所有的通用計算機大都採用馮·諾依曼結構，因此，<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">IAS計算機</span></strong>是現代計算機的原型機。</li></ul><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">計算機在運行時，先從內存中取出第一條指令，通過控制器的譯碼，按指令的要求，從存儲器中取出數據進行指定的運算和邏輯操作等加工，然後再按地址把結果送到內存中去。接下來，再取出第二條指令，在控制器的指揮下完成規定操作。依此進行下去。直至遇到停止指令。</span></p></blockquote><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">程序</span><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">於</span><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">數據一樣存貯，按程序編排的順序，一步一步地取出指令，自動地完成指令規定的操作是計算機最基本的工作模型。這一原理最初是由美籍匈牙利數學家</span><strong><span style="color:#773098;--tt-darkmode-color: #9940C3"><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">馮.諾依曼</span></span></strong><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">於1945年提出來的，故稱為馮.諾依曼計算機模型。</span></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">馮·諾依曼結構是怎樣的？</span></strong></h1><ul><li>有主存，用來存放程序和數據</li><li>一個自動逐條取 出指令的部件</li><li>具體執行指令 （即運算）的部件</li><li>程序由指令構成</li><li>指令描述如何對數據進 行處理</li><li>將程序和原始數據輸入計算機的部件</li><li>將運算結果輸出計算機的部件</li></ul><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/338ed6ff0b994cfb84214160834281e8><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">馮·諾依曼結構的主要思想</span></strong></h1><ul><li>計算機應由<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">計算器(運算器)</span></strong>、<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">控制器</span></strong>、<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">存儲器</span></strong>、<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">輸入設備</span></strong>和<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">輸出設備</span></strong> 五個基本部件組成。</li><li>各基本部件的功能是：<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">控制器(Control)</span></strong>：是整個計算機的中樞神經，其功能是對程序規定的控制信息進行解釋，根據其要求進行控制，調度程序、數據、地址，協調計算機各部分工作及內存與外設的訪問等。<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">運算器(Datapath)</span></strong>：運算器的功能是對數據進行各種算術運算和邏輯運算，即對數據進行加工處理。<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">存儲器(Memory)</span></strong>：存儲器的功能是存儲程序、數據和各種信號、命令等信息，並在需要時提供這些信息。<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">輸入(Input system)</span></strong>：輸入設備是計算機的重要組成部分，輸入設備與輸出設備合併為外部設備，簡稱外設，輸入設備的作用是將程序、原始數據、文字、字符、控制命令或現場採集的數據等信息輸入到計算機。常見的輸入設備有鍵盤、鼠標器、光電輸入機、磁帶機、磁盤機、光盤機等。<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">輸出(Output system)</span></strong>：輸出設備與輸入設備同樣是計算機的重要組成部分，它把外算機的中間結果或最後結果、機內的各種數據符號及文字或各種控制信號等信息輸出出來。微機常用的輸出設備有顯示終端CRT、打印機、激光印字機、繪圖儀及磁帶、光盤機等。</li><li>內部以二進制表示指令和數據。每條指令由<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">操作碼</span></strong>和<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">地址碼</span></strong> 兩部分組成。操作碼指出操作類型，地址碼指出操作數的地址。由一串指令組成程序。</li><li>採用“<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">存儲程序</span></strong>”工作方式。</li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">現代計算機結構模型</span></strong></h1><p>基於馮·諾依曼計算機理論的抽象簡化模型，它的具體應用就是現代計算機當中的硬件結構設計：</p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/decd07d296b44a3aa093d58b8e0a2594><p class=pgc-img-caption></p></div><p>在上圖硬件結構當中，配件很多，但最核心的只有兩部分：CPU、內存。所以我們重點學習的也是這兩部分。</p><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">CPU：中央處理器；PC：程序計數器； MAR：存儲器地址寄存器 ALU：算術邏輯部件； IR：指令寄存器；MDR：存儲器數據寄存器 GPRs：通用寄存器組（由若干通用寄存器組成，早期就是累加器）</span></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">CPU指令結構</span></strong></h1><p>CPU內部結構</p><ul><li>控制單元</li><li>運算單元</li><li>數據單元</li></ul><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a05ddeb2a75b4a2cbb4af803d987d769><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>控制單元</strong></h1><p>控制單元是整個CPU的指揮控制中心，由指令寄存器IR（Instruction Register）、指令譯碼器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等組成，對協調整個電腦有序工作極為重要。它根據用戶預先編好的程序，依次從存儲器中取出各條指令，放在指令寄存器IR中，通過指令譯碼（分析）確定應該進行什麼操作，然後通過操作控制器OC，按確定的時序，向相應的部件發出微操作控制信號。操作控制器OC中主要包括：節拍脈衝發生器、控制矩陣、時鐘脈衝發生器、復位電路和啟停電路等控制邏輯。</p><h1 class=pgc-h-arrow-right><strong>運算單元</strong></h1><p>運算單元是運算器的核心。可以執行算術運算（包括加減乘數等基本運算及其附加運算）和邏輯運算（包括移位、邏輯測試或兩個值比較）。相對控制單元而言，運算器接受控制單元的命令而進行動作，即運算單元所進行的全部操作都是由控制單元發出的控制信號來指揮的，所以它是執行部件。</p><h1 class=pgc-h-arrow-right><strong>存儲單元</strong></h1><p>存儲單元包括 CPU 片內緩存Cache和寄存器組，是 CPU 中暫時存放數據的地方，裡面保存著那些等待處理的數據，或已經處理過的數據，CPU 訪問寄存器所用的時間要比訪問內存的時間短。 寄存器是CPU內部的元件，寄存器擁有非常高的讀寫速度，所以在寄存器之間的數據傳送非常快。採用寄存器，可以減少 CPU 訪問內存的次數，從而提高了 CPU 的工作速度。寄存器組可分為專用寄存器和通用寄存器。專用寄存器的作用是固定的，分別寄存相應的數據；而通用寄存器用途廣泛並可由程序員規定其用途。</p><p>下表列出了CPU關鍵技術的發展歷程以及代表系列，每一個關鍵技術的誕生都是環環相扣的，處理器這些技術發展歷程都圍繞著如何不讓“CPU閒下來”這一個核心目標展開。</p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9b6f5713c9a4975865d7f3460d1e654><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">CPU緩存結構</span></strong></h1><p>現代CPU為了提升執行效率，減少CPU與內存的交互(交互影響CPU效率)，一般在CPU上集成了多級緩存架構，常見的為<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">三級緩存</span></strong>結構</p><ul><li>L1 Cache，分為數據緩存和指令緩存，邏輯核獨佔</li><li>L2 Cache，物理核獨佔，邏輯核共享</li><li>L3 Cache，所有物理核共享</li></ul><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7f4d6f5146b94894a3f2ba601416a9e4><p class=pgc-img-caption></p></div><ul><li>存儲器存儲空間大小：內存>L3>L2>L1>寄存器；</li><li>存儲器速度快慢排序：寄存器>L1>L2>L3>內存；</li></ul><p>注意：緩存是由最小的存儲區塊-緩存行(cacheline)組成，緩存行大小通常為64byte。</p><p>緩存行是什麼意思呢？ 比如你的L1緩存大小是512kb,而cacheline = 64byte,那麼就是L1裡有512 * 1024/64個cacheline</p><h1 class=pgc-h-arrow-right><strong>CPU讀取存儲器數據過程</strong></h1><ol start=1><li>CPU要取寄存器X的值，只需要一步：直接讀取。</li><li>CPU要取L1 cache的某個值，需要1-3步（或者更多）：把cache行鎖住，把某個數據拿來，解鎖，如果沒鎖住就慢了。</li><li>CPU要取L2 cache的某個值，先要到L1 cache裡取，L1當中不存在，在L2裡，L2開始加鎖，加鎖以後，把L2裡的數據複製到L1，再執行讀L1的過程，上面的3步，再解鎖。</li><li>CPU取L3 cache的也是一樣，只不過先由L3複製到L2，從L2複製到L1，從L1到CPU。</li><li>CPU取內存則最複雜：通知內存控制器佔用總線帶寬，通知內存加鎖，發起內存讀請求，等待迴應，迴應數據保存到L3（如果沒有就到L2），再從L3/2到L1，再從L1到CPU，之後解除總線鎖定。</li></ol><h1 class=pgc-h-arrow-right><strong>CPU為何要有高速緩存</strong></h1><p>CPU在摩爾定律的指導下以每18個月翻一番的速度在發展，然而內存和硬盤的發展速度遠遠不及CPU。這就造成了高性能能的內存和硬盤價格及其昂貴。然而CPU的高度運算需要高速的數據。為了解決這個問題，CPU廠商在CPU中內置了少量的高速緩存以解決I\O速度和CPU運算速度之間的不匹配問題。</p><p>在CPU訪問存儲設備時，無論是存取數據抑或存取指令，都趨於聚集在一片連續的區域中，這就被稱為<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">局部性原理</span></strong>。</p><ul><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">時間局部性（Temporal Locality）</span></strong>：如果一個信息項正在被訪問，那麼在近期它很可能還會被再次訪問。</li></ul><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">比如循環、遞歸、方法的反覆調用等。</span></p></blockquote><ul><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">空間局部性（Spatial Locality）</span></strong>：如果一個存儲器的位置被引用，那麼將來他附近的位置也會被引用。</li></ul><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">比如順序執行的代碼、連續創建的兩個對象、數組等。</span></p></blockquote><p><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">空間局部性案例</span></strong>：</p><p><br></p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9af66ff4c9334920987091d8d58782d1><p class=pgc-img-caption></p></div><pre><code>public class TwoDimensionalArraySum {    private static final int RUNS = 100;    private static final int DIMENSION_1 = 1024 * 1024;    private static final int DIMENSION_2 = 6;    private static long[][] longs;    public static void main(String[] args) throws Exception {        /*         * 初始化數組         */        longs = new long[DIMENSION_1][];        for (int i = 0; i &lt; DIMENSION_1; i++) {            longs[i] = new long[DIMENSION_2];            for (int j = 0; j &lt; DIMENSION_2; j++) {                longs[i][j] = 1L;            }        }        System.out.println("Array初始化完畢....");        long sum = 0L;        long start = System.currentTimeMillis();        for (int r = 0; r &lt; RUNS; r++) {            for (int i = 0; i &lt; DIMENSION_1; i++) {//DIMENSION_1=1024*1024                for (int j=0;j&lt;DIMENSION_2;j++){//6                    sum+=longs[i][j];                }            }        }        System.out.println("spend time1:"+(System.currentTimeMillis()-start));        System.out.println("sum1:"+sum);        sum = 0L;        start = System.currentTimeMillis();        for (int r = 0; r &lt; RUNS; r++) {            for (int j=0;j&lt;DIMENSION_2;j++) {//6                for (int i = 0; i &lt; DIMENSION_1; i++){//1024*1024                    sum+=longs[i][j];                }            }        }        System.out.println("spend time2:"+(System.currentTimeMillis()-start));        System.out.println("sum2:"+sum);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>帶有高速緩存的CPU執行計算的流程</strong></h1><ol start=1><li>程序以及數據被加載到主內存</li><li>指令和數據被加載到CPU的高速緩存</li><li>CPU執行指令，把結果寫到高速緩存</li><li>高速緩存中的數據寫回主內存</li></ol><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">CPU運行安全等級</span></strong></h1><p>CPU有4個運行級別，分別為：</p><ul><li>ring0</li><li>ring1</li><li>ring2</li><li>ring3</li></ul><p>Linux與Windows只用到了2個級別:ring0、ring3，操作系統內部內部程序指令通常運行在ring0級別，操作系統以外的第三方程序運行在ring3級別，第三方程序如果要調用操作系統內部函數功能，由於運行安全級別不夠,必須切換CPU運行狀態，從ring3切換到ring0,然後執行系統函數，說到這裡相信大家明白為什麼JVM創建線程，線程阻塞喚醒是重型操作了，因為CPU要切換運行狀態。 下面我大概梳理一下JVM創建線程CPU的工作過程</p><ul><li>step1：CPU從ring3切換ring0創建線程</li><li>step2：創建完畢,CPU從ring0切換回ring3</li><li>step3：線程執行JVM程序</li><li>step4：線程執行完畢，銷燬還得切會ring0</li></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">操作系統內存管理</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">執行空間保護</span></strong></h1><p>操作系統有<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">用戶空間</span></strong>與<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">內核空間</span></strong>兩個概念，目的也是為了做到程序運行安全隔離與穩定，以32位操作系統4G大小的內存空間為例</p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c6fca18712394e60a594881f1c2f6657><p class=pgc-img-caption></p></div><p>Linux為內核代碼和數據結構預留了幾個頁框，這些頁永遠不會被轉出到磁盤上。從 0x00000000 到 0xC0000000（PAGE_OFFSET） 的線性地址可由用戶代碼 和 內核代碼進行引用（<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">即用戶空間</span></strong>）。從0xC0000000（PAGE_OFFSET）到 0xFFFFFFFFF的線性地址只能由內核代碼進行訪問（<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">即內核空間</span></strong>）。內核代碼及其數據結構都必須位於這 1 GB的地址空間中，但是對於此地址空間而言，更大的消費者是物理地址的虛擬映射。</p><p>這意味著在 4 GB 的內存空間中，只有 3 GB 可以用於用戶應用程序。進程與線程只能運行在用戶方式（usermode）或內核方式（kernelmode）下。用戶程序運行在用戶方式下，而系統調用運行在內核方式下。在這兩種方式下所用的堆棧不一樣：用戶方式下用的是一般的堆棧(用戶空間的堆棧)，而內核方式下用的是固定大小的堆棧（內核空間的對戰，一般為一個內存頁的大小），即每個進程與線程其實有兩個堆棧，分別運行與用戶態與內核態。</p><p>由空間劃分我們再引申一下，CPU調度的基本單位線程，也劃分為：</p><ol start=1><li>內核線程模型(<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">KLT</span></strong>)</li><li>用戶線程模型(<strong><span style="color:#773098;--tt-darkmode-color: #9940C3">ULT</span></strong>)</li></ol><h1 class=pgc-h-arrow-right><strong>內核線程模型</strong></h1><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eb33220f56c54a259f745d82a3f0b1b1><p class=pgc-img-caption></p></div><p><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">內核線程(KLT)</span></strong>：系統內核管理線程(KLT),內核保存線程的狀態和上下文信息，線程阻塞不會引起進程阻塞。在多處理器系統上，多線程在多處理器上並行運行。線程的創建、調度和管理由內核完成，效率比ULT要慢，比進程操作快。</p><h1 class=pgc-h-arrow-right><strong>用戶線程模型</strong></h1><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ae76a3da49b49e58bf545f7d7259c3b><p class=pgc-img-caption></p></div><p><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">用戶線程(ULT)</span></strong>：用戶程序實現,不依賴操作系統核心,應用提供創建、同步、調度和管理線程的函數來控制用戶線程。不需要用戶態/內核態切換，速度快。內核對ULT無感知，線程阻塞則進程（包括它的所有線程）阻塞。</p><blockquote class=pgc-blockquote-abstract><p><strong><span style="color:#773098;--tt-darkmode-color: #9940C3"><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">到這裡，大家不妨思考一下，jvm是採用的哪一種線程模型？</span></span></strong></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">進程與線程</span></strong></h1><h1 class=pgc-h-arrow-right><strong>什麼是進程？</strong></h1><p>現代操作系統在運行一個程序時，會為其創建一個進程；例如，啟動一個Java程序，操作系統就會創建一個Java進程。進程是OS(操作系統)資源分配的最小單位。</p><h1 class=pgc-h-arrow-right><strong>什麼是線程？</strong></h1><p>線程是OS(操作系統)調度CPU的最小單元，也叫輕量級進程（Light Weight Process），在一個進程裡可以創建多個線程，這些線程都擁有各自的計數器、堆棧和局部變量等屬性，並且能夠訪問共享的內存變量。CPU在這些線程上高速切換，讓使用者感覺到這些線程在同時執行，即併發的概念，相似的概念還有並行！</p><p>線程上下文切換過程：</p><div class=pgc-img><img alt=併發編程從操作系統底層工作整體認識開始 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a974adbfe8a3477ab1685b267d7c71ae><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">虛擬機指令集架構</span></strong></h1><p>虛擬機指令集架構主要分兩種：</p><ol start=1><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">棧指令集架構</span></strong></li><li><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">寄存器指令集架構</span></strong></li></ol><p>關於指令集架構的wiki詳細說明：http://zh.wikipedia.org/wiki/指令集架構</p><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">棧指令集架構</span></strong></h1><ol start=1><li>設計和實現更簡單,適用於資源受限的系統;</li><li>避開了寄存器的分配難題:使用零地址指令方式分配;</li><li>指令流中的指令大部分是零地址指令,其執行過程依賴於操作棧,指令集更小,編譯器容易實現;</li><li>不需要硬件支持,可移植性更好,更好實現跨平臺。</li></ol><h1 class=pgc-h-arrow-right><strong><span style="color:#773098;--tt-darkmode-color: #9940C3">寄存器指令集架構</span></strong></h1><ol start=1><li>典型的應用是x86的二進制指令集:比如傳統的PC以及Android的Davlik虛擬機。</li><li>指令集架構則完全依賴硬件,可移植性差。</li><li>性能優秀和執行更高效。</li><li>花費更少的指令去完成一項操作。</li><li>在大部分情況下,基於寄存器架構的指令集往往都以一地址指令、二地址指令和三地址指令為主,而基於棧式架構的指令集卻是以零地址指令為主。</li></ol><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fbf9fd;--tt-darkmode-bgcolor: #161616">Java符合典型的棧指令集架構特徵，像Python、Go都屬於這種架構。</span></p></blockquote><blockquote class=pgc-blockquote-abstract><p>文章持續更新，可以公眾號搜一搜「 <span style="color:#4b1785;--tt-darkmode-color: #944FE0">一角錢技術</span> 」第一時間閱讀， 本文 GitHub <span style="color:#4b1785;--tt-darkmode-color: #944FE0">org_hejianhui/JavaStudy</span> 已經收錄，歡迎 Star。</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>發編程</a></li><li><a>系統</a></li><li><a>底層</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5c4e123.html alt=操作系統底層核心講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ed27d0a6d0847bca62c754877af69c6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5c4e123.html title=操作系統底層核心講解>操作系統底層核心講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html alt=電廠直流系統調試方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e8200036f19e04c25bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html title=電廠直流系統調試方案>電廠直流系統調試方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html alt=一文讀懂智能客服：發展歷程、系統搭建、市場推廣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RbYMTZ55OrJUgU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html title=一文讀懂智能客服：發展歷程、系統搭建、市場推廣>一文讀懂智能客服：發展歷程、系統搭建、市場推廣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html alt=生活垃圾焚燒發電及蒸汽系統優化改造項目公告 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RcblrbTDBokV23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html title=生活垃圾焚燒發電及蒸汽系統優化改造項目公告>生活垃圾焚燒發電及蒸汽系統優化改造項目公告</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html alt=電驅動橋系統或加快電氣化進程，多個案例共同說明問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539571595921bc5b27eff6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html title=電驅動橋系統或加快電氣化進程，多個案例共同說明問題>電驅動橋系統或加快電氣化進程，多個案例共同說明問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html alt=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/470f515e8fe44c6184b07227fdb51333 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html title=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）>《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html alt=基於混沌系統的偽隨機數發生器設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html title=基於混沌系統的偽隨機數發生器設計>基於混沌系統的偽隨機數發生器設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html alt=win10系統打印機打印不了顯示已暫停的解決方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10d0de369d4746c7a0c220ff59bd2470 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html title=win10系統打印機打印不了顯示已暫停的解決方法>win10系統打印機打印不了顯示已暫停的解決方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html alt=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html title=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案>虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4b6c065.html alt=全球定位系統（GPS），不只是導航 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S7sY2h8G8GOmul style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4b6c065.html title=全球定位系統（GPS），不只是導航>全球定位系統（GPS），不只是導航</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f75e014c.html alt=謹記！短線王者交易系統，學會極大概率提高買入與賣出的時機！掌握終身獲益無窮！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RL8KN4P57T39Db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f75e014c.html title=謹記！短線王者交易系統，學會極大概率提高買入與賣出的時機！掌握終身獲益無窮！>謹記！短線王者交易系統，學會極大概率提高買入與賣出的時機！掌握終身獲益無窮！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ad4f2c9.html alt="焦爐系統停電 —— 應急操作" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8ca2e135770644bfb97620aad1b362c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ad4f2c9.html title="焦爐系統停電 —— 應急操作">焦爐系統停電 —— 應急操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75270289.html alt=win10系統如何使用返回桌面快捷鍵 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/822a8f5c52e1461a94e116d0e24871f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75270289.html title=win10系統如何使用返回桌面快捷鍵>win10系統如何使用返回桌面快捷鍵</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a435b80f.html alt=從操作系統（Windows）的角度討論中斷和異常機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/95371ea9a81e4e32b3cf7591d4dbbc83 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a435b80f.html title=從操作系統（Windows）的角度討論中斷和異常機制>從操作系統（Windows）的角度討論中斷和異常機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/093fe492.html alt=企業標準-管路系統裝配工藝規範 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab245e924a004753b625eeb6495dd2ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/093fe492.html title=企業標準-管路系統裝配工藝規範>企業標準-管路系統裝配工藝規範</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>