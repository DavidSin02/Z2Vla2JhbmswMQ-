<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>微服務-如何解決鏈路追蹤問題 | 极客快訊</title><meta property="og:title" content="微服務-如何解決鏈路追蹤問題 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6ad951a771234a11bf19e1aefb90ac22"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a0cbd7f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a0cbd7f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a0cbd7f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a0cbd7f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a0cbd7f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a0cbd7f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a0cbd7f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a0cbd7f.html><meta property="article:published_time" content="2020-11-14T21:06:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:12+08:00"><meta name=Keywords content><meta name=description content="微服務-如何解決鏈路追蹤問題"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9a0cbd7f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>微服務-如何解決鏈路追蹤問題</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>一、鏈路追蹤</strong></h1><p style=text-align:start>微服務架構是將單個應用程序被劃分成各種小而連接的服務，每一個服務完成一個單一的業務功能，相互之間保持獨立和解耦，每個服務都可以獨立演進。相對於傳統的單體服務，微服務具有隔離性、技術異構性、可擴展性以及簡化部署等優點。</p><p style=text-align:start>​ 同樣的，微服務架構在帶來諸多益處的同時，也為系統增加了不少複雜性。它作為一種分佈式服務，通常部署於由不同的數據中心、不同的服務器組成的集群上。而且，同一個微服務系統可能是由不同的團隊、不同的語言開發而成。通常一個應用由多個微服務組成，微服務之間的數據交互需要通過遠過程調用的方式完成，所以在一個由眾多微服務構成的系統中，請求需要在各服務之間流轉，調用鏈路錯綜複雜，一旦出現問題，是很難進行問題定位和追查異常的。</p><p style=text-align:start>​ 鏈路追蹤系統就是為解決上述問題而產生的，它用來追蹤每一個請求的完整調用鏈路，記錄從請求開始到請求結束期間調用的任務名稱、耗時、標籤數據以及日誌信息，並通過可視化的界面進行分析和展示，來幫助技術人員準確地定位異常服務、發現性能瓶頸、梳理調用鏈路以及預估系統容量。</p><p style=text-align:start>​ 鏈路追蹤系統的理論模型幾乎都借鑑了 Google 的一篇論文”Dapper, a Large-Scale Distributed Systems Tracing Infrastructure”，典型產品有Uber jaeger、Twitter zipkin、淘寶鷹眼等。這些產品的實現方式雖然不盡相同，但核心步驟一般都有三個：<strong>數據採集、數據存儲和查詢展示</strong>。</p><p style=text-align:start>​ 鏈路追蹤系統第一步，也是最基本的工作就是數據採集。在這個過程中，鏈路追蹤系統需要侵入用戶代碼進行埋點，用於收集追蹤數據。但是由於不同的鏈路追蹤系統的API互不兼容，所以埋點代碼寫法各異，導致用戶在切換不同鏈路追蹤產品時需要做很大的改動。為了解決這類問題，於是誕生了OpenTracing規範，旨在統一鏈路追蹤系統的API。</p><h1 class=pgc-h-arrow-right><strong>二、OpenTracing規範</strong></h1><p style=text-align:start>​ OpenTracing 是一套分佈式追蹤協議，與平臺和語言無關，具有統一的接口規範，方便接入不同的分佈式追蹤系統。</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>​ OpenTracing語義規範詳見：https://github.com/opentracing/specification/blob/master/specification.md</p></blockquote><h1 class=pgc-h-arrow-right>2.1 數據模型（Data Model）</h1><p style=text-align:start>​ OpenTracing語義規範中定義的數據模型有 Trace、Sapn以及Reference。</p><h1 class=pgc-h-arrow-right><strong>2.1.1 Trace</strong></h1><p style=text-align:start>​ Trace表示一條完整的追蹤鏈路，例如：一個事務或者一個流程的執行過程。一個 Trace 是由一個或者多個 Span 組成的有向無環圖（DAG）。</p><p style=text-align:start>下圖表示一個由8個Span組成的Trace：</p><pre><code>        [Span A]  ←←←(the root span)            |     +------+------+     |             | [Span B]      [Span C] ←←←(Span C is a `ChildOf` Span A)     |             | [Span D]      +---+-------+               |           |           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]                                       ↑                                       ↑                                       ↑                         (Span G `FollowsFrom` Span F)</code></pre><p style=text-align:start>按照時間軸方式更為直觀地展現該Trace：</p><pre><code>––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time [Span A···················································]   [Span B··············································]      [Span D··········································]    [Span C········································]         [Span E·······]        [Span F··] [Span G··] [Span H··]</code></pre><h1 class=pgc-h-arrow-right><strong>2.1.2 Span</strong></h1><p style=text-align:start>​ Span表示一個獨立的工作單元，它是一條追蹤鏈路的基本組成要素。例如：一次RPC調用、一次函數調用或者一次Http請求。</p><p style=text-align:start>每個Span封裝瞭如下狀態：</p><ul><li>操作名稱用於表示該Span的任務名稱。 例如：一個 RPC方法名， 一個函數名，或者大型任務中的子任務名稱。</li><li>開始時間戳任務開始時間。</li><li>結束時間戳。任務結束時間。通過Span的結束時間戳和開始時間戳，就能夠計算出該Span的整體耗時。</li><li>一組Span標籤每一個Span標籤是一個鍵值對。鍵必須是字符串，值可以是字符串、布爾或數值類型。</li></ul><blockquote class=pgc-blockquote-abstract><p>常見標籤鍵可參考：https://github.com/opentracing/specification/blob/master/semantic_conventions.md</p></blockquote><p>一組Span日誌每一條Span日誌由一個鍵值對和一個相應的時間戳組成。鍵必須是字符串，值可以是任何類型。</p><blockquote class=pgc-blockquote-abstract><p>常見日誌鍵參考：https://github.com/opentracing/specification/blob/master/semantic_conventions.md</p></blockquote><h1 class=pgc-h-arrow-right><strong>2.1.3 Reference</strong></h1><p style=text-align:start>​ 一個Span可以與一個或者多個Span存在因果關係，這種關係稱為Reference。OpenTracing目前定義了兩種關係：ChildOf（父子）關係 和 FollowsFrom（跟隨）關係。</p><ul><li>ChildOf關係父Span的執行依賴子Span的執行結果，此時子Span對父Span的Reference關係是ChildOf。比如對於一次RPC調用，服務端的Span（子Span）與客戶端調用的Span（父Span）就是ChildOf關係。</li><li>FollowsFrom關係父Span的執行不依賴子Span的執行結果，此時子Span對父Span的Reference關係是FollowFrom。FollowFrom常用於表示異步調用，例如消息隊列中Consumer Span與Producer Span之間的關係。</li></ul><h1 class=pgc-h-arrow-right>2.2 應用接口（API）</h1><h1 class=pgc-h-arrow-right><strong>2.2.1 Tracer</strong></h1><p style=text-align:start>​ Tracer接口用於創建Span、跨進程注入數據和提取數據。通常具有以下功能：</p><ul><li>Start a new span<br>創建並啟動一個新的Span。</li><li>Inject<br>將SpanContext注入載體（Carrier）。</li><li>Extract<br>從載體（Carrier）中提取SpanContext。</li></ul><h1 class=pgc-h-arrow-right><strong>2.2.2 Span</strong></h1><ul><li>Retrieve a SpanContext<br>返回Span對應的SpanContext。</li><li>Overwrite the operation name<br>更新操作名稱。</li><li>Set a span tag<br>設置Span標籤數據。</li><li>Log structured data<br>記錄結構化數據。</li><li>Set a baggage item<br>baggage item是字符串型的鍵值對，它對應於某個 Span，隨Trace一起傳播。由於每個鍵值都會被拷貝到每一個本地及遠程的子Span，這可能導致巨大的網絡和CPU開銷。</li><li>Get a baggage item<br>獲取baggage item的值。</li><li>Finish<br>結束一個Span。</li></ul><h1 class=pgc-h-arrow-right><strong>2.2.3 Span Context</strong></h1><p style=text-align:start>​ 用於攜帶跨越服務邊界的數據，包括trace ID、Span ID以及需要傳播到下游Span的baggage數據。在OpenTracing中，強制要求SpanContext實例不可變，以避免在Span完成和引用時出現複雜的生命週期問題。</p><h1 class=pgc-h-arrow-right><strong>2.2.4 NoopTracer</strong></h1><p style=text-align:start>​ 所有對OpenTracing API的實現，必須提供某種形式的NoopTracer，用於標記控制OpenTracing或注入對測試無害的東西。</p><h1 class=pgc-h-arrow-right><strong>三、Jaeger</strong></h1><p style=text-align:start>​ Jaeger是Uber開源的分佈式追蹤系統，它的應用接口完全遵循OpenTracing規範。jaeger本身採用go語言編寫，具有跨平臺跨語言的特性，提供了各種語言的客戶端調用接口，例如c++、java、go、python、ruby、php、nodejs等。</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>項目地址：https://github.com/jaegertracing</p></blockquote><h1 class=pgc-h-arrow-right>3.1 Jaeger組件</h1><div class=pgc-img><img alt=微服務-如何解決鏈路追蹤問題 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ad951a771234a11bf19e1aefb90ac22><p class=pgc-img-caption></p></div><ul><li><strong>jaeger-client</strong>jaeger的客戶端代碼庫，它實現了OpenTracing協議。當我們的應用程序將其裝配後，負責收集數據，併發送到jaeger-agent。<strong>這是我們唯一需要編寫代碼的地方</strong>。</li><li><strong>jaeger-agent</strong>負責接收從jaeger-client發來的Trace/Span信息，並批量上傳到jaeger-collector。</li><li><strong>jaeger-collector</strong>負責接收從jaeger-agent發來的Trace/Span信息，並經過校驗、索引等處理，然後寫入到後端存儲。</li><li><strong>data store</strong>負責數據存儲。Jaeger的數據存儲是一個可插拔的組件，目前支持Cassandra、ElasticSearch和Kafka。</li><li><strong>jaeger-query & ui</strong>負責數據查詢，並通過前端界面展示查詢結果。</li></ul><div class=pgc-img><img alt=微服務-如何解決鏈路追蹤問題 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a883197f2ca4bf6b1725cf4bba67372><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>3.2 快速入門</h1><p style=text-align:start>​ Jaeger官方提供了all-in-one鏡像，方便快速進行測試：</p><pre><code># 拉取鏡像$docker pull jaegertracing/all-in-one:latest# 運行鏡像$docker run -d --name jaeger \  -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \  -p 5775:5775/udp \  -p 6831:6831/udp \  -p 6832:6832/udp \  -p 5778:5778 \  -p 14268:14268 \  -p 9411:9411 \  -p 16686:16686 \  jaegertracing/all-in-one:latest</code></pre><p style=text-align:start>​ 通過all-in-one鏡像啟動，我們發現Jaeger佔據了很多端口。以下是端口使用說明：</p><div class=pgc-img><img alt=微服務-如何解決鏈路追蹤問題 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b2963eef7c4d446f816e8f2c2be66a41><p class=pgc-img-caption></p></div><blockquote class=pgc-blockquote-abstract><p style=text-align:start>​ 啟動後，我們可以訪問 http://localhost:16686 ，在瀏覽器中查看和查詢收集的數據。</p></blockquote><p style=text-align:start>​ 由於通過all-in-one鏡像方式收集的數據都存儲在docker中，無法持久保存，所以只能用於開發或者測試環境，無法用於生產環境。生產環境中需要依據實際情況，分別部署各個組件。</p><h1 class=pgc-h-arrow-right><strong>四、Jaeger在業務代碼中的應用</strong></h1><p style=text-align:start>​ 系統中使用Jaeger非常簡單，只需要在原有程序中插入少量代碼。以下代碼模擬了一個查詢用戶賬戶餘額，執行扣款的業務場景：</p><h1 class=pgc-h-arrow-right>4.1 初始化jaeger函數</h1><p style=text-align:start>​ 主要是按照實際需要配置有關參數，例如服務名稱、採樣模式、採樣比例等等。</p><pre><code>func initJaeger() (tracer opentracing.Tracer, closer io.Closer, err error) {	// 構造配置信息	cfg := &amp;config.Configuration{		// 設置服務名稱		ServiceName: "ServiceAmount",		// 設置採樣參數		Sampler: &amp;config.SamplerConfig{			Type:  "const", // 全採樣模式			Param: 1,       // 開啟狀態		},	}		// 生成一條新tracer	tracer, closer, err = cfg.NewTracer()	if err == nil {		// 設置tracer為全局單例對象		opentracing.SetGlobalTracer(tracer)	}	return}</code></pre><h1 class=pgc-h-arrow-right>4.2 檢測用戶餘額函數</h1><p style=text-align:start>​ 用於檢測用戶餘額，模擬一個子任務Span。</p><pre><code>func CheckBalance(request string, ctx context.Context) {	// 創建子span	span, _ := opentracing.StartSpanFromContext(ctx, "CheckBalance")	// 模擬系統進行一系列的操作，耗時1/3秒	time.Sleep(time.Second / 3)	// 示例：將需要追蹤的信息放入tag	span.SetTag("request", request)	span.SetTag("reply", "CheckBalance reply")	// 結束當前span	span.Finish()	log.Println("CheckBalance is done")}</code></pre><h1 class=pgc-h-arrow-right>4.3 從用戶賬戶扣款函數</h1><p style=text-align:start>​ 從用戶賬戶扣款，模擬一個子任務span。</p><pre><code>func Reduction(request string, ctx context.Context) {	// 創建子span	span, _ := opentracing.StartSpanFromContext(ctx, "Reduction")	// 模擬系統進行一系列的操作，耗時1/2秒	time.Sleep(time.Second / 2)	// 示例：將需要追蹤的信息放入tag	span.SetTag("request", request)	span.SetTag("reply", "Reduction reply")	// 結束當前span	span.Finish()	log.Println("Reduction is done")}</code></pre><h1 class=pgc-h-arrow-right>4.4 主函數</h1><p style=text-align:start>​ 初始化jaeger環境，生成tracer，創建父span，以及調用查詢餘額和扣款兩個子任務span。</p><pre><code>package mainimport (	"context"	"fmt"	"github.com/opentracing/opentracing-go"	"github.com/uber/jaeger-client-go/config"	"io"	"log"	"time")func main() {	// 初始化jaeger，創建一條新tracer	tracer, closer, err := initJaeger()	if err != nil {		panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))	}	defer closer.Close()	// 創建一個新span，作為父span，開始計費過程	span := tracer.StartSpan("CalculateFee")		// 生成父span的context	ctx := opentracing.ContextWithSpan(context.Background(), span)	// 示例：設置一個span標籤信息	span.SetTag("db.instance", "customers")	// 示例：輸出一條span日誌信息	span.LogKV("event", "timed out")	// 將父span的context作為參數，調用檢測用戶餘額函數	CheckBalance("CheckBalance request", ctx)	// 將父span的context作為參數，調用扣款函數	Reduction("Reduction request", ctx)	// 結束父span	span.Finish()}</code></pre><h1 class=pgc-h-arrow-right><strong>五、Jaeger在gRPC微服務中的應用</strong></h1><p style=text-align:start>​ 我們依然模擬了一個查詢用戶賬戶餘額，執行扣款的業務場景，並把查詢用戶賬戶餘額和執行扣款功能改造為gRPC微服務：</p><h1 class=pgc-h-arrow-right>5.1 gRPC Server端代碼</h1><p style=text-align:start>main.go：</p><p style=text-align:start>​ 代碼使用了第三方依賴庫github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing，該依賴庫將OpenTracing封裝為通用的gRPC中間件，並通過gRPC攔截器無縫嵌入gRPC服務中。</p><pre><code>package mainimport (	"fmt"	"github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"	"github.com/opentracing/opentracing-go"	"github.com/uber/jaeger-client-go/config"	"google.golang.org/grpc"	"google.golang.org/grpc/reflection"	"grpc-jaeger-server/account"	"io"	"log"	"net")// 初始化jaegerfunc initJaeger() (tracer opentracing.Tracer, closer io.Closer, err error) {	// 構造配置信息	cfg := &amp;config.Configuration{		// 設置服務名稱		ServiceName: "ServiceAmount",		// 設置採樣參數		Sampler: &amp;config.SamplerConfig{			Type:  "const", // 全採樣模式			Param: 1,       // 開啟全採樣模式		},	}	// 生成一條新tracer	tracer, closer, err = cfg.NewTracer()	if err == nil {		// 設置tracer為全局單例對象		opentracing.SetGlobalTracer(tracer)	}	return}func main() {	// 初始化jaeger，創建一條新tracer	tracer, closer, err := initJaeger()	if err != nil {		panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))	}	defer closer.Close()	log.Println("succeed to init jaeger")	// 註冊gRPC account服務	server := grpc.NewServer(grpc.UnaryInterceptor(grpc_opentracing.UnaryServerInterceptor(grpc_opentracing.WithTracer(tracer))))	account.RegisterAccountServer(server, &amp;AccountServer{})	reflection.Register(server)	log.Println("succeed to register account service")	// 監聽gRPC account服務端口	listener, err := net.Listen("tcp", ":8080")	if err != nil {		log.Println(err)		return	}	log.Println("starting register account service")	// 開啟gRpc account服務	if err := server.Serve(listener); err != nil {		log.Println(err)		return	}}</code></pre><p style=text-align:start>計費微服務 accountsever.go：</p><pre><code>package mainimport (	"github.com/opentracing/opentracing-go"	"golang.org/x/net/context"	"grpc-jaeger-server/account"	"time")// 計費服務type AccountServer struct{}// 檢測用戶餘額微服務，模擬子span任務func (s *AccountServer) CheckBalance(ctx context.Context, request *account.CheckBalanceRequest) (response *account.CheckBalanceResponse, err error) {	response = &amp;account.CheckBalanceResponse{		Reply: "CheckBalance Reply", // 處理結果	}	// 創建子span	span, _ := opentracing.StartSpanFromContext(ctx, "CheckBalance")	// 模擬系統進行一系列的操作，耗時1/3秒	time.Sleep(time.Second / 3)	// 將需要追蹤的信息放入tag	span.SetTag("request", request)	span.SetTag("reply", response)	// 結束當前span	span.Finish()	return response, err}// 從用戶賬戶扣款微服務，模擬子span任務func (s *AccountServer) Reduction(ctx context.Context, request *account.ReductionRequest) (response *account.ReductionResponse, err error) {	response = &amp;account.ReductionResponse{		Reply: "Reduction Reply", // 處理結果	}	// 創建子span	span, _ := opentracing.StartSpanFromContext(ctx, "Reduction")	// 模擬系統進行一系列的操作，耗時1/3秒	time.Sleep(time.Second / 3)	// 將需要追蹤的信息放入tag	span.SetTag("request", request)	span.SetTag("reply", response)	// 結束當前span	span.Finish()	return response, err}</code></pre><h1 class=pgc-h-arrow-right>5.2 gRPC Client端代碼main.go：</h1><pre><code>package mainimport (	"context"	"fmt"	"github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"	"github.com/opentracing/opentracing-go"	"github.com/uber/jaeger-client-go/config"	"google.golang.org/grpc"	"grpc-jaeger-client/account"	"io"	"log")// 初始化jaegerfunc initJaeger() (tracer opentracing.Tracer, closer io.Closer, err error) {	// 構造配置信息	cfg := &amp;config.Configuration{		// 設置服務名稱		ServiceName: "ServiceAmount",		// 設置採樣參數		Sampler: &amp;config.SamplerConfig{			Type:  "const", // 全採樣模式			Param: 1,       // 開啟全採樣模式		},	}	// 生成一條新tracer	tracer, closer, err = cfg.NewTracer()	if err == nil {		// 設置tracer為全局單例對象		opentracing.SetGlobalTracer(tracer)	}	return}func main() {	// 初始化jaeger，創建一條新tracer	tracer, closer, err := initJaeger()	if err != nil {		panic(fmt.Sprintf("ERROR: cannot init Jaeger: %v\n", err))	}	defer closer.Close()	log.Println("succeed to init jaeger")	// 創建一個新span，作為父span	span := tracer.StartSpan("CalculateFee")	// 函數返回時關閉span	defer span.Finish()	// 生成span的context	ctx := opentracing.ContextWithSpan(context.Background(), span)	// 連接gRPC server	conn, err := grpc.Dial("localhost:8080",		grpc.WithInsecure(),		grpc.WithUnaryInterceptor(grpc_opentracing.UnaryClientInterceptor(grpc_opentracing.WithTracer(tracer),		)))	if err != nil {		log.Println(err)		return	}	// 創建gRPC計費服務客戶端	client := account.NewAccountClient(conn)	// 將父span的context作為參數，調用檢測用戶餘額的gRPC微服務	checkBalanceResponse, err := client.CheckBalance(ctx,		&amp;account.CheckBalanceRequest{			Account: "user account",		})	if err != nil {		log.Println(err)		return	}	log.Println(checkBalanceResponse)	// 將父span的context作為參數，調用扣款的gRPC微服務	reductionResponse, err := client.Reduction(ctx,		&amp;account.ReductionRequest{			Account: "user account",			Amount: 1,		})	if err != nil {		log.Println(err)		return	}	log.Println(reductionResponse)}</code></pre><blockquote class=pgc-blockquote-abstract><p style=text-align:start>注：<br>本文全部源代碼位於：https://github.com/wangshizebin/micro-service<br>本文時候用的開發工具為：goland</p><p style=text-align:start>原文鏈接：https://www.cnblogs.com/wanghao72214/p/13932810.html</p></blockquote><p>如果覺得本文對你有幫助，可以轉發關注支持一下</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>解決</a></li><li><a>鏈路</a></li><li><a>微服</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/204d163e.html alt="五毛錢解決 蘋果 AirPods容易掉的問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/61600003f2800f627a0d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/204d163e.html title="五毛錢解決 蘋果 AirPods容易掉的問題">五毛錢解決 蘋果 AirPods容易掉的問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60684aec.html alt=刀具斷屑不可靠的原因分析及解決方法，建議收藏！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f407c10bcc734093ba560997011073c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60684aec.html title=刀具斷屑不可靠的原因分析及解決方法，建議收藏！>刀具斷屑不可靠的原因分析及解決方法，建議收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3e505a4.html alt=轉化思想：解決數學問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/59e6f1ce51984cb8961d6c6343f300fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3e505a4.html title=轉化思想：解決數學問題>轉化思想：解決數學問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/874267c5.html alt=骨壞死原因及解決 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3c6b00043c4da524f4ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/874267c5.html title=骨壞死原因及解決>骨壞死原因及解決</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/de3e8d44.html alt=剖析軸承損壞症狀、原因及解決方案，收藏技術貼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/56820001ad8184adee69 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/de3e8d44.html title=剖析軸承損壞症狀、原因及解決方案，收藏技術貼>剖析軸承損壞症狀、原因及解決方案，收藏技術貼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ab3c579.html alt=HASH碰撞以及解決方案總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8ea629245a5342d9910ea7e9f749200c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ab3c579.html title=HASH碰撞以及解決方案總結>HASH碰撞以及解決方案總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42b64558.html alt=Hash算法解決衝突的方法總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15401292345529c66f06db8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42b64558.html title=Hash算法解決衝突的方法總結>Hash算法解決衝突的方法總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html alt="SQL 難點解決：記錄的引用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3a1b904121564aa389aba6a046772870 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html title="SQL 難點解決：記錄的引用">SQL 難點解決：記錄的引用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/831e8d80.html alt=和麵機出現故障時應如何解決 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d439c7f04957423fad42fb48879e4af5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/831e8d80.html title=和麵機出現故障時應如何解決>和麵機出現故障時應如何解決</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/99b61eda.html alt=溶解微塑料汙染的解決方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b5dec037b56246898cbcf5e964f487ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99b61eda.html title=溶解微塑料汙染的解決方案>溶解微塑料汙染的解決方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6334f375.html alt=怎麼在短時間內解決滾筒軸承位磨損問題？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d764cf47bae1433787eca00aac011446 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6334f375.html title=怎麼在短時間內解決滾筒軸承位磨損問題？>怎麼在短時間內解決滾筒軸承位磨損問題？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/541714b0.html alt=墊鼻基底解決臉上的哪些問題？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8bd84cfa42df4c9c8f16fd7b7b88edd4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/541714b0.html title=墊鼻基底解決臉上的哪些問題？>墊鼻基底解決臉上的哪些問題？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb9df85e.html alt=耐磨防腐塗層——速效解決浮選機磨損問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0fc86b0452ff473eb9fc9aa401b4c346 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb9df85e.html title=耐磨防腐塗層——速效解決浮選機磨損問題>耐磨防腐塗層——速效解決浮選機磨損問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b61ebb50.html alt=激光切割機廠家分析激光的解決方法和產生原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/43b8a5bc201d4e43967c8001dc5bf70d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b61ebb50.html title=激光切割機廠家分析激光的解決方法和產生原理>激光切割機廠家分析激光的解決方法和產生原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/972a2cdd.html alt="表格技巧—如何解決 Excel 表格篩選後圖片重疊的問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f838164d2b3c4c8bb16c23e2d0669987 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/972a2cdd.html title="表格技巧—如何解決 Excel 表格篩選後圖片重疊的問題">表格技巧—如何解決 Excel 表格篩選後圖片重疊的問題</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>