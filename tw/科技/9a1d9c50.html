<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何創建自己的Tracker | 极客快訊</title><meta property="og:title" content="如何創建自己的Tracker - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/aab1214f60164ba18b7fb459483e88ee"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><meta property="article:published_time" content="2020-11-14T20:59:24+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:24+08:00"><meta name=Keywords content><meta name=description content="如何創建自己的Tracker"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9a1d9c50.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何創建自己的Tracker</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aab1214f60164ba18b7fb459483e88ee><p class=pgc-img-caption></p></div><p></p><h2 class=pgc-h-arrow-right>0x00 前言</h2><p>某一天，我正在瀏覽abuse.ch。這個網站會收集用戶提交的惡意/可疑URL，我偶然發現了一些非常有趣的東西。我看到某推特用戶Gandylyan1每日上傳大量名為Mozi的惡意軟件樣本（可參閱此文)。此殭屍網絡是一IoT P2P殭屍網絡，似乎正在瘋狂地傳播著。當我撰寫本文時，Gandy依然在上傳樣本，目前有24,709個IP上傳到abuse.ch。</p><p>該惡意軟件非常有趣，並且不是很複雜，同時不是很難理解。它會使用已知exp及暴力破解方式在IoT設備中傳播，若它已連接到某IoT設備，則會在該設備上啟動http服務，之後將自身上傳到隨機端口，並將其託管在該IoT設備的IP地址上。接下來該設備開始掃描並攻擊網絡，當它成功接管另一臺設備時，新感染的設備將從先前感染的設備接收Mozi。於是我決定為此殭屍網絡構建一個Tracker。</p><p>可惜我的Linux相關知識僅限於我知道ls -la命令功能。但是為殭屍網絡構建一個Tracker的想法使我夜不能寐。經過短暫的搜索，我發現了Intezer創建的工具。此工具是一個小型的Python項目，可以讓研究人員通過模擬OS環境來偽造出受惡意軟件感染的客戶端。研究人員所要關注的就是惡意軟件通信協議。不需要蜜罐，不需要虛擬機，什麼也不需要。之後我在GitHub上搜索了所有開源的惡意軟件，發現了Quasar，一款開源RAT。研究該RAT是瞭解惡意軟件，逆向開源惡意軟件以及瞭解其網絡相關工作原理的好方法。我們的小實驗的絕佳候選人！</p><ul><li>必備知識：</li></ul><ol start=1><li>Wireshark相關的基礎知識</li><li>編程相關知識</li><li>Python</li><li>C＃</li></ol><ul><li>所需工具：</li></ul><ol start=1><li>VMWare</li><li>Visual Studio Community</li><li>Python 3.8</li><li>Sublime Text Editor 3</li><li>Dnspy</li><li>De4dot</li></ol><ul><li>目標：</li></ul><ol start=1><li>我們想知道Quasar客戶端是如何連接到服務器的</li><li>我們想知道Quasar是如何構造發送給服務器的消息的</li><li>我們想知道是否存在用於處理消息的加密/解密過程</li><li>我們想知道服務器如何處理客戶端消息的（因為我們有Quasar的源碼，所以這是可能的）</li></ol><p></p><h2 class=pgc-h-arrow-right>0x01 如何閱讀Quasar源碼</h2><p>我們將下載的Quasar源代碼加載到Visual Studio 2019 Community(下載地址)中：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3db05670d2c3422683f011a742e1e9b6><p class=pgc-img-caption></p></div><p>我們對客戶端代碼，以及如何與其他對象協作都很感興趣——Common包含各個公用程序，Server包含Server端代碼。據我所知，所有C＃程序都以Program.cs開始，所以我們將從此開始，讓我們打開Quasar.Client並找到Program.CS文件：</p><p>如果我們右擊QuasarClient，然後單擊”轉到實現”，我們將在此處看到一些有趣的東西：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7147d44a3d5e4011930c1be1d2c68bd6><p class=pgc-img-caption></p></div><p>首先解釋從Client類繼承的QuasarClient類。其工作是管理客戶端中發生的所有事件。它具有專門的函數來處理bot的註冊（OnClientState），並讀取事件（OnClientRead）以及處理失敗事件（OnClientFail）。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed51387e29f9487ea8d42abefda2c656><p class=pgc-img-caption></p></div><p>OnClientState函數嘗試發送數據包到服務器。若想了解如何創建該消息，我們可以查看ClientIdentification類的構造函數：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/31f509bb5a314665a180aa288ee62b7a><p class=pgc-img-caption></p></div><p>讓我們回到Program.cs ，並查看ConnectClient.Connect：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b18a88be699544f6a543f2b17fd06a3b><p class=pgc-img-caption></p></div><p>這使我們回到了Client類：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c90ad298db342238b500ee8936a765d><p class=pgc-img-caption></p></div><p>這應該是我們第一個目標的答案！若要啟動連接，客戶端首先會建立一個SSL流，然後可能使用ValidateServerCertificate回調函數和AuthnticateAsClient正在進行某種形式的驗證。讓我們暫時先不管這些，因為我們只是在探索代碼的工作方式。接下來會發生什麼？如果我們通過Client基類訪問OnClientState，這將導致我們進入事件處理程序本身，那麼若要找到觸發該事件的函數，我們必須轉到QuasarClient.cs並通過其查看該函數的實現。如我們之前所見，OnClientState函數觸發了client.Send函數：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de75ce25bd4c4da09d50e935210606d1><p class=pgc-img-caption></p></div><p>說實話，我不懂C＃，但是我在這裡通過我的直覺看到唯一有價值的東西是ProcessSendBuffers，所以讓我們查看下，看看是否能有所收穫：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/015ad86647594fc2960708f2f6523e3b><p class=pgc-img-caption></p></div><p>使用與之前相同的策略，讓我們查看下SafeSendMessage：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddca9ae977bd459c8493857d19f063e1><p class=pgc-img-caption></p></div><p>現在我們暫且不訪問OnClientWrite，因為我擔心它不會帶我們到我們想要的地方去。我們可以查看位於PayloadWriter類中的WriteMessage：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/13ef36146f894d6f93d64e23f27d2deb><p class=pgc-img-caption></p></div><p>該函數會將序列化消息（我稍後會解釋什麼是序列化）寫入SSL數據流！因此，讓我們通過一張流程圖來說明我們的發現：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9f1e5187a86b4f299797df3408af74c9><p class=pgc-img-caption></p></div><p>上圖是非常淺顯且不完整的，隨著我們進行動態分析，我們可以在該圖上進行擴充，因此讓我們在Visual Studio中編譯Quasar項目，並將編譯後文件移至虛擬機並開始研究它。</p><p></p><h2 class=pgc-h-arrow-right>0x02 分析Quasar樣本</h2><p>編譯Quasar項目並將其移至虛擬機後，即可啟動Quasar：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9dbb838ae8b242368c715508bc4a2c06><p class=pgc-img-caption></p></div><p>此時屏幕應該會彈出一消息框，該消息用於構建X509證書(非常重要)。該證書負責在客戶端和服務器之間創建有效的SSL數據流。Quasar會生成一個X509證書並將該證書綁定到所有生成的客戶端。可以在此處瞭解有關SSL的更多信息。</p><p>生成證書後，就可以構建樣本了，單擊Builder然後使用builder菜單進行相關配置，其中最重要的部分如下所示：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a20865afe4f947fab9b3b4c69d599850><p class=pgc-img-caption></p></div><p>這裡有2個IP：一個是本機回送地址，另一個是該虛擬機IP。我建議將客戶端綁定到當前虛擬機IP，因為這樣可以模擬從當前虛擬機與外部主機服務器的連接（主機也是VMWare本地網絡中的一員）。您可以使用任何您喜歡的端口，這裡我使用了27015端口。生成客戶端後，您應該可以在當前目錄看到它。我們將其在dnspy中打開(dnspy是.NET反編譯器)：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/82b01669f7b24da1906487aeec6911db><p class=pgc-img-caption></p></div><p>但是我們遇到了代碼混淆，不用擔心，我們可以使用de4dot，它是個.NET反混淆工具，運行它之後，我們可以得到一個去混淆的Quasar客戶端：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2b2f32be97254846bdf71073bbfaf20c><p class=pgc-img-caption></p></div><p>儘管我們的Quasar客戶端代碼是去混淆後的，但符號已經消失了，不用擔心，因為我們擁有完整的源代碼，所以接下來讓我們開始調試。我只想驗證我的流程圖是否正確，所以讓我們單擊開始調試，然後在入口點設置一個斷點（我強烈建議根據源代碼重命名這些函數和類名，但是由於調試了許多次，我對此已經非常熟悉了）。請確保Quasar服務端正在運行中。我們將在Class0.smethod_3()遇到第一個問題，這是第二個初始化方法：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eb108d2a39ae4fa0a1416788357f1149><p class=pgc-img-caption></p></div><p>它不會返回True，從而導致客戶端無法正確執行和退出。但是為什麼會這樣？讓我們看一下源碼：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57957f35ff01476986dc282de74ede00><p class=pgc-img-caption></p></div><p>上圖中標紅的if語句，會在初始化後通過返回true來安裝並將客戶端連接到服務器，但由於此時客戶端正在運行的current path不等於install path，所以它不會執行。要理解上述說明，需要回到Builder：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ffe776b90f3f43cca8f9570964c28a4a><p class=pgc-img-caption></p></div><p>因此，此代碼塊會檢查客戶端當前是否正在AppdataRomaing目錄下運行(於本文的情況下)，如果沒有，它將執行以下代碼：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8dbe3f7c279d46a9822aade4b2323e79><p class=pgc-img-caption></p></div><p>此代碼會處理兩個問題：其一是客戶端檢測到另一個Quasar實例正在運行，通過檢測互斥體；其二是客戶端已安裝到受害主機中，但實現了持久化，此時會終止進程並刪除該文件，然後將其移至我們指定的install文件夾後重新啟動。您可以查看Install方法自行研究，因為源碼已經給出。它使得研究人員可以真正瞭解如何開發惡意軟件。下面讓我們做兩件事：</p><ol start=1><li>更新我們的流程圖</li><li>將客戶端移動到指定的安裝目錄並啟動</li></ol><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8133e28dcec741718e3e039040b57d43><p class=pgc-img-caption></p></div><p>讓我們從預設的安裝目錄中調試客戶端，看看會發生什麼，請確保Quasar服務端正在運行。此外，我啟動了Wireshark來監視流量（下圖是我自己的設置，IP地址及端口在您的計算機上將會有所不同）：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e20058fdfd54844996ea834a96a1f84><p class=pgc-img-caption></p></div><p>我將從AppdataRoaming目錄重新啟動客戶端，然後直接跳到Client.Connect函數：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dab8fe0925544f8f8823a829e51334aa><p class=pgc-img-caption></p></div><p>這次我們恰好到達了想要的位置(專家提示：您可以右鍵單擊dnspy對象並更改其名稱) 。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/145bc6e0d4574eb681ecd7f852474fe8><p class=pgc-img-caption></p></div><p>這裡有三處重點，首先是RemoteCertificationValidationCallBack——它將驗證從服務器接收到的證書，數據流讀取函數和OnClientState函數。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/805ea1b0bb574e8d8f225a81715883e4><p class=pgc-img-caption></p></div><p>所以socket.Connect函數應該將客戶端成功連接到服務器並進行第一次TCP握手：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e142c540338243c5a7220a48c17fc07a><p class=pgc-img-caption></p></div><p>接下來，我想研究執行到第287行時發生了什麼：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d7173661a3974fe8a6521c620fd680fa><p class=pgc-img-caption></p></div><p>這是一個SSL握手，但是發生的是服務器將X509證書傳給了客戶端，並且客戶端認證了該證書，並且這是在RemoteCertificationValidationCallBack內部發生的。讓我們查看一下它的源碼：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d944ffc8b8d646eea0c805621918e90d><p class=pgc-img-caption></p></div><p>正如您在else語句中看到的那樣(在關閉調試模式的情況下編譯會進入此語句)，該函數會檢查客戶端證書和服務器證書是否匹配。但是，看看在調試模式下發生了什麼——它只會返回true，並且發生在客戶端……我們的客戶端可以執行同樣的操作以啟動與服務器的有效SSL通信。讓我們記住這一點並繼續。接下來發生的事情有些棘手，在Client類的第290行中，將調用OnClientState，但是因為從Client類中調用了OnClientState，所以事件註冊功能會生效，而事件處理功能將不會生效：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/faeede725ee94bf48eab5f88405e9b1c><p class=pgc-img-caption></p></div><p>我們必須手動找到QuasarClient類，然後從那裡進入到OnClientState 函數(我建議讀者多讀幾次源碼並充分理解其含義，這對於理解其工作原理有相當大的幫助)。但我們應該如何找到它？答案很簡單，讓我們回到Class0，即Program.cs</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f465068779c4048845f66ef86b943bb><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/09b7049d6c1740caa468d025a950a8d4><p class=pgc-img-caption></p></div><p>因此，Gclass27是QuasarClient，為其重命名以便之後找到它更方便，接下來我們將通過雙擊該類並嘗試手動查找OnClientState來訪問該類：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a2bd82348d6f4ed98345b0d73ba2c06a><p class=pgc-img-caption></p></div><p>讓我們在第79行設置一個斷點，並在之前的PayloadWriter WriteBytes函數內設置一個斷點，該函數位於Stream1的method02。在第79 行，創建Class18，然後將其傳遞給send函數中。Class18在Quasar源碼中為ClientIdentification：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7dcfd14b52a340d18fcf490c256f67ae><p class=pgc-img-caption></p></div><p>這是消息構造函數，如果我們繼續執行到 payload writer，可以看到該消息的內容：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3085ebfe826f442d825443d52994c452><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b91b9d7715ef4cb4bca6c78742c280dc><p class=pgc-img-caption></p></div><p>我們僅是截取了整個消息。但是我注意到一些奇怪的事情——ClientIdentification類中只有14個成員，為什麼這裡卻有28個成員？</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/532eabb0018844ceaedd169524a1ea1a><p class=pgc-img-caption></p></div><p>另外，在第38行中，會將消息複製到數據流中並進行序列化，然後發送消息的長度，以及由序列化函數返回的原始字節。我嘗試查看序列化後消息的內容。首先，讓我們調試該程序到第40行，右鍵單擊該變量，然後選擇show memory window，以查看該數組變量的內容：</p><p>除了一些文本內容，其它的部分沒有任何意義。</p><p></p><h2 class=pgc-h-arrow-right>0x03 消息序列化與Google Protocol Buffer</h2><p>為了節省讀者時間，我簡單解釋下什麼是序列化。序列化是一種壓縮消息大小並提高處理效率的方法。序列化有諸多類型——其中一種是將消息壓縮為json格式或XML格式，然後將其發送，接收方會按照預先約定好的協議對消息進行反序列化。可以在此處瞭解有關序列化的信息。</p><p>Quasar使用了由Google開發的Protobuf，Protobuf是一消息序列化程序。（希望您在看完上述視頻後明白其原理）</p><p>這就是我們之前看到的這些ProtoMember：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5bbf9e278d3d4ecd92e791cb2855aa71><p class=pgc-img-caption></p></div><p>該C＃類是基於ProtoContract定義的，使得編譯器在生成這14個成員時會同時生成google protobuf消息。這就是為什麼每個類成員都有一個原型成員。現在，protobuf協議會以不同的方式壓縮每種類型(int32，int64，字符串)，所以我們會在消息中看到很多奇怪的字節。到這裡基本上已經可以回答我們之前設定的目標1-3。</p><p>很明顯，下一步我們要做的是：</p><ol start=1><li>創建一個啟動SSL連接的python腳本</li><li>驗證客戶端和服務器之間的連接</li><li>生成一個protobuf消息，並且可以與生成客戶端發送的消息匹配。</li></ol><p>關於第3點，我們可以假設消息的重要部分是Tag，Signature和EncryptionKey成員，根據我進行的測試，它們必須保持不變並與生成的客戶端完全匹配。因為Signature和EncrpytionKey是包含X509證書信息的成員。</p><p></p><h2 class=pgc-h-arrow-right>0x04 如何使用Python生成Protobuf消息</h2><p>幸運的是，Google提供了一個使用Python生成protobuf消息的編程接口以及教程。</p><p>我精心設計了一條消息來啟動與服務器的SSL連接：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a5166575ecea4343ba12441e4b79eb27><p class=pgc-img-caption></p></div><p>首先，消息內容很簡單，它包含14個成員，這些成員與Quasar客戶端發送的消息完全匹配。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b47e8a1efa904178aab7c50498766768><p class=pgc-img-caption></p></div><p>該腳本會創建SSL socket，並通過始終在每個證書上返回1來來處理驗證問題。儘管這是作弊，但我們是Hackers。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/88d0d7d9c5b346c3b7efd89dfa024bc1><p class=pgc-img-caption></p></div><p>接下來讓我們生成一條消息並將其序列化。請記住，必須在其後附加4個little endian字節——代表消息的總長度。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fc088458ef3740c482d5ac737297a97f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/820ea2b5bf7e476ea35c7ae667329eda><p class=pgc-img-caption></p></div><p>因此，我創建了一個簡單的函數，它將返回該值並將其添加到序列化消息前綴中。現在我們可以生成消息，進行序列化並輸出內容，看看它是否與Quasar客戶端生成的內容匹配：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7c0506003fb54692b2cd6877ac817c0d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b67a8b5857442648ca727317f7266f1><p class=pgc-img-caption></p></div><p>如您所見，生成消息有問題。Python生成的消息與客戶端生成消息(除0x0A，0xCF，0x05之外)完全匹配(忽略前綴0xdf 0x02 0x00 0x00)。這些字節是什麼？我不知道，所以我在stack overflow上提出了相關問題。</p><p>經過些許研究，我確定該前綴只能是消息的長度。Python生成的消息其餘部分與客戶端生成的消息完全匹配。另外，如果我們編輯Quasar客戶端生成的消息，則隨著我們增加消息的長度，該前綴字段將會改變。讓我們再次調試生成的Quasar客戶端，並在發送消息之前於第36行中斷Payload Writer函數，於任意一個字段中添加任意數量的字符”A”來改變消息內容：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/76a99a6385f84288803054a973e4b5c3><p class=pgc-img-caption></p></div><p>如上所示，消息已更改，第二個字節從0xcf變為0xf5。0xF5與0xCF之間差38，這正是我添加的字符”A”的數量。若要準確計算出長度，我們必須瞭解對該字節序列進行編碼的工作原理，幸運的是，Google並未對此保密(參考)，另外這裡也給出了答案。</p><p>我不會詳細解釋整個過程的工作原理，但是理解它對於我們目標的實現是有益的。Google Protobuf是開源項目，故我們無須從頭開始重新實現。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/779ad30b6817451db83c685b265ce977><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9e4dbef17673476b8538975a5d9d752b><p class=pgc-img-caption></p></div><p>在這兩個代碼塊中，我將序列化一條消息並將其長度傳遞給我從protobuf項目中”借用”的函數。我對其進行了一些修改，使其始終位於最終結果的0x0A字節之前，最終結果表示字段編號和字段類型。由於該消息是我們生成的消息的前綴，因此其類型始終為2（length prefix）以及編號為1：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2fd7609c4dfa4654b896dee71f4f6c53><p class=pgc-img-caption></p></div><p>現在，我們使用python生成的消息與Quasar生成的消息完全匹配。</p><p>接下來轉到連接部分：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/557cbdf8e9dc480a9aea140bb8693241><p class=pgc-img-caption></p></div><p>以上代碼塊將連接到我們的服務器並與其進行握手。服務器將對其進行X509認證，然後我們的驗證功能將會被觸發：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04126d4f82e0468eb3fc29dc15316afa><p class=pgc-img-caption></p></div><p>它始終返回True。然後，我們將生成序列化的消息，並以消息的長度加序列化後消息的長度作為前綴：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/afad34e9aeee41c9b4c7219b93ac30af><p class=pgc-img-caption></p></div><p>首先在第97行，我將消息序列化。然後，我在消息中附加一個代表消息長度的前綴。最終，我計算了包括前綴在內的消息總長度，轉換為小端序格式，並將其附加在序列化消息中。發送該消息到服務器，我們可以在Wireshark中查看此消息：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba83d4208a4b43be9b3bdbeb2063b51e><p class=pgc-img-caption></p></div><p>如果檢查我們的Quasar服務端，可以看到：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57800ea883224eb6bb750b2b5242519c><p class=pgc-img-caption></p></div><p>我已經發送了一條自定義消息，沒有問題！現在，我開始學習Intezers工具的工作原理，以便將我的Python腳本完善成為完整的Quasar RAT Tracker。</p><p>腳本完整代碼可以在這裡找到。</p><p></p><h2 class=pgc-h-arrow-right>0x05 為Intezers Puppets創建Quasar插件</h2><p>由於Intezer並未在該工具上投入過多心血，所以這一部分會比較棘手，但我會盡力解釋該工具的工作原理，為您節省時間，因為我相信該工具對於跟蹤惡意軟件具有巨大價值。</p><p>Puppets是一組Python腳本，可以模擬出一個完整的OS環境，從而節省了研究人員構建蜜罐或虛擬機環境所需要的時間和資源。現在，我們不需要構建完整的OS與內核以及引導項，因為大多數惡意軟件都希望與特定的用戶模式應用程序和文件系統進行交互，而這些程序很容易模擬！Puppets附帶了許多實用腳本與處理程序，這些腳本和處理程序將模擬基本功能以處理惡意軟件——例如連接，註冊，發送，接收等等。研究人員唯一要做的工作就是為特定惡意軟件創建插件，其它工作都可以交由該工具來處理。我想引導讀者閱讀代碼，並共同創建一個圖表，以幫助開發人員瞭解該工具的工作原理。首次下載MoP以及從這裡下載我的自定義插件quasar.py，targets.yaml，utils.py。</p><p>接下來，請按照此處的安裝指南進行操作。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/312bdee6256c4a6e92dded0fe3daab99><p class=pgc-img-caption></p></div><p>打開orchestrator.py，刪除第一行#!/usr/bin/env python3.6，因為它會使該工具無法在Python 3.6以外的其他環境中運行。這是該工具的核心部分。來到第46行，您將看到一個command parser，在本例中，我們將使用第53行的選項–targets-config，該選項允許此工具連接到多個客戶端，因此請打開targets.yaml並刪除其中的相關hash。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bbcc77b3a44f44a8a341923d746e61a1><p class=pgc-img-caption></p></div><p>我已經將其設置為與我的Quasar實例一起運行，但是由於尚未設置插件，因此您可以使其保持原樣。該工具會通過指定目標IP，端口和插件來設置多個目標。</p><p>讓我們回到核心腳本：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7784b1e07924401ba85f3119271db1f><p class=pgc-img-caption></p></div><p>在第54行，對targets.yaml文件進行了解析，並提取其內容。然後調用函數connect_targets()：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/49ff03884f8443c189dd663c5e753ed1><p class=pgc-img-caption></p></div><p>對於targets.yaml文件中的每個目標執行connect()函數：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/95e86e21f15b4e418642f221ce1df4b2><p class=pgc-img-caption></p></div><p>connect()函數位於第22行，它使用_connect()回調函數啟動線程，並將ip，port和plugin傳遞給該函數。_connect在第27行被調用。首先，它從plugin文件夾中導入一個插件，然後在第29行，使用插件構造函數連接到RAT，接下來調用插件的connect，register和loop函數。創建的所有插件擴展了puppet_rat.py中類的所有屬性。因此，讓我們查看下：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/869466b678324b74b84d9a35ef7c5576><p class=pgc-img-caption></p></div><p>於第16行，我們可以看到該類的構造函數，就像之前在核心腳本中看到的那樣，於第29行被觸發。第16行的構造函數設置了客戶端屬性——ip，端口，偽進程ID，記錄所有事件的記錄器和用於表示套接字的conn變量。最重要的功能是：</p><ol start=1><li>connect用來實現從客戶端到服務器的連接</li><li>register用來實現註冊功能</li><li>loop用來等待服務端發送命令</li></ol><p>接下來我們對該腳本進行測試。首先我們從最簡單的事情開始，讓我們修改target.yaml文件以滿足我們的需求，可以在上文找到示例。接下來，請下載quasar.py和clientidentity_pb2.py，將它們放到plugins文件夾中。</p><p>現在，我會逐行回顧我的插件代碼：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e704307388e44a08d8b7604446da670><p class=pgc-img-caption></p></div><p>首先，讓我們來看下構造函數——它擴展了PuppetRat類，從而繼承了其所有屬性。我添加了message成員，以便可以隨時對其進行編輯。用戶必須自己設置的是Tag，EncryptionKey和Signature，它們在客戶端之間傳輸。另外，我添加了一個名為message的protobuf消息成員，在第70行可以看到。它創建了未初始化的Quasar消息。</p><p>同時我增加了4個自定義函數，這些函數使研究人員可以更改tag，id，key及signature，並且可以生成和設置protobuf消息。函數__del__是一標準的Python函數，當對象被銷燬時執行——它會關閉為Quasar創建的連接。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d3f47a53e22740bca026bc8977fe4dce><p class=pgc-img-caption></p></div><p>重新實現的connect函數——該函數與測試腳本中的非常相近。在我們閱讀其源碼 之前，請先從我的Github上下載utils.py文件，並將其放置在stage props文件夾中。在第112行，創建一個tcp套接字，然後將該套接字綁定到SSL套接字。create_ssl_sock是一個添加到utils腳本中的自定義函數。就像在我們的測試腳本，它所做的只是創建一個SSL套接字並將其綁定，以便我們可以驗證Quasar證書。然後，連接到Quasar服務器並嘗試進行握手。如果一切順利，logger會顯示一正確的消息。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab84c69edc5d4e169ee44fcf96eb5d3e><p class=pgc-img-caption></p></div><p>接下來，我們來看loop函數，該函數功能非常簡單，它所做的只是從服務器接收消息並顯示它們。</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6820daca3e3d4d19a152b163d1c8f38e><p class=pgc-img-caption></p></div><p>我們繼續看register函數，這是最後一個函數，它所做的只是模仿測試腳本。它會構造一個Quasar消息併發送到服務器。正如我之前說過的，我不會對此做過多介紹。</p><p>最後，讓我們看看腳本是如何運作的！</p><p>開啟您的虛擬機並啟動Quasar服務器，然後於MoP中打開一個Shell並輸入下列命令：</p><pre><code>py orchestrator.py –targets-configtargets.yaml</code></pre><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/56ecec3566d3415192f8b87efcc718f0><p class=pgc-img-caption></p></div><p>讓我們看看如果服務端命令客戶端打開一消息框會發生什麼：</p><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a807972c957433493f89fb4a5817d2b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何創建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9589b0357532418f95850cfbcc5bfcc2><p class=pgc-img-caption></p></div><p>如您所見，我們收到了一條需要反序列化的新消息。這將需要更多的努力，但根據您目前所學知識，應該不會太難。本文翻譯自 0x00sec.org， 原文鏈接 。如若轉載請註明出處。可以私信我們，有優惠大禮包和免費課程學習。<a class=tteditor-mention data-concern-id data-id data-name=安界人才培養計劃 data-uid=3443310982085820>@安界人才培養計劃</a><a class=tteditor-forum data-concern-id=1630858953410567 data-id=1630858953410567 data-name=網絡安全在我身邊 data-uid>#網絡安全在我身邊#</a><a class=tteditor-forum data-concern-id=1669559494056983 data-id=1669559494056983 data-name=小白入行網絡安全 data-uid>#小白入行網絡安全#</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>創建</a></li><li><a>Tracker</a></li><li><a>如何</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bda6b3fd.html alt=如何做一個屬於自己的網站？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f547dc1aea0847028c710039aab58386 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bda6b3fd.html title=如何做一個屬於自己的網站？>如何做一個屬於自己的網站？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b58e1ad.html alt=網頁如何製作？這幾點要知道 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1f3b235c266644a69d1eef5e4baae955 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b58e1ad.html title=網頁如何製作？這幾點要知道>網頁如何製作？這幾點要知道</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a23a9bd.html alt="如何“讀懂'模擬電路圖？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9e82fdaee2dc459db363b02d94a2ed78 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a23a9bd.html title="如何“讀懂'模擬電路圖？">如何“讀懂'模擬電路圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ed242bb.html alt=牆厚如何識別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ed242bb.html title=牆厚如何識別>牆厚如何識別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac62942e.html alt=禪城創建放心消費城市 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152116341963423636ee2f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac62942e.html title=禪城創建放心消費城市>禪城創建放心消費城市</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eccb2e83.html alt=如何正確賣出股票 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eccb2e83.html title=如何正確賣出股票>如何正確賣出股票</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aad0ebdb.html alt=如何正確賣出股票？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/01a2a013-f9b1-4526-9ae1-116444959bf1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aad0ebdb.html title=如何正確賣出股票？>如何正確賣出股票？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1a7cced.html alt=如何自己就把主軸給修了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4240f87451ff48ce92db4c43732f0819 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1a7cced.html title=如何自己就把主軸給修了>如何自己就把主軸給修了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b5beaea.html alt=鋼製文件櫃如何檢查好壞呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b57b5acd6b81406d8aefd619a1e8424e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b5beaea.html title=鋼製文件櫃如何檢查好壞呢>鋼製文件櫃如何檢查好壞呢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36d7a60b.html alt=在多地工作過，社保如何轉移？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8093f6d2ecb141ec8ed813694f6b4e71 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36d7a60b.html title=在多地工作過，社保如何轉移？>在多地工作過，社保如何轉移？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/afcda8f6.html alt=如何判斷砂石的好壞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5fa5da0dbe64456aa44eca095062bdc7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/afcda8f6.html title=如何判斷砂石的好壞>如何判斷砂石的好壞</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4915ffaa.html alt=如何判斷承重牆和非承重牆? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/da5e2fb2f0134c559f4deceb56feddae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4915ffaa.html title=如何判斷承重牆和非承重牆?>如何判斷承重牆和非承重牆?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4f1c37a.html alt=如何理解位置度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522905438382bf82a83d58 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4f1c37a.html title=如何理解位置度>如何理解位置度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/356476ce.html alt=如何理解位置度？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522905438382bf82a83d58 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/356476ce.html title=如何理解位置度？>如何理解位置度？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4275af10.html alt=白水法院常態化開展平安創建工作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4275af10.html title=白水法院常態化開展平安創建工作>白水法院常態化開展平安創建工作</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>