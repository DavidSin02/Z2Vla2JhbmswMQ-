<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++｜從基本數據類型到抽象數據類型，從結構體到類 | 极客快訊</title><meta property="og:title" content="C++｜從基本數據類型到抽象數據類型，從結構體到類 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3b4e36cdde464fbb8f1e5b984c273e87"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9c18da6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9c18da6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9c18da6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9c18da6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9c18da6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9c18da6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9c18da6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9c18da6.html><meta property="article:published_time" content="2020-10-29T20:59:51+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:51+08:00"><meta name=Keywords content><meta name=description content="C++｜從基本數據類型到抽象數據類型，從結構體到類"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9c18da6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++｜從基本數據類型到抽象數據類型，從結構體到類</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>1 從基本數據類型到抽象數據類型</strong></h1><p>在馮 · 諾依曼體系結構中，程序代碼和數據都是以二進制存儲的，因此，對計算機系統和硬件本身而言，數據類型的概念其實是不存在的。機器指令和彙編語言中，數據對象是用二進制數表示的，內存裡存的都是二進制，對於內存裡存的內容，可以說 “你認為它是什麼，它就是什麼”。在高級語言中，為了有效地組織數據，規範數據的使用，提高程序的可讀性，方便用戶使用，引入了整型，實型等基本數據類型。不同的高級語言會定義不同的基本數據類型。編程時只需知道如何使用這些類型的變量（如何聲明，能執行哪些運算等），而不必瞭解變量的內部數據表示形式和操作的具體實現。</p><p>然而當表示複雜數據對象時，僅使用幾種基本數據類型顯然是不夠的。某些語言(如PL/1)試圖規定較多的基本數據類型(如數組，樹，棧等)來解決這個問題。但實踐表明，這不是一個好的辦法，因此任何一種程序設計語言都無法將實際應用中涉及的所有複雜數據對象都作為其基本數據類型。所以，根本的解決方法就是允許用戶自定義數據類型(User-Defined Data Type)。於是在後來發展的語言(如C語言)中，出現了構造數據類型(也稱為複合數據類型)。它允許用戶根據實際需要利用已有的基本數據類型來構造自己所需的數據類型，它們是由基本數據類型派生而來的，用於表示鏈表、樹、堆棧等複雜的數據對象。例如C語言中構造數據類型的典型代表就是結構體。C語言通過指針和類型強轉，使我們可以對一塊內存進行“你希望它代表什麼，它就代表什麼”的操作，從而實現在更深的層次上控制計算機。</p><p>儘管構造數據類型機制使得某些比較複雜的數據對象可以作為某種類型的變量直接處理，但是這些類型的表示細節對外是可見的，沒有相應的保護機制，因而在使用中會帶來許多問題。例如，用戶可在一個模塊中隨意修改該類型變量的某個成分，而這種修改對處理該數據對象的其他模塊又會產生間接的影響，這對於一個由多人合作完成的大型軟件系統的開發是很不利的。於是又出現了“信息隱藏”和抽象數據類型的概念。</p><p>所謂抽象數據類型(Abstract Data Type，ADT)是指這樣一種數據類型，它不再單純是一組值的集合，還包括作用在值集上的操作的集合，即在構造數據類型的基礎上增加了對數據的操作，且類型的表示細節及操作的實現細節對外是不可見得。之所以說它是抽象的，是因為外部只知道它做什麼，而不知道它如何做，更不知道數據的內部表示細節。這樣，即使改變數據的表示和操作的實現，也不會影響程序的其他部分。抽象數據類型可達到更好的信息隱藏效果，因為它使程序不依賴於數據結構的具體實現方法，只要提供相同的操作（接口），換用其他方法實現（內部實現）時，程序無需修改，這個特徵對於系統的維護很有利。C++中的類(Class)是抽象數據類型的一種具體實現，也是面向對象(Object-Oriented)程序設計語言中的一個重要概念。從結構體過渡到類是順其自然的事情，但是不能將C++看成是帶類的C，因為它帶來的是思考和解決問題角度的轉變。不同於面向過程的程序設計，在面向對象程序設計中，程序員面對的不再是一個個函數和變量，而是一個個對象。每個對象包含兩個部分：數據和方法，數據用來保存對象的屬性，而方法用來完成對數據的操作。對象與對象之間是通過消息進行通信的。</p><h1><strong>2 從結構體到類</strong></h1><p>結構體類型可以很方便地根據程序設計需要將某些具有內在聯繫的相同或不同類型的數據組合成一個有機的整體，便於統一使用。</p><p>但結構體也存在著一些不可避免的侷限性：數據和代碼是分離的，即結構體定義只包含數據成員，將所有對數據的處理放在函數中進行。這樣在大型應用軟件的編寫和後期維護升級過程中，程序員不僅要考慮代碼，還必須時時刻刻考慮數據結構，一量數據結構需要變更，就必須修改與之相關的所有模塊的程序代碼，使得代碼可重用性差，維護代碼代價高。一旦程序達到一定規模，程序的複雜性超過了結構化程序設計所能管理的限度，它就會變得難以處理和控制。</p><p>將數據和處理數據的函數當成一個整體，就能很好地解決上述的問題，這就是面向對象程序設計的編程思想。</p><p>結構體只是把數據封裝在一起。突破這個概念，將處理數據了函數和數據一起“封裝”成一種新的編程類型，這就是面向對象程序設計的類了。封裝可以形象地理解為以類的格式為大包，將各種不同類型的相關數據封在包內同時將其處理函數也打包在一起。</p><p><strong>2.1 類的三部曲</strong></p><p>函數的“聲明、定義和調用”三部曲延伸到類，類的三部曲包括：</p><p>2.1.1 類的聲明：類也是一種自定義的構造數據類型，它是將不同類型的數據和與這些數據相關的操作函數封裝在一起的集體體，類中的數據和操作函數分別稱為數據成員和成員函數。聲明一個類，也就是聲明類的數據成員和成員函數。</p><p>2.1.2 類的成員函數定義：類的成員函數定義可以放在類聲明的外部來實現。成員函數的定義形式為：</p><pre>類名::成員函數名(){ 成員函數體}</pre><p>2.1.3 類的應用：C++把類的“變量”改稱為“對象”。因此“對象”與一個基本類型“變量”的地位和作用是一樣的，在類的基礎上定義的“對象”才是應用類來編程要處理的對象，其定義形式也相同，格式如下：</p><pre>類名：對象名列表;</pre><p>對象是類的實例，在類定義後可根據需要定義多個實例（對象）。之後類的應用就像結構成員的引用一樣來引用對象的成員，只是現在的成員有兩部分：數據成員和成員函數。一般來說，只有在類中被定義為公有的數據成員或成員函數才能夠在類外被引用，使用引用符“.”來引用成員，其一般形式是：</p><pre>對象名.公有數據成員;對象名.公有成員函數(實參列表);</pre><p>類將數據成員和成員函數封裝在一起，成員函數直接處理數據成員，可以保證私有數據成員的安全性。所有類既有“牢固的屏障”保護著私有成員的安全，又有公有成員函數作為良好的接口與外界交流。</p><div class=pgc-img><img alt=C++｜從基本數據類型到抽象數據類型，從結構體到類 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3b4e36cdde464fbb8f1e5b984c273e87><p class=pgc-img-caption></p></div><p>面向過程程序設計採用的是結構化程序設計方法。其核心是功能分解。當程序員試圖編程解決一個實際問題時，第一步要做的是將問題分解成若干模塊，接著根據模塊來設計數據的表示方式，然後編寫函數對這些數據進行處理，最終的程序是由這些函數構成的。在整個設計過程中，模塊的數據處於功能實現的從屬地位，著重點在編寫函數，但程序員在編程時又必須時時考慮到數據，因為函數就是針對具體數據的操作。</p><p>這種數據和處理數據的函數的分離，給編程人員帶來沉重負擔。一旦後期數據結構需要變更，就必須修改與之有關的所有模塊，因此代碼可重用性差，維護代價高。一旦程序達到一定的規模，程序的複雜性超過了結構化程序設計技術所能管理的限度，它就會變得難以處理和控制。數據和函數的分離，是面向過程的程序設計在大型軟件開發時的瓶頸問題，也是面向對象的程序設計著力解決的問題。</p><p>面向對象的程序設計，顧名思意就是以對象（“數據”）為主導的一種程序設計。面向對象的程序設計思想出現得很早，只是人們認識它是從C++語言開始的。C+語言是以數據為主導，以算法為輔助的面向對象的程序設計語言。在面向對象的程序設計中，數據和處理這些數據的操作函數構成了一個整體（類），這樣數據結構發生變化時，只要對相關類進行修改，並不需要做大量的修改工作，即可實現對軟件系統的修改，降低了軟件維護成本。</p><p>在日常生活中，對象就是人們認識世界的基本單元，它可以是人，也可以是物體或者一件事。整個世界都是由形形色色的“對象”組成的，例如一個學生、一塊黑板、一場比賽等。對象可以很簡單，也可以很複雜，複雜的對象可由若干簡單的對象構成。那麼，對一組具有共同屬性特徵（數據）和行為特徵（函數）的對象的抽象就是“類”。例如，由許多學生的共同特徵可以抽象出“學生類”，而具體某一個學生就是“學生類”的一個實例（對象）。</p><p>可見，類和對象之間是抽象和具體的關係。以面向對象的觀點來看，一個對象是由描述其屬性的數據和處理這些數據的行為（函數）組成的實體，是由數據和函數共同構成的。類是對一組對象的抽象，這組對象具有相同的數據屬性和行為特徵（操作函數），在對象所屬的類中要說明這些數據和操作函數。進行C++程序設計時，有了類，才能創建對象，一個對象是類的一個實例。就如同C語言中由系統定義了整形數據int的相關特徵，用戶才能夠定義int型變量，並用該變量編程一樣，C++的編程需要用戶自己先定義“類”這種新的類型，才能定義該類的對象，並用該類對象編程。</p><p><strong>2.2 類的三大特性</strong></p><p>面向對象程序設計中最重要的概念是類和對象，最顯著的特徵是三大特性：封裝性、繼承性和多態性。</p><p>2.2.1<strong> 封裝性</strong>：封裝與數據抽象密切相關，它們在現實世界中廣泛存在。以手機為例，手機上有若干按鍵，當人們使用手機時，只需根據自己的需要按下相應的按鍵，手機就會完成相應的工作。這些按鍵裝在手機表面，人們通過它們與手機交互，而手機內部電路是封裝在機殼裡的，其內部原理對用戶來說是隱藏的，這就是“封裝”。</p><p>那麼如何知道手機上哪個鍵是撥打、哪個鍵是掛斷呢？這是手機的使用說明書告訴我們的。但使用說明書一般不會告訴我們內部電路是如何工作的。也就是說，說明書在手機做什麼和怎麼做之間做了明確的分工。</p><p>將這些觀點應用於類，就不難理解數據的抽象和封裝。將數據和處理數據的操作函數組成一個實體，數據的具體結構和對數的操作細節隱藏起來，用戶通過操作接口（公有成員函數）對數據進行操作。對於用戶來說，只需要知道如何通過操作接口對該數據進行操作，而不需要知道具體是如何做到的，也不需要知道數據如何表示，這就是“封裝”。</p><p>對象的這一封裝機制，可將對象的使用者和設計者分開，使用者像手機用戶一樣，不必知道對象行為實現的細節，只需按照設計得提供的接口去做。封裝的結果實際上隱藏了複雜性，並提供了代碼重用性，從而減輕了開發和維護一個軟件系統的難度。同時，封裝可以防止程序員對對象內部的數據成員和成員函數進行不必要的干涉，提高了系統的安全性。</p><p>2.2.2 <strong>繼承性</strong>：繼承在現實生活中是一個很容易理解的概念。例如，每人都繼承了父母的某些特徵。從面向對象程序設計的觀點來看，繼承所表達的是類之間延續的關係。這種關係使得某類（子類或派生類）可以繼承另一個類（父類或基類）的屬性特徵和行為特徵。例如，動物是一個類，狗是動物中的一種，具有動物的一般特徵，因此可以繼承動物類的某些特性，產生出一個新的狗類，而無須重新定義一個新類。</p><p>在有繼承關係的派生類中，可以直接使用基類的非私有成員數據或調用基類的非私有成員方法。</p><p>因此，在面向對象程序設計中，繼承的作用有兩個：一是避免公用代碼的重複開發，減少代碼和數據冗餘；二是通過增強一致性來減少模塊間的接口和界面。繼承機制為程序員提供了一種組織、構造和重用類的手段。</p><p>2.2.3 <strong>多態性</strong>：多態性的意義在於，類的各個對象能以不同的方式響應同一消息，即所謂的“同一接口，多種響應方式”，或者說屬於不同類的函數可以共用一個函數名，或者同樣的信息，會因接收的個體的不同而有不同的動作，例如同樣是“出行”，飛機出行、火車出行、汽車出行、......，會因為交通工具的不同，實現的方式截然不同。</p><p>類的多態性也是存在於繼承關係中，基類定義虛函數，派生類重寫這個虛函數，當基類指針對象指向派生類對象並調用虛函數時就產生了多態。</p><h1><strong>3 面向過程思維</strong></h1><p>傳統的面向過程的程序設計是圍繞著功能實現的過程而進行的。在面向過程的程序設計模式下，首先要為解決某個問題確定一個算法，為該算法構造適當的數據結構，將算法和數據結構用計算機語言描述出來，程序結構是過程化的分級結構形式。在這種程序設計中，數據與操作需要分別設計，重點放在對數據進行操作的過程上。一旦數據發生變化，需要及時修改與之相關的程序模塊。數據與操作過程的分離容易造成代碼的可重用性差及維護代價高。</p><p>面向過程主要思考的是數據結構和算法的選擇，主要工作是將任務逐漸分解為函數，並通過函數的相互調用去完成任務。</p><p>結構化、模塊化的面向過程的程序設計方法對於小規模的問題是一種非常不錯的選擇。</p><h1><strong>4 面向對象的思維</strong></h1><p>面向對象的程序設計把客觀世界看成一系列相互關聯的對象，每個對象都有其屬性及允許的各種操作；程序員主要考慮如何創建對象和創建什麼樣的對象，並設計必要的程序代碼；每個對象都有描述其特徵的屬性及其附屬於它的行為；</p><p>現實世界事物的抽象：</p><p>I 實體entity→數據模型→實體用數據來描述，實體名（屬性名1…）；</p><p>II 對象object：屬性（數據）、事件、方法，將屬性和操作封裝在一起；</p><p>對象至少有兩個要素；一是從事活動的主體，二是活動的內容；從計算機的角度看，一個對象應該包括兩個要素：一是數據，二是需要進行的操作。對象就是一個包含數據以及與這些數據有關的操作的集合。在程序設計中，對象是由數據及可以對這些數據施加的操作結合在一起所構成的獨立實體。也就是說，對象就是把數據和對這些數據的操作放在一起，作為一個相互依存不可分割的整體。對象是對客觀事物的表示或描述，一個對象具有自身的屬性（數據）和可為自己或別人做的工作功能（操作），它能通過發送消息與其他對象進行通信，協同完成任務。</p><p>面向對象的程序設計是一種先進的程序設計技術，其核心思想是封裝。首先提取要解決問題中所需要的數據，然後分析出對這些數據需要進行的操作，最後將數據與操作封裝（encapsulation)在一起形成一個整體（即對象）。在這種程序設計中，數據與操作作為一個整體進行設計，這種方法將提高代碼的可重用性，減少程序設計的工作量，方便維護。</p><p>面向對象程序設計者的任務包括兩個方面。</p><p>（1）設計對象，即決定把哪些數據和操作代碼“封裝”在一起；</p><p>（2）怎樣通知有關對象所需完成的任務，即如何發送消息。程序設計者如同一個總調度，不斷地向各個對象發出命令，讓這些對象活動起來，完成自己範圍內的操作（消息循環與事件響應）；</p><p>對象的操作可通過修改對象的屬性值或執行對象的方法完成。</p><p>具體來說：</p><p>① 需要哪些類，哪些對象；</p><p>② 每個類應該定義哪些屬性和方法；</p><p>③ 類之間的關係：關聯、繼承、聚合、實現、多態；</p><p>面向對象編程的程序就是由一組協同工作的對象組成，抽象類是類的模板，類是對象的模板。</p><p>在面向對象的語言中，利用繼承，可以先創建一個共有屬性的一般類，根據一般類再創建具有特殊屬性的新類。</p><p>體現的抽象層次：接口→抽象類→父類→子類→對象。</p><p>－End－</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>類型</a></li><li><a>C++</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/11452718.html alt=C++基本數據類型的大小和極值範圍 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3247bc04-7125-4cb0-89a2-5bcef14bb5b1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/11452718.html title=C++基本數據類型的大小和極值範圍>C++基本數據類型的大小和極值範圍</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ed397a4.html alt=C語言入門教程（二）數據類型及標準函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/244f95dddbbb47a29b312d3800957ea7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ed397a4.html title=C語言入門教程（二）數據類型及標準函數>C語言入門教程（二）數據類型及標準函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0729002.html alt=一文讀懂MySQL數據類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3969d292a92340368ca9cc80eb1b4040 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0729002.html title=一文讀懂MySQL數據類型>一文讀懂MySQL數據類型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6d5c05.html alt=Access中的數據類型和字段屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6d5c05.html title=Access中的數據類型和字段屬性>Access中的數據類型和字段屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51633c6.html alt=MySQL常用數據類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51633c6.html title=MySQL常用數據類型>MySQL常用數據類型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/54ee5cb.html alt=字段數據類型用小數注意點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/12b7b89e-37f0-441d-bf56-636f4a21c841 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/54ee5cb.html title=字段數據類型用小數注意點>字段數據類型用小數注意點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ee568a.html alt=Python數據清洗(一)：類型轉換和冗餘數據刪除 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/936eb6071cd947a4b3fedc4277d90815 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ee568a.html title=Python數據清洗(一)：類型轉換和冗餘數據刪除>Python數據清洗(一)：類型轉換和冗餘數據刪除</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18002a6.html alt=前端數據類型的動態與靜態檢查 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1536595914705a22d247c3c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18002a6.html title=前端數據類型的動態與靜態檢查>前端數據類型的動態與靜態檢查</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b093d18.html alt=光纖跳線類型、尾纖類型一目瞭然，其實你也可以很專業 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/5e730002f30f156d752c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b093d18.html title=光纖跳線類型、尾纖類型一目瞭然，其實你也可以很專業>光纖跳線類型、尾纖類型一目瞭然，其實你也可以很專業</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5513d652.html alt=HTML元素類型如何分類？如何相互轉化？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5513d652.html title=HTML元素類型如何分類？如何相互轉化？>HTML元素類型如何分類？如何相互轉化？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ec898b4.html alt=三分鐘讓你分清鋼筋的類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/adf123fe955b46c1bdd651a5d691fdf1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ec898b4.html title=三分鐘讓你分清鋼筋的類型>三分鐘讓你分清鋼筋的類型</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>