<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++模板元編程實戰：順序、分支與循環代碼的編寫 | 极客快訊</title><meta property="og:title" content="C++模板元編程實戰：順序、分支與循環代碼的編寫 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e3ef70b8c9914d08bc50e701b30587a4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d298c6e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d298c6e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9d298c6e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d298c6e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d298c6e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9d298c6e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9d298c6e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d298c6e.html><meta property="article:published_time" content="2020-11-14T21:00:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:09+08:00"><meta name=Keywords content><meta name=description content="C++模板元編程實戰：順序、分支與循環代碼的編寫"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/9d298c6e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++模板元編程實戰：順序、分支與循環代碼的編寫</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>順序執行的代碼</p><p>順序執行的代碼書寫起來是比較直觀的，考慮如下代碼：</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e3ef70b8c9914d08bc50e701b30587a4><p class=pgc-img-caption></p></div><p>這一段代碼的重點是2-7行,它封裝了元函數RemoveReferenceconst_,這個函數內部則包含了兩條語句,順序執行：</p><p>(1)第4行根據T計算出inter_type ;</p><p>(2)第6行根據inter_type算出type。</p><p>同時,代碼中的inter_type被聲明為private類型,以確保函數的使用者不會誤用inter_type這個中間結果作為函數的返回值。</p><p>這種順序執行的代碼很好理解,唯一需要提醒的是,現在結構體中的所有聲明都要看成執行的語句,不能隨意調換其順序。考慮下面的代碼:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ac8cba89f0a48a2b2e8c88cc37e458b><p class=pgc-img-caption></p></div><p>這段代碼是正確的，可以將fun1與fun2的定義順序發生調換，不會改變它們的行為。但如果我們將元編程示例中的代碼調整順序：</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fea2659fc6da42ebbd18460fd0952fee><p class=pgc-img-caption></p></div><p>程序將無法編譯,這並不難理解:在編譯期,編譯囂會掃描兩遍結構體中的代碼,第一遍處理聲明,第二遍才會深入到函數的定義之中。正因為如此, RunTimeExample是正確的,第一遍掃描時,編譯器只是瞭解到RunTimeExample包含了兩個成員函數fun1與fun2 ;在後續的掃描中,編譯器才會關注fun1中調用了fun2,雖然fun2的調用語句出現在其聲明之前,但正是因為這樣的兩遍掃描,編譯囂並不會報告找不到fun2這樣的錯誤。</p><p>但修改後的RemoveReferenceconst_中,編譯器在首次從前到後掃描程序時,就會發現type依賴於一個沒有定義的inter-type ,它不繼續掃描後續的代碼,而是會直接給出錯誤信息。在很多情況下,我們會將元函數的語句置於結構體或類中,此時就要確保其中的語句順序正確。</p><p><strong>1.3.2分支執行的代碼</strong></p><p>我們也可以在編譯期引入分支的邏輯。與編譯期順序執行的代碼不同的是,編譯期的分支邏輯既可以表現為純粹的元函數,也可以與運行期的執行邏輯相結合。對於後者,編譯期的分支往往用於運行期邏輯的選擇。我們將在這一小節看到這兩種情形各自的例子。</p><p>事實上,在前面的討論中,我們已經實現過分支執行的代碼了。比如在1.2.2節中,實現了一個Fun-元函數,並使用一個bool參數來決定函數的行為(返回值) :這就是一種典型的分支行為。事實上,像該例那樣,使用模板的特化或部分特化來實現分支,是一種非常常見的分支實現方式。當然,除此之外,還存在一些其他的分支實現方式,每種方式都有自己的優缺點-本小節會討論其中的幾種。</p><p>使用std:：conditional與std:：conditional實現分支</p><p>conditional與conditional_t是type_traits中提供的兩個元函數,其定義如下:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cf0d43861c974eedb8c4bbc281a7db73><p class=pgc-img-caption></p></div><p>其邏輯行文是：如果B為真，則函數返回T,否則返回F。其典型的使用方式為：</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e787f2fa7e2f4bf892d3a563710ef029><p class=pgc-img-caption></p></div><p>分別定義了int型的變量x與float型的變量y。</p><p>conditional與conditional_t的優勢在於使用比較簡單,但缺點是表達能力不強:它只能實現二元分支(真假分支) ,其行為更像運行期的問號表達式:x=B?T:F；。對於多元分支(類似於switch的功能)則支持起來就比較困難了。相應地, conditional與conditional_t的使用場景是相對較少的。除非是特別簡單的分支情況,否則並不建議使用這兩個元函數。</p><p>使用(部分)特化實現分支</p><p>在前文的討論中,我們就是使用特化來實現的分支。(部分)特化天生就是用來引入差異的,因此,使用它來實現分支也是十分自然的。考慮下面的代碼:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6f34c8fd873b40e5b678502ca9b603f9><p class=pgc-img-caption></p></div><p>代碼的第18行根據元函數Fun_的輸入參數不同,為h賦予了不同的值-這是一種典型的分支行為。Fun_元函數實際上引入了3個分支,分別對應輸入參數為A,B與默認的情況。使用特化引入分支代碼書寫起來比較自然,容易理解,但代碼一般比較長。</p><p>在C++ 14中,除了可以使用上述方法進行特化,還可以有其他的特化方式,考慮下面的代碼:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/90f6f602e76f47eeb58c0eb3c06c7b99><p class=pgc-img-caption></p></div><p>這段代碼與上一段實現了相同的功能(唯一的區別是元函數調用時,前者需要給出依賴型名稱::value ,而後者則無須如此),但實現簡單一些。如果希望分支返回的結果是單一的數值,則可以考慮這種方式。</p><p>使用特化來實現分支時,有一點需要注意:在非完全特化的類模板中引入完全特化的分支代碼是非法的。考慮如下代碼:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c4de96aa69240af872756c70e517d54><p class=pgc-img-caption></p></div><p>這個程序是非法的。原因是Wrapper是一個未完全特化的類模板,但在其內部包含了一個模板的完全特化Fun_&lt;int> ,這是C++標準所不允許的,會產生編譯錯誤。</p><p>為了解決這個問題,我們可以使用部分特化來代替完全特化,將上面的代碼修改如下:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/20b7e7cbd95648f6ac968037d79c3716><p class=pgc-img-caption></p></div><p>這裡引入了一個偽參數TDummy ,用於將原有的完全特化修改為部分特化。這個參數有一個默認值void,這樣就可直接以Fun_&lt;int>的形式調用這個元函數,無需為偽參數賦值了。</p><p>使用std:：enable_jf與std::enable_if_t實現分支</p><p>enable_if與enable_if_t的定義如下:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/818590a622364d62b7270dd2e3417f90><p class=pgc-img-caption></p></div><p>對於分支的實現來說，這裡面的T並不特別重要，重要的是當B為true時，enable_if元函數可以返回結果type。可以基於這個構造實現分支，考慮下面的代碼：</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8833cb41e9cc4cca81446b3d44ea13ff><p class=pgc-img-caption></p></div><p>這裡引入了一個分支。當IsFeedbackOut為真時, std:：enable_if_t&lt;lsFeedbackOut>::type是有意義的,這就使得第一個函數匹配成功;與之相應的,第二個函數匹配是失敗的。反之,當lsFeedbackOut為假時,std::enable_if_ t&lt;llsFeedbackOut>::type是有意義的,這就使得第二個函數匹配成功,第一個函數匹配失敗。</p><p>C++中有一個特性SFINAE ( Substitution Failure Is Not An Error ) ,中文譯為"匹配失敗並非錯誤"。對於上面的程序來說,一個函數匹配失敗,另一個函數匹配成功,則編譯囂會選擇匹配成功的函數而不會報告錯誤。這裡的分支實現也正是利用了這個特性。</p><p>通常來說, enable_if與enable_if_t會被用於函數之中,用做重載的有益補充-重載通過不同類型的參數來區別重名的函數。但在一些情況下,我們希望引入重名函數,但無法通過參數類型加以區分,此時通過enable_if與enable_if_t就能在一定程度上解決相應的重載問題。</p><p>需要說明的是, enable_if與enable_if_t的使用形式是多種多樣的,並不侷限於前文中作為模板參數的方式。事實上,只要C++中支持SFINAE的地方,都可以引入enable_if或enable_if_t。有興趣的讀者可以參考C++ Reference中的說明。</p><p>enable_if或enable_if_t也是有缺點的:它並不像模板特化那樣直觀,以之書寫的代碼閱讀起來也相對困難一些(相信瞭解模板特化機制的程序員比了解SFINAE的還是多一些的)。</p><p>還要說明的一點是,這裡給出的基於enable_if的例子就是一個典型的編譯期與運行期結合的使用方式。FeedbackOut_中包含了運行期的邏輯,而選擇哪個FeedbackOut_則是通過編譯期的分支來實現的。通過引入編譯期的分支方法,我們可以創造出更加靈活的函數。</p><p>編譯期分支與多種返回類型</p><p>編譯期分支代碼看上去比運行期分支複雜一些,但與運行期相比,它也更加靈活。考慮如下代碼:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90f2036f51a3473082e50b8f2f0f51be><p class=pgc-img-caption></p></div><p>這是一個運行期的代碼。首先要對第1行的代碼簡單說明一下:在C++ 14中,函數聲明中可以不用顯式指明其返回類型,編譯器可以根據函數體中的return語句來自動推導其返回類型,但要求函數體中的所有return語句所返回的類型均相同。對於上述代碼來說,其第3行與第4行返回的類型並不相同,這會導致編譯出錯。事實上,對於運行期的函數來說,其返回類型在編譯期就已經確定了,無論採用何種寫法,都無法改變。</p><p>但在編譯期,我們可以在某種程度上打破這樣的限制:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/88fb6ceb4ecd463e96fa83cd0dba3343><p class=pgc-img-caption></p></div><p>wrap2的返回值是什麼呢?事實上,這要根據模板參數Check的值來決定。通過C++中的這個新特性以及編譯期的計算能力,我們實現了一種編譯期能夠返回不同類型的數據結果的函數。當然,為了執行這個函數,我們還是需要在編譯期指定模板參數值,從而將這個編譯期的返回多種類型的函數蛻化為運行期的返回單一類型的函數。但無論如何,通過上述技術,編譯期的函數將具有更強大的功能,這種功能對元編程來說是很有用的。</p><p>這也是一個編譯期分支與運行期函數相結合的例子。事實上,通過元函數在編譯期選擇正確的運行期函數是一種相對常見的編程方法,因此C++ 17專門引入了一種新的語法if constexpr來簡化代碼的編寫。</p><p>使用if constexpr簡化代碼</p><p>對於上面的代碼段來說,在C++ 17中可以簡化為:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8979955a05b94220beedc064c93588b1><p class=pgc-img-caption></p></div><p>其中的if constexpr必須接收一個常量表達式,即編譯期常量。編譯器在解析到相關的函數調用時,會自動選擇if constexpr表達式為真的語句體,而忽略其他的語句體。比如,在編譯器解析到第15行的函數調用時,會自動構造類似如下的函數:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7a4dfd3c0fb242e6a17bfca7ffa4f63d><p class=pgc-img-caption></p></div><p>使用if constexpr寫出的代碼與運行期的分支代碼更像。同時,它有一個額外的好處,就是可以減少編譯實例的產生。使用上一節中編寫的代碼,編譯器在進行一次實例化時,需要構造wrap2與fun兩個實例;但使用本節的代碼,編譯器在實例化時只會產生一個fun函數的實例。雖然優秀的編譯器可以通過內聯等方式對構造的實例進行合併,但我們並不能保證編譯器一定會這樣處理。反過來,使用if constexpr則可以確保減少編譯器所構造的實例數,這也就意味著在一定程度上減少編譯所需要的資源以及編譯產出的文件大小。</p><p>但if constexpr也有缺點。首先,如果我們在編程時忘記書寫constexpr ,那麼某些函數也能通過編譯,但分支的選擇則從編譯期轉換到了運行期-此時,我們還是會在運行期引入相應的分支選擇,無法在編譯期將其優化掉。其次, if constexpr的使用場景相對較容:它只能放在一般意義上的函數內部,用於在編譯期選擇所執行的代碼。如果我們希望構造元函數,通過分支來返回不同的類型作為結果,那麼if constexpr就無能為力了。該在什麼情況下使用if constexpr ,還需要針對特定的問題具體分析。</p><p><strong>1.3.3循環執行的代碼</strong></p><p>一般來說,我們不會用while, for這樣的語句組織元函數中的循環代碼-因為這些代碼操作的是變量。但在編譯期,我們操作的更多的則是常量、類型與模板,為了能夠有效地操縱元數據,我們往往會使用遞歸的形式來實現循環。</p><p>還是讓我們參考一個例子:給定一個無符號整數,求該整數所對應的二進制表示中1的個數。在運行期,我們可以使用一個簡單的循環來實現。在編譯期,我們就需要使用遞歸來實現了:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b8efd1a46df24d018001c29194a4b80f><p class=pgc-img-caption></p></div><p>1-4行定義了元函數Onescount,第6行則使用了這個元函數計算45對應的二進制包含的1的個數。</p><p>你可能需要一段時間才能適應這種編程風格。整個程序在邏輯上並不複雜,它使用了C++ 14中的特性,代碼量也與編寫一個while循環相差無幾。程序第2行0nesCount&lt;(Input / 2)>是其核心,它本質上是一個遞歸調用。讀者可以思考一下,當input為45或者任意其他的數值時,代碼段第2行的行為。</p><p>般來說,在採用遞歸實現循環的元程序中,需要引入一個分支來結束循環。上述程序的第4行實現了這一分支:當將輸入減小到0時,程序進入這一分支,結束循環。</p><p>循環使用更多的一類情況則是處理數組元素。我們在前文中討論了數組的表示方法,在這裡,給出一個處理數組的示例:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0af365bf9f845358f0f0a0e84fce3b8><p class=pgc-img-caption></p></div><p>1-6行定義了一個元函數: Accumulate ,它接收一個size_t類型的數組,對數組中的元素求和並將結果作為該元函數的輸出。第8行展示了該元函數的用法:計算res的值15.</p><p>正如前文所述,在元函數中引入循環,非常重要的一點是引入一個分支來終止循環。程序的第2行是用於終止循環的分支:當輸入數組為空時,會匹配這個函數的模板參數&lt;size_t...1nputs> ,此時Accumulate返回0。而4-6行則組成了另一個分支:如果數組中包含一個或多於一個的元素,那麼調用Accumulate將匹配第二個模板特化,取出首個元素,將剩餘元素求和後加到首個元素之上。</p><p>事實上,僅就本例而言,在C++ 17中可以有更簡單的代碼編寫方法,即使用其所提供的fold expression技術：</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87db89bb6b6046dc88f2d11e77cbb873><p class=pgc-img-caption></p></div><p>fold expression本質上也是一種簡化的循環寫法,它的使用具有一定的限制。本書不對其進行重點討論。</p><p>編譯期的循環,本質上是通過分支對遞歸代碼進行控制的。因此,上一節所討論的很多分支編寫方法也可以衍生並編寫相應的循環代碼。典型的,可以使用if constexpr來編寫分支,這項工作就留給讀者進行練習了</p><p><strong>1.3.4 小心：實例化爆炸與編譯崩潰</strong></p><p>回顧一下之前的代碼：</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/611d1fd2b3ba45a4b9b326e043fff1c8><p class=pgc-img-caption></p></div><p>考慮一下,編譯器在編譯這一段時,會產生多少個實例。</p><p>在第6行以7為模板參數傳入時,編譯器將使用7、3、1、0來實例化OnesCount ,構造出4個實例。接下來第7行以15為參數傳入這個模板,那麼編譯器需要用15,7、3、1、0來實例化代碼。通常,編譯器會將第-次使用7, 3,1、0實例化出的代碼保留起來,這樣一來,如果後面的編譯過程中需要使用同樣的實例,那麼之前保存的實例就可以複用了。對於一般的C++程序來說,這樣做能極大地提升編譯速度,但對於元編程來說,這可能會造成災難。考慮以下的代碼:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2617755a40d14b0c928c70e8d65f1a59><p class=pgc-img-caption></p></div><p>這段代碼結合了前文所討論的分支與循環技術,構造出了Wrap_類模板。它是一個元函數,接收參數A返回另一個元函數。後者接收參數ID,並計算</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/897f323994cf48ef808c2a98ad1ac271><p class=pgc-img-caption></p></div><p>。</p><p>在編譯第18行代碼時,編譯器會因為這條語句產生Wrap_ &lt;3>::imp的一系列實例。不幸的是,在編譯第19行代碼時,編譯器無法複用這些實例,因為它所需要的是Wrap_ &lt;10>::imp的一系列實例,這與Wrap_ &lt;3>::imp系列並不同名。因此,我們無法使用編譯器已經編譯好的實例來提升編譯速度。</p><p>實際情況可能會更糟,編譯囂很可能會保留Wrap _&lt;3>::imp的一系列實例,因為它會假定後續可能還會出現再次需要該實例的情形。上例中Wrap_中包含了一個循環,循環所產生的全部實例都會在編譯器中保存。如果我們的元函數中包含了循環嵌套,那麼由此產生的實例將隨循環層數的增加呈指數的速度增長-這些內容都會被保存在編譯器中。</p><p>下幸的是,編譯器的設計往往是為了滿足一般性的編譯任務,對於元編程這種目前來說使用情形並不多的技術來說,優化相對較少。因此編譯器的開發者可能不會考慮編譯過程中保存在內存中的實例數過多的問題(對於非元編程的情況,這可能並不是一個大問題)。但另一方面,如果編譯過程中保存了大量的實例,那麼可能會導致編譯器的內存超限,從而出現編譯失敗甚至崩潰的情況。</p><p>這並非危言聳聽。事實上,在作者編寫深度學習框架時,就出現過對這個問題沒有引起足夠重視,而導致編譯內存佔用過多,最終編譯失敗的情況。在小心修改了代碼之後,編譯所需的內存比之前減少了50%以上,編譯也不再崩潰了.</p><p>那麼如何解決這個問題呢?其實很簡單:將循環拆分出來。對於上述代碼,我們可以修改為如下內容:</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/20c84fcf54c548fc8cb44d6e43306577><p class=pgc-img-caption></p></div><p>在實例化Wrap _&lt;3>::value&lt;2>時,編譯器會以5、4,3,2,1、0為參數構造imp,在隨後實例化Wrap _&lt;10>::value_&lt;2>時,之前構造的東西還可以被使用,新的實例化次數也會隨之變少,</p><p>但這種修改還是有不足之處的:在之前的代碼中, imp被置於Wrap_中,這表明了二者的緊密聯繫;從名稱汙染的角度上來說,這樣做不會讓imp汙染Wrap_外圍的名字空間。但在後一種實現中, imp將對名字空間造成汙染:在相同的名字空間中,我們無法再引入另一個名為imp的構造,供其他元函數調用。</p><p>如何解決這種問題呢?這實際上是一種權衡。如果元函數的邏輯比較簡單,同時並不會產生大量實例,那麼保留前一種(對編譯器來說比較糟糕的)形式,可能並不會對編譯器產生太多負面的影響,同時使得代碼具有更好的內聚性。反之,如果元函數邏輯比較複雜(典型情況是多重循環嵌套) ,又可能會產生很多實例,那麼就選擇後一種方式以節省編譯資源。</p><p>即使選擇後一種方式,我們也應當盡力避免名字汙染。為了解決這個問題,在後續編寫深度學習框架時,我們會引入專用的名字空間,來存放像imp這樣的輔助代碼。</p><p><strong>1.3.5 分支選擇與短路邏輯</strong></p><p>減少編譯期實例化的另一種重要的技術就是引入短路邏輯。考慮如下代碼：</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e3b87c584f7b4f2bbc32d335b7fa505f><p class=pgc-img-caption></p></div><p>這段代碼的邏輯並不複雜。1-2行引入了一個元函數is _odd ,用來判斷一個數是否為奇數。在此基礎上, Allodd_用於給定數N,判斷0~N的數列中是否每個數均為奇數。</p><p>雖然這段代碼的邏輯非常簡單,但足以用於討論本節中的問題了。考慮一下在上述代碼中,為了進行判斷,編譯器進行了多少次實例化。在代碼段的第7行,系統進行了遞歸的實例化。給定N作為AllOdd的輸入時,系統會實例化出N+1個對象。</p><p>上述代碼判斷的核心是第8行:一個邏輯“與"操作。對於“與"來說,只要有一個操作數不為真,那麼就該返回假。但這種邏輯短路的行為在上述元程序中並沒有得到很好地利用-無論is_cur_odd的值是什麼,Allodd_都會對is _pre_ odd進行求值,這會間接產生若干實例化的結果,雖然這些實例化可能對系統最終的求值沒什麼作用。</p><p>以下是這個程序的改進版本(這裡只列出了修改的部分) :</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b405e98378b446f180f2e3059cfc81c7><p class=pgc-img-caption></p></div><p>這裡引入了一個輔助元函數AndValue :只有當該元函數的第一個操作數為true時,它才會實例化第二個操作數 ;否則將直接返回false,代碼段的10~ 11行使用了AndValue以減少實例化的次數,同時也減少了代碼的編譯成本。</p><p>本文節選自《C++模板元編程實戰：一個深度學習框架的初步實現》</p><div class=pgc-img><img alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e2300393209e485da96a611eec0d614c><p class=pgc-img-caption></p></div><p>本書將以一個深度學習框架的實現為例，討論如何在一個相對較大的項目中深入應用元編程，為系統性能優化提供了更多的可能。本書分8章，前兩章討論了一些元編程與編譯期計算的基本技術，後面六章則討論了元編程在深度學習框架中的實際應用，涉及到富類型與標籤體系、表達式模板、複雜元函數的編寫等多個主題，詳盡地展示瞭如何將面向對象與元編程相結合以構造複雜系統。</p><p></p><div class=tt-column-card data-content='{"url":"","content":"","thumb_url":"http://p7.pstatp.com/large/pgc-image/ff76e1fcba414763b5d25b2c03579625","title":"C Primer Plus官方視頻解讀","author_description":"異步社區","price":119,"share_price":9.52,"sold":5,"column_id":"6822821206685647116","new_thumb_url":"http://sf6-ttcdn-tos.pstatp.com/img/pgc-image/ff76e1fcba414763b5d25b2c03579625"}'><p class=column-placeholder></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>C++</a></li><li><a>編程</a></li><li><a>實戰</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html alt=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3058ca03-deee-4287-a38c-9163687a0673 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html title=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上>C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fb3d61e.html alt=C++編程自學寶典：如何編寫一個簡單的項目程序？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ec424c077c6a41d9a6de2b6c4c0c4954 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fb3d61e.html title=C++編程自學寶典：如何編寫一個簡單的項目程序？>C++編程自學寶典：如何編寫一個簡單的項目程序？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e551fdf0.html alt=C++｜深入理解編程中的字符編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2a9d352f7db7442987c04f2b54daf4f1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e551fdf0.html title=C++｜深入理解編程中的字符編碼>C++｜深入理解編程中的字符編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html alt=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/805329c3d3fc4c7aae35456efd84cd6c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html title=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板>C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04743eb6.html alt=C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/b35fbec7-2043-4f8f-b354-617f095d32cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04743eb6.html title=C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性>C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57af4069.html alt=C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1322941786864783877a7707ec15289f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57af4069.html title=C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？>C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a142cb95.html alt=C/C++編程入門基礎項目：C語言控制檯版本，貪吃蛇源代碼示例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/412ec0fbaede42c2aab496366afb8dd3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a142cb95.html title=C/C++編程入門基礎項目：C語言控制檯版本，貪吃蛇源代碼示例>C/C++編程入門基礎項目：C語言控制檯版本，貪吃蛇源代碼示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d208ccdc7f074f67a257d52df74e4f48 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html title=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）>C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5727a1aa.html alt=C/C++編程筆記：C語言開發黃金礦工遊戲！項目源碼分享學習 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b4fcdf4fd6ef4d98b5579675bfb07a87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5727a1aa.html title=C/C++編程筆記：C語言開發黃金礦工遊戲！項目源碼分享學習>C/C++編程筆記：C語言開發黃金礦工遊戲！項目源碼分享學習</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35f99da2.html alt="C/C++編程筆記：《C語言》—— 數組知識詳解，學編程建議收藏！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/925551ca-8f79-45eb-91c7-6c36d0ec6953 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35f99da2.html title="C/C++編程筆記：《C語言》—— 數組知識詳解，學編程建議收藏！">C/C++編程筆記：《C語言》—— 數組知識詳解，學編程建議收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6f4f655.html alt=C/C++編程筆記：C語言“井字棋”小遊戲，井字棋走起來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/82ab35a2de17490c96eff21a335413b8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6f4f655.html title=C/C++編程筆記：C語言“井字棋”小遊戲，井字棋走起來>C/C++編程筆記：C語言“井字棋”小遊戲，井字棋走起來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1517c90b.html alt=C/C++編程筆記：C語言開發經典項目《五子棋大戰》，源碼分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/58189ca8d0964e4283fcc9e33b00df22 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1517c90b.html title=C/C++編程筆記：C語言開發經典項目《五子棋大戰》，源碼分享>C/C++編程筆記：C語言開發經典項目《五子棋大戰》，源碼分享</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c983d7a.html alt=C/C++編程筆記：推箱子小遊戲，大一學習C語言練手項目 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e0e939e0a6945c495eff4c30164d3ae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c983d7a.html title=C/C++編程筆記：推箱子小遊戲，大一學習C語言練手項目>C/C++編程筆記：推箱子小遊戲，大一學習C語言練手項目</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72f2884c.html alt=C/C++編程筆記：流行的數字遊戲2048，C語言400行源代碼分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/810e773711f546b1bac33601023ef4e2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72f2884c.html title=C/C++編程筆記：流行的數字遊戲2048，C語言400行源代碼分享>C/C++編程筆記：流行的數字遊戲2048，C語言400行源代碼分享</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/93e54952.html alt=C/C++，被譽為“最經典的編程語言”，不僅是因為編程入門需要學 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0a635ca6a22c46bd85e32fa483d69d0d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/93e54952.html title=C/C++，被譽為“最經典的編程語言”，不僅是因為編程入門需要學>C/C++，被譽為“最經典的編程語言”，不僅是因為編程入門需要學</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>