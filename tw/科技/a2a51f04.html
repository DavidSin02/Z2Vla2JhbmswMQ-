<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 | 极客快訊</title><meta property="og:title" content="“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a33570f8a0234b9ebec6e7c7d55e341e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><meta property="article:published_time" content="2020-11-14T21:02:38+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:38+08:00"><meta name=Keywords content><meta name=description content="“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a2a51f04.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>難度</strong></h1><p>初級</p><h1><strong>學習時間</strong></h1><p>30分鐘</p><h1><strong>適合人群</strong></h1><p>零基礎</p><h1><strong>開發語言</strong></h1><p>Java</p><h1><strong>開發環境</strong></h1><ul><li>JDK v11</li><li>IntelliJIDEA v2018.3</li></ul><h1><strong>友情提示</strong></h1><ul><li><strong>本教學屬於系列教學，內容具有連貫性，本章使用到的內容之前教學中都有詳細講解。</strong></li><li><strong>本章內容針對零基礎或基礎較差的同學比較友好，可能對於有基礎的同學來說很簡單，希望大家可以根據自己的實際情況選擇繼續看完或等待看下一篇文章。謝謝大家的諒解！</strong></li></ul><h1><strong>1.溫故知新</strong></h1><p>前面在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6678949160684618247/?group_id=6678949160684618247" target=_blank>《“全棧2019”Java原子操作第九章：atomic包下原子數組介紹與使用》</a>一章中介紹了<strong>什麼是原子數組AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray&lt;E></strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6679249369402704388/?group_id=6679249369402704388" target=_blank>《“全棧2019”Java原子操作第十章：atomic包下字段原子更新器介紹》</a>一章中介紹了<strong>什麼是字段原子更新器AtomicIntegerFieldUpdater&lt;T>、AtomicLongFieldUpdater&lt;T>和AtomicReferenceFieldUpdater&lt;T,​V>。</strong></p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6679706985446769164/?group_id=6679706985446769164" target=_blank>《“全棧2019”Java原子操作第十一章：CAS與ABA問題介紹與探討》</a>一章中介紹了<strong>CAS算法中存在的ABA問題</strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6680534743513039368/?group_id=6680534743513039368" target=_blank>《“全棧2019”Java原子操作第十二章：AtomicStampedReference詳解》</a>一章中介紹了<strong>什麼是帶版本號的原子類AtomicStampedReference&lt;V></strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6680912625175364107/?group_id=6680912625175364107" target=_blank>《“全棧2019”Java原子操作第十三章：AtomicMarkableReference類》</a>一章中介紹了<strong>什麼是帶修改標記的原子類AtomicMarkableReference&lt;V></strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6681250302424777224/?group_id=6681250302424777224" target=_blank>《“全棧2019”Java原子操作第十四章：高性能高效率的原子類介紹》</a>一章中介紹了<strong>高性能高效率的原子類DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</strong>。</p><p>現在介紹<strong>高性能原子類是如何實現的</strong>。</p><h1><strong>2.通過</strong>LongAdder源碼分析高性能原子類是如何實現的</h1><p>以LongAdder類為例，閱讀源碼瞭解實現原理。</p><p>LongAdder類的繼承結構：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a33570f8a0234b9ebec6e7c7d55e341e><p class=pgc-img-caption></p></div><p>LongAdder的直接父類是Striped64。</p><p>Striped64是<strong>適用於於併發情況下進行累加運算的類（Java8新增的）</strong>。它是抽象的，需要子類去實現它裡面的抽象方法才能使用。在高併發情況下，它不光性能強，而且效率也高。</p><p>Striped64的子類包括前一章我們介紹到的<strong>DoubleAccumulator、DoubleAdder、LongAccumulator和LongAdder四個原子類。</strong></p><p>下面我們一起來看看它內部屬性有哪些。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8ba663ce706f4dd39fee74dfc5afd240><p class=pgc-img-caption></p></div><p>在Striped64類中，這四個變量值得注意：</p><ol><li>static final int NCPU = Runtime.getRuntime().availableProcessors();</li><li>transient volatile Cell[] cells;</li><li>transient volatile long base;</li><li>transient volatile int cellsBusy;</li></ol><p>依次來看：</p><p>變量NCPU是用來<strong>記錄當前機器上有多少個可用的CPU</strong>。</p><p>從該變量可以看出：<strong>一旦計算任務繁重，就會充分利用CPU資源。</strong></p><p>這也就是為什麼Striped64及其子類性能高效率高的原因之一。</p><p>變量cells是一個Cell數組。</p><p><strong>Cell類相當於是一個低配版的原子類。</strong></p><p>為什麼這麼說呢？</p><p>因為<strong>Cell類裡面有一個用來記錄內存值的變量和一個調用底層CAS算法的方法</strong>：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fd73af0470a847899b9cc1c283b58eaa><p class=pgc-img-caption></p></div><p>可以說，<strong>Cell類就是一個嵌入在Striped64類中的原子類。</strong></p><p>可它為什麼要嵌入在Striped64類中呢？</p><p>Striped64類內部需要一個原子類數組，組成數組的原子類一定要輕量，滿足基本的原子類要求即可。已有的原子類太重量級，一旦形成數組，內存就是一筆不小的開銷，這時就需要一個滿足原子類基本要求的且輕量的原子類，Cell類就誕生了，就在Striped64類中，以內部類的形式存在。Cell類裡面只有一個用於記錄內存值的變量value，和一個利用CAS算法更新值的方法cas。由於它沒有過多的功能，Cell類只能在atomic包內使用，不能在包外使用。</p><p>Striped64類為什麼需要一個原子類數組（Cell數組）呢？</p><p>在計算機中，單線程情況下，一個線程去執行一個原子類任務，這樣的操作沒有任何問題；但是在多線程情況下，三個線程共同去執行一個原子類任務，看起來也沒有什麼問題，卻暴露出線程資源浪費現象：三個線程共同執行一個原子類任務，其中只有一個線程做的事情是有效的，其他兩個線程做了無用功，這無疑是一種線程資源浪費，而且還佔用了CPU資源。為了解決此類現象，Striped64類定義出原子類數組，儘可能讓多線程同時完成更多的原子類任務，高效利用線程資源和CPU資源。</p><p>Striped64類中為什麼還有一個long類型變量base呢？</p><p>在計算機中，計算任務不是總有那麼多，也有很少的時候。10000個計算任務和1個計算任務用的線程個數和佔的CPU資源是不一樣的，針對上述情況，Striped64類分了兩種情況：同時要計算的任務很多和同時要計算的任務不多，即高併發和非高併發。</p><p>非高併發情況：這時候需要計算的任務可能只有一兩個，一個線程完全應付的來，而且也沒有用原子類數組的必要，用一個變量足以，這個變量就是base。當計算任務完成直接返回base變量的值即可。</p><p>高併發情況：這時候需要計算的任務可能就有10000或者更多，一個線程可以應付的來，但是太慢，這時會支援多個線程共同來完成這些任務。多個線程共同操作一個變量必然會造成線程資源的浪費，而且CPU也被佔用著。為了不讓線程做沒用的忙碌，有必要用原子類數組來裝任務結果。當計算任務完成時，返回base與Cell數組中每個Cell對象的value之和。</p><p>以add(long x)方法為例來說具體是怎麼實現的：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7bc0107756bc46cc9b70e91797241023><p class=pgc-img-caption></p></div><p>下面一步一步來看。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/601ef9fed6204fc4ba05104b1a845a02><p class=pgc-img-caption></p></div><p>這一步是判斷Cell數組是否已經被初始化。</p><p>為什麼要判斷Cell數組是否已經被初始化？</p><p>若Cell數組已被初始化，說明計算任務很多，已啟動高併發模式。</p><p>若Cell數組沒有被初始化，說明計算任務很少，當前線程數量還應付得來。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/36aca8a32e094bca96e78781457d0ca2><p class=pgc-img-caption></p></div><p>如果程序來到這一步，說明Cell數組沒有被初始化，計算任務不是很多，當前線程數量還應付得來。但是，如果當前線程數量利用CAS算法更新base值失敗的話，那就要進入高併發模式，去初始化Cell數組啦。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0cacdd9dc9c54a608062af4ef23be208><p class=pgc-img-caption></p></div><p>局部變量uncontended用來記錄後面Cell對象調用cas()方法利用CAS算法更新值是否成功。</p><p>若成功，則不必進入longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法；</p><p>若不成功，則需要進入longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法。</p><p>longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法是用來繼續更新值的方法。</p><p>繼續往下看，if語句中條件表達式有四個：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b1f9857b0d684d4bae5761748d9b7426><p class=pgc-img-caption></p></div><ol><li>cs == null</li><li>(m = cs.length - 1) &lt; 0</li><li>(c = cs[getProbe() & m]) == null</li><li>!(uncontended = c.cas(v = c.value, v + x))</li></ol><p>這四個條件表達式它們用“||”符合連接，只要滿足其中任意一個，就進入賦值階段。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72c837107cb5472fb90a7af6536ec923><p class=pgc-img-caption></p></div><p>“cs == null”：走到這一步，說明cells數組已經不為空了，因為在它之前“(cs = cells) != null”判斷過了，所以這裡的cells通常來說不會為空。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b58b53e78fa64eaea1a91a3407c48270><p class=pgc-img-caption></p></div><p>“(m = cs.length - 1) &lt; 0”：既然Cell數組不為空，那麼Cell數組的長度是否為0呢？該步驟就是檢查Cell數組長度為0的情況。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/606ff33e7634499190eb06a4e8f4fec9><p class=pgc-img-caption></p></div><p>“(c = cs[getProbe() & m]) == null”：Cell數組不為空且Cell數組長度也不為0，接下來就該獲取其中一個Cell對象，然後進行CAS賦值操作。</p><p>問題是該取哪個位置的元素呢？</p><p>這個就通過我們的getProbe()方法計算得到的：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75bc8df0e1cc430d9ab58af5e6d8ba8a><p class=pgc-img-caption></p></div><p>getProbe()方法：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ffeec1a9b4f4425fa626010327b0712e><p class=pgc-img-caption></p></div><p>通過對當前線程進行hash運算，得到一個hash值。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/818de724eb3440b2afac5b1963c4dbf9><p class=pgc-img-caption></p></div><p>然後拿著這個hash值和數組最大下標做“&”運算，運算總會得到一個0-最大下標的值，然後取到cells[前面計算好的下標]的元素，最後判斷該元素是否為空。</p><p>來一個動畫演示一下上述操作：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a9ca33414b374dc0adac33107ab42bd4><p class=pgc-img-caption></p></div><p>為什麼還有判斷該元素是否為空？</p><p>因為有可能該位置元素前面已經被其他線程算過，所以我們取到已存在的元素時，只需在此基礎之上累加即可。</p><p>下面就是開始累加的操作：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/321a23ac131e452886795a6f900f683b><p class=pgc-img-caption></p></div><p>“!(uncontended = c.cas(v = c.value, v + x))”：能進行到這一步，說明Cell對象不為空，那麼我們就繼續在此基礎之上調用cas(v = c.value, v + x)方法利用CAS算法進行賦值。並將賦值是否成功的結果用變量uncontended記錄下來，以便在後面運算時做出相應的決策。</p><p>假設最後一步cas失敗，我們進入到“longAccumulate(x, null, uncontended)”執行步驟中：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2555f19192d64175ba568ef2e0551406><p class=pgc-img-caption></p></div><p>longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2abf878ed3004e598912c0a3fa26c722><p class=pgc-img-caption></p></div><p>方法太長，我們依次分段往下說。</p><p>在此之前，瞭解幾個參數的作用：</p><p><strong>long x</strong>：操作數，比如給原值+1，那麼這個1就是操作數。</p><p><strong>LongBinaryOperator fn</strong>：二元運算，即自定義操作數與原值做什麼運算，如加法、減法、乘法、除法等等。</p><p><strong>boolean wasUncontended</strong>：前面CAS賦值是否成功。</p><p>方法最開始需要給當前線程分配操作的Cell對象，待分配的Cell對象被裝在Cell數組變量cells中（<strong>cells初始值為null</strong>）：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8c0e3501c5cb4399b36b7ab230f8c270><p class=pgc-img-caption></p></div><p>合理分配就成了一個問題。若分配不合理，所有線程都操作一個Cell對象，那就沒必要建數組，分配Cell對象了。</p><h1>&算法</h1><p>Striped64類就採取了一種類似於取餘算法的操作：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7e736ba427804dd8a3b6d086f9ae4fd8><p class=pgc-img-caption></p></div><p>下面，我們就來簡單模擬這一操作。</p><p>模擬100個線程和長度為8的Cell數組分配過程：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0a3a54b916894969bfdb4b18143df2c2><p class=pgc-img-caption></p></div><p>例子中“i & 7”裡面的7是數組最大下標，即數組長度-1。和add(long x)方法源碼中的操作一樣：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c95d4e2498a148cf9000773056c98032><p class=pgc-img-caption></p></div><p>運行程序，執行結果：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fc64e075f255425fa7244b6e52d864ad><p class=pgc-img-caption></p></div><p>從運行結果來看，結果一直是0-7循環，即cells[0]-cells[7]，這樣我們每個元素都會被合理取到。</p><p>不得不佩服這一設計，很巧妙。</p><h1>hash值為0時，重新計算</h1><p>在longAccumulate()方法內部用一個局部變量h來記錄當前線程的hash值：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77d2f8373d3044ef9fb83fe00d325e5a><p class=pgc-img-caption></p></div><p>如果h為0的話，則會強制重新再計算一次：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8c8fcca527da42dfab0080e5ceba0208><p class=pgc-img-caption></p></div><p>順便將變量wasUncontended置為true。</p><h1>避免hash碰撞</h1><p>用一個局部變量collide來避免hash碰撞情況，當cells數組長度大於CPU數量時，我們就要去重新算一次當前線程的hash值：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19d8a451a92b44f59b79717972fb3ab0><p class=pgc-img-caption></p></div><p>目的就是避免發生hash值相同的情況，即hash碰撞。</p><h1>外層無限循環</h1><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8bb04648437e4676abc79c54b4706092><p class=pgc-img-caption></p></div><p>外層無需循環用來做CAS賦值操作的，待會分析到裡面具體操作時你就會看到。</p><h1>Cell數組、Cell對象、下標、操作數</h1><p>用四個臨時變量來記錄當前線程操作的Cell數組、Cell對象、下標以及操作數：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/58c6a18a01f941a99f81610c7e5a49f9><p class=pgc-img-caption></p></div><p><strong>Cell[] cs：</strong>當前線程操作的Cell數組，即cells變量;</p><p><strong>Cell c：</strong>當前線程操作的Cell對象，該對象從Cell數組分配而來的;</p><p><strong>int n：</strong>給當前線程分配的下標;</p><p><strong>long v：</strong>參與運算的操作數；</p><h1>初始化Cell數組</h1><p>最初，變量cells還沒有被初始：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d7cddc5305de4f7ca7958cb050b6b613><p class=pgc-img-caption></p></div><p>所以一旦出現高併發情況，第一時間應該是先初始化cells變量：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9505ff4700074d098f3778d9c15e811a><p class=pgc-img-caption></p></div><p><strong>“cellsBusy == 0”：</strong>沒有其他線程正在初始化Cell數組。</p><p><strong>“cells == cs”：</strong>cells數組為null，沒有被初始化過。</p><p><strong>“casCellsBusy()”：</strong></p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f535dd1f9061475ab63d8151a0a89eab><p class=pgc-img-caption></p></div><p>cellsBusy算是一把非阻塞鎖，如果沒有線程正在給cells賦值，那麼casCellsBusy()方法執行結果就為true；如果已有線程正在給cells賦值，那麼casCellsBusy()方法執行結果為false。</p><p>當casCellsBusy()方法返回false時，<strong>因為是無限循環，所以還得再執行循環體裡面的內容，直到cells變量被初始化</strong>：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64ce90b974c04e6a963d320c4468cd41><p class=pgc-img-caption></p></div><p>如果拿到給cells變量初始化的鎖，那麼就可以執行以下內容（即初始化cells變量）：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b2e6597a61cd443496fed90b075f5576><p class=pgc-img-caption></p></div><p><strong>“if(cs == cells){}”：</strong>在上面已經判斷過了，這裡如果沒有問題的話，肯定為true。</p><p><strong>“Cell[] rs = new Cell[2];”：</strong>創建Cell數組，初始長度為2，默認擴容公式是2^n。</p><p><strong>“rs[h & 1] = new Cell(x);”：</strong>h為上面說過的當前線程hash值，1為Cell數組長度-1，這裡利用&算法給各個線程分配元素。</p><p>此處因為是第一個元素，所以直接將操作數作為參數傳入Cell對象。</p><p><strong>“cells = rs;”：</strong>將初始化好的Cell數組賦給cells變量。</p><p><strong>“break done;”：</strong>結束外層無限循環，第一次賦值到此完成。</p><p>代碼結束之前，<strong>在finally代碼塊中將cellsBusy變量又置為0</strong>。</p><p>第一次賦值過程分析完成，下面來看後續賦值過程是怎樣的。</p><p>只拿出局部代碼來分析：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6d5049eabece4bd7bd280e433c0d2508><p class=pgc-img-caption></p></div><p><strong>“(c = cs[(n - 1) & h]) == null”：</strong>取出給當前線程分配的Cell元素，判斷當前元素是否為null。</p><p>拿上面已經初始化好的Cell數組來說，假如Cell數組情況是這樣的：</p><p>cells[0] = Cell(value = 1);</p><p>cells[1] = null;</p><p>正好給當前線程分配的Cell元素為cells[1]，即當前元素為null。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f7c1d74164644298809b5f9cc86f557b><p class=pgc-img-caption></p></div><p>若當前線程持有非阻塞cellsBusy鎖，那麼就繼續執行if語句裡面的內容：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f53da70b0cf843a08da05be9049e1287><p class=pgc-img-caption></p></div><p>創建一個新的Cell對象，並指定初始值為當前操作數x。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4f12477982664f95bba1d732f710d2e7><p class=pgc-img-caption></p></div><p>這一步給cellsBusy上鎖，即將cellsBusy由0變為1，這樣其他線程判斷cellsBusy==0結果為false，就無法獲取到cellsBusy鎖。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bd79ef0420aa43a992d7c6d933fdc5f4><p class=pgc-img-caption></p></div><p><strong>“(rs = cells) != null”：</strong>Cell數組不能為null。</p><p><strong>“(m = rs.length) > 0”：</strong>Cell數組長度要大於0。</p><p><strong>“rs[j = (m - 1) & h] == null”：</strong>給當前線程分配位置上不能有已存在的元素。</p><p><strong>“rs[j] = r;”：</strong>將剛剛新建的Cell對象賦給Cell數組指定位置。</p><p><strong>“break done;”：</strong>結束外層無限循環。</p><p><strong>finally代碼塊中最後的“cellsBusy = 0;”操作是釋放非阻塞鎖cellsBusy。</strong></p><p>以上是取到元素為null的情況。</p><p>下面我們來看看取到元素不為null的情況。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e58617deff9c4ed2bfc0ee8b7989e627><p class=pgc-img-caption></p></div><p>直接調用取到的元素cas方法，如果執行成功，那麼整個賦值過程就完成；</p><p>如果執行失敗，那麼重新計算當前線程的hash值：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/958258ad4bfc49588d95c04e038e8d65><p class=pgc-img-caption></p></div><p>advanceProbe(int probe)方法：</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/65568173656e4bb7aabe86ea3f2d22b1><p class=pgc-img-caption></p></div><p>advanceProbe(int probe)方法的作用是重新計算當前線程的hash值。</p><p>為什麼要重新計算當前線程hash值？</p><p>因為考慮到一個hash值相同的情況，即hash碰撞，所以避免出現此類問題出現，每次循環完都要重新計算一次當前線程的hash值。</p><h1>整體流程</h1><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9806f95ee524538b7801adf3118fa1e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c1d98b5ab4664b448049fe66b7ae0fd4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ec0606723f8a47a2a0c1c2dc0ae523e8><p class=pgc-img-caption></p></div><p>當所有值賦值完成時，最終返回結果就是：base+cells數組中每個Cell對象的value值之和。</p><p>最後，希望大家可以把這個例子照著寫一遍，然後再自己默寫一遍，方便以後碰到類似的面試題可以輕鬆應對。</p><p>祝大家編碼愉快！</p><h1><strong>GitHub</strong></h1><p>本章程序GitHub地址：https://github.com/gorhaf/Java2019/tree/master/Thread/atomic/高性能原子類</p><h1><strong>總結</strong></h1><ul><li>Striped64是適用於於併發情況下進行累加運算的類（Java8新增的）。它是抽象的，需要子類去實現它裡面的抽象方法才能使用。在高併發情況下，它不光性能強，而且效率也高。</li><li>Striped64的子類包括DoubleAccumulator、DoubleAdder、LongAccumulator和LongAdder四個原子類。</li><li>Cell類是一個嵌入在Striped64類中的原子類。</li><li>第一階段：判斷當前多線程情況下操作base變量是否失敗，若失敗則進入高併發模式。</li><li>第二階段：初始化Cell數組。</li><li>第三階段：根據當前線程hash值計算出當前線程所操作的Cell對象。</li><li>第四階段：判斷Cell對象元素是否為null，為null創建一個新值給Cell數組，否則利用CAS算法更新值。</li><li>從第三階段開始，每個階段都會重新計算當前線程的hash值。</li></ul><p>至此，Java中分析Striped64類相關內容講解先告一段落，更多內容請持續關注。</p><h1><strong>答疑</strong></h1><p>如果大家有問題或想了解更多前沿技術，請在下方留言或評論，我會為大家解答。</p><h1><strong>上一章</strong></h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6681250302424777224/?group_id=6681250302424777224" target=_blank>“全棧2019”Java原子操作第十四章：高性能高效率的原子類介紹</a></p><h1><strong>下一章</strong></h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6682265473255473672/?group_id=6682265473255473672" target=_blank>“全棧2019”Java原子操作第十六章：從零手寫非阻塞棧數據結構</a></p><h1><strong>學習小組</strong></h1><p>加入同步學習小組，共同交流與進步。</p><ul><li><strong>方式一：關注頭條號Gorhaf，私信“Java學習小組”。</strong></li><li><strong>方式二：關注公眾號Gorhaf，回覆“Java學習小組”。</strong></li></ul><h1><strong>全棧工程師學習計劃</strong></h1><p>關注我們，加入“全棧工程師學習計劃”。</p><div class=pgc-img><img alt=“全棧2019”Java原子操作第十五章：高性能原子類實現原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7782c8aee3024b2f9a865e0fa40280dc><p class=pgc-img-caption></p></div><h1><strong>版權聲明</strong></h1><p>原創不易，未經允許不得轉載！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>原子</a></li><li><a>全棧</a></li><li><a>2019</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/365593b1.html alt=“全棧2019”16篇Java原子操作學習資料及知識總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7782c8aee3024b2f9a865e0fa40280dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/365593b1.html title=“全棧2019”16篇Java原子操作學習資料及知識總結>“全棧2019”16篇Java原子操作學習資料及知識總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60db39cd.html alt=“全棧2019”Java原子操作第十六章：從零手寫非阻塞棧數據結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a9216c9f0d794b81a3cb8343aaa48750 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60db39cd.html title=“全棧2019”Java原子操作第十六章：從零手寫非阻塞棧數據結構>“全棧2019”Java原子操作第十六章：從零手寫非阻塞棧數據結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51b0e7a4.html alt=“全棧2019”Java第七十三章：外部類裡多個靜態非靜態內部類詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ddb1e2829cd40da92367cb521c8e280 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51b0e7a4.html title=“全棧2019”Java第七十三章：外部類裡多個靜態非靜態內部類詳解>“全棧2019”Java第七十三章：外部類裡多個靜態非靜態內部類詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7367527e.html alt=“全棧2019”Java多線程第二十九章：可重入鎖與不可重入鎖詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/80acb55db12e4d959f79f001db81407a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7367527e.html title=“全棧2019”Java多線程第二十九章：可重入鎖與不可重入鎖詳解>“全棧2019”Java多線程第二十九章：可重入鎖與不可重入鎖詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3fe0e068.html alt=“全棧2019”Java異常第十一章：重寫方法時子類不能拋出新異常 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8efe683ede77421a822e5586c0edfb62 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3fe0e068.html title=“全棧2019”Java異常第十一章：重寫方法時子類不能拋出新異常>“全棧2019”Java異常第十一章：重寫方法時子類不能拋出新異常</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/098f546.html alt=“全棧2019”Java多線程第三十五章：如何計算線程被等待的時間？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/22bd7be6c3574497b96c3ff0b274dc72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/098f546.html title=“全棧2019”Java多線程第三十五章：如何計算線程被等待的時間？>“全棧2019”Java多線程第三十五章：如何計算線程被等待的時間？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b91ab7.html alt=“全棧2019”Java第七十章：靜態內部類詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/188f29ea78cf4443aced3f0c87d040be style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b91ab7.html title=“全棧2019”Java第七十章：靜態內部類詳解>“全棧2019”Java第七十章：靜態內部類詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/21d2ba3e.html alt=2019年土木畢業生要知道的那些事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/21d2ba3e.html title=2019年土木畢業生要知道的那些事>2019年土木畢業生要知道的那些事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/171b22b4.html alt=2019年度《特種鑄造及有色合金》優秀論文結果公佈 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/137c70000b816835d80bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/171b22b4.html title=2019年度《特種鑄造及有色合金》優秀論文結果公佈>2019年度《特種鑄造及有色合金》優秀論文結果公佈</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/817e1015.html alt=2019年度《特種鑄造及有色合金》網絡評選結果出爐 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/66c26cbe459a4361b1d501e4bbac6c88 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/817e1015.html title=2019年度《特種鑄造及有色合金》網絡評選結果出爐>2019年度《特種鑄造及有色合金》網絡評選結果出爐</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/df18bcc1.html alt=金川集團公司2019年全國合金鑄造行業商洽會舉行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/df18bcc1.html title=金川集團公司2019年全國合金鑄造行業商洽會舉行>金川集團公司2019年全國合金鑄造行業商洽會舉行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c5292d6.html alt="2019年度數字孿生城市之無人機 航攝應用及真三維建模技術培訓班" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c5292d6.html title="2019年度數字孿生城市之無人機 航攝應用及真三維建模技術培訓班">2019年度數字孿生城市之無人機 航攝應用及真三維建模技術培訓班</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcd2a59f.html alt=2019年最爆笑的120個名場面合集 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dc6fcd05f35e499a9ef7a2d19ff9c66b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcd2a59f.html title=2019年最爆笑的120個名場面合集>2019年最爆笑的120個名場面合集</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/715eacc1.html alt=《獅子王》2019：引入VR虛擬製作技術，顛覆動畫電影拍攝 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9a08cc2f25cb41c5be515de0d79879a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/715eacc1.html title=《獅子王》2019：引入VR虛擬製作技術，顛覆動畫電影拍攝>《獅子王》2019：引入VR虛擬製作技術，顛覆動畫電影拍攝</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e342e11c.html alt="2019掌上生活10元風暴怎麼玩攻略 快速獲取小招喵方法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rk8ZSn39iz0Be8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e342e11c.html title="2019掌上生活10元風暴怎麼玩攻略 快速獲取小招喵方法">2019掌上生活10元風暴怎麼玩攻略 快速獲取小招喵方法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>