<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java輸入輸出流知識總結 | 极客快訊</title><meta property="og:title" content="Java輸入輸出流知識總結 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a0f864db4f6e4b278ae6ed120d6be149"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2fdf026.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2fdf026.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2fdf026.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2fdf026.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2fdf026.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2fdf026.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2fdf026.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2fdf026.html><meta property="article:published_time" content="2020-10-29T21:09:47+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:47+08:00"><meta name=Keywords content><meta name=description content="Java輸入輸出流知識總結"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a2fdf026.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java輸入輸出流知識總結</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>輸入/輸出流</strong></p><p></p><p><img alt=Java輸入輸出流知識總結 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a0f864db4f6e4b278ae6ed120d6be149></p><p><br></p><p><strong>1.File類</strong></p><p>File類可以使用文件路徑字符串來創建File實例，該文件路徑字符串可以是絕對路徑，也可以是相對路徑。</p><p><strong>1.1訪問文件名</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>String getName()返回File對象的文件名或者路徑名</p></li><li><p>String getPath()返回File對象對應的路徑名</p></li><li><p>File getAbsoluteFile()返回File對象的絕對路徑</p></li><li><p>String getAbsolutePath()返回File對象的絕對路徑名</p></li><li><p>String getParent()返回File對象的父目錄</p></li><li><p>boolean renameTo(File newName)重命名文件</p></li></ul><p>代碼示例:</p><pre>  //返回File對象的文件名或者路徑名  String name = file.getName();  System.out.println(name);  //相對路徑  String path = file.getPath();  System.out.println(path);  //絕對路徑  String f1 = file.getAbsolutePath();  System.out.println(f1);  //上一級目錄  String parent = file.getParent();  System.out.println(parent);  //重命名文件  File file2  = new File("D://2019xx");  boolean b= file.renameTo(file2);  System.out.println(b);  //返回File對象的絕對路徑  File file3 = file.getAbsoluteFile();  System.out.println(file3);</pre><p><br></p><p><strong>1.2 文件檢測</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>boolean exists()判斷File對象所對應的文件或目錄是否存在</p></li><li><p>boolean canWrite()判斷文件和目錄是否可寫</p></li><li><p>boolean canRead()判斷文件和目錄是否可讀</p></li><li><p>boolean isFile()判斷是否是文件</p></li><li><p>boolean isDirectory()判斷是否是目錄</p></li><li><p>boolean isAbsolute()判斷是否是絕對路徑</p></li><li><p>boolean isHidden()判斷文件是否隱藏</p></li></ul><p>代碼示例:</p><pre>  //判斷可讀  System.out.println(file.canRead());  //判斷可寫  System.out.println(file.canWrite());  //判斷是否存在  System.out.println(file.exists());    //判斷是否是絕對的  System.out.println(file.isAbsolute());  //判斷是否是文件  System.out.println(file.isFile());  //判斷是否是目錄  System.out.println(file.isDirectory());  //判斷是否是隱藏文件  System.out.println(file.isHidden());</pre><p><br></p><p><strong>1.3 獲取文件信息</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>long lastModified()最後一次修改時間</p></li><li><p>long length()獲取文件長度</p></li></ul><p>代碼示例:</p><pre>  File file= new File("D://1//2//111.txt");  //最後一次修改時間  long l = file.lastModified();  Date d= new Date(l);   SimpleDateFormat s= new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  String string = s.format(d);  System.out.println(string);  //獲取文件長度  long length = file.length();  System.out.println(length);</pre><p><br></p><p><strong>1.4文件操作</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>boolean createNewFile()當File對象對應的文件不存在時， 該方法新建一個File對象指定的新文件。成功返回true</p></li><li><p>boolean delete()刪除文件</p></li></ul><p>代碼示例:</p><pre>public static void main(String[] args) throws IOException {  File file = new File("D://1//2//3");  //創建文件夾  boolean b = file.mkdirs();  System.out.println(b);   //刪除文件  boolean delete = file.delete();  System.out.println(delete);  File f1 = new File("D://1//2//1.png");  //當File對象對應的文件不存在時，該方法新建一個File對象指定的新文件。成功返回true  boolean b1 = f1.createNewFile();   System.out.println(b1);  }</pre><p><strong>1.5 目錄操作</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>boolean mkdir()創建新目錄</p></li><li><p>boolean mkdirs()創建多層目錄</p></li><li><p>String[] list()列出File對象子文件名和路徑名，返回String數組</p></li><li><p>File[] listFiles()列出File對象的所有子文件和路徑</p></li><li><p>static File[] listRoots()獲取系統根路徑(獲取分區)</p></li></ul><p>代碼示例:</p><pre>  //創建一層文件夾  boolean b = file.mkdir();  System.out.println(b);  //創建多層文件夾  boolean b1 = file.mkdirs();  System.out.println(b1);   File file = new File("D://2019px");  //只獲取目錄和文件名稱  String[] list = file.list();  for (String string : list) {   System.out.println(string);  }    //獲取磁盤分區(根目錄)  File[] listRoots = File.listRoots();  for (File file2 : listRoots) {   System.out.println(file2);  }      //獲取目錄的子目錄,文件  File[] files = file.listFiles();  for (File f1 : files) {   System.out.println(f1);  }</pre><p><strong>1.6 獲取分區大小</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>long getTotalSpace()獲取分區大小</p></li><li><p>long getFreeSpace()獲取分區空閒大小</p></li><li><p>long getUsableSpace()獲取分區可用大小</p></li></ul><p>代碼示例:</p><pre>  File f1= new File("D://");  //獲取分區大小  long totalSpace = f1.getTotalSpace();  System.out.println(totalSpace/1024/1024/1024);  //獲取分區空閒大小    long freeSpace = f1.getFreeSpace();  System.out.println(freeSpace/1024/1024/1024);  //獲取分區可用大小  long usableSpace = f1.getUsableSpace();  System.out.println(usableSpace/1024/1024/1024);</pre><p><br></p><p><strong>2.InputStream和OutputStream</strong></p><p><strong>2.1FileInputStream</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>FileInputSteam(File f)構造方法，傳入File對象</p></li><li><p>FileInputSteam(String path)構造方法，傳入文件路徑</p></li><li><p>int read()一次讀1字節，逐個讀取，文件末尾返回-1</p></li><li><p>int read(byte[] b)一次讀取b.length長度字節</p></li><li><p>int read( byte[ ] b,int offset,int len)從輸入流中讀取最多len長度的字節, 保存到字節數組b中, 保存的位置從offset開始</p></li><li><p>void close()關閉此輸入流並釋放與流相關聯的任何系統資源。</p></li><li><p>int available()返回從該輸入流中可以讀取（或跳過）的字節數的估計值， 而不會被下一次調用此輸入流的方法阻塞。</p></li></ul><p>代碼示例:</p><pre>public static void main(String[] args) {  FileInputStream fis = null;  try {   File file = new File("D://1//2//111.txt");   fis = new FileInputStream(file);   //fis.available()判斷文件可讀取的字節數            //利用緩衝區byte數組加快輸出速率   byte[] bs = new byte[fis.available()];   int i;            ////讀取下一個字節數據,並存入緩衝區數組中,返回實際讀取的字節數   while ((i = fis.read(bs)) &gt; -1) {    //將byte數組轉換為String類型    System.out.println(new String(bs));   }  } catch (FileNotFoundException e) {   e.printStackTrace();  } catch (IOException e) {   e.printStackTrace();  } finally {   try {    fis.close();   } catch (IOException e) {    e.printStackTrace();   }  } }</pre><p><br></p><p><strong>2.2FileOutputStream</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>FileOutputStream(File file)創建文件輸出流以寫入由指定的File對象表示的文件</p></li><li><p>FileOutputStream(File file, boolean append)創建文件輸出流以寫入由指定的File對象表示的文件</p></li><li><p>FileOutputStream(String name)創建文件輸出流以指定的名稱寫入文件</p></li><li><p>FileOutputStream(String name, boolean append)創建文件輸出流以指定的名稱寫入文件</p></li><li><p>void write()將指定的字節數據寫入此輸出流中</p></li><li><p>void write( byte[ ] b )將b.length個字節從指定的字節數組寫入此文件輸出流</p></li><li><p>void write( byte[ ] b , int offset , int len )將len字節從位於偏移量 offset的指定字節數組寫入此文件輸出流</p></li><li><p>void close()關閉此文件輸出流並釋放與此流相關聯的任何系統資源</p></li></ul><p>代碼示例:</p><pre>public class OutputTest1 { public static void printFile(File file) throws IOException {  //true表示在文本末尾添加數據,為false表示覆蓋源文件內容  FileOutputStream fos = new FileOutputStream("D://1//log1.txt", true);  //如若文件夾不存在,則創建  File f1 = new File("D://1//");  if (!(f1.exists())) {   f1.mkdir();  }  //如若文件不存在,則創建  File f2 = new File("D://1//log1.txt");  if (!(f2.exists())) {   f2.createNewFile();  }  if (file.isDirectory()) {   File[] files = file.listFiles();   if (files == null) {    return;   }   for (File file2 : files) {    byte[] bs = (file2.getAbsolutePath() + "").getBytes();    fos.write(bs);    printFile(file2);   }  }  fos.close(); } public static void main(String[] args) throws IOException {  // 獲取所有的根目錄  long s = System.currentTimeMillis();  //遍歷所有磁盤分區 /* File[] files = File.listRoots();  for (int i = 0; i &lt; files.length; i++) {   try {    printFile(files[i]);   } catch (IOException e1) {    e1.printStackTrace();   }  }*/  printFile(new File("D://"));  long e = System.currentTimeMillis();  System.out.println("耗時"+(e - s) / 1000+"秒"); }}</pre><p><br></p><p><strong>2.4BufferedInputStream</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>BufferedInputStream(InputStream in)創建一個</p></li><li><p>BufferedInputStream並保存其參數，輸入流</p></li><li><p>inint available()返回從該輸入流中可以讀取（或跳過）的字節數的估計值 而不會被下一次調用此輸入流的方法阻塞</p></li><li><p>int read()讀取1字節文件</p></li><li><p>int read(byte[ ] b)讀取b.length長度的字節數據</p></li><li><p>int read(byte[ ] b, int off, int len)從給定的偏移開始，將字節輸入流中的字節讀入指定的字節數組</p></li><li><p>void close()關閉此輸入流並釋放與流相關聯的任何系統資源。</p></li></ul><p><br></p><p>代碼示例:</p><pre>public static void main(String[] args) {  FileInputStream fis = null;  BufferedInputStream bis = null;  try {   //定義讀取對象   fis = new FileInputStream("D://1//2.txt");   //緩存輸讀取流包裝輸出讀取的對象   bis = new BufferedInputStream(fis);   int i = 0;   //bis.available()判斷文件可讀取的字節數   byte[] bs = new byte[bis.available()];   while ((i = bis.read(bs)) &gt; -1) {    // 將byte數組裝換為String類型    String string = new String(bs);    System.out.println(string);       }  } catch (FileNotFoundException e) {   e.printStackTrace();  } catch (IOException e) {   e.printStackTrace();  } finally {   try {    fis.close();    bis.close();   } catch (IOException e) {    e.printStackTrace();   }  } }</pre><p><br></p><p><strong>2.5BufferedOutputStream</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>BufferedOutputStream(OutputStream out)創建一個新的緩衝輸出流，以將數據寫入指定的底層輸出流</p></li><li><p>void flush()刷新緩衝輸出流</p></li><li><p>void write(int b)將指定的字節寫入緩衝的輸出流</p></li><li><p>void write(byte[] b)將b.length個字節從指定的字節數組寫入此文件輸出流</p></li><li><p>void write(byte[] b, int off, int len)從指定的字節數組寫入len個字節， 從偏移 off開始到緩衝的輸出流</p></li></ul><p>代碼示例:</p><pre> public static void main(String[] args) {  FileOutputStream fos = null;  BufferedOutputStream bos = null;  try {   //定義寫入對象   fos = new FileOutputStream("D:/1/3.txt",true);   //緩存輸出流包裝輸出寫入對象   bos = new BufferedOutputStream(fos);   String s = new String("路漫漫其修遠兮,吾將上下而求索.");   //將字符串裝換成Byte數組   byte[] bytes = s.getBytes();   //以bytes.length長度寫入文件   bos.write(bytes);     //寫入文件   //bos.write(bytes, 0, bytes.length);  } catch (IOException e) {   // TODO: handle exception   e.printStackTrace();  } finally {   try {    bos.flush();    fos.close();    bos.close();   } catch (IOException e) {    e.printStackTrace();   }  } }</pre><pre> public static void main(String[] args) {  InputStream is = null;  BufferedInputStream bis = null;  OutputStream os = null;  BufferedOutputStream bos = null;    try {   is = new FileInputStream("D://zl//myeclipse10.zip");   bis = new BufferedInputStream(is);   os = new FileOutputStream("D://1//2//1.zip");   bos = new BufferedOutputStream(os);   int i;   byte[] bs = new byte[1024 * 2];   long s = System.currentTimeMillis();   while ((i = bis.read(bs)) &gt; -1) {    bos.write(bs);   }   long e = System.currentTimeMillis();   System.out.println("耗時" + (e - s) / 1000 + "s");  } catch (FileNotFoundException e1) {   e1.printStackTrace();  } catch (IOException e1) {   e1.printStackTrace();  } finally {   try {    bos.flush();    bis.close();    bos.close();   } catch (IOException e) {    e.printStackTrace();   }  } }</pre><p><br></p><p><strong>3.Reader和Writer</strong></p><p><strong>3.1FileReader</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>FileReader(File file)創建一個新的 FileReader，給出 File讀取。</p></li><li><p>FileReader(String fileName)創建一個新的 FileReader，給定要讀取的文件的名稱。</p></li><li><p>int read()讀入單個字符</p></li><li><p>int read(char[ ] c)將c.length長度字符讀入數組中</p></li><li><p>int read(char[ ] c, int offset, int length)從給定的偏移開始，將字符輸入流中的字符讀入指定的字符數組</p></li><li><p>void close()關閉此文件輸出流並釋放與此流相關聯的任何系統資源</p></li></ul><p><strong>3.2FileWriter</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>FileWriter(File file)給一個File對象構造一個FileWriter對象</p></li><li><p>FileWriter(String fileName)構造一個給定文件名的FileWriter對象</p></li><li><p>FileWriter(File file, boolean append)給一個File對象構造一個FileWriter對象</p></li><li><p>FileWriter(String fileName, boolean append)構造一個FileWriter對象， 給出一個帶有布爾值的文件名，表示是否附加寫入的數據</p></li><li><p>void write(int c)寫一個字符</p></li><li><p>void write(char[] c)寫入c.length長度的字符</p></li><li><p>void write(char[] c, int off, int len)寫入字符的一部分</p></li><li><p>void write(String s, int off, int len)寫入一個字符串的一部分</p></li><li><p>Write append(char c)文件末尾追加字符</p></li><li><p>void flush()刷新流</p></li><li><p>void close()關閉流，先刷新</p></li></ul><p>代碼示例:</p><pre> public static void main(String[] args) throws IOException {  FileReader fr = new FileReader(new File("D:/1/2/111.txt"));  FileWriter fw = new FileWriter(new File("D:/1/2.txt"));  int i = 0;  char[] cs = new char[1024];  while ((i = fr.read(cs)) &gt; -1) {   // 讀取文本信息   // System.out.println(new String(cs));   // 寫入文件2.txt中   fw.write(cs, 0, cs.length);  }  fr.close();  fw.close(); }</pre><p><br></p><p><strong>3.3BufferedReader</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>BufferedReader(Reader in)創建使用默認大小的輸入緩衝區的緩衝字符輸入流</p></li><li><p>int read()讀一個字符</p></li><li><p>int read(char[ ] c)讀入單個字符</p></li><li><p>int read(char[] c, int off, int len)將c.length長度字符讀入數組中</p></li><li><p>String readLine()讀一行文字</p></li><li><p>void close()關閉流並釋放與之相關聯的任何系統資源</p></li></ul><p><strong>3.4BufferWriter</strong></p><p>方法描述</p><ul class=list-paddingleft-2><li><p>BufferedWriter(Writer out)創建使用默認大小的輸出緩衝區的緩衝字符輸出流</p></li><li><p>void write(int c)寫一個字符</p></li><li><p>void write(char[] c)寫入c.length長度的字符</p></li><li><p>void write(char[] c, int off, int len)寫入字符數組的一部分</p></li><li><p>void write(String s, int off, int len)寫一個字符串的一部分</p></li><li><p>Write append(char c)文件末尾追加字符</p></li><li><p>void newLine()寫一行行分隔符</p></li><li><p>void flush()刷新流</p></li><li><p>void close()關閉流，先刷新</p></li></ul><p><strong>4.RandomAccessFile</strong></p><p>該類的實例支持讀取和寫入隨機訪問文件。 隨機訪問文件的行為類似於存儲在文件系統中的大量字節。 有一種遊標，或索引到隱含的數組，稱為文件指針 ; 輸入操作讀取從文件指針開始的字節，並使文件指針超過讀取的字節。 如果在讀/寫模式下創建隨機訪問文件，則輸出操作也可用; 輸出操作從文件指針開始寫入字節，並將文件指針提前到寫入的字節。</p><p>方法描述</p><ul class=list-paddingleft-2><li><p>RandomAccessFile(File file, String mode)創建一個隨機訪問文件流從File參數指定的文件中讀取，並可選地寫入文件</p></li><li><p>RandomAccessFile(String name, String mode)創建隨機訪問文件流，以從中指定名稱的文件讀取，並可選擇寫入文件</p></li><li><p>int read()從該文件讀取一個字節的數據</p></li><li><p>int read(byte[] b)從該文件讀取最多b.length字節的數據到字節數</p></li><li><p>void write(int b)將指定的字節寫入此文件</p></li><li><p>void write(byte[] b)從指定的字節數組寫入b.length個字節到該文件，從當前文件指針開始</p></li><li><p>long length()返回此文件的長度。</p></li><li><p>void seek(long pos)設置文件指針偏移，從該文件的開頭測量，發生下一次讀取或寫入</p></li><li><p>int skipBytes(int n)嘗試跳過 n字節的輸入丟棄跳過的字節</p></li><li><p>void close()關閉此隨機訪問文件流並釋放與流相關聯的任何系統資源</p></li></ul><p>這兩個構造方法均涉及到一個String類型的參數mode，它決定隨機存儲文件流的操作模式，其中mode值及對應的含義如下：</p><p>1.“r”：以只讀的方式打開，調用該對象的任何write（寫）方法都會導致IOException異常</p><p>2.“rw”：以讀、寫方式打開，支持文件的讀取或寫入。若文件不存在，則創建之。</p><p>3.“rws”：以讀、寫方式打開，與“rw”不同的是，還要對文件內容的每次更新都同步更新到潛在的存儲設備中去。這裡的“s”表示synchronous（同步）的意思 4.“rwd”：以讀、寫方式打開，與“rw”不同的是，還要對文件內容的每次更新都同步更新到潛在的存儲設備中去。使用“rwd”模式僅要求將文件的內容更新到存儲設備中，而使用“rws”模式除了更新文件的內容，還要更新文件的元數據（metadata），因此至少要求1次低級別的I/O操作</p><p>代碼示例</p><pre>package com.it.day2;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFileTest { public static void main(String[] args) {  try {   RandomAccessFile raf = new RandomAccessFile("D:/1/4.txt", "rw");   byte[] b = new byte[2];   int i;   raf.seek(raf.length());   int skipBytes = raf.skipBytes(4);   System.out.println(skipBytes);   while ((i = raf.read(b)) &gt; -1) {    System.out.println(new String(b));    raf.write(100);   }   // String a = "天蒼蒼，野茫茫";   // raf.write(a.getBytes());  } catch (FileNotFoundException e) {   // TODO Auto-generated catch block   e.printStackTrace();  } catch (IOException e) {   // TODO Auto-generated catch block   e.printStackTrace();  } }}</pre><p><br></p><p><strong>5.對象序列化</strong></p><ul class=list-paddingleft-2><li><p>序列化就是將對象的狀態(對象的屬性)存儲到特定的存儲介質中的過程, 也就是將對象狀態轉換為可保持或可傳輸格式的過程.</p></li><ul class=list-paddingleft-2><li><p>序列化的核心:1.保存對象的狀態</p><p>2.對象狀態可儲存</p></li></ul><li><p>反序列化則是從特定的存儲介質中讀取數據並重新構建成對象的過程</p><p>注意:Java中只有實現了java.io.Serializable接口的類的對象才能被序列化</p></li></ul><p><strong>5.1ObjectInputStream</strong></p><p>方法描述Object readObject(Object o)讀取對象</p><p><strong>5.2 ObjectOutputStream</strong></p><p>方法描述Object writeObject(Object o)序列化對象</p><p><strong>5.3示例</strong></p><pre>/** * 序列化 * @author zl * */public class Test { public static void main(String[] args) throws IOException {  Student s1= new Student("方一凡", 18);  FileOutputStream fos = new FileOutputStream("D://s1.txt");  ObjectOutputStream oos = new ObjectOutputStream(fos);  //將內存中的對象保存到硬盤  oos.writeObject(s1); }}</pre><pre>/** * 反序列化 * @author zl * */public class Test2 { public static void main(String[] args) throws ClassNotFoundException, IOException {  FileInputStream fis  = new FileInputStream("D://s1.txt");  ObjectInputStream ois = new ObjectInputStream(fis);    Student s = (Student) ois.readObject();  System.out.println(s.getName()+s.getAge()); }}</pre><p>代碼示例:</p><pre>package com.it.day2;import java.io.Serializable;/** * 測試序列化與反序列化(注意:一個類要想序列化,必須實現Serializable接口) * @author zl * @parameter   * @return  * @version */public class Student implements Serializable{ private static final long serialVersionUID = 1L; private int id; private String name; private int age; public Student(int id, String name, int age) {  super();  this.id = id;  this.name = name;  this.age = age; } public int getId() {  return id; } public void setId(int id) {  this.id = id; } public String getName() {  return name; } public void setName(String name) {  this.name = name; } public int getAge() {  return age; } public void setAge(int age) {  this.age = age; } }----------------------------------------------------------------------------------------package com.it.day2;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.util.ArrayList;import java.util.List;/** * 測試序列化 * @author zl * @parameter   * @return  * @version */public class StudentTest1 { public static void main(String[] args) {  Student s1 = new Student(1001, "張三", 20);  Student s2 = new Student(1002, "李四", 23);  Student s3 = new Student(1003, "趙武", 41);  Student s4 = new Student(1004, "小明", 22);  Student s5 = new Student(1005, "周八", 34);  List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();  list.add(s1);  list.add(s2);  list.add(s3);  list.add(s4);  list.add(s5);  ObjectOutputStream oos = null;  FileOutputStream fos = null;  try {   fos = new FileOutputStream("D://1//s1.txt");   oos = new ObjectOutputStream(fos);   // 序列化集合對象   oos.writeObject(list);   // 序列化單個對象   // oos.writeObject(s1);  } catch (FileNotFoundException e) {   e.printStackTrace();  } catch (IOException e) {   e.printStackTrace();  } finally {   try {    oos.close();   } catch (IOException e) {    e.printStackTrace();   }  } }}-----------------------------------------------------------------------------------------package com.it.day2;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.ObjectInputStream;import java.util.ArrayList;import java.util.List;/** * 測試反序列化 * @author zl * @parameter   * @return  * @version */public class StudentTest2 { public static void main(String[] args) {  ObjectInputStream ois = null;  FileInputStream fis = null;  try {   fis = new FileInputStream("D://1//s1.txt");   ois = new ObjectInputStream(fis);   // 反序列化 集合 對象,並遍歷輸出   List&lt;Student&gt; list = (ArrayList&lt;Student&gt;) ois.readObject();   for (Student student : list) {    System.out.println(student.getId() + student.getName() + student.getAge());   }   // 反序列化單個對象,並輸出   // Student student=(Student)ois.readObject();   // System.out.println(student.getId()+student.getName()+student.getAge());  } catch (FileNotFoundException e) {   e.printStackTrace();  } catch (ClassNotFoundException e) {   e.printStackTrace();  } catch (IOException e) {   e.printStackTrace();  } finally {   try {    ois.close();   } catch (IOException e) {    e.printStackTrace();   }  } }}</pre><p><strong>6.DataInputStrean和DataOutputStream</strong></p><ol class=list-paddingleft-2><li><p>DataInputStream(InputStream為父類)</p><p>數據輸入流允許應用程序以獨立於機器的方式從底層輸入流讀取原始Java數據類型。 應用程序使用數據輸出流來寫入稍後可以被數據輸入流讀取的數據。</p><p>方法描述DataInputStream(InputStream in)創建使用指定的底層InputStream的DataInputStream。int read(byte[] b)從包含的輸入流中讀取一些字節數，並將它們存儲到緩衝區數組 bint skipBytes(int n)嘗試跳過 n字節的輸入丟棄跳過的字節</p></li><li><p>DataOutputStream(OutputStream為父類)</p><p>數據輸出流使應用程序以便攜式方式將原始Java數據類型寫入輸出流。 然後應用程序可以使用數據輸入流來讀取數據。</p><p>方法描述DataOutputStream(OutputStream out創建一個新的數據輸出流，以將數據寫入指定的底層輸出流void write(int b)將指定的字節（參數 b的低8位）寫入底層輸出流int size()返回計數器的當前值 written， 到目前為止寫入此數據輸出流的字節數</p></li></ol><p><strong>7.克隆(clone)</strong></p><p><strong>7.1淺複製（淺克隆）</strong></p><p>(要實現淺克隆被克隆的類必須實現Cloneable接口)</p><p>被複制對象的所有變量都含有與原來的對象相同的值，而所有的對其他對象的引用仍然指向原來的對象。換言之，淺複製僅僅複製所考慮的對象，而不復制它所引用的對象。</p><p>繼承自java.lang.Object類的clone()方法是淺複製</p><p><strong>7.2深複製（深克隆）</strong></p><p>(要實現深克隆被克隆類以及被克隆類的引用必須實現Serializable接口)</p><p>被複制對象的所有變量都含有與原來的對象相同的值，除去那些引用其他對象的變量。那些引用其他對象的變量將指向被複制過的新對象，而不再是原有的那些被引用的對象。換言之，深複製把要複製的對象所引用的對象都複製了一遍。深克隆的實現實際上是對對象的序列化和反序列化.</p><p><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>輸入</a></li><li><a>輸出</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b18f52fd.html alt=Java輸入/輸出流基礎（IO流） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fe9b96733a614a15bbb33683620b2596 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b18f52fd.html title=Java輸入/輸出流基礎（IO流）>Java輸入/輸出流基礎（IO流）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8fbe992.html alt=把輸入/輸出接口視為存儲單元，與存儲器統一編址 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1526536447865be6f7e7065 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8fbe992.html title=把輸入/輸出接口視為存儲單元，與存儲器統一編址>把輸入/輸出接口視為存儲單元，與存儲器統一編址</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bab183da.html alt=輸入輸出接口電路是主機與外部設備連接的邏輯控制部件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/6b97626a4ebe4e599e78b0933f04b785 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bab183da.html title=輸入輸出接口電路是主機與外部設備連接的邏輯控制部件>輸入輸出接口電路是主機與外部設備連接的邏輯控制部件</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/423e1f95.html alt=不能輸出的時候，就輸入吧，開本新書讀一讀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e1dec93b26884b76bea9d15b507d411c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/423e1f95.html title=不能輸出的時候，就輸入吧，開本新書讀一讀>不能輸出的時候，就輸入吧，開本新書讀一讀</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/61020d00.html alt=CC++｜輸入輸出與內存、緩存、設備文件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7ea116098ce24015a0e7b3e0d2c7bf33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/61020d00.html title=CC++｜輸入輸出與內存、緩存、設備文件>CC++｜輸入輸出與內存、緩存、設備文件</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/87e13c64.html alt=Java標準輸入/輸出/錯誤流 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/81f72ef3526b46b49d752e55b351c944 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/87e13c64.html title=Java標準輸入/輸出/錯誤流>Java標準輸入/輸出/錯誤流</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82c29328.html alt=C語言I/O輸入輸出專題——開篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44f68a822ffc4c19a1629c1a2d58618a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82c29328.html title=C語言I/O輸入輸出專題——開篇>C語言I/O輸入輸出專題——開篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a98bd89.html alt=PLC的輸入與輸出，你懂得怎麼連接麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/a8d80f02-a9a1-4588-8de3-6cac17bfd3e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a98bd89.html title=PLC的輸入與輸出，你懂得怎麼連接麼？>PLC的輸入與輸出，你懂得怎麼連接麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cddb942c.html alt="Python3 輸入和輸出(完成版)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/31d469d2102d4dedbba5567a3cabd798 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cddb942c.html title="Python3 輸入和輸出(完成版)">Python3 輸入和輸出(完成版)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f671704b.html alt="Python第七課7. 輸入輸出" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f671704b.html title="Python第七課7. 輸入輸出">Python第七課7. 輸入輸出</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/64c521f0.html alt=字節流的輸入輸出，JAVA基礎知識筆記 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d02211d1d832407aa203b9f4ab524f18 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/64c521f0.html title=字節流的輸入輸出，JAVA基礎知識筆記>字節流的輸入輸出，JAVA基礎知識筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56b809a1.html alt=最好的輸入是輸出！輸出的三個方式與持續輸出的三個方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0de87132bc4f4b6fb9f67d264c1d174b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56b809a1.html title=最好的輸入是輸出！輸出的三個方式與持續輸出的三個方法>最好的輸入是輸出！輸出的三個方式與持續輸出的三個方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/616d5c2c.html alt=詳解Java輸入輸出數據流模型和Web應用程序開發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/64b3228d-a726-45da-aa12-32b204d6fdd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/616d5c2c.html title=詳解Java輸入輸出數據流模型和Web應用程序開發>詳解Java輸入輸出數據流模型和Web應用程序開發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/94a37759.html alt=輸出與輸入函數使用方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94a37759.html title=輸出與輸入函數使用方法>輸出與輸入函數使用方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8dcf9a4.html alt=C++中的基本輸入/輸出 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af21467ecf9e42cebb90f716b9dc9471 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8dcf9a4.html title=C++中的基本輸入/輸出>C++中的基本輸入/輸出</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>