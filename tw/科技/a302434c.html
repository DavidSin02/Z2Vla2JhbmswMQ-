<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java堆、棧、堆棧，常量池的區別 | 极客快訊</title><meta property="og:title" content="java堆、棧、堆棧，常量池的區別 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/ab1ff19ca9dc41c6a7be34ab842d3bbc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a302434c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><meta property="article:published_time" content="2020-11-14T20:59:55+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:55+08:00"><meta name=Keywords content><meta name=description content="java堆、棧、堆棧，常量池的區別"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a302434c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java堆、棧、堆棧，常量池的區別</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>先說一下棧和堆棧，我們聽老一輩的程序員一般都會說堆棧，其實棧就是堆棧的意思，連著叫只是由於歷史的原因。博主04年學數據結構的時候，書上都是說的堆棧，FILO（先進後出），也經常拿堆棧和隊列，FIFO（先進先出）這兩種數據結構拿來作比較。</p><p><strong>系統中的堆、棧 和 數據結構堆、棧</strong></p><p>系統中的堆、棧和數據結構堆、棧不是一個概念。可以說系統中的堆、棧是真實的內存物理區，數據結構中的堆、棧是抽象的數據存儲結構。</p><p><strong>數據結構堆、棧</strong></p><p>1. 棧：實際上就是滿足後進先出的性質，是一種數據項按序排列的數據結構，只能在一端(稱為棧頂(top))對數據項進行插入和刪除。</p><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ab1ff19ca9dc41c6a7be34ab842d3bbc><p class=pgc-img-caption></p></div><p>2. 堆：堆是一種完全二叉樹或者近似完全二叉樹，完全二叉樹是效率很高的數據結構，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能優化。</p><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3b3b85449e1459cb60da65964561c08><p class=pgc-img-caption></p></div><p><strong>堆排序</strong>（Heapsort）是指利用堆這種數據結構所設計的一種排序算法。詳見：十大經典排序算法</p><p><strong>系統方面的堆和棧</strong></p><p>1、棧區（stack）— 由編譯器自動分配釋放 ，存放函數的參數值，局部變量的值等。其操作方式類似於數據結構中的棧。</p><p>2、堆區（heap）— 是一個可動態申請的內存空間(其記錄空閒內存空間的鏈表由操作系統維護)，在java中,所有使用new xxx()構造出來的對象都在堆中存儲一般由程序員分配釋放， 若程序員不釋放，程序結束時可能由OS回收 。注意它與數據結構中的堆是兩回事，分配方式倒是類似於鏈表。</p><blockquote><p>堆是全局的，堆棧是每個函數進入的時候分一小塊，函數返回的時候就釋放了，靜態和全局變量，new得到的變量，都放在堆中，局部變量放在棧中，所以函數返回，局部變量就全沒了。</p></blockquote><p>我們今天重點講的是Java裡的堆和棧也就是系統方面的堆和棧。</p><p><strong>Java裡的堆、棧和常量池</strong></p><p><strong>（下面以圖文的方式講解，方便大家理解）</strong></p><p>1. 棧(stack)與堆(heap)都是Java用來在Ram中存放數據的地方。與C++不同，Java自動管理棧和堆，程序員不能直接地設置棧或堆。</p><p>2. 棧的優勢是，存取速度比堆要快，僅次於直接位於CPU中的寄存器。但缺點是，存在棧中的數據大小與生存期必須是確定的，缺乏靈活性。另外，棧數據可以共享，詳見第3點。</p><p>堆的優勢是可以動態地分配內存大小，所有使用new xxx()構造出來的對象都在堆中存儲，生存期也不必事先告訴編譯器，Java的垃圾收集器會自動收走這些不再使用的數據。但缺點是，由於要在運行時動態分配內存，存取速度較慢。</p><p>3. 常量池：存放字符串常量和基本類型常量（public static final）。</p><p>常量池的好處是為了避免頻繁的創建和銷燬對象而影響系統性能，其實現了對象的共享。</p><blockquote><p>例如字符串常量池，在編譯階段就把所有的字符串文字放到一個常量池中。</p><p>（1）節省內存空間：常量池中所有相同的字符串常量被合併，只佔用一個空間。</p><p>（2）節省運行時間：比較字符串時，==比equals()快。對於兩個引用變量，只用==判斷引用是否相等，也就可以判斷實際值是否相等。</p></blockquote><p>4. Java中的數據類型有兩種。</p><p>一種是基本類型(primitive types), 共有8種，即int, short, long, byte, float, double, boolean, char(注意，不包含String)。</p><p>如int a = 3; 這裡的a是一個指向int類型的引用，指向3這個字面值。這些字面值的數據，由於大小可知，生存期可知(這些字面值固定定義在某個程序塊裡面，程序塊退出後，字段值就消失了)，出於追求速度的原因，就存在於棧中。</p><p>另外，棧有一個很重要的特殊性，就是存在棧中的數據可以共享。假設我們同時定義：</p><pre>int a = 3;int b = 3;</pre><p>編譯器先處理int a = 3；首先它會在棧中創建一個變量為a的引用，然後查找有沒有字面值為3的地址，沒找到，就開闢一個存放3這個字面值的地址，然後將a指向3的地址。接著處理int b = 3；在創建完b的引用變量後，由於在棧中已經有3這個字面值，便將b直接指向3的地址。這樣，就出現了a與b同時均指向3的情況。</p><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b9a249887d3c490f9a7e42889174e547><p class=pgc-img-caption></p></div><p>image</p><blockquote><p>特別注意的是，這種字面值的引用與類對象的引用不同。假定兩個類對象的引用同時指向一個對象，如果一個對象引用變量修改了這個對象的內部狀態，那麼另 一個對象引用變量也即刻反映出這個變化。相反，通過字面值的引用來修改其值，不會導致另一個指向此字面值的引用的值也跟著改變的情況。</p></blockquote><p>如上例，我們定義完 a與b的值後，再令a=4；那麼，b不會等於4，還是等於3。在編譯器內部，遇到a=4；時，它就會重新搜索棧中是否有4的字面值，如果沒有，重新開闢地址存放4的值；如果已經有了，則直接將a指向這個地址。因此a值的改變不會影響到b的值。</p><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a69fbdb2e664bc78b6079c02aec0810><p class=pgc-img-caption></p></div><p>image</p><p>另一種是包裝類數據，如Integer, String, Double等將相應的基本數據類型包裝起來的類。這些類數據全部存在於堆中，Java用new()語句來顯示地告訴編譯器，在運行時才根據需要動態創建，因此比較靈活，但缺點是要佔用更多的時間。</p><p>4. String是一個特殊的包裝類數據。</p><pre>即可以用String str = new String("abc"); 的形式來創建也可以用String str = "abc"; 的形式來創建</pre><p>前者是規範的類的創建過程，即在Java中，一切都是對象，而對象是類的實例，全部通過new()的形式來創建。</p><blockquote><p>作為對比，在JDK 5.0之前，你從未見過Integer i = 3;的表達式，因為類與字面值是不能通用的，除了String。而在JDK 5.0中，這種表達式是可以的！因為編譯器在後臺進行Integer i = new Integer(3)的轉換。</p><p>Java 中的有些類，如DateFormat類，可以通過該類的getInstance()方法來返回一個新創建的類，似乎違反了此原則。其實不然。該類運用了單 例模式來返回類的實例，只不過這個實例是在該類內部通過new()來創建的，而getInstance()向外部隱藏了此細節。</p></blockquote><p>那為什麼在String str = "abc"；中，並沒有通過new()來創建實例，是不是違反了上述原則？其實沒有。</p><p>5. 關於String str = "abc"的內部工作。Java內部將此語句轉化為以下幾個步驟：</p><p>(1) 先定義一個名為str的對String類的對象引用變量放入棧中。</p><p>(2) 在常量池中查找是否存在內容為"abc"字符串對象。</p><p>(3) 如果不存在則在常量池中創建"abc"，並讓str引用該對象。</p><p>(4) 如果存在則直接讓str引用該對象。</p><p>為了更好地說明這個問題，我們可以通過以下的幾個代碼進行驗證。</p><pre>String str1 = "abc"; String str2 = "abc"; System.out.println(str1==str2); //true</pre><blockquote><p>注意，我們這裡並不用str1.equals(str2)；的方式，因為這將比較兩個字符串的地值是否相等==號，根據JDK的說明，只有在兩個引用都指向了同一個對象時才返回真值。而我們在這裡要看的是，str1與str2是否都指向了同一個對象。</p><p>結果說明，JVM創建了兩個引用str1和str2，但只創建了一個對象，而且兩個引用都指向了這個對象。</p></blockquote><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4553bbe91a24c52881cd7d0660708fc><p class=pgc-img-caption></p></div><p>image</p><p>我們再來更進一步，將以上代碼改成：</p><pre>String str1 = "abc"; String str2 = "abc"; str1 = "bcd"; System.out.println(str1 + "," + str2); //bcd, abc System.out.println(str1==str2); //false </pre><blockquote><p>這就是說，賦值的變化導致了類對象引用的變化，str1指向了另外一個新對象！而str2仍舊指向原來的對象。上例中，當我們將str1的值改為"bcd"時，JVM發現在棧中沒有存放該值的地址，便開闢了這個地址，並創建了一個新的對象，其字符串的值指向這個地址。</p><p>事實上，String類被設計成為不可改變(immutable)的類。如果你要改變其值，可以，但JVM在運行時根據新值悄悄創建了一個新對象，然後將這個對象的地址返回給原來類的引用。這個創建過程雖說是完全自動進行的，但它畢竟佔用了更多的時間。在對時間要求比較敏感的環境中，會帶有一定的不良影響。</p></blockquote><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3d9208196bbb461c82a98c36d4a14e0a><p class=pgc-img-caption></p></div><p>image</p><p>再修改原來代碼：</p><pre>String str1 = "abc"; String str2 = "abc"; str1 = "bcd"; String str3 = str1; System.out.println(str3); //bcd String str4 = "bcd"; System.out.println(str1 == str4); //true</pre><blockquote><p>str3這個對象的引用直接指向str1所指向的對象(注意，str3並沒有創建新對象)。當str1改完其值後，再創建一個String的引用 str4，並指向因str1修改值而創建的新的對象。可以發現，這回str4也沒有創建新的對象，從而再次實現棧中數據的共享。</p></blockquote><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8835d173c882469cbb06d827632ed8e8><p class=pgc-img-caption></p></div><p>image</p><p>6. 我們再來看看 String str = new String("abc")創建過程</p><p>(1) 先定義一個名為str的對String類的對象引用變量放入棧中。</p><p>(2) 然後在堆中（不是常量池）創建一個指定的對象，並讓str引用指向該對象。</p><p>(3) 在常量池中查找是否存在內容為"abc"字符串對象。</p><p>(4) 如果不存在，則在常量池中創建內容為"abc"的字符串對象，並將堆中的對象與之聯繫起來。</p><p>(5) 如果存在，則將new出來的字符串對象與字符串常量池中的對象聯繫起來（即讓那個特殊的成員變量value的指針指向它）</p><p>我們再接著看以下的代碼。</p><pre>String str1 = new String("abc"); String str2 = "abc"; System.out.println(str1==str2); //false </pre><p>創建了兩個引用。創建了兩個對象。兩個引用分別指向不同的兩個對象。</p><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/de880b7b9c954f66a8d0bdfa98a9f9ca><p class=pgc-img-caption></p></div><p>image</p><blockquote><p>對於字符串：其對象的引用都是存儲在棧中的，如果是編譯期已經創建好(直接用雙引號定義的)的就存儲在常量池中，如果是運行期（new出來的）才能確定的就存儲在堆中。對於equals相等的字符串，在常量池中永遠只有一份，在堆中有多份。</p></blockquote><p><strong>這也就是有道面試題：String s = new String(“abc”);產生幾個對象？答：一個或兩個，如果常量池中原來沒有”abc”,就是兩個。</strong></p><p>7. 基本數據類型包裝類的值不可修改。不僅僅是String類的值不可修改，所有的基本數據數據類型包裝類都不能更改其內部的值。</p><ol><li>String的intern()方法就是擴充常量池的一個方法；當一個String實例str調用intern()方法時，Java查找常量池中是否有相同Unicode的字符串常量，如果有，則返回其的引用，如果沒有，則在常量池中增加一個Unicode等於str的字符串並返回它的引用；</li></ol><pre>String str1 = "abc"; String str2 = new String("abc"); String str3 = str2.intern();System.out.println( str1==str2 ); //falseSystem.out.println( str1==str3 ); //true</pre><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/12d4fa0f8bf64fbdb81d72530cd84762><p class=pgc-img-caption></p></div><p>image</p><ol><li>結論與建議：</li></ol><p>(1) 我們在使用諸如String str = "abc"；的格式定義類時，總是想當然地認為，我們創建了String類的對象str。擔心陷阱！對象可能並沒有被創建！唯一可以肯定的是，指向 String類的引用被創建了。至於這個引用到底是否指向了一個新的對象，必須根據上下文來考慮，除非你通過new()方法來顯要地創建一個新的對象。</p><p>因此，更為準確的說法是，我們創建了一個指向String類的對象的引用變量str，這個對象引用變量指向了某個值為"abc"的String類。清醒地認識到這一點對排除程序中難以發現的bug是很有幫助的。</p><p>(2) 使用String str = "abc"；的方式，可以在一定程度上提高程序的運行速度，因為JVM會自動根據常量池中數據的實際情況來決定是否有必要創建新對象。</p><p>而對於String str = new String("abc")；的代碼，則一概在堆中創建新對象，而不管其字符串值是否相等，是否有必要創建新對象，從而加重了程序的負擔。這個思想應該是享元模式的思想，但JDK的內部在這裡實現是否應用了這個模式，不得而知。</p><p>(3) 當比較包裝類裡面的數值是否相等時，用equals()方法；當測試兩個包裝類的引用是否指向同一個對象時，用==。</p><p>(4) 由於String類的immutable性質，當String變量需要經常變換其值時，應該考慮使用StringBuffer類，以提高程序效率。</p><p><strong>申請響應</strong></p><p>棧：只要棧的剩餘空間大於所申請空間，系統將為程序提供內存，否則將報異常提示棧溢出。</p><p>堆：首先應該知道操作系統有一個記錄空閒內存地址的鏈表，當系統收到程序的申請時，會遍歷該鏈表，尋找第一個空間大於所申請空間的堆結點，然後將該結點從空閒結點鏈表中刪除，並將該結點的空間分配給程序，另外，對於大多數系統，會在這塊內存空間中的首地址處記錄本次分配的大小，這樣，代碼中的delete語句才能正確的釋放本內存空間。另外，由於找到的堆結點的大小不一定正好等於申請的大小，系統會自動的將多餘的那部分重新放入空閒鏈表中。</p><p><strong>申請限制</strong></p><p>棧：在Windows下,棧是向低地址擴展的數據結構，是一塊連續的內存的區域。這句話的意思是棧頂的地址和棧的最大容量是系統預先規定好的，在 WINDOWS下，棧的大小是2M（也有的說是1M，總之是一個編譯時就確定的常數），如果申請的空間超過棧的剩餘空間時，將提示overflow。因此，能從棧獲得的空間較小。</p><p>堆：堆是向高地址擴展的數據結構，是不連續的內存區域。這是由於系統是用鏈表來存儲的空閒內存地址的，自然是不連續的，而鏈表的遍歷方向是由低地址向高地址。堆的大小受限於計算機系統中有效的虛擬內存。由此可見，堆獲得的空間比較靈活，也比較大。</p><div class=pgc-img><img alt=java堆、棧、堆棧，常量池的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ac8ef2bd5d234037b2346738ef9965f4><p class=pgc-img-caption></p></div><p>image</p><p><strong>堆和棧的區別用比喻來看：</strong></p><p>使用棧就象我們去飯館裡吃飯，只管點菜（發出申請）、付錢、和吃（使用），吃飽了就走，不必理會切菜、洗菜等準備工作和洗碗、刷鍋等掃尾工作，他的好處是快捷，但是自由度小。</p><p>使用堆就象是自己動手做喜歡吃的菜餚，比較麻煩，但是比較符合自己的口味，而且自由度大。</p><p><strong>堆棧緩存方式</strong></p><p>棧使用的是<strong>一級緩存</strong>， 他們通常都是被調用時處於存儲空間中，調用完畢立即釋放。</p><p>堆則是存放在<strong>二級緩存</strong>中，生命週期由虛擬機的垃圾回收算法來決定（並不是一旦成為孤兒對象就能被回收）。所以調用這些對象的速度要相對來得低一些。</p><p><strong>在JAVA中，有六個不同的地方可以存儲數據：</strong></p><p>1. 寄存器（register）：這是最快的存儲區，因為它位於不同於其他存儲區的地方——處理器內部。但是寄存器的數量極其有限，所以寄存器由編譯器根據需求進行分配。你不能直接控制，也不能在程序中感覺到寄存器存在的任何跡象。</p><p>2. 棧（stack）：存放基本類型的變量數據和對象的引用。位於通用RAM中，但通過它的“堆棧指針”可以從處理器哪裡獲得支持。堆棧指針若向下移動，則分配新的內存；若向上移動，則釋放那些內存。這是一種快速有效的分配存儲方法，僅次於寄存器。創建程序時候，JAVA編譯器必須知道存儲在堆棧內所有數據的確切大小和生命週期，因為它必須生成相應的代碼，以便上下移動堆棧指針。這一約束限制了程序的靈活性。</p><p>3. 堆（heap）：一種通用性的內存池（也存在於RAM中），用於存放所有的JAVA對象。堆不同於堆棧的好處是：編譯器不需要知道要從堆裡分配多少存儲區 域，也不必知道存儲的數據在堆裡存活多長時間。因此，在堆裡分配存儲有很大的靈活性。當你需要創建一個對象的時候，只需要new寫一行簡單的代碼，當執行 這行代碼時，會自動在堆裡進行存儲分配。當然，為這種靈活性必須要付出相應的代價，用堆進行存儲分配比用堆棧進行存儲存儲需要更多的時間。</p><p>4. 靜態存儲（static storage）：這裡的“靜態”是指“在固定的位置”。靜態存儲裡存放程序運行時一直存在的數據。你可用關鍵字static來標識一個對象的特定元素是靜態的，但JAVA對象本身從來不會存放在靜態存儲空間裡。</p><p>5. 常量存儲（constant storage）：存放字符串常量和基本類型常量（public static final）。 常量值通常直接存放在程序代碼內部，這樣做是安全的，因為它們永遠不會被改變。</p><p>6. 非RAM存儲：硬盤等永久存儲空間。如果數據完全存活於程序之外，那麼它可以不受程序的任何控制，在程序沒有運行時也可以存在。</p><p>就速度來說，有如下關係：</p><p>**寄存器 &lt; 堆棧 &lt; 堆 &lt; 其他 **</p><blockquote><p>作者：互扯程序</p><p>鏈接：https://www.jianshu.com/p/e39ab6ff17c2</p><p>來源：簡書</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>java</a></li><li><a>堆棧</a></li><li><a>區別</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ee269a56.html alt=java堆、棧、堆棧，常量池的區別，史上最全總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d3292cdcde741f6a466a8aa1f9cf02e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ee269a56.html title=java堆、棧、堆棧，常量池的區別，史上最全總結>java堆、棧、堆棧，常量池的區別，史上最全總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9ea15ed4.html alt=Java中的堆、棧和堆棧的區別介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9ea15ed4.html title=Java中的堆、棧和堆棧的區別介紹>Java中的堆、棧和堆棧的區別介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3714ce0c.html alt=碳素鑄鋼件與合金鑄鋼件有什麼樣的區別？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1686cec0-1b3a-4569-8be8-fa81ad2691fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3714ce0c.html title=碳素鑄鋼件與合金鑄鋼件有什麼樣的區別？>碳素鑄鋼件與合金鑄鋼件有什麼樣的區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25ba5d26.html alt=“無愧”和“不愧”到底有什麼區別？很多人都用錯了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/781885f1-bb08-4a6e-ac54-c184b4d2207c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25ba5d26.html title=“無愧”和“不愧”到底有什麼區別？很多人都用錯了>“無愧”和“不愧”到底有什麼區別？很多人都用錯了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f3264fa.html alt=什麼是層高、什麼又是淨高呢?它們有什麼區別呢? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4c871191f800421790b43b223a57f401 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f3264fa.html title=什麼是層高、什麼又是淨高呢?它們有什麼區別呢?>什麼是層高、什麼又是淨高呢?它們有什麼區別呢?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/29b4880a.html alt=層高和淨高的區別是什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/05583d5969984731ad7cc0877b1c49f2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/29b4880a.html title=層高和淨高的區別是什麼？>層高和淨高的區別是什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04e39a7b.html alt=層高和淨高的區別？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bea7b5a30f1645ff82703f0b352b8f0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04e39a7b.html title=層高和淨高的區別？>層高和淨高的區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6b5a166.html alt=房屋層高和淨高的區別是什麼？為什麼拿到房子層高會縮水？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1540957560177032bae534a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6b5a166.html title=房屋層高和淨高的區別是什麼？為什麼拿到房子層高會縮水？>房屋層高和淨高的區別是什麼？為什麼拿到房子層高會縮水？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html alt=java相關知識(10)總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/84649e6ba0f8442a8b10584403bf6635 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html title=java相關知識(10)總結>java相關知識(10)總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8ea72ca.html alt=買相機不要再被忽悠了！教你區別最大像素，有效像素，插值像素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8a0dff28ac174424a5241af1967b95e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8ea72ca.html title=買相機不要再被忽悠了！教你區別最大像素，有效像素，插值像素>買相機不要再被忽悠了！教你區別最大像素，有效像素，插值像素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html alt=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d69c7c9d8b85444da9360e334ba6555d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html title=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID>java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html alt=多態的本質，java動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac000493fbc8532b5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html title=多態的本質，java動態綁定>多態的本質，java動態綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a5ab8117.html alt=lan口與wan口的區別？多條寬帶如何疊加？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RVmc7tiJ6bEYRC style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a5ab8117.html title=lan口與wan口的區別？多條寬帶如何疊加？>lan口與wan口的區別？多條寬帶如何疊加？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c93cfa8.html alt=硬分幣的“平”版和“凸”版的區別——硬分幣收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1523801533449b674a76943 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c93cfa8.html title=硬分幣的“平”版和“凸”版的區別——硬分幣收藏>硬分幣的“平”版和“凸”版的區別——硬分幣收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d85420c4.html alt=基金申購贖回，買入賣出的區別是什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/b3a85398-8f58-4aa5-876b-3f340463b712 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d85420c4.html title=基金申購贖回，買入賣出的區別是什麼？>基金申購贖回，買入賣出的區別是什麼？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>