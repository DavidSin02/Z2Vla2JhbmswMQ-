<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從原理到優化，深入淺出數據庫索引 | 极客快訊</title><meta property="og:title" content="從原理到優化，深入淺出數據庫索引 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/b59d88e0563642728dd6294e09a8a0af"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a3c371fa.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a3c371fa.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a3c371fa.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a3c371fa.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a3c371fa.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a3c371fa.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a3c371fa.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a3c371fa.html><meta property="article:published_time" content="2020-11-14T21:00:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:21+08:00"><meta name=Keywords content><meta name=description content="從原理到優化，深入淺出數據庫索引"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a3c371fa.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從原理到優化，深入淺出數據庫索引</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>MySQL官方對索引的定義為：索引（Index）是幫助MySQL高效獲取數據的數據結構。數據庫查詢是數據庫的最主要功能之一，我們都希望查詢數據的速度能儘可能的快，因此數據庫系統的設計者會從查詢算法的角度進行優化，這篇文章對索引做一個系統的梳理，希望對大家有幫助。</p><h2 class=pgc-h-arrow-right>一、MySQL有哪些索引類型</h2><p>索引的分類可以從多個角度進行，下面分別從數據結構，物理存儲和業務邏輯三個維度進行劃分。</p><h3 class=pgc-h-arrow-right>1、從數據結構角度</h3><h4 class=pgc-h-arrow-right>（1）B+樹索引(O(log(n)))</h4><p>關於B+樹索引，後面會深入解析</p><h4 class=pgc-h-arrow-right>（2）hash索引</h4><ul><li>僅僅能滿足"=","IN"和"&lt;=>"查詢，不能使用範圍查詢</li><li>其檢索效率非常高，索引的檢索可以一次定位，不像B-Tree 索引需要從根節點到枝節點，最後才能訪問到頁節點這樣多次的IO訪問，所以 Hash 索引的查詢效率要遠高於 B-Tree 索引</li><li>只有Memory存儲引擎顯示支持hash索引</li></ul><h4 class=pgc-h-arrow-right>（3）FULLTEXT索引</h4><p>現在MyISAM和InnoDB引擎都支持了</p><h4 class=pgc-h-arrow-right>（4）R-Tree索引</h4><p>用於對GIS數據類型創建SPATIAL索引</p><h3 class=pgc-h-arrow-right>2、從物理存儲角度</h3><h4 class=pgc-h-arrow-right>（1）聚集索引（clustered index）</h4><ul><li>正文內容按照一個特定維度排序存儲，這個特定的維度就是聚集索引；</li><li>Innodb存儲引擎中行記錄就是按照聚集索引維度順序存儲的，Innodb的表也稱為索引表；因為行記錄只能按照一個維度進行排序，所以一張表只能有一個聚集索引。</li></ul><h4 class=pgc-h-arrow-right>（2）非聚集索引（non-clustered index）</h4><ul><li>索引是通過二叉樹的數據結構來描述的，我們可以這麼理解聚簇索引：索引的葉節點就是數據節點。而非聚簇索引的葉節點仍然是索引節點，只不過有一個指針指向對應的數據塊。</li><li>非聚集索引索引項順序存儲，但索引項對應的內容卻是隨機存儲的；</li></ul><p>舉個例子說明下：</p><pre><code>create table student (`id` INT UNSIGNED AUTO_INCREMENT,`name` VARCHAR(255),PRIMARY KEY(`id`),KEY(`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>該表中主鍵id是該表的聚集索引、name為非聚集索引；表中的每行數據都是按照聚集索引id排序存儲的；比如要查找name='Arla'和name='Arle'的兩個同學，他們在name索引表中位置可能是相鄰的，但是實際存儲位置可能差的很遠。name索引表節點按照name排序，檢索的是每一行數據的主鍵。聚集索引表按照主鍵id排序，檢索的是每一行數據的真實內容。</p><h3 class=pgc-h-arrow-right>3、從邏輯角度</h3><h4 class=pgc-h-arrow-right>（1）主鍵索引</h4><p>主鍵索引是一種特殊的唯一索引，不允許有空值</p><h4 class=pgc-h-arrow-right>（2）普通索引或者單列索引</h4><h4 class=pgc-h-arrow-right>（3）多列索引（複合索引）</h4><p>複合索引指多個字段上創建的索引，只有在查詢條件中使用了創建索引時的第一個字段，索引才會被使用。使用複合索引時遵循最左前綴集合</p><h4 class=pgc-h-arrow-right>（4）唯一索引或者非唯一索引</h4><h4 class=pgc-h-arrow-right>（5）空間索引</h4><p>空間索引是對空間數據類型的字段建立的索引，MYSQL中的空間數據類型有4種，分別是GEOMETRY、POINT、LINESTRING、POLYGON。</p><p>MYSQL使用SPATIAL關鍵字進行擴展，使得能夠用於創建正規索引類型的語法創建空間索引。創建空間索引的列，必須將其聲明為NOT NULL，空間索引只能在存儲引擎為MYISAM的表中創建.</p><h2 class=pgc-h-arrow-right>二、索引創建方式</h2><pre><code>CREATE TABLE table_name[col_name data type][unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]</code></pre><ul><li>unique|fulltext|spatial為可選參數，分別表示唯一索引、全文索引和空間索引；</li><li>index和key為同義詞，兩者作用相同，用來指定創建索引</li><li>col_name為需要創建索引的字段列，該列必須從數據表中該定義的多個列中選擇；</li><li>index_name指定索引的名稱，為可選參數，如果不指定，MYSQL默認col_name為索引值；length為可選參數，表示索引的長度，只有字符串類型的字段才能指定索引長度；</li><li>asc或desc指定升序或降序的索引值存儲</li></ul><h3 class=pgc-h-arrow-right>1、創建表時建立索引</h3><h4 class=pgc-h-arrow-right>（1）創建普通索引</h4><pre><code>create table table_name(    id int(11),    name varchar(20),    sex boolean,    INDEX(id));</code></pre><p>查看錶結構</p><p>show create table table_name;可以使 EXPLAIN 語句查看索引是否被使用</p><pre><code>explain select * from table_name where id = 1\G</code></pre><h4 class=pgc-h-arrow-right>（2）創建唯一索引</h4><pre><code>create table index2(    id int unique,    name varchar(20),    unique INDEX index_2(id asc));</code></pre><h4 class=pgc-h-arrow-right>（3）創建全文索引</h4><p>全文索引只能在char，varchar或者text 類型的字段上。而且，只有MyISAM 儲存引擎支持全文索引。</p><pre><code>create table idnex3(    id int,    info varchar(20),    FULLTEXT INDEX index3_info(info))ENGINE=MyISAM;</code></pre><h4 class=pgc-h-arrow-right>（4）創建單列索引</h4><pre><code>create table index4(    id int,    subject varchar(255),    index index4_st(subject(10)));</code></pre><p>這裡需要注意的，subject 的長度為255，但是index4_st索引只有10。這樣做的目的還是為了提高查詢速度。對於字符型的數據，可以不用查詢全部信息，只查詢其前面的若干字符信息。</p><h4 class=pgc-h-arrow-right>（5）創建多列索引</h4><pre><code>create table index5(    id int,    name varchar(20),    sex char(4),    index index5_ns(name.sex));</code></pre><p>這是我們可以看到，name 和sex字段上已經創建了index_ns索引。</p><h3 class=pgc-h-arrow-right>2、在已經存在的表中創建索引</h3><h4 class=pgc-h-arrow-right>（1）創建普通索引</h4><p>在example0() 表中的id 創建名為index7_id 的索引。</p><pre><code>create index index7_id on example0(id);</code></pre><h4 class=pgc-h-arrow-right>（2）創建唯一索引</h4><pre><code>create UNIQUE index index_name on table_name(name);</code></pre><h4 class=pgc-h-arrow-right>（3）創建全文索引</h4><pre><code>create FULLTEXT index index_name on table_name(info);</code></pre><h4 class=pgc-h-arrow-right>（4）創建單列索引</h4><pre><code>create INDEX index_name ON table_name(name(10));</code></pre><h4 class=pgc-h-arrow-right>（5）創建多列索引</h4><pre><code>create INDEX index_name ON table_name(name,sex);</code></pre><h3 class=pgc-h-arrow-right>3、用alter table 語句來創建索引</h3><h4 class=pgc-h-arrow-right>（1）創建普通索引</h4><p>在name字段上創建名為indx_name 的索引</p><pre><code>alter table table_name ADD INDEX index_name(name(20));</code></pre><h4 class=pgc-h-arrow-right>（2）創建唯一性索引</h4><pre><code>alter table table_name ADD UNIQUE INDEX index_name(id);</code></pre><h4 class=pgc-h-arrow-right>（3）創建全文索引</h4><pre><code>alter table table_name ADD FULLTEXT INDEX index_name(info);</code></pre><h4 class=pgc-h-arrow-right>（4）創建單列索引</h4><pre><code>alter table table_name ADD INDEX index_name(name(4));</code></pre><h4 class=pgc-h-arrow-right>（5）創建多列索引</h4><pre><code>alter tabel table_name ADD INDEX index_name(name.sex);</code></pre><h3 class=pgc-h-arrow-right>4、刪除索引</h3><pre><code>DROP INDEX index_name ON table_name;</code></pre><h2 class=pgc-h-arrow-right>三、索引樹是如何維護的</h2><p>目前大部分數據庫系統及文件系統都採用B-Tree或其變種B+Tree作為索引結構，那麼索引樹是如何維護的？</p><h3 class=pgc-h-arrow-right>1、查找結構進化史</h3><p>查找是數據結構和算法中一個非常重要的概念。</p><ul><li>線性查找：一個個找；實現簡單；太慢</li><li>二分查找：有序；簡單；要求是有序的，插入特別慢</li><li>HASH查找：查詢快；佔用空間；不太適合存儲大規模數據</li><li>二叉查找樹：插入和查詢很快(log(n))；無法存大規模數據，複雜度退化</li><li>平衡樹：解決 BST 退化問題，樹是平衡的；節點非常多的時候，依然樹高很高</li><li>多路查找樹：一個父親多個孩子節點（度）；節點過多樹高不會特別深</li><li>多路平衡查找樹：B-Tree</li></ul><h3 class=pgc-h-arrow-right>2、B-Tree</h3><p>B-Tree是一種多路搜索樹（並不是二叉的）：</p><ol start=1><li>定義任意非葉子結點最多隻有M個兒子；且M>2；</li><li>根結點的兒子數為[2, M]；</li><li>除根結點以外的非葉子結點的兒子數為[M/2, M]；</li><li>每個結點存放至少M/2-1（取上整）和至多M-1個關鍵字；（至少2個關鍵字）</li><li>非葉子結點的關鍵字個數=指向兒子的指針個數-1；</li><li>非葉子結點的關鍵字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非葉子結點的指針：P[1], P[2], …, P[M]；其中P[1]指向關鍵字小於K[1]的<br>子樹，P[M]指向關鍵字大於K[M-1]的子樹，其它P[i]指向關鍵字屬於(K[i-1], K[i])的子樹；</li><li>所有葉子結點位於同一層；</li><li>每個k對應一個data。<br>如：（M=3）相當於一個2–3樹，2–3樹是一個這樣的一棵樹， 它的每個節點要麼有2個孩子和1個數據元素，要麼有3個孩子和2個數據元素，葉子節點沒有孩子，並且有1個或2個數據元素。</li></ol><div class=pgc-img><img alt=從原理到優化，深入淺出數據庫索引 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b59d88e0563642728dd6294e09a8a0af><p class=pgc-img-caption></p></div><p>B-樹的搜索，從根結點開始，對結點內的關鍵字（有序）序列進行二分查找，如果命中則結束，否則進入查詢關鍵字所屬範圍的兒子結點；重複，直到所對應的兒子指針為空，或已經是葉子結點；B-Tree上查找算法的偽代碼如下：</p><pre><code>BTree_Search(node, key) { if(node == null) return null; foreach(node.key) { if(node.key[i] == key) return node.data[i]; if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node); } return BTree_Search(point[i+1]-&gt;node); } data = BTree_Search(root, my_key);</code></pre><h4 class=pgc-h-arrow-right>（1）B-樹的特性</h4><ol start=1><li>關鍵字集合分佈在整顆樹中；</li><li>任何一個關鍵字出現且只出現在一個結點中；</li><li>搜索有可能在非葉子結點結束；</li><li>其搜索性能等價於在關鍵字全集內做一次二分查找；</li><li>自動層次控制；</li></ol><h4 class=pgc-h-arrow-right>（2）B-樹的自控制</h4><p>B樹中每一個內部節點會包含一定數量的鍵值。通常，鍵值的數量被選定在d和2d之間。在實際中，鍵值佔用了節點中大部分的空間。因數2將保證節點可以被拆分或組合。如果一個內部節點有2d個鍵值，那麼添加一個鍵值給此節點的過程，將會拆分2d鍵值為2個d鍵值的節點，並把此鍵值添加給父節點。每一個拆分的節點需要最小數目的鍵值。相似地，如果一個內部節點和他的鄰居兩者都有d個鍵值，那麼將通過它與鄰居的合併來刪除一個鍵值。刪除此鍵值將導致此節點擁有d-1個鍵值;與鄰居的合併則加上d個鍵值，再加上從鄰居節點的父節點移來的一個鍵值。結果為完全填充的2d個鍵值。</p><h4 class=pgc-h-arrow-right>（3）B-樹的構造過程</h4><p>下面是往B樹中依次插入</p><blockquote><p>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</p></blockquote><div class=pgc-img><img alt=從原理到優化，深入淺出數據庫索引 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb08c30da3d7450394d9efdd4e906f4b><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>3、B+Tree</h3><p>B-Tree有許多變種，其中最常見的是B+Tree，MySQL就普遍使用B+Tree實現其索引結構。與B-Tree相比，B+Tree有以下不同點：</p><ol start=1><li>非葉子結點的子樹指針與關鍵字個數相同；</li><li>非葉子結點的子樹指針P[i]，指向關鍵字值屬於[K[i], K[i+1])的子樹（B-樹是開區間）；</li><li>為所有葉子結點增加一個鏈指針；</li><li>所有關鍵字都在葉子結點出現；</li><li>內節點不存儲data，只存儲key<br>如：（M=3）</li></ol><div class=pgc-img><img alt=從原理到優化，深入淺出數據庫索引 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bd53c75103474fc883daa737d96c0a47><p class=pgc-img-caption></p></div><p>B+的搜索與B-樹也基本相同，區別是B+樹只有達到葉子結點才命中（B-樹可以在非葉子結點命中），其性能也等價於在關鍵字全集做一次二分查找；</p><h4 class=pgc-h-arrow-right>（1）B+的特性</h4><ol start=1><li>所有關鍵字都出現在葉子結點的鏈表中（稠密索引），且鏈表中的關鍵字恰好是有序的；</li><li>不可能在非葉子結點命中；</li><li>非葉子結點相當於是葉子結點的索引（稀疏索引），葉子結點相當於是存儲（關鍵字）數據的數據層；</li><li>更適合文件索引系統；</li></ol><h4 class=pgc-h-arrow-right>（2）B+樹的構造過程</h4><p>下面是往B+樹中依次插入</p><blockquote><p>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</p></blockquote><div class=pgc-img><img alt=從原理到優化，深入淺出數據庫索引 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7967b7e0cbd4572b376b4d3da2e64f5><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>3、索引的物理存儲</h3><p>一般來說，索引本身也很大，不可能全部存儲在內存中，因此索引往往以索引文件的形式存儲的磁盤上。</p><p>這樣的話，索引查找過程中就要產生磁盤I/O消耗，相對於內存存取，I/O存取的消耗要高几個數量級，所以評價一個數據結構作為索引的優劣最重要的指標就是在查找過程中磁盤I/O操作次數的漸進複雜度。換句話說，索引的結構組織要儘量減少查找過程中磁盤I/O的存取次數。</p><p>假如每個盤塊可以正好存放一個B樹的結點（正好存放2個文件名）。那麼一個BTNODE結點就代表一個盤塊，而子樹指針就是存放另外一個盤塊的地址。</p><h4 class=pgc-h-arrow-right>（1）模擬B+樹查找過程</h4><p>下面，咱們來模擬下查找文件29的過程：</p><div class=pgc-img><img alt=從原理到優化，深入淺出數據庫索引 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fc4838ddb9e14c6cbca9f686885417c3><p class=pgc-img-caption></p></div><ol start=1><li>根據根結點指針找到文件目錄的根磁盤塊1，將其中的信息導入內存。【磁盤IO操作 1次】</li><li>此時內存中有兩個文件名17、35和三個存儲其他磁盤頁面地址的數據。根據算法我們發現：17&lt;29&lt;35，因此我們找到指針p2。</li><li>根據p2指針，我們定位到磁盤塊3，並將其中的信息導入內存。【磁盤IO操作 2次】</li><li>此時內存中有兩個文件名26，30和三個存儲其他磁盤頁面地址的數據。根據算法我們發現：26&lt;29&lt;30，因此我們找到指針p2。</li><li>根據p2指針，我們定位到磁盤塊8，並將其中的信息導入內存。【磁盤IO操作 3次】</li><li>此時內存中有兩個文件名28，29。根據算法我們查找到文件名29，並定位了該文件內存的磁盤地址。<br>分析上面的過程，發現需要3次磁盤IO操作和3次內存查找操作。關於內存中的文件名查找，由於是一個有序表結構，可以利用折半查找提高效率。至於IO操作是影響整個B樹查找效率的決定因素。<br>當然，如果我們使用平衡二叉樹的磁盤存儲結構來進行查找，磁盤4次，最多5次，而且文件越多，B樹比平衡二叉樹所用的磁盤IO操作次數將越少，效率也越高。</li></ol><h3 class=pgc-h-arrow-right>4、B+tree的優點</h3><h4 class=pgc-h-arrow-right>（1）B+-tree的磁盤讀寫代價更低</h4><p>B+-tree的內部結點並沒有指向關鍵字具體信息的指針。因此其內部結點相對B 樹更小。如果把所有同一內部結點的關鍵字存放在同一盤塊中，那麼盤塊所能容納的關鍵字數量也越多。一次性讀入內存中的需要查找的關鍵字也就越多。相對來說IO讀寫次數也就降低了。舉個例子，假設磁盤中的一個盤塊容納16bytes，而一個關鍵字2bytes，一個關鍵字具體信息指針2bytes。一棵9階B-tree(一個結點最多8個關鍵字)的內部結點需要2個盤快。而B+樹內部結點只需要1個盤快。當需要把內部結點讀入內存中的時候，B 樹就比B+樹多一次盤塊查找時間(在磁盤中就是盤片旋轉的時間)。</p><h4 class=pgc-h-arrow-right>（2）B+-tree的查詢效率更加穩定</h4><p>由於非終結點並不是最終指向文件內容的結點，而只是葉子結點中關鍵字的索引。所以任何關鍵字的查找必須走一條從根結點到葉子結點的路。所有關鍵字查詢的路徑長度相同，導致每一個數據的查詢效率相當。</p><h2 class=pgc-h-arrow-right>四、索引創建有哪些原則</h2><p>索引查詢是數據庫中重要的記錄查詢方法，要不要進入索引以及在那些字段上建立索引都要和實際數據庫系統的查詢要求結合來考慮，下面給出實際中的一些通用的原則：</p><ol start=1><li>在經常用作過濾器的字段上建立索引；</li><li>在SQL語句中經常進行GROUP BY、ORDER BY的字段上建立索引；</li><li>在不同值較少的字段上不必要建立索引，如性別字段；</li><li>對於經常存取的列避免建立索引；</li><li>用於聯接的列（主健/外健）上建立索引；</li><li>在經常存取的多個列上建立複合索引，但要注意複合索引的建立順序要按照使用的頻度來確定；</li><li>缺省情況下建立的是非簇集索引，但在以下情況下最好考慮簇集索引，如：含有有限數目（不是很少）唯一的列；進行大範圍的查詢；充分的利用索引可以減少表掃描I/0的次數，有效的避免對整表的搜索。</li><li>經常用在WHERE子句中的數據列；</li><li>經常出現在關鍵字order by、group by、distinct後面的字段，建立索引。如果建立的是複合索引，索引的字段順序要和這些關鍵字後面的字段順序一致，否則索引不會被使用；</li><li>對於那些查詢中很少涉及的列，重複值比較多的列不要建立索引；</li><li>對於定義為text、image和bit的數據類型的列不要建立索引；</li><li>對於經常存取的列避免建立索引；</li><li>限制表上的索引數目。對一個存在大量更新操作的表，所建索引的數目一般不要超過3個，最多不要超過5個。索引雖說提高了訪問速度，但太多索引會影響數據的更新操作。</li><li>對複合索引，按照字段在查詢條件中出現的頻度建立索引。在複合索引中，記錄首先按照第一個字段排序。對於在第一個字段上取值相同的記錄，系統再按照第二個字段的取值排序，以此類推。因此只有複合索引的第一個字段出現在查詢條件中，該索引才可能被使用,因此將應用頻度高的字段，放置在複合索引的前面，會使系統最大可能地使用此索引，發揮索引的作用。</li></ol><h3 class=pgc-h-arrow-right>1、組合多個索引</h3><p>一個單獨的索引掃描只能用於這樣的條件子句：使用被索引字段和索引操作符類中的操作符， 並且這些條件以AND連接。</p><p>假設在(a, b)上有一個索引， 那麼類似WHERE a = 5 AND b = 6的條件可以使用索引，但是像WHERE a = 5 OR b = 6的條件就不能直接使用索引。</p><p>一個類似WHERE x =42 OR x = 47 OR x = 53 OR x = 99 這樣的查詢可以分解成四個在x上的獨立掃描，每個掃描使用一個條件， 最後將這些掃描的結果OR 在一起，生成最終結果。</p><p>另外一個例子是，如果我們在x 和y上有獨立的索引，一個類似WHERE x = 5 AND y = 6 這樣的查詢可以分解為幾個使用獨立索引的子句，然後把這幾個結果AND 在一起，生成最終結果。</p><h2 class=pgc-h-arrow-right>五、索引失效有哪幾種情況</h2><ol start=1><li>如果條件中有or，即使其中有條件帶索引也不會使用(這也是為什麼儘量少用or的原因)</li><li>對於多列索引，不是使用的第一部分(第一個)，則不會使用索引</li><li>like查詢是以%開頭</li><li>如果列類型是字符串，那一定要在條件中將數據使用引號引用起來,否則不使用索引</li><li>如果mysql估計使用全表掃描要比使用索引快,則不使用索引</li></ol><h3 class=pgc-h-arrow-right>1、聯合索引失效的條件</h3><p>聯合索引又叫複合索引。兩個或更多個列上的索引被稱作複合索引。</p><p>對於複合索引：Mysql從左到右的使用索引中的字段，一個查詢可以只使用索引中的一部份，但只能是最左側部分。例如索引是key index （a,b,c）。 可以支持a | a,b| a,b,c 3種組合進行查找，但不支持 b,c進行查找 .當最左側字段是常量引用時，索引就十分有效。</p><p>所以說創建複合索引時，應該仔細考慮列的順序。對索引中的所有列執行搜索或僅對前幾列執行搜索時，複合索引非常有用；僅對後面的任意列執行搜索時，複合索引則沒有用處。</p><h2 class=pgc-h-arrow-right>六、如何查看索引的使用情況</h2><p>這裡記錄兩種方式，分別是</p><h3 class=pgc-h-arrow-right>1、使用Handler_read查看索引的使用情況</h3><pre><code>show status like ‘Handler_read%';</code></pre><p>大家可以注意：</p><ul><li>handler_read_key:這個值越高越好，越高表示使用索引查詢到的次數</li><li>handler_read_rnd_next:這個值越高，說明查詢低效</li></ul><pre><code>+-----------------------+--------------+| Variable_name         | Value        |+-----------------------+--------------+| Handler_read_first    | 153      || Handler_read_key      | 364   || Handler_read_next     | 425    || Handler_read_prev     | 598     || Handler_read_rnd      | 605     || Handler_read_rnd_next | 860571 |+-----------------------+--------------+6 rows in set (0.00 sec)————————————————</code></pre><p>分析這幾個值，我們可以查看當前索引的使用情況：</p><ul><li>Handler_read_first：索引中第一條被讀的次數。如果較高，它表示服務器正執行大量全索引掃描；例如，SELECT col1 FROM foo，假定col1有索引（這個值越低越好）。</li><li>Handler_read_key：如果索引正在工作，這個值代表一個行被索引值讀的次數，如果值越低，表示索引得到的性能改善不高，因為索引不經常使用（這個值越高越好）。</li><li>Handler_read_next ：按照鍵順序讀下一行的請求數。如果你用範圍約束或如果執行索引掃描來查詢索引列，該值增加。</li><li>Handler_read_prev：按照鍵順序讀前一行的請求數。該讀方法主要用於優化ORDER BY ... DESC。</li><li>Handler_read_rnd ：根據固定位置讀一行的請求數。如果你正執行大量查詢並需要對結果進行排序該值較高。你可能使用了大量需要MySQL掃描整個表的查詢或你的連接沒有正確使用鍵。這個值較高，意味著運行效率低，應該建立索引來補救。</li><li>Handler_read_rnd_next：在數據文件中讀下一行的請求數。如果你正進行大量的表掃描，該值較高。通常說明你的表索引不正確或寫入的查詢沒有利用索引。</li></ul><h3 class=pgc-h-arrow-right>2、在sys庫中查看沒用的索引</h3><p>查詢 schema_unused_indexes庫。</p><pre><code>root@localhost [sys]&gt;select * from schema_unused_indexes;+-------------------+-------------+------------+| object_schema     | object_name | index_name |+-------------------+-------------+------------+| sysbench_testdata | sbtest1     | k_1        || sysbench_testdata | sbtest10    | k_10       || sysbench_testdata | sbtest3     | k_3        || sysbench_testdata | sbtest4     | k_4        || sysbench_testdata | sbtest5     | k_5        || sysbench_testdata | sbtest6     | k_6        || sysbench_testdata | sbtest7     | k_7        || sysbench_testdata | sbtest8     | k_8        || sysbench_testdata | sbtest9     | k_9        |+-------------------+-------------+------------+9 rows in set (0.00 sec)</code></pre><h2 class=pgc-h-arrow-right>七、EXPLAIN解釋命令查看索引是否生效</h2><p>explain顯示了mysql如何使用索引來處理select語句以及連接表。可以幫助選擇更好的索引和寫出更優化的查詢語句。</p><h3 class=pgc-h-arrow-right>1、一個實際例子</h3><p>新建一張表，</p><pre><code>CREATE TABLE IF NOT EXISTS `article` (`id` int(10) unsigned NOT NULL AUTO_INCREMENT,`author_id` int(10) unsigned NOT NULL,`category_id` int(10) unsigned NOT NULL,`views` int(10) unsigned NOT NULL,`comments` int(10) unsigned NOT NULL,`title` varbinary(255) NOT NULL,`content` text NOT NULL,PRIMARY KEY (`id`));</code></pre><p>執行查詢，</p><pre><code>EXPLAINSELECT author_idFROM `article`WHERE category_id = 1 AND comments &gt; 1ORDER BY views DESCLIMIT 1</code></pre><p>響應數據如下，</p><pre><code>*************************** 1. row ***************************           id: 1  select_type: SIMPLE        table: article         type: ALLpossible_keys: NULL          key: NULL      key_len: NULL          ref: NULL         rows: 3        Extra: Using where; Using filesort1 row in set (0.00 sec)</code></pre><p>type 是 ALL,即最壞的情況。Extra 裡還出現了 Using filesort,也是最壞的情況。</p><h3 class=pgc-h-arrow-right>2、EXPLAIN列的解釋：</h3><ul><li>table：顯示這一行的數據是關於哪張表的</li><li>type：這是重要的列，顯示連接使用了何種類型。從最好到最差的連接類型為const、eq_reg、ref、range、indexhe和ALL</li><li>possible_keys：顯示可能應用在這張表中的索引。如果為空，沒有可能的索引。可以為相關的域從WHERE語句中選擇一個合適的語句</li><li>key： 實際使用的索引。如果為NULL，則沒有使用索引。很少的情況下，MYSQL會選擇優化不足的索引。這種情況下，可以在SELECT語句中使用USE INDEX（indexname）來強制使用一個索引或者用IGNORE INDEX（indexname）來強制MYSQL忽略索引</li><li>key_len：使用的索引的長度。在不損失精確性的情況下，長度越短越好</li><li>ref：顯示索引的哪一列被使用了，如果可能的話，是一個常數</li><li>rows：MYSQL認為必須檢查的用來返回請求數據的行數</li><li>Extra：關於MYSQL如何解析查詢的額外信息。將在表4.3中討論，但這裡可以看到的壞的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，結果是檢索會很慢</li></ul><h3 class=pgc-h-arrow-right>3、type返回結果的解釋</h3><p>MySQL 在表裡找到所需行的方式。包括（由左至右，由最差到最好）：| All | index | range | ref | eq_ref | const,system | null |</p><ul><li>system 表只有一行：system表。這是const連接類型的特殊情況</li><li>const:表中的一個記錄的最大值能夠匹配這個查詢（索引可以是主鍵或惟一索引）。因為只有一行，這個值實際就是常數，因為MYSQL先讀這個值然後把它當做常數來對待</li><li>eq_ref:在連接中，MYSQL在查詢時，從前面的表中，對每一個記錄的聯合都從表中讀取一個記錄，它在查詢使用了索引為主鍵或惟一鍵的全部時使用</li><li>ref:這個連接類型只有在查詢使用了不是惟一或主鍵的鍵或者是這些類型的部分（比如，利用最左邊前綴）時發生。對於之前的表的每一個行聯合，全部記錄都將從表中讀出。這個類型嚴重依賴於根據索引匹配的記錄多少—越少越好</li><li>range:這個連接類型使用索引返回一個範圍中的行，比如使用>或&lt;查找東西時發生的情況</li><li>index: 這個連接類型對前面的表中的每一個記錄聯合進行完全掃描（比ALL更好，因為索引一般小於表數據）</li><li>ALL:這個連接類型對於前面的每一個記錄聯合進行完全掃描，這一般比較糟糕，應該儘量避免</li></ul><h3 class=pgc-h-arrow-right>4、extra列返回的描述的意義</h3><ul><li>Distinct:一旦MYSQL找到了與行相聯合匹配的行，就不再搜索了</li><li>Not exists: MYSQL優化了LEFT JOIN，一旦它找到了匹配LEFT JOIN標準的行，就不再搜索了</li><li>Range checked for each Record（index map:#）:沒有找到理想的索引，因此對於從前面表中來的每一個行組合，MYSQL檢查使用哪個索引，並用它來從表中返回行。這是使用索引的最慢的連接之一</li><li>Using filesort: 看到這個的時候，查詢就需要優化了。MYSQL需要進行額外的步驟來發現如何對返回的行排序。它根據連接類型以及存儲排序鍵值和匹配條件的全部行的行指針來排序全部行</li><li>Using index: 列數據是從僅僅使用了索引中的信息而沒有讀取實際的行動的表返回的，這發生在對錶的全部的請求列都是同一個索引的部分的時候</li><li>Using temporary 看到這個的時候，查詢需要優化了。這裡，MYSQL需要創建一個臨時表來存儲結果，這通常發生在對不同的列集進行ORDER BY上，而不是GROUP BY上</li><li>Using where 使用了WHERE從句來限制哪些行將與下一張表匹配或者是返回給用戶。如果不想返回表中的全部行，並且連接類型ALL或index，這就會發生，或者是查詢有問題不同連接類型的解釋（按照效率高低的順序排序）</li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>優化</a></li><li><a>淺出</a></li><li><a>數據庫</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cff66554.html alt=深入淺出數據庫索引 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/413ce62658ef4b99963ef4043863560e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cff66554.html title=深入淺出數據庫索引>深入淺出數據庫索引</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/e65a0b90.html alt=數據庫的性能優化的一些思考 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/e65a0b90.html title=數據庫的性能優化的一些思考>數據庫的性能優化的一些思考</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html alt="深度研究自然梯度優化，從入門到放棄 | Deep Reading" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2cc1b8ef47a5458190c22d26d8bd164c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html title="深度研究自然梯度優化，從入門到放棄 | Deep Reading">深度研究自然梯度優化，從入門到放棄 | Deep Reading</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html alt=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html title=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理>解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e18864df.html alt=深入淺出西門子PLC連載一：西門子S7-300/400通信功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d2fa4bebce394c979e42408cab824fdb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e18864df.html title=深入淺出西門子PLC連載一：西門子S7-300/400通信功能>深入淺出西門子PLC連載一：西門子S7-300/400通信功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18681b55.html alt=PHP鏈接數據庫操作教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3b10e2d3b35043f8ae9cb1823878b66a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18681b55.html title=PHP鏈接數據庫操作教程>PHP鏈接數據庫操作教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e1b3755.html alt=裝完系統必做的優化，更改用戶文件和軟件安裝默認路徑，你知道嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d349042865d40cf9b8f1e91e2537426 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e1b3755.html title=裝完系統必做的優化，更改用戶文件和軟件安裝默認路徑，你知道嗎>裝完系統必做的優化，更改用戶文件和軟件安裝默認路徑，你知道嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86bb40ab.html alt=深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RFHu4Sf9eDhDDd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86bb40ab.html title=深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸>深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0518503.html alt=優化營商環境“大家談”︱擔當職責使命，貢獻公安力量 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RHnAsqqAQHVKXV style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0518503.html title=優化營商環境“大家談”︱擔當職責使命，貢獻公安力量>優化營商環境“大家談”︱擔當職責使命，貢獻公安力量</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3e06bc8.html alt=熱血傳奇的第二個數據庫，怪物數據庫參數值解析教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/875b193ef0954c6286e409e03cff93de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3e06bc8.html title=熱血傳奇的第二個數據庫，怪物數據庫參數值解析教程>熱血傳奇的第二個數據庫，怪物數據庫參數值解析教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b87553dc.html alt=LevelDB深入淺出之整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/125e826e651c48c3911abad6c8d076c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b87553dc.html title=LevelDB深入淺出之整體架構>LevelDB深入淺出之整體架構</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>