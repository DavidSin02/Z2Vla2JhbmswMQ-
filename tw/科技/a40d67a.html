<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>分佈式系統核心問題 | 极客快訊</title><meta property="og:title" content="分佈式系統核心問題 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/30bfbd168e6c49cbbc8ebb388f55b997"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a40d67a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a40d67a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a40d67a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a40d67a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a40d67a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a40d67a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a40d67a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a40d67a.html><meta property="article:published_time" content="2020-10-29T21:05:05+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:05+08:00"><meta name=Keywords content><meta name=description content="分佈式系統核心問題"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a40d67a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>分佈式系統核心問題</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>分佈式系統核心問題</p><p>隨著摩爾定律遇到瓶頸，越來越多情況下要依靠分佈式架構，才能實現海量數據處理能力和可擴展計算能力。</p><p>區塊鏈系統，首先是一個分佈式系統。傳統單節點結構演變到分佈式系統，碰到的首要問題就是一致性的保障。很顯然，如果分佈式集群無法保證處理結果一致的話，那任何建立於其上的業務系統都無法正常工作。</p><p>本文將介紹分佈式系統領域的核心問題，包括一致性、共識的定義，基本的原理和算法，另外還介紹了評估分佈式系統可靠性的指標。</p><p><br></p><p><strong>一、一致性問題</strong></p><p>一致性問題是分佈式領域最為基礎也是最重要的問題。如果分佈式系統能實現“一致”，對外就可以呈現為一個完美的、可擴展的“虛擬節點”，相對物理節點具備更優越性能和穩定性。這也是分佈式系統希望能實現的最終目標。</p><p><strong>1.1、定義與重要性</strong></p><p>定義：一致性（consistency），早期也叫agreement，是指對於分佈式系統中的多個服務節點，給定一系列操作，在約定協議的保障下，試圖使得它們對處理結果達成“某種程度”的認同。</p><p>理想情況下，如果各個服務節點嚴格遵循相同的處理協議，構成相同的處理狀態機，給定相同的初始狀態和輸入序列，則可以保障在處理過程中的每個環節的結果都是相同的。</p><p>那麼，為什麼說一致性問題十分重要呢？</p><p>舉個現實生活中的例子，多個售票處同時出售某線路上的火車票，該線路上存在多個經停站，怎麼才能保證在任意區間都不會出現超售（同一個座位賣給兩個人）的情況呢？</p><p>這個問題看起來似乎沒那麼難，現實生活中經常通過分段分站售票的機制。然而，為了支持海量的用戶和避免出現錯誤，存在很多設計和實現上的挑戰。特別在計算機的世界裡，為了達到遠超普通世界的高性能和高可擴展性需求，問題會變得更為複雜。</p><p>注意：一致性並不代表結果正確與否，而是系統對外呈現的狀態一致與否；例如，所有節點都達成失敗狀態也是一種一致。</p><p><strong>1.2、問題與挑戰</strong></p><p>看似強大的計算機系統，實際上很多地方都比人類世界要脆弱得多。特別是在分佈式計算機集群系統中，如下幾個方面很容易出現問題：</p><p>節點之間的網絡通信是不可靠的，包括消息延遲、亂序和內容錯誤等；</p><p>節點的處理時間無法保障，結果可能出現錯誤，甚至節點自身可能發生宕機；</p><p>同步調用可以簡化設計，但會嚴重降低分佈式系統的可擴展性，甚至使其退化為單點系統。</p><p>仍以火車票售賣問題為例，願意動腦筋的讀者可能已經想到了一些不錯的解決思路，例如：</p><p>要出售任意一張票前，先打電話給其他售票處，確認下當前這張票不衝突。即通過同步調用來避免衝突；</p><p>多個售票處提前約好隔離的售票時間。比如第一家可以在上午8點到9點期間賣票，接下來一個小時是另外一家……即通過令牌機制來避免衝突；</p><p>成立一個第三方的存票機構，票集中存放，每次賣票前找存票機構查詢。此時問題退化為中心化單點系統。</p><p>當然，還會有更多方案。</p><p>實際上，這些方案背後的思想，都是將可能引發不一致的並行操作進行串行化。這實際上也是現代分佈式系統處理一致性問題的基礎思路。只是因為現在的計算機系統應對故障往往不夠“智能”，而人們又希望系統可以更快更穩定地工作，所以實際可行的方案需要更加全面和更加高效。</p><p>注意：這些思路都沒有考慮請求和答覆消息出現失敗的情況，同時假設每個售票處的售票機制是正常工作的。</p><p><strong>1.3、一致性要求</strong></p><p>規範地說，分佈式系統達成一致的過程，應該滿足：</p><p>可終止性（termination）：一致的結果在有限時間內能完成；</p><p>約同性（agreement）：不同節點最終完成決策的結果是相同的；</p><p>合法性（validity）：決策的結果必須是某個節點提出的提案；</p><p>可終止性很容易理解。有限時間內完成，意味著可以保障提供服務（liveness）。這是計算機系統可以被正常使用的前提。需要注意，在現實生活中這點並不是總能得到保障的。例如取款機有時候會出現“服務中斷”；撥打電話有時候是“無法連接”的。</p><p>約同性看似容易，實際上暗含了一些潛在信息。決策的結果相同，意味著算法要麼不給出結果，任何給出的結果必定是達成了共識的，即安全性（safety）。挑戰在於算法必須要考慮的是可能會處理任意的情形。凡事一旦推廣到任意情形，往往就不像看起來那麼簡單。例如現在就剩一張某區間（如北京–>南京）的車票了，兩個售票處也分別剛通過某種方式確認過這張票的存在。這時，兩家售票處幾乎同時分別來了一個乘客要買這張票，從各自“觀察”看來，自己一方的乘客都是先到的……這種情況下，怎麼能達成對結果的共識呢？看起來很容易，賣給物理時間上率先提交請求的乘客即可。然而，對於兩個來自不同位置的請求來說，要判斷在時間上的“先後”關係並不是那麼容易。兩個車站的時鐘可能是不一致的；可能無法記錄下足夠精確的時間；更何況根據相對論的觀點，並不存在絕對的時空觀。</p><p>可見，事件發生的先後順序十分重要，這也是解決分佈式系統領域很多問題的核心祕訣：把多件事情進行排序，而且這個順序還得是大家都認可的。</p><p>最後一個合法性看似繞口，但是其實比較容易理解，即達成的結果必須是節點執行操作的結果。仍以賣票為例，如果兩個售票處分別決策某張票出售給張三和李四，那麼最終達成一致的結果要麼是張三，要麼是李四，而絕對不能是其他人。</p><p><strong>1.4、帶約束的一致性</strong></p><p>從前面的分析可以看到，要實現絕對理想的嚴格一致性（strict consistency）代價很大。除非系統不發生任何故障，而且所有節點之間的通信無需任何時間，這個時候整個系統其實就等價於一臺機器了。實際上，越強的一致性要求往往會造成越弱的處理性能，以及越差的可擴展性。</p><p>一般來講，強一致性（strong consistency）主要包括下面兩類：</p><p>順序一致性（sequential consistency）：Leslie Lamport在1979年的經典論文《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》中提出，是一種比較強的約束，保證所有進程看到的全局執行順序（total order）一致，並且每個進程看自身的執行順序（local order）跟實際發生順序一致。例如，某進程先執行A，後執行B，則實際得到的全局結果中就應該為A在B前面，而不能反過來。同時所有其他進程在全局上也應該看到這個順序。順序一致性實際上限制了各進程內指令的偏序關係，但不在進程間按照物理時間進行全局排序；</p><p>線性一致性（linearizability consistency）：Maurice P.Herlihy與Jeannette M.Wing在1990年的經典論文《Linearizability：A Correctness Condition for Concurrent Objects》中共同提出，在順序一致性前提下加強了進程間的操作排序，形成唯一的全局順序（系統等價於是順序執行，所有進程看到的所有操作的序列順序都一致，並且跟實際發生順序一致），是很強的原子性保證。但是比較難實現，目前基本上要麼依賴於全局的時鐘或鎖，要麼通過一些複雜算法實現，性能往往不高。</p><p>實現強一致性往往需要準確的計時設備。高精度的石英鐘的偏移率為10的-7次方，最準確的原子震盪時鐘的偏移率為10的負13次方。Google曾在其分佈式數據庫Spanner中採用基於原子時鐘和GPS的“TrueTime”方案，能夠將不同數據中心的時間偏差控制在10ms以內。方案簡單粗暴而且有效，但存在成本較高的問題。</p><p>由於強一致性的系統往往比較難實現，而且很多時候，實際需求並沒有那麼嚴格需要強一致性。因此，可以適當地放寬對一致性的要求，從而降低系統實現的難度。例如在一定約束下實現所謂最終一致性（eventual consistency），即總會存在一個時刻（而不是立刻），讓系統達到一致的狀態。大部分Web系統實現的都是最終一致性。相對強一致性，這一類在某些方面弱化的一致性都籠統稱為弱一致性（weak consistency）。</p><p><strong>二、共識算法</strong></p><p>共識（consensus）在很多時候會與一致性（consistency）術語放在一起討論。嚴謹地講，兩者的含義並不完全相同。</p><p>一致性往往指分佈式系統中多個副本對外呈現的數據的狀態。如前面提到的順序一致性、線性一致性，描述了多個節點對數據狀態的維護能力。而共識則描述了分佈式系統中多個節點之間，彼此對某個狀態達成一致結果的過程。因此，一致性描述的是結果狀態，共識則是一種手段。達成某種共識並不意味著就保障了一致性。</p><p>實踐中，要保障系統滿足不同程度的一致性，核心過程往往需要通過共識算法來達成。</p><p>共識算法解決的是對某個提案（proposal）大家達成一致意見的過程。提案的含義在分佈式系統中十分寬泛，如多個事件發生的順序、某個鍵對應的值、誰是領導……等等。可以認為任何可以達成一致的信息都是一個提案。對於分佈式系統來講，各個節點通常都是相同的確定性狀態機模型（又稱為狀態機複製問題，state-machine replication），從相同初始狀態開始接收相同順序的指令，則可以保證相同的結果狀態。因此，系統中多個節點最關鍵的是對多個事件的順序進行共識，即排序。</p><p><strong>2.1、問題與挑戰</strong></p><p>實際上，如果分佈式系統中各個單節點都能保證以十分“理想”的性能（瞬間響應、超高吞吐）無故障地運行，節點之間通信瞬時送達，則實現共識過程並不十分複雜，簡單地通過廣播進行瞬時投票和應答即可。</p><p>可惜的是，現實中這樣的“理想”系統並不存在。不同節點之間通信存在延遲（光速物理限制，通信處理延遲），並且任意環節都可能存在故障（系統規模越大，發生故障可能性越高）。如通信網絡會發生中斷、節點會發生故障、甚至存在惡意節點故意要偽造消息，破壞系統的正常工作流程。</p><p>一般地，把出現故障（crash或fail-stop，即不響應）但不會偽造信息的情況稱為“非拜占庭錯誤”（non-byzantine fault）或“故障錯誤”（Crash Fault）；偽造信息惡意響應的情況稱為“拜占庭錯誤”（Byzantine Fault），對應節點為拜占庭節點。</p><p><strong>2.2、常見算法</strong></p><p>根據解決的是非拜占庭的普通錯誤情況還是拜占庭錯誤情況，共識算法可以分為Crash Fault Tolerance（CFT）類算法和Byzantine Fault Tolerance（BFT）類算法。</p><p>針對常見的非拜占庭錯誤的情況，已經存在一些經典的解決算法，包括Paxos、Raft及其變種等。這類容錯算法往往性能比較好，處理較快，容忍不超過一半的故障節點。</p><p>對於要能容忍拜占庭錯誤的情況，一般包括PBFT（Practical Byzantine Fault Tolerance）為代表的確定性系列算法、PoW為代表的概率算法等。對於確定性算法，一旦達成對某個結果的共識就不可逆轉，即共識是最終結果；而對於概率類算法，共識結果則是臨時的，隨著時間推移或某種強化，共識結果被推翻的概率越來越小，成為事實上的最終結果。拜占庭類容錯算法往往性能較差，容忍不超過1/3的故障節點。</p><p>此外，XFT（Cross Fault Tolerance）等最近提出的改進算法可以提供類似CFT的處理響應速度，並能在大多數節點正常工作時提供BFT保障。</p><p>注意：實踐中，一致性的結果往往還需要客戶端的額外支持，典型情況如通過訪問足夠多個服務節點來比對驗證，確保獲取共識後的正確結果。</p><p><strong>2.3、理論界限</strong></p><p>數學家都喜歡對問題先確定一個最壞的理論界限。那麼，共識問題的最壞界限在哪裡呢？很不幸，在推廣到任意情形時，分佈式系統的共識問題無通用解。這似乎很容易理解，當多個節點之間的通信網絡自身不可靠的情況下，很顯然，無法確保實現共識（例如，所有涉及共識的消息都在網絡上丟失）。那麼，對於一個設計得當，可以大概率保證消息正確送達的網絡，是不是就一定能保證達成共識呢？</p><p>科學家們證明，即便在網絡通信可靠情況下，可擴展的分佈式系統的共識問題，其通用解法的理論下限是——沒有下限（無解）。</p><p>這個結論稱為“FLP不可能原理”。該原理極其重要，可以看做是分佈式領域裡的“測不準原理”。</p><p>提示：不僅在分佈式系統領域，實際上在很多領域都存在類似“測不準原理”的約束。</p><p><strong>三、FLP不可能原理</strong></p><p><strong>3.1、定義</strong></p><p>FLP不可能原理：在網絡可靠，但允許節點失效（即便只有一個）的最小化異步模型系統中，不存在一個可以解決一致性問題的確定性共識算法（No completely asynchronous consensus protocol can tolerate even a single unannounced process death）。</p><p>提出並證明該定理的論文《Impossibility of Distributed Consensus with One Faulty Process》由Fischer、Lynch和Patterson三位科學家於1985年發表，該論文後來獲得了Dijkstra（就是發明最短路徑算法的那位計算機科學家）獎。</p><p>FLP不可能原理實際上告訴人們，不要浪費時間，去為異步分佈式系統設計在任意場景下都能實現共識的算法。</p><p><strong>3.2、正確理解</strong></p><p>要正確理解FLP不可能原理，首先要弄清楚“異步”的含義。</p><p>在分佈式系統中，同步和異步這兩個術語存在特殊的含義。</p><p>同步是指系統中的各個節點的時鐘誤差存在上限；並且消息傳遞必須在一定時間內完成，否則認為失敗；同時各個節點完成處理消息的時間是一定的。對於同步系統，可以很容易地判斷消息是否丟失。</p><p>異步是指系統中各個節點可能存在較大的時鐘差異，同時消息傳輸時間是任意長的，各節點對消息進行處理的時間也可能是任意長的，這就造成無法判斷某個消息遲遲沒有被響應是哪裡出了問題（節點故障還是傳輸故障？）。不幸地是，現實生活中的系統往往都是異步系統。</p><p>FLP不可能性在原始論文中以圖論的形式進行了嚴格證明。要理解這一基本原理並不複雜，一個不嚴謹的例子如下。</p><p>三個人在不同房間進行投票（投票結果是0或者1）。彼此可以通過電話進行溝通，但經常有人會時不時睡著。比如某個時候，A投票0，B投票1，C收到了兩人的投票，然後C睡著了。此時，A和B將永遠無法在有限時間內獲知最終的結果，究竟是C沒有應答還是應答的時間過長。如果可以重新投票，則類似情形可以在每次取得結果前發生，這將導致共識過程永遠無法完成。</p><p>FLP原理實際上說明對於允許節點失效情況下，純粹異步系統無法確保一致性在有限時間內完成。即便對於非拜占庭錯誤的前提下，包括Paxos、Raft等算法也都存在無法達成共識的情況，只是在工程實踐中這種情況出現的概率很小。</p><p>那麼，FLP不可能原理是否意味著研究共識算法壓根沒有意義？</p><p>先別這麼悲觀。學術界做研究，往往考慮地是數學和物理意義上最極端的情形，很多時候現實生活要美好得多（感謝這個世界如此魯棒！）。例如，上面例子中描述的最壞情形，每次都發生的概率其實並沒有那麼大。工程實現上多嘗試幾次，很大可能就成功了</p><p>科學告訴你什麼是不可能的；工程則告訴你，付出一些代價，可以把它變成可行。這就是科學和工程不同的魅力。</p><p>那麼，退一步講，在付出一些代價的情況下，我們在共識的達成上，能做到多好？回答這一問題的是另一個很出名的原理：CAP原理。</p><p>提示：科學告訴你去賭場賭博從概率上總會是輸錢的；工程則告訴你，如果你願意接受最終輸錢的風險，中間說不定能偶爾小贏幾筆呢！</p><p><strong>四、CAP原理</strong></p><p>CAP原理最早是2000年由Eric Brewer在ACM組織的一個研討會上提出猜想，後來Lynch等人進行了證明。該原理被認為是分佈式系統領域的重要原理之一。</p><p><strong>4.1、定義</strong></p><p>CAP原理：分佈式計算系統不可能同時確保以下三個特性：一致性（Consistency）、可用性（Availability）和分區容忍性（Partition），設計中往往需要弱化對某個特性的保證。</p><p>這裡，一致性、可用性和分區容忍性的含義如下：</p><p>一致性：任何操作應該都是原子的，發生在後面的事件能看到前面事件發生導致的結果，注意這裡指的是強一致性；</p><p>可用性：在有限時間內，任何非失敗節點都能應答請求；</p><p>分區容忍性：網絡可能發生分區，即節點之間的通信不可保障。</p><p>比較直觀地理解如下，當網絡可能出現分區的時候，系統是無法同時保證一致性和可用性的。要麼，節點收到請求後因為沒有得到其他節點的確認而不應答（犧牲可用性），要麼節點只能應答非一致的結果（犧牲一致性）。</p><p>由於大多數時候網絡被認為是可靠的，因此係統可以提供一致可靠的服務；當網絡不可靠時，系統要麼犧牲掉一致性（多數場景下），要麼犧牲掉可用性。</p><p>注意：網絡分區是可能存在的，出現分區情況後很可能會導致發生“腦裂”，多個新出現的主節點可能會嘗試關閉其他主節點。</p><p><strong>4.2、應用場景</strong></p><p>既然CAP三種特性不可同時得到保障，則設計系統時必然要弱化對某個特性的支持。那麼可能出現下面三個應用場景。</p><p>1、弱化一致性</p><p>對結果一致性不敏感的應用，可以允許在新版本上線後過一段時間才最終更新成功，期間不保證一致性。例如網站靜態頁面內容、實時性較弱的查詢類數據庫等，簡單分佈式同步協議如Gossip，以及CouchDB、Cassandra數據庫等，都是為此設計的。</p><p>2、弱化可用性</p><p>對結果一致性很敏感的應用，例如銀行取款機，當系統故障時候會拒絕服務。MongoDB、Redis、MapReduce等是為此設計的。Paxos、Raft等共識算法，主要處理這種情況。在Paxos類算法中，可能存在著無法提供可用結果的情形，同時允許少數節點離線。</p><p>3、弱化分區容忍性</p><p>現實中，網絡分區出現概率較小，但較難完全避免。兩階段的提交算法，某些關係型數據庫及ZooKeeper主要考慮了這種設計。實踐中，網絡可以通過雙通道等機制增強可靠性，達到高穩定的網絡通信。</p><p><strong>五、ACID原則</strong></p><p>ACID原則指的是：Atomicity（原子性）、Consistency（一致性）、Isolation（隔離性）、Durability（持久性），用了四種特性的縮寫。</p><p>ACID也是一種比較出名的描述一致性的原則，通常出現在分佈式數據庫領域。具體來說，ACID原則描述了分佈式數據庫需要滿足的一致性需求，同時允許付出可用性的代價。</p><p>ACID特徵如下：</p><p>Atomicity：每次操作是原子的，要麼成功，要麼不執行；</p><p>Consistency：數據庫的狀態是一致的，無中間狀態；</p><p>Isolation：各種操作彼此之間互相不影響；</p><p>Durability：狀態的改變是持久的，不會失效。</p><p>與ACID相對的一個原則是BASE（Basic Availability，Soft-state，Eventual Consistency）原則，犧牲掉對一致性的約束（但實現最終一致性），來換取一定的可用性。</p><p>注意：ACID和BASE在英文中分別是“酸”和“鹼”，看似對立，實則是分別對CAP三特性的不同取捨。</p><p><strong>六、Paxos算法與Raft算法</strong></p><p>Paxos問題是指分佈式的系統中存在故障（crash fault），但不存在惡意（corrupt）節點的場景（即可能消息丟失或重複，但無錯誤消息）下的共識達成問題。這也是分佈式共識領域最為常見的問題。解決Paxos問題的算法主要有Paxos系列算法和Raft算法。</p><p><strong>6.1、Paxos算法</strong></p><p>1990年由Leslie Lamport在論文《The Part-time Parliament》中提出的Paxos共識算法，在工程角度實現了一種最大化保障分佈式系統一致性（存在極小的概率無法實現一致）的機制。Paxos算法被廣泛應用在Chubby、ZooKeeper這樣的分佈式系統中。Leslie Lamport作為分佈式系統領域的早期研究者，因為相關成果獲得了2013年度圖靈獎。</p><p>故事背景是古希臘Paxon島上的多個法官在一個大廳內對一個議案進行表決，如何達成統一的結果。他們之間通過服務人員來傳遞紙條，但法官可能離開或進入大廳，服務人員可能偷懶去睡覺。</p><p>Paxos是第一個廣泛應用的共識算法，其原理基於“兩階段提交”算法並進行泛化和擴展，通過消息傳遞來逐步消除系統中的不確定狀態，是後來不少共識算法（如Raft、ZAB等）設計的基礎。Paxos算法基本思想並不複雜，但最初論文描述得比較難懂，後來在2001年Leslie Lamport還專門寫了論文《Paxos Made Simple》予以解釋。</p><p>算法的基本原理是將節點分為三種邏輯角色，在實現上同一個節點可以擔任多個角色：</p><p>Proposer（提案者）：提出一個提案，等待大家批准（chosen）為結案（value）。系統中提案都擁有一個自增的唯一提案號。往往由客戶端擔任該角色；</p><p>Acceptor（接受者）：負責對提案進行投票，接受（accept）提案。往往由服務端擔任該角色；</p><p>Learner（學習者）：獲取批准結果，並可以幫忙傳播，不參與投票過程。可能為客戶端或服務端。</p><p>算法需要滿足Safety和Liveness兩方面的約束要求。實際上這兩個基礎屬性也是大部分分佈式算法都該考慮的：</p><p><strong>Safety約束：</strong></p><p>保證決議（value）結果是對的，無歧義的，不會出現錯誤情況。</p><p>只有是被Proposers提出的提案才可能被最終批准；</p><p>在一次執行中，只批准（chosen）一個最終決議。被多數接受（accept）的結果成為決議；</p><p><strong>Liveness約束：</strong></p><p>保證決議過程能在有限時間內完成。</p><p>決議總會產生，並且學習者能獲得被批准的決議。</p><p>基本過程是多個提案者先爭取到提案的權利（得到大多數接受者的支持）；得到提案權利的提案者發送提案給所有人進行確認，得到大部分人確認的提案成為批准的結案。</p><p>Paxos不保證系統隨時處在一致的狀態。但由於每次達成一致的過程中至少有超過一半的節點參與，這樣最終整個系統都會獲知共識的結果。一個潛在的問題是Proposer在此過程中出現故障，可以通過超時機制來解決。極為湊巧的情況下，每次新一輪提案的Proposer都恰好故障，又或者兩個Proposer恰好依次提出更新的提案，則導致活鎖，系統永遠無法達成一致（實際發生概率很小）。</p><p>Paxos能保證在超過一半的節點正常工作時，系統總能以較大概率達成共識。讀者可以試著自己設計一套非拜占庭容錯下基於消息傳遞的異步共識方案，會發現在滿足各種約束情況下，算法過程會十分類似於Paxos的過程。</p><p>下面，由簡單情況逐步推廣到一般情況來探討算法過程。</p><p><strong>1、單個提案者+多接受者</strong></p><p>如果系統中限定只有某個特定節點是提案者，那麼共識結果很容易能達成（只有一個方案，要麼達成，要麼失敗）。提案者只要收到了來自多數接受者的投票，即可認為通過，因為系統中不存在其他的提案。</p><p>但此時一旦提案者故障，則系統無法工作。</p><p><strong>2、多個提案者+單個接受者</strong></p><p>限定某個節點作為接受者。這種情況下，共識也很容易達成，接受者收到多個提案，選第一個提案作為決議，發送給其他提案者即可。</p><p>缺陷也是容易發生單點故障，包括接受者故障或首個提案者節點故障。</p><p>以上兩種情形其實類似主從模式，雖然不那麼可靠，但因為原理簡單而被廣泛採用。</p><p>當提案者和接受者都推廣到多個的情形，會出現一些挑戰。</p><p><strong>3、多個提案者+多個接受者</strong></p><p>既然限定單提案者或單接受者都會出現故障，那麼就得允許出現多個提案者和多個接受者。問題一下子變得複雜了。</p><p>一種情況是同一時間片段（如一個提案週期）內只有一個提案者，這時可以退化到單提案者的情形。需要設計一種機制來保障提案者的正確產生，例如按照時間、序列、或者大家猜拳（出一個參數來比較）之類。考慮到分佈式系統要處理的工作量很大，這個過程要儘量高效，滿足這一條件的機制非常難設計。</p><p>另一種情況是允許同一時間片段內可以出現多個提案者。那同一個節點可能收到多份提案，怎麼對他們進行區分呢？這個時候採用只接受第一個提案而拒絕後續提案的方法也不適用。很自然的，提案需要帶上不同的序號。節點需要根據提案序號來判斷接受哪個。比如接受其中序號較大（往往意味著是接受新提出的，因為舊提案者故障概率更大）的提案。</p><p>如何為提案分配序號呢？一種可能方案是每個節點的提案數字區間彼此隔離開，互相不衝突。為了滿足遞增的需求可以配合用時間戳作為前綴字段。</p><p>同時允許多個提案意味著很可能單個提案人無法集齊足夠多的投票；另一方面，提案者即便收到了多數接受者的投票，也不敢說就一定通過。因為在此過程中投票者無法獲知其他投票人的結果，也無法確認提案人是否收到了自己的投票。因此，需要實現兩個階段的提交過程。</p><p><strong>4、兩階段的提交</strong></p><p>提案者發出提案申請之後，會收到來自接受者的反饋。一種結果是提案被大多數接受者接受了，一種結果是沒被接受。沒被接受的話，可以過會再重試。即便收到來自大多數接受者的答覆，也不能認為就最終確認了。因為這些接受者並不知道自己剛答覆的提案是否可以構成大多數的一致意見。</p><p>很自然，需要引入新的一個階段，即提案者在第一階段拿到所有的反饋後，需要再次判斷這個提案是否得到大多數的支持，如果支持則需要對其進行最終確認。</p><p>Paxos裡面對這兩個階段分別命名為準備（Prepare）階段和提交（Commit）階段。準備階段通過鎖來解決對哪個提案內容進行確認的問題，提交階段解決大多數確認最終值的問題。</p><p><strong>準備階段：</strong></p><p>提案者發送自己計劃提交的提案的編號到多個接收者，試探是否可以鎖定多數接收者的支持；</p><p>接受者時刻保留收到過提案的最大編號和接受的最大提案。如果收到提案號比目前保留的最大提案號還大，則返回自己已接受的提案值（如果還未接受過任何提案，則為空）給提案者，更新當前最大提案號，並說明不再接受小於最大提案號的提案。</p><p><strong>提交階段：</strong></p><p>提案者如果收到大多數的回覆（表示大部分人聽到它的請求），則可準備發出帶有剛才提案號的接受消息。如果收到的回覆中不帶有新的提案，說明鎖定成功。則使用自己的提案內容；如果返回中有提案內容，則替換提案值為返回中編號最大的提案值。如果沒收到足夠多的回覆，則需要再次發出請求；</p><p>接受者收到“接受消息”後，如果發現提案號不小於已接受的最大提案號，則接受該提案，並更新接受的最大提案。</p><p>一旦多數接受者接受了共同的提案值，則形成決議，成為最終確認。</p><p><strong>6.2、Raft算法</strong></p><p>Paxos算法的設計並沒有考慮到一些優化機制，同時論文中也沒有給出太多實現細節，因此後來出現了不少性能更優化的算法和實現，包括Fast Paxos、Multi-Paxos等。最近出現的Raft算法，算是對Multi-Paxos的重新簡化設計和實現，相對也更容易理解。</p><p>Raft算法由斯坦福大學的Diego Ongaro和John Ousterhout於2014年在論文《In Search of an Understandable Consensus Algorithm》中提出。Raft算法面向對多個決策達成一致的問題，分解了Leader選舉、日誌複製和安全方面的考慮，並通過約束減少了不確定性的狀態空間。</p><p>Raft算法包括三種角色：Leader（領導者）、Candidate（候選領導者）和Follower（跟隨者），決策前通過選舉一個全局的leader來簡化後續的決策過程。Leader角色十分關鍵，決定日誌（log）的提交。日誌只能由Leader向Follower單向複製。</p><p>典型的過程包括以下兩個主要階段：</p><p>Leader選舉：開始所有節點都是Follower，在隨機超時發生後未收到來自Leader或Candidate消息，則轉變角色為Candidate，提出選舉請求。最近選舉階段（Term）中得票超過一半者被選為Leader；如果未選出，隨機超時後進入新的階段重試。Leader負責從客戶端接收log，並分發到其他節點；</p><p>同步日誌：Leader會找到系統中日誌最新的記錄，並強制所有的Follower來刷新到這個記錄，數據的同步是單向的。</p><p>注意：此處日誌並非是指輸出消息，而是各種事件的發生記錄。</p><p><strong>七、拜占庭問題與算法</strong></p><p>拜占庭問題（Byzantine Problem）更為廣泛，討論的是允許存在少數節點作惡（消息可能被偽造）場景下的一致性達成問題。拜占庭容錯（Byzantine Fault Tolerant，BFT）算法討論的是在拜占庭情況下對系統如何達成共識。</p><p><strong>7.1、兩將軍問題</strong></p><p>在拜占庭將軍問題之前，就已經存在兩將軍問題（Two Generals Paradox）：兩個將軍要通過信使來達成進攻還是撤退的約定，但信使可能迷路或被敵軍阻攔（消息丟失或偽造），如何達成一致？根據FLP不可能原理，這個問題無通用解。</p><p><strong>7.2、拜占庭問題</strong></p><p>拜占庭問題又叫拜占庭將軍問題（Byzantine Generals Problem），是Leslie Lamport等科學家於1982年提出用來解釋一致性問題的一個虛構模型。拜占庭是古代東羅馬帝國的首都，由於地域寬廣，守衛邊境的多個將軍（系統中的多個節點）需要通過信使來傳遞消息，達成某些一致的決定。但由於將軍中可能存在叛徒（系統中節點出錯），這些叛徒將努力向不同的將軍發送不同的消息，試圖干擾共識的達成。拜占庭問題即為在此情況下，如何讓忠誠的將軍們能達成行動的一致。</p><p>論文中指出，對於拜占庭問題來說，假如節點總數為N，叛變將軍數為F，則當N≥3F+1時，問題才有解，由BFT算法進行保證。</p><p>例如，N=3，F=1時。</p><p>提案人不是叛變者，提案人發送一個提案出來，叛變者可以宣稱收到的是相反的命令。則對於第三個人（忠誠者）收到兩個相反的消息，無法判斷誰是叛變者，則系統無法達到一致。</p><p>提案人是叛變者，發送兩個相反的提案分別給另外兩人，另外兩人都收到兩個相反的消息，無法判斷究竟誰是叛變者，則系統無法達到一致。</p><p>更一般的，當提案人不是叛變者，提案人提出提案信息1，則對於合作者來看，系統中會有N-F份確定的信息1，和F份不確定的信息（可能為0或1，假設叛變者會盡量干擾一致的達成），N-F>F，即N>2F情況下才能達成一致。</p><p>當提案人是叛變者，會盡量發送相反的提案給N-F個合作者，從收到1的合作者看來，系統中會存在（N-F）/2個信息1，以及（N-F）/2個信息0；從收到0的合作者看來，系統中會存在（N-F）/2個信息0，以及（N-F）/2個信息1；另外存在F-1個不確定的信息。合作者要想達成一致，必須進一步對所獲得的消息進行判定，詢問其他人某個被懷疑對象的消息值，並通過取多數來作為被懷疑者的信息值。這個過程可以進一步遞歸下去。</p><p>Leslie Lamport等人在論文《Reaching agreement in the presence of faults》中證明，當叛變者不超過1/3時，存在有效的拜占庭容錯算法（最壞需要F+1輪交互）。反之，如果叛變者過多，超過1/3，則無法保證一定能達到一致結果。</p><p>那麼，當存在多於1/3的叛變者時，有沒有可能存在解決方案呢？</p><p>設想F個叛變者和L個忠誠者，叛變者故意使壞，可以給出錯誤的結果，也可以不響應。某個時候F個叛變者都不響應，則L個忠誠者取多數即能得到正確結果。當F個叛變者都給出一個惡意的提案，並且L個忠誠者中有F個離線時，剩下的L-F個忠誠者此時無法分別是否混入了叛變者，仍然要確保取多數能得到正確結果，因此，L-F>F，即L>2F或N-F>2F，所以系統整體規模N要大於3F。</p><p>能確保達成一致的拜占庭系統節點數至少為4，此時最多允許出現1個壞的節點。</p><p><strong>7.3、拜占庭容錯算法</strong></p><p>拜占庭容錯算法（Byzantine Fault Tolerant，BFT）是面向拜占庭問題的容錯算法，解決的是在網絡通信可靠但節點可能故障情況下如何達成共識。拜占庭容錯算法最早的討論在1980年Leslie Lamport等人發表的論文《Polynomial Algorithms for Byzantine Agreement》，之後出現了大量的改進工作。長期以來，拜占庭問題的解決方案都存在複雜度過高的問題，直到PBFT算法的提出。</p><p>1999年，Castro和Liskov於論文《Practical Byzantine Fault Tolerance and Proactive Recovery》中提出的Practical Byzantine Fault Tolerant（PBFT）算法，基於前人工作進行了優化，首次將拜占庭容錯算法複雜度從指數級降低到了多項式級，目前已得到廣泛應用。其可以在失效節點不超過總數1/3的情況下同時保證Safety和Liveness。</p><p>PBFT算法採用密碼學相關技術（RSA簽名算法、消息驗證編碼和摘要）確保消息傳遞過程無法被篡改和破壞。</p><p>算法的基本過程如下：</p><p>首先通過輪換或隨機算法選出某個節點為主節點，此後只要主節點不切換，則稱為一個視圖（View）；</p><p>在某個視圖中，客戶端將請求（REQUEST，operation，timestamp，client）發送給主節點，主節點負責廣播請求到所有其他副本節點；</p><p>所有節點處理完成請求，將處理結果（REPLY，view，timestamp，client，id_node，response）返回給客戶端。客戶端檢查是否收到了至少f+1個來自不同節點的相同結果，作為最終結果。</p><p>主節點廣播過程包括三個階段的處理：預準備（pre-prepare）階段、準備（prepare）階段和提交（commit）階段。預準備和準備階段確保在同一個視圖內請求發送的順序正確；準備和提交階段則確保在不同視圖之間的確認請求是保序的；</p><p>預準備階段：主節點為從客戶端收到的請求分配提案編號，然後發出預準備消息（PRE-PREPARE，view，n，digest，message）給各副本節點，其中message是客戶端的請求消息，digest是消息的摘要；</p><p>準備階段：副本節點收到預準備消息後，檢查消息合法，如檢查通過則向其他節點發送準備消息（PREPARE，view，n，digest，id），帶上自己的id信息，同時接收來自其他節點的準備消息。收到準備消息的節點對消息同樣進行合法性檢查。驗證通過則把這個準備消息寫入消息日誌中。集齊至少2f+1個驗證過的消息才進入準備狀態；</p><p>提交階段：廣播commit消息，告訴其他節點某個提案n在視圖v裡已經處於準備狀態。如果集齊至少2f+1個驗證過的commit消息，則說明提案通過。</p><p>具體實現上還包括視圖切換、checkpoint機制等，讀者可自行參考論文內容，在此不再贅述。</p><p><strong>7.4、新的解決思路</strong></p><p>拜占庭問題之所以難解，在於任何時候系統中都可能存在多個提案（因為提案成本很低），並且要完成最終一致性確認過程十分困難，容易受干擾。</p><p>比特幣的區塊鏈網絡在設計時提出了創新的PoW（Proof of Work）概率算法思路，針對這兩個環節進行了改進。</p><p>首先，限制一段時間內整個網絡中出現提案的個數（通過增加提案成本）；其次是放寬對最終一致性確認的需求，約定好大家都確認並沿著已知最長的鏈進行拓展。系統的最終確認是概率意義上的存在。這樣，即便有人試圖惡意破壞，也會付出相應的經濟代價（超過整體系統一半的計算力）。</p><p>後來的各種PoX系列算法，也都是沿著這個思路進行改進，採用經濟上的懲罰來制約破壞者。</p><p><strong>八、可靠性指標</strong></p><p>可靠性（availability），或者說可用性，是描述系統可以提供服務能力的重要指標。高可靠的分佈式系統往往需要各種複雜的機制來進行保障。</p><p>通常情況下，服務的可用性可以用服務承諾（Service Level Agreement，SLA SLA）、服務指標（Service Level Indicator，SLI）、服務目標（Service Level Objective，SLO）等方面進行衡量。</p><p><strong>8.1、幾個9的指標</strong></p><p>很多領域裡談到服務的高可靠性，都喜歡用幾個9的指標來進行衡量。幾個9，其實是概率意義上粗略反映了系統能提供服務的可靠性指標，最初是電信領域提出的概念。</p><p>表4-1給出同指標下每年允許服務出現不可用時間的參考值。</p><p><br></p><div class=pgc-img><img alt=分佈式系統核心問題 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30bfbd168e6c49cbbc8ebb388f55b997><p class=pgc-img-caption></p></div><p>表4-1　同指標下，每年允許服務出現不可用時間的參考值</p><p>一般來說，單點的服務器系統至少應能滿足兩個9；普通企業信息系統三個9就肯定足夠了（大家可以統計下自己企業內因系統維護每年要停多少時間），系統能達到四個9已經是領先水平了（參考AWS等雲計算平臺）。電信級的應用一般需要能達到五個9，這已經很厲害了，一年裡面最多允許出現五分鐘左右的服務不可用。六個9以及以上的系統，就更加少見了，要實現往往意味著極高的代價。</p><p><strong>8.2、兩個核心時間</strong></p><p>一般地，描述系統出現故障的可能性和故障出現後的恢復能力，有兩個基礎的指標：MTBF和MTTR：</p><p>MTBF（Mean Time Between Failures）：平均故障間隔時間，即系統可以無故障運行的預期時間；</p><p>MTTR（Mean Time to Repair）：平均修復時間，即發生故障後，系統可以恢復到正常運行的預期時間。</p><p>MTBF衡量了系統發生故障的頻率，如果一個系統的MTBF很短，則往往意味著該系統可用性低；而MTTR則反映了系統碰到故障後服務的恢復能力，如果系統的MTTR過長，則說明系統一旦發生故障，需要較長時間才能恢復服務。</p><p>一個高可用的系統應該是具有儘量長的MTBF和儘量短的MTTR。</p><p><strong>8.3、提高可靠性</strong></p><p>如何提升系統的可靠性呢？有兩個基本思路：一是讓系統中的單個組件都變得更可靠；二是乾脆消滅單點。</p><p>IT從業人員大都有類似的經驗，普通筆記本電腦，基本上是過一陣可能就要重啟一下；而運行Linux/Unix系統的專用服務器，則可能連續運行幾個月甚至幾年時間都不出問題。另外，普通的家用路由器，跟生產級別路由器相比，更容易出現運行故障。這些都是單個組件可靠性不同導致的例子，可以通過簡單升級單點的軟硬件來改善可靠性。</p><p>然而，依靠單點實現的可靠性畢竟是有限的。要想進一步地提升，那就只好消滅單點，通過主從、多活等模式讓多個節點集體完成原先單點的工作。這可以從概率意義上改善服務對外的整體可靠性，這也是分佈式系統的一個重要用途。</p><p><strong>九、小結</strong></p><p>分佈式系統是計算機科學中十分重要的一個研究領域。隨著現代計算機集群規模的不斷增長，所處理的數據量越來越大，同時對於性能、可靠性的要求越來越高，分佈式系統相關技術已經變得越來越重要，起到的作用也越來越關鍵。</p><p>分佈式系統中如何保證共識是個經典的技術問題，無論在學術上還是工程上都存在很高的研究價值。令人遺憾地是，理想的（各項指標均最優）解決方案並不存在。在現實各種約束條件下，往往需要通過犧牲掉某些需求，來設計出滿足特定場景的協議。通過本文的學習，讀者可以體會到在工程應用中的類似設計技巧。</p><p>實際上，工程領域中不少問題都不存在一勞永逸的通用解法；而實用的解決思路是，合理地在實際需求和條件限制之間進行靈活的取捨。</p><p><strong>JAVA進階架構程序員福利：我這裡還總結整理了比較全面的JAVA相關的面試資料，都已經整理成了PDF版，這些都可以分享給大家，關注私信我：【806】，免費領取！</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>系統</a></li><li><a>問題</a></li><li><a>核心</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a9dd0a78.html alt=中央系統軟件出問題，Facebook兩社交軟件大規模宕機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RjAc3Dz9H8GnSD style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a9dd0a78.html title=中央系統軟件出問題，Facebook兩社交軟件大規模宕機>中央系統軟件出問題，Facebook兩社交軟件大規模宕機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/794069db.html alt=分佈式系統互斥性與冪等性問題的分析與解決 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15336083003196c982cf9e8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/794069db.html title=分佈式系統互斥性與冪等性問題的分析與解決>分佈式系統互斥性與冪等性問題的分析與解決</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2058c2c.html alt=分佈式系統核心問題簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2058c2c.html title=分佈式系統核心問題簡介>分佈式系統核心問題簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f87337a.html alt=收不到交警便民通知？可能是這裡出了問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdf88511c83f431c9f75609d9e44d585 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f87337a.html title=收不到交警便民通知？可能是這裡出了問題>收不到交警便民通知？可能是這裡出了問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db1a012.html alt=問題408:在變壓器送電前後怎樣檢測差動保護裝置？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e7912ea051664f678d2616da1c042a37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db1a012.html title=問題408:在變壓器送電前後怎樣檢測差動保護裝置？>問題408:在變壓器送電前後怎樣檢測差動保護裝置？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html alt=電廠直流系統調試方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e8200036f19e04c25bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html title=電廠直流系統調試方案>電廠直流系統調試方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html alt=一文讀懂智能客服：發展歷程、系統搭建、市場推廣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RbYMTZ55OrJUgU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html title=一文讀懂智能客服：發展歷程、系統搭建、市場推廣>一文讀懂智能客服：發展歷程、系統搭建、市場推廣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html alt=生活垃圾焚燒發電及蒸汽系統優化改造項目公告 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RcblrbTDBokV23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html title=生活垃圾焚燒發電及蒸汽系統優化改造項目公告>生活垃圾焚燒發電及蒸汽系統優化改造項目公告</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html alt=電驅動橋系統或加快電氣化進程，多個案例共同說明問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539571595921bc5b27eff6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html title=電驅動橋系統或加快電氣化進程，多個案例共同說明問題>電驅動橋系統或加快電氣化進程，多個案例共同說明問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html alt=基於混沌系統的偽隨機數發生器設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html title=基於混沌系統的偽隨機數發生器設計>基於混沌系統的偽隨機數發生器設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html alt=win10系統打印機打印不了顯示已暫停的解決方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10d0de369d4746c7a0c220ff59bd2470 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html title=win10系統打印機打印不了顯示已暫停的解決方法>win10系統打印機打印不了顯示已暫停的解決方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84e317ac.html alt=檢測虛設問題，應當採取強有力的措施加以解決 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/115bad769be144f19346317e77eed4b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84e317ac.html title=檢測虛設問題，應當採取強有力的措施加以解決>檢測虛設問題，應當採取強有力的措施加以解決</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dfdb3278.html alt=南通中海問題多多？！竟遭市住建局通報批評 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZ6gaqQHcJXxWV style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dfdb3278.html title=南通中海問題多多？！竟遭市住建局通報批評>南通中海問題多多？！竟遭市住建局通報批評</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afc3600.html alt="歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fe51a7bcc26445fa95824ca74c172f17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afc3600.html title="歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑">歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html alt=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html title=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案>虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>