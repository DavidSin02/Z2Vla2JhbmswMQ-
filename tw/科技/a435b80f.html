<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從操作系統（Windows）的角度討論中斷和異常機制 | 极客快訊</title><meta property="og:title" content="從操作系統（Windows）的角度討論中斷和異常機制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/95371ea9a81e4e32b3cf7591d4dbbc83"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a435b80f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a435b80f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a435b80f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a435b80f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a435b80f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a435b80f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a435b80f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a435b80f.html><meta property="article:published_time" content="2020-11-14T21:07:50+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:50+08:00"><meta name=Keywords content><meta name=description content="從操作系統（Windows）的角度討論中斷和異常機制"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a435b80f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從操作系統（Windows）的角度討論中斷和異常機制</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">本章的內容是針對Windows XP的32位版本的，但是絕大多數內容也適用於Windows的其他32位版本（Windows NT、Windows 2000和Windows Vista），並且可以比較容易地推廣到64位版本的Windows系統。</span></span></p><h1 class=pgc-h-arrow-right>11.1　中斷描述符表</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">在保護模式下，當有中斷或異常發生時，CPU是通過中斷描述符表（Interrupt Descriptor Table，IDT）來尋找處理函數的。因此，可以說IDT是CPU（硬件）與操作系統（軟件）交接中斷和異常的關口（gate）。操作系統在啟動早期的一個重要任務就是設置IDT，準備好處理異常和中斷的各個函數。</span></span></p><h1 class=pgc-h-arrow-right>11.1.1　概況</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">簡單來說，IDT是一張位於物理內存中的線性表，共有256個表項。在IA-32e（64位）模式下，每個IDT項的長度是16字節，IDT的總長度是4096字節（4KB）。在32位模式下，每個IDT項的長度是8字節，IDT的總長度是2048字節（2KB）。32位與64位的主要差異在於地址長度的變化，因此，下文只討論32位的情況。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">IDT的位置和長度是由CPU的IDTR來描述的。IDTR共有48位，高32位是IDT的基地址，低16位是IDT的長度（limit）。LIDT（Load IDT）指令用於將操作數指定的基地址和長度加載到IDTR中，也就是改寫IDTR的內容。SIDT（Store IDT）指令用於將IDTR的內容寫到內存變量中，也就是讀取IDTR的內容。LIDT和SIDT指令只能在實模式或保護模式的高特權級（Ring 0）下執行。在內核調試時，可以使用</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">rigtr</span></span>和<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">rigtl</span></span>命令觀察IDTR的內容（卷1中的2.6.2節）。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">在Windows操作系統中，IDT的初始化過程大致是這樣的。IDT的最初建立和初始化工作是由Windows系統的加載程序（NTLDR或WinLoad）在實模式下完成的。在準備好一個內存塊後，加載程序先執行CLI指令關閉中斷處理，然後執行LIDT指令將IDT的位置和長度信息加載到CPU中，而後，加載程序將CPU從實模式切換到保護模式，並將執行權移交給NT內核的入口函數</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiSystemStartup</span></span>。接下來，內核中的處理器初始化函數會通過SIDT指令取得IDT的信息，對其進行必要的調整，然後以參數形式傳遞給<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiInitializePcr</span></span>函數，後者將其記錄到描述處理器的基本數據區PCR（Processor Control Region）和Prcb（Processor control block）中。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">以上介紹的過程都是發生在0號處理器中的，也就是所謂的Bootstrap Processor，簡稱BSP。因為即使是多CPU的系統，在把NTLDR或WinLoad及執行權移交給內核的階段都只有BSP在運行。在BSP完成了內核初始化和執行體的階段0初始化後，在階段1初始化時，BSP才會執行</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KeStartAllProcessors</span></span>函數來初始化其他CPU。BSP之外的其他CPU一般稱為AP（Application Processor）。對於每個AP，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KeStartAllProcessors</span></span>函數會為其建立一個單獨的處理器狀態區，包括它的IDT，然後調用<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiInitProcessor</span></span>函數，後者會根據啟動CPU的IDT為要初始化的AP複製一份，並做必要的修改。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">在內核調試會話中，可以使用</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">!pcr</span></span>命令觀察CPU的PCR內容，清單11-1顯示了Windows Vista系統中0號CPU的PCR內容。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">清單11-1　Windows Vista系統中0號CPU的PCR內容</span></span></p><pre><code>kd&gt; !pcrKPCR for Processor 0 at 81969a00:        // KPCR結構的線性內存地址    Major 1 Minor 1                        // KPCR結構的主版本號和子版本號    NtTib.ExceptionList: 9f1d9644       // 異常處理註冊鏈表[…]    // 省略數行關於NTTIB的信息            SelfPcr: 81969a00              // 本結構的起始地址               Prcb: 81969b20              // KPRCB結構的地址               Irql: 0000001f              // CPU的中斷請求級別（IRQL）                IRR: 00000000              //                IDR: ffff20f0              //      InterruptMode: 00000000              //                IDT: 834da400              // IDT的基地址                GDT: 834da000              // GDT的基地址                TSS: 8013e000              // 任務狀態段（TSS）的地址      CurrentThread: 84af6270              // 當前在執行的線程，ETHREAD地址         NextThread: 00000000              // 下一個準備執行的線程         IdleThread: 8196cdc0              // IDLE線程的ETHREAD地址</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">內核數據結構KPCR描述了PCR內存區的佈局，因此也可以使用</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">dt</span></span>命令來觀察PCR，例如，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">kd> dt nt!_KPCR 81969a00</span></span>。</span></p><h1 class=pgc-h-arrow-right>11.1.2　門描述符</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">IDT的每個表項是一個所謂的門描述符（gate descriptor）結構。之所以這樣稱呼，是因為IDT項的基本用途就是引領CPU從一個空間到另一個空間去執行，每個表項好像是一個從一個空間進入另一個空間的大門（gate）。在穿越這扇門時CPU會做必要的安全檢查和準備工作。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">IDT中可以包含以下3種門描述符。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（1）任務門（task-gate）描述符：用於任務切換，裡面包含用於選擇任務狀態段（TSS）的段選擇子。可以使用JMP或CALL指令通過任務門來切換到任務門所指向的任務，當CPU因為中斷或異常轉移到任務門時，也會切換到指定的任務。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（2）中斷門（interrupt-gate）描述符：用於描述中斷處理例程的入口。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（3）陷阱門（trap-gate）描述符：用於描述異常處理例程的入口。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">圖11-1描述了以上3種門描述符的內容佈局。</span></span></p><div class=pgc-img><img alt=從操作系統（Windows）的角度討論中斷和異常機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/95371ea9a81e4e32b3cf7591d4dbbc83><p class=pgc-img-caption></p></div><p style="text-align:center;margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">圖11-1　IDT中的3種門描述符的內容佈局</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">從圖11-1可以看出，3種門描述符的格式非常相似，有很多共同的字段。其中DPL代表描述符優先級（descriptor previlege level），用於優先級控制，P是段存在標誌。段選擇子用於選擇一個段描述符（位於LDT或GDT中，選擇子的格式參見本書卷1的2.6.3節），偏移部分用來指定段中的偏移，二者共同定義一個準確的內存位置。對於中斷門和陷阱門，二者指定的就是中斷或異常處理例程的地址；對於任務門，它們指定的就是任務狀態段的內存地址。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">系統通過門描述符的類型字段，即高4字節的6～12位，來區分一個描述符的種類。例如任務門的類型是0b00101（b代表二進制數），中斷門的類型是0b0D110，其中D位用來表示描述的是16位門（0）還是32位門（1），陷阱門的類型是0b0D111。</span></span></p><h1 class=pgc-h-arrow-right>11.1.3　執行中斷和異常處理函數</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">下面我們看看當有中斷或異常發生時，CPU是如何通過IDT尋找和執行處理函數的。首先，CPU會根據其向量號碼和IDTR中的IDT基地址信息找到對應的門描述符。然後判斷門描述符的類型，如果是任務描述符，那麼CPU會執行硬件方式的任務切換，切換到這個描述符所定義的線程；如果是陷阱描述符或中斷描述符，那麼CPU會在當前任務上下文中調用描述符所描述的處理例程。下面分別加以討論。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">我們先來看任務門的情況。簡單來說，任務門描述的是一個TSS，CPU要做的是切換到這個TSS所代表的線程，然後開始執行這個線程。TSS是用來保存任務信息的一段內存區，其格式是CPU所定義的。圖11-2給出了IA-32 CPU的TSS格式。從中我們看到TSS中包含了一個任務的關鍵上下文信息，如段寄存器、通用寄存器和控制寄存器，其中特別值得注意的是靠下方的SS0～SS2和ESP0～ESP2字段，它們記錄著一項任務在不同優先級執行時所應使用的棧，SSx用來選擇棧所在的段，ESPx是棧指針值。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">CPU在通過任務門的段選擇子找到TSS描述符後，會執行一系列的檢查動作，比如確保TSS描述符中的存在標誌是1，邊界值應該大於0x67，B（Busy）標誌不為1等。所有檢查都通過後，CPU會將當前任務的狀態保存到當前任務的TSS中。然後把TSS描述符中的B標誌設置為1。接下來，CPU要把新任務的段選擇子（與門描述符中的段選擇子等值）加載到TR寄存器，然後把新任務的寄存器信息加載到物理寄存器中。最後，CPU開始執行新的任務。</span></span></p><div class=pgc-img><img alt=從操作系統（Windows）的角度討論中斷和異常機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4cd83fcb56b84733a9aaebf4cbdbff4f><p class=pgc-img-caption></p></div><p style="text-align:center;margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">圖11-2　32位的任務狀態段（TSS）</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">下面通過一個小實驗來加深大家的理解。首先，在一個調試Windows Vista的內核調試會話中，通過</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ridtr</span></span>命令得到系統IDT的基地址。</span></p><pre><code>kd&gt; r idtridtr=834da400</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">因為雙重錯誤異常（Double Fault，#DF）通常是使用任務門來處理的，所以我們觀察這個異常對應的IDT項。因為#DF異常的向量號是8，每個IDT項的長度是8字節，所以我們可以使用如下命令顯示出8號IDT項的內容。</span></span></p><pre><code>kd&gt; db 834da400+8*8 l8834da440  00 00 50 00 00 85 00 00                          ..P.....</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">其中第2、3字節（從0起，下同）組成的WORD是段選擇子，即0x0050。第5字節（0x85）是P標誌（為1）、DPL（0b00）和類型（0b00101）。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">接下來使用</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">dg</span></span>命令顯示段選擇子所指向的段描述符。</span></p><pre><code>kd&gt; dg 50                                              P    Si    Gr    Pr    LoSel    Base    Limit    Type l    ze    an    es    ng    Flags---- -------- -------- ---------- - -- -- -- -- -----------0050    81967000    00000068    TSS32 Avl    0    Nb    By    P    Nl    00000089</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">也就是說，TSS的基地址是0x81967000，長度是0x68字節（</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Gran</span></span>位指示<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">By</span></span>即Byte）。<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Type</span></span>字段顯示這個段的類型是32位的TSS（<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">TSS32</span></span>），它的狀態為Available，並非Busy。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">至此，我們知道了#DF異常對應的門描述符所指向的TSS，是位於內存地址0x81967000開始的0x68字節。使用內存觀察命令便可以顯示這個TSS的內容了（清單11-2）。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">清單11-2　TSS的內容</span></span></p><pre><code>kd&gt; dd 8196700081967000  00000000 81964000 00000010 0000000081967010  00000000 00000000 00000000 0012200081967020  8193f0a0 00000000 00000000 0000000081967030  00000000 00000000 81964000 0000000081967040  00000000 00000000 00000023 0000000881967050  00000010 00000023 00000030 0000000081967060  00000000 20ac0000 00000000 8196400081967070  00000010 00000000 00000000 00000000</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">參考清單11-2，從上至下，</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">81964000</span></span>是在優先級0執行時的棧指針，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">00000010</span></span>是在優先級0執行時的棧選擇子，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">00122000</span></span>是這個任務的頁目錄基地址寄存器（PDBR，即CR3）的值，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">8193f0a0</span></span>是程序指針寄存器（EIP）的值，當CPU切換到這個任務時便是從這裡開始執行的。接下來，依次是標誌寄存器（EFLAGS）和通用寄存器的值。偏移0x48字節處的0x23是ES寄存器的值，相鄰的<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">00000008</span></span>是CS寄存器的值，即這個任務的代碼段的選擇子。而後是SS寄存器的值，即棧段的選擇子，再往後是DS、FS和GS寄存器的值（0x23、0x30和0）。偏移0x64字節處的<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">20ac0000</span></span>是TSS的最後4字節，它的最低位是T標誌（0），即我們在卷1的4.3.3節介紹過的TSS中的陷阱標誌。高16字節是用來定位IO映射區基地址的偏移地址，它是相對於TSS的基地址的。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">使用</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ln</span></span>命令可以觀察EIP的值對應的就是內核函數<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiTrap08</span></span>。</span></p><pre><code>kd&gt; ln 8193f0a0 (8193f0a0)   nt!KiTrap08   |  (8193f118)   nt!Dr_kit9_aExact matches:    nt!KiTrap08 = &lt;no type information&gt;</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">也就是說，當有#DF異常發生時，CPU會切換到以上TSS所描述的線程，然後在這個線程環境中執行</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiTrap08</span></span>函數。之所以要切換到一個新的線程，而不是像其他異常那樣在原來的線程中處理，是因為#DF異常指的是在處理一個異常時又發生了異常，這可能意味著本來的線程環境已經不可靠了，所以有必要切換到一個新的線程來執行。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">類似地，代表緊急任務的不可屏蔽中斷（NMI）也是使用任務門機制來處理的。最後要說明的是，因為</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">x64</span></span>架構不支持硬件方式的任務切換，所以IDT中也不再有任務門了。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">大多數中斷和異常是利用中斷門或陷阱門來處理的，下面我們看看這兩種情況。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">首先，CPU會根據門描述符中的段選擇子定位到段描述符，然後再進行一系列檢查，如果檢查通過，CPU就判斷是否需要切換棧。如果目標代碼段的特權級別比當前特權級別高（級別的數值小），那麼CPU需要切換棧，其方法是從當前任務的TSS中讀取新棧的段選擇子（SS）和棧指針（ESP），並將其加載到SS和ESP寄存器。然後，CPU會把被中斷過程（舊的）的棧段選擇子（SS）和棧指針（ESP）壓入新的棧。接下來，CPU會執行如下兩項操作。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（1）把EFLAGS、CS和EIP的指針壓入棧。CS和EIP的指針代表了轉到處理例程前CPU正在執行代碼的位置。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（2）如果發生的是異常，而且該異常具有錯誤代碼（參見本書卷1的3.3.2節），那麼把該錯誤代碼也壓入棧。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">如果處理例程所在代碼段的特權級別與當前特權級別相同，那麼CPU便不需要進行棧切換，但仍要執行上面的兩步操作。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">TR寄存器中存放著指向當前任務TSS的選擇子，使用WinDBG可以觀察TSS的內容。</span></span></p><pre><code>kd&gt; r trtr=00000028kd&gt; dg 28                                      P Si Gr Pr LoSel    Base     Limit     Type     l ze an es ng Flags---- -------- -------- ---------- - -- -- -- -- ---------0028 8013e000 000020ab TSS32 Busy    0 Nb By P  Nl 0000008b</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">經常做內核調試的讀者可能會發現，TR寄存器的值大多時候是固定的。也就是說，值並不隨著應用程序的線程切換而變化。事實上，Windows系統中的TSS個數並不是與系統中的線程個數相關的，而是與CPU個數相關的。在啟動期間，Windows系統會為每個CPU創建3～4個TSS，一個用於處理NMI，一個用於處理#DF異常，一個用於處理機器檢查異常（與版本有關，在XP SP1中存在），另一個供所有Windows線程共享。當Windows系統切換線程時，它把當前線程的狀態複製到共享的TSS中。也就是說，普通的線程切換並不會切換TSS，只有當NMI或 #DF異常發生時，才會切換TSS，這就是所謂的以軟件方式切換線程（任務）。</span></span></p><h1 class=pgc-h-arrow-right>11.1.4　IDT一覽</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">使用WinDBG的</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">!idt</span></span>擴展命令可以列出IDT中的各個項，不過該命令做了很多翻譯，顯示出的不是門描述符的原始格式。</span></p><pre><code>lkd&gt; !idt -a Dumping IDT:00:  804dbe13 nt!KiTrap00        // 0號異常，即除以001:  804dbf6b nt!KiTrap0102:  Task Selector = 0x0058      // NMI的門描述符，顯示的是TSS的選擇子03:  804dc2bd nt!KiTrap03</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">表11-1列出了典型Windows系統的IDT設置，對於不同的Windows版本或硬件配置不同的系統，某些表項可能有所不同，但是大多數表項是一致的。</span></span></p><p style="text-align:center;margin:8px 0"><span style=font-size:.833em><strong><span style="color:#666;--tt-darkmode-color: #666666">表11-1　IDT設置一覽（略）</span></strong></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">在Windows XP系統中，處理機器檢查異常（#MC）的18號表項處是一個任務門描述符，指向一個單獨的TSS，對應的處理函數是hal模塊中的</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">HalpMcaExceptionHandlerWrapper</span></span>。</span></p><h1 class=pgc-h-arrow-right>11.2　異常的描述和登記</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">為了更好地管理異常，Windows系統定義了專門的數據結構來描述異常，並定義了一系列代碼來標識典型的異常。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">在操作系統層次，除了CPU產生的異常，還有通過軟件方式模擬出的異常，比如調用RaiseException API而產生的異常和使用編程語言的throw關鍵字拋出的異常。為了行文方便，我們把前一類稱為CPU異常（或硬件異常），把後一類稱為軟件異常。Windows是使用統一的方式來描述和分發這兩類異常的。本節介紹異常的描述方式，11.3節將介紹異常的分發過程。</span></span></p><h1 class=pgc-h-arrow-right>11.2.1　EXCEPTION_RECORD結構</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">Windows系統使用EXCEPTION_RECORD結構來描述異常，清單11-3給出了這個結構的定義。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">清單11-3　EXCEPTION_RECORD結構</span></span></p><pre><code>typedef struct _EXCEPTION_RECORD {  DWORD ExceptionCode;                            // 異常代碼  DWORD ExceptionFlags;                           // 異常標誌  struct _EXCEPTION_RECORD* ExceptionRecord;      // 相關的另一個異常  PVOID ExceptionAddress;                         // 異常發生地址  DWORD NumberParameters;                         // 參數數組中的元素個數  ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; // 參數數組} EXCEPTION_RECORD, *PEXCEPTION_RECORD;</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">其中</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ExceptionCode</span></span>為異常代碼，是一個32位的整數，其格式是Windows系統的狀態代碼格式，NtStatus.h中包含了已經定義的所有狀態代碼，在WinBase.h中可以看到異常代碼只是狀態代碼的別名，例如：</span></p><pre><code>#define EXCEPTION_BREAKPOINT                STATUS_BREAKPOINT#define EXCEPTION_SINGLE_STEP               STATUS_SINGLE_STEP</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">表11-2列出了常見的用於異常代碼的狀態代碼。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">字段用來記錄異常標誌，它的每一位代表一種標誌，目前已經定義的標誌位如下。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（1）EH_NONCONTINUABLE（1），該異常不可恢復繼續執行。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（2）EH_UNWINDING（2），當因為執行棧展開而調用異常處理函數時，會設置此標誌。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（3）EH_EXIT_UNWIND（4），也是用於棧展開，較少使用。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（4）EH_STACK_INVALID（8），當檢測到棧錯誤時，設置此標誌。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（5）EH_NESTED_CALL（0x10），用於標識內嵌的異常（第24章）。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">EH_NONCONTINUABLE位用來表示該異常是否可以恢復繼續執行，如果試圖恢復運行一個不可繼續的異常，便會導致</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">EXCEPTION_NONCONTINUABLE_EXCEPTION</span></span>異常。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">ExceptionRecord指針指向與該異常有關的另一個異常記錄，如果沒有相關的異常，那麼這個指針便為空。</span></span></p><p style="text-align:center;margin:8px 0"><span style=font-size:.833em><strong><span style="color:#666;--tt-darkmode-color: #666666">表11-2　用於的異常代碼的狀態代碼（略）</span></strong></span></p><p style="text-align:center;margin:8px 0"><br></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">ExceptionAddress字段用來記錄異常地址，對於硬件異常，它的值因為異常類型不同而可能是導致異常的那條指令的地址，或者是導致異常指令的下一條指令的地址。例如，非法訪問異常（EXCEPTION_ACCESS_VIOLATION）屬於錯誤（Fault）類異常，ExceptionAddress的值是導致異常的那條指令的地址。數據斷點觸發的調試異常屬於陷阱（Trap）類異常，ExceptionAddress的值是導致異常指令的下一條指令的地址。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">NumberParameters是附加參數的個數，即ExceptionInformation數組中包含的有效參數個數，該結構最多允許存儲15個附加參數。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">導致非法訪問異常的原因主要來源於CPU的頁錯誤異常#PF（14），但也可能是由於系統檢測到的其他違反系統規則的情況。</span></span></p><h1 class=pgc-h-arrow-right>11.2.2　登記CPU異常</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">對於CPU異常，KiTrapXX例程在完成針對本異常的特別動作後，通常會調用</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">CommonDispatchException</span></span>函數，並通過寄存器將如下信息傳遞給這個函數。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（1）將唯一標識該異常的一個異常代碼（表11-2）放入EAX寄存器。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（2）將導致異常的指令地址放入EBX寄存器。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">（3）將其他信息作為附帶參數（最多3個）分別放入EDX（參數1）、ESI（參數2）和EDI（參數3）寄存器，並將參數個數放入ECX寄存器。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">CommonDispatchException</span></span>被調用後，它會在棧中分配一個EXCEPTION_ RECORD結構，並把以上異常信息存儲到該結構中。在準備好這個結構後，它會調用內核中的<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiDispatchException</span></span>函數來分發異常。</span></p><h1 class=pgc-h-arrow-right>11.2.3　登記軟件異常</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">下面看看軟件異常的產生和登記過程。簡單來說，軟件異常是通過直接或間接調用內核服務NtRaiseException而產生的。</span></span></p><pre><code>NTSTATUS NtRaiseException (IN PEXCEPTION_RECORD ExceptionRecord,    IN PCONTEXT ContextRecord, IN BOOLEAN FirstChance )</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">用戶模式中的程序可以通過</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">RaiseException ()</span></span>API來調用這個內核服務。RaiseException API是由KERNEL32.DLL導出的API，供應用程序產生“自定義”的異常，其原型如下。</span></p><pre><code>void RaiseException( DWORD , DWORD , DWORD , const DWORD* );</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">其中是異常代碼，可以是表11-2中的代碼，也可以是應用程序自己定義的代碼。和用來定義異常的常數，相當於EXCEPTION_RECORD結構中的和。事實上，</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">RaiseException</span></span>的實現也很簡單，它只是將參數放入一個 EXCEPTION_RECORD 後便調用NTDLL.DLL中的<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">RtlRaiseException()</span></span>。<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">RtlRaiseException</span></span>會將當前的執行上下文（通用寄存器等）放入CONTEXT結構，然後通過NTDLL.DLL中的系統服務調用機制調用內核中的<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">NtRaiseException</span></span>。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">NtRaiseException</span></span>內部會調用另一個內核函數<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiRaiseException</span></span>。</span></p><pre><code>NTSTATUS KiRaiseException (IN PEXCEPTION_RECORD ExceptionRecord,    IN PCONTEXT ContextRecord, IN PKEXCEPTION_FRAME ExceptionFrame,    IN PKTRAP_FRAME TrapFrame, IN BOOLEAN FirstChance )</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ExceptionRecord</span></span>是指向異常記錄的指針，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ContextRecord</span></span>是指向線程上下文（CONTEXT）結構的指針，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ExceptionFrame</span></span>對於x86平臺總是為NULL，TrapFrame就是棧幀的基地址，FirstChance表示這是該異常的第一輪（TRUE）還是第二輪（FALSE）處理機會。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">內核中的代碼可以通過RtlRaiseException（相當於NTDLL.DLL中的版本）來調用NtRaiseException和KiRaiseException。也就是說，不論是從用戶模式調用RaiseException API，還是從內核模式調用相應的函數，最後都會轉到KiRaiseException。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">KiRaiseException內部會通過KeContextToKframes例程把ContextRecord結構中的信息複製到當前線程的內核棧，然後把ExceptionRecord 中的異常代碼的最高位清0，以便把軟件產生的異常與CPU異常區分開來。接下來KiRaiseException會調用KiDispatchException開始分發該異常。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">對於Visual C++程序拋出的異常，比如MFC中從CException派生來的各個異常類對應的異常，</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">throw</span></span>關鍵字直接對應的是<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">CxxThrowException</span></span>函數，<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">CxxThrowException</span></span>會調用RaiseException，並將<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ExceptionCode</span></span>參數固定為0xe06d7363（對應的ASCII碼為.msc）。接下來的過程與上面直接調用RaiseException的情況相同。因為C++異常的實現與編譯器有關，所以本書只討論使用Visual C++編譯器的情況。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">.NET程序拋出的異常（CLR異常）也是通過RaiseException API產生的，其異常代碼固定為0xe0434f4d（對應的ASCII碼為.COM）。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">綜上所述，不論是CPU異常還是軟件異常，儘管產生的原因不同，但最終都會調用內核中的KiDispatchException來分發異常，也就是說，Windows系統是使用統一的方法來分發CPU異常和軟件異常的。</span></span></p><h1 class=pgc-h-arrow-right>11.3　異常分發過程</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">根據前面兩節的介紹，當有異常發生時，CPU會通過IDT找到異常處理函數，即內核中的KiTrapXX系列函數，然後轉去執行。但是，KiTrapXX函數通常只是對異常作簡單的表徵和描述，為了支持調試和軟件自己定義的異常處理函數，系統需要將異常分發給調試器或應用程序的處理函數。對於軟件異常，Windows系統是以和CPU異常統一的方式來分發和處理的，本節將介紹分發異常的核心函數</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiDispatchException</span></span>和它的工作過程。</span></p><h1 class=pgc-h-arrow-right>11.3.1　KiDispatchException函數</h1><p style="margin:0 0 8px"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">Windows內核中的</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiDispatchException</span></span>函數是分發各種Windows異常的樞紐。其函數原型如下。</span></p><pre><code>VOID KiDispatchException ( IN PEXCEPTION_RECORD ExceptionRecord,    IN PKEXCEPTION_FRAME ExceptionFrame, IN PKTRAP_FRAME TrapFrame,    IN KPROCESSOR_MODE PreviousMode, IN BOOLEAN FirstChance )</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">其中，參數</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ExceptionRecord</span></span>指向的是上一節介紹的EXCEPTION_RECORD結構，用來描述要分發的異常。參數<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ExceptionFrame</span></span>對於x86系統總是為NULL。參數TrapFrame指向的是 KTRAP_FRAME 結構，用來描述異常發生時的處理器狀態，包括各種通用寄存器、調試寄存器、段寄存器等。參數<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">PreviousMode</span></span> 是一個枚舉類型的常量，DDK的頭文件中有這個枚舉類型的定義。</span></p><pre><code>typedef enum _MODE { KernelMode, UserMode, MaximumMode} MODE;</code></pre><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">也就是說，PreviousMode等於0表示前一個模式（通常是觸發異常代碼的執行模式）是內核模式，1表示用戶模式。FirstChance參數表示是否是第一輪分發這個異常。對於一個異常，Windows系統最多分發兩輪。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">圖11-3畫出了KiDispatchException分發異常的基本過程（示意圖）。</span></span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">從圖11-3中可以看到，</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiDispatchException</span></span>會先調用<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KeContextFromKframes</span></span>函數，目的是根據<span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">TrapFrame</span></span>參數指向的KTRAP_FRAME結構產生一個CONTEXT結構，以供向調試器和異常處理器函數報告異常時使用。</span></p><p style="margin:8px 0"><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">接下來，根據前一個模式（異常發生的模式）是內核模式還是用戶模式，</span><span style="color:#d14;--tt-darkmode-color: #DD1144"><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">KiDispatchException</span></span>會選取左右兩個流程之一來分發異常，下面我們分別作進一步說明。</span></p><p><span style=font-size:.833em>本文截選自《<span style="color:#666;--tt-darkmode-color: #666666">軟件調試 第2版 卷2 Windows平臺調試 上、下冊</span>》</span></p><div class=pgc-img><img alt=從操作系統（Windows）的角度討論中斷和異常機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bccb80ef95a243f59ec131d0ab590597><p class=pgc-img-caption></p></div><p><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666">本書是國內當前集中介紹軟件調試主題的權威著作。本書第2 卷分為5 篇，共30 章，主要圍繞Windows系統展開介紹。第一篇（第1~4 章）介紹Windows 系統簡史、進程和線程、架構和系統部件，以及Windows系統的啟動過程，既從空間角度講述Windows 的軟件世界，也從時間角度描述Windows 世界的搭建過程。第二篇（第5~8 章）描述特殊的過程調用、墊片、託管世界和Linux 子系統。第三篇（第9~19 章）深入探討用戶態調試模型、用戶態調試過程、中斷和異常管理、未處理異常和JIT 調試、硬錯誤和藍屏、錯誤報告、日誌、事件追蹤、WHEA、內核調試引擎和驗證機制。第四篇（第20~25 章）從編譯和編譯期檢查、運行時庫和運行期檢查、棧和函數調用、堆和堆檢查、異常處理代碼的編譯、調試符號等方面概括編譯器的調試支持。第五篇（第26~30 章）首先縱覽調試器的發展歷史、工作模型和經典架構，然後分別討論集成在Visual Studio 和Visual Studio（VS）Code 中的調試器，最後深度解析WinDBG 調試器的歷史、結構和用法。</span></span><br><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666"><br>本書理論與實踐結合，不僅涵蓋了相關的技術背景知識，還深入研討了大量具有代表性的技術細節，是學習軟件調試技術的珍貴資料。</span></span><br><span style=font-size:.833em><span style="color:#666;--tt-darkmode-color: #666666"><br>本書適合所有從事軟件開發工作的讀者閱讀，特別適合從事軟件開發、測試和支持的技術人員閱讀。</span></span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>系統</a></li><li><a>Windows</a></li><li><a>討論</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f7811ad.html alt=Windows系統下PHP環境手動搭建教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7647644fbbcc454faf228227806249d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f7811ad.html title=Windows系統下PHP環境手動搭建教程>Windows系統下PHP環境手動搭建教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/126a2f76.html alt=馬起來！Windows系統下原來可以改變分區大小 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5c2699f68dcf44df999c460e26c804f7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/126a2f76.html title=馬起來！Windows系統下原來可以改變分區大小>馬起來！Windows系統下原來可以改變分區大小</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/155993ff.html alt=Windows系統C盤，用著就滿了，教你無損轉移C盤已安裝好的程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99f572cdfb5c44a294e9287aa55f0fdf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/155993ff.html title=Windows系統C盤，用著就滿了，教你無損轉移C盤已安裝好的程序>Windows系統C盤，用著就滿了，教你無損轉移C盤已安裝好的程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44030066.html alt=系統小技巧：Windows磁盤簽名衝突及其解決 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1dd2f76ddb5f4a9c8e4fa8ce2d3ef775 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44030066.html title=系統小技巧：Windows磁盤簽名衝突及其解決>系統小技巧：Windows磁盤簽名衝突及其解決</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c7e8ed4a.html alt=Windows系統安全管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/69025cada8a649659a9d8a5a302db3c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c7e8ed4a.html title=Windows系統安全管理>Windows系統安全管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90250abb.html alt="Windows 10操作系統的一些使用技巧（快捷鍵篇）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0238edbd-0c15-4245-9400-4551612adc2a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90250abb.html title="Windows 10操作系統的一些使用技巧（快捷鍵篇）">Windows 10操作系統的一些使用技巧（快捷鍵篇）</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/73b0026e.html alt="如何保障操作系統文檔安全，Windows 7設置自動備份文件和文件夾" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/abe8bb7bc0b2449eafa0071831a16338 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/73b0026e.html title="如何保障操作系統文檔安全，Windows 7設置自動備份文件和文件夾">如何保障操作系統文檔安全，Windows 7設置自動備份文件和文件夾</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d6f7e189.html alt=Windows系統中使用Telnet命令查看遠程服務是否可用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/abd09f79b2ad47fea0595d153eaf7a72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d6f7e189.html title=Windows系統中使用Telnet命令查看遠程服務是否可用>Windows系統中使用Telnet命令查看遠程服務是否可用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7246697e.html alt=Windows系統實現多人同時遠程連接，超詳細教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8ab4de974c74468296260a18c8b25545 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7246697e.html title=Windows系統實現多人同時遠程連接，超詳細教程>Windows系統實現多人同時遠程連接，超詳細教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05f6c0db.html alt=Windows系統不打補丁！看黑客是如何攻擊你電腦的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5788f00f00174d8094f6f416086f3845 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05f6c0db.html title=Windows系統不打補丁！看黑客是如何攻擊你電腦的>Windows系統不打補丁！看黑客是如何攻擊你電腦的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f99b2f98.html alt="大量 Linux/Windows 系統可能被攻擊，GRUB2中被曝新BootHole漏洞" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f10a698e5a854e4fa760544b227b61da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f99b2f98.html title="大量 Linux/Windows 系統可能被攻擊，GRUB2中被曝新BootHole漏洞">大量 Linux/Windows 系統可能被攻擊，GRUB2中被曝新BootHole漏洞</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f07ddb.html alt=「Windows」系統桌面點擊鼠標右鍵卡頓問題，終於解決了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152112392239079895d9569 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f07ddb.html title=「Windows」系統桌面點擊鼠標右鍵卡頓問題，終於解決了>「Windows」系統桌面點擊鼠標右鍵卡頓問題，終於解決了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f1de35c.html alt=使用Windows服務器IIS搭建個人網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/94b8a85895c04c9b83d5d35b6b24df9c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f1de35c.html title=使用Windows服務器IIS搭建個人網站>使用Windows服務器IIS搭建個人網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html alt=電廠直流系統調試方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e8200036f19e04c25bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html title=電廠直流系統調試方案>電廠直流系統調試方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html alt=一文讀懂智能客服：發展歷程、系統搭建、市場推廣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RbYMTZ55OrJUgU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html title=一文讀懂智能客服：發展歷程、系統搭建、市場推廣>一文讀懂智能客服：發展歷程、系統搭建、市場推廣</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>