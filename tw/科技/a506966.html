<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>TCP協議詳解 | 极客快訊</title><meta property="og:title" content="TCP協議詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/23a1b33d10ec4885a1e3606c1aca021c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a506966.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a506966.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a506966.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a506966.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a506966.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a506966.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a506966.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a506966.html><meta property="article:published_time" content="2020-10-29T20:50:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:28+08:00"><meta name=Keywords content><meta name=description content="TCP協議詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a506966.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>TCP協議詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p>小到基於應用層做網絡開發，大到生活中無處不在的網絡。我們在享受這個便利的時候，沒有人會關心它如此牢固的底層基石是如何搭建的。而這些基石中很重要的一環就是tcp協議。翻看一下“三次握手”和“四次揮手”，本以為這就是tcp了，其實不然。它僅僅解決了連接和關閉的問題，傳輸的問題才是tcp協議更重要，更難，更復雜的問題。回頭看tcp協議的原理，會發現它為了承諾上層數據傳輸的“可靠”，不知要應對多少網絡中複雜多變的情況。簡單直白列舉一下：</p><ul><li>怎麼保證數據都是可靠呢？---連接確認！關閉確認！收到數據確認！各種確認！！</li><li>因為網絡或其他原因，對方收不到數據怎麼辦？--超時重試</li><li>網絡情況千變萬化，超時時間怎麼確定？--根據RTT動態計算</li><li>反反覆覆，不厭其煩的重試，導致網絡擁塞怎麼辦？---慢啟動，擁塞避免，快速重傳，快速恢復</li><li>發送速度和接收速度不匹配怎麼辦？--滑動窗口</li><li>滑動窗口滑的過程中，他一直告訴我處理不過來了，不讓傳數據了怎麼辦？--ZWP</li><li>滑動窗口滑的過程中，他處理得慢，就理所當然的每次讓我發很少的數據，導致網絡利用率很低怎麼辦？---Nagle</li></ul><p>其中任何一個小環節，都凝聚了無數的算法，我們沒有能力理解各個算法的實現，但是需要了解下tcp實現者的思路歷程。</p><p>梳理完所有內容，大概可以知道：</p><h1 class=pgc-h-arrow-right>tcp提供哪些機制保證了數據傳輸的可靠性？</h1><h1 class=pgc-h-arrow-right>tcp連接的“三次握手”和關閉的“四次揮手”流程是怎麼樣的？</h1><h1 class=pgc-h-arrow-right>tcp連接和關閉過程中，狀態是如何變化的？</h1><h1 class=pgc-h-arrow-right>tcp頭部有哪些字段，分別用來做什麼的？</h1><h1 class=pgc-h-arrow-right>tcp的滑動窗口協議是什麼？</h1><h1 class=pgc-h-arrow-right>超時重傳的機制是什麼？</h1><h1 class=pgc-h-arrow-right>如何避免傳輸擁塞？</h1><h1 class=pgc-h-arrow-right>一. 概述</h1><h1 class=pgc-h-arrow-right>1. tcp連接的特點</h1><ul><li>提供面向連接的，可靠的字節流服務</li><li>為上層應用層提供服務，不關心具體傳輸的內容是什麼，也不知道是二進制流，還是ascii字符。</li></ul><h1 class=pgc-h-arrow-right>2. tcp的可靠性如何保證</h1><ul><li>分塊傳送：數據被分割成<strong>最合適的</strong>數據塊（UDP的數據報長度不變）</li><li>等待確認：通過定時器等待接收端發送確認請求，收不到確認則重發</li><li>確認回覆：收到確認後發送確認回覆(不是立即發送，通常推遲幾分之一秒)</li><li>數據校驗：保持首部和數據的校驗和，檢測數據傳輸過程有無變化</li><li>亂序排序：接收端能重排序數據，以正確的順序交給應用端</li><li>重複丟棄：接收端能丟棄重複的數據包</li><li>流量緩衝：兩端有固定大小的緩衝區（滑動窗口），防止速度不匹配丟數據</li></ul><h1 class=pgc-h-arrow-right>3. tcp的首部格式</h1><h1 class=pgc-h-arrow-right>3.1 宏觀位置</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/23a1b33d10ec4885a1e3606c1aca021c><p class=pgc-img-caption></p></div><ul><li>從應用層->傳輸層->網絡層->鏈路層，每經過一次都會在報文中增加相應的首部。參考之前的文章http協議</li><li>TCP數據被封裝在IP數據報中</li></ul><h1 class=pgc-h-arrow-right>3.2 首部格式</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c5147786573d4cc5b28dc4fa5383c7c7><p class=pgc-img-caption></p></div><ul><li>tcp首部數據通常包含20個字節（不包括任選字段）</li><li>第1-2兩個字節：源端口號</li><li>第3-4兩個字節：目的端口號 源端口號+ip首部中的源ip地址+目的端口號+ip首部中的目的ip地址，唯一的確定了一個tcp連接。對應編碼級別的socket。</li><li>第5-8四個字節：32位序號。tcp提供全雙工服務，兩端都有各自的序號。<strong>編號：解決網絡包亂序的問題</strong> 序號如何生成：不能是固定寫死的，否則斷網重連時序號重複使用會亂套。tcp基於時鐘生成一個序號，每4微秒加一，到2^32-1時又從0開始</li><li>第9-12四個字節：32位確認序列號。上次成功收到數據字節序號加1，ack為1才有效。<strong>確認號：解決丟包的問題</strong></li><li>第13位字節：首部長度。因為任選字段長度可變</li><li>後面6bite：保留</li><li>隨後6bite：標識位。<strong>控制各種狀態</strong></li><li>第15-16兩個字節：窗口大小。接收端期望接收的字節數。<strong>解決流量控制的問題</strong></li><li>第17-18兩個字節：校驗和。由發送端計算和存儲，由接收端校驗。<strong>解決數據正確性問題</strong></li><li>第19-20兩個字節：緊急指針</li></ul><h1 class=pgc-h-arrow-right>3.3 標識位說明</h1><ul><li>URG：為1時，表示緊急指針有效</li><li>ACK：確認標識，連接建立成功後，總為1。為1時確認號有效</li><li>PSH：接收方應儘快把這個報文交給應用層</li><li>RST：復位標識，重建連接</li><li>SYN：建立新連接時，該位為0</li><li>FIN：關閉連接標識</li></ul><h1 class=pgc-h-arrow-right>3.4 tcp選項格式</h1><p><br></p><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a1616ba5c967444581a06e2e9b7a6444><p class=pgc-img-caption></p></div><ul><li>每個選項開始是1字節kind字段，說明選項的類型</li><li>kind為0和1的選項，只佔一個字節</li><li>其他kind後有一字節len，表示該選項總長度（包括kind和len）</li><li>kind為11，12，13表示tcp事務</li></ul><h1 class=pgc-h-arrow-right>3.5 MSS 最長報文大小</h1><ul><li>最常見的可選字段</li><li>MSS只能出現在SYN時傳過來（第一次握手和第二次握手時）</li><li>指明本端能接收的最大長度的報文段</li><li>建立連接時，雙方都要發送MSS</li><li>如果不發送，默認為536字節</li></ul><h1 class=pgc-h-arrow-right>二. 連接的建立與釋放</h1><h1 class=pgc-h-arrow-right>1. 連接建立的“三次握手”</h1><h1 class=pgc-h-arrow-right>1.1 三次握手流程</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/17aee0985fcc40239b64f4a20c64d41d><p class=pgc-img-caption></p></div><ul><li>客戶端發送SYN，表明要向服務器建立連接。同時帶上序列號ISN</li><li>服務器返回ACK（序號為客戶端序列號+1）作為確認。同時發送SYN作為應答（SYN的序列號為服務端唯一的序號）</li><li>客戶端發送ACK確認收到回覆（序列號為服務端序列號+1）</li></ul><h1 class=pgc-h-arrow-right>1.2 為什麼是三次握手</h1><ul><li>tcp連接是全雙工的，數據在兩個方向上能同時傳遞。</li><li>所以要<strong>確保雙方，同時能發數據和收數據</strong></li><li>第一次握手：證明了發送方能發數據</li><li>第二次握手：ack確保了接收方能收數據，syn確保了接收方能發數據</li><li>第三次握手：確保了發送方能收數據</li><li>實際上是四個維度的信息交換，不過中間兩步合併為一次握手了。</li><li>四次握手浪費，兩次握手不能保證“雙方同時具備收發功能”</li></ul><h1 class=pgc-h-arrow-right>2. 連接關閉的“四次揮手”</h1><h1 class=pgc-h-arrow-right>2.1 為什麼是四次揮手</h1><ul><li>因為tcp連接是全雙工的，數據在兩個方向上能同時傳遞。</li><li>同時tcp支持半關閉（發送一方結束髮送還能接收數據的功能）。</li><li>因此每個方向都要單獨關閉，且收到關係通知需要發送確認回覆</li></ul><h1 class=pgc-h-arrow-right>2.2 為什麼要支持半關閉</h1><ul><li>客戶端需要通知服務端，它的數據已經傳輸完畢</li><li>同時仍要接收來自服務端的數據</li><li>使用半關閉的單連接效率要比使用兩個tcp連接更好</li></ul><h1 class=pgc-h-arrow-right>2.3 四次握手流程</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d075fecbf04949929512aff67f0fbae5><p class=pgc-img-caption></p></div><ul><li>主動關閉的一方發送FIN，表示要單方面關閉數據的傳輸</li><li>服務端收到FIN後，發送一個ACK作為確認（序列號為收到的序列號+1）</li><li>等服務器數據傳輸完畢，也發送一個FIN標識，表示關閉這個方向的數據傳輸</li><li>客戶端回覆ACK以確認回覆</li></ul><h1 class=pgc-h-arrow-right>3. 連接和關閉對應的狀態</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f8ee86a9004548da8710c756a03bfe8c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>3.1 狀態說明</h1><ul><li>服務端等待客戶端連接時，處於Listen監聽狀態</li><li>客戶端主動打開請求，發送SYN時處於SYN_SENT發送狀態</li><li>客戶端收到syn和ack，並回復ack時，處與Established狀態等待發送報文</li><li>服務端收到ack確認後，也處於Established狀態等待發送報文</li><li>客戶端發送fin後，處於fin_wait_1狀態</li><li>服務端收到fin併發送ack時，處於close_wait狀態</li><li>客戶端收到ack確認後，處於fin_wait_2狀態</li><li>服務端發送fin後，處於last_ack狀態</li><li>客戶端收到fin後發送ack，處於time_wait狀態</li><li>服務端收到ack後，處於closed狀態</li></ul><h1 class=pgc-h-arrow-right>3.2 time_wait狀態</h1><ul><li>也稱為2MSL等待狀態，MSL=Maximum Segment LifetIme，報文段最大生存時間，根據不同的tcp實現自行設定。常用值為30s，1min，2min。linux一般為30s。</li><li>主動關閉的一方發送最後一個ack所處的狀態</li><li>這個狀態必須維持2MSL等待時間</li></ul><h1 class=pgc-h-arrow-right>3.2.1 為什麼需要這麼做？</h1><ul><li>設想一個場景，最後這個ack丟失了，接收方沒有收到</li><li>這時候接收方會重新發送fin給發送方</li><li>這個等待時間就是為了防止這種情況發生，讓發送方重新發送ack</li><li>總結：預留足夠的時間給接收端收ack。同時保證，這個連接不會和後續的連接亂套（有些路由器會緩存數據包）</li></ul><h1 class=pgc-h-arrow-right>3.2.2 這麼做的後果？</h1><ul><li>在這2MSL等待時間內，該連接（socket，ip+port）將不能被使用</li><li>很多時候linux上報too many open files，說端口不夠用了，就需要檢查一些代碼裡面是不是創建大量的socket連接，而這些socket連接並不是關閉後就立馬釋放的</li><li>客戶端連接服務器的時候，一般不指定客戶端的端口。因為客戶端關閉然後立馬啟動，按照理論來說是會提示端口被佔用。同樣的道理，主動關閉服務器，2MSL時間內立馬啟動是會報端口被佔用的錯誤</li><li>多併發的短連接情況下，會出現大量的Time_wait狀態。這兩個參數可以解決問題，但是它違背了tcp協議，是有風險的。參數為：tcp_tw_reuse和tcp_tw_recycle</li><li>如果是服務端開發，可設置keep-alive，讓客戶端主動關閉連接解決這個問題</li></ul><h1 class=pgc-h-arrow-right>4. 復位報文段</h1><p>一個報文段從源地址發往目的地址，只要出現錯誤，都會發出復位的報文段，首部字段的RST是用於“復位”的。這些錯誤包括以下情況</p><ul><li>端口沒有在監聽</li><li>異常中止：通過發送RST而不是fin來中止連接</li></ul><h1 class=pgc-h-arrow-right>5. 同時打開</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7951780f0f32495f80f3f6d8d37a1b99><p class=pgc-img-caption></p></div><ul><li>兩個應用程序同時執行主動打開，稱為“同時打開“</li><li>這種情況極少發生</li><li>兩端同時發送SYN，同時進入SYN_SENT狀態</li><li>打開一條連接而不是兩條</li><li>要進行四次報文交換過程，“四次握手”</li></ul><h1 class=pgc-h-arrow-right>6. 同時關閉</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9ed1cba1a17451792c9863e995aa4e0><p class=pgc-img-caption></p></div><ul><li>雙方同時執行主動關閉</li><li>進行四次報文交換</li><li>狀態和正常關閉不一樣</li></ul><h1 class=pgc-h-arrow-right>7. 服務器對於併發請求的處理</h1><ul><li>正等待連接的一端有一個固定長度的隊列（長度叫做“積壓值”，大多數情況長度為5）</li><li>該隊列中的連接為：已經完成了三次握手，但還沒有被應用層接收（應用層需要等待最後一個ack收到後才知道這個連接）</li><li>應用層接收請求的連接，將從該隊列中移除</li><li>當新的請求到來時，先判斷隊列情況來決定是否接收這個連接</li><li>積壓值的含義：tcp監聽的端點已經被tcp接收，但是等待應用層接收的最大值。與系統允許的最大連接數，服務器接收的最大併發數無關</li></ul><h1 class=pgc-h-arrow-right>三. 數據的傳輸</h1><h1 class=pgc-h-arrow-right>1. tcp傳輸的數據分類</h1><ul><li>成塊數據傳輸：量大，報文段常常滿</li><li>交互數據傳輸：量小，報文段為微小分組，大量微小分組，在廣域網傳輸會增加擁堵的出現</li><li>tcp處理的數據包括兩類，有不同的特點，需要不同的傳輸技術</li></ul><h1 class=pgc-h-arrow-right>2. 交互數據的傳輸技術</h1><h1 class=pgc-h-arrow-right>2.1 經受時延的確認</h1><ul><li>概念：tcp收到數據時，並不立馬發送ack確認，而是稍後發送</li><li>目的：將ack與需要沿該方向發送的數據一起發送，以減少開銷</li><li>特點：接收方不必確認每一個收到的分組，ACk是累計的，它表示接收方已經正確收到了一直到確認序號-1的所有字節</li><li>延時時間：絕大多數為200ms。不能超過500ms</li></ul><h1 class=pgc-h-arrow-right>2.2 Nagle算法</h1><ul><li>解決什麼問題：微小分組導致在廣域網出現的擁堵問題</li><li>核心：減少了通過廣域網傳輸的小分組數目</li><li>原理：要求一個tcp連接上最多只能有一個未被確認的未完成的分組，該分組的確認到達之前，不能發送其他分組。tcp收集這些分組，確認到來之前以一個分組的形式發出去</li><li>優點：自適應。確認到達的快，數據發送越快。確認慢，發送更少的組。</li><li>使用注意：局域網很少使用該算法。且有些特殊場景需要禁用該算法</li></ul><h1 class=pgc-h-arrow-right>3. 成塊數據的傳輸</h1><ul><li>主要使用滑動窗口協議</li></ul><h1 class=pgc-h-arrow-right>四. 滑動窗口協議</h1><h1 class=pgc-h-arrow-right>1. 概述</h1><ul><li>解決了什麼問題：發送方和接收方速率不匹配時，保證可靠傳輸和包亂序的問題</li><li>機制：接收方根據目前緩衝區大小，通知發送方目前能接收的最大值。發送方根據接收方的處理能力來發送數據。通過這種協調機制，防止接收端處理不過來。</li><li>窗口大小：接收方發給發送端的這個值稱為窗口大小</li></ul><h1 class=pgc-h-arrow-right>2. tcp緩衝區的數據結構</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f4573f36bfd74becb0fcaa68f02b9245><p class=pgc-img-caption></p></div><ul><li>接收端： LastByteRead: 緩衝區讀取到的位置 NextByteExpected：收到的連續包的最後一個位置 LastByteRcvd：收到的包的最後一個位置 中間空白區：數據沒有到達</li><li>發送端： LastByteAcked: 被接收端ack的位置，表示成功發送確認 LastByteSent：發出去了，還沒有收到成功確認的Ack LastByteWritten：上層應用正在寫的地方</li></ul><h1 class=pgc-h-arrow-right>3. 滑動窗口示意圖</h1><h1 class=pgc-h-arrow-right>3.1 初始時示意圖</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/23a14db85e3c44a383323e39f9fd35a3><p class=pgc-img-caption></p></div><ul><li>黑框表示滑動窗口</li><li>#1表示收到ack確認的數據</li><li>#2表示還沒收到ack的數據</li><li>#3表示在窗口中還沒有發出的（接收方還有空間）</li><li>#4窗口以外的數據（接收方沒空間）</li></ul><h1 class=pgc-h-arrow-right>3.2 滑動過程示意圖</h1><div class=pgc-img><img alt=TCP協議詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/798b1c9293244f9fa666f104e886fab1><p class=pgc-img-caption></p></div><ul><li>收到36的ack，併發出46-51的字節</li></ul><h1 class=pgc-h-arrow-right>4. 擁塞窗口</h1><ul><li>解決什麼問題：發送方發送速度過快，導致中轉路由器擁堵的問題</li><li>機制：發送方增加一個擁塞窗口（cwnd），每次受到ack，窗口值加1。發送時，取擁塞窗口和接收方發來的窗口大小取最小值發送</li><li>起到發送方流量控制的作用</li></ul><h1 class=pgc-h-arrow-right>5. 滑動窗口會引發的問題</h1><h1 class=pgc-h-arrow-right>5.1 零窗口</h1><ul><li>如何發生： 接收端處理速度慢，發送端發送速度快。窗口大小慢慢被調為0</li><li>如何解決：ZWP技術。發送zwp包給接收方，讓接收方ack他的窗口大小。</li></ul><h1 class=pgc-h-arrow-right>5.2 糊塗窗口綜合徵</h1><ul><li>如何發生：接收方太忙，取不完數據，導致發送方越來越小。最後只讓發送方傳幾字節的數據。</li><li>缺點：數據比tcp和ip頭小太多，網絡利用率太低。</li><li>如何解決：避免對小的窗口大小做響應。 發送端：前面說到的Nagle算法。 接收端：窗口大小小於某個值，直接ack（0），阻止發送數據。窗口變大後再發。</li></ul><h1 class=pgc-h-arrow-right>五. 超時與重傳</h1><h1 class=pgc-h-arrow-right>1. 概述</h1><ul><li>tcp提供可靠的運輸層，使用的方法是確認機制。</li><li>但是數據和確認都有可能丟失</li><li>tcp通過在發送時設置定時器解決這種問題</li><li>定時器時間到了還沒收到確認，就重傳該數據</li></ul><h1 class=pgc-h-arrow-right>2. tcp管理的定時器類型</h1><ul><li>重傳定時器：等待收到確認</li><li>堅持定時器：使窗口大小信息保持不斷流動</li><li>保活定時器：檢測空閒連接崩潰或重啟</li><li>2MSL定時器：檢測time_wait狀態</li></ul><h1 class=pgc-h-arrow-right>3. 超時重傳機制</h1><h1 class=pgc-h-arrow-right>3.1 背景</h1><ul><li>接收端給發送端的Ack確認只會確認最後一個連續的包</li><li>比如發送1,2,3,4,5共五份數據，接收端收到1,2，於是回ack3，然後收到4（還沒收到3），此時tcp不會跳過3直接確認4，否則發送端以為3也收到了。這時你能想到的方法是什麼呢？tcp又是怎麼處理的呢？</li></ul><h1 class=pgc-h-arrow-right>3.1 被動等待的超時重傳策略</h1><ul><li>直觀的方法是：接收方不做任何處理，等待發送方超時，然後重傳。 缺點：發送端不知道該重發3，還是重發3,4,5</li><li>如果發送方如果只發送3：節省寬度，但是慢</li><li>如果發送方如果發送3,4,5：快，但是浪費寬帶</li><li>總之，都在被動等待超時，超時可能很長。所以tcp不採用此方法</li></ul><h1 class=pgc-h-arrow-right>3.2 主動的快速重傳機制</h1><h1 class=pgc-h-arrow-right>3.2.1 概述</h1><ul><li>名稱為：Fast Retransmit</li><li>不以實際驅動，而以數據驅動重傳</li></ul><h1 class=pgc-h-arrow-right>3.2.2 實現原理</h1><ul><li>如果包沒有送達，就一直ack最後那個可能被丟的包</li><li>發送方連續收到3相同的ack，就重傳。不用等待超時</li><li>圖中發生1,2,3,4,5數據</li><li>數據1到達，發生ack2</li><li>數據2因為某些原因沒有送到</li><li>後續收到3的時候，接收端並不是ack4，也不是等待。而是主動ack2</li><li>收到4,5同理，一直主動ack2</li><li>客戶端收到三次ack2，就重傳2</li><li>2收到後，結合之前收到的3,4,5，直接ack6</li></ul><h1 class=pgc-h-arrow-right>3.2.3 快速重傳的利弊</h1><ul><li>解決了被動等待timeout的問題</li><li>無法解決重傳之前的一個，還是所有的問題。</li><li>上面的例子中是重傳2，還是重傳2,3,4,5。因為並不清楚ack2是誰傳回來的</li></ul><h1 class=pgc-h-arrow-right>3.3 SACK方法</h1><h1 class=pgc-h-arrow-right>3.3.1 概述</h1><ul><li>為了解決快速重傳的缺點，一種更好的SACK重傳策略被提出</li><li>基於快速重傳，同時在tcp頭裡加了一個SACK的東西</li><li>解決了什麼問題：客戶端應該發送哪些超時包的問題</li></ul><h1 class=pgc-h-arrow-right>3.3.2 實現原理</h1><ul><li>SACK記錄一個數值範圍，表示哪些數據收到了</li><li>linux2.4後默認打開該功能，之前版本需要配置tcp-sack參數</li><li>SACK只是一種輔助的方式，發送方不能完全依賴SACK。主要還是依賴ACK和timout</li></ul><h1 class=pgc-h-arrow-right>3.3.3 Duplicate SACK(D-SACK)</h1><ul><li>使用SACK標識的範圍，還可以知道告知發送方，有哪些數據被重複接收了</li><li>可以讓發送方知道：是發出去的包丟了，還是回來的ack包丟了</li></ul><h1 class=pgc-h-arrow-right>4. 超時時間的確定</h1><h1 class=pgc-h-arrow-right>4.1 背景</h1><ul><li>路由器和網絡流量均會變化</li><li>所以超時時間肯定不能設置為一個固定值</li><li>超時長：重發慢，效率低，性能差</li><li>超時短：並沒有丟就重發，導致網絡擁塞，導致更多超時和更多重發</li><li>tcp會追蹤這些變化，並相應的動態改變超時時間（RTO）</li></ul><h1 class=pgc-h-arrow-right>4.2 如何動態改變</h1><ul><li>每次重傳的時間間隔為上次的一倍，直到最大間隔為64s，稱為“指數退避”</li><li>首次重傳到最後放棄重傳的時間間隔一般為9min</li><li>依賴以往的往返時間計算（RTT）動態的計算</li></ul><h1 class=pgc-h-arrow-right>4.3 往返時間（RTT）的計算方法</h1><ul><li>並不是簡單的ack時間和發送時間的差值。因為有重傳，網絡阻塞等各種變化的因素。</li><li>而是通過採樣多次數值，然後做估算</li><li>tcp使用的方法有： 被平滑的RTT估計器 被平滑的均值偏差估計器</li></ul><h1 class=pgc-h-arrow-right>4.4. 重傳時間的具體計算</h1><ul><li>計算往返時間（RTT），保存測量結果</li><li>通過測量結果維護一個被平滑的RTT估計器和被平滑的均值偏差估計器</li><li>根據這兩個估計器計算下一次重傳時間</li></ul><h1 class=pgc-h-arrow-right>5. 超時重傳引發的問題-擁塞</h1><h1 class=pgc-h-arrow-right>5.1 為什麼重傳會引發擁塞</h1><ul><li>當網絡延遲突然增加時，tcp會重傳數據</li><li>但是過多的重傳會導致網絡負擔加重，從而導致更大的延時和丟包，進入惡性循環</li><li>也就是tcp的擁塞問題</li></ul><h1 class=pgc-h-arrow-right>5.2 解決擁塞-擁塞控制的算法</h1><ul><li>慢啟動：降低分組進入網絡的傳輸速率</li><li>擁塞避免：處理丟失分組的算法</li><li>快速重傳</li><li>快速恢復</li></ul><h1 class=pgc-h-arrow-right>六. 其他定時器</h1><h1 class=pgc-h-arrow-right>1. 堅持定時器</h1><h1 class=pgc-h-arrow-right>1.1 堅持定時器存在的意義</h1><ul><li>當窗口大小為0時，接收方會發送一個沒有數據，只有窗口大小的ack</li><li>但是，如果這個ack丟失了會出現什麼問題？雙方可能因為等待而中止連接</li><li>堅持定時器週期性的向接收方查詢窗口是否被增大。這些發出的報文段稱為窗口探查</li></ul><h1 class=pgc-h-arrow-right>1.2 堅持定時器啟動時機</h1><ul><li>發送方被通告接收方窗口大小為0時</li></ul><h1 class=pgc-h-arrow-right>1.3 與超時重傳的相同和不同</h1><ul><li>相同：同樣的重傳時間間隔</li><li>不同：窗口探查從不放棄發送，直到窗口被打開或者進程被關閉。而超時重傳到一定時間就放棄發送</li></ul><h1 class=pgc-h-arrow-right>2. 保活定時器</h1><h1 class=pgc-h-arrow-right>2.1 保活定時器存在的意義</h1><ul><li>當tcp上沒有數據傳輸時，服務器如何檢測到客戶端是否還存活</li></ul><p><br>作者：kinnylee</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>TCP</a></li><li><a>協議</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/049e5b0.html alt="TCP協議詳解 - TCP狀態轉移" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/11f74803a5c140f48e7d9c1a6aa0ae30 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/049e5b0.html title="TCP協議詳解 - TCP狀態轉移">TCP協議詳解 - TCP狀態轉移</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3b2329.html alt=詳解TCP協議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd966a2fb304494dae57421d89b70389 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3b2329.html title=詳解TCP協議>詳解TCP協議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d5a515e.html alt=理解HTTP協議－HTTP協議詳解總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1f9dd54a51c344d9be602aa94f72056e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d5a515e.html title=理解HTTP協議－HTTP協議詳解總結>理解HTTP協議－HTTP協議詳解總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce824d7f.html alt=淺談TCP協議（建立與斷開連接） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4112ca2d63f04cddae0aadca168ea063 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce824d7f.html title=淺談TCP協議（建立與斷開連接）>淺談TCP協議（建立與斷開連接）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ef9ee79.html alt="OAuth2 協議詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/bf91cb3c7e7c411e9910d22a6df2cf4f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ef9ee79.html title="OAuth2 協議詳解">OAuth2 協議詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1a9e79e.html alt=CAN總線協議詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/72c49427aae34856b73a5f367c1f2c28 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1a9e79e.html title=CAN總線協議詳解>CAN總線協議詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d611ad93.html alt=DNS協議詳解及報文格式分析「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e50900c300af44348cbcd47341825485 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d611ad93.html title=DNS協議詳解及報文格式分析「轉」>DNS協議詳解及報文格式分析「轉」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5eef641.html alt=SPI協議詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/30e622a233f8489798892e001006ea4a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5eef641.html title=SPI協議詳解>SPI協議詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e566ae8.html alt="TCP 協議快被淘汰了，UDP 協議才是新世代的未來？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/b0c59e7c-978c-4b8e-b40c-52d64954c164 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e566ae8.html title="TCP 協議快被淘汰了，UDP 協議才是新世代的未來？">TCP 協議快被淘汰了，UDP 協議才是新世代的未來？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ca6ff7.html alt=TCP協議總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153156590409218ee54748f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ca6ff7.html title=TCP協議總結>TCP協議總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1bd1e17.html alt=一文讀懂TCP/IP協議工作原理和工作流程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ea27784370b9441090baaf9c8cf57977 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1bd1e17.html title=一文讀懂TCP/IP協議工作原理和工作流程>一文讀懂TCP/IP協議工作原理和工作流程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e347b4c.html alt=網絡協議-TCP和UDP最完整的區別介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/4fa7c983-2109-4db9-84ec-5431e01c87ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e347b4c.html title=網絡協議-TCP和UDP最完整的區別介紹>網絡協議-TCP和UDP最完整的區別介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7308701.html alt=網絡協議之TCP和UDP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/50f23be4fe764f69ab2ed27288e88510 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7308701.html title=網絡協議之TCP和UDP>網絡協議之TCP和UDP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8ebfea.html alt="TCP 協議概覽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2f900e98cdba494993003fef43aba139 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8ebfea.html title="TCP 協議概覽">TCP 協議概覽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13955a3.html alt="TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8f291e6a61fa4b45a91b81f2589002c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13955a3.html title="TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）">TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>