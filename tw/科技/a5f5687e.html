<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>標題黨？NO!NO!NO!全網閱讀過20k的Java集合框架常見面試題總結 | 极客快訊</title><meta property="og:title" content="標題黨？NO!NO!NO!全網閱讀過20k的Java集合框架常見面試題總結 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/0c79f3baedb84935a1992f38fb3da703"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a5f5687e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a5f5687e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a5f5687e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a5f5687e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a5f5687e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a5f5687e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a5f5687e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a5f5687e.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="標題黨？NO!NO!NO!全網閱讀過20k的Java集合框架常見面試題總結"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a5f5687e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>標題黨？NO!NO!NO!全網閱讀過20k的Java集合框架常見面試題總結</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1>剖析面試最常見問題之Java集合框架</h1><p>當了會標題黨，這是第一次，後面還有很多次！不過這文章全網閱讀肯定是超過 20 k 的，而且經過了很多同行的優化，質量有保障哦！</p><div class=pgc-img><img alt=標題黨？NO!NO!NO!全網閱讀過20k的Java集合框架常見面試題總結 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0c79f3baedb84935a1992f38fb3da703><p class=pgc-img-caption></p></div><h1>說說List,Set,Map三者的區別？</h1><ul><li><strong>List(對付順序的好幫手)：</strong> List接口存儲一組不唯一（可以有多個元素引用相同的對象），有序的對象</li><li><strong>Set(注重獨一無二的性質):</strong> 不允許重複的集合。不會有多個元素引用相同的對象。</li><li><strong>Map(用Key來搜索的專家):</strong> 使用鍵值對存儲。Map會維護與Key有關聯的值。兩個Key可以引用相同的對象，但Key不能重複，典型的Key是String類型，但也可以是任何對象。</li></ul><h1>Arraylist 與 LinkedList 區別?</h1><ul><li><strong>1. 是否保證線程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保證線程安全；</li><li><strong>2. 底層數據結構：</strong> Arraylist 底層使用的是 <strong>Object 數組</strong>；LinkedList 底層使用的是 <strong>雙向鏈表</strong> 數據結構（JDK1.6之前為循環鏈表，JDK1.7取消了循環。注意雙向鏈表和雙向循環鏈表的區別，下面有介紹到！）</li><li><strong>3. 插入和刪除是否受元素位置的影響：</strong> ① <strong>ArrayList 採用數組存儲，所以插入和刪除元素的時間複雜度受元素位置的影響。</strong> 比如：執行add(E e)方法的時候， ArrayList 會默認在將指定的元素追加到此列表的末尾，這種情況時間複雜度就是O(1)。但是如果要在指定位置 i 插入和刪除元素的話（add(int index, E element)）時間複雜度就為 O(n-i)。因為在進行上述操作的時候集合中第 i 和第 i 個元素之後的(n-i)個元素都要執行向後位/向前移一位的操作。 ② <strong>LinkedList 採用鏈表存儲，所以對於add(E e)方法的插入，刪除元素時間複雜度不受元素位置的影響，近似 O（1），如果是要在指定位置i插入和刪除元素的話（(add(int index, E element)） 時間複雜度近似為o(n))因為需要先移動到指定位置再插入。</strong></li><li><strong>4. 是否支持快速隨機訪問：</strong> LinkedList 不支持高效的隨機元素訪問，而 ArrayList 支持。快速隨機訪問就是通過元素的序號快速獲取元素對象(對應於get(int index)方法)。</li><li><strong>5. 內存空間佔用：</strong> ArrayList的空 間浪費主要體現在在list列表的結尾會預留一定的容量空間，而LinkedList的空間花費則體現在它的每一個元素都需要消耗比ArrayList更多的空間（因為要存放直接後繼和直接前驅以及數據）。</li></ul><p><strong>補充內容:RandomAccess接口</strong></p><pre>public interface RandomAccess {}複製代碼</pre><p>查看源碼我們發現實際上 RandomAccess 接口中什麼都沒有定義。所以，在我看來 RandomAccess 接口不過是一個標識罷了。標識什麼？ 標識實現這個接口的類具有隨機訪問功能。</p><p>在 binarySearch（）方法中，它要判斷傳入的list 是否 RamdomAccess 的實例，如果是，調用indexedBinarySearch（）方法，如果不是，那麼調用iteratorBinarySearch（）方法</p><pre> public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) { if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); }複製代碼</pre><p>ArrayList 實現了 RandomAccess 接口， 而 LinkedList 沒有實現。為什麼呢？我覺得還是和底層數據結構有關！ArrayList 底層是數組，而 LinkedList 底層是鏈表。數組天然支持隨機訪問，時間複雜度為 O（1），所以稱為快速隨機訪問。鏈表需要遍歷到特定位置才能訪問特定位置的元素，時間複雜度為 O（n），所以不支持快速隨機訪問。，ArrayList 實現了 RandomAccess 接口，就表明了他具有快速隨機訪問功能。 RandomAccess 接口只是標識，並不是說 ArrayList 實現 RandomAccess 接口才具有快速隨機訪問功能的！</p><p><strong>下面再總結一下 list 的遍歷方式選擇：</strong></p><ul><li>實現了 RandomAccess 接口的list，優先選擇普通 for 循環 ，其次 foreach,</li><li>未實現 RandomAccess接口的list，優先選擇iterator遍歷（foreach遍歷底層也是通過iterator實現的,），大size的數據，千萬不要使用普通for循環</li></ul><p>補充內容:雙向鏈表和雙向循環鏈表</p><p><strong>雙向鏈表：</strong> 包含兩個指針，一個prev指向前一個節點，一個next指向後一個節點。</p><p><strong>雙向循環鏈表：</strong> 最後一個節點的 next 指向head，而 head 的prev指向最後一個節點，構成一個環。</p><h1>ArrayList 與 Vector 區別呢?為什麼要用Arraylist取代Vector呢？</h1><p>Vector類的所有方法都是同步的。可以由兩個線程安全地訪問一個Vector對象、但是一個線程訪問Vector的話代碼要在同步操作上耗費大量的時間。</p><p>Arraylist不是同步的，所以在不需要保證線程安全時建議使用Arraylist。</p><p>說一說 ArrayList 的擴容機制吧</p><p>詳見筆主的這篇文章:通過源碼一步一步分析ArrayList 擴容機制</p><h1>HashMap 和 Hashtable 的區別</h1><ol start=1><li><strong>線程是否安全：</strong> HashMap 是非線程安全的，HashTable 是線程安全的；HashTable 內部的方法基本都經過synchronized 修飾。（如果你要保證線程安全的話就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因為線程安全的問題，HashMap 要比 HashTable 效率高一點。另外，HashTable 基本被淘汰，不要在代碼中使用它；</li><li><strong>對Null key 和Null value的支持：</strong> HashMap 中，null 可以作為鍵，這樣的鍵只有一個，可以有一個或多個鍵所對應的值為 null。。但是在 HashTable 中 put 進的鍵值只要有一個 null，直接拋出 NullPointerException。</li><li><strong>初始容量大小和每次擴充容量大小的不同 ：</strong> ①創建時如果不指定容量初始值，Hashtable 默認的初始大小為11，之後每次擴充，容量變為原來的2n+1。HashMap 默認的初始化大小為16。之後每次擴充，容量變為原來的2倍。②創建時如果給定了容量初始值，那麼 Hashtable 會直接使用你給定的大小，而 HashMap 會將其擴充為2的冪次方大小（HashMap 中的tableSizeFor()方法保證，下面給出了源代碼）。也就是說 HashMap 總是使用2的冪作為哈希表的大小,後面會介紹到為什麼是2的冪次方。</li><li><strong>底層數據結構：</strong> JDK1.8 以後的 HashMap 在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間。Hashtable 沒有這樣的機制。</li></ol><p><strong>HashMap 中帶有初始容量的構造函數：</strong></p><pre> public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); }複製代碼</pre><p>下面這個方法保證了 HashMap 總是使用2的冪作為哈希表的大小。</p><pre> /** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }複製代碼</pre><p>HashMap 和 HashSet區別</p><p>如果你看過 HashSet 源碼的話就應該知道：HashSet 底層就是基於 HashMap 實現的。（HashSet 的源碼非常非常少，因為除了 clone()、writeObject()、readObject()是 HashSet 自己不得不實現之外，其他方法都是直接調用 HashMap 中的方法。</p><p>HashMap HashSet 實現了Map接口 實現Set接口 存儲鍵值對 僅存儲對象 調用 put（）向map中添加元素 調用 add（）方法向Set中添加元素 HashMap使用鍵（Key）計算Hashcode HashSet使用成員對象來計算hashcode值，對於兩個對象來說hashcode可能相同，所以equals()方法用來判斷對象的相等性，</p><p>HashSet如何檢查重複</p><p>當你把對象加入HashSet時，HashSet會先計算對象的hashcode值來判斷對象加入的位置，同時也會與其他加入的對象的hashcode值作比較，如果沒有相符的hashcode，HashSet會假設對象沒有重複出現。但是如果發現有相同hashcode值的對象，這時會調用equals（）方法來檢查hashcode相等的對象是否真的相同。如果兩者相同，HashSet就不會讓加入操作成功。（摘自我的Java啟蒙書《Head fist java》第二版）</p><p><strong>hashCode（）與equals（）的相關規定：</strong></p><ol start=1><li>如果兩個對象相等，則hashcode一定也是相同的</li><li>兩個對象相等,對兩個equals方法返回true</li><li>兩個對象有相同的hashcode值，它們也不一定是相等的</li><li>綜上，equals方法被覆蓋過，則hashCode方法也必須被覆蓋</li><li>hashCode()的默認行為是對堆上的對象產生獨特值。如果沒有重寫hashCode()，則該class的兩個對象無論如何都不會相等（即使這兩個對象指向相同的數據）。</li></ol><p><strong>==與equals的區別</strong></p><ol start=1><li>==是判斷兩個變量或實例是不是指向同一個內存空間 equals是判斷兩個變量或實例所指向的內存空間的值是不是相同</li><li>==是指對內存地址進行比較 equals()是對字符串的內容進行比較</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><p>HashMap的底層實現</p><p>JDK1.8之前</p><p>JDK1.8 之前 HashMap 底層是 <strong>數組和鏈表</strong> 結合在一起使用也就是 <strong>鏈表散列</strong>。<strong>HashMap 通過 key 的 hashCode 經過擾動函數處理過後得到 hash 值，然後通過 (n - 1) & hash 判斷當前元素存放的位置（這裡的 n 指的是數組的長度），如果當前位置存在元素的話，就判斷該元素與要存入的元素的 hash 值以及 key 是否相同，如果相同的話，直接覆蓋，不相同就通過拉鍊法解決衝突。</strong></p><p><strong>所謂擾動函數指的就是 HashMap 的 hash 方法。使用 hash 方法也就是擾動函數是為了防止一些實現比較差的 hashCode() 方法 換句話說使用擾動函數之後可以減少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源碼:</strong></p><p>JDK 1.8 的 hash方法 相比於 JDK 1.7 hash 方法更加簡化，但是原理不變。</p><pre> static final int hash(Object key) { int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位異或 // &gt;&gt;&gt;:無符號右移，忽略符號位，空位都以0補齊 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); }複製代碼</pre><p>對比一下 JDK1.7的 HashMap 的 hash 方法源碼.</p><pre>static int hash(int h) { // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}複製代碼</pre><p>相比於 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能會稍差一點點，因為畢竟擾動了 4 次。</p><p>所謂 <strong>“拉鍊法”</strong> 就是：將鏈表和數組相結合。也就是說創建一個鏈表數組，數組中每一格就是一個鏈表。若遇到哈希衝突，則將衝突的值加到鏈表中即可。</p><p>JDK1.8之後</p><p>相比於之前的版本， JDK1.8之後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><blockquote><p>TreeMap、TreeSet以及JDK1.8之後的HashMap底層都用到了紅黑樹。紅黑樹就是為了解決二叉查找樹的缺陷，因為二叉查找樹在某些情況下會退化成一個線性結構。</p></blockquote><p><strong>推薦閱讀：</strong></p><ul><li>《Java 8系列之重新認識HashMap》 ：zhuanlan.zhihu.com/p/21673805</li></ul><p>HashMap 的長度為什麼是2的冪次方</p><p>為了能讓 HashMap 存取高效，儘量較少碰撞，也就是要儘量把數據分配均勻。我們上面也講到了過了，Hash 值的範圍值-2147483648到2147483647，前後加起來大概40億的映射空間，只要哈希函數映射得比較均勻鬆散，一般應用是很難出現碰撞的。但問題是一個40億長度的數組，內存是放不下的。所以這個散列值是不能直接拿來用的。用之前還要先做對數組的長度取模運算，得到的餘數才能用來要存放的位置也就是對應的數組下標。這個數組下標的計算方法是“ (n - 1) & hash”。（n代表數組長度）。這也就解釋了 HashMap 的長度為什麼是2的冪次方。</p><p><strong>這個算法應該如何設計呢？</strong></p><p>我們首先可能會想到採用%取餘的操作來實現。但是，重點來了：<strong>“取餘(%)操作中如果除數是2的冪次則等價於與其除數減一的與(&)操作（也就是說 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。”</strong> 並且 <strong>採用二進制位操作 &，相對於%能夠提高運算效率，這就解釋了 HashMap 的長度為什麼是2的冪次方。</strong></p><p>HashMap 多線程操作導致死循環問題</p><p>主要原因在於 併發下的Rehash 會造成元素之間會形成一個循環鏈表。不過，jdk 1.8 後解決了這個問題，但是還是不建議在多線程下使用 HashMap,因為多線程下使用 HashMap 還是會存在其他問題比如數據丟失。併發環境下推薦使用 ConcurrentHashMap 。</p><p>詳情請查看：coolshell.cn/articles/96…</p><p>ConcurrentHashMap 和 Hashtable 的區別</p><p>ConcurrentHashMap 和 Hashtable 的區別主要體現在實現線程安全的方式上不同。</p><ul><li><strong>底層數據結構：</strong> JDK1.7的 ConcurrentHashMap 底層採用 <strong>分段的數組+鏈表</strong> 實現，JDK1.8 採用的數據結構跟HashMap1.8的結構一樣，數組+鏈表/紅黑二叉樹。Hashtable 和 JDK1.8 之前的 HashMap 的底層數據結構類似都是採用 <strong>數組+鏈表</strong> 的形式，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的；</li><li><strong>實現線程安全的方式（重要）：</strong> ① <strong>在JDK1.7的時候，ConcurrentHashMap（分段鎖）</strong> 對整個桶數組進行了分割分段(Segment)，每一把鎖只鎖容器其中一部分數據，多線程訪問容器裡不同數據段的數據，就不會存在鎖競爭，提高併發訪問率。 <strong>到了 JDK1.8 的時候已經摒棄了Segment的概念，而是直接用 Node 數組+鏈表+紅黑樹的數據結構來實現，併發控制使用 synchronized 和 CAS 來操作。（JDK1.6以後 對 synchronized鎖做了很多優化）</strong> 整個看起來就像是優化過且線程安全的 HashMap，雖然在JDK1.8中還能看到 Segment 的數據結構，但是已經簡化了屬性，只是為了兼容舊版本；② <strong>Hashtable(同一把鎖)</strong> :使用 synchronized 來保證線程安全，效率非常低下。當一個線程訪問同步方法時，其他線程也訪問同步方法，可能會進入阻塞或輪詢狀態，如使用 put 添加元素，另一個線程不能使用 put 添加元素，也不能使用 get，競爭會越來越激烈效率越低。</li></ul><p><strong></strong></p><p>ConcurrentHashMap線程安全的具體實現方式/底層具體實現</p><p>JDK1.7（上面有示意圖）</p><p>首先將數據分為一段一段的存儲，然後給每一段數據配一把鎖，當一個線程佔用鎖訪問其中一個段數據時，其他段的數據也能被其他線程訪問。</p><p><strong>ConcurrentHashMap 是由 Segment 數組結構和 HashEntry 數組結構組成</strong>。</p><p>Segment 實現了 ReentrantLock,所以 Segment 是一種可重入鎖，扮演鎖的角色。HashEntry 用於存儲鍵值對數據。</p><pre>static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {}複製代碼</pre><p>一個 ConcurrentHashMap 裡包含一個 Segment 數組。Segment 的結構和HashMap類似，是一種數組和鏈表結構，一個 Segment 包含一個 HashEntry 數組，每個 HashEntry 是一個鏈表結構的元素，每個 Segment 守護著一個HashEntry數組裡的元素，當對 HashEntry 數組的數據進行修改時，必須首先獲得對應的 Segment的鎖。</p><p>JDK1.8 （上面有示意圖）</p><p>ConcurrentHashMap取消了Segment分段鎖，採用CAS和synchronized來保證併發安全。數據結構跟HashMap1.8的結構類似，數組+鏈表/紅黑二叉樹。Java 8在鏈表長度超過一定閾值（8）時將鏈表（尋址時間複雜度為O(N)）轉換為紅黑樹（尋址時間複雜度為O(log(N))）</p><p>synchronized只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要hash不衝突，就不會產生併發，效率又提升N倍。</p><p>comparable 和 Comparator的區別</p><ul><li>comparable接口實際上是出自java.lang包 它有一個 compareTo(Object obj)方法用來排序</li><li>comparator接口實際上是出自 java.util 包它有一個compare(Object obj1, Object obj2)方法用來排序</li></ul><p>一般我們需要對一個集合使用自定義排序時，我們就要重寫compareTo()方法或compare()方法，當我們需要對某一個集合實現兩種排序方式，比如一個song對象中的歌名和歌手名分別採用一種排序方法的話，我們可以重寫compareTo()方法和使用自制的Comparator方法或者以兩個Comparator來實現歌名排序和歌星名排序，第二種代表我們只能使用兩個參數版的 Collections.sort().</p><p>Comparator定製排序</p><pre> ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); arrayList.add(-1); arrayList.add(3); arrayList.add(3); arrayList.add(-5); arrayList.add(7); arrayList.add(4); arrayList.add(-9); arrayList.add(-7); System.out.println("原始數組:"); System.out.println(arrayList); // void reverse(List list)：反轉 Collections.reverse(arrayList); System.out.println("Collections.reverse(arrayList):"); System.out.println(arrayList); // void sort(List list),按自然排序的升序排序 Collections.sort(arrayList); System.out.println("Collections.sort(arrayList):"); System.out.println(arrayList); // 定製排序的用法 Collections.sort(arrayList, new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); System.out.println("定製排序後："); System.out.println(arrayList);複製代碼</pre><p>Output:</p><pre>原始數組:[-1, 3, 3, -5, 7, 4, -9, -7]Collections.reverse(arrayList):[-7, -9, 4, 7, -5, 3, 3, -1]Collections.sort(arrayList):[-9, -7, -5, -1, 3, 3, 4, 7]定製排序後：[7, 4, 3, 3, -1, -5, -7, -9]複製代碼</pre><p>重寫compareTo方法實現按年齡來排序</p><pre>// person對象沒有實現Comparable接口，所以必須實現，這樣才不會出錯，才可以使treemap中的數據按順序排列// 前面一個例子的String類已經默認實現了Comparable接口，詳細可以查看String類的API文檔，另外其他// 像Integer類等都已經實現了Comparable接口，所以不需要另外實現了public class Person implements Comparable&lt;Person&gt; { private String name; private int age; public Person(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } /** * TODO重寫compareTo方法實現按年齡來排序 */ @Override public int compareTo(Person o) { // TODO Auto-generated method stub if (this.age &gt; o.getAge()) { return 1; } else if (this.age &lt; o.getAge()) { return -1; } return age; }}複製代碼</pre><pre> public static void main(String[] args) { TreeMap&lt;Person, String&gt; pdata = new TreeMap&lt;Person, String&gt;(); pdata.put(new Person("張三", 30), "zhangsan"); pdata.put(new Person("李四", 20), "lisi"); pdata.put(new Person("王五", 10), "wangwu"); pdata.put(new Person("小紅", 5), "xiaohong"); // 得到key的值的同時得到key所對應的值 Set&lt;Person&gt; keys = pdata.keySet(); for (Person key : keys) { System.out.println(key.getAge() + "-" + key.getName()); } }複製代碼</pre><p>Output：</p><pre>5-小紅10-王五20-李四30-張三複制代碼</pre><h1>集合框架底層數據結構總結</h1><p>Collection</p><p>1. List</p><ul><li><strong>Arraylist：</strong> Object數組</li><li><strong>Vector：</strong> Object數組</li><li><strong>LinkedList：</strong> 雙向鏈表(JDK1.6之前為循環鏈表，JDK1.7取消了循環)</li></ul><p>2. Set</p><ul><li><strong>HashSet（無序，唯一）:</strong> 基於 HashMap 實現的，底層採用 HashMap 來保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 繼承於 HashSet，並且其內部是通過 LinkedHashMap 來實現的。有點類似於我們之前說的LinkedHashMap 其內部是基於 HashMap 實現一樣，不過還是有一點點區別的</li><li><strong>TreeSet（有序，唯一）：</strong> 紅黑樹(自平衡的排序二叉樹)</li></ul><p>Map</p><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由數組+鏈表組成的，數組是HashMap的主體，鏈表則是主要為了解決哈希衝突而存在的（“拉鍊法”解決衝突）。JDK1.8以後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 繼承自 HashMap，所以它的底層仍然是基於拉鍊式散列結構即由數組和鏈表或紅黑樹組成。另外，LinkedHashMap 在上面結構的基礎上，增加了一條雙向鏈表，使得上面的結構可以保持鍵值對的插入順序。同時通過對鏈表進行相應的操作，實現了訪問順序相關邏輯。詳細可以查看：《LinkedHashMap 源碼詳細分析（JDK1.8）》</li><li><strong>Hashtable：</strong> 數組+鏈表組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的</li><li><strong>TreeMap：</strong> 紅黑樹（自平衡的排序二叉樹）</li></ul><h1>如何選用集合?</h1><p>主要根據集合的特點來選用，比如我們需要根據鍵值獲取到元素值時就選用Map接口下的集合，需要排序時選擇TreeMap,不需要排序時就選擇HashMap,需要保證線程安全就選用ConcurrentHashMap.當我們只需要存放元素值時，就選擇實現Collection接口的集合，需要保證元素唯一時選擇實現Set接口的集合比如TreeSet或HashSet，不需要就選擇實現List接口的比如ArrayList或LinkedList，然後再根據實現這些接口的集合的特點來選用。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>NO</a></li><li><a>標題</a></li><li><a>全網</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html alt=全網流行的像素風插畫怎麼做？看這篇教程就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c6a523bb05004ed59ac7080c46f41e10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/08542c50.html title=全網流行的像素風插畫怎麼做？看這篇教程就夠了>全網流行的像素風插畫怎麼做？看這篇教程就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d65aa7b.html alt=全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/76ac70f31cde4c3f8b3f073b28660a91 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d65aa7b.html title=全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？>全網最強軍工股，13連陽逆勢漲停20.04%！後市何去何從？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/abb4a186.html alt="這應該是全網講解JAVA 異常處理最全的文章了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b29b2b140f7e4922b0f2ecdff264f228 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/abb4a186.html title="這應該是全網講解JAVA 異常處理最全的文章了">這應該是全網講解JAVA 異常處理最全的文章了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b34e2a54.html alt=全網首測——你們等的米家新風機來了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cd719d0cbcf64b9d81fdcd41fca0807e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b34e2a54.html title=全網首測——你們等的米家新風機來了>全網首測——你們等的米家新風機來了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d30a492.html alt=連個標題都不會起，腦子呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S5XgarIf9ZsyB style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d30a492.html title=連個標題都不會起，腦子呢？>連個標題都不會起，腦子呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5bf32589.html alt=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ecdce8a25bde4964bbfb879fdb8f6e5f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5bf32589.html title=全網分析HTTP協議最全的一篇文章，程序員趕緊收藏>全網分析HTTP協議最全的一篇文章，程序員趕緊收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56fc41c3.html alt=全網最詳細電動機故障維修 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56fc41c3.html title=全網最詳細電動機故障維修>全網最詳細電動機故障維修</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/41cbc751.html alt=全網最具收藏價值的塑膠模具知識，趕緊下手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/71c977a3b6f44ec49892829503350260 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/41cbc751.html title=全網最具收藏價值的塑膠模具知識，趕緊下手>全網最具收藏價值的塑膠模具知識，趕緊下手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f2745470.html alt=你還在為設計對話框和小標題板發愁嗎？看過來，是不是很有愛啊！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/593b0005178942ac894b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f2745470.html title=你還在為設計對話框和小標題板發愁嗎？看過來，是不是很有愛啊！>你還在為設計對話框和小標題板發愁嗎？看過來，是不是很有愛啊！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/813d6eae.html alt=追劇人的福音，全網Vip影視免費看，再不用去借會員去追劇了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a44e01191f6341deb12703571793ce4f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/813d6eae.html title=追劇人的福音，全網Vip影視免費看，再不用去借會員去追劇了>追劇人的福音，全網Vip影視免費看，再不用去借會員去追劇了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d3b0d02.html alt=大家給起個標題吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d3b0d02.html title=大家給起個標題吧>大家給起個標題吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b71aac4.html alt=寶貝上架如何取一個好的商品標題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/c7b72131-a437-4001-b324-5a8e1fd6f2bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b71aac4.html title=寶貝上架如何取一個好的商品標題>寶貝上架如何取一個好的商品標題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f727d257.html alt=店鋪商品標題寫法與關鍵詞編寫公式（整理分享） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/42bab6ce-6849-47cb-9985-58df13d0bfdd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f727d257.html title=店鋪商品標題寫法與關鍵詞編寫公式（整理分享）>店鋪商品標題寫法與關鍵詞編寫公式（整理分享）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22b4058c.html alt=愛採購｜教你寫好商品標題，優化展現效果 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1e112cc269d543a6a132e2293c446ee4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22b4058c.html title=愛採購｜教你寫好商品標題，優化展現效果>愛採購｜教你寫好商品標題，優化展現效果</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/349511ba.html alt=零基礎學淘寶——商品標題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29dff71bbfc64faea2c8052d3421881f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/349511ba.html title=零基礎學淘寶——商品標題>零基礎學淘寶——商品標題</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>