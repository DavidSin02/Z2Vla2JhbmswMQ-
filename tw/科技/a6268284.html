<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C#客戶端和服務端通信的幾種方法：Rest和GRPC和其他 | 极客快訊</title><meta property="og:title" content="C#客戶端和服務端通信的幾種方法：Rest和GRPC和其他 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ce1e708de336421eb2253ae0934a235f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6268284.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><meta property="article:published_time" content="2020-11-14T21:03:40+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:40+08:00"><meta name=Keywords content><meta name=description content="C#客戶端和服務端通信的幾種方法：Rest和GRPC和其他"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a6268284.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C#客戶端和服務端通信的幾種方法：Rest和GRPC和其他</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>本文來自：https://michaelscodingspot.com/rest-vs-grpc-for-asp-net/</p><p><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在C＃客戶端和C＃服務器之間進行通信的方法有很多。一些功能強大，而其他功能則不是很多。有些非常快，有些則不是。知道不同的選擇很重要，這樣您才能決定最適合自己的選擇。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">本文將介紹當今最流行的技術，以及為何如此廣泛地使用它們。我們將討論REST，gRPC及其兩者之間的所有內容。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">最佳方案</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">讓我們考慮一下我們希望如何在最佳環境中使客戶端與服務器之間的通信看起來像。我在想像這樣的東西：</span></p><pre><code>// on client sidepublic void Foo(){    var server = new MyServer(new Uri("https://www.myserver.com/");)    int sum = server.Calculator.SumNumbers(12,13); }</code></pre><pre><code>// on server sideclass CalculatorController : Controller{    public int SumNumbers(int a, int b)    {        return a + b;    }}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我當然想要完整的Intellisense。當我單擊 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">server</span> 並 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.</span> 希望Visual Studio顯示所有控制器時。當我單擊 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">CalculatorController</span> 和時 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.</span> ，我想查看所有操作。我還想要一流的性能，很少的網絡負載和雙向通信。而且我想要一個能夠完美處理版本控制的強大系統，這樣我就可以毫不費力地部署新的客戶端版本和新的服務器版本。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">要求太多嗎？</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">請注意，我在這裡談論的是 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">無狀態</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> API。這等效於C＃項目，其中只有兩種類型的類：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• 靜態類，只有靜態方法。 • POCO類 [1] 僅具有類型為基本類型或其他POCO類的字段和屬性。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在API中使用狀態會帶來複雜性，而這正是萬惡之源。因此，為了本文的方便，讓我們保持美好和無狀態。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">傳統REST</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">REST API出現在2000年代初期，席捲了整個互聯網。到目前為止，它是創建Web服務的最流行的方法。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">REST為客戶端到服務器的請求定義了一組固定的操作 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">GET，POST，PUT</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 和 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">DELETE</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 。每個請求都將通過包含有效負載（通常為JSON）的響應來回答。請求包含在查詢本身中的參數，或者在它是POST請求時包含為有效負載（通常為JSON）的參數。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有一個稱為RESTful API的標準，它定義了以下規則（您實際上不必使用它）：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• GET用於檢索資源 • PUT用於更改資源狀態 • POST用於創建資源 • DELETE用於刪除資源</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">如果您到目前為止還不熟悉REST，則上面的解釋可能不會減少它，因此這裡有一個示例。在.NET中，內置了對REST的支持。實際上，默認情況下，ASP.NET Web API被構建為REST Web服務。這是典型的客戶端和ASP.NET服務器的外觀：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在服務器中：</span></p><pre><code>[Route("People")]public class PeopleController : Controller{    [HttpGet]    public Person GetPersonById(int id)    {        Person person = _db.GetPerson(id);        return person;//Automatically serialized to JSON    }}   </code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在客戶中：</span></p><pre><code>var client = new HttpClient();string resultJson =     await client.GetStringAsync("https://www.myserver.com/People/GetPersonById?id=123");Person person = JsonConvert.DeserializeObject&lt;Person&gt;(resultJson);</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">REST非常方便，但是並沒有達到最佳方案。因此，讓我們看看是否可以做得更好。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">ReFit</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">ReFit不能替代REST。相反，它建立在REST之上，並允許我們像調用簡單方法一樣調用服務器端點。這是通過在客戶端和服務器之間共享接口來實現的。在服務器端，您的控制器將實現一個接口：</span></p><pre><code>public interface IMyEmployeeApi{    [Get("/employee/{id}")]    Task&lt;Employee&gt; GetEmployee(string id);}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">然後，在客戶端，您需要包括相同的接口並使用以下代碼：</span></p><pre><code>var api = RestService.For&lt;IMyEmployeeApi&gt;("https://www.myserver.com");var employee = await api.GetEmployee("abc");</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">就這麼簡單。除了幾個NuGet軟件包外，無需運行困難的自動化程序或使用任何第三方工具。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這更接近最佳方案。現在，我們有了IntelliSense，並且客戶端和服務器之間的合同很牢固。但是還有另一種選擇，在某些方面甚至更好。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">昂首闊步</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">像ReFit一樣，Swagger也建立在REST之上。 OpenAPI [2] 或 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Swagger</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 是REST API的規範。它描述了具有簡單JSON文件的REST Web服務。這些文件是Web服務的API架構。它們包括：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• API中的所有路徑（URL）。 • 每個路徑的預期操作（GET，POST等）。每個路徑可以處理不同的操作。例如，單個路徑 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">https://mystore.com/Product</span> 可能接受添加產品的POST操作和返回產品的GET操作。 • 每個路徑和操作的預期參數。 • 每個路徑的預期響應。 • 每個參數和響應對象的類型。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">該JSON文件實質上是客戶端和服務器之間的合同。這是一個描述一個稱為 Swagger Petstore [3] 的Web服務的swagger文件的示例（為清楚起見，我刪除了一些部分）：</span></p><pre><code>{    "swagger":"2.0",   "info":{       "version":"1.0.0",      "title":"Swagger Petstore",      "description":"A sample API that uses a petstore as an example to demonstrate features in the swagger-2.0 specification",   },   "host":"petstore.swagger.io",   "basePath":"/api",   "schemes":[       "http"   ],   "consumes":[       "application/json"   ],   "produces":[       "application/json"   ],   "paths":{       "/pets":{          "get":{             "description":"Returns all pets from the system that the user has access to",            "operationId":"findPets",            "produces":[                "application/json",               "application/xml",            ],            "parameters":[                {                   "name":"tags",                  "in":"query",                  "description":"tags to filter by",                  "required":false,                  "type":"array",                  "items":{                      "type":"string"                  },                  "collectionFormat":"csv"               },               {                   "name":"limit",                  "in":"query",                  "description":"maximum number of results to return",                  "required":false,                  "type":"integer",                  "format":"int32"               }            ],            "responses":{                "200":{                   "description":"pet response",                  "schema":{                      "type":"array",                     "items":{                         "$ref":"#/definitions/Pet"                     }                  }               },...</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">讓我們考慮一下這個結果。使用上面的JSON文件，您可以潛在地創建具有完整IntelliSense的C＃客戶端。畢竟，您知道所有路徑，操作，它們期望的參數，什麼參數類型，什麼是響應等等。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有幾種工具可以做到這一點。對於服務器端，可以使用 Swashbuckle.AspNetCore [4] 將Swagger添加到ASP.NET中並生成所述JSON文件。對於客戶端，您可以使用 swagger-codegen [5] 和 AutoRest [6] 來使用這些JSON文件並生成客戶端。讓我們看一個如何做到這一點的例子：</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">將Swagger添加到ASP.NET服務器</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">首先添加NuGet包 Swashbuckle.AspNetCore [7] 。在中 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ConfigureServices</span> ，註冊Swagger生成器：</p><pre><code>services.AddSwaggerGen(options =&gt;     options.SwaggerDoc("v1", new OpenApiInfo {Title = "My Web API", Version = "v1"}));</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在添加 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Configure</span> 方法中 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Startup.cs</span> ：</p><pre><code>app.UseSwagger();</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">最後，控制器內部的動作應使用 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[HttpXXX]</span> 和 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[FromXXX]</span> 屬性修飾：</p><pre><code>[HttpPost]public async Task AddEmployee([FromBody]Employee employee){    //...}[HttpGet]public async Task&lt;Employee&gt; Employee([FromQuery]string id){    //...}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">就像服務器端一樣簡單。運行項目時， </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">swagger.json</span> 將生成一個文件，可用於生成客戶端。</p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">使用AutoRest從Swagger生成客戶端</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">要開始使用 AutoRest [8] ，與安裝 NPM [9] ： </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">npm install -g autorest</span> 。安裝後，您將需要使用AutoRest的命令行界面從該 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">swagger.json</span> 文件生成C＃客戶端。這是一個例子：</p><pre><code>autorest --input-file="./swagger.json" --output-folder="GeneratedClient" --namespace="MyClient" --override-client-name="MyClient" --csharp</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這將產生一個 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">GeneratedClient</span> 包含生成的C＃文件的文件夾。請注意，名稱空間和客戶端名稱被覆蓋。從這裡，將此文件夾添加到Visual Studio中的客戶端項目。</p><div class=pgc-img><img alt=C#客戶端和服務端通信的幾種方法：Rest和GRPC和其他 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ce1e708de336421eb2253ae0934a235f><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">您需要安裝 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Microsoft.Rest.ClientRuntime</span> NuGet軟件包，因為生成的代碼取決於該軟件包。安裝後，您可以像使用常規C＃類一樣使用API：</p><pre><code>var client = new MyClient();Employee employee = client.Employee(id: "abc");</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">您可以在AutoRest的 文檔中 [10] 閱讀一些細微之處。而且您需要使該過程自動化，因此我建議閱讀Patrik Svensson的 教程， [11] 以獲得一些好的建議以及Peter Jausovec的這篇 文章 [12] 。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Swagger的問題是JSON文件是在運行時創建的，因此這使得在CI / CD流程中實現自動化有點困難。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">傳統REST vs Swagger vs ReFit</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">進行選擇時，請注意以下幾點。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• 如果您有一個非常簡單的私有REST API，則也許不必理會客戶端生成和共享接口。小任務並不能證明付出額外的努力是合理的。 • Swagger支持多種語言，而ReFit僅支持.NET。Swagger還是許多工具，測試，自動化和UI工具的基礎。如果您要創建一個大型的公共API，它將可能是最佳選擇。 • Swagger比ReFit複雜得多。使用ReFit，只需在服務器和客戶端項目中添加一個接口即可。另一方面，使用ReFit，您必須為每個控制器創建新的接口，而Swagger會自動進行處理。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">但是在決定任何事情之前，請檢查與REST無關的第四個選項。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC [13] （ </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC遠程過程調用</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> ）是Google開發的開源遠程過程調用系統。它有點像REST，它提供了一種將請求從客戶端發送到服務器的方式。但這在許多方面都不同，這是相同點和不同點：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• 像REST一樣，gRPC與語言無關。有適用於所有流行語言的工具，包括C＃。 • gRPC是契約的基礎，並使用 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件來定義契約。這有點類似於Swagger <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">swagger.json</span> 和ReFit的共享界面。可以從那些文件中生成任何編程語言的客戶端。 • gRPC使用 協議緩衝區（Protobuf） [14] 二進制序列化。這與REST（通常序列化為JSON或XML）不同。二進制序列化較小，因此更快。 • gRPC用於使用HTTP / 2協議創建持久連接。該協議更簡單，更緊湊。REST使用HTTP 1.x協議（通常為HTTP 1.1）。 • HTTP 1.1要求每個請求都進行TCP握手，而HTTP / 2則保持連接打開。 • HTTP / 2連接使用多路複用流。這意味著單個TCP連接可以支持許多流。這些流可以並行執行，而不必像HTTP 1.1中那樣互相等待。 • gRPC允許雙向流。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有兩種使用gRPC的方法。對於.NET Core 3.0，有一個完全託管的庫，稱為 .NET的gRPC [15] 。對於其中的任何內容，您都可以使用 gRPC C＃ [16] ，它是使用本機代碼構建的。這並不意味著 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">適用於.NET的gRPC可以</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 替代 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC C＃</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 。讓我們來看一個 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">用於.NET</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 的更新 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 的示例。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">.NET的gRPC的服務器端</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這不是教程，而是更多有關預期內容的一般性想法。這是示例控制器在gRPC中的外觀：</span></p><pre><code>public class GreeterService : Greeter.GreeterBase{    public override Task&lt;HelloReply&gt; SayHello(HelloRequest request,        ServerCallContext context)    {        _logger.LogInformation("Saying hello to {Name}", request.Name);        return Task.FromResult(new HelloReply         {            Message = "Hello " + request.Name        });    }}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">您需要添加以下的 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Configure</span> 在 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Startup.cs</span> ：</p><pre><code>app.UseEndpoints(endpoints =&gt;{    endpoints.MapGrpcService&lt;GreeterService&gt;();});</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">API在 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件中描述，該文件是項目的一部分：</p><pre><code>syntax = "proto3";service Greeter {  rpc SayHello (HelloRequest) returns (HelloReply);}message HelloRequest {  string name = 1;}message HelloReply {  string message = 1;}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">此 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件添加到 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.csproj</span> ：</p><pre><code>&lt;ItemGroup&gt;  &lt;Protobuf Include="Protos\greet.proto" /&gt;&lt;/ItemGroup&gt;</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">.NET的gRPC客戶端</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">客戶端是從 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件生成的。代碼本身非常簡單：</p><pre><code>var channel = GrpcChannel.ForAddress("https://localhost:5001");var client = new Greeter.GreeterClient(channel);var response = await client.SayHello(    new HelloRequest { Name = "World" });Console.WriteLine(response.Message);</code></pre><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC與REST</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC聽起來不錯。它在框架下更快，更簡單。那麼，我們都應該從REST變為gRPC嗎？答案是，這取決於你的應用場景。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">以下是一些注意事項：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">從我的印象來看，使用gRPC和ASP.NET仍然不是很好。藉助對REST的成熟支持，您會變得更好。就基於契約的通信而言，這很不錯，除了在REST中有我們已經討論過的類似替代方案：Swagger和ReFit。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">最大的優勢是性能。 根據這些基準 [17] ，在大多數情況下，gRPC更快。特別是對於大型有效載荷，Protobuf序列化確實有所作為。這意味著對於高負載服務器而言，這是一個巨大的優勢。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在大型ASP.NET應用程序中從REST過渡到gRPC將非常困難。但是，如果您具有基於微服務的體系結構，那麼逐步完成此過渡就變得容易得多。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">其他溝通方式</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">還有其他一些我完全沒有提及的通信方式，但是值得一提的是：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• GraphQL [18] 是Facebook開發的API的查詢語言。它允許客戶端從服務器確切地要求它需要的數據。這樣，您可以在服務器上僅創建一個端點，該端點將非常靈活，並且僅返回客戶端所需的數據。近年來，GraphQL變得非常流行。 • SignalR [19] 是一項允許服務器與客戶端之間進行實時雙向通信的技術。SignalR不僅允許客戶端始終向服務器發送請求，還允許服務器向客戶端發送推送通知。這樣可以查看Web應用程序中的實時更新。SignalR在ASP.NET中非常流行。 • TcpClient [20] 和 TcpListener [21] （在中 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">System.Net.Sockets</span> ）提供基於TCP的低級連接。基本上，您將建立連接並傳輸字節數組。對於大型應用程序而言，它不是理想的選擇，在大型應用程序中，您可以使用ASP.NET的控制器和操作在大型API中進行訂購。 • UdpClient [22] 提供了一種通過UDP協議進行通信的方法。TCP建立連接，然後發送數據，而UDP僅發送數據。TCP確保數據中沒有錯誤，而UDP沒有。UDP可以更有效地快速傳輸數據，您不必擔心它是否可靠且沒有錯誤。一些示例是：視頻流，實時廣播和IP語音（VoIP）。 • WCF [23] 是一種較舊的技術，主要在進程之間使用基於SOAP的通信。這是一個龐大的框架，我要說的是它已不再受REST和JSON負載的歡迎。</p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">References</span></strong></h1><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[1]</span> POCO類: <em>https://www.c-sharpcorner.com/UploadFile/5d065a/poco-classes-in-entity-framework/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[2]</span> OpenAPI: <em>https://swagger.io/specification/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[3]</span> Swagger Petstore: <em>https://bfanger.nl/swagger-explained/#operationObject</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[4]</span> Swashbuckle.AspNetCore: <em>https://github.com/domaindrivendev/Swashbuckle.AspNetCore</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[5]</span> swagger-codegen: <em>https://github.com/swagger-api/swagger-codegen</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[6]</span> AutoRest: <em>https://azure.github.io/autorest/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[7]</span> Swashbuckle.AspNetCore: <em>https://www.nuget.org/packages/Swashbuckle.AspNetCore</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[8]</span> AutoRest: <em>https://github.com/Azure/autorest</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[9]</span> NPM: <em>https://www.w3schools.com/nodejs/nodejs_npm.asp</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[10]</span> 文檔中: <em>https://azure.github.io/autorest/client/ops.html</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[11]</span> 教程，: <em>https://www.patriksvensson.se/2018/10/generating-api-clients-using-autorest</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[12]</span> 文章: <em>https://medium.com/@pjausovec/creating-c-client-library-for-web-api-projects-be132c831f9c</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[13]</span> gRPC: <em>https://grpc.io/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[14]</span> 協議緩衝區（Protobuf）: <em>https://en.wikipedia.org/wiki/Protocol_Buffers</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[15]</span> .NET的gRPC: <em>https://github.com/grpc/grpc-dotnet</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[16]</span> gRPC C＃: <em>https://github.com/grpc/grpc/tree/master/src/csharp</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[17]</span> 根據這些基準: <em>https://www.yonego.com/nl/why-milliseconds-matter/#gref</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[18]</span> GraphQL: <em>https://graphql.org/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[19]</span> SignalR: <em>https://github.com/SignalR/SignalR</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[20]</span> TcpClient: <em>https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcpclient?view=netframework-4.8</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[21]</span> TcpListener: <em>https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcplistener?view=netframework-4.8</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[22]</span> UdpClient: <em>https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.udpclient?view=netframework-4.8</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[23]</span> WCF: <em>https://docs.microsoft.com/en-us/dotnet/framework/wcf/whats-wcf</em></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>C#</a></li><li><a>客戶</a></li><li><a>務端</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/92a51eb6.html alt="打造最佳客戶體驗 掌上生活榮獲“最佳商業銀行App”獎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RBo4YSEIi2ZCq0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92a51eb6.html title="打造最佳客戶體驗 掌上生活榮獲“最佳商業銀行App”獎">打造最佳客戶體驗 掌上生活榮獲“最佳商業銀行App”獎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50cccce6.html alt=作為二手車準客戶，你必須要知道汽車的車身結構件都在這裡 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68dab73e134f42e587f5144653f44d1e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50cccce6.html title=作為二手車準客戶，你必須要知道汽車的車身結構件都在這裡>作為二手車準客戶，你必須要知道汽車的車身結構件都在這裡</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b7c4cde.html alt=圖文詳解典型客戶配電室 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/b0d80059-00a9-4fa4-8151-0e56153a02cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b7c4cde.html title=圖文詳解典型客戶配電室>圖文詳解典型客戶配電室</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html alt=C#算法系列（1）——二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html title=C#算法系列（1）——二叉樹>C#算法系列（1）——二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00422be0.html alt=看杭州客戶如何利用河卵石創千萬價值年收益！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e19579a90cad4c5ab84dd2b3bdf3ed72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00422be0.html title=看杭州客戶如何利用河卵石創千萬價值年收益！>看杭州客戶如何利用河卵石創千萬價值年收益！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7fc062f.html alt=客戶需要怎樣的視覺檢測技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7643124b98de4aa3a6fabd8677bf9b0d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7fc062f.html title=客戶需要怎樣的視覺檢測技術>客戶需要怎樣的視覺檢測技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97aeea76.html alt=客戶資源管理——掃清發展“障礙”，助力企業發展 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ee810d2bd654635b1081a8362013e1a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97aeea76.html title=客戶資源管理——掃清發展“障礙”，助力企業發展>客戶資源管理——掃清發展“障礙”，助力企業發展</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5400247a.html alt=C#對於初學者來講，數據類型的種類是一把必備的利刃 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f421e70dc2e6402f99afdc234d1e2e30 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5400247a.html title=C#對於初學者來講，數據類型的種類是一把必備的利刃>C#對於初學者來講，數據類型的種類是一把必備的利刃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c9519fd.html alt=職場中如何管理和對客戶進行分類？——實戰職場客戶管理篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/4b0000018e4c423ed1b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c9519fd.html title=職場中如何管理和對客戶進行分類？——實戰職場客戶管理篇>職場中如何管理和對客戶進行分類？——實戰職場客戶管理篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48aad4c1.html alt=如何準確又高效地與B端客戶對接需求？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RymZiJP2dPNUtB style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48aad4c1.html title=如何準確又高效地與B端客戶對接需求？>如何準確又高效地與B端客戶對接需求？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60f507fa.html alt="毛大慶：從資產端和服務端本源重新思考聯合辦公 | 睿和公開課" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cf280771809a419aa86e8524f8ef695f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60f507fa.html title="毛大慶：從資產端和服務端本源重新思考聯合辦公 | 睿和公開課">毛大慶：從資產端和服務端本源重新思考聯合辦公 | 睿和公開課</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24b7f1ac.html alt=淺談前端、客戶端、服務器、後臺、與下位機之間的關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15365562904682b8d9691c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24b7f1ac.html title=淺談前端、客戶端、服務器、後臺、與下位機之間的關係>淺談前端、客戶端、服務器、後臺、與下位機之間的關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c312e6e2.html alt=英雄聯盟遊戲客戶端與系統介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f22ba0ace20f47608ab3d64e2ba52212 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c312e6e2.html title=英雄聯盟遊戲客戶端與系統介紹>英雄聯盟遊戲客戶端與系統介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ca10d887.html alt=“反饋給大客戶超管你就永封了！”神豪虛語被“實錘”公司號？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/93ce6478ed87461795023c118479319d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ca10d887.html title=“反饋給大客戶超管你就永封了！”神豪虛語被“實錘”公司號？>“反饋給大客戶超管你就永封了！”神豪虛語被“實錘”公司號？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c41028d.html alt="圓柱卷繞機順利交付海外客戶 贏合製造加速國際進階路" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d27cb3445c194cfdb4b1df9323100c70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c41028d.html title="圓柱卷繞機順利交付海外客戶 贏合製造加速國際進階路">圓柱卷繞機順利交付海外客戶 贏合製造加速國際進階路</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>