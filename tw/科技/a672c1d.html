<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 | 极客快訊</title><meta property="og:title" content="我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/23f7750cba654d2087c132af3fbd6836"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><meta property="article:published_time" content="2020-10-29T21:04:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:30+08:00"><meta name=Keywords content><meta name=description content="我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a672c1d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>說到python發送HTTP請求進行接口自動化測試，腦子裡第一個閃過的可能就是requests庫了，當然python有很多模塊可以發送HTTP請求，包括原生的模塊http.client,urllib2等，但由於原生的模塊過於複雜，使用繁瑣，那麼requests庫就誕生了，它也是現階段比較流行的接口自動化測試工具之一。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/23f7750cba654d2087c132af3fbd6836><p class=pgc-img-caption></p></div><p>requests是個第三方庫，封裝了HTTP請求的所有方法，使用方便簡單，只需要根據不同的請求方式調用相對應的方法就可以完成發送網絡請求的整個過程，那麼今天我們就來說說requests庫是如何使用的，<strong>那麼在開始之前我們大致說一下今天的主要內容：</strong></p><p>1. requets如何發送get請求</p><p>2. requests如何發送post請求</p><p>3. params參數和data參數的區別</p><p>4. requests庫中Session類的的妙用</p><p>5. 針對get請求和post請求，對requests進行簡單封裝</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/2b98d589-8a88-4218-8c2d-14480adab91e><p class=pgc-img-caption></p></div><p><strong>發送get請求</strong></p><p>requests是通過調用get()方法來完成發送get請求的，那麼，在掌握requests庫如何發送get請求之前，你還應該簡單瞭解一下什麼是get請求？</p><p>通常在我們學習一個方法如何使用之前，我們需先知道這個方法需要哪些參數？參數類型是什麼？ 那麼我們就先分析一下get()方法的源碼：</p><p>def get(url, params=None, **kwargs):</p><p>r"""Sends a GET request.</p><p>:param url: URL for the new :class:`Request` object.</p><p>:param params: (optional) Dictionary, list of tuples or bytes to send</p><p>in the body of the :class:`Request`.</p><p>:param \*\*kwargs: Optional arguments that ``request`` takes.</p><p>:return: :class:`Response &lt;Response>` object</p><p>:rtype: requests.Response</p><p>"""</p><p>kwargs.setdefault('allow_redirects', True)</p><p>return request('get', url, params=params, **kwargs)</p><p>這就是get方法的源碼了，你應該能夠發現，get()方法只有一個必傳的參數url，其他參數都是非必傳的，那麼其他的參數有什麼作用呢？</p><p><strong>params</strong></p><p>對於這個參數，可以是字典，也可以是嵌套元組的列表，基於get請求的特點，請求參數是可以直接跟在URL之後的，以？號開始以key=value的形式傳遞(多個參數使用&符號進行分割)，但是為了明確區分URL和參數，就需要使用params參數傳遞。</p><p>**kwargs：其他一些關鍵字參數，暫時不做介紹。</p><p>接下來我們來看2個簡單的實例，體會一下reauets通過get()方法發送一個不帶參數的get請求和帶參數的請求的過程。</p><p>通過get()方法發送get請求訪問博客園首頁</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/11 20:34</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests # 導入requests模塊</p><p>response = requests.get('https://www.cnblogs.com/') # 發送get請求</p><p>print(response.text) # 獲取響應數據</p><p>響應數據</p><p>&lt;!DOCTYPE html></p><p>&lt;html></p><p>&lt;head></p><p>&lt;meta charset="utf-8" /></p><p>&lt;meta name="viewport" content="width=device-width, initial-scale=1" /></p><p>&lt;meta name="referrer" content="always" /></p><p>&lt;title>博客園 - 代碼改變世界&lt;/title></p><p>&lt;meta name="keywords" content="開發者,博客園,開發者,程序猿,程序媛,極客,編程,代碼,開源,IT網站,Developer,Programmer,Coder,Geek,技術社區" /></p><p>&lt;meta name="description" content="博客園是一個面向開發者的知識分享社區。自創建以來，博客園一直致力並專注於為開發者打造一個純淨的技術交流社區，推動並幫助開發者通過互聯網分享知識，從而讓更多開發者從中受益。博客園的使命是幫助開發者用代碼改變世界。" /></p><p>&lt;link rel="shortcut icon" href="//common.cnblogs.com/favicon.ico" type="image/x-icon" /></p><p>&lt;link rel="Stylesheet" type="text/css" href="../../bundles/aggsite.css?v=IlEZk4Ic2eCzcO6r0s4bGm62FAo8VZI-US_0EqUe2Bk1" /></p><p>&lt;link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://feed.cnblogs.com/blog/sitehome/rss" /></p><p>&lt;script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js" type="text/javascript">&lt;/script></p><p>&lt;script src="../../bundles/aggsite.js?v=cE0bqImLWsEG3gZXOupKxj5tj_ukK7pLeSd73DHZOT81" type="text/javascript">&lt;/script></p><p>&lt;script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'>&lt;/script></p><p>&lt;script></p><p>var googletag = googletag || {};</p><p>googletag.cmd = googletag.cmd || [];</p><p>&lt;/script></p><p>這裡我只截取了一部分響應數據，響應數據其實是博客園的首頁HTML源碼。</p><p>可以看到只需要一行代碼即可完成整個請求過程，通過response.text得到響應數據(其實這個過程和我們在瀏覽器中輸入博客園地址訪問是一樣的)，當然你還可以使用以下的方法獲取不同的響應數據。</p><p>response.headers # 獲取響應頭信息</p><p>response.cookies # 獲取返回的cookie</p><p>response.status_code # 獲取狀態碼</p><p>發送帶params參數的get請求</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/11 20:34</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login' # 接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需參數</p><p>response = requests.get(url=login_url, params=login_data) # 發送get請求</p><p>print(response.text) # 獲取響應數據</p><p>print(response.url)</p><p>響應數據</p><p>{"status":1,"code":"10001","data":null,"msg":"登錄成功"}</p><p>http://***:8080/futureloan/mvc/api/member/login?mobilephone=13691579841&pwd=123456</p><p>Process finished with exit code 0</p><p>我們通過傳遞一個字典給params參數，即可完成帶參數的get請求，並獲取響應數據。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/9fa5f185-0ff4-48d4-806f-e38c2fa6accb><p class=pgc-img-caption></p></div><p><strong>注意</strong></p><p>1. 我們日常工作中也最好傳遞字典作為接口數據，如果數據類型是json則在發送請求的時候需要先轉成字典。</p><p>2. 只要你發送的是get請求，且不想通過url拼接的方式直接傳遞接口參數，那麼只能使用params參數來傳遞(如果你使用data，json等參數時你會發現，請求並不會成功)，因為通過params傳遞的參數會附加到url後，這也是get請求的特點，因此你需記住：發送get請求時參數只能使用params即可。</p><p>以上只是簡單的發送get請求的方法，至於如何發送帶其他參數的get請求(比如headers，cookies等)，還需對get()進一步的研究和實踐。</p><p><strong>發送post請求</strong></p><p>同樣，在開始學習下面的內容之前，仍建議你先了解什麼是post請求及其特點，對你學習接下來的內容也會更好理解。</p><p>requests發送post請求是通過post()方法來實現的，那麼我們還是先看一下它的源碼：</p><p>def post(url, data=None, json=None, **kwargs):</p><p>r"""Sends a POST request.</p><p>:param url: URL for the new :class:`Request` object.</p><p>:param data: (optional) Dictionary (will be form-encoded), bytes, or file-like object to send in the body of the :class:`Request`.</p><p>:param json: (optional) json data to send in the body of the :class:`Request`.</p><p>:param \*\*kwargs: Optional arguments that ``request`` takes.</p><p>:return: :class:`Response &lt;Response>` object</p><p>:rtype: requests.Response</p><p>"""</p><p>return request('post', url, data=data, json=json, **kwargs)</p><p>通過源碼我們可以發現，post()和get()一樣，僅有一個url參數是必傳的，其他仍然可以不傳遞，但是其中data和json參數卻是post()方法中最重要的參數，下面就說一下何時使用data，何時使用json。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/6b3a72e9-6116-499e-972a-32d0d4614798><p class=pgc-img-caption></p></div><p><strong>data</strong></p><p>大多數post請求的接口默認支持參數類型Content-Type為application/x-www-form-urlencoded, 它告訴我們請求的接口參數需要傳遞一個form表單，那麼我們往往是通過構造一個字典來傳遞form表單的，</p><p>所以當我們向服務器提交form表單時就可以使用data參數，它會接收一個字典類型的數據，存放到請求體中，然後發送給服務器(參數需是字典類型)。</p><p><strong>Json</strong></p><p>首先你訪問的接口需要支持content_type為application/json格式的數據類型，那麼你就可以通過json這個參數來傳遞接口參數（參數可以是字典也可以是json類型）。</p><p>下面我們來看一個發送post請求，使用data參數的實例：</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***.com:8080/futureloan/mvc/api/member/login' # 接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需參數</p><p>response = requests.post(url=login_url, data=login_data) # 發送post請求</p><p>print(response.text) # 獲取響應數據</p><p>print(response.url)</p><p>print(response.status_code)</p><p><strong>響應數據</strong></p><p>{"status":1,"code":"10001","data":null,"msg":"登錄成功"}</p><p>http://***:8080/futureloan/mvc/api/member/login</p><p>200</p><p>Process finished with exit code 0</p><p>使用json參數實例</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***monban.com:8080/futureloan/mvc/api/member/login' # 接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需參數</p><p>response = requests.post(url=login_url, json=login_data) # 發送post請求</p><p>print(response.text) # 獲取響應數據</p><p>print(response.url)</p><p>print(response.status_code)</p><p><strong>響應數據</strong></p><p>{"status":0,"code":"20103","data":null,"msg":"手機號不能為空"}</p><p>http://***/futureloan/mvc/api/member/login</p><p>200</p><p>Process finished with exit code 0</p><p>可以看到使用data參數和json參數，獲取到的返回結果是不一樣的，因為我這裡使用的接口不支持application/json數據格式，所以當你使用json參數傳遞參數時，服務器是無法解析數據的，也就不會返回正確的結果了。</p><p>所以對於何時使用data參數，何時使用json參數，還需要根據實際的接口所支持的數據類型進行選擇。</p><p><strong>params和data區別</strong></p><p>上面已經說過get請求中的params參數和post請求中的data參數，那麼這兩個參數到底有什麼區別呢？</p><p>1. 發送get請求時，由於get請求沒有請求體，請求參數只能跟在url地址後的，而且服務器也只能通過解析url獲得請求的參數，因此get()方法發送get請求時只能使用params參數，它會把請求的參數默認追加到url地址後面。</p><p>2. 通常情況下用戶需要提交某些數據時，發送的請求一般都為post請求，post請求會提交一個form表單，那麼我們就可以構造一個字典格式的數據，使用data參數傳遞，由於post請求是有請求體的，而且請求參數就存放在請求體中，服務器也只能通過解析請求體中內容而獲得請求的參數，所以post請求不能使用params傳遞接口參數，只能使用data，json，file等, data參數會把請求參數放到請求體中。</p><p><strong>Session類的妙用</strong></p><p>實際工作中，我們會經常遇到需要保持某一個狀態，才能測試後續的接口，比如說：充值接口，那麼需要用戶先登錄，且一直保持登錄狀態才能進行充值，那麼對於這種情況該怎麼解決呢？這就要用到requests庫中的Session類了，Session可以保持請求的狀態，像我們訪問某個網站一樣，我們只要登錄後就可以瀏覽該網站上的任意頁面，先看下面實例：</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login' # 登錄接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需參數</p><p>response_login = requests.post(url=login_url, data=login_data) # 發送post請求 登錄</p><p>print(response_login.text)</p><p>recharge_url = r'http://***:8080/futureloan/mvc/api/member/recharge' # 充值接口地址</p><p>recharge_data = {"mobilephone": "13691579841", "amount": 10000.00} # 接口所需參數</p><p>response_recharge = requests.post(url=recharge_url, data=recharge_data) # 發送請求，開始充值</p><p>print(response_recharge.text)</p><p>執行結果</p><p>{"status":1,"code":"10001","data":null,"msg":"登錄成功"}</p><p>{"status":0,"code":null,"data":null,"msg":"抱歉，請先登錄。"}</p><p>Process finished with exit code 0</p><p>可以發現，我們之前都已經登錄過了，但是充值時卻失敗了，原因就是直接使用reauests來發送請求時，並不會保持當前的狀態(這也是HTTP請求的缺陷)，現在我們使用Session對像再次發送充值請求，修改代碼。</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>request = requests.Session() # 初始化Session</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login' # 登錄接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需參數</p><p>response_login = request.request(method='post', url=login_url, data=login_data) # 發送post請求 登錄</p><p>print(response_login.text)</p><p>recharge_url = r'http://***:8080/futureloan/mvc/api/member/recharge' # 充值接口地址</p><p>recharge_data = {"mobilephone": "13691579841", "amount": 10000.00} # 接口所需參數</p><p>response_recharge = request.request(method='post', url=recharge_url, data=recharge_data) # 發送請求，開始充值</p><p>print(response_recharge.text)</p><p>執行結果</p><p>{"status":1,"code":"10001","data":null,"msg":"登錄成功"}</p><p>{"status":1,"code":"10001","data":</p><p>{"id":5451,"regname":"test","pwd":"E10ADC3949BA59ABBE56E057F20F883E","mobilephone":"13691579841","leaveamount":"15000.00","type":"1","regtime":"2019-05-26 19:08:44.0"},</p><p>"msg":"充值成功"}</p><p>Process finished with exit code 0</p><p>可以發現，我們改用Session對象來發送充值請求就成功了。那這是什麼原因呢？</p><p>簡單來說，當我們第一次請求服務器時，獲取的響應信息會包含一個set-cookie的字段，保存了我們登錄的cookies信息，如果我們想保持這個狀態，那麼再次訪問服務器時就需要帶上這個cookies傳遞給服務器，才能保持這個狀態。</p><p>那麼我們使用Session對象發送請求時，Session會自動幫我們完成上述的過程，Session會自動把cookies的信息傳遞給服務器，而無需我們在請求參數中手動添加cookies，這樣就保持了登錄的狀態，後續的依賴操作都可以正常執行了。</p><p><strong>reqests簡單封裝</strong></p><p>有人會問，requests庫已經封裝的很好了，直接用就行了，為啥還要自己封裝一次？</p><p><strong>第一.</strong>通過封裝，我可以直接把所有的請求參數統一使用字典來傳遞　<strong>　</strong></p><p>比如，我們接口請求需要的數據也就是測試數據往往會保存在excel表裡面，那麼我們取到後是字符串類型，字符串是無法作為請求參數傳遞的，所以我每次都要做數據轉換，再傳遞給接口，為了節省這個過程，我只需要把這個過程封裝到我的requests裡即可，每次取數據後自動給我處理。</p><p><strong>第二.</strong>當我想保持某個狀態時，不想每次都初始化一個Session對象，那麼我可以把它封裝到我的requests裡面，以後直接調用即可。</p><p>下面來看封裝的代碼</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 16:14</p><p>@Auth : linux超</p><p>@File : sendrequests.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import json</p><p>import requests</p><p>class HttpRequests(object):</p><p>"""</p><p>eg: request = HttpRequests()</p><p>response = request(method, url, data)</p><p>or</p><p>response = request.send_request(method, url, data)</p><p>print(response.text)</p><p>"""</p><p>def __init__(self):</p><p>self.session = requests.Session()</p><p>def send_request(self, method, url, params_type='form', data=None, **kwargs):</p><p>method = method.upper()</p><p>params_type = params_type.upper()</p><p>if isinstance(data, str):</p><p>try:</p><p>data = json.loads(data)</p><p>except Exception:</p><p>data = eval(data)</p><p>if 'GET' == method:</p><p>response = self.session.request(method=method, url=url, params=data, **kwargs)</p><p>elif 'POST' == method:</p><p>if params_type == 'FORM': # 發送表單數據，使用data參數傳遞</p><p>response = self.session.request(method=method, url=url, data=data, **kwargs)</p><p>elif params_type == 'JSON': # 如果接口支持application/json類型，則使用json參數傳遞</p><p>response = self.session.request(method=method, url=url, json=data, **kwargs)</p><p>else: # 如果接口需要傳遞其他類型的數據比如 上傳文件，調用下面的請求方法</p><p>response = self.session.request(method=method, url=url, **kwargs)</p><p># 如果請求方式非 get 和post 會報錯，當然你也可以繼續添加其他的請求方法</p><p>else:</p><p>raise ValueError('request method "{}" error ! please check'.format(method))</p><p>return response</p><p>def __call__(self, method, url, params_type='form', data=None, **kwargs):</p><p>return self.send_request(method, url,</p><p>params_type=params_type,</p><p>data=data,</p><p>**kwargs)</p><p>def close_session(self):</p><p>self.session.close()</p><p>try:</p><p>del self.session.cookies['JSESSIONID']</p><p>except:</p><p>Pass</p><p>request = HttpRequests()</p><p>if __name__ == '__main__':</p><p>pass</p><p>這個封裝只針對了get請求和post請求，當然你也可以把put，delete等請求添加在32行代碼後面，實現更多的請求方式。</p><p>解釋一下30-34行代碼： 這幾行數據是為了把json和字符串類型的數據轉換為字典的格式(通過使用字典傳遞接口參數)且可以處理一些特殊的形式，比如下面這樣的格式。</p><p>'{"mobilephone": None, "pwd": null}' # 字符串類型的，但是即不是json形式的字符串，也不是字典類型的字符串，因為字典裡面沒有null。</p><p><strong>封裝測試</strong></p><p>現在我們使用封裝好的方法來測試一下發送登錄和充值接口的請求</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 16:16</p><p>@Auth : linux超</p><p>@File : test_requests.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>from sendrequests import request</p><p>import unittest</p><p>class TestRequests(unittest.TestCase):</p><p># 登錄接口地址</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login'</p><p># 登錄接口測試數據</p><p>login_test_value = '{"mobilephone": "13691579841", "pwd": 123456}'</p><p># 充值接口地址</p><p>recharge_url = r'http://***:8080/futureloan/mvc/api/member/recharge'</p><p># 充值接口測試數據</p><p>recharge_test_value = {"mobilephone": "13691579841", "amount": 10000.00}</p><p>def test_login_api(self):</p><p>"""登錄接口測試用例"""</p><p>response = request('get', url=self.login_url, data=self.login_test_value)</p><p>self.assertTrue(response.json()["code"] == "10001")</p><p>print("登錄接口測試通過")</p><p>def test_recharge_api(self):</p><p>"""充值接口測試用例"""</p><p>response = request('get', url=self.login_url, data=self.login_test_value)</p><p>try:</p><p># 充值接口需要先登錄，才能充值</p><p>self.assertTrue(response.json()["code"] == '10001')</p><p>except AssertionError as e:</p><p>print('登錄失敗!')</p><p>raise e</p><p>else:</p><p>response = request('post', url=self.recharge_url, data=self.recharge_test_value)</p><p>self.assertTrue(response.json()["code"] == "10001")</p><p>print("充值接口測試通過")</p><p>if __name__ == '__main__':</p><p>unittest.main()</p><p>測試結果</p><p>登錄接口測試通過</p><p>..</p><p>充值接口測試通過</p><p>----------------------------------------------------------------------</p><p>Ran 2 tests in 0.570s</p><p>OK</p><p>Process finished with exit code 0</p><p>ok，測試代碼執行通過，說明我們的封裝沒有啥問題， 且可以正常發送get和post請求，也可以解決測試數據問題和需要接口依賴的問題。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/cc576679-30ca-477e-b874-61909607c2c5><p class=pgc-img-caption></p></div><p><strong>總結</strong></p><p>最後我們再來總結一下本文涉及到的所有的知識點和你需要掌握的。</p><p>1.requests發送get請求和post請求的方法</p><p>get(url, params=None, **kwargs)</p><p>post(url, data=None, json=None, **kwargs)</p><p>2.parmas參數和data參數的區別</p><p>由於get請求無請求體，post請求有請求體。</p><p>使用params參數時，默認會把參數附加到url後面，所以發送get請求時應使用params參數。</p><p>使用data參數時，參數會存放到請求體中，所以發送post請求時不能使用params，應使用data，除非接口及支持get又支持post，同樣get請求也不能使用data參數。</p><p>3.如何使用Seesion解決接口保持狀態的問題</p><p>初始化Session實例，通過這個實例調用request()方法發送請求。</p><p>4.最重要的一個封裝方法，並掌握這個封裝該如何使用</p><p>主要針對get和post請求的接口。</p><p><strong>請關注+私信回覆：“學習”就可以免費拿到軟件測試學習資料</strong></p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口測試工具requests庫原來這麼好用 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6a8aceadda87417cb7fc23b33e78c89f><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>測試</a></li><li><a>requests</a></li><li><a>庫原來</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d1c2a0c.html alt=塑料扯斷伸長率的概念及測試要點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/6fe0ba07-c929-4046-9216-7f6d5eaa1716 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d1c2a0c.html title=塑料扯斷伸長率的概念及測試要點>塑料扯斷伸長率的概念及測試要點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html alt=時間繼電器測試儀的使用方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1205bf787f1f4de6a5f1e73e7737887b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebbbc375.html title=時間繼電器測試儀的使用方法>時間繼電器測試儀的使用方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bee6be40.html alt=河北省邯鄲市計量測試所大力實施專業技能提升行動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bee6be40.html title=河北省邯鄲市計量測試所大力實施專業技能提升行動>河北省邯鄲市計量測試所大力實施專業技能提升行動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9b084990.html alt=介質損耗測試儀的操作方法與注意事項 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/1a746168-e5df-4643-9117-3f1fb4faf100 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9b084990.html title=介質損耗測試儀的操作方法與注意事項>介質損耗測試儀的操作方法與注意事項</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d38b572e.html alt=有關於射頻測試設備：電纜/天線分析儀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0e79c2e668d84f09be994180e66f90c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d38b572e.html title=有關於射頻測試設備：電纜/天線分析儀>有關於射頻測試設備：電纜/天線分析儀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0f90fbd.html alt=透氣性、透氣度測試知多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/45ac8fb9-3365-4327-901d-b21b7cd9cbbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0f90fbd.html title=透氣性、透氣度測試知多少？>透氣性、透氣度測試知多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26e2bf51.html alt=振動測試中需要了解的27個常識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/523bd012e455466f857587d9314c3084 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26e2bf51.html title=振動測試中需要了解的27個常識>振動測試中需要了解的27個常識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72951256.html alt=現場密度測試方法——灌砂法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e780002be67a3fa5bad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72951256.html title=現場密度測試方法——灌砂法>現場密度測試方法——灌砂法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html alt=測試開發專題：spring-boot統一異常捕獲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/135918e30e2f4a2ea248b539eb383688 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html title=測試開發專題：spring-boot統一異常捕獲>測試開發專題：spring-boot統一異常捕獲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/01e5dc8b.html alt=汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1527412810099aa43fbd71b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/01e5dc8b.html title=汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險>汽車別再測試油箱警示後跑多遠，油箱球閥故障很危險</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6a66288.html alt=性能測試的分類、流程及工具介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6a66288.html title=性能測試的分類、流程及工具介紹>性能測試的分類、流程及工具介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3eeb035b.html alt=懸索橋的“原始指紋測試” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2157b4b13e4b4f42820eb641677f2c23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3eeb035b.html title=懸索橋的“原始指紋測試”>懸索橋的“原始指紋測試”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cffb680d.html alt=軟件測試必備之數據庫知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1adc8d8adfcd4b239442f447cebf7731 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cffb680d.html title=軟件測試必備之數據庫知識>軟件測試必備之數據庫知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63a90cc1.html alt=重要提醒：別讓你的UI自動化測試技術落後別人一個時代 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c9173ecb95284123b89717ae657af26d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63a90cc1.html title=重要提醒：別讓你的UI自動化測試技術落後別人一個時代>重要提醒：別讓你的UI自動化測試技術落後別人一個時代</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e539424.html alt=時鐘測試儀是如何校準的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fadd9ef687ec4d4f9df7047e1c255709 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e539424.html title=時鐘測試儀是如何校準的>時鐘測試儀是如何校準的</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>