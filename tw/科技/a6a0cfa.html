<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux性能及調優指南之Linux進程管理 | 极客快訊</title><meta property="og:title" content="Linux性能及調優指南之Linux進程管理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/c6b9ea197a2246018342770b84ec2efc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6a0cfa.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6a0cfa.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6a0cfa.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6a0cfa.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6a0cfa.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6a0cfa.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6a0cfa.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6a0cfa.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="Linux性能及調優指南之Linux進程管理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a6a0cfa.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux性能及調優指南之Linux進程管理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Linux進程管理</p><p>進程管理是操作系統的最重要的功能之一。有效率的進程管理能保證一個程序平穩而高效地運行。<br>Linux的進程管理與UNIX的進程管理相似。它包括進程調度、中斷處理、信號、進程優先級、上下文切換、進程狀態、進度內存等。<br>在本節中，我們將描述Linux進程管理的基本原理的實現。它將更好地幫助你理解Linux內核如何處理進程及其對系統性能的影響。<br><strong>1 什麼是進程？</strong><br>一個進程是一個運行在處理器的程序的一個實例。該進程使用Linux內核能夠處理的任何資源來完成它的任務。<br>所有運行在Linux操作系統中的進程都被task_struct結構管理，該結構同時被叫作進程描述。一個進程描述包含一個運行進程所有的必要信息，例如進程標識、進程屬性和構建進程的資源。如果你瞭解該進程構造，你就能理解對於進程的運行和性能來說，什麼是重要的。下圖展示了進程結構相關的進程信息概述。<br></p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c6b9ea197a2246018342770b84ec2efc><p class=pgc-img-caption>task_struct結構體</p></div><p><br><strong>2 進程的生命週期</strong><br>每一個進程都有其生命週期，例如創建、運行、終止和消除。這些階段會在系統啟動和運行中重複無數次。因此，進程的生命週期對於其性能的分析是非常重要的。</p><p style=text-align:start>下圖展示了經典的進程生命週期。</p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8144b893df72461db6c19358ce2dbc60><p class=pgc-img-caption>經典的進程生命週期</p></div><p style=text-align:start>當一個進程創建一個新的進程，進程的創建進程（父進程）調用一個fork()系統調用。當fork()系統調用被調用，它得到該新創建進程（子進程）的進程描述並調用一個新的進程id。它複製該值到父進程進程描述到子進程中。此時整個的父進程的地址空間是沒有被複制的；父子進程共享相同的地址空間。</p><p style=text-align:start><br>exec()系統調用複製新的程序到子進程的地址空間。因為父子進程共享地址空間，寫入一個新的程序的數據會引起一個分頁錯誤。在這種情況下，內存會分配新的物理內存頁給子進程。</p><p style=text-align:start><br>這個推遲的操作叫作寫時複製。子進程通常運行他們自己的程序而不是與父進程運行相同的程序。這個操作避免了不必要的開銷，因為複製整個地址空間是一個非常緩慢和效率低下的操作，它需要使用大量的處理器時間和資源。</p><p style=text-align:start><br>當程序已經執行完成，子進程通過調用exit()系統調用終止。exit()系統調用釋放進程大部分的數據並通過發送一個信號通知其父進程。此時，子進程是一個被叫作殭屍進程的進程（參閱page 7的“Zombie processes”）。</p><p style=text-align:start><br>子進程不會被完全移除直到其父進程知道其子進程的調用wait()系統調用而終止。當父進程被通知子進程終止，它移除子進程的所有數據結構並釋放它的進程描述。</p><p style=text-align:start><strong>需要C/C++ Linux服務器架構師學習資料私信“資料”（資料包括C/C++，Linux，golang技術，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒體，CDN，P2P，K8S，Docker，TCP/IP，協程，DPDK，ffmpeg等），免費分享</strong></p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/38755fbc61154d06a243d159fdae398b><p class=pgc-img-caption></p></div><p style=text-align:start><br><strong>3 線程</strong><br>一個線程是一個單獨的進程生成的一個執行單元。它與其他的線程並行地運行在同一個進程中。各個線程可以共享進程的資源，例如內存、地址空間、打開的文件等等。它們能訪問相同的程序數據集。線程也被叫作輕量級的進程（Light Weight Process，LWP）。因為它們共享資源，所以每個線程不應該在同一時間改變它們共享的資源。互斥的實現、鎖、序列化等是用戶程序的責任。</p><p style=text-align:start><br>從性能的角度來說，創建線程的開銷比創建進程少，因數創建一個線程時不需要複製資源。另一方面，進程和線程擁在調度算法上有相似的特性。內核以相似的方式處理它們。<br></p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/380a7166e1c54b8d8530fd0ecfa305ce><p class=pgc-img-caption>進程和線程</p></div><p><br>在現在的Linux實現中，線程支持UNIX的可移植操作系統接口（POSIX）標準庫。在Linux操作系統中有幾種可用的線程實現。以下是廣泛使用的線程庫：<br>LinuxThreads<br>LinuxThreads自從Linux內核2.0起就已經被作為默認的線程實現。LinuxThreads的一些實現並不符合POSIX標準。Native POSIX Thread Library（NPTL）正在取代LinuxThreads。LinuxThreads在將來的Linux企業發行版中將不被支持。</p><p style=text-align:start><br>Native POSIX Thread Libary（NPTL）<br>NPTL最初是由紅帽公司開發的。NPTL與POSIX更加兼容。通過Linux內核2.6的高級特性，例如，新的clone()系統調用、信號處理的實現等等，它具有比LinuxThreads更高的性能和伸縮性。<br>NPTL與LinuxThreads有一些不兼容。一個依賴於LinuxThreads的應用可能不能在NPTL實現中工作。</p><p style=text-align:start><br>Next Generation POSIX Thread（NGPT）<br>NGPT是一個IBM開發的POSIX線程庫。現在處於維護階段並且在未來也沒有開發計劃。<br>使用LD_ASSUME_KERNEL環境變量，你可以選擇在應用中使用哪一個線程庫。</p><p style=text-align:start><br><strong>4 進程優先級和nice值</strong><br>進程優先級是一個數值，它通過動態的優先級和靜態的優先級來決定進程被CPU處理的順序。一個擁有更高進程優先級的進程擁有更大的機率得到處理器的處理。</p><p style=text-align:start><br>內核根據進程的行為和特性使用試探算法，動態地調整調高或調低動態優先級。一個用戶進程可以通過使用進程的nice值間接改變靜態優先級。一個擁有更高靜態優先級的進程將會擁有更長的時間片（進程能在處理上運行多長時間）。</p><p style=text-align:start><br>Linux支持從19（最低優先級）到-20（最高優先級）的nice值。默認值為0。把程序的nice值修改為負數（使進程的優先級更高），需要以root身份登陸或使用su命令以root身份執行。</p><p style=text-align:start><br><strong>5 上下文切換</strong><br>在進程運行過程中，進程的運行信息被保存於處理器的寄存器和它的緩存中。正在執行的進程加載到寄存器中的數據集被稱為上下文。為了切換進程，運行中進程的上下文將會被保存，接下來的運行進程的上下文將被被恢復到寄存器中。進程描述和內核模式堆棧的區域將會用來保存上下文。這個切換被稱為上下文切換。過多的上下文切換是不受歡迎的，因為處理器每次都必須清空刷新寄存器和緩存，為新的進程製造空間。它可能會引起性能問題。</p><p style=text-align:start><br>下圖 說明了上下文切換如何工作。<br></p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/410b2a4a569a43f991b98dad99df3bb7><p class=pgc-img-caption>上下文切換</p></div><p><br><strong>6 中斷處理</strong><br>中斷處理是優先級最高的任務之一。中斷通常由I/O設備產生，例如網絡接口卡、鍵盤、磁盤控制器、串行適配器等等。中斷處理器通過一個事件通知內核（例如，鍵盤輸入、以太網幀到達等等）。它讓內核中斷進程的執行，並儘可能快地執行中斷處理，因為一些設備需要快速的響應。它是系統穩定的關鍵。當一箇中斷信號到達內核，內核必須切換當前的進程到一個新的中斷處理進程。這意味著中斷引起了上下文切換，因此大量的中斷將會引起性能的下降。</p><p style=text-align:start><br>在Linux的實現中，有兩種類型的中斷。硬中斷是由請求響應的設備發出的（磁盤I/O中斷、網絡適配器中斷、鍵盤中斷、鼠標中斷）。軟中斷被用於處理可以延遲的任務（TCP/IP操作，SCSI協議操作等等）。你可以在/proc/interrupts文件中查看硬中斷的相關信息。</p><p style=text-align:start><br>在多處理器的環境中，中斷被每一個處理器處理。綁定中斷到單個的物理處理中能提高系統的性能。</p><p style=text-align:start><br><strong>7 進程狀態</strong><br>每一個進程擁有自己的狀態，狀態表示了進程當前在發生什麼。</p><p style=text-align:start><br>在進程的執行期間進程的狀態會發生改變。一些進程的狀態如下：<br>TASK_RUNNING<br>在此狀態下，表示進程正在CPU中運行或在隊列中等待運行（運行隊列）。</p><p style=text-align:start><br>TASK_STOPPED<br>在此狀態下的進程被某些信號（如SIGINT，SIGSTOP）暫停。進程正在等待通過一個信號恢復運行，例如SIGCONT。</p><p style=text-align:start><br>TASK_INTERRUPTIBLE<br>在此狀態下，進程被暫停並等待一個某些條件狀態的到達。如果一個進程處於TASK_INTERRUPTIBLE狀態並接收到一個停止的信號，進程的狀態將會被改變並中斷操作。一個典型的TASK_INTERRUPTIBLE狀態的進程的例子是一個進程等待鍵盤中斷。</p><p style=text-align:start><br>TASK_UNINTERRUPTIBLE<br>與TASK_INTERRUPTIBLE相似。當一個進程處於TASK_UNINTERRUPTIBLE狀態可以被中斷，向處於TASK_UNINTERRUPTIBLE狀態的進程發送一個信號不會發生任何操作。一個TASK_UNINTERRUPTIBLE進程的典型的例子是等待磁盤I/O操作。</p><p style=text-align:start><br>TASK_ZOMBIE<br>當一個進程調用exit()系統調用退出後，它的父進程應該知道該進程的終止。處於TASK_ZOMBIE狀態的進程會等待其父進程通知其釋放所有的數據結構。<br></p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e188cc8916954558b414ffc3e162686f><p class=pgc-img-caption>進程狀態</p></div><p><br><strong>殭屍進程</strong><br>當一個進程接收到一個信號而終止，它在結束自己之前，通常需要一些時間來結束所有的任務（例如關閉打開的文件）。在這個通常非常短暫的時間內，該進程就是一個殭屍進程。</p><p style=text-align:start><br>進程已經完成所有的關閉任務後，它會向父進程報告其即將終止。有些時候，一個殭屍進程不能把自己終止，這將會引導它的狀態顯示為z（zombie）。</p><p style=text-align:start><br>使用kill命令來關閉這樣的一個進程是不可能的，因為該進程已經被認為已經死掉了。如果你不能清除殭屍進程，你可以結束其父進程，然後殭屍進程也隨之消失。但是，如果父進程為init進程，你不能結束它。init進程是一個非常重要的進程，因此可能需要重啟系統來清除殭屍進程。</p><p style=text-align:start><br><strong>8 進程內存段</strong><br>進程使用其自身的內存區域來執行工作。工作的變化根據情況和進程的使用而決定。進程可以擁有不同的工作量特性和不同的數據大小需求。進程必須處理各種數據大小。為了滿足需求，Linux內核為每個進程使用動態申請內存的機制。進程內存分配的數據結構如圖所示。<br></p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bfab88c348dc4c9396d7ad4536eab9db><p class=pgc-img-caption>圖7 進程地址空間</p></div><p><br>進程內存區由以下幾部分組成：<br>Text段<br>該區域用於存儲運行代碼。<br></p><p style=text-align:start>Data段<br>數據段包括三個區域。<br>- Data：該區域存儲已被初始化的數據，如靜態變量。<br>- BSS：該區域存儲初始化為0的數據。數據被初始化為0。<br>- Heap：該區域用於根據需求使用malloc()動態申請的內存。堆向高地址方向增長。</p><p style=text-align:start>Stack段<br>該區域用於存儲局部變量、函數參數和返回函數的地址。棧向低地址方向增長。</p><p style=text-align:start><br>用戶進程的地址空間內存分佈可以使用pmap命令來查看。你可以使用ps命令來查看內存段的大小。</p><p style=text-align:start><br><strong>9 Linux CPU調度</strong><br>任何的計算機的基本功能都非常簡單，就是計算。為了能夠計算，它意味著必須管理計算資源或處理器和計算任務，也就是我們所知道的線程或進程。感謝Ingo Molnar的巨大貢獻，Linux內核使用一個O（1）的算法代替以前的O（n）的CPU調度算法。O（1）指的是一種靜態的算法，意味著選擇一個進程並執行所花費的時間是一個常數，不管進程的數量的大小。</p><p style=text-align:start><br>新的調度算法的擴展性非常好，不管進程的數量或者處理器的數量是多少，系統的開銷都是非常少的。該算法使用兩個進程優先級數組：<br>active（活動的）<br>expired（過期的）</p><p style=text-align:start><br>調度器根據進程的優先級和優先攔截率為進程分配時間片，然後進程以優先級順序放置到active數組內。當進程時間片耗盡，進程申請一個新的時間片並放置到expired數組內。當active數組中的所有進程的時間片耗盡，這兩個數組進行切換，重新運行該算法。對於一般的交互式進程（相對於實時進程），擁有高優先級的進程通常比低優先級的進程得到更長的時間片和更多的計算時間，但這並不表示低優先級的進程會被完全忽略（餓死）。該算法的優勢是為擁有大量線程和進程並擁有多處理器的企業級環境提升Linux內核的擴展性。該O（1）的新CPU調度器是為內存2.6設計的，但是現在已經移植到2.4系列中。下圖說明了Linux CPU如何調度工作。<br></p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/36cd8be60b74474091e303a410d5c9af><p class=pgc-img-caption>Linux內核2.6 O（1）調度器</p></div><p>新調度器的另一個顯著改進是支持非一致性內存架構（NUMA）和對稱多線程處理器，例如Intel超線程技術。<br>改進後的NUMA支持確保只有某個節點過載時，負載平衡才會跨越某個NUMA節點。這個機制確保了在NUMA系統相對比較緩慢的擴展鏈接流量的最小化。儘管每個調度節拍時負載平衡會遍歷調度域群組中的處理器，但只有在節點過載並請求負載平衡時，負載才會跨越調度域轉移。</p><div class=pgc-img><img alt=Linux性能及調優指南之Linux進程管理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e42b061de75b4aa493f265aeeaa7aa8f><p class=pgc-img-caption>O（1）CPU調度器結構</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>調優</a></li><li><a>進程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html alt=世界發展進程中的耀眼篇章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RCLmM9dF1KnwoT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html title=世界發展進程中的耀眼篇章>世界發展進程中的耀眼篇章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09d5d35b.html alt=加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09d5d35b.html title=加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人>加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html alt=Java併發編程：進程和線程之由來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/4f658919-1d85-46bc-bbf1-64aac52f4c80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html title=Java併發編程：進程和線程之由來>Java併發編程：進程和線程之由來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html alt="PHP 線程，進程和併發" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7a700a857098411d884a928d6b5f5e01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html title="PHP 線程，進程和併發">PHP 線程，進程和併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html alt=Python中的多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49dd44b999924b69bd3396709ecacaf4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html title=Python中的多進程>Python中的多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7ce9ac1.html alt=java併發編程之進程狀態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0779ab7cadfe428f8d74d66161aa48b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7ce9ac1.html title=java併發編程之進程狀態>java併發編程之進程狀態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d62f6365.html alt=java併發編程之進程與線程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1b777a6b4c24fc390776034329c92d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d62f6365.html title=java併發編程之進程與線程>java併發編程之進程與線程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fa5f4d06.html alt="linux fork多進程併發服務器模型之C/C++代碼實戰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5794b6eba487410ebcd6838aac6772fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fa5f4d06.html title="linux fork多進程併發服務器模型之C/C++代碼實戰">linux fork多進程併發服務器模型之C/C++代碼實戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/01920188.html alt=python乾貨｜python多進程併發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153075082008107d9bdbb84 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/01920188.html title=python乾貨｜python多進程併發>python乾貨｜python多進程併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d7504b3a.html alt=python併發編程：進程的創建和結束 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d7504b3a.html title=python併發編程：進程的創建和結束>python併發編程：進程的創建和結束</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>