<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>新手編程導論（七） | 极客快訊</title><meta property="og:title" content="新手編程導論（七） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3ce280dbe328491f8bc043512295d4d3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a86cb2c2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a86cb2c2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a86cb2c2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a86cb2c2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a86cb2c2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a86cb2c2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a86cb2c2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a86cb2c2.html><meta property="article:published_time" content="2020-10-29T21:08:56+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:56+08:00"><meta name=Keywords content><meta name=description content="新手編程導論（七）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a86cb2c2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>新手編程導論（七）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>第6章 抽象之數據結構</strong><br><strong>6.1 所謂數據結構</strong>編譯時是編譯期的事情，運行時是運行期的事情，這裡的時可以理解為期間（運行期間），也可理解為空間(運行邏輯關於使用reg還是stack的邏輯)，<br>一門語言同時提供編譯器，和這門語言實現的運行時解釋器,一個編譯邏輯，一個面向某平臺的運行邏輯(針對本地機器的一般稱為運行時，針對類JVM機器的一般稱為解釋器,所以jvm跟解釋器是分開的，一個是平臺，一個是平臺下針對Java代碼的runtime實現)，<br>在學習C++的運行期動態OO對象時，我們也要學習一個稱為rtti的東西,,一切高級的語言機制，都可在運行期探求它的平臺實現細節，如何用stack內存和reg展開,。。這樣才是深克理解了高級語言該機制(因為了解了某一平臺下具體實現的細節，而且是最細節的彙編邏輯，因此該語言抽象也被在高層次被體現並理解了)。。<br>比如C++類的成員函數，它實際上是一種變態的函數。。從他的彙編邏輯中可以看出來，，在壓參時還壓入一個this指針。從這個眼光來看。跟普通的cdel,fast,pascal函數都不一樣，所以說，函數作為一種機制，有不同的實作品。<br>runtime的意思在這裡進一步明顯，，實際上不只執行函數要用到stack runtime和stack frame，在執行諸如堆棧隊列數組鏈表樹這些高級數據表示與組織的內存邏輯時(即運行時邏輯，這也屬於運行時邏輯)，，不一定直接用到stack runtime機制，，雖然執行函數時的stack機制的是代表機器就是一種堆棧機運行時的典型。。<br>數組是編譯期就指定的(數組大小固定，因此每個成員都被硬編碼為內存地址，動態數組並非運行期數組，只是指定數組大小的是一個變量，實際上還是一種靜態數組)，鏈表是動態運行時構造的，數組和鏈表都是一種存儲機制，而堆棧隊列數據結構是一種數據抽象機制(抽象瞭如何訪問刪除數據成員的通用接口)，數組可以摸擬這二者，當然鏈表也可以。。(這個道理表明，數據結構分存儲數據結構和邏輯數據結構，中心是數據成員本身處理，不可能有離開數據存儲地談數據結構的道理(所以每一種抽象數據結構，必有存儲機制<br>數組的特點就是可以下標索引，，抽象了對內存地址的需要作的干涉(只需操作索引就可操作數據)，從數組中增加刪除一個數據是可能的，但數組本身業已變化，數組增刪一個元素都要經過大量的重新對齊和移動操作(因為索引得視增加刪除的位置重排)，，要形成一個新數組，從這個意思上看，，數組是根本運行期不可變的。它的變化只能發生在它的一個複製品上。 因為在靜態期被固定了<br>數組的另一特點是它只存儲同型數據<br>而鏈表則不一樣，因為它內置了指針，沒有抽象對內存地址需要做的干涉工作(對於程序員來說，這都是他們的工作，這樣可以動態分配，開闢，增加刪除成員)，，對數據的讀寫訪問（我們知道，這是數據結構的中心存在意義所在）沒有抽象上的索引可用，，只能操作指針和底層。。。<br>對鏈表的插入和刪除是很方便的。因為只需往往改動一個指針，，所有的改變都是在這鏈表上發生並自更新，<br>樹是一種可用鏈表和數組摸擬的抽象數據結構，，因為它內含了大小邏輯，，因此可以索引(左右索引，而不是一般數組的前後索引)，，也可指針索引<br><strong>6.2 算法+數據結構的本質</strong>高級語言編譯器所涉及到的那些東西，就像OO一樣，對於計算機來說，完全是一種迂迴。<br>因為高級語言編譯器的出現是為了迎合人類能讀懂的文本源程序(面向行的編譯器),所以它先提出一套語法,為了這套語法就造出了正規式,自動機,最終到語言本身這中間的諸多邏輯，而OO和框架(FrameWork)也是一樣的道理,,計算機直接執行的是二進制,,但人類若要組織這些邏輯,就得用OO思想....因為這是人類工程的需要(對於計算機來說就是迂迴了)<br>編程設計的本質在於將語言機機制邏輯轉化為應用邏輯，完成它們之間的變換,任何語言都有算法+數據結構之說的設計，但C更為突出，因為C只有這種設計範式，相對其它語言眾多的語言機制來說（除了基礎流程，類型系統那些東西不說），這更像是C的設計全部，為C而生的，在用語言機機制表達應用方面，C++有“類”,有設計模式，有模板，有編譯期多態，有範型，當然也有“算法加數據結構”，但C彷彿只有這種““算法加數據結構””，，，是設計的非常原始階段和手段。<br><strong>6.4 算法不是設計</strong>（算法更多的不是代碼邏輯的設計，用最小內核的流程控制比如C都可以實現算法跟數據結構），<br>一種算是通用的解決問題的方法,不限於編程開發<br>一種算法是算法設計方法,如遞歸<br>一種算法是計算機的執行方法,圖靈算法,證明算法可行性<br>一種算法是跟某具體語言結合的數學問題的解答,如雞免問題等<br>一種算法是設計算法,架構邏輯<br>一種算法是綜合設計算法,<br><strong>6.5 函數增長與算法複雜性分析</strong>從這一節開始，我們就慢慢進入算法了，，為什麼把算法放在這裡而不是放在數據結構那一章呢，，因為算法是屬於數學和計算機的，，跟它們的結合要更前於數據結構(雖然也嚴重與數據結構有關，但是數據結構是進入到計算機以後的抽象，算法是它以前的概念)<br>，，先講講什麼是算法，，它的分類與有關證明<br>遞歸算法，，，分支定界，，二分法，，貪婪法，等都是用來描述算法的(它們本身不是算法，，，只是用來設計算法的方法)<br>程序正確性<br>算法的有效性包含二部分,算法的正確性和算法的複雜性,,這裡討論算法的正確性,,複雜性在前面2.2節函數增長部分討論過了<br>對算法的正確性的研究用到邏輯規則，證明技術(如數學歸納法)，算法不考慮語法等其它因素,,,除非測試了所有可能的輸入，，程序都給出正確的答案，這就是程序正確性的概念<br>如何把以上概念分解為形式定義使它具有可操作性呢？<br>在有輸入的情況下，只要第一部分證明：若程序終止，則獲得正確的答案，，第二部分證明：程序總是終止，就可以斷言這個程序是正確的(二者之一成立是部分正確)<br>第三章討論算法的正確性，這裡討論算法的複雜性,在假定輸入值一樣的條件下，，求算法的空間或時間複雜性<br>由於空間複雜性跟數據結構有關而本書不涉及太多的數據結構,因此在這裡主要討論算法的時間複雜性，，即步數,運算次數的單位是整數加法，減法，，等基本運算<br><strong>6.6 數據結構初步引象(1)</strong>一維數組(向量)<br>二維數組(包含行向量與列向量的矩陣)<br>表table也是二維數組，它的行是記錄，列是字段<br>List有三種意義，VList,廣義表，狹義指linked list，，普通意義下的list表是有序的,typed 的ordered的即線性表(alistis an orderedcollectionofentities/items)，但不一定是sorteded的(Asequenceis 循序而非順序?anothername, emphasizing the ordering and suggesting that it may not be a linked list.)查找表是同型數據的無序(sorted or unsorted)有限序列。二叉查找樹也叫二叉順序樹。<br>二叉樹遍歷的本質在於動態地將非線性樹轉化為線性表。,<br>線性數據結構就是邏輯上有頭有尾的一對一的數據結點組成的結構,,當它用於表時，就是linear list,線性表用順序存儲的方法來存儲就是順序表sequences list了,注意線性表只指出結點有序(表的意義所在)一一對應(線性的意義所在)，至於如何有序它沒有作規定，而數組是一種用下標index來體現’有序’的方式，indexied 的線性表即index list(與linked list對應)=vector，因此是一種順序表的方式(當然index list就字眼上說並沒有完全地指出它應有的限制，準確的說法是index linear list)。是順序表最簡單最基本的形式(注意數組是一種抽象數據結構)。與鏈式存儲的單鏈表一樣，是最基本的，因此常有sequence stack,link stack的對比（而其實數組有多維數組，鏈表有循環鏈表等）。當然這二種表都是屬於邏輯上的linear list.6.7 數據結構初步引象(2)<br>數據結構的討論是在抽象了數據類型之後才出現的(因此數據結構的準確含義是“計算機開發領域中的數據抽象學”)，彙編不需要變量是因為程序員包攬了內存分配，而高級語言提供變量，變量的內存分配由編譯器或運行時完成，因此可在這個基礎上發展基於靠近人的抽象數據結構，而OO既是對數據的一種抽象(當然，它跟數據結構對數據的抽象是站在不同角度的)，也是一種對代碼的抽象<br>數據結構中也有文件的概念，實際上當這個文件(數據結構一般處理數據在內存中的模型)放在外存中(被持久化)就成了數據庫，數據結構中也大量用到字段，記錄，鍵等數據庫概念，，在計算機領域，數據庫和數據結構本來就是同根共源的，數據結構的抽象模式就是內模式，，關係數據庫與其它數據庫的區別在於關係數據庫會返回一個集合，而不是一些特定記錄，在數據結構的討論中，頻頻用到關係代數的概念，比如排序線性表sorted list.它按照某種順序來組織數據，比如&lt;，這實際上是一種偏序關係。<br>List有三種意義1 linked list 2 廣義表 3 (ordered) list，其中3就是普遍講到的“有序線性表”，而sequence list=sequence order list（以順序結構存儲的線性表,區別於linked ordered list）,,,線性表除了有序線性表這種形式之外，還有sorted ordered list.即排序(線性)表。。<br>如 binary search tree,= binary sort tree<br>查找表(lookup table?search<br>table?)是一種無序的集合,這使得只能以順序比較方式操作，因此我們必須對它們強加一些關係，形成sorted的,動態查找表必須動態變化以維持它的表序(即它是一種動態查找表，表是自變化的以維持某種利於查找的順序)。。<br>鍵可以是一個記錄中的某個字段，或字段的組合，單字段的以這個字段值作為鍵。。<br>（一般）樹，森林，二叉樹之間可以相互變換，，，樹可以通過對節點的限制或修飾發展出多種抽象，比如平衡樹，AVL樹，B+(B_的一種變體)，紅黑樹。。。當然還有很多，因此數據結構實際上是一門可以無限深入的科學<br>如果說樹是一種層次關係(樹是嚴格分父子的)，那麼圖就是一種鬆散關係，在任何節點間都會產生關係，因此最符合現實模型。<br>對圖的學習涉及到關係代數，線性代數中很多知識<br>其實要注意各種數據結構的存儲結構，圖的多重鏈表，樹的最小帶權路徑，，圖的多路查找<br>等等知識，這些都是高級話題。。<br><strong>6.8 數據結構初步引象(3)</strong>交換排序是置換順序，插入排序更理應被稱為交換排序。<br>雙端隊列是棧和隊列的一種泛化（因為它的二頭都可以出或入）。棧和隊列跟其它數據結構遍歷不同的是，對於棧和隊列的內部是不可訪問的，只有棧頂和隊列頭<br>這幾個元素可以遍歷到。<br>查找表是一種集合，是同類型數據的集合，，因為集合是一種無結構的無序鬆散排列（表是一對一更，樹是一對多，圖是多對多，那麼集合對這些都沒有規定，實際上有表，圖，集合三種大數據結構，樹是表的推廣，圖是樹的推廣，但表和樹都有作為自身存在的意義和作為樹和圖的雙重意義存在，在所有數據結構中，反而只有圖才是用得最為廣泛的。<br>用位向量可以表示集合（這有點像用鄰接矩陣表示圖），其它方法也可，比如鏈表等，，但位向量表達法在提供了位操的機器上產生的效益是很高的。<br>圖也有根，還有無序鏈表unsorted 還是unordered？？連通和強連通，，，迴路和路徑，，環弧邊，無向圖是無向還是雙向圖，這些都是微妙差別的概念。。</p><p><strong>6.9 數據結構初步引象(4)</strong>線性表是最常見的數據結構和邏輯結構，然而只有圖才是最常用的數據結構和邏輯結構。。<br>其實樹狀結構有天然的轉化成線性結構的優勢，因此也有作為線性表的樹的存在(因此說樹是樹性表的一種推廣,教學的時候完全可以從線性表引伸到樹,, 樹有作為線性表存在的樹，樹也有作為樹本身意義存在的樹，和作為樹圖意義存在的樹，這三種情況都需要被討論。)<br>此時從樹的眼光來看這種原來是樹的數據結構它還是存在父子關係，從線性表的眼光來看是變換了的平等關係.<br><strong>6.10 ordered與sorted</strong>Lists廣義列表，list線性表<br>有些教科書混用ordered與sorted,比如二叉排序樹它並非二叉有序樹，當然，<br>為什麼又有無序樹，有序樹呢。<br>Ordered表示一個接一個，順序不可改變，如果被改變(比如一個元素後接的元素不再是以前那個了)，就不再是以前那個ordered list了，<br>所以如果一個unosorted表被sorted過了，它肯定不再是以前那個ordered list了(但它肯定是ordered的，因為它要維護它<br>線性表的特性即ordered不過它當中有些元素的ordered位置換動了而已)，而是一個新的ordered且sorted的表。<br>.<br><strong>6.11 數據結構與抽象</strong>(1)<br>程序如何分類呢，從算法和數據結構的角度看我們可以發現，數據結構加算法等於程序。<br>因為數據結構源於從一套相似的算法中找出操作對象的共性這個現實<br>而從複用來看呢，，又可以產生設計和接口就等於程序這種說法<br>因此這完全是不同事物的不同唯度而已。。根本沒有可比性。（至少二者都可以產生程序這個概念，於是，程序=機器加電也是正確的）<br>OO化並不強求以靠近現實的模型來設計應用,而更多地是利用OO的訪問控制以同一種方式看待代碼與數據(設計代碼，定義數據)<br>在命令式編程語言中，控制結構等等被證明為可以產生一切邏輯。。因此具備三種控制結構的語言都可以成為產生一切邏輯的語言。。<br>(2)<br>抽象完成了之後，只要不是過度抽象，那麼所有後來的事情都是另外一回事了，比如抽象了數據類型，那麼關於數據的邏輯都成了數據結構學了<br>算法並非代碼邏輯，而只是附屬於語言和數據結構學交界的那些東西（算法是從屬數據結構的），只有設計模式才是代碼邏輯和代碼抽象學。。<br>從開發（者）的觀點，我們可以把OS看成是提供API的軟件抽象機制(這本書主要是從開發的角度抽象地講解一系列專業概念)，同樣從計算機開發領域的角度看，我們可以把算法看成是數據結構的附屬，，因為數據結構是源於算法的，而數據結構是開發中的數據抽象，，,,因此作為從開發眼光來看的算法是數據結構的附屬(因此人們說算法和數據結構是數學，計算機軟件，計算機硬件三門學科之間的交叉學科，)。<br>在程序設計中，抽象無所不在，OO就是一種對數據和代碼進行統一抽象的方式。。<br>在架構中，抽象也是很常見的，比如七層模型，只有解決了前面的問題，才能著手下一層更高級的問題，這是目的也是原因，，是起點也是下一個終點。<br>我們知道抽象的本質在於對人的簡單性，比如OO的三重機制製造的抽象就在於統一數據和代碼，於是產生了複用效益。抽象的本質在於遠離問題，從靠近人的一<br>個高層角度去解決更高級的問題。<br>這就是抽象.<br><strong>6.12 真正的邏輯數據結構只有二種</strong>字符串這麼平常，然而卻需要涉及到不淺的數據結構和IO，，這使語言表達字串方面成為學習這種語言的一個重要方面。<br>當然，數據結構絕非僅僅數值數據結構。數據結構不僅用來研究數值，節點數據可以是任何類型。或adt<br>其實理解很多數據結構(data set 和data relation set)前要理解的東西就是什麼是數據和數據節點，，這才是最重要的，但很多人忽略了它，那麼數據節點體現了什麼重要概念呢，1是order還是sorted,2是key value的分別，計算機能處理的數據節點是邏輯上存在order的，所以產生無order，即集合，有order，線性list，層次tree，，，另外，計算機能處理的數據節點是key value的，這就是計算機能處理的“數據‘和它能形成數據結構學這樣的科學所加的二個traits，，數據結構絕對不是廣義數據的結構，而是有一定條件的概念(我們人類目前的科學都是在一定的限制下討論某具體問題的)。<br>明白了以上這樣我們就可以理解一種特別的數據結構了，即hash table,首先它是key value對，如果不是，就是hash set hash map之類的東西，，這滿足第二點條件traits。。。第二，它的hash，是針對數據結構來說的，hash一定要是hash個數據結構出來，而前一些數據結構是uniform的而hash table,map,set之類的都是uniform的而已。這滿足第一個traits.<br>真正的數據結構其實只有二種，表和樹，因為按order來看，前者是線性，後者是層次（我認為只有這二者才是劃分和形成概念的標準），如果說硬有第三種，那是unordered的，即集合，集合才是取代圖的概念，而不是圖，圖只是邏輯結構居先<br><strong>6.12 樹與圖初步引象</strong>樹是圖的一種特例（沒有迴路的連通圖，樹是sparse圖），圖的樹的區別在於，樹是嚴格分層次的(它的前驅是父，後繼只能是子，因此產生出父子，節點的高，寬度，樹的高，寬度等概念)，而圖是任何頂點間都有可能發生關係(即存在邊，存在邊就叫鄰接),除了樹，圖之外，還有森林（相比樹對圖的定義來說。它少了一個條件，森林是沒有環，可能不連通的圖,一棵樹也可以是林林，但森林不一定是一棵樹），,二叉樹與一般樹的區別在於1，一般樹不可以無節點，而二叉樹可以沒有節點，2，二叉樹的某個節點至多有二子節點，即二叉樹不但分層次，而且子樹也分順序，因此對於一般樹的邊歷過程有三種,,先（根）邊歷，中（根）邊歷，後（根）邊歷，，但是正是因為二叉樹有左右子樹之分，因此中序邊歷是二叉樹特有的。<br>樹和圖都可以作為數據結構(主要作用在於存數據,附帶一定邏輯的數據)或邏輯結構（主要作用在於表邏輯），節點可存任何東西，比如一個條件，一個值或一個結構都可以。邊也可以加權表邏輯。。比如最小生成樹是最小加權生成樹的簡稱，，注意，樹有最小子樹，圖也有最小生成樹。<br>如何存儲呢，因為用圖可以用來解釋樹，因為決定圖的特徵在於它的節點，因此它也可以用跟圖一樣的存儲結構來表示自己。但是因為樹是圖的稀疏表示，一般不用鄰接數組存儲節點的每個所有特徵，,引線二叉樹才這樣做(因為它賴此達到一種維護它訪問的能力)。<br>.<br><strong>6.13 樹初步引象</strong>(1)<br>如果將樹某個節點的從左到右的子樹看成有序的（有左右的order之分），那麼就是有序樹，即ordered樹，但卻不是sorted的，因為只有二叉排序樹binary sorted tree才是排序樹（不過它不是左右子樹之間的sorted，而是左右子樹與它們的根之間的sortness）。<br>就特徵的逐步放寬而言，存在，二叉樹（order），二叉查找樹(sorted)，N叉樹(un ordered),多叉樹(之所以不把N,多叉樹這二者等同，是因為我們特別強調N叉樹子樹間不order,而多叉樹根本不考慮這一點,根本不考慮左右子樹之間的關係)<br>樹為什麼稱為遞歸的呢，就是因為它的子樹也是一棵樹，，而這棵樹的子子樹也是一棵樹，因此被稱為遞歸定義的。<br>樹的高度就是深度，因為根的深度就是高度。（因為遞歸定義中非葉節點就是子樹，所以非葉節點的高度就是該子樹的高度寬度等特徵，即用根節點特徵來代替子節點高度等特徵）<br>線性表的線性“序order”和樹的層次“序order”這二者有什麼意義呢，這種意義決定了對於它們的遍歷邏輯。搜索邏輯主要跟sortness有關，而不是orderness有關，線性表決定了它的元素順序是有序ordered的(雖然並不一定經過排序sorted)因此遍歷可按前驅的方向或後繼的方向但不一定搜索一定要嚴格按這個順序因為那是由sortness決定的，因此樹的搜索方向可先（根）序，後（根）序。而樹的遍歷其實任何訪問都是從根開始，，所謂中序，其實也是從根開始，只不過它處理數據的順序是不跟它的訪問順序一樣的而已。而且它是隻有二叉排序樹才有的。<br>兄弟是同一個節點為父的子節點，而堂兄弟是父節點在同一層的子節點。<br>通路跟迴路，七橋問題解決的是歐拉通路而非迴路，最小生成樹是最小加權生成樹的簡稱，但是存在另外一種最小非負加權生成樹的東西，，就是最小代價cost生成樹了。<br>在樹中，有height balanced tree也有weight balanced tree,這個weight就是一個層上節點的最大值。。<br>作為圖的樹的深度優先有時要求回溯，深度優先遍歷時，它從一個節點開始往下遍歷時，在到達葉節點時需要重新向上“溯樹”。<br>這就需要額外維護一個棧來記錄已經訪問過的節點。當訪問到一開頭那個節點時就“標記已訪問並存入棧”，下次從這個節點的兄弟作下步向下遍歷完成並作回溯時需要將其彈出堆棧，，，以此類推完成遍歷（因此它是一個由樹的遞歸特性決定的遞歸過程）。。<br>圖的廣度遍歷用到了隊列邏輯。<br>.<br><strong>6.14 B減樹</strong>B-tree就是B減樹（因為存在一個B+樹所以會導致這樣的誤解，實際上並沒有B減樹這個概念存在，-號只是一個連字符而已也可寫成B_），也不要跟二叉樹binary tree混淆了。<br>那麼什麼是B減樹呢，一般說它是Bayer’s tree的縮寫（bayer是這種樹的創建者之一的名字，另外一種最常見的命名方法是b=broad,bushy,因為這種樹所有“外部葉節點”在同一level上聚 集）。它適用於樹的內部節點被頻繁訪問，但又一般不常訪問這些節點以下 節點的情況，比如計算機的二級存儲器硬盤等設備，常以結點為目錄，葉節點為文件，，一般我們頻繁訪問目錄但又不常深入最終每個文件。<br>實際上b減樹也是要求一定的balance的(有人也說B減樹的B代表balance,不過這樣的話就與普通的平衡樹相重意義了所以並不常採用這種),,它是一種動態查找樹，因為需要在每次update後都動態調整它的節點情況。只不過它並不需要作特別頻繁的rebalancing動作，因為B減樹將外部節點維護在同一層次上這個特點使它只需要只很少的調整便可保持balanced。<br>那麼B減樹到底具體是如何一種數據邏輯呢？它到底如何使保持平衡只需很少的調整呢？更重要的是，B減樹到底有什麼用呢？<br>首先，這種樹的某個（或每個）“內部非葉節點”的下層子節點(直接子樹)是數量可變的，而且在一個區間裡變動（我們呆會再來討論這個所謂的區間），這個非葉節點維護一堆elements和pointer,其中elments用來區別各個子樹的取值範圍，比如這個非葉節點有3個子節點為根的子樹，那麼它需要維護2個 (子節點數-1個)elments，假設為key1,key2，那麼第一個子樹的所有值都小於key1,中間子樹的所有值都在key1和key2之間，最右邊子樹的所有值都小於key2(當然，這是N叉樹，3叉樹，這裡不是說二叉樹的左右)，很顯然地，key1,key2這些elments是sorted有序線性表，那麼points部分呢，它指向每個子樹..有幾個子樹(子節點)就有幾個pointer. 所以，每個內部節點維護（該節點所擁有子樹數-1）個的elements和（子樹數）個的pointer. 葉節點在同一層上，沒有element也沒有pointer.，不帶任何信息。<br>現在來討論那個所謂的區間，以m為order的B減樹(稱為B-tree of order m)，再設n是一個內部節點允許的最少節點數，那麼那麼區間就是[n上界,m下界]，以這種區間為表徵的B減樹一般呈現出以下特性<br>（1） 每個內部子節點（只要不是作為該子樹的根或葉子）都至少有m/2個子節點；<br>注意，最多m,最少m/2;此時n相當於m/2<br>（2） 每個內部子節點(如果它就是作為子樹的根並且不是葉子)那麼最少可以有2個子節點；<br>這說明，該內部節點最大子elments數可以為m或m-1,最少elements數可以為m/2或m/2-1(n=m/2或n=m/2-1);<br>(3)每個內部子節點(如果它是葉子)，，，那麼不帶任何elemnets或pointers<br>所以，“子樹數-1個elements”,“子樹數個pointer”,“葉節點不帶任何信息”，“n-m的區間所體現的上面三點”，，這些都說明了什麼呢，這些特徵都賦於了這種樹什麼樣的特性和能力呢？<br>我們可以看到，如果內部節點不是作為最終葉節點，那麼它(要討論的這個內部節點)的子節點(它的下一級子節點)個數至少是半滿half full的，這意味著，在[m,n]區間內(或稱[m/2,m])二個半滿的內部節點可以進行合併形成一個合法的新內部節點。一個全滿的內部節點可以分離成二個合法的<br>新內部節點(只要父節點中可以容納這些新子節點就可以)，從這層意義上，的確不需要太多的高度上的平衡。<br>更多的關於這種樹的刪除，插入算法可以從這層意義上引申而來.</p><p><strong>6.15 圖初步引象</strong>在數據結構中，我們一般是從最普通的情況談到施加了各件條件和限制的情況），比如有向圖是無向圖的一種特殊情況（施加了有向這個條件，而無向圖是一種更一般的圖，因此圖論中一般是談無向圖及遍歷等操作，再談有向圖及其特性。(特別DAG)。<br>線性表是數據項平等的集合（抽象數據的最高境界最一般情況是集合,因此在對各種ADT進行定義的時候都涉及有集合），無論對其進行什麼操作，只有維護一 個線性關係而不管它是無序還是有序的，就是線性表，而樹的各數據項是有層次level的，無論對其進行什麼變換，只有作為樹的眼光從根向下來看，它總存 在邏輯意義上的父子，這層邏輯意義是作為樹的意義存在的，在對樹的各種操作中都考慮進去了作為處理時的因素的)，<br>因此從邏輯意義上來說，樹是線性表的推廣,,,圖卻不是樹的推廣,,,因為雖然它也處理數據項集，但它處理的是數據項間連通關係而不是地位關係，在其各種存儲表示和後來高級邏輯中都會加入鄰接考慮。<br>如果說其它數據結構只有數據項集，那麼圖不但有數據項集，而且有頂點連通關係集。參見對其ad t的定義就知道了,,而顯然連通關係並非前驅後繼關係，，在關係代數中，，存在有全序偏序對稱自反等關係。。<br>也即在圖中，結點的地位關係我們不考慮，不存在線性平等也不存在樹型父子，而是不考慮這樣的地位關係,這一點上它像集合，（集合，是不考慮結點之間地位關係也不考慮連通的），圖只考慮一種稱為連通關係的不倫不類的關係，這一點上它區別所有的數據結構，它的二個頂點間可以連接，這一點跟樹相同，但是頂點並不經常用作存儲數據用，這一點又跟樹不同，樹的二頂點存在的是地位關係，而圖的二頂點要處理的是連通不連通關係。。<br>因此我們規定，邏輯數據結構只有二種線性和非線性，只要不是線性，那就是非線性，而不管它是節點地位關係導致的非線性，還是其它關係，比如連通不連通導致的非線性（其實這二者無關，因為圖也可用矩陣來存，，而矩陣，雖然是一種非線性結構，但以某種眼光看，它又是線性的）。<br>數據結構也可是邏輯結構，樹可作為數據處理結構也可作為邏輯表達結構比如流程，因此圖不但是一種數據結構而且還是一種組合數學中的離散結構(比如拓樸學就是關於有向圖的)。。。.<br><strong>6.16 樹的平衡與旋轉</strong>一般教科書把廣義表跟（多維）數組放在一起講解，是因為有時泛意義上的數組就是廣義表的一種。<br>如果你知道函數對於結構化程序設計的重要性的話，那麼你也會明白堆棧對於函數調用邏輯的重要性，所以理解結構化程序設計範式的重要手段是理解堆棧這種ADT。<br>相比線性表O(n)的複雜度來說(輸入的元素個數是最主要的影響因子)，對二叉樹的各種操作（插入，查找刪除）效益直接受制於高度，即h = O(logN)，即樹提供了O(logN)的複雜度，其中N是節點數，（二叉樹中）我們並不直接把N作為影響操作效益的因素，h才是，因此需要對height進行balancing才能控制操作效益。<br>BST的構造是嚴格取決於待輸入系列的，當待輸入系列本身就是一個sorted的系列時，那麼當這些序列被用來構造BST時，它就是會退化成對應的“鏈表”。在操作上會失去樹的優勢。<br>一般存在“節點的深度”，“節點的高度”，“（子）樹的高度”這三種說法，節點的深度是從根開發，到這節點為止的那條唯一路徑的長，節點的高度就是從節點出發，到這個節點能到達的某個葉節點的最長路徑的長度，因此如果這個節點是內部節點，那麼其深度就是其所在層次（葉節點時為0，不存在時為-1），其高度就是從這個內部節點到與它相連通的最長路徑的那個葉節點的長度，當為根節點時高度最高，當為葉節點時，高度為0，而樹(或子樹)的高度就是以此為根的那個樹或子樹的節點的高度。<br>實際上avl樹只是自平衡二叉樹的一種，高度差為一是這種樹的最古老定義（self balanceing並不僅僅是height balancing 動作。而AVL僅僅是balanacing the height），還存在其它不以height的調整為其平衡方式的樹，比如紅黑樹，但是隻有AVL樹是嚴格用平衡因子去定義的(因此是“平衡”的最正宗意義所在)，而紅黑樹不是，因此紅黑樹不是平衡二叉樹，實際上它故意允許一定程序上的不平衡。<br>紅黑樹不是平衡二叉樹但它“保證”2*O(logN)的最壞情況下的平衡度（人們往往根據這個原因把它歸為跟AVL一類），AVL樹是1.44*O(logN)，這二種樹只“保證”（注意只是保證）最差情況下的下界為1.44*O(logN)或2*O(logN)，稱它們為平衡樹不是因為其內部是不是極力在保持平衡還是不是，重點在這裡（最壞情況下保證了多少的平衡度），，綜合考慮插入，查找，刪除等操作來說，紅黑樹的效益要好於AVL，因為AVL是嚴格平衡的因此只對查找intensive。查找時只需向上查找1.44*O(logN)個節點就行(經過AVL平衡的樹只需對height bounded at 1.44*O(logN)個節點進行處理)。。<br>一個節點的平衡因子是左右子樹根節點深度之差(注意並非高度之差)，因此不要跟這個節點所處的深度本身搞混了，一個只有左子樹無右子樹的樹，它的樹根的深度是0(樹根的高度越到根越大，樹根的深度(相對整樹來說)永遠是0空樹為-1,這個深度並不影響樹根的平衡因子)，平衡因子是1(只跟左右子樹的深度有關)，因為右子樹不存在，深度為-1,（而左子樹深度為0）,因此它們差的絕對值為1,,即平衡因子為1.<br>在建立AVL樹（向一棵普通意義下的binary sort tree進入插入一系列key碼）時，邊插入邊判斷（插入點的平衡因子是否導致了不平衡），在發現因為插入動作導致的不平衡現象時進行rotation.，以維護其平衡性，直到所有的數據插完，這樹依然維持binary sort性質（因此稱sort tree為查找樹，，即查找特性intensive的，作為數據結構的樹，其實它的本名最開始是sort tree然後才是search tree，search tree一般有二種，第一種是每個節點都含key 和value的，所以它的每個節點都包含數據，而有些search tree只有葉節點含數據，其包括根在內的內部節點都用來search,只包含有key）和height balanced 性質。<br>那麼怎麼樣進行判斷並在需要的時克rot(根據情況不同有時是二次rot)呢？ 在這之前，我們需要規範一些概念。1.rot所涉及到的主體（插入點和支點privot）2,最小不平衡子樹。3, 扁擔原理。<br>最好的方法是舉個例子。<br>比如我們將考慮把{20,35,40,15,30,25}製造為一棵binary sort並height balanced tree，，當插入20,35時，20為根(第一個插入的當然作為“整棵樹”的根)，35為其右子樹（因為binary sort要求它作為20的右子），當考慮插入40時，40>35也應該被插到作為35的右子樹，此時雖然binary sorted了，但是卻不height balanced,因為隨著40的插入它將這(整棵)樹變成了不平衡的樹（明眼人一看就知道這屬於明顯的四種不平衡情況中的RR型不平衡，當然為了學習的目的我們還是打算仔細地說明一下，而且存在比這樣的僅僅由三個節點構成的RR型不平衡的情況更復雜的情況，需要我們考慮一套更通用的處理方法，在這裡第一個R是指整樹的R，即35，第二個R是指整樹的R35的R，即40，顯然地，40節點處的深度為2，35節點處的深度為1，20節點處的深度為0，但在這樣的樹中35沒有兄弟，整樹沒有左子樹，而40也沒有兄弟，即35沒有左子樹，這導致三個節點的平衡因子不一樣，我們從上到下再一層一層考慮一遍，，首先拿20來說，它的右子樹即35深為1，而“整樹”左子樹不存在為-1（這就是第一個R，因為只要左子樹為-1就可能產生深度上不平衡的劇變開始），因此20平衡因子為2，請時克提醒自己牢記這是棵二叉樹因此只有L，R的情況需要被考慮，，再看35的平衡因子，40作為35的右節點也作為整樹的葉節點，其深度為0，而35的左子樹不存在為-1（這就是第二個R，這裡討論的是35的R而非跟前面那個作為整樹R的R，，這第二個R的左子樹也不存在，因此提出這個R，，因為它也有可能產生深度上不平衡的劇變）,因此差絕對值還是在1之內，既然出現了不平衡，而且我們也知道為什麼不平衡(就是整樹根處平衡因子超出了1違規了，，由於前面那二個RR，終於在這裡產生了真正的劇變)。那麼接下來就是處理掉這個不平衡了。我們不妨細化這個不平衡到一個稱為“最小不平衡子樹”的地方。然後再考慮處理之。<br>即從插入點40的眼光來看，我們可以找出一個 “最小不平衡子樹”， 不平衡的地方一定發生在這裡(這個“最小不平衡子樹與插入點相關，因為它就是距離插入點最近，而平衡因子卻產生違規的第一個節點為根的子樹”)，我們需要對其進行平衡處理主要在這裡進行。(在上面的例子中，是“整樹“作為“不平衡子樹”。因為20處出現了違規而且那是整樹的根, 這裡提出了20這樣我們就可以開始著手解決開篇提到的處理主體的問題，即一步一步導出“最小不平衡子樹”這個概念相關的插入點和支點，下面我們談到扁擔原理)；<br>對這個以20為根的“最小不平衡子樹”的處理涉及到“扁擔原理”，在用扁擔挑東西的實踐中，如果前面重我們就把支點向後移動，如果後面重我們就把支點向前移動，（雖然都是以“支點”移動，但挑扁擔中是移動，支點是我們的肩膀，在這裡我們是作二叉樹的平衡處理也稱為“旋轉”，那麼樹旋轉中的“支點”呢，是不是也可以找到能類比的概念呢？是不是就是最小不平衡樹的樹根呢？），首先我們要明確提出“最小不平衡子樹是為了確定作平衡處理的範圍”，而找出“支點”卻是另外一件事,(與找最小不平衡子樹的目的不同，找支點是為確定從何處為軸進行旋轉，我們找出了最小不平衡子樹並不意味著這裡的“支點”就是最小不平衡子樹的根，-------其實上面情況中的支點即RR的第一個R35,,我們能找出它，是因為在RR模型中，這樣的模型所在的最小不平衡子樹中必定存在三個節點，即由“最小不平衡子樹的根節點”，“根節點的右節點也即第一個R”，“再就是第一個R的再下面一級R即第二個R”這三者組成的模型中，“支點”就是第一個R（而不是最小不平衡樹的根），上面問題中，顯然35才是那個“支點”，至此我們找出了支點，接下來判斷哪裡重的問題)，“重”即“支點需要往支點的哪個方向移動”這個邏輯。<br>那麼究竟往哪裡移動呢？根據挑扁擔原理，當然是往重了的方向移動，但這裡有二個“重”的邏輯，首先第一個，我們知道20不是支點，20的右子樹深1,而左子樹深-1，這裡存在一個以20為中心但左重右輕的情況，那麼它是不是就是“重”的意義所在呢？顯然在這裡是右邊過重了（平衡的情況是要麼左子樹大右子樹一，要麼右子樹太左子樹一，這裡卻大了二下，重了二下），如果這裡是“重”的意義所在，支點就需要往輕的地方即左子樹方向移。<br>再來看第二個重的意義，在RR模型中，如果說第一個R是支點，那麼顯然地比起上面提到的第一個“重了”的意義來說，這裡的重是指代第一個R的父節點平衡因子過大為2，而R的R即第二個R為0,這也產生了左重右輕，（RR模型中，第一個R的父節點是產生違規的所在，正是它帶出了RR，這三者由於旋轉的需要又產生了“過重”，又需要找出一個“支點”進行平衡處理,這個道理也很自然，而且找出的支點是嚴格以平衡因子來決定其左輕右重或右重左輕的），但是顯得有點蹩腳，因為這裡的支點並不嚴格相當於現實生活中挑扁擔的支點，，這裡的支點完全是從一種模型中比如RR模型中選中的第一個R），這雖然成立，然而，以這樣的意義導出的支點再層出的“重”不是上面第一個意義的直觀的含義，是不太符合現實中扁擔水平移動那麼簡單自然的道理，這裡的重是考慮了“R的父節點”+“第一個R”+“第二個R”的，因此是一種有層次的樹的模型（而不是對應於扁擔加扁擔二邊的重物那樣選肩膀就可以作為支點的模型，因為我們上面談到的第一層重的意義不是支持支點移動的意義所在，，這裡的是只需要從RR模型中選擇前一個R作為支點，而且其旋轉是一種左傾主義的旋轉）產生的“非水平過重（從樹的旋轉圖中可以明顯看到）”。。。<br>但反而這裡的“重了”才是“重”的真正意義所在， 在這第二層意義下，我們再看詳細的例子就會理解它們了。<br>這樣我們就解決了開篇提到的“扁擔原理”，綜上所述，我們討論了RR的情況（如何判斷違規以及如何作重平衡處理），，下面談到的是LR的情況了。請自行理解。<br>.<br><strong>6.17 完全與滿</strong>Vector之所以稱為index list，，我們知道index是索引式存儲，list是邏輯結構，於是四種存儲結構和四種邏輯結構可以組合到16種組合方式。而index list正好是這其中的一種。<br>滿二叉樹的概念容易弄懂，而完全二叉樹（二叉樹都是從左到右有序的）這個概念實際上並不突出“編號”，它表現的是這樣一種樹：如果在某一層上，左邊的節點為空，那麼（在這個節點）右邊就不能有節點，無論是這個節點右邊的節點是個兄弟節點還是堂兄弟節點。所以滿二叉樹一定是個完全二叉樹，而完全二叉樹不一定是個滿二叉樹。。<br>樹的遍歷分先序，中序和後序，又分遞歸遍歷法和非遞歸遍歷法，故有6種遍歷方法(也許只有前序才能遞歸？因為它是根，只有根才有遞歸意義？)。 當把對樹的遞歸遍歷轉化為非遞歸遍歷時需要一個輔助棧外加幾個循環(我們知道加棧是遞歸算法轉化為非遞歸的通用手段之一)。<br>完全二叉樹中的完全跟完全(無向)圖中的完全以及完全有向圖的完全意思是不一樣的，前者並不是一種規則形狀(比起滿二叉樹來)而後兩者是規則情況。<br>因為連通圖對無向圖有意義但對有向圖卻沒有意義，因此對有向圖引入強連通分量的概念。<br>.<br><strong>6.18 多路234樹與紅黑樹的導出</strong>數據結構間都是有聯繫的，比如234樹其實可以導出紅黑樹也可導出B樹。<br>紅黑樹也是一種二叉排序樹，因此一方面保證了查找效率（中序遍歷時可以快速到達根部），另一方面，它也保證“最深的深度不大於最淺的深度的2倍”，這使得紅黑樹有一定程度的balance 特性，因此對於查找之外的另外操作，它也有很不錯的效率。<br>紅黑樹主要是通過為每一個節點著色來達到以上特徵的<br>1． 首先一個節點要麼是紅要麼是黑只有二色可以被用來著色。<br>2． 根節點默認為黑色<br>3． 對於葉節點來說，不管它的父節點是黑色還是紅色，一律著色為黑色。（每一個葉節點我們都可以假設它是一個內部節點因此有有二個不存在的子節點設為NULL）<br>4． 對於任何一個節點來說如果它是紅色，那麼它的二個子節點都為黑色。(從每個葉子到根的所有路徑上不能有兩個連續的紅色節點，因為從葉子到根的路徑是唯一的，也即它就是從根到這個葉子的路徑，因此它是這個葉子的深度)<br>5． 高度方向上（注意這裡不談到具體的高度，而是指高度方向上），從任一節點到其每個子孫葉子的所有路徑都包含相同數目的黑色節點。<br>以上五條特性導致了<br>深度上，“最深的深度不大於最淺的深度的2倍”， 從根到葉子的最長的可能路徑不多於最短的可能路徑的兩倍長。<br>我們來推導一下上述性質，並規範一下“從節點到根，從根到節點，從節點到葉節點”這些說法的準確含義。(注意有時候高度就是深度，當一條邊的層次決定它有多少個點附著上面的時候，這也就決定了它的高度和深度具有同一性)<br>.<br><strong>6.19 快速排序思想</strong>快排是一種交換排序，這種交換髮生在待排序列本身之上，首先，將序列按中間位置分為二部分，隨便從整個序列中取一個臨時成員，這個成員就是“待排”的對象，這個待排對象完成它的一次排序後，那麼整個快排也就完成了，因為它最終到了它應該被排在的位置。<br>取出這個待排元素後，以中間位置為基準，分別以從左趨向中間，從右趨向中間的順序找二個對象與這個待排對象比較，，，這所謂的二個對象是滿足條件的(從左趨向中間找的元素要大於待排對象，從右向中間找的元素要小於待排對象，首先是從右向中間找，然後才是。。)，而且可能有多個（顯然在二邊可能會有多個大於或小於待排對象的值），，所以這個過程要持續幾次，，這個待排對象才能最終到他應該去的位置。<br>那麼這是一種什麼樣的“交換”排序呢，我們知道待排元素所在位置空出後，，從右邊找的值填充（右端第一個大於待排對象的值）這個位置後，那麼這個值所在的位置我們置空它，到這裡為止，待快排對象原來所處的位置被填充，，只是它的值尚未被放入一個確定位置，而且，這裡又空出來一個位置，，就是在右端比較的那個值填充待排對象原來空位後空出來的位置。<br>現在在左端進行與待排對象比較的過程，同樣在找到第一個小於待排對象的對象後，將這個左端這個空出來的位置空出來，將這個值填入上面右端比較時空出來的位，那麼到現在為止，第一套左右值被找出來了，而且到現在為止，待排對象沒有被置入一個位置（因為只是比較了第一套左右值），而且左端又空出來一個位置(但是此時還不是結束快排的機會，因為還存在其它的左右值對可供與待排對象比較併產生新的空位—左邊或右邊的)。。、<br>那麼在進行第二套，最後一套左右值比較時，一定最終會多出一個左空位或右空位，此時將待排對象置入，，就算完成了快排。<br>.<br><strong>6.20 數據結構之數組</strong>數組是一種順序數據結構，它本身獨立作為數據結構來用時，也是一種線性結構，然而它用來模擬樹時，或用來實現其它數據結構時，那麼這些形成的數據結構就談不上是線性結構了(當然作為底層的數組它還是順序的)。。<br>線性是針對邏輯數據結構來說的，數據結構可按邏輯結構和存儲結構分類，當數據結構按邏輯來分時，有一種是線性的，因為數據結構總有結點，線性數據結構中的結點存在線性關係，即每一個結點都有且只有一個前驅和後繼，這種現象可用一種關係數學的表達符來表達(關係數學是關係數據庫的數學基礎，而計算機的數據結構學跟數據庫學又是相通的)。。當然，頭結點和尾結點除外，與線性對應的當然就是非線性了，比如樹，除了根節點作為沒有前驅的之外，包括根節點的任何節點卻都在邏輯上（作為樹的邏輯）有二個後繼，還比如圖，任何一個節點都在邏輯上可以包括多個前驅和後繼，，，邏輯上都有前後之分只是線性的是一個對一個，而非線性的是一對多，或多對一。。<br>(下面我們用結點來表示邏輯數據結構中的獨立項，用節點來表示存儲結構中的獨立項,用記錄表達索引邏輯的獨立項，這是三個完全不矛盾的詞,)，<br>當數結按存儲來分時，有一種是順序的，即它申請了一塊連續的內存來構見自己(至於它是用這內存實現了線性的還是非線性的邏輯上的數結我們不知道)，，數組用存儲結構的相對位置來表達它的邏輯結構（這就是索引），，數組可以獨立成為一種抽象數據結構(這就是普通的以數字為下標索引的數組)，，也可以用來實現更高級的抽象數據結構(比如樹)。。<br>按存儲來分時，還存在鏈接型數組結構，索引數據結構，離散(散列)數據結構，其中順序的當節點沒有使用完全部空間，它就顯得有點浪費，而其它的還行。。下面一一介紹。。<br>鏈式的很普通，索引式的就是系統(你的應用邏輯)維護一張索引表，裡面有各個記錄(我們稱要索引才會有記錄)的記錄，比如一個記錄的長度，存儲位置,等，通過查找表，就能找到記錄。<br>而散列的，系統維護一個函數而非一張表，函數體的邏輯計算出“記錄的存儲位置”和"key(KEY就是索引邏輯面向用戶的一層)"之間的對應關係。。<br>所以無論是順序，鏈式，散列，索引表，我們都是在進行一種最終到記錄的存儲位置的索引工作。。數組名[下標]這樣的一個形式，用計算機的眼光來看是內存地址，用人的抽象來看是索引工作。。而無論是順序數組，還是鏈式，索引，散列，都是通過某種抽象形式(下標，，全局表，函數)來最終尋找到內存地址。。。<br>這個道理就像，我們通常不用&變量的形式來獲得指針的意義，而是用*，因為&是面向內存的，而*是面向用戶的抽象.<br><strong>6.21 數據結構的抽象名字</strong>在C中提供了很多支持數據結構和算法的元素，比如數組，鏈表，指針，struct,typedef,相比其它語言，c還提供了比其它語言的更好的支持數據結構的語言機制。。特別是，C中的一些語言機制，如位移(其實大都機器提供的位指令並不直接操作位，而是對整個字節進行位操作，進而間接控制所需要的位，我們常常通過對原字節進行位移的方法得出bit mask，再將這個bit mask跟原字節進行與，或，異或，最後得出需要的效果，比如提取1位，消去0位，顛倒特定位)，跟搜索算法中 特定一些算法直接相關，，相比之下，其它高級語言的數據結構都是基於高級語法結構的.甚至於像lisp這樣的語言就將adt內置為其一級類型。<br>算法源於用計算機去解決實際問題，對由研究算法過程中出現的數據結構問題的研究也是一個很重要的工作，特定數據結構和作用於其上的算法們，就稱為一個adt..<br>有時，上層的抽象adt可以有自己的一套算法獨成一種adt,與它們的子adt一樣，，，，有時，adt之間進行某種意義上的組合形成新的變種adt,,,又有自己的一種算法，如果組合了2種adt,那麼就是一種帶有2種意義的adt,有時，一種adt以另一種adt作為實現，自己作為一種抽象，，這樣的方式演化成一種新的adt.我們必須明白這所有抽象叫法之間的關係，明確他們其實所指的東西有很大的不一樣。。而且要明確這些叫法之間的特指與泛指的層次關係。。誰由誰通過誰抽象得來。<br>我們一般稱線性表為list,或者sequences,但其實後者比前者意思更清楚一點，因為一般list就是指linked list,這字面上的相似給我們理解造成了麻煩，而sequences正好指出了線性表的二個方面，(1)，sequences這個詞意思是序列，list不但是一種序列，它更是一種有序序列，即ordered list,這就是說，前面一個元素是接著後面一個元素的，可由相鄰的節點按一定邏輯到達下一個元素，雖然list不一定是sorted list(各個節點按數組順序或字母順序排列)，但它至少是ordered list,(2)，sequences很好地與linked list在名字上區別開來,它跟linked list是泛指和特指的關係，除它之外，數組，集合，隊列，堆棧這樣的adt都是list.<br>關聯數組包括普通數組，關聯數組是一種可以被稱為廣義數組的數組，我們知道關聯數組是key value索引對，只是它的key可以是任何類型，而普通數組只是interger,,,關聯數組有很多抽象，甚至只是別名，比如在smalltalk,objectivec,.net,python,realbasic中被稱為dictionaries，在perl和Ruby中被稱為hashes，在C++和Java中被稱為maps,在common lisp和Windows powershell中被稱為hashetables,在php中存在關聯數組，只是索引被限制成整型和字符串，這就變成普通數組和字典了，在lua中唯一隻有關聯數組這種數據結構，被稱為table,這也是關聯數組比較正統的稱法之一，<br>我們知道集合也是一種關聯數組，不過它把key value對中的value給忽略了，把key作為value,從有keyvalue對這一點來說它像關聯數組，另外，它的索引就是1到n的某個子集，從這一點來說又像普通數組，聯繫一下bit vecotr.<br>數組跟向量這個說法的關係是什麼呢，其實向量vector一般被實現為動態數組dymic array，我們知道靜態數組的空間是在編譯期被分配的，那麼動態數組就是用malloc函數在運行期構成起來的數組邏輯，我們知道數組能線性時間隨機訪問，但是不好重建和插入，因為需要移動插入點後的所有元素，比起linked list來它的索引字段並非指針，而是直接對應內存位置的硬編碼索引，因此比不上linked list在發生插入時可以僅僅通過轉變指向的方式就可以實現數據結構內部的重建。。而動態數組就是這樣一種在運行期有優化了的重建能力的數組邏輯。。<br>vector的學名叫向量，也即數組index list的一種,linked list也即鏈表而非索引表,跟數組有關的不只向量，還有隊列，堆棧關於數組的表示，甚至還有樹，圖,矩陣(一種多維數組，C語言中把foo[m][n]看成是foo[m*n]的一維數組)，關聯表等，除了數組是實現之外，，其它的叫法，它們有些不是指同一個東西(比如向量跟矩陣是不一樣的東西，數學上的向量是矩陣中某維為1的情況下的子矩陣，是構成矩陣的量，向量是向量空間的概念，而矩陣是線性空間的概念，不過他們同構，於是在運算上涉及到了一起，數據結構上，一般vector就是一維數組，而matrix是多維數組)，，有些是一層一層的抽象關係(比如vector是index list的一種，index list又是順序列表的一種,圖有一種形式是樹，而樹又是bst的基礎)。都是建交在C數組這個語言要素上的抽象(前者是實現，是存儲抽象，後者是高層抽象叫法).</p><p><strong>6.22 真正的ADT</strong>在講解算法與數據結構的教科書，有一種語言抽象機制屢屢被談到，這就是ADT。<br>類是真正的數據，，比類的成員數據更能代表數據的意義，我們的程序就是一個一個的數據，類是用用戶的觀點來表達現實生活中出現的各種各樣的數據的最好方式,因此會有面向對象數據庫的出現(數據庫技術中，關係模式的下表達的數據給人的引象似乎是它是為專門的數值數據而建立的)<br>ADT就是指封裝了事物屬性跟作用的指代物本身，它的屬性和作用是ADT之所以為ADT的意義所在。即數據類型不再是基本類型，而是結合了數據跟代碼的抽象了的模型（是一種數據類型）<br>人腦往往不適於長輻記憶，因此也需要對象來表達一些數據(類型)或事物.(抽象抽取對象的可用部分)，再在這裡抽象上構建更為高層的抽象。也即，從問題到解決不是一步而就的，而是一層一層通過OO來建立抽象達成的，這就是多範型的“方案領域”和“應用領域”的概念。<br>多範型開發讓你在高於面向對象的範疇裡看待軟件工程,所以真正的編程學習過程是要明白設計在先，這是基礎的思想，然後去學習編碼，，（以上二點都是方案領域）然後再去研究編程領域對現實問題的解法（這就是應用領域）<br>而且如果你知道可複用和可擴展對於軟件工業來說是多麼重要的一件事情，，，你就會知道面向對象是多麼好的一種機制了(面向對象和麵向構件，面向構件可以不用對象的方法，，但是很明顯面向對象和麵向構件都有一個共同點那就是它們都提供了可擴展，而這就促進了可複用)<br>數據接口是另一個很重要的概念<br>接口實際上就是將要用的部分作為某個接口提取出來(就是定製要使用的實現的某個子集而已)，而所有實現就是接口下的所有代碼,即數據本身，故其實數據與數據接口是分離的<br>設計模式不致於使我們聲明對象的過程變為硬編碼，，，這樣就使得整個軟件的對象生成是動態的，這個過程就如同動態分配內存，尋求一種好的方式來組織類的過程稱為設計模式或策略<br>接口這個概念其實無比自然，無論是為了隱藏實現的安全考慮，還是為了更好地讓這些實現為用戶所用這個方面來說，接口都是必需的，<br>接口幾乎改變了現今我們開發軟件的方式<br>舉個例子，在現實生活中，經理人可以賣票，，，個人可以賣票，國家也可以賣票，，在面向對象的範疇裡(注意這裡並非指某個具體的面向對象設計)，我們一般是把國家，個人，經理人都各聲明為一個對象，再為它們各自添加一個“賣票”服務，，但是事實上，我們需要的僅僅是賣票這個服務，(如果這個服務被包含在一個發佈的第三方代碼庫中為我們所用)，我們只需提取這個可用部分，，而不是要知道提供這個服務的各個提供者的細節(還好上面只是列舉了三個對象提供了這個服務，，然而現實生活是複雜的，還存在成千上萬個對象也可以提供這個服務)，，因此，對於複用者我們來說，我們需要的僅僅是賣票這個服務，而不需要知道賣票服務這個背後的情況(而且，對於發佈這個第三方代碼庫的第三方來說，這可以更有效地隱藏它的實現細節)<br>接口就是把我們所需要的對象部分封裝起來提供給我們，而把我們壓根不需要知道的關於對象的細節隱藏，，，也就是說，，接口是關於一個對象如何能被使用的形式的封裝者(一個對象可以有多種形式被使用，因此可以一個對象提供多個接口)，是真正的對象(實現)和外界複用的包裝器和橋樑，也稱適配器(即接口就是直接面向使用的中間件,或封裝了給二個不同架構提供適配作用使它們能協作運轉的中間邏輯)<br>.<br><strong>6.23 Vector的觀點</strong>vector就是數組的數組，我們知道邏輯上的多維數組必須轉成一維數組的方式被存儲，C中的一維數組是地地道道的數組，，這個意義上的數組是實實在在的，，因為它們是按內存線性地址存儲的，，所以明顯地，，C語言中的其它泛數組的adt都是抽象的，，從C用一維數組實現多維數組這個意思上，可以看出C語言的確是面向底層的，，它企圖用底層解釋一切。由於它的這種作為，導致了表示方式上的一些多義性，比如多維數組的指針跟元素的表示混淆不錯。<br>C中泛數組有普通多維數組,動態數組和vector,其中又以vector最為典型，我們知道，多維數組要轉為邏輯等價的一維數組，，有三種方式，，1，row列優先，這就是C的方式，，比如foo[3][4],它有三行4列row,它先每一行排3個，再4列,,2,行優先，這也就是pascal的方式，但是這二種方式都有侷限，因為它們只能實現為方形規則的數組，要突然這種侷限就是vector的事情了，<br>3,,就是vector方式，，C標準庫中倒是沒有一個vector,我們講c++的stl中的vector,一門語言要模擬多維數組，必須要達到一種“多維數組就是數組的數組”這樣的抽象，而vector就是這種思想的本質，，因為3維數組是2維的，這就是說，3維數組是2維數組的數組，而由3到2,就是把3維中的其中一維標準化了,,縮為1了，，這正是vector的思想，不要把線性代數中的矢量跟這裡的混淆了，但在線性代數中這樣的比較有巧合性，比如矩陣(對應多維數組)是由矢量(某維縮為1的矩陣）所組成的，，矢量就是數組中的數組了。。比如foo[3][4][5],可以是:<br>(1)一個下標為3的一維數組，，每個元素都是[4][5]的二維數組；<br>(2)..<br>(3)..<br><strong>6.24 真正的數據結構</strong>數據結構是什麼？它是組織內存中對象或基本類型數值(primtive types)的形式，為了更好地組織和使用這些對象而慢慢發展起來的固有形式，慣用法(idioms),<br>數據分類與ADT<br>基本類型數值是沒有構造函數的，而Java中對於數值類型的封裝形式就有構造函數，這是它們二者本質的不同，像C++中用new動態聲明一個對象，它一定用到了這個對象所屬類的某個構造函數，可以說C與C++的最大區別就是C++用到了對象ADT，而C沒用到(因此C壓根不需要構造函數來著),STL可以說是一種總數據結構.<br>很多地方都用到到向量，，在學彙編時，，中斷向量表就是一種向量,為什麼STL沒有arrary而只有vector呢？因為數組一般都用來實現vector，而且數組是語言的內含類型,一定程序上不提供太多的接口(根本因為是作為數值形式的數值沒有被wrapper成一個first class因此不能作為函數的參數—因為沒有複製構造函數，只能作為指針形式間接來操作它，也因此不能成為一個函數的返回值)，而Vector可以提供跟數組類似的結構（也有多維數組）和比數組更高級的使用接口(一般數組類型只能是靜態的不可伸縮的，而Vector可作為動態數組動態改變大小)<br>實際上多維數組並不是在內存中是一個標準的矩陣(學過線代就知道，任何一種矩陣都可以化為它的等價三角矩陣)，比如C或C++就用一種行或列優先的方式來索引其元素。<br>數組是一個靜態配置的空間，在命名方面JAVA做得比C++好（個人看法），比如INT MyVar[10];作為數組名的MyVar帶了序列，而JAVA中INT[] MyVar;這就有點相當於type *是指向某種type的指針類型，而type[]是某種大小的數組類型一樣好記<br>下面來闡述幾個易混淆的概念<br>順序線性表，，有序線性表(orderd list)，hasp map（可用關聯容器來表達）都是列表,比如字典順序，也即字母順序的一種關聯機制<br>線性表即通俗意義上的“線性數據結構”，線性的意思是什麼呢，它一定要滿足幾個規則(1，有唯一的第一個元素和最後一個元素，2除了第一個元素都有一個前驅，，3，除了最後一個元素，都有一個後綴)<br>上述的元素就是數據結點的意思，數據和數據結點之間的關係可表達為B=(K,R)的二元組,滿足關係的二個元素一個稱為前驅一個為後繼<br>計算機存儲數據的方式只有二種，順序存儲與離散存儲(又有鏈式，索引式，Hash式)，這是面向計算機端的存儲結構，本向用戶端的邏輯結構有集合(set),,哈希(hash map是一種map),,表(table),數組(array),,向量(vector),,圖,樹,map映射,線性表，節點鏈式表linked list,多維數據結構(matrix)等等，這種關係就有點像數據庫的內外模式之分。邏輯結構間也有高級的演變方式，比如用vector來實現矩陣和table map是映射，，，set是集合,,都是關聯型的數據結構，因此可用關聯容器來表達 集合這種數據結構是用位集來描述數據集(可能以一個數組的形式存在),通過移位和位運算<br>線性表就是不能隨機存儲的表，像數組就是線性的，堆棧和隊列也是線性的,有雙向鏈表的存在(list),,dequece(double end quece),<br>表table就對應關係數據中的模式,,也即一個記錄是一個表，它的各個字段就是表的豎維聚合數據類型就是像圖(map)啊,樹啊之類的，樹是一種特別的圖(每二個節點都有通路)而且是簡單圖<br>圖的存儲結構主要由它的鄰接矩陣來表示，或鄰接表，而樹的存儲表示主要由以下三種表示：結點表示法，兄弟子女表示法，等<br>這就是關聯，，關聯一定有key和一個value,,它們一同被存入數據結構，然後運用某種機制(可能是hash)通過key來索引value圖是一種離散結構而非一種數據結構<br>圖的邊就是頂點之間的關係，這種關係是單向的或者雙向的<br>像MFC的消息系統用的就是表驅動方式(它的消息映射表就是一個靜態表)<br>我們知道，棧是一端開口的，往往從高端壓和出棧(稱為棧頂)後進先出的（但是後出先進這種說法是不存的，因為當一個棧沒有數據時，它就不能出任何東西，因此只能說後進先出，先假設它有至少一個數據存在）因此它有當前指針和棧頂指針這二個元素來表示(當前指針指)，棧往往用數組來模擬(++p,p--這樣的形式)，棧其實是一種跟它的實現形式無關的思想而已(是一種邏輯結構)，因此可以說是數組（指針數組）來摸擬（順序存儲的存儲結構），可以用數組的一端，當，而隊列是一種先進先出的，它二端開口，有三個描述元素(尾，頭和當前指針)，它往往被實現作為一個管道（因為隊列從意義上來講它也其實就是一端進而從另一端出的數據結構啊）作為緩衝，或forward給其它處理list是列表的意思，有序列表orderdlist，鏈表(linked list是一種orderd list)，堆棧，隊列都是一種orderd list就像鏈表和數組都可以仿真堆棧一樣，，樹啊，圖啊都是思想模型，鏈表和數組才是實際存儲的機制.對數據結構的討論中經常用到遞歸，特別是樹中，因為樹本質就是一個遞歸結構，在回溯節點時就是回溯同一種節點(因此這個節點可用遞歸描述 )<br>遞歸跟回溯,棧<br>遞推與迭代還是有區別的，遞歸就是用自己來定義自己，，一般不需要一個循環，，而迭代需要從1開始，將這個循環變量一直自加到最大值(循環不變量？)，，需要一個循環，一般來說，迭代比遞歸更有效率(在某些專門對遞歸進行了優化的環境中除外)<br>對一種數據結構的討論常常不但要明白它們的工作原理，還要明白它們的操作，如查找，排序等，數據結構存儲結構和這些操作就構成了ADT<br>《數據結構C語言版》<br>前言:這是我在2005.7月 - 2005.9月署假看《數據結構C語言版 - 清華大學出版社 黃國瑜葉艿菁著》時寫的讀書筆記,現在把它發佈出來,希望對大家有用,也算是作個備忘錄吧,不科學之處,還望高手斧正.<br><strong>6.25 堆棧與隊列</strong><br>堆棧與隊列都是數據結構(更復雜的還有樹,圖)在關係上是平等的數據結構,實際上堆棧與隊列都是"內含在空間裡的數據塊",堆棧,隊列的本質就是"數據塊",不過它們都是包含在特定內存空間裡的"有序數據塊",如下圖(4.bmp,用數組模擬"特定內存空間")<br>"特定內存空間"可以用數組表示,也可以用鏈表表示,數組是內存中的線形空間,也就是說,數組可以在內存中開闢一段空間,該空間是線性連續的,對該空間裡任一元素的存取要根據"索引值"來進行,這些索引取從0~MS-1(如定義一個int queue[ms]或int stack[ms])是線性遞增的,與數組空間從低地到高地的排列一一對應,數組的每一個空間都可有數據,也可無數據,每個空間的大小為一個int,整個數組大小就是ms個int,但是無論如何,對其中任何一個元素的存取(存是往數組任意位置裡存入一個大小為int的空間,或在某個無數據內容的數組空單元空間裡賦值,顯然,這個數組空間是本來就存在於數組內的,而不同於鏈表要動態開闢一個新空間,而如果是前一種情況,數組就不再是靜態的空間了,因為它的大小由ms變成了ms+1,而這是不可行的,同理,取是釋放一個空間單元,這就使數組總空間大小由ms變為ms-1,或在某個空間裡賦值0,術語稱置0,而事先不管這個空間裡有無值,如果有值,有的是什麼值),其實,對數組索引的描述不但可用0~MS-1,當然也可用1~MS，但是為了方便考慮,把前一種看作為常用的,專業的方式,當然還可用2~ms+1(3種方式在定義了一個大小為ms的數組的情況下都可行可用),因為數組空間是一定的,對其的表示方式當然可以自由地使用不同的方法,一切的一切,只要保證能正確存取到所需的數據為程序所用為準,因為這是數組這種數據結構要最終達到的作用和總則,另外還要保持易用(像0~ms-1就顯得專業並且簡單易用,1~ms就人性化,而2~ms+1就什麼都不是),上圖中的數組示意圖都開了"口",是表示只能從數組的開口的那一端存取數據(數組每個元素都是空間裡包含的內容值,即數據,請搞清"元素","數組每個空間單元","內容值"等的說法),是一種形象的表示方法,而標準的數組圖示方法可如下表示</p><div class=pgc-img><img alt=新手編程導論（七） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3ce280dbe328491f8bc043512295d4d3><p class=pgc-img-caption></p></div><p>5.bmp)哪為什麼要開口呢?一個數組為什麼能開口呢?這是因為前面提到,這個"數組開闢的空間"將作"堆棧空間"使用,也就是"用數組模擬堆棧",因此標準數組示意圖就要經過一些變形以適應能正確表示堆棧(空間)的要求,首先第一點變化就是"開了口",第二個變化就是還加入了一個top指針,這二個變化適應"能正確地表示堆棧(空間)"而生,其實要說top指針,它還不是標準意義上的指針,指針是一個32位的整型,而這裡的top本質還是索引值,而非內存或外存地址單元名稱代號,只是因為它發揮了類似指針"尋址"的作用,因此將其看作為"索引型"的指針,數組"堆棧"相比鏈表"堆棧",數組"堆棧"中的top是索引,而鏈表"堆棧"中的top才是真正的指針,因此數組的索引本質上是一種線性循序查找,而鏈表"堆棧"的top才是指針,分散在內存空間非線性不密集,只能由指針指定查找,這裡就比較了數組與鏈表的本質(數組是內存中一段緊密的空間塊,各個空間單元的連接是線性緊密的,這是對數組的低層討論,反應到數組中就是其中的各個元素,將上一個元素的索引加1就可定向到下一個元素的索引位置,將上一個元素的內存空間地址加一個空間單元長度可定向到下一個元素在內存空間的位置,用0~ms-1或1~ms這樣的遞增性的索引就可表示數組的各個空間並引用它們,存取其中的空間或元素),有高地址和低地址之分,索引由小到大遞增的方向就是內存地址低地到高地的線性遞增方向,而堆棧是內存中各個分散的節點數據,各個節點數據就是元素或者更確切地講,各個節點數據中的內容值,或稱數據值而非指針值,就是鏈表的各個元素,相比起數組的空間單元的"連接",各個鏈表單元空間,也即節點空間的鏈表使用一種指定式的數值指定法而非數組採用的循序式的查找定位法,各個無素之間分散的鏈接由內含在各個元素(節點數據)中的指針字段而非內容字段,數據字段來完成,因此對其每個元素的存取前首先確定元素位置時是不能像數組中循序進行的,而是已被指定的,當前元素的內存位置就在上一個節點數據(元素)的指針字段裡,而鏈表結構裡,顯然就沒有高地與低地這種數組裡才有的特徵.<br>另外,要注意堆棧和隊列中所說,它們都是有序列表,上面講到,4.bmp中各個空間裡的"有序數據塊"才是確切意義上的"有序列表",即堆棧,隊列這二個詞語作為概念所指的實體所在,那麼,它們的有序性是靠什麼來體現的呢?堆棧靠的是遊離於0~ms-1之間的索引值top,那麼堆棧就是指0到top的數據塊,top有一個特殊情況,top也可等於-1,顯然,此時它指向序列為0的空間的更低地址的一個空間,表示堆棧為空(即堆棧中沒有元素再供出棧了,出棧&lt;=>從棧中輸出一個元素&lt;=>從堆棧中釋放一個元素&lt;=>刪除一個元素),前面談到,出口和top的引入都為用一個標準數組變為"堆棧"數組提供了可能,堆棧數據塊是出入有序的,因此稱為有序列表,那麼,堆棧是如何依靠top來實現其空間裡數據塊元素出入的有序性的呢?在堆棧裡,出口是唯一的數據輸入輸出(壓入即輸入push)通道,而隊列有2個數據出入口,準確的說法是一個出口,一個入口,而堆棧的出口和入口集中在數組空間的一端而已,示意圖就是隻能從數組空間的高地址方向端輸入輸出數據(而堆棧有2端前端後端或稱頭端尾端,即front,end與head,rear),從rear端入棧,從f端出棧,堆棧數據實體就是從f到r的數據塊,在數組表示的圖示中f在下,r在上,在鏈表表堆棧中,f在前,r在後(f此時也可稱為頭,r也可稱作後端),在數組表示中,各個數據實體是各個數組空間裡的內容值,而在鏈表表堆棧中,各個數據實體(f到r),堆棧就是各個節點的內容字段鏈接而成的,這些內容字段鏈接起來構成的一串數據值就是堆棧數據塊實體,從f到r,可見f到r不是從低地到高地,也不是從高地到低地,因為鏈表整個空間是分散於內存中的"節點空間"鏈接起來的,各個節點空間是分散佈列在內存中的,因此,各個節點空間的value字段也是分散於內存裡的,鏈表的各個空間間實際上沒有一條一條的鏈,這只是示意圖中的形象表示,鏈表的各個空間的鏈接橋樑就是內含在各個節點空間中的指針字段,鏈表與數組的一個重要區別與優點就是鏈表使用指針而非索引來尋址,這樣就可以通過改變指針的值來重新形成鏈表空間或增刪元素(實際上也是重新形成鏈表空間),這樣鏈表就是一種動態配置的空間,而數組就是一種靜態配置的空間,數組中的每個空間在數組被定義後就存在了,其中的任一個空間都不能被增刪,只能向其賦值內容值0,表示置空此空間單元,這就是靜態配置的空間.<br>.<br><strong>6.26 真正的遞歸</strong><br>遞歸是一種思想，只要問題本身滿足遞歸你才能,遞歸涉及到三個概念，回溯<br>遞歸定義<br>即用遞歸來定義一些離散結構(集合，函數),3.4遞歸算法，用遞歸思想來解決問題的一般化步驟(算法即解決特定問題的一般化步驟，”停機問題”證明不存在解決所有問題的算法)<br>這種關係就如同二叉樹的定義和查找，因為二叉權的定義就是指明它的左右節點存在次序關係，所以可以用這種定義作為思想來對二叉樹進行查找，這並不難理解<br>用對象本身來定義對象就是遞歸，，這是遞歸的描述性定義，，是不確定的，，，非形式的，<br>集合的定義和算法的定義只有在形式語言裡面才有形式定義,,(特別是圖靈機證明不存在所有問題的一般化算法時用到的集合和算法的概念)<br>遞歸是用自身來定義自身這種說法成立嗎，先來看一個問題<br></p><div class=pgc-img><img alt=新手編程導論（七） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d693ec0417d6463ca90e44456d57c9e8><p class=pgc-img-caption></p></div><p><br>你能描述以上一副畫嗎？？（如果它的中心是無限循環的）<br>你可以這樣描述，，，一副畫的中心區域的內容是它自身(也是一副畫，而且具有跟前面描述的一樣的性質)，這樣一副畫就是如上的畫的定義<br>顯然遞歸的說法在這個例子是成立的<br>序列函數的定義比較容易理解,,集合的遞歸定義常常用來產生一些合式公式<br>迭代與遞歸在不同的情況下各有其優勢<br>兔子和斐波那契數<br>例4 免子和斐波那契數 考慮如下問題,一對剛出生的免子(一公一母)被放到島上，每對兔子出生後兩個月後才開始繁殖後代，如下表所示，在出生兩個月後，每對兔子在每個月都將繁殖一對新的兔子，假定兔子不會死去，找出n個月後關於島上兔子對數的遞推關係。<br></p><div class=pgc-img><img alt=新手編程導論（七） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04677665aa8d4d4497784fd310c4ffbe><p class=pgc-img-caption></p></div><p><br>如何理解該月新生兔子即為距該月二個月前的兔子總對數?如6月新生的兔子為4月總兔數,4月新生的兔子為2月總兔數，3月新生兔數即為1月總兔數？<br>對某個月的討論要追到與它的前二個月的情況(題目意思如此:每對兔子出生後二月才開始生育),這裡是某個月的新生兔子與它二月前兔子總數“相等”的情況(注意這是一種遞推說法,在任意差為二的月份間都存在這種聯繫,比如3-1,4-2,5-3,6-4，而6-2則不能考慮,因為它超出了遞推為2階的階數2),從第三個月開始，放上島的第一對兔子A+A-生下了一對兔子B+B-(假設每生下來的一對兔子都是一對公母可生育),在B+B-被生育下來的這個三月份，B+B-並不生育，這對A+A-在第四個月繼續生育C+C-,而B+B-在第四個月也不生育，第五個月A+A-繼續生育，B+B-終於開始生育出一對兔子D+D-,,<br>上面描述的可以作為典型,因為從第三個月開始，它就滿足“每對兔子出生後二個月才開始繁殖後代”“任意出生在a月份的兔子在二個月後的b月後才生育,b-a=2”的題目要求,作為典型的3-1,5-3的情況被提出，後來處理任意相差二個月的兔子情況都可參照以上的描述了.<br>這樣問題便被縮小到相鄰二個月之間的情況，，<br>(為什麼這是對的呢，作為典型的3-1,5-3為什麼可代表一切相鄰二月的情況,上面說了,這是題目意思告訴我們的,而不是遞推，n個月後的兔子跟n-1總數與n-2總數才是遞推,,這個遞推也是在假設不知道存在這個遞推的情況下列出的一個式子，列出之後才發現它是一個線性組合的遞歸,列出這個式子之間設了an,這並不表明事先就知道an一定是個滿足某種遞推的通項,只是在列出式子之後才明白是一個遞推,而列出式子的過程僅僅依賴於題目意思)<br>既然已經得知,5月兔子與3月兔子間存在聯繫，那麼這種聯繫是什麼呢？重要的是知道這個聯繫本身,這個聯繫可用於任意相鄰二月之間(題目意思)<br>從以上3-1,5-3的描述中容易看出,<br><br>漢諾塔問題：<br></p><div class=pgc-img><img alt=新手編程導論（七） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/38dcc370eff34c1dbf206911746452bb><p class=pgc-img-caption></p></div><p><br>圖1 初始狀態<br></p><div class=pgc-img><img alt=新手編程導論（七） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d162a38fde4045e1a17cc63d54becdec><p class=pgc-img-caption></p></div><p><br>圖2 柱1 n-1個盤移到柱3後的情形<br>我們的目標是計數移動步數，，，並不是如題目所說得出移動的具體方法和每個書面步驟<br>因為等我們得出步數這個結論後，就會發現如果具體去得出移動步驟會多傻<br>而且，尊照規則(一次只能移動一塊盤子，最後全部原樣移動到柱2而不是柱3,並且最重要的大在下小在上)把n個盤子成功轉移,移動的方法也可以千千萬萬,,所以我們要求的移動步數是最少的移動步數,那麼對這個問題(求出最少移動步數)該如何建模呢?<br>首先，我們設想這樣一個步驟:第一步,把柱1的n-1個盤子移到柱3,保持小在上大在下的順序(如圖2所示),保留最下面一個底盤，第二步，把底盤移到柱2，第三步，再把從柱1移過來的n-1個盤按步驟1的方法和順序移動柱2,至此完成(注意方法和順序的說法，方法:步驟1是怎麼樣移盤的這次也怎麼移,順序:保持小在上大在下)<br>容易看出，使用更小的步數是不可能求解這個難題的<br>下面具體建模<br>按照上面設想的所產生最少移動步數的移法,首先，設Sn是把n個盤子從一根柱子移動到另一根柱子的需要的總步數,(問題是什麼我們就設什麼,,雖然我們並不知道這其實是一個為了滿足遞推關係的設法,雖然我們也不知道有了以上設法,再用遞推關係就可以很好地解此題,因為從形式來看Sn像一個序列的通項,它指明Sn就是把n個盤子從柱1到柱3所需要的Step,S2就是2個,S10就是10所需要的Step,這個設法假定Sn與n之間存在序列關係),按照步驟1，移動次數可用Sn-1來表示,步驟2可用1來表示，步驟3亦為Sn-1,故有<br>Sn=2Sn-1+1 (Sn為把n盤從柱1移到柱3所需步數或直接就是)<br>注意Sn為什麼不直接說是“設Sn是把n盤從柱1移到柱2所需步數”呢,這樣說當然沒有錯，不過為了嚴緊性和通用性考慮還是這樣設(本題當然是從柱1移到柱3,如果沒有規定其實移到柱2作為中轉也可,最後求移動到柱3上的步數同樣滿足Sn=2Sn-1+1,,況且還有很多同類的題目，移奶酪到盤子裡什麼的,所以為了通用性考慮還是如上設)<br>最後的問題：我們用迭代方法來求解這個遞推關係</p><p><strong>5.2 求解遞推關係</strong>有一類重要的遞推關係可以用一種系統的方法明確地求解,,在這種遞推關係中（好像我們見過的都是這樣的），序列的項由它前面的線性組合來表示<br>請注意,遞歸，遞推，迭代在措詞上的區別<br>遞歸是用自身定義自身的,或過程調用自身，用在序列通項表示上，，形如，an= an-1,用在過程體內，這僅僅是一種思想，而不能說是一種算法，，顯然這種思想是成立的,,,遞推關係和迭代是用了遞歸思想的2個概念而已,是用到了遞歸思想的所有東西的集合中的二個元素,<br>要對它們三者定性的話，遞歸是一種思想，遞推只是一種說法，迭代是一種算法(常用來求解滿足遞推關係問題)<br>遞推是一個序列的某個通項可由它的前幾項組合推導而來的關係，，強調的是通項和推出它的前幾項之間的關係滿足這個“遞歸推導而出”說法,因此它一定用到了遞歸的思想,滿足遞歸<br>序列中,遞推是發生在某個項和它的相領項之間的關係，，但是指定了初始項和這個遞推關係，可以得出所有的項，即通項,,實際上“某個項”的定義一旦被提出，它就表示了通項的意義,,因此序列所有項=由通項關係得出每個項後,這些項的組合=初始項+滿足遞推的相領的某幾項<br>（我們設這裡是二項,而不是前幾項）所以，所謂遞歸只是二個項之間的關係，，但是由於這二個項可以是任意項,,因此，遞歸是所有項中任意二相領項的關係,可用來求解整個序列每一項,求此也求解所有項<br>定義X:一切序列可以用到遞推要求它滿足遞歸,這永遠是前提(實際上並不是所有的序列都滿足遞推和遞歸)<br>迭代是用迭次代換，(常用來求解一個“線性組合”型遞推關係的方法,也可求解不滿足線性組合的一些遞推關係)把一個項逐次展開，，用到一個迭代器i，比如求解an,必須使i從第n項到第k項逐次遞減，(k通常情況下是1,即第一項),,迭代也只在幾個相鄰項之間進行，因為它也借用了遞歸和遞推思想而已,這一切都是因為用到迭代的序列(或其它問題)也要由定義x而來,,不再贅述<br>.<br><strong>6.27 樹與單鏈表，圖</strong>除了單鏈表之外還有高級鏈表,包括雙鏈表和循環鏈表,但是它們的基礎依然是單鏈表,對單鏈表的討論可運用於高級鏈表,也即無論單,高級鏈表,本質都是一樣的數據結構,都是鏈表,即鏈表的本質是節點的單向或雙向串連,注意"串連",這是所有鏈表區別於樹這種數據結構的所在,因為樹是一種節點的"分支"鏈接,(樹是較線性表,圖更為複雜的數據結構,它的任何二個結點間都可以發生聯繫)它們的共同點就是:這些節點都是分散於內存中的節點,由上一個節點(鏈表)或父的一方節點(樹)的指段字段指向,樹和鏈表的示意圖中,圓形就代表節點,包含數據字段和指向下一個節點的指針字段,這是對鏈表來說的,而對於樹來說(這裡說的是二叉樹)圓形節點就包含數據字段和指向其左右節點的指針字段,或稱左右子樹,因為這些左右子樹是以這個節點為根的子樹,注意左右是有順序性的,不能顛倒,用Left,Right區別.無論是鏈表還是樹示意圖中的直線都是指針,有方向的,不是互逆的,這處互逆性決定了對單鏈表的"首->尾"遍歷和對二叉樹的"二叉查找"遍歷方式(中序,左右序)的單向性,可見樹與鏈表的實體數據都存在節點中,這是節點的主體存儲空間,鏈表,樹作為數據結構用於組織程序中要用到的數據,它們的節點單元的Data字段發揮的是主體存儲作用,而它們節點的指針字段是輔助性且必要的,用於樹,鏈表的查找,遍歷,插入,刪除等操作,嚴格來說,圖並非一種數據結構,書中對圖的討論只能稱為對"與線長,面積大小"無關的點線面的拓樸討論,而由點邊組成的圖形中居然沒有一個點或邊發揮數據存儲作用,而這是一種數據結構首要完成的任務.<br>3.數組,鏈表為什麼能仿真堆棧?<br>其實這個問題被提出來一點都不可笑,對這個問題的討論很有意義,它能讓我們明白一些細微而重要的東西.<br>數組,鏈表,堆棧,隊列,是四大數據結構,在關係是並列的,為什麼又有"用數組和鏈表仿真堆 棧"之說呢,其實數組,鏈表是較高級的複雜的數據結構,還記得本書序言中的一句話嗎?數據結構是人類在長期的編程過程中總結歸納出來的一套科學有序的方法,數組是,鏈表是,堆棧和隊列也是,但是在人類總結歸納這些數據結構並形成術語進而形成數據結構這門計算機科學時,永遠是從簡單低級的數組和鏈表開始的,對它的討論和總結歸納先於堆棧,隊列之前進行,當人們總結出數組和鏈表數據結構時,並得出對數組和鏈表的刪除,複製,插入等操作後,形成了數組鏈表等數據結構概念及其操作的一整套理論後,人們進一步探索數據結構,發現了堆棧的存在,而堆棧又是基於數組,鏈表的高一級的數據結構,對堆棧,隊列的研究與討論經歷了與對數組鏈表相同的過程,對數組和鏈表的研究和技術總結業已成型的情況下,就應該採用現在的知識來描述新出現的知識,因此有以上的說法.<br><strong>6.28 樹</strong>樹是一種數據結構,稱為樹狀結構,簡稱樹,樹的本質是一個或多個節點的有限集合,樹只有一個節點的情況是例外的特殊的情況但也是允許的樹的形式,而一般情況下,樹都有不止一個的節點,有限集合這四個字指明:一棵樹,無論它由多少個節點構成,這些節點的數量都是有限的,可以計數的,也即,從來沒有一棵樹,它的節點個數為無限不確定的.<br>在一棵樹的所有節點中,它們的地位是不一樣的,每棵樹必定有一個特定的節點,稱為根節點(root),根節點與這棵樹的其它節點構成了這棵樹(當然這些節點並不是單獨地存在無聯繫的,不然就無法從這些節點中搞出一個為根的地位節點,這些就構不成一棵樹),可見,"根"是相對於"樹"來說的,根這個概念是樹一級的概念,只要有樹,便會有根,根的本質是一棵樹的"特定節點"(第一個節點,其它節點由它分支而來),而樹又是一種特定的數據結構,請記住,根是依附在樹概念上的概念,脫離了樹便無所謂根概念,總之,根是與樹直接掛鉤的一對概念,為什麼我要在這裡這麼花心思地說明根是相對於樹的概念呢?因為這是理解7.1節中關於樹的其它概念的一個基本點,掌握了它,你便不會在理解這些概念中迷失.<br>說完了根,再來說其它節點,其它節點(實際上這裡說的其它節點準確的意義不是說除了根節點外的一棵樹的其它所有節點,而是說根節點的下一級節點,可以有0個,可以有n個,0個就是沒有下一級節點,而n的大小便決定了這棵樹的分類性質,如果n=2,便是二叉樹,後面會談到)是根的子節點.(8.bmp)<br>從樹結構的圖示來看,樹與現實中的樹雖然類似,但是,數據結構中的樹是一棵倒樹,根是相對於樹的概念與樹直接掛鉤,而子節點的概念直接與根節點的概念掛鉤,而與樹不掛鉤,根節點與子節點的概念僅僅存在於一個節點與該節點下一級節點之間,與樹不掛鉤,這就像主程序與子程序的概念,主程序與子程序永遠是相對的概念,如果前面說的子程序它又有它的下一級程序,那麼主程序與子程序有主子關係之外,還可以說前面談到的子程序與該子程序調用的子程序也有主子關係,此時這裡的子程序是主程序而子程序調用的子程序就是子程序,這2種說法都是可行的,因為主子關係是相對的可變的而非絕對的,主子這種說法存在於只要滿足一方是調用者而另一方是被調用者之間,而非絕對不變的,再接著上圖講,那麼B,C,D,M就是A的子節點,而不能說B,C,D,M是樹T的子節點,沒有這種說法,樹只有根和子樹,葉節點與其掛鉤,而只能說(因為B作為根節點其下還有P,Q2個子節點)B,C是樹T的子樹(D,M不是),這裡,B,C,D,M作為A的子節點,同時B,C又是樹T的子樹,子樹B(以它的根節點為名稱故根節點就是B)的根節點B又有自己的子節點,T的樹C的根節點C又有自己的子節點R,若一棵樹中的任意一級(根)節點最多有n個子節點,則稱這樣的樹為n元樹,二叉樹的得名也來源於此.<br>12.樹的本質是什麼?<br>樹是一種數據結構,所以樹的本質是一種組織內存空間的方法,就像數組是靜態配置內存空間的方法,且數組配置出來的空間不但是靜態的,而且是緊密相連排列的線性的各個"小空間",是一塊內存中的塊狀數據靜態的存儲區,由它的一個小空間的地址可以推導出下一個小空間在內存中的地址,而鏈表是一種動態的配置內存的方法,程序中,數組空間在數組被定義出來時就被開闢,在它的生命期內從此不能更改大小,而鏈表被定義出來時還要用內存開闢函數malloc()來實際分配內存,所以它開闢出來的空間是動態的,而且這些空間單元不是線性緊密排列的而是分散的,分散於內存中的各個"節點"空間,是不可通過索引下標循序查找定位的,只能通過內含於各個節點數據內的指針字段來"指定查找",形象示意如下</p><div class=pgc-img><img alt=新手編程導論（七） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e6b09eb51b9f4df7b1d029edf29e301e><p class=pgc-img-caption></p></div><p>1.bmp)那麼樹呢?樹的本質是"節點的非空有限集合",跟鏈表有一定的相似性,首先,鏈表與樹(基礎樹,書中所講為二叉樹,這屬於簡單樹而非廣度意義上的樹,但是對二叉樹的討論可以延用擴展為整個樹的範疇)都是動態內存配置的方式,鏈表空間間連接依賴於各個節點數據的指針字段,而樹的節點空間連接的方法為"格式上的約定",樹的節點空間和鏈表的節點空間都是這二種數據結構實際存儲實體數據的存儲場所,是怎麼樣一種"格式上的約定"呢?以二叉樹為例(其實樹各個空間之間沒有什麼鏈接,鏈表各空間發生關係的紐帶與橋樑是指針字段,而樹的各個節點空間間發生關係的鈕帶與橋樑為"格式上的約定","約定俗成的方法來格定"),二叉樹的每一個節點空間實際各各分散佈列於內存中,它們發生聯繫的手段就在於各個節點的性質,前面談到,樹是節點的非空有限集,如根就是樹的第一個節點空間,如果是二叉樹,這個節點自然會跟其下一階的二個子節點發生關係,這就是父子節點關係,當然不止根與其下一階節點,在其它節點間也存在父子關係,除此之外還有兄弟關係,樹->子樹關係這種"關係機制"是遠遠不同於鏈表依賴指針表示各節點空間聯繫的手段的,所以這是一種"節點關係"上的"約定",是一種全新的組織節點空間的手段和方法,而沒有用到指針,當然可以用指針來模擬和仿真,這就涉及到"用鏈表來表示二叉樹"的知識點,這是後來的內容.<br>13.圖的本質是什麼?<br>要說圖是一種數據結構實在很難理解,因為我第一次碰到圖的概念,根本就沒有發現圖形結構中的哪部分用於存儲數據,378頁對圖形的定義"在圖形G中包含了2個集合,一個是由頂點所構成的有限非空集,另一個是由邊所構成的有限非空集,可用G(V,E)表示",按照這個定義,圖形就是頂點和邊的有限集合(至少要有一頂點一邊),暈死,那麼實體數據存在哪?頂點中?不是,邊的描述值權嗎?好像也不是,署假我只看了這本書17天,所以對圖我沒太多深入研究.<br><strong>6.29 真正的散列表</strong>一般抽象到了某個程度，為了獲得計算機作為底層的馮氏能力，，就不應該再抽象下去了。<br>開發模型不需要再變了，數據抽象到數據結構級就是頂級了再抽象就不是開發問題了()<br>Hash表就是hashed list,,,它是邏輯上的list（所以也有hash map,hash set等）,但按hash方式存儲地址作為存儲，Hash是一種利於搜索的啟發過程，一般的搜索是對搜索空間uniform的，而hash function是對搜索空間的目標問題建立的一種啟發機制的函數。<br>Hash的最重要的意思不是提供一個映射函數，那反而是hash解決的第二個問題，即地址問題，，它最重要的意義，即第一個解決的問題是基於統計的本質。進行的對搜索空間的一種抽象（即hashtable而不是hashfunction問題，比如元素會出現一次，還是二次，這樣抽象對操作元素有好處，但顯然此時並不出現hasing function的意思），<br>一般設計散列時，說的都是設計散列表，然後處理衝突處理，，，如何散列所用的函數是附帶問題。<br>也即其實hash table的第一層意思是table,,即形成數據結構才是他的第一層意義,,,而不是如何hash,,,並提供一套hash 機制,,,<br>它著手於"在解空間和目標數據空間建立一套具有inform關係"的數據結構,,,這才是它的第一層意思,即名字中的table一詞<br>至於如何hash並解決衝突,,那反而是它解決的第二個問題..即名字中的hash一詞<br>只有理解了這點之後,你才會明白hash table是如何來的,以及為什麼存在,,與其它數據結構作比較時所呈現的那些不一樣的特點(比如為什麼要進行hash,,為什麼要處理衝突,而其它的數據結構則不需要這樣的分析過程).<br><strong>6.30 算法設計方法</strong>攤還分析不僅是解釋數據結構性能的工具，而且也是設計時要考慮的因素。就跟NP完全一樣（遜於圖靈不可計算機的停機問題）。如果複雜度超過了10的確良8次方這個計算機的數量級就沒有意義了。<br>存在很多類型的問題，比如最優化問題，，找點問題，理解諸如貪婪算法的前提是理解這些問題在先，比如最優化問題可以很好地解釋什麼是貪婪設計。<br>迭代是方程求根的一種方法，並且它也體現了一種算法設計方法。<br>遞歸體現了分治的算法設計思想，但它提出的子問題一定要跟原問題接口一致。。 遞歸的終結條件是不需要遞歸也可直接求解的條件，，因此是終止條件，，當以從下到上的眼光來看時，它是超始條件（直到問題規模n）<br>其實並不是只有所有明顯遞歸性質的問題才可以用遞歸來解答，而是隻有能把原問題分解為子問題並能製造一個接口的情況下就可以利用遞歸來求解它。<br>遞歸是從上而下，所以有時要求用輔助棧來保存中間結果，而遞推只有一個函數，並不發生欠套的函數調用，並沒有出入棧的時空開銷。複雜的遞歸結構轉化成遞推時，需要回SU處理，二個概念僅一字之差，一個歸，是向下，一個推是向上，<br>關鍵字相當於字典中的單詞，，而數據項相當於這個詞的詞義，造句，等全部的詞條信息，這樣說你一定不會明白，說實話我第一次看到這樣的說話也沒能明白。。<br>實際上就是說，我們要查的是關於某個詞的詞條義，音等，，但我們是通過某個單詞找到該單詞的詞條義，音的。。在字典中單詞和其音義是一同被存入字典的，都是(某記錄的)數據項，但單詞是作為鍵的數據項。.</p><div class=pgc-img><img alt=新手編程導論（七） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7a021d0f4210458bb1d50363c8579340><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編程</a></li><li><a>導論</a></li><li><a>新手</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/45de4a01.html alt=新手編程導論(十) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f9ae9dd10f344864b55d78ae3b54dec5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45de4a01.html title=新手編程導論(十)>新手編程導論(十)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8df37fda.html alt=新手編程導論（九） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0bf11efddc9d41d1908a368d1c11824c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8df37fda.html title=新手編程導論（九）>新手編程導論（九）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html alt=「編程基礎」PHP基礎教程（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17685aad04c54d02928724fb99fea026 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html title=「編程基礎」PHP基礎教程（二）>「編程基礎」PHP基礎教程（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html alt=「編程基礎」PHP基礎教程（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/355d0f0c0f274bdfaeb90747dbd918fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html title=「編程基礎」PHP基礎教程（一）>「編程基礎」PHP基礎教程（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html alt=零基礎如何學PHP編程語言？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html title=零基礎如何學PHP編程語言？>零基礎如何學PHP編程語言？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html alt=遊戲引擎編程需要哪些基本數學知識？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f6ca97249fa468db6982c44a024979d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html title=遊戲引擎編程需要哪些基本數學知識？>遊戲引擎編程需要哪些基本數學知識？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html alt=UG編程獨當一面，如何提高鑽孔精度方法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532093430052c29be7656f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html title=UG編程獨當一面，如何提高鑽孔精度方法？>UG編程獨當一面，如何提高鑽孔精度方法？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html alt=Java高級編程基礎：如何理解進程、線程與併發編程的關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/426d60ae-7dd7-4ab4-90bd-4dfeb286a68b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html title=Java高級編程基礎：如何理解進程、線程與併發編程的關係>Java高級編程基礎：如何理解進程、線程與併發編程的關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html alt=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3058ca03-deee-4287-a38c-9163687a0673 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html title=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上>C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html alt=java流式編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/92118583492140e3b610df69c711fd87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html title=java流式編程思想>java流式編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html alt=盤點那些爭議最大的編程觀點，看看你有什麼見解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/501956d4daa845caa468124f22bb35f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html title=盤點那些爭議最大的編程觀點，看看你有什麼見解>盤點那些爭議最大的編程觀點，看看你有什麼見解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>