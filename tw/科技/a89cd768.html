<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>秋招進行時：十個Android面試技術乾貨寶典 | 极客快訊</title><meta property="og:title" content="秋招進行時：十個Android面試技術乾貨寶典 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/513f81ac-d4e2-47bf-8c42-f67682e03725"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a89cd768.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a89cd768.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a89cd768.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a89cd768.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a89cd768.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a89cd768.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a89cd768.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a89cd768.html><meta property="article:published_time" content="2020-10-29T21:08:51+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:51+08:00"><meta name=Keywords content><meta name=description content="秋招進行時：十個Android面試技術乾貨寶典"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a89cd768.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>秋招進行時：十個Android面試技術乾貨寶典</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/513f81ac-d4e2-47bf-8c42-f67682e03725><p class=pgc-img-caption></p></div><h1><strong>Android中的四大組件以及應用場景</strong></h1><ol><li>Activity：在Android應用中負責與用戶交互的組件。</li><li>Service：常用於為其他組件提供後臺服務或者監控其他組件的運行狀態。經常用來執行一些耗時操作。</li><li>BroadcastReceiver：用於監聽應用程序中的其他組件。</li><li>ContentProvider：Android應用程序之間實現實時數據交換。</li></ol><h1><strong>1、Activity的生命週期</strong></h1><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/51eee27f1c7942a088752022f6ede99f><p class=pgc-img-caption></p></div><p><strong>生命週期</strong>：對象什麼時候生，什麼時候死，怎麼寫代碼，代碼往那裡寫。</p><p><strong>注意</strong>：</p><ol><li>當打開新的Activity，採用透明主題的時候，當前Activity不會回調onStop</li><li>onCreate和onDestroy配對，onStart和onStop配對（是否可見），onResume和onPause配對（是否在前臺，可以與用戶交互）</li><li>打開新的Activity的時候，相關的Log為：</li></ol><pre>Main1Activity: onPause Main2Activity: onCreate Main2Activity: onStart Main2Activity: onResume MainA1ctivity: onStop</pre><p><strong>異常狀態下的生命週期</strong>：</p><p>資源相關的系統配置發生改變或者資源不足：例如屏幕旋轉，當前Activity會銷燬，並且在onStop之前回調onSaveInstanceState保存數據，在重新創建Activity的時候在onStart之後回調onRestoreInstanceState。其中Bundle數據會傳到onCreate（不一定有數據）和onRestoreInstanceState（一定有數據）。</p><pre>防止屏幕旋轉的時候重建，在清單文件中添加配置： android:configChanges="orientation"</pre><h1><strong>2、Fragment的生命週期</strong></h1><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/537109c8c460475aa10a06433419428d><p class=pgc-img-caption></p></div><p><strong>正常啟動</strong></p><pre> Activity: onCreate Fragment: onAttach Fragment: onCreate Fragment: onCreateView Fragment: onActivityCreated Activity: onStart Activity: onResume</pre><p><strong>正常退出</strong></p><pre> Activity: onPause Activity: onStop Fragment: onDestroyView Fragment: onDestroy Fragment: onDetach Activity: onDestroy</pre><h1><strong>3、Activity的啟動模式</strong></h1><ol><li>standard：每次激活Activity時(startActivity)，都創建Activity實例，並放入任務棧；</li><li>singleTop：如果某個Activity自己激活自己，即任務棧棧頂就是該Activity，則不需要創建，其餘情況都要創建Activity實例；</li><li>singleTask：如果要激活的那個Activity在任務棧中存在該實例，則不需要創建，只需要把此Activity放入棧頂，即把該Activity以上的Activity實例都pop，並調用其onNewIntent；</li><li>singleInstance：應用1的任務棧中創建了MainActivity實例，如果應用2也要激活MainActivity，則不需要創建，兩應用共享該Activity實例。</li></ol><h1><strong>4、Activity與Fragment之間的傳值</strong></h1><ol><li>通過findFragmentByTag或者getActivity獲得對方的引用（強轉）之後，再相互調用對方的public方法，但是這樣做一是引入了“強轉”的醜陋代碼，另外兩個類之間各自持有對方的強引用，耦合較大，容易造成內存洩漏。</li><li>通過Bundle的方法進行傳值，例如以下代碼：</li></ol><pre> //Activity中對fragment設置一些參數 fragment.setArguments(bundle); //fragment中通過getArguments獲得Activity中的方法 Bundle arguments = getArguments();</pre><ol><li>利用eventbus進行通信，這種方法實時性高，而且Activity與Fragment之間可以完全解耦。</li></ol><pre> //Activity中的代碼 EventBus.getDefault().post("消息"); //Fragment中的代碼 EventBus.getDefault().register(this); @Subscribe public void test(String text) { tv_test.setText(text); }</pre><h1><strong>5、Service</strong></h1><p>Service分為兩種：</p><ol><li>本地服務，屬於同一個應用程序，通過startService來啟動或者通過bindService來綁定並且獲取代理對象。如果只是想開個服務在後臺運行的話，直接startService即可，如果需要相互之間進行傳值或者操作的話，就應該通過bindService。</li><li>遠程服務（不同應用程序之間），通過bindService來綁定並且獲取代理對象。</li></ol><p>對應的生命週期如下：</p><pre> context.startService() -&gt;onCreate()- &gt;onStartCommand()-&gt;Service running--調用context.stopService() -&gt;onDestroy() context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running--調用&gt;onUnbind() -&gt; onDestroy() </pre><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2198ece284e249289b2b181a451d1812><p class=pgc-img-caption></p></div><p><strong>注意</strong></p><p>Service默認是運行在main線程的，因此Service中如果需要執行耗時操作（大文件的操作，數據庫的拷貝，網絡請求，文件下載等）的話應該在子線程中完成。</p><p>特殊情況是！：Service在清單文件中指定了在其他進程中運行。</p><h1><strong>6、Android中的消息傳遞機制</strong></h1><p><strong>為什麼要使用Handler？</strong></p><p>因為屏幕的刷新頻率是60Hz，大概16毫秒會刷新一次，所以為了保證UI的流暢性，耗時操作需要在子線程中處理，子線程不能直接對UI進行更新操作。因此需要Handler在子線程發消息給主線程來更新UI。</p><p>這裡再深入一點，Android中的UI控件不是線程安全的，因此在多線程併發訪問UI的時候會導致UI控件處於不可預期的狀態。Google不通過鎖的機制來處理這個問題是因為：</p><ol><li>引入鎖會導致UI的操作變得複雜</li><li>引入鎖會導致UI的運行效率降低</li></ol><p>因此，Google的工程師最後是通過單線程的模型來操作UI，開發者只需要通過Handler在不同線程之間切花就可以了。</p><p><strong>概述一下Android中的消息機制？</strong></p><p>Android中的消息機制主要是指Handler的運行機制。Handler是進行線程切換的關鍵，在主線程和子線程之間切換隻是一種比較特殊的使用情景而已。其中消息傳遞機制需要了解的東西有Message、Handler、Looper、Looper裡面的MessageQueue對象。</p><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0348ceb9235d4f59b0b654a66a0e836a><p class=pgc-img-caption></p></div><p>如上圖所示，我們可以把整個消息機制看作是一條流水線。其中：</p><ol><li>MessageQueue是傳送帶，負責Message隊列的傳送與管理</li><li>Looper是流水線的發動機，不斷地把消息從消息隊列裡面取出來，交給Handler來處理</li><li>Message是每一件產品</li><li>Handler就是工人。但是這麼比喻不太恰當，因為發送以及最終處理Message的都是Handler</li></ol><h1><strong>為什麼在子線程中創建Handler會拋異常？</strong></h1><p>Handler的工作是依賴於Looper的，而Looper（與消息隊列）又是屬於某一個線程（ThreadLocal是線程內部的數據存儲類，通過它可以在指定線程中存儲數據，其他線程則無法獲取到），其他線程不能訪問。因此Handler就是間接跟線程是綁定在一起了。因此要使用Handler必須要保證Handler所創建的線程中有Looper對象並且啟動循環。因為子線程中默認是沒有Looper的，所以會報錯。</p><p>正確的使用方法是：</p><pre> handler = null; new Thread(new Runnable() { private Looper mLooper; @Override public void run() { //必須調用Looper的prepare方法為當前線程創建一個Looper對象，然後啟動循環 //prepare方法中實質是給ThreadLocal對象創建了一個Looper對象 //如果當前線程已經創建過Looper對象了，那麼會報錯 Looper.prepare(); handler = new Handler(); //獲取Looper對象 mLooper = Looper.myLooper(); //啟動消息循環 Looper.loop(); //在適當的時候退出Looper的消息循環，防止內存洩漏 mLooper.quit(); } }).start();</pre><p>主線程中默認是創建了Looper並且啟動了消息的循環的，因此不會報錯：</p><p>應用程序的入口是ActivityThread的main方法，在這個方法裡面會創建Looper，並且執行Looper的loop方法來啟動消息的循環，使得應用程序一直運行。</p><p><strong>子線程中可以通過Handler發送消息給主線程嗎？</strong></p><p>可以。有時候出於業務需要，主線程可以向子線程發送消息。子線程的Handler必須按照上述方法創建，並且關聯Looper。</p><h1><strong>7、事件傳遞機制以及自定義View相關</strong></h1><p><strong>Android的視圖樹</strong></p><p>Android中View的機制主要是Activity的顯示，每個Activity都有一個Window（具體在手機中的實現類是PhoneWindow），Window以下有DecorView，DecorView下面有TitleVie以及ContentView，而ContentView就是我們在Activity中通過setContentView指定的。</p><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f4b7b07ae2054ac8ac5bfe9d271cc43e><p class=pgc-img-caption></p></div><p><strong>事件傳分發機制</strong></p><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/df222dc0cab341f89f00926e7fbca437><p class=pgc-img-caption></p></div><p>ViewGroup有以下三個與事件分發的方法，而View只有dispatchTouchEvent和onTouchEvent。</p><pre> @Override public boolean dispatchTouchEvent(MotionEvent ev) { return super.dispatchTouchEvent(ev); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { return super.onInterceptTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent event) { return super.onTouchEvent(event); }</pre><p>事件總是從上往下進行分發，即先到達Activity，再到達ViewGroup，再到達子View，如果沒有任何視圖消耗事件的話，事件會順著路徑往回傳遞。其中：</p><ol><li>dispatchTouchEvent是事件的分發方法，如果事件能夠到達該視圖的話，就首先一定會調用，一般我們不會去修改這個方法。</li><li>onInterceptTouchEvent是事件分發的核心方法，表示ViewGroup是否攔截事件，如果返回true表示攔截，在這之後ViewGroup的onTouchEvent會被調用，事件就不會往下傳遞。</li><li>onTouchEvent是最低級的，在事件分發中最後被調用。</li><li>子View可以通過requestDisallowInterceptTouchEvent方法去請求父元素不要攔截。</li></ol><p><strong>注意</strong></p><ol><li>事件從Activity.dispatchTouchEvent()開始傳遞，只要沒有被停止或攔截，從最上層的View(ViewGroup)開始一直往下(子View)傳遞。子View 可以通過onTouchEvent()對事件進行處理。</li><li>事件由父View(ViewGroup)傳遞給子View，ViewGroup 可以通過onInterceptTouchEvent()對事件做攔截，停止其往下傳遞。</li><li>如果事件從上往下傳遞過程中一直沒有被停止，且最底層子View 沒有消費事件，事件會反向往上傳遞，這時父View(ViewGroup)可以進行消費，如果還是沒有被消費的話，最後會到Activity 的onTouchEvent()函數。</li><li>如果View 沒有對ACTION_DOWN 進行消費，之後的其他事件不會傳遞過來。</li><li>OnTouchListener 優先於onTouchEvent()對事件進行消費。</li></ol><p><strong>自定義View的分類</strong></p><ol><li>對現有的View的子類進行擴展，例如複寫onDraw方法、擴展新功能等。</li><li>自定義組合控件，把常用一些控件組合起來以方便使用。</li><li>直接繼承View實現View的完全定製，需要完成View的測量以及繪製。</li><li>自定義ViewGroup，需要複寫onLayout完成子View位置的確定等工作。</li></ol><p><strong>View的測量-onMeasure</strong></p><p>View的測量最終是在onMeasure方法中通過setMeasuredDimension把代表寬高兩個MeasureSpec設置給View，因此需要掌握MeasureSpec。MeasureSpec包括大小信息以及模式信息。</p><p>MeasureSpec的三種模式：</p><ol><li>EXACTLY模式：精確模式，對應於用戶指定為match_parent或者具體大小的時候（實際上指定為match_parent實質上是指定大小為父容器的大小）</li><li>AT_MOST模式：對應於用戶指定為wrap_content，此時控件尺寸只要不超過父控件允許的最大尺寸即可。</li><li>UNSPECIFIED模式：不指定大小的測量模式，這種模式比較少用</li></ol><p>下面給出模板代碼：</p><pre> public class MeasureUtils { /** * 用於View的測量 * * @param measureSpec * @param defaultSize * @return */ public static int measureView(int measureSpec, int defaultSize) { int measureSize; //獲取用戶指定的大小以及模式 int mode = View.MeasureSpec.getMode(measureSpec); int size = View.MeasureSpec.getSize(measureSpec); //根據模式去返回大小 if (mode == View.MeasureSpec.EXACTLY) { //精確模式（指定大小以及match_parent）直接返回指定的大小 measureSize = size; } else { //UNSPECIFIED模式、AT_MOST模式（wrap_content）的話需要提供默認的大小 measureSize = defaultSize; if (mode == View.MeasureSpec.AT_MOST) { //AT_MOST（wrap_content）模式下，需要取測量值與默認值的最小值 measureSize = Math.min(measureSize, defaultSize); } } return measureSize; } }</pre><p>最後，複寫onMeasure方法，把super方法去掉：</p><pre> @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(MeasureUtils.measureView(widthMeasureSpec, 200), MeasureUtils.measureView(heightMeasureSpec, 200) ); }</pre><p><strong>View的繪製-onDraw</strong></p><p>View繪製，需要掌握Android中View的座標體系：</p><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c777f448d81a4f449a8b09bb3afa4438><p class=pgc-img-caption></p></div><p>View的座標體系是以左上角為座標原點，向右為X軸正方向，向下為Y軸正方向。</p><p>View繪製，主要是通過Android的2D繪圖機制來完成，時機是onDraw方法中，其中包括畫布Canvas，畫筆Paint。下面給出示例代碼。相關API不是介紹的重點，重點是Canvas的save和restore方法，通過save以後可以對畫布進行一些放大縮小旋轉傾斜等操作，這兩個方法一般配套使用，其中save的調用次數可以多於restore。</p><pre> @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); Bitmap bitmap = ImageUtils.drawable2Bitmap(mDrawable); canvas.drawBitmap(bitmap, getLeft(), getTop(), mPaint); canvas.save(); //注意，這裡的旋轉是指畫布的旋轉 canvas.rotate(90); mPaint.setColor(Color.parseColor("#FF4081")); mPaint.setTextSize(30); canvas.drawText("測試", 100, -100, mPaint); canvas.restore(); }</pre><p><strong>View的位置-onLayout</strong></p><p>與佈局位置相關的是onLayout方法的複寫，一般我們自定義View的時候，只需要完成測量，繪製即可。如果是自定義ViewGroup的話，需要做的就是在onLayout中測量自身以及控制子控件的佈局位置，onLayout是自定義ViewGroup必須實現的方法。</p><h1><strong>8、性能優化</strong></h1><p><strong>佈局優化</strong></p><ol><li>使用include標籤，通過layout屬性複用相同的佈局。</li></ol><pre> &lt;include android:id="@+id/v_test" layout="@layout/include_view" /&gt;</pre><ol><li>使用merge標籤，去除同類的視圖</li><li>使用ViewStub來進行佈局的延遲加載一些不是馬上就用到的佈局。例如列表頁中，列表在沒有拿到數據之前不加載，這樣做可以使UI變得流暢。</li></ol><pre> &lt;ViewStub android:id="@+id/v_stub" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout="@layout/view_stub" /&gt; //需要手動調用inflate方法，佈局才會顯示出來。 stub.inflate(); //其中setVisibility在底層也是會調用inflate方法 //stub.setVisibility(View.VISIBLE); //之後，如果要使用ViewStub標籤裡面的View，只需要按照平常來即可。 TextView tv_1 = (TextView) findViewById(R.id.tv_1);</pre><ol><li>儘量多使用RelativeLayout，因為這樣可以大大減少視圖的層級。</li></ol><p><strong>內存優化</strong></p><p>APP設計以及代碼編寫階段都應該考慮內存優化：</p><ol><li>珍惜Service，儘量使得Service在使用的時候才處於運行狀態。儘量使用IntentService</li><li>IntentService在內部其實是通過線程以及Handler實現的，當有新的Intent到來的時候，會創建線程並且處理這個Intent，處理完畢以後就自動銷燬自身。因此使用IntentService能夠節省系統資源。</li><li>內存緊張的時候釋放資源（例如UI隱藏的時候釋放資源等）。複寫Activity的回調方法。</li></ol><pre> @Override public void onLowMemory() { super.onLowMemory(); } @Override public void onTrimMemory(int level) { super.onTrimMemory(level); switch (level) { case TRIM_MEMORY_COMPLETE: //... break; case 其他: } }</pre><ol><li>通過Manifest中對Application配置更大的內存，但是一般不推薦</li></ol><pre> android:largeHeap="true"</pre><ol><li>避免Bitmap的浪費，應該儘量去適配屏幕設備。儘量使用成熟的圖片加載框架，Picasso，Fresco，Glide等。</li><li>使用優化的容器，SparseArray等</li><li>其他建議：儘量少用枚舉變量，儘量少用抽象，儘量少增加類，避免使用依賴注入框架，謹慎使用library，使用代碼混淆，時當場合考慮使用多進程等。</li><li>避免內存洩漏（本來應該被回收的對象沒有被回收）。一旦APP的內存短時間內快速增長或者GC非常頻繁的時候，就應該考慮是否是內存洩漏導致的。</li></ol><pre>分析方法 1\. 使用Android Studio提供的Android Monitors中Memory工具查看內存的使用以及沒使用的情況。2\. 使用DDMS提供的Heap工具查看內存使用情況，也可以手動觸發GC。3\. 使用性能分析的依賴庫，例如Square的LeakCanary，這個庫會在內存洩漏的前後通過Notification通知你。</pre><p><strong>什麼情況會導致內存洩漏</strong></p><ol><li>資源釋放問題：程序代碼的問題，長期保持某些資源，如Context、Cursor、IO 流的引用，資源得不到釋放造成內存洩露。</li><li>對象內存過大問題：保存了多個耗用內存過大的對象（如Bitmap、XML 文件），造成內存超出限制。</li><li>static 關鍵字的使用問題：static 是Java 中的一個關鍵字，當用它來修飾成員變量時，那麼該變量就屬於該類，而不是該類的實例。所以用static 修飾的變量，它的生命週期是很長的，如果用它來引用一些資源耗費過多的實例（Context 的情況最多），這時就要謹慎對待了。</li></ol><pre>解決方案 1\. 應該儘量避免static 成員變量引用資源耗費過多的實例，比如Context。 2\. Context 儘量使用ApplicationContext，因為Application 的Context 的生命週期比較長，引用它不會出現內存洩露的問題。 3\. 使用WeakReference 代替強引用。比如可以使用WeakReference&lt;Context&gt; mContextRef</pre><ol><li>線程導致內存溢出：線程產生內存洩露的主要原因在於線程生命週期的不可控。例如Activity中的Thread在run了，但是Activity由於某種原因重新創建了，但是Thread仍然會運行，因為run方法不結束的話Thread是不會銷燬的。</li></ol><pre>解決方案 1\. 將線程的內部類，改為靜態內部類（因為非靜態內部類擁有外部類對象的強引用，而靜態類則不擁有）。 2\. 在線程內部採用弱引用保存Context 引用。</pre><p><strong>查看內存洩漏的方法、工具</strong></p><ol><li>android官方提供的工具：Memory Monitor（當APP佔用的內存在短時間內快速增長或者GC變得頻繁的時候）、DDMS提供的Heap工具（手動觸發GC）</li><li>Square提供的內存洩漏檢測工具，LeakCanary（能夠自動完成內存追蹤、檢測、輸出結果），進行演示，並且適當的解說。</li></ol><p><strong>性能優化</strong></p><ol><li>防止過度繪製，通過打開手機的“顯示過度繪製區域”即可查看過度繪製的情況。</li><li>最小化渲染時間，使用視圖樹查看節點，對節點進行性能分析。</li><li>通過TraceView進行數據的採集以及分析。在有大概定位的時候，使用Android官方提供的Debug類進行採集。最後通過DDMS即可打開這個.trace文件，分析函數的調用情況（包括在指定情況下執行時間，調用次數）</li></ol><pre> //開啟數據採集 Debug.startMethodTracing("test.trace"); //關閉 Debug.stopMethodTracing();</pre><p><strong>OOM</strong></p><p>避免OOM的一些常見方法：</p><ol><li>App資源中儘量少用大圖。使用Bitmap的時候要注意等比例縮小圖片，並且注意Bitmap的回收。</li></ol><pre> BitmapFactory.Options options = new BitmapFactory.Option(); options.inSampleSize = 2; //Options 只保存圖片尺寸大小，不保存圖片到內存 BitmapFactory.Options opts = new BitmapFactory.Options(); opts.inSampleSize = 2; Bitmap bmp = null; bmp = BitmapFactory.decodeResource(getResources(), mImageIds[position],opts); //回收 bmp.recycle();</pre><ol><li>結合組件的生命週期，釋放資源</li><li>IO流，數據庫查詢的遊標等應該在使用完之後及時關閉。</li><li>ListView中應該使用ViewHolder模式緩存ConverView</li><li>頁面切換的時候儘量去傳遞（複用）一些對象</li></ol><p><strong>ANR</strong></p><p>不同的組件發生ANR 的時間不一樣，主線程（Activity、Service）是5 秒，BroadCastReceiver 是10 秒。</p><p>ANR一般有三種類型：</p><ol><li>KeyDispatchTimeout(5 seconds)</li><li>主要類型按鍵或觸摸事件在特定時間內無響應</li><li>BroadcastTimeout(10 seconds)</li><li>BroadcastReceiver在特定時間內無法處理完成</li><li>ServiceTimeout(20 seconds)</li><li>小概率類型Service在特定的時間內無法處理完成</li></ol><pre>解決方案： 1\. UI線程只進行UI相關的操作。所有耗時操作，比如訪問網絡，Socket 通信，查詢大量SQL 語句，複雜邏輯計算等都放在子線程中去，然後通過handler.sendMessage、runonUITread、AsyncTask 等方式更新UI。 2\. 無論如何都要確保用戶界面操作的流暢度。如果耗時操作需要讓用戶等待，那麼可以在界面上顯示進度條。 3\. BroadCastReceiver要進行復雜操作的的時候，可以在onReceive()方法中啟動一個Service來處理。</pre><p><strong>9、九切圖（.9圖）、SVG圖片</strong></p><p><strong>九切圖</strong></p><p>點九圖，是Android開發中用到的一種特殊格式的圖片，文件名以”.9.png“結尾。這種圖片能告訴程序，圖像哪一部分可以被拉昇，哪一部分不能被拉昇需要保持原有比列。運用點九圖可以保證圖片在不模糊變形的前提下做到自適應。點九圖常用於對話框背景圖片中。</p><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c2ab6bbe5b964470aa108ae94c5c40d2><p class=pgc-img-caption></p></div><ol><li>1、2部分規定了圖像的可拉伸部分,當實際程序中設定了對話框的寬高時，1、2部分就會被拉伸成所需要的高和寬，呈現出於設計稿一樣的視覺效果。</li><li>而3、4部分規定了圖像的內容區域。內容區域規定了可編輯區域，例如文字需要被包裹在其內。</li></ol><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/003f0ab8a790455db537c6e1f7b52fd7><p class=pgc-img-caption></p></div><p><strong>android5.0的SCG矢量動畫機制</strong></p><ol><li>圖像在方法縮小的時候圖片質量不會有損失</li><li>使用XML來定義圖形</li><li>適配不同分辨率</li></ol><h1><strong>10、Android中數據常見存儲方式</strong></h1><ol><li>文件（包括XML、SharePreference等）</li><li>數據庫</li><li>Content Provider</li><li>保存在網絡</li></ol><h1><strong>11、進程間通信</strong></h1><p><strong>操作系統進程間通信的方法，android中有哪些？</strong></p><p><strong>操作系統：</strong></p><ol><li>Windows：剪貼板、管道、郵槽等</li><li>Linux：命名管道、共享內存、信號量</li></ol><p><strong>Android中的進程通信方式並不是完全繼承於Linux：</strong></p><ol><li>Bundle</li><li>文件共享</li><li>AIDL</li><li>Messenger</li><li>Content Provider</li><li>Socket</li></ol><h1><strong>12、常見的網絡框架</strong></h1><p><strong>常用的http框架以及他們的特點</strong></p><ol><li>HttpURLConnection:在Android 2.2版本之前，HttpClient擁有較少的bug，因此使用它是最好的選擇。而在Android 2.3版本及以後，HttpURLConnection則是最佳的選擇。它的API簡單，體積較小，因而非常適用於Android項目。壓縮和緩存機制可以有效地減少網絡訪問的流量，在提升速度和省電方面也起到了較大的作用。對於新的應用程序應該更加偏向於使用HttpURLConnection，因為在以後的工作當中我們也會將更多的時間放在優化HttpURLConnection上面。特點：比較輕便，靈活，易於擴展，在3.0後以及4.0中都進行了改善，如對HTTPS的支持，在4.0中，還增加了對緩存的支持。</li><li>HttpClient：高效穩定，但是維護成本高昂，故android 開發團隊不願意在維護該庫而是轉投更為輕便的</li><li>okHttp：okhttp 是一個 Java 的 HTTP+SPDY 客戶端開發包，同時也支持 Android。需要Android 2.3以上。特點：OKHttp是Android版Http客戶端。非常高效，支持SPDY、連接池、GZIP和 HTTP 緩存。默認情況下，OKHttp會自動處理常見的網絡問題，像二次連接、SSL的握手問題。如果你的應用程序中集成了OKHttp，Retrofit默認會使用OKHttp處理其他網絡層請求。從Android4.4開始HttpURLConnection的底層實現採用的是okHttp。</li><li>volley：早期使用HttpClient，後來使用HttpURLConnection，是谷歌2013年推出的網絡請求框架，非常適合去進行數據量不大，但通信頻繁的網絡操作，而對於大數據量的網絡操作，比如說下載文件等，Volley的表現就會非常糟糕。</li><li>xutils：緩存網絡請求數據</li><li>Retrofit：和Volley框架的請求方式很相似，底層網絡請求採用okhttp（效率高，android4.4底層採用okhttp），採用註解方式來指定請求方式和url地址，減少了代碼量。</li><li>AsyncTask</li></ol><h1><strong>13、常用的圖片加載框架以及特點、源碼</strong></h1><ol><li>Picasso：PicassoSquare的網絡庫一起能發揮最大作用，因為Picasso可以選擇將網絡請求的緩存部分交給了okhttp實現。</li><li>Glide：模仿了Picasso的API，而且在他的基礎上加了很多的擴展(比如gif等支持)，支持圖片流，因此在做愛拍之類的視頻應用用得比較多一些。</li><li>Fresco：Fresco中設計有一個叫做image pipeline的模塊。它負責從網絡，從本地文件系統，本地資源加載圖片。 為了最大限度節省空間和CPU時間，它含有3級緩存設計（2級內存，1級文件）。Fresco中設計有一個叫做Drawees模塊， 方便地顯示loading圖，當圖片不再顯示在屏幕上時，及時地釋放內存和空間佔用。</li></ol><p>Fresco是把圖片緩存放在了Ashmem（系統匿名內存共享區）</p><ol><li>Heap-堆內存：Android中每個App的 Java堆內存大小都是被嚴格的限制的。每個對象都是使用Java的new在堆內存實例化，這是內存中相對安全的一塊區域。內存有垃圾回收機制，所以當 App不在使用內存的時候，系統就會自動把這塊內存回收。不幸的是，內存進行垃圾回收的過程正是問題所在。當內存進行垃圾回收時，內存不僅僅進行了垃圾回收，還把 Android 應用完全終止了。這也是用戶在使用 App 時最常見的卡頓或短暫假死的原因之一。</li><li>Ashmem：Android 在操作 Ashmem 堆時，會把該堆中存有數據的內存區域從 Ashmem 堆中抽取出來，而不是把它釋放掉，這是一種弱內存釋放模式；被抽取出來的這部分內存只有當系統真正需要更多的內存時（系統內存不夠用）才會被釋放。當 Android 把被抽取出來的這部分內存放回 Ashmem 堆，只要被抽取的內存空間沒有被釋放，之前的數據就會恢復到相應的位置。</li></ol><p>不管發生什麼，垃圾回收器都不會自動回收這些 Bitmap。當 Android 繪製系統在渲染這些圖片，Android 的系統庫就會把這些 Bitmap 從 Ashmem 堆中抽取出來，而當渲染結束後，這些 Bitmap 又會被放回到原來的位置。如果一個被抽取的圖片需要再繪製一次，系統僅僅需要把它再解碼一次，這個操作非常迅速。</p><h1><strong>14、在Android開發裡用什麼做線程間的通訊工具？</strong></h1><p>傳統點的方法就是往同步代碼塊裡些數據，然後使用回調讓另外一條線程去讀。在Android裡我一般會創建Looper線程，然後Hanlder傳遞消息。</p><h1>15、Android新特性相關</h1><ol><li>5.0：Material Design、多種設備的支持、支持64位ART虛擬機、Project Volta電池續航改進計劃等</li><li>6.0：動態權限管理、過度動畫、支付、指紋等</li><li>7.0：分屏、通知消息快捷回覆、夜間模式、流量保護模式等</li></ol><h1><strong>16、網絡請求優化</strong></h1><p><strong>網絡請求優化</strong></p><ol><li>能夠緩存起來的儘量去緩存起來，減輕服務器的壓力。例如APP中首頁的一些數據，又例如首頁的圖標、文案都是緩存起來的，而且這些數據通過網絡來指定可以使app具有更大的靈活性。</li><li>不用域名，用 IP 直連，省去了DNS域名解析。</li><li>連接複用、請求合併、請求數據Body可以利用壓縮算法Gzip來進行壓縮，使用JSON 代替 XML</li></ol><p><strong>網絡請求的安全性</strong></p><p>這塊瞭解的不多。我給你說說我的思路吧，利用哈希算法，比如MD5，服務器給我們的數據可以通過時間戳和其他參數做個加密，得到一個key，在客戶端取出數據後根據數據和時間戳再去生成key與服務端給的做個對比。</p><p><strong>17、新技術相關</strong></p><p>RXJava：一個異步請求庫，核心就是異步。利用的是一種擴展的觀察模式，被觀察者發生某種變化的時候，可以通過事件（onNext、onError、onComplete）等方式通過觀察者。RXJava同時支持線程的調度和切換，用戶可以指定訂閱發生的線程以及觀察者觸發的線程。</p><p>Retrofit：通過註解的方式來指定URL、請求方法，實質上底層是通過OKHttp來實現的。</p><h1>文末</h1><p>好了，今天的分享就到這裡，如果你對在面試中遇到的問題，或者剛畢業及工作幾年迷茫不知道該如何準備面試並突破現狀提升自己，對於自己的未來還不夠了解不知道給如何規劃，可以加一下合作的技術群：185873940。來看看同行們都是如何突破現狀，怎麼學習的，來吸收他們的面試以及工作經驗完善自己的之後的面試計劃及職業規劃。</p><blockquote><p>這裡放上一部分我工作以來以及參與過的大大小小的面試收集總結出來的一套<strong>進階學習的視頻及面試專題資料包</strong>，在這裡免費分享給大家，主要還是希望大家在如今大環境不好的情況下面試能夠順利一點，希望可以幫助到大家~</p></blockquote><p>需要的讀者可以<strong>關注</strong>，<strong>私信</strong>我免費【<strong>面試</strong>】獲取</p><div class=pgc-img><img alt=秋招進行時：十個Android面試技術乾貨寶典 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/84b4aa1ea6844e918ca52e978afd2910><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>秋招</a></li><li><a>進行</a></li><li><a>十個</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/72139afe.html alt=怎樣對臍橙樹進行扭枝（彎枝）促花？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fe6ea8ad111f421c9673e3f61072fa1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72139afe.html title=怎樣對臍橙樹進行扭枝（彎枝）促花？>怎樣對臍橙樹進行扭枝（彎枝）促花？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0c52137.html alt=作文裡面怎麼進行場面描寫？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/230976bf-ee1d-44c0-8ce9-4a4714b8ad40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0c52137.html title=作文裡面怎麼進行場面描寫？>作文裡面怎麼進行場面描寫？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cc683c38.html alt=怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7559326b0b254462970a98290ef15e9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cc683c38.html title=怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分>怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/862b0119.html alt=庭院景觀進行分類，分析其設計手法及景觀元素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0b2a23998d02489a9f65c5ac190e0ab1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/862b0119.html title=庭院景觀進行分類，分析其設計手法及景觀元素>庭院景觀進行分類，分析其設計手法及景觀元素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9aacad8d.html alt=四子王旗著陸場進行夜間返回器回收演練 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SGCsDGZChiSE1J style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9aacad8d.html title=四子王旗著陸場進行夜間返回器回收演練>四子王旗著陸場進行夜間返回器回收演練</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/252400c5.html alt=工程造價控制超實用的十個技巧，收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a57073220b94ca2ae5d0117430666c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/252400c5.html title=工程造價控制超實用的十個技巧，收藏>工程造價控制超實用的十個技巧，收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1051ab4.html alt=稅務機關是如何進行稅務檢查的？小白必看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/5910228d-1631-4921-8a4e-08a892a227ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1051ab4.html title=稅務機關是如何進行稅務檢查的？小白必看>稅務機關是如何進行稅務檢查的？小白必看</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b24cd416.html alt="有勒索軟件冒充解密工具對用戶文件進行二次加密 真是壞透了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2b5b02227754787880b9798bc0d8451 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b24cd416.html title="有勒索軟件冒充解密工具對用戶文件進行二次加密 真是壞透了">有勒索軟件冒充解密工具對用戶文件進行二次加密 真是壞透了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d30af34.html alt=脈動進行年輕化品牌升級，起用吳亦凡為品牌全球代言人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RxWrYnBCPI4mSB style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d30af34.html title=脈動進行年輕化品牌升級，起用吳亦凡為品牌全球代言人>脈動進行年輕化品牌升級，起用吳亦凡為品牌全球代言人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb05cafa.html alt=項目經理不可告人的十個祕密 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aeaed449d9d8407db7e34f77d264646b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb05cafa.html title=項目經理不可告人的十個祕密>項目經理不可告人的十個祕密</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d160830e.html alt="基於 Oracle 的系統識別方法來進行 Control-CPS 軟件缺陷定位" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7f751bafd94a4c9a933109a7b3f275eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d160830e.html title="基於 Oracle 的系統識別方法來進行 Control-CPS 軟件缺陷定位">基於 Oracle 的系統識別方法來進行 Control-CPS 軟件缺陷定位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/839128d9.html alt=如何利用MES系統進行生產防錯？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1a9be6af1166482e9570cecda0f01f8c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/839128d9.html title=如何利用MES系統進行生產防錯？>如何利用MES系統進行生產防錯？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3cbc9ea.html alt=進行百年的瀝青滴落實驗，如此大費干戈，究竟是為了證明什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9729abe48f9c47919432f44bf48e02e2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3cbc9ea.html title=進行百年的瀝青滴落實驗，如此大費干戈，究竟是為了證明什麼？>進行百年的瀝青滴落實驗，如此大費干戈，究竟是為了證明什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9c9b225.html alt=9座市管隨路橋樑今起進行“體檢” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9c9b225.html title=9座市管隨路橋樑今起進行“體檢”>9座市管隨路橋樑今起進行“體檢”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f8212b0.html alt=中交怒江連心橋進行荷載試驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c5de27c9149c45b29e1fb42cc5f16f9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f8212b0.html title=中交怒江連心橋進行荷載試驗>中交怒江連心橋進行荷載試驗</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>