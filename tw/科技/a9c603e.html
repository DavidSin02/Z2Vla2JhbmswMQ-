<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++面向對象繼承與多態 | 极客快訊</title><meta property="og:title" content="C++面向對象繼承與多態 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1829e61ab5e647368f12ef5846074713"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a9c603e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a9c603e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a9c603e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a9c603e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a9c603e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a9c603e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a9c603e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a9c603e.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="C++面向對象繼承與多態"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/a9c603e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++面向對象繼承與多態</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">前言</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這一篇開始正式展開講多態，以及我們為什麼要使用多態。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">多態</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">什麼是多態</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">引用百度百科的定義：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">多態（Polymorphism）按字面的意思就是“多種狀態”。在面嚮對象語言中，接口的多種不同的實現方式即為多態。引用Charlie Calverts對多態的描述——多態性是允許你將父對象設置成為一個或更多的他的子對象相等的技術，賦值之後，父對象就可以根據當前賦值給它的子對象的特性以不同的方式運作（摘自“Delphi4 編程技術內幕”）。簡單的說，就是一句話：允許將子類類型的指針賦值給父類類型的指針。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我的理解是：子類可以通過父類的指針或者引用，調用子類重寫父類的虛函數，以達到一個類型多種狀態的效果。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這聽起來好像沒有什麼，我可以直接通過子類的對象調用成員函數不就行了，為啥還要捨近求遠將其賦值到一個父類指針再調用呢？起初學習的時候我也不懂為什麼，直到後來我遇到了一個很典型的例子才恍然大悟，這個例子我會在下面講到。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">多態的條件</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">前面也零零散散地介紹了C++多態的條件，這裡總結一下：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">需要有繼承</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">需要使用父類的指針或引用</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">父類需要有虛函數，子類要重寫父類的虛函數</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">需要上轉型是Java多態的條件，C++主要是通過使用父類的指針或者引用來實現的，也可以認為是一種上轉型吧。正是因為使用了父類的指針或者引用，才使得他能夠調用子類的虛函數，而不是像上一篇的上轉型導致的靜態綁定，最終調用的是父類的虛函數。我們通過以下代碼來回顧一下：</span></p><pre><code>class base {public:    virtual void do_something() //有虛函數 {        cout &lt;&lt; "I'm base class" &lt;&lt; endl;    }};class derived : public base            //有繼承{public:    void do_something() //子類重寫了父類的虛函數 {        cout &lt;&lt; "I'm derived class" &lt;&lt; endl;    }};void fun1(base &amp;b) //父類的引用 {    b.do_something();}void fun2(base *b) //父類的指針 {    b-&gt;do_something();}void fun3(base b) {    b.do_something();}int main() {    derived d;    fun1(d);    //I'm derived class    fun2(&amp;d);    //I'm derived class    fun3(d);    //I'm base class    return 0;}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">fun1()和fun2()實現的過程都是動態綁定的，即運行時才動態確定要調用哪個函數。那他究竟是怎麼實現的？</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">動態綁定的原理</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">大家還記得虛類的對象是有一個vptr，多個同類對象的vptr指向同一個vtable。動態綁定就是通過這個vptr間接尋址來實現的。雖然子類對象被賦值到了父類的指針，但是對象的vptr是沒有改變的，他指向的還是子類的vtable。 所以父類指針去調用某個虛函數的時候，就會去vtable裡面找函數入口，那找到的自然是子類的函數入口。所以他不是在編譯期間就確定的，而是在代碼運行到那一行的時候才找到的函數入口。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">那為什麼只有指針或者引用才能達到這個效果呢？《深度探索C++對象模型》這本書對此有這樣一個解釋：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">一個pointer或一個reference之所以支持多態，是因為它們並不引發內存任何與類型有關的內存委託操作。會受到改變的，只有它們所指向內存的大小和解釋方式而已。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這樣讀起來有點拗口，簡單講就是指針或者引用的賦值並不會改變原對象內存裡的內容，他只會改變對內存大小及內容的解釋方式。舉個簡單的例子：我將int變量的地址賦值給了char型指針，char型指針才不管原來的變量是什麼，他對外只解釋一個字節的內容。</span></p><div class=pgc-img><img alt=C++面向對象繼承與多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1829e61ab5e647368f12ef5846074713><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">同理可知，子類對象的內存內容並沒有發生改變，那麼對象的vptr還是指向子類的vtable，所以調用的還是子類的的成員函數。而簡單的上轉型並不會有這樣的效果，他會對內存進行重新分配。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">另外說一下，只用C++有靜態綁定這個概念，其他面向對象類的語言都是動態綁定。可以看出C語言的知識是很細緻入微的。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">為什麼要使用多態</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">到此其實多態已經講完了，鋪墊了這麼多前置知識，其實多態就這麼一點點。我主要還是想講講為什麼要使用多態，只有知道了為什麼，才能使我們在設計代碼的時候考慮得到如何運用這個知識點。我們用一個遊戲的例子來說明為什麼。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">遊戲的描述如下：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">遊戲有一個英雄角色，角色屬性有生命（hp）和攻擊力（ack）</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">英雄可以對怪物進行攻擊，同時也會受到怪物的攻擊</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">怪物屬性有生命（hp）和攻擊力（ack）</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">怪物可以對英雄進行攻擊，也會受到英雄的攻擊</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">現階段有三種怪物：狼人，殭屍，女巫</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我們先來實現怪物類：</span></p><pre><code>class wolf //狼人類 {public:    wolf(int hp, int ack)    : hp(hp)    , ack(ack)    {}    bool damage(int dm) {        if (this-&gt;hp &lt;= 0) return false;        this-&gt;hp -= dm;        return false;    }    bool attack(hero &amp;hr) {        return hr.damage(this-&gt;ack);    }private:    int hp;    int ack;};class zombie {public:    zombie(int hp, int ack)    : hp(hp)    , ack(ack)    {}    bool damage(int dm) {        if (this-&gt;hp &lt;= 0) return false;        this-&gt;hp -= dm;        return false;    }    bool attack(hero &amp;hr) {        return hr.damage(this-&gt;ack);    }private:    int hp;    int ack;};class witch {public:    witch(int hp, int ack)    : hp(hp)    , ack(ack)    {}    bool damage(int dm) {        if (this-&gt;hp &lt;= 0) return false;        this-&gt;hp -= dm;        return false;    }    bool attack(hero &amp;hr) {        return hr.damage(this-&gt;ack);    }private:    int hp;    int ack;};</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">然後我們來實現英雄類：</span></p><pre><code>class hero {public:    hero(int hp, int ack)    : hp(hp)    , ack(ack)    {}    bool damage(int dm) {        if (this-&gt;hp &lt;= 0) return false;        this-&gt;hp -= dm;    }    bool attack(wolf &amp;wf) {        return wf.damage(this-&gt;ack);    }    bool attack(zombie &amp;zb) {        return zb.damage(this-&gt;ack);    }    bool attack(witch &amp;wt) {        return wt.damage(this-&gt;ack);    }private:    int hp;    int ack;};</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我們發現，同樣邏輯的attack()函數，我們需要實現三次。如果後期遊戲要增添新的怪物，我們還得繼續寫attack()函數。 這其實還是一種面向過程的思想，並不是說寫幾個類出來就是面向對象了。而且這也完全不符合我們程序猿的編程習慣，我們程序猿不喜歡重複的東西。欸，這個時候多態就能發揮他的作用了。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我們來定義怪物們的基類：</span></p><pre><code>class monster {public:    virtual bool damage(int dm) = 0;    virtual bool attack(hero &amp;hr) = 0;};</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">之前說了，我們並不關心這個基類的虛函數具體是怎麼實現的，那麼我們就可以將其聲明為純虛類。然後讓怪物都繼承這個基類，實現上面這兩個函數就可以了。這樣我們就可以將hero類改造成這樣：</span></p><pre><code>class hero {public:    hero(int hp, int ack)    : hp(hp)    , ack(ack)    {}    bool damage(int dm) {        if (this-&gt;hp &lt;= 0) return false;        this-&gt;hp -= dm;    }    bool attack(monster &amp;ms) //參數修改為monster類一定要用指針或者引用 {        return ms.damage(this-&gt;ack);    }private:    int hp;    int ack;};</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這樣代碼是不是就簡潔很多。而且根據多態的性質，不同的怪物會調用其各自的damage()函數。以後要是新增怪物，只要繼承和實現虛基類就好了，hero類並不需要進行修改。這就體現了面向對象編程的優勢了，這還只是其中之一。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">同理，要是有多種英雄，我們同樣可以抽象出一個英雄類的虛基類，然後派生出各式各樣的英雄，怪物類也不需要重複寫多個attack()函數。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有同學還是覺得怪物類的實現還是重複度太高了，這沒有體現多態的優勢啊。其實不然，前面說到每個子類都應該重寫基類的虛函數，是因為不同的子類都應該有他的特別之處， 所以才叫派生嘛。如果子類和子類，或者子類和基類完全一樣那就沒有必要繼承與派生了。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">這裡重複度高只是因為代碼量小，我只是舉了個小小的例子，其實在真正的遊戲中不同怪物</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">子類</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">的attack()函數和damage()函數的內部細節應該是不一樣。比如不同的怪物有不同的攻擊特效，有不同的受擊效果，有不同的技能冷卻時間等等。這些細節都是通過子類去重寫基類的虛函數，才得以體現的。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">總結</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">到此為止，我所瞭解的繼承與多態算是總結完畢了。會簡單地封裝幾個類並不是面向對象編程，只有徹底理解了封裝、繼承與多態，面向對象編程才算是入了個門。只有理解了這些，我們才能開始學習設計模式，才能領悟到設計模式的精髓所在。學設計模式建議大家去看《大話設計模式》這本書，以後有時間我也會在我的博客裡總結一些設計模式。</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>C++</a></li><li><a>對象</a></li><li><a>繼承</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9faee81.html alt=C++面向對象編程-000-面向對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/53cb20cd97dc48329b5dedb5db019f0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9faee81.html title=C++面向對象編程-000-面向對象>C++面向對象編程-000-面向對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html alt=C++面向對象設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c001c4074d3f4c658dfea942671f0ea6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html title=C++面向對象設計>C++面向對象設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/864c3f59.html alt=C++面向對象程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b42379075324d628f329f2d6e793e4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/864c3f59.html title=C++面向對象程序設計>C++面向對象程序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3636ac.html alt=C++面向對象開發的四大特性：封裝、抽象、繼承、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3e3474f5-6297-4c89-bf9d-36a32a33bf7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3636ac.html title=C++面向對象開發的四大特性：封裝、抽象、繼承、多態>C++面向對象開發的四大特性：封裝、抽象、繼承、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fde3f58.html alt=C++｜面向對象實現鏈表的創建、遍歷，結點的查找、插入、刪除 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/154010356552484b174b862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fde3f58.html title=C++｜面向對象實現鏈表的創建、遍歷，結點的查找、插入、刪除>C++｜面向對象實現鏈表的創建、遍歷，結點的查找、插入、刪除</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html alt=C++哈希表是如何解決衝突的? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ac4410086e640ea82846bde1dd72c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html title=C++哈希表是如何解決衝突的?>C++哈希表是如何解決衝突的?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html alt=CC++語言19｜靜態成員（對象共享數據成員及其成員函數） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html title=CC++語言19｜靜態成員（對象共享數據成員及其成員函數）>CC++語言19｜靜態成員（對象共享數據成員及其成員函數）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f82b787b.html alt=流式編碼體驗：C++智能成員列表拉取 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d058f34e27f64b069d334ca6aa6cb793 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f82b787b.html title=流式編碼體驗：C++智能成員列表拉取>流式編碼體驗：C++智能成員列表拉取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/262136fa.html alt=C++中虛函數的缺省參數值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/9a4a59de-572f-49ae-abab-649a767d05d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/262136fa.html title=C++中虛函數的缺省參數值>C++中虛函數的缺省參數值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95d5c549.html alt=C++實現二叉樹數據結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/feeddb3a-c96d-44b6-8672-b125cf06a33c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95d5c549.html title=C++實現二叉樹數據結構>C++實現二叉樹數據結構</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>