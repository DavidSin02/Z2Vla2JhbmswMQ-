<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java集合Set 集合、List和Collections類 | 极客快訊</title><meta property="og:title" content="Java集合Set 集合、List和Collections類 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e1ec4b6968944a9aba6a970e3792728c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><meta property="article:published_time" content="2020-11-14T21:05:52+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:52+08:00"><meta name=Keywords content><meta name=description content="Java集合Set 集合、List和Collections類"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/aa2e8109.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java集合Set 集合、List和Collections類</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、前言</h1><p>在 Java 集合（一） 中我們已經講了 <strong>Collection 集合接口</strong>、<strong>Iterator 迭代器</strong>和<strong>泛型</strong>，今天我們來講 <strong>Set 集合</strong>、<strong>List 集合</strong> 和 <strong>Collections 工具類</strong>。</p><h1 class=pgc-h-arrow-right>二、Set 集合</h1><p>Set 接口繼承自 Collection 接口，它與 Collection 接口中地方法基本一致，並沒有對 Collection 接口進行功能上的擴展，只是比 Collection 接口更加嚴格了，與 List 集合不同的是，Set 集合不允許存儲重複的元素，而且 Set 集合是沒有索引的。</p><p>Set 集合有多個子類，這裡我們介紹其中的 HashSet 與 LinkedHashSet 這兩個集合。</p><h1 class=pgc-h-arrow-right>2.1、HashSet 集合</h1><p>HashSet 集合實現了 Set 接口，首先 Set 集合有的特點它都有，同時它還有以下特點：</p><ol start=1><li>是一個無序的集合，存儲元素和取出元素的順序有可能不一致。</li><li>底層是一個哈希表結構，查詢的速度非常的快。</li></ol><blockquote><p>HashSet 集合代碼演示如下所示:</p></blockquote><pre><code>public class SetDemo01 {    public static void main(String[] args) {        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        // 使用 add() 方法添加元素        set.add(1);        set.add(3);        set.add(2);        set.add(1);        // 使用迭代器遍歷集合        Iterator&lt;Integer&gt; iterator = set.iterator();        while (iterator.hasNext()) {            System.out.println(iterator.next());        }                // 使用增強 for 循環遍歷        for (Integer integer : set) {            System.out.println(integer);        }    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>2.2、哈希值</h1><p>哈希值是一個十進制的整數，由系統隨機給出，實際上就是對象的地址值，是一個邏輯地址，是模擬出來的地址，不是數據實際存儲的物理地址。在 Object 類有一個方法 hashCode()，可以獲取對象的哈希值。</p><p>hashCode() 方法源碼如下：（native 代表該方法調用的是本地操作系統的方法）</p><pre><code>public native int hashCode();複製代碼</code></pre><p>toString() 的源碼如下：</p><pre><code>public String toString() {    return getClass().getName() + "@" + Integer.toHexString(hashCode());}複製代碼</code></pre><p>可以看出 toString() 也調用了 hashCode() 並將其轉化為十六進制。</p><blockquote><p>哈希值代碼演示如下所示:</p></blockquote><pre><code>public class Person extends Object {    public static void main(String[] args) {        Person p1 = new Person();        int h1 = p1.hashCode();        System.out.println(h1); // 1163157884        Person p2 = new Person();        int h2 = p2.hashCode();        System.out.println(h2); // 1956725890        /**         * toString() 的源碼         * public String toString() {         *         return getClass().getName() + "@" + Integer.toHexString(hashCode());         *     }         */        System.out.println(p1); // com.zjgsu.Set.Person@4554617c        System.out.println(p2); // com.zjgsu.Set.Person@74a14482        /**         * String 類的哈希值         * String 類重寫了 hashCode() 所以下面兩個哈希值是一樣的         */        String s1 = new String("abc");        String s2 = new String("abc");        System.out.println(s1.hashCode());        System.out.println(s2.hashCode());    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>2.3、哈希表</h1><p>在 <strong>JDK1.8 之前哈希表 =數組 + 鏈表</strong>，但是在<strong>JDK1.8之後</strong>，<strong>哈希表 = 數組 + 鏈表 + 紅黑樹</strong>（提高查詢效率）。具體如下圖所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections類" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e1ec4b6968944a9aba6a970e3792728c><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>2.4、Set 集合存儲元素不重複的原理</h1><p>我們先來執行以下下面的代碼：</p><pre><code>public class SetDemo02 {    public static void main(String[] args) {        HashSet&lt;String&gt; set = new HashSet&lt;String&gt; ();        String s1 = new String("abc");        String s2 = new String("abc");        set.add(s1);        set.add(s2);        set.add("重地");        set.add("通話");        set.add("abc");        System.out.println(set); // [重地, 通話, abc]    }}複製代碼</code></pre><p>打印結果如下所示：（可以看到 "abc" 只有一個）</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections類" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/366b3dd8b26943a0b2a5c49411f04424><p class=pgc-img-caption></p></div><p><br></p><p>我們根據代碼來分析一下：</p><ol start=1><li>HashSet set = new HashSet ()：現在我們已經知道hashSet 底層是一個哈希表，所以這句代碼會創建一個哈希表。</li><li>set.add(s1)：add() 方法會調用 s1 的 hashCode() 方法。計算字符串 “abc” 的哈希值，哈希值是 <strong>96354</strong>，在集合中找有沒有 <strong>96354</strong> 這個哈希值的元素，發現<strong>沒有</strong>，<strong>就把 s1 存儲到集合中</strong>。</li><li>set.add(s2)：add() 方法會調用 s2 的 hashCode() 方法。計算字符串 “abc” 的哈希值，哈希值是 <strong>96354</strong>，在集合中找有沒有 <strong>96354</strong> 這個哈希值的元素，發現<strong>有（哈希衝突）</strong>，s2 會調用 equals() 方法和哈希值相同的元素進行比較，<strong>s2.equals(s1) 返回 true</strong>，兩個元素相同，就不會把 s2 存儲到集合中。</li><li>set.add("重地");：add() 方法會調用 <strong>"重地"</strong> 的 hashCode() 方法。計算字符串 “重地” 的哈希值，哈希值是 <strong>1179395</strong>，在集合中找有沒有 <strong>1179395</strong> 這個哈希值的元素，發現 <strong>沒有</strong>，<strong>就把"重地"存儲到集合中</strong>。</li><li>set.add("通話");：add() 方法會調用 <strong>"通話"</strong> 的 hashCode() 方法。計算字符串 “通話” 的哈希值，哈希值是 <strong>1179395</strong>，在集合中找有沒有 <strong>1179395</strong> 這個哈希值的元素，發現<strong>有（哈希衝突）</strong>，"通話" 會調用 equals() 方法和哈希值相同的元素進行比較，<strong>"通話".equals("重地") 返回 false</strong>，兩個元素不同，就把"通話"存儲到集合中。</li></ol><p>最後哈希表中的元素如下所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections類" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24bb9e3dc0144ffca6f276ac624a5262><p class=pgc-img-caption></p></div><p><br></p><p>通過上述步驟的分析，已經很明瞭的說明了 Set 集合元素不重複的原理，前提就是存儲的元素必須重寫 hashCode() 方法 和 equals() 方法。</p><h1 class=pgc-h-arrow-right>2.5、HashSet 集合存儲自定義類型元素</h1><p>給 HashSet 中存放自定義類型元素時，需要重寫對象中的hashCode() 方法和 equals() 方法，建立自己的比較方式，才能保證 HashSet 集合中的對象唯一。我們來看個例子，如下所示：</p><pre><code>public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return "Student{" +                "name='" + name + '\'' +                ", age=" + age +                '}';    }    public static void main(String[] args) {        HashSet&lt;Student&gt; set = new HashSet&lt;&gt;();        Student s1 = new Student("張三", 18);        Student s2 = new Student("張三", 18);        Student s3 = new Student("張三", 30);        System.out.println(s1.hashCode());        System.out.println(s2.hashCode());        System.out.println(s3.hashCode());        set.add(s1);        set.add(s2);        set.add(s3);        System.out.println(set);    }}複製代碼</code></pre><p>打印結果如下所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections類" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cdcfe5c32a043bbaad7dd42b42d7956><p class=pgc-img-caption></p></div><p><br></p><p>可以看到，如果沒有重寫 hashCode() 方法 和 equals() 方法，那麼三個人是都會打印出來的，因為這時候他們的哈希值是不同的。</p><hr><p>給 Student 類重寫 hashCode() 方法和 equals() 方法，具體如下所示：</p><pre><code>@Overridepublic int hashCode() {    return Objects.hash(name, age);}@Overridepublic boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Student student = (Student) o;    return age == student.age &amp;&amp;            Objects.equals(name, student.name);}複製代碼</code></pre><p>打印結果如下所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections類" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c4fd9d2da4d74f568bbc9f251d69a4ef><p class=pgc-img-caption></p></div><p><br></p><p>可以看到，重寫了 hashCode() 方法 和 equals() 方法之後，就把重複的 Student 對象去掉了。</p><h1 class=pgc-h-arrow-right>2.6、LinkedHashSet 集合</h1><p>我們知道 HashSet 保證元素唯一，可是元素存放進去是沒有順序的，那麼我們要保證有序，怎麼辦呢？在 HashSet 下面有一個子類 LinkedHashSet，它是鏈表和哈希表組合的一個數據存儲結構，它多了一條鏈表用來記錄元素的存儲順序，所以 LinkedHashSet 是有序的。</p><blockquote><p>LinkedHashSet 集合代碼演示如下所示:</p></blockquote><pre><code>public class LinkedHashSetDemo01 {    public static void main(String[] args) {        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();        set.add("abc");        set.add("www");        set.add("zz");        set.add("qq");        set.add("it");        System.out.println(set);        LinkedHashSet&lt;String&gt; linkedSet = new LinkedHashSet&lt;&gt;();        linkedSet.add("abc");        linkedSet.add("www");        linkedSet.add("zz");        linkedSet.add("qq");        linkedSet.add("it");        System.out.println(linkedSet);    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>三、List 集合</h1><h1 class=pgc-h-arrow-right>3.1、List 接口介紹</h1><p>List 接口繼承自 Collection 接口，我們會將實現了 List 接口的對象稱為 List 集合。在 List 集合中允許出現重複的元素，所有的元素是以一種線性的方式進行存儲的，在程序中可以通過索引來訪問集合中的指定元素。另外，List 集合還有一個特點就是元素有序，即元素的存儲和取出順序一致。</p><h1 class=pgc-h-arrow-right>3.2、List 接口常用方法</h1><p>List 不但繼承了 Collection 接口的全部方法，而且還增加了一些根據元素索引來操作集合的特有方法，如下：</p><ul><li>public void add(int index, E element)：將指定的元素添加到指定位置上。</li><li>public E get(int index)：返回集合中指定位置的元素。</li><li>public E remove(int index)：將指定位置上的元素移除並返回該元素。</li><li>public E set(int index, E element)：用指定元素替換集合中指定位置的元素，並返回被替換的元素。</li></ul><blockquote><p>List 接口常用方法代碼演示如下所示:</p></blockquote><pre><code>public class ListDemo01 {    public static void main(String[] args) {        // 創建一個 List 集合對象        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add("a");        list.add("b");        list.add("c");        list.add("d");        list.add("a");        System.out.println(list);        // public void add(int index, E element)        // 在 c 和 d 之間添加一個 Test        list.add(3, "Test");        System.out.println(list);        // public E remove(int index)        // 移除 c 元素        String removeE = list.remove(2);        System.out.println(removeE);        System.out.println(list);        // public E set(int index, E element)        // 把最後一個 a 替換成 A        String setE = list.set(4, "A");        System.out.println(setE);        System.out.println(list);        // public E get(int index)        // List 集合遍歷有三種方式        // 1、使用普通 for 循環        for (int i = 0; i &lt; list.size(); i++) {            System.out.print(list.get(i) + ", ");        }        System.out.println("\n");        System.out.println("----------------------------分割線--------------------------");        // 2、使用迭代器循環        Iterator&lt;String&gt; iterator = list.iterator();        while (iterator.hasNext()) {            System.out.print(iterator.next() + ", ");        }        System.out.println("\n");        System.out.println("----------------------------分割線--------------------------");        // 3、使用增強 for 循環        for (String s : list) {            System.out.print(s + ", ");        }    }}複製代碼</code></pre><p>注意\color{red}{注意}<span style="color:red;--tt-darkmode-color: #FF0C00">注意</span>：操作索引的時候一定要放置索引越界異常。</p><h1 class=pgc-h-arrow-right>3.3、List 接口的子類</h1><h1 class=pgc-h-arrow-right>3.3.1、ArrayList 集合</h1><p>ArrayList 集合的底層數據結構是<strong>數組結構</strong>，其特點是<strong>元素增刪慢，查詢快</strong>，由於日常開發中使用最多的功能就算查詢數據，所以 ArrayList 是最常用的集合。但是呢，我們不能在開發中隨意的使用 ArrayList 完成任何需求，只有當 ArrayList 適合我們的開發需求時（查詢多，增刪少），我們才去使用它。</p><h1 class=pgc-h-arrow-right>3.3.2、LinkedList 集合</h1><p>LinkedList 集合的底層數據結構是<strong>鏈表結構</strong>，其特點是<strong>元素增刪快，查詢慢</strong>，但是鏈表結構的首尾元素查找速度跟數組的查找是一樣快的，所以 LinkedList 中包含了大量操作首尾元素的方法。所以當我們需要實現的需求增刪操作很多，查詢很少或者查詢很多但都是查詢手尾的時候，我們就可以使用 LinkedList 集合。</p><blockquote><p>LinkedList 集合操作首尾元素方法代碼演示如下所示:</p></blockquote><pre><code>public class LinkedListDemo02 {    public static void main(String[] args) {        // show01();        // show02();        show03();    }    // 增加元素    private static void show01() {        // 創建LinkedList集合對象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        System.out.println(linkedList);        // addFirst()        linkedList.addFirst("www");        System.out.println(linkedList);        // push() 等效於 addFirst()        linkedList.push("ccc");        System.out.println(linkedList);        // addLast() 等效於 add()        linkedList.addLast("com");        System.out.println(linkedList);    }    // 獲取元素    private static void show02() {        // 創建LinkedList集合對象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        System.out.println(linkedList);        if (!linkedList.isEmpty()) {            String first = linkedList.getFirst();            System.out.println(first);            String last = linkedList.getLast();            System.out.println(last);        }    }    // 移除元素    private static void show03() {        // 創建LinkedList集合對象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        System.out.println(linkedList);        // pop() 相當於 removeFirst()        String first = linkedList.removeFirst();        System.out.println(first);        String last = linkedList.removeLast();        System.out.println(last);        System.out.println(linkedList);    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>3.3.3、Vector 集合</h1><p>Vector 集合的底層數據結構也是<strong>數組結構</strong>，但是與List和LinkedList 不同的是，Vector 集合是單線程的，速度慢，目前已經被 ArrayList 所取代。</p><h1 class=pgc-h-arrow-right>四、Collections 集合工具類</h1><h1 class=pgc-h-arrow-right>4.1、常用功能</h1><p>Collections 是集合工具類，用來對集合進行操作，部分方法如下：</p><ul><li>public static &lt;泛型> boolean addAll(Collections, c, T...elements)：往集合中添加一些元素。</li><li>public static void shuffle(List&lt;?> list)：打亂集合順序。</li><li>public static &lt;泛型> void sort(List&lt;?> list)：將集合中元素按照默認規則排序。</li><li>public static &lt;泛型> void sort(List&lt;?> list, Comparator&lt;? super T>)：將集合中元素按照指定規則排序。</li></ul><h1 class=pgc-h-arrow-right>4.2、sort(List&lt;?> list) 方法</h1><p>sort(List&lt;?> list) 方法的使用前提是被排序的集合裡面存儲的元素必須實現 Comparable 接口，並重寫接口中的 compareTo() 方法定義排序的規則。</p><blockquote><p>sort(List&lt;?> list) 方法代碼演示如下所示:</p></blockquote><pre><code>public class CollectionsDemo01 {    public static void main(String[] args) {        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(new Student("張三", 18));        list.add(new Student("李四", 20));        list.add(new Student("王五", 15));        System.out.println(list);        Collections.sort(list);        System.out.println(list);    }    static class Student implements Comparable&lt;Student&gt; {            private String name;        private int age;        public Student() {        }        public Student(String name, int age) {            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        @Override        public String toString() {            return "Student{" +                    "name='" + name + '\'' +                    ", age=" + age +                    '}';        }        @Override        public int compareTo(Student o) {            // 自定義比較規則            // 比較兩個人的年齡            return this.getAge() - o.getAge();   // 按照年齡升序            //return o.getAge() - this.getAge();  // 按照年齡降序        }    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>4.3、sort(list, Comparator) 方法</h1><p>Comparator 和 Comparable 的區別：</p><ol start=1><li>Comparable 是排序接口，若一個類實現了 Comparable 接口，就意味著“該類支持排序”。</li><li>Comparator 是比較器，我們若需要控制某個類的次序，可以建立一個“該類的比較器”來進行排序。</li><li>Comparable 相當於“內部比較器”，而 Comparator 相當於“外部比較器”。</li></ol><p>一個對象不支持自己和自己比較（沒有實現Comparable接口），但是又想對兩個對象進行比較</p><blockquote><p>sort(list, Comparator) 方法代碼演示如下所示:</p></blockquote><pre><code>public class ComparatorDemo01 {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(3);        list.add(2);        System.out.println(list);        Collections.sort(list, new Comparator&lt;Integer&gt;() {            // 重寫比較的規則            @Override            public int compare(Integer o1, Integer o2) {                return o1 - o2; // 升序                //return o2 - o1; // 降序            }        });        System.out.println(list);        ArrayList&lt;CollectionsDemo01.Student&gt; list2 = new ArrayList&lt;&gt;();        list2.add(new CollectionsDemo01.Student("張三", 18));        list2.add(new CollectionsDemo01.Student("李四", 20));        list2.add(new CollectionsDemo01.Student("b王五", 15));        list2.add(new CollectionsDemo01.Student("a李六", 15));        System.out.println(list2);        Collections.sort(list2, new Comparator&lt;CollectionsDemo01.Student&gt;() {            @Override            public int compare(CollectionsDemo01.Student o1, CollectionsDemo01.Student o2) {                int result = o1.getAge() - o2.getAge();                // 如果兩個人的年齡是一樣的，就用姓名的第一字比較規則                if (result == 0) {                    return o1.getName().charAt(0) - o2.getName().charAt(0);                }                return result;            }        });        System.out.println(list2);    }    static class Student {        private String name;        private int age;        public Student() {        }        public Student(String name, int age) {            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        @Override        public String toString() {            return "Student{" +                    "name='" + name + '\'' +                    ", age=" + age +                    '}';        }    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>五、小結</h1><p>集合第二部分中我們講了 <strong>List 集合</strong>、 <strong>Set 集合</strong>和 <strong>Collections 集合工具類</strong>，下一節我們講 <strong>Map 集合</strong>和<strong>一個綜合案例</strong>。</p><p><br>作者：萌果愛吃檸檬<br>鏈接：https://juejin.im/post/6889596397943816199<br>來源：掘金<br>著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>集合</a></li><li><a>Java</a></li><li><a>Set</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html alt=Java集合-Collection class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html title=Java集合-Collection>Java集合-Collection</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1ee224b.html alt=Java集合-Queue class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b956858a7a540d0990d7831eb906983 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1ee224b.html title=Java集合-Queue>Java集合-Queue</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1e4549b9.html alt=Java集合框架綜述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fca2a03e52a1473db53da27e12467181 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1e4549b9.html title=Java集合框架綜述>Java集合框架綜述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/98943258.html alt=帶你從零學大數據之Java篇第十八章：集合(Set) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f5c0991dc0364e098d7650153308110e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/98943258.html title=帶你從零學大數據之Java篇第十八章：集合(Set)>帶你從零學大數據之Java篇第十八章：集合(Set)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/80dcc482.html alt=最常用的Java集合類，你一定用過 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c67cd5e4de3b459c8010e8be5a995e0d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/80dcc482.html title=最常用的Java集合類，你一定用過>最常用的Java集合類，你一定用過</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcb4e09c.html alt=詳談Java集合框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcb4e09c.html title=詳談Java集合框架>詳談Java集合框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65ba507a.html alt=Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e3bf229076045f18e5bb24370a78db0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65ba507a.html title=Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？>Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html alt=Java集合詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d86fadc20bed4a69ad6bf811308371d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html title=Java集合詳解>Java集合詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>