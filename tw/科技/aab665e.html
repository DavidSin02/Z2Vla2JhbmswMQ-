<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JAVA 線上故障排查完整套路 | 极客快訊</title><meta property="og:title" content="JAVA 線上故障排查完整套路 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/S9LRwPUHmvyLdR"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aab665e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aab665e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aab665e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aab665e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aab665e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aab665e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aab665e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aab665e.html><meta property="article:published_time" content="2020-10-29T20:53:30+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:30+08:00"><meta name=Keywords content><meta name=description content="JAVA 線上故障排查完整套路"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/aab665e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JAVA 線上故障排查完整套路</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>優質文章，及時送達</p><p>線上故障主要會包括cpu、磁盤、內存以及網絡問題，而大多數故障可能會包含不止一個層面的問題，所以進行排查時候儘量四個方面依次排查一遍。</p><p>同時例如jstack、jmap等工具也是不囿於一個方面的問題的，基本上出問題就是df、free、top 三連，然後依次jstack、jmap伺候，具體問題具體分析即可。</p><p>一般來講我們首先會排查cpu方面的問題。cpu異常往往還是比較好定位的。原因包括業務邏輯問題(死循環)、頻繁gc以及上下文切換過多。而最常見的往往是業務邏輯(或者框架邏輯)導致的，可以使用jstack來分析對應的堆棧情況。</p><p>我們先用ps命令找到對應進程的pid(如果你有好幾個目標進程，可以先用top看一下哪個佔用比較高)。</p><p>接著用top -H -p pid來找到cpu使用率比較高的一些線程</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRwPUHmvyLdR><p>然後將佔用最高的pid轉換為16進制<code>printf '%x\n' pid</code>得到nid</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRwPvD93C5lG><p>接著直接在jstack中找到相應的堆棧信息<code>jstack pid |grep 'nid' -C5 –color</code></p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRwQDAS0OqLx><p>可以看到我們已經找到了nid為0x42的堆棧信息，接著只要仔細分析一番即可。</p><p>當然更常見的是我們對整個jstack文件進行分析，通常我們會比較關注WAITING和TIMED_WAITING的部分，BLOCKED就不用說了。我們可以使用命令<code>cat jstack.log | grep "java.lang.Thread.State" | sort -nr | uniq -c</code>來對jstack的狀態有一個整體的把握，如果WAITING之類的特別多，那麼多半是有問題啦。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRwQe2DKIGFR><p>當然我們還是會使用jstack來分析問題，但有時候我們可以先確定下gc是不是太頻繁，使用jstat -gc pid 1000命令來對gc分代變化情況進行觀察，1000表示採樣間隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU分別代表兩個Survivor區、Eden區、老年代、元數據區的容量和使用量。YGC/YGT、FGC/FGCT、GCT則代表YoungGc、FullGc的耗時和次數以及總耗時。如果看到gc比較頻繁，再針對gc方面做進一步分析。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9LRwT7JJPZWYj><p>針對頻繁上下文問題，我們可以使用vmstat命令來進行查看</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRx9w7z8Qd8N><p>cs(context switch)一列則代表了上下文切換的次數。</p><p>如果我們希望對特定的pid進行監控那麼可以使用 pidstat -w pid命令，cswch和nvcswch表示自願及非自願切換。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRxAHIz3mPlp><p>磁盤問題和cpu一樣是屬於比較基礎的。首先是磁盤空間方面，我們直接使用df -hl來查看文件系統狀態</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRxAd4OIOpOh><p>更多時候，磁盤問題還是性能上的問題。我們可以通過iostatiostat -d -k -x來進行分析</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRxBCCycM1iw><p>最後一列%util可以看到每塊磁盤寫入的程度，而rrqpm/s以及wrqm/s分別表示讀寫速度，一般就能幫助定位到具體哪塊磁盤出現問題了。</p><p>另外我們還需要知道是哪個進程在進行讀寫，一般來說開發自己心裡有數，或者用iotop命令來進行定位文件讀寫的來源。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9LRxBbE41y8LV><p>不過這邊拿到的是tid，我們要轉換成pid，可以通過readlink來找到pidreadlink -f /proc/*/task/tid/../..。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRxob8BQjm6b><p>找到pid之後就可以看這個進程具體的讀寫情況cat /proc/pid/io</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRxow4fmlVlA><p>我們還可以通過lsof命令來確定具體的文件讀寫情況lsof -p pid</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRxpSFX17OHc><p>內存問題排查起來相對比CPU麻煩一些，場景也比較多。主要包括OOM、GC問題和堆外內存。一般來講，我們會先用free命令先來檢查一發內存的各種情況。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRxqE7g0PAlO><p>內存問題大多還都是堆內內存問題。表象上主要分為OOM和StackOverflow。</p><p>JMV中的內存不足，OOM大致可以分為以下幾種：</p><p><code>Exception in thread "main" java.lang.OutOfMemoryError: unable to create new native thread</code></p><p>這個意思是沒有足夠的內存空間給線程分配java棧，基本上還是線程池代碼寫的有問題，比如說忘記shutdown，所以說應該首先從代碼層面來尋找問題，使用jstack或者jmap。如果一切都正常，JVM方面可以通過指定Xss來減少單個thread stack的大小。</p><p>另外也可以在系統層面，可以通過修改/etc/security/limits.confnofile和nproc來增大os對線程的限制</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRxqeDQn1Msm><p><code>Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</code></p><p>這個意思是堆的內存佔用已經達到-Xmx設置的最大值，應該是最常見的OOM錯誤了。解決思路仍然是先應該在代碼中找，懷疑存在內存洩漏，通過jstack和jmap去定位問題。如果說一切都正常，才需要通過調整Xmx的值來擴大內存。</p><p><code>Caused by: java.lang.OutOfMemoryError: Meta space</code></p><p>這個意思是元數據區的內存佔用已經達到XX:MaxMetaspaceSize設置的最大值，排查思路和上面的一致，參數方面可以通過XX:MaxPermSize來進行調整(這裡就不說1.8以前的永久代了)。</p><p>棧內存溢出，這個大家見到也比較多。</p><p><code>Exception in thread "main" java.lang.StackOverflowError</code></p><p>表示線程棧需要的內存大於Xss值，同樣也是先進行排查，參數方面通過Xss來調整，但調整的太大可能又會引起OOM。</p><p>上述關於OOM和StackOverflow的代碼排查方面，我們一般使用JMAPjmap -dump:format=b,file=filename pid來導出dump文件</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRyOK8q333PZ><p>通過mat(Eclipse Memory Analysis Tools)導入dump文件進行分析，內存洩漏問題一般我們直接選Leak Suspects即可，mat給出了內存洩漏的建議。另外也可以選擇Top Consumers來查看最大對象報告。和線程相關的問題可以選擇thread overview進行分析。除此之外就是選擇Histogram類概覽來自己慢慢分析，大家可以搜搜mat的相關教程。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRyOp81cyGGb><p>日常開發中，代碼產生內存洩漏是比較常見的事，並且比較隱蔽，需要開發者更加關注細節。比如說每次請求都new對象，導致大量重複創建對象；進行文件流操作但未正確關閉；手動不當觸發gc；ByteBuffer緩存分配不合理等都會造成代碼OOM。</p><p>另一方面，我們可以在啟動參數中指定<code>-XX:+HeapDumpOnOutOfMemoryError</code>來保存OOM時的dump文件。</p><p>搜索Java知音，回覆“後端面試”，送你一份面試寶典.pdf</p><p>gc問題除了影響cpu也會影響內存，排查思路也是一致的。一般先使用jstat來查看分代變化情況，比如youngGC或者fullGC次數是不是太多呀；EU、OU等指標增長是不是異常呀等。</p><p>線程的話太多而且不被及時gc也會引發oom，大部分就是之前說的unable to create new native thread。除了jstack細細分析dump文件外，我們一般先會看下總體線程，通過pstreee -p pid |wc -l。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRyPYJ4SuzMG><p>或者直接通過查看/proc/pid/task的數量即為線程數量。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LRyPnH1TrgpW><p>如果碰到堆外內存溢出，那可真是太不幸了。首先堆外內存溢出表現就是物理常駐內存增長快，報錯的話視使用方式都不確定，如果由於使用Netty導致的，那錯誤日誌裡可能會出現OutOfDirectMemoryError錯誤，如果直接是DirectByteBuffer，那會報<code>OutOfMemoryError: Direct buffer memory</code>。</p><p>堆外內存溢出往往是和NIO的使用相關，一般我們先通過pmap來查看下進程佔用的內存情況pmap -x pid | sort -rn -k3 | head -30，這段意思是查看對應pid倒序前30大的內存段。這邊可以再一段時間後再跑一次命令看看內存增長情況，或者和正常機器比較可疑的內存段在哪裡。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LRyRP94XAuuw><p>我們如果確定有可疑的內存端，需要通過gdb來分析gdb --batch --pid {pid} -ex "dump memory filename.dump {內存起始地址} {內存起始地址+內存塊大小}"</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LS2LTHPx7pG0><p>獲取dump文件後可用heaxdump進行查看hexdump -C filename | less，不過大多數看到的都是二進制亂碼。</p><p>NMT是Java7U40引入的HotSpot新特性，配合jcmd命令我們就可以看到具體內存組成了。需要在啟動參數中加入 <code>-XX:NativeMemoryTracking=summary</code>或者<code>-XX:NativeMemoryTracking=detail</code>，會有略微性能損耗。</p><p>一般對於堆外內存緩慢增長直到爆炸的情況來說，可以先設一個基線jcmd pid VM.native_memory baseline。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LS2Lo57BVGOF><p>然後等放一段時間後再去看看內存增長的情況，通過jcmd pid VM.native_memory detail.diff(summary.diff)做一下summary或者detail級別的diff。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LS2MLEdzcOzs><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9LS2MjEGqdanO><p>可以看到jcmd分析出來的內存十分詳細，包括堆內、線程以及gc(所以上述其他內存異常其實都可以用nmt來分析)，這邊堆外內存我們重點關注Internal的內存增長，如果增長十分明顯的話那就是有問題了。</p><p>detail級別的話還會有具體內存段的增長情況，如下圖。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LS2NS8v3rq6S><p>此外在系統層面，我們還可以使用strace命令來監控內存分配 strace -f -e "brk,mmap,munmap" -p pid</p><p>這邊內存分配信息主要包括了pid和內存地址。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LS3J77NImGeo><p>不過其實上面那些操作也很難定位到具體的問題點，關鍵還是要看錯誤日誌棧，找到可疑的對象，搞清楚它的回收機制，然後去分析對應的對象。比如DirectByteBuffer分配內存的話，是需要full GC或者手動system.gc來進行回收的(所以最好不要使用-XX:+DisableExplicitGC)。</p><p>那麼其實我們可以跟蹤一下DirectByteBuffer對象的內存情況，通過jmap -histo:live pid手動觸發fullGC來看看堆外內存有沒有被回收。如果被回收了，那麼大概率是堆外內存本身分配的太小了，通過-XX:MaxDirectMemorySize進行調整。如果沒有什麼變化，那就要使用jmap去分析那些不能被gc的對象，以及和DirectByteBuffer之間的引用關係了。</p><p>搜索Java知音，回覆“後端面試”，送你一份面試寶典.pdf</p><p>堆內內存洩漏總是和GC異常相伴。不過GC問題不只是和內存問題相關，還有可能引起CPU負載、網絡問題等系列併發症，只是相對來說和內存聯繫緊密些，所以我們在此單獨總結一下GC相關問題。</p><p>我們在cpu章介紹了使用jstat來獲取當前GC分代變化信息。而更多時候，我們是通過GC日誌來排查問題的，在啟動參數中加上<code>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</code>來開啟GC日誌。</p><p>常見的Young GC、Full GC日誌含義在此就不做贅述了。</p><p>針對gc日誌，我們就能大致推斷出youngGC與fullGC是否過於頻繁或者耗時過長，從而對症下藥。我們下面將對G1垃圾收集器來做分析，這邊也建議大家使用G1-XX:+UseG1GC。</p><p>youngGC頻繁一般是短週期小對象較多，先考慮是不是Eden區/新生代設置的太小了，看能否通過調整-Xmn、-XX:SurvivorRatio等參數設置來解決問題。如果參數正常，但是young gc頻率還是太高，就需要使用Jmap和MAT對dump文件進行進一步排查了。</p><p>耗時過長問題就要看GC日誌裡耗時耗在哪一塊了。以G1日誌為例，可以關注Root Scanning、Object Copy、Ref Proc等階段。Ref Proc耗時長，就要注意引用相關的對象。</p><p>Root Scanning耗時長，就要注意線程數、跨代引用。Object Copy則需要關注對象生存週期。而且耗時分析它需要橫向比較，就是和其他項目或者正常時間段的耗時比較。比如說圖中的Root Scanning和正常時間段比增長較多，那就是起的線程太多了。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LS3JlAx75YXo><p>G1中更多的還是mixedGC，但mixedGC可以和youngGC思路一樣去排查。觸發fullGC了一般都會有問題，G1會退化使用Serial收集器來完成垃圾的清理工作，暫停時長達到秒級別，可以說是半跪了。</p><p>fullGC的原因可能包括以下這些，以及參數調整方面的一些思路：</p><ul><li><p>併發階段失敗：在併發標記階段，MixGC之前老年代就被填滿了，那麼這時候G1就會放棄標記週期。這種情況，可能就需要增加堆大小，或者調整併發標記線程數-XX:ConcGCThreads。</p></li><li><p>晉升失敗：在GC的時候沒有足夠的內存供存活/晉升對象使用，所以觸發了Full GC。這時候可以通過-XX:G1ReservePercent來增加預留內存百分比，減少-XX:InitiatingHeapOccupancyPercent來提前啟動標記，-XX:ConcGCThreads來增加標記線程數也是可以的。</p></li><li><p>大對象分配失敗：大對象找不到合適的region空間進行分配，就會進行fullGC，這種情況下可以增大內存或者增大-XX:G1HeapRegionSize。</p></li><li><p>程序主動執行System.gc：不要隨便寫就對了。</p></li></ul><p>另外，我們可以在啟動參數中配置-XX:HeapDumpPath=/xxx/dump.hprof來dump fullGC相關的文件，並通過jinfo來進行gc前後的dump</p><pre><p><code>jinfo -flag +HeapDumpBeforeFullGC pid <br>jinfo -flag +HeapDumpAfterFullGC pid<br></code></p></pre><p>這樣得到2份dump文件，對比後主要關注被gc掉的問題對象來定位問題。</p><p>搜索Java知音，回覆“後端面試”，送你一份面試寶典.pdf</p><p>涉及到網絡層面的問題一般都比較複雜，場景多，定位難，成為了大多數開發的噩夢，應該是最複雜的了。這裡會舉一些例子，並從tcp層、應用層以及工具的使用等方面進行闡述。</p><p>超時錯誤大部分處在應用層面，所以這塊著重理解概念。超時大體可以分為連接超時和讀寫超時，某些使用連接池的客戶端框架還會存在獲取連接超時和空閒連接清理超時。</p><ul><li><div><p>讀寫超時。readTimeout/writeTimeout，有些框架叫做so_timeout或者socketTimeout，均指的是數據讀寫超時。注意這邊的超時大部分是指邏輯上的超時。soa的超時指的也是讀超時。讀寫超時一般都只針對客戶端設置。</p></div></li><li><div><p>連接超時。connectionTimeout，客戶端通常指與服務端建立連接的最大時間。服務端這邊connectionTimeout就有些五花八門了，jetty中表示空閒連接清理時間，tomcat則表示連接維持的最大時間。</p></div></li><li><div><p>其他。包括連接獲取超時connectionAcquireTimeout和空閒連接清理超時idleConnectionTimeout。多用於使用連接池或隊列的客戶端或服務端框架。</p></div></li></ul><p>我們在設置各種超時時間中，需要確認的是儘量保持客戶端的超時小於服務端的超時，以保證連接正常結束。</p><p>在實際開發中，我們關心最多的應該是接口的讀寫超時了。</p><p>如何設置合理的接口超時是一個問題。如果接口超時設置的過長，那麼有可能會過多地佔用服務端的tcp連接。而如果接口設置的過短，那麼接口超時就會非常頻繁。</p><p>服務端接口明明rt降低，但客戶端仍然一直超時又是另一個問題。這個問題其實很簡單，客戶端到服務端的鏈路包括網絡傳輸、排隊以及服務處理等，每一個環節都可能是耗時的原因。</p><p>tcp隊列溢出是個相對底層的錯誤，它可能會造成超時、rst等更表層的錯誤。因此錯誤也更隱蔽，所以我們單獨說一說。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9LS3KLJ8nDuQJ><p>如上圖所示，這裡有兩個隊列：syns queue(半連接隊列）、accept queue（全連接隊列）。三次握手，在server收到client的syn後，把消息放到syns queue，回覆syn+ack給client，server收到client的ack，如果這時accept queue沒滿，那就從syns queue拿出暫存的信息放入accept queue中，否則按tcp_abort_on_overflow指示的執行。</p><p>tcp_abort_on_overflow 0表示如果三次握手第三步的時候accept queue滿了那麼server扔掉client發過來的ack。tcp_abort_on_overflow 1則表示第三步的時候如果全連接隊列滿了，server發送一個rst包給client，表示廢掉這個握手過程和這個連接，意味著日誌裡可能會有很多connection reset / connection reset by peer。</p><p>那麼在實際開發中，我們怎麼能快速定位到tcp隊列溢出呢？</p><p>netstat命令，執行<code>netstat -s | egrep "listen|LISTEN"</code></p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9LS3Kh1xNDuKf><p>如上圖所示，overflowed表示全連接隊列溢出的次數，sockets dropped表示半連接隊列溢出的次數。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9LS3L3IG4g7bk><p>上面看到Send-Q 表示第三列的listen端口上的全連接隊列最大為5，第一列Recv-Q為全連接隊列當前使用了多少。</p><p>接著我們看看怎麼設置全連接、半連接隊列大小吧：</p><p>全連接隊列的大小取決於min(backlog, somaxconn)。backlog是在socket創建的時候傳入的，somaxconn是一個os級別的系統參數。而半連接隊列的大小取決於max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p><p>在日常開發中，我們往往使用servlet容器作為服務端，所以我們有時候也需要關注容器的連接隊列大小。在tomcat中backlog叫做acceptCount，在jetty裡面則是acceptQueueSize。</p><p>RST包表示連接重置，用於關閉一些無用的連接，通常表示異常關閉，區別於四次揮手。</p><p>在實際開發中，我們往往會看到connection reset / connection reset by peer錯誤，這種情況就是RST包導致的。</p><p>如果像不存在的端口發出建立連接SYN請求，那麼服務端發現自己並沒有這個端口則會直接返回一個RST報文，用於中斷連接。</p><p>一般來說，正常的連接關閉都是需要通過FIN報文實現，然而我們也可以用RST報文來代替FIN，表示直接終止連接。實際開發中，可設置SO_LINGER數值來控制，這種往往是故意的，來跳過TIMED_WAIT，提供交互效率，不閒就慎用。</p><p><strong>客戶端或服務端有一邊發生了異常，該方向對端發送RST以告知關閉連接</strong></p><p>我們上面講的tcp隊列溢出發送RST包其實也是屬於這一種。這種往往是由於某些原因，一方無法再能正常處理請求連接了(比如程序崩了，隊列滿了)，從而告知另一方關閉連接。</p><p><strong>接收到的TCP報文不在已知的TCP連接內</strong></p><p>比如，一方機器由於網絡實在太差TCP報文失蹤了，另一方關閉了該連接，然後過了許久收到了之前失蹤的TCP報文，但由於對應的TCP連接已不存在，那麼會直接發一個RST包以便開啟新的連接。</p><p><strong>一方長期未收到另一方的確認報文，在一定時間或重傳次數後發出RST報文</strong></p><p>這種大多也和網絡環境相關了，網絡環境差可能會導致更多的RST報文。</p><p>之前說過RST報文多會導致程序報錯，在一個已關閉的連接上讀操作會報connection reset，而在一個已關閉的連接上寫操作則會報connection reset by peer。通常我們可能還會看到broken pipe錯誤，這是管道層面的錯誤，表示對已關閉的管道進行讀寫，往往是在收到RST，報出connection reset錯後繼續讀寫數據報的錯，這個在glibc源碼註釋中也有介紹。</p><p>我們在排查故障時候怎麼確定有RST包的存在呢？當然是使用tcpdump命令進行抓包，並使用wireshark進行簡單分析了。tcpdump -i en0 tcp -w xxx.cap，en0表示監聽的網卡。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LS71GDdYl5SX><p>接下來我們通過wireshark打開抓到的包，可能就能看到如下圖所示，紅色的就表示RST包了。</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9LS71jAbMafkc><p>TIME_WAIT和CLOSE_WAIT是啥意思相信大家都知道。</p><p>在線上時，我們可以直接用命令<code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</code>來查看time-wait和close_wait的數量</p><p>用ss命令會更快<code>ss -ant | awk '{++S[$1]} END {for(a in S) print a, S[a]}'</code></p><p></p><h2 toutiao-origin=h3>TIME_WAIT</h2><p>time_wait的存在一是為了丟失的數據包被後面連接複用，二是為了在2MSL的時間範圍內正常關閉連接。它的存在其實會大大減少RST包的出現。</p><p>過多的time_wait在短連接頻繁的場景比較容易出現。這種情況可以在服務端做一些內核參數調優:</p><pre><p><code>#表示開啟重用。允許將TIME-WAIT sockets重新用於新的TCP連接，默認為0，表示關閉<br>net.ipv4.tcp_tw_reuse = 1<br>#表示開啟TCP連接中TIME-WAIT sockets的快速回收，默認為0，表示關閉<br>net.ipv4.tcp_tw_recycle = 1<br></code></p></pre><p>當然我們不要忘記在NAT環境下因為時間戳錯亂導致數據包被拒絕的坑了，另外的辦法就是改小tcp_max_tw_buckets，超過這個數的time_wait都會被幹掉，不過這也會導致報time wait bucket table overflow的錯。</p><p>close_wait往往都是因為應用程序寫的有問題，沒有在ACK後再次發起FIN報文。close_wait出現的概率甚至比time_wait要更高，後果也更嚴重。往往是由於某個地方阻塞住了，沒有正常關閉連接，從而漸漸地消耗完所有的線程。</p><p>想要定位這類問題，最好是通過jstack來分析線程堆棧來排查問題，具體可參考上述章節。這裡僅舉一個例子。</p><p>開發同學說應用上線後CLOSE_WAIT就一直增多，直到掛掉為止，jstack後找到比較可疑的堆棧是大部分線程都卡在了countdownlatch.await方法，找開發同學瞭解後得知使用了多線程但是確沒有catch異常，修改後發現異常僅僅是最簡單的升級sdk後常出現的class not found。</p><p class=pgc-end-source>作者：fredal</p><p class=pgc-end-source>https://fredal.xin/java-error-check</p><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9EB9kkI70t6Ud><p class=pgc-end-source>#投 稿 通 道#</p><p class=pgc-end-source>讓你的博客被更多人看到</p><p class=pgc-end-source>自己辛苦寫的博客沒人看？想讓自己的作品被更多人看到？或者利用寫作賺點外快？快來投稿吧。</p><p class=pgc-end-source>Java後端 鼓勵讀者朋友在我們的平臺上分享各類優質內容，可以是技術博客，也可以是面試經驗或圖文教材。我們的目的只有一個，讓知識真正流動起來。</p><p class=pgc-end-source>📝 來稿標準：</p><p class=pgc-end-source>• 稿件確係個人原創作品</p><p class=pgc-end-source>• 如果文章並非首發，請在投稿時提醒並附上所有已發佈鏈接</p><p class=pgc-end-source>• 如作者同意 Java後端 標記“原創”標誌，將會提供豐厚的稿費</p><p class=pgc-end-source>• 如果文章已在別的公眾號以原創的方式發佈，請給 Java後端 開白名單</p><p class=pgc-end-source>📬 投稿方式：</p><p class=pgc-end-source>• 投稿請聯繫：web527zsd</p><p class=pgc-end-source>• 添加好友時，請備註投稿</p><pre><p class=pgc-end-source>- END -</p><p class=pgc-end-source>最近整理一份面試資料《Java技術棧學習手冊》，覆蓋了Java技術、面試題精選、Spring全家桶、Nginx、SSM、微服務、數據庫、數據結構、架構等等。</p><div><img alt="JAVA 線上故障排查完整套路" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S7QqYwT3jhkulD></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JAVA</a></li><li><a>線上</a></li><li><a>套路</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html alt=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15310942260931dda577a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html title=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點>JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3f00a17.html alt=又被套路了，買二手車一定要注意這些 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c4158e929c1a474d9eb7cd8d461119db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3f00a17.html title=又被套路了，買二手車一定要注意這些>又被套路了，買二手車一定要注意這些</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf248ef5.html alt=2018年收藏和田玉最新關鍵詞——線上交易！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/54000003fda0ced1dd2b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf248ef5.html title=2018年收藏和田玉最新關鍵詞——線上交易！>2018年收藏和田玉最新關鍵詞——線上交易！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ddaaafd3.html alt=“寶立在線”打開收藏品線上新市場 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ddaaafd3.html title=“寶立在線”打開收藏品線上新市場>“寶立在線”打開收藏品線上新市場</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c23926da.html alt=“線上收藏館”為收藏愛好者服務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RZxKkNJ6Q7bdsr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c23926da.html title=“線上收藏館”為收藏愛好者服務>“線上收藏館”為收藏愛好者服務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0bb644a7.html alt=打造“線上收藏館”，微拍堂正式啟動大宅雲倉項目 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RZgypSlDWDdpaW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0bb644a7.html title=打造“線上收藏館”，微拍堂正式啟動大宅雲倉項目>打造“線上收藏館”，微拍堂正式啟動大宅雲倉項目</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9927d4ef.html alt=高架線上的防震錘是這樣用的，你造嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1524796931786223b0d4a09 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9927d4ef.html title=高架線上的防震錘是這樣用的，你造嗎？>高架線上的防震錘是這樣用的，你造嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html alt=JAVA入門到大神（玩轉正則表達式） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html title=JAVA入門到大神（玩轉正則表達式）>JAVA入門到大神（玩轉正則表達式）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a3d9e7a.html alt=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ea11259e-5098-451f-b989-4e3169a16a1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a3d9e7a.html title=「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道>「JAVA」從格式化輸出到掃描輸入，深究Java正則表達式匹配之道</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html alt=給JAVA開發人員的正則表達式入門課 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html title=給JAVA開發人員的正則表達式入門課>給JAVA開發人員的正則表達式入門課</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html alt=JAVA怎麼處理異常 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/6cf507ab-d41c-4bb0-bef0-6def0eb1fef8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0a9e51.html title=JAVA怎麼處理異常>JAVA怎麼處理異常</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d987d8ec.html alt=新突破！粒界科技線上發佈自主產權3D渲染引擎GritGene class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4456820038a44b6ba9e64ce9bbd6648e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d987d8ec.html title=新突破！粒界科技線上發佈自主產權3D渲染引擎GritGene>新突破！粒界科技線上發佈自主產權3D渲染引擎GritGene</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html alt=JAVA應用程序開發之集合類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aa9e1fe1752a4a1886a691485e0e1373 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3906fa80.html title=JAVA應用程序開發之集合類>JAVA應用程序開發之集合類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html alt=小白學JAVA之——List接口的實現類——ArrayList class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b14b6a69b8354d53a35156eaa365395e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4f080cc.html title=小白學JAVA之——List接口的實現類——ArrayList>小白學JAVA之——List接口的實現類——ArrayList</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>