<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>正則表達式在Java中的使用 | 极客快訊</title><meta property="og:title" content="正則表達式在Java中的使用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><meta property="article:published_time" content="2020-11-14T21:07:13+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:13+08:00"><meta name=Keywords content><meta name=description content="正則表達式在Java中的使用"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/aae5ff48.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>正則表達式在Java中的使用</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>正則表達式一般用於字符串匹配, 字符串查找和字符串替換. 別小看它的作用, 在工作學習中靈活運用正則表達式處理字符串能夠大幅度提高效率, 編程的快樂來得就是這麼簡單。</p><p>一下子給出一堆匹配的規則可能會讓人恐懼, 下面將由淺入深講解正則表達式的使用。</p><h1 class=pgc-h-arrow-right>從簡單例子認識正則表達式匹配</h1><p>先上代碼</p><pre><code>public class Demo1 {    public static void main(String[] args) {        //字符串abc匹配正則表達式&#34;...&#34;, 其中&#34;.&#34;表示一個字符        //&#34;...&#34;表示三個字符        System.out.println(&#34;abc&#34;.matches(&#34;...&#34;));        System.out.println(&#34;abcd&#34;.matches(&#34;...&#34;));    }}//輸出結果truefalse</code></pre><p>String類中有個matches(String regex)方法, 返回值為布爾類型, 用於告訴這個字符串是否匹配給定的正則表達式。</p><p>在本例中我們給出的正則表達式為..., 其中每個.表示一個字符, 整個正則表達式的意思是三個字符, 顯然當匹配abc的時候結果為true, 匹配abcd時結果為false。</p><h1 class=pgc-h-arrow-right>Java中對正則表達式的支持(各種語言有相應的實現)</h1><p>在java.util.regex包下有兩個用於正則表達式的類, 一個是Matcher類, 另一個Pattern。</p><p>Java官方文檔中給出對這兩個類的典型用法, 代碼如下:</p><pre><code>public class Demo2 {    public static void main(String[] args) {        //[a-z]表示a~z之間的任何一個字符, {3}表示3個字符, 意思是匹配一個長度為3, 並且每個字符屬於a~z的字符串        Pattern p = Pattern.compile(&#34;[a-z]{3}&#34;);        Matcher m = p.matcher(&#34;abc&#34;);        System.out.println(m.matches());    }}//輸出結果true</code></pre><p>如果要深究正則表達式背後的原理, 會涉及編譯原理中自動機等知識, 此處不展開描述. 為了達到通俗易懂, 這裡用較為形象的語言描述。</p><p>Pattern可以理解為一個模式, 字符串需要與某種模式進行匹配. 比如Demo2中, 我們定義的模式是一個長度為3的字符串, 其中每個字符必須是a~z中的一個。</p><p>我們看到創建Pattern對象時調用的是Pattern類中的compile方法, 也就是說對我們傳入的正則表達式編譯後得到一個模式對象. 而這個經過編譯後模式對象, 會使得正則表達式使用效率會大大提高, 並且作為一個常量, 它可以安全地供多個線程併發使用。</p><p>Matcher可以理解為模式匹配某個字符串後產生的結果. 字符串和某個模式匹配後可能會產生很多個結果, 這個會在後面的例子中講解。</p><p>最後當我們調用m.matches()時就會返回完整字符串與模式匹配的結果。</p><p>上面的三行代碼可以簡化為一行代碼</p><p>System.out.println("abc".matches("[a-z]{3}"));</p><p>但是如果一個正則表達式需要被重複匹配, 這種寫法效率較低。</p><h1 class=pgc-h-arrow-right>初步認識 . + * ?</h1><p>在介紹之前首先要說明的是, 正則表達式的具體含義不用強背, 各個符號的含義在Java官方文檔的Pattern類描述中或網上有詳細的定義. 當然能熟用就更好了。</p><pre><code>public class Demo3 {    /**     * 為了省略每次寫打印語句, 這裡把輸出語句封裝起來     * @param o     */    private static void p(Object o){        System.out.println(o);    }    /**     * .	Any character (may or may not match line terminators), 任意字符     * X?	X, once or not at all       零個或一個     * X*	X, zero or more times       零個或多個     * X+	X, one or more times        一個或多個     * X{n}	X, exactly n times          x出現n次     * X{n,}	X, at least n times     x出現至少n次     * X{n,m}	X, at least n but not more than m times 出現n~m次     * @param args     */    public static void main(String[] args) {        p(&#34;a&#34;.matches(&#34;.&#34;));        p(&#34;aa&#34;.matches(&#34;aa&#34;));        p(&#34;aaaa&#34;.matches(&#34;a*&#34;));        p(&#34;aaaa&#34;.matches(&#34;a+&#34;));        p(&#34;&#34;.matches(&#34;a*&#34;));        p(&#34;a&#34;.matches(&#34;a?&#34;));        // \d	A digit: [0-9], 表示數字, 但是在java中對&#34;\&#34;這個符號需要使用\進行轉義, 所以出現\d        p(&#34;2345&#34;.matches(&#34;\d{2,5}&#34;));        // \.用於匹配&#34;.&#34;        p(&#34;192.168.0.123&#34;.matches(&#34;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}&#34;));        // [0-2]指必須是0~2中的一個數字        p(&#34;192&#34;.matches(&#34;[0-2][0-9][0-9]&#34;));    }}//輸出結果//全為true</code></pre><h1 class=pgc-h-arrow-right>範圍</h1><p>[]用於描述一個字符的範圍, 下面是一些例子：</p><pre><code>public class Demo4 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        //[abc]指abc中的其中一個字母        p(&#34;a&#34;.matches(&#34;[abc]&#34;));        //[^abc]指除了abc之外的字符        p(&#34;1&#34;.matches(&#34;[^abc]&#34;));        //a~z或A~Z的字符, 以下三個均是或的寫法        p(&#34;A&#34;.matches(&#34;[a-zA-Z]&#34;));        p(&#34;A&#34;.matches(&#34;[a-z|A-Z]&#34;));        p(&#34;A&#34;.matches(&#34;[a-z[A-Z]]&#34;));        //[A-Z&amp;&amp;[REQ]]指A~Z中並且屬於REQ其中之一的字符        p(&#34;R&#34;.matches(&#34;[A-Z&amp;&amp;[REQ]]&#34;));    }}//輸出結果全部為true</code></pre><h1 class=pgc-h-arrow-right>認識\s \w \d \</h1><p>下面介紹數字和字母的正則表達, 這是編程中使用最多的字符了.</p><h2 class=pgc-h-arrow-right>關於\</h2><p>這裡重點介紹最不好理解的\. 在Java中的字符串中, 如果要用到特殊字符, 必須通過在前面加\進行轉義。</p><p>舉個例子, 考慮這個字符串"老師大聲說:"同學們,快交作業!"". 如果我們沒有轉義字符, 那麼開頭的雙引號的結束應該在說:"這裡, 但是我們的字符串中需要用到雙引號, 所以需要用轉義字符。</p><p>使用轉義字符後的字符串為"老師大聲說:\"同學們,快交作業!\"", 這樣我們的原意才能被正確識別。</p><p>同理如果我們要在字符串中使用\, 也應該在前面加一個\, 所以在字符串中表示為"\\"。</p><p>那麼如何在正則表達式中表示要匹配\呢, 答案為"\\\\"。</p><p>我們分開考慮: 由於正則式中表示\同樣需要轉義, 所以前面的\\表示正則表達式中的轉義字符\, 後面的\\表示正則表達式中\本身, 合起來在正則表達式中表示\.</p><p>如果感覺有點繞的話請看下面代碼：</p><pre><code>public class Demo5 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        /**         * \d	A digit: [0-9]          數字         * \D	A non-digit: [^0-9]     非數字         * \s	A whitespace character: [ \t\n0B\f\r] 空格         * \S	A non-whitespace character: [^\s]       非空格         * \w	A word character: [a-zA-Z_0-9]          數字字母和下劃線         * \W	A non-word character: [^\w]             非數字字母和下劃線         */        // \s{4}表示4個空白符        p(&#34; \n\r\t&#34;.matches(&#34;\s{4}&#34;));        // \S表示非空白符        p(&#34;a&#34;.matches(&#34;\S&#34;));        // \w{3}表示數字字母和下劃線        p(&#34;a_8&#34;.matches(&#34;\w{3}&#34;));        p(&#34;abc888&amp;^%&#34;.matches(&#34;[a-z]{1,3}\d+[%^&amp;*]+&#34;));        // 匹配 \        p(&#34;\&#34;.matches(&#34;\\&#34;));    }}//輸出結果全部為true</code></pre><h1 class=pgc-h-arrow-right>邊界處理</h1><p>^在中括號內表示取反的意思[^], 如果不在中括號裡則表示字符串的開頭</p><pre><code>public class Demo6 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        /**         * ^	The beginning of a line 一個字符串的開始         * $	The end of a line       字符串的結束         * \b	A word boundary         一個單詞的邊界, 可以是空格, 換行符等         */        p(&#34;hello sir&#34;.matches(&#34;^h.*&#34;));        p(&#34;hello sir&#34;.matches(&#34;.*r$&#34;));        p(&#34;hello sir&#34;.matches(&#34;^h[a-z]{1,3}o\b.*&#34;));        p(&#34;hellosir&#34;.matches(&#34;^h[a-z]{1,3}o\b.*&#34;));    }}</code></pre><h2 class=pgc-h-arrow-right>練習:匹配空白行合email地址</h2><p>拿到一篇文章, 如何判斷裡面有多少個空白行? 用正則表達式能方便地進行匹配, 注意空白行中可能包括空格, 製表符等。</p><pre><code>p(&#34; \n&#34;.matches(&#34;^[\s&amp;&amp;[^\n]]*\n$&#34;));</code></pre><p>解釋: ^[\\s&&[^\n]]*是空格符號但不是換行符, \\n$最後以換行符結束</p><p>下面是匹配郵箱：</p><pre><code>p(&#34;liuyj24@126.com&#34;.matches(&#34;[\w[.-]]+@[\w[.-]]+\.[\w]+&#34;));</code></pre><p>解釋: [\\w[.-]]+以一個或多個數字字母下劃線.或-組成, @接著是個@符號, 然後同樣是[\\w[.-]]+, 接著\\.匹配., 最後同樣是[\\w]+</p><h1 class=pgc-h-arrow-right>Matcher類的matches(),find()和lookingAt()</h1><p>matches()方法會將整個字符串與模板進行匹配.</p><p>find()則是從當前位置開始進行匹配, 如果傳入字符串後首先進行find(), 那麼當前位置就是字符串的開頭, 對當前位置的具體分析可以看下面的代碼示例</p><p>lookingAt()方法會從字符串的開頭進行匹配.</p><pre><code>public class Demo8 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        Pattern pattern = Pattern.compile(&#34;\d{3,5}&#34;);        String s = &#34;123-34345-234-00&#34;;        Matcher m = pattern.matcher(s);        //先演示matches(), 與整個字符串匹配.        p(m.matches());        //結果為false, 顯然要匹配3~5個數字會在-處匹配失敗        //然後演示find(), 先使用reset()方法把當前位置設置為字符串的開頭        m.reset();        p(m.find());//true 匹配123成功        p(m.find());//true 匹配34345成功        p(m.find());//true 匹配234成功        p(m.find());//false 匹配00失敗        //下面我們演示不在matches()使用reset(), 看看當前位置的變化        m.reset();//先重置        p(m.matches());//false 匹配整個字符串失敗, 當前位置來到-        p(m.find());// true 匹配34345成功        p(m.find());// true 匹配234成功        p(m.find());// false 匹配00始邊        p(m.find());// false 沒有東西匹配, 失敗        //演示lookingAt(), 從頭開始找        p(m.lookingAt());//true 找到123, 成功    }}</code></pre><h1 class=pgc-h-arrow-right>Matcher類中的start()和end()</h1><p>如果一次匹配成功的話start()用於返回匹配開始的位置, end()用於返回匹配結束字符的後面一個位置</p><pre><code>public class Demo9 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        Pattern pattern = Pattern.compile(&#34;\d{3,5}&#34;);        String s = &#34;123-34345-234-00&#34;;        Matcher m = pattern.matcher(s);        p(m.find());//true 匹配123成功        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        p(m.find());//true 匹配34345成功        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        p(m.find());//true 匹配234成功        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        p(m.find());//false 匹配00失敗        try {            p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        }catch (Exception e){            System.out.println(&#34;報錯了...&#34;);        }        p(m.lookingAt());        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());    }}//輸出結果truestart: 0 - end:3truestart: 4 - end:9truestart: 10 - end:13false報錯了...truestart: 0 - end:3</code></pre><h1 class=pgc-h-arrow-right>替換字符串</h1><p>想要替換字符串首先要找到被替換的字符串, 這裡要新介紹Matcher類中的一個方法group(), 它能返回匹配到的字符串.</p><p>下面我們看一個例子, 把字符串中的java轉換為大寫.</p><pre><code>public class Demo10 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        Pattern p = Pattern.compile(&#34;java&#34;);        Matcher m = p.matcher(&#34;java Java JAVA JAva I love Java and you&#34;);        p(m.replaceAll(&#34;JAVA&#34;));//replaceAll()方法會替換所有匹配到的字符串    }}//輸出結果JAVA Java JAVA JAva I love Java and you</code></pre><h2 class=pgc-h-arrow-right>升級: 不區分大小寫查找並替換字符串</h2><p>為了在匹配的時候不區分大小寫, 我們要在創建模板模板時指定大小寫不敏感</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;java&#34;, Pattern.CASE_INSENSITIVE);//指定為大小寫不敏感的    Matcher m = p.matcher(&#34;java Java JAVA JAva I love Java and you&#34;);    p(m.replaceAll(&#34;JAVA&#34;));}//輸出結果JAVA JAVA JAVA JAVA I love JAVA and you</code></pre><h2 class=pgc-h-arrow-right>再升級: 不區分大小寫, 替換查找到的指定字符串</h2><p>這裡演示把查找到第奇數個字符串轉換為大寫, 第偶數個轉換為小寫</p><p>這裡會引入Matcher類中一個強大的方法appendReplacement(StringBuffer sb, String replacement), 它需要傳入一個StringBuffer進行字符串拼接.</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;java&#34;, Pattern.CASE_INSENSITIVE);    Matcher m = p.matcher(&#34;java Java JAVA JAva I love Java and you ?&#34;);    StringBuffer sb = new StringBuffer();    int index = 1;    while(m.find()){        //m.appendReplacement(sb, (index++ &amp; 1) == 0 ? &#34;java&#34; : &#34;JAVA&#34;); 較為簡潔的寫法        if((index &amp; 1) == 0){//偶數            m.appendReplacement(sb, &#34;java&#34;);        }else{            m.appendReplacement(sb, &#34;JAVA&#34;);        }        index++;    }    m.appendTail(sb);//把剩餘的字符串加入    p(sb);}//輸出結果JAVA java JAVA java I love JAVA and you ?</code></pre><h1 class=pgc-h-arrow-right>分組</h1><p>先從一個問題引入, 看下面這段代碼</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;\d{3,5}[a-z]{2}&#34;);    String s = &#34;123aa-5423zx-642oi-00&#34;;    Matcher m = p.matcher(s);    while(m.find()){        p(m.group());    }}//輸出結果123aa5423zx642oi</code></pre><p>其中正則表達式"\\d{3,5}[a-z]{2}"表示3~5個數字跟上兩個字母, 然後打印出每個匹配到的字符串</p><p>如果想要打印每個匹配串中的數字, 如何操作呢.</p><p>首先你可能想到把匹配到的字符串再進行匹配, 但是這樣太麻煩了, 分組機制可以幫助我們在正則表達式中進行分組.</p><p>規定使用()進行分組, 這裡我們把字母和數字各分為一組"(\\d{3,5})([a-z]{2})"</p><p>然後在調用m.group(int group)方法時傳入組號即可</p><p>注意, 組號從0開始, 0組代表整個正則表達式, 從0之後, 就是在正則表達式中從左到右每一個左括號對應一個組. 在這個表達式中第1組是數字, 第2組是字母.</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;(\d{3,5})([a-z]{2})&#34;);//正則表達式為3~5個數字跟上兩個字母    String s = &#34;123aa-5423zx-642oi-00&#34;;    Matcher m = p.matcher(s);    while(m.find()){        p(m.group(1));    }}//輸出結果1235423642</code></pre><h1 class=pgc-h-arrow-right>實戰1: 抓取網頁中的email地址(爬蟲)</h1><p>假設我們手頭上有一些優質的資源, 打算分享給網友, 於是便到貼吧上發出一個留郵箱發資源的帖子. 沒想到網友熱情高漲, 留下了近百個郵箱. 但逐個複製發送太累了, 我們考慮用程序實現.</p><p>這裡不展開講發郵件部分, 重點應用已經學到的正則表達式從網頁中截取所有的郵箱地址.</p><p>首先獲取一個帖子的html代碼隨便找了一個, 點擊跳轉, 在瀏覽器中點擊右鍵保存html文件</p><p>接下來看代碼:</p><pre><code>public class Demo12 {    public static void main(String[] args) {        BufferedReader br = null;        try {            br = new BufferedReader(new FileReader(&#34;C:\emailTest.html&#34;));            String line = &#34;&#34;;            while((line = br.readLine()) != null){//讀取文件的每一行                parse(line);//解析其中的email地址            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            if(br != null){                try {                    br.close();                    br = null;                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }    private static void parse(String line){        Pattern p = Pattern.compile(&#34;[\w[.-]]+@[\w[.-]]+\.[\w]+&#34;);        Matcher m = p.matcher(line);        while(m.find()){            System.out.println(m.group());        }    }}//輸出結果2819531636@qq.com2819531636@qq.com2405059759@qq.com2405059759@qq.com1013376804@qq.com...</code></pre><h1 class=pgc-h-arrow-right>實戰2: 代碼統計小程序</h1><p>最後的一個實戰案例: 統計一個項目中一共有多少行代碼, 多少行註釋, 多少個空白行. 不妨對自己做過的項目進行統計, 發現不知不覺中也是個寫過成千上萬行代碼的人了…</p><p>我在github上挑選了一個項目, 是純java寫的小項目, 方便統計. 點擊跳轉</p><p>下面是具體的代碼, 除了判斷空行用了正則表達式外, 判斷代碼行和註釋行用了String類的api</p><pre><code>public class Demo13 {    private static long codeLines = 0;    private static long commentLines = 0;    private static long whiteLines = 0;    private static String filePath = &#34;C:\TankOnline&#34;;    public static void main(String[] args) {        process(filePath);        System.out.println(&#34;codeLines : &#34; + codeLines);        System.out.println(&#34;commentLines : &#34; + commentLines);        System.out.println(&#34;whiteLines : &#34; + whiteLines);    }    /**     * 遞歸查找文件     * @param pathStr     */    public static void process(String pathStr){        File file = new File(pathStr);        if(file.isDirectory()){//是文件夾則遞歸查找            File[] fileList = file.listFiles();            for(File f : fileList){                String fPath = f.getAbsolutePath();                process(fPath);            }        }else if(file.isFile()){//是文件則判斷是否是.java文件            if(file.getName().matches(&#34;.*\.java$&#34;)){                parse(file);            }        }    }    private static void parse(File file) {        BufferedReader br = null;        try {            br = new BufferedReader(new FileReader(file));            String line = &#34;&#34;;            while((line = br.readLine()) != null){                line = line.trim();//清空每行首尾的空格                if(line.matches(&#34;^[\s&amp;&amp;[^\n]]*$&#34;)){//注意不是以\n結尾, 因為在br.readLine()會去掉\n                    whiteLines++;                }else if(line.startsWith(&#34;/*&#34;) || line.startsWith(&#34;*&#34;) || line.endsWith(&#34;*/&#34;)){                    commentLines++;                }else if(line.startsWith(&#34;//&#34;) || line.contains(&#34;//&#34;)){                    commentLines++;                }else{                    if(line.startsWith(&#34;import&#34;) || line.startsWith(&#34;package&#34;)){//導包不算                        continue;                    }                    codeLines++;                }            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if(null != br){                try {                    br.close();                    br = null;                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}//輸出結果codeLines : 1139commentLines : 124whiteLines : 172</code></pre><h1 class=pgc-h-arrow-right>貪婪模式與非貪婪模式</h1><p>經過兩個實戰後, 相信大家已經掌握了正則表達式的基本使用了, 下面介紹貪婪模式與非貪婪模式.</p><p>通過查看官方api我們發現Pattern類中有如下定義:</p><pre><code>Greedy quantifiers 貪婪模式X?	X, once or not at allX*	X, zero or more timesX+	X, one or more timesX{n}	X, exactly n timesX{n,}	X, at least n timesX{n,m}	X, at least n but not more than m times Reluctant quantifiers 非貪婪模式(勉強的, 不情願的)X??	X, once or not at allX*?	X, zero or more timesX+?	X, one or more timesX{n}?	X, exactly n timesX{n,}?	X, at least n timesX{n,m}?	X, at least n but not more than m times Possessive quantifiers  獨佔模式X?+	X, once or not at allX*+	X, zero or more timesX++	X, one or more timesX{n}+	X, exactly n timesX{n,}+	X, at least n timesX{n,m}+	X, at least n but not more than m times</code></pre><p>這三種模式表達的意思是一樣的, 在前面的講解中我們全部使用的是貪婪模式. 那麼其他兩種模式的寫法有什麼區別呢? 通過下面的代碼示例進行講解.</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;.{3,10}[0-9]&#34;);    String s = &#34;aaaa5bbbb6&#34;;//10個字符    Matcher m = p.matcher(s);    if(m.find()){        System.out.println(m.start() + &#34; - &#34; + m.end());    }else {        System.out.println(&#34;not match!&#34;);    }}//輸出結果0 - 10</code></pre><p>正則表達式的意思是3~10個字符加一個數字. 在貪婪模式下匹配時, 系統會先吞掉10個字符, 這時檢查最後一個是否時數字, 發現已經沒有字符了, 於是吐出來一個字符, 再次匹配數字, 匹配成功, 得到0-10.</p><p>下面是非貪婪模式演示(勉強的, 不情願的)</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;.{3,10}?[0-9]&#34;);//添加了一個?    String s = &#34;aaaa5bbbb6&#34;;    Matcher m = p.matcher(s);    if(m.find()){        System.out.println(m.start() + &#34; - &#34; + m.end());    }else {        System.out.println(&#34;not match!&#34;);    }}//輸出結果0 - 5</code></pre><p>在非貪婪模式下, 首先只會吞掉3個(最少3個), 然後判斷後面一個是否是數字, 結果不是, 在往後吞一個字符, 繼續判斷後面的是否數字, 結果是, 輸出0-5</p><p>最後演示獨佔模式, 通常只在追求效率的情況下這麼做, 用得比較少</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;.{3,10}+[0-9]&#34;);//多了個+    String s = &#34;aaaa5bbbb6&#34;;    Matcher m = p.matcher(s);    if(m.find()){        System.out.println(m.start() + &#34; - &#34; + m.end());    }else {        System.out.println(&#34;not match!&#34;);    }}//輸出結果not match!</code></pre><p>獨佔模式會一下吞進10個字符, 然後判斷後一個是否是數字, 不管是否匹配成功它都不會繼續吞或者吐出一個字符.</p><h1 class=pgc-h-arrow-right>結束</h1><p>願正則表達式給你帶來更愉快的編程體驗.</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>正則</a></li><li><a>表達式</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2dd7ebf.html alt="Java 正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2dd7ebf.html title="Java 正則表達式">Java 正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22c24c31.html alt="Java 正則表達式 StackOverflowError 問題及其優化" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/28110ae7b0fc46f1a5ad2e6bcf0e40c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22c24c31.html title="Java 正則表達式 StackOverflowError 問題及其優化">Java 正則表達式 StackOverflowError 問題及其優化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/53f942fa.html alt=Java正則表達式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531051821759d2705acacc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/53f942fa.html title=Java正則表達式>Java正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0c20e1e.html alt=Java正則表達式介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0c20e1e.html title=Java正則表達式介紹>Java正則表達式介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5c2f2cd7.html alt=Java正則表達式模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d9eaa59ae704773aef9e0851d9625fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5c2f2cd7.html title=Java正則表達式模式>Java正則表達式模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38a1ca5a.html alt=Java正則表達式組 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cb895437221f4629a7a4f697a8ac9f7a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38a1ca5a.html title=Java正則表達式組>Java正則表達式組</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3836e27c.html alt=Java正則表達式Pattern和Matcher類詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535620668920d4515bfc5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3836e27c.html title=Java正則表達式Pattern和Matcher類詳解>Java正則表達式Pattern和Matcher類詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a6bedf3.html alt=Java正則表達式中的貪婪型、勉強型和佔有性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a3606c2e85b340e0bfa6b63a26ededff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a6bedf3.html title=Java正則表達式中的貪婪型、勉強型和佔有性>Java正則表達式中的貪婪型、勉強型和佔有性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d02df1d6.html alt=Java正則表達式入坑指南：正則表達式使用的類有哪些嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/00407db6c5d544f8aeb61c83d3f974eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d02df1d6.html title=Java正則表達式入坑指南：正則表達式使用的類有哪些嗎？>Java正則表達式入坑指南：正則表達式使用的類有哪些嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b27edec9.html alt=Java正則表達式大全詳解「收藏起來以後你一定會用的到的」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1537156478131e5dd12e2a4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b27edec9.html title=Java正則表達式大全詳解「收藏起來以後你一定會用的到的」>Java正則表達式大全詳解「收藏起來以後你一定會用的到的」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1e56bcc.html alt=Java正則表達式詳細解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/78591e5cc20e4b2197c16978c08ea890 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1e56bcc.html title=Java正則表達式詳細解析>Java正則表達式詳細解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2405cdf4.html alt=Java正則表達式詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bd26939e3f8248709b624e7cd38ac594 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2405cdf4.html title=Java正則表達式詳解>Java正則表達式詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c005517.html alt=Java程序員：一刻鐘精通正則表達式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c005517.html title=Java程序員：一刻鐘精通正則表達式>Java程序員：一刻鐘精通正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/806b0846.html alt=Java入門教程-日期和正則表達式入門 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15352845316194ba375faa7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/806b0846.html title=Java入門教程-日期和正則表達式入門>Java入門教程-日期和正則表達式入門</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html alt="java 常用的正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1540129072390e6c4c05126 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html title="java 常用的正則表達式">java 常用的正則表達式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>