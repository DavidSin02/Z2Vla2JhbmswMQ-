<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>5萬字、97 張圖總結操作系統核心知識點(下) | 极客快訊</title><meta property="og:title" content="5萬字、97 張圖總結操作系統核心知識點(下) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/c3b64f421acc45b2a147aa814c139b48"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aafa7dc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aafa7dc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aafa7dc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aafa7dc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aafa7dc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aafa7dc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aafa7dc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aafa7dc.html><meta property="article:published_time" content="2020-10-29T21:05:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:04+08:00"><meta name=Keywords content><meta name=description content="5萬字、97 張圖總結操作系統核心知識點(下)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/aafa7dc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>5萬字、97 張圖總結操作系統核心知識點(下)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>許多操作系統支持兩部分的文件名，它們之間用 . 分隔開，比如文件名 prog.c。原點後面的文件稱為 文件擴展名(file extension) ，文件擴展名通常表示文件的一些信息。一些常用的文件擴展名以及含義如下圖所示</p><p>擴展名含義bak備份文件cc 源程序文件gif符合圖形交換格式的圖像文件hlp幫助文件htmlWWW 超文本標記語言文檔jpg符合 JPEG 編碼標準的靜態圖片mp3符合 MP3 音頻編碼格式的音樂文件mpg符合 MPEG 編碼標準的電影o目標文件（編譯器輸出格式，尚未鏈接）pdfpdf 格式的文件psPostScript 文件tex為 TEX 格式化程序準備的輸入文件txt文本文件zip壓縮文件</p><p>在 UNIX 系統中，文件擴展名只是一種約定，操作系統並不強制採用。</p><h3>文件結構</h3><p>文件的構造有多種方式。下圖列出了常用的三種構造方式</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c3b64f421acc45b2a147aa814c139b48></p><p>三種不同的文件。 a) 字節序列 。b) 記錄序列。c) 樹</p><p>上圖中的 a 是一種無結構的字節序列，操作系統不關心序列的內容是什麼，操作系統能看到的就是字節(bytes)。其文件內容的任何含義只在用戶程序中進行解釋。UNIX 和 Windows 都採用這種辦法。</p><p>圖 b 表示在文件結構上的第一部改進。在這個模型中，文件是具有固定長度記錄的序列，每個記錄都有其內部結構。 把文件作為記錄序列的核心思想是：<strong>讀操作返回一個記錄，而寫操作重寫或者追加一個記錄</strong>。第三種文件結構如上圖 c 所示。在這種組織結構中，文件由一顆記錄樹構成，記錄樹的長度不一定相同，每個記錄樹都在記錄中的固定位置包含一個key 字段。這棵樹按 key 進行排序，從而可以對特定的 key 進行快速查找。</p><h3>文件類型</h3><p>很多操作系統支持多種文件類型。例如，UNIX（同樣包括 OS X）和 Windows 都具有常規的文件和目錄。除此之外，UNIX 還具有字符特殊文件(character special file) 和 塊特殊文件(block special file)。常規文件(Regular files) 是包含有用戶信息的文件。用戶一般使用的文件大都是常規文件，常規文件一般包括 <strong>可執行文件、文本文件、圖像文件</strong>，從常規文件讀取數據或將數據寫入時，內核會根據文件系統的規則執行操作，是寫入可能被延遲，記錄日誌或者接受其他操作。</p><h3>文件訪問</h3><p>早期的操作系統只有一種訪問方式：序列訪問(sequential access)。在這些系統中，進程可以按照順序讀取所有的字節或文件中的記錄，但是不能跳過並亂序執行它們。順序訪問文件是可以返回到起點的，需要時可以多次讀取該文件。當存儲介質是磁帶而不是磁盤時，順序訪問文件很方便。</p><p>在使用磁盤來存儲文件時，可以不按照順序讀取文件中的字節或者記錄，或者按照關鍵字而不是位置來訪問記錄。這種能夠以任意次序進行讀取的稱為隨機訪問文件(random access file)。許多應用程序都需要這種方式。</p><p>隨機訪問文件對許多應用程序來說都必不可少，例如，數據庫系統。如果乘客打電話預定某航班機票，訂票程序必須能夠直接訪問航班記錄，而不必先讀取其他航班的成千上萬條記錄。</p><p>有兩種方法可以指示從何處開始讀取文件。第一種方法是直接使用 read 從頭開始讀取。另一種是用一個特殊的 seek 操作設置當前位置，在 seek 操作後，從這個當前位置順序地開始讀文件。UNIX 和 Windows 使用的是後面一種方式。</p><h3>文件屬性</h3><p>文件包括文件名和數據。除此之外，所有的操作系統還會保存其他與文件相關的信息，如文件創建的日期和時間、文件大小。我們可以稱這些為文件的屬性(attributes)。有些人也喜歡把它們稱作 元數據(metadata)。文件的屬性在不同的系統中差別很大。文件的屬性只有兩種狀態：設置(set) 和 清除(clear)。</p><h3>文件操作</h3><p>使用文件的目的是用來存儲信息並方便以後的檢索。對於存儲和檢索，不同的系統提供了不同的操作。以下是與文件有關的最常用的一些系統調用：</p><ol><li>Create，創建不包含任何數據的文件。調用的目的是表示文件即將建立，並對文件設置一些屬性。</li><li>Delete，當文件不再需要，必須刪除它以釋放內存空間。為此總會有一個系統調用來刪除文件。</li><li>Open，在使用文件之前，必須先打開文件。這個調用的目的是允許系統將屬性和磁盤地址列表保存到主存中，用來以後的快速訪問。</li><li>Close，當所有進程完成時，屬性和磁盤地址不再需要，因此應關閉文件以釋放表空間。很多系統限制進程打開文件的個數，以此達到鼓勵用戶關閉不再使用的文件。磁盤以塊為單位寫入，關閉文件時會強制寫入最後一塊，即使這個塊空間內部還不滿。</li><li>Read，數據從文件中讀取。通常情況下，讀取的數據來自文件的當前位置。調用者必須指定需要讀取多少數據，並且提供存放這些數據的緩衝區。</li><li>Write，向文件寫數據，寫操作一般也是從文件的當前位置開始進行。如果當前位置是文件的末尾，則會直接追加進行寫入。如果當前位置在文件中，則現有數據被覆蓋，並且永遠消失。</li><li>append，使用 append 只能向文件末尾添加數據。</li><li>seek，對於隨機訪問的文件，要指定從何處開始獲取數據。通常的方法是用 seek 系統調用把當前位置指針指向文件中的特定位置。seek 調用結束後，就可以從指定位置開始讀寫數據了。</li><li>get attributes，進程運行時通常需要讀取文件屬性。</li><li>set attributes，用戶可以自己設置一些文件屬性，甚至是在文件創建之後，實現該功能的是 set attributes 系統調用。</li><li>rename，用戶可以自己更改已有文件的名字，rename 系統調用用於這一目的。</li></ol><h2>目錄</h2><p>文件系統通常提供目錄(directories) 或者 文件夾(folders) 用於記錄文件的位置，在很多系統中目錄本身也是文件，下面我們會討論關於文件，他們的組織形式、屬性和可以對文件進行的操作。</p><h3>一級目錄系統</h3><p>目錄系統最簡單的形式是有一個能夠包含所有文件的目錄。這種目錄被稱為根目錄(root directory)，由於根目錄的唯一性，所以其名稱並不重要。在最早期的個人計算機中，這種系統很常見，部分原因是因為只有一個用戶。下面是一個單層目錄系統的例子</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2a24803e23548338ea91c4fa5606504></p><p>含有四個文件的單層目錄系統</p><p>該目錄中有四個文件。這種設計的優點在於簡單，並且能夠快速定位文件，畢竟只有一個地方可以檢索。這種目錄組織形式現在一般用於簡單的嵌入式設備（如數碼相機和某些便攜式音樂播放器）上使用。</p><h3>層次目錄系統</h3><p>對於簡單的應用而言，一般都用單層目錄方式，但是這種組織形式並不適合於現代計算機，因為現代計算機含有成千上萬個文件和文件夾。如果都放在根目錄下，查找起來會非常困難。為了解決這一問題，出現了層次目錄系統(Hierarchical Directory Systems)，也稱為目錄樹。通過這種方式，可以用很多目錄把文件進行分組。進而，如果多個用戶共享同一個文件服務器，比如公司的網絡系統，每個用戶可以為自己的目錄樹擁有自己的私人根目錄。這種方式的組織結構如下</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3e46dad6c0a944118a7b44da03d30af7></p><p>根目錄含有目錄 A、B 和 C ，分別屬於不同的用戶，其中兩個用戶個字創建了子目錄。用戶可以創建任意數量的子目錄，現代文件系統都是按照這種方式組織的。</p><h3>路徑名</h3><p>當目錄樹組織文件系統時，需要有某種方法指明文件名。常用的方法有兩種，第一種方式是每個文件都會用一個絕對路徑名(absolute path name)，它由根目錄到文件的路徑組成。</p><p>另外一種指定文件名的方法是 相對路徑名(relative path name)。它常常和 工作目錄(working directory) （也稱作 當前目錄(current directory)）一起使用。用戶可以指定一個目錄作為當前工作目錄。例如，如果當前目錄是 /usr/ast，那麼絕對路徑 /usr/ast/mailbox可以直接使用 mailbox 來引用。</p><h3>目錄操作</h3><p>不同文件中管理目錄的系統調用的差別比管理文件的系統調用差別大。為了瞭解這些系統調用有哪些以及它們怎樣工作，下面給出一個例子（取自 UNIX）。</p><ol><li>Create，創建目錄，除了目錄項 . 和 .. 外，目錄內容為空。</li><li>Delete，刪除目錄，只有空目錄可以刪除。只包含 . 和 .. 的目錄被認為是空目錄，這兩個目錄項通常不能刪除</li><li>opendir，目錄內容可被讀取。例如，未列出目錄中的全部文件，程序必須先打開該目錄，然後讀其中全部文件的文件名。與打開和讀文件相同，在讀目錄前，必須先打開文件。</li><li>closedir，讀目錄結束後，應該關閉目錄用於釋放內部表空間。</li><li>readdir，系統調用 readdir 返回打開目錄的下一個目錄項。以前也採用 read 系統調用來讀取目錄，但是這種方法有一個缺點：程序員必須瞭解和處理目錄的內部結構。相反，不論採用哪一種目錄結構，readdir 總是以標準格式返回一個目錄項。</li><li>rename，在很多方面目錄和文件都相似。文件可以更換名稱，目錄也可以。</li><li>link，鏈接技術允許在多個目錄中出現同一個文件。這個系統調用指定一個存在的文件和一個路徑名，並建立從該文件到路徑所指名字的鏈接。這樣，可以在多個目錄中出現同一個文件。有時也被稱為硬鏈接(hard link)。</li><li>unlink，刪除目錄項。如果被解除鏈接的文件只出現在一個目錄中，則將它從文件中刪除。如果它出現在多個目錄中，則只刪除指定路徑名的鏈接，依然保留其他路徑名的鏈接。在 UNIX 中，用於刪除文件的系統調用就是 unlink。</li></ol><h2>文件系統的實現</h2><h3>文件系統佈局</h3><p>文件系統存儲在磁盤中。大部分的磁盤能夠劃分出一到多個分區，叫做磁盤分區(disk partitioning) 或者是磁盤分片(disk slicing)。每個分區都有獨立的文件系統，每塊分區的文件系統可以不同。磁盤的 0 號分區稱為 主引導記錄(Master Boot Record, MBR)，用來引導(boot) 計算機。在 MBR 的結尾是分區表(partition table)。每個分區表給出每個分區由開始到結束的地址。</p><p>當計算機開始引 boot 時，BIOS 讀入並執行 MBR。</p><h4>引導塊</h4><p>MBR 做的第一件事就是確定活動分區，讀入它的第一個塊，稱為引導塊(boot block) 並執行。引導塊中的程序將加載分區中的操作系統。為了一致性，每個分區都會從引導塊開始，即使引導塊不包含操作系統。引導塊佔據文件系統的前 4096 個字節，從磁盤上的字節偏移量 0 開始。引導塊可用於啟動操作系統。</p><p>除了從引導塊開始之外，磁盤分區的佈局是隨著文件系統的不同而變化的。通常文件系統會包含一些屬性，如下</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/89d97a18f0744531bb5f368a86b309c7></p><p>文件系統佈局</p><h4>超級塊</h4><p>緊跟在引導塊後面的是 超級塊(Superblock)，超級塊 的大小為 4096 字節，從磁盤上的字節偏移 4096 開始。超級塊包含文件系統的所有關鍵參數</p><ul><li>文件系統的大小</li><li>文件系統中的數據塊數</li><li>指示文件系統狀態的標誌</li><li>分配組大小</li></ul><p>在計算機啟動或者文件系統首次使用時，超級塊會被讀入內存。</p><h4>空閒空間塊</h4><p>接著是文件系統中空閒塊的信息，例如，可以用位圖或者指針列表的形式給出。</p><p><strong>BitMap 位圖或者 Bit vector 位向量</strong></p><p>位圖或位向量是一系列位或位的集合，其中每個位對應一個磁盤塊，該位可以採用兩個值：0和1，0表示已分配該塊，而1表示一個空閒塊。下圖中的磁盤上給定的磁盤塊實例（分配了綠色塊）可以用16位的位圖表示為：0000111000000110。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a982e6c7a5614dccb30620b2d2b208c0></p><p><strong>使用鏈表進行管理</strong></p><p>在這種方法中，空閒磁盤塊鏈接在一起，即一個空閒塊包含指向下一個空閒塊的指針。第一個磁盤塊的塊號存儲在磁盤上的單獨位置，也緩存在內存中。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/218048728e3f489f9e1378a777c69a01></p><h4>碎片</h4><p>這裡不得不提一個叫做碎片(fragment)的概念，也稱為片段。一般零散的單個數據通常稱為片段。 磁盤塊可以進一步分為固定大小的分配單元，片段只是在驅動器上彼此不相鄰的文件片段。</p><h4>inode</h4><p>然後在後面是一個 inode(index node)，也稱作索引節點。它是一個數組的結構，每個文件有一個 inode，inode 非常重要，它說明了文件的方方面面。每個索引節點都存儲對象數據的屬性和磁盤塊位置</p><p>有一種簡單的方法可以找到它們 ls -lai 命令。讓我們看一下根文件系統：</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f59649bbbbc4f8f86d98cbf531ce747></p><p>inode 節點主要包括了以下信息</p><ul><li>模式/權限（保護）</li><li>所有者 ID</li><li>組 ID</li><li>文件大小</li><li>文件的硬鏈接數</li><li>上次訪問時間</li><li>最後修改時間</li><li>inode 上次修改時間</li></ul><p>文件分為兩部分，索引節點和塊。一旦創建後，每種類型的塊數是固定的。你不能增加分區上 inode 的數量，也不能增加磁盤塊的數量。</p><p>緊跟在 inode 後面的是根目錄，它存放的是文件系統目錄樹的根部。最後，磁盤的其他部分存放了其他所有的目錄和文件。</p><h3>文件的實現</h3><p>最重要的問題是記錄各個文件分別用到了哪些磁盤塊。不同的系統採用了不同的方法。下面我們會探討一下這些方式。分配背後的主要思想是有效利用文件空間和快速訪問文件 ，主要有三種分配方案</p><ul><li>連續分配</li><li>鏈表分配</li><li>索引分配</li></ul><h4>連續分配</h4><p>最簡單的分配方案是把每個文件作為一連串連續數據塊存儲在磁盤上。因此，在具有 1KB 塊的磁盤上，將為 50 KB 文件分配 50 個連續塊。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/222088ceb9eb4f79a4a41f91dd16f355></p><p>使用連續空間存儲文件</p><p>上面展示了 40 個連續的內存塊。從最左側的 0 塊開始。初始狀態下，還沒有裝載文件，因此磁盤是空的。接著，從磁盤開始處（塊 0 ）處開始寫入佔用 4 塊長度的內存 A 。然後是一個佔用 6 塊長度的內存 B，會直接在 A 的末尾開始寫。</p><p>注意每個文件都會在新的文件塊開始寫，所以如果文件 A 只佔用了 3 又 1/2 個塊，那麼最後一個塊的部分內存會被浪費。在上面這幅圖中，總共展示了 7 個文件，每個文件都會從上個文件的末尾塊開始寫新的文件塊。</p><p>連續的磁盤空間分配有兩個優點。</p><ul><li><p>第一，連續文件存儲實現起來比較簡單，只需要記住兩個數字就可以：一個是第一個塊的文件地址和文件的塊數量。給定第一個塊的編號，可以通過簡單的加法找到任何其他塊的編號。</p></li><li><p>第二點是讀取性能比較強，可以通過一次操作從文件中讀取整個文件。只需要一次尋找第一個塊。後面就不再需要尋道時間和旋轉延遲，所以數據會以全帶寬進入磁盤。</p></li></ul><p>因此，連續的空間分配具有實現簡單、高性能的特點。</p><p>不幸的是，連續空間分配也有很明顯的不足。隨著時間的推移，磁盤會變得很零碎。下圖解釋了這種現象</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0c53ae48cc7f4e20b661ef3ffc8077bd></p><p>這裡有兩個文件 D 和 F 被刪除了。當刪除一個文件時，此文件所佔用的塊也隨之釋放，就會在磁盤空間中留下一些空閒塊。磁盤並不會在這個位置擠壓掉空閒塊，因為這會複製空閒塊之後的所有文件，可能會有上百萬的塊，這個量級就太大了。</p><h4>鏈表分配</h4><p>第二種存儲文件的方式是為每個文件構造磁盤塊鏈表，每個文件都是磁盤塊的鏈接列表，就像下面所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/948c98dc6bda4fb896a71eb13f0ece18></p><p>以磁盤塊的鏈表形式存儲文件</p><p>每個塊的第一個字作為指向下一塊的指針，塊的其他部分存放數據。如果上面這張圖你看的不是很清楚的話，可以看看整個的鏈表分配方案</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5649967181704df386a0b2bf46ec271d></p><p>與連續分配方案不同，這一方法可以充分利用每個磁盤塊。除了最後一個磁盤塊外，不會因為磁盤碎片而浪費存儲空間。同樣，在目錄項中，只要存儲了第一個文件塊，那麼其他文件塊也能夠被找到。</p><p>另一方面，在鏈表的分配方案中，儘管順序讀取非常方便，但是隨機訪問卻很困難（這也是數組和鏈表數據結構的一大區別）。</p><p>還有一個問題是，由於指針會佔用一些字節，每個磁盤塊實際存儲數據的字節數並不再是 2 的整數次冪。雖然這個問題並不會很嚴重，但是這種方式降低了程序運行效率。許多程序都是以長度為 2 的整數次冪來讀寫磁盤，由於每個塊的前幾個字節被指針所使用，所以要讀出一個完成的塊大小信息，就需要當前塊的信息和下一塊的信息拼湊而成，因此就引發了查找和拼接的開銷。</p><h4>使用內存表進行鏈表分配</h4><p>由於連續分配和鏈表分配都有其不可忽視的缺點。所以提出了使用內存中的表來解決分配問題。取出每個磁盤塊的指針字，把它們放在內存的一個表中，就可以解決上述鏈表的兩個不足之處。下面是一個例子</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cc0b74be10f84aadb3993316b79e69ea></p><p>上圖表示了鏈表形成的磁盤塊的內容。這兩個圖中都有兩個文件，文件 A 依次使用了磁盤塊地址 <strong>4、7、 2、 10、 12</strong>，文件 B 使用了<strong>6、3、11 和 14</strong>。也就是說，文件 A 從地址 4 處開始，順著鏈表走就能找到文件 A 的全部磁盤塊。同樣，從第 6 塊開始，順著鏈走到最後，也能夠找到文件 B 的全部磁盤塊。你會發現，這兩個鏈表都以不屬於有效磁盤編號的特殊標記（-1）結束。內存中的這種表格稱為 文件分配表(File Application Table,FAT)。</p><h3>目錄的實現</h3><p>文件只有打開後才能夠被讀取。在文件打開後，操作系統會使用用戶提供的路徑名來定位磁盤中的目錄。目錄項提供了查找文件磁盤塊所需要的信息。根據系統的不同，提供的信息也不同，可能提供的信息是整個文件的磁盤地址，或者是第一個塊的數量（兩個鏈表方案）或 inode的數量。不過不管用那種情況，目錄系統的主要功能就是 <strong>將文件的 ASCII 碼的名稱映射到定位數據所需的信息上</strong>。</p><h3>共享文件</h3><p>當多個用戶在同一個項目中工作時，他們通常需要共享文件。如果這個共享文件同時出現在多個用戶目錄下，那麼他們協同工作起來就很方便。下面的這張圖我們在上面提到過，但是有一個更改的地方，就是 <strong>C 的一個文件也出現在了 B 的目錄下</strong>。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e68da3bb691c40639af2dd3b190517bc></p><p>如果按照如上圖的這種組織方式而言，那麼 B 的目錄與該共享文件的聯繫稱為 鏈接(link)。那麼文件系統現在就是一個 有向無環圖(Directed Acyclic Graph, 簡稱 DAG)，而不是一棵樹了。</p><h3>日誌結構文件系統</h3><p>技術的改變會給當前的文件系統帶來壓力。這種情況下，CPU 會變得越來越快，磁盤會變得越來越大並且越來越便宜（但不會越來越快）。內存容量也是以指數級增長。但是磁盤的尋道時間（除了固態盤，因為固態盤沒有尋道時間）並沒有獲得提高。</p><p>為此，Berkeley 設計了一種全新的文件系統，試圖緩解這個問題，這個文件系統就是 日誌結構文件系統(Log-structured File System, LFS)。旨在解決以下問題。</p><ul><li><p>不斷增長的系統內存</p></li><li><p>順序 I/O 性能勝過隨機 I/O 性能</p></li><li><p>現有低效率的文件系統</p></li><li><p>文件系統不支持 RAID（虛擬化）</p></li></ul><p>另一方面，當時的文件系統不論是 UNIX 還是 FFS，都有大量的隨機讀寫（在 FFS 中創建一個新文件至少需要5次隨機寫），因此成為整個系統的性能瓶頸。同時因為 Page cache的存在，作者認為隨機讀不是主要問題：隨著越來越大的內存，大部分的讀操作都能被 cache，因此 LFS 主要要解決的是減少對硬盤的隨機寫操作。</p><p>在這種設計中，inode 甚至具有與 UNIX 中相同的結構，但是現在它們分散在整個日誌中，而不是位於磁盤上的固定位置。所以，inode 很定位。為了能夠找到 inode ，維護了一個由 inode 索引的 inode map(inode 映射)。表項 i 指向磁盤中的第 i 個 inode 。這個映射保存在磁盤中，但是也保存在緩存中，因此，使用最頻繁的部分大部分時間都在內存中。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aea937d3e5f24209b7c75d982ea57d23></p><p>到目前為止，所有寫入最初都緩存在內存中，並且追加在日誌末尾，所有緩存的寫入都定期在單個段中寫入磁盤。所以，現在打開文件也就意味著用映射定位文件的索引節點。一旦 inode 被定位後，磁盤塊的地址就能夠被找到。所有這些塊本身都將位於日誌中某處的分段中。</p><p>真實情況下的磁盤容量是有限的，所以最終日誌會佔滿整個磁盤空間，這種情況下就會出現沒有新的磁盤塊被寫入到日誌中。幸運的是，許多現有段可能具有不再需要的塊。例如，如果一個文件被覆蓋了，那麼它的 inode 將被指向新的塊，但是舊的磁盤塊仍在先前寫入的段中佔據著空間。</p><p>為了處理這個問題，LFS 有一個清理(clean)線程，它會循環掃描日誌並對日誌進行壓縮。首先，通過查看日誌中第一部分的信息來查看其中存在哪些索引節點和文件。它會檢查當前 inode 的映射來查看 inode 否在在當前塊中，是否仍在被使用。如果不是，該信息將被丟棄。如果仍然在使用，那麼 inode 和塊就會進入內存等待寫回到下一個段中。然後原來的段被標記為空閒，以便日誌可以用來存放新的數據。用這種方法，清理線程遍歷日誌，從後面移走舊的段，然後將有效的數據放入內存等待寫到下一個段中。由此一來整個磁盤會形成一個大的環形緩衝區，寫線程將新的段寫在前面，而清理線程則清理後面的段。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/17650080b5574f26963628d1769ad0fd></p><h3>日誌文件系統</h3><p>雖然日誌結構系統的設計很優雅，但是由於它們和現有的文件系統不相匹配，因此還沒有廣泛使用。不過，從日誌文件結構系統衍生出來一種新的日誌系統，叫做日誌文件系統，它會記錄系統下一步將要做什麼的日誌。微軟的 NTFS 文件系統、Linux 的 ext3 就使用了此日誌。 OS X 將日誌系統作為可供選項。為了看清它是如何工作的，我們下面討論一個例子，比如 移除文件 ，這個操作在 UNIX 中需要三個步驟完成：</p><ul><li>在目錄中刪除文件</li><li>釋放 inode 到空閒 inode 池</li><li>將所有磁盤塊歸還給空閒磁盤池。</li></ul><h3>虛擬文件系統</h3><p>UNIX 操作系統使用一種 虛擬文件系統(Virtual File System, VFS) 來嘗試將多種文件系統構成一個有序的結構。關鍵的思想是抽象出所有文件系統都共有的部分，並將這部分代碼放在一層，這一層再調用具體文件系統來管理數據。下面是一個 VFS 的系統結構</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d0a95884c71b41dc9662d74fcd797440></p><p>還是那句經典的話，在計算機世界中，任何解決不了的問題都可以加個代理來解決。所有和文件相關的系統調用在最初的處理上都指向虛擬文件系統。這些來自用戶進程的調用，都是標準的 POSIX 系統調用，比如 open、read、write 和 seek 等。VFS 對用戶進程有一個 上層 接口，這個接口就是著名的 POSIX 接口。</p><h2>文件系統的管理和優化</h2><p>能夠使文件系統工作是一回事，能夠使文件系統高效、穩定的工作是另一回事，下面我們就來探討一下文件系統的管理和優化。</p><h3>磁盤空間管理</h3><p>文件通常存在磁盤中，所以如何管理磁盤空間是一個操作系統的設計者需要考慮的問題。在文件上進行存有兩種策略：<strong>分配 n 個字節的連續磁盤空間；或者把文件拆分成多個並不一定連續的塊</strong>。在存儲管理系統中，主要有分段管理和 分頁管理 兩種方式。</p><p>正如我們所看到的，按連續字節序列存儲文件有一個明顯的問題，當文件擴大時，有可能需要在磁盤上移動文件。內存中分段也有同樣的問題。不同的是，相對於把文件從磁盤的一個位置移動到另一個位置，內存中段的移動操作要快很多。因此，幾乎所有的文件系統都把文件分割成固定大小的塊來存儲。</p><h4>塊大小</h4><p>一旦把文件分為固定大小的塊來存儲，就會出現問題，塊的大小是多少？按照<strong>磁盤組織方式，扇區、磁道和柱面顯然都可以作為分配單位</strong>。在分頁系統中，分頁大小也是主要因素。</p><p>擁有大的塊尺寸意味著每個文件，甚至 1 字節文件，都要佔用一個柱面空間，也就是說小文件浪費了大量的磁盤空間。另一方面，小塊意味著大部分文件將會跨越多個塊，因此需要多次搜索和旋轉延遲才能讀取它們，從而降低了性能。因此，如果分配的塊太大會浪費空間；分配的塊太小會浪費時間。</p><h4>記錄空閒塊</h4><p>一旦指定了塊大小，下一個問題就是怎樣跟蹤空閒塊。有兩種方法被廣泛採用，如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2ac0c0a457ac4e2c970d9fcbd36c0199></p><p>第一種方法是採用磁盤塊鏈表，鏈表的每個塊中包含極可能多的空閒磁盤塊號。對於 1 KB 的塊和 32 位的磁盤塊號，空閒表中每個塊包含有 255 個空閒的塊號。考慮 1 TB 的硬盤，擁有大概十億個磁盤塊。為了存儲全部地址塊號，如果每塊可以保存 255 個塊號，則需要將近 400 萬個塊。通常，空閒塊用於保存空閒列表，因此存儲基本上是空閒的。</p><p>另一種空閒空間管理的技術是位圖(bitmap)，n 個塊的磁盤需要 n 位位圖。在位圖中，空閒塊用 1 表示，已分配的塊用 0 表示。對於 1 TB 硬盤的例子，需要 10 億位表示，即需要大約 130 000 個 1 KB 塊存儲。很明顯，和 32 位鏈表模型相比，位圖需要的空間更少，因為每個塊使用 1 位。只有當磁盤快滿的時候，鏈表需要的塊才會比位圖少。</p><h3>磁盤配額</h3><p>為了防止一些用戶佔用太多的磁盤空間，多用戶操作通常提供一種磁盤配額(enforcing disk quotas)的機制。系統管理員為每個用戶分配<strong>最大的文件和塊分配</strong>，並且操作系統確保用戶不會超過其配額。我們下面會談到這一機制。</p><p>在用戶打開一個文件時，操作系統會找到文件屬性和磁盤地址，並把它們送入內存中的打開文件表。其中一個屬性告訴文件所有者是誰。任何有關文件的增加都會記到所有者的配額中。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c74482a4d9214a47b68ecca52d096a40></p><p>配額表中記錄了每個用戶的配額</p><p>第二張表包含了每個用戶當前打開文件的配額記錄，即使是其他人打開該文件也一樣。如上圖所示，該表的內容是從被打開文件的所有者的磁盤配額文件中提取出來的。當所有文件關閉時，該記錄被寫回配額文件。</p><p>當在打開文件表中建立一新表項時，會產生一個指向所有者配額記錄的指針。每次向文件中添加一個塊時，文件所有者所用數據塊的總數也隨之增加，並會同時增加硬限制和軟限制的檢查。可以超出軟限制，但硬限制不可以超出。當已達到硬限制時，再往文件中添加內容將引發錯誤。同樣，對文件數目也存在類似的檢查。</p><h3>文件系統備份</h3><p>做文件備份很耗費時間而且也很浪費空間，這會引起下面幾個問題。首先，是要<strong>備份整個文件還是僅備份一部分呢</strong>？一般來說，只是備份特定目錄及其下的全部文件，而不是備份整個文件系統。</p><p>其次，對上次未修改過的文件再進行備份是一種浪費，因而產生了一種增量轉儲(incremental dumps) 的思想。最簡單的增量轉儲的形式就是週期性的做全面的備份，而每天只對增量轉儲完成後發生變化的文件做單個備份。</p><p>稍微好一點的方式是隻備份最近一次轉儲以來更改過的文件。當然，這種做法極大的縮減了轉儲時間，但恢復起來卻更復雜，因為<strong>最近的全面轉儲先要全部恢復，隨後按逆序進行增量轉儲</strong>。為了方便恢復，人們往往使用更復雜的轉儲模式。</p><p>第三，既然待轉儲的往往是海量數據，那麼在將其寫入磁帶之前對文件進行壓縮就很有必要。但是，如果在備份過程中出現了文件損壞的情況，就會導致破壞壓縮算法，從而使整個磁帶無法讀取。所以在備份前是否進行文件壓縮需慎重考慮。</p><p>第四，對正在使用的文件系統做備份是很難的。如果在轉儲過程中要添加，刪除和修改文件和目錄，則轉儲結果可能不一致。因此，因為轉儲過程中需要花費數個小時的時間，所以有必要在晚上將系統脫機進行備份，然而這種方式的接受程度並不高。所以，人們修改了轉儲算法，記下文件系統的瞬時快照，即複製關鍵的數據結構，然後需要把將來對文件和目錄所做的修改複製到塊中，而不是到處更新他們。</p><p>磁盤轉儲到備份磁盤上有兩種方案：<strong>物理轉儲和邏輯轉儲</strong>。物理轉儲(physical dump) 是從磁盤的 0 塊開始，依次將所有磁盤塊按照順序寫入到輸出磁盤，並在複製最後一個磁盤時停止。這種程序的萬無一失性是其他程序所不具備的。</p><p>第二個需要考慮的是<strong>壞塊的轉儲</strong>。製造大型磁盤而沒有瑕疵是不可能的，所以也會存在一些壞塊(bad blocks)。有時進行低級格式化後，壞塊會被檢測出來並進行標記，這種情況的解決辦法是用磁盤末尾的一些空閒塊所替換。</p><p>然而，一些塊在格式化後會變壞，在這種情況下操作系統可以檢測到它們。通常情況下，它可以通過創建一個由所有壞塊組成的文件來解決問題，確保它們不會出現在空閒池中並且永遠不會被分配。<strong>那麼此文件是完全不可讀的</strong>。如果磁盤控制器將所有的壞塊重新映射，物理轉儲還是能夠正常工作的。</p><p>Windows 系統有分頁文件(paging files) 和 休眠文件(hibernation files) 。它們在文件還原時不發揮作用，同時也不應該在第一時間進行備份。</p><h3>文件系統的一致性</h3><p>影響可靠性的一個因素是文件系統的一致性。許多文件系統讀取磁盤塊、修改磁盤塊、再把它們寫回磁盤。如果系統在所有塊寫入之前崩潰，文件系統就會處於一種不一致(inconsistent)的狀態。如果某些尚未寫回的塊是索引節點塊，目錄塊或包含空閒列表的塊，則此問題是很嚴重的。</p><p>為了處理文件系統一致性問題，大部分計算機都會有應用程序來檢查文件系統的一致性。例如，UNIX 有 fsck；Windows 有 sfc，每當引導系統時（尤其是在崩潰後），都可以運行該程序。</p><p>可以進行兩種一致性檢查：<strong>塊的一致性檢查和文件的一致性檢查</strong>。為了檢查塊的一致性，應用程序會建立兩張表，每個包含一個計數器的塊，最初設置為 0 。第一個表中的計數器跟蹤該塊在文件中出現的次數，第二張表中的計數器記錄每個塊在空閒列表、空閒位圖中出現的頻率。</p><h3>文件系統性能</h3><p>訪問磁盤的效率要比內存滿的多，是時候又祭出這張圖了</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a0c5787519594653a225b813b2a68275></p><p>從內存讀一個 32 位字大概是 10ns，從硬盤上讀的速率大概是 100MB/S，對每個 32 位字來說，效率會慢了四倍，另外，還要加上 5 - 10 ms 的尋道時間等其他損耗，如果只訪問一個字，內存要比磁盤快百萬數量級。所以磁盤優化是很有必要的，下面我們會討論幾種優化方式</p><h4>高速緩存</h4><p>最常用的減少磁盤訪問次數的技術是使用 塊高速緩存(block cache) 或者 緩衝區高速緩存(buffer cache)。高速緩存指的是一系列的塊，它們在邏輯上屬於磁盤，但實際上基於性能的考慮被保存在內存中。</p><p>管理高速緩存有不同的算法，常用的算法是：檢查全部的讀請求，查看在高速緩存中是否有所需要的塊。如果存在，可執行讀操作而無須訪問磁盤。如果檢查塊不再高速緩存中，那麼首先把它讀入高速緩存，再複製到所需的地方。之後，對同一個塊的請求都通過高速緩存來完成。</p><p>高速緩存的操作如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b305f4cafc6b47faadd60877bde674e4></p><p>由於在高速緩存中有許多塊，所以需要某種方法快速確定所需的塊是否存在。常用方法是將設備和磁盤地址進行散列操作，然後，在散列表中查找結果。具有相同散列值的塊在一個鏈表中連接在一起（這個數據結構是不是很像 HashMap?），這樣就可以沿著衝突鏈查找其他塊。</p><p>如果高速緩存已滿，此時需要調入新的塊，則要把原來的某一塊調出高速緩存，如果要調出的塊在上次調入後已經被修改過，則需要把它寫回磁盤。</p><h4>塊提前讀</h4><p>第二個明顯提高文件系統的性能是，在需要用到塊之前，試圖提前將其寫入高速緩存，從而提高命中率。許多文件都是順序讀取。如果請求文件系統在某個文件中生成塊 k，文件系統執行相關操作並且在完成之後，會檢查高速緩存，以便確定塊 k + 1 是否已經在高速緩存。如果不在，文件系統會為 k + 1 安排一個預讀取，因為文件希望在用到該塊的時候能夠直接從高速緩存中讀取。</p><p>當然，塊提前讀取策略只適用於實際順序讀取的文件。對隨機訪問的文件，提前讀絲毫不起作用。甚至還會造成阻礙。</p><h4>減少磁盤臂運動</h4><p>高速緩存和塊提前讀並不是提高文件系統性能的唯一方法。另一種重要的技術是<strong>把有可能順序訪問的塊放在一起，當然最好是在同一個柱面上，從而減少磁盤臂的移動次數</strong>。當寫一個輸出文件時，文件系統就必須按照要求一次一次地分配磁盤塊。如果用位圖來記錄空閒塊，並且整個位圖在內存中，那麼選擇與前一塊最近的空閒塊是很容易的。如果用空閒表，並且鏈表的一部分存在磁盤上，要分配緊鄰的空閒塊就會困難很多。</p><h4>磁盤碎片整理</h4><p>在初始安裝操作系統後，文件就會被不斷的創建和清除，於是磁盤會產生很多的碎片，在創建一個文件時，它使用的塊會散佈在整個磁盤上，降低性能。刪除文件後，回收磁盤塊，可能會造成空穴。</p><p>磁盤性能可以通過如下方式恢復：移動文件使它們相互挨著，並把所有的至少是大部分的空閒空間放在一個或多個大的連續區域內。Windows 有一個程序 defrag 就是做這個事兒的。Windows 用戶會經常使用它，SSD 除外。</p><p>磁盤碎片整理程序會在讓文件系統上很好地運行。Linux 文件系統（特別是 ext2 和 ext3）由於其選擇磁盤塊的方式，在磁盤碎片整理上一般不會像 Windows 一樣困難，因此很少需要手動的磁盤碎片整理。而且，固態硬盤並不受磁盤碎片的影響，事實上，在固態硬盤上做磁盤碎片整理反倒是多此一舉，不僅沒有提高性能，反而磨損了固態硬盤。所以碎片整理只會縮短固態硬盤的壽命。</p><p>下面我們來探討一下 I/O 流程問題。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d59c12ec19614be39cdeb38e7eb0fd3d></p><h2>I/O 設備</h2><p>什麼是 I/O 設備？I/O 設備又叫做輸入/輸出設備，它是人類用來和計算機進行通信的外部硬件。輸入/輸出設備能夠向計算機發送數據（輸出）並從計算機接收數據（輸入）。</p><p>I/O 設備(I/O devices)可以分成兩種：塊設備(block devices) 和 字符設備(character devices)。</p><h4>塊設備</h4><p>塊設備是一個能存儲固定大小塊信息的設備，它支持<strong>以固定大小的塊，扇區或群集讀取和（可選）寫入數據</strong>。每個塊都有自己的物理地址。通常塊的大小在 512 - 65536 之間。所有傳輸的信息都會以連續的塊為單位。塊設備的基本特徵是每個塊都較為對立，能夠獨立的進行讀寫。常見的塊設備有 <strong>硬盤、藍光光盤、USB 盤</strong></p><p>與字符設備相比，塊設備通常需要較少的引腳。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9baccacddadb48cb9b16d21e2ee85c78></p><h4>塊設備的缺點</h4><p>基於給定固態存儲器的塊設備比基於相同類型的存儲器的字節尋址要慢一些，因為必須在塊的開頭開始讀取或寫入。所以，要讀取該塊的任何部分，必須尋找到該塊的開始，讀取整個塊，如果不使用該塊，則將其丟棄。要寫入塊的一部分，必須尋找到塊的開始，將整個塊讀入內存，修改數據，再次尋找到塊的開頭處，然後將整個塊寫回設備。</p><h4>字符設備</h4><p>另一類 I/O 設備是字符設備。字符設備以字符為單位發送或接收一個字符流，而不考慮任何塊結構。字符設備是不可尋址的，也沒有任何尋道操作。常見的字符設備有 <strong>打印機、網絡設備、鼠標、以及大多數與磁盤不同的設備</strong>。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2b00cb9bc66044a68619aeacda21680d></p><h3>設備控制器</h3><p>設備控制器是處理 CPU 傳入和傳出信號的系統。設備通過插頭和插座連接到計算機，並且插座連接到設備控制器。設備控制器從連接的設備處接收數據，並將其存儲在控制器內部的一些特殊目的寄存器(special purpose registers) 也就是本地緩衝區中。</p><p>每個設備控制器都會有一個應用程序與之對應，設備控制器通過應用程序的接口通過中斷與操作系統進行通信。設備控制器是硬件，而設備驅動程序是軟件。</p><h3>內存映射 I/O</h3><p>每個控制器都會有幾個寄存器用來和 CPU 進行通信。通過寫入這些寄存器，操作系統可以命令設備發送數據，接收數據、開啟或者關閉設備等。通過從這些寄存器中讀取信息，操作系統能夠知道設備的狀態，是否準備接受一個新命令等。</p><p>為了控制寄存器，許多設備都會有數據緩衝區(data buffer)，來供系統進行讀寫。</p><p>那麼問題來了，CPU 如何與設備寄存器和設備數據緩衝區進行通信呢？存在兩個可選的方式。第一種方法是，每個控制寄存器都被分配一個 I/O 端口(I/O port)號，這是一個 8 位或 16 位的整數。所有 I/O 端口的集合形成了受保護的 I/O 端口空間，以便普通用戶程序無法訪問它（只有操作系統可以訪問）。使用特殊的 I/O 指令像是</p><p>IN REG,PORT</p><p>CPU 可以讀取控制寄存器 PORT 的內容並將結果放在 CPU 寄存器 REG 中。類似的，使用</p><p>OUT PORT,REG</p><p>CPU 可以將 REG 的內容寫到控制寄存器中。大多數早期計算機，包括幾乎所有大型主機，如 IBM 360 及其所有後續機型，都是以這種方式工作的。</p><p>第二個方法是 PDP-11 引入的，它將<strong>所有控制寄存器映射到內存空間</strong>中。</p><h3>直接內存訪問</h3><p>無論一個 CPU 是否具有內存映射 I/O，它都需要尋址設備控制器以便與它們交換數據。CPU 可以從 I/O 控制器每次請求一個字節的數據，但是這麼做會浪費 CPU 時間，所以經常會用到一種稱為直接內存訪問(Direct Memory Access) 的方案。為了簡化，我們假設 CPU 通過單一的系統總線訪問所有的設備和內存，該總線連接 CPU 、內存和 I/O 設備，如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a2c560caf5ad4e33887457945822ec59></p><p>DMA 傳送操作</p><p>現代操作系統實際更為複雜，但是原理是相同的。如果硬件有DMA 控制器，那麼操作系統只能使用 DMA。有時這個控制器會集成到磁盤控制器和其他控制器中，但這種設計需要在每個設備上都裝有一個分離的 DMA 控制器。單個的 DMA 控制器可用於向多個設備傳輸，這種傳輸往往同時進行。</p><h4>DMA 工作原理</h4><p>首先 CPU 通過設置 DMA 控制器的寄存器對它進行編程，所以 DMA 控制器知道將什麼數據傳送到什麼地方。DMA 控制器還要向磁盤控制器發出一個命令，通知它從磁盤讀數據到其內部的緩衝區並檢驗校驗和。當有效數據位於磁盤控制器的緩衝區中時，DMA 就可以開始了。</p><p>DMA 控制器通過在總線上發出一個讀請求到磁盤控制器而發起 DMA 傳送，這是第二步。這個讀請求就像其他讀請求一樣，磁盤控制器並不知道或者並不關心它是來自 CPU 還是來自 DMA 控制器。通常情況下，要寫的內存地址在總線的地址線上，所以當磁盤控制器去匹配下一個字時，它知道將該字寫到什麼地方。寫到內存就是另外一個總線循環了，這是第三步。當寫操作完成時，磁盤控制器在總線上發出一個應答信號到 DMA 控制器，這是第四步。</p><p>然後，DMA 控制器會增加內存地址並減少字節數量。如果字節數量仍然大於 0 ，就會循環步驟 2 - 步驟 4 ，直到字節計數變為 0 。此時，DMA 控制器會打斷 CPU 並告訴它傳輸已經完成了。</p><h3>重溫中斷</h3><p>在一臺個人計算機體系結構中，中斷結構會如下所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/184a1cc745b94b08b8678f454785cbd4></p><p>中斷是怎樣發生的</p><p>當一個 I/O 設備完成它的工作後，它就會產生一箇中斷（默認操作系統已經開啟中斷），它通過在總線上聲明已分配的信號來實現此目的。主板上的中斷控制器芯片會檢測到這個信號，然後執行中斷操作。</p><h4>精確中斷和不精確中斷</h4><p>使機器處於良好狀態的中斷稱為精確中斷(precise interrupt)。這樣的中斷具有四個屬性：</p><ul><li>PC （程序計數器）保存在一個已知的地方</li><li>PC 所指向的指令之前所有的指令已經完全執行</li><li>PC 所指向的指令之後所有的指令都沒有執行</li><li>PC 所指向的指令的執行狀態是已知的</li></ul><p>不滿足以上要求的中斷稱為 不精確中斷(imprecise interrupt)，不精確中斷讓人很頭疼。上圖描述了不精確中斷的現象。指令的執行時序和完成度具有不確定性，而且恢復起來也非常麻煩。</p><h2>IO 軟件原理</h2><h3>I/O 軟件目標</h3><h4>設備獨立性</h4><p>I/O 軟件設計一個很重要的目標就是設備獨立性(device independence)。這意味著<strong>我們能夠編寫訪問任何設備的應用程序，而不用事先指定特定的設備</strong>。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a9d35178a114cf8b1317fdb6ecf5faf></p><h4>錯誤處理</h4><p>除了設備獨立性外，I/O 軟件實現的第二個重要的目標就是錯誤處理(error handling)。通常情況下來說，錯誤應該交給硬件層面去處理。如果設備控制器發現了讀錯誤的話，它會儘可能的去修復這個錯誤。如果設備控制器處理不了這個問題，那麼設備驅動程序應該進行處理，設備驅動程序會再次嘗試讀取操作，很多錯誤都是偶然性的，如果設備驅動程序無法處理這個錯誤，才會把錯誤向上拋到硬件層面（上層）進行處理，很多時候，上層並不需要知道下層是如何解決錯誤的。</p><h4>同步和異步傳輸</h4><p>I/O 軟件實現的第三個目標就是 同步(synchronous) 和 異步(asynchronous，即中斷驅動)傳輸。這裡先說一下同步和異步是怎麼回事吧。</p><p>同步傳輸中數據通常以塊或幀的形式發送。發送方和接收方在數據傳輸之前應該具有同步時鐘。而在異步傳輸中，數據通常以字節或者字符的形式發送，異步傳輸則不需要同步時鐘，但是會在傳輸之前向數據添加奇偶校驗位。大部分物理IO(physical I/O) 是異步的。物理 I/O 中的 CPU 是很聰明的，CPU 傳輸完成後會轉而做其他事情，它和中斷心靈相通，等到中斷髮生後，CPU 才會回到傳輸這件事情上來。</p><h4>緩衝</h4><p>I/O 軟件的最後一個問題是緩衝(buffering)。通常情況下，從一個設備發出的數據不會直接到達最後的設備。其間會經過一系列的校驗、檢查、緩衝等操作才能到達。</p><h4>共享和獨佔</h4><p>I/O 軟件引起的最後一個問題就是共享設備和獨佔設備的問題。有些 I/O 設備能夠被許多用戶共同使用。一些設備比如磁盤，讓多個用戶使用一般不會產生什麼問題，但是某些設備必須具有獨佔性，即只允許單個用戶使用完成後才能讓其他用戶使用。</p><p>一共有三種控制 I/O 設備的方法</p><ul><li>使用程序控制 I/O</li><li>使用中斷驅動 I/O</li><li>使用 DMA 驅動 I/O</li></ul><h2>I/O 層次結構</h2><p>I/O 軟件通常組織成四個層次，它們的大致結構如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/74fe291fcffb4181a9db753903de610f></p><p>下面我們具體的來探討一下上面的層次結構</p><h3>中斷處理程序</h3><p>在計算機系統中，中斷就像女人的脾氣一樣無時無刻都在產生，中斷的出現往往是讓人很不爽的。中斷處理程序又被稱為中斷服務程序 或者是 ISR(Interrupt Service Routines)，它是最靠近硬件的一層。中斷處理程序由硬件中斷、軟件中斷或者是軟件異常啟動產生的中斷，用於實現設備驅動程序或受保護的操作模式（例如系統調用）之間的轉換。</p><p>中斷處理程序負責處理中斷髮生時的所有操作，操作完成後阻塞，然後啟動中斷驅動程序來解決阻塞。通常會有三種通知方式，依賴於不同的具體實現</p><ul><li>信號量實現中：在信號量上使用 up 進行通知；</li><li>管程實現：對管程中的條件變量執行 signal 操作</li><li>還有一些情況是發送一些消息</li></ul><h3>設備驅動程序</h3><p>每個連接到計算機的 I/O 設備都需要有某些特定設備的代碼對其進行控制。這些提供 I/O 設備到設備控制器轉換的過程的代碼稱為 設備驅動程序(Device driver)。</p><p>設備控制器的主要功能有下面這些</p><ul><li><p>接收和識別命令：設備控制器可以接受來自 CPU 的指令，並進行識別。設備控制器內部也會有寄存器，用來存放指令和參數</p></li><li><p>進行數據交換：CPU、控制器和設備之間會進行數據的交換，CPU 通過總線把指令發送給控制器，或從控制器中並行地讀出數據；控制器將數據寫入指定設備。</p></li><li><p>地址識別：每個硬件設備都有自己的地址，設備控制器能夠識別這些不同的地址，來達到控制硬件的目的，此外，為使 CPU 能向寄存器中寫入或者讀取數據，這些寄存器都應具有唯一的地址。</p></li><li><p>差錯檢測：設備控制器還具有對設備傳遞過來的數據進行檢測的功能。</p></li></ul><p>在這種情況下，設備控制器會阻塞，直到中斷來解除阻塞狀態。還有一種情況是操作是可以無延遲的完成，所以驅動程序不需要阻塞。在第一種情況下，操作系統可能被中斷喚醒；第二種情況下操作系統不會被休眠。</p><p>設備驅動程序必須是可重入的，因為設備驅動程序會阻塞和喚醒然後再次阻塞。驅動程序不允許進行系統調用，但是它們通常需要與內核的其餘部分進行交互。</p><h3>與設備無關的 I/O 軟件</h3><p>I/O 軟件有兩種，一種是我們上面介紹過的基於特定設備的，還有一種是設備無關性的，設備無關性也就是不需要特定的設備。設備驅動程序與設備無關的軟件之間的界限取決於具體的系統。下面顯示的功能由設備無關的軟件實現</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d94ddff96b5640e99c9b6087bc50bed6></p><p>與設備無關的軟件的基本功能是對所有設備執行公共的 I/O 功能，並且向用戶層軟件提供一個統一的接口。</p><h4>緩衝</h4><p>無論是對於塊設備還是字符設備來說，緩衝都是一個非常重要的考量標準。緩衝技術應用廣泛，但它也有缺點。如果數據被緩衝次數太多，會影響性能。</p><h4>錯誤處理</h4><p>在 I/O 中，出錯是一種再正常不過的情況了。當出錯發生時，操作系統必須儘可能處理這些錯誤。有一些錯誤是隻有特定的設備才能處理，有一些是由框架進行處理，這些錯誤和特定的設備無關。</p><p>I/O 錯誤的一類是程序員編程錯誤，比如還沒有打開文件前就讀流，或者不關閉流導致內存溢出等等。這類問題由程序員處理；另外一類是實際的 I/O 錯誤，例如向一個磁盤壞塊寫入數據，無論怎麼寫都寫入不了。這類問題由驅動程序處理，驅動程序處理不了交給硬件處理，這個我們上面也說過。</p><h4>設備驅動程序統一接口</h4><p>我們在操作系統概述中說到，操作系統一個非常重要的功能就是屏蔽了硬件和軟件的差異性，為硬件和軟件提供了統一的標準，這個標準還體現在為設備驅動程序提供統一的接口，因為不同的硬件和廠商編寫的設備驅動程序不同，所以如果為每個驅動程序都單獨提供接口的話，這樣沒法搞，所以必須統一。</p><h4>分配和釋放</h4><p>一些設備例如打印機，它只能由一個進程來使用，這就需要操作系統根據實際情況判斷是否能夠對設備的請求進行檢查，判斷是否能夠接受其他請求，一種比較簡單直接的方式是在特殊文件上執行 open操作。如果設備不可用，那麼直接 open 會導致失敗。還有一種方式是不直接導致失敗，而是讓其阻塞，等到另外一個進程釋放資源後，在進行 open 打開操作。這種方式就把選擇權交給了用戶，由用戶判斷是否應該等待。</p><h4>設備無關的塊</h4><p>不同的磁盤會具有不同的扇區大小，但是軟件不會關心扇區大小，只管存儲就是了。一些字符設備可以一次一個字節的交付數據，而其他的設備則以較大的單位交付數據，這些差異也可以隱藏起來。</p><h3>用戶空間的 I/O 軟件</h3><p>雖然大部分 I/O 軟件都在內核結構中，但是還有一些在用戶空間實現的 I/O 軟件，凡事沒有絕對。一些 I/O 軟件和庫過程在用戶空間存在，然後以提供系統調用的方式實現。</p><h2>盤</h2><p>盤可以說是硬件裡面比較簡單的構造了，同時也是最重要的。下面我們從盤談起，聊聊它的物理構造</p><h3>盤硬件</h3><p>盤會有很多種類型。其中最簡單的構造就是磁盤(magnetic hard disks)， 也被稱為 hard disk,HDD等。磁盤通常與安裝在磁臂上的磁頭配對，磁頭可將數據讀取或者將數據寫入磁盤，因此磁盤的讀寫速度都同樣快。在磁盤中，數據是隨機訪問的，這也就說明可以通過任意的順序來存儲和檢索單個數據塊，所以你可以在任意位置放置磁盤來讓磁頭讀取，磁盤是一種非易失性的設備，即使斷電也能永久保留。</p><h4>磁盤</h4><p>為了組織和檢索數據，會將磁盤組織成特定的結構，這些特定的結構就是<strong>磁道、扇區和柱面</strong></p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed7d0e3759664117a41ee26db128d30f></p><p>磁盤被組織成柱面形式，每個盤用軸相連，每一個柱麵包含若干磁道，每個磁道由若干扇區組成。軟盤上大約每個磁道有 8 - 32 個扇區，硬盤上每條磁道上扇區的數量可達幾百個，磁頭大約是 1 - 16 個。</p><p>對於磁盤驅動程序來說，一個非常重要的特性就是控制器是否能夠同時控制兩個或者多個驅動器進行磁道尋址，這就是重疊尋道(overlapped seek)。對於控制器來說，它能夠控制一個磁盤驅動程序完成尋道操作，同時讓其他驅動程序等待尋道結束。控制器也可以在一個驅動程序上進行讀寫草哦做，與此同時讓另外的驅動器進行尋道操作，但是軟盤控制器不能在兩個驅動器上進行讀寫操作。</p><h4>RAID</h4><p>RAID 稱為 磁盤冗餘陣列，簡稱 磁盤陣列。利用虛擬化技術把多個硬盤結合在一起，成為一個或多個磁盤陣列組，目的是提升性能或數據冗餘。</p><p>RAID 有不同的級別</p><ul><li>RAID 0 - 無容錯的條帶化磁盤陣列</li><li>RAID 1 - 鏡像和雙工</li><li>RAID 2 - 內存式糾錯碼</li><li>RAID 3 - 比特交錯奇偶校驗</li><li>RAID 4 - 塊交錯奇偶校驗</li><li>RAID 5 - 塊交錯分佈式奇偶校驗</li><li>RAID 6 - P + Q冗餘</li></ul><h4>磁盤格式化</h4><p>磁盤由一堆鋁的、合金或玻璃的盤片組成，磁盤剛被創建出來後，沒有任何信息。磁盤在使用前必須經過低級格式化(low-levvel format)，下面是一個扇區的格式</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e6a4c9742b824b2fb1447bc44e6e14e7></p><p>前導碼相當於是標示扇區的開始位置，通常以位模式開始，前導碼還包括柱面號、扇區號等一些其他信息。緊隨前導碼後面的是數據區，數據部分的大小由低級格式化程序來確定。大部分磁盤使用 512 字節的扇區。數據區後面是 ECC，ECC 的全稱是 <strong>error correction code</strong> ，數據糾錯碼，它與普通的錯誤檢測不同，ECC 還可以用於恢復讀錯誤。ECC 階段的大小由不同的磁盤製造商實現。ECC 大小的設計標準取決於<strong>設計者願意犧牲多少磁盤空間來提高可靠性</strong>，以及程序可以處理的 ECC 的複雜程度。通常情況下 ECC 是 16 位，除此之外，硬盤一般具有一定數量的備用扇區，用於替換製造缺陷的扇區。</p><h3>磁盤臂調度算法</h3><p>下面我們來探討一下關於影響磁盤讀寫的算法，一般情況下，影響磁盤快讀寫的時間由下面幾個因素決定</p><ul><li>尋道時間 - 尋道時間指的就是將磁盤臂移動到需要讀取磁盤塊上的時間</li><li>旋轉延遲 - 等待合適的扇區旋轉到磁頭下所需的時間</li><li>實際數據的讀取或者寫入時間</li></ul><p>這三種時間參數也是磁盤尋道的過程。一般情況下，尋道時間對總時間的影響最大，所以，有效的降低尋道時間能夠提高磁盤的讀取速度。</p><p>如果磁盤驅動程序每次接收一個請求並按照接收順序完成請求，這種處理方式也就是 先來先服務(First-Come, First-served, FCFS) ，這種方式很難優化尋道時間。因為每次都會按照順序處理，不管順序如何，有可能這次讀完後需要等待一個磁盤旋轉一週才能繼續讀取，而其他柱面能夠馬上進行讀取，這種情況下每次請求也會排隊。</p><p>通常情況下，磁盤在進行尋道時，其他進程會產生其他的磁盤請求。磁盤驅動程序會維護一張表，表中會記錄著柱面號當作索引，每個柱面未完成的請求會形成鏈表，鏈表頭存放在表的相應表項中。</p><p>一種對先來先服務的算法改良的方案是使用 最短路徑優先(SSF) 算法，下面描述了這個算法。</p><p>假如我們在對磁道 6 號進行尋址時，同時發生了對 11 , 2 , 4, 14, 8, 15, 3 的請求，如果採用先來先服務的原則，如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2b4bf4aa8fd4a6397714693c40e1d05></p><p>我們可以計算一下磁盤臂所跨越的磁盤數量為 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相當於是跨越了 51 次盤面，如果使用最短路徑優先，我們來計算一下跨越的盤面</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/598caf5dd550460da4e4a0815c9b43fe></p><p>跨越的磁盤數量為 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了兩倍的時間。</p><p>但是，最短路徑優先的算法也不是完美無缺的，這種算法照樣存在問題，那就是優先級 問題，</p><p>這裡有一個原型可以參考就是我們日常生活中的電梯，電梯使用一種電梯算法(elevator algorithm) 來進行調度，從而滿足協調效率和公平性這兩個相互衝突的目標。電梯一般會保持向一個方向移動，直到在那個方向上沒有請求為止，然後改變方向。</p><p>電梯算法需要維護一個二進制位，也就是當前的方向位：UP(向上)或者是 DOWN(向下)。當一個請求處理完成後，磁盤或電梯的驅動程序會檢查該位，如果此位是 UP 位，磁盤臂或者電梯倉移到下一個更高跌未完成的請求。如果高位沒有未完成的請求，則取相反方向。當方向位是 DOWN時，同時存在一個低位的請求，磁盤臂會轉向該點。如果不存在的話，那麼它只是停止並等待。</p><p>我們舉個例子來描述一下電梯算法，比如各個柱面得到服務的順序是 4，7，10，14，9，6，3，1 ，那麼它的流程圖如下</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ead40ed226e3478196d275d8f10e6c38></p><p>所以電梯算法需要跨越的盤面數量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p><p>電梯算法通常情況下不如 SSF 算法。</p><h3>錯誤處理</h3><p>一般壞塊有兩種處理辦法，一種是在控制器中進行處理；一種是在操作系統層面進行處理。</p><p>這兩種方法經常替換使用，比如一個具有 30 個數據扇區和兩個備用扇區的磁盤，其中扇區 4 是有瑕疵的。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9d3eb4d787b641f7865681b7418429bc></p><p>控制器能做的事情就是將備用扇區之一重新映射。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa932bbdc325496ea96d1dad97375170></p><p>還有一種處理方式是將所有的扇區都向上移動一個扇區</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f8e8e772e5844dcbb5b299cbe8725f5e></p><p>上面這這兩種情況下控制器都必須知道哪個扇區，可以通過內部的表來跟蹤這一信息，或者通過重寫前導碼來給出重新映射的扇區號。如果是重寫前導碼，那麼涉及移動的方式必須重寫後面所有的前導碼，但是最終會提供良好的性能。</p><h3>穩定存儲器</h3><p>磁盤經常會出現錯誤，導致好的扇區會變成壞扇區，驅動程序也有可能掛掉。RAID 可以對扇區出錯或者是驅動器崩潰提出保護，然而 RAID 卻不能對壞數據中的寫錯誤提供保護，也不能對寫操作期間的崩潰提供保護，這樣就會破壞原始數據。</p><p>我們期望磁盤能夠準確無誤的工作，但是事實情況是不可能的，但是我們能夠知道的是，一個磁盤子系統具有如下特性：當一個寫命令發給它時，磁盤要麼正確地寫數據，要麼什麼也不做，讓現有的數據完整無誤的保留。這樣的系統稱為 穩定存儲器(stable storage)。 穩定存儲器的目標就是不惜一切代價保證磁盤的一致性。</p><p>穩定存儲器使用兩個一對相同的磁盤，對應的塊一同工作形成一個無差別的塊。穩定存儲器為了實現這個目的，定義了下面三種操作：</p><ul><li>穩定寫(stable write)</li><li>穩定讀(stable read)</li><li>崩潰恢復(crash recovery)</li></ul><h2>時鐘</h2><p>時鐘(Clocks) 也被稱為定時器(timers)，時鐘/定時器對任何程序系統來說都是必不可少的。時鐘負責維護時間、防止一個進程長期佔用 CPU 時間等其他功能。時鐘軟件(clock software) 也是一種設備驅動的方式。下面我們就來對時鐘進行介紹，一般都是先討論硬件再介紹軟件，採用由下到上的方式，也是告訴你，底層是最重要的。</p><h3>時鐘硬件</h3><p>在計算機中有兩種類型的時鐘，這些時鐘與現實生活中使用的時鐘完全不一樣。</p><ul><li>比較簡單的一種時鐘被連接到 110 V 或 220 V 的電源線上，這樣每個電壓週期會產生一箇中斷，大概是 50 - 60 HZ。這些時鐘過去一直佔據支配地位。</li><li>另外的一種時鐘由晶體振盪器、計數器和寄存器組成，示意圖如下所示</li></ul><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/505b87e8d2364908ac02f113acc217e3></p><p>這種時鐘稱為可編程時鐘 ，可編程時鐘有兩種模式，一種是 一鍵式(one-shot mode)，當時鍾啟動時，會把存儲器中的值複製到計數器中，然後，每次晶體的振盪器的脈衝都會使計數器 -1。當計數器變為 0 時，會產生一箇中斷，並停止工作，直到軟件再一次顯示啟動。還有一種模式時 方波(square-wave mode) 模式，在這種模式下，當計數器變為 0 併產生中斷後，存儲寄存器的值會自動複製到計數器中，這種週期性的中斷稱為一個時鐘週期。</p><h3>時鐘軟件</h3><p>時鐘硬件所做的工作只是根據已知的時間間隔產生中斷，而其他的工作都是由時鐘軟件來完成，一般操作系統的不同，時鐘軟件的具體實現也不同，但是一般都會包括以下這幾點</p><ul><li>維護一天的時間</li><li>阻止進程運行的時間超過其指定時間</li><li>統計 CPU 的使用情況</li><li>處理用戶進程的警告系統調用</li><li>為系統各個部分提供看門狗定時器</li><li>完成概要剖析，監視和信息收集</li></ul><h3>軟定時器</h3><p>時鐘軟件也被稱為可編程時鐘，可以設置它以程序需要的任何速率引發中斷。時鐘軟件觸發的中斷是一種硬中斷，但是某些應用程序對於硬中斷來說是不可接受的。</p><p>這時候就需要一種軟定時器(soft timer) 避免了中斷，無論何時當內核因為某種原因呢在運行時，它返回用戶態之前都會檢查時鐘來了解軟定時器是否到期。如果軟定時器到期，則執行被調度的事件也無需切換到內核態，因為本身已經處於內核態中。這種方式避免了頻繁的內核態和用戶態之前的切換，提高了程序運行效率。</p><p>軟定時器因為不同的原因切換進入內核態的速率不同，原因主要有</p><ul><li>系統調用</li><li>TLB 未命中</li><li>缺頁異常</li><li>I/O 中斷</li><li>CPU 變得空閒</li></ul><p>死鎖問題也是操作系統非常重要的一類問題</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b88bc260b330476096ba278623a60b0c></p><h2>資源</h2><p>大部分的死鎖都和資源有關，在進程對設備、文件具有獨佔性（排他性）時會產生死鎖。我們把這類需要排他性使用的對象稱為資源(resource)。資源主要分為 <strong>可搶佔資源和不可搶佔資源</strong></p><h3>可搶佔資源和不可搶佔資源</h3><p>資源主要有可搶佔資源和不可搶佔資源。可搶佔資源(preemptable resource) 可以從擁有它的進程中搶佔而不會造成其他影響，內存就是一種可搶佔性資源，任何進程都能夠搶先獲得內存的使用權。</p><p>不可搶佔資源(nonpreemtable resource) 指的是除非引起錯誤或者異常，否則進程無法搶佔指定資源，這種不可搶佔的資源比如有光盤，在進程執行調度的過程中，其他進程是不能得到該資源的。</p><h2>死鎖</h2><p>如果要對死鎖進行一個定義的話，下面的定義比較貼切</p><p><strong>如果一組進程中的每個進程都在等待一個事件，而這個事件只能由該組中的另一個進程觸發，這種情況會導致死鎖</strong>。</p><h3>資源死鎖的條件</h3><p>針對我們上面的描述，資源死鎖可能出現的情況主要有</p><ul><li>互斥條件：每個資源都被分配給了一個進程或者資源是可用的</li><li>保持和等待條件：已經獲取資源的進程被認為能夠獲取新的資源</li><li>不可搶佔條件：分配給一個進程的資源不能強制的從其他進程搶佔資源，它只能由佔有它的進程顯示釋放</li><li>循環等待：死鎖發生時，系統中一定有兩個或者兩個以上的進程組成一個循環，循環中的每個進程都在等待下一個進程釋放的資源。</li></ul><p>發生死鎖時，上面的情況必須同時會發生。如果其中任意一個條件不會成立，死鎖就不會發生。可以通過破壞其中任意一個條件來破壞死鎖，下面這些破壞條件就是我們探討的重點</p><h3>死鎖模型</h3><p>Holt 在 1972 年提出對死鎖進行建模，建模的標準如下：</p><ul><li>圓形表示進程</li><li>方形表示資源</li></ul><p>從資源節點到進程節點表示資源已經被進程佔用，如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f57da67e225a46d2a621ca170e43a242></p><p>在上圖中表示當前資源 R 正在被 A 進程所佔用</p><p>由進程節點到資源節點的有向圖表示當前進程正在請求資源，並且該進程已經被阻塞，處於等待這個資源的狀態</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0160e046f6454921a5bebb7709582eea></p><p>在上圖中，表示的含義是進程 B 正在請求資源 S 。Holt 認為，死鎖的描述應該如下</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b75cb51753ff4ba7bde587a489956381></p><p>這是一個死鎖的過程，進程 C 等待資源 T 的釋放，資源 T 卻已經被進程 D 佔用，進程 D 等待請求佔用資源 U ，資源 U 卻已經被線程 C 佔用，從而形成環。</p><p>有四種處理死鎖的策略：</p><ul><li>忽略死鎖帶來的影響（驚呆了）</li><li>檢測死鎖並回復死鎖，死鎖發生時對其進行檢測，一旦發生死鎖後，採取行動解決問題</li><li>通過仔細分配資源來避免死鎖</li><li>通過破壞死鎖產生的四個條件之一來避免死鎖</li></ul><p>下面我們分別介紹一下這四種方法</p><h2>鴕鳥算法</h2><p>最簡單的解決辦法就是使用鴕鳥算法(ostrich algorithm)，把頭埋在沙子裡，假裝問題根本沒有發生。每個人看待這個問題的反應都不同。數學家認為死鎖是不可接受的，必須通過有效的策略來防止死鎖的產生。工程師想要知道問題發生的頻次，系統因為其他原因崩潰的次數和死鎖帶來的嚴重後果。如果死鎖發生的頻次很低，而經常會由於硬件故障、編譯器錯誤等其他操作系統問題導致系統崩潰，那麼大多數工程師不會修復死鎖。</p><h2>死鎖檢測和恢復</h2><p>第二種技術是死鎖的檢測和恢復。這種解決方式不會嘗試去阻止死鎖的出現。相反，這種解決方案會希望死鎖儘可能的出現，在監測到死鎖出現後，對其進行恢復。下面我們就來探討一下死鎖的檢測和恢復的幾種方式</p><h3>每種類型一個資源的死鎖檢測方式</h3><p>每種資源類型都有一個資源是什麼意思？我們經常提到的打印機就是這樣的，資源只有打印機，但是設備都不會超過一個。</p><p>可以通過構造一張資源分配表來檢測這種錯誤，比如我們上面提到的</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/659a7caab02e4be690db0d20b44dc66e></p><p>如果這張圖包含了一個或一個以上的環，那麼死鎖就存在，處於這個環中任意一個進程都是死鎖的進程。</p><h3>每種類型多個資源的死鎖檢測方式</h3><p>如果有多種相同的資源存在，就需要採用另一種方法來檢測死鎖。可以通過構造一個矩陣來檢測從 P1 -> Pn 這 n 個進程中的死鎖。</p><p>現在我們提供一種基於矩陣的算法來檢測從 P1 到 Pn 這 n 個進程中的死鎖。假設資源類型為 m，E1 代表資源類型1，E2 表示資源類型 2 ，Ei 代表資源類型 i (1 &lt;= i &lt;= m)。E 表示的是 現有資源向量(existing resource vector)，代表每種已存在的資源總數。</p><p>現在我們就需要構造兩個數組：C 表示的是當前分配矩陣(current allocation matrix) ，R 表示的是 請求矩陣(request matrix)。Ci 表示的是 Pi 持有每一種類型資源的資源數。所以，Cij 表示 Pi 持有資源 j 的數量。Rij 表示 Pi 所需要獲得的資源 j 的數量</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c322ceb29c4b487eaf8835dce0dd5200></p><p>一般來說，已分配資源 j 的數量加起來再和所有可供使用的資源數相加 = 該類資源的總數。</p><p>死鎖的檢測就是基於向量的比較。每個進程起初都是沒有被標記過的，算法會開始對進程做標記，進程被標記後說明進程被執行了，不會進入死鎖，當算法結束時，任何沒有被標記過的進程都會被判定為死鎖進程。</p><p>上面我們探討了兩種檢測死鎖的方式，那麼現在你知道怎麼檢測後，你何時去做死鎖檢測呢？一般來說，有兩個考量標準：</p><ul><li>每當有資源請求時就去檢測，這種方式會佔用昂貴的 CPU 時間。</li><li>每隔 k 分鐘檢測一次，或者當 CPU 使用率降低到某個標準下去檢測。考慮到 CPU 效率的原因，如果死鎖進程達到一定數量，就沒有多少進程可以運行，所以 CPU 會經常空閒。</li></ul><h3>從死鎖中恢復</h3><p>上面我們探討了如何檢測進程死鎖，我們最終的目的肯定是想讓程序能夠正常的運行下去，所以針對檢測出來的死鎖，我們要對其進行恢復，下面我們會探討幾種死鎖的恢復方式</p><h4>通過搶佔進行恢復</h4><p>在某些情況下，可能會臨時將某個資源從它的持有者轉移到另一個進程。比如在不通知原進程的情況下，將某個資源從進程中強制取走給其他進程使用，使用完後又送回。這種恢復方式一般比較困難而且有些簡單粗暴，並不可取。</p><h4>通過回滾進行恢復</h4><p>如果系統設計者和機器操作員知道有可能發生死鎖，那麼就可以定期檢查流程。進程的檢測點意味著進程的狀態可以被寫入到文件以便後面進行恢復。檢測點不僅包含存儲映像(memory image)，還包含資源狀態(resource state)。一種更有效的解決方式是不要覆蓋原有的檢測點，而是每出現一個檢測點都要把它寫入到文件中，這樣當進程執行時，就會有一系列的檢查點文件被累積起來。</p><p>為了進行恢復，要從上一個較早的檢查點上開始，這樣所需要資源的進程會回滾到上一個時間點，在這個時間點上，死鎖進程還沒有獲取所需要的資源，可以在此時對其進行資源分配。</p><h4>殺死進程恢復</h4><p>最簡單有效的解決方案是直接殺死一個死鎖進程。但是殺死一個進程可能照樣行不通，這時候就需要殺死別的資源進行恢復。</p><p>另外一種方式是選擇一個環外的進程作為犧牲品來釋放進程資源。</p><h2>死鎖避免</h2><p>我們上面討論的是如何檢測出現死鎖和如何恢復死鎖，下面我們探討幾種規避死鎖的方式</p><h3>單個資源的銀行家算法</h3><p>銀行家算法是 Dijkstra 在 1965 年提出的一種調度算法，它本身是一種死鎖的調度算法。它的模型是基於一個城鎮中的銀行家，銀行家向城鎮中的客戶承諾了一定數量的貸款額度。算法要做的就是判斷請求是否會進入一種不安全的狀態。如果是，就拒絕請求，如果請求後系統是安全的，就接受該請求。</p><p>類似的，還有多個資源的銀行家算法，讀者可以自行了解。</p><h2>破壞死鎖</h2><p>死鎖本質上是無法避免的，因為它需要獲得未知的資源和請求，但是死鎖是滿足四個條件後才出現的，它們分別是</p><ul><li>互斥</li><li>保持和等待</li><li>不可搶佔</li><li>循環等待</li></ul><p>我們分別對這四個條件進行討論，按理說破壞其中的任意一個條件就能夠破壞死鎖</p><h3>破壞互斥條件</h3><p>我們首先考慮的就是<strong>破壞互斥使用條件</strong>。如果資源不被一個進程獨佔，那麼死鎖肯定不會產生。如果兩個打印機同時使用一個資源會造成混亂，打印機的解決方式是使用 假脫機打印機(spooling printer) ，這項技術可以允許多個進程同時產生輸出，在這種模型中，實際請求打印機的唯一進程是打印機守護進程，也稱為後臺進程。後臺進程不會請求其他資源。我們可以消除打印機的死鎖。</p><p>後臺進程通常被編寫為能夠輸出完整的文件後才能打印，假如兩個進程都佔用了假脫機空間的一半，而這兩個進程都沒有完成全部的輸出，就會導致死鎖。</p><p>因此，儘量做到儘可能少的進程可以請求資源。</p><h3>破壞保持等待的條件</h3><p>第二種方式是如果我們能阻止持有資源的進程請求其他資源，我們就能夠消除死鎖。一種實現方式是讓所有的進程開始執行前請求全部的資源。如果所需的資源可用，進程會完成資源的分配並運行到結束。如果有任何一個資源處於頻繁分配的情況，那麼沒有分配到資源的進程就會等待。</p><p>很多進程<strong>無法在執行完成前就知道到底需要多少資源</strong>，如果知道的話，就可以使用銀行家算法；還有一個問題是這樣<strong>無法合理有效利用資源</strong>。</p><p>還有一種方式是進程在請求其他資源時，先釋放所佔用的資源，然後再嘗試一次獲取全部的資源。</p><h3>破壞不可搶佔條件</h3><p>破壞不可搶佔條件也是可以的。可以通過虛擬化的方式來避免這種情況。</p><h3>破壞循環等待條件</h3><p>現在就剩最後一個條件了，循環等待條件可以通過多種方法來破壞。一種方式是制定一個標準，一個進程在任何時候只能使用一種資源。如果需要另外一種資源，必須釋放當前資源。對於需要將大文件從磁帶複製到打印機的過程，此限制是不可接受的。</p><p>另一種方式是將所有的資源統一編號，如下圖所示</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8bc7bac63a04410a87f9b7d0b7552355></p><p>進程可以在任何時間提出請求，但是所有的請求都必須按照資源的順序提出。如果按照此分配規則的話，那麼資源分配之間不會出現環。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b38be71473e142708695e6bd0b573e7a></p><p>儘管通過這種方式來消除死鎖，但是編號的順序不可能讓每個進程都會接受。</p><h2>其他問題</h2><p>下面我們來探討一下其他問題，包括 <strong>通信死鎖、活鎖是什麼、飢餓問題和兩階段加鎖</strong></p><h3>兩階段加鎖</h3><p>雖然很多情況下死鎖的避免和預防都能處理，但是效果並不好。隨著時間的推移，提出了很多優秀的算法用來處理死鎖。例如在數據庫系統中，一個經常發生的操作是請求鎖住一些記錄，然後更新所有鎖定的記錄。當同時有多個進程運行時，就會有死鎖的風險。</p><p>一種解決方式是使用 兩階段提交(two-phase locking)。顧名思義分為兩個階段，一階段是進程嘗試一次鎖定它需要的所有記錄。如果成功後，才會開始第二階段，第二階段是執行更新並釋放鎖。第一階段並不做真正有意義的工作。</p><p>如果在第一階段某個進程所需要的記錄已經被加鎖，那麼該進程會釋放所有鎖定的記錄並重新開始第一階段。從某種意義上來說，這種方法類似於預先請求所有必需的資源或者是在進行一些不可逆的操作之前請求所有的資源。</p><p>不過在一般的應用場景中，兩階段加鎖的策略並不通用。如果一個進程缺少資源就會半途中斷並重新開始的方式是不可接受的。</p><h3>通信死鎖</h3><p>我們上面一直討論的是資源死鎖，資源死鎖是一種死鎖類型，但並不是唯一類型，還有通信死鎖，也就是兩個或多個進程在發送消息時出現的死鎖。進程 A 給進程 B 發了一條消息，然後進程 A 阻塞直到進程 B 返回響應。假設請求消息丟失了，那麼進程 A 在一直等著回覆，進程 B 也會阻塞等待請求消息到來，這時候就產生死鎖。</p><p>儘管會產生死鎖，但是這並不是一個資源死鎖，因為 A 並沒有佔據 B 的資源。事實上，通信死鎖並沒有完全可見的資源。根據死鎖的定義來說：每個進程因為等待其他進程引起的事件而產生阻塞，這就是一種死鎖。相較於最常見的通信死鎖，我們把上面這種情況稱為通信死鎖(communication deadlock)。</p><p>通信死鎖不能通過調度的方式來避免，但是可以使用通信中一個非常重要的概念來避免：超時(timeout)。在通信過程中，只要一個信息被髮出後，發送者就會啟動一個定時器，定時器會記錄消息的超時時間，如果超時時間到了但是消息還沒有返回，就會認為消息已經丟失並重新發送，通過這種方式，可以避免通信死鎖。</p><p>但是並非所有網絡通信發生的死鎖都是通信死鎖，也存在資源死鎖，下面就是一個典型的資源死鎖。</p><p>當一個數據包從主機進入路由器時，會被放入一個緩衝區，然後再傳輸到另外一個路由器，再到另一個，以此類推直到目的地。緩衝區都是資源並且數量有限。如下圖所示，每個路由器都有 10 個緩衝區（實際上有很多）。</p><p><img alt="5萬字、97 張圖總結操作系統核心知識點(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74f84c2c94e04b9d9f8f840d36ebf65f></p><p>假如路由器 A 的所有數據需要發送到 B ，B 的所有數據包需要發送到 D，然後 D 的所有數據包需要發送到 A 。沒有數據包可以移動，因為在另一端沒有緩衝區可用，這就是一個典型的資源死鎖。</p><h3>活鎖</h3><p>某些情況下，當進程意識到它不能獲取所需要的下一個鎖時，就會嘗試禮貌的釋放已經獲得的鎖，然後等待非常短的時間再次嘗試獲取。可以想像一下這個場景：當兩個人在狹路相逢的時候，都想給對方讓路，相同的步調會導致雙方都無法前進。</p><p>現在假想有一對並行的進程用到了兩個資源。它們分別嘗試獲取另一個鎖失敗後，兩個進程都會釋放自己持有的鎖，再次進行嘗試，這個過程會一直進行重複。很明顯，這個過程中沒有進程阻塞，但是進程仍然不會向下執行，這種狀況我們稱之為 活鎖(livelock)。</p><h3>飢餓</h3><p>與死鎖和活鎖的一個非常相似的問題是 飢餓(starvvation)。想象一下你什麼時候會餓？一段時間不吃東西是不是會餓？對於進程來講，最重要的就是資源，如果一段時間沒有獲得資源，那麼進程會產生飢餓，這些進程會永遠得不到服務。</p><p>我們假設打印機的分配方案是每次都會分配給最小文件的進程，那麼要打印大文件的進程會永遠得不到服務，導致進程飢餓，進程會無限制的推後，雖然它沒有阻塞。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>萬字</a></li><li><a>97</a></li><li><a>張圖</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/74c701b.html alt="5萬字、97 張圖總結操作系統核心知識點(上)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/98a0e3ef45ee4fc4b806e816919b54f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/74c701b.html title="5萬字、97 張圖總結操作系統核心知識點(上)">5萬字、97 張圖總結操作系統核心知識點(上)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4c5606f.html alt=21張圖譜解析21種儀器原理及應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e4cf495f5e44418f95dbf149a8f2b174 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4c5606f.html title=21張圖譜解析21種儀器原理及應用>21張圖譜解析21種儀器原理及應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1dfdbb27.html alt=這4張圖如果不懂，自噴至少損失8分！（詳解報警閥！） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5fe122eff5694ace8861fcc8d3dab174 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1dfdbb27.html title=這4張圖如果不懂，自噴至少損失8分！（詳解報警閥！）>這4張圖如果不懂，自噴至少損失8分！（詳解報警閥！）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b011459.html alt=拳皇97金家藩隊全人物介紹、出招表、高清圖片僅供收藏（七） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d1297f468bc64cd296fec5cd8b06b67f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b011459.html title=拳皇97金家藩隊全人物介紹、出招表、高清圖片僅供收藏（七）>拳皇97金家藩隊全人物介紹、出招表、高清圖片僅供收藏（七）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5368032e.html alt=僅28張圖說清壓力錶及附件的選擇與安裝姿勢，就這麼簡單？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/94975f451af74934a9557e45396dab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5368032e.html title=僅28張圖說清壓力錶及附件的選擇與安裝姿勢，就這麼簡單？>僅28張圖說清壓力錶及附件的選擇與安裝姿勢，就這麼簡單？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/46ff8566.html alt=輸入主題就能生成萬字文章？解密狗屁不通文章生成器！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c2383ec46acf4ed5aec149441b42dea8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/46ff8566.html title=輸入主題就能生成萬字文章？解密狗屁不通文章生成器！>輸入主題就能生成萬字文章？解密狗屁不通文章生成器！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/530dc6c1.html alt=西遊記連載（文字版）第97一100回 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d55f1c57abc5485b92a6876b29ab5793 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/530dc6c1.html title=西遊記連載（文字版）第97一100回>西遊記連載（文字版）第97一100回</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51b15950.html alt=18張圖，幫你“扒”光一箇中國醫生 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R69MoTNH1oohss style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51b15950.html title=18張圖，幫你“扒”光一箇中國醫生>18張圖，幫你“扒”光一箇中國醫生</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe84c631.html alt=武漢：6日97條求助信息得到積極響應 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe84c631.html title=武漢：6日97條求助信息得到積極響應>武漢：6日97條求助信息得到積極響應</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea1261c8.html alt="25 張圖讀懂「文件系統」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S7ioqtx8IVQKiQ style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea1261c8.html title="25 張圖讀懂「文件系統」">25 張圖讀懂「文件系統」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/453083d5.html alt=福州97條道路廣告牌大提升，你覺得好看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d6e1524b0a9a4c0bbfb54b25f73f9d3d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/453083d5.html title=福州97條道路廣告牌大提升，你覺得好看嗎>福州97條道路廣告牌大提升，你覺得好看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/140771cb.html alt=20張圖讓你掌握常用放大器配置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/674ee6fd7b0d433aaf3b8279b7f1efef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/140771cb.html title=20張圖讓你掌握常用放大器配置>20張圖讓你掌握常用放大器配置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fd215c8.html alt=22張圖帶你瞭解螺紋緊固件及螺紋連接畫法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c43522f7797b434f927a4761a25a0d3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fd215c8.html title=22張圖帶你瞭解螺紋緊固件及螺紋連接畫法>22張圖帶你瞭解螺紋緊固件及螺紋連接畫法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a7bf3e2.html alt=什麼葡萄品種好？7張圖囊括50個品種對比！幾十年實戰經驗總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15281038686255b03364e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a7bf3e2.html title=什麼葡萄品種好？7張圖囊括50個品種對比！幾十年實戰經驗總結！>什麼葡萄品種好？7張圖囊括50個品種對比！幾十年實戰經驗總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb440040.html alt=拐角裝修怎麼做？9張圖告訴你答案，省空間又有格調！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66b600029597e8d74b6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb440040.html title=拐角裝修怎麼做？9張圖告訴你答案，省空間又有格調！>拐角裝修怎麼做？9張圖告訴你答案，省空間又有格調！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>