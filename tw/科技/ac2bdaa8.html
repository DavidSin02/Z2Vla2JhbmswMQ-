<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從零開始手寫 redis(13) HashMap源碼詳解 | 极客快訊</title><meta property="og:title" content="從零開始手寫 redis(13) HashMap源碼詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e2fd616e0a2e438aa897f2e87f3fda25"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ac2bdaa8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ac2bdaa8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ac2bdaa8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ac2bdaa8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ac2bdaa8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ac2bdaa8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ac2bdaa8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ac2bdaa8.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="從零開始手寫 redis(13) HashMap源碼詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ac2bdaa8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從零開始手寫 redis(13) HashMap源碼詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>為什麼學習 HashMap 源碼？</strong></h1><p>作為一名 java 開發，基本上最常用的數據結構就是 HashMap 和 List，jdk 的 HashMap 設計還是非常值得深入學習的。</p><p>無論是在面試還是工作中，知道原理都對會我們有很大的幫助。</p><p>本篇的內容較長，建議先收藏，再細細品味。</p><p>不同於網上簡單的源碼分析，更多的是實現背後的設計思想。</p><p>涉及的內容比較廣泛，從統計學中的泊松分佈，到計算機基礎的位運算，經典的紅黑樹、鏈表、數組等數據結構，也談到了 Hash 函數的相關介紹，文末也引入了美團對於 HashMap 的源碼分析，所以整體深度和廣度都比較大。</p><p>思維導圖如下：</p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e2fd616e0a2e438aa897f2e87f3fda25><p class=pgc-img-caption>思維導圖</p></div><p><br></p><p>本文是<strong>兩年前整理的</strong>，文中不免有疏漏過時的地方，歡迎大家提出寶貴的意見。</p><p>之所以這裡拿出來，有以下幾個目的：</p><p>（1）讓讀者理解 HashMap 的設計思想，知道 rehash 的過程。下一節我們將自己實現一個 HashMap</p><p>（2）為什麼要自己實現 HashMap?</p><p>最近在手寫 redis 框架，都說 redis 是一個特性更加強大的 Map，自然 HashMap 就是入門基礎。Redis 高性能中一個過人之處的設計就是漸進式 rehash，和大家一起實現一個漸進式 rehash 的 map，更能體會和理解作者設計的巧妙。</p><p>想把常見的數據結構獨立為一個開源工具，便於後期使用。比如這次手寫 redis，循環鏈表，LRU map 等都是從零開始寫的，不利於複用，還容易有 BUG。</p><p>好了，下面就讓我們一起開始 HashMap 的源碼之旅吧~</p><h1 class=pgc-h-arrow-right><strong>HashMap 源碼</strong></h1><p>HashMap 是平時使用到非常多的一個集合類，感覺有必要深入學習一下。</p><p>首先嚐試自己閱讀一遍源碼。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">java 版本</span></span></strong></h1><pre><code>$ java -versionjava version "1.8.0_91"Java(TM) SE Runtime Environment (build 1.8.0_91-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">數據結構</span></span></strong></h1><p>從結構實現來講，HashMap是數組+鏈表+紅黑樹（JDK1.8增加了紅黑樹部分）實現的。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">對於當前類的官方說明</span></span></strong></h1><p>基於哈希表實現的映射接口。這個實現提供了所有可選的映射操作，並允許空值和空鍵。(HashMap類大致相當於Hashtable，但它是非同步的，並且允許為空。)</p><p>這個類不保證映射的順序;特別地，它不能保證順序會隨時間保持不變。</p><p>這個實現為基本操作(get和put)提供了恆定時間的性能，假設哈希函數將元素適當地分散在各個桶中。對集合視圖的迭代需要與HashMap實例的“容量”(桶數)及其大小(鍵-值映射數)成比例的時間。因此，如果迭代性能很重要，那麼不要將初始容量設置得太高(或者負載係數太低)，這是非常重要的。</p><p>HashMap實例有兩個影響其性能的參數: <strong>初始容量和負載因子</strong>。</p><p>容量是哈希表中的桶數，初始容量只是創建哈希表時的容量。負載因子是在哈希表的容量自動增加之前，哈希表被允許達到的最大容量的度量。當哈希表中的條目數量超過負載因子和當前容量的乘積時，哈希表就會被重新哈希(也就是說，重新構建內部數據結構)，這樣哈希表的桶數大約是原來的兩倍。</p><p>一般來說，默認的負載因子(<span style="color:#ef7060;--tt-darkmode-color: #EF7060">0.75</span>)在時間和空間成本之間提供了很好的權衡。</p><p>較高的值減少了空間開銷，但增加了查找成本(反映在HashMap類的大多數操作中，包括get和put)。在設置映射的初始容量時，應該考慮映射中的期望條目數及其負載因子，以最小化重哈希操作的數量。如果初始容量大於條目的最大數量除以負載因子，就不會發生重哈希操作。</p><p>如果要將許多映射存儲在HashMap實例中，那麼使用足夠大的容量創建映射將使映射存儲的效率更高，而不是讓它根據需要執行自動重哈希以增長表。</p><p>注意，使用具有相同hashCode()的多個鍵確實可以降低任何散列表的性能。為了改善影響，當鍵具有可比性時，這個類可以使用鍵之間的比較順序來幫助斷開連接。</p><p>注意，這個實現不是同步的。如果多個線程併發地訪問散列映射，並且至少有一個線程在結構上修改了映射，那麼它必須在外部同步。(結構修改是添加或刪除一個或多個映射的任何操作;僅更改與實例已經包含的鍵關聯的值並不是結構修改。這通常是通過對自然封裝映射的對象進行同步來完成的。</p><p>如果不存在這樣的對象，則應該使用集合“包裝” Collections.synchronizedMap 方法。這最好在創建時完成，以防止意外的對映射的非同步訪問:</p><pre><code>Map m = Collections.synchronizedMap(new HashMap(...));</code></pre><p>這個類的所有“集合視圖方法”返回的迭代器都是快速失敗的:如果在創建迭代器之後的任何時候對映射進行結構上的修改，除了通過迭代器自己的remove方法，迭代器將拋出ConcurrentModificationException。因此，在併發修改的情況下，迭代器會快速而乾淨地失敗，而不是在未來的不確定時間內冒著任意的、不確定的行為的風險。</p><p>注意，迭代器的快速故障行為不能得到保證，因為一般來說，在存在非同步併發修改的情況下，不可能做出任何硬性保證。快速失敗迭代器以最佳的方式拋出ConcurrentModificationException。因此，編寫依賴於此異常的程序來保證其正確性是錯誤的:迭代器的快速故障行為應該僅用於檢測錯誤。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">其他基礎信息</span></span></strong></h1><ol start=1><li>這個類是Java集合框架的成員。</li><li>@since 1.2</li><li>java.util 包下</li></ol><h1 class=pgc-h-arrow-right><strong>源碼初探</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">接口</span></span></strong></h1><pre><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable {}</code></pre><p>當前類實現了三個接口，我們主要關心 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">Map</span> 接口即可。</p><p>繼承了一個抽象類 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">AbstractMap</span>，這個暫時放在本節後面學習。</p><h1 class=pgc-h-arrow-right><strong>常量定義</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">默認初始化容量</span></span></strong></h1><pre><code>/** * The default initial capacity - MUST be a power of two. */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code></pre><ul><li>為什麼不直接使用 16？</li></ul><p>看了下 statckoverflow，感覺比較靠譜的解釋是：</p><ol start=1><li>為了避免使用魔法數字，使得常量定義本身就具有自我解釋的含義。</li><li>強調這個數必須是 2 的冪。</li></ol><ul><li>為什麼要是 2 的冪？</li></ul><p>它是這樣設計的，因為它允許使用快速位和操作將每個鍵的哈希代碼包裝到表的容量範圍內，正如您在訪問表的方法中看到的:</p><pre><code>final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) { /// &lt;-- bitwise 'AND' here        ...</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">最大容量</span></span></strong></h1><p>隱式指定較高值時使用的最大容量。</p><p>由任何帶有參數的構造函數。</p><p>必須是2的冪且小於 1&lt;&lt;30。</p><pre><code>/*** The maximum capacity, used if a higher value is implicitly specified* by either of the constructors with arguments.* MUST be a power of two &lt;= 1&lt;&lt;30.*/static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code></pre><ul><li>為什麼是 1 &lt;&lt; 30？</li></ul><p>當然了 interger 的最大容量為 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">2^31-1</span></p><p>除此之外，2**31是20億，每個哈希條目需要一個對象作為條目本身，一個對象作為鍵，一個對象作為值。</p><p>在為應用程序中的其他內容分配空間之前，最小對象大小通常為24字節左右，因此這將是1440億字節。</p><p>可以肯定地說，最大容量限制只是理論上的。</p><p>感覺實際內存也沒這麼大！</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">負載因子</span></span></strong></h1><p>當負載因子較大時，去給table數組擴容的可能性就會少，所以相對佔用內存較少（空間上較少），但是每條entry鏈上的元素會相對較多，查詢的時間也會增長（時間上較多）。</p><p>反之就是，負載因子較少的時候，給table數組擴容的可能性就高，那麼內存空間佔用就多，但是entry鏈上的元素就會相對較少，查出的時間也會減少。</p><p>所以才有了負載因子是時間和空間上的一種折中的說法。</p><p>所以設置負載因子的時候要考慮自己追求的是時間還是空間上的少。</p><pre><code>/** * The load factor used when none specified in constructor. */static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre><ul><li>為什麼是 0.75，不是 0.8 或者 0.6</li></ul><p>其實 hashmap 源碼中有解釋。</p><pre><code>Because TreeNodes are about twice the size of regular nodes, weuse them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due toremoval or resizing) they are converted back to plain bins.  Inusages with well-distributed user hashCodes, tree bins arerarely used.  Ideally, under random hashCodes, the frequency ofnodes in bins follows a Poisson distribution(http://en.wikipedia.org/wiki/Poisson_distribution) with aparameter of about 0.5 on average for the default resizingthreshold of 0.75, although with a large variance because ofresizing granularity. Ignoring variance, the expectedoccurrences of list size k are (exp(-0.5) * pow(0.5, k) /factorial(k)). The first values are:0:    0.606530661:    0.303265332:    0.075816333:    0.012636064:    0.001579525:    0.000157956:    0.000013167:    0.000000948:    0.00000006more: less than 1 in ten million</code></pre><p>簡單翻譯一下就是在理想情況下,使用隨機哈希碼,節點出現的頻率在hash桶中遵循泊松分佈，同時給出了桶中元素個數和概率的對照表。</p><p>從上面的表中可以看到當桶中元素到達8個的時候，概率已經變得非常小，也就是說用0.75作為加載因子，每個碰撞位置的鏈表長度超過８個是幾乎不可能的。</p><p>Poisson distribution —— 泊松分佈</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">閾值</span></span></strong></h1><pre><code>/** * The bin count threshold for using a tree rather than list for a * bin.  Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64;</code></pre><h1 class=pgc-h-arrow-right><strong>TREEIFY_THRESHOLD</strong></h1><p>使用紅黑樹而不是列表的bin count閾值。</p><p>當向具有至少這麼多節點的bin中添加元素時，bin被轉換為樹。這個值必須大於2，並且應該至少為8，以便與樹刪除中關於收縮後轉換回普通容器的假設相匹配。</p><h1 class=pgc-h-arrow-right><strong>UNTREEIFY_THRESHOLD</strong></h1><p>在調整大小操作期間取消(分割)存儲庫的存儲計數閾值。</p><p>應小於TREEIFY_THRESHOLD，並最多6個網格與收縮檢測下去除。</p><h1 class=pgc-h-arrow-right><strong>MIN_TREEIFY_CAPACITY</strong></h1><p>最小的表容量，可為容器進行樹狀排列。(否則，如果在一個bin中有太多節點，表將被調整大小。)</p><p>至少為 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">4 * TREEIFY_THRESHOLD</span>，以避免調整大小和樹化閾值之間的衝突。</p><h1 class=pgc-h-arrow-right><strong>Node</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">源碼</span></span></strong></h1><ul><li>Node.java</li></ul><p>基礎 hash 結點定義。</p><pre><code>/** * Basic hash bin node, used for most entries.  (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {        this.hash = hash;        this.key = key;        this.value = value;        this.next = next;    }    public final K getKey()        { return key; }    public final V getValue()      { return value; }    public final String toString() { return key + "=" + value; }    public final int hashCode() {        return Objects.hashCode(key) ^ Objects.hashCode(value);    }    public final V setValue(V newValue) {        V oldValue = value;        value = newValue;        return oldValue;    }    public final boolean equals(Object o) {        // 快速判斷        if (o == this)            return true;        // 類型判斷            if (o instanceof Map.Entry) {            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;            if (Objects.equals(key, e.getKey()) &amp;&amp;                Objects.equals(value, e.getValue()))                return true;        }        return false;    }}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">個人理解</span></span></strong></h1><p>四個核心元素：</p><pre><code>final int hash; // hash 值final K key;    // keyV value;    // value 值Node&lt;K,V&gt; next; // 下一個元素結點</code></pre><h1 class=pgc-h-arrow-right><strong>hash 值的算法</strong></h1><p>hash 算法如下。</p><p>直接 key/value 的異或(<span style="color:#ef7060;--tt-darkmode-color: #EF7060">^</span>)。</p><pre><code>Objects.hashCode(key) ^ Objects.hashCode(value);</code></pre><p>其中 hashCode() 方法如下：</p><pre><code>public static int hashCode(Object o) {    return o != null ? o.hashCode() : 0;}</code></pre><p>最後還是會調用對象本身的 hashCode() 算法。一般我們自己會定義。</p><h1 class=pgc-h-arrow-right><strong>靜態工具類</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">hash</span></span></strong></h1><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><h1 class=pgc-h-arrow-right><strong>為什麼這麼設計？</strong></h1><ul><li>jdk8 自帶解釋</li></ul><p>計算key.hashCode()，並將(XORs)的高比特位分散到低比特位。</p><p>因為表使用的是power-of-two掩蔽，所以只在當前掩碼上方以位為單位變化的哈希總是會發生衝突。</p><p>(已知的例子中有一組浮點鍵，它們在小表中保存連續的整數。)</p><p>因此，我們應用了一種轉換，將高比特的影響向下傳播。</p><p>比特傳播的速度、效用和質量之間存在權衡。</p><p>因為許多常見的散列集已經合理分佈(所以不要受益於傳播),因為我們用樹來處理大型的碰撞在垃圾箱,我們只是XOR一些改變以最便宜的方式來減少系統lossage,以及將最高位的影響,否則永遠不會因為指數計算中使用的表。</p><ul><li>知乎的解釋</li></ul><p>這段代碼叫<strong>擾動函數</strong>。</p><p>HashMap擴容之前的數組初始大小才16。所以這個散列值是不能直接拿來用的。</p><p>用之前還要先做對數組的長度取模運算，得到的餘數才能用來訪問數組下標。</p><p><span style="color:#ef7060;--tt-darkmode-color: #EF7060">putVal</span> 函數源碼</p><pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        //...    }</code></pre><p>其中這一句 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">tab[i = (n - 1) & hash])</span></p><p>這一步就是在尋找桶的過程，就是上圖總數組，根據容量取如果容量是16 對hash值取低16位，那麼下標範圍就在容量大小範圍內了。</p><p>這裡也就解釋了為什麼 hashmap 的大小需要為 2 的正整數冪，因為這樣（數組長度-1）正好相當於一個“低位掩碼”。</p><p>比如大小 16，則 (16-1) = 15 = 00000000 00000000 00001111(二進制);</p><pre><code>    10100101 11000100 00100101&amp; 00000000 00000000 00001111-------------------------------    00000000 00000000 00000101    //高位全部歸零，只保留末四位</code></pre><p>但是問題是，散列值分佈再鬆散，要是隻取最後幾位的話，碰撞也會很嚴重。</p><p>擾動函數的價值如下：</p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/40c0a82a79934b76ba93bff886f76c51><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">擾動函數的價值</span></p><p>右位移16位，正好是32bit的一半，自己的高半區和低半區做異或，就是為了混合原始哈希碼的高位和低位，以此來加大低位的隨機性。</p><p>而且混合後的低位摻雜了高位的部分特徵，這樣高位的信息也被變相保留下來。</p><p>優化哈希的原理介紹</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">comparable class</span></span></strong></h1><ul><li>comparableClassFor()</li></ul><p>獲取對象 x 的類，如果這個類實現了 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">class C implements Comparable&lt;C></span> 接口。</p><p>ps: 這個方法很有借鑑意義，可以做簡單的拓展。我們可以獲取任意接口泛型中的類型。</p><pre><code>static Class&lt;?&gt; comparableClassFor(Object x) {    if (x instanceof Comparable) {        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;        if ((c = x.getClass()) == String.class) // bypass checks            return c;        if ((ts = c.getGenericInterfaces()) != null) {            for (int i = 0; i &lt; ts.length; ++i) {                if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;                    ((p = (ParameterizedType)t).getRawType() ==                     Comparable.class) &amp;&amp;                    (as = p.getActualTypeArguments()) != null &amp;&amp;                    as.length == 1 &amp;&amp; as[0] == c) // type arg is c                    return c;            }        }    }    return null;}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">compareComparables()</span></span></strong></h1><p>獲取兩個可比較對象的比較結果。</p><pre><code>@SuppressWarnings({"rawtypes","unchecked"}) // for cast to Comparablestatic int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {    return (x == null || x.getClass() != kc ? 0 :            ((Comparable)k).compareTo(x));}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">tableSizeFor</span></span></strong></h1><p>獲取 2 的冪</p><pre><code>static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><ul><li>被調用處</li></ul><pre><code>public HashMap(int initialCapacity, float loadFactor) {    // check...    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);}</code></pre><ul><li>感想</li></ul><p>emmm....為什麼要這麼寫？性能嗎？</p><h1 class=pgc-h-arrow-right><strong>簡單分析</strong></h1><p>當在實例化HashMap實例時，如果給定了initialCapacity，由於HashMap的capacity都是2的冪，因此這個方法用於找到大於等於initialCapacity的最小的2的冪（initialCapacity如果就是2的冪，則返回的還是這個數）。</p><ul><li>為什麼要 -1</li></ul><p><span style="color:#ef7060;--tt-darkmode-color: #EF7060">int n = cap - 1;</span></p><p>首先，為什麼要對cap做減1操作。int n = cap - 1; 這是為了防止，cap已經是2的冪。如果cap已經是2的冪， 又沒有執行這個減1操作，則執行完後面的幾條無符號右移操作之後，返回的capacity將是這個cap的2倍。如果不懂，要看完後面的幾個無符號右移之後再回來看看。</p><p>下面看看這幾個無符號右移操作：</p><p>如果n這時為0了（經過了cap-1之後），則經過後面的幾次無符號右移依然是0，最後返回的capacity是1（最後有個n+1的操作）。</p><p>這裡只討論n不等於0的情況。</p><ul><li>第一次位運算</li></ul><p><span style="color:#ef7060;--tt-darkmode-color: #EF7060">n |= n >>> 1;</span></p><p>由於n不等於0，則n的二進制表示中總會有一bit為1，這時考慮最高位的1。</p><p>通過無符號右移1位，則將最高位的1右移了1位，再做或操作，使得n的二進制表示中與最高位的1緊鄰的右邊一位也為1，如000011xxxxxx。</p><p>其他依次類推</p><h1 class=pgc-h-arrow-right><strong>實例</strong></h1><p>比如 initialCapacity = 10;</p><pre><code>表達式                       二進制------------------------------------------------------    initialCapacity = 10;int n = 9;                  0000 1001------------------------------------------------------    n |= n &gt;&gt;&gt; 1;               0000 1001                            0000 0100   (右移1位) 或運算                          = 0000 1101------------------------------------------------------    n |= n &gt;&gt;&gt; 2;               0000 1101                            0000 0011   (右移2位) 或運算                          = 0000 1111------------------------------------------------------    n |= n &gt;&gt;&gt; 4;               0000 1111                            0000 0000   (右移4位) 或運算                          = 0000 1111------------------------------------------------------  n |= n &gt;&gt;&gt; 8;               0000 1111                            0000 0000   (右移8位) 或運算                          = 0000 1111------------------------------------------------------  n |= n &gt;&gt;&gt; 16;              0000 1111                            0000 0000   (右移16位) 或運算                          = 0000 1111------------------------------------------------------  n = n+1;                    0001 0000    結果：2^4 = 16;      </code></pre><h1 class=pgc-h-arrow-right><strong>put() 解釋</strong></h1><p>下面的內容出自美團博客 Java 8系列之重新認識HashMap</p><p>由於寫的非常好，此處就直接複製過來了。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">流程圖解</span></span></strong></h1><p>HashMap的put方法執行過程可以通過下圖來理解，自己有興趣可以去對比源碼更清楚地研究學習。</p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f7b60b03bc404abbb8e08dada0ebf4c3><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">輸入圖片說明</span></p><p>①.判斷鍵值對數組table[i]是否為空或為null，否則執行resize()進行擴容；</p><p>②.根據鍵值key計算hash值得到插入的數組索引i，如果table[i]==null，直接新建節點添加，轉向⑥，如果table[i]不為空，轉向③；</p><p>③.判斷table[i]的首個元素是否和key一樣，如果相同直接覆蓋value，否則轉向④，這裡的相同指的是hashCode以及equals；</p><p>④.判斷table[i] 是否為treeNode，即table[i] 是否是紅黑樹，如果是紅黑樹，則直接在樹中插入鍵值對，否則轉向⑤；</p><p>⑤.遍歷table[i]，判斷鏈表長度是否大於8，大於8的話把鏈表轉換為紅黑樹，在紅黑樹中執行插入操作，否則進行鏈表的插入操作；遍歷過程中若發現key已經存在直接覆蓋value即可；</p><p>⑥.插入成功後，判斷實際存在的鍵值對數量size是否超多了最大容量threshold，如果超過，進行擴容。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">方法源碼</span></span></strong></h1><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><h1 class=pgc-h-arrow-right><strong>擴容機制</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">簡介</span></span></strong></h1><p>擴容(resize)就是重新計算容量，向HashMap對象裡不停的添加元素，而HashMap對象內部的數組無法裝載更多的元素時，對象就需要擴大數組的長度，以便能裝入更多的元素。</p><p>當然Java裡的數組是無法自動擴容的，方法是使用一個新的數組代替已有的容量小的數組，就像我們用一個小桶裝水，如果想裝更多的水，就得換大水桶。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">JDK7 源碼</span></span></strong></h1><p>我們分析下resize()的源碼，鑑於JDK1.8融入了紅黑樹，較複雜，為了便於理解我們仍然使用JDK1.7的代碼，好理解一些，本質上區別不大，具體區別後文再說。</p><pre><code>void resize(int newCapacity) {   //傳入新的容量    Entry[] oldTable = table;    //引用擴容前的Entry數組    int oldCapacity = oldTable.length;             if (oldCapacity == MAXIMUM_CAPACITY) {  //擴容前的數組大小如果已經達到最大(2^30)了        threshold = Integer.MAX_VALUE; //修改閾值為int的最大值(2^31-1)，這樣以後就不會擴容了        return;    }    Entry[] newTable = new Entry[newCapacity];  //初始化一個新的Entry數組    transfer(newTable);                         //！！將數據轉移到新的Entry數組裡    table = newTable;                           //HashMap的table屬性引用新的Entry數組    threshold = (int)(newCapacity * loadFactor);//修改閾值}</code></pre><p>這裡就是使用一個容量更大的數組來代替已有的容量小的數組，transfer() 方法將原有Entry數組的元素拷貝到新的Entry數組裡。</p><pre><code>void transfer(Entry[] newTable) {    Entry[] src = table;                   //src引用了舊的Entry數組    int newCapacity = newTable.length;    for (int j = 0; j &lt; src.length; j++) { //遍歷舊的Entry數組        Entry&lt;K,V&gt; e = src[j];             //取得舊Entry數組的每個元素        if (e != null) {            src[j] = null;//釋放舊Entry數組的對象引用（for循環後，舊的Entry數組不再引用任何對象）            do {                Entry&lt;K,V&gt; next = e.next;                int i = indexFor(e.hash, newCapacity); //！！重新計算每個元素在數組中的位置                e.next = newTable[i]; //標記[1]                newTable[i] = e;      //將元素放在數組上                e = next;             //訪問下一個Entry鏈上的元素            } while (e != null);        }    }}</code></pre><p>newTable[i]的引用賦給了e.next，也就是使用了單鏈表的頭插入方式，同一位置上新元素總會被放在鏈表的頭部位置；</p><p>這樣先放在一個索引上的元素終會被放到Entry鏈的尾部(如果發生了hash衝突的話），這一點和Jdk1.8有區別，下文詳解。</p><p>在舊數組中同一條Entry鏈上的元素，通過重新計算索引位置後，有可能被放到了新數組的不同位置上。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">案例</span></span></strong></h1><p>下面舉個例子說明下擴容過程。假設了我們的hash算法就是簡單的用key mod 一下表的大小（也就是數組的長度）。</p><p>其中的哈希桶數組table的size=2， 所以key = 3、7、5，put順序依次為 5、7、3。</p><p>在mod 2以後都衝突在table[1]這裡了。</p><p>這裡假設負載因子 loadFactor=1，即當鍵值對的實際大小size 大於 table的實際大小時進行擴容。</p><p>接下來的三個步驟是哈希桶數組 resize成4，然後所有的Node重新rehash的過程。</p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/83c8fc71fb9c4c0dad2d535dcc034564><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">輸入圖片說明</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">Jdk8 優化</span></span></strong></h1><p>經過觀測可以發現，我們使用的是2次冪的擴展(指長度擴為原來2倍)，所以，元素的位置要麼是在原位置，要麼是在原位置再移動2次冪的位置。</p><p>看下圖可以明白這句話的意思，n為table的長度，圖（a）表示擴容前的key1和key2兩種key確定索引位置的示例，</p><p>圖（b）表示擴容後key1和key2兩種key確定索引位置的示例，其中hash1是key1對應的哈希與高位運算結果。</p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64fe8a5a9a444aecb1bd51105502e52d><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">位運算</span></p><p>元素在重新計算hash之後，因為n變為2倍，那麼n-1的mask範圍在高位多1bit(紅色)，因此新的index就會發生這樣的變化：</p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/867ec10252554326abee817ae01e976d><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">index</span></p><p>因此，我們在擴充HashMap的時候，不需要像JDK1.7的實現那樣重新計算hash，只需要看看原來的hash值新增的那個bit是1還是0就好了，是0的話索引沒變，是1的話索引變成“原索引+oldCap”，可以看看下圖為16擴充為32的resize示意圖：</p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/09f336771f9747de8ca8acfa6dba4eb6><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">rehash</span></p><p>這個設計確實非常的巧妙，既省去了重新計算hash值的時間，而且同時，由於新增的1bit是0還是1可以認為是隨機的，因此resize的過程，均勻的把之前的衝突的節點分散到新的bucket了。</p><p>這一塊就是JDK1.8新增的優化點。</p><p>有一點注意區別，JDK1.7中rehash的時候，舊鏈表遷移新鏈表的時候，如果在新表的數組索引位置相同，則鏈表元素會倒置，但是從上圖可以看出，JDK1.8不會倒置。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">JDK8 源碼</span></span></strong></h1><p>有興趣的同學可以研究下JDK1.8的resize源碼，寫的很贊:</p><pre><code>/** * Initializes or doubles table size.  If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({"rawtypes","unchecked"})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><h1 class=pgc-h-arrow-right><strong>小結</strong></h1><p>如果你已經通讀全文，那麼你已經非常厲害了。</p><p>其實第一遍沒有徹底理解也沒有關係，知道 HashMap 有一個 reHash 的過程就行，類似於 ArrayList 的 resize。</p><p>下一節我們將一起學習下自己手寫實現一個漸進式 rehash 的 HashMap，感興趣的可以關注一下，便於實時接收最新內容。</p><p>覺得本文對你有幫助的話，歡迎點贊評論收藏轉發一波。你的鼓勵，是我最大的動力~</p><p>不知道你有哪些收穫呢？或者有其他更多的想法，歡迎留言區和我一起討論，期待與你的思考相遇。</p><p>文中較多鏈接失效，可以點擊 {閱讀原文}。</p><p><br></p><div class=pgc-img><img alt="從零開始手寫 redis(13) HashMap源碼詳解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ce799b70434643b893b21bf70e813158><p class=pgc-img-caption>深入學習</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>零開始</a></li><li><a>手寫</a></li><li><a>redis</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f74c4fe8.html alt=從零開始服務器搭建wordpress網站詳細建站教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/991db5d6ab1c4209bc6bb9fb185a69b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f74c4fe8.html title=從零開始服務器搭建wordpress網站詳細建站教程>從零開始服務器搭建wordpress網站詳細建站教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html alt="web前端（從零開始），每天更新學習筆記 HTML5元素分類" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/46d70004fcd55e1ddad3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html title="web前端（從零開始），每天更新學習筆記 HTML5元素分類">web前端（從零開始），每天更新學習筆記 HTML5元素分類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e5b92f2.html alt=Mini-patch：從零開始的反向傳播（附詳細代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0b58b4457c95428a8f14c71e2da9c021 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e5b92f2.html title=Mini-patch：從零開始的反向傳播（附詳細代碼）>Mini-patch：從零開始的反向傳播（附詳細代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaf6fcd.html alt=手寫壁紙｜你從這邊走向那邊，你避開了我的一生 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535341020756dc1a9b3f3f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaf6fcd.html title=手寫壁紙｜你從這邊走向那邊，你避開了我的一生>手寫壁紙｜你從這邊走向那邊，你避開了我的一生</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/882264f6.html alt=26個英文字母逐字母手寫模板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/839d9b3c13514c34bdee8c146f18fef6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/882264f6.html title=26個英文字母逐字母手寫模板>26個英文字母逐字母手寫模板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ebd12f8.html alt=在線仿真手寫文稿生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/037e6191d7d64ce68d87b59280afc56e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ebd12f8.html title=在線仿真手寫文稿生成器>在線仿真手寫文稿生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be61162.html alt=手寫AOP實現過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6ac9667b9b064f57903047a4156004fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be61162.html title=手寫AOP實現過程>手寫AOP實現過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83ffff02.html alt="redis緩存穿透, 緩存雪崩, 熱點緩存以及緩存雙寫一致性問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83ffff02.html title="redis緩存穿透, 緩存雪崩, 熱點緩存以及緩存雙寫一致性問題">redis緩存穿透, 緩存雪崩, 熱點緩存以及緩存雙寫一致性問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a9f55ba8.html alt=從零開始學畫畫（素描）——柱體的明暗畫法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a454da0546054f64aefe4939b22ef87e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a9f55ba8.html title=從零開始學畫畫（素描）——柱體的明暗畫法>從零開始學畫畫（素描）——柱體的明暗畫法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84915242.html alt=一起從零開始學習網絡架構設計-出口區設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9c9125f248b744768c280209b4917f01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84915242.html title=一起從零開始學習網絡架構設計-出口區設計>一起從零開始學習網絡架構設計-出口區設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2858bec0.html alt=從零開始的計算機系統，從本質上深入理解計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3b020000cc2d7ccbd819 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2858bec0.html title=從零開始的計算機系統，從本質上深入理解計算機>從零開始的計算機系統，從本質上深入理解計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b19386c.html alt=「HTML」從零開始學網頁製作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8b2d93848870404498f8f08839c22549 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b19386c.html title=「HTML」從零開始學網頁製作>「HTML」從零開始學網頁製作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f665872d.html alt="「數據庫」 redis入門到實戰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f665872d.html title="「數據庫」 redis入門到實戰">「數據庫」 redis入門到實戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/28ad5227.html alt=教你畫彩色線描畫，從零開始，學會了再也不用羨慕別人的線描了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8bf90b4089d146ff873a47b18dfb6582 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/28ad5227.html title=教你畫彩色線描畫，從零開始，學會了再也不用羨慕別人的線描了！>教你畫彩色線描畫，從零開始，學會了再也不用羨慕別人的線描了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/64abfba7.html alt=書寫黑科技，手寫記錄也能做到電子“備份”—UPEN智能筆體驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/567f00015b1d82f246d3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/64abfba7.html title=書寫黑科技，手寫記錄也能做到電子“備份”—UPEN智能筆體驗>書寫黑科技，手寫記錄也能做到電子“備份”—UPEN智能筆體驗</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>