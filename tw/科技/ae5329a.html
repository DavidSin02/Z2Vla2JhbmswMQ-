<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「每週FPGA案例」 SDRAM讀寫控制器（二） | 极客快訊</title><meta property="og:title" content="「每週FPGA案例」 SDRAM讀寫控制器（二） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/01017b3cb6b744ca9e316182a69a95a9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><meta property="article:published_time" content="2020-10-29T20:51:12+08:00"><meta property="article:modified_time" content="2020-10-29T20:51:12+08:00"><meta name=Keywords content><meta name=description content="「每週FPGA案例」 SDRAM讀寫控制器（二）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ae5329a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「每週FPGA案例」 SDRAM讀寫控制器（二）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">1.5.2SDRAM工作流程</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">SDRAM初始化</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><span style="color:#444;--tt-darkmode-color: #A2A2A2">在</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">SDRAM內部有一個邏輯控制單元，並且有一個模式寄存器為其提供控制參數。每次開機時SDRAM都要先對這個控制邏輯核心進行初始化。SDRAM必須以預定義的方式啟動和初始化。</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">在</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">電源同時作用於Vdd和Vddq後開始初始化SDRAM，此時的時鐘穩定並且將數據掩碼和時鐘使能信號拉高。在向SDRAM發送命令之前需要有100us的延時，此時SDRAM不執行任何操作。在100us延時滿足後，需要對Bank進行預充電，在此期間所有的Bank處於空閒狀態。預充電之後會有至少兩個自刷新操作，完成自刷新便可以對SDRAM進行模式寄存器配置。下面是初始化的時序圖<br></span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01017b3cb6b744ca9e316182a69a95a9><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>從上圖中可以看出，上電後等待時間為T=100us，預充電操作需要的時間為TRP，一次自刷新需要的時間是TRC，加載模式寄存器需要的時間為TMRD。<br>在初始化中的預充電期間，地址線A10定義自動預充電，以確定是否所有Bank都被預充電，也可以通過Bank地址選擇信號BA0和BA1來決定進行預充電的Bank地址。在加載模式寄存器期間，地址線A0到A11一起組成命令碼。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">SDRAM行激活</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>初始化完成之後，在向SDRAM發送讀或者寫命令之前必須打開該Bank中的一行，通過ACTIVE命令來確定要激活的Bank和行。要想對一個Bank中的陣列進行尋址，首先要確定行（Row），然後確定列。片選信號與Bank選擇信號與行有效同時進行，下面是激活的時序圖</span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44eac32d8d0048bfaefdd3138e26f253><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>從上圖中可以看出，在片選信號、Bank地址選定的同時，行地址選通信號RAS也處於有效狀態，此時An地址線發送具體的行地址。行地址位寬為12，共可以指示2^12=4096個具體的行地址。當行地址被激活後，相應的Bank也被激活，因此行激活又叫L-Bank激活。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">列</span></strong><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">選擇</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>行地址確定後，就要對列地址進行尋址，地址線仍使用A0~A11，即行地址與列地址共用地址線。當列地址選通後，就需要對SDRAM進行</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">讀寫</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">，而給SDRAM讀命令還是寫命令由WE信號決定。當WE信號拉低時，SDRAM接收到的是寫命令；當WE拉高，SDRAM接收讀命令。列尋址信號與讀寫命令是同時發出的。雖然地址線與行尋址共用，但列地址選通脈衝CAS則可以區分開行與列尋址的不同，配合A0~A9、A11來確定具體的地址。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>在發送列讀寫命令時必須要與有效命令有一個時間間隔，這個時間間隔被定義為TRCD。<br></span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f56afffd10b4573b70fedcd555932f6><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">讀操作</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>讀命令從輸入信號BA0、BA1中選取要進行讀數據操作的BANK，並在已激活的行中進行突發讀寫操作。輸入的A0~A7用來進行列尋址。在選定列地址後，就已經確定了具體的存儲單元，剩下的事情就是數據通過dq輸出到內存總線上了。但是</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">再</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">CAS發出之後，仍要經過一定的時間才能有數據輸出，從CAS與讀取命令發出到第一個數據輸出的這段時間，被定義為CALLatency（CAS潛伏期）。由於此現象只在讀的時候出現，所以又稱作讀潛伏期</span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a31d09c268d44e8c9c707b858e89a5aa><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>由於存儲體中晶體管存在反應時間，從而造成數據不可能與CAS 在同一上升沿觸發，因此要延後至少一個時鐘週期。考慮到芯片體積較小的因素，存儲單元中的電容容量很小，所以信號要經過放大來保證其有效的識別性，這個放大/驅動工作由 S-AMP 負責，一個存儲體對應一個 S-AMP 通道。但它要有一個準備時間才能保證信號的發送強度（事前還要進行電壓比較以進行邏輯電平的判斷），因此從數據 I/O 總線上有數據輸出之前的一個時鐘上升沿開始，數據即已傳向 S-AMP，也就是說此時數據已經被觸發，經過一定的驅動時間最終傳向數據 I/O 總線進行輸出，這段時間我們稱之為 tAC（Access-Time-from-CLK，時鐘觸發後的訪問時間），單位是 ns。在突發讀操作完成後，如果選擇了自動預充電模式，那麼該行就會直接進入充電。如果沒有選擇此模式，那麼該行將保持打開狀態，供後續訪問。自動預充電模式的選擇與 A10的值有關，A10 為高時為自動預充電命令模式。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">寫操作</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>數據寫入的操作也是在 tRCD 之後進行，但此時沒有 CL（CL 只出現在讀取操作中），行尋址與列尋址的時序一樣致，只是在列尋址時，WE#為有效狀態。由於數據信號由控制端發出，輸入時芯片無需做任何調校，只需直接傳到數據輸入寄存器中，然後再由寫入驅動器進行對存儲電容的充電操作，因此數據可以與 CAS 同時發送，也就是說寫入延遲為 0。不過，數據並不是即時地寫入存儲電容，因為選通三極管（就如讀取時一樣）與電容的充電必須要有一段時間，所以數據的真正寫入需要一定的週期。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">突發</span></strong><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">讀寫</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>突發（Burst）是指在同一行中相鄰的存儲單元連續進行數據傳輸的方式，連續傳輸所涉及到存儲單元（列）的數量就是突發長度（Burst Lengths，簡稱 BL）。前文講到的讀/寫操作，都是一次對一個存儲單元進行尋址，如果想要連續的向 SDRAM 中讀數據或者寫數據，就需要對當前存儲單元的下一個單元進行尋址，也即是需要不停給 SDRAM 列激活信號以及讀/寫命令（行地址不變，所以不用再對行尋址）。雖然由於讀/寫延遲相同可以讓數據的傳輸在 I/O 端是連續的，但它佔用了大量的內存控制資源，在數據進行連續傳輸時無法輸入新的命令，效率很低。為此，人們開發了突發傳輸技術，只要指定起始列地址與突發長度，SDRAM 就會不再需要控制器連續地提供列地址，依次地自動對後面相應數量的存儲單元進行讀/寫操作。這樣，在突發模式讀寫中，除了第一個數據的傳輸需要若干個週期（主要是之前的延遲，一般的是tRCD+CL），其後每個數據只需一個週期的即可獲</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">。至於突發長度 BL 的數值，也是不能隨便設或在數據進行傳輸前臨時決定，而是在上文講到的 SDRAM 初始化過程中模式寄存器配置階段就要對突發長度進行設置。目前可用的選項是 1、2、4、8、全頁（FullPage），常見的突發長度設定是 BL=4、BL=8 或者全頁突發模式。<br></span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/930a10d626074f5d80c17833fce26dfd><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">1.5.3設計思路</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>經過上面對SDRAM工作流程的介紹，可以採用狀態機作為本工程的一個架構，根據指令的不同，劃分為8個狀態，分別為空操作（NOP）、預充電（PER）、自刷新（REF）、加載模式寄存器（MOD）、空閒（IDL）、激活（ACT）、讀數據（RED）和寫數據（WIR）。由於每個操作需要的時間都不同，因此需要一個計數器來對每個操作需要的時間進行計數。<br></span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb0295691f274e4fa0908921d8dbc06c><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>該計數器加一條件為state_c!=IDL，表示只要不是處於空閒狀態，就進行計數；結束條件為數x個，x根據目前所處的狀態的不同而不同，具體數據可以看下面的表格。 當前狀態 計數器數多少個空操作（NOP）20000預充電（PER）2自刷新（REF）7加載模式寄存器（MOD）2激活（ACT）2讀/寫數據（RED/WIR）512<br>由於再初始化階段，自刷新需要連續進行兩次，因此需要將初始化階段區分出來，設計一個初始化指示信號init_flag：該信號初始狀態為高電平，表示上電之後SDRAM處於初始化階段；當初始化完成之後變為低電平，因此從高變低的條件為mod2idl_start。<br>自刷新計數器cnt1：該計數器表示初始化階段進行自刷新的次數。加一條件為(init_flag && state_c==REF && end__cnt)，表示在初始化階段，如果當前狀態為自刷新，則時鐘計數器數完一次就加一；結束條件為數兩個，初始化階段共進行兩次自刷新，因此只需要數兩個即可。<br>在初始化完成之後，需要進行自刷新、讀數據和寫數據等操作，由於自刷新是必須進行的，因此自刷新請求的優先級是最高的，那麼讀請求和寫請求的優先級怎麼確定呢？假設設置讀請求的優先級高於寫請求，讀請求和寫請求一起來的時候，總是先執行讀請求，如果讀請求一直有效的話，便不會執行寫操作。反之設置寫請求的優先級高於讀請求，也會出現這樣的問題，這當然是不可以的。因此我們設置為如果兩個請求不是同時有效，則哪一個有效便執行哪一個。如果同時來的時候，第一次同時來，先執行寫操作，第二次同時有效的時候在執行寫操作，如此交替進行即可。通過兩個信號進行控制：<br>讀操作指示信號flag_rd：初始狀態為低電平，表示上一次執行的寫操作；從低變高的條件為state_c==RED，表示如果執行的是讀操作，則置為高電平；當執行的是寫操作的時候，該信號置為0，所以變0的條件是state_c==WIR。<br>讀寫同步指示信號flag_syn：初始狀態為0，表示讀寫請求沒有同時有效，如果當前處於激活狀態，並且讀寫請求同時有效，則置為1，當激活狀態結束，重新變為0。<br>設計中的輔助信號已經完成的差不多了，下面開始進行狀態機的架構，架構圖如下圖所示：<br></span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9d7183138a424d51ad2a9981709c2e3f><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>下面介紹一個各個狀態之間的跳轉條件。<br>上電之後，先進入空操作狀態，在空操作狀態下：<br>1、 延時100us之後，進入到預充電狀態。<br>當處於預充電狀態的時候：<br>1、 如果處於初始化階段，兩個時鐘週期之後，跳轉到自刷新狀態。2、 如果不是初始化階段，兩個時鐘週期之後，跳轉到空閒狀態。<br>當處於自刷新狀態時：<br>1、 如果處於初始化狀態，7個時鐘週期之後，跳轉到自刷新狀態。2、 如果處於初始化狀態，並且已經進行過一次初始化，7個時鐘週期之後，跳轉到加載模式寄存器狀態。3、 如果不是初始化階段，7個時鐘週期之後，跳轉到空閒狀態。<br>當處於加載模式寄存器狀態時：<br>1、 2個時鐘週期之後，進入到空閒狀態。當處於空閒狀態時：<br>1、 如果收到自刷新請求，則跳轉到自刷新狀態。2、 如果自刷新請求無效，收到讀/寫請求，則跳轉到激活狀態。<br>當處於處於激活狀態時：<br>1、 當讀寫請求不同時的時候，接收到讀請求，則跳轉到讀狀態。2、 當讀寫請求不同時的時候，接收到寫請求，則跳轉到寫狀態3、 當讀寫請求同時到達的時候，第一次來的時候，首先響應讀請求，跳轉到讀狀態4、 當讀寫請求同時到達，但不是第一次同時有效的時候，則根據上一次執行的操作進行判斷，如果上一次執行的讀操作，則這次執行寫操作，跳轉到寫狀態；如果上一次執行的寫操作，則這次執行讀操作，跳轉到讀狀態。當處於寫狀態的時候：<br>1、 寫數據完成，就進入到預充電狀態。<br>當處於讀狀態的時候：<br>1、 讀數據完成，就進入到預充電狀態。<br>指令集信號conmand：該信號共4bit，從最高位到最低位分別表示cs、ras、cas、we。在空操作階段，指令為4’b0111；在預充電階段，指令為4’b0010；在自刷新階段，指令為4’b0001；在加載模式寄存器階段，指令為4’b0000；在激活階段，指令為4’b0011；在讀數據階段，指令為4’b0101；在寫數據階段，指令為4’b0100。這些操作對應的指令碼都是從圖中的表格中查找得來。<br></span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8513a96b5c1448b298caeee29e2680b7><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>數據掩碼dqm：初始狀態為2’b11，表示輸入得兩個字節數據無效。當初始化完成之後，變為2’b00，表示輸入</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">兩個字節數據有效。<br>時鐘使能cke：復位時為0，表示輸入時鐘無效，復位結束之後為1，表示輸入時鐘有效。<br>Bank選擇信號sd_bank：初始狀態為2’b00，表示選擇Bank0；在激活階段、讀階段和寫階段，該信號由輸入得bank信號決定。<br>SDRAM地址選擇信號sd_addr：由於本工程採用的預充電模式為全Bnak自動預充電，該模式由地址線A10控制，因此在預充電</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">時候，地址指令為13’b001_0_00_000_0_000；在激活的時候提供</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">行</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">地址；在加載模式寄存器得時候，地址線提供運算碼，這時每個地址表示得意思</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">入</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">下圖所示，A9決定讀模式，A6、A5、A4決定讀數據得潛伏期，A3決定突發類型，A2、A1、A0決定突發長度。<br></span></p><div class=pgc-img><img alt="「每週FPGA案例」 SDRAM讀寫控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a1bb5d9db4f4e069c89c07d781335c1><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>由於MP801開發板使用得SDRAM有兩種型號，一種是W9812G6KH，共4096行，自刷新週期為1562，另一種是H57V2562GTR，共8192行，自刷新週期為780。在使用</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">時候需要注意開發板型號，這裡我們以H57V2562GTR為例。自刷新需要以下信號：<br>時鐘計數器cnt_780：該計數器主要得作用是初始化結束之後，</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">數自</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">刷新得週期；加一條件為init_flag==0，表示初始化結束就開始計數；結束條件為數780個，數完就清零。<br>自刷新請求ref_req：初始狀態為0，表示不需要進行自刷新，當時鍾計數器cnt_780數完</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">時候，ref_req拉高，請求進行自刷新，如果當前處於空閒狀態，則進行自刷新，如果不是，則等待。<br>可能有人會想，如果不是空閒狀態，就要等待，這樣會不會對數據保存造成影響？其實不會得，存儲器要求64ms全部刷新一遍，但不需要每一行刷新</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">間隔都一樣。當時鍾計數器cnt_780數完之後，產生自刷新請求，同時時鐘計數器又會開始計數，所以可能自刷新</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">間隔不同，但每一行肯定能在64ms內刷新1次。寫SDRAM數據信號dq_out：該信號直接等於寫數據wdata（注意，需要用組合邏輯實現）。<br>三態門使能信號dq_out_en：初始狀態為0，表示使能無效，在寫數據期間，變為高電平，表示使能有效。<br>讀SDRAM數據信號rdata：直接將sdram輸出數據dq_in連接即可。<br>讀數據有效指示信號rdata_vld：由於存在讀數據潛伏期，根據設置得潛伏期得長度，將rdata_vld進行相應得延時。<br></span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>每週</a></li><li><a>FPGA</a></li><li><a>SDRAM</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ca6277.html alt="「每週FPGA案例」 SDRAM讀寫控制器設計（一）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f670d48a5dc24f91b7dee7524a810099 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ca6277.html title="「每週FPGA案例」 SDRAM讀寫控制器設計（一）">「每週FPGA案例」 SDRAM讀寫控制器設計（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html alt=FPGA無線通信課程連載——擾碼的原理及實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RzH3OlM2Sr7uEv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html title=FPGA無線通信課程連載——擾碼的原理及實現>FPGA無線通信課程連載——擾碼的原理及實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html alt=FPGA管腳調整注意事項及技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rt0Fp44Iqh26UT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html title=FPGA管腳調整注意事項及技巧>FPGA管腳調整注意事項及技巧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1960cbb9.html alt=小區外人員一律不得進入，居民每週兩次指派1人外出採購……漢濱中心城區開始管控 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RpKQYiz2BK1lFX style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1960cbb9.html title=小區外人員一律不得進入，居民每週兩次指派1人外出採購……漢濱中心城區開始管控>小區外人員一律不得進入，居民每週兩次指派1人外出採購……漢濱中心城區開始管控</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/554edda1.html alt=「每週觀點」收益率曲線隱含了什麼信息？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15353032388447c24aa82b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/554edda1.html title=「每週觀點」收益率曲線隱含了什麼信息？>「每週觀點」收益率曲線隱含了什麼信息？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/df2d4da3.html alt=「每週觀點」曲線“牛平”的邏輯 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R77gHBrAwWGLwI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/df2d4da3.html title=「每週觀點」曲線“牛平”的邏輯>「每週觀點」曲線“牛平”的邏輯</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html title=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示>正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dcd15269.html alt=每週損失約195億！澳大利亞經濟或雪上加霜：24萬家企業面臨倒閉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ec3cd56b2b274d558510633aa58ca480 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dcd15269.html title=每週損失約195億！澳大利亞經濟或雪上加霜：24萬家企業面臨倒閉>每週損失約195億！澳大利亞經濟或雪上加霜：24萬家企業面臨倒閉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html title="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗">正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html alt=基於FPGA的多通道同步實時高速數據採集系統設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RT9ec7T8clHaQI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html title=基於FPGA的多通道同步實時高速數據採集系統設計>基於FPGA的多通道同步實時高速數據採集系統設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51718fda.html alt=FPGA基礎之時序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b67909f181e2497f883a202aadca9129 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51718fda.html title=FPGA基礎之時序設計>FPGA基礎之時序設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/769d1d2c04b9410aa18cd0add525013f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/436e2022.html title=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了>「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3006b33b.html alt=基於FPGA的LVDS高可靠性傳輸優化設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153533281868967dc1af365 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3006b33b.html title=基於FPGA的LVDS高可靠性傳輸優化設計>基於FPGA的LVDS高可靠性傳輸優化設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html alt=FPGA為什麼可編程，這篇文章來告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7abe76ede514e308d57ca293420a430 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6aea576.html title=FPGA為什麼可編程，這篇文章來告訴你>FPGA為什麼可編程，這篇文章來告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07498dad.html alt=每週一式：鷹式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/149a0002db54196fe56e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07498dad.html title=每週一式：鷹式>每週一式：鷹式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>