<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Flink 滑動窗口優化 | 极客快訊</title><meta property="og:title" content="Flink 滑動窗口優化 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/efb733b701294ed085d37f6a8871e99f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aed6c673.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aed6c673.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aed6c673.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aed6c673.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aed6c673.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aed6c673.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aed6c673.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aed6c673.html><meta property="article:published_time" content="2020-11-14T21:04:55+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:55+08:00"><meta name=Keywords content><meta name=description content="Flink 滑動窗口優化"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/aed6c673.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Flink 滑動窗口優化</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>一、前言</p><p class=ql-align-justify>Flink 的窗口功能非常強大，因為要支持各種各樣的窗口，像滑動窗口和滾動窗口這樣的對齊窗口，像會話窗口這樣的非對齊窗口，複雜度也會比較高。其中在超長滑動窗口的性能上也不盡如人意。這篇文章首先會闡述為什麼在超長滑動窗口下 Flink 的性能會降級的很嚴重，以及在有讚我們是如何解決這個問題的。此外，在優化中並沒有去兼顧 Evictor 的邏輯，因為在業務中並沒有相應的需求。</p><p class=ql-align-justify>二、Flink 滑動窗口的實現</p><p class=ql-align-justify>Flink Window 算子的整體概念如下圖所示，可以看到有幾個重要的部分，首先是 WindowAssigner 和 Trigger，還有 Evaluation Function (也就是用戶定義的對窗口內元素的計算方式)，Evictor 與本次優化關係不大，不會展開。</p><div class=pgc-img><img alt="Flink 滑動窗口優化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/efb733b701294ed085d37f6a8871e99f><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>2.1 WindowAssigner</p><p class=ql-align-justify>WindowAssigner 抽象類有一個關鍵的抽象方法就是 assignWindows，根據一個元素分配它所屬的窗口。</p><pre class=ql-align-justify>// 返回該元素應該被分配的窗口的集合。public abstract Collection&lt;W&gt; assignWindows(T element, long timestamp, WindowAssignerContext context);</pre><p class=ql-align-justify>對於滑動窗口來說，如下圖所示，每個元素可能屬於多個窗口。這個數量也可以由 n = 窗口長度 / 滑動步長 計算出來，範圍在 [n, n+1]。</p><div class=pgc-img><img alt="Flink 滑動窗口優化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63c408df31ad4f09bbb5c9f3e99b13e7><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>此處使用 SlidingEventTimeWindows 來舉例，它的 assignWindows 實現如下，針對輸入的元素和它綁定的 timestamp，計算出該元素所屬的每一個窗口。</p><pre class=ql-align-justify>@Override public Collection&lt;TimeWindow&gt; assignWindows(Object element, long timestamp, WindowAssignerContext context) { if (timestamp &gt; Long.MIN_VALUE) { List&lt;TimeWindow&gt; windows = new ArrayList&lt;&gt;((int) (size / slide)); long lastStart = TimeWindow.getWindowStartWithOffset(timestamp, offset, slide); for (long start = lastStart; start &gt; timestamp - size; start -= slide) { windows.add(new TimeWindow(start, start + size)); } return windows; } else { throw new RuntimeException("Record has Long.MIN_VALUE timestamp (= no timestamp marker). " + "Is the time characteristic set to 'ProcessingTime', or did you forget to call " + "'DataStream.assignTimestampsAndWatermarks(...)'?"); } }</pre><p class=ql-align-justify>2.2 Trigger 抽象類</p><p class=ql-align-justify>對於 Trigger 來說，有三個很重要的方法，如下：</p><pre class=ql-align-justify>// 針對流入的每一個元素的每一個所屬的窗口，會調用該方法，返回 Trigger 結果。 public abstract TriggerResult onElement(T element, long timestamp, W window, TriggerContext ctx) throws Exception;  // 當處理時間到達了註冊的計時器的時間時，會調用該方法，返回 Trigger 結果。 public abstract TriggerResult onProcessingTime(long time, W window, TriggerContext ctx) throws Exception;  // 當事件時間到達了註冊的計時器的時間時，會調用該方法，返回 Trigger 結果。  public abstract TriggerResult onEventTime(long time, W window, TriggerContext ctx) throws Exception;</pre><p class=ql-align-justify>而 EventTimeTrigger 的實現如下，當 onElement 被調用時，如果 watermark 已經超過了 window 的話會直接返回 Fire，不然的話會將 window 的最大時間戳註冊到定時器中。 當 onEventTime 被調用時，會比較這個定時器註冊的時間和當前 window 最大時間戳，只有等於的情況下才會 Fire。因為是事件時間的 Trigger，所以 onProcessingTime 沒有作為，事實上這個 Code Path 也不應該被調用到。</p><pre class=ql-align-justify>@Override public TriggerResult onElement(Object element, long timestamp, TimeWindow window, TriggerContext ctx) throws Exception { if (window.maxTimestamp() &lt;= ctx.getCurrentWatermark()) { // if the watermark is already past the window fire immediately return TriggerResult.FIRE; } else { ctx.registerEventTimeTimer(window.maxTimestamp()); return TriggerResult.CONTINUE; } }  @Override public TriggerResult onEventTime(long time, TimeWindow window, TriggerContext ctx) { return time == window.maxTimestamp() ? TriggerResult.FIRE : TriggerResult.CONTINUE; }  @Override public TriggerResult onProcessingTime(long time, TimeWindow window, TriggerContext ctx) throws Exception { return TriggerResult.CONTINUE; }</pre><p class=ql-align-justify>2.3 WindowOperator</p><p class=ql-align-justify>當一條數據進入到 WindowOperator，首先會通過 WindowAssigner 獲取它所屬的所有窗口的集合，在非 MergingWindowAssigner(SessionWindow) 的情況下，會對這條數據所屬的窗口集合進行遍歷，操作如下：</p><pre class=ql-align-justify>for (W window: elementWindows) {  // drop if the window is already late if (isWindowLate(window)) { continue; } isSkippedElement = false;  windowState.setCurrentNamespace(window); windowState.add(element.getValue());  triggerContext.key = key; triggerContext.window = window;  TriggerResult triggerResult = triggerContext.onElement(element);  if (triggerResult.isFire()) { ACC contents = windowState.get(); if (contents == null) { continue; } emitWindowContents(window, contents); }  if (triggerResult.isPurge()) { windowState.clear(); } registerCleanupTimer(window);}</pre><p class=ql-align-justify>首先判斷這個窗口是否過期了，當這個窗口已經被清理過的話，就會直接跳過。</p><p class=ql-align-justify>接下來把 windowState 切換到這個窗口的 namespace 下，並且調用 TriggerContext 的 onElement 方法，這個方法接下來會調用用戶定義的 Trigger 的 onElement 方法。事實上如果是 EventTimeTrigger 的話，只有當 Window 已經被 Watermark 超過時才會返回 Fire。最後為這個 窗口註冊一個清理的定時器。</p><p class=ql-align-justify>三、超長滑動窗口場景的性能問題及解決方案</p><p class=ql-align-justify>3.1 問題一 - 狀態寫入</p><p class=ql-align-justify>首先是吞吐量，因為使用了 RocksDB 作為 Statebackend，所以寫入和讀取的速度都不會像在堆內那麼快。下圖是在窗口長度為步長的兩倍情況下，每個元素都會屬於兩個窗口，而 Flink 的窗口算子會將每一個元素分別寫入到每一個所屬的 key window 組合對應的狀態中 (Window 5 不在圖中)。</p><div class=pgc-img><img alt="Flink 滑動窗口優化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/53742362178b4098a9f7b0079f80c4dc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>上圖中的開銷還不是那麼明顯，例如在一小時窗口長度和五分鐘步長的情況下，針對每一個元素，需要遍歷 288 個窗口並往對應的 State 寫入數據，在窗口算子中，開銷最大的往往就是對 State 的讀寫。所以同一個操作相比於滾動窗口，吞吐量下滑在 288 倍以上。</p><p class=ql-align-justify>3.2 問題二 - 定時器</p><p class=ql-align-justify>就像上圖中所示，因為每個 key Window 對都對應一個 State，所以它們需要知道什麼時候觸發輸出和清除，這個就需要依賴於定時器。</p><p class=ql-align-justify>在 Flink 的實現中，基於 RocksDB 實現了一個定時器的最小堆，這個最小堆是根據定時器的註冊時間排序的並且可以去重，時間小的會被先 pop 出來。並且這個堆由 InternalTimerServiceManager 來管理的。</p><p class=ql-align-justify>例如在事件時間下，每個算子會將介紹到的 Watermark 與當前的 WaterMark 進行比較，當 Watermark 的值更新後，會調用 InternalTimerServiceManager 的 advanceWatermark 方法。這個方法會將定時器的最小堆中所有時間小於 Watermark 的定時器全都 pop 出來，並且調用 WindowOperator 的 onEventTime 方法 (上文中已有介紹)。</p><p class=ql-align-justify>在窗口算子的實現中，針對每一個 key window 對，需要至少註冊一個觸發輸出的定時器和一個清理窗口狀態的計時器 (因為有 allowLateness 這個 API)。雖然定時器可以去重，但是同樣去重也會需要對狀態的讀取成本。由於定時器的讀取與寫入相對於 State 來說成本較低，但是還是對吞吐量有降級。</p><p class=ql-align-justify>3.3 解決方案</p><p class=ql-align-justify>首先針對問題一，如何去減少 n (窗口長度與滑動步長的比值) 倍的狀態讀寫，可以通過時間分片的方法。對於滑動窗口這樣的對齊窗口，其實是有很多重疊的區域。而且從業務的視角來看，往往窗口的長度是可以被步長所整除的，那麼第一件事就是要找到窗口長度和窗口步長的最小公約數。例如下圖窗口長度是滑動步長兩倍的滑動窗口，這個公約數就是滑動步長，在這裡我叫它們重疊窗口。</p><p class=ql-align-justify>通過將元素存入重疊窗口，保證了每個元素在進入窗口算子時只會更新一個重疊窗口 (對於聚合狀態此處相當於根據重疊窗口做預聚合)。下圖可以看到雖然對於存儲來說 key 的數量是一樣的，但是狀態的寫入少了一半。如果這個狀態還不是聚合狀態的話，那 checkpoint 的成本也會降低很多。</p><div class=pgc-img><img alt="Flink 滑動窗口優化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dfa103bdb1c849e0896a600548d16078><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>對於寫入成本降低 n 倍事實上不難理解，但是讀就比較複雜了，因為讀的次數不止取決於數據的數量，還取決於每個 key 下數據的分佈。</p><p class=ql-align-justify>乍一眼看，在輸出的時候，讀的成本事實上是增加的。對於同樣的數據集來說，它們觸發的窗口輸出也是相同的。而且優化前是讀的完全聚合的狀態或者是完整的狀態集合，而現在輸出的時候只能獲取到按重疊窗口預聚合的結果，需要去獲取所有重疊窗口的結果再做一次聚合。可能說到這大家會覺得對於 RocksDB 這種採用 LSM 樹作為存儲引擎的數據庫來說讀的成本（沒有命中緩存的情況下）比寫的成本還要高。</p><p class=ql-align-justify>但是對於聚合的結果更新而言，是會有三個操作，讀，聚合，寫，這三個操作是會隨著 n 和吞吐量倍增。而對於重疊窗口的方式就比較複雜，它受到每個 key 的數據的分佈的影響更多，接下來從三種分佈來分析比較優化前和優化後讀取的次數。</p><p class=ql-align-justify>3.3.1 密集分佈</p><p class=ql-align-justify>對於一個 key 的密集分佈，這樣的場景有很多，比如在電商中，對於一個比較火熱的店鋪統計訪問人數，假如說這個窗口不是特別小，即使是分鐘級，那麼每個重疊的窗口都會有不止一條數據。</p><div class=pgc-img><img alt="Flink 滑動窗口優化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dec036a8b0c740129cb953315978f3a1><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>我們此處定義重疊窗口長度為 1 (時間單位可以是任意), 窗口總長度為 L，每個重疊窗口中數據的平均數量為 a (例如在上圖 a 的值為 2.5)。</p><p class=ql-align-justify>由於狀態更新是是先寫入後讀取的，在優化後，每個消息都會對應一次讀取，在這段時間內會有讀取次數為</p><pre class=ql-align-justify>L * a</pre><p class=ql-align-justify>而優化前由於要針對每一個輸入的窗口各更新一次，讀取次數為</p><pre class=ql-align-justify>L * L * a = L ^ 2 * a</pre><p class=ql-align-justify>那在這段時間內到底有多少次窗口輸出觸發了狀態的讀取呢？乍一看在圖中 L 為 4，2L - 1 (7) 個窗口需要讀取重疊窗口中的狀態。優化後的窗口輸出時總共涉及到了的狀態讀取次數為</p><pre class=ql-align-justify>(1 + ... + (L - 1)) * 2 + L = L * (L - 1) / 2 * 2 + L = L ^ 2</pre><p class=ql-align-justify>而在優化前，這些窗口輸出時只需要讀一次狀態，並且由於前後分佈相同的緣故，事實上對於這一批數據等價於 L 次狀態讀取。</p><p class=ql-align-justify>所以總的代價是優化之後和之前分別為</p><pre class=ql-align-justify>優化後 = L ^ 2 + L * a優化前 = L ^ 2 * a + LDelta = (1 - a）* (L - 1）* L</pre><p class=ql-align-justify>因為是密集場景，根據我們之前的假設，a 必然大於 1， 因為是滑動窗口, L 也必然大於 1，Delta 必然是小於 0 的。</p><p class=ql-align-justify>所以在窗口與步長比例越高的情況下，讀優化的數量會接近平方增長。</p><p class=ql-align-justify>或者是在每個重疊窗口內數據越多的情況下 (數據越密集)，讀優化的數量會接近線性增長。</p><p class=ql-align-justify>3.3.2 稀疏分佈</p><p class=ql-align-justify>對於 Key 的稀疏分佈，很有可能是某個用戶的行為，往往是在短時間內 (一個或少數幾個重疊窗口內) 做統計。為了簡化邏輯，這裡的稀疏分佈假設數據只會出現在一個重疊窗口之內, 並且在前後接近一個窗口的時間內都不會出現。</p><div class=pgc-img><img alt="Flink 滑動窗口優化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1acf0d6ef4904d62961cc797ce6689ce><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>定義在這個窗口內數據的個數為 a。</p><p class=ql-align-justify>狀態更新時的讀取很容易可以得出，優化前後分別為</p><pre class=ql-align-justify>優化前 = L * a優化後 = a</pre><p class=ql-align-justify>而輸出時候的讀取只會影響到 L 個窗口，優化前後分別為，根據規律，發現非零讀取的總數約等於 1 + … + 1 + 2 + … + 2 + … + m 總共有 2 * L - 1 個數</p><pre class=ql-align-justify>優化前 = L優化後 ≈ (2 * L - 1) * (1 + m) / 2 + ≈ L * m</pre><p class=ql-align-justify>乍一看優化後成本增加了許多，但由於每一次窗口輸出的時候只有一個重疊窗口是有狀態的，L - 1 個重疊窗口的都為空，根據 RocksDB 的設計，可以藉助到 Bloom Filter。Bloom Filter 判斷元素不在集合，那肯定不在。如果判斷元素存在集合中，有一定的概率判斷錯誤。這裡假設一個係數為 K，K 表示沒有 BloomFilter 的情況下空狀態讀取的成本除以藉助 BloomFilter 後空狀態讀取的成本的比例。</p><p class=ql-align-justify>優化後的成本就變成了</p><pre class=ql-align-justify>L + L * (L - 1) / K 約等於 L + L * (L / K)</pre><p class=ql-align-justify>優化前減優化後也就等於</p><pre class=ql-align-justify>L * (a - L / K)</pre><p class=ql-align-justify>在 K 可能為常量（並且大於 1）的情況下，優化後窗口長度與步長比例越大，成本越高，稀疏窗口中的消息條數越多，成本就會降低。但是可以看出來在這種情況下對讀優化是不明顯的，甚至會起到反效果，但是由於寫次數上還有從 L * L * a 降到了 L * a。加入引入另一個係數 D，讀狀態的成本除以的寫狀態的成本。優化前後的總成本差值為</p><pre class=ql-align-justify>L * (a - L / K) + L * a * (L - 1) / D ≈ L * (a - L / K) + L * L * a / D = L * (a + L * (a / D - 1 / K))</pre><p class=ql-align-justify>這裡頭涉及的變量太多，但是假如讀成本是寫成本的十倍，BloomFilter 將讀空值的成本降低 10 倍。那麼在最差的情況下，只有一條數據，那麼總成本還是會降低一些。</p><p class=ql-align-justify>3.3.3 數據定期批量出現</p><p class=ql-align-justify>這種情形更像是監控的數據。假設每 L 的時間中會有 m 個重疊窗口有數據，並且每個重疊窗口有 a 條數據。</p><div class=pgc-img><img alt="Flink 滑動窗口優化" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8ceda6df29854d0eb5932ddb3a150b88><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>優化前的數據讀取依舊很容易得出為</p><pre class=ql-align-justify>L * m * a + L</pre><p class=ql-align-justify>而優化後的讀取成本比較難以估計，由於前後分佈相同，我們只計算從這個時間階段開始以後的窗口對狀態的讀取。所以讀取的總狀態次數為 (1 + … + L)，非空狀態次數約為 L * (1 + m) / 2, 空狀態約為 L * (L - m + 1) / 2, (這兩者加起來略大於總的狀態讀取數，不過可以忽略) 所以總成本約為</p><pre class=ql-align-justify>L * (1 + m) / 2 + (L - m + 1) / 2K + m * a</pre><p class=ql-align-justify>為了簡化計算嘗試省去常數項，假設 m >> 1 並且 (L - m) >> 1，就變成</p><pre class=ql-align-justify>L * m / 2 + (L - m) / 2K + m * a</pre><p class=ql-align-justify>前後的差值約為</p><pre class=ql-align-justify>L / 2 * ( 2 * m * a - m - (L - m) / 2K) - L - ma</pre><p class=ql-align-justify>假設 a 分別為 1 和 100</p><pre class=ql-align-justify>L / 2 * (m - (L - m) / 2K) - L - mL / 2 * (99 * m - (L - m) / 2K) - L - 100 * m</pre><p class=ql-align-justify>可以看出來在 L 比較大的情形下， a 越大，m 越大讀成本優化越明顯。</p><p class=ql-align-justify>3.4 其他場景</p><p class=ql-align-justify>接下來從讀的角度舉兩個比較極端的例子 (不考慮緩存命中的情況下)：</p><p class=ql-align-justify>首先是一些變量的命名，當窗口長度與滑動步長的比值為 n 時，假設總共處理的時間為 m 個窗口步長，一個窗口步長的時間內總共處理的數據 T，key 的數量 K。</p><p class=ql-align-justify>例子一：假設這些 Key 全部都平均分佈到了各個步長中.</p><p class=ql-align-justify>使用 Flink 本身的滑動窗口來處理的話，當所有消息剛進入時，因為要更新狀態，所以會有 n * m * T 的讀取。最後當輸出的時候會對每個 key 和 Window 對觸發，也就是 m * K 的狀態讀取，總共加起來就是 n * m * T + m * K 次讀取。</p><p class=ql-align-justify>而當使用重疊窗口的方法優化時，每條消息消息進入系統，只會對重疊窗口進行一次更新，也就是 m * T 次讀取。而當每個 key 和 window 對的觸發輸出，都會有 n 個重疊窗口的狀態讀取，也就是 n * m * K，總共就是 n * m * K + m * T。將優化前讀取次數減去優化後，可以得到的是</p><pre class=ql-align-justify>Delta = n * m * (T - K) + m * (K - T) = m * (n - 1) * (T - K) ≈ m * n * (T - K)</pre><p class=ql-align-justify>因為前面的假設這些 Key 全部平分到了各個步長中，所以 T 是大於 K 的，優化後讀取次數明顯減少。</p><p class=ql-align-justify>例子二: 現實中的另一種情況就是這些 key 是稀疏的，那上述的公式也就不成立了。</p><p class=ql-align-justify>此處假設變了，每個 key 只會出現在 1 個步長中，還可以知道 1 &lt;&lt; n。過程這裡就不贅述了，最後 flink 自帶的滑窗，至多會有 n * m * T + n * K，而對於優化之後，則變成了 m * T + n * n * K。</p><p class=ql-align-justify>單看後半部分，已經隨著 n 做平方級的增長了，看起來性能會有很大的下滑。</p><p class=ql-align-justify>但是可以將這兒再拆一下，變成 m * T + n * (1 + (n - 1)) * K，此處的意義在與在每次窗口觸發輸出是，只有 1 個重疊窗口是有值得，另外 (n - 1) 個重疊窗口是空的，根據 RocksDB 的設計，可以藉助到 Bloom Filter。Bloom Filter 判斷元素不在集合，那肯定不在。如果判斷元素存在集合中，有一定的概率判斷錯誤。</p><p class=ql-align-justify>而其中的 (n - 1) 個重疊窗口讀的大部分都能夠被 BloomFilter 給過濾掉，成本很低。而 1 又遠小於 n。如果我們引入一個係數，這個係數 L 表示的是經過 Bloom Filter 優化後對空的重疊窗口的讀成本的比例的話（L 的係數比較難以確定），</p><p class=ql-align-justify>所以最後得到的公式是 m * T + n * K + n * (n - 1) * K * L 約等於 m * T + n * K + n * n * K * L。</p><p class=ql-align-justify>將優化前減去優化後，得到的是</p><pre class=ql-align-justify>(n - 1) * m * T - n * n * K * L ≈ n * (m * T - n * K * L)</pre><p class=ql-align-justify>m * T 是總數據量， m * T > K 是確定的，n * L 同時取決於比值和 Bloom Filter 的效率。</p><p class=ql-align-justify>現實的情況往往是例子一和例子二的綜合，有熱點，大部分又是稀疏的，再加上又有緩存的存在，並且優化後總的狀態的量被減少了很多，再加上寫被大大減少了，所以總體性能是有提升的，但是也會取決於用戶的場景。</p><p class=ql-align-justify>針對問題二，其實並沒有特別好的優化方案。但是因為用戶在用 Flink 的 SQL 來做實時任務時，其實大部分情況下是不會配置 allowLateness 的，也就是說輸出和清理狀態可以用同一個定時器來觸發，所以當判斷到 allowLateness 為 0 時，只註冊一個定時器，可以將定時器的寫入成本最多降低到一半。</p><p class=ql-align-justify>3.5 相關工作</p><p class=ql-align-justify>Flink 社區也曾經提出過類似的方案 (FLINK-7001), 但是沒有合入. 對於這種長窗口的情況，這並不是一個最優雅的解決方案，只能算是一個 Work Around。對於業務方來說，真正的訴求應該是實時的獲取截止到當前的一個時間段內的統計數據。</p><p class=ql-align-justify>在有贊, 除了在 Flink 引擎做優化意外, 目前還在朝著兩個方向:</p><ol><li class=ql-align-justify>藉助 Druid 這個預聚合的實時 olap 解決方案 ;</li><li class=ql-align-justify>利用 Flink 實現實時指標服務, 基本思想也是預聚合的思想, 將細粒度結果存儲在在線存儲中, 做讀時聚合.</li></ol><p class=ql-align-justify>Druid 方案目前還存在著整點讀 RT 抖動和平均 RT 過長的問題, 對於 RT 敏感的應用場景, 沒辦法很好滿足.</p><p class=ql-align-justify>實時指標服務方案還在構建中, 初步想法是抽象實時指標轉化為 Flink 實時任務, 將細粒度實時指標結果寫入 在線存儲 (HBase, Redis) 中, 最後做讀時聚合. 方案的最終效果, 還要待上線後驗證。</p><p class=ql-align-justify>四、小結</p><p class=ql-align-justify>這次優化事實上效果會取決多個因素，從線上實際效果看, 視重疊係數的不同，性能上有 3~8 倍的優化.</p><p class=ql-align-justify>作者簡介：</p><p class=ql-align-justify>有贊大數據團隊是有贊共享技術核心技術團隊之一，該團隊主要由算法，數據產品，數據倉庫和底層基礎平臺四個團隊構成，目前共有 50 位優秀的工程師組成。"</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Flink</a></li><li><a>滑動</a></li><li><a>優化</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html alt="深度研究自然梯度優化，從入門到放棄 | Deep Reading" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2cc1b8ef47a5458190c22d26d8bd164c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html title="深度研究自然梯度優化，從入門到放棄 | Deep Reading">深度研究自然梯度優化，從入門到放棄 | Deep Reading</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e1b3755.html alt=裝完系統必做的優化，更改用戶文件和軟件安裝默認路徑，你知道嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d349042865d40cf9b8f1e91e2537426 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e1b3755.html title=裝完系統必做的優化，更改用戶文件和軟件安裝默認路徑，你知道嗎>裝完系統必做的優化，更改用戶文件和軟件安裝默認路徑，你知道嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0518503.html alt=優化營商環境“大家談”︱擔當職責使命，貢獻公安力量 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RHnAsqqAQHVKXV style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0518503.html title=優化營商環境“大家談”︱擔當職責使命，貢獻公安力量>優化營商環境“大家談”︱擔當職責使命，貢獻公安力量</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1367a773.html alt=【直線導軌】滑動導軌和滾動導軌的特性與優缺點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d4cdb029a2ea46e7b814fa483d68be41 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1367a773.html title=【直線導軌】滑動導軌和滾動導軌的特性與優缺點>【直線導軌】滑動導軌和滾動導軌的特性與優缺點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd4899a4.html alt="引進打樁“神器”  優化施工工藝海濱路東西延伸工程順利推進" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/48a3decd487848809296b7f0b9a0b15c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd4899a4.html title="引進打樁“神器”  優化施工工藝海濱路東西延伸工程順利推進">引進打樁“神器”  優化施工工藝海濱路東西延伸工程順利推進</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8654883c.html alt=項目實踐中的一些性能優化指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8c9ad977831f4b6bbaaf2e1b4651b667 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8654883c.html title=項目實踐中的一些性能優化指南>項目實踐中的一些性能優化指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4bcf71f1.html alt=如何優化一個投資組合的omega比率？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RzQabD49vAZW1Y style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4bcf71f1.html title=如何優化一個投資組合的omega比率？>如何優化一個投資組合的omega比率？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3638ad51.html alt="Apache Flink 1.10 細粒度資源管理解析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15513883d97c4f799a3897342310c24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3638ad51.html title="Apache Flink 1.10 細粒度資源管理解析">Apache Flink 1.10 細粒度資源管理解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62513e9d.html alt=廊坊移動優化傳輸網絡資源提升政企專網承載能力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62513e9d.html title=廊坊移動優化傳輸網絡資源提升政企專網承載能力>廊坊移動優化傳輸網絡資源提升政企專網承載能力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00724d57.html alt=「技術帖」基於拓撲優化的複合材料汽車座椅骨架設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d17fc52c47764b149b99c25fd6ded601 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00724d57.html title=「技術帖」基於拓撲優化的複合材料汽車座椅骨架設計>「技術帖」基於拓撲優化的複合材料汽車座椅骨架設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/903b91ab.html alt=優化技術如何從無到有設計一輛雙人自行車的車架？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e05e62d452f94d2289d5920138fe0518 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/903b91ab.html title=優化技術如何從無到有設計一輛雙人自行車的車架？>優化技術如何從無到有設計一輛雙人自行車的車架？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49c9a0f8.html alt=王者榮耀：墨子雙皮膚優化，增強觀賞效果，終於要擺脫醜皮膚了？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/182d19f593614bf5baeeae8372bc2549 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49c9a0f8.html title=王者榮耀：墨子雙皮膚優化，增強觀賞效果，終於要擺脫醜皮膚了？>王者榮耀：墨子雙皮膚優化，增強觀賞效果，終於要擺脫醜皮膚了？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7275256d.html alt=matlab實現滑動平均濾波 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/22c427f367ab4a8989d116dc3c620415 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7275256d.html title=matlab實現滑動平均濾波>matlab實現滑動平均濾波</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9072b4d.html alt=肱骨頭的滾動與滑動機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0b73ea23c91848d9b94803a913be7b48 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9072b4d.html title=肱骨頭的滾動與滑動機制>肱骨頭的滾動與滑動機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0682e79.html alt=山東立法優化營商環境破解“中梗阻” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0682e79.html title=山東立法優化營商環境破解“中梗阻”>山東立法優化營商環境破解“中梗阻”</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>