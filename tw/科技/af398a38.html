<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring—面向切面編程（AOP）詳解 | 极客快訊</title><meta property="og:title" content="Spring—面向切面編程（AOP）詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af398a38.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Spring—面向切面編程（AOP）詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/af398a38.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring—面向切面編程（AOP）詳解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre>作者：我要進阿里！原文：https://www.cnblogs.com/liuhongchen/p/11580319.html?utm_source=tuicool&amp;utm_medium=referral</pre><p>聲明：本問僅僅是一個初學者的學習記錄、心得總結，其中肯定有許多錯誤，不具有參考價值，歡迎大佬指正，謝謝！</p><div class=pgc-img><img alt=Spring—面向切面編程（AOP）詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570><p class=pgc-img-caption></p></div><p><strong>一、問題引入</strong></p><p>​ 在日常寫項目的時候，肯定少不了要打印日誌。例如，要向數據庫中insert一個用戶，我想在插入前輸出一下相關信息，怎麼實現呢？最基本的做法是：在insert方法中寫日誌輸出語句。這樣寫完全能實現功能，但是會不會顯得很冗餘？耦合度是不是很高？編程的準則是“高內聚，低耦合”，低耦合的意思就是類與類之間的依賴關係儘量少、關聯程度儘量小。</p><p>​ 而如果在上述情景中使用面向切面編程（AOP），就可以不在insert方法中寫日誌輸出語句卻能實現日誌輸出功能。當然，AOP不止如此。</p><p><strong>二、概念引入</strong></p><p><strong>1.AOP</strong></p><p>在軟件業，AOP為Aspect Oriented Programming的縮寫，意為：面向切面編程，通過預編譯方 式和運行期動態代理實現程序功能的統一維護的一種技術。AOP是OOP的延續，是軟件開發中的一個 熱點，也是Spring框架中的一個重要內容，是函數式編程的一種衍生範型。利用AOP可以對業務邏輯 的各個部分進行隔離，從而使得業務邏輯各部分之間的耦合度降低，提高程序的可重用性，同時提高 了開發的效率。</p><p><strong>2.幾個基本概念</strong></p><pre>- 切入點：所有要操作的方法定義，要求業務層方法風格統一- 分離點：將不可分割的組件單獨提取出去定義為單獨的操作功能- 橫切關注點：將所有與開發無關的程序組成類單獨提取後組織運行- 織入：將所有切入點、關注點的代碼組成在一張完整的程序結構中</pre><p><strong>3.通知（Advice）</strong></p><p>​ AOP是通過通知來實現功能的，有如下五種：</p><ul><li>前置通知（BeforeAdvice）</li><li>後置通知（AfterAdvice）</li><li>後置返回通知（AfterReturningAdvice）</li><li>後置異常通知（AfterThrowingAdvice）</li><li>環繞通知（AroundAdvice）</li></ul><p><strong>三、Pointcut與Execution表達式</strong></p><p>​ pointcut使用execution表達式表示要被切入的方法（即定義切入點）。</p><p>​ execution表達式，功能類似於正則表達式，都是用來匹配篩選，只不過正則表達式用來篩選字符串，而execution表達式用來篩選要被切入的方法。</p><p>​ execution表達式的格式為：</p><p>​ execution(&lt;註解>? &lt;修飾符>? &lt;返回值類型> &lt;方法名模式>(&lt;參數模式>) &lt;異常>?)) &lt;and args()>?)</p><p>​ 例： execution(@Deprecated public Void aop.MyAspect.hello(int,String) throws Exception))')</p><pre>package aop;public class AspectDemo { @Deprecated public void hello(int i,String s) throws Exception{ }}</pre><p>​ 其實不難發現，這個表達式和我們聲明的方法的各個部分一一對應</p><ul><li>註解：（可省略）例如上面代碼中的 @Deprecated ，就是篩選帶有該註解的方法</li><li>修飾符（可省略）</li><li class=ql-indent-1>public</li><li class=ql-indent-1>protected</li><li class=ql-indent-1>private</li><li>當然一般用通配符 *</li><li>返回值類型</li><li>寫各種返回值，一般用通配符 *</li><li>方法名模式</li><li>包名部分：在上例中，AspectDemo是位於aop包中的，所以可以通過包名.包名.類名的格式來定位到某個類，例如aop.AspectDemo 中aop. 就是包名部分;</li><li>當然也可以用通配符</li><li class=ql-indent-2>*：匹配任何數量字符，例如service.*.UserService 表示的是service的直接子包</li><li class=ql-indent-2>..：匹配任何數量字符的重複，如在類型模式中匹配任何數量子包，例如service..代表著匹配service及其包含的所有包；而在方法參數模式中匹配任何數量參數。</li><li class=ql-indent-1><strong>+：</strong> 匹配指定類型的子類型；僅能作為後綴放在類型模式後邊，例如java.lang.Number+ 表示的是lang包下Numer的子類</li><li class=ql-indent-1>類名部分：在上例中aop.AspectDemo中aop.是包名部分，AspectDemo就是類名部分，可以用通配符來表示，*用的比較多</li><li>參數模式</li><li class=ql-indent-1>寫法1:直接按照方法的參數列表寫具體類型，上例的方法中參數列表(int i,String s),就可以直接在表達式中寫(int,String)</li><li>寫法2:使用通配符:</li><li class=ql-indent-2>“()”表示方法沒有任何參數；</li><li class=ql-indent-2>“(..)”表示匹配接受任意個參數的方法</li><li class=ql-indent-2>“(..,java.lang.String)”表示匹配接受java.lang.String類型的參數結束，且其前邊可以接受有任意個參數的方法</li><li class=ql-indent-2>“(java.lang.String,..)” 表示匹配接受java.lang.String類型的參數開始，且其後邊可以接受任意個參數的方法</li><li class=ql-indent-1>“(*,java.lang.String)” 表示匹配接受java.lang.String類型的參數結束，且其前邊接受有一個任意類型參數的方法；</li><li>異常模式（可省略）</li><li>throws Exception1，Exception2.。。。</li><li>傳入參數（可省略）</li><li>​ and args(arg-name),一般用於AfterAdvice和Around通知</li></ul><p><strong>四、前期準備</strong></p><ol><li>創建項目，導入相關jar包，參考Spring——IOC，此外還需導入aop和aspectj的jar包</li><li>創建applicationContext.xml文件</li></ol><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;</pre><p>​ 注意：新增了</p><p>​ xmlns:aop="http://www.springframework.org/schema/aop"</p><p>​ http://www.springframework.org/schema/aop</p><p>​ http://www.springframework.org/schema/beans/spring-aop.xsd</p><p>​ &lt;aop:aspectj-autoproxy/> 不加這個可能會報錯，可坑了</p><ol><li>創建UserService這個類，內部有insert方法用來註冊用戶</li></ol><pre>public class UserService {  public void insert(){ System.out.println("UserService正在註冊用戶……"); }}</pre><ol><li>創建MyAspect類</li></ol><pre>public class MyAspect {}</pre><p><strong>五、基於XML配置的AOP</strong></p><p><strong>1.BeforeAdvice</strong></p><p>​ (1)在MyAspect類中創建方法beforeAdvice</p><pre>public void beforeAdvice(){ System.out.println("【AOP】Before Advice正在執行……"); }</pre><p>​ (2)在applicationContext.xml中配置</p><p>​ <em>關於pointcut和execution表達式見下文</em></p><pre>&lt;!--首先要引入myAspect這個bean，備用--&gt; &lt;bean id="myAspect" class="aop.MyAspect"/&gt; &lt;bean id="userService" class="aop.UserService"/&gt; &lt;aop:config&gt; &lt;!--配置切面，一個aop:aspect標籤對應一個Aspect類--&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;!--配置通知 method對應MyAspect類中定義的方法，pointcut是切入點表達式用於篩選需要被 切入的方法--&gt; &lt;aop:before method="beforeAdvice" pointcut="execution(* aop..*.*(..)))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;</pre><p>​ (3)編寫測試類</p><pre>public class UserServiceTest { public static void main(String[] args) { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert(); }}</pre><p>​ (4)輸出結果</p><pre>【AOP】Before Advice正在執行…… UserService正在註冊用戶……</pre><p>​ 可以發現，BeforeAdvice就已經實現了</p><p><strong>2.AfterAdvice（相當於異常裡面的finally語句）</strong></p><p>​ (1)UserService類同上</p><p>​ (2)在MyAspect中創建方法afterAdvice</p><pre>public void afterAdvice(){ System.out.println("【AOP】after Advice…… 不管怎樣我都會執行");}</pre><p>​ (3)修改applicationContext.xml</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:after method="afterAdvice" pointcut="execution(* aop.*.insert(..)))" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ (4)編寫測試類（同上）</p><p>​ (5)輸出結果</p><pre>UserService正在註冊用戶……【AOP】after Advice…… 不管怎樣我都會執行</pre><p><strong>3.AfterReturningAdvice</strong></p><p>​ (1)修改UserService的insert方法，使其有返回值</p><pre>public class UserService { public int insert(){ System.out.println("UserService正在註冊用戶……"); return 1; }}</pre><p>​ (2)在MyAspect中新增afterReturningAdvice方法</p><pre>public void afterReturningAdvice(int result) { System.out.println("【AOP】after advice……返回值為"+result); }</pre><p>​ (3)在applicationContext.xml中配置</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:after-returning method="afterReturningAdvice" pointcut="execution(* aop.*.insert(..)))" returning="result"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ 注意：這裡這個returning="result"與MyAspect類中對應方法的參數名必須保持一致，本例中都為result</p><p>​ (4)編寫測試類(代碼同1.)</p><p>​ (5)輸出結果</p><pre>UserService正在註冊用戶…… 【AOP】after advice……返回值為1</pre><p><strong>4.AfterThrowingAdvice</strong></p><p>​ (1)修改UserService使其拋異常</p><pre>public int insert() throws Exception { try { System.out.println("UserService開始註冊用戶……"); int i=1/0; }catch (Exception e){ throw new Exception("insert方法遇到異常……"); } return 1;}</pre><p>​ (2)在MyAspect中新增方法 afterThrowingAdvice</p><pre>//這裡傳入的這個Exception就是捕獲到的異常對象public void afterThrowingAdvice(Exception e){ System.out.println("【AOP】得到異常信息："+e.getMessage());}</pre><p>​ (3)修改applicationContext.xml</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:after-throwing method="afterThrowingAdvice" pointcut="execution(* aop.*.insert(..)))" throwing="e"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ 注意：這裡的throwing="e”就是跑出的異常對象的名字，要與MyAspect中afterThrowingAdvice方法中傳入的參數Exception e的名字保持一致。</p><p>​ (4)編寫測試類</p><pre>public static void main(String[] args) throws Exception { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert();}</pre><p>​ (5)輸出結果</p><pre>UserService開始註冊用戶……【AOP】得到異常信息insert方法遇到異常……Exception in thread "main" java.lang.Exception: insert方法遇到異常…… at aop.UserService.insert(UserService.java:12) at aop.UserService$$FastClassBySpringCGLIB$$7e3b8e5e.invoke(&lt;generated&gt;) ...</pre><p><strong>5.AroundAdvice</strong></p><p>​ (1)修改UserService中的insert方法</p><pre>public int insert(int arg) throws Exception { try { int i = 1 / 0; } catch (Exception e) { throw new Exception("insert方法遇到異常……"); } return 1;}</pre><p>​ (2)在MyAspect中添加方法AroundAdvice</p><pre>//這裡這個ProceedingJointPoint可以理解為切入點對象，可以通過它獲取切入點（被切入的方法）的參數、返回值、拋出的異常，並且可以通過pjp.proceed(args);為該切入點設置參數public int aroundAdvice(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); System.out.println("【AOP】before Advice,獲取到insert方法傳入的參數為："+args[0]); Object result; try { result=pjp.proceed(args);//這裡是我們手動執行切入點，並傳入參數 System.out.println("【AOP】after Returning Advice,返回值為："+result); }catch (Exception e){ //這裡捕獲的就是切入點運行時拋出的異常 System.out.println("【AOP】after Throwing Advice,錯誤信息為："+e.getMessage()); } System.out.println("【AOP】after advice……不管異常不異常我都執行"); //這個就跟著這樣寫吧。。如果不寫返回值的話會報 null return value does not match... return 1;}</pre><p>​ (3)修改applicationContext.xml文件</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:around method="aroundAdvice" pointcut="execution(* aop.*.insert(..)))" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ (4)編寫測試類</p><pre>public static void main(String[] args) throws Exception { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert(2);}</pre><p>​ (5)輸出結果</p><pre>【AOP】before Advice,獲取到insert方法傳入的參數為：2【AOP】after Throwing Advice,錯誤信息為：insert方法遇到異常……【AOP】after advice……不管異常不異常我都執行</pre><p><strong>六、基於註解配置的AOP</strong></p><p>​ 先把項目狀態恢復到 “四、前期準備”的狀態,然後在applicationContext.xml中添加下面的語句開啟註解和包掃描。</p><pre>&lt;context:annotation-config/&gt;&lt;context:component-scan base-package="aop"/&gt;</pre><p>​ 注意，這個base-package可以配置多個包，以半角（英文）逗號隔開，例如“aop,mvc,dao,service”，當然，為了省事，可以直接配一個頂級包，他會自動遍歷掃描所有的子包及子包的子包等等。</p><p>​ 然後為MyAspect類和UserService類加上註解</p><pre>@Component@Aspectpublic class MyAspect {}@Servicepublic class UserService {}</pre><p><strong>1.BeforeAdvice</strong></p><p>​ (1)在MyAspect類中創建beforeAdvice方法，並寫好註解</p><pre>@Before(value = "execution(* aop..*.*(..)))")public void beforeAdvice(){ System.out.println("【AOP】Before Advice正在執行……");}</pre><p>​ 不需要配任何bean，是不是很爽</p><p>​ (2)編寫測試類</p><pre>public static void main(String[] args) { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert();}</pre><p>​ (3)輸出結果</p><pre>【AOP】Before Advice正在執行…… UserService正在註冊用戶……</pre><p><strong>2.AfterService(我就不寫測試了)</strong></p><p>​ (1)在MyAspect類中創建afterAdvice方法，並寫好註解</p><pre>@After(value = "execution(* aop..*.*(..)))")public void afterAdvice(){ System.out.println("【AOP】after Advice正在執行……");}</pre><p><strong>3.AfterReturningAdvice</strong></p><p>​ (1)修改UserService中的insert方法</p><pre>public int insert(){ System.out.println("UserService正在註冊用戶……"); return 1;}</pre><p>​ (2)在MyAspect類中創建afterReturningAdvice方法，並寫好註解</p><pre>@AfterReturning(value = "execution(* aop..*.*(..))&amp;&amp; args(result))")public void afterReturningAdvice(int result){ System.out.println("【AOP】after Returning Advice正在執行……返回值為："+result);}</pre><p>​ (3)不寫測試了</p><p><strong>4.AfterThrowingAdvice</strong></p><p>​ (1)修改UserService中的insert方法</p><pre>public int insert() throws Exception { try { int i=1/0; }catch (Exception e){ throw new Exception("【UserService】的insert遇到了錯誤……"); } return 1;}</pre><p>​ (2)在MyAspect類中創建afterThrowingAdvice方法，並寫好註解</p><pre>@AfterThrowing(value = "execution(* aop..*.*(..)))",throwing = "e")public void afterThrowingAdvice(Exception e){ System.out.println("【AOP】after Throwing Advice正在執行……錯誤信息為："+e.getMessage());}</pre><p>​ (3)不測試了。。</p><p><strong>5.AroundAdvice</strong></p><p>​ (1)把MyAspect中之前寫的方法註釋掉，不然會影響觀察結果</p><p>​ (2)修改insert方法</p><pre>public int insert(int arg) throws Exception { try { int i=1/0; }catch (Exception e){ throw new Exception("【UserService】的insert遇到了錯誤……"); } return 1;}</pre><p>​ (3)在MyAspect類中創建aroundAdvice方法，並寫好註解</p><pre>@Around(value = "execution(* aop..*.*(..)))")public int aroundAdvice(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); System.out.println("【AOP】before Advice,獲取到insert方法傳入的參數為："+args[0]); Object result; try { result=pjp.proceed(args); System.out.println("【AOP】after Returning Advice,返回值為："+result); }catch (Exception e){ System.out.println("【AOP】after Throwing Advice,錯誤信息為："+e.getMessage()); } System.out.println("【AOP】after advice……不管異常不異常我都執行"); return 1;}</pre><p><strong>關注作者：JAVA高級程序員</strong></p><p>專注分享：（高可用、高併發、高性能及分佈式、Jvm性能調優、Spring源碼，MyBatis，Netty，Redis，Kafka，Mysql，Zookeeper，Tomcat，Docker，Dubbo，Nginx等技術...）</p><p>歡迎轉發，評論~~~每天Java一下，成為架構師！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>編程</a></li><li><a>AOP</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面編程AOP的初步瞭解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面編程AOP的初步瞭解>Spring面向切面編程AOP的初步瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面編程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面編程需要知道的事">Spring AOP 面向切面編程需要知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html alt="Spring：AOP 面向切面編程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html title="Spring：AOP 面向切面編程">Spring：AOP 面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用註解方式配置Spring中的面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用註解方式配置Spring中的面向切面編程AOP>使用註解方式配置Spring中的面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html alt="Spring AOP簡介與底層實現機制——動態代理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/413780d1-cf47-4038-9471-b686d97aa99b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html title="Spring AOP簡介與底層實現機制——動態代理">Spring AOP簡介與底層實現機制——動態代理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html alt=Spring框架AOP技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/760bf32faca443cb8e28ed0b9bc20205 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html title=Spring框架AOP技術>Spring框架AOP技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html alt=小實例理解Spring中的AOP----面向切面編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35942664cec244f88d6a0f7b1e7067cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html title=小實例理解Spring中的AOP----面向切面編程>小實例理解Spring中的AOP----面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a7b6ff44.html alt=談談AOP（面向切面編程） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534580818763e7a06b5c87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a7b6ff44.html title=談談AOP（面向切面編程）>談談AOP（面向切面編程）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82a2f71a.html alt=面向切面編程（AOP）中的術語你能說出幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/5436586b-f08f-4845-b15a-7da897dc9b16 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82a2f71a.html title=面向切面編程（AOP）中的術語你能說出幾個？>面向切面編程（AOP）中的術語你能說出幾個？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ef619f7.html alt=Autofac的AOP面向切面編程研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15b5a9a952f84c688e4f9a33c0fe0f13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ef619f7.html title=Autofac的AOP面向切面編程研究>Autofac的AOP面向切面編程研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html alt="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html title="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現">Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html alt="Spring學習（4）：Spring AOP" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/be8a179a4a8040648c1fb5a0532cc84b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html title="Spring學習（4）：Spring AOP">Spring學習（4）：Spring AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html alt=Spring面向切面編程的AOP的事務增強完整版的配置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html title=Spring面向切面編程的AOP的事務增強完整版的配置>Spring面向切面編程的AOP的事務增強完整版的配置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d826c93.html alt=spring框架之AOP面向切面編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9b61c468edc241dda89e2ac1e5fabd74 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d826c93.html title=spring框架之AOP面向切面編程>spring框架之AOP面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d371c81c.html alt=一招學會面向切面編程(AOP) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d371c81c.html title=一招學會面向切面編程(AOP)>一招學會面向切面編程(AOP)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>