<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java基礎系列：理解Java多態的實現機制 | 极客快訊</title><meta property="og:title" content="Java基礎系列：理解Java多態的實現機制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/cd7b252f82e04b6da1d594eab4d030b9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><meta property="article:published_time" content="2020-10-29T20:58:49+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:49+08:00"><meta name=Keywords content><meta name=description content="Java基礎系列：理解Java多態的實現機制"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/af4bb85.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java基礎系列：理解Java多態的實現機制</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多態性是面向對象程序設計代碼重用的一個重要機制，我們曾不只一次的提到Java多態性。在Java運行時多態性：繼承和接口的實現一文中，我們曾詳細介紹了Java實現運行時多態性的動態方法調度；今天我們再次深入Java核心，一起學習Java中多態性的實現。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">“polymorphism(多態）”一詞來自希臘語，意為“多種形式”。多數Java程序員是多態看作對象的一種能力，使其能調用正確的方法版本。儘管如此，這種面向實現的觀點導致了多態的神奇功能，勝於僅僅把多態看成純粹的概念。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Java中的多態總是子類型的多態。幾乎是機械式產生了一些多態的行為，使我們不去考慮其中涉及的類型問題。本文研究了一種面向類型的對象觀點，分 析瞭如何將對象能夠 表現的行為和對象即將表現的行為分離開來。拋開Java中的多態度是來自繼承的概念，我們仍讓可以感到，Java中的接口是一組沒有公共代碼的對象共享實現。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多態的分類</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多態在面嚮對象語言中是個很普遍的概念.雖然我們經常把多態混為一談，但實際上 有四種不同類型的多態。在開始正式的子類型多態的細節討論前，然我們先來看看普通面向對象中的多態。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Luca Cardelli和Peter Wegner（"On Understanding Types, Data Abstraction, and Polymorphism"一文的作者， 文章參考資源鏈接）把多態分為兩大類----特定的和通用的----四小類：強制的，重載的，參數的和包含的。他們的結構如下：</span></p><p><br></p><div class=pgc-img><img alt=Java基礎系列：理解Java多態的實現機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cd7b252f82e04b6da1d594eab4d030b9><p class=pgc-img-caption></p></div><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">在這樣一個體系中，多態表現出多種形式的能力。通用多態引用有 相同結構類型的大量對象，他們有著共同的特徵。特定的多態涉及的是小部分沒有相同特徵的對象。四種多態可做以下描述：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆強制的：一種隱 式做類型轉換的方法。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆重載的：將一個標誌符用作多個意義。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆參數的：為不同類型的參數提供相同的操作。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆包含的：類包含關係的抽象操作。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">我將在講述子類型多態前簡單介紹一下這幾種多態。</span></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">強制的多態</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">強制多態隱式的將參數按某種方法，轉換成編譯器認為正確的類型以避免錯誤。在以下的表達式中，編譯器必須決定二元運算符‘+’所應做的工作：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">2.0 + 2.0</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">2.0 + 2</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">2.0 + "2"</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">第一個表達式將兩個double的 操作數相加；Java中特別聲明瞭這種用法。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">第二個表達式將double型和int相加。Java中沒有明確定義這種運算。不過，編 譯器隱式的將第二個操作數轉換為double型，並作double型的加法。做對程序員來說十分方便，否則將會拋出一個編譯錯誤，或者強制程序員顯式的將 int轉換為double。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">第三個表達式將double與一個String相加。Java中同樣沒有定義這樣的操作。所以，編譯器將 double轉換成String類型，並將他們做串聯。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">強制多態也會發生在方法調用中。假設類Derived繼承了類Base，類C 有一個方法，原型為m(Base)，在下面的代碼中，編譯器隱式的將Derived類的對象derived轉化為Base類的對象。這種隱式的轉換使 m(Base)方法使用所有能轉換成Base類的所有參數。</span></p><p><br></p><ol start=1><li><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">C c = new C();</span></li><li><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Derived derived = new Derived();</span></li><li><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">c.m( derived );</span></li></ol><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">並且，隱式的強制轉換，可以避免 類型轉換的麻煩，減少編譯錯誤。當然，編譯器仍然會優先驗證符合定義的對象類型。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">重載的多態</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">重載 允許用相同的運算符或方法，去表示截然不同的意義。‘+’在上面的程序中有兩個意思：兩個double型的數相加；兩個串相連。另外還有整型相加，長整 型，等等。這些運算符的重載，依賴於編譯器根據上下文做出的選擇。以往的編譯器會把操作數隱式轉換為完全符合操作符的類型。雖然Java明確支持重載，但 不支持用戶定義的操作符重載。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Java支持用戶定義的函數重載。一個類中可以有相同名字的方法，這些方法可以有不同的意義。這些重載 的方法中，必須滿足參數數目不同，相同位置上的參數類型不同。這些不同可以幫助編譯器區分不同版本的方法。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">編譯器以這種唯一表示的特 用來表示不同的方法，比用名字表示更為有效。據此，所有的多態行為都能編譯通過。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">強制和重載的多態都被分類為特定的多態，因為這些多 態都是在特定的意義上的。這些被劃入多態的特性給程序員帶來了很大的方便。強制多態排除了麻煩的類型和編譯錯誤。重載多態像一塊糖，允許程序員用相同的名 字表示不同的方法，很方便。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">參數的多態</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">參數多態允許把許多類型抽象成單一的表示。例如，List 抽象類中，描述了一組具有同樣特徵的對象，提供了一個通用的模板。你可以通過指定一種類型以重用這個抽象類。這些參數可以是任何用戶定義的類型，大量的用 戶可以使用這個抽象類，因此參數多態毫無疑問的成為最強大的多態。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">乍一看，上面抽象類好像是java.util.List的功能。然 而，Java實際上並不支持真正的安全類型風格的參數多態，這也是java.util.List和java.util的其他集合類是用原始的 java.lang.Object寫的原因（參考我的文章"A Primordial Interface?" 以獲得更多細節）。Java的單根繼承方式解決了部分問題，但沒有發揮出參數多態的全部功能。Eric Allen有一篇精彩的文章“Behold the Power of Parametric Polymorphism”，描述了Java通用類型的需求，並建議給Sun的Java規格需求#000014號文檔"Add Generic Types to the Java Programming Language."（參考資源鏈接）</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">包含的多態</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">包含多態通過值的類型和集合的包含關係實現了多態的行為.在包括Java在內的眾多面嚮對象語言中，包含關係是子類型的。所以，Java的包含多態是子 類型的多態。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">在早期，Java開發者們所提及的多態就特指子類型的多態。通過一種面向類型的觀點，我們可以看到子類型多態的強大功 能。以下的文章中我們將仔細探討這個問題。為簡明起見，下文中的多態均指包含多態。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">面向類型觀點</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">圖1的UML類圖給出了類和類型的簡單繼承關係，以便於解釋多 態機制。模型中包含5種類型，4個類和一個接口。雖然UML中稱為類圖，我把它看成類型圖。如"Thanks Type and Gentle Class," 一文中所述，每個類和接口都是一種用戶定義的類型。按獨立實現的觀點（如面向類型的觀點），下圖中的每個矩形代表一種類型。從實現方法看，四種類型運用了 類的結構，一種運用了接口的結構。</span></p><p><br></p><div class=pgc-img><img alt=Java基礎系列：理解Java多態的實現機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81a9ff3721f34cf6ac24f4b5b1f67de3><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">圖1：示範代碼的UML類圖</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">以下的代碼實現了每個用戶 定義的數據類型，我把實現寫得很簡單。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">用這樣的類型聲明和類的定義，圖2從概念的觀點描述了Java指令。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Derived2 derived2 = new Derived2();</span></p><p><br></p><div class=pgc-img><img alt=Java基礎系列：理解Java多態的實現機制 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3d752940017f40948cccfbe6f58644dc><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">圖2 ：Derived2 對象上的引用</span></span></strong></p><p style=text-align:start><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">上文中聲明瞭 derived2這個對象，它是Derived2類的。圖2中的最頂層把Derived2引用描述成一個集合的窗口，雖然其下的Derived2對象是可 見的。這裡為每個Derived2類型的操作留了一個孔。Derived2對象的每個操作都去映射適當的代碼，按照上面的代碼所描述的那樣。例 如，Derived2對象映射了在Derived中定義的m1()方法。而且還重載了Base類的m1()方法。一個Derived2的引用變量無權訪問 Base類中被重載的m1()方法。但這並不意味著不可以用super.m1()的方法調用去使用這個方法。關係到derived2這個引用的變量，這個 代碼是不合適的。Derived2的其他的操作映射同樣表明了每種類型操作的代碼執行。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">既然你有一個Derived2對象，可以用任 何一個Derived2類型的變量去引用它。如圖1所示，Derived, Base和IType都是Derived2的基類。所以，Base類的引用是很有用的。圖3描述了以下語句的概念觀點。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Base base = derived2;</span></p><p><br></p><div class=pgc-img><img alt=Java基礎系列：理解Java多態的實現機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5c42911d743a460db6ef51de02e93c04><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">圖3：Base類引用附於Derived2對象之上</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">雖然Base類的引用不用再訪問m3()和m4()，但是卻不會改變它Derived2對象的任何特徵及操作映射。無論是變量derived2還是 base，其調用m1()或m2(String)所執行的代碼都是一樣的。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">兩個引用之所以調用同一個行為，是因為Derived2對象並不知道去調用哪個方法。對 象只知道什麼時候調用，它隨著繼承實現的順序去執行。這樣的順序決定了Derived2對象調用Derived裡的m1()方法，並調用Derived2 裡的m2(String)方法。這種結果取決於對象本身的類型，而不是引用的類型。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">儘管如此，但不意味著你用derived2和 base引用的效果是完全一樣的。如圖3所示，Base的引用只能看到Base類型擁有的操作。所以，雖然Derived2有對方法m3()和m4()的 映射，但是變量base不能訪問這些方法。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">運行期的Derived2對象保持了接受m3()和m4()方法的能力。類型的限制使 Base的引用不能在編譯期調用這些方法。編譯期的類型檢查像一套鎧甲，保證了運行期對象只能和正確的操作進行相互作用。換句話說，類型定義了對象間相互 作用的邊界。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多態的依附性</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">類型的一致性是多態的核心。對象上的每一個引用，靜態的類型檢查器都要確認這樣的依附和其對象的層次是一致的。當一個引用成功的依附於另一個不同的 對象 時，有趣的多態現象就產生了。（嚴格的說，對象類型是指類的定義。）你也可以把幾個不同的引用依附於同一個對象。在開始更有趣的場景前，我們先來看一下下 面的情況為什麼不會產生多態。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多個引用依附於一個對象</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">圖2和圖3描述的例子是把兩個及兩個以上的 引用依附於一個對象。雖然Derived2對象在被依附之後仍保持了變量的類型，但是，圖3中的Base類型的引用依附之後，其功能減少了。結論很明顯：把一個基類的引用依附於派生類的對象之上會減少其能力。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">一個開發者怎麼會選擇減少對象能力的方案呢？這種選擇是間接的。假設有一個名 為ref的引用依附於一個包含如下方法的類的對象：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">用一個Derived2的參數調用poly(Base)是符合參數類型檢查的：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">方法調用把一個本地Base類型的變量依附在一個引入的對象上。所以，雖然這個方法直接 受Base類型的參數，但Derived2對象仍是允許的。開發者就不必選擇丟失功能的方案。從人眼在通過Derived2對象時所看到的情況，Base 類型引用的依附導致了功能的喪失。但從執行的觀點看，每一個傳入poly1(Base)的參數都認為是Base的對象。執行機並不在乎有多個引用指向同一 個對象，它只注重把指向另一個對象的引用傳給方法。這些對象的類型不一致並不是主要問題。執行器只關心給運行時的對象找到適當的實現。面向類型的觀點展示 了多態的巨大能力。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">附於多個對象的引用</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">讓我們來看一下發生在poly1(Base)中的多態行 為。下面的代碼創建了三個對象，並通過引用傳給poly1(Base):</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">poly1(Base)的實現代碼是調用傳進來的參數的m1()方法。圖3和圖4展示了 把三個類的對象傳給方法時，面向類型的所使用的體系結構。</span></p><p><br></p><div class=pgc-img><img alt=Java基礎系列：理解Java多態的實現機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0858e8a58b4e4bfbb5706522a9bee45f><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">圖4：將Base引用指向Derived類，以及Base對象</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">請注意每個圖中方法m1()的映射。圖3中，m1()調用了Derived類的代碼；上面代碼中的註釋標明瞭ploy1(Base)調用 Derived.m1()。圖4中Derived對象調用的仍然是Derived類的m1()方法。最後，圖4中，Base對象調用的m1()是Base 類中定義的代碼。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多態的魅力何在？再來看一下poly1(Base)的代碼，它可以接受任何屬於Base類範疇的參數。然而，當他收 到一個Derived2的對象時，它實際上卻調用了Derived版本的方法。當你根據Base類派生出其他類時，如 Derived，Derived2，poly1(Base)都可以接受這些參數，並作出選擇調用合適的方法。多態允許你在完成poly1(Base)後擴 展它的用途。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">這看起來當然很神奇。基本的理解展示了多態的內部工作原理。在面向類型的觀點中，底層的對象所實現的代碼是非實質性的。重要的是，類型檢查器會在編譯期間為每個引用選擇合適的代碼以實現其方法。多態使開發者運用面向類型的觀點，不考慮實現的細節。這樣有助於把類型和實現分 離（實際用處是把接口和實現分離）。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">對象接口</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多態依賴於類型和實現的分離，多用來把接口和實現分離。但下面的觀點好像把Java的關鍵字 interface搞得很糊塗。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">更為重要的是開發者們怎樣理解短語“the interface to an object"，典型地，根據上下文，這個短語的意思是指一切對象類中所定義的方法，指一切對象公開的方法。這種傾向於以實現為中心的觀點較之於面向類型 的觀點來說，使我們更加註重於對象在運行期的能力。圖3中，引用面板的對象表面被標誌成"Derived2 Object"。這個面板上列出了Derived2對象的所有可用的方法。但是要理解多態，我們必須從實現這一層次上解放出來，並注意面向類型的透視圖中 被標為"Base Reference"的面板。在這一層意思上，引用變量的類型指明瞭一個對象的表面。這只是一個表面，不是接口。在類型一致的原則下，我們可以用面向類型 的觀點，為一個對象依附多個引用。對interface to an object這個短語的理解沒有確定的理解。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">該類型概念 中，the interface to an object refers 引用了面向類型觀點的最大可能----如圖2的情形。把一個基類的引用指向相同的對象縮小了這樣的觀點----如圖3所示。類型概念能使人獲得把對象間的 相互作用同實現細節分離的要領。相對於一個對象的接口，面向類型的觀點更鼓勵人們去使用一個對象的引用。引用類型規定了對象間的相互作用。當你考慮一個對 象能做什麼的時候，只需搞明白他的類型，而不需要去考慮他的實現細節。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Java接口</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">以上所談到的 多態行為用到了類的繼承關係所建立起來的子類型關係。Java接口同樣支持用戶定義的類型，相對地，Java的接口機制啟動了建立在類型層次結構上的多態 行為。假設一個名為ref的引用變量，並使其指向一個包含以下方法的類對象：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">為了弄明白poly2(IType)中的多態，以下的代碼從不同的類創建兩個對象，並分別把他們傳給 poly2(IType)：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">上面的代碼類似於關於poly1(Base)中的多態的討論。poly2(IType)的實現代碼是調 用每個對象的 本地版本的m3()方法。如同以前，代碼的註釋表明了每次調用所返回的CString類型的結果。圖5表明了兩次調用poly2(IType)的概念結構：</span></p><p><br></p><div class=pgc-img><img alt=Java基礎系列：理解Java多態的實現機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e4899ea21b3b4355a582594de6028772><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">圖5：指向Derived2和Separate對象的IType引用</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">方法poly1(Base)和poly2(IType)中所表現的多態行為的相似之處可以從透視圖中直接看出來。把我們在實現在一層上的理解再提高 一 層，就可以看到這兩段代碼的技巧。基類的引用指向了作為參數傳進的類，並且按照類型的限制調用對象的方法。引用既不知道也不關心執行哪一段代碼。編譯期間 的子類型關係檢查保證了通過的對象有能力在被調用的時候選擇合適的實現代碼。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">然而，他們在實現層上有一個重要的差別。在 poly1(Base)的例子中（圖3和圖4），Base-Derived-Derived2的類繼承結構為子類型關係的建立提供了條件，並決定了方法去 調用哪段代碼。在poly2(IType)的例子中（如圖5），則是完全不同的動態發生的。Derived2和Separate不共享任何實現的層次，但 是他們還是通過IType的引用展示了多態的行為。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">這樣的多態行為使Java的接口的功能的重大意義顯得很明顯。圖1中的UML類圖 說明了Derived是Base和IType的子類型。通過完全脫離實現細節的類型的定義方法，Java實現了多類型繼承，並且不存在Java所禁止的多 繼承所帶來的煩人的問題。完全脫離實現層次的類可以按照Java接口實現分組。在圖1中，接口IType和Derived,Separate以及這類型的 其他子類型應該劃為一組。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">按照這種完全不同於實現層次的分類方法，Java的接口機制是多態變得很方便，哪怕不存在任何共享的實現或 者複寫的方法。如圖5所示，一個IType的引用，用多態的方法訪問到了Derived2和Separate對象的m3()方法。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">再次探討對象的接口</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">注意圖5中的Derived2和Separate對象的對m1()的映射方法。如前所述，每一個對象的接 口都包含方法m1()。但卻沒有辦法用這兩個對象使方法m1()表現出多態的行為。每一個對象佔有一個m1()方法是不夠的。必須存在一個可以操作 m1()方法的類型，通過這個類型可以看到對象。這些對象似乎是共享了m1()方法，但在沒有共同基類的條件下，多態是不可能的。通過對象的接口來看多 態，會把這個概念搞混。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">結論</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">從全文所述的面向對象多態所建立起來的子類型多態，你可以清楚地認識到這種面向類型的觀點。如果你想理解子類型多態的思想，就應該把注意力從實現的細節轉移到類型的上。類型把對象分成組，並且管理著這些對象的接口。類型的 繼承層次結構決定了實現多態所需的類型關係。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">有趣的是，實現的細節並不影響子類型多態的層次結構。類型決定了對象調用什麼方法，而是 現則決定了對象怎麼執行這個方法。也就是說，類型表明了責任，而負責實施的則是具體的實現。將實現和類型分離後，我們好像看到了這兩個部分在一起跳舞，類 型決定了他的舞伴和舞蹈的名字，而實現則是舞蹈動作的設計師。</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>基礎</a></li><li><a>多態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html alt=Java基礎（多態的理解與應用) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html title=Java基礎（多態的理解與應用)>Java基礎（多態的理解與應用)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e27caade.html alt=python基礎知識，多態實例講解以及多態的作用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2506d9fe7f6641a6a12c35a35a9335db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e27caade.html title=python基礎知識，多態實例講解以及多態的作用>python基礎知識，多態實例講解以及多態的作用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cbd7408a.html alt="Java基礎知識總結 - 超詳細篇(下)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0a2c5c74ea004348be7d53c613226e92 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cbd7408a.html title="Java基礎知識總結 - 超詳細篇(下)">Java基礎知識總結 - 超詳細篇(下)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/502df7c1.html alt=Java基礎：Java容器之LinkedList class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6c01b9fdce224f35a8ff6512449a0fca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/502df7c1.html title=Java基礎：Java容器之LinkedList>Java基礎：Java容器之LinkedList</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5e5665b.html alt="Java後端精選基礎教程：Java 中的基本數據類型「連載 6」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/052bcee530bb426395f4a317122d11e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5e5665b.html title="Java後端精選基礎教程：Java 中的基本數據類型「連載 6」">Java後端精選基礎教程：Java 中的基本數據類型「連載 6」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72987d84.html alt=Java重點基礎知識回顧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/86a1f861-87fd-48a5-ad2c-ada591ff6801 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72987d84.html title=Java重點基礎知識回顧>Java重點基礎知識回顧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4cccd0e.html alt=Java基礎：面向接口編程詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/fdda4de3-84ff-4cff-bb1e-c691ed81ff9c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4cccd0e.html title=Java基礎：面向接口編程詳解>Java基礎：面向接口編程詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a398feda.html alt=「Java基礎知識」J2EE基礎知識，快看看和Java基礎的差別吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ae630290a7243d28f4c0dc08d22b88f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a398feda.html title=「Java基礎知識」J2EE基礎知識，快看看和Java基礎的差別吧>「Java基礎知識」J2EE基礎知識，快看看和Java基礎的差別吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc996cea.html alt=Java面試基礎回顧05-子類繼承父類的注意點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc996cea.html title=Java面試基礎回顧05-子類繼承父類的注意點>Java面試基礎回顧05-子類繼承父類的注意點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html alt=Java筆記之——多態詳解（重要） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/002a620d6944415d8d650a5636c4ff41 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html title=Java筆記之——多態詳解（重要）>Java筆記之——多態詳解（重要）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/015102c.html alt=Java面試基礎回顧17-多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6c2ec55fb7c24df2858c3d9da1a00019 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/015102c.html title=Java面試基礎回顧17-多態>Java面試基礎回顧17-多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>