<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試官：熟悉Java集合？那來聊聊HashMap吧 | 极客快訊</title><meta property="og:title" content="面試官：熟悉Java集合？那來聊聊HashMap吧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/3d5272f4ff3046ba946d292d85ef92b7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af89575d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af89575d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af89575d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af89575d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af89575d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af89575d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af89575d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af89575d.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="面試官：熟悉Java集合？那來聊聊HashMap吧"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/af89575d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試官：熟悉Java集合？那來聊聊HashMap吧</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>來了，他來了。</p><p>髮量稀少的面試官皺著眉頭在瀏覽後端君的簡歷，正在我忐忑不安的時候，他開口了：“我看你簡歷上寫著熟悉Java集合，那你一定知道HashMap吧？”</p><p>我點點頭，略懂。</p><p>那你先來簡單介紹一下你瞭解的HashMap，你可以把你知道的都說一下。</p><p>這麼牛？那我可不客氣了，HashMap我可是看過源碼的！</p><p>稍微梳理了一下，後端君開始了。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3d5272f4ff3046ba946d292d85ef92b7><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>1. HashMap簡述</strong></h1><p>HashMap是一個基於哈希表實現的無序的key-value容器，它鍵和值都允許設置為null，但是它是線程不安全的，同時在默認情況下如果HashMap元素超過默認容量的0.75時會進行擴容，將容量擴大為原來的兩倍。</p><h1 class=pgc-h-arrow-right><strong>1.1 HashMap的底層數據結構</strong></h1><p>在JDK1.7以前HashMap底層是數組和鏈表實現的，但是為了防止同一個數組下標中的鏈表過於長導致查詢效率過低的情況，從JDK1.8開始在HashMap容量大於64且鏈表長度大於8時會將鏈表轉化為紅黑樹。</p><p>HashMap中每一個元素都以一個Node節點的形式存放在數組中。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/da29b7d39c2844f7a415f2fc7e497a6f><p class=pgc-img-caption>HashMap底層結構</p></div><pre><code>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;    // ...}</code></pre><p>hash屬性是鍵的哈希值，key屬性存放的是鍵，value屬性存放的是值。</p><p>還有一個next屬性，就是當兩個key的哈希值相同時，這兩個元素會被放在數組的同一個下標位置中，通過next屬性指定一下個Node對象，從而會形成一個鏈表。</p><h1 class=pgc-h-arrow-right><strong>1.2 哈希碰撞</strong></h1><p>HashMap的底層數據結構首先是一個Node類型的數組，一個Node節點存放在數組中的位置（即數組下標）是由該Node節點key屬性的哈希值（也就是hash屬性）確定的，但是這就可能產生一種特殊情況——不同Node節點的哈希值相同。</p><p>如果存在兩個Node節點的hash屬性相同，那麼它們都會存放在數組下標為hash的位置，同時會通過Node節點的next屬性將這兩個節點連接在一起，形成一個鏈表，這就解決了哈希衝突的問題。</p><p>舉個例子，當我在Map中添加一個鍵為Java值為No1的元素時，Java字符串會通過hash方法來計算哈希值。假設Java字符串的哈希值為1，那麼此時HashMap的結構就是下面這樣。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e428215784834c808f57460d2060278b><p class=pgc-img-caption>放入鍵Java後的HashMap</p></div><p>假設這時再放入一個鍵為PHP值為No2的元素，剛好很不巧假設PHP作為鍵的哈希值結果也是1，那麼這個Node節點也會放在數組下標為1的位置上，同時與Java鍵形成一個鏈表，如下圖所示。</p><blockquote><p>JDK1.7中是頭插法，會引起死循環，在JDK1.8中改為使用尾插法。</p></blockquote><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/248a8799119e48f2b7388cb890fd13c7><p class=pgc-img-caption>放入鍵PHP後的HashMap</p></div><p>但是如果發生大量哈希值相同的特殊情況，導致鏈表很長，就會嚴重影響HashMap的性能，因為鏈表的查詢效率需要遍歷所有Node節點。</p><p>於是在JDK1.8引入了紅黑樹，當鏈表的長度大於8，且HashMap的容量大於64的時候，就會將鏈表轉化為紅黑樹。</p><pre><code>// JDK1.8 HashMap#putValfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {    // 省略    // binCount 是該鏈表的長度計數器，當鏈表長度大於等於8時，執行樹化方法    // TREEIFY_THRESHOLD = 8    if (binCount &gt;= TREEIFY_THRESHOLD - 1)        treeifyBin(tab, hash);    // 省略}// HashMap#treeifyBin    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    // MIN_TREEIFY_CAPACITY=64    // 若 HashMap 的大小小於64，僅擴容，不會轉化為紅黑樹    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        // 代碼省略...    }}</code></pre><h1 class=pgc-h-arrow-right><strong>1.3 如何計算鍵的哈希值</strong></h1><blockquote><p>“你剛剛一直在說鍵的哈希值，那它到底是怎麼計算的你瞭解嗎？”面試官再次提問。這是要問源碼了，作為自稱看過源碼的人，後端君當然不會落下hash函數，於是胸有成竹。</p></blockquote><p>當一個鍵值對被放入HashMap時，會通過HashMap#hash(Object key)方法來計算該鍵的哈希值，作為它存放在HashMap數組中的索引下標值，hash方法的源碼如下所示。</p><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>假如鍵為null的元素，它會被放在HashMap數組下標為0的位置。</p><p>然後就是鍵不為null的情況。</p><ol start=1><li>h被賦值為鍵的哈希值</li><li>進行h >>> 16運算</li><li>將上述兩步的結果進行^運算</li></ol><blockquote><p>作為一個在大學時計算機組成原理差點掛科的差等生，後端君對於位運算符其實是有些發憷的，幸而得到搜索引擎老師的教導，才搞明白了上述兩個位運算符的意義。</p></blockquote><ul><li>>>>符號表示<strong>無符號右移</strong>，右移後高位補0</li><li>^是<strong>異或運算符</strong>，當兩者不同時結果為1，相同時結果為0</li></ul><p>假設h=15，我們來計算一下hash方法的結果，先把15轉化為二進制，也就是0000 1111。</p><p>h >>> 16的結果就是在15的32位二進制中取高半區，也就是0000 0000 0000 0000，最後對這兩者做異或運算。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d834c2507b3d43f393040525adc433fd><p class=pgc-img-caption></p></div><p>運算結果</p><p>所以最終h=15的鍵值對將被存放在HashMap數組下標為15的位置。</p><p>上面這段hash方法有一個專業術語叫做<strong>擾動函數</strong>，它的作用就是讓元素充分的散列，減少發生哈希碰撞的可能性。</p><h1 class=pgc-h-arrow-right><strong>1.4 為什麼HashMap是線程不安全的</strong></h1><blockquote><p>"看來你對HashMap還是有些瞭解的，那你知道為什麼HashMap是線程不安全的嗎？"</p></blockquote><p>線程不安全？那當然是多線程情況下沒有考慮併發的情況了。如果面試的時候這麼答，那基本是涼涼了。</p><p>後端君在CSDN上找到一篇比較全面的回答：<strong>JDK1.7和JDK1.8中HashMap為什麼是線程不安全的？</strong>，寫的很詳細，建議大家可以去看一下。</p><p>對於這個問題後端君就不再贅述啦。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bbb06c29e95b445cb391c2b84d0a0fb3><p class=pgc-img-caption></p></div><p>總結一下：</p><ol start=1><li>在JDK1.7中，併發執行擴容操作時會造成環形鏈和數據丟失的情況</li><li>在JDK1.8中，併發執行put操作時會發生數據覆蓋的情況</li></ol><h1 class=pgc-h-arrow-right><strong>2. 紅黑樹</strong></h1><blockquote><p>“既然HashMap在擴容時會將鏈表樹化，那再來說說紅黑樹吧，你對紅黑樹有什麼瞭解？”面試官臉上毫無表情，穩穩地再次拋出一個包袱。</p></blockquote><p>紅黑樹是一棵特殊的二叉搜索樹，除了根節點外，每個非根節點有且只有一個父節點，對於一個節點來說，它的左子樹上所有節點的值都小於等於根節點的值，它的右子樹上的值都大於等於根節點的值，同時從任一節點到其每個葉子的所有路徑都包含相同數目的黑色節點。</p><p>基於紅黑樹這樣的結構特性，它的時間複雜度是O(logn)，所以會比鏈表的O(N)快，這也就是JDK1.8引入紅黑樹的原因。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ac6a8555cec48a5904fe7efccd43462><p class=pgc-img-caption>紅黑樹</p></div><blockquote><p>“那HashMap的紅黑樹是如何進行維護的呢？比如我插入一個數，如何保證這棵樹還是一個紅黑樹？”</p></blockquote><p>這……後端君只知道在HashMap會通過左旋右旋來維護一棵紅黑樹，具體的邏輯……還真不知道，於是只能如實回答。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46c51b631ff646898864f3dfc8277c13><p class=pgc-img-caption></p></div><p>不過後端君在此附上一篇博文：<strong>聊一聊紅黑樹的左旋和右旋（結合JAVA中TreeMap紅黑樹實現）</strong>，這裡面那張動圖可以說是十分形象了。</p><h1 class=pgc-h-arrow-right><strong>3. 加載因子</strong></h1><blockquote><p>“沒關係”，面試官終於有表情了，他好像感覺挺滿意似的在笑？“那你之前提到過HashMap在進行擴容的時候有一定的條件，就是元素超過默認容量的0.75，那為什麼這個值被定為0.75呢？”</p></blockquote><p>這個0.75是HashMap的加載因子屬性，它是用來進行擴容判斷的。</p><p>假設加載因子是0.5，HashMap初始化容量是16，當HashMap中有16 * 0.5=8個元素時，HashMap就會進行擴容操作。</p><p>而HashMap中加載因子為0.75，是考慮到了性能和容量的平衡。</p><p>由加載因子的定義，可以知道它的取值範圍是(0, 1]。</p><ul><li>如果加載因子過小，那麼擴容門檻低，擴容頻繁，這雖然能使元素存儲得更稀疏，有效避免了哈希衝突發生，同時操作性能較高，但是會佔用更多的空間。</li><li>如果加載因子過大，那麼擴容門檻高，擴容不頻繁，雖然佔用的空間降低了，但是這會導致元素存儲密集，發生哈希衝突的概率大大提高，從而導致存儲元素的數據結構更加複雜（用於解決哈希衝突），最終導致操作性能降低。</li><li>還有一個因素是為了提升擴容效率。因為HashMap的容量（size屬性，構造函數中的initialCapacity變量）有一個要求：它一定是2的冪。所以加載因子選擇了0.75就可以保證它與容量的乘積為整數。</li></ul><pre><code>// 構造函數public HashMap(int initialCapacity, float loadFactor) {    // ……    this.loadFactor = loadFactor;// 加載因子    this.threshold = tableSizeFor(initialCapacity);}/** * 返回2的冪 * Returns a power of two size for the given target capacity. * MAXIMUM_CAPACITY = 1 &lt;&lt; 30 */static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><h1 class=pgc-h-arrow-right><strong>4. HashMap容量</strong></h1><blockquote><p>HashMap的默認初始容量是16，而每次擴容是擴容為原來的2倍。這裡的16和2倍就保證了HashMap的容量是2的n次冪，這樣設計的原因是什麼呢？</p></blockquote><h1 class=pgc-h-arrow-right>原因一：與運算高效</h1><p>與運算&，基於二進制數值，同時為1結果為1，否則就是0。如1&1=1,1&0=0,0&0=0。使用與運算的原因就是對於計算機來說，與運算十分高效。</p><h1 class=pgc-h-arrow-right>原因二：有利於元素充分散列，減少 Hash 碰撞</h1><p>在給HashMap添加元素的putVal函數中，有這樣一段代碼：</p><pre><code>// n為容量，hash為該元素的hash值if ((p = tab[i = (n - 1) &amp; hash]) == null)    tab[i] = newNode(hash, key, value, null);</code></pre><p>它會在添加元素時，通過i = (n - 1) & hash計算該元素在HashMap中的位置。</p><p>當 HashMap 的容量為 2 的 n 次冪時，他的二進制值是100000……（n個0），所以n-1的值就是011111……（n個1），這樣的話(n - 1) & hash的值才能夠充分散列。</p><p>舉個例子，假設容量為16，現在有哈希值為1111，1110，1011，1001四種將被添加，它們與n-1(15的二進制=01111)的哈希值分別為1111、1110、1110、1011，都不相同。</p><p>而假設容量不為2的n次冪，假設為10，那麼它與上述四個哈希值進行與運算的結果分別是：0101、0100、0001、0001。</p><p>可以看到後兩個值發生了碰撞，從中可以看出，非2的n次冪會加大哈希碰撞的概率。所以HashMap的容量設置為2的n次冪有利於元素的充分散列。</p><h1 class=pgc-h-arrow-right><strong>5. 死循環</strong></h1><p>上文在說到為什麼HashMap是線程不安全的的時候提到過在JDK1.7中由於哈希碰撞，在同一個數組下標中進行鏈表元素的新增時是用頭插法，會導致死循環，而在JDK1.8中改為使用尾插法，避免了死循環的情況的發生。</p><hr><p>“小夥子，看來你對HashMap的瞭解還是挺多的。”面試官點了點頭，對後端君發出了肯定。</p><p>“接下來我們再來聊聊其他內容吧……”</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c72abb4fbc8a4ebea383a028ca1cde08><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>6. 小結</strong></h1><p>你還記得面試官對後端君提出的那些關於HashMap的問題嗎？來回顧一下吧</p><ul><li>HashMap的底層數據結構是怎麼樣的？</li><li>哈希碰撞是什麼？如何解決？</li><li>哈希值的計算過程？</li><li>為什麼HashMap是線程不安全的？</li><li>簡單說下紅黑樹的特性</li><li>HashMap加載因子為什麼默認是0.75？</li><li>HashMap容量為什麼設計成是2的n次冪？</li><li>HashMap死循環是怎麼回事？</li></ul><h1 class=pgc-h-arrow-right>7.分享</h1><p>最後小編整理了一份Java相關的資料，需要的小夥伴可以<strong>私信我【面試】</strong>即可免費領取！</p><p>放一些大概截圖，感興趣的小夥伴可以收著。</p><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b2d69222f7ba465a9cb5b0009af4cf2b><p class=pgc-img-caption>java面試題及大廠真題</p></div><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c18704e19f28422c9da6e10d77bc1f4b><p class=pgc-img-caption>大量電子書</p></div><h1 class=pgc-h-arrow-right>知識點相關面試題</h1><div class=pgc-img><img alt=面試官：熟悉Java集合？那來聊聊HashMap吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0aec7063cffb4fe0b29e1080160ea253><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>私信【面試】即可免費獲得<br></h1></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>Java</a></li><li><a>那來</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6886951d.html alt="IT面試---Java基礎：Collection 和 Collections 有什麼區別？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a61f90ddf82c41ffb6fb3b30b86ea5bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6886951d.html title="IT面試---Java基礎：Collection 和 Collections 有什麼區別？">IT面試---Java基礎：Collection 和 Collections 有什麼區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7816c067.html alt=Java高級面試寶典，必備分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7816c067.html title=Java高級面試寶典，必備分享>Java高級面試寶典，必備分享</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68200806.html alt=面試官：兄弟，說說Java到底是值傳遞還是引用傳遞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8427a88278d4440e90b95ad363ecad34 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68200806.html title=面試官：兄弟，說說Java到底是值傳遞還是引用傳遞>面試官：兄弟，說說Java到底是值傳遞還是引用傳遞</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/754c19ae.html alt=Java集合框架常見面試問題剖析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/74010d4d11bc4d0494947b59936d6a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/754c19ae.html title=Java集合框架常見面試問題剖析>Java集合框架常見面試問題剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8da88db.html alt="Java面試官：請說下java向上轉型和向下轉型 程序汪：不清楚啊" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e3a0cd7f20054843a3e8559998a96263 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8da88db.html title="Java面試官：請說下java向上轉型和向下轉型 程序汪：不清楚啊">Java面試官：請說下java向上轉型和向下轉型 程序汪：不清楚啊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ee3fbb9.html alt=Java面試都會涉及到哪些內容？Java筆試題庫（三） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/17503d30-904f-41c0-b073-bfcb1ee363ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ee3fbb9.html title=Java面試都會涉及到哪些內容？Java筆試題庫（三）>Java面試都會涉及到哪些內容？Java筆試題庫（三）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc996cea.html alt=Java面試基礎回顧05-子類繼承父類的注意點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc996cea.html title=Java面試基礎回顧05-子類繼承父類的注意點>Java面試基礎回顧05-子類繼承父類的注意點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/015102c.html alt=Java面試基礎回顧17-多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6c2ec55fb7c24df2858c3d9da1a00019 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/015102c.html title=Java面試基礎回顧17-多態>Java面試基礎回顧17-多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3bc8bd1.html alt=Java面試官問：“面向對象7大設計原則”——教你如何完美解答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/01fe429309444a6885c5b2e92feac9db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3bc8bd1.html title=Java面試官問：“面向對象7大設計原則”——教你如何完美解答>Java面試官問：“面向對象7大設計原則”——教你如何完美解答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>