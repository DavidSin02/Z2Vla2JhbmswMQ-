<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>智能合約編寫之Solidity的編程攻略 | 火星號精選 | 极客快訊</title><meta property="og:title" content="智能合約編寫之Solidity的編程攻略 | 火星號精選 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RivR6n1AU5yy8h"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b0618900.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b0618900.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b0618900.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b0618900.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b0618900.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b0618900.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b0618900.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b0618900.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="智能合約編寫之Solidity的編程攻略 | 火星號精選"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b0618900.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>智能合約編寫之Solidity的編程攻略 | 火星號精選</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="智能合約編寫之Solidity的編程攻略 | 火星號精選" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RivR6n1AU5yy8h><blockquote><p>免責聲明：本文旨在傳遞更多市場信息，不構成任何投資建議。文章僅代表作者觀點，不代表火星財經官方立場。</p></blockquote><p>小編：記得關注哦</p><p>來源：區塊鏈服務網絡BSN</p><p>3月25日，BSN第二次開發者大賽正式啟動，本次大賽以“編寫基於多種底層框架的智能合約”為主題，開發者可基於FISCO BCOS等主流底層框架，結合業務場景設計、開發並部署智能合約。</p><p>為了讓大家更好上手智能合約開發，區塊鏈服務網絡發展聯盟與FISCO BCOS開源社區共同推出“7個課時速成智能合約全能型開發”系列教程，助力開發者學習並熟悉合約開發，輕鬆應對此次大賽並拔得頭籌。</p><p><strong>系列專題 | 超話區塊鏈之智能合約專場</strong></p><p><strong>編寫篇：智能合約編寫之 Solidity 的編程攻略</strong></p><p>作者：毛嘉宇</p><img alt="智能合約編寫之Solidity的編程攻略 | 火星號精選" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RzQ4k7H1UNWSGq><p></p><h1><strong>前 言</strong></h1><p>作為一名搬磚多年的資深碼農，剛開始接觸Solidity便感覺無從下手：昂貴的計算和存儲資源、簡陋的語法特性、令人抓狂的debug體驗、近乎貧瘠的類庫支持、一言不合就插入彙編語句……讓人不禁懷疑，這都已經過了9012年了，居然還有這種反人類的語言？</p><p>對於習慣使用各類日益“傻瓜化”的類庫和自動化高級框架的碼農而言，學習Solidity的過程就是一場一言難盡的勸退之旅。</p><p>但隨著對區塊鏈底層技術的深入學習，大家會慢慢理解作為運行在“The World Machine”上的Solidity語言，必須要嚴格遵循的設計原則以及權衡後必須付出的代價。</p><p>正如黑客帝國中那句著名的slogan：“Welcome to the dessert of the real”，在惡劣艱苦的環境面前，最重要的是學會如何適應環境、保存自身並快速進化。</p><p>本文總結了一些Solidity編程的攻略，期待各位讀者不吝分享交流，達到拋磚引玉之效。</p><p></p><h1><strong>上鍊的原則</strong></h1><p><strong>“如無必要，勿增實體”。</strong></p><p>基於區塊鏈技術及智能合約發展現狀，數據的上鍊需遵循以下原則：</p><ul><li>需要分佈式協作的重要數據才上鍊，非必需數據不上鍊；</li><li>敏感數據脫敏或加密後上鏈（視數據保密程度選擇符合隱私保護安全等級要求的加密算法）；</li><li>鏈上驗證，鏈下授權。</li></ul><p>在使用區塊鏈時，開發者不需要將所有業務和數據都放到鏈上。相反，“好鋼用在刀刃上”，智能合約更適合被用在分佈式協作的業務場景中。</p><p></p><h1><strong>精簡函數變量</strong></h1><p>如果在智能合約中定義了複雜的邏輯，特別是合約內定義了複雜的函數入參、變量和返回值，就會在編譯的時候碰到以下錯誤：</p><pre><code>Compiler error: Stack too deep, try removing local variables.</code></pre><p>這也是社區中的高頻技術問題之一。造成這個問題的原因就是EVM所設計用於最大的棧深度為16。</p><p>所有的計算都在一個棧內執行，對棧的訪問只限於其頂端，限制方式為：允許拷貝最頂端16個元素中的一個到棧頂，或者將棧頂元素和下面16個元素中的一個交換。</p><p>所有其他操作都只能取最頂的幾個元素，運算後，把結果壓入棧頂。當然可以把棧上的元素放到存儲或內存中。但無法只訪問棧上指定深度的那個元素，除非先從棧頂移除其他元素。如果一個合約中，入參、返回值、內部變量的大小超過了16個，顯然就超出了棧的最大深度。</p><p>因此，我們可以使用結構體或數組來封裝入參或返回值，達到減少棧頂元素使用的目的，從而避免此錯誤。</p><p>例如以下代碼，通過使用bytes數組來封裝了原本16個bytes變量。</p><pre><code>function doBiz(bytes[] paras) public {<br>require(paras.length &gt;= 16);<br>// do something<br>}</code></pre><p></p><h1><strong>保證參數和行為符合預期</strong></h1><p>心懷“Code is law”的遠大理想，極客們設計和創造了區塊鏈的智能合約。</p><p>在聯盟鏈中，不同的參與者可以使用智能合約來定義和書寫一部分業務或交互的邏輯，以完成部分社會或商業活動。</p><p>相比於傳統軟件開發，智能合約對函數參數和行為的安全性要求更為嚴格。在聯盟鏈中提供了身份實名和CA證書等機制，可以有效定位和監管所有參與者。不過，智能合約缺乏對漏洞和攻擊的事前干預機制。正所謂字字珠璣，如果不嚴謹地檢查智能合約輸入參數或行為，有可能會觸發一些意想不到的bug。</p><p>因此，在編寫智能合約時，一定要注意對合約參數和行為的檢查，尤其是那些對外部開放的合約函數。</p><p>Solidity提供了require、revert、assert等關鍵字來進行異常的檢測和處理。一旦檢測並發現錯誤，整個函數調用會被回滾，所有狀態修改都會被回退，就像從未調用過函數一樣。</p><p>以下分別使用了三個關鍵字，實現了相同的語義。</p><pre><code>require(_data == data, "require data is valid");<br><br>if(_data != data) { revert("require data is valid"); }<br><br>assert(_data == data);</code></pre><p>不過，這三個關鍵字一般適用於不同的使用場景：</p><ul><li>require：最常用的檢測關鍵字，用來驗證輸入參數和調用函數結果是否合法。</li><li>revert：適用在某個分支判斷的場景下。</li><li>assert: 檢查結果是否正確、合法，一般用於函數結尾。</li></ul><p>在一個合約的函數中，可以使用函數修飾器來抽象部分參數和條件的檢查。在函數體內，可以對運行狀態使用if-else等判斷語句進行檢查，對異常的分支使用revert回退。在函數運行結束前，可以使用assert對執行結果或中間狀態進行斷言檢查。</p><p>在實踐中，推薦使用require關鍵字，並將條件檢查移到函數修飾器中去；這樣可以讓函數的職責更為單一，更專注到業務邏輯中。同時，函數修飾器等條件代碼也更容易被複用，合約也會更加安全、層次化。</p><p>在本文中，我們以一個水果店庫存管理系統為例，設計一個水果超市的合約。這個合約只包含了對店內所有水果品類和庫存數量的管理，setFruitStock函數提供了對應水果庫存設置的函數。在這個合約中，我們需要檢查傳入的參數，即水果名稱不能為空。</p><pre><code>pragma solidity ^0.4.25;<br><br>contract FruitStore {<br>mapping(bytes =&gt; uint) _fruitStock;<br>modifier validFruitName(bytes fruitName) {<br>require(fruitName.length &gt; 0, "fruite name is invalid!");<br>_;<br>}<br>function setFruitStock(bytes fruitName, uint stock) validFruitName(fruitName) external {<br>_fruitStock[fruitName] = stock;<br>}<br>}</code></pre><p>如上所述，我們添加了函數執行前的參數檢查的函數修飾器。同理，通過使用函數執行前和函數執行後檢查的函數修飾器，可以保證智能合約更加安全、清晰。智能合約的編寫需要設置嚴格的前置和後置函數檢查，來保證其安全性。</p><p></p><h1><strong>嚴控函數的執行權限</strong></h1><p>如果說智能合約的參數和行為檢測提供了靜態的合約安全措施，那麼合約權限控制的模式則提供了動態訪問行為的控制。</p><p>由於智能合約是發佈到區塊鏈上，所有數據和函數對所有參與者都是公開透明的，任一節點參與者都可發起交易，無法保證合約的隱私。因此，合約發佈者必須對函數設計嚴格的訪問限制機制。</p><p>Solidity提供了函數可見性修飾符、修飾器等語法，靈活地使用這些語法，可幫助構建起合法授權、受控調用的智能合約系統。</p><p>還是以剛才的水果合約為例。現在getStock提供了查詢具體水果庫存數量的函數。</p><pre><code>pragma solidity ^0.4.25;<br><br>contract FruitStore {<br>mapping(bytes =&gt; uint) _fruitStock;<br>modifier validFruitName(bytes fruitName) {<br>require(fruitName.length &gt; 0, "fruite name is invalid!");<br>_;<br>}<br>function getStock(bytes fruit) external view returns(uint) {<br>return _fruitStock[fruit];<br>}<br>function setFruitStock(bytes fruitName, uint stock) validFruitName(fruitName) external {<br>_fruitStock[fruitName] = stock;<br>}<br>}</code></pre><p>水果店老闆將這個合約發佈到了鏈上。但是，發佈之後，setFruitStock函數可被任何其他聯盟鏈的參與者調用。</p><p>雖然聯盟鏈的參與者是實名認證且可事後追責；但一旦有惡意攻擊者對水果店發起攻擊，調用setFruitStock函數就能任意修改水果庫存，甚至將所有水果庫存清零，這將對水果店正常經營管理產生嚴重後果。</p><p>因此，設置某些預防和授權的措施很必要：對於修改庫存的函數setFruitStock，可在函數執行前對調用者進行鑑權。</p><p>類似的，這些檢查可能會被多個修改數據的函數複用，使用一個onlyOwner的修飾器就可以抽象此檢查。_owner字段代表了合約的所有者，會在合約構造函數中被初始化。使用public修飾getter查詢函數，就可以通過_owner函數查詢合約的所有者。</p><pre><code>contract FruitStore {<br>address public _owner;<br>mapping(bytes =&gt; uint) _fruitStock;<br><br>constructor public {<br>_owner = msg.sender;<br>}<br><br>modifier validFruitName(bytes fruitName) {<br>require(fruitName.length &gt; 0, "fruite name is invalid!");<br>_;<br>}<br>// 鑑權函數修飾器<br>modifier onlyOwner {<br>require(msg.sender == _owner, "Auth: only owner is authorized.");<br>_;<br>}<br>function getStock(bytes fruit) external view returns(uint) {<br>return _fruitStock[fruit];<br>}<br>// 添加了onlyOwner修飾器<br>function setFruitStock(bytes fruitName, uint stock)<br>onlyOwner validFruitName(fruitName) external {<br>_fruitStock[fruitName] = stock;<br>}<br>}</code></pre><p>這樣一來，我們可以將相應的函數調用權限檢查封裝到修飾器中，智能合約會自動發起對調用者身份驗證檢查，並且只允許合約部署者來調用setFruitStock函數，以此保證合約函數向指定調用者開放。</p><p></p><h1><strong>抽象通用的業務邏輯</strong></h1><p>分析上述FruitStore合約，我們發現合約裡似乎混入了奇怪的東西。參考單一職責的編程原則，水果店庫存管理合約多了上述函數功能檢查的邏輯，使合約無法將所有代碼專注在自身業務邏輯中。</p><p>對此，我們可以抽象出可複用的功能，利用Solidity的繼承機制繼承最終抽象的合約。</p><p>基於上述FruitStore合約，可抽象出一個BasicAuth合約，此合約包含之前onlyOwner的修飾器和相關功能接口。</p><pre><code>contract BasicAuth {<br>address public _owner;<br><br>constructor public {<br>_owner = msg.sender;<br>}<br><br>function setOwner(address owner)<br>public<br>onlyOwner<br>{<br>_owner = owner;<br>}<br><br>modifier onlyOwner {<br>require(msg.sender == _owner, "BasicAuth: only owner is authorized.");<br>_;<br>}<br>}</code></pre><p>FruitStore可以複用這個修飾器，並將合約代碼收斂到自身業務邏輯中。</p><pre><code>import "./BasicAuth.sol";<br><br>contract FruitStore is BasicAuth {<br>mapping(bytes =&gt; uint) _fruitStock;<br><br>function setFruitStock(bytes fruitName, uint stock)<br>onlyOwner validFruitName(fruitName) external {<br>_fruitStock[fruitName] = stock;<br>}<br>}</code></pre><p>這樣一來，FruitStore的邏輯被大大簡化，合約代碼更精簡、聚焦和清晰。</p><p></p><h1><strong>預防私鑰的丟失</strong></h1><p>在區塊鏈中調用合約函數的方式有兩種：內部調用和外部調用。</p><p>出於隱私保護和權限控制，業務合約會定義一個合約所有者。假設用戶A部署了FruitStore合約，那上述合約owner就是部署者A的外部賬戶地址。這個地址由外部賬戶的私鑰計算生成。</p><p>但是，在現實世界中，私鑰洩露、丟失的現象比比皆是。一個商用區塊鏈DAPP需要嚴肅考慮私鑰的替換和重置等問題。</p><p>這個問題最為簡單直觀的解決方法是添加一個備用私鑰。這個備用私鑰可支持權限合約修改owner的操作，代碼如下：</p><pre><code>contract BasicAuth {<br>address public _owner;<br>address public _bakOwner;<br><br>constructor(address bakOwner) public {<br>_owner = msg.sender;<br>_bakOwner = bakOwner;<br>}<br><br>function setOwner(address owner)<br>public<br>canSetOwner<br>{<br>_owner = owner;<br>}<br><br>function setBakOwner(address owner)<br>public<br>canSetOwner<br>{<br>_bakOwner = owner;<br>}<br><br>// ...<br><br>modifier isAuthorized {<br>require(msg.sender == _owner || msg.sender == _bakOwner, "BasicAuth: only owner or back owner is authorized.");<br>_;<br>}<br>}</code></pre><p>這樣，當發現私鑰丟失或洩露時，我們可以使用備用外部賬戶調用setOwner重置賬號，恢復、保障業務正常運行。</p><p></p><h1><strong>面向接口編程</strong></h1><p>上述私鑰備份理念值得推崇，不過其具體實現方式存在一定侷限性，在很多業務場景下，顯得過於簡單粗暴。</p><p>對於實際的商業場景，私鑰的備份和保存需要考慮的維度和因素要複雜得多，對應密鑰備份策略也更多元化。</p><p>以水果店為例，有的連鎖水果店可能希望通過品牌總部來管理私鑰，也有的可能通過社交關係重置帳號，還有的可能會綁定一個社交平臺的管理帳號……</p><p>面向接口編程，而不依賴具體的實現細節，可以有效規避這個問題。例如，我們利用接口功能首先定義一個判斷權限的抽象接口：</p><pre><code>contract Authority {<br>function canCall(<br>address src, address dst, bytes4 sig<br>) public view returns (bool);<br>}</code></pre><p>這個canCall函數涵蓋了函數調用者地址、目標調用合約的地址和函數簽名，函數返回一個bool的結果。這包含了合約鑑權所有必要的參數。</p><p>我們可進一步修改之前的權限管理合約，並在合約中依賴Authority接口，當鑑權時，修飾器會調用接口中的抽象方法：</p><pre><code>contract BasicAuth {<br>Authority public _authority;<br><br>function setAuthority(Authority authority)<br>public<br>auth<br>{<br>_authority = authority;<br>}<br><br>modifier isAuthorized {<br>require(auth(msg.sender, msg.sig), "BasicAuth: only owner or back owner is authorized.");<br>_;<br>}<br><br>function auth(address src, bytes4 sig) public view returns (bool) {<br>if (src == address(this)) {<br>return true;<br>} else if (src == _owner) {<br>return true;<br>} else if (_authority == Authority(0)) {<br>return false;<br>} else {<br>return _authority.canCall(src, this, sig);<br>}<br>}<br>}</code></pre><p>這樣，我們只需要靈活定義實現了canCall接口的合約，在合約的canCall方法中定義具體判斷邏輯。而業務合約，例如FruitStore繼承BasicAuth合約，在創建時只要傳入具體的實現合約，就可以實現不同判斷邏輯。</p><p></p><h1><strong>合理預留事件</strong></h1><p>迄今為止，我們已實現強大靈活的權限管理機制，只有預先授權的外部賬戶才能修改合約owner屬性。</p><p>不過，僅通過上述合約代碼，我們無法記錄和查詢修改、調用函數的歷史記錄和明細信息。而這樣的需求在實際業務場景中比比皆是。比如，FruitStore水果店需要通過查詢歷史庫存修改記錄，計算出不同季節的暢銷與滯銷水果。</p><p>一種方法是依託鏈下維護獨立的臺賬機制。不過，這種方法存在很多問題：保持鏈下臺賬和鏈上記錄一致的成本開銷非常高；同時，智能合約面向鏈上所有參與者開放，一旦其他參與者調用了合約函數，相關交易信息就存在不能同步的風險。</p><p>針對此類場景，Solidity提供了event語法。event不僅具備可供SDK監聽回調的機制，還能用較低的gas成本將事件參數等信息完整記錄、保存到區塊中。FISCO BCOS社區中，也有WEBASE-Collect-Bee這樣的工具，在事後實現區塊歷史事件信息的完整導出。</p><p>WEBASE-Collect-Bee工具參考鏈接如下：</p><p>https://webasedoc.readthedocs.io/zh_CN/latest/docs/WeBASE-Collect-Bee/index.html</p><p>基於上述權限管理合約，我們可以定義相應的修改權限事件，其他事件以此類推。</p><pre><code>event LogSetAuthority (Authority indexed authority, address indexed from);<br>}</code></pre><p>接下來，可以調用相應的事件：</p><pre><code>function setAuthority(Authority authority)<br>public<br>auth<br>{<br>_authority = authority;<br>emit LogSetAuthority(authority, msg.sender);<br>}</code></pre><p>當setAuthority函數被調用時，會同時觸發LogSetAuthority，將事件中定義的Authority合約地址以及調用者地址記錄到區塊鏈交易回執中。當通過控制檯調用setAuthority方法時，對應事件LogSetAuthority也會被打印出來。</p><p>基於WEBASE-Collect-Bee，我們可以導出所有該函數的歷史信息到數據庫中。也可基於WEBASE-Collect-Bee進行二次開發，實現複雜的數據查詢、大數據分析和數據可視化等功能。</p><p></p><h1><strong>遵循安全編程規範</strong></h1><p>每一門語言都有其相應的編碼規範，我們需要儘可能嚴格地遵循Solidity官方編程風格指南，使代碼更利於閱讀、理解和維護，有效地減少合約的bug數量。</p><p>Solidity官方編程風格指南參考鏈接如下：</p><p>https://solidity.readthedocs.io/en/latest/style-guide.html</p><p>除了編程規範，業界也總結了很多安全編程指南，例如重入漏洞、數據結構溢出、隨機數誤區、構造函數失控、為初始化的存儲指針等等。重視和防範此類風險，採用業界推薦的安全編程規範至關重要，例如Solidity官方安全編程指南。參考鏈接如下：</p><p>https://solidity.readthedocs.io/en/latest/security-considerations.html</p><p>同時，在合約發佈上線後，還需要注意關注、訂閱Solidity社區內安全組織或機構發佈的各類安全漏洞、攻擊手法，一旦出現問題，及時做到亡羊補牢。</p><p>對於重要的智能合約，有必要引入審計。現有的審計包括了人工審計、機器審計等方法，通過代碼分析、規則驗證、語義驗證和形式化驗證等方法保證合約安全性。</p><p>雖然本文通篇都在強調，模塊化和重用被嚴格審查並廣泛驗證的智能合約是最佳的實踐策略。但在實際開發過程，這種假設過於理想化，每個項目或多或少都會引入新的代碼，甚至從零開始。</p><p>不過，我們仍然可以視代碼的複用程度進行審計分級，顯式地標註出引用的代碼，將審計和檢查的重點放在新代碼上，以節省審計成本。</p><p>最後，“前事不忘後事之師”，我們需要不斷總結和學習前人的最佳實踐，動態和可持續地提升編碼工程水平，並不斷應用到具體實踐中。</p><p></p><h1><strong>積累和複用成熟的代碼</strong></h1><p>前文面向接口編程中的思想可降低代碼耦合，使合約更容易擴展、利於維護。在遵循這條規則之外，還有另外一條忠告：儘可能地複用現有代碼庫。</p><p>智能合約發佈後難以修改或撤回，而且發佈到公開透明的區塊鏈環境上，就意味著一旦出現bug造成的損失和風險更甚於傳統軟件。因此，複用一些更好更安全的輪子遠勝過重新造輪子。</p><p>在開源社區中，已經存在大量的業務合約和庫可供使用，例如OpenZeppelin等優秀的庫。</p><p>如果在開源世界和過去團隊的代碼庫裡找不到合適的可複用代碼，建議在編寫新代碼時儘可能地測試和完善代碼設計。此外，還要定期分析和審查歷史合約代碼，將其模板化，以便於擴展和複用。</p><p>例如，針對上面的BasicAuth，參考防火牆經典的ACL(Access Control List)設計，我們可以進一步地繼承和擴展BasicAuth，抽象出ACL合約控制的實現。</p><pre><code>contract AclGuard is BasicAuth {<br>bytes4 constant public ANY_SIG = bytes4(uint(-1));<br>address constant public ANY_ADDRESS = address(bytes20(uint(-1)));<br>mapping (address =&gt; mapping (address =&gt; mapping (bytes4 =&gt; bool))) _acl;<br><br>function canCall(<br>address src, address dst, bytes4 sig<br>) public view returns (bool) {<br>return _acl[src][dst][sig]<br>|| _acl[src][dst][ANY_SIG]<br>|| _acl[src][ANY_ADDRESS][sig]<br>|| _acl[src][ANY_ADDRESS][ANY_SIG]<br>|| _acl[ANY_ADDRESS][dst][sig]<br>|| _acl[ANY_ADDRESS][dst][ANY_SIG]<br>|| _acl[ANY_ADDRESS][ANY_ADDRESS][sig]<br>|| _acl[ANY_ADDRESS][ANY_ADDRESS][ANY_SIG];<br>}<br><br>function permit(address src, address dst, bytes4 sig) public onlyAuthorized {<br>_acl[src][dst][sig] = true;<br>emit LogPermit(src, dst, sig);<br>}<br><br>function forbid(address src, address dst, bytes4 sig) public onlyAuthorized {<br>_acl[src][dst][sig] = false;<br>emit LogForbid(src, dst, sig);<br>}<br><br>function permit(address src, address dst, string sig) external {<br>permit(src, dst, bytes4(keccak256(sig)));<br>}<br><br>function forbid(address src, address dst, string sig) external {<br>forbid(src, dst, bytes4(keccak256(sig)));<br>}<br><br>function permitAny(address src, address dst) external {<br>permit(src, dst, ANY_SIG);<br>}<br><br>function forbidAny(address src, address dst) external {<br>forbid(src, dst, ANY_SIG);<br>}<br>}</code></pre><p>在這個合約裡，有調用者地址、被調用合約地址和函數簽名三個主要參數。通過配置ACL的訪問策略，可以精確地定義和控制函數訪問行為及權限。合約內置了ANY的常量，匹配任意函數，使訪問粒度的控制更加便捷。這個模板合約實現了強大靈活的功能，足以滿足所有類似權限控制場景的需求。</p><p></p><h1><strong>提升存儲和計算的效率</strong></h1><p>迄今為止，在上述的推演過程中，更多的是對智能合約編程做加法。但相比傳統軟件環境，智能合約上的存儲和計算資源更加寶貴。因此，如何對合約做減法也是用好Solidity的必修課程之一。</p><p><strong>選取合適的變量類型</strong></p><p>顯式的問題可通過EVM編譯器檢測出來並報錯；但大量的性能問題可能被隱藏在代碼的細節中。</p><p>Solidity提供了非常多精確的基礎類型，這與傳統的編程語言大相徑庭。下面有幾個關於Solidity基礎類型的小技巧。</p><p>在C語言中，可以用short\int\long按需定義整數類型，而到了Solidity，不僅區分int和uint，甚至還能定義uint的長度，比如uint8是一個字節，uint256是32個字節。這種設計告誡我們，能用uint8搞定的，絕對不要用uint16！</p><p>幾乎所有Solidity的基本類型，都能在聲明時指定其大小。開發者一定要有效利用這一語法特性，編寫代碼時只要滿足需求就儘可能選取小的變量類型。</p><p>數據類型bytes32可存放 32 個（原始）字節，但除非數據是bytes32或bytes16這類定長的數據類型，否則更推薦使用長度可以變化的bytes。bytes類似byte，但在外部函數中會自動壓縮打包，更節省空間。</p><p>如果變量內容是英文的，不需要採用UTF-8編碼，在這裡，推薦bytes而不是string。string默認採用UTF-8編碼，所以相同字符串的存儲成本會高很多。</p><p><strong>緊湊狀態變量打包</strong></p><p>除了儘可能使用較小的數據類型來定義變量，有的時候，變量的排列順序也非常重要，可能會影響到程序執行和存儲效率。</p><p>其中根本原因還是EVM，不管是EVM存儲插槽（Storage Slot）還是棧，每個元素長度是一個字（256位，32字節）。</p><p>分配存儲時，所有變量（除了映射和動態數組等非靜態類型）都會按聲明順序從位置0開始依次寫下。</p><p>在處理狀態變量和結構體成員變量時，EVM會將多個元素打包到一個存儲插槽中，從而將多個讀或寫合併到一次對存儲的操作中。</p><p>值得注意的是，使用小於32 字節的元素時，合約的gas使用量可能高於使用32字節元素時。這是因為EVM每次會操作32個字節，所以如果元素比32字節小，必須使用更多的操作才能將其大小縮減到所需。這也解釋了Solidity中最常見的數據類型，例如int，uint，byte32，為何都剛好佔用32個字節。</p><p>所以，當合約或結構體聲明多個狀態變量時，能否合理地組合安排多個存儲狀態變量和結構體成員變量，使之佔用更少的存儲位置就十分重要。</p><p>例如，在以下兩個合約中，經過實際測試，Test1合約比Test2合約佔用更少的存儲和計算資源。</p><pre><code>contract Test1 {<br>//佔據2個slot, "gasUsed":188873<br>struct S {<br>bytes1 b1;<br>bytes31 b31;<br>bytes32 b32;<br>}<br>S s;<br>function f public {<br>S memory tmp = S("a","b","c");<br>s = tmp;<br>}<br>}<br><br>contract Test2 {<br>//佔據1個slot, "gasUsed":188937<br>struct S {<br>bytes31 b31;<br>bytes32 b32;<br>bytes1 b1;<br>}<br>// ……<br>}</code></pre><p><strong>優化查詢接口</strong></p><p>查詢接口的優化點很多，比如一定要在只負責查詢的函數聲明中添加view修飾符，否則查詢函數會被當成交易打包併發送到共識隊列，被全網執行並被記錄在區塊中；這將大大增加區塊鏈的負擔，佔用寶貴的鏈上資源。</p><p>再如，不要在智能合約中添加複雜的查詢邏輯，因為任何複雜查詢代碼都會使整個合約變得更長更復雜。讀者可使用上文提及的WeBASE數據導出組件，將鏈上數據導出到數據庫中，在鏈下進行查詢和分析。</p><p><strong>縮減合約binary長度</strong></p><p>開發者編寫的Solidity代碼會被編譯為binary code，而部署智能合約的過程實際上就是通過一個transaction將binary code存儲在鏈上，並取得專屬於該合約的地址。</p><p>縮減binary code的長度可節省網絡傳輸、共識打包數據存儲的開銷。例如，在典型的存證業務場景中，每次客戶存證都會新建一個存證合約，因此，應當儘可能地縮減binary code的長度。</p><p>常見思路是裁剪不必要的邏輯，刪掉冗餘代碼。特別是在複用代碼時，可能引入一些非剛需代碼。以上文ACL合約為例，支持控制合約函數粒度的權限。</p><pre><code>function canCall(<br>address src, address dst, bytes4 sig<br>) public view returns (bool) {<br>return _acl[src][dst][sig]<br>|| _acl[src][dst][ANY_SIG]<br>|| _acl[src][ANY_ADDRESS][sig]<br>|| _acl[src][ANY_ADDRESS][ANY_SIG]<br>|| _acl[ANY_ADDRESS][dst][sig]<br>|| _acl[ANY_ADDRESS][dst][ANY_SIG]<br>|| _acl[ANY_ADDRESS][ANY_ADDRESS][sig]<br>|| _acl[ANY_ADDRESS][ANY_ADDRESS][ANY_SIG];<br>}</code></pre><p>但在具體業務場景中，只需要控制合約訪問者即可，通過刪除相應代碼，進一步簡化使用邏輯。這樣一來，對應合約的binary code長度會大大縮小。</p><pre><code>function canCall(<br>address src, address dst<br>) public view returns (bool) {<br>return _acl[src][dst]<br>|| _acl[src][ANY_ADDRESS]<br>|| _acl[ANY_ADDRESS][dst];<br>}</code></pre><p>另一種縮減binary code的思路是採用更緊湊的寫法。</p><p>經實測，採取如上短路原則的判斷語句，其binary長度會比採用if-else語法的更短。同樣，採用if-else的結構，也會比if-if-if的結構生成更短的binary code。</p><p>最後，在對binary code長度有極致要求的場景中，應當儘可能避免在合約中新建合約，這會顯著增加binary的長度。例如，某個合約中有如下的構造函數：</p><pre><code>constructor public {<br>// 在構造器內新建一個新對象<br>_a = new A;<br>}</code></pre><p>我們可以採用在鏈下構造A對象，並基於address傳輸和固定校驗的方式，來規避這一問題。</p><pre><code>constructor(address a) public {<br>A _a = A(a);<br>require(_a._owner == address(this));<br>}</code></pre><p>當然，這樣也可能會使合約交互方式變得複雜。但其提供了有效縮短binary code長度的捷徑，需要在具體業務場景中做權衡取捨。</p><p></p><h1><strong>保證合約可升級</strong></h1><p><strong>經典的三層結構</strong></p><p>通過前文方式，我們盡最大努力保持合約設計的靈活性；翻箱倒櫃複用了輪子；也對發佈合約進行全方位、無死角的測試。除此之外，隨著業務需求變化，我們還將面臨一個問題：如何保證合約平滑、順利的升級？</p><p>作為一門高級編程語言，Solidity支持運行一些複雜控制和計算邏輯，也支持存儲智能合約運行後的狀態和業務數據。不同於WEB開發等場景的應用-數據庫分層架構，Solidity語言甚至沒有抽象出一層獨立的數據存儲結構，數據都被保存到了合約中。</p><p>但是，一旦合約需要升級，這種模式就會出現瓶頸。</p><p>在Solidity中，一旦合約部署發佈後，其代碼就無法被修改，只能通過發佈新合約去改動代碼。假如數據存儲在老合約，就會出現所謂的“孤兒數據”問題，新合約將丟失之前運行的歷史業務數據。</p><p>這種情況，開發者可以考慮將老合約數據遷移到新合約中，但此操作至少存在兩個問題：</p><ol><li>遷移數據會加重區塊鏈的負擔，產生資源浪費和消耗，甚至引入安全問題；</li><li>牽一髮而動全身，會引入額外的遷移數據邏輯，增加合約複雜度。</li></ol><p>一種更合理的方式是抽象一層獨立的合約存儲層。這個存儲層只提供合約讀寫的最基本方法，而不包含任何業務邏輯。</p><p>在這種模式中，存在三種合約角色：</p><ul><li>數據合約：在合約中保存數據，並提供數據的操作接口。</li><li>管理合約：設置控制權限，保證只有控制合約才有權限修改數據合約。</li><li>控制合約：真正需要對數據發起操作的合約。</li></ul><p>具體的代碼示例如下：</p><p>數據合約：</p><pre><code>contract FruitStore is BasicAuth {<br>address _latestVersion;<br>mapping(bytes =&gt; uint) _fruitStock;<br><br>modifier onlyLatestVersion {<br>require(msg.sender == _latestVersion);<br>_;<br>}<br><br>function upgradeVersion(address newVersion) public {<br>require(msg.sender == _owner);<br>_latestVersion = newVersion;<br>}<br><br>function setFruitStock(bytes fruit, uint stock) onlyLatestVersion external {<br>_fruitStock[fruit] = stock;<br>}<br>}</code></pre><p>管理合約：</p><pre><code>contract Admin is BasicAuth {<br>function upgradeContract(FruitStore fruitStore, address newController) isAuthorized external {<br>fruitStore.upgradeVersion(newController);<br>}<br>}</code></pre><p>控制合約：</p><pre><code>contract FruitStoreController is BasicAuth {<br>function upgradeStock(bytes fruit, uint stock) isAuthorized external {<br>fruitStore.setFruitStock(fruit, stock);<br>}<br>}</code></pre><p>一旦函數的控制邏輯需要變更，開發者只需修改FruitStoreController控制合約邏輯，部署一個新合約，然後使用管理合約Admin修改新的合約地址參數就可輕鬆完成合約升級。這種方法可消除合約升級中因業務控制邏輯改變而導致的數據遷移隱患。</p><p>但天下沒有免費的午餐，這種操作需要在可擴展性和複雜性之間需要做基本的權衡。首先，數據和邏輯的分離降低了運行性能。其次，進一步封裝增加了程序複雜度。最後，越是複雜的合約越會增加潛在攻擊面，簡單的合約比複雜的合約更安全。</p><p><strong>通用數據結構</strong></p><p>到目前為止，還存在一個問題，假如數據合約中的數據結構本身需要升級怎麼辦？</p><p>例如，在FruitStore中，原本只保存了庫存信息，現在由於水果銷售店生意發展壯大，一共開了十家分店，需要記錄每家分店、每種水果的庫存和售出信息。</p><p>在這種情況下，一種解決方案是採用外部關聯管理方式：創建一個新的ChainStore合約，在這個合約中創建一個mapping，建立分店名和FruitStore的關係。</p><p>此外，不同分店需要創建一個FruitStore的合約。為了記錄新增的售出信息等數據，我們還需要新建一個合約來管理。</p><p>假如在FruitStore中可預設一些不同類型的reserved字段，可幫助規避新建售出信息合約的開銷，仍然複用FruitStore合約。但這種方式在最開始會增加存儲開銷。</p><p>一種更好的思路是抽象一層更為底層和通用的存儲結構。</p><p>代碼如下：</p><pre><code>contract commonDB  is BasicAuth {<br>mapping(bytes =&gt; uint) _uintMapping;<br><br>function getUint(bytes key) external view returns(uint) {<br>return _uintMapping[key];<br>}<br><br>function setUint(bytes key, uint value) isAuthorized onlyLatestVersion external {<br>_uintMapping[key] = value;<br>}<br><br>}</code></pre><p>類似的，我們可加入所有數據類型變量，幫助commonDB應對和滿足不同的數據類型存儲需求。</p><p>相應的控制合約可修改如下：</p><pre><code>contract FruitStoreControllerV2 is BasicAuth {<br>function upgradeStock(bytes32 storeName, bytes32 fruit, uint stock)<br>isAuthorized external {<br>commonDB.setUint(sha256(storeName, fruit), stock);<br>uint result = commonDB.getUint(sha256(storeName, fruit));<br>}<br>}</code></pre><p>使用以上存儲的設計模式，可顯著提升合約數據存儲靈活性，保證合約可升級。</p><p>眾所周知，Solidity既不支持數據庫，使用代碼作為存儲entity，也無法提供更改schema的靈活性。但是，通過這種KV設計，可以使存儲本身獲得強大的可擴展性。</p><p>總之，<strong>沒有一個策略是完美的，優秀的架構師善於權衡</strong>。智能合約設計者需要充分了解各種方案的利弊，並基於實際情況選擇合適的設計方案。</p><p></p><h1><strong>總 結</strong></h1><p>文至於此，希望激起讀者對在Solidity世界生存與進化的興趣。“若有完美，必有謊言”，軟件開發的世界沒有銀彈。本文行文過程就是從最簡單的合約逐步完善和進化的過程。</p><p>在Solidity編程世界中，生存與進化都離不開三個關鍵詞：安全、可複用、高效。生命不息，進化不止。短短一篇小文難以窮盡所有生存進化之術，希望這三個關鍵詞能幫助大家在Solidity的世界裡翱翔暢遊，並不斷書寫輝煌的故事和傳說：）</p><p><strong>FISCO BCOS的代碼完全開源且免費</strong></p><p><strong>下載地址↓↓↓</strong></p><p>https://github.com/FISCO-BCOS/FISCO-BCOS</p><img alt="智能合約編寫之Solidity的編程攻略 | 火星號精選" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RzQ4k80HfJt15T><p>文章來源於FISCO BCOS開源社區 ，作者毛嘉宇</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>合約</a></li><li><a>編寫</a></li><li><a>Solidity</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c197b413.html alt="8 個幫助你編寫可維護、精簡化前端代碼的 CSS 策略" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/53ee00030d3ef9916cbc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c197b413.html title="8 個幫助你編寫可維護、精簡化前端代碼的 CSS 策略">8 個幫助你編寫可維護、精簡化前端代碼的 CSS 策略</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57e10498.html alt="2020年4月永續合約市場分析報告 | TokenInsight" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c69d335f1b94722996326792d1f80ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57e10498.html title="2020年4月永續合約市場分析報告 | TokenInsight">2020年4月永續合約市場分析報告 | TokenInsight</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18386e20.html alt=用AI文本生成器來編寫故事、詩歌、新聞文章！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ae781a540ea34338a19bdf453996a2f7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18386e20.html title=用AI文本生成器來編寫故事、詩歌、新聞文章！>用AI文本生成器來編寫故事、詩歌、新聞文章！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9149e7d.html alt=iOS開發——編寫一個完整的彙編 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a600049f300806c05c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9149e7d.html title=iOS開發——編寫一個完整的彙編>iOS開發——編寫一個完整的彙編</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a09fc571.html alt=彙編語言的指令格式是重中之重，不然你編寫出來就會偏離軌道！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2067778b1e584e7787c52e5c7fb79522 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a09fc571.html title=彙編語言的指令格式是重中之重，不然你編寫出來就會偏離軌道！>彙編語言的指令格式是重中之重，不然你編寫出來就會偏離軌道！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e56094c.html alt=使用彙編語言編寫一個Android應用程序（hello，word） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153959723768236050b4e62 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e56094c.html title=使用彙編語言編寫一個Android應用程序（hello，word）>使用彙編語言編寫一個Android應用程序（hello，word）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f17b99bf.html alt=python編寫的在線翻譯小程序（自動生成exe文件） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/06b8275b0bf74df99e1b64f76f5003d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f17b99bf.html title=python編寫的在線翻譯小程序（自動生成exe文件）>python編寫的在線翻譯小程序（自動生成exe文件）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cac445fc.html alt=可以編寫代碼的代碼：代碼生成的利與弊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9c09691126b94ac1b20ca9841fe0a7cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cac445fc.html title=可以編寫代碼的代碼：代碼生成的利與弊>可以編寫代碼的代碼：代碼生成的利與弊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4aca8e2.html alt=編寫測試用例的幾種方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7336aa5d97ae46b5a4fd215429afb09b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4aca8e2.html title=編寫測試用例的幾種方法>編寫測試用例的幾種方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/70cbe180.html alt=測試用例編寫總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9bca0606aaec433fbab651da939fd449 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/70cbe180.html title=測試用例編寫總結>測試用例編寫總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/08a5eb4e.html alt=編寫測試用例的七種方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533605177476c21de81e12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/08a5eb4e.html title=編寫測試用例的七種方法>編寫測試用例的七種方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ac48bd0.html alt="如何編寫 VS Code 擴展 | Linux 中國" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/699af8d9882b4ec69cdb3ca651b1871b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ac48bd0.html title="如何編寫 VS Code 擴展 | Linux 中國">如何編寫 VS Code 擴展 | Linux 中國</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0aae99bd.html alt=Typora-編寫博客格式化文檔的最佳軟件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f1be75f3a5964d4d9f2b1dce49ef6dfd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0aae99bd.html title=Typora-編寫博客格式化文檔的最佳軟件>Typora-編寫博客格式化文檔的最佳軟件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6f2d0e1.html alt=進階Python，從編寫Python函數開始 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/51b384b607d04e45b26f4204be770617 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6f2d0e1.html title=進階Python，從編寫Python函數開始>進階Python，從編寫Python函數開始</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9fdb4e7.html alt=﻿﻿一個定時器編寫的瞬時接通、延時斷開控制程序，敬請拿走！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15286402134541bb80717dd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9fdb4e7.html title=﻿﻿一個定時器編寫的瞬時接通、延時斷開控制程序，敬請拿走！>﻿﻿一個定時器編寫的瞬時接通、延時斷開控制程序，敬請拿走！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>