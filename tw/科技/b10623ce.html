<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你不得不知道的HashMap面試連環炮 | 极客快訊</title><meta property="og:title" content="你不得不知道的HashMap面試連環炮 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b10623ce.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b10623ce.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b10623ce.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b10623ce.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b10623ce.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b10623ce.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b10623ce.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b10623ce.html><meta property="article:published_time" content="2020-11-14T21:07:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:42+08:00"><meta name=Keywords content><meta name=description content="你不得不知道的HashMap面試連環炮"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b10623ce.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你不得不知道的HashMap面試連環炮</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>主題 HashMap 鏈表</p><ol><li>為什麼用HashMap？</li><li>簡述一下Map類繼承關係？</li><li>解決哈希衝突的方法？</li><li>為什麼HashMap線程不安全？</li><li>resize機制？</li><li>HashMap的工作原理是什麼？</li><li>有什麼方法可以減少碰撞？</li><li>HashMap中hash函數怎麼是是實現的?</li><li>拉鍊法導致的鏈表過深問題為什麼不用二叉查找樹代替，而選擇紅黑樹？為什麼不一直使用紅黑樹？</li><li>說說你對紅黑樹的見解？</li><li>解決hash 碰撞還有那些辦法？</li><li>如果HashMap的大小超過了負載因子(load factor)定義的容量，怎麼辦？</li><li>重新調整HashMap大小存在什麼問題嗎？</li><li>HashTable</li><li>HashMap ，HashTable 區別</li><li>ConcurrentHashMap 原理</li><li><strong>我們可以使用CocurrentHashMap來代替Hashtable嗎？</strong></li><li>現在是晚上11點了，學校屠豬館的自習室因為太晚要關閉了，勤奮且疲憊的小魯班也從屠豬館出來了，正準備回宿舍洗洗睡，由於自習室位置比較偏僻所以是接收不到手機網絡信號的，因此小魯班從兜裡掏出手機的時候，信息可真是炸了呀，小魯班心想，微信群平時都沒什麼人聊天，今晚肯定是發生了什麼大事，仔細一看，才發現原來是小魯班的室友達摩（光頭）拿到了阿里巴巴JAVA開發實習生的offer，此時小魯班真替他室友感到高興的同時，心裡也難免會產生一絲絲的失落感，那是因為自己投了很多份簡歷，別說拿不拿得到offer，就連給面試邀的公司也都寥寥無幾，小魯班這會可真是受到了一萬點真實暴擊，不過小魯班還是很樂觀的，很快調整了心態，帶上耳機，慢慢的走回了宿舍，正打算準備向他那神室友達摩取取經。</li><li>片刻後~</li></ol><ul><li>小魯班：666，聽說你拿到了阿里的offer，能透露一下面試內容和技巧嗎</li><li>達摩：嘿嘿嘿，沒問題鴨，叫聲爸爸我就告訴你</li><li>小魯班：baba（表面笑嘻嘻，心裡MMP）</li><li>達摩：JAVA的基礎知識：數據結構（Map,List,Set等）,設計模式，算法，線程相關，IO/NIO，序列化等等。其次是高級特徵：反射機制，併發與鎖，JVM（GC策略，類加載機制，內存模型）等等</li><li>小魯班：問這麼多內容，那豈不是一個人都面試很久嗎？</li><li>達摩：不是的，面試官一般都會用連環炮的方式提問的。</li><li>小魯班：你說的連環炮是什麼意思鴨？</li><li>達摩：那我舉個例子</li><li>就比如問你HashMap是不是有序的？</li><li>你回答不是有序的。那面試官就會可能繼續問你，有沒有有序的Map實現類呢？</li><li>你如果這個時候說不知道的話，那這塊問題就到此結束了。</li><li>如果你說有TreeMap和LinkedHashMap。那麼面試官接下來就可能會問你，TreeMap和LinkedHashMap是如何保證它的順序的？如果你回答不上來，那麼到此為止。如果你說TreeMap是通過實現SortMap接口，能夠把它保存的鍵值對根據key排序，基於紅黑樹，從而保證TreeMap中所有鍵值對處於有序狀態。LinkedHashMap則是通過插入排序（就是你put的時候的順序是什麼，取出來的時候就是什麼樣子）和訪問排序（改變排序把訪問過的放到底部）讓鍵值有序。</li><li>那麼面試官還會繼續問你，你覺得它們兩個哪個的有序實現比較好？</li><li>如果你依然可以回答的話，那麼面試官會繼續問你，你覺得還有沒有比它更好或者更高效的實現方式。。無窮無盡深入，直到你回答不出來或者面試官認為問題到底了</li><li>小魯班捏了一把汗，我去。。。這是魔鬼吧，那我們來試試唄（因為小魯班剛剛在自習室才看了這章的知識，想趁機裝一波逼，畢竟剛剛叫了聲爸爸~~）於是達摩and小魯班就開始了對決：</li></ul><p>1.為什麼用HashMap？</p><p>HashMap是一個散列桶（數組和鏈表），它存儲的內容是鍵值對(key-value)映射</p><p>HashMap採用了數組和鏈表的數據結構，能在查詢和修改方便繼承了數組的線性查找和鏈表的尋址修改</p><p>HashMap是非synchronized，所以HashMap很快</p><p>HashMap可以接受null鍵和值，而Hashtable則不能（原因就是equlas()方法需要對象，因為HashMap是後出的API經過處理才可以）</p><p>2.簡述一下Map類繼承關係</p><div class=pgc-img><img alt=你不得不知道的HashMap面試連環炮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e><p class=pgc-img-caption></p></div><p>上面展示了java中Map的繼承圖，Map是一個接口，我們常用的實現類有HashMap、LinkedHashMap、TreeMap，HashTable。HashMap根據key的hashCode值來保存value，需要注意的是，HashMap不保證遍歷的順序和插入的順序是一致的。HashMap允許有一條記錄的key為null，但是對值是否為null不做要求。HashTable類是線程安全的，它使用synchronize來做線程安全，全局只有一把鎖，在線程競爭比較激烈的情況下hashtable的效率是比較低下的。因為當一個線程訪問hashtable的同步方法時，其他線程再次嘗試訪問的時候，會進入阻塞或者輪詢狀態，比如當線程1使用put進行元素添加的時候，線程2不但不能使用put來添加元素，而且不能使用get獲取元素。所以，競爭會越來越激烈。相比之下，ConcurrentHashMap使用了分段鎖技術來提高了併發度，不在同一段的數據互相不影響，多個線程對多個不同的段的操作是不會相互影響的。每個段使用一把鎖。所以在需要線程安全的業務場景下，推薦使用ConcurrentHashMap，而HashTable不建議在新的代碼中使用，如果需要線程安全，則使用ConcurrentHashMap，否則使用HashMap就足夠了。</p><p>LinkedHashMap屬於HashMap的子類，與HashMap的區別在於LinkedHashMap保存了記錄插入的順序。TreeMap實現了SortedMap接口，TreeMap有能力對插入的記錄根據key排序，默認按照升序排序，也可以自定義比較強，在使用TreeMap的時候，key應當實現Comparable。</p><p>3. HashMap的工作原理是什麼？</p><p>java7和java8在實現HashMap上有所區別，當然java8的效率要更好一些，主要是java8的HashMap在java7的基礎上增加了紅黑樹這種數據結構，使得在桶裡面查找數據的複雜度從O(n)降到O(logn)，當然還有一些其他的優化，比如resize的優化等。</p><p>HashMap是基於hashing的原理，我們使用put(key, value)存儲對象到HashMap中，使用get(key)從HashMap中獲取對象。當我們給put()方法傳遞鍵和值時，我們先對鍵調用hashCode()方法，計算並返回的hashCode是用於找到Map數組的bucket位置來儲存Node 對象。這裡關鍵點在於指出，HashMap是在bucket中儲存鍵對象和值對象，作為Map.Node 。</p><p>Node&lt;K,V>就是實際保存我們的key-value對的數據結構，下面是這個數據結構的主要內容：</p><p>final int hash;</p><p>final K key;</p><p>V value;</p><p>Node&lt;K,V> next;</p><p>以下是HashMap初始化 ，簡單模擬數據結構</p><p>以下是具體的put過程（JDK1.8版）</p><div class=pgc-img><img alt=你不得不知道的HashMap面試連環炮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/598430fa9a2b4bc5bb3155c87dfce3db><p class=pgc-img-caption></p></div><ul><li>對Key求Hash值，然後再計算下標</li><li>如果沒有碰撞，直接放入桶中（碰撞的意思是計算得到的Hash值相同，需要放到同一個bucket中）</li><li>如果碰撞了，以鏈表的方式鏈接到後面</li><li>如果鏈表長度超過閥值( TREEIFY THRESHOLD==8)，就把鏈表轉成紅黑樹，鏈表長度低於6，就把紅黑樹轉回鏈表</li></ul><div class=pgc-img><img alt=你不得不知道的HashMap面試連環炮 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4cf7b4cddd9c4f53976464f07c9856c5><p class=pgc-img-caption></p></div><ul><li><br></li><li>如果節點已經存在就替換舊值</li><li>如果桶滿了(容量16*加載因子0.75)，就需要 resize（擴容2倍後重排），直到設定的最大值之後就無法再resize了</li><li>以下是具體get過程(考慮特殊情況如果兩個鍵的hashcode相同，你如何獲取值對象？)</li><li>當我們調用get()方法，HashMap會使用鍵對象的hashcode找到bucket位置，找到bucket位置之後，會調用keys.equals()方法去找到鏈表中正確的節點，最終找到要找的值對象。</li></ul><p>4.解決哈希衝突的方法？</p><ul><li>有開放地址方法</li><li>以及鏈地址方法</li></ul><p>5.resize機制</p><p>HashMap的擴容機制就是重新申請一個容量是當前的2倍的桶數組，然後將原先的記錄逐個重新映射到新的桶裡面，然後將原先的桶逐個置為null使得引用失效。後面會講到，HashMap之所以線程不安全，就是resize這裡出的問題。</p><p>6.為什麼HashMap線程不安全</p><p>上面說到，HashMap會進行resize操作，在resize操作的時候會造成線程不安全。下面將舉兩個可能出現線程不安全的地方。</p><ul><li>put的時候導致的多線程數據不一致。</li><li>這個問題比較好想象，比如有兩個線程A和B，首先A希望插入一個key-value對到HashMap中，首先計算記錄所要落到的桶的索引座標，然後獲取到該桶裡面的鏈表頭結點，此時線程A的時間片用完了，而此時線程B被調度得以執行，和線程A一樣執行，只不過線程B成功將記錄插到了桶裡面，假設線程A插入的記錄計算出來的桶索引和線程B要插入的記錄計算出來的桶索引是一樣的，那麼當線程B成功插入之後，線程A再次被調度運行時，它依然持有過期的鏈表頭但是它對此一無所知，以至於它認為它應該這樣做，如此一來就覆蓋了線程B插入的記錄，這樣線程B插入的記錄就憑空消失了，造成了數據不一致的行為。</li><li>另外一個比較明顯的線程不安全的問題是HashMap的get操作可能因為resize而引起死循環（cpu100%），具體分析如下：</li></ul><p>下面的代碼是resize的核心內容：</p><p>void transfer(Entry[] newTable, boolean rehash) {</p><p>int newCapacity = newTable.length;</p><p>for (Entry&lt;K,V> e : table) {</p><p>while(null != e) {</p><p>Entry&lt;K,V> next = e.next;</p><p>if (rehash) {</p><p>e.hash = null == e.key ? 0 : hash(e.key);</p><p>}</p><p>int i = indexFor(e.hash, newCapacity);</p><p>e.next = newTable[i];</p><p>newTable[i] = e;</p><p>e = next;</p><p>}</p><p>}</p><p>}</p><p>這個方法的功能是將原來的記錄重新計算在新桶的位置，然後遷移過去。</p><div class=pgc-img><img alt=你不得不知道的HashMap面試連環炮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e114642f5685463ca68f2460d9fe2eb2><p class=pgc-img-caption></p></div><p>我們假設有兩個線程同時需要執行resize操作，我們原來的桶數量為2，記錄數為3，需要resize桶到4，原來的記錄分別為：[3,A],[7,B],[5,C]，在原來的map裡面，我們發現這三個entry都落到了第二個桶裡面。</p><p>假設線程thread1執行到了transfer方法的Entry next = e.next這一句，然後時間片用完了，此時的e = [3,A], next = [7,B]。線程thread2被調度執行並且順利完成了resize操作，需要注意的是，此時的[7,B]的next為[3,A]。此時線程thread1重新被調度運行，此時的thread1持有的引用是已經被thread2 resize之後的結果。線程thread1首先將[3,A]遷移到新的數組上，然後再處理[7,B]，而[7,B]被鏈接到了[3,A]的後面，處理完[7,B]之後，就需要處理[7,B]的next了啊，而通過thread2的resize之後，[7,B]的next變為了[3,A]，此時，[3,A]和[7,B]形成了環形鏈表，在get的時候，如果get的key的桶索引和[3,A]和[7,B]一樣，那麼就會陷入死循環。</p><p>如果在取鏈表的時候從頭開始取（現在是從尾部開始取）的話，則可以保證節點之間的順序，那樣就不存在這樣的問題了。</p><p>綜合上面兩點，可以說明HashMap是線程不安全的。</p><p>7. 有什麼方法可以減少碰撞？</p><ul><li>擾動函數可以減少碰撞，原理是如果兩個不相等的對象返回不同的hashcode的話，那麼碰撞的機率就會小些，這就意味著存鏈表結構減小，這樣取值的話就不會頻繁調用equal方法，這樣就能提高HashMap的性能。（擾動即Hash方法內部的算法實現，目的是讓不同對象返回不同hashcode。）</li><li>使用不可變的、聲明作final的對象，並且採用合適的equals()和hashCode()方法的話，將會減少碰撞的發生。不可變性使得能夠緩存不同鍵的hashcode，這將提高整個獲取對象的速度，使用String，Interger這樣的wrapper類作為鍵是非常好的選擇。為什麼String, Interger這樣的wrapper類適合作為鍵？因為String是final的，而且已經重寫了equals()和hashCode()方法了。不可變性是必要的，因為為了要計算hashCode()，就要防止鍵值改變，如果鍵值在放入時和獲取時返回不同的hashcode的話，那麼就不能從HashMap中找到你想要的對象。</li></ul><p>8. HashMap中hash函數怎麼是是實現的?</p><ul><li>我們可以看到在hashmap中要找到某個元素，需要根據key的hash值來求得對應數組中的位置。如何計算這個位置就是hash算法。前面說過hashmap的數據結構是數組和鏈表的結合，所以我們當然希望這個hashmap裡面的元素位置儘量的分佈均勻些，儘量使得每個位置上的元素數量只有一個，那麼當我們用hash算法求得這個位置的時候，馬上就可以知道對應位置的元素就是我們要的，而不用再去遍歷鏈表。 所以我們首先想到的就是把hashcode對數組長度取模運算，這樣一來，元素的分佈相對來說是比較均勻的。但是，“模”運算的消耗還是比較大的，能不能找一種更快速，消耗更小的方式，我們來看看JDK1.8的源碼是怎麼做的（被樓主修飾了一下）</li></ul><p><strong>簡單來說就是</strong></p><ol><li>高16bt不變，低16bit和高16bit做了一個異或(得到的HASHCODE轉化為32位的二進制，前16位和後16位低16bit和高16bit做了一個異或)</li><li>(n·1)&hash=->得到下標</li><li>拉鍊法導致的鏈表過深問題為什麼不用二叉查找樹代替，而選擇紅黑樹？為什麼不一直使用紅黑樹？</li><li>之所以選擇紅黑樹是為了解決二叉查找樹的缺陷，二叉查找樹在特殊情況下會變成一條線性結構（這就跟原來使用鏈表結構一樣了，造成很深的問題），遍歷查找會非常慢。而紅黑樹在插入新數據後可能需要通過左旋，右旋、變色這些操作來保持平衡，引入紅黑樹就是為了查找數據快，解決鏈表查詢深度的問題，我們知道紅黑樹屬於平衡二叉樹，但是為了保持“平衡”是需要付出代價的，但是該代價所損耗的資源要比遍歷線性鏈表要少，所以當長度大於8的時候，會使用紅黑樹，如果鏈表長度很短的話，根本不需要引入紅黑樹，引入反而會慢。</li></ol><p>9. 說說你對紅黑樹的見解？</p><ul><li>每個節點非紅即黑</li><li>根節點總是黑色的</li><li>如果節點是紅色的，則它的子節點必須是黑色的（反之不一定）</li><li>每個葉子節點都是黑色的空節點（NIL節點）</li><li>從根節點到葉節點或空子節點的每條路徑，必須包含相同數目的黑色節點（即相同的黑色高度）</li></ul><p>10. 解決hash 碰撞還有那些辦法？</p><p>開放定址法。</p><p>當衝突發生時，使用某種探查技術在散列表中形成一個探查(測)序列。沿此序列逐個單元地查找，直到找到給定的地址。</p><p>按照形成探查序列的方法不同，可將開放定址法區分為線性探查法、二次探查法、雙重散列法等。</p><p><strong>下面給一個線性探查法的例子</strong></p><p>問題：已知一組關鍵字為(26，36，41，38，44，15，68，12，06，51)，用除餘法構造散列函數，用線性探查法解決衝突構造這組關鍵字的散列表。</p><p>前5個關鍵字插入時，其相應的地址均為開放地址，故將它們直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。</p><p>當插入第6個關鍵字15時，其散列地址2(即h(15)=15％13=2)已被關鍵字41(15和41互為同義詞)佔用。故探查h1=(2+1)％13=3，此地址開放，所以將15放入T[3]中。</p><p>當插入第7個關鍵字68時，其散列地址3已被非同義詞15先佔用，故將其插入到T[4]中。</p><p>當插入第8個關鍵字12時，散列地址12已被同義詞38佔用，故探查hl=(12+1)％13=0，而T[0]亦被26佔用，再探查h2=(12+2)％13=1，此地址開放，可將12插入其中。</p><p>類似地，第9個關鍵字06直接插入T[6]中；而最後一個關鍵字51插人時，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。</p><p>11. 如果HashMap的大小超過了負載因子(load factor)定義的容量，怎麼辦？</p><p>默認的負載因子大小為0.75，也就是說，當一個map填滿了75%的bucket時候，和其它集合類(如ArrayList等)一樣，將會創建原來HashMap大小的兩倍的bucket數組，來重新調整map的大小，並將原來的對象放入新的bucket數組中。這個過程叫作rehashing，因為它調用hash方法找到新的bucket位置。這個值只可能在兩個地方，一個是原下標的位置，另一種是在下標為&lt;原下標+原容量>的位置</p><p>12. 重新調整HashMap大小存在什麼問題嗎？</p><p>當重新調整HashMap大小的時候，確實存在條件競爭，因為如果兩個線程都發現HashMap需要重新調整大小了，它們會同時試著調整大小。在調整大小的過程中，存儲在鏈表中的元素的次序會反過來，因為移動到新的bucket位置的時候，HashMap並不會將元素放在鏈表的尾部，而是放在頭部，這是為了避免尾部遍歷(tail traversing)。如果條件競爭發生了，那麼就死循環了。(多線程的環境下不使用HashMap）</p><p>HashMap的容量是有限的。當經過多次元素插入，使得HashMap達到一定飽和度時，Key映射位置發生衝突的機率會逐漸提高。這時候，HashMap需要擴展它的長度，也就是進行Resize。</p><ol><li>擴容：創建一個新的Entry空數組，長度是原數組的2倍。</li><li>ReHash：遍歷原Entry數組，把所有的Entry重新Hash到新數組。</li></ol><ul><li>達摩：哎呦，小老弟不錯嘛~~意料之外呀</li><li>小魯班：嘿嘿，優秀吧，中場休息一波，我先喝口水</li><li>達摩：不僅僅是這些哦，面試官還會問你相關的集合類對比，比如：</li></ul><p>13. HashTable</p><p>數組 + 鏈表方式存儲</p><p>默認容量： 11(質數 為宜)</p><p>put:</p><ul><li>索引計算 : （key.hashCode() & 0x7FFFFFFF）% table.length</li><li>若在鏈表中找到了，則替換舊值，若未找到則繼續</li><li>當總元素個數超過容量*加載因子時，擴容為原來 2 倍並重新散列。</li><li>將新元素加到鏈表頭部</li><li>對修改 Hashtable 內部共享數據的方法添加了 synchronized，保證線程安全。</li></ul><p>14. HashMap ，HashTable 區別</p><p>默認容量不同。擴容不同</p><p>線程安全性，HashTable 安全</p><p>效率不同 HashTable 要慢因為加鎖</p><p>15. ConcurrentHashMap 原理</p><p>1、最大特點是引入了 CAS（藉助 Unsafe 來實現【native code】）</p><p>CAS有3個操作數：</p><ul><li>內存值V</li><li>舊的預期值A</li><li>要修改的新值B。</li></ul><p>當且僅當預期值A和內存值V相同時，將內存值V修改為B，否則什麼都不做。</p><p>Unsafe 藉助 CPU 指令 cmpxchg 來實現</p><p>使用實例：</p><ul><li>對 sizeCtl 的控制都是用 CAS 來實現的</li><li>sizeCtl ：默認為0，用來控制 table 的初始化和擴容操作。</li></ul><p>-1 代表table正在初始化</p><p>N 表示有 -N-1 個線程正在進行擴容操作</p><p>如果table未初始化，表示table需要初始化的大小。</p><p>如果table初始化完成，表示table的容量，默認是table大小的0.75倍，居然用這個公式算0.75（n - (n >>> 2)）。</p><p>CAS 會出現的問題：ABA</p><p>對變量增加一個版本號，每次修改，版本號加 1，比較的時候比較版本號。</p><p>16. 我們可以使用CocurrentHashMap來代替Hashtable嗎？</p><p>我們知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因為它僅僅根據同步級別對map的一部分進行上鎖。ConcurrentHashMap當然可以代替HashTable，但是HashTable提供更強的線程安全性。它們都可以用於多線程的環境，但是當Hashtable的大小增加到一定的時候，性能會急劇下降，因為迭代時需要被鎖定很長的時間。因為ConcurrentHashMap引入了分割(segmentation)，不論它變得多麼大，僅僅需要鎖定map的某個部分，而其它的線程不需要等到迭代完成才能訪問map。簡而言之，在迭代的過程中，ConcurrentHashMap僅僅鎖定map的某個部分，而Hashtable則會鎖定整個map。</p><ul><li>此時躺著床上的張飛哄了一聲：睡覺了睡覺了~</li><li>見此不太妙：小魯班立馬回到床上（泉水），把被子蓋過頭，心裡有一絲絲愉悅感，不對。好像還沒洗澡。。。</li><li><strong>by the way</strong></li></ul><p>CocurrentHashMap在JAVA8中存在一個bug，會進入死循環，原因是遞歸創建ConcurrentHashMap 對象，但是在1.9已經修復了,場景重現如下：</p><div class=pgc-img><img alt=你不得不知道的HashMap面試連環炮 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b599d64852246518a521f80cda60207><p class=pgc-img-caption></p></div><h1><strong>最後</strong></h1><p><strong>關注我+私信【資料】，免費獲取最新整理的資料。</strong></p><p><strong>部分截圖如下：</strong></p><div class=pgc-img><img alt=你不得不知道的HashMap面試連環炮 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/33029626f00543b28ede7d3282b798d8><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>HashMap</a></li><li><a>面試</a></li><li><a>連環炮</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html alt=HashMap面試專題：常問六題深入解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/75bf5de0-37fd-469c-b6b3-8067c551568a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html title=HashMap面試專題：常問六題深入解析>HashMap面試專題：常問六題深入解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html alt=一個HashMap能跟面試官扯上半個小時 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3c09bf1ad1b54adaab3db4be30c10c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html title=一個HashMap能跟面試官扯上半個小時>一個HashMap能跟面試官扯上半個小時</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html alt=面試必備：HashMap源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html title=面試必備：HashMap源碼解析>面試必備：HashMap源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html alt=HashMap？面試？我是誰？我在哪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8aa437a2fb3143e7a345a46a36d2c81e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html title=HashMap？面試？我是誰？我在哪>HashMap？面試？我是誰？我在哪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html alt=「最完整系列」JAVA-容器篇-HashMap面試最詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/71d7c60ccb9e4e57acda3ded903a1fd5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html title=「最完整系列」JAVA-容器篇-HashMap面試最詳解>「最完整系列」JAVA-容器篇-HashMap面試最詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html alt=面試必問的HashMap，你真的瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/19a8d23522b640b4a8d8a927514eca33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html title=面試必問的HashMap，你真的瞭解嗎？>面試必問的HashMap，你真的瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>