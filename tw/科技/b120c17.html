<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Solidity位運算：與、或、非、異或、移位 | 极客快訊</title><meta property="og:title" content="Solidity位運算：與、或、非、異或、移位 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/2e0e43e516f54a7cb3c200fc7cc664e5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b120c17.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b120c17.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b120c17.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b120c17.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b120c17.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b120c17.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b120c17.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b120c17.html><meta property="article:published_time" content="2020-10-29T21:00:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:27+08:00"><meta name=Keywords content><meta name=description content="Solidity位運算：與、或、非、異或、移位"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b120c17.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Solidity位運算：與、或、非、異或、移位</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>Solidity位操作運算有助於縮減以太坊交易的成本。本文介紹以太坊智能合約開發語言 Solidity中的位操作運算符，以及如何使用這些Solidity位操作符對合約數據執 行位操作運算，例如與、或、非、異或等，同時也介紹如何實現Soldity不支持 的取反、移位等操作。</p><p class=ql-align-justify><strong>1、Solidity位操作概述</strong></p><p class=ql-align-justify>以太坊是一臺世界計算機， 雖然可能是最昂貴的那臺。由於存儲是最消耗gas的操作，因此時不時地需要精打細算， 進行一些位操作，就像彙編開發者在芯片固件編程時所做的一樣。這可以讓你對數據有 更多的控制並最終縮減交易成本。</p><p class=ql-align-justify>以太坊智能合約開發語言Solidity支持基本的位操作運算，雖然目前還不支持左/右 位移。幸運的是有等價的算數運<span>算。</span></p><p class=ql-align-justify>所有的位操作都是逐位執行的，就和你比較兩個不同的數組成員一樣，都會 按順序逐位操作。注意：在位操作中0和1,分別對應false和true。</p><p class=ql-align-justify>出於簡化考慮，我將使用bytes1類型（和byte一樣），不過更長的數據類型也是 同樣的原理。在下面的例子中我們都是用相同的兩個變量a和b：</p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2e0e43e516f54a7cb3c200fc7cc664e5><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>在Solidity中，我們使用16進製表示的值來初始化這兩個變量：</p><pre class=ql-align-right>12bytes1 a = 0xb5; // [10110101]bytes1 b = 0x56; // [01010110]</pre><p class=ql-align-justify><strong>2、與運算/AND</strong></p><p class=ql-align-justify>兩個變量中都是1的位，其與計算/AND結果位才是1，否則都是0：</p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/720949ec447648719549dac034d938dc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>上圖中黃色部分表示計算結果，可以看到只有當兩個輸入變量a和b的對應位 都是1時，結果的響應位才是1。</p><p class=ql-align-justify>在Solidity中，與操作符是&：</p><pre class=ql-align-right>1a &amp; b; // 結果: 0x14 [00010100]</pre><p class=ql-align-justify><strong>3、或運算/OR</strong></p><p class=ql-align-justify>在計算或操作結果的某一位時，只要任何一個輸入變量的對應位是1， 那麼結果都是1：</p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/992876f0d4004bd78ace283ad3bee56c><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>在Solidity中，或操作符是|：</p><pre class=ql-align-right>1a | b; // 結果: 0xf7 [11110111]</pre><p class=ql-align-justify><strong>4、異或運算/XOR</strong></p><p class=ql-align-justify>在計算異或運算結果的某一位時，只有當兩個輸入變量的對應位不一致 時，結果才是1：</p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ffcca8ba0214901a8e7cb31990e3e4e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>在Solidity中，異或操作符時^：</p><pre class=ql-align-right>1a ^ b; // 結果: 0xe3 [11100011]</pre><p class=ql-align-justify>異或運算有趣的一點是，你把結果和任意一個輸入變量再做異或運算， 就可以得到另一個輸入變量：</p><pre class=ql-align-right>10xe3 ^ a; // 結果: 0x56 == b [01010110]</pre><p class=ql-align-justify><strong>5、非運算/NEG</strong></p><p class=ql-align-justify>非運算是單目運算，只需要一個輸入變量，它就是取反，原來是1結果 就是0，原來是0結果就是1：</p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8665ed03a5f84d83b3b7daf53f68004e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>Solidity本身並不支持非運算，不過幸運的是你可以將變量與全1值 異或，就得到同樣的結果：</p><pre class=ql-align-right>1a ^ 0xff; // Result: 0x4a [01001010]</pre><p class=ql-align-justify><strong>6、移位運算/SHIFT</strong></p><p class=ql-align-justify>位移運算指的是向左或向右移動輸入變量的位。</p><p class=ql-align-justify>讓我們先用十進制數來舉個例子。例如對於下面的數值：</p><pre class=ql-align-right>100001230</pre><p class=ql-align-justify>向左位移3位就得到：</p><pre class=ql-align-right>101230000</pre><p class=ql-align-justify>換句話說，向左移動3位其實就是將原來的數乘以10的3次方。</p><p class=ql-align-justify>同樣，如果我們繼續向右移動4位，結果就和將輸入變量除以10的4次方一樣：</p><pre class=ql-align-right>100000123</pre><p class=ql-align-justify>上面的原理對於二進制移位運算也是適用的，因此當我們向左 移N位時，就等價於乘以2的N次方；向右移M位時，就等價於除以2 的M次方。</p><p class=ql-align-justify>由於Solidity目前不支持移位運算，因此我們需要藉助於算數運算 來實現同樣的效果。</p><p class=ql-align-justify><strong>6.1 左移位</strong></p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/feeafb259f464397a4f14b9e770a3a8d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>示例代碼如下：</p><pre class=ql-align-right>1234var n = 3; var aInt = uint8(a); // Converting bytes1 into 8 bit integervar shifted = aInt * 2 ** n;bytes1(shifted); // Back to bytes. Result: 0xa8 [10101000]</pre><p class=ql-align-justify><strong>6.2 右移位</strong></p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b82498812cb74b7d932a8b003d698fe1><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>示例代碼如下：</p><pre class=ql-align-right>1234var n = 2; var aInt = uint8(a); // Converting bytes1 into 8 bit integervar shifted = aInt / 2 ** n;bytes1(shifted); // Back to bytes. Result: 0x2d [00101101]</pre><p class=ql-align-justify><strong>7、提取前N位</strong></p><p class=ql-align-justify>我們可以使用與操作來提取變量的前N位，方法就是創建一個掩碼變量， 其前N位都是1：</p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0e5fc762f2bc47ffa5d36605d9eeb3d7><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>示例代碼如下：</p><pre class=ql-align-right>1234var n = 5;var nOnes = bytes1(2 ** n - 1); // Creates 5 1svar mask = shiftLeft(nOnes, 8 - n); // Shift left by 3 positionsa &amp; mask; // Result: 0xb0 [10110000]</pre><p class=ql-align-justify><strong>8、提取後N位</strong></p><p class=ql-align-justify>利用對2取模計算就可以提取變量的後N位，例如：</p><pre class=ql-align-right>123var n = 5;var lastBits = uint8(a) % 2 ** n;bytes1(lastBits); // Result: 0x15 [00010101]</pre><p class=ql-align-justify><strong>9、數據壓縮</strong></p><p class=ql-align-justify>有了上面的基礎，我們就可以使用更少的存儲空間來減少交易成本。 例如，假設有兩個變量其實都是隻利用了4位，那麼我們可以將其 壓縮到一個變量裡：</p><div class=pgc-img><img alt=Solidity位運算：與、或、非、異或、移位 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/05d0f2f71ec9419eaba8de58dfdfab8e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>示例代碼如下：</p><pre class=ql-align-right>123bytes1 c = 0x0d;bytes1 d = 0x07;var result = shiftLeft(c, 4) | d; // 0xd7 [11010111]</pre><p class=ql-align-justify><strong>完整源代碼</strong></p><p class=ql-align-justify>下面是本文內容的完整源代碼：</p><pre class=ql-align-right>12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061contract BitsAndPieces {  function and(bytes1 a, bytes1 b) returns (bytes1) { return a &amp; b; }  function or(bytes1 a, bytes1 b) returns (bytes1) { return a | b; }  function xor(bytes1 a, bytes1 b) returns (bytes1) { return a ^ b; }  function negate(bytes1 a) returns (bytes1) { return a ^ allOnes(); }  function shiftLeft(bytes1 a, uint8 n) returns (bytes1) { var shifted = uint8(a) * 2 ** n; return bytes1(shifted); }  function shiftRight(bytes1 a, uint8 n) returns (bytes1) { var shifted = uint8(a) / 2 ** n; return bytes1(shifted); }  function getFirstN(bytes1 a, uint8 n) returns (bytes1) { var nOnes = bytes1(2 ** n - 1); var mask = shiftLeft(nOnes, 8 - n); // Total 8 bits return a &amp; mask; }   function getLastN(bytes1 a, uint8 n) returns (bytes1) { var lastN = uint8(a) % 2 ** n; return bytes1(lastN); }   // Sets all bits to 1 function allOnes() returns (bytes1) { return bytes1(-1); // 0 - 1, since data type is unsigned, this results in all 1s. }  // Get bit value at position function getBit(bytes1 a, uint8 n) returns (bool) { return a &amp; shiftLeft(0x01, n) != 0; }  // Set bit value at position function setBit(bytes1 a, uint8 n) returns (bytes1) { return a | shiftLeft(0x01, n); }  // Set the bit into state "false" function clearBit(bytes1 a, uint8 n) returns (bytes1) { bytes1 mask = negate(shiftLeft(0x01, n)); return a &amp; mask; } }</pre><p class=ql-align-center>原文：Solidity位操作 - 匯智網</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Solidity</a></li><li><a>位運算</a></li><li><a>移位</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce238bab.html alt=代碼：C語言中的移位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/37ce0000d799b4e516fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce238bab.html title=代碼：C語言中的移位>代碼：C語言中的移位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c56be47.html alt=關於馬桶移位，你瞭解多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ef8080b701854361a4853e1205285648 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c56be47.html title=關於馬桶移位，你瞭解多少？>關於馬桶移位，你瞭解多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4db18fe3.html alt=馬桶移位怎麼做？無下沉衛生間就不能改下水嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2a3771687e43406bbf902285f9547091 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4db18fe3.html title=馬桶移位怎麼做？無下沉衛生間就不能改下水嗎？>馬桶移位怎麼做？無下沉衛生間就不能改下水嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4bd67d3b.html alt=馬桶移位的5種方法，你家用過哪種？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/ea5405c8-8b2b-408a-a100-cd2b9a9258a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4bd67d3b.html title=馬桶移位的5種方法，你家用過哪種？>馬桶移位的5種方法，你家用過哪種？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b0618900.html alt="智能合約編寫之Solidity的編程攻略 | 火星號精選" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RivR6n1AU5yy8h style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b0618900.html title="智能合約編寫之Solidity的編程攻略 | 火星號精選">智能合約編寫之Solidity的編程攻略 | 火星號精選</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/33250c8.html alt=C語言中的位運算與各運算符的用途 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66b5000092354da02874 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/33250c8.html title=C語言中的位運算與各運算符的用途>C語言中的位運算與各運算符的用途</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d4f291.html alt=位運算小結（按位與、按位或、按位異或、取反、左移、右移） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d4f291.html title=位運算小結（按位與、按位或、按位異或、取反、左移、右移）>位運算小結（按位與、按位或、按位異或、取反、左移、右移）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1913116.html alt=物聯網學習：算術移位和邏輯移位實現分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9f80b0cebaab44f0964993de43cbd494 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1913116.html title=物聯網學習：算術移位和邏輯移位實現分析>物聯網學習：算術移位和邏輯移位實現分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/348da37.html alt="面向 Solidity 語言的變異測試系統" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcbae61fce31436a8639e1aa1cc31db2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/348da37.html title="面向 Solidity 語言的變異測試系統">面向 Solidity 語言的變異測試系統</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>