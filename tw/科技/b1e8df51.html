<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>精心整理20道高頻Java集合面試題(建議收藏) | 极客快訊</title><meta property="og:title" content="精心整理20道高頻Java集合面試題(建議收藏) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8cd7079d0ebe42ba9078b663d6c32de1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b1e8df51.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b1e8df51.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b1e8df51.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b1e8df51.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b1e8df51.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b1e8df51.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b1e8df51.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b1e8df51.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="精心整理20道高頻Java集合面試題(建議收藏)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b1e8df51.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>精心整理20道高頻Java集合面試題(建議收藏)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote>前言：把這段時間複習的關於集合類的東西整理出來，特別是HashMap相關的一些東西，之前都沒有很注意1.7 ->> 1.8的變化問題，但後來發現這其實變化挺大的，而且很多整理的面試資料都沒有更新（包括我之前整理的…）</blockquote><p class=ql-align-justify><strong>1）說說常見的集合有哪些吧？</strong></p><p class=ql-align-justify>答：Map接口和Collection接口是所有集合框架的父接口：</p><ol><li class=ql-align-justify>Collection接口的子接口包括：Set接口和List接口</li><li class=ql-align-justify>Map接口的實現類主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li class=ql-align-justify>Set接口的實現類主要有：HashSet、TreeSet、LinkedHashSet等</li><li class=ql-align-justify>List接口的實現類主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><hr class=ql-align-justify><p class=ql-align-justify><strong>2）HashMap與HashTable的區別？</strong></p><p class=ql-align-justify>答：</p><ol><li class=ql-align-justify>HashMap沒有考慮同步，是線程不安全的；Hashtable使用了synchronized關鍵字，是線程安全的；</li><li class=ql-align-justify>HashMap允許K/V都為null；後者K/V都不允許為null；</li><li class=ql-align-justify>HashMap繼承自AbstractMap類；而Hashtable繼承自Dictionary類；</li></ol><hr class=ql-align-justify><p class=ql-align-justify><strong>3）HashMap的put方法的具體流程？</strong></p><blockquote>圖引用自：https://blog.csdn.net/u011240877/article/details/53358305</blockquote><p class=ql-align-justify>答：下面先來分析一下源碼</p><pre class=ql-align-justify>final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { HashMap.Node&lt;K,V&gt;[] tab; HashMap.Node&lt;K,V&gt; p; int n, i; // 1.如果table為空或者長度為0，即沒有元素，那麼使用resize()方法擴容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 2.計算插入存儲的數組索引i，此處計算方法同 1.7 中的indexFor()方法 // 如果數組為空，即不存在Hash衝突，則直接插入數組 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 3.插入時，如果發生Hash衝突，則依次往下判斷 else { HashMap.Node&lt;K,V&gt; e; K k; // a.判斷table[i]的元素的key是否與需要插入的key一樣，若相同則直接用新的value覆蓋掉舊的value // 判斷原則equals() - 所以需要當key的對象重寫該方法 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // b.繼續判斷：需要插入的數據結構是紅黑樹還是鏈表 // 如果是紅黑樹，則直接在樹中插入 or 更新鍵值對 else if (p instanceof HashMap.TreeNode) e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 如果是鏈表，則在鏈表中插入 or 更新鍵值對 else { // i .遍歷table[i]，判斷key是否已存在：採用equals對比當前遍歷結點的key與需要插入數據的key // 如果存在相同的，則直接覆蓋 // ii.遍歷完畢後任務發現上述情況，則直接在鏈表尾部插入數據 // 插入完成後判斷鏈表長度是否 &gt; 8：若是，則把鏈表轉換成紅黑樹 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } // 對於i 情況的後續操作：發現key已存在，直接用新value覆蓋舊value&amp;返回舊value if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; // 插入成功後，判斷實際存在的鍵值對數量size &gt; 最大容量 // 如果大於則進行擴容 if (++size &gt; threshold) resize(); // 插入成功時會調用的方法（默認實現為空） afterNodeInsertion(evict); return null;}</pre><p class=ql-align-justify>圖片簡單總結為：</p><div class=pgc-img><img alt=精心整理20道高頻Java集合面試題(建議收藏) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8cd7079d0ebe42ba9078b663d6c32de1><p class=pgc-img-caption></p></div><hr class=ql-align-justify><p class=ql-align-justify><strong>4）HashMap的擴容操作是怎麼實現的？</strong></p><p class=ql-align-justify>答：通過分析源碼我們知道了HashMap通過resize()方法進行擴容或者初始化的操作，下面是對源碼進行的一些簡單分析：</p><pre class=ql-align-justify>/** * 該函數有2中使用情況：1.初始化哈希表；2.當前數組容量過小，需要擴容 */final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table;// 擴容前的數組（當前數組） int oldCap = (oldTab == null) ? 0 : oldTab.length;// 擴容前的數組容量（數組長度） int oldThr = threshold;// 擴容前數組的閾值 int newCap, newThr = 0; if (oldCap &gt; 0) { // 針對情況2：若擴容前的數組容量超過最大值，則不再擴容 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 針對情況2：若沒有超過最大值，就擴容為原來的2倍（左移1位） else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } // 針對情況1：初始化哈希表（採用指定或者使用默認值的方式） else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 計算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({"rawtypes","unchecked"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每一個bucket都移動到新的bucket中去 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;}</pre><hr class=ql-align-justify><p class=ql-align-justify><strong>5）HashMap是怎麼解決哈希衝突的？</strong></p><blockquote>參考資料：https://juejin.im/post/5ab99afff265da23a2291dee</blockquote><p class=ql-align-justify>答：在解決這個問題之前，我們首先需要知道<strong>什麼是哈希衝突</strong>，而在瞭解哈希衝突之前我們還要知道<strong>什麼是哈希</strong>才行；</p><p class=ql-align-justify><strong>什麼是哈希？</strong></p><p class=ql-align-justify><strong>Hash，一般翻譯為“散列”，也有直接音譯為“哈希”的，這就是把任意長度的輸入通過散列算法，變換成固定長度的輸出，該輸出就是散列值（哈希值）；</strong>這種轉換是一種壓縮映射，也就是，散列值的空間通常遠小於輸入的空間，不同的輸入可能會散列成相同的輸出，所以不可能從散列值來唯一的確定輸入值。<strong>簡單的說就是一種將任意長度的消息壓縮到某一固定長度的消息摘要的函數。</strong></p><p class=ql-align-justify>所有散列函數都有如下一個基本特性：<strong>根據同一散列函數計算出的散列值如果不同，那麼輸入值肯定也不同。但是，根據同一散列函數計算出的散列值如果相同，輸入值不一定相同。</strong></p><p class=ql-align-justify><strong>什麼是哈希衝突？</strong></p><p class=ql-align-justify><strong>當兩個不同的輸入值，根據同一散列函數計算出相同的散列值的現象，我們就把它叫做碰撞（哈希碰撞）。</strong></p><p class=ql-align-justify><strong>HashMap的數據結構</strong></p><p class=ql-align-justify>在Java中，保存數據有兩種比較簡單的數據結構：數組和鏈表。<strong>數組的特點是：尋址容易，插入和刪除困難；鏈表的特點是：尋址困難，但插入和刪除容易；</strong>所以我們將數組和鏈表結合在一起，發揮兩者各自的優勢，使用一種叫做<strong>鏈地址法</strong>的方式可以解決哈希衝突：</p><div class=pgc-img><img alt=精心整理20道高頻Java集合面試題(建議收藏) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8e92facfc40a42928bb785372805cf6a><p class=pgc-img-caption></p></div><p class=ql-align-justify>這樣我們就可以將擁有相同哈希值的對象組織成一個鏈表放在hash值所對應的bucket下，<strong>但相比於hashCode返回的int類型，我們HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要遠小於int類型的範圍，所以我們如果只是單純的用hashCode取餘來獲取對應的bucket這將會大大增加哈希碰撞的概率，並且最壞情況下還會將HashMap變成一個單鏈表，</strong>所以我們還需要對hashCode作一定的優化</p><p class=ql-align-justify><strong>hash()函數</strong></p><p class=ql-align-justify>上面提到的問題，主要是因為如果使用hashCode取餘，那麼相當於<strong>參與運算的只有hashCode的低位</strong>，高位是沒有起到任何作用的，所以我們的思路就是讓hashCode取值出的高位也參與運算，進一步降低hash碰撞的概率，使得數據分佈更平均，我們把這樣的操作稱為<strong>擾動</strong>，在<strong>JDK 1.8</strong>中的hash()函數如下：</p><pre class=ql-align-justify>static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 與自己右移16位進行異或運算（高低位異或）}</pre><p class=ql-align-justify>這比在<strong>JDK 1.7</strong>中，更為簡潔，<strong>相比在1.7中的4次位運算，5次異或運算（9次擾動），在1.8中，只進行了1次位運算和1次異或運算（2次擾動）；</strong></p><p class=ql-align-justify><strong>JDK1.8新增紅黑樹</strong></p><div class=pgc-img><img alt=精心整理20道高頻Java集合面試題(建議收藏) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3d856efd48d34dd887177717321f7839><p class=pgc-img-caption></p></div><p class=ql-align-justify>通過上面的<strong>鏈地址法（使用散列表）</strong>和<strong>擾動函數</strong>我們成功讓我們的數據分佈更平均，哈希碰撞減少，但是當我們的HashMap中存在大量數據時，加入我們某個bucket下對應的鏈表有n個元素，那麼遍歷時間複雜度就為O(n)，為了針對這個問題，JDK1.8在HashMap中新增了紅黑樹的數據結構，進一步使得遍歷複雜度降低至O(logn)；</p><p class=ql-align-justify><strong>總結</strong></p><p class=ql-align-justify>簡單總結一下HashMap是使用了哪些方法來有效解決哈希衝突的：</p><p class=ql-align-justify><strong>1. 使用鏈地址法（使用散列表）來鏈接擁有相同hash值的數據；</strong></p><p class=ql-align-justify><strong>2. 使用2次擾動函數（hash函數）來降低哈希衝突的概率，使得數據分佈更平均；</strong></p><p class=ql-align-justify><strong>3. 引入紅黑樹進一步降低遍歷的時間複雜度，使得遍歷更快；</strong></p><hr class=ql-align-justify><p class=ql-align-justify><strong>6）HashMap為什麼不直接使用hashCode()處理後的哈希值直接作為table的下標？</strong></p><p class=ql-align-justify>答：hashCode()方法返回的是int整數類型，其範圍為-(2 ^ 31)~(2 ^ 31 - 1)，約有40億個映射空間，而HashMap的容量範圍是在16（初始化默認值）~2 ^ 30，HashMap通常情況下是取不到最大值的，並且設備上也難以提供這麼多的存儲空間，從而導致通過hashCode()計算出的哈希值可能不在數組大小範圍內，進而無法匹配存儲位置；</p><p class=ql-align-justify><strong>面試官：那怎麼解決呢？</strong></p><p class=ql-align-justify>答：</p><ol><li class=ql-align-justify>HashMap自己實現了自己的hash()方法，通過兩次擾動使得它自己的哈希值高低位自行進行異或運算，降低哈希碰撞概率也使得數據分佈更平均；</li><li class=ql-align-justify>在保證數組長度為2的冪次方的時候，使用hash()運算之後的值與運算（&）（數組長度 - 1）來獲取數組下標的方式進行存儲，這樣一來是比取餘操作更加有效率，二來也是因為只有當數組長度為2的冪次方時，h&(length-1)才等價於h%length，三來解決了“哈希值與數組大小範圍不匹配”的問題；</li></ol><p class=ql-align-justify><strong>面試官：為什麼數組長度要保證為2的冪次方呢？</strong></p><p class=ql-align-justify>答：</p><ol><li class=ql-align-justify>只有當數組長度為2的冪次方時，h&(length-1)才等價於h%length，即實現了key的定位，2的冪次方也可以減少衝突次數，提高HashMap的查詢效率；</li><li class=ql-align-justify>如果 length 為 2 的次冪 則 length-1 轉化為二進制必定是 11111……的形式，在於 h 的二進制與操作效率會非常的快，而且空間不浪費；如果 length 不是 2 的次冪，比如 length 為 15，則 length - 1 為 14，對應的二進制為 1110，在於 h 與操作，最後一位都為 0 ，而 0001，0011，0101，1001，1011，0111，1101 這幾個位置永遠都不能存放元素了，空間浪費相當大，更糟的是這種情況中，數組可以使用的位置比數組長度小了很多，這意味著進一步增加了碰撞的機率，減慢了查詢的效率！這樣就會造成空間的浪費。</li></ol><p class=ql-align-justify><strong>面試官：那為什麼是兩次擾動呢？</strong></p><p class=ql-align-justify>答：這樣就是加大哈希值低位的隨機性，使得分佈更均勻，從而提高對應數組存儲下標位置的隨機性&均勻性，最終減少Hash衝突，兩次就夠了，已經達到了高位低位同時參與運算的目的；</p><hr class=ql-align-justify><p class=ql-align-justify><strong>7）HashMap在JDK1.7和JDK1.8中有哪些不同？</strong></p><p class=ql-align-justify>答：</p><p class=ql-align-justify>不同JDK 1.7JDK 1.8存儲結構數組 + 鏈表數組 + 鏈表 + 紅黑樹初始化方式單獨函數：inflateTable()直接集成到了擴容函數resize()中hash值計算方式擾動處理 = 9次擾動 = 4次位運算 + 5次異或運算擾動處理 = 2次擾動 = 1次位運算 + 1次異或運算存放數據的規則無衝突時，存放數組；衝突時，存放鏈表無衝突時，存放數組；衝突 & 鏈表長度 &lt; 8：存放單鏈表；衝突 & 鏈表長度 > 8：樹化並存放紅黑樹插入數據方式頭插法（先講原位置的數據移到後1位，再插入數據到該位置）尾插法（直接插入到鏈表尾部/紅黑樹）擴容後存儲位置的計算方式全部按照原來方法進行計算（即hashCode ->> 擾動函數 ->> (h&length-1)）按照擴容後的規律計算（即擴容後的位置=原位置 or 原位置 + 舊容量）</p><p class=ql-align-justify><strong>8）為什麼HashMap中String、Integer這樣的包裝類適合作為K？</strong></p><p class=ql-align-justify>答：String、Integer等包裝類的特性能夠保證Hash值的不可更改性和計算準確性，能夠有效的減少Hash碰撞的機率</p><ol><li class=ql-align-justify>都是final類型，即不可變性，保證key的不可更改性，不會存在獲取hash值不同的情況</li><li class=ql-align-justify>內部已重寫了equals()、hashCode()等方法，遵守了HashMap內部的規範（不清楚可以去上面看看putValue的過程），不容易出現Hash值計算錯誤的情況；</li></ol><p class=ql-align-justify><strong>面試官：如果我想要讓自己的Object作為K應該怎麼辦呢？</strong></p><p class=ql-align-justify>答：重寫hashCode()和equals()方法</p><ol><li class=ql-align-justify><strong>重寫hashCode()是因為需要計算存儲數據的存儲位置</strong>，需要注意不要試圖從散列碼計算中排除掉一個對象的關鍵部分來提高性能，這樣雖然能更快但可能會導致更多的Hash碰撞；</li><li class=ql-align-justify><strong>重寫`equals()`方法</strong>，需要遵守自反性、對稱性、傳遞性、一致性以及對於任何非null的引用值x，x.equals(null)必須返回false的這幾個特性，<strong>目的是為了保證key在哈希表中的唯一性</strong>；</li></ol><hr class=ql-align-justify><p class=ql-align-justify><strong>9）ConcurrentHashMap和Hashtable的區別？</strong></p><p class=ql-align-justify>答：ConcurrentHashMap 結合了 HashMap 和 HashTable 二者的優勢。HashMap 沒有考慮同步，HashTable 考慮了同步的問題。但是 HashTable 在每次同步執行時都要鎖住整個結構。ConcurrentHashMap 鎖的方式是稍微細粒度的。</p><p class=ql-align-justify><strong>面試官：ConcurrentHashMap的具體實現知道嗎？</strong></p><blockquote>參考資料：http://www.importnew.com/23610.html</blockquote><p class=ql-align-justify>答：<strong>在JDK1.7中，ConcurrentHashMap採用Segment + HashEntry的方式進行實現</strong>，結構如下：</p><div class=pgc-img><img alt=精心整理20道高頻Java集合面試題(建議收藏) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/51dabbd3dfa04f58bccb6ddb2d345ddb><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>該類包含兩個靜態內部類 HashEntry 和 Segment ；前者用來封裝映射表的鍵值對，後者用來充當鎖的角色；</li><li class=ql-align-justify>Segment 是一種可重入的鎖 ReentrantLock，每個 Segment 守護一個HashEntry 數組裡得元素，當對 HashEntry 數組的數據進行修改時，必須首先獲得對應的 Segment 鎖。</li></ol><p class=ql-align-justify>在<strong>JDK1.8中，放棄了Segment臃腫的設計，取而代之的是採用Node + CAS + Synchronized來保證併發安全進行實現</strong>，結構如下：</p><div class=pgc-img><img alt=精心整理20道高頻Java集合面試題(建議收藏) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/80d4de010bf04db498c199ca90d8f37e><p class=pgc-img-caption></p></div><p class=ql-align-justify>插入元素過程（建議去看看源碼）：</p><ol><li class=ql-align-justify>如果相應位置的Node還沒有初始化，則調用CAS插入相應的數據；</li></ol><pre class=ql-align-justify>else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) { if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin}</pre><ol><li class=ql-align-justify>如果相應位置的Node不為空，且當前該節點不處於移動狀態，則對該節點加synchronized鎖，如果該節點的hash不小於0，則遍歷鏈表更新節點或插入新節點；</li></ol><pre class=ql-align-justify>if (fh &gt;= 0) { binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) { K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) { oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; } Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) { pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; } }}</pre><ol><li class=ql-align-justify>如果該節點是TreeBin類型的節點，說明是紅黑樹結構，則通過putTreeVal方法往紅黑樹中插入節點；如果binCount不為0，說明put操作對數據產生了影響，如果當前鏈表的個數達到8個，則通過treeifyBin方法轉化為紅黑樹，如果oldVal不為空，說明是一次更新操作，沒有對元素個數產生影響，則直接返回舊值；</li><li class=ql-align-justify>如果插入的是一個新節點，則執行addCount()方法嘗試更新元素個數baseCount；</li></ol><hr class=ql-align-justify><p class=ql-align-justify><strong>10）Java集合的快速失敗機制 “fail-fast”？</strong></p><p class=ql-align-justify>答：</p><p class=ql-align-justify><strong>是java集合的一種錯誤檢測機制，當多個線程對集合進行結構上的改變的操作時，有可能會產生 fail-fast 機制。</strong></p><p class=ql-align-justify>例如：假設存在兩個線程（線程1、線程2），線程1通過Iterator在遍歷集合A中的元素，在某個時候線程2修改了集合A的結構（是結構上面的修改，而不是簡單的修改集合元素的內容），那麼這個時候程序就會拋出 ConcurrentModificationException 異常，從而產生fail-fast機制。</p><p class=ql-align-justify><strong>原因：迭代器在遍歷時直接訪問集合中的內容，並且在遍歷過程中使用一個 modCount 變量。集合在被遍歷期間如果內容發生變化，就會改變modCount的值。每當迭代器使用hashNext()/next()遍歷下一個元素之前，都會檢測modCount變量是否為expectedmodCount值，是的話就返回遍歷；否則拋出異常，終止遍歷。</strong></p><p class=ql-align-justify><strong>解決辦法：</strong></p><p class=ql-align-justify><strong>1. 在遍歷過程中，所有涉及到改變modCount值得地方全部加上synchronized。</strong></p><p class=ql-align-justify><strong>2. 使用CopyOnWriteArrayList來替換ArrayList</strong></p><hr class=ql-align-justify><p class=ql-align-justify><strong>11）ArrayList 和 Vector 的區別？</strong></p><p class=ql-align-justify>答：</p><p class=ql-align-justify>這兩個類都實現了 List 接口（List 接口繼承了 Collection 接口），他們都是有序集合，即存儲在這兩個集合中的元素位置都是有順序的，相當於一種動態的數組，我們以後可以按位置索引來取出某個元素，並且其中的數據是允許重複的，這是與 HashSet 之類的集合的最大不同處，HashSet 之類的集合不可以按索引號去檢索其中的元素，也不允許有重複的元素。</p><p class=ql-align-justify>ArrayList 與 Vector 的區別主要包括兩個方面：</p><ol><li class=ql-align-justify>同步性：</li><li class=ql-align-justify>Vector 是線程安全的，也就是說它的方法之間是線程同步（加了synchronized 關鍵字）的，而 ArrayList 是線程不安全的，它的方法之間是線程不同步的。如果只有一個線程會訪問到集合，那最好是使用 ArrayList，因為它不考慮線程安全的問題，所以效率會高一些；如果有多個線程會訪問到集合，那最好是使用 Vector，因為不需要我們自己再去考慮和編寫線程安全的代碼。</li><li class=ql-align-justify>數據增長：</li><li class=ql-align-justify>ArrayList 與 Vector 都有一個初始的容量大小，當存儲進它們裡面的元素的個人超過了容量時，就需要增加 ArrayList 和 Vector 的存儲空間，每次要增加存儲空間時，不是隻增加一個存儲單元，而是增加多個存儲單元，每次增加的存儲單元的個數在內存空間利用與程序效率之間要去的一定的平衡。Vector 在數據滿時（加載因子1）增長為原來的兩倍（擴容增量：原容量的 2 倍），而 ArrayList 在數據量達到容量的一半時（加載因子 0.5）增長為原容量的 (0.5 倍 + 1) 個空間。</li></ol><hr class=ql-align-justify><p class=ql-align-justify><strong>12）ArrayList和LinkedList的區別？</strong></p><p class=ql-align-justify>答：</p><ol><li class=ql-align-justify>LinkedList 實現了 List 和 Deque 接口，一般稱為雙向鏈表；ArrayList 實現了 List 接口，動態數組；</li><li class=ql-align-justify>LinkedList 在插入和刪除數據時效率更高，ArrayList 在查找某個 index 的數據時效率更高；</li><li class=ql-align-justify>LinkedList 比 ArrayList 需要更多的內存；</li></ol><p class=ql-align-justify><strong>面試官：Array 和 ArrayList 有什麼區別？什麼時候該應 Array 而不是 ArrayList 呢？</strong></p><p class=ql-align-justify>答：它們的區別是：</p><ol><li class=ql-align-justify>Array 可以包含基本類型和對象類型，ArrayList 只能包含對象類型。</li><li class=ql-align-justify>Array 大小是固定的，ArrayList 的大小是動態變化的。</li><li class=ql-align-justify>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li></ol><p class=ql-align-justify>對於基本類型數據，集合使用自動裝箱來減少編碼工作量。但是，當處理固定大小的基本數據類型的時候，這種方式相對比較慢。</p><hr class=ql-align-justify><p class=ql-align-justify><strong>13）HashSet是如何保證數據不可重複的？</strong></p><p class=ql-align-justify>答：HashSet的底層其實就是HashMap，只不過我們<strong>HashSet是實現了Set接口並且把數據作為K值，而V值一直使用一個相同的虛值來保存</strong>，我們可以看到源碼：</p><pre class=ql-align-justify>public boolean add(E e) { return map.put(e, PRESENT)==null;// 調用HashMap的put方法,PRESENT是一個至始至終都相同的虛值}</pre><p class=ql-align-justify>由於HashMap的K值本身就不允許重複，並且在HashMap中如果K/V相同時，會用新的V覆蓋掉舊的V，然後返回舊的V，那麼在HashSet中執行這一句話始終會返回一個false，導致插入失敗，這樣就保證了數據的不可重複性；</p><hr class=ql-align-justify><p class=ql-align-justify><strong>20）BlockingQueue是什麼？</strong></p><p class=ql-align-justify>答：</p><p class=ql-align-justify>Java.util.concurrent.BlockingQueue是一個隊列，在進行檢索或移除一個元素的時候，它會等待隊列變為非空；當在添加一個元素時，它會等待隊列中的可用空間。BlockingQueue接口是Java集合框架的一部分，主要用於實現生產者-消費者模式。我們不需要擔心等待生產者有可用的空間，或消費者有可用的對象，因為它都在BlockingQueue的實現類中被處理了。Java提供了集中BlockingQueue的實現，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><p class=ql-align-center>—————END—————</p><hr></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>20</a></li><li><a>高頻</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6785387f.html alt=20個高級Java面試題彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/48f61a2c724c464a8774a34e68d84974 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6785387f.html title=20個高級Java面試題彙總>20個高級Java面試題彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f4c64e.html alt=20個對Java程序員有用的開源庫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15329379816255c841a295d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f4c64e.html title=20個對Java程序員有用的開源庫>20個對Java程序員有用的開源庫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ec2f973.html alt=Java程序員必備的20個庫，你有嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d1e4621d24f149a98b6275f93b894b1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ec2f973.html title=Java程序員必備的20個庫，你有嗎？>Java程序員必備的20個庫，你有嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9258f998.html alt=20個機械設計知識點總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b796c9aa87ea44c3af3f0bcf540c10e5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9258f998.html title=20個機械設計知識點總結>20個機械設計知識點總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ee85449.html alt=20個機械設計知識點總結（含動圖） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/379b9324a57043c182970c2785682cb1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ee85449.html title=20個機械設計知識點總結（含動圖）>20個機械設計知識點總結（含動圖）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c385baa6.html alt=20個機械設計知識點總結，20個機械基本常識學習，你知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d057d152-a500-47b5-86c5-36fca1da8e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c385baa6.html title=20個機械設計知識點總結，20個機械基本常識學習，你知道嗎？>20個機械設計知識點總結，20個機械基本常識學習，你知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/edf74594.html alt=20個機械設計知識點總結，快收藏吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e157cebc-e3a4-47c0-956c-d2f50e5efdaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/edf74594.html title=20個機械設計知識點總結，快收藏吧>20個機械設計知識點總結，快收藏吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html alt=20個機械設計知識點總結，搞懂也是半個行家 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html title=20個機械設計知識點總結，搞懂也是半個行家>20個機械設計知識點總結，搞懂也是半個行家</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/23926f2e.html alt=20個機械設計面試題，看你能答對多少 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3f84f74244c046b482e39ddde54909f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/23926f2e.html title=20個機械設計面試題，看你能答對多少>20個機械設計面試題，看你能答對多少</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdef4f26.html alt=20條機械設計知識點乾貨，好用，收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdef4f26.html title=20條機械設計知識點乾貨，好用，收藏>20條機械設計知識點乾貨，好用，收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6ba701c.html alt=每天掌握一點點——20個機械設計知識點總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/c0cb711d-f9a4-4f31-9189-64e64430fbf6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6ba701c.html title=每天掌握一點點——20個機械設計知識點總結>每天掌握一點點——20個機械設計知識點總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38dd8905.html alt=牢記這20個機械設計知識點，減少犯錯機率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/31174612-d2c7-48b2-8411-9f2e0e40fffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38dd8905.html title=牢記這20個機械設計知識點，減少犯錯機率>牢記這20個機械設計知識點，減少犯錯機率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00b1183a.html alt=牢記這20個機械設計知識點，減少犯錯，2020年提高自己工資待遇！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c2150368e8ab40f1b0a561656a2dd1f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00b1183a.html title=牢記這20個機械設計知識點，減少犯錯，2020年提高自己工資待遇！>牢記這20個機械設計知識點，減少犯錯，2020年提高自己工資待遇！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6aa2cf54.html alt=日本地下1000米深處，20多年存儲5萬噸超純水，目的何在？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f2429125acb04d748bff2539dcea0756 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6aa2cf54.html title=日本地下1000米深處，20多年存儲5萬噸超純水，目的何在？>日本地下1000米深處，20多年存儲5萬噸超純水，目的何在？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>