<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>讓你不再害怕指針——C指針詳解(經典,非常詳細) | 极客快訊</title><meta property="og:title" content="讓你不再害怕指針——C指針詳解(經典,非常詳細) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b25d76e4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b25d76e4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b25d76e4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b25d76e4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b25d76e4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b25d76e4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b25d76e4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b25d76e4.html><meta property="article:published_time" content="2020-11-14T21:00:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:22+08:00"><meta name=Keywords content><meta name=description content="讓你不再害怕指針——C指針詳解(經典,非常詳細)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b25d76e4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>讓你不再害怕指針——C指針詳解(經典,非常詳細)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>前言:複雜類型說明</strong></p><p>要了解指針,多多少少會出現一些比較複雜的類型,所以我先介紹一下如何完全理解一個複雜類型,要理解複雜類型其實很簡單,一個類型裡會出現很多運算符,他們也像普通的表達式一樣,有優先級,其優先級和運算優先級一樣,所以我總結了一下其原則:從變量名處起,根據運算符優先級結合,一步一步分析.下面讓我們先從簡單的類型開始慢慢分析吧:</p><pre>int p; //這是一個普通的整型變量int *p; //首先從P 處開始,先與*結合,所以說明P 是一個指針,然後再與int 結合,說明指針所指向的內容的類型為int 型.所以P是一個返回整型數據的指針int p[3]; //首先從P 處開始,先與[]結合,說明P 是一個數組,然後與int 結合,說明數組裡的元素是整型的,所以P 是一個由整型數據組成的數組int *p[3]; //首先從P 處開始,先與[]結合,因為其優先級比*高,所以P 是一個數組,然後再與*結合,說明數組裡的元素是指針類型,然後再與int 結合,說明指針所指向的內容的類型是整型的,所以P 是一個由返回整型數據的指針所組成的數組int (*p)[3]; //首先從P 處開始,先與*結合,說明P 是一個指針然後再與[]結合(與"()"這步可以忽略,只是為了改變優先級),說明指針所指向的內容是一個數組,然後再與int 結合,說明數組裡的元素是整型的.所以P 是一個指向由整型數據組成的數組的指針int **p; //首先從P 開始,先與*結合,說是P 是一個指針,然後再與*結合,說明指針所指向的元素是指針,然後再與int 結合,說明該指針所指向的元素是整型數據.由於二級指針以及更高級的指針極少用在複雜的類型中,所以後面更復雜的類型我們就不考慮多級指針了,最多隻考慮一級指針.int p(int); //從P 處起,先與()結合,說明P 是一個函數,然後進入()裡分析,說明該函數有一個整型變量的參數,然後再與外面的int 結合,說明函數的返回值是一個整型數據Int (*p)(int); //從P 處開始,先與指針結合,說明P 是一個指針,然後與()結合,說明指針指向的是一個函數,然後再與()裡的int 結合,說明函數有一個int 型的參數,再與最外層的int 結合,說明函數的返回類型是整型,所以P 是一個指向有一個整型參數且返回類型為整型的函數的指針int *(*p(int))[3]; //可以先跳過,不看這個類型,過於複雜從P 開始,先與()結合,說明P 是一個函數,然後進入()裡面,與int 結合,說明函數有一個整型變量參數,然後再與外面的*結合,說明函數返回的是一個指針,,然後到最外面一層,先與[]結合,說明返回的指針指向的是一個數組,然後再與*結合,說明數組裡的元素是指針,然後再與int 結合,說明指針指向的內容是整型數據.所以P 是一個參數為一個整數據且返回一個指向由整型指針變量組成的數組的指針變量的函數.</pre><p>說到這裡也就差不多了,我們的任務也就這麼多,理解了這幾個類型,其它的類型對我們來說也是小菜了,不過我們一般不會用太複雜的類型,那樣會大大減小程序的可讀性,請慎用,這上面的幾種類型已經足夠我們用了.</p><p><strong>一、細說指針</strong></p><p>指針是一個特殊的變量，它裡面存儲的數值被解釋成為內存裡的一個地址。要搞清一個指針需要搞清指針的四方面的內容：指針的類型、指針所指向的類型、指針的值或者叫指針所指向的內存區、指針本身所佔據的內存區。讓我們分別說明。</p><p>先聲明幾個指針放著做例子：</p><p>例一：</p><pre>(1)int*ptr;(2)char*ptr;(3)int**ptr;(4)int(*ptr)[3];(5)int*(*ptr)[4];</pre><p><strong>1.指針的類型</strong></p><p>從語法的角度看，你只要把指針聲明語句裡的指針名字去掉，剩下的部分就是這個指針的類型。這是指針本身所具有的類型。讓我們看看例一中各個指針的類型：</p><p>(1)int*ptr;//指針的類型是int*</p><p>(2)char*ptr;//指針的類型是char*</p><p>(3)int**ptr;//指針的類型是int**</p><p>(4)int(*ptr)[3];//指針的類型是int(*)[3]</p><p>(5)int*(*ptr)[4];//指針的類型是int*(*)[4]</p><p>怎麼樣？找出指針的類型的方法是不是很簡單？</p><p><strong>2.指針所指向的類型</strong></p><p>當你通過指針來訪問指針所指向的內存區時，指針所指向的類型決定了編譯器將把那片內存區裡的內容當做什麼來看待。</p><p>從語法上看，你只須把指針聲明語句中的指針名字和名字左邊的指針聲明符*去掉，剩下的就是指針所指向的類型。例如：</p><p>(1)int*ptr; //指針所指向的類型是int</p><p>(2)char*ptr; //指針所指向的的類型是char</p><p>(3)int**ptr; //指針所指向的的類型是int*</p><p>(4)int(*ptr)[3]; //指針所指向的的類型是int()[3]</p><p>(5)int*(*ptr)[4]; //指針所指向的的類型是int*()[4]</p><p>在指針的算術運算中，指針所指向的類型有很大的作用。</p><p>指針的類型(即指針本身的類型)和指針所指向的類型是兩個概念。當你對C 越來越熟悉時，你會發現，把與指針攪和在一起的"類型"這個概念分成"指針的類型"和"指針所指向的類型"兩個概念，是精通指針的關鍵點之一。我看了不少書，發現有些寫得差的書中，就把指針的這兩個概念攪在一起了，所以看起書來前後矛盾，越看越糊塗。</p><p><strong>3.指針的值----或者叫指針所指向的內存區或地址</strong></p><p>指針的值是指針本身存儲的數值，這個值將被編譯器當作一個地址，而不是一個一般的數值。在32 位程序裡，所有類型的指針的值都是一個32 位整數，因為32 位程序裡內存地址全都是32 位長。指針所指向的內存區就是從指針的值所代表的那個內存地址開始，長度為si zeof(指針所指向的類型)的一片內存區。以後，我們說一個指針的值是XX，就相當於說該指針指向了以XX 為首地址的一片內存區域；我們說一個指針指向了某塊內存區域，就相當於說該指針的值是這塊內存區域的首地址。指針所指向的內存區和指針所指向的類型是兩個完全不同的概念。在例一中，指針所指向的類型已經有了，但由於指針還未初始化，所以它所指向的內存區是不存在的，或者說是無意義的。</p><p><strong>以後，每遇到一個指針，都應該問問：這個指針的類型是什麼？指針指的類型是什麼？該指針指向了哪裡？（重點注意）</strong></p><p><strong>4 指針本身所佔據的內存區</strong></p><p>指針本身佔了多大的內存？你只要用函數sizeof(指針的類型)測一下就知道了。在32 位平臺裡，指針本身佔據了4 個字節的長度。指針本身佔據的內存這個概念在判斷一個指針表達式（後面會解釋）是否是左值時很有用。</p><p><strong>二、指針的算術運算</strong></p><p>指針可以加上或減去一個整數。指針的這種運算的意義和通常的數值的加減運算的意義是不一樣的，以單元為單位。例如：</p><p>例二：</p><pre>char a[20];int *ptr=(int *)a; //強制類型轉換並不會改變a 的類型ptr++;</pre><p>在上例中，指針ptr 的類型是int*,它指向的類型是int，它被初始化為指向整型變量a。接下來的第3句中，指針ptr被加了1，編譯器是這樣處理的：它把指針ptr 的值加上了sizeof(int)，在32 位程序中，是被加上了4，因為在32 位程序中，int 佔4 個字節。由於地址是用字節做單位的，故ptr 所指向的地址由原來的變量a 的地址向高地址方向增加了4 個字節。由於char 類型的長度是一個字節，所以，原來ptr 是指向數組a 的第0 號單元開始的四個字節，此時指向了數組a 中從第4 號單元開始的四個字節。我們可以用一個指針和一個循環來遍歷一個數組，看例子：</p><p>例三：</p><pre>int array[20]={0};int *ptr=array;for(i=0;i&lt;20;i++){ (*ptr)++; ptr++；}</pre><p>這個例子將整型數組中各個單元的值加1。由於每次循環都將指針ptr加1 個單元，所以每次循環都能訪問數組的下一個單元。</p><p>再看例子：</p><p>例四：</p><pre>char a[20]="You_are_a_girl";int *ptr=(int *)a;ptr+=5;</pre><p>在這個例子中，ptr 被加上了5，編譯器是這樣處理的：將指針ptr 的值加上5 乘sizeof(int)，在32 位程序中就是加上了5 乘4=20。由於地址的單位是字節，故現在的ptr 所指向的地址比起加5 後的ptr 所指向的地址來說，向高地址方向移動了20 個字節。</p><p>在這個例子中，沒加5 前的ptr 指向數組a 的第0 號單元開始的四個字節，加5 後，ptr 已經指向了數組a 的合法範圍之外了。雖然這種情況在應用上會出問題，但在語法上卻是可以的。這也體現出了指針的靈活性。如果上例中，ptr 是被減去5，那麼處理過程大同小異，只不過ptr 的值是被減去5 乘sizeof(int)，新的ptr 指向的地址將比原來的ptr 所指向的地址向低地址方向移動了20 個字節。</p><p>下面請允許我再舉一個例子:(一個誤區)</p><p>例五:</p><pre>#include&lt;stdio.h&gt;int main(){ char a[20]=" You_are_a_girl"; char *p=a; char **ptr=&amp;p; //printf("p=%d\n",p); //printf("ptr=%d\n",ptr); //printf("*ptr=%d\n",*ptr); printf("**ptr=%c\n",**ptr); ptr++; //printf("ptr=%d\n",ptr); //printf("*ptr=%d\n",*ptr); printf("**ptr=%c\n",**ptr);}</pre><p><strong>誤區一、</strong>輸出答案為Y 和o</p><p>誤解:ptr 是一個char 的二級指針,當執行ptr++;時,會使指針加一個sizeof(char),所以輸出如上結果,這個可能只是少部分人的結果.</p><p><strong>誤區二、</strong>輸出答案為Y 和a誤解:ptr 指向的是一個char *類型,當執行ptr++;時,會使指針加一個sizeof(char *)(有可能會有人認為這個值為1,那就會得到誤區一的答案,這個值應該是4,參考前面內容), 即&p+4; 那進行一次取值運算不就指向數組中的第五個元素了嗎?那輸出的結果不就是數組中第五個元素了嗎?答案是否定的.</p><p><strong>正解:</strong> ptr 的類型是char **,指向的類型是一個char *類型,該指向的地址就是p的地址(&p),當執行ptr++;時,會使指針加一個sizeof(char*),即&p+4;那*(&p+4)指向哪呢,這個你去問上帝吧,或者他會告訴你在哪?所以最後的輸出會是一個隨機的值,或許是一個非法操作.</p><p><strong>總結一下:</strong></p><p>一個指針ptrold 加(減)一個整數n 後，結果是一個新的指針ptrnew，ptrnew 的類型和ptrold 的類型相同，ptrnew 所指向的類型和ptrold所指向的類型也相同。ptrnew 的值將比ptrold 的值增加(減少)了n 乘sizeof(ptrold 所指向的類型)個字節。就是說，ptrnew 所指向的內存區將比ptrold 所指向的內存區向高(低)地址方向移動了n 乘sizeof(ptrold 所指向的類型)個字節。指針和指針進行加減：兩個指針不能進行加法運算，這是非法操作，因為進行加法後，得到的結果指向一個不知所向的地方，而且毫無意義。兩個指針可以進行減法操作，但必須類型相同，一般用在數組方面，不多說了。</p><p><strong>三、運算符&和*</strong></p><p>這裡&是取地址運算符，*是間接運算符。</p><p>&a 的運算結果是一個指針，指針的類型是a 的類型加個*，指針所指向的類型是a 的類型，指針所指向的地址嘛，那就是a 的地址。</p><p>*p 的運算結果就五花八門了。總之*p 的結果是p 所指向的東西，這個東西有這些特點：它的類型是p 指向的類型，它所佔用的地址是p所指向的地址。</p><p>例六：</p><pre>int a=12; int b; int *p; int **ptr;p=&amp;a; //&amp;a 的結果是一個指針，類型是int*，指向的類型是//int，指向的地址是a 的地址。*p=24; //*p 的結果，在這裡它的類型是int，它所佔用的地址是//p 所指向的地址，顯然，*p 就是變量a。ptr=&amp;p; //&amp;p 的結果是個指針，該指針的類型是p 的類型加個*，//在這裡是int **。該指針所指向的類型是p 的類型，這//裡是int*。該指針所指向的地址就是指針p 自己的地址。*ptr=&amp;b; //*ptr 是個指針，&amp;b 的結果也是個指針，且這兩個指針//的類型和所指向的類型是一樣的，所以用&amp;b 來給*ptr 賦//值就是毫無問題的了。**ptr=34; //*ptr 的結果是ptr 所指向的東西，在這裡是一個指針，//對這個指針再做一次*運算，結果是一個int 類型的變量。</pre><p><strong>四、指針表達式</strong></p><p>一個表達式的結果如果是一個指針，那麼這個表達式就叫指針表式。</p><p>下面是一些指針表達式的例子：</p><p>例七：</p><pre>int a,b;int array[10];int *pa;pa=&amp;a; //&amp;a 是一個指針表達式。Int **ptr=&amp;pa; //&amp;pa 也是一個指針表達式。*ptr=&amp;b; //*ptr 和&amp;b 都是指針表達式。pa=array;pa++; //這也是指針表達式。</pre><p>例八：</p><pre>char *arr[20];char **parr=arr; //如果把arr 看作指針的話，arr 也是指針表達式char *str;str=*parr; //*parr 是指針表達式str=*(parr+1); //*(parr+1)是指針表達式str=*(parr+2); //*(parr+2)是指針表達式</pre><p>由於指針表達式的結果是一個指針，所以指針表達式也具有指針所具有的四個要素：指針的類型，指針所指向的類型，指針指向的內存區，指針自身佔據的內存。</p><p>好了，當一個指針表達式的結果指針已經明確地具有了指針自身佔據的內存的話，這個指針表達式就是一個左值，否則就不是一個左值。在例七中，&a 不是一個左值，因為它還沒有佔據明確的內存。*ptr 是一個左值，因為*ptr 這個指針已經佔據了內存，其實*ptr 就是指針pa，既然pa 已經在內存中有了自己的位置，那麼*ptr 當然也有了自己的位置。</p><p><strong>五、數組和指針的關係</strong></p><p>數組的數組名其實可以看作一個指針。看下例：</p><p>例九：</p><pre>int array[10]={0,1,2,3,4,5,6,7,8,9},value;value=array[0]; //也可寫成：value=*array;value=array[3]; //也可寫成：value=*(array+3);value=array[4]; //也可寫成：value=*(array+4);</pre><p>上例中，一般而言數組名array 代表數組本身，類型是int[10]，但如果把array 看做指針的話，它指向數組的第0 個單元，類型是int* 所指向的類型是數組單元的類型即int。因此*array 等於0 就一點也不奇怪了。同理，array+3 是一個指向數組第3 個單元的指針，所以*(array+3)等於3。其它依此類推。</p><p>例十：</p><pre>char *str[3]={ "Hello,thisisasample!", "Hi,goodmorning.", "Helloworld"};char s[80]；strcpy(s,str[0]); //也可寫成strcpy(s,*str);strcpy(s,str[1]); //也可寫成strcpy(s,*(str+1));strcpy(s,str[2]); //也可寫成strcpy(s,*(str+2));</pre><p>上例中，str 是一個三單元的數組，該數組的每個單元都是一個指針，這些指針各指向一個字符串。把指針數組名str 當作一個指針的話，它指向數組的第0 號單元，它的類型是char **，它指向的類型是char *。</p><p>*str 也是一個指針，它的類型是char *，它所指向的類型是char，它指向的地址是字符串"Hello,thisisasample!"的第一個字符的地址，即'H'的地址。注意:字符串相當於是一個數組,在內存中以數組的形式儲存,只不過字符串是一個數組常量,內容不可改變,且只能是右值.如果看成指針的話,他即是常量指針,也是指針常量.</p><p>str+1 也是一個指針，它指向數組的第1 號單元，它的類型是char**，它指向的類型是char*。</p><p>*(str+1)也是一個指針，它的類型是char*，它所指向的類型是char，它指向"Hi,goodmorning."的第一個字符'H'</p><p><strong>下面總結一下數組的數組名(數組中儲存的也是數組)的問題:</strong></p><p>聲明瞭一個數組TYPE array[n]，則數組名稱array 就有了兩重含義：</p><p>第一，它代表整個數組，它的類型是TYPE[n]；</p><p>第二，它是一個常量指針，該指針的類型是TYPE*，該指針指向的類型是TYPE，也就是數組單元的類型，該指針指向的內存區就是數組第0 號單元，該指針自己佔有單獨的內存區，注意它和數組第0 號單元佔據的內存區是不同的。該指針的值是不能修改的，即類似array++的表達式是錯誤的。在不同的表達式中數組名array 可以扮演不同的角色。在表達式sizeof(array)中，數組名array 代表數組本身，故這時sizeof 函數測出的是整個數組的大小。</p><p>在表達式*array 中，array 扮演的是指針，因此這個表達式的結果就是數組第0 號單元的值。sizeof(*array)測出的是數組單元的大小。</p><p>表達式array+n（其中n=0，1，2，.....）中，array 扮演的是指針，故array+n 的結果是一個指針，它的類型是TYPE *，它指向的類型是TYPE，它指向數組第n號單元。故sizeof(array+n)測出的是指針類型的大小。在32 位程序中結果是4</p><p>例十一:</p><pre>int array[10];int (*ptr)[10];ptr=&amp;array;：</pre><p>上例中ptr 是一個指針，它的類型是int(*)[10]，他指向的類型是int[10] ，我們用整個數組的首地址來初始化它。在語句ptr=&array中，array 代表數組本身。</p><p>本節中提到了函數sizeof()，那麼我來問一問，sizeof(指針名稱)測出的究竟是指針自身類型的大小呢還是指針所指向的類型的大小？</p><p>答案是前者。例如：</p><p>int(*ptr)[10];</p><p>則在32 位程序中，有：</p><p>sizeof(int(*)[10])==4</p><p>sizeof(int[10])==40</p><p>sizeof(ptr)==4</p><p>實際上，sizeof(對象)測出的都是對象自身的類型的大小，而不是別的什麼類型的大小。</p><p><strong>六、指針和結構類型的關係</strong></p><p>可以聲明一個指向結構類型對象的指針。</p><p>例十二：</p><pre>struct MyStruct{ int a; int b; int c;};struct MyStruct ss={20,30,40};//聲明瞭結構對象ss，並把ss 的成員初始化為20，30 和40。struct MyStruct *ptr=&amp;ss;//聲明瞭一個指向結構對象ss 的指針。它的類型是//MyStruct *,它指向的類型是MyStruct。int *pstr=(int*)&amp;ss;//聲明瞭一個指向結構對象ss 的指針。但是pstr 和//它被指向的類型ptr 是不同的。</pre><p><strong>請問怎樣通過指針ptr 來訪問ss 的三個成員變量？</strong></p><p><strong>答案：</strong></p><p>ptr->a; //指向運算符，或者可以這們(*ptr).a,建議使用前者</p><p>ptr->b;</p><p>ptr->c;</p><p><strong>又請問怎樣通過指針pstr 來訪問ss 的三個成員變量？</strong></p><p><strong>答案：</strong></p><p>*pstr； //訪問了ss 的成員a。</p><p>*(pstr+1); //訪問了ss 的成員b。</p><p>*(pstr+2) //訪問了ss 的成員c。</p><p>雖然我在我的MSVC++6.0 上調式過上述代碼，但是要知道，這樣使用pstr 來訪問結構成員是不正規的，為了說明為什麼不正規，讓我們看看怎樣通過指針來訪問數組的各個單元: (將結構體換成數組)</p><p>例十三：</p><pre>int array[3]={35,56,37};int *pa=array;//通過指針pa 訪問數組array 的三個單元的方法是：*pa; //訪問了第0 號單元*(pa+1); //訪問了第1 號單元*(pa+2); //訪問了第2 號單元</pre><p>從格式上看倒是與通過指針訪問結構成員的不正規方法的格式一樣。</p><p>所有的C/C++編譯器在排列數組的單元時，總是把各個數組單元存放在連續的存儲區裡，單元和單元之間沒有空隙。但在存放結構對象的各個成員時，在某種編譯環境下，可能會需要字對齊或雙字對齊或者是別的什麼對齊，需要在相鄰兩個成員之間加若干個"填充字節"，這就導致各個成員之間可能會有若干個字節的空隙。</p><p>所以，在例十二中，即使*pstr 訪問到了結構對象ss 的第一個成員變量a，也不能保證*(pstr+1)就一定能訪問到結構成員b。因為成員a 和成員b 之間可能會有若干填充字節，說不定*(pstr+1)就正好訪問到了這些填充字節呢。這也證明了指針的靈活性。要是你的目的就是想看看各個結構成員之間到底有沒有填充字節，嘿，這倒是個不錯的方法。</p><p>不過指針訪問結構成員的正確方法應該是象例十二中使用指針ptr 的方法。</p><p><strong>七、指針和函數的關係</strong></p><p>可以把一個指針聲明成為一個指向函數的指針。</p><p>int fun1(char *,int);</p><p>int (*pfun1)(char *,int);</p><p>pfun1=fun1;</p><p>int a=(*pfun1)("abcdefg",7); //通過函數指針調用函數。</p><p>可以把指針作為函數的形參。在函數調用語句中，可以用指針表達式來作為實參。</p><p>例十四：</p><pre>int fun(char *);inta;char str[]="abcdefghijklmn";a=fun(str);int fun(char *s){ int num=0; for(int i=0;;) { num+=*s;s++; } return num;}</pre><p>這個例子中的函數fun 統計一個字符串中各個字符的ASCII 碼值之和。前面說了，數組的名字也是一個指針。在函數調用中，當把str作為實參傳遞給形參s 後，實際是把str 的值傳遞給了s，s 所指向的地址就和str 所指向的地址一致，但是str 和s 各自佔用各自的存儲空間。在函數體內對s 進行自加1 運算，並不意味著同時對str 進行了自加1 運算。</p><p><strong>八、指針類型轉換</strong></p><p>當我們初始化一個指針或給一個指針賦值時，賦值號的左邊是一個指針，賦值號的右邊是一個指針表達式。在我們前面所舉的例子中，絕大多數情況下，指針的類型和指針表達式的類型是一樣的，指針所指向的類型和指針表達式所指向的類型是一樣的。</p><p>例十五：</p><pre>float f=12.3;float *fptr=&amp;f;int *p;</pre><p>在上面的例子中，假如我們想讓指針p 指向實數f，應該怎麼辦？</p><p>是用下面的語句嗎？</p><p>p=&amp;f;</p><p>不對。因為指針p 的類型是int *，它指向的類型是int。表達式&f 的結果是一個指針，指針的類型是float *,它指向的類型是float。</p><p>兩者不一致，直接賦值的方法是不行的。至少在我的MSVC++6.0 上，對指針的賦值語句要求賦值號兩邊的類型一致，所指向的類型也一致，其它的編譯器上我沒試過，大家可以試試。為了實現我們的目的，需要進行"強制類型轉換"：</p><p>p=(int*)&amp;f;</p><p>如果有一個指針p，我們需要把它的類型和所指向的類型改為TYEP *TYPE， 那麼語法格式是： (TYPE *)p；</p><p>這樣強制類型轉換的結果是一個新指針，該新指針的類型是TYPE *，它指向的類型是TYPE，它指向的地址就是原指針指向的地址。</p><p>而原來的指針p 的一切屬性都沒有被修改。（切記）</p><p>一個函數如果使用了指針作為形參，那麼在函數調用語句的實參和形參的結合過程中，必須保證類型一致，否則需要強制轉換</p><p>例十六：</p><pre>void fun(char*);int a=125,b;fun((char*)&amp;a);void fun(char*s){	charc;	c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;	c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;}</pre><p>注意這是一個32 位程序，故int 類型佔了四個字節，char 類型佔一個字節。函數fun 的作用是把一個整數的四個字節的順序來個顛倒。注意到了嗎？在函數調用語句中，實參&a 的結果是一個指針，它的類型是int *，它指向的類型是int。形參這個指針的類型是char *，它指向的類型是char。這樣，在實參和形參的結合過程中，我們必須進行一次從int *類型到char *類型的轉換。</p><p><strong>結合這個例子，我們可以這樣來</strong></p><p>想象編譯器進行轉換的過程：編譯器先構造一個臨時指針char *temp，然後執行temp=(char *)&a，最後再把temp 的值傳遞給s。所以最後的結果是：s 的類型是char *,它指向的類型是char，它指向的地址就是a 的首地址。</p><p>我們已經知道，指針的值就是指針指向的地址，在32 位程序中，指針的值其實是一個32 位整數。</p><p>那可不可以把一個整數當作指針的值直接賦給指針呢？就象下面的語句：</p><pre>unsigned int a;TYPE *ptr; //TYPE 是int，char 或結構類型等等類型。a=20345686;ptr=20345686; //我們的目的是要使指針ptr 指向地址20345686 ptr=a; //我們的目的是要使指針ptr 指向地址20345686//編譯一下吧。結果發現後面兩條語句全是錯的。那麼我們的目的就不能達到了嗎？不，還有辦法：unsigned int a;TYPE *ptr; //TYPE 是int，char 或結構類型等等類型。a=N //N 必須代表一個合法的地址；ptr=(TYPE*)a； //呵呵，這就可以了。</pre><p>嚴格說來這裡的(TYPE *)和指針類型轉換中的(TYPE *)還不一樣。這裡的(TYPE*)的意思是把無符號整數a 的值當作一個地址來看待。上面強調了a 的值必須代表一個合法的地址，否則的話，在你使用ptr 的時候，就會出現非法操作錯誤。想想能不能反過來，把指針指向的地址即指針的值當作一個整數取出來。完全可以。下面的例子演示了把一個指針的值當作一個整數取出來，然後再把這個整數當作一個地址賦給一個指針：</p><p>例十七：</p><pre>int a=123,b;int *ptr=&amp;a;char *str;b=(int)ptr; //把指針ptr 的值當作一個整數取出來。str=(char*)b; //把這個整數的值當作一個地址賦給指針str。</pre><p>現在我們已經知道了，可以把指針的值當作一個整數取出來，也可以把一個整數值當作地址賦給一個指針。</p><p><strong>九、指針的安全問題</strong></p><p>看下面的例子：</p><p>例十八：</p><pre>char s='a';int *ptr;ptr=(int *)&amp;s;*ptr=1298；</pre><p>指針ptr 是一個int *類型的指針，它指向的類型是int。它指向的地址就是s 的首地址。在32 位程序中，s 佔一個字節，int 類型佔四個字節。最後一條語句不但改變了s 所佔的一個字節，還把和s 相臨的高地址方向的三個字節也改變了。這三個字節是幹什麼的？只有編譯程序知道，而寫程序的人是不太可能知道的。也許這三個字節裡存儲了非常重要的數據，也許這三個字節里正好是程序的一條代碼，而由於你對指針的馬虎應用，這三個字節的值被改變了！這會造成崩潰性的錯誤。</p><p>讓我們再來看一例：</p><p>例十九：</p><pre>char a;int *ptr=&amp;a;ptr++;*ptr=115;</pre><p>該例子完全可以通過編譯，並能執行。但是看到沒有？第3 句對指針ptr 進行自加1 運算後，ptr 指向了和整形變量a 相鄰的高地址方向的一塊存儲區。這塊存儲區裡是什麼？我們不知道。有可能它是一個非常重要的數據，甚至可能是一條代碼。</p><p>而第4 句竟然往這片存儲區裡寫入一個數據！這是嚴重的錯誤。所以在使用指針時，程序員心裡必須非常清楚：我的指針究竟指向了哪裡。在用指針訪問數組的時候，也要注意不要超出數組的低端和高端界限，否則也會造成類似的錯誤。</p><p>在指針的強制類型轉換：ptr1=(TYPE *)ptr2 中，如果sizeof(ptr2的類型)大於sizeof(ptr1 的類型)，那麼在使用指針ptr1 來訪問ptr2所指向的存儲區時是安全的。如果sizeof(ptr2 的類型) 小於sizeof(ptr1 的類型)，那麼在使用指針ptr1 來訪問ptr2 所指向的存儲區時是不安全的。至於為什麼，讀者結合例十八來想一想，應該會明白的。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>指針</a></li><li><a>詳解</a></li><li><a>經典</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/299cf68e.html alt="C語言指針詳解（經典 非常詳細 通俗易懂）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/945d85d21fcf45cba3e994a7220e2112 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/299cf68e.html title="C語言指針詳解（經典 非常詳細 通俗易懂）">C語言指針詳解（經典 非常詳細 通俗易懂）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc4c942.html alt=「鋼構知識」經典鋼結構設計問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc4c942.html title=「鋼構知識」經典鋼結構設計問答>「鋼構知識」經典鋼結構設計問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f6e1fd9.html alt=「鋼構知識」經典鋼結構設計問答彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/76195b1e9d934c2e952b060dad0951e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f6e1fd9.html title=「鋼構知識」經典鋼結構設計問答彙總>「鋼構知識」經典鋼結構設計問答彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html alt=經典設計延續至今的烏尼莫克403萬能卡車 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/132ba54553374c7eb2c0a9c155bba041 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html title=經典設計延續至今的烏尼莫克403萬能卡車>經典設計延續至今的烏尼莫克403萬能卡車</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0249bca7.html alt=民間經典名言「上」：仰不愧天，俯不愧地，那不愧心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/4000b541-b105-4302-8cc9-546a79e90ece style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0249bca7.html title=民間經典名言「上」：仰不愧天，俯不愧地，那不愧心>民間經典名言「上」：仰不愧天，俯不愧地，那不愧心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html alt=C語言經典100例004-統計各個年齡階段的人數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/98c4bb54-8d7e-4234-bf07-0d8190ba1a0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html title=C語言經典100例004-統計各個年齡階段的人數>C語言經典100例004-統計各個年齡階段的人數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51c6dcb7.html alt=經典分享：華為模擬集成電路設計講義 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ReTMiwsAymTebE style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51c6dcb7.html title=經典分享：華為模擬集成電路設計講義>經典分享：華為模擬集成電路設計講義</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>