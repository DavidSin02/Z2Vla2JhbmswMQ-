<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JAVA基礎——面向對象三大特性：封裝、繼承、多態 | 极客快訊</title><meta property="og:title" content="JAVA基礎——面向對象三大特性：封裝、繼承、多態 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/403f086d79124a40aab485ad48379757"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b298260.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b298260.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b298260.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b298260.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b298260.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b298260.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b298260.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b298260.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="JAVA基礎——面向對象三大特性：封裝、繼承、多態"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b298260.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JAVA基礎——面向對象三大特性：封裝、繼承、多態</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>一、封裝<br></p><p>1、概念：</p><p>將類的某些信息隱藏在類內部，不允許外部程序直接訪問，而是通過該類提供的方法來實現對隱藏信息的操作和訪問。</p><p><br></p><p>2、好處：</p><ul class=list-paddingleft-2><li>只能通過規定的方法訪問數據。</li><li>隱藏類的實例細節，方便修改和實現。</li></ul><p>　</p><p>3、封裝的實現步驟</p><p><br></p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/403f086d79124a40aab485ad48379757><p class=pgc-img-caption></p></div><p><strong>需要注意：</strong>對封裝的屬性不一定要通過get/set方法，其他方法也可以對封裝的屬性進行操作。當然最好使用get/set方法，比較標準。</p><p><br></p><p>A、訪問修飾符</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d1c8c8924e744a18ab57ca0f145771b5><p class=pgc-img-caption></p></div><p>從表格可以看出從上到下封裝性越來越差。</p><p><br></p><p>B、this關鍵字</p><p>1.this關鍵字代表當前對象</p><p>this.屬性 操作當前對象的屬性</p><p>this.方法 調用當前對象的方法。</p><p>2.封裝對象的屬性的時候，經常會使用this關鍵字。</p><p>3.當getter和setter函數參數名和成員函數名重合的時候，可以使用this區別。如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/573e2abcd61a4ae5aea1b03ecaf8971a><p class=pgc-img-caption></p></div><p><br></p><p>C、Java 中的內部類</p><p>內部類（ Inner Class ）就是定義在另外一個類裡面的類。與之對應，包含內部類的類被稱為外部類。</p><p>那麼問題來了：那為什麼要將一個類定義在另一個類裡面呢？清清爽爽的獨立的一個類多好啊！！</p><p><strong>答：內部類的主要作用如下：</strong></p><p>1. 內部類提供了更好的封裝，可以把內部類隱藏在外部類之內，不允許同一個包中的其他類訪問該類。</p><p>2. 內部類的方法可以直接訪問外部類的所有數據，包括私有的數據。</p><p>3. 內部類所實現的功能使用外部類同樣可以實現，只是有時使用內部類更方便。</p><p>內部類可分為以下幾種：</p><ul class=list-paddingleft-2><li>成員內部類</li><li>靜態內部類</li><li>方法內部類</li><li>匿名內部類　　</li></ul><p>二、繼承</p><p>1、繼承的概念</p><p>繼承是類與類的一種關係，是一種“is a”的關係。比如“狗”繼承“動物”，這裡動物類是狗類的父類或者基類，狗類是動物類的子類或者派生類。如下圖所示：<br></p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b7b95e19cdc6410785f02a2a7db953d3><p class=pgc-img-caption></p></div><p>注：java中的繼承是單繼承，即一個類只有一個父類。</p><p><br></p><p>2、繼承的好處</p><p>子類擁有父類的所有屬性和方法（除了private修飾的屬性不能擁有）從而實現了實現代碼的複用；　<br></p><p><br></p><p>3、語法規則，只要在子類加上extends關鍵字繼承相應的父類就可以了：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d66d18a40f0149b496c20a503e6c7e12><p class=pgc-img-caption></p></div><hr><p><br></p><p>A、方法的重寫</p><p>子類如果對繼承的父類的方法不滿意（不適合），可以自己編寫繼承的方法，這種方式就稱為方法的重寫。當調用方法時會優先調用子類的方法。</p><p><strong>重寫要注意：</strong></p><ol start=1><li>返回值類型</li><li>方法名</li><li>參數類型及個數</li></ol><p>都要與父類繼承的方法相同，才叫方法的重寫。</p><p>重載和重寫的區別：</p><p><strong>方法重載：</strong>在同一個類中處理不同數據的多個相同方法名的多態手段。</p><p><strong>方法重寫：</strong>相對繼承而言，子類中對父類已經存在的方法進行區別化的修改。</p><hr><p><br></p><p>B、繼承的初始化順序</p><p>1、初始化父類再初始化子類</p><p>2、先執行初始化對象中屬性，再執行構造方法中的初始化。</p><p>基於上面兩點，我們就知道實例化一個子類，java程序的執行順序是：</p><p>父類對象屬性初始化---->父類對象構造方法---->子類對象屬性初始化--->子類對象構造方法　　　</p><p>下面有個形象的圖：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de13d2bfe9864341a63e94ea97969f4a><p class=pgc-img-caption></p></div><hr><p><br></p><p>C、final關鍵字</p><p><br></p><p>使用final關鍵字做標識有“最終的”含義。</p><p>1. final 修飾類，則該類不允許被繼承。</p><p>2. final 修飾方法，則該方法不允許被覆蓋(重寫)。</p><p>3. final 修飾屬性，則該類的該屬性不會進行隱式的初始化，所以 該final 屬性的初始化屬性必須有值，或在構造方法中賦值(但只能選其一，且必須選其一，因為沒有默認值！)，且初始化之後就不能改了，只能賦值一次。</p><p>4. final 修飾變量，則該變量的值只能賦一次值，在聲明變量的時候才能賦值，即變為常量。</p><hr><p></p><p>D、super關鍵字</p><p>在對象的內部使用，可以代表父類對象。<br></p><p>1、訪問父類的屬性：super.age</p><p>2、訪問父類的方法：super.eat()</p><p><strong>super的應用：</strong></p><p>首先我們知道子類的構造的過程當中必須調用父類的構造方法。其實這個過程已經隱式地使用了我們的super關鍵字。</p><p>這是因為如果子類的構造方法中沒有顯示調用父類的構造方法，則系統默認調用父類無參的構造方法。</p><p>那麼如果自己用super關鍵字在子類裡調用父類的構造方法，則必須在子類的構造方法中的第一行。</p><p>要注意的是：如果子類構造方法中既沒有顯示調用父類的構造方法，而父類沒有無參的構造方法，則編譯出錯。</p><p>（補充說明，雖然沒有顯示聲明父類的無參的構造方法，系統會自動默認生成一個無參構造方法，但是，如果你聲明瞭一個有參的構造方法，而沒有聲明無參的構造方法，這時系統不會動默認生成一個無參構造方法，此時稱為父類有沒有無參的構造方法。）</p><hr><p><br></p><p>E、Object類</p><p>Object類是所有類的父類，如果一個類沒有使用extends關鍵字明確標識繼承另一個類，那麼這個類默認繼承Object類。<br></p><p>Object類中的方法，適合所有子類！！！</p><p>那麼Object類中有什麼主要的方法呢？</p><p><strong>1、toString()</strong></p><p>a. 在Object類裡面定義toString()方法的時候返回的對象的哈希code碼(對象地址字符串)。</p><p>我們可以發現，如果我們直接用System.out.print（對象）輸出一個對象，則運行結果輸出的是對象的對象地址字符串，也稱為哈希code碼。如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/11b3533ebeb44d68aaf786a98326002f><p class=pgc-img-caption></p></div><p>哈希碼是通過哈希算法生成的一個字符串，它是用來唯一區分我們對象的地址碼，就像我們的身份證一樣。　　</p><p>b. 可以通過重寫toString()方法表示出對象的屬性。</p><p>如果我們希望輸出一個對象的時候，不是它的哈希碼，而是它的各個屬性值，那我們可以通過重寫toString()方法表示出對象的屬性。</p><p><strong>2、equals()</strong></p><p>a、equals（）----返回值是布爾類型。</p><p>b、默認的情況下，比較的是對象的引用是否指向同一塊內存地址-------對象實例化時，即給對象分配內存空間，該內存空間的地址就是內存地址。使用方法如：dog.equals(dog2);</p><p>c、 如果是兩個對象，但想判斷兩個對象的屬性是否相同，則重寫equals（）方法。</p><p>以Dog類為例，重寫後的equals（）方法如下（當然你可以根據自己想比較的屬性來重寫，這裡我以age屬性是否相同來重寫equals（）方法）：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e5e085c694ed421380fb6cbb1a5f29b2><p class=pgc-img-caption></p></div><p>上面有四個判斷，它們的含義分別是：</p><p>1.判斷地址是否相同----if (this == obj)，相同則返回true</p><p>2.判斷對象是否為空----if (obj == null)，為空則返回false</p><p>3.getClass（）可以得到類對象，判斷類型是否一樣-----if (getClass() != obj.getClass())，不一樣則返回false</p><p>4.判斷屬性值是否一樣----if (age != other.age)，不一樣返回false</p><p>5.如果地址相同，對象不為空，類型一樣，屬性值一樣則返回true</p><p>這裡要注意的是，理解obj.getClass()得到的類對象和類的對象的區別，以下用圖形表示：<br></p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2ceef155fc614a7d92d2a3a2180d7849><p class=pgc-img-caption></p></div><p>可以看到，對於類對象我們關心它屬於哪個類，擁有什麼屬性和方法，比如我和你都是屬於“人”這個類對象；而類的對象則是一個類的實例化的具體的一個對象。比如我和你是兩個不同的人。</p><p>三、多態</p><p>面向對象的最後一個特性就是多態，那麼什麼是多態呢？多態就是對象的多種形態。<br></p><p>java裡的多態主要表現在兩個方面：</p><p><br></p><p>1.引用多態</p><p>父類的引用可以指向本類的對象；<br></p><p>父類的引用可以指向子類的對象；</p><p>這兩句話是什麼意思呢，讓我們用代碼來體驗一下，首先我們創建一個父類Animal和一個子類Dog，在主函數裡如下所示：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9c998afea3e0417c84b00b8ff8546027><p class=pgc-img-caption></p></div><p>注意：我們不能使用一個子類的引用來指向父類的對象，如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b4de0474fefa44e8a0ba7bbc92610476><p class=pgc-img-caption></p></div><p>。</p><p>這裡我們必須深刻理解引用多態的意義，才能更好記憶這種多態的特性。為什麼子類的引用不能用來指向父類的對象呢？我在這裡通俗給大家講解一下：就以上面的例子來說，我們能說“狗是一種動物”，但是不能說“動物是一種狗”，狗和動物是父類和子類的繼承關係，它們的從屬是不能顛倒的。當父類的引用指向子類的對象時，該對象將只是看成一種特殊的父類（裡面有重寫的方法和屬性），反之，一個子類的引用來指向父類的對象是不可行的！！</p><p><br></p><p>2.方法多態</p><p>根據上述創建的兩個對象：本類對象和子類對象，同樣都是父類的引用，當我們指向不同的對象時，它們調用的方法也是多態的。<br></p><p>創建本類對象時，調用的方法為本類方法；</p><p>創建子類對象時，調用的方法為子類重寫的方法或者繼承的方法；</p><p>使用多態的時候要注意：如果我們在子類中編寫一個獨有的方法（沒有繼承父類的方法），此時就不能通過父類的引用創建的子類對象來調用該方法！！！</p><p>注意：繼承是多態的基礎。</p><hr><p></p><p>A、引用類型轉換　</p><p>瞭解了多態的含義後，我們在日常使用多態的特性時經常需要進行引用類型轉換。<br></p><p>引用類型轉換：</p><p><strong>1. 向上類型轉換(隱式/自動類型轉換)，是小類型轉換到大類型。</strong></p><p>就以上述的父類Animal和一個子類Dog來說明，當父類的引用可以指向子類的對象時，就是向上類型轉換。如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0caa33cd38754eb88a5d786aa89d5949><p class=pgc-img-caption></p></div><p><strong>2. 向下類型轉換(強制類型轉換)，是大類型轉換到小類型(有風險,可能出現數據溢出)。</strong></p><p>將上述代碼再加上一行，我們再次將父類轉換為子類引用，那麼會出現錯誤，編譯器不允許我們直接這麼做，雖然我們知道這個父類引用指向的就是子類對象，但是編譯器認為這種轉換是存在風險的。如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/09fef3ab45d44d5fb28b17948e64c4f1><p class=pgc-img-caption></p></div><p>那麼我們該怎麼解決這個問題呢，我們可以在animal前加上（Dog）來強制類型轉換。如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfdbcc8722d5411b8875fb9b95e74d39><p class=pgc-img-caption></p></div><p>但是如果父類引用沒有指向該子類的對象，則不能向下類型轉換，雖然編譯器不會報錯，但是運行的時候程序會出錯，如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d10a9cd71fb8468d881bc1fb9055e4fb><p class=pgc-img-caption></p></div><p>其實這就是上面所說的子類的引用指向父類的對象，而強制轉換類型也不能轉換！！</p><p>還有一種情況是父類的引用指向其他子類的對象，則不能通過強制轉為該子類的對象。如：　　　</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7f59d6165b3b4499a0be2139b781e600><p class=pgc-img-caption></p></div><p>這是因為我們在編譯的時候進行了強制類型轉換，編譯時的類型是我們強制轉換的類型，所以編譯器不會報錯，而當我們運行的時候，程序給animal開闢的是Dog類型的內存空間，這與Cat類型內存空間不匹配，所以無法正常轉換。這兩種情況出錯的本質是一樣的，所以我們在使用強制類型轉換的時候要特別注意這兩種錯誤！！下面有個更安全的方式來實現向下類型轉換。。。。</p><p><strong>3. instanceof運算符，來解決引用對象的類型，避免類型轉換的安全性問題。</strong></p><p>instanceof是Java的一個二元操作符，和==，>，&lt;是同一類東東。由於它是由字母組成的，所以也是Java的保留關鍵字。它的作用是測試它左邊的對象是否是它右邊的類的實例，返回boolean類型的數據。</p><p>我們來使用instanceof運算符來規避上面的錯誤，代碼修改如下：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63ca42b4be1f4626b7a356f83527097e><p class=pgc-img-caption></p></div><p>利用if語句和instanceof運算符來判斷兩個對象的類型是否一致。</p><p>補充說明：在比較一個對象是否和另一個對象屬於同一個類實例的時候，我們通常可以採用instanceof和getClass兩種方法通過兩者是否相等來判斷，但是兩者在判斷上面是有差別的。Instanceof進行類型檢查規則是:你屬於該類嗎？或者你屬於該類的派生類嗎？而通過getClass獲得類型信息採用==來進行檢查是否相等的操作是嚴格的判斷,不會存在繼承方面的考慮；</p><p>總結：在寫程序的時候，如果要進行類型轉換，我們最好使用instanceof運算符來判斷它左邊的對象是否是它右邊的類的實例，再進行強制轉換。</p><hr><p><br></p><p>B、抽象類</p><p><br></p><p>定義：抽象類前使用abstract關鍵字修飾，則該類為抽象類。</p><p>使用抽象類要注意以下幾點：</p><p>1. 抽象類是約束子類必須有什麼方法，而並不關注子類如何實現這些方法。</p><p>2. 抽象類應用場景：</p><p>a. 在某些情況下，某個父類只是知道其子類應該包含怎樣的方法，但無法準確知道這些子類如何實現這些方法(可實現動態多態)。</p><p>b. 從多個具有相同特徵的類中抽象出一個抽象類，以這個抽象類作為子類的模板，從而避免子類設計的隨意性。</p><p>3. 抽象類定義抽象方法，只有聲明，不需要實現。抽象方法沒有方法體以分號結束，抽象方法必須用abstract關鍵字來修飾。如:　　</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/39de9e6f7da1415cbc11e2c834e15c77><p class=pgc-img-caption></p></div><p>4、包含抽象方法的類是抽象類。抽象類中可以包含普通的方法，也可以沒有抽象方法。如：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1c3ea06dec694033bffb2b0591201ce0><p class=pgc-img-caption></p></div><p>5、抽象類不能直接創建，可以定義引用變量來指向子類對象，來實現抽象方法。以上述的Telephone抽象類為例：　　　　　</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>public abstract class Telephone { public abstract void call();//抽象方法，方法體以分號結束，只有聲明，不需要實現 public void message(){ System.out.println("我是抽象類的普通方法"); }//抽象類中包含普通的方法}</pre><pre></pre><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>public class Phone extends Telephone { public void call() {//繼承抽象類的子類必須重寫抽象方法 // TODO Auto-generated method stub System.out.println("我重寫了抽象類的方法"); } }</pre><p>以上是Telephone抽象類和子類Phone的定義，下面我們看main函數裡：　　　</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0f20bf75ccdb4dd9b7838864be4f2e09><p class=pgc-img-caption></p></div><p>運行結果（排錯之後）：</p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/56fae00e2c6c44e892f658d8751703bc><p class=pgc-img-caption></p></div><hr><p><br></p><p>C、接口</p><p><strong>1、概念</strong><br></p><p>接口可以理解為一種特殊的類，由全局常量和公共的抽象方法所組成。也可理解為一個特殊的抽象類，因為它含有抽象方法。</p><p>如果說類是一種具體實現體，而接口定義了某一批類所需要遵守的規範，接口不關心這些類的內部數據，也不關心這些類裡方法的實現細節，它只規定這些類裡必須提供的某些方法。（這裡與抽象類相似）</p><p><strong>2.接口定義的基本語法</strong></p><p>　　　　　　[修飾符] [abstract] interface 接口名 [extends父接口1,2....]（多繼承）{</p><p>　　　　　　　　0…n常量 (public static final)</p><p>　　　　　　　　0…n 抽象方法(public abstract)</p><p>　　　　　　}</p><p>其中[ ]裡的內容表示可選項，可以寫也可以不寫;接口中的屬性都是常量，即使定義時不添加public static final 修飾符，系統也會自動加上；接口中的方法都是抽象方法，即使定義時不添加public abstract修飾符，系統也會自動加上。</p><p><strong>3.使用接口</strong></p><p>一個類可以實現一個或多個接口，實現接口使用implements關鍵字。java中一個類只能繼承一個父類，是不夠靈活的，通過實現多個接口可以補充。</p><p>繼承父類實現接口的語法為：</p><p>　　　　　[修飾符] class 類名 extends 父類 implements 接口1，接口2...{</p><p>　　　　　　　類體部分//如果繼承了抽象類，需要實現繼承的抽象方法；要實現接口中的抽象方法</p><p>　　　　　}</p><p>注意：如果要繼承父類，繼承父類必須在實現接口之前,即extends關鍵字必須在implements關鍵字前</p><p>補充說明：通常我們在命名一個接口時，經常以I開頭，用來區分普通的類。如：IPlayGame</p><p>以下我們來補充在上述抽象類中的例子，我們之前已經定義了一個抽象類Telephone和子類Phone，這裡我們再創建一個IPlayGame的接口，然後在原來定義的兩個類稍作修改，代碼如下：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>public interface IPlayGame { public void paly();//abstract 關鍵字可以省略，系統會自動加上 public String name="遊戲名字";//static final關鍵字可以省略，系統會自動加上}</pre><pre></pre><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>public class Phone extends Telephone implements IPlayGame{ public void call() {//繼承抽象類的子類必須重寫抽象方法 // TODO Auto-generated method stub System.out.println("我重寫了抽象類的方法"); } @Override public void paly() { // TODO Auto-generated method stub System.out.println("我重寫了接口的方法"); } }</pre><pre>public class train {  public static void main(String[] args) { // TODO Auto-generated method stub IPlayGame i=new Phone();//用接口的引用指向子類的對象 i.paly();//調用接口的方法 System.out.println(i.name);//輸出接口的常量 }}</pre><p>運行結果：<br></p><div class=pgc-img><img alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0ffa10c1351845f59d04694221aef7d0><p class=pgc-img-caption></p></div><p><strong>4.接口和匿名內部類配合使用</strong></p><p>接口在使用過程中還經常和匿名內部類配合使用。匿名內部類就是沒有沒名字的內部類，多用於關注實現而不關注實現類的名稱。</p><p><strong>語法格式：</strong></p><pre>Interface i =new interface(){ Public void method{ System.out.println(“利用匿名內部類實現接口1”); }};i.method();</pre><pre>還有一種寫法：（直接把方法的調用寫在匿名內部類的最後）</pre><pre>Interface i =new interface(){ Public void method{ System.out.println(“利用匿名內部類實現接口1”); }}.method();</pre><pre></pre><p>四、抽象類和接口的區</p><p>我們在多態的學習過程中認識到抽象類和接口都是實現java多態特性的關鍵部分，兩者都包含抽象方法，只關注方法的聲明而不關注方法的具體實現，那麼這兩者又有什麼區別呢？？我們在編寫java程序的時候又該如何抉擇呢？</p><p><strong>（1）語法層面上的區別</strong></p><p>1.一個類只能繼承一個抽象類，而一個類卻可以實現多個接口。<br>2.抽象類中的成員變量可以是各種類型的，而接口中的成員變量只能是public static final類型的；且必須給其初值，所以實現類中不能重新定義，也不能改變其值；抽象類中的變量默認是 friendly 型，其值可以在子類中重新定義，也可以重新賦值。<br>3.抽象類中可以有非抽象方法，接口中則不能有非抽象方法。<br>4.接口可以省略abstract 關鍵字，抽象類不能。<br>5.接口中不能含有靜態代碼塊以及靜態方法，而抽象類可以有靜態代碼塊和靜態方法；</p><p><strong>（2）設計層面上的區別</strong></p><p><strong>1）</strong>抽象類是對一種事物的抽象，即對類抽象，而接口是對行為的抽象。抽象類是對整個類整體進行抽象，包括屬性、行為，但是接口卻是對類局部（行為）進行抽象。舉個簡單的例子，飛機和鳥是不同類的事物，但是它們都有一個共性，就是都會飛。那麼在設計的時候，可以將飛機設計為一個類Airplane，將鳥設計為一個類Bird，但是不能將 飛行 這個特性也設計為類，因此它只是一個行為特性，並不是對一類事物的抽象描述。此時可以將 飛行 設計為一個接口Fly，包含方法fly( )，然後Airplane和Bird分別根據自己的需要實現Fly這個接口。然後至於有不同種類的飛機，比如戰鬥機、民用飛機等直接繼承Airplane即可，對於鳥也是類似的，不同種類的鳥直接繼承Bird類即可。從這裡可以看出，繼承是一個 "是不是"的關係，而 接口 實現則是 "有沒有"的關係。如果一個類繼承了某個抽象類，則子類必定是抽象類的種類，而接口實現則是有沒有、具備不具備的關係，比如鳥是否能飛（或者是否具備飛行這個特點），能飛行則可以實現這個接口，不能飛行就不實現這個接口。</p><p><strong>2）</strong>設計層面不同，抽象類作為很多子類的父類，它是一種模板式設計。而接口是一種行為規範，它是一種輻射式設計。什麼是模板式設計？最簡單例子，大家都用過ppt裡面的模板，如果用模板A設計了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它們的公共部分需要改動，則只需要改動模板A就可以了，不需要重新對ppt B和ppt C進行改動。而輻射式設計，比如某個電梯都裝了某種報警器，一旦要更新報警器，就必須全部更新。也就是說對於抽象類，如果需要添加新的方法，可以直接在抽象類中添加具體的實現，子類可以不進行變更；而對於接口則不行，如果接口進行了變更，則所有實現這個接口的類都必須進行相應的改動。</p><p>下面看一個網上流傳最廣泛的例子：門和警報的例子：門都有open( )和close( )兩個動作，此時我們可以定義通過抽象類和接口來定義這個抽象概念：</p><pre>abstract class Door { public abstract void open(); public abstract void close();}</pre><pre>或者：</pre><pre>interface Door { public abstract void open(); public abstract void close();}</pre><p>但是現在如果我們需要門具有報警alarm( )的功能，那麼該如何實現？下面提供兩種思路：</p><p><strong>1）</strong>將這三個功能都放在抽象類裡面，但是這樣一來所有繼承於這個抽象類的子類都具備了報警功能，但是有的門並不一定具備報警功能；</p><p><strong>2）</strong>將這三個功能都放在接口裡面，需要用到報警功能的類就需要實現這個接口中的open( )和close( )，也許這個類根本就不具備open( )和close( )這兩個功能，比如火災報警器。</p><p>從這裡可以看出， Door的open() 、close()和alarm()根本就屬於兩個不同範疇內的行為，open()和close()屬於門本身固有的行為特性，而alarm()屬於延伸的附加行為。因此最好的解決辦法是單獨將報警設計為一個接口，包含alarm()行為,Door設計為單獨的一個抽象類，包含open和close兩種行為。再設計一個報警門繼承Door類和實現Alarm接口。</p><pre>interface Alram { void alarm();} abstract class Door { void open(); void close();} class AlarmDoor extends Door implements Alarm { void oepn() { //.... } void close() { //.... } void alarm() { //.... }}</pre><p><br></p><hr><p><strong>最後我自己是一名從事了多年開發的JAVA老程序員，今年年初我花了一個月整理了一份最適合2019年學習的java學習乾貨，想分享給每一位喜歡java的小夥伴，需要獲取的可以關注我並在後臺私信我：01，即可免費領取。</strong></p><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JAVA</a></li><li><a>基礎</a></li><li><a>對象</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c301abde.html alt="UML - 建模基礎 - 對象分析方法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5c999adf5c814144b79f2fc7a7628420 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c301abde.html title="UML - 建模基礎 - 對象分析方法">UML - 建模基礎 - 對象分析方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html alt=JAVA：面向對象編程的底層邏輯，深度剖析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f7362955cbfb4eb0bb89b09491c5d9a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html title=JAVA：面向對象編程的底層邏輯，深度剖析>JAVA：面向對象編程的底層邏輯，深度剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c28975fa.html alt=JAVA基礎&繼承(上) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c28975fa.html title=JAVA基礎&繼承(上)>JAVA基礎&繼承(上)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91b4528.html alt=JAVA格物致知基礎篇：你所不知道的返回碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2903da41dc11495e9ff0316e913c9286 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91b4528.html title=JAVA格物致知基礎篇：你所不知道的返回碼>JAVA格物致知基礎篇：你所不知道的返回碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30afbab.html alt="JAVA進階 深入理解面向對象" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/83f04804597d4a2f8d6c18f54334b5ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30afbab.html title="JAVA進階 深入理解面向對象">JAVA進階 深入理解面向對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34766df.html alt="來談談JAVA面向對象 - 繼續說多態~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/58d42ac1398d4b5c873487092f8e5d05 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34766df.html title="來談談JAVA面向對象 - 繼續說多態~">來談談JAVA面向對象 - 繼續說多態~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f6d25f.html alt=JAVA面向對象程序設計之創建型設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/13ac656d-76b7-4249-91ea-92b30fb1b48b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f6d25f.html title=JAVA面向對象程序設計之創建型設計模式>JAVA面向對象程序設計之創建型設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/415b5df.html alt=JAVA面向對象程序設計之對象、類和封裝 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/77a25702-72bd-453c-b973-4d2daeb06d21 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/415b5df.html title=JAVA面向對象程序設計之對象、類和封裝>JAVA面向對象程序設計之對象、類和封裝</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa5c078.html alt=JAVA面向對象程序設計之結構型&行為型設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/29896a1aca91464587685c5edc2cf694 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa5c078.html title=JAVA面向對象程序設計之結構型&行為型設計模式>JAVA面向對象程序設計之結構型&行為型設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html alt=素描五官基礎知識，學素描的同學可參考 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99b7762898d34e2f9a667c431fc7da6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html title=素描五官基礎知識，學素描的同學可參考>素描五官基礎知識，學素描的同學可參考</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c480db6b.html alt=梯度，散度，旋度的重要基礎：對向量場的詮釋 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c8ce2cc3bb0f4a5da0dcbc0a881f9617 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c480db6b.html title=梯度，散度，旋度的重要基礎：對向量場的詮釋>梯度，散度，旋度的重要基礎：對向量場的詮釋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/40b3969a.html alt=專業音頻基礎概念｜數字音頻是如何工作的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3684bfc4e93447a5bdfd6d573beec22c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/40b3969a.html title=專業音頻基礎概念｜數字音頻是如何工作的？>專業音頻基礎概念｜數字音頻是如何工作的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3faa79.html alt=立體聲系統基礎篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15288739589536026ad6bae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3faa79.html title=立體聲系統基礎篇>立體聲系統基礎篇</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>