<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android 上哪個更好：除以 2 還是位移 1？ | 极客快訊</title><meta property="og:title" content="Android 上哪個更好：除以 2 還是位移 1？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/RzDApJ2446C0Cb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><meta property="article:published_time" content="2020-10-29T21:00:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:27+08:00"><meta name=Keywords content><meta name=description content="Android 上哪個更好：除以 2 還是位移 1？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b5d9acd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android 上哪個更好：除以 2 還是位移 1？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="Android 上哪個更好：除以 2 還是位移 1？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RzDApJ2446C0Cb><p>作者 | Jake Wharton</p><p>譯者 | 孫薇，責編 | 夕顏</p><p>頭圖 | CSDN下載自視覺中國</p><p>出品 | CSDN（ID:CSDNnews）</p><p><strong>以下為譯文：</strong></p><p>我一直在將AndroidX集合庫移植到Kotlin multiplatform上，以試驗二進制兼容性、性能、工具以及不同的內存模型。庫中的某些數據結構使用了基於數組的二叉樹來存儲元素。Java代碼中有大量位移來替代2的冪的乘除法。當移植到Kotlin之後，這些就成了略微有點彆扭的中綴運算符，導致代碼意圖進一步被混淆。</p><p>我找了些人來調查對按位移位（bitwise shifts）與乘除法的看法，很多人聽說過移位性能更好的傳聞，但每個人對其真實性仍持懷疑態度。一些人認為，代碼在CPU上運行之前所見過的一個編譯器可用來優化這個案例。</p><p>為了滿足我的好奇心（部分也是為了避免Kotlin的中綴按位運算符），我打算回答哪個更優的問題，以及一些相關的問題。那麼這就開始吧。</p><img alt="Android 上哪個更好：除以 2 還是位移 1？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p></p><h1 toutiao-origin=h3>有人優化嗎？</h1><p>在代碼進入CPU之前，主要經過三個編譯器：`javac`/`kotlinc`，D8/R8，以及ART。</p><img alt="Android 上哪個更好：除以 2 還是位移 1？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RzEPVHu8hK92pI><p>它們都有機會對代碼進行優化，但它們會這樣做嗎？</p><p></p><h1 toutiao-origin=h3>javac</h1><pre><code>class Example {</code><code> static int multiply(int value) {</code><code> return value * 2;</code><code> }</code><code> static int divide(int value) {</code><code> return value / 2;</code><code> }</code><code> static int shiftLeft(int value) {</code><code> return value &lt;&lt; 1;</code><code> }</code><code> static int shiftRight(int value) {</code><code> return value &gt;&gt; 1;</code><code> }</code><code>}</code></pre><p>可以使用JDK14中的javac來編譯這段Java代碼，並通過javap來顯示生成的字節碼。</p><pre><code>$ javac Example.java</code><code>$ javap -c Example</code><code>Compiled from "Example.java"</code><code>class Example {</code><code> static int multiply(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: imul</code><code> 3: ireturn</code><br><br><code> static int divide(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: idiv</code><code> 3: ireturn</code><br><br><code> static int shiftLeft(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishl</code><code> 3: ireturn</code><br><br><code> static int shiftRight(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishr</code><code> 3: ireturn</code></pre><p>以 `iload_0` 開頭的每個方法會加載第一個實參值，之後乘法和除法都包含 `iconst_2` ，它們加載常量2，然後分別運行 `imul` 或者 `idiv` ，以執行整數乘法或整數除法。移位方法在`ishl`或`ishr`之前加載常量1，分別執行整數向左移位和整數向右移位。</p><p>這裡沒有優化，但如果你有對Java有所瞭解，就知道這並不意外。`javac`並不是一個優化編譯器，它將大部分工作留給了JVM上的運行時編譯器或者提前編譯器。</p><p></p><h1 toutiao-origin=h3>kotlinc</h1><pre><code>fun multiply(value: Int) = value * 2</code><code>fun divide(value: Int) = value / 2</code><code>fun shiftLeft(value: Int) = value shl 1</code><code>fun shiftRight(value: Int) = value shr 1</code></pre><p>使用Kotlin 1.4-M1中的`Kotlinc`將Kotlin編譯為Java字節碼，這樣`javap`工具就能再次使用。</p><pre><code>$ kotlinc Example.kt</code><code>$ javap -c ExampleKt</code><code>Compiled from "Example.kt"</code><code>public final class ExampleKt {</code><code> public static final int multiply(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: imul</code><code> 3: ireturn</code><br><br><code> public static final int divide(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: idiv</code><code> 3: ireturn</code><br><br><code> public static final int shiftLeft(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishl</code><code> 3: ireturn</code><br><br><code> public static final int shiftRight(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishr</code><code> 3: ireturn</code></pre><p>與Java的輸出結果完全一致。這是運用了Kotlin原始的JVM後端，但使用基於IR的後端（通過`-Xuse-ir`）也能產生同樣的輸出。</p><p></p><h1 toutiao-origin=h3>D8</h1><p>我們使用Kotlin示例中的Java字節碼輸出作為由 `master`（在文本撰寫時是SHA `2a2bf622d`）所構建的最新D8的輸入。</p><pre><code>$ java -jar $R8_HOME/build/libs/d8.jar \</code><code> --release \</code><code> --output . \</code><code> ExampleKt.class</code><code>$ dexdump -d classes.dex</code><code>Opened 'classes.dex', DEX version '035'</code><code>Class #0 -</code><code> Class descriptor : 'LExampleKt;'</code><code> Access flags : 0x0011 (PUBLIC FINAL)</code><code> Superclass : 'Ljava/lang/Object;'</code><code> Direct methods -</code><code> #0 : (in LExampleKt;)</code><code> name : 'divide'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000118: |[000118] ExampleKt.divide:(I)I</code><code>000128: db00 0102 |0000: div-int/lit8 v0, v1, #int 2 // #02</code><code>00012c: 0f00 |0002: return v0</code><br><br><code> #1 : (in LExampleKt;)</code><code> name : 'multiply'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000130: |[000130] ExampleKt.multiply:(I)I</code><code>000140: da00 0102 |0000: mul-int/lit8 v0, v1, #int 2 // #02</code><code>000144: 0f00 |0002: return v0</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000148: |[000148] ExampleKt.shiftLeft:(I)I</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1, #int 1 // #01</code><code>00015c: 0f00 |0002: return v0</code><br><br><code> #3 : (in LExampleKt;)</code><code> name : 'shiftRight'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000160: |[000160] ExampleKt.shiftRight:(I)I</code><code>000170: e100 0101 |0000: shr-int/lit8 v0, v1, #int 1 // #01</code><code>000174: 0f00 |0002: return </code><br></pre><p>(注：輸出略微修剪)</p><p>Dalvik字節碼是基於寄存器的，而不是像Java字節碼那樣基於堆棧。因此，每種方法只有一個實字節碼來執行相關的整數運算。每個寄存器都使用v1寄存器，也是第一個實參值，以及2或1的整型常量。</p><p>因此沒有更改行為，但D8也不是一個優化編輯器（儘管它可以執行局部方法的優化）。</p><p></p><h1 toutiao-origin=h3>R8</h1><p>要運行R8，我們需要定義一項規則，以防止我們的方法被刪除。</p><pre><code>-keep,allowoptimization class ExampleKt {</code><code> &lt;methods&gt;;</code><code>}</code></pre><p>這些規則通過 `--pg-conf` 來傳遞，我們還提供了Android API來鏈接使用 `--lib`。</p><pre><code>$ java -jar $R8_HOME/build/libs/r8.jar \</code><code> --lib $ANDROID_HOME/platforms/android-29/android.jar \</code><code> --release \</code><code> --pg-conf rules.txt \</code><code> --output . \</code><code> ExampleKt.class</code><code>$ dexdump -d classes.dex</code><code>Opened 'classes.dex', DEX version '035'</code><code>Class #0 -</code><code> Class descriptor : 'LExampleKt;'</code><code> Access flags : 0x0011 (PUBLIC FINAL)</code><code> Superclass : 'Ljava/lang/Object;'</code><code> Direct methods -</code><code> #0 : (in LExampleKt;)</code><code> name : 'divide'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000118: |[000118] ExampleKt.divide:(I)I</code><code>000128: db00 0102 |0000: div-int/lit8 v0, v1, #int 2 // #02</code><code>00012c: 0f00 |0002: return v0</code><br><br><code> #1 : (in LExampleKt;)</code><code> name : 'multiply'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000130: |[000130] ExampleKt.multiply:(I)I</code><code>000140: da00 0102 |0000: mul-int/lit8 v0, v1, #int 2 // #02</code><code>000144: 0f00 |0002: return v0</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000148: |[000148] ExampleKt.shiftLeft:(I)I</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1, #int 1 // #01</code><code>00015c: 0f00 |0002: return v0</code><br><br><code> #3 : (in LExampleKt;)</code><code> name : 'shiftRight'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000160: |[000160] ExampleKt.shiftRight:(I)I</code><code>000170: e100 0101 |0000: shr-int/lit8 v0, v1, #int 1 // #01</code><code>000174: 0f00 |0002: return </code></pre><p>與D8的輸出完全相同。</p><p></p><h1 toutiao-origin=h3>ART</h1><p>我們使用R8示例中的Dalvik字節碼輸出，作為在x86模擬器上的Android 10系統運行的ART的輸入。</p><pre><code>$ adb push classes.dex /sdcard/classes.dex</code><code>$ adb shell</code><code>generic_x86:/ $ su</code><code>generic_x86:/ # dex2oat --dex-file=/sdcard/classes.dex --oat-file=/sdcard/classes.oat</code><code>generic_x86:/ # oatdump --oat-file=/sdcard/classes.oat</code><code>OatDexFile:</code><code>0: LExampleKt; (offset=0x000003c0) (type_idx=1) (Initialized) (OatClassAllCompiled)</code><code> 0: int ExampleKt.divide(int) (dex_method_idx=0)</code><code> CODE: (code_offset=0x00001010 size_offset=0x0000100c size=15)...</code><code> 0x00001010: 89C8 mov eax, ecx</code><code> 0x00001012: 8D5001 lea edx, [eax + 1]</code><code> 0x00001015: 85C0 test eax, eax</code><code> 0x00001017: 0F4DD0 cmovnl/ge edx, eax</code><code> 0x0000101a: D1FA sar edx</code><code> 0x0000101c: 89D0 mov eax, edx</code><code> 0x0000101e: C3 ret</code><code> 1: int ExampleKt.multiply(int) (dex_method_idx=1)</code><code> CODE: (code_offset=0x00001030 size_offset=0x0000102c size=5)...</code><code> 0x00001030: D1E1 shl ecx</code><code> 0x00001032: 89C8 mov eax, ecx</code><code> 0x00001034: C3 ret</code><code> 2: int ExampleKt.shiftLeft(int) (dex_method_idx=2)</code><code> CODE: (code_offset=0x00001030 size_offset=0x0000102c size=5)...</code><code> 0x00001030: D1E1 shl ecx</code><code> 0x00001032: 89C8 mov eax, ecx</code><code> 0x00001034: C3 ret</code><code> 3: int ExampleKt.shiftRight(int) (dex_method_idx=3)</code><code> CODE: (code_offset=0x00001040 size_offset=0x0000103c size=5)...</code><code> 0x00001040: D1F9 sar ecx</code><code> 0x00001042: 89C8 mov eax, ecx</code><code> 0x00001044: C3 ret</code></pre><pre> (注意：輸出有大幅修剪)</pre><p>x86彙編顯示，ART確實介入並規範化了算術運算符以使用移位。</p><p>首先，現在`multiply`和`shiftLeft的`實現完全一致。它們都使用`shl`來執行向左按位移位1，此外如果查看文件夾中的偏移量（最左邊的列），會發現它們是完全一致的。ART認識到這些函數在編譯到x86彙編時具有相同的主體，並已經刪除了重複的數據。</p><p>下一步，儘管`divide`和`shiftRight`不一樣，其對`sar`的用法是一樣的，都是向右按位移位1，在`divide`中的四條附加指令通過給值加1，先於`sar`處理輸入為負的情況（註釋1）。</p><p>在Android 10系統的Pixel 4上運行相同的命令，會顯示ART如何將此代碼編譯到ARM彙編中（註釋2）。</p><pre><code>OatDexFile:</code><code>0: LExampleKt; (offset=0x000005a4) (type_idx=1) (Verified) (OatClassAllCompiled)</code><code> 0: int ExampleKt.divide(int) (dex_method_idx=0)</code><code> CODE: (code_offset=0x00001009 size_offset=0x00001004 size=10)...</code><code> 0x00001008: 0fc8 lsrs r0, r1, #31</code><code> 0x0000100a: 1841 adds r1, r0, r1</code><code> 0x0000100c: 1049 asrs r1, #1</code><code> 0x0000100e: 4608 mov r0, r1</code><code> 0x00001010: 4770 bx lr</code><code> 1: int ExampleKt.multiply(int) (dex_method_idx=1)</code><code> CODE: (code_offset=0x00001021 size_offset=0x0000101c size=4)...</code><code> 0x00001020: 0048 lsls r0, r1, #1</code><code> 0x00001022: 4770 bx lr</code><code> 2: int ExampleKt.shiftLeft(int) (dex_method_idx=2)</code><code> CODE: (code_offset=0x00001021 size_offset=0x0000101c size=4)...</code><code> 0x00001020: 0048 lsls r0, r1, #1</code><code> 0x00001022: 4770 bx lr</code><code> 3: int ExampleKt.shiftRight(int) (dex_method_idx=3)</code><code> CODE: (code_offset=0x00001031 size_offset=0x0000102c size=4)...</code><code> 0x00001030: 1048 asrs r0, r1, #1</code><code> 0x00001032: 4770 bx lr</code></pre><p>同樣，`multiply`和`shiftLeft`都使用`lsls`來執行向左位移，因此被去重了。`shiftRight`用`asrs`來執行向右位移。`divide`也使用`asrs`來執行向右位移，但它使用另一個向右位移`lsrs`來處理負值加一的操作（註釋3）。</p><p>這樣一來，我們現在可以肯定地說，用`value &lt;&lt; 1`來替代`value * 2`沒有任何好處，不要再為了算術運算而這麼做了，僅保留用於嚴格的按位運算。</p><p>然而，`value / 2` 和`value >> 1`仍會產生不同的彙編指令，因而可能具有不同的性能特徵。幸運的是，使用`value / 2`可避免使用通用除法，並且仍舊主要基於向右位移，因此它們在性能方面差異可能不大。</p><p></p><h1 toutiao-origin=h3>位移會比除法快一些嗎？</h1><p>為了確定除法快還是位移更快，我們可以使用Jetpack benchmark庫。</p><pre><code>class DivideOrShiftTest {</code><code> @JvmField @Rule val benchmark = BenchmarkRule</code><br><br><code> @Test fun divide {</code><code> val value = "4".toInt // Ensure not a constant.</code><code> var result = 0</code><code> benchmark.measureRepeated {</code><code> result = value / 2</code><code> }</code><code> println(result) // Ensure D8 keeps computation.</code><code> }</code><br><br><code> @Test fun shift {</code><code> val value = "4".toInt // Ensure not a constant.</code><code> var result = 0</code><code> benchmark.measureRepeated {</code><code> result = value shr 1</code><code> }</code><code> println(result) // Ensure D8 keeps computation.</code><code> }</code></pre><p>我沒有x86設備，但有一臺運行Android 10系統的基於ARM的Pixel 3，結果如下：</p><pre><code>android.studio.display.benchmark=4 ns DivideOrShiftTest.divide</code><code>count=4006</code><code>mean=4</code><code>median=4</code><code>min=4</code><code>standardDeviation=0</code><br><br><code>android.studio.display.benchmark=3 ns DivideOrShiftTest.shift</code><code>count=3943</code><code>mean=3</code><code>median=3</code><code>min=3</code><code>standardDeviation=0</code></pre><p>對如此小的數字使用除法或位移之間的區別幾近於無，畢竟差異太小了。使用負數顯示結果並無差異。</p><p>這樣一來，我們現在可以肯定，用`value >> 1`代替`value / 2`並無好處，不要再為算術運算這麼做了，僅保留用於嚴格的按位運算。</p><p></p><h1 toutiao-origin=h3>D8/R8能用這些信息來保存APK大小嗎？</h1><p>針對兩個操作相同的表達方式，我們應該選擇性能更佳的。但如果兩者性能相同的話，則應選擇APK更小的。</p><p>我們知道，ART中`value * 2`和`value &lt;&lt; 1`會產生相同的彙編，因此如果在Dalvik字節碼中，一個比另一個更省空間，我們應該無條件地以更小的形式將其重寫。查看D8中的輸出，它們產生的字節碼大小相同：</p><pre><code> #1 : (in LExampleKt;) name : 'multiply'</code><code> ⋮</code><code>000140: da00 0102 |0000: mul-int/lit8 v0, v1, #int 2 // #02</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> ⋮</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1, #int 1 // #01</code></pre><p>儘管使用2的冪沒有收益，但在移位以存儲常量值之前，乘法用完了字節碼空間，下面是`value * 32_768`與`value &lt;&lt; 15`的對比：</p><pre><code> #1 : (in LExampleKt;) name : 'multiply'</code><code> ⋮</code><code>000128: 1400 0080 0000 |0000: const v0, #float 0.000000 // #00008000</code><code>00012e: 9201 0100 |0003: mul-int v1, v1, v0</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> ⋮</code><code>00015c: e000 000f |0000: shl-int/lit8 v0, v0, #int 15 // #0f</code></pre><p>我在D8上提了個問題以調查如何自動優化此問題，但我強烈懷疑這種適用情況接近於零，因此很可能並不值得。</p><p>D8和R8的輸出也告訴我們，在Dalvik字節碼方面，`value / 2`和`value >> 1`的代價是相同的。</p><pre><code> #0 : (in LExampleKt;) name : 'divide'</code><code> ⋮</code><code>000128: db00 0102 |0000: div-int/lit8 v0, v1, #int 2 // #02</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> ⋮</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1,#int 1 // #01</code></pre><p>當常量達到32768時，其字節碼大小也會有所不同。無條件地將2的冪除法換成向右位移永遠不是安全的選項，這是因為負數的存在。如果能保證其值非負，那我們可以這樣替換，但此時D8和R8並不會追蹤可能的整數值範圍。</p><p></p><h1 toutiao-origin=h3>無符號的“2的冪除法”使用位移嗎？</h1><p>Java字節碼缺少無符號的數字，但使用符號的對應部分是可以模擬的。在Java中，有一些將符號類型當作無符號值運算的靜態輔助方法。Kotlin提供了類似 `UInt` 這樣的類型完成類似的功能，但在類型後完全抽象了。可以想象的是，當使用除以2的冪時，應當以移位方式重寫。</p><p>我們可以使用Kotlin來為兩種情況建模。</p><pre><code>fun javaLike(value: Int) = Integer.divideUnsigned(value, 2)</code><code>fun kotlinLike(value: UInt) = value / 2U</code></pre><p>在某些情況下，僅需考慮代碼的編譯方式。我們從普通的 `kotlinc`開始（還是從Kotlin 1.4-M1開始）。</p><pre><code>$ kotlinc Example.kt</code><code>$ javap -c ExampleKt</code><code>Compiled from "Example.kt"</code><code>public final class ExampleKt {</code><code> public static final int javaLike(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: invokestatic #12 // Method java/lang/Integer.divideUnsigned:(II)I</code><code> 5: ireturn</code><br><br><code> public static final int kotlinLike-WZ4Q5Ns(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: istore_1</code><code> 2: iconst_2</code><code> 3: istore_2</code><code> 4: iconst_0</code><code> 5: istore_3</code><code> 6: iload_1</code><code> 7: iload_2</code><code> 8: invokestatic #20 // Method kotlin/UnsignedKt."uintDivide-J1ME1BU":(II)I</code><code> 11: ireturn</code><code>}</code></pre><p>Kotlin無法將其識別為可使用`iushr`字節碼的“2的冪除法”，我提交了KT-38493以追蹤此行為的添加。</p><p>使用`-Xuse-ir`不會有任何改變（除非移除某些負載/存儲噪音），然而以Java 8為目標則會有變化。</p><pre><code>$ kotlinc -jvm-target 1.8 Example.kt</code><code>$ javap -c ExampleKt</code><code>Compiled from "Example.kt"</code><code>public final class ExampleKt {</code><code> public static final int javaLike(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: invokestatic #12 // Method java/lang/Integer.divideUnsigned:(II)I</code><code> 5: ireturn</code><br><br><code> public static final int kotlinLike-WZ4Q5Ns(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: invokestatic #12 // Method java/lang/Integer.divideUnsigned:(II)I</code><code> 5: ireturn</code><code>}</code></pre><p>`Integer.divideUnsigned`方法在Java 8中可以使用，因此在1.8或更高版本中較多使用，由於這會使得兩個函數體完全相同，我們還是返回舊輸出，對比看看會發生什麼。</p><p>接下來是R8，與上面調用明顯不同，我們將Kotlin stdlib作為輸入引入，同時由於 `Integer.divideUnsigned` 僅在API 24和更高版本中可用，也傳遞了`--min-api 24`。</p><pre><code>$ java -jar $R8_HOME/build/libs/r8.jar \</code><code> --lib $ANDROID_HOME/platforms/android-29/android.jar \</code><code> --min-api 24 \</code><code> --release \</code><code> --pg-conf rules.txt \</code><code> --output . \</code><code> ExampleKt.class kotlin-stdlib.jar</code><code>$ dexdump -d classes.dex</code><code>Opened 'classes.dex', DEX version '039'</code><code>Class #0 -</code><code> Class descriptor : 'LExampleKt;'</code><code> Access flags : 0x0011 (PUBLIC FINAL)</code><code> Superclass : 'Ljava/lang/Object;'</code><code> Direct methods -</code><code> #0 : (in LExampleKt;)</code><code> name : 'javaLike'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>0000f8: |[0000f8] ExampleKt.javaLike:(I)I</code><code>000108: 1220 |0000: const/4 v0, #int 2 // #2</code><code>00010a: 7120 0200 0100 |0001: invoke-static {v1, v0}, Ljava/lang/Integer;.divideUnsigned:(II)I // method@0002</code><code>000110: 0a01 |0004: move-result v1</code><code>000112: 0f01 |0005: return v1</code><br><br><code> #1 : (in LExampleKt;)</code><code> name : 'kotlinLike-WZ4Q5Ns'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000114: |[000114] ExampleKt.kotlinLike-WZ4Q5Ns:(I)I</code><code>000124: 8160 |0000: int-to-long v0, v6</code><code>000126: 1802 ffff ffff 0000 0000 |0001: const-wide v2, #double 0.000000 // #00000000ffffffff</code><code>000130: c020 |0006: and-long/2addr v0, v2</code><code>000132: 1226 |0007: const/4 v6, #int 2 // #2</code><code>000134: 8164 |0008: int-to-long v4, v6</code><code>000136: c042 |0009: and-long/2addr v2, v4</code><code>000138: be20 |000a: div-long/2addr v0, v2</code><code>00013a: 8406 |000b: long-to-int v6, v0</code><code>00013c: 0f06 |000c: return v6</code></pre><p>Kotlin有自己的無符號整數除法的實現方式，已經與我們的函數內聯。它會將輸入實參和常量轉化為longs，執行longs除法，然後再轉回整數。當我們最終通過ART來運行時，它們會轉成等效的x86，因此我們將保留此函數，這裡優化的機會已經失去了。</p><p>對於Java版本，R8無法將`divideUnsigned`調用替換成位移，我針對D8和R8提交了issue 154712996來跟蹤這個問題。</p><p>最後一個優化的機會是ART。</p><pre><code>$ adb push classes.dex /sdcard/classes.dex</code><code>$ adb shell</code><code>generic_x86:/ $ su</code><code>generic_x86:/ # dex2oat --dex-file=/sdcard/classes.dex --oat-file=/sdcard/classes.oat</code><code>generic_x86:/ # oatdump --oat-file=/sdcard/classes.oat</code><code>OatDexFile:</code><code>0: LExampleKt; (offset=0x000003c0) (type_idx=1) (Initialized) (OatClassAllCompiled)</code><code> 0: int ExampleKt.javaLike(int) (dex_method_idx=0)</code><code> CODE: (code_offset=0x00001010 size_offset=0x0000100c size=63)...</code><code> 0x00001010: 85842400E0FFFF test eax, [esp + -8192]</code><code> StackMap[0] (native_pc=0x1017, dex_pc=0x0, register_mask=0x0, stack_mask=0b)</code><code> 0x00001017: 55 push ebp</code><code> 0x00001018: 83EC18 sub esp, 24</code><code> 0x0000101b: 890424 mov [esp], eax</code><code> 0x0000101e: 6466833D0000000000 cmpw fs:[0x0], 0 ; state_and_flags</code><code> 0x00001027: 0F8519000000 jnz/ne +25 (0x00001046)</code><code> 0x0000102d: E800000000 call +0 (0x00001032)</code><code> 0x00001032: 5D pop ebp</code><code> 0x00001033: BA02000000 mov edx, 2</code><code> 0x00001038: 8B85CE0F0000 mov eax, [ebp + 4046]</code><code> 0x0000103e: FF5018 call [eax + 24]</code><code> StackMap[1] (native_pc=0x1041, dex_pc=0x1, register_mask=0x0, stack_mask=0b)</code><code> 0x00001041: 83C418 add esp, 24</code><code> 0x00001044: 5D pop ebp</code><code> 0x00001045: C3 ret</code><code> 0x00001046: 64FF15E0020000 call fs:[0x2e0] ; pTestSuspend</code><code> StackMap[2] (native_pc=0x104d, dex_pc=0x0, register_mask=0x0, stack_mask=0b)</code><code> 0x0000104d: EBDE jmp -34 (0x0000102d)</code><code> 1: int ExampleKt.kotlinLike-WZ4Q5Ns(int) (dex_method_idx=1)</code><code> CODE: (code_offset=0x00001060 size_offset=0x0000105c size=67)...</code><code> ⋮</code></pre><p>ART內化調用 `divideUnsigned`，因此我們讓機器跳至常規方法的實現。我提交了issue 154693569以跟蹤為無符號除法添加ART內化的問題。</p><p>好吧，這確實費了不少勁。恭喜你到達此步（或只是快速翻到這裡），我們總結一下：</p><ol><li><p>ART將2的冪乘法重寫為向左位移，將2的冪除法重寫為向右位移（通過一些額外的指令來處理負數）；</p></li><li><p>向右位移和2的冪除法之間沒有明顯的性能差異；</p></li><li><p>Dalvik字節碼中，位移和乘法/除法之間沒有大小差異；</p></li><li><p>截至目前還沒有人優化無簽名除法，但也許你也不會用到。</p></li></ol><p>通過以上事實，我們可以回答本文題目中提出的問題了：</p><blockquote><p>Android上哪個更好：除以2還是位移1？</p></blockquote><p>都不好！因此將除法用於算術運算中，對於真實的按位操作只使用位移，我會將AndroidX集合端口從位移切換到乘除法。下次見！</p><p>註釋：</p><p>1. 二進制中的-3為0b11111101，如果我們嘗試僅向右位移來實現除以2，結果是0b11111110，即-2，這是錯誤的結果。通過給-3加1，首先我們會得到-2，二進制表達是0b11111110，向右位移則得出0b11111111，也就是-1，這是正確的結果。</p><p>根據實際中的指令：</p><ul><li><p>`mov eax, ecx` 將原始輸入實參值保存在`eax`中；</p></li><li><p>`lea edx, [eax + 1]` 給輸入實參加1，並將結果存儲在`edx`中，即我們要位移的寄存器；</p></li><li><p>`test eax, eax`對自身的輸入實參進行按位操作，導致一些寄存器會根據輸入實參的屬性來設置；</p></li><li><p>之後`cmovnl/ge edx, eax`可能會基於`test`的結果，以`eax` (值)重寫`edx` (值+1)。</p></li></ul><p>之後指令會執行普通的向右位移，與 `(value &lt; 0 ? value + 1 : value) >> 1`. ↩基本相同。</p><p>2. 感謝Sergey Vasilinets提供的相關內容，`dex2oat`只能在現代Android版本中以root身份來運行，因此普通的Android（如在Pixel3上的）就無法運行。↩</p><p>3. 就實際指令而言：</p><ul><li><p>`lsrs r0, r1, #31` 對輸入實參進行邏輯（即不對符號進行擴展）31位的位移到`r0`，導致負數結果為1，正數結果為0。</p></li><li><p>`adds r1, r0, r1` 會將前一條指令的結果與輸入實參相加，實際上是給負值輸入加1。</p></li></ul><p>自此指令會執行普通的向右位移，基本上等同於`(value + (value >>> 31)) >> 1`。</p><p>原文鏈接：</p><p>https://jakewharton.com/which-is-better-on-android-divide-by-two-or-shift-by-one/</p><p>本文為CSDN翻譯文章，轉載請註明出處。</p><img alt="Android 上哪個更好：除以 2 還是位移 1？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R69FpRH4d90a7d><img alt="Android 上哪個更好：除以 2 還是位移 1？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rz2ij7Q6pwhZWh><pre><p>☞潘石屹 Python 考試成績 99 分，網友：還有一分怕你驕傲</p><pre><p>☞贈書 | 程序員修煉的務實哲學</p><p>☞JavaScript 流行度最高，Java 屈居第三！| 2020 最新軟件開發狀況報告</p><p>☞深度學習基礎總結，無一句廢話（附完整思維導圖）</p><p>☞震驚！阿里的程序員竟被一個簡單的 SQL 查詢難住了！</p><p>☞大學生程序員被勒索比特幣後，絕地反擊！</p></pre></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Android</a></li><li><a>哪個</a></li><li><a>還是</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/7697e301.html alt=退休夫妻同時患癌，還是中晚期！兩人每天都要吃一斤這種零食 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SB5GydOIYBAOWk style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7697e301.html title=退休夫妻同時患癌，還是中晚期！兩人每天都要吃一斤這種零食>退休夫妻同時患癌，還是中晚期！兩人每天都要吃一斤這種零食</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b6871ad.html alt=過度設計還是人性化設計，羅技雙模式滾輪拆解，你們怎麼看？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/51d58f282cad467fb9a443fd319a42f2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b6871ad.html title=過度設計還是人性化設計，羅技雙模式滾輪拆解，你們怎麼看？>過度設計還是人性化設計，羅技雙模式滾輪拆解，你們怎麼看？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/957be695.html alt=藍牙音頻編碼哪個音質好？今天我們來逐一解讀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4fb112ff23ef4c6091f6479a6d296bd4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/957be695.html title=藍牙音頻編碼哪個音質好？今天我們來逐一解讀>藍牙音頻編碼哪個音質好？今天我們來逐一解讀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/58db1e44.html alt=氣候宜人，美女如雲，卻不受美國待見。天堂還是地獄？波多黎各 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/90d01391696c491e990431b04ad16fd0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/58db1e44.html title=氣候宜人，美女如雲，卻不受美國待見。天堂還是地獄？波多黎各>氣候宜人，美女如雲，卻不受美國待見。天堂還是地獄？波多黎各</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17311768.html alt=獨立，還是成為美國的第51個州？美國海外領地波多黎各百年悲歌 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cc0c9b3ba3e8432399f778c9a84127cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17311768.html title=獨立，還是成為美國的第51個州？美國海外領地波多黎各百年悲歌>獨立，還是成為美國的第51個州？美國海外領地波多黎各百年悲歌</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ca3b7208.html alt=如何判斷彈性工作制對一家公司有害還是有利？拿成績說話 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/novel-images/130c80fb8dd039e1d0b1ec8e32d03fea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ca3b7208.html title=如何判斷彈性工作制對一家公司有害還是有利？拿成績說話>如何判斷彈性工作制對一家公司有害還是有利？拿成績說話</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c8f5463c.html alt=哪個品種的倉鼠最適合孩子養？有些倉鼠千萬別讓孩子碰 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3305a7878bb44c5985c44e51315d5eff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c8f5463c.html title=哪個品種的倉鼠最適合孩子養？有些倉鼠千萬別讓孩子碰>哪個品種的倉鼠最適合孩子養？有些倉鼠千萬別讓孩子碰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb2ea94b.html alt=單拐，拄患側還是健側？可別再繼續錯下去了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ca67e96a62534c49b681ef25750bd068 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb2ea94b.html title=單拐，拄患側還是健側？可別再繼續錯下去了>單拐，拄患側還是健側？可別再繼續錯下去了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bbf6eecc.html alt=你的戶型是「硬通貨」還是「鬼見愁」一篇看懂廈門 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bbb3c88bb1a741b08b5b5ddf9bfa0f0e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bbf6eecc.html title=你的戶型是「硬通貨」還是「鬼見愁」一篇看懂廈門>你的戶型是「硬通貨」還是「鬼見愁」一篇看懂廈門</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/81fc3180.html alt=血管瘤是平的還是凸的？濟南血管瘤醫院專家專業解答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RUgLHx99M99zBd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/81fc3180.html title=血管瘤是平的還是凸的？濟南血管瘤醫院專家專業解答>血管瘤是平的還是凸的？濟南血管瘤醫院專家專業解答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e25c8879.html alt=賣出還是買入，配股要怎麼操作，歡迎朋友們來討論！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/04e633e44210494b85fbd87da1acc8a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e25c8879.html title=賣出還是買入，配股要怎麼操作，歡迎朋友們來討論！>賣出還是買入，配股要怎麼操作，歡迎朋友們來討論！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ead682f.html alt=虹吸式馬桶好用還是直衝式馬桶好用？聽老師傅的話，不再糾結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/4128279b33c74517975ff7bcd7678baa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ead682f.html title=虹吸式馬桶好用還是直衝式馬桶好用？聽老師傅的話，不再糾結！>虹吸式馬桶好用還是直衝式馬桶好用？聽老師傅的話，不再糾結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00e69a4c.html alt=塔吊電梯標準節螺栓螺母在上還是下？問你為什麼你知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/0fb29da5-8754-4e03-803f-8e1a563d4a54 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00e69a4c.html title=塔吊電梯標準節螺栓螺母在上還是下？問你為什麼你知道嗎？>塔吊電梯標準節螺栓螺母在上還是下？問你為什麼你知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ff03bda.html alt=常用的辦公室文件櫃有哪些？哪個廠家生產的好？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1f7bbe97de154edcb49c7a20806bf845 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ff03bda.html title=常用的辦公室文件櫃有哪些？哪個廠家生產的好？>常用的辦公室文件櫃有哪些？哪個廠家生產的好？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56ae192f.html alt=在相對論中，長度是以距離還是空間在高速收縮的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d723c4e1f92143ad9b1912d4cec970fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56ae192f.html title=在相對論中，長度是以距離還是空間在高速收縮的？>在相對論中，長度是以距離還是空間在高速收縮的？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>