<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java 第三模塊 多線程面試題（未完待續） | 极客快訊</title><meta property="og:title" content="Java 第三模塊 多線程面試題（未完待續） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/45db8708c0654c589ac997d5f099041a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b63fb4a5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b63fb4a5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b63fb4a5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b63fb4a5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b63fb4a5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b63fb4a5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b63fb4a5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b63fb4a5.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="Java 第三模塊 多線程面試題（未完待續）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b63fb4a5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java 第三模塊 多線程面試題（未完待續）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>35. 並行和併發有什麼區別？</strong></h1><ul><li>並行是指兩個或者多個事件在同一時刻發生；而併發是指兩個或多個事件在同一時間間隔發生。</li><li>並行是在不同實體上的多個事件，併發是在同一實體上的多個事件。</li><li>在一臺處理器上“同時”處理多個任務，在多臺處理器上同時處理多個任務。如hadoop分佈式集群。</li></ul><p>所以併發編程的目標是充分的利用處理器的每一個核，以達到最高的處理性能。</p><h1><strong>36. 線程和進程的區別？</strong></h1><p>簡而言之，進程是程序運行和資源分配的基本單位，一個程序至少有一個進程，一個進程至少有一個線程。進程在執行過程中擁有獨立的內存單元，而多個線程共享內存資源，減少切換次數，從而效率更高。線程是進程的一個實體，是cpu調度和分派的基本單位，是比程序更小的能獨立運行的基本單位。同一進程中的多個線程之間可以併發執行。</p><h1><strong>37. 守護線程是什麼？</strong></h1><p>守護線程（即daemon thread），是個服務線程，準確地來說就是服務其他的線程。</p><h1><strong>38. 創建線程有哪幾種方式？</strong></h1><p>①. 繼承Thread類創建線程類</p><ul><li>定義Thread類的子類，並重寫該類的run方法，該run方法的方法體就代表了線程要完成的任務。因此把run()方法稱為執行體。</li><li>創建Thread子類的實例，即創建了線程對象。</li><li>調用線程對象的start()方法來啟動該線程。</li></ul><p>②. 通過Runnable接口創建線程類</p><ul><li>定義runnable接口的實現類，並重寫該接口的run()方法，該run()方法的方法體同樣是該線程的線程執行體。</li><li>創建 Runnable實現類的實例，並依此實例作為Thread的target來創建Thread對象，該Thread對象才是真正的線程對象。</li><li>調用線程對象的start()方法來啟動該線程。</li></ul><p>③. 通過Callable和Future創建線程</p><ul><li>創建Callable接口的實現類，並實現call()方法，該call()方法將作為線程執行體，並且有返回值。</li><li>創建Callable實現類的實例，使用FutureTask類來包裝Callable對象，該FutureTask對象封裝了該Callable對象的call()方法的返回值。</li><li>使用FutureTask對象作為Thread對象的target創建並啟動新線程。</li><li>調用FutureTask對象的get()方法來獲得子線程執行結束後的返回值。</li></ul><h1><strong>39. 說一下 runnable 和 callable 有什麼區別？</strong></h1><p>有點深的問題了，也看出一個Java程序員學習知識的廣度。</p><ul><li>Runnable接口中的run()方法的返回值是void，它做的事情只是純粹地去執行run()方法中的代碼而已；</li><li>Callable接口中的call()方法是有返回值的，是一個泛型，和Future、FutureTask配合可以用來獲取異步執行的結果。</li></ul><h1><strong>40. 線程有哪些狀態？</strong></h1><p>線程通常都有五種狀態，創建、就緒、運行、阻塞和死亡。</p><ul><li>創建狀態。在生成線程對象，並沒有調用該對象的start方法，這是線程處於創建狀態。</li><li>就緒狀態。當調用了線程對象的start方法之後，該線程就進入了就緒狀態，但是此時線程調度程序還沒有把該線程設置為當前線程，此時處於就緒狀態。在線程運行之後，從等待或者睡眠中回來之後，也會處於就緒狀態。</li><li>運行狀態。線程調度程序將處於就緒狀態的線程設置為當前線程，此時線程就進入了運行狀態，開始運行run函數當中的代碼。</li><li>阻塞狀態。線程正在運行的時候，被暫停，通常是為了等待某個時間的發生(比如說某項資源就緒)之後再繼續運行。sleep,suspend，wait等方法都可以導致線程阻塞。</li><li>死亡狀態。如果一個線程的run方法執行結束或者調用stop方法後，該線程就會死亡。對於已經死亡的線程，無法再使用start方法令其進入就緒</li></ul><h1><strong>41. sleep() 和 wait() 有什麼區別？</strong></h1><p>sleep()：方法是線程類（Thread）的靜態方法，讓調用線程進入睡眠狀態，讓出執行機會給其他線程，等到休眠時間結束後，線程進入就緒狀態和其他線程一起競爭cpu的執行時間。因為sleep() 是static靜態的方法，他不能改變對象的機鎖，當一個synchronized塊中調用了sleep() 方法，線程雖然進入休眠，但是對象的機鎖沒有被釋放，其他線程依然無法訪問這個對象。</p><p>wait()：wait()是Object類的方法，當一個線程執行到wait方法時，它就進入到一個和該對象相關的等待池，同時釋放對象的機鎖，使得其他線程能夠訪問，可以通過notify，notifyAll方法來喚醒等待的線程</p><h1><strong>42. notify()和 notifyAll()有什麼區別？</strong></h1><ul><li>如果線程調用了對象的 wait()方法，那麼線程便會處於該對象的等待池中，等待池中的線程不會去競爭該對象的鎖。</li><li>當有線程調用了對象的 notifyAll()方法（喚醒所有 wait 線程）或 notify()方法（只隨機喚醒一個 wait 線程），被喚醒的的線程便會進入該對象的鎖池中，鎖池中的線程會去競爭該對象鎖。也就是說，調用了notify後只要一個線程會由等待池進入鎖池，而notifyAll會將該對象等待池內的所有線程移動到鎖池中，等待鎖競爭。</li><li>優先級高的線程競爭到對象鎖的概率大，假若某線程沒有競爭到該對象鎖，它還會留在鎖池中，唯有線程再次調用 wait()方法，它才會重新回到等待池中。而競爭到對象鎖的線程則繼續往下執行，直到執行完了 synchronized 代碼塊，它會釋放掉該對象鎖，這時鎖池中的線程會繼續競爭該對象鎖。</li></ul><h1><strong>43. 線程的 run()和 start()有什麼區別？</strong></h1><p>每個線程都是通過某個特定Thread對象所對應的方法run()來完成其操作的，方法run()稱為線程體。通過調用Thread類的start()方法來啟動一個線程。</p><p>start()方法來啟動一個線程，真正實現了多線程運行。這時無需等待run方法體代碼執行完畢，可以直接繼續執行下面的代碼； 這時此線程是處於就緒狀態， 並沒有運行。 然後通過此Thread類調用方法run()來完成其運行狀態， 這裡方法run()稱為線程體，它包含了要執行的這個線程的內容， Run方法運行結束， 此線程終止。然後CPU再調度其它線程。</p><p>run()方法是在本線程裡的，只是線程裡的一個函數,而不是多線程的。 如果直接調用run(),其實就相當於是調用了一個普通函數而已，直接待用run()方法必須等待run()方法執行完畢才能執行下面的代碼，所以執行路徑還是隻有一條，根本就沒有線程的特徵，所以在多線程執行時要使用start()方法而不是run()方法。</p><h1><strong>44. 創建線程池有哪幾種方式？</strong></h1><p>①. newFixedThreadPool(int nThreads)</p><p>創建一個固定長度的線程池，每當提交一個任務就創建一個線程，直到達到線程池的最大數量，這時線程規模將不再變化，當線程發生未預期的錯誤而結束時，線程池會補充一個新的線程。</p><p>②. newCachedThreadPool()</p><p>創建一個可緩存的線程池，如果線程池的規模超過了處理需求，將自動回收空閒線程，而當需求增加時，則可以自動添加新線程，線程池的規模不存在任何限制。</p><p>③. newSingleThreadExecutor()</p><p>這是一個單線程的Executor，它創建單個工作線程來執行任務，如果這個線程異常結束，會創建一個新的來替代它；它的特點是能確保依照任務在隊列中的順序來串行執行。</p><p>④. newScheduledThreadPool(int corePoolSize)</p><p>創建了一個固定長度的線程池，而且以延遲或定時的方式來執行任務，類似於Timer。</p><h1><strong>45. 線程池都有哪些狀態？</strong></h1><p>線程池有5種狀態：Running、ShutDown、Stop、Tidying、Terminated。</p><p>線程池各個狀態切換框架圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 第三模塊 多線程面試題（未完待續）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45db8708c0654c589ac997d5f099041a><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><h1><strong>46. 線程池中 submit()和 execute()方法有什麼區別？</strong></h1><ul><li>接收的參數不一樣</li><li>submit有返回值，而execute沒有</li><li>submit方便Exception處理</li></ul><h1><strong>47. 在 java 程序中怎麼保證多線程的運行安全？</strong></h1><p>線程安全在三個方面體現：</p><ul><li>原子性：提供互斥訪問，同一時刻只能有一個線程對數據進行操作，（atomic,synchronized）；</li><li>可見性：一個線程對主內存的修改可以及時地被其他線程看到，（synchronized,volatile）；</li><li>有序性：一個線程觀察其他線程中的指令執行順序，由於指令重排序，該觀察結果一般雜亂無序，（happens-before原則）。</li></ul><h1><strong>48. 多線程鎖的升級原理是什麼？</strong></h1><p>在Java中，鎖共有4種狀態，級別從低到高依次為：無狀態鎖，偏向鎖，輕量級鎖和重量級鎖狀態，這幾個狀態會隨著競爭情況逐漸升級。鎖可以升級但不能降級。</p><p>鎖升級的圖示過程：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 第三模塊 多線程面試題（未完待續）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/edbe68d6579b4890adc802835c741317><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><h1><strong>49. 什麼是死鎖？</strong></h1><p>死鎖是指兩個或兩個以上的進程在執行過程中，由於競爭資源或者由於彼此通信而造成的一種阻塞的現象，若無外力作用，它們都將無法推進下去。此時稱系統處於死鎖狀態或系統產生了死鎖，這些永遠在互相等待的進程稱為死鎖進程。是操作系統層面的一個錯誤，是進程死鎖的簡稱，最早在 1965 年由 Dijkstra 在研究銀行家算法時提出的，它是計算機操作系統乃至整個併發程序設計領域最難處理的問題之一。</p><h1><strong>50. 怎麼防止死鎖？</strong></h1><p>死鎖的四個必要條件：</p><ul><li>互斥條件：進程對所分配到的資源不允許其他進程進行訪問，若其他進程訪問該資源，只能等待，直至佔有該資源的進程使用完成後釋放該資源</li><li>請求和保持條件：進程獲得一定的資源之後，又對其他資源發出請求，但是該資源可能被其他進程佔有，此事請求阻塞，但又對自己獲得的資源保持不放</li><li>不可剝奪條件：是指進程已獲得的資源，在未完成使用之前，不可被剝奪，只能在使用完後自己釋放</li><li>環路等待條件：是指進程發生死鎖後，若干進程之間形成一種頭尾相接的循環等待資源關係</li></ul><p>這四個條件是死鎖的必要條件，只要系統發生死鎖，這些條件必然成立，而只要上述條件之 一不滿足，就不會發生死鎖。</p><p>理解了死鎖的原因，尤其是產生死鎖的四個必要條件，就可以最大可能地避免、預防和 解除死鎖。</p><p>所以，在系統設計、進程調度等方面注意如何不讓這四個必要條件成立，如何確 定資源的合理分配算法，避免進程永久佔據系統資源。</p><p>此外，也要防止進程在處於等待狀態的情況下佔用資源。因此，對資源的分配要給予合理的規劃。</p><h1><strong>51. ThreadLocal 是什麼？有哪些使用場景？</strong></h1><p>線程局部變量是侷限於線程內部的變量，屬於線程自身所有，不在多個線程間共享。Java提供ThreadLocal類來支持線程局部變量，是一種實現線程安全的方式。但是在管理環境下（如 web 服務器）使用線程局部變量的時候要特別小心，在這種情況下，工作線程的生命週期比任何應用變量的生命週期都要長。任何線程局部變量一旦在工作完成後沒有釋放，Java 應用就存在內存洩露的風險。</p><h1><strong>52.說一下 synchronized 底層實現原理？</strong></h1><p>synchronized可以保證方法或者代碼塊在運行時，同一時刻只有一個方法可以進入到臨界區，同時它還可以保證共享變量的內存可見性。</p><p>Java中每一個對象都可以作為鎖，這是synchronized實現同步的基礎：</p><ul><li>普通同步方法，鎖是當前實例對象</li><li>靜態同步方法，鎖是當前類的class對象</li><li>同步方法塊，鎖是括號裡面的對象</li></ul><h1><strong>53. synchronized 和 volatile 的區別是什麼？</strong></h1><ul><li>volatile本質是在告訴jvm當前變量在寄存器（工作內存）中的值是不確定的，需要從主存中讀取； synchronized則是鎖定當前變量，只有當前線程可以訪問該變量，其他線程被阻塞住。</li><li>volatile僅能使用在變量級別；synchronized則可以使用在變量、方法、和類級別的。</li><li>volatile僅能實現變量的修改可見性，不能保證原子性；而synchronized則可以保證變量的修改可見性和原子性。</li><li>volatile不會造成線程的阻塞；synchronized可能會造成線程的阻塞。</li><li>volatile標記的變量不會被編譯器優化；synchronized標記的變量可以被編譯器優化。</li></ul><h1><strong>54. synchronized 和 Lock 有什麼區別？</strong></h1><ul><li>首先synchronized是java內置關鍵字，在jvm層面，Lock是個java類；</li><li>synchronized無法判斷是否獲取鎖的狀態，Lock可以判斷是否獲取到鎖；</li><li>synchronized會自動釋放鎖(a 線程執行完同步代碼會釋放鎖 ；b 線程執行過程中發生異常會釋放鎖)，Lock需在finally中手工釋放鎖（unlock()方法釋放鎖），否則容易造成線程死鎖；</li><li>用synchronized關鍵字的兩個線程1和線程2，如果當前線程1獲得鎖，線程2線程等待。如果線程1阻塞，線程2則會一直等待下去，而Lock鎖就不一定會等待下去，如果嘗試獲取不到鎖，線程可以不用一直等待就結束了；</li><li>synchronized的鎖可重入、不可中斷、非公平，而Lock鎖可重入、可判斷、可公平（兩者皆可）；</li><li>Lock鎖適合大量同步的代碼的同步問題，synchronized鎖適合代碼少量的同步問題。</li></ul><h1><strong>55. synchronized 和 ReentrantLock 區別是什麼？</strong></h1><p>synchronized是和if、else、for、while一樣的關鍵字，ReentrantLock是類，這是二者的本質區別。既然ReentrantLock是類，那麼它就提供了比synchronized更多更靈活的特性，可以被繼承、可以有方法、可以有各種各樣的類變量，ReentrantLock比synchronized的擴展性體現在幾點上：</p><ul><li>ReentrantLock可以對獲取鎖的等待時間進行設置，這樣就避免了死鎖</li><li>ReentrantLock可以獲取各種鎖的信息</li><li>ReentrantLock可以靈活地實現多路通知</li></ul><p>另外，二者的鎖機制其實也是不一樣的:ReentrantLock底層調用的是Unsafe的park方法加鎖，synchronized操作的應該是對象頭中mark word。</p><h1><strong>56. 說一下 atomic 的原理？</strong></h1><p>Atomic包中的類基本的特性就是在多線程環境下，當有多個線程同時對單個（包括基本類型及引用類型）變量進行操作時，具有排他性，即當多個線程同時對該變量的值進行更新時，僅有一個線程能成功，而未成功的線程可以向自旋鎖一樣，繼續嘗試，一直等到執行成功。</p><p>Atomic系列的類中的核心方法都會調用unsafe類中的幾個本地方法。我們需要先知道一個東西就是Unsafe類，全名為：sun.misc.Unsafe，這個類包含了大量的對C代碼的操作，包括很多直接內存分配以及原子操作的調用，而它之所以標記為非安全的，是告訴你這個裡面大量的方法調用都會存在安全隱患，需要小心使用，否則會導致嚴重的後果，例如在通過unsafe分配內存的時候，如果自己指定某些區域可能會導致一些類似C++一樣的指針越界到其他進程的問題。</p><hr><pre>感謝您的閱讀，如果您覺得閱讀本文對您有幫助，請點一下“關注，點贊和轉發”按鈕。本文歡迎各位轉發!</pre><p>分類: Java筆試</p><p>標籤:Java 第三模塊 多線程面試題（未完待續）</p><p>好文要頂 關注我 收藏該文 ！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>模塊</a></li><li><a>多線</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d5ed9b10.html alt=掌上生活APP：積分模塊設計分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rj5TAZoAjFz5G2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d5ed9b10.html title=掌上生活APP：積分模塊設計分析>掌上生活APP：積分模塊設計分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>