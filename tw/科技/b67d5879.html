<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入解析Kotlin 泛型 | 极客快訊</title><meta property="og:title" content="深入解析Kotlin 泛型 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67d5879.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67d5879.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b67d5879.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67d5879.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67d5879.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b67d5879.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b67d5879.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67d5879.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="深入解析Kotlin 泛型"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b67d5879.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入解析Kotlin 泛型</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>閱讀前請點擊右上角“關注”，每天免費獲取Android知識解析及面試解答。Android架構解析，只做職場乾貨，完全免費分享！</strong></p><p>以下文章來源於Kotlin ，作者bennyhuo</p><h2 class=pgc-h-arrow-right>0. 引子</h2><p>Kotlin 100% 與 Java 兼容，所以拋開語言表面上面的種種特質之外，背後的語言邏輯或者說“靈魂”與 Java 總是想通的。本文只涉及 Kotlin Jvm，Kotlin Js、Kotlin Native 的具體實現可能有差異。</p><p>最近一段時間在網上發了一套 Kotlin 的入門視頻，涵蓋了基礎語法、面向對象、高階函數、DSL、協程等比較有特色的知識點，不過有朋友提出了疑問：這門課為什麼不專門講講泛型、反射和註解呢？</p><p>我最早聽到這個問題的時候，反應比較懵逼，因為我居然沒有感覺到 Kotlin 的反射、泛型特別是註解有專門學習的必要，因為他們跟 Java 實在是太像了。</p><p>實際上，從社區裡面學習 Kotlin 的朋友的反應來看，大家大多對於函數式的寫法，DSL，協程這些內容比較困惑，或者說不太適應，這與大家的知識結構是密切相關的，面向對象的東西大家很容易理解，因為就那麼點兒內容，你懂了 C++ 的面向對象，Java 的也很容易理解，Kotlin 的也就不在話下了；而你沒有接觸過 Lua 的狀態機，沒有接觸過 Python 的推導式，自然對於協程也就會覺得比較陌生。</p><p>所以我想說的是，泛型這東西，只要你對 Java 泛型有一定的認識，Kotlin 的泛型基本可以直接用。那我們這篇文章要幹嘛呢？只是做一個簡單的介紹啦，都很好理解的。</p><h2 class=pgc-h-arrow-right>1. 真·泛型和偽·泛型</h2><p>Java 的泛型大家肯定都知道了，1.5 之後才加入的，可以為類和方法分別定義泛型參數，就像下面這樣：</p><pre><code> public class Generics&lt;T&gt;{     private T t;     ...     public &lt;R&gt; R getResult(){         ...     }  } </code></pre><p>Kotlin 的寫法呢？完全一樣：</p><pre><code> class Generics&lt;T&gt;{     private val t: T     ...     fun &lt;R&gt; getResult(): R{         ...     }  } </code></pre><p>Java/Kotlin 的泛型實現採用了類型擦除的方式，這與 C# 的實現不同，後者是真·泛型，前者是偽·泛型。當然這麼說是從運行時的角度來看的，在編譯期，Java 的泛型對於語法的約束也是真實存在的，所以你願意的話，也可以管 Java 的泛型叫做編譯期真·泛型。</p><p>那麼什麼是真·泛型呢？我們給大家看一段 C# 的代碼：</p><pre><code> using System;  public class Program{     public static void Main(String[] args){         testGeneric&lt;string&gt;();     }      public static void testGeneric&lt;T&gt;(){          Console.WriteLine(typeof(T));      }  } </code></pre><p>testGeneric 的泛型參數 string 可以在運行時獲取到，儼然一個真實可用的類型啊。下面是輸出的結果：</p><pre><code> System.String </code></pre><p>那偽·泛型呢？如果同樣的代碼放到 Java 或者 Kotlin 當中，結果會怎樣呢？</p><pre><code> public static &lt;T&gt; void testGenerics(){      System.out.println(T.class);  } </code></pre><p>這段代碼無法編譯，因為 T 是個泛型參數，你不能用它去獲取 class 對象。為了更清楚地說明問題，我們看下下面的代碼：</p><pre><code> public static &lt;T&gt; T testGenerics(){      T t = null;      return t;  } </code></pre><p>編譯後的字節碼：</p><pre><code>   public static testGenerics()Ljava/lang/Object;     L0      LINENUMBER 13 L0      ACONST_NULL      ASTORE 0     L1      LINENUMBER 14 L1      ALOAD 0      ARETURN     L2      LOCALVARIABLE t Ljava/lang/Object; L1 L2 0      // signature TT;      // declaration: T      MAXSTACK = 1      MAXLOCALS = 1 </code></pre><p>我們看到，編譯之後 T 變成了 Object，簡單來說就相當於：</p><pre><code> public static Object testGenerics(){      Object t = null;      return t;  } </code></pre><p>這就是傳說中的類型擦除了。而 Kotlin 在 JVM 之上，編譯之後也是字節碼，機制與 Java 是一樣的。也正是因為這個原因，我們在使用 Gson 反序列化對象的時候除了制定泛型參數，還需要傳入一個 class ：</p><pre><code> public &lt;T&gt; T fromJson(String json, Class&lt;T&gt; classOfT) throws JsonSyntaxException {     ...  } </code></pre><p>顯然 Gson 沒有辦法根據 T 直接去反序列化。</p><p>下面我們說一點兒不太一樣的。在 Kotlin 當中有一個關鍵字叫做 reified，還有一個叫做 inline，後者可以將函數定義為內聯函數，前者可以將內聯函數的泛型參數當做真實類型使用，我們先來看例子：</p><pre><code> inline fun &lt;reified T&gt; Gson.fromJson(json: String): T{      return fromJson(json, T::class.java)  } </code></pre><p>這是一個 Gson 的擴展方法，有了這個之後我們就無須在 Kotlin 當中顯式的傳入一個 class 對象就可以直接反序列化 json 了。</p><p>這個會讓人感覺到有點兒迷惑，實際上由於是內聯的方法調用，T 的類型在編譯時就可以確定的：</p><pre><code> class Person(var id: Int, var name: String)  fun test(){      val person: Person = Gson().fromJson(&#34;&#34;&#34;{&#34;id&#34;: 0, &#34;name&#34;: &#34;Jack&#34; }&#34;&#34;&#34;)  } </code></pre><p>反編譯之後：</p><pre><code> public static final void test() {    Gson $receiver$iv = new Gson();    String json$iv = &#34;{\&#34;id\&#34;: 0, \&#34;name\&#34;: \&#34;Jack\&#34; }&#34;;    Person person = (Person)$receiver$iv.fromJson(json$iv, Person.class);  } </code></pre><p><strong>注意，在這裡，inline 是必須的。</strong></p><h2 class=pgc-h-arrow-right>2. 型變</h2><h3 class=pgc-h-arrow-right>2.1 Java 的型變</h3><p>如果 Parent 是 Child 的父類，那麼 List&lt;Parent> 和 List&lt;Child> 的關係是什麼呢？對於 Java 來說，沒有關係。</p><p>也就是說下面的代碼是無法編譯的：</p><pre><code> List&lt;Number&gt; numbers = new ArrayList&lt;Integer&gt;(); //ERROR! </code></pre><p>不過 numbers 中可以添加 Number 類型的對象，所以我添加個 Integer 可以不呢？可以的：</p><pre><code> numbers.add(1); </code></pre><p>那麼我要想添加一堆 Integer 呢？用 addAll 是吧？注意看下 addAll 的簽名：</p><pre><code> boolean addAll(Collection&lt;? extends E&gt; c); </code></pre><p>這個泛型參數又是什麼鬼？如果我把這個簽名寫成下面這樣：</p><pre><code> boolean addAll(Collection&lt;E&gt; c); </code></pre><p>我想要在 numbers 當中 addAll 一個 ArrayList&lt;Integer>，那就不可能了，因為我們說過，ArrayList&lt;Number> 和 ArrayList&lt;Integer> 是兩個不同的類型，毛關係都沒有。</p><p>? extends E 其實就是使用點協變，允許傳入的參數可以是泛型參數類型為 Number 子類的任意類型。</p><p>當然，也有 ? super E 的用法，這表示元素類型為 E 及其父類，這個通常也叫作逆變。</p><h3 class=pgc-h-arrow-right>2.2 Kotlin 的型變</h3><blockquote><p>型變包括協變、逆變、不變三種。</p></blockquote><p>下面我們看看 Kotlin 是怎麼支持這個特性的。Kotlin 支持聲明點型變，我們直接看 Collection 接口的定義：</p><pre><code> public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; {     ...  } </code></pre><p>out E 就是型變的定義，表明 Collection 的元素類型是協變的，即 Collection&lt;Number> 也是 Collection&lt;Int> 的父類。</p><p>而對於 MutableList 來說，它的元素類型就是不變的：</p><pre><code> public interface MutableCollection&lt;E&gt; : Collection&lt;E&gt;, MutableIterable&lt;E&gt; {     ...     public fun addAll(elements: Collection&lt;E&gt;): Boolean     ...  } </code></pre><p>換言之，MutableCollection&lt;Number> 與</p><p>MutableCollection&lt;Int> 沒有什麼關係。</p><p>那麼請注意看 addAll 的聲明，參數是 Collection&lt;E>，而 Collection 是協變的，所以傳入的參數可以是任意 E 或者其子類的集合。</p><p>逆變的寫法也簡單一些： Collection&lt;in E>。</p><p>那麼 Kotlin 是否支持使用點型變呢？當然支持。</p><p>我們剛才說 MutableCollection 是不變的，那麼如果下面的參數改成這樣：</p><pre><code> public fun addAll(elements: MutableCollection&lt;E&gt;): Boolean </code></pre><p>結果就是，當 E 為 Number 時，addAll 無法接類受似 ArrayList&lt;Int> 的參數。而為了接受這樣的參數，我們可以修改一下簽名：</p><pre><code> public fun addAll(elements: MutableCollection&lt;out E&gt;): Boolean </code></pre><p>這其實就與 Java 的型變完全一致了。</p><h3 class=pgc-h-arrow-right>2.3 @UnsafeVariance</h3><p>型變是一個讓人費解的話題，很多人接觸這東西的時候一開始都會比較暈，我們來看看下面的例子：</p><pre><code> class MyCollection&lt;out T&gt;{      fun add(t: T){ // ERROR!         ...      }  } </code></pre><p>為什麼會報錯呢？因為 T 是協變的，所以外部傳入的參數類型如果是 T 的話，會出問題，不信你看：</p><pre><code> var myList: MyCollection&lt;Number&gt; = MyCollection&lt;Int&gt;()  myList.add(3.0) </code></pre><p>上面的代碼毫無疑問可以編譯，但運行時就會比較尷尬，因為 MyCollection&lt;Int> 希望接受的是 Int，沒想到來了一個 Double。。</p><p>對於協變的類型，通常我們是不允許將泛型類型作為傳入參數的類型的，或者說，對於協變類型，我們通常是不允許其涉及泛型參數的部分被改變的。這也很容易解釋為什麼 MutableCollection 是不變的，而 Collection 是協變的，因為在 Kotlin 當中，前者是可被修改的，後者是不可被修改的。</p><p>逆變的情形正好相反，即不可以將泛型參數作為方法的返回值。</p><p>但實際上有些情況下，我們不得已需要在協變的情況下使用泛型參數類型作為方法參數的類型：</p><pre><code> public interface Collection&lt;out E&gt; : Iterable&lt;E&gt; {     ...      public operator fun contains(element: @UnsafeVariance E): Boolean     ...  } </code></pre><p>比如這種情形，為了讓編譯器放過一馬，我們就可以用 @UnsafeVariance 來告訴編譯器：“我知道我在幹啥，保證不會出錯，你不用擔心”。</p><p>最後再給大家提一個點，現在你們知道為什麼 in 表示逆變，out 表示協變了嗎？</p><h2 class=pgc-h-arrow-right>3. 通配符</h2><p>在Java 中，當我們不知道泛型具體類型的時候可以用 ？來代替具體的類型來使用，比如下面的寫法：</p><pre><code> Class&lt;?&gt; cls = numbers.getClass(); </code></pre><p>Kotlin 也可以有類似的寫法：</p><pre><code> val cls: Class&lt;*&gt; = list.javaClass  val cls2: Class&lt;*&gt; = List::class.java </code></pre><p>Kotlin 可以根據 * 所指代的泛型參數進行相應的映射，下面是官方的說法：</p><ul><li>對於 Foo &lt;out T>，其中 T 是一個具有上界 TUpper 的協變類型參數，Foo &lt;*> 等價於 Foo &lt;out TUpper>。 這意味著當 T 未知時，你可以安全地從 Foo &lt;*> 讀取 TUpper 的值。</li><li>對於 Foo &lt;in T>，其中 T 是一個逆變類型參數，Foo &lt;*> 等價於 Foo &lt;in Nothing>。 這意味著當 T 未知時，沒有什麼可以以安全的方式寫入 Foo &lt;*>。</li><li>對於 Foo &lt;T>，其中 T 是一個具有上界 TUpper 的不型變類型參數，Foo&lt;*> 對於讀取值時等價於 Foo&lt;out TUpper> 而對於寫值時等價於 Foo&lt;in Nothing>。</li></ul><p>那麼 * 在哪些場合下可以或者不可以使用呢？</p><p>我們來看幾個例子：</p><pre><code> val list = ArrayList&lt;*&gt;()// ERROR! </code></pre><p>* 不允許作為函數和變量的類型的泛型參數！</p><pre><code> fun &lt;T&gt; hello(args: Array&lt;T&gt;){      ...  }  ...  hello&lt;*&gt;(args) // ERROR!! </code></pre><p>* 不允許作為函數和變量的類型的泛型參數！</p><pre><code> interface Foo&lt;T&gt;  class Bar : Foo&lt;*&gt; // ERROR! </code></pre><p>* 不能直接作為父類的泛型參數傳入！</p><pre><code> interface Foo&lt;T&gt;  class Bar : Foo&lt;Foo&lt;*&gt;&gt; </code></pre><p>這是正確的。注意，儘管 * 不能直接作為類的泛型參數，Foo&lt;*> 卻可以，按照前面官方給出的說法，它在讀時等價於Foo&lt;out Any> 寫時等價於 Foo&lt;in Nothing></p><pre><code> fun hello(args: Array&lt;*&gt;){      ...  } </code></pre><p>同樣，這表示接受的參數的類型在讀寫時分別等價於Array&lt;out Any> 和 Array&lt;in Nothing></p><h2 class=pgc-h-arrow-right>4. 其他</h2><h3 class=pgc-h-arrow-right>4.1 Raw 類型</h3><p>Raw 類型就是對於定義時有泛型參數要求，但在使用時指定泛型參數的情況，這個只在 Java 中有，顯然也是為了前向兼容而已。</p><p>例如：</p><pre><code> List list = new ArrayList(); </code></pre><p>這類用法在 Kotlin 當中是不被允許的。上面的代碼大致相當於：</p><pre><code> val list = ArrayList&lt;Any?&gt;() </code></pre><p>不過，在 Java 中，raw 類型可以有這種寫法：</p><pre><code> List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();  List list = new ArrayList();  list = integers; </code></pre><p>但 Kotlin 中，單純的 ArrayList&lt;Any?> 並不是協變的，所以下面的寫法是錯誤的：</p><pre><code> var list = ArrayList&lt;Any?&gt;()  val integers = ArrayList&lt;Int&gt;()  list = integers // ERROR! </code></pre><p>Java，你這樣做很危險呀。</p><h3 class=pgc-h-arrow-right>4.2 泛型邊界</h3><p>在 Java 中，我們同樣可以用 extends 為泛型參數指定上限：</p><pre><code> class NumberFormatter&lt;T extends Number&gt;{     ...  } </code></pre><p>這表示使用時，泛型參數必須是 Number 及其子類的一種。</p><p>而在 Kotlin 中，寫法與繼承類似：</p><pre><code> class NumberFormatter&lt;T: Number&gt;{     ...  } </code></pre><p>如果有多個上界，那麼：</p><pre><code> class NumberFormatter&lt;T&gt; where T: Number, T: Cloneable{     ...  } </code></pre><h2 class=pgc-h-arrow-right>5. 小結</h2><p>通過上面的討論，其實大家會發現 Kotlin 的泛型相比 Java 有了更嚴格的約束，更簡潔的表述，更靈活的配置，但背後的思路和具體的實現總體來說是一致的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Kotlin</a></li><li><a>泛型</a></li><li><a>解析</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html alt=解析橋樑設計計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa4d0bcf2a204a2fac9b37978b1b0713 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html title=解析橋樑設計計算>解析橋樑設計計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b0fcc3c2.html alt=來看看，什麼是高解析數字音頻！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153562218779909d30fcdab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b0fcc3c2.html title=來看看，什麼是高解析數字音頻！>來看看，什麼是高解析數字音頻！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a2e8d15.html alt=常見數字音頻格式解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/6c2f000314f485982daf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a2e8d15.html title=常見數字音頻格式解析>常見數字音頻格式解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16005ce4.html alt=2020年註冊測繪師職業資格考試測繪綜合能力試卷及答案和解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ba39c80703f74d0b8f209ada195d71a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16005ce4.html title=2020年註冊測繪師職業資格考試測繪綜合能力試卷及答案和解析>2020年註冊測繪師職業資格考試測繪綜合能力試卷及答案和解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c786e17.html alt="關 於“沙”和“砂”，小解析！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532935405966f50826d753 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c786e17.html title="關 於“沙”和“砂”，小解析！">關 於“沙”和“砂”，小解析！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac6d8d10.html alt=全面解析連桿支柱懸掛 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/fdb6d1f2639b41149fce641a491884c7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac6d8d10.html title=全面解析連桿支柱懸掛>全面解析連桿支柱懸掛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/88924514.html alt=深度解析真空滅弧室 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/17ba93bb5d184cf38a6934a3fa8af1e5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/88924514.html title=深度解析真空滅弧室>深度解析真空滅弧室</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0c29d7e2.html alt=攝影常用基本術語解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ff39dce402b54aec82643e9895a0a4db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0c29d7e2.html title=攝影常用基本術語解析>攝影常用基本術語解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50e05494.html alt=全面解析二極管知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/40fabede54844e8fb94fa32d21f09cbc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50e05494.html title=全面解析二極管知識>全面解析二極管知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/abf54574.html alt=java8的Stream全解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/85c2842d59284b6bbc86952a03632c60 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/abf54574.html title=java8的Stream全解析>java8的Stream全解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/54d00679.html alt=各光伏企業電池片非硅成本解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1534989889603c460b96be2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/54d00679.html title=各光伏企業電池片非硅成本解析>各光伏企業電池片非硅成本解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c22a059.html alt=橋樑樁基施工技術圖文解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1c4330955d2542eda7380f03286d95fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c22a059.html title=橋樑樁基施工技術圖文解析>橋樑樁基施工技術圖文解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3fe3a8ef.html alt=材料力學圖文全解析，收藏一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/796066a272ae415a8561d60e80fd090c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3fe3a8ef.html title=材料力學圖文全解析，收藏一下！>材料力學圖文全解析，收藏一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07dc7e00.html alt=分佈式變頻控制技術原理解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/da1921f974c74d309d46cb3bdd8382b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07dc7e00.html title=分佈式變頻控制技術原理解析>分佈式變頻控制技術原理解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5e1e208.html alt=物聯網通信協議全解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc3bb396c41451b8de278bdfe763b79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5e1e208.html title=物聯網通信協議全解析>物聯網通信協議全解析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>