<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文看懂編程中的基本數據結構與算法思想 | 极客快訊</title><meta property="og:title" content="一文看懂編程中的基本數據結構與算法思想 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67e3584.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67e3584.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b67e3584.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67e3584.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67e3584.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b67e3584.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b67e3584.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b67e3584.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="一文看懂編程中的基本數據結構與算法思想"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b67e3584.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文看懂編程中的基本數據結構與算法思想</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>編程的關鍵在於選擇數據結構和算法，數據結構用於描述問題，算法用於描述解決問題的方法和步驟。</p><p class=ql-align-justify>描述問題的數據除了各數據元素本身，還要考慮各元素的邏輯關係，主要是一對一的線性關係，一對多的樹型關係和多對多的圖形關係。另外，內存中對各數據元素的存儲只有順序存儲和鏈式存儲兩種方式，所以數據結構還要考慮數據的存儲結構，並考慮邏輯結構與數據結構如何有效地結合到一起。</p><p class=ql-align-justify>用算法描述問題，當問題比較複雜時，通常的思路是分而治之，並輔以適當的數據結構。</p><h1 class=ql-align-justify>1 分治法Divide and Conquer</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>分治法通常描述為以下三步：</p><blockquote>Divide the problem into more subproblems（分解問題為眾多的子問題）;Conuqe(solve) the subproblems（解決各子問題）;Combine(merge) the solution of subproblems(if need)（合併各子問題的解（如果需要））.</blockquote><p class=ql-align-justify>如用分治法來計算2^10?</p><p class=ql-align-justify>2^10＝2^5*x^5=2^2*x^3*x^5=32*32=1024</p><p class=ql-align-justify>相對於順序查找，二分查找有更高的效率，前提是二分查找需要事先排好序：</p><p>int binarySearchLoop(int arr[], int len, int findData)</p><p>{</p><p>if(arr==NULL || len &lt;=0)</p><p>return -1;</p><p>int start = 0;</p><p>int end = len-1;</p><p>while(start&lt;=end)</p><p>{</p><p>int mid = start+(end-start)/2;</p><p>if(arr[mid] == findData)</p><p>return mid;</p><p>else if(findData &lt; arr[mid])</p><p>end = mid-1;</p><p>else</p><p>start = mid+1;</p><p>}</p><p>return -1;</p><p>}</p><h1 class=ql-align-justify>2 枚舉法也是一種暴力縮小問題規模的算法</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>簡單的枚舉算法也是可以優化的，即儘可能縮小搜索的空間，如判斷質數：</p><blockquote>質數（prime number）又稱素數，有無限個。質數定義為在大於1的自然數中，除了1和它本身以外不再有其他因數。</blockquote><p class=ql-align-justify>判斷質數的函數：</p><pre class=ql-align-justify></pre><p>int isPrime(int n)</p><p>{</p><p>if(n&lt;= 1)// 小於等於1的整數不可能是素數</p><p>return 0;</p><p>if(n == 2); // 2 是素數</p><p>return 1;</p><p>if(n%2 == 0); // 能被2整除的其他整數都不是素數</p><p>return 0;</p><p>int limit = (int)sqrt((double)n)+1;</p><p>for(int i = 3; i &lt;= limit; i=i+2)</p><p>{</p><p>if(n % i == 0)</p><p>return 0;</p><p>}</p><p>return 1;</p><p>}</p><p class=ql-align-justify>isPrime()沒有必要枚舉所有的因子。</p><p class=ql-align-justify>I 只要發現任何一個大於1小於n的因子，就能停下來報告n不是素數。</p><p class=ql-align-justify>II 如果n能被2整除，直接報告n不是素數。如果n不能被2整除，那麼它也不可能被4或6或其他偶數整除。因此，isPrime只需要檢查2和奇數（由3開始，步長為2）。但注意有個特例，2能被2整除，但2是素數。</p><p class=ql-align-justify>III 如果n不是素數，則必有一個因子小於√<strong>n 。因此不需要檢查到n為止。只需檢查到</strong>√<strong>n（n=</strong>√<strong>n*</strong>√<strong>n） 。</strong></p><p class=ql-align-justify>因為如果n能被2~n-1之間任一整數整除，其二個因子必定有一個小於或等於√n，另一個大於或等於√n。例如24可以表示為：2*12、3*8、4*6，前面的因子小於√24，後面的因子大於√24，檢驗出了小因子，即可判斷n是否為素數，就像邏輯運算的短路求值。</p><h1 class=ql-align-justify>3 程序的模塊化</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>分治法在程序思想中的應用就是實現程序的模塊化，包括面向過程的函數化和麵向對象的對象化。</p><p class=ql-align-justify>許多原因都促使我們將應用程序分解成函數，下面僅列舉其中三個：</p><p class=ql-align-justify>函數一般小而具體。用一系列函數來寫程序，勝於一氣呵成寫完整個程序。這稱為“分而治之”，使你的精力一次集中在一個函數上。</p><p class=ql-align-justify>包含許多小函數的應用程序比單一的長程序更容易閱讀和調試。</p><p class=ql-align-justify>函數可以重用。函數寫好後可在程序的其他任何地方調用。這減少了編碼量，提高了開發效率。</p><h1 class=ql-align-justify>4 函數調用與棧</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>首先討論一個從a點出發去f點，然後回到a點的問題（中間的b、c、d、e都有多個分岔口）：</p><p class=ql-align-justify>a→b2→c1→d3→e2→f，每個分岔口都有一個信封，告訴你應該走哪一個分支，為了能夠正確地回到起點a，正確的做法是拿到一個信封后，即將這個信封疊在上一次拿到的信封的上面，回去時，依次從上面拿取信封，按提示即可正確返回。</p><p class=ql-align-justify>其做法就是依次放入，依次取出，信封之間是順序關係，只在一端操作，也就是不管是放入還是取出都不在中間操作。這樣一種思路在計算機上用數據來描述就是後進先出的棧，函數的調用、返回，遞歸、回溯算法都需要使用棧這種數據結構（由程序員或遞歸時由編譯器來實現）。</p><p class=ql-align-justify>在C++中，函數不能嵌套定義，但可以嵌套調用，在函數調用時，編譯器需要確保在逐級調用後能夠迴歸到最初的調用點，編譯器會隱式實現一個堆棧，用來保存每一級函數調用時的函數返回地址和局部變量，依次入棧和出棧。</p><p class=ql-align-justify>C++也支持遞歸函數的遞歸調用，同樣是由編譯器隱式地實現了一個堆棧。</p><h1 class=ql-align-justify>5 深度搜索與廣度搜索</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>如果將上述的問題稍微擴展一點，要從源點到目標點，中間的節點可能有多個分叉，這樣的問題可以用一個樹或圖來描述。</p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>而探路的方法可以分為兩種，一種是深度優先搜索（下一點、下一點……回溯……），一種是廣度優先搜索（下一點的全部分叉、下一點的全部分叉……）：</p><p class=ql-align-justify>5.1 深度優先搜索用棧（stack）來實現，整個過程可以想象成一個倒立的樹形：</p><blockquote>1）把根節點壓入棧中。2）每次從棧中彈出一個元素，搜索所有在它下一級的元素，把這些元素壓入棧中。並把這個元素記為它下一級元素的前驅。3）找到所要找的元素時結束程序。4）如果遍歷整個樹還沒有找到，結束程序。</blockquote><p class=ql-align-justify><br></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f8de5ca7befc4fcb8eaf2c75973ca798><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>5.2 廣度優先搜索使用隊列（queue）來實現，整個過程也可以看做一個倒立的樹形：</p><blockquote>1）把根節點放到隊列的末尾。2）每次從隊列的頭部取出一個元素，查看這個元素所有的下一級元素，把它們放到隊列的末尾。並把這個元素記為它下一級元素的前驅。（取出的元素也可以保存到一個隊列）3）找到所要找的元素時結束程序。4）如果遍歷整個樹還沒有找到，結束程序。</blockquote><p class=ql-align-justify><br></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>廣度優先搜索相對於深度優先搜索，因為是逐層探索的，可以確保以較少的點到達目標點，缺點是存儲量較大。</p><h1 class=ql-align-justify>6 遞歸算法</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>遞歸就是某個函數直接或間接的調用自身。</p><p class=ql-align-justify>語法形式上: 在一個函數的運行過程中, 調用這個函數自己：</p><blockquote>直接調用: 在fun()中直接執行fun()；間接調用: 在fun1()中執行fun2(); 在fun2()中又執行fun1() ；</blockquote><p class=ql-align-justify>問題的求解過程是劃分成許多相同性質的子問題的求解，而小問題的求解過程可以很容易的求出。這些子問題的解就構成裡原問題的解。</p><p class=ql-align-justify>待求解問題的解可以描述為輸入變量x的函數f(x)。</p><p class=ql-align-justify>通過尋找函數g( )，使得f(x) = g(f(x-1))。</p><p class=ql-align-justify>且已知f(0)的值, 就可以通過f(0)和g( )求出f(x)的值。</p><p class=ql-align-justify>擴展到多個輸入變量x, y, z等, x-1也可以推廣到 x - x1 , 只要遞歸朝著 “出口” 的方向即可。</p><p class=ql-align-justify>遞歸算法分解出的子問題與原問題之間是縱向的, 同類的關係（枚舉分解出的子問題之間是橫向的, 同類的關係）。</p><p class=ql-align-justify>遞歸的三個要點:</p><blockquote>遞歸式：如何將原問題劃分成子問題；遞歸出口：遞歸終止的條件, 即最小子問題的求解,可以允許多個出口；界函數：問題規模變化的函數, 它保證遞歸的規模向出口條件靠攏。</blockquote><p class=ql-align-justify>如一個求階乘的遞歸程序，給定n, 求階乘n!</p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ac05786c904c4799ba39a7e1d34bc190><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>階乘的棧：</p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b047eee594014fe4a77090a7355cc603><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>二分搜索的遞歸實現：</p><pre class=ql-align-justify></pre><p class=ql-align-justify><br></p><ul><li><br></li></ul><p>int binarySearchRecursion(int arr[], int findData, int start, int end)</p><p>{</p><p>if(arr==NULL || start>end)</p><p>return -1;</p><p>int mid = start+(end-start)/2;</p><p>if(arr[mid] == findData)</p><p>return mid;</p><p>else if(findData &lt; arr[mid])</p><p>binarySearchRecursion(arr, findData, start, mid-1);</p><p>else</p><p>binarySearchRecursion(arr, findData, mid+1, end);</p><h1 class=ql-align-justify>7 歸併排序</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>歸併排序（merge sort）是建立在歸併操作上的一種有效的排序算法。該算法是分治法（Divide and Conquer）的一個非常典型的應用。將已有序的子序列合併，得到完全有序的序列；即先使每個子序列有序，再使子序列段間有序。若將兩個有序表合併成一個有序表，稱為2-路歸併（2-way or binary merges sort）。</p><p class=ql-align-justify>歸併排序在1945年由馮·諾伊曼首次提出。</p><p class=ql-align-justify>2-路歸併的基本思路就是將數組分成二組A，B，如果這二組組內的數據都是有序的，那麼就可以很方便的將這二組數據進行排序。如何讓這二組組內數據有序？</p><p class=ql-align-justify>可以將A，B組各自再分成二組。依次類推，<strong>當分出來的小組只有一個數據時，可以認為這個小組組內已經達到了有序</strong>，然後再合併相鄰的二個小組就可以了。這樣<strong>通過先遞歸的分解數列，再合併數列就完成了歸併排序。</strong></p><p class=ql-align-justify>歸併排序的效率是比較高的，設數列長為N，將數列分開成小數列一共要logN步，每步都是一個合併有序數列的過程，時間複雜度可以記為O(N)，故一共為O(N*logN)。因為歸併排序每次都是在相鄰的數據中進行操作，所以歸併排序在O(N*logN)的幾種排序方法（快速排序，歸併排序，希爾排序，堆排序）也是效率比較高的。</p><p class=ql-align-justify>歸併排序的實現分為<strong>遞歸實現</strong>與<strong>非遞歸(迭代)實現</strong>。遞歸實現的歸併排序是算法設計中分治策略的典型應用，我們將一個大問題分割成小問題分別解決，然後用所有小問題的答案來解決整個大問題。非遞歸(迭代)實現的歸併排序首先進行是兩兩歸併，然後四四歸併，然後是八八歸併，一直下去直到歸併了整個數組。</p><p class=ql-align-justify><strong>7.1 </strong>歸併排序<strong>分解</strong></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b4eef732c8054f688d947e84d34041f9><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>可以看到這種結構很像一棵完全二叉樹，<strong>分</strong>階段可以理解為就是遞歸拆分子序列的過程，遞歸深度為log2n。</p><p class=ql-align-justify><strong>7.2 </strong>歸併排序<strong>合併相鄰有序子序列</strong></p><p class=ql-align-justify>再來看看<strong>並</strong>階段，我們需要將兩個已經有序的子序列合併成一個有序序列，比如上圖中的最後一次合併，要將[4,5,7,8]和[1,2,3,6]兩個已經有序的子序列，合併為最終序列[1,2,3,4,5,6,7,8]，來看下實現步驟。</p><ul><li class=ql-align-justify>申請空間，使其大小為兩個已經排序序列之和，該空間用來存放合併後的序列；</li><li class=ql-align-justify>設定兩個指針，最初位置分別為兩個已經排序序列的起始位置；</li><li class=ql-align-justify>比較兩個指針所指向的元素，選擇相對小的元素放入到合併空間，並移動指針到下一位置；temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++];</li><li class=ql-align-justify>重複步驟3直到某一指針到達序列尾；</li><li class=ql-align-justify>將另一序列剩下的所有元素直接複製到合併序列尾；</li></ul><p class=ql-align-justify><br></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ae2af0c170af4077b9d3cc2e5c692c1c><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1 class=ql-align-justify><strong>7.3 </strong>歸併排序<strong>動圖演示</strong></h1><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cdb68a5106594095ad4917efc127397b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6dc69d7b67446edb82cc8a688b06e0b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1 class=ql-align-justify><strong>7.4 </strong>歸併排序<strong>代碼</strong></h1><p class=ql-align-justify><br></p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f0a4c4d71df24b86b168ac736c1074e1><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1 class=ql-align-justify>8 回溯法和分書問題</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>回溯算法實際上是一個類似枚舉的搜索嘗試過程，主要是在搜索嘗試過程中尋找問題的解，當發現已不滿足求解條件時，就“回溯“返回，嘗試別的路徑。可以參考一下走迷宮的過程，一開始會隨機選擇一條道路前進，一直到走不通之後就會回頭直到找到另外一條沒有試過的道路前進。實際上，走迷宮的算法就是回溯法的經典問題。</p><p class=ql-align-justify>回溯法實際上<strong>也是一種試錯的思路</strong>，通過不斷嘗試解的組合來達到求解可行解和最優解的目的。雖然都有窮搜的概念蘊含其中，但是回溯法和窮舉查找法是不同的。對於一個問題的所有實例，窮舉法註定都是非常緩慢的，但應用回溯法至少可以期望對於一些規模不是很小的實例，計算機在可接受的時間內對問題求解。</p><p class=ql-align-justify>許多複雜的規模的問題都可以使用回溯法，有”通用解題方法”的美稱。分書問題和八皇后都是典型的回溯法問題。</p><p class=ql-align-justify>分書問題能夠較有代表性地表現數據描述、遞歸、回溯的算法思路。</p><p class=ql-align-justify>有編號為0，1，2，3，4的5本書，準備分給5個人A，B，C，D，E，寫一個程序，輸出所有皆大歡喜的分書方案。</p><p class=ql-align-justify>每個人的閱讀興趣用一個二維數組like描述：</p><p class=ql-align-justify>Like[i][j] = true i喜歡書j</p><p class=ql-align-justify>Like[i][j] = false i不喜歡書j</p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1bce726124c408ab7cd01fee9ad5b7d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>設計一個函數trynext(int i)給第i個人分書。</p><p class=ql-align-justify>用一個一維數組take表示某本書分給了某人。take[j]=i+1;//把第j本書分配給第i個人</p><p class=ql-align-justify>依次嘗試把書j分給人i。</p><p class=ql-align-justify>如果第i個人不喜歡第j本書，則嘗試下一本書，如果喜歡，並且第j本書尚未分配，則把書j分配給i。</p><p class=ql-align-justify>如果i是最後一個人，則方案數加1，輸出該方案。否則調用trynext(i+1)為第i+1個人分書。</p><p class=ql-align-justify>如果對第i個人枚舉了他喜歡的所有的書，都沒有找到可行的方案，那就回到前一個狀態i-1，讓i-1把分到的書退回去，重新找喜歡的書，再遞歸調用函數，尋找可行的方案。</p><ul><li><br></li></ul><pre>#include &lt;iostream&gt;#include &lt;conio.h&gt;using namespace std;int like[5][5]={{0,0,1,1,0},{1,1,0,0,1},{0,1,1,0,1},{0,0,0,1,0},{0,1,0,0,1}};int take[5]={0,0,0,0,0};//記錄每一本書的分配情況int n;//n表示分書方案數void trynext(int i);int main(){n=0;trynext(0);getch();return 0;}//對第 i 個人進行分配void trynext(int i){int j,k;for(j=0;j&lt;5;j++){if(like[i][j]&amp;&amp;take[j]==0){take[j]=i+1;//把第j本書分配給第i個人if(i==4)//第5個人分配結束，也即所有的書已經分配完畢，可以將方案進行輸出{n++;cout&lt;&lt;"第"&lt;&lt;n&lt;&lt;"種分配方案"&lt;&lt;endl;for(k=0;k&lt;5;k++)cout&lt;&lt;"第"&lt;&lt;k&lt;&lt;"本書分配給"&lt;&lt;(char)(take[k]+'A'-1)&lt;&lt;endl;cout&lt;&lt;endl;}elsetrynext(i+1);//遞歸，對下一個人進行分配take[j]=0;//回溯，尋找下一種方案}}}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>當like矩陣的值為</p><div class=pgc-img><img alt=一文看懂編程中的基本數據結構與算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>附歸併排序的代碼：</p><ul><li><br></li></ul><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;limits.h&gt;// 分類 -------------- 內部比較排序// 數據結構 ---------- 數組// 最差時間複雜度 ---- O(nlogn)// 最優時間複雜度 ---- O(nlogn)// 平均時間複雜度 ---- O(nlogn)// 所需輔助空間 ------ O(n)// 穩定性 ------------ 穩定// 合併兩個已排好序的數組A[left...mid]和A[mid+1...right]void Merge(int A[], int left, int mid, int right){ int len = right - left + 1; int *temp = new int[len]; // 輔助空間O(n) int index = 0; int i = left; // 前一數組的起始元素 int j = mid + 1; // 後一數組的起始元素 while (i &lt;= mid &amp;&amp; j &lt;= right) { temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; // 帶等號保證歸併排序的穩定性 } while (i &lt;= mid) { temp[index++] = A[i++]; } while (j &lt;= right) { temp[index++] = A[j++]; } for (int k = 0; k &lt; len; k++) { A[left++] = temp[k]; }}// 遞歸實現的歸併排序(自頂向下)void MergeSortRecursion(int A[], int left, int right){ if (left == right) // 當待排序的序列長度為1時，遞歸開始回溯，進行merge操作 return; int mid = (left + right) / 2; MergeSortRecursion(A, left, mid); //左半部分排好序 MergeSortRecursion(A, mid + 1, right); //右半部分排好序 Merge(A, left, mid, right); //合併左右部分}// 非遞歸(迭代)實現的歸併排序(自底向上)void MergeSortIteration(int A[], int len){ int left, mid, right;// 子數組索引,前一個為A[left...mid]，後一個子數組為A[mid+1...right] for (int i = 1; i &lt; len; i *= 2) // 子數組的大小i初始為1，每輪翻倍 { left = 0; while (left + i &lt; len) // 後一個子數組存在(需要歸併) { mid = left + i - 1; right = mid + i &lt; len ? mid + i : len - 1;// 後一個子數組大小可能不夠 Merge(A, left, mid, right); left = right + 1; // 前一個子數組索引向後移動 } }}int main(){ int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; // 從小到大歸併排序 int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; int n1 = sizeof(A1) / sizeof(int); int n2 = sizeof(A2) / sizeof(int); MergeSortRecursion(A1, 0, n1 - 1); // 遞歸實現 MergeSortIteration(A2, n2); // 非遞歸實現 printf("遞歸實現的歸併排序結果："); for (int i = 0; i &lt; n1; i++) { printf("%d ", A1[i]); } printf(" "); printf("非遞歸實現的歸併排序結果："); for (i = 0; i &lt; n2; i++) { printf("%d ", A2[i]); } printf(" "); system("pause"); return 0;}</pre><p class=ql-align-justify><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編程</a></li><li><a>數據</a></li><li><a>結構</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html alt=數據結構與算法（7）遞歸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html title=數據結構與算法（7）遞歸>數據結構與算法（7）遞歸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/062bbe77.html alt=軟考自查：數據結構與算法基礎（內容有點多！！！） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/60f8235323314304b4dac050f8cb1e7d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/062bbe77.html title=軟考自查：數據結構與算法基礎（內容有點多！！！）>軟考自查：數據結構與算法基礎（內容有點多！！！）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>