<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>這一次搞懂Spring代理創建+AOP鏈式調用過程 | 极客快訊</title><meta property="og:title" content="這一次搞懂Spring代理創建+AOP鏈式調用過程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e1c7c82fff674a01b49573f34eb5dc1b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="這一次搞懂Spring代理創建+AOP鏈式調用過程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b6fc620f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>這一次搞懂Spring代理創建+AOP鏈式調用過程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=line>前言</h1><p>AOP，也就是面向切面編程，它可以將公共的代碼抽離出來，動態的植入到目標類、目標方法中，大大提高我們編程的效率，也使程序變得更加優雅。如事務、操作日誌等都可以使用AOP實現。這種織入可以是<strong>在運行期動態生成代理對象</strong>實現，也可以在<strong>編譯期</strong>、<strong>類加載時期</strong>靜態織入到代碼中。而Spring正是通過第一種方法實現，且在代理類的生成上也有兩種方式：JDK Proxy和CGLIB，默認當類實現了接口時使用前者，否則使用後者；另外Spring AOP只能實現對方法的增強。</p><h1 class=line>正文</h1><h2 class=line>基本概念</h2><p>AOP的術語很多，雖然不清楚術語我們也能很熟練地使用AOP，但是要理解分析源碼，術語就需要深刻體會其含義。</p><ul><li>增強（Advice）：就是我們想要額外增加的功能</li><li>目標對象（Target）：就是我們想要增強的目標類，如果沒有AOP，我們需要在每個目標對象中實現日誌、事務管理等非業務邏輯</li><li>連接點（JoinPoint）：程序執行時的特定時機，如方法執行前、後以及拋出異常後等等。</li><li>切點（Pointcut）：連接點的導航，我們如何找到目標對象呢？切點的作用就在於此，在Spring中就是匹配表達式。</li><li>引介（Introduction）：引介是一種特殊的增強，它為類添加一些屬性和方法。這樣，即使一個業務類原本沒有實現某個接口，通過AOP的引介功能，我們可以動態地為該業務類添加接口的實現邏輯，讓業務類成為這個接口的實現類。</li><li>織入（Weaving）：即如何將增強添加到目標對象的連接點上，有動態（運行期生成代理）、靜態（編譯期、類加載時期）兩種方式。</li><li>代理（Proxy）：目標對象被植入增強後，就會產生一個代理對象，該對象可能是和原對象實現了同樣的一個接口（JDK），也可能是原對象的子類（CGLIB）。</li><li>切面（Aspect、Advisor）：切面由切點和增強組成，包含了這兩者的定義。</li></ul><h2 class=line>代理對象的創建</h2><p>在熟悉了AOP術語後，下面就來看看Spring是如何創建代理對象的，是否還記得上一篇提到的AOP的入口呢？在<strong>AbstractAutowireCapableBeanFactory</strong>類的<strong>applyBeanPostProcessorsAfterInitialization</strong>方法中循環調用了<strong>BeanPostProcessor</strong>的<strong>postProcessAfterInitialization</strong>方法，其中一個就是我們創建代理對象的入口。這裡是Bean實例化完成去創建代理對象，理所當然應該這樣，但實際上在Bean實例化之前調用了一個<strong>resolveBeforeInstantiation</strong>方法，這裡實際上我們也是有機會可以提前創建代理對象的，這裡放到最後來分析，先來看主入口，進入到<strong>AbstractAutoProxyCreator</strong>類中：</p><pre><code>    public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {        if (bean != null) {            Object cacheKey = getCacheKey(bean.getClass(), beanName);            if (!this.earlyProxyReferences.contains(cacheKey)) {                return wrapIfNecessary(bean, beanName, cacheKey);            }        }        return bean;    }    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {        //創建當前bean的代理，如果這個bean有advice的話，重點看        // Create proxy if we have advice.        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);        //如果有切面，則生成該bean的代理        if (specificInterceptors != DO_NOT_PROXY) {            this.advisedBeans.put(cacheKey, Boolean.TRUE);            //把被代理對象bean實例封裝到SingletonTargetSource對象中            Object proxy = createProxy(                    bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));            this.proxyTypes.put(cacheKey, proxy.getClass());            return proxy;        }        this.advisedBeans.put(cacheKey, Boolean.FALSE);        return bean;    }</code></pre><p>先從緩存中拿，沒有則調用<strong>wrapIfNecessary</strong>方法創建。在這個方法裡面主要看兩個地方：<strong>getAdvicesAndAdvisorsForBean</strong>和<strong>createProxy</strong>。簡單一句話概括就是先掃描後創建，問題是掃描什麼呢？你可以先結合上面的概念思考下，換你會怎麼做。進入到子類<strong>AbstractAdvisorAutoProxyCreator</strong>的<strong>getAdvicesAndAdvisorsForBean</strong>方法中：</p><pre><code>    protected Object[] getAdvicesAndAdvisorsForBean(            Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {        //找到合格的切面        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);        if (advisors.isEmpty()) {            return DO_NOT_PROXY;        }        return advisors.toArray();    }    protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {        //找到候選的切面,其實就是一個尋找有@Aspectj註解的過程，把工程中所有有這個註解的類封裝成Advisor返回        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();        //判斷候選的切面是否作用在當前beanClass上面，就是一個匹配過程。現在就是一個匹配        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);        extendAdvisors(eligibleAdvisors);        if (!eligibleAdvisors.isEmpty()) {            //對有@Order@Priority進行排序            eligibleAdvisors = sortAdvisors(eligibleAdvisors);        }        return eligibleAdvisors;    }</code></pre><p>在<strong>findEligibleAdvisors</strong>方法中可以看到有兩個步驟，第一先找到所有的切面，即掃描所有帶有@Aspect註解的類，並將其中的<strong>切點（表達式）</strong>和<strong>增強</strong>封裝為<strong>切面</strong>，掃描完成後，自然是要判斷哪些<strong>切面</strong>能夠連接到當前Bean實例上。下面一步步來分析，首先是掃描過程，進入到<strong>AnnotationAwareAspectJAutoProxyCreator</strong>類中：</p><pre><code>    protected List&lt;Advisor&gt; findCandidateAdvisors() {        // 先通過父類AbstractAdvisorAutoProxyCreator掃描，這裡不重要        List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();        // 主要看這裡        if (this.aspectJAdvisorsBuilder != null) {            advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());        }        return advisors;    }</code></pre><p>這裡委託給了<strong>BeanFactoryAspectJAdvisorsBuilderAdapter</strong>類，並調用其父類的<strong>buildAspectJAdvisors</strong>方法創建切面對象：</p><pre><code>    public List&lt;Advisor&gt; buildAspectJAdvisors() {        List&lt;String&gt; aspectNames = this.aspectBeanNames;        if (aspectNames == null) {            synchronized (this) {                aspectNames = this.aspectBeanNames;                if (aspectNames == null) {                    List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();                    aspectNames = new ArrayList&lt;&gt;();                    //獲取spring容器中的所有bean的名稱BeanName                    String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(                            this.beanFactory, Object.class, true, false);                    for (String beanName : beanNames) {                        if (!isEligibleBean(beanName)) {                            continue;                        }                        Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);                        if (beanType == null) {                            continue;                        }                        //判斷類上是否有@Aspect註解                        if (this.advisorFactory.isAspect(beanType)) {                            aspectNames.add(beanName);                            AspectMetadata amd = new AspectMetadata(beanType, beanName);                            if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {                                // 當@Aspect的value屬性為""時才會進入到這裡                                // 創建獲取有@Aspect註解類的實例工廠，負責獲取有@Aspect註解類的實例                                MetadataAwareAspectInstanceFactory factory =                                        new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);                                //創建切面advisor對象                                List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);                                if (this.beanFactory.isSingleton(beanName)) {                                    this.advisorsCache.put(beanName, classAdvisors);                                }                                else {                                    this.aspectFactoryCache.put(beanName, factory);                                }                                advisors.addAll(classAdvisors);                            }                            else {                                MetadataAwareAspectInstanceFactory factory =                                        new PrototypeAspectInstanceFactory(this.beanFactory, beanName);                                this.aspectFactoryCache.put(beanName, factory);                                advisors.addAll(this.advisorFactory.getAdvisors(factory));                            }                        }                    }                    this.aspectBeanNames = aspectNames;                    return advisors;                }            }        }        return advisors;    }</code></pre><p>這個方法裡面首先從IOC中拿到所有Bean的名稱，並循環判斷該類上是否帶有@Aspect註解，如果有則將BeanName和Bean的Class類型封裝到<strong>BeanFactoryAspectInstanceFactory</strong>中，並調用<strong>ReflectiveAspectJAdvisorFactory.getAdvisors</strong>創建切面對象：</p><pre><code>    public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {        //從工廠中獲取有@Aspect註解的類Class        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();        //從工廠中獲取有@Aspect註解的類的名稱        String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();        validate(aspectClass);        // 創建工廠的裝飾類，獲取實例只會獲取一次        MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =                new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);        List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();        //這裡循環沒有@Pointcut註解的方法        for (Method method : getAdvisorMethods(aspectClass)) {            //非常重要重點看看            Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);            if (advisor != null) {                advisors.add(advisor);            }        }        if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {            Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);            advisors.add(0, instantiationAdvisor);        }        //判斷屬性上是否有引介註解，這裡可以不看        for (Field field : aspectClass.getDeclaredFields()) {            //判斷屬性上是否有DeclareParents註解，如果有返回切面            Advisor advisor = getDeclareParentsAdvisor(field);            if (advisor != null) {                advisors.add(advisor);            }        }        return advisors;    }    private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) {        final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();        ReflectionUtils.doWithMethods(aspectClass, method -&gt; {            // Exclude pointcuts            if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {                methods.add(method);            }        });        methods.sort(METHOD_COMPARATOR);        return methods;    }</code></pre><p>根據Aspect的Class拿到所有不帶@Pointcut註解的方法對象（為什麼是不帶@Pointcut註解的方法？仔細想想不難理解），另外要注意這裡對method進行了排序，看看這個<strong>METHOD_COMPARATOR</strong>比較器：</p><pre><code>    private static final Comparator&lt;Method&gt; METHOD_COMPARATOR;    static {        Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(                new InstanceComparator&lt;&gt;(                        Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),                (Converter&lt;Method, Annotation&gt;) method -&gt; {                    AspectJAnnotation&lt;?&gt; annotation =                        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);                    return (annotation != null ? annotation.getAnnotation() : null);                });        Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);        METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);    }</code></pre><p>關注<strong>InstanceComparator</strong>構造函數參數，記住它們的順序，這就是AOP鏈式調用中同一個@Aspect類中Advice的<strong>執行順序</strong>。接著往下看，在<strong>getAdvisors</strong>方法中循環獲取到的methods，分別調用<strong>getAdvisor</strong>方法，也就是根據方法逐個去創建切面：</p><pre><code>    public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,            int declarationOrderInAspect, String aspectName) {        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());        //獲取pointCut對象，最重要的是從註解中獲取表達式        AspectJExpressionPointcut expressionPointcut = getPointcut(                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());        if (expressionPointcut == null) {            return null;        }        //創建Advisor切面類，這才是真正的切面類，一個切面類裡面肯定要有1、pointCut 2、advice        //這裡pointCut是expressionPointcut， advice 增強方法是 candidateAdviceMethod        return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,                this, aspectInstanceFactory, declarationOrderInAspect, aspectName);    }    private static final Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = new Class&lt;?&gt;[] {            Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};    private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) {        //從候選的增強方法裡面 candidateAdviceMethod  找有有註解        //Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class        //並把註解信息封裝成AspectJAnnotation對象        AspectJAnnotation&lt;?&gt; aspectJAnnotation =                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);        if (aspectJAnnotation == null) {            return null;        }        //創建一個PointCut類，並且把前面從註解裡面解析的表達式設置進去        AspectJExpressionPointcut ajexp =                new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);        ajexp.setExpression(aspectJAnnotation.getPointcutExpression());        if (this.beanFactory != null) {            ajexp.setBeanFactory(this.beanFactory);        }        return ajexp;    }</code></pre><p>之前就說過<strong>切面</strong>的定義，是切點和增強的組合，所以這裡首先通過<strong>getPointcut</strong>獲取到註解對象，然後new了一個Pointcut對象，並將表達式設置進去。然後在<strong>getAdvisor</strong>方法中最後new了一個<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>對象：</p><pre><code>    public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,            Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {        this.declaredPointcut = declaredPointcut;        this.declaringClass = aspectJAdviceMethod.getDeclaringClass();        this.methodName = aspectJAdviceMethod.getName();        this.parameterTypes = aspectJAdviceMethod.getParameterTypes();        this.aspectJAdviceMethod = aspectJAdviceMethod;        this.aspectJAdvisorFactory = aspectJAdvisorFactory;        this.aspectInstanceFactory = aspectInstanceFactory;        this.declarationOrder = declarationOrder;        this.aspectName = aspectName;        if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {            // Static part of the pointcut is a lazy type.            Pointcut preInstantiationPointcut = Pointcuts.union(                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);            // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.            // If it's not a dynamic pointcut, it may be optimized out            // by the Spring AOP infrastructure after the first evaluation.            this.pointcut = new PerTargetInstantiationModelPointcut(                    this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);            this.lazy = true;        }        else {            // A singleton aspect.            this.pointcut = this.declaredPointcut;            this.lazy = false;            //這個方法重點看看，創建advice對象            this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);        }    }</code></pre><p>這個就是我們的切面類，在其構造方法的最後通過<strong>instantiateAdvice</strong>創建了<strong>Advice</strong>對象。注意這裡傳進來的<strong>declarationOrder</strong>參數，它就是循環method時的序號，其作用就是賦值給這裡的<strong>declarationOrder</strong>屬性以及Advice的<strong>declarationOrder</strong>屬性，在後面排序時就會通過這個序號來比較，因此Advice的執行順序是<strong>固定</strong>的，至於為什麼要固定，後面分析完AOP鏈式調用過程自然就明白了。</p><pre><code>    public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {        //獲取有@Aspect註解的類        Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();        validate(candidateAspectClass);        //找到candidateAdviceMethod方法上面的註解，並且包裝成AspectJAnnotation對象，這個對象中就有註解類型        AspectJAnnotation&lt;?&gt; aspectJAnnotation =                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);        if (aspectJAnnotation == null) {            return null;        }        AbstractAspectJAdvice springAdvice;        //根據不同的註解類型創建不同的advice類實例        switch (aspectJAnnotation.getAnnotationType()) {            case AtPointcut:                if (logger.isDebugEnabled()) {                    logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'");                }                return null;            case AtAround:                //實現了MethodInterceptor接口                springAdvice = new AspectJAroundAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtBefore:                //實現了MethodBeforeAdvice接口，沒有實現MethodInterceptor接口                springAdvice = new AspectJMethodBeforeAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtAfter:                //實現了MethodInterceptor接口                springAdvice = new AspectJAfterAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtAfterReturning:                //實現了AfterReturningAdvice接口，沒有實現MethodInterceptor接口                springAdvice = new AspectJAfterReturningAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();                if (StringUtils.hasText(afterReturningAnnotation.returning())) {                    springAdvice.setReturningName(afterReturningAnnotation.returning());                }                break;            case AtAfterThrowing:                //實現了MethodInterceptor接口                springAdvice = new AspectJAfterThrowingAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();                if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());                }                break;            default:                throw new UnsupportedOperationException(                        "Unsupported advice type on method: " + candidateAdviceMethod);        }        // Now to configure the advice...        springAdvice.setAspectName(aspectName);        springAdvice.setDeclarationOrder(declarationOrder);        String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);        if (argNames != null) {            springAdvice.setArgumentNamesFromStringArray(argNames);        }        //計算argNames和類型的對應關係        springAdvice.calculateArgumentBindings();        return springAdvice;    }</code></pre><p>這裡邏輯很清晰，就是拿到方法上的註解類型，根據類型創建不同的增強Advice對象：AspectJAroundAdvice、AspectJMethodBeforeAdvice、AspectJAfterAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice。完成之後通過<strong>calculateArgumentBindings</strong>方法進行參數綁定，感興趣的可自行研究。這裡主要看看幾個Advice的繼承體系：</p><div class=pgc-img><img alt=這一次搞懂Spring代理創建+AOP鏈式調用過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1c7c82fff674a01b49573f34eb5dc1b><p class=pgc-img-caption></p></div><p>可以看到有兩個Advice是沒有實現<strong>MethodInterceptor</strong>接口的：AspectJMethodBeforeAdvice和AspectJAfterReturningAdvice。而<strong>MethodInterceptor</strong>有一個<strong>invoke</strong>方法，這個方法就是<strong>鏈式調用</strong>的核心方法，但那兩個沒有實現該方法的Advice怎麼處理呢？稍後會分析。到這裡切面對象就創建完成了，接下來就是判斷當前創建的Bean實例是否和這些切面匹配以及對<strong>切面</strong>排序。匹配過程比較複雜，對理解主流程也沒什麼幫助，所以這裡就不展開分析，感興趣的自行分析（AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply()）。下面看看排序的過程，回到AbstractAdvisorAutoProxyCreator.findEligibleAdvisors方法：</p><pre><code>    protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {        //找到候選的切面,其實就是一個尋找有@Aspectj註解的過程，把工程中所有有這個註解的類封裝成Advisor返回        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();        //判斷候選的切面是否作用在當前beanClass上面，就是一個匹配過程。。現在就是一個匹配        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);        extendAdvisors(eligibleAdvisors);        if (!eligibleAdvisors.isEmpty()) {            //對有@Order@Priority進行排序            eligibleAdvisors = sortAdvisors(eligibleAdvisors);        }        return eligibleAdvisors;    }</code></pre><p><strong>sortAdvisors</strong>方法就是排序，但這個方法有兩個實現：當前類<strong>AbstractAdvisorAutoProxyCreator</strong>和子類<strong>AspectJAwareAdvisorAutoProxyCreator</strong>，應該走哪個呢？</p><div class=pgc-img><img alt=這一次搞懂Spring代理創建+AOP鏈式調用過程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/419537d02465492990aed14903ddda42><p class=pgc-img-caption></p></div><p>通過類圖我們可以肯定是進入的<strong>AspectJAwareAdvisorAutoProxyCreator</strong>類，因為<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的父類是它。</p><pre><code>    protected List&lt;Advisor&gt; sortAdvisors(List&lt;Advisor&gt; advisors) {        List&lt;PartiallyComparableAdvisorHolder&gt; partiallyComparableAdvisors = new ArrayList&lt;&gt;(advisors.size());        for (Advisor element : advisors) {            partiallyComparableAdvisors.add(                    new PartiallyComparableAdvisorHolder(element, DEFAULT_PRECEDENCE_COMPARATOR));        }        List&lt;PartiallyComparableAdvisorHolder&gt; sorted = PartialOrder.sort(partiallyComparableAdvisors);        if (sorted != null) {            List&lt;Advisor&gt; result = new ArrayList&lt;&gt;(advisors.size());            for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) {                result.add(pcAdvisor.getAdvisor());            }            return result;        }        else {            return super.sortAdvisors(advisors);        }    }</code></pre><p>這裡排序主要是委託給<strong>PartialOrder</strong>進行的，而在此之前將所有的切面都封裝成了<strong>PartiallyComparableAdvisorHolder</strong>對象，注意傳入的<strong>DEFAULT_PRECEDENCE_COMPARATOR</strong>參數，這個就是比較器對象：</p><pre><code>    private static final Comparator&lt;Advisor&gt; DEFAULT_PRECEDENCE_COMPARATOR = new AspectJPrecedenceComparator();</code></pre><p>所以我們直接看這個比較器的<strong>compare</strong>方法：</p><pre><code>    public int compare(Advisor o1, Advisor o2) {        int advisorPrecedence = this.advisorComparator.compare(o1, o2);        if (advisorPrecedence == SAME_PRECEDENCE &amp;&amp; declaredInSameAspect(o1, o2)) {            advisorPrecedence = comparePrecedenceWithinAspect(o1, o2);        }        return advisorPrecedence;    }    private final Comparator&lt;? super Advisor&gt; advisorComparator;    public AspectJPrecedenceComparator() {        this.advisorComparator = AnnotationAwareOrderComparator.INSTANCE;    }</code></pre><p>第一步先通過<strong>AnnotationAwareOrderComparator</strong>去比較，點進去看可以發現是對實現了<strong>PriorityOrdered</strong>和<strong>Ordered</strong>接口以及標記了<strong>Priority</strong>和<strong>Order</strong>註解的<strong>非同一個@Aspect類中的切面</strong>進行排序。這個和之前分析<strong>BeanFacotryPostProcessor</strong>類是一樣的原理。而對<strong>同一個@Aspect類中的切面</strong>排序主要是<strong>comparePrecedenceWithinAspect</strong>方法：</p><pre><code>    private int comparePrecedenceWithinAspect(Advisor advisor1, Advisor advisor2) {        boolean oneOrOtherIsAfterAdvice =                (AspectJAopUtils.isAfterAdvice(advisor1) || AspectJAopUtils.isAfterAdvice(advisor2));        int adviceDeclarationOrderDelta = getAspectDeclarationOrder(advisor1) - getAspectDeclarationOrder(advisor2);        if (oneOrOtherIsAfterAdvice) {            // the advice declared last has higher precedence            if (adviceDeclarationOrderDelta &lt; 0) {                // advice1 was declared before advice2                // so advice1 has lower precedence                return LOWER_PRECEDENCE;            }            else if (adviceDeclarationOrderDelta == 0) {                return SAME_PRECEDENCE;            }            else {                return HIGHER_PRECEDENCE;            }        }        else {            // the advice declared first has higher precedence            if (adviceDeclarationOrderDelta &lt; 0) {                // advice1 was declared before advice2                // so advice1 has higher precedence                return HIGHER_PRECEDENCE;            }            else if (adviceDeclarationOrderDelta == 0) {                return SAME_PRECEDENCE;            }            else {                return LOWER_PRECEDENCE;            }        }    }    private int getAspectDeclarationOrder(Advisor anAdvisor) {        AspectJPrecedenceInformation precedenceInfo =            AspectJAopUtils.getAspectJPrecedenceInformationFor(anAdvisor);        if (precedenceInfo != null) {            return precedenceInfo.getDeclarationOrder();        }        else {            return 0;        }    }</code></pre><p>這裡就是通過<strong>precedenceInfo.getDeclarationOrder</strong>拿到在創建<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>對象時設置的<strong>declarationOrder</strong>屬性，這就驗證了之前的說法（實際上這裡排序過程非常複雜，不是簡單的按照這個屬性進行排序）。當上面的一切都進行完成後，就該創建代理對象了，回到<strong>AbstractAutoProxyCreator.wrapIfNecessary</strong>，看關鍵部分代碼：</p><pre><code>    //如果有切面，則生成該bean的代理    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.put(cacheKey, Boolean.TRUE);        //把被代理對象bean實例封裝到SingletonTargetSource對象中        Object proxy = createProxy(                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }</code></pre><p>注意這裡將被代理對象封裝成了一個<strong>SingletonTargetSource</strong>對象，它是<strong>TargetSource</strong>的實現類。</p><pre><code>    protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,            @Nullable Object[] specificInterceptors, TargetSource targetSource) {        if (this.beanFactory instanceof ConfigurableListableBeanFactory) {            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);        }        //創建代理工廠        ProxyFactory proxyFactory = new ProxyFactory();        proxyFactory.copyFrom(this);        if (!proxyFactory.isProxyTargetClass()) {            if (shouldProxyTargetClass(beanClass, beanName)) {                //proxyTargetClass 是否對類進行代理，而不是對接口進行代理，設置為true時，使用CGLib代理。                proxyFactory.setProxyTargetClass(true);            }            else {                evaluateProxyInterfaces(beanClass, proxyFactory);            }        }        //把advice類型的增強包裝成advisor切面        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);        proxyFactory.addAdvisors(advisors);        proxyFactory.setTargetSource(targetSource);        customizeProxyFactory(proxyFactory);        ////用來控制代理工廠被配置後，是否還允許修改代理的配置,默認為false        proxyFactory.setFrozen(this.freezeProxy);        if (advisorsPreFiltered()) {            proxyFactory.setPreFiltered(true);        }        //獲取代理實例        return proxyFactory.getProxy(getProxyClassLoader());    }</code></pre><p>這裡通過<strong>ProxyFactory</strong>對象去創建代理實例，這是<strong>工廠模式</strong>的體現，但在創建代理對象之前還有幾個準備動作：需要判斷是JDK代理還是CGLIB代理以及通過<strong>buildAdvisors</strong>方法將擴展的<strong>Advice</strong>封裝成<strong>Advisor</strong>切面。準備完成則通過<strong>getProxy</strong>創建代理對象：</p><pre><code>    public Object getProxy(@Nullable ClassLoader classLoader) {        //根據目標對象是否有接口來判斷採用什麼代理方式，cglib代理還是jdk動態代理        return createAopProxy().getProxy(classLoader);    }    protected final synchronized AopProxy createAopProxy() {        if (!this.active) {            activate();        }        return getAopProxyFactory().createAopProxy(this);    }    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {            Class&lt;?&gt; targetClass = config.getTargetClass();            if (targetClass == null) {                throw new AopConfigException("TargetSource cannot determine target class: " +                        "Either an interface or a target is required for proxy creation.");            }            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {                return new JdkDynamicAopProxy(config);            }            return new ObjenesisCglibAopProxy(config);        }        else {            return new JdkDynamicAopProxy(config);        }    }</code></pre><p>首先通過配置拿到對應的代理類：ObjenesisCglibAopProxy和JdkDynamicAopProxy，然後再通過<strong>getProxy</strong>創建Bean的代理，這裡以<strong>JdkDynamicAopProxy</strong>為例：</p><pre><code>    public Object getProxy(@Nullable ClassLoader classLoader) {        //advised是代理工廠對象        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);    }</code></pre><p>這裡的代碼你應該不陌生了，就是JDK的原生API，<strong>newProxyInstance</strong>方法傳入的<strong>InvocationHandler</strong>對象是<strong>this</strong>，因此，最終AOP代理的調用就是從該類中的<strong>invoke</strong>方法開始。至此，代理對象的創建就完成了，下面來看下整個過程的時序圖：</p><div class=pgc-img><img alt=這一次搞懂Spring代理創建+AOP鏈式調用過程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/692f7c1d1455426a8f4b2c6d119f7d0c><p class=pgc-img-caption></p></div><h2 class=line>小結</h2><p>代理對象的創建過程整體來說並不複雜，首先找到所有帶有@Aspect註解的類，並獲取其中沒有@Pointcut註解的方法，循環創建切面，而創建切面需要<strong>切點</strong>和<strong>增強</strong>兩個元素，其中切點可簡單理解為我們寫的表達式，增強則是根據@Before、@Around、@After等註解創建的對應的Advice類。切面創建好後則需要循環判斷哪些切面能對當前的Bean實例的方法進行增強並排序，最後通過ProxyFactory創建代理對象。</p><h2 class=line>AOP鏈式調用</h2><p>熟悉JDK動態代理的都知道通過代理對象調用方法時，會進入到<strong>InvocationHandler</strong>對象的<strong>invoke</strong>方法，所以我們直接從<strong>JdkDynamicAopProxy</strong>的這個方法開始：</p><pre><code>    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        MethodInvocation invocation;        Object oldProxy = null;        boolean setProxyContext = false;        //從代理工廠中拿到TargetSource對象，該對象包裝了被代理實例bean        TargetSource targetSource = this.advised.targetSource;        Object target = null;        try {            //被代理對象的equals方法和hashCode方法是不能被代理的，不會走切面            .......            Object retVal;            // 可以從當前線程中拿到代理對象            if (this.advised.exposeProxy) {                // Make invocation available if necessary.                oldProxy = AopContext.setCurrentProxy(proxy);                setProxyContext = true;            }            //這個target就是被代理實例            target = targetSource.getTarget();            Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);            //從代理工廠中拿過濾器鏈 Object是一個MethodInterceptor類型的對象，其實就是一個advice對象            List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);            //如果該方法沒有執行鏈，則說明這個方法不需要被攔截，則直接反射調用            if (chain.isEmpty()) {                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);            }            else {                invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);                retVal = invocation.proceed();            }            // Massage return value if necessary.            Class&lt;?&gt; returnType = method.getReturnType();            if (retVal != null &amp;&amp; retVal == target &amp;&amp;                    returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;                    !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {                retVal = proxy;            }            return retVal;        }        finally {            if (target != null &amp;&amp; !targetSource.isStatic()) {                // Must have come from TargetSource.                targetSource.releaseTarget(target);            }            if (setProxyContext) {                // Restore old proxy.                AopContext.setCurrentProxy(oldProxy);            }        }    }</code></pre><p>這段代碼比較長，我刪掉了不關鍵的地方。首先來看<strong>this.advised.exposeProxy</strong>這個屬性，這在@EnableAspectJAutoProxy註解中可以配置，當為true時，會將該代理對象設置到<strong>當前線程的ThreadLocal對象</strong>中，這樣就可以通過<strong>AopContext.currentProxy</strong>拿到代理對象。這個有什麼用呢？我相信有經驗的Java開發都遇到過這樣一個BUG，在Service實現類中調用本類中的另一個方法時，事務不會生效，這是因為直接通過this調用就不會調用到代理對象的方法，而是原對象的，所以事務切面就沒有生效。因此這種情況下就可以從<strong>當前線程的ThreadLocal對象</strong>拿到代理對象，不過實際上直接使用@Autowired注入自己本身也可以拿到代理對象。接下來就是通過<strong>getInterceptorsAndDynamicInterceptionAdvice</strong>拿到執行鏈，看看具體做了哪些事情：</p><pre><code>    public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(            Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) {        AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();        //從代理工廠中獲得該被代理類的所有切面advisor，config就是代理工廠對象        Advisor[] advisors = config.getAdvisors();        List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(advisors.length);        Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());        Boolean hasIntroductions = null;        for (Advisor advisor : advisors) {            //大部分走這裡            if (advisor instanceof PointcutAdvisor) {                // Add it conditionally.                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;                //如果切面的pointCut和被代理對象是匹配的，說明是切面要攔截的對象                if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {                    MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();                    boolean match;                    if (mm instanceof IntroductionAwareMethodMatcher) {                        if (hasIntroductions == null) {                            hasIntroductions = hasMatchingIntroductions(advisors, actualClass);                        }                        match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);                    }                    else {                        //接下來判斷方法是否是切面pointcut需要攔截的方法                        match = mm.matches(method, actualClass);                    }                    //如果類和方法都匹配                    if (match) {                        //獲取到切面advisor中的advice，並且包裝成MethodInterceptor類型的對象                        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);                        if (mm.isRuntime()) {                            for (MethodInterceptor interceptor : interceptors) {                                interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));                            }                        }                        else {                            interceptorList.addAll(Arrays.asList(interceptors));                        }                    }                }            }            //如果是引介切面            else if (advisor instanceof IntroductionAdvisor) {                IntroductionAdvisor ia = (IntroductionAdvisor) advisor;                if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {                    Interceptor[] interceptors = registry.getInterceptors(advisor);                    interceptorList.addAll(Arrays.asList(interceptors));                }            }            else {                Interceptor[] interceptors = registry.getInterceptors(advisor);                interceptorList.addAll(Arrays.asList(interceptors));            }        }        return interceptorList;    }</code></pre><p>這也是個長方法，看關鍵的部分，因為之前我們創建的基本上都是<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>對象，該類是<strong>PointcutAdvisor</strong>的實現類，所以會進入第一個if判斷裡，這裡首先進行匹配，看<strong>切點</strong>和<strong>當前對象</strong>以及該對象的哪些<strong>方法</strong>匹配，如果能匹配上，則調用<strong>getInterceptors</strong>獲取執行鏈：</p><pre><code>    private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;&gt;(3);    public DefaultAdvisorAdapterRegistry() {        registerAdvisorAdapter(new MethodBeforeAdviceAdapter());        registerAdvisorAdapter(new AfterReturningAdviceAdapter());        registerAdvisorAdapter(new ThrowsAdviceAdapter());    }    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {        List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3);        Advice advice = advisor.getAdvice();        //如果是MethodInterceptor類型的，如：AspectJAroundAdvice        //AspectJAfterAdvice        //AspectJAfterThrowingAdvice        if (advice instanceof MethodInterceptor) {            interceptors.add((MethodInterceptor) advice);        }        //處理 AspectJMethodBeforeAdvice  AspectJAfterReturningAdvice        for (AdvisorAdapter adapter : this.adapters) {            if (adapter.supportsAdvice(advice)) {                interceptors.add(adapter.getInterceptor(advisor));            }        }        if (interceptors.isEmpty()) {            throw new UnknownAdviceTypeException(advisor.getAdvice());        }        return interceptors.toArray(new MethodInterceptor[0]);    }</code></pre><p>這裡我們可以看到如果是<strong>MethodInterceptor</strong>的實現類，則直接添加到鏈中，如果不是，則需要通過<strong>適配器</strong>去包裝後添加，剛好這裡有<strong>MethodBeforeAdviceAdapter</strong>和<strong>AfterReturningAdviceAdapter</strong>兩個適配器對應上文兩個沒有實現<strong>MethodInterceptor</strong>接口的類。最後將<strong>Interceptors</strong>返回。</p><pre><code>if (chain.isEmpty()) {    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);}else {    // We need to create a method invocation...    invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);    // Proceed to the joinpoint through the interceptor chain.    retVal = invocation.proceed();}</code></pre><p>返回到<strong>invoke</strong>方法後，如果執行鏈為空，說明該方法不需要被增強，所以直接反射調用原對象的方法（注意傳入的是TargetSource封裝的被代理對象）；反之，則通過<strong>ReflectiveMethodInvocation</strong>類進行鏈式調用，關鍵方法就是<strong>proceed</strong>：</p><pre><code>    private int currentInterceptorIndex = -1;    public Object proceed() throws Throwable {        //如果執行鏈中的advice全部執行完，則直接調用joinPoint方法，就是被代理方法        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {            return invokeJoinpoint();        }        Object interceptorOrInterceptionAdvice =                this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {            InterceptorAndDynamicMethodMatcher dm =                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;            Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());            if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {                return dm.interceptor.invoke(this);            }            else {                return proceed();            }        }        else {            //調用MethodInterceptor中的invoke方法            return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);        }    }</code></pre><p>這個方法的核心就在兩個地方：<strong>invokeJoinpoint</strong>和<strong>interceptorOrInterceptionAdvice.invoke(this)</strong>。當增強方法調用完後就會通過前者調用到被代理的方法，否則則是依次調用<strong>Interceptor</strong>的<strong>invoke</strong>方法。下面就分別看看每個<strong>Interceptor</strong>是怎麼實現的。</p><ul><li>AspectJAroundAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        if (!(mi instanceof ProxyMethodInvocation)) {            throw new IllegalStateException("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);        }        ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;        ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);        JoinPointMatch jpm = getJoinPointMatch(pmi);        return invokeAdviceMethod(pjp, jpm, null, null);    }</code></pre><ul><li>MethodBeforeAdviceInterceptor -> AspectJMethodBeforeAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());        return mi.proceed();    }    public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {        invokeAdviceMethod(getJoinPointMatch(), null, null);    }</code></pre><ul><li>AspectJAfterAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        try {            return mi.proceed();        }        finally {            invokeAdviceMethod(getJoinPointMatch(), null, null);        }    }</code></pre><ul><li>AfterReturningAdviceInterceptor -> AspectJAfterReturningAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        Object retVal = mi.proceed();        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());        return retVal;    }    public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable {        if (shouldInvokeOnReturnValueOf(method, returnValue)) {            invokeAdviceMethod(getJoinPointMatch(), returnValue, null);        }    }</code></pre><ul><li>AspectJAfterThrowingAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        try {            return mi.proceed();        }        catch (Throwable ex) {            if (shouldInvokeOnThrowing(ex)) {                invokeAdviceMethod(getJoinPointMatch(), null, ex);            }            throw ex;        }    }</code></pre><p>這裡的調用順序是怎樣的呢？其核心就是通過<strong>proceed</strong>方法控制流程，每執行完一個Advice就會回到<strong>proceed</strong>方法中調用下一個Advice。可以思考一下，怎麼才能讓調用結果滿足如下圖的<strong>執行順序</strong>。</p><div class=pgc-img><img alt=這一次搞懂Spring代理創建+AOP鏈式調用過程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b56c9dee30924620b3ed4175efd82096><p class=pgc-img-caption></p></div><p><br></p><p>以上就是AOP的鏈式調用過程，但是這只是只有一個切面類的情況，如果有多個@Aspect類呢，這個調用過程又是怎樣的？其核心思想和“棧”一樣，就是“<strong>先進後出，後進先出</strong>”。</p><h2 class=line>AOP擴展知識</h2><h3 class=line>一、自定義全局攔截器Interceptor</h3><p>在上文創建代理對象的時候有這樣一個方法：</p><pre><code>    protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) {        //自定義MethodInterceptor.拿到setInterceptorNames方法注入的Interceptor對象        Advisor[] commonInterceptors = resolveInterceptorNames();        List&lt;Object&gt; allInterceptors = new ArrayList&lt;&gt;();        if (specificInterceptors != null) {            allInterceptors.addAll(Arrays.asList(specificInterceptors));            if (commonInterceptors.length &gt; 0) {                if (this.applyCommonInterceptorsFirst) {                    allInterceptors.addAll(0, Arrays.asList(commonInterceptors));                }                else {                    allInterceptors.addAll(Arrays.asList(commonInterceptors));                }            }        }        Advisor[] advisors = new Advisor[allInterceptors.size()];        for (int i = 0; i &lt; allInterceptors.size(); i++) {            //對自定義的advice要進行包裝，把advice包裝成advisor對象，切面對象            advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));        }        return advisors;    }</code></pre><p>這個方法的作用就在於我們可以擴展我們自己的Interceptor，首先通過<strong>resolveInterceptorNames</strong>方法獲取到通過<strong>setInterceptorNames</strong>方法設置的Interceptor，然後調用<strong>DefaultAdvisorAdapterRegistry.wrap</strong>方法將其包裝為<strong>DefaultPointcutAdvisor</strong>對象並返回：</p><pre><code>    public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {        if (adviceObject instanceof Advisor) {            return (Advisor) adviceObject;        }        if (!(adviceObject instanceof Advice)) {            throw new UnknownAdviceTypeException(adviceObject);        }        Advice advice = (Advice) adviceObject;        if (advice instanceof MethodInterceptor) {            return new DefaultPointcutAdvisor(advice);        }        for (AdvisorAdapter adapter : this.adapters) {            if (adapter.supportsAdvice(advice)) {                return new DefaultPointcutAdvisor(advice);            }        }        throw new UnknownAdviceTypeException(advice);    }    public DefaultPointcutAdvisor(Advice advice) {        this(Pointcut.TRUE, advice);    }</code></pre><p>需要注意<strong>DefaultPointcutAdvisor</strong>構造器裡面傳入了一個<strong>Pointcut.TRUE</strong>，表示這種擴展的Interceptor是全局的攔截器。下面來看看如何使用：</p><pre><code>public class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object invoke(MethodInvocation invocation) throws Throwable {        System.out.println("自定義攔截器");        return invocation.proceed();    }}</code></pre><p>首先寫一個類實現<strong>MethodInterceptor 接口，在invoke</strong>方法中實現我們的攔截邏輯，然後通過下面的方式測試，只要<strong>UserService 有AOP攔截就會發現自定義的MyMethodInterceptor</strong>也生效了。</p><pre><code>    public void costomInterceptorTest() {        AnnotationAwareAspectJAutoProxyCreator bean = applicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);        bean.setInterceptorNames("myMethodInterceptor ");        UserService userService = applicationContext.getBean(UserService.class);        userService.queryUser("dark");    }</code></pre><p>但是如果換個順序，像下面這樣：</p><pre><code>    public void costomInterceptorTest() {        UserService userService = applicationContext.getBean(UserService.class);        AnnotationAwareAspectJAutoProxyCreator bean = applicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);        bean.setInterceptorNames("myMethodInterceptor ");        userService.queryUser("dark");    }</code></pre><p>這時自定義的全局攔截器就沒有作用了，這是為什麼呢？因為當執行<strong>getBean</strong>的時候，如果有切面匹配就會通過<strong>ProxyFactory</strong>去創建代理對象，注意<strong>Interceptor</strong>是存到這個Factory對象中的，而這個對象和代理對象是<strong>一一對應</strong>的，因此調用<strong>getBean</strong>時，還沒有<strong>myMethodInterceptor</strong>這個對象，自定義攔截器就沒有效果了，也就是說要想自定義攔截器生效，就必須在代理對象生成之前註冊進去。</p><h3 class=line>二、循環依賴三級緩存存在的必要性</h3><p>在上一篇文章我分析了Spring是如何通過三級緩存來解決循環依賴的問題的，但你是否考慮過<strong>第三級緩存</strong>為什麼要存在？我直接將bean存到二級不就行了麼，為什麼還要存一個<strong>ObjectFactory</strong>對象到<strong>第三級緩存</strong>中？這個在學習了AOP之後就很清楚了，因為我們在@Autowired對象時，想要注入的不一定是Bean本身，而是想要注入一個<strong>修改</strong>過後的對象，如<strong>代理對象</strong>。在<strong>AbstractAutowireCapableBeanFactory.getEarlyBeanReference</strong>方法中循環調用了<strong>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</strong>方法，<strong>AbstractAutoProxyCreator</strong>對象就實現了該方法：</p><pre><code>    public Object getEarlyBeanReference(Object bean, String beanName) {        Object cacheKey = getCacheKey(bean.getClass(), beanName);        if (!this.earlyProxyReferences.contains(cacheKey)) {            this.earlyProxyReferences.add(cacheKey);        }        // 創建代理對象        return wrapIfNecessary(bean, beanName, cacheKey);    }</code></pre><p>因此，當我們想要對循壞依賴的Bean做出<strong>修改</strong>時，就可以像AOP這樣做。</p><h3 class=line>三、如何在Bean創建之前提前創建代理對象</h3><p>Spring的代理對象基本上都是在Bean實例化完成之後創建的，但在文章開始我就說過，Spring也提供了一個機會在創建Bean對象之前就創建代理對象，在<strong>AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation</strong>方法中：</p><pre><code>    protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {        Object bean = null;        if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {            // Make sure bean class is actually resolved at this point.            if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {                Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);                if (targetType != null) {                    bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);                    if (bean != null) {                        bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);                    }                }            }            mbd.beforeInstantiationResolved = (bean != null);        }        return bean;    }    protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) {                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);                if (result != null) {                    return result;                }            }        }        return null;    }</code></pre><p>主要是<strong>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</strong>方法中，這裡又會進入到<strong>AbstractAutoProxyCreator</strong>類中：</p><pre><code>    public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);        if (targetSource != null) {            if (StringUtils.hasLength(beanName)) {                this.targetSourcedBeans.add(beanName);            }            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);            this.proxyTypes.put(cacheKey, proxy.getClass());            return proxy;        }        return null;    }    protected TargetSource getCustomTargetSource(Class&lt;?&gt; beanClass, String beanName) {        // We can't create fancy target sources for directly registered singletons.        if (this.customTargetSourceCreators != null &amp;&amp;                this.beanFactory != null &amp;&amp; this.beanFactory.containsBean(beanName)) {            for (TargetSourceCreator tsc : this.customTargetSourceCreators) {                TargetSource ts = tsc.getTargetSource(beanClass, beanName);                if (ts != null) {                    return ts;                }            }        }        // No custom TargetSource found.        return null;    }</code></pre><p>看到這裡大致應該明白了，先是獲取到一個<strong>自定義的TargetSource</strong>對象，然後創建代理對象，所以我們首先需要自己實現一個<strong>TargetSource</strong>類，這裡直接繼承一個抽象類，<strong>getTarget</strong>方法則返回原始對象：</p><pre><code>public class MyTargetSource extends AbstractBeanFactoryBasedTargetSource {    @Override    public Object getTarget() throws Exception {        return getBeanFactory().getBean(getTargetBeanName());    }}</code></pre><p>但這還不夠，上面首先判斷了<strong>customTargetSourceCreators!=null</strong>，而這個屬性是個數組，可以通過下面這個方法設置進來：</p><pre><code>    public void setCustomTargetSourceCreators(TargetSourceCreator... targetSourceCreators) {        this.customTargetSourceCreators = targetSourceCreators;    }</code></pre><p>所以我們還要實現一個<strong>TargetSourceCreator</strong>類，同樣繼承一個抽象類實現，並只對<strong>userServiceImpl</strong>對象進行攔截：</p><pre><code>public class MyTargetSourceCreator extends AbstractBeanFactoryBasedTargetSourceCreator {    @Override    protected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(Class&lt;?&gt; beanClass, String beanName) {        if (getBeanFactory() instanceof ConfigurableListableBeanFactory) {            if(beanName.equalsIgnoreCase("userServiceImpl")) {                return new MyTargetSource();            }        }        return null;    }}</code></pre><p><strong>createBeanFactoryBasedTargetSource</strong>方法是在<strong>AbstractBeanFactoryBasedTargetSourceCreator.getTargetSource</strong>中調用的，而<strong>getTargetSource</strong>就是在上面<strong>getCustomTargetSource</strong>中調用的。以上工作做完後，還需要將其設置到<strong>AnnotationAwareAspectJAutoProxyCreator</strong>對象中，因此需要我們注入這個對象：</p><pre><code>@Configurationpublic class TargetSourceCreatorBean {    @Autowired    private BeanFactory beanFactory;   @Bean    public AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator() {        AnnotationAwareAspectJAutoProxyCreator creator = new AnnotationAwareAspectJAutoProxyCreator();        MyTargetSourceCreator myTargetSourceCreator = new MyTargetSourceCreator();        myTargetSourceCreator.setBeanFactory(beanFactory);        creator.setCustomTargetSourceCreators(myTargetSourceCreator);        return creator;    }}</code></pre><p>這樣，當我們通過getBean獲取<strong>userServiceImpl</strong>的對象時，就會優先生成代理對象，然後在調用執行鏈的過程中再通過<strong>TargetSource.getTarget</strong>獲取到被代理對象。但是，為什麼我們在<strong>getTarget</strong>方法中調用<strong>getBean</strong>就能拿到被代理對象呢？繼續探究，通過斷點我發現從<strong>getTarget</strong>進入時，在<strong>resolveBeforeInstantiation</strong>方法中返回的bean就是null了，而<strong>getBeanPostProcessors</strong>方法返回的<strong>Processors</strong>中也沒有了<strong>AnnotationAwareAspectJAutoProxyCreator</strong>對象，也就是沒有進入到<strong>AbstractAutoProxyCreator.postProcessBeforeInstantiation</strong>方法中，所以不會再次獲取到代理對象，那<strong>AnnotationAwareAspectJAutoProxyCreator</strong>對象是在什麼時候移除的呢？帶著問題，我開始反推，發現在<strong>AbstractBeanFactoryBasedTargetSourceCreator</strong>類中有這樣一個方法<strong>buildInternalBeanFactory</strong>：</p><pre><code>    protected DefaultListableBeanFactory buildInternalBeanFactory(ConfigurableBeanFactory containingFactory) {        DefaultListableBeanFactory internalBeanFactory = new DefaultListableBeanFactory(containingFactory);        // Required so that all BeanPostProcessors, Scopes, etc become available.        internalBeanFactory.copyConfigurationFrom(containingFactory);        // Filter out BeanPostProcessors that are part of the AOP infrastructure,        // since those are only meant to apply to beans defined in the original factory.        internalBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor -&gt;                beanPostProcessor instanceof AopInfrastructureBean);        return internalBeanFactory;    }</code></pre><p>在這裡移除掉了所有<strong>AopInfrastructureBean</strong>的子類，而<strong>AnnotationAwareAspectJAutoProxyCreator</strong>就是其子類，那這個方法是在哪裡調用的呢？繼續反推：</p><pre><code>    protected DefaultListableBeanFactory getInternalBeanFactoryForBean(String beanName) {        synchronized (this.internalBeanFactories) {            DefaultListableBeanFactory internalBeanFactory = this.internalBeanFactories.get(beanName);            if (internalBeanFactory == null) {                internalBeanFactory = buildInternalBeanFactory(this.beanFactory);                this.internalBeanFactories.put(beanName, internalBeanFactory);            }            return internalBeanFactory;        }    }    public final TargetSource getTargetSource(Class&lt;?&gt; beanClass, String beanName) {        AbstractBeanFactoryBasedTargetSource targetSource =                createBeanFactoryBasedTargetSource(beanClass, beanName);        // 創建完targetSource後就移除掉AopInfrastructureBean類型的BeanPostProcessor對象，如AnnotationAwareAspectJAutoProxyCreator        DefaultListableBeanFactory internalBeanFactory = getInternalBeanFactoryForBean(beanName);        ......        return targetSource;    }</code></pre><p>至此，關於<strong>TargetSource</strong>接口擴展的原理就搞明白了。</p><h1 class=line>總結</h1><p>本篇篇幅比較長，主要搞明白Spring代理對象是如何創建的以及AOP鏈式調用過程，而後面的擴展則是對AOP以及Bean創建過程中一些疑惑的補充，可根據實際情況學習掌握。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>搞懂</a></li><li><a>Spring</a></li><li><a>創建</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html alt=20個機械設計知識點總結，搞懂也是半個行家 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html title=20個機械設計知識點總結，搞懂也是半個行家>20個機械設計知識點總結，搞懂也是半個行家</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html alt=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/433259b5-1936-4cee-ab74-70aef36536ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html title=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理>（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html alt=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/47783c95e3a34185be9ff00f54b4fe7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html title=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？>電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac62942e.html alt=禪城創建放心消費城市 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152116341963423636ee2f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac62942e.html title=禪城創建放心消費城市>禪城創建放心消費城市</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html alt=軸承保持架斷裂原因，終於搞懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/926568ad42794eac8db9ccfc13716933 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html title=軸承保持架斷裂原因，終於搞懂了！>軸承保持架斷裂原因，終於搞懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html alt=「工程造價」搞懂這41個問題，你就是造價大神 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/61e6d766-6c64-42b0-8adc-44437be425ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html title=「工程造價」搞懂這41個問題，你就是造價大神>「工程造價」搞懂這41個問題，你就是造價大神</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dccc27aa.html alt=搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/45dfe66dfe2b42088ca53ab0c5d316b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dccc27aa.html title=搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏>搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/142b983a.html alt=一文搞懂常用鋼材型號、性能特性，收藏隨時查看！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533653259067c6eef0dcc2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/142b983a.html title=一文搞懂常用鋼材型號、性能特性，收藏隨時查看！>一文搞懂常用鋼材型號、性能特性，收藏隨時查看！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00a88a85.html alt="沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rd1uElWC8gP2we style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00a88a85.html title="沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃">沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/187187bc.html alt="技術趣講 | 60 分鐘搞懂「正則表達式」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/eaee8d2e512c44168627b8f244fb5e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/187187bc.html title="技術趣講 | 60 分鐘搞懂「正則表達式」">技術趣講 | 60 分鐘搞懂「正則表達式」</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>