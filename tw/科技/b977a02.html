<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux系統移植之——在 U-BOOT 對 Nand Flash 的支持，先收藏 | 极客快訊</title><meta property="og:title" content="Linux系統移植之——在 U-BOOT 對 Nand Flash 的支持，先收藏 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3fbc533d28464dae828bdfd33c49046d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b977a02.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><meta property="article:published_time" content="2020-10-29T20:53:12+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:12+08:00"><meta name=Keywords content><meta name=description content="Linux系統移植之——在 U-BOOT 對 Nand Flash 的支持，先收藏"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/b977a02.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux系統移植之——在 U-BOOT 對 Nand Flash 的支持，先收藏</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>上章節講了Nand flash驅動的編寫與移植，本章節主要講在 U-BOOT 對 Nand Flash 的支持，學linux的建議收藏，以後工作中會遇到。</p><pre><code>說明：本人作為一名工作多年的程序員，給大家都是精心挑選的資料，希望對大家的學習有幫助。</code></pre><p>本章主要內容如下：</p><p>3 在 U­BOOT 對 Nand Flash 的支持</p><p>3.1 U­BOOT 對從 Nand Flash 啟動的支持</p><p>3.1.1 從 Nand Flash 啟動 U­BOOT 的基本原理</p><p>3.1.2 支持 Nand Flash 啟動代碼說明</p><p>3.2 U­BOOT 對 Nand Flash 命令的支持</p><p>3.2.1 主要數據結構介紹</p><p>3.2.2 支持的命令函數說明</p><p>4 在 Linux 對 Nand Flash 的支持</p><p>4.1 Linux 下 Nand Flash 調用關係</p><p>4.1.1 Nand Flash 設備添加時數據結構包含關係</p><p>4.1.2 Nand Flash 設備註冊時數據結構包含關係</p><p>4.2 Linux 下 Nand Flash 驅動主要數據結構說明</p><p>4.2.1 s3c2410 專有數據結構</p><p>4.2.2 Linux 通用數據結構說明</p><p>4.3.1 註冊 driver_register</p><p>4.3.2 探測設備 probe</p><p>4.3.3 初始化 Nand Flash 控制器</p><p>4.3.4 移除設備</p><p>4.3.5 Nand Flash 芯片初始化</p><p>4.3.6 讀 Nand Flash</p><p>4.3.7 寫 Nand Flash</p><p><br></p><div class=pgc-img><img alt="Linux系統移植之——在 U-BOOT 對 Nand Flash 的支持，先收藏" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3fbc533d28464dae828bdfd33c49046d><p class=pgc-img-caption></p></div><p><br></p><p><strong>3.1 U-BOOT 對從 Nand Flash 啟動的支持</strong></p><p><strong>3.1.1 從 Nand Flash 啟動 U-BOOT 的基本原理</strong></p><p>1. 前 4K 的問題</p><p>如果 S3C2410 被配置成從 Nand Flash 啟動(配置由硬件工程師在電路板設置), S3C2410 的 Nand Flash 控制器</p><p>有一個特殊的功能, 在 S3C2410 上電後, Nand Flash 控制器會自動的把 Nand Flash 上的前 4K 數據搬移到 4K 內部</p><p>RAM 中, 並把 0x00000000 設置內部 RAM 的起始地址, CPU 從內部 RAM 的 0x00000000 位置開始啟動。這個過</p><p>程不需要程序干涉。</p><p>程序員需要完成的工作，是把最核心的啟動程序放在 Nand Flash 的前 4K 中。</p><p>2. 啟動程序的安排</p><p>由於 Nand Flash 控制器從 Nand Flash 中搬移到內部 RAM 的代碼是有限的,所以, 在啟動代碼的前 4K 裡,我</p><p>們必須完成 S3C2410 的核心配置以及把啟動代碼(UBOOT)剩餘部分搬到 RAM 中運行。以 UBOOT 為例, 前 4K</p><p>完成的主要工作, 見第四部分的 2.2 節。</p><p><strong>3.1.2 支持 Nand Flash 啟動代碼說明</strong></p><p>首先在 include/configs/crane2410.h 中加入 CONFIG_S3C2410_NAND_BOOT, 如下：</p><p>#define CONFIG_S3C2410_NAND_BOOT 1</p><p>支持從 Nand Flash 中啟動.</p><p>1. 執行 Nand Flash 初始化</p><p>下面代碼在 cpu/arm920t/start.S 中</p><p>#ifdef CONFIG_S3C2410_NAND_BOOT</p><p>copy_myself:</p><p>mov r10, lr</p><p>ldr sp, DW_STACK_START @安裝棧的起始地址</p><p>mov fp, #0 @初始化幀指針寄存器</p><p>bl nand_reset @跳到復位 C 函數去執行</p><p>...</p><p>DW_STACK_START:</p><p>.word STACK_BASE+STACK_SIZE­4</p><p>2. nand_reset C 代碼</p><p>下面代碼被加在/board/crane2410/crane2410.c 中</p><p>void nand_reset(void)</p><p>{</p><p>int i;</p><p>/* 設置 Nand Flash 控制器 */</p><p>rNFCONF=(1&lt;&lt;15)|(1&lt;&lt;14)|(1&lt;&lt;13)|(1&lt;&lt;12)|(1&lt;&lt;11)|(TACLS&lt;&lt;8)|(TWRPH0&lt;&lt;4)|(TWRPH1&lt;&lt;0);</p><p>/* 給 Nand Flash 芯片發送復位命令 */</p><p>NF_nFCE_L();</p><p>NF_CMD(0xFF);</p><p>for(i=0; i&lt;10; i++);</p><p>NF_WAITRB(); NF_nFCE_H();</p><p>}</p><p>3. 從 Nand Flash 中把 UBOOT 拷貝到 RAM</p><p>@read U­BOOT from Nand Flash to RAM</p><p>ldr r0, =UBOOT_RAM_BASE @ 設置第 1 個參數: UBOOT 在 RAM 中的起始地址</p><p>mov r1, #0x0 @ 設置第 2 個參數:Nand Flash 的起始地址</p><p>mov r2, #0x20000 @ 設置第 3 個參數: UBOOT 的長度(128KB)</p><p>bl nand_read_whole @ 調用 nand_read_whole(), 該函數在 board/crane2410/crane2410.c 中</p><p>tst r0, #0x0 @ 如果函數的返回值為 0,表示執行成功.</p><p>beq ok_nand_read @ 執行內存比較</p><p>4. 從 Nand Flash 中把數據讀入到 RAM 中</p><p>int nand_read_whole(unsigned char *buf, unsigned long start_addr, int size)</p><p>{</p><p>int i, j;</p><p>/* 如果起始地址和長度不是 512 字節(1 頁)的倍數, 則返回錯誤代碼 */</p><p>if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {</p><p>return ­1;</p><p>}</p><p>/* 激活 Nand Flash */</p><p>NF_nFCE_L();</p><p>for(i=0; i&lt;10; i++);</p><p>i = start_addr;</p><p>while(i &lt; start_addr + size) {</p><p>/* 讀 A 區 */</p><p>rNFCMD = 0;</p><p>/* 寫入讀取地址 */</p><p>rNFADDR = i & 0xff;</p><p>rNFADDR = (i >> 9) & 0xff;</p><p>rNFADDR = (i >> 17) & 0xff;</p><p>rNFADDR = (i >> 25) & 0xff;</p><p>NF_WAITRB();</p><p>/* 讀出一頁(512 字節) */</p><p>for(j=0; j &lt; NAND_SECTOR_SIZE; j++, i++) {</p><p>*buf = (rNFDATA & 0xff);</p><p>buf++;</p><p>}</p><p>}</p><p>/* 停止驅動 Nand Flash */</p><p>NF_nFCE_H();</p><p>return 0;</p><p>}5. 校查搬移後的數據</p><p>把 RAM 中的前 4K 與內部中前 4K 進行比較, 如果完全相同, 則表示搬移成功.</p><p>ok_nand_read:</p><p>mov r0, #0x00000000 @內部 RAM 的起始地址</p><p>ldr r1, =UBOOT_RAM_BASE @UBOOT 在 RAM 中的起始地址</p><p>mov r2, #0x400 @比較 1024 次, 每次 4 字節, 4 bytes * 1024 = 4K­bytes</p><p>go_next: @ 比較 1024 次, 每次 4 個字節</p><p>ldr r3, [r0], #4</p><p>ldr r4, [r1], #4</p><p>teq r3, r4</p><p>bne notmatch</p><p>subs r2, r2, #4</p><p>beq done_nand_read</p><p>bne go_next</p><p>notmatch:</p><p>1:b 1b</p><p>done_nand_read:</p><p>mov pc, r10</p><p><strong>3.2 U-BOOT 對 Nand Flash 命令的支持</strong></p><p>在 U­BOOT 下對 Nand Flash 的支持主要是在命令行下實現對 nand flash 的操作。對 nand flash 實現的命令</p><p>為：nand info、nand device、nand read、nand write、nand erease、nand bad。</p><p>用到的主要數據結構有：struct nand_flash_dev、struct nand_chip。前者包括主要的芯片型號、存儲容量、</p><p>設備 ID、I/O 總線寬度等信息；後者是具體對 nand flash 進行操作時用到的信息。</p><p><strong>3.2.1 主要數據結構介紹</strong></p><p>1. struct nand_flash_dev 數據結構</p><p>該數據結構在 include/linux/mtd/nand.h 中定義，在 include/linux/mtd/nand_ids.h 中賦初值。</p><p>struct nand_flash_dev {</p><p>char *n<strong>ame;</strong></p><p><strong>/* 芯片名稱 */</strong></p><p>int manufacture_id; /* 廠商 ID */</p><p>int model_id; /* 模式 ID */</p><p>int chipshift; /* Nand Flash 地址位數 */</p><p>char page256; /* 表明是否時 256 字節一頁。1：是；0：否。*/</p><p>char pageadrlen; /* 完成一次地址傳送需要往 NFADDR 中傳送幾次。*/</p><p>unsigned long erasesize; /* 一次塊擦除可以擦除多少字節 */</p><p>int bus16; /* 地址線是否是 16 位，1：是；0：否 */</p><p>};</p><p>2. struct nand_chip 數據結構</p><p>該數據結構在 include/linux/mtd/nand.h 中定義. 該結構體定義出一個 Nand Flash 設備數組:</p><p>struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];</p><p>該數組在 nand_probe()中對其進行初始化.</p><p>struct nand_chip {</p><p>int</p><p>page_shift; /* Page 地址位數 */</p><p>u_char *data_buf; /* 本次讀出的一頁數據 */</p><p>u_char *data_cache; /* 讀出的一頁數據 */</p><p>int cache_page; /* 上次操作的頁號 */u_char ecc_code_buf[6]; /* ECC 校驗碼 */</p><p>u_char reserved[2];</p><p>char ChipID;</p><p>/* 芯片 ID 號 */</p><p>struct Nand *chips; /* Nand Flash 芯片列表, 表示支持幾個芯片為一個設備*/</p><p>int chipshift;</p><p>char* chips_name; /* Nand Flash 芯片名稱 */</p><p>unsigned long erasesize; /* 塊擦寫的大小 */</p><p>unsigned long mfr; /* 廠商 ID */</p><p>unsigned long id; /* 模式 ID */</p><p>char* name; /* 設備名稱 */</p><p>int numchips; /* 有幾塊 Nand Flash 芯片 */</p><p>char page256; /* 一頁是 256 字節, 還是 512 字節 */</p><p>char pageadrlen; /* 頁地址的長度 */</p><p>unsigned long IO_ADDR; /* 用於對 nand flash 進行尋址的地址值存放處 */</p><p>unsigned long totlen; /* Nand Flash 總共大小 */</p><p>uint oobblock; /* 一頁的大小。本款 nand flash 為 512 */</p><p>uint oobsize;</p><p>/* spare array 大小。本款 nand flash 為 16 */</p><p>uint eccsize; /* ECC 大小 */</p><p>int bus16; /* 地址線是否是 16 位，1：是；0：否 */</p><p>};</p><p><strong>3.2.2 支持的命令函數說明</strong></p><p>1. nand info/nand device</p><p>功能：顯示當前 nand flash 芯片信息。</p><p>函數調用關係如下(按先後順序)：</p><p>static void nand_print(struct nand_chip *nand) ;</p><p>2. nand erase</p><p>功能：擦除指定塊上的數據。</p><p>函數調用關係如下(按先後順序)：</p><p>int nand_erase(struct nand_chip* nand, size_t ofs, size_t len, int clean);</p><p>3. nand bad</p><p>功能：顯示壞塊。</p><p>函數調用關係如下(按先後順序)：</p><p>static void nand_print_bad(struct nand_chip* nand);</p><p>int check_block (struct nand_chip *nand, unsigned long pos);</p><p>4. nand read</p><p>功能：讀取 nand flash 信息到 SDRAM。</p><p>函數調用關係如下(按先後順序)：</p><p>int nand_rw (struct nand_chip* nand, int cmd,size_t start, size_t len, size_t * retlen, u_char * buf);</p><p>static int nand_read_ecc(struct nand_chip *nand, size_t start, size_t len,</p><p>size_t * retlen, u_char *buf, u_char *ecc_code);</p><p>static void NanD_ReadBuf (struct nand_chip *nand, u_char * data_buf, int cntr);</p><p>READ_NAND(adr);</p><p>5. nand write</p><p>功能：從 SDRAM 寫數據到 nand flash 中。</p><p>函數調用關係如下(按先後順序)：int nand_rw (struct nand_chip* nand, int cmd,size_t start, size_t len, size_t * retlen, u_char * buf);</p><p>static int nand_write_ecc (struct nand_chip* nand, size_t to, size_t len,</p><p>size_t * retlen, const u_char * buf, u_char * ecc_code);</p><p>static int nand_write_page (struct nand_chip *nand, int page, int col, int last, u_char * ecc_code);</p><p>WRITE_NAND(d , adr);</p><p><strong>3.2.3 U-BOOT 支持 Nand Flash 命令移植說明</strong></p><p>1. 設置配置選項</p><p>在 CONFIG_COMMANDS 中, 打開 CFG_CMD_NAND 選項.</p><p>#define CONFIG_COMMANDS \</p><p>(CONFIG_CMD_DFL</p><p>| \</p><p>CFG_CMD_CACHE</p><p>| \</p><p>CFG_CMD_NAND</p><p>| \</p><p>/*CFG_CMD_EEPROM |*/ \</p><p>/*CFG_CMD_I2C</p><p>|*/ \</p><p>/*CFG_CMD_USB</p><p>|*/ \</p><p>CFG_CMD_PING | \</p><p>CFG_CMD_REGINFO | \</p><p>CFG_CMD_DATE</p><p>| \</p><p>CFG_CMD_ELF)</p><p>#if (CONFIG_COMMANDS & CFG_CMD_NAND)</p><p>#define CFG_NAND_BASE 0x4E000000 /* Nand Flash 控制器在 SFR 區中起始寄存器地址 */</p><p>#define CFG_MAX_NAND_DEVICE 1 /* 支持的最在 Nand Flash 數據 */</p><p>#define SECTORSIZE 512 /* 1 頁的大小 */</p><p>#define NAND_SECTOR_SIZE SECTORSIZE</p><p>#define NAND_BLOCK_MASK (NAND_SECTOR_SIZE – 1) /* 頁掩碼 */</p><p>#define ADDR_COLUMN 1 /* 一個字節的 Column 地址 */</p><p>#define ADDR_PAGE 3 /* 3 字節的頁塊地址, A9­A25*/</p><p>#define ADDR_COLUMN_PAGE 4 /* 總共 4 字節的頁塊地址 */</p><p>#define NAND_ChipID_UNKNOWN 0x00 /* 未知芯片的 ID 號 */</p><p>#define NAND_MAX_FLOORS 1</p><p>#define NAND_MAX_CHIPS 1</p><p>/* Nand Flash 命令層底層接口函數 */</p><p>#define WRITE_NAND_COMMAND(d, adr) do {rNFCMD = d;} while(0)</p><p>#define WRITE_NAND_ADDRESS(d, adr) do {rNFADDR = d;} while(0)</p><p>#define WRITE_NAND(d, adr) do {rNFDATA = d;} while(0)</p><p>#define READ_NAND(adr) (rNFDATA)</p><p>#define NAND_WAIT_READY(nand) {while(!(rNFSTAT&(1&lt;&lt;0)));}</p><p>#define NAND_DISABLE_CE(nand) {rNFCONF |= (1&lt;&lt;11);}</p><p>#define NAND_ENABLE_CE(nand) {rNFCONF &= ~(1&lt;&lt;11);}</p><p>/* 下面一組操作對 Nand Flash 無效 */</p><p>#define NAND_CTL_CLRALE(nandptr)</p><p>#define NAND_CTL_SETALE(nandptr)</p><p>#define NAND_CTL_CLRCLE(nandptr)</p><p>#define NAND_CTL_SETCLE(nandptr)/* 允許 Nand Flash 寫校驗 */</p><p>#define CONFIG_MTD_NAND_VERIFY_WRITE 1</p><p>#endif /* CONFIG_COMMANDS & CFG_CMD_NAND*/</p><p>2. 加入自己的 Nand Flash 芯片型號</p><p>在 include/linux/mtd/ nand_ids.h 中的對如下結構體賦值進行修改:</p><p>static struct nand_flash_dev nand_flash_ids[] = {</p><p>......</p><p>{"Samsung K9F1208U0B", NAND_MFR_SAMSUNG, 0x76, 26, 0, 4, 0x4000, 0},</p><p>.......</p><p>}</p><p>這樣對於該款 Nand Flash 芯片的操作才能正確執行。</p><p>3. 編寫自己的 Nand Flash 初始化函數</p><p>在 board/crane2410/crane2410.c 中加入 nand_init()函數.</p><p>void nand_init(void)</p><p>{</p><p>/* 初始化 Nand Flash 控制器, 以及 Nand Flash 芯片 */</p><p>nand_reset();</p><p>/* 調用 nand_probe()來檢測芯片類型 */</p><p>printf ("%4lu MB\n", nand_probe(CFG_NAND_BASE) >> 20);</p><p>}</p><p>該函數在啟動時被 start_armboot()調用.</p><p><strong>4 在 Linux 對 Nand Flash 的支持</strong></p><p><strong>4.1 Linux 下 Nand Flash 調用關係</strong></p><p><strong>4.1.1 Nand Flash 設備添加時數據結構包含關係</strong></p><p>struct mtd_partition <strong>partition_info[]</strong></p><p>--> struct s3c2410_nand_<strong>set nandset</strong></p><p>--> struct s3c2410_platform_nand <strong>superlpplatfrom</strong></p><p>--> struct platform_device <strong>s3c_device_nand</strong></p><p><strong>在該數據結構的 name字段的初始化值"s3c2410-nand",必須與 Nand Flash設備驅動註冊時</strong></p><p><strong>struct device_driver結構中的 name字段相同,因為 platfrom bus 是依靠名字來匹配的.</strong></p><p><strong>-</strong>-> struct platform_device <strong>*smdk2410_devices[]</strong></p><p><strong>4.1.2 Nand Flash 設備註冊時數據結構包含關係</strong></p><p>struct device_driver s3c2410_nand_driver</p><p>-->struct device *dev</p><p>該數據構由系統分配.</p><p>-->struct platform_device *pdev</p><p>-->struct s3c2410_platform_nand *plat</p><p>-->struct s3c2410_nand_set nset</p><p>-->struct mtd_partition</p><p><strong>4.1.3 當發生系統調用時數據結構調用關係</strong></p><p>struct mtd_info它的*priv指向 chip</p><p>-->struct nand_chip</p><p>它的*priv指向 nmtd</p><p>-->struct s3c2410_nand_mtd</p><p>它是 s3c2410_nand_info 的一個字段</p><p>-->s3c2410_nand_info</p><p>它被設為 Nand Flash設備驅動的私有數據結構,在 Nand Flash設備驅動註冊時分配空間.</p><p>-->struct device</p><p><strong>4.2 Linux 下 Nand Flash 驅動主要數據結構說明</strong></p><p><strong>4.2.1 s3c2410 專有數據結構</strong></p><p>1. s3c2410_nand_set</p><p>struct s3c2410_nand_set {</p><p>int nr_chips; /* 芯片的數目 */</p><p>int nr_partitions; /* 分區的數目 */</p><p>char *name; /* 集合名稱 */</p><p>int <strong>nr_map; /* 可選, 底層邏輯到物理的芯片數目 */</strong></p><p>struct mtd_partition <strong>partitions; /* 分區列表 */</strong></p><p>};</p><p>2. s3c2410_platform_and</p><p>struct s3c2410_platform_nand {</p><p>/* timing information for controller, all times in nanoseconds */</p><p>int tacls; /* 從 CLE/ALE有效到 nWE/nOE 的時間 */</p><p>int twrph0; /* nWE/nOE 的有效時間 */</p><p>int twrph1; /* 從釋放 CLE/ALE到 nWE/nOE 不活動的時間 */</p><p>int nr_sets; /* 集合數目 */</p><p>struct s3c2410_nand_set <strong>sets; /* 集合列表 */</strong></p><p><strong>/* 根據芯片編號選擇有效集合 */</strong></p><p>void (*select_chip)(struct s3c2410_nand_set <strong>, int chip);</strong></p><p>};</p><p>3. s3c2410_nand_mtd</p><p>在 drivers/mtd/nand/s3c2410.c 中,</p><p>struct s3c2410_nand_mtd {</p><p>struct mtd_info mtd; /* MTD 信息 */</p><p>struct nand_chip chip; /* nand flash 芯片信息 */</p><p>struct s3c2410_nand_set <strong>set; /*</strong> nand flash 集合 */</p><p>struct s3c2410_nand_info *info; /* nand flash 信息 */</p><p>int scan_res;</p><p>};</p><p>4. s3c2410_nand_info</p><p>struct s3c2410_nand_info {</p><p>/* mtd info */</p><p>struct nand_hw_control controller; /* 硬件控制器 */</p><p>struct s3c2410_nand_mtd *mtds; /* MTD 設備表 */</p><p>struct s3c2410_platform_nand <strong>platform; /* Nand 設備的平臺 */</strong> /* device info */</p><p>struct device *device; /* 設備指針 */</p><p>struct resource *area; /* 資源指針 */</p><p>struct clk *clk; /* Nand Flash 時鐘 */</p><p>void __iomem *regs; /* 寄存器基地址(map後的邏輯地址) */</p><p>int mtd_count; /* MTD的數目 */</p><p>unsigned char is_s3c2440;</p><p>};</p><p>5. struct clk</p><p>在 arch/arm/mach­s3c2410/clock.h 中</p><p>struct clk {</p><p>struct list_head list; /* clock 列表結點 */</p><p>struct module *owner; /* 所屬模塊 */</p><p>struct clk *parent; /* 父結點 */</p><p>const char *name; /* 名稱 */</p><p>int id; /* 編號 */</p><p>atomic_t used; /* 使用者計數 */</p><p>unsigned long rate; /* 時鐘速率 */</p><p>unsigned long ctrlbit; /* 控制位 */</p><p>int (*enable)(struct clk *, int enable); /* Clock 打開方法 */</p><p>};</p><p><strong>4.2.2 Linux 通用數據結構說明</strong></p><p>1. device_driver</p><p>include/linux/device.h</p><p>struct device_driver {</p><p>const char * name; <strong>/* 驅動名稱 */</strong></p><p>struct bus_type * bus; /* 總線類型 */</p><p>struct completion unloaded; /* 卸載事件通知機制 */</p><p>struct kobject kobj; /* sys中的對象 */</p><p>struct klist klist_devices; /* 設備列表 */</p><p>struct klist_node knode_bus; /* 總線結點列表 */</p><p>struct module * owner;/* 所有者 */</p><p>/* 設備驅動通用方法 */</p><p>int (*probe) (struct device * dev); /* 探測設備 */</p><p>int (*remove) (struct device * dev); /* 移除設備 */</p><p>void (*shutdown) (struct device * dev); /* 關閉設備 */</p><p>/* 掛起設備 */</p><p>int (*suspend) (struct device * dev, pm_message_t state, u32 level);</p><p>int (*resume) (struct device * dev, u32 level); /* 恢復 */</p><p>};</p><p>2. platform_device</p><p>include/linux/device.h</p><p>struct platform_device {</p><p>const char * name; /* 名稱 */</p><p>u32 id; /* 設備編號, -1表示不支持同類多個設備 */</p><p>struct device dev; /* 設備 */</p><p>u32 num_resources; /* 資源數 */</p><p>struct resource * resource; /* 資源列表 */};</p><p>3. resource</p><p>struct resource {</p><p>const char <strong>name; /* 資源名稱 */</strong></p><p>unsigned long start, end; /* 開始位置和結束位置 */</p><p>unsigned long flags; /* 資源類型 */</p><p>/* 資源在資源樹中的父親,兄弟和孩子 */</p><p>struct resource *parent, *sibling, *child;</p><p>};</p><p>4. device</p><p>include/linux/device.h</p><p>struct device {</p><p>struct klist klist_children; /* 在設備列表中的孩子列表 */</p><p>struct klist_node knode_parent; /* 兄弟結點 */</p><p>struct klist_node knode_driver; /* 驅動結點 */</p><p>struct klist_node knode_bus; /* 總線結點 */</p><p>struct device <strong>parent; /* 父親 */</strong></p><p>struct kobject kobj; /* sys結點 */</p><p>char bus_id[BUS_ID_SIZE];</p><p>struct semaphore sem; /* 同步驅動的信號量 */</p><p>struct bus_type * bus; /* 總線類型 */</p><p>struct device_driver *driver; /* 設備驅動 */</p><p>void *driver_data; /* 驅動的私有數據 */</p><p>void *platform_data; /* 平臺指定的數據,為 device核心驅動保留 */</p><p>void *firmware_data; /* 固件指定的數據,為 device核心驅動保留 */</p><p>struct dev_pm_info power; /* 設備電源管理信息 */</p><p>u64 *dma_mask; /* DMA掩碼 */</p><p>u64 coherent_dma_mask;</p><p>struct list_head dma_pools; /* DMA緩衝池 */</p><p>struct dma_coherent_mem *dma_mem; /* 連續 DMA 內存的起始位置 */</p><p>void (*release)(struct device * dev); /* 釋放設置方法 */</p><p>};</p><p>5. nand_hw_control</p><p>include/linux/mtd/nand.h</p><p>struct nand_hw_control {</p><p>spinlock_t lock; /* 自旋鎖,用於硬件控制 */</p><p>struct nand_chip *active; /* 正在處理 MTD 設備 */</p><p>wait_queue_head_t wq; /* 等待隊列 */</p><p>};</p><p>6. nand_chip</p><p>include/linux/mtd/nand.h</p><p>struct nand_chip {</p><p>void __iomem *IO_ADDR_R; /* 讀地址 */</p><p>void __iomem *IO_ADDR_W; /* 寫地址 */ /* 字節操作 */</p><p>u_char (*read_byte)(struct mtd_info *mtd); /* 讀一個字節 */</p><p>void (*write_byte)(struct mtd_info *mtd, u_char byte); /* 寫一個字節 */</p><p>/* 雙字節操作 */</p><p>u16 (*read_word)(struct mtd_info <strong>mtd); /* 讀一個字 */</strong></p><p>void (*write_word)(struct mtd_info *mtd, u16 word); /* 寫一個字 */</p><p>/* buffer操作 */</p><p>void (*write_buf)(struct mtd_info *mtd, const u_char *buf, int len);</p><p>void (*read_buf)(struct mtd_info *mtd, u_char *buf, int len);</p><p>int (*verify_buf)(struct mtd_info *mtd, const u_char *buf, int len);</p><p>/* 選擇一個操作芯片 */</p><p>void (*select_chip)(struct mtd_info *mtd, int chip);</p><p>/* 壞塊檢查操作 */</p><p>int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);</p><p>/* 壞塊標記操作 */</p><p>int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);</p><p>/* 硬件控制操作 */</p><p>void (*hwcontrol)(struct mtd_info *mtd, int cmd);</p><p>/* 設備準備操作 */</p><p>int (*dev_ready)(struct mtd_info *mtd);</p><p>/* 命令發送操作 */</p><p>void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int</p><p>page_addr);</p><p>/* 等待命令完成 */</p><p>int (*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);</p><p>/* 計算 ECC 碼操作 */</p><p>int (*calculate_ecc)(struct mtd_info *mtd, const u_char *dat, u_char</p><p>*ecc_code);</p><p>/* 數據糾錯操作 */</p><p>int (*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc,</p><p>u_char *calc_ecc);</p><p>/* 開啟硬件 ECC */</p><p>void (*enable_hwecc)(struct mtd_info *mtd, int mode);</p><p>/* 擦除操作 */</p><p>void (*erase_cmd)(struct mtd_info *mtd, int page);</p><p>/* 檢查壞塊表 */</p><p>int (*scan_bbt)(struct mtd_info *mtd);</p><p>int eccmode; /* ECC 模式 */</p><p>int eccsize; /* ECC 計算時使用的字節數 */</p><p>int eccbytes; /* ECC 碼的字節數 */</p><p>int eccsteps; /* ECC 碼計算的步驟數 */</p><p>int chip_delay; /* 芯片的延遲時間 */</p><p>spinlock_t chip_lock; /* 芯片訪問的自旋鎖 */</p><p>wait_queue_head_t wq; /* 芯片訪問的等待隊列 */</p><p>nand_state_t state; /* Nand Flash狀態 */</p><p>int page_shift; /* 頁右移的位數,即 column地址位數 */</p><p>int phys_erase_shift; /* 塊右移的位數, 即 column和頁一共的地址位數 */</p><p>int bbt_erase_shift; /* 壞塊頁表的位數 */</p><p>int chip_shift; /* 該芯片總共的地址位數 */</p><p>u_char *data_buf; /* 數據緩衝區 */</p><p>u_char *oob_buf; /* oob 緩衝區 */</p><p>int oobdirty; /* oob 緩衝區是否需要重新初始化 */</p><p>u_char *data_poi; /* 數據緩衝區指針 */</p><p>unsigned int options; /* 芯片專有選項 */</p><p>int badblockpos;/* 壞塊標示字節在 OOB 中的位置 */</p><p>int numchips; /* 芯片的個數 */ unsigned long chipsize; /* 在多個芯片組中, 一個芯片的大小 */</p><p>int pagemask; /* 每個芯片頁數的屏蔽字, 通過它取出每個芯片包含多少個頁 */</p><p>int pagebuf; /* 在頁緩衝區中的頁號 */</p><p>struct nand_oobinfo *autooob; /* oob 信息 */</p><p>uint8_t *bbt; /* 壞塊頁表 */</p><p>struct nand_bbt_descr *bbt_td; /* 壞塊表描述 */</p><p>struct nand_bbt_descr *bbt_md; /* 壞塊表鏡像描述 */</p><p>struct nand_bbt_descr *badblock_pattern; /* 壞塊檢測模板 */</p><p>struct nand_hw_control *controller; /* 硬件控制 */</p><p>void *priv; /* 私有數據結構 */</p><p>/* 進行附加錯誤檢查 */</p><p>int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int</p><p>status, int page);</p><p>};</p><p>7. mtd_info</p><p>include/linux/mtd/mtd.h</p><p>struct mtd_info {</p><p>u_char type; /* 設備類型 */</p><p>u_int32_t flags; /* 設備標誌位組 */</p><p>u_int32_t size; /* 總共設備的大小 */</p><p>u_int32_t erasesize; /* 擦除塊的大小 */</p><p>u_int32_t oobblock; /* OOB塊的大小,如：512 個字節有一個 OOB */</p><p>u_int32_t oobsize; /* OOB數據的大小,如:一個 OOB 塊有 16 個字節 */</p><p>u_int32_t ecctype; /* ECC 校驗的類型 */</p><p>u_int32_t eccsize; /* ECC 碼的大小 */</p><p>char *name; /* 設備名稱 */</p><p>int index; /* 設備編號 */</p><p>/* oobinfo 信息,它可以通過 MEMSETOOBINFO ioctl 命令來設置 */</p><p>struct nand_oobinfo oobinfo;</p><p>u_int32_t oobavail; /* OOB區的有效字節數,為文件系統提供 */</p><p>/* 數據擦除邊界信息 */</p><p>int numeraseregions;</p><p>struct mtd_erase_region_info *eraseregions;</p><p>u_int32_t bank_size; /* 保留 */</p><p>/* 擦除操作 */</p><p>int (*erase) (struct mtd_info *mtd, struct erase_info *instr);</p><p>/* 指向某個執行代碼位置 */</p><p>int (*point) (struct mtd_info *mtd, loff_t from,</p><p>size_t len, size_t *retlen, u_char **mtdbuf);</p><p>/* 取消指向 */</p><p>void (*unpoint) (struct mtd_info *mtd, u_char * addr, loff_t from, size_t len);</p><p>/* 讀/寫操作 */</p><p>int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);</p><p>int (*write) (struct mtd_info *mtd, loff_t to, size_t len,</p><p>size_t *retlen, const u_char *buf);</p><p>/* 帶 ECC 碼的讀/寫操作 */</p><p>int (*read_ecc) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,</p><p>u_char *buf, u_char *eccbuf, struct nand_oobinfo *oobsel);</p><p>int (*write_ecc) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,</p><p>const u_char *buf, u_char *eccbuf, struct nand_oobinfo *oobsel); /* 帶 OOB 碼的讀/寫操作 */</p><p>int (*read_oob) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,</p><p>u_char *buf);</p><p>int (*write_oob) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,</p><p>const u_char *buf);</p><p>/* 提供訪問保護寄存器區的方法 */</p><p>int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);</p><p>int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len,</p><p>size_t *retlen, u_char *buf);</p><p>int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);</p><p>int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len,</p><p>size_t *retlen, u_char *buf);</p><p>int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len,</p><p>size_t *retlen, u_char *buf);</p><p>int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len);</p><p>/* 提供 readv和 writev 方法 */</p><p>int (*readv) (struct mtd_info *mtd, struct kvec *vecs, unsigned long count,</p><p>loff_t from, size_t *retlen);</p><p>int (*readv_ecc) (struct mtd_info *mtd, struct kvec *vecs, unsigned long count,</p><p>loff_t from, size_t *retlen, u_char *eccbuf,</p><p>struct nand_oobinfo *oobsel);</p><p>int (*writev) (struct mtd_info *mtd, const struct kvec *vecs,</p><p>unsigned long count, loff_t to, size_t *retlen);</p><p>int (*writev_ecc) (struct mtd_info *mtd, const struct kvec *vecs,</p><p>unsigned long count, loff_t to, size_t *retlen,</p><p>u_char *eccbuf, struct nand_oobinfo *oobsel);</p><p>/* 同步操作 */</p><p>void (*sync) (struct mtd_info *mtd);</p><p>/* 芯片級支持的加/解鎖操作 */</p><p>int (*lock) (struct mtd_info *mtd, loff_t ofs, size_t len);</p><p>int (*unlock) (struct mtd_info *mtd, loff_t ofs, size_t len);</p><p>/* 電源管理操作 */</p><p>int (*suspend) (struct mtd_info *mtd);</p><p>void (*resume) (struct mtd_info *mtd);</p><p>/* 壞塊管理操作 */</p><p>int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);</p><p>int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);</p><p>/* 重啟前的通知事件 */</p><p>struct notifier_block reboot_notifier;</p><p>void *priv; /* 私有數據結構 */</p><p>struct module *owner; /* 模塊所有者 */</p><p>int usecount; /* 使用次數 */</p><p>};</p><p><strong>4.3 Linux 下 Nand Flash 驅動說明4.3.1 註冊 driver_register</strong></p><p>通過 module_init(s3c2410_nand_init);註冊 Nand Flash 驅動. 在 s3c2410_nand_init ()中通過 driver_register()註冊</p><p>s3c2410_nand_driver驅動程序,如下所示:</p><p>static struct device_driver s3c2410_nand_driver = {</p><p>.name = "s3c2410-nand",</p><p>.bus = &platform_bus_type, /* 在 drivers/base/platform.c中定義 */</p><p>.probe = s3c2410_nand_probe,</p><p>.remove = s3c2410_nand_remove,</p><p>};</p><p><strong>4.3.2 探測設備 probe</strong></p><p>在註冊的 Nand Flash驅動程序中, probe 方法為 s3c2410_nand_probe(). s3c2410_nand_probe()再調用</p><p>s3c24xx_nand_probe(). 在該函數中, 把*info 作為 Nand Flash 驅動的私有數據結構, 並通過 dev_set_drvdata(dev,</p><p>info)把*info 保存在*device 的*driver_data 字段中.然後通過 clk_get(dev, "nand")獲取 Nand Flash的時鐘資</p><p>源, clk_use(info->clk)增加時鐘資源的使用計數, clk_enable(info->clk)開啟資源.填寫*info 的其它字段,</p><p>其中包括:</p><p>1. 通過 request_mem_region()為 Nand Flash 寄存器區申請 I/O 內存地址空間區,並通過 ioremap()把它映射到虛</p><p>擬地址空間.</p><p>2. 調用 s3c2410_nand_inithw()初始化 Nand Flash 控制器.</p><p>3. 為 mtd 設備分配設備信息的存儲空間.</p><p>4. 對當前 mtd 設備,調用 s3c2410_nand_init_chip()進行初始化.</p><p>5. 對當前 mtd 設備, 調用 nand_scan()檢測 Nand Flash 芯片, nand_scan()函數在 drivers/mtd/nand/nand_base.c 中</p><p>定義.該函數的作用是初始化 struct nand_chip 中一些方法, 並從 Nand Flash 中讀取芯片 ID, 並初始化 struct</p><p>mtd_info 中的方法.</p><p>6. 對當前 mtd 設備,加入其分區信息.</p><p>7. 如果還有更多 mtd 設備,到 4 執行.</p><p><strong>4.3.3 初始化 Nand Flash 控制器</strong></p><p>s3c2410_nand_inithw()函數會初始化 Nand Flash 控制器, 通過設置 Nand Flash 控制寄存器(S3C2410_NFCONF)來</p><p>完成, 這裡最重要的是根據 S3C2410 的 PCLK 計算出 tacls, twrph0 以及 twrph1 值.</p><p><strong>4.3.4 移除設備</strong></p><p>s3c2410_nand_remove()當設備被移除時,被 device 核心驅動調用.它完成的主要工作如下:</p><p>1. 把*device 的*driver_data 字段置空.</p><p>2. 釋放 mtd 設備信息.</p><p>3. 釋放 clk 資源.</p><p>4. 通過 iounmap()取消映地址空間.</p><p>5. 釋放申請的 I/O 內存資源.</p><p>6. 釋放設備私有數據*info 的空間.</p><p><strong>4.3.5 Nand Flash 芯片初始化</strong></p><p>s3c2410_nand_init_chip()初始化 struct nand_chip 中的一些主要字段以及方法.其中主要包括的方法有：</p><p>1. s3c2410_nand_hwcontrol(); 硬件控制</p><p>2. s3c2410_nand_devready(); 設備是否準備好</p><p>3. s3c2410_nand_write_buf(); 寫一個 buffer 到 nand flash</p><p>4. s3c2410_nand_read_buf(); 讀一個 buffer 到 nand flash</p><p>5. s3c2410_nand_select_chip(); 選擇操作芯片</p><p>如果支持 ECC 硬件校驗,還設置如下方法： 1. s3c2410_nand_correct_data(); 通過 ECC 碼校正數據</p><p>2. s3c2410_nand_enable_hwecc(); 開啟硬件 ECC 檢查</p><p>3. s3c2410_nand_calculate_ecc(); 計算 ECC 碼</p><p><strong>4.3.6 讀 Nand Flash</strong></p><p>當對 nand flash 的設備文件(nand flash 在/dev 下對應的文件)執行系統調用 read(),或在某個文件系統中對該</p><p>設備進行讀操作時. 會調用 struct mtd_info 中的 read方法,他們缺省調用函數為 nand_read(),在</p><p>drivers/mtd/nand/nand_base.c中定義.nand_read()調用 nand_do_read_ecc(),執行讀操作. 在</p><p>nand_do_read_ecc()函數中,主要完成如下幾項工作：</p><p>1. 會調用在 nand flash驅動中對 struct nand_chip 重載的 select_chip 方法,即</p><p>s3c2410_nand_select_chip()選擇要操作的 MTD 芯片.</p><p>2. 會調用在 struct nand_chip 中系統缺省的方法 cmdfunc 發送讀命令到 nand flash.</p><p>3. 會調用在 nand flash驅動中對 struct nand_chip 重載的 read_buf(),即 s3c2410_nand_read_buf()</p><p>從 Nand Flash的控制器的數據寄存器中讀出數據.</p><p>4. 如果有必要的話,會調用在 nand flash驅動中對 struct nand_chip 重載的</p><p>enable_hwecc,correct_data 以及 calculate_ecc方法,進行數據 ECC 校驗。</p><p><strong>4.3.7 寫 Nand Flash</strong></p><p>當對 nand flash 的設備文件(nand flash 在/dev 下對應的文件)執行系統調用 write(),或在某個文件系統中對該設備</p><p>進行讀操作時, 會調用 struct mtd_info 中 write 方法,他們缺省調用函數為 nand_write(),這兩個函數在</p><p>drivers/mtd/nand/nand_base.c中定義. nand_write()調用 nand_write_ecc(),執行寫操作.在</p><p>nand_do_write_ecc()函數中,主要完成如下幾項工作：</p><p>1. 會調用在 nand flash驅動中對 struct nand_chip 重載的 select_chip 方法,即</p><p>s3c2410_nand_select_chip()選擇要操作的 MTD 芯片.</p><p>2. 調用 nand_write_page()寫一個頁.</p><p>3. 在 nand_write_page()中,會調用在 struct nand_chip 中系統缺省的方法 cmdfunc 發送寫命令</p><p>到 nand flash.</p><p>4. 在 nand_write_page()中,會調用在 nand flash驅動中對 struct nand_chip 重載的</p><p>write_buf(),即 s3c2410_nand_write_buf()從 Nand Flash的控制器的數據寄存器中寫入數據.</p><p>5. 在 nand_write_page()中,會調用在 nand flash驅動中對 struct nand_chip 重載 waitfunc 方法,</p><p>該方法調用系統缺省函數 nand_wait(),該方法獲取操作狀態,並等待 nand flash操作完成.等</p><p>待操作完成,是調用 nand flash驅動中對 struct nand_chip 中重載的 dev_ready方法,即</p><p>s3c2410_nand_devready()函數.</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>系統</a></li><li><a>BOOT</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html alt=Linux系統常用命令大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html title=Linux系統常用命令大全>Linux系統常用命令大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d39b51ac.html alt=Linux操作系統存儲子系統核心技術之硬盤與RAID class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/12a0a3d09fd54be3b2087a5d45b798b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d39b51ac.html title=Linux操作系統存儲子系統核心技術之硬盤與RAID>Linux操作系統存儲子系統核心技術之硬盤與RAID</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/59993286.html alt="Linux 文件系統介紹" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/50a30000b2bb9135b878 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/59993286.html title="Linux 文件系統介紹">Linux 文件系統介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8024f20c.html alt="Linux 文件系統剖析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7ea491ff1de847568632e723367af267 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8024f20c.html title="Linux 文件系統剖析">Linux 文件系統剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13a20156.html alt=Linux文件系統101 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/184733a1b935442eaf00466d218e78af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13a20156.html title=Linux文件系統101>Linux文件系統101</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d5836cb.html alt=Linux文件系統介紹：Ext、XFS、Btrfs等，選擇適合自己的文件系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/988b5ddedbeb42e8ae01b11a525ff754 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d5836cb.html title=Linux文件系統介紹：Ext、XFS、Btrfs等，選擇適合自己的文件系統>Linux文件系統介紹：Ext、XFS、Btrfs等，選擇適合自己的文件系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/198ca4e7.html alt=Linux文件系統概念解釋 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153dc1ea3f434fef9762d98d4d308380 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/198ca4e7.html title=Linux文件系統概念解釋>Linux文件系統概念解釋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/11002b4c.html alt=Linux文件系統目錄標準介紹（FHS） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5fcf0579209e4a4794121746fe9b8ddc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/11002b4c.html title=Linux文件系統目錄標準介紹（FHS）>Linux文件系統目錄標準介紹（FHS）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b2909f2b.html alt=Linux文件系統與目錄結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b2909f2b.html title=Linux文件系統與目錄結構>Linux文件系統與目錄結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10be8693.html alt=一篇文章講清Linux操作系統的目錄結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/64f85cc0fcc548d99f56bd2567c34511 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10be8693.html title=一篇文章講清Linux操作系統的目錄結構>一篇文章講清Linux操作系統的目錄結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4717b88a.html alt=嵌入式開發之Linux系統中文件和目錄相關命令 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1d8b5c2d75ba4ed5a0cc99267cb18c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4717b88a.html title=嵌入式開發之Linux系統中文件和目錄相關命令>嵌入式開發之Linux系統中文件和目錄相關命令</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd75dea8.html alt="系統瞭解 Linux 文件系統" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3b15000077fa0e231516 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd75dea8.html title="系統瞭解 Linux 文件系統">系統瞭解 Linux 文件系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1b6548ae.html alt=詳解Linux系統架構--內核（內存、進程、設備、文件系統和網絡） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/69fc12e26bdd4ebf942d997de47a1396 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1b6548ae.html title=詳解Linux系統架構--內核（內存、進程、設備、文件系統和網絡）>詳解Linux系統架構--內核（內存、進程、設備、文件系統和網絡）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7ea2e49.html alt=Linux文件系統是怎麼工作的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/dc7369f3a6f547b4a03c383142a7af8c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7ea2e49.html title=Linux文件系統是怎麼工作的？>Linux文件系統是怎麼工作的？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>