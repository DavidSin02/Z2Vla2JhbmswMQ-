<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>輕量級內存計算引擎 | 极客快訊</title><meta property="og:title" content="輕量級內存計算引擎 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b92fec85d50b4526a29704cb376d028a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb7cde8a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb7cde8a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bb7cde8a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb7cde8a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb7cde8a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bb7cde8a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bb7cde8a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb7cde8a.html><meta property="article:published_time" content="2020-11-14T21:07:40+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:40+08:00"><meta name=Keywords content><meta name=description content="輕量級內存計算引擎"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/bb7cde8a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>輕量級內存計算引擎</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>內存計算指數據事先存儲於內存，各步驟中間結果不落硬盤的計算方式，適合性能要求較高，併發較大的情況。</p><p>HANA、TimesTen等內存數據庫可實現內存計算，但這類產品價格昂貴結構複雜實施困難，總體擁有成本較高。本文介紹的集算器同樣可實現內存計算，而且結構簡單實施方便，是一種輕量級內存計算引擎。</p><p>下面就來介紹一下集算器實現內存計算的一般過程。</p><h1 class=ql-align-center>一、 啟動服務器</h1><p class=ql-align-center>集算器有兩種部署方式：獨立部署、內嵌部署，區別首先在於啟動方式有所不同。</p><ul><li class=ql-align-center>l <strong>獨立部署</strong></li></ul><p class=ql-align-center>作為獨立服務部署時，集算器與應用系統分別使用不同的JVM，兩者可以部署在同一臺機器上，也可分別部署。應用系統通常使用集算器驅動（ODBC或JDBC）訪問集算服務，也可通過HTTP訪問。</p><ul><li class=ql-align-center>n Windows下啟動獨立服務，執行“安裝目錄\esProc\bin\esprocs.exe”，然後點擊“啟動”按鈕。</li></ul><p class=ql-align-center></p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b92fec85d50b4526a29704cb376d028a><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><ul><li class=ql-align-center>n Linux下應執行“安裝目錄/esProc/bin/ServerConsole.sh”。</li></ul><p class=ql-align-center>啟動服務器及配置參數的細節，請參考：http://doc.raqsoft.com.cn/esproc/tutorial/fuwuqi.html。</p><p class=ql-align-center></p><ul><li class=ql-align-center>l <strong>內嵌部署</strong></li></ul><p class=ql-align-center>作為內嵌服務部署時，集算器只能與JAVA應用系統集成，兩者共享JVM。應用系統通過JDBC訪問內嵌的集算服務，無需特意啟動。</p><p class=ql-align-center>詳情參考http://doc.raqsoft.com.cn/esproc/tutorial/bjavady.html。</p><h1 class=ql-align-center>二、 加載數據</h1><p class=ql-align-center>加載數據是指通過集算器腳本，將數據庫、日誌、WebService等外部數據讀入內存的過程。</p><p class=ql-align-center>比如Oracle中訂單表如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/407e1bb778d949b3b9247d69b76f3c7f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>訂單明細如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75e659a1029b4c209a372b2edf3a875b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A1：連接Oracle數據庫。</p><p class=ql-align-center>A2-A3：執行SQL查詢，分別取出訂單表和訂單明細表。query@x表示執行SQL後關閉連接。函數keys可建立主鍵，如果數據庫已定義主鍵，則無需使用該函數。</p><p class=ql-align-center>A4-A5:將兩張表常駐內存，分別命名為訂單和訂單明細，以便將來在業務計算時引用。函數env的作用是設置/釋放全局共享變量，以便在同一個JVM下被其他算法引用，這裡將內存表設為全局變量，也就是將全表數據保存在內存中，供其他算法使用，也就實現了內存計算。事實上，對於外存表、文件句柄等資源也可以用這個辦法設為全局變量，使變量駐留在內存中。</p><p class=ql-align-center></p><p class=ql-align-center>腳本需要執行才能生效。</p><p class=ql-align-center>對於<strong>內嵌部署</strong>的集算服務，通常在應用系統啟動時執行腳本。如果應用系統是JAVA程序，可以在程序中通過JDBC執行initData.dfx，關鍵代碼如下：</p><p class=ql-align-center>1. com.esproc.jdbc.InternalConnection con=null;</p><p class=ql-align-center>2. try {</p><p class=ql-align-center>3. Class.forName("com.esproc.jdbc.InternalDriver");</p><p class=ql-align-center>4. con =(com.esproc.jdbc.InternalConnection)DriverManager.getConnection("jdbc:esproc:local://");</p><p class=ql-align-center>5. ResultSet rs = con.executeQuery("call initData()");</p><p class=ql-align-center>6. } catch (SQLException e){</p><p class=ql-align-center>7. out.println(e);</p><p class=ql-align-center>8. }finally{</p><p class=ql-align-center>9. if (con!=null) con.close();</p><p class=ql-align-center>10. }</p><p class=ql-align-center>這篇文章詳細介紹了JAVA調用集算器的過程http://doc.raqsoft.com.cn/esproc/tutorial/bjavady.html</p><p class=ql-align-center>如果應用系統是JAVA WebServer，那麼需要編寫一個Servlet，在Servlet的init方法中通過JDBC執行initData.dfx，同時將該servlet設置為啟動類，並在web.xml裡進行如下配置：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e80602904b5f40ad86935aa0db9f4547><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>對於<strong>獨立部署</strong>的集算服務器，JAVA應用系統同樣要用JDBC接口執行集算器腳本，用法與內嵌服務類似。區別在於腳本存放於遠端，所以需要像下面這樣指定服務器地址和端口：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e41f479f2b8642dc8947b20ba65b8708><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>如果應用系統非JAVA架構，則應當使用ODBC執行集算器腳本，詳見http://doc.raqsoft.com.cn/esproc/tutorial/odbcbushu.html</p><p class=ql-align-center>對於獨立部署的服務器，也可以<strong>脫離應用程序</strong>，在命令行手工執行initData.dfx。這種情況下需要再寫一個腳本（如runOnServer.dfx）：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/038cfccf1a5040afb664af2957f97a47><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>然後在命令行用esprocx.exe調用runOnServer.dfx：</p><p class=ql-align-center>D:\raqsoft64\esProc\bin>esprocx runOnServer.dfx</p><p class=ql-align-center>Linux下用法類似，參考http://doc.raqsoft.com.cn/esproc/tutorial/minglinghang.html</p><h1 class=ql-align-center>三、 執行運算獲得結果</h1><p class=ql-align-center>數據加載到內存之後，就可以編寫各種算法進行訪問，執行計算並獲得結果，下面舉例說明：以客戶ID為參數，統計該客戶每年每月的訂單數量。</p><p class=ql-align-center>該算法對應的Oracle中的SQL語句如下：</p><p class=ql-align-center>select to_char(訂單日期,'yyyy') AS 年份,to_char(訂單日期,'MM') AS 月份, count(1) AS 訂單數量 from 訂單 where客戶ID=? group by to_char(訂單日期,'yyyy'),to_char(訂單日期,'MM')</p><p class=ql-align-center>在集算器中，應當編寫如下業務算法（algorithm_1.dfx）</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04aa206f9e8f48818b2adb898508ee1c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>為方便調試和維護，也可以分步驟編寫：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7419af9728824388ab8312d1d84478e4><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A1：按客戶ID過濾數據。其中，“訂單”就是加載數據時定義的全局變量，pCustID是外部參數，用於指定需要統計的客戶ID，函數select執行查詢。@m表示並行計算，可顯著提高性能。</p><p class=ql-align-center>A2：執行分組彙總，輸出計算結果。集算器默認返回有表達式的最後一個單元格，也就是A2。如果要返回指定單元的值，可以用return語句</p><p class=ql-align-center>當pCustID=”VINET”時，計算結果如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30c5d398b5fb4c35a539ff4ea41089d8><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>需要注意的是，假如多個業務計算都要對客戶ID進行查詢，那不妨在加載數據時把訂單按客戶ID排序，這樣後續業務算法中就可以使用二分法進行快速查詢，也就是使用select@b函數。具體實現上，initData.dfx中SQL應當改成：</p><p class=ql-align-center>=A1.query("select 訂單ID,客戶ID,訂單日期,運貨費 from 訂單 order by 客戶ID")</p><p class=ql-align-center>相應的，algorithm_1.dfx中的查詢應當改成：</p><p class=ql-align-center>=訂單.select@b(客戶ID==pCustID)</p><p class=ql-align-center>執行腳本獲得結果的方法，前面已經提過，下面重點說說報表，這類最常用的應用程序。</p><p class=ql-align-center>由於報表工具都有可視化設計界面，所以無需用JAVA代碼調用集算器，只需將數據源配置為指向集算服務，在報表工具中以存儲過程的形式調用集算器腳本。</p><p class=ql-align-center>對於內嵌部署的集算服務器，調用語句如下：</p><p class=ql-align-center>call algorithm_1(”VINET”)</p><p class=ql-align-center>由於本例中算法非常簡單，所以事實上可以不用編寫獨立的dfx腳本，而是在報表中直接以SQL方式書寫表達式：</p><p class=ql-align-center>=訂單.select@m(客戶ID==”VINET”).groups(year(訂單日期):年份, month(訂單日期):月份;count(1):訂單數量)</p><p class=ql-align-center>對於獨立部署的集算服務器，遠程調用語句如下：</p><p class=ql-align-center>=callx(“algorithm_1.dfx”,”VINET”;[“127.0.0.1:8281”])</p><p class=ql-align-center>有時，需要在內存進行的業務算法較少，而web.xml不方便添加啟動類，這時可以在業務算法中調用初始化腳本，達到自動初始化的效果，同時也省去編寫servlet的過程。具體腳本如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9d34ad26c0f84e2cbe802a1f4697b7d3><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A1-B1:判斷是否存在全局變量“訂單明細”，如果不存在，則執行初始化數據腳本initData.dfx。</p><p class=ql-align-center>A2-A3:繼續執行原算法。</p><p class=ql-align-center></p><h1 class=ql-align-center>四、 引用思維</h1><p class=ql-align-center>前面例子用到了select函數，這個函數的作用與SQL的where語句類似，都可進行條件查詢，但兩者的底層原理大不相同。where語句每次都會複製一遍數據，生成新的結果集；而select函數只是引用原來的記錄指針，並不會複製數據。以按客戶查詢訂單為例，引用和複製的區別如下圖所示：</p><p class=ql-align-center></p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b097c5c483f04a358f95637ca43b7526><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>可以看到，集算器由於採用了引用機制，所以計算結果佔用空間更小，計算性能更高（分配內存更快）。此外，對於上述計算結果還可再次進行查詢，集算器中新結果集同樣引用最初的記錄，而SQL就要複製出很多新記錄。</p><p class=ql-align-center>除了查詢之外，還有很多集算器算法都採用了引用思維，比如排序、集合交併補、關聯、歸併。</p><h1 class=ql-align-center>五、 常用計算</h1><p class=ql-align-center>回顧前面案例，可以看到集算器語句和SQL語句存在如下的對應關係：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/98c966ea9c424bf39dcfae657d9a0f64><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>事實上，集算器支持完善的結構化數據算法，比如：</p><ul><li class=ql-align-center>l GROUP BY…HAVING</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aee09692e7684d8f923af317d83b0397><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>l ORDER BY…ASC/DESC</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5a199bc69b6d425b9165b43ae03be2ea><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>l DISTINCT</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8c24a242703a48f49a0805cc00bd9301><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>l UNION/UNION ALL/INTERSECT/MINUS</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2b05cc5475814ca397368a1e8e3d2590><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><ul><li class=ql-align-center>與SQL的交併補不同，集算器只是組合記錄指針，並不會複製記錄。</li><li class=ql-align-center>l SELECT … FROM (SELECT …)</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6c418b835a99480d908bdf34fbf01db4><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>l SELECT (SELECT … FROM) FROM</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/42dd1be1d21f439aa4d4cfd5d3cc9a55><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>l CURSOR/FETCH</p><p class=ql-align-center>遊標有兩種用法，其一是外部JAVA程序調用集算器，集算器返回遊標，比如下面腳本：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dd35d63da5d24f239d579c16dee7b439><p class=pgc-img-caption></p></div><p class=ql-align-center>JAVA獲得遊標後可繼續處理，與JDBC訪問遊標的方法相同。</p><p class=ql-align-center>其二，在集算器內部使用遊標，遍歷並完成計算。比如下面腳本：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebb3b20f9d3e424db3326b870b0ed48a><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>集算器適合解決複雜業務邏輯的計算，但考慮到簡單算法佔大多數，而很多程序員習慣使用SQL語句，所以集算器也支持所謂“簡單SQL”的語法。比如algorithm_1.dfx也可寫作：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/643310fe3c4e4e8a9315339be1fa8a47><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>上述腳本通用於任意SQL，$()表示執行默認數據源（集算器）的SQL語句，如果指定數據源名稱比如$(orcl)，則可以執行相應數據庫（數據源名稱是orcl的Oracle數據庫）的SQL語句。</p><p class=ql-align-center>from {}語句可從任意集算器表達式取數，比如：from {訂單.groups(year(訂單日期):年份;count(1):訂單數量)}</p><p class=ql-align-center>from 也可從文件或excel取數，比如：from d:/emp.xlsx</p><p class=ql-align-center>簡單SQL同樣支持join…on…語句，但由於SQL語句（指任意RDB）在關聯算法上性能較差，因此不建議輕易使用。對於關聯運算，集算器有專門的高性能實現方法，後續章節會有介紹。</p><p class=ql-align-center>簡單SQL的詳情可以參考：http://doc.raqsoft.com.cn/esproc/func/dbquerysql.html#db_sql_</p><p class=ql-align-center>六、 有序引用</p><p class=ql-align-center>SQL基於無序集合做運算，不能直接用序號取數，只能臨時生成序號，效率低且用法繁瑣。集算器與SQL體系不同，能夠基於有序集合運算，可以直接用序號取數。例如：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/79fcd99985084ba099f835c6159c64b8><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>函數m()可按指定序號獲取成員，參數為負表示倒序。參數也可以是集合，比如m([3,4,5])。而利用函數to()可按起止序號生成集合，to(3,5)=[3,4,5]。</p><p class=ql-align-center>前面例子提到過二分法查詢select@b，其實已經利用了集算器有序訪問的特點。</p><p class=ql-align-center></p><p class=ql-align-center>有時候我們想取前 N名，常規的思路就是先排序，再按位置取前N個成員，集算器腳本如下：</p><p class=ql-align-center>=訂單.sort(訂單日期).m(to(100))</p><p class=ql-align-center>對應SQL寫法如下：</p><p class=ql-align-center>select top(100) * from 訂單 order by 訂單日期 --MSSQL</p><p class=ql-align-center>select * from (select * from 訂單 order by 訂單日期) where rownum&lt;=100 --Oracle</p><p class=ql-align-center>但上述常規思路要對數據集大排序，運算效率很低。除了常規思路，集算器還有更高效的實現方法：使用函數top。</p><p class=ql-align-center>=訂單.top(100;訂單日期)</p><p class=ql-align-center>函數top只排序出訂單日期最早的N條記錄，然後中斷排序立刻返回，而不是常規思路那樣進行全量排序。由於底層模型的限制，SQL不支持這種高性能算法。</p><p class=ql-align-center></p><p class=ql-align-center>函數top還可應用於計算列，比如擬對訂單採取新的運貨費規則，求新規則下運貨費最大的前100條訂單，而新規則是：如果原運貨費大於等於1000，則運貨費打八折。</p><p class=ql-align-center>集算器腳本為：</p><p class=ql-align-center>=訂單.top(-100;if(運貨費>=1000,運貨費*0.8,運貨費))</p><h1 class=ql-align-center>七、 關聯計算</h1><p class=ql-align-center>關聯計算是關係型數據庫的核心算法，在內存計算中應用廣泛，比如：統計每年每月的訂單數量和訂單金額。</p><p class=ql-align-center>該算法對應Oracle的SQL語句為：</p><p class=ql-align-center>select to_char(訂單.訂單日期,'yyyy') AS 年份,to_char(訂單.訂單日期,'MM') AS 月份，sum(訂單明細.單價*訂單明細.數量) AS 銷售金額，count(1) AS 訂單數量</p><p class=ql-align-center>from 訂單明細 left join 訂單 on 訂單明細.訂單ID=訂單.訂單ID</p><p class=ql-align-center>group by to_char(訂單.訂單日期,'yyyy'),to_char(訂單.訂單日期,'MM')</p><p class=ql-align-center>用集算器實現上述算法時，加載數據的腳本不變，業務算法如下（algorithm_2.dfx）</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/859534e2da0f430ca1d5d5c004d2a273><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A1:將訂單明細與訂單關聯起來，子表主表為別名，點擊單元格可見結果如下</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f23c17038d434628a09df60c87967db8><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>可以看到，集算器join函數與SQL join語句雖然作用一樣，但結構原理大不相同。函數join關聯形成的結果，其字段值不是原子數據類型，而是記錄，後續可用“.”號表達關係引用，多層關聯非常方便。</p><p class=ql-align-center>A2:分組彙總。</p><p class=ql-align-center>計算結果如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7869b71bce7843afa01daf354f2bf7bf><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>關聯關係分很多類，上述訂單和訂單明細屬於其中一類：主子關聯。針對主子關聯，只需在加載數據時各自按關聯字段排序，業務算法中就可用歸併算法來提高性能。例如：</p><p class=ql-align-center>=join@m(訂單明細:子表,訂單ID;訂單:主表,訂單ID)</p><p class=ql-align-center>函數join@m表示歸併關聯，只對同序的兩個或多個表有效。</p><p class=ql-align-center>集算器的關聯計算與RDB不同，RDR對所有類型的關聯關係都採用相同的算法，無法進行有針對性的優化，而集算器採取分而治之的理念，對不同類型的關聯關係提供了不同的算法，可進行有針對性的透明優化。</p><p class=ql-align-center></p><p class=ql-align-center>除了主子關聯，最常用的就是外鍵關聯，常用的外鍵表（或字典表）有分類、地區、城市、員工、客戶等。對於外鍵關聯，集算器也有相應的優化方法，即在數據加載階段事先建立關聯，如此一來業務算法就不必臨時關聯，性能因此提高，併發時效果尤為明顯。另外，集算器用指針建立外鍵關聯，訪問速度更快。</p><p class=ql-align-center>比如這個案例：訂單表的客戶ID字段是外鍵，對應客戶表（客戶ID、客戶名稱、地區、城市），需要統計出每個地區每個城市的訂單數量。</p><p class=ql-align-center>數據加載腳本（initData_3.dfx）如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9f357024759e4d95ad2da99143a7c5a7><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A4：用函數switch建立外鍵關聯，將訂單表的客戶ID字段，替換為客戶表相應記錄的指針。</p><p class=ql-align-center>業務算法腳本如下（algorithm_3.dfx）如下</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a98d3dccd09149a3ae6eae753f27cd93><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>加載數據時已經建立了外鍵指針關聯，所以A1中的“客戶ID”表示：訂單表的客戶ID字段所指向的客戶表記錄，“客戶ID.地區”即客戶表的地區字段。</p><p class=ql-align-center>腳本中多處使用“.”號表達關聯引用，語法比SQL直觀易懂，遇到多表多層關聯時尤為便捷。而在SQL中，關聯一多如同天書。</p><p class=ql-align-center>上述計算結果如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae16821fcf204fa2ba8aec482a199075><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><h1 class=ql-align-center>八、 內外混合計算</h1><p class=ql-align-center>內存計算雖然快，但是內存有限，因此通常只駐留最常用、併發訪問最多的數據，而內存放不下或訪問頻率低的數據，還是要留在硬盤，用到的時候再臨時加載，並與內存數據共同參與計算。這就是所謂的內外混合計算。</p><p class=ql-align-center>下面舉例說明集算器中的內外混合計算。</p><p class=ql-align-center>案例描述：某零售行業系統中，訂單明細訪問頻率較低，數據量較大，沒必要也沒辦法常駐內存。現在要將訂單明細與內存裡的訂單關聯起來，統計出每年每種產品的銷售數量。數據加載腳本（initData_4.dfx）如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/517492bfe6a7411590f97e84b6851159><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>業務算法腳本（algorithm_4.dfx）如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92fcf4eede8d41098dd455e5481afba1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A2：執行SQL，以遊標方式取訂單明細，以便計算遠超內存的大量數據。</p><p class=ql-align-center>A3：將訂單錶轉為遊標模式，下一步會用到。</p><p class=ql-align-center>A4：關聯訂單明細表和訂單表。函數joinx與join@m作用類似，都可對有序數據進行歸併關聯，區別在於前者對遊標有效，後者對序表有效。</p><p class=ql-align-center>A5：執行分組彙總。</p><p class=ql-align-center></p><h1 class=ql-align-center>九、 數據更新</h1><p class=ql-align-center>數據庫中的物理表總會變化，這種變化應當及時反映到共享的內存表中，才能保證內存計算結果的正確，這種情況下就需要更新內存。如果物理表較小，那麼解決起來很容易，只要定時執行初始化數據腳本（initData.dfx）就可以了。但如果物理表太大，就不能這樣做了，因為初始化腳本會進行全量加載，本身就會消耗大量時間，而且加載時無法進行內存計算。例如：某零售巨頭訂單數據量較大，從數據庫全量加載到內存通常超過5分鐘，但為保證一定的實時性，內存數據又需要5分鐘更新一次，顯然，兩者存在明顯的矛盾。</p><p class=ql-align-center>解決思路其實很自然，物理表太大的時候，應該進行增量更新，5分鐘的增量業務數據通常很小，增量不會影響更新內存的效率。</p><p class=ql-align-center>要實現增量更新，就需要知道哪些是增量數據，不外乎以下三種方法：</p><p class=ql-align-center>方法A：在原表加標記字段以識別。缺點是會改動原表。</p><p class=ql-align-center>方法B：在原庫創建一張“變更表”，將變更的數據記錄在內。好處是不動原表，缺點是仍然要動數據庫。</p><p class=ql-align-center>方法C：將變更表記錄在另一個數據庫，或文本文件Excel中。好處是對原數據庫不做任何改動，缺點是增加了維護工作量。</p><p class=ql-align-center>集算器支持多數據源計算，所以方法B、C沒本質區別，下面就以B為例更新訂單表。</p><p class=ql-align-center></p><p class=ql-align-center>第一步，在數據庫中建立“訂單變更表”，繼承原表字段，新加一個“變更標記”字段，當用戶修改原始表時，需要在變更表同步記錄。如下所示的訂單變更表，表示新增1條修改2條刪除1條。</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/969b3a921da1428ea8e38dd3c5f489e4><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>第二步，編寫集算器腳本updatemem_4.dfx，進行數據更新。</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ffd642f6199640d292eaab4b75e823ec><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A1：建立數據庫連接。</p><p class=ql-align-center>A2：將內存中的訂單複製一份，命名為訂單cp。下面過程只針對訂單cp進行修改，修改完畢再替代內存中的訂單，期間訂單仍可正常進行業務計算。</p><p class=ql-align-center>A3：取數據庫訂單變更表。</p><p class=ql-align-center>A4-B5：取出訂單變更表中需刪除的記錄，在訂單cp中找到這些記錄，並刪除。</p><p class=ql-align-center>A6-B6：取出訂單變更表中需新增的記錄，在訂單cp中追加。</p><p class=ql-align-center>A7-B9：這一步是修改訂單cp，相當於先刪除再追加。也可用modify函數實現修改。</p><p class=ql-align-center>A10：將修改後的訂單cp常駐內存，命名為訂單。</p><p class=ql-align-center>A11-A12：清空“變更表”，以便下次取新的變更記錄。</p><p class=ql-align-center>上述腳本實現了完整的數據更新，而實際上很多情況下只需要追加數據，這樣腳本還會簡單很多。</p><p class=ql-align-center>腳本編寫完成後，還需第三步：定時5分鐘執行該腳本。</p><p class=ql-align-center>定時執行的方法有很多。如果集算器部署為獨立服務，與Web應用沒有共用JVM，那麼可以使用操作系統自帶的定時工具（計劃任務或crontab），使其定時執行集算器命令(esprocx.exe或esprocx.sh)。</p><p class=ql-align-center>有些web應用有自己的定時任務管理工具，可定時執行某個JAVA類，這時可以編寫JAVA類，用JDBC調用集算器腳本。</p><p class=ql-align-center>如果web應用沒有定時任務管理工具，那就需要手工實現定時任務，即編寫JAVA類，繼承java內置的定時類TimerTask，在其中調用集算器腳本，再在啟動類中調用定時任務類。</p><p class=ql-align-center>其中啟動類myServle4為：</p><p class=ql-align-center>1. import java.io.IOException;</p><p class=ql-align-center>2. import java.util.Timer;</p><p class=ql-align-center>3. import javax.servlet.RequestDispatcher;</p><p class=ql-align-center>4. import javax.servlet.ServletContext;</p><p class=ql-align-center>5. import javax.servlet.ServletException;</p><p class=ql-align-center>6. import javax.servlet.http.HttpServlet;</p><p class=ql-align-center>7. import javax.servlet.http.HttpServletRequest;</p><p class=ql-align-center>8. import javax.servlet.http.HttpServletResponse;</p><p class=ql-align-center>9. import org.apache.commons.lang.StringUtils;</p><p class=ql-align-center>10. public class myServlet4 extends HttpServlet {</p><p class=ql-align-center>11. private static final long serialVersionUID = 1L;</p><p class=ql-align-center>12. private Timer timer1 = null;</p><p class=ql-align-center>13. private Task task1;</p><p class=ql-align-center>14. public ConvergeDataServlet() {</p><p class=ql-align-center>15. super();</p><p class=ql-align-center>16. }</p><p class=ql-align-center>17. public void destroy() {</p><p class=ql-align-center>18. super.destroy();</p><p class=ql-align-center>19. if(timer1!=null){</p><p class=ql-align-center>20. timer1.cancel();</p><p class=ql-align-center>21. }</p><p class=ql-align-center>22. }</p><p class=ql-align-center>23. public void doGet(HttpServletRequest request, HttpServletResponse response)</p><p class=ql-align-center>24. throws ServletException, IOException {</p><p class=ql-align-center>25. }</p><p class=ql-align-center>26. public void doPost(HttpServletRequest request, HttpServletResponse response)</p><p class=ql-align-center>27. throws ServletException, IOException {</p><p class=ql-align-center>28. doGet(request, response);</p><p class=ql-align-center>29. }</p><p class=ql-align-center>30. public void init() throws ServletException {</p><p class=ql-align-center>31. ServletContext context = getServletContext();</p><p class=ql-align-center>32. // 定時刷新時間(5分鐘)</p><p class=ql-align-center>33. Long delay = new Long(5);</p><p class=ql-align-center>34. // 啟動定時器</p><p class=ql-align-center>35. timer1 = new Timer(true);</p><p class=ql-align-center>36. task1 = new Task(context);</p><p class=ql-align-center>37. timer1.schedule(task1, delay * 60 * 1000, delay * 60 * 1000);</p><p class=ql-align-center>38. }</p><p class=ql-align-center>39. }</p><p class=ql-align-center>定時任務類Task為：</p><p class=ql-align-center>11. <strong>import</strong> java.util.TimerTask;</p><p class=ql-align-center>12. <strong>import</strong> javax.servlet.ServletContext;</p><p class=ql-align-center>13. <strong>import</strong> java.sql.*;</p><p class=ql-align-center>14. <strong>import</strong> com.esproc.jdbc.*;</p><p class=ql-align-center>15. <strong>public</strong> <strong>class</strong> Task <strong>extends</strong> TimerTask{</p><p class=ql-align-center>16. <strong>private</strong> ServletContext context;</p><p class=ql-align-center>17. <strong>private</strong> <strong>static</strong> <strong>boolean</strong> isRunning = <strong>true</strong>;</p><p class=ql-align-center>18. <strong>public</strong> Task(ServletContext context){</p><p class=ql-align-center>19. <strong>this</strong>.context = context;</p><p class=ql-align-center>20. }</p><p class=ql-align-center>21. @Override</p><p class=ql-align-center>22. <strong>public</strong> <strong>void</strong> run() {</p><p class=ql-align-center>23. <strong>if</strong>(!isRunning){</p><p class=ql-align-center>24. com.esproc.jdbc.InternalConnection con=null;</p><p class=ql-align-center>25. <strong>try</strong> {</p><p class=ql-align-center>26. Class.forName("com.esproc.jdbc.InternalDriver");</p><p class=ql-align-center>27. con =(com.esproc.jdbc.InternalConnection)DriverManager.getConnection("jdbc:esproc:local://");</p><p class=ql-align-center>28. ResultSet rs = con.executeQuery("call updatemem_4()");</p><p class=ql-align-center>29. }</p><p class=ql-align-center>30. <strong>catch</strong> (SQLException e){</p><p class=ql-align-center>31. out.println(e);</p><p class=ql-align-center>32. }<strong>finally</strong>{</p><p class=ql-align-center>33. //關閉數據集</p><p class=ql-align-center>34. <strong>if</strong> (con!=null) con.close();</p><p class=ql-align-center>35. }</p><p class=ql-align-center>36. }</p><p class=ql-align-center>37. }</p><p class=ql-align-center>38. }</p><h1 class=ql-align-center>十、 綜合示例</h1><p class=ql-align-center>下面，通過一個綜合示例來看一下在數據源多樣、算法複雜的情況下，集算器如何很好地實現內存計算：</p><p class=ql-align-center>案例描述：某B2C網站需要試算訂單的郵寄總費用，以便在一定成本下挑選合適的郵費規則。大部分情況下，郵費由包裹的總重量決定，但當訂單的價格超過指定值時（比如300美元），則提供免費付運。結果需輸出各訂單郵寄費用以及總費用。</p><p class=ql-align-center>其中訂單表已加載到內存，如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4d96d78fea904f44ba1d50d6e80efb79><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>郵費規則每次試算時都不同，因此由參數“pRule”臨時傳入，格式為json字符串，某次規則如下：</p><p class=ql-align-center>[{"field":"cost","minVal":300,"maxVal":1000000,"Charge":0},</p><p class=ql-align-center>{"field":"weight","minVal":0,"maxVal":1,"Charge":10},</p><p class=ql-align-center>{"field":"weight","minVal":1,"maxVal":5,"Charge":20},</p><p class=ql-align-center>{"field":"weight","minVal":5,"maxVal":10,"Charge":25},</p><p class=ql-align-center>{"field":"weight","minVal":10,"maxVal":1000000,"Charge":40}]</p><p class=ql-align-center>上述json串表示各字段在各種取值範圍內時的郵費。第一條記錄表示，cost字段取值在300與1000000之間的時候，郵費為0（免費付運）；第二條記錄表示，weight字段取值在0到1（kg）之間時，郵費為10（美元）。</p><p class=ql-align-center>思路：將json串轉為二維表，分別找出filed字段為cost和weight的記錄，再對整個訂單表進行循環。循環中先判斷訂單記錄中的cost值是否滿足免費標準，不滿足則根據重量判斷郵費檔次，之後計算郵費。算完各訂單郵費後再計算總郵費，並將彙總結果附加為訂單表的最後一條記錄。</p><p class=ql-align-center>數據加載過程很簡單，這裡不再贅述，即：讀數據庫表，並命名為“訂單表”。</p><p class=ql-align-center>業務算法相對複雜，具體如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8a2c742f6af64bdca41296c59136d299><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>A1:解析json，將其轉為二維表。集算器支持多數據源，不僅支持RDB，也支持NOSQL、文件、webService。</p><p class=ql-align-center>A2-A3：查詢郵費規則，分為免費和收費兩種。</p><p class=ql-align-center>A4：新增空字段postage。</p><p class=ql-align-center>A5-D8：按兩種規則循環訂單表，計算相應的郵費，並填入postage字段。這裡多處用到流程控制，集算器用縮進表示，其中A5、B7為循環語句，C6、D8跳入下一輪循環，B5、C7為判斷語句</p><p class=ql-align-center>A9:在訂單表追加新紀錄，填入彙總值。</p><p class=ql-align-center>計算結果如下：</p><div class=pgc-img><img alt=輕量級內存計算引擎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d5f7dd074dba46ac988bea5bfec773b5><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>至此，本文詳細介紹了集算器用作內存計算引擎的完整過程，同時包括了常用計算方法和高級運算技巧。可以看到，集算器具有以下顯著優點：</p><ul><li class=ql-align-center>l 結構簡單實施方便，可快速實現內存計算；</li><li class=ql-align-center>l 支持多種調用接口，應用集成沒有障礙；</li><li class=ql-align-center>l 支持透明優化，可顯著提升計算性能；</li><li class=ql-align-center>l 支持多種數據源，便於實現混合計算；</li><li class=ql-align-center>l 語法敏捷精妙，可輕鬆實現複雜業務邏輯。</li></ul><p class=ql-align-center>關於內存計算，還有個多機分佈式計算的話題，將在後續文章中進行介紹。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>輕量</a></li><li><a>存計算</a></li><li><a>引擎</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/56692649.html alt=《迴路：設計人生的增長引擎》 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/58d61c5fc652464cab0bfe09f6bf64fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56692649.html title=《迴路：設計人生的增長引擎》>《迴路：設計人生的增長引擎》</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a16607fe.html alt=【技術帖】輕量化工藝在車身開發中的應用研究 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/21c11855e5d74c51903d56b7ff04bcf2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a16607fe.html title=【技術帖】輕量化工藝在車身開發中的應用研究>【技術帖】輕量化工藝在車身開發中的應用研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cef95023.html alt="開源 | Umajs：輕量級 Node.js Web 框架" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/186828b5b34b4255903df4a9fadc6158 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cef95023.html title="開源 | Umajs：輕量級 Node.js Web 框架">開源 | Umajs：輕量級 Node.js Web 框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/945f94d0.html alt=餓了麼輕量級分佈式時序數據庫的設計與探索 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15254882999416c80866253 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/945f94d0.html title=餓了麼輕量級分佈式時序數據庫的設計與探索>餓了麼輕量級分佈式時序數據庫的設計與探索</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6e91f5f.html alt="輕量型變焦鏡頭 佳能RF24-105mm F4-7.1測評" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RN7gZcbAxeBjkW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6e91f5f.html title="輕量型變焦鏡頭 佳能RF24-105mm F4-7.1測評">輕量型變焦鏡頭 佳能RF24-105mm F4-7.1測評</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ffba63c.html alt="輕量迷你大炮？尼康AF-S 500/5.6E PF鏡頭評測" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8584270037af4c5d8b05a842c91cac26 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ffba63c.html title="輕量迷你大炮？尼康AF-S 500/5.6E PF鏡頭評測">輕量迷你大炮？尼康AF-S 500/5.6E PF鏡頭評測</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3ff676d.html alt=為什麼要用規則引擎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4ba80991dc0444e490f4a9760ebae654 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3ff676d.html title=為什麼要用規則引擎？>為什麼要用規則引擎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/ecc01648.html alt="輕量電競鼠——魔幻豹Kone Pure Ultra 夜梟來襲：飄逸的感覺" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e9a5df3c450947488353146b53ccb7c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/ecc01648.html title="輕量電競鼠——魔幻豹Kone Pure Ultra 夜梟來襲：飄逸的感覺">輕量電競鼠——魔幻豹Kone Pure Ultra 夜梟來襲：飄逸的感覺</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/3ce69519.html alt=阿里開源——用於前端和nodejs的輕量級任務管理和構建工具Dawn class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8b338a772f884be3ab7a3b1d8d5c31e1 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/3ce69519.html title=阿里開源——用於前端和nodejs的輕量級任務管理和構建工具Dawn>阿里開源——用於前端和nodejs的輕量級任務管理和構建工具Dawn</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c2f43d.html alt="AppStore今日限免 輕量級的待辦事項、日程管理和提醒工具" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5117bdec6c0d4d0f86cf0233a94770f2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c2f43d.html title="AppStore今日限免 輕量級的待辦事項、日程管理和提醒工具">AppStore今日限免 輕量級的待辦事項、日程管理和提醒工具</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/871637a.html alt=黃石千億銅產業集群又添“新引擎” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/64c56b35e40349eea5f1e9bef395fe22 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/871637a.html title=黃石千億銅產業集群又添“新引擎”>黃石千億銅產業集群又添“新引擎”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a2bed6.html alt="Uruk 3.0，輕量級的伊拉操克作系統，舊電腦也能運行如飛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6c3733e8f3e04728a45c948e223f86f4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a2bed6.html title="Uruk 3.0，輕量級的伊拉操克作系統，舊電腦也能運行如飛">Uruk 3.0，輕量級的伊拉操克作系統，舊電腦也能運行如飛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab2a0f8.html alt=輕量級的PS圖片處理軟件：PhotoScape，完全免費，可批量處理圖片 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0e18b224db4844bab2e7c954fd96e81e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab2a0f8.html title=輕量級的PS圖片處理軟件：PhotoScape，完全免費，可批量處理圖片>輕量級的PS圖片處理軟件：PhotoScape，完全免費，可批量處理圖片</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a369c2.html alt=PLA輕量級3D打印天線原型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/60f2751ba1f84ceabb70e4e4b2079674 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a369c2.html title=PLA輕量級3D打印天線原型>PLA輕量級3D打印天線原型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/950b2fa.html alt="輕量、安全可靠、保暖、便攜 以上對防潮墊的要求，希望這個方案可以都滿足" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/65c6000f7934dcaaecf0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/950b2fa.html title="輕量、安全可靠、保暖、便攜 以上對防潮墊的要求，希望這個方案可以都滿足">輕量、安全可靠、保暖、便攜 以上對防潮墊的要求，希望這個方案可以都滿足</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>