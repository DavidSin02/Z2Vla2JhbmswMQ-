<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>中篇｜說說無鎖(Lock-Free)編程那些事 | 极客快訊</title><meta property="og:title" content="中篇｜說說無鎖(Lock-Free)編程那些事 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6c3ac3950dc7484a82d4ceecc885027b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb933d05.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb933d05.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bb933d05.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb933d05.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb933d05.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bb933d05.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bb933d05.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bb933d05.html><meta property="article:published_time" content="2020-11-14T21:06:27+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:27+08:00"><meta name=Keywords content><meta name=description content="中篇｜說說無鎖(Lock-Free)編程那些事"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/bb933d05.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>中篇｜說說無鎖(Lock-Free)編程那些事</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>6 內存屏障（Memory Barriers）</strong></p><p class=ql-align-justify><strong>6.1 What Memory Barriers？</strong></p><p class=ql-align-justify>內存屏障，也稱內存柵欄，內存柵障，屏障指令等，是一類同步屏障指令，是CPU或編譯器在對內存隨機訪問的操作中的一個同步點，使得此點之前的所有讀寫操作都執行後才可以開始執行此點之後的操作。大多數現代計算機為了提高性能而採取亂序執行，這使得內存屏障成為必須。語義上，內存屏障之前的所有寫操作都要寫入內存；內存屏障之後的讀操作都可以獲得同步屏障之前的寫操作的結果。因此，對於敏感的程序塊，寫操作之後、讀操作之前可以插入內存屏障。</p><p class=ql-align-justify>通常情況下，我們希望我們所編寫的程序代碼能"所見即所得"，即程序邏輯滿足程序的順序性(滿足program order)，然而，很遺憾，我們的程序邏輯("所見")和最後的執行結果("所得")隔著：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1. 編譯器</p><p class=ql-align-justify>2. CPU取指執行</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1. 編譯器將符合人類思考的邏輯（程序代碼）翻譯成了符合CPU運算規則的彙編指令，編譯器瞭解底層CPU的思維模式，因此，它可以在將程序翻譯成彙編的時候進行優化（例如內存訪問指令的重新排序），讓產出的彙編指令在CPU上運行的時候更快。然而，這種優化產出的結果未必符合程序員原始的邏輯，因此，作為程序員，必須有能力瞭解編譯器的行為，並在通過內嵌在程序代碼中的memory barrier來指導編譯器的優化行為（這種memory barrier又叫做優化屏障，Optimization barrier），讓編譯器產出即高效，又邏輯正確的代碼。</p><p class=ql-align-justify>2. CPU的核心思想就是取指執行，對於in-order的單核CPU，並且沒有cache，彙編指令的取指和執行是嚴格按照順序進行的，也就是說，彙編指令就是所見即所得的，彙編指令的邏輯嚴格的被CPU執行。然而，隨著計算機系統越來越複雜（多核、cache、superscalar、out-of-order），使用匯編指令這樣貼近處理器的語言也無法保證其被CPU執行的結果的一致性，從而需要程序員告知CPU如何保證邏輯正確。</p><p class=ql-align-justify>綜上所述，memory barrier是一種保證內存訪問順序的一種方法，讓系統中的HW block（各個cpu、DMA controler、device等）對內存有一致性的視角。</p><p class=ql-align-justify>通過上面介紹，我們知道我們所編寫的代碼會根據一定規則在與內存的交互過程中發生亂序。內存執行順序的變化在編譯器(編譯期間)和cpu(運行期間)中都會發生，其目的都是為了讓代碼運行的更快。就算是為了性能而亂序，但是亂序總有個度吧(總不能將指針的初始化的代碼亂序在使用指針的代碼之後吧，這樣誰還敢寫代碼)。編譯器開發者和cpu廠商都遵守著內存亂序的基本原則，簡單歸納如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>不能改變單線程程序的執行行為 -- 但線程程序總是滿足Program Order(所見即所得)</p><p class=ql-align-justify>```</p><p class=ql-align-justify>在此原則指導下，寫單線程代碼的程序員不需要關心內存亂序的問題。在多線程編程中，由於使用互斥量，信號量和事件都在設計的時候都阻止了它們調用點中的內存亂序(已經隱式包含各種memery barrier)，內存亂序的問題同樣不需要考慮了。只有當使用無鎖(lock-free)技術時–內存在線程間共享而沒有任何的互斥量，內存亂序的效果才會顯露無疑，這樣我們才需要考慮在合適的地方加入合適的memery barrier。</p><p class=ql-align-justify><strong>6.1.1 編譯期亂序</strong></p><p class=ql-align-justify>考慮下面一段代碼：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>int Value = 0;</p><p class=ql-align-justify>int IsPublished = 0;</p><p class=ql-align-justify>void sendValue(int x)</p><p class=ql-align-justify>{</p><p class=ql-align-justify>Value = x;</p><p class=ql-align-justify>IsPublished = 1;</p><p class=ql-align-justify>}</p><p class=ql-align-justify>int tryRecvValue()</p><p class=ql-align-justify>{</p><p class=ql-align-justify>if (IsPublished)</p><p class=ql-align-justify>{</p><p class=ql-align-justify>return Value;</p><p class=ql-align-justify>}</p><p class=ql-align-justify>return -1; // or some other value to mean not yet received</p><p class=ql-align-justify>}</p><p class=ql-align-justify>```</p><p class=ql-align-justify>在出現編譯期亂序的時候，sendValue可能變成如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>void sendValue(int x)</p><p class=ql-align-justify>{</p><p class=ql-align-justify>IsPublished = 1;</p><p class=ql-align-justify>Value = x;</p><p class=ql-align-justify>}</p><p class=ql-align-justify>```</p><p class=ql-align-justify>對於但線程而言，這樣的亂序是不會有影響的，因為sendValue(10)調用後，IsPublished == 1; Value == 10；這時調用tryRecvValue()就會得到10和亂序前是一樣的結果。但是對於多線程，線程1調用sendValue(10)， 線程2調用tryRecvValue()，當線程1執行完IsPublished = 1;的時候，線程2調用tryRecvValue()就會得到Value的初始默認值0，這和程序原本邏輯違背，於是我們必須加上編譯器的barrier來防止編譯器的亂序優化：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>#define COMPILER_BARRIER() asm volatile("" ::: "memory")</p><p class=ql-align-justify>int Value;</p><p class=ql-align-justify>int IsPublished = 0;</p><p class=ql-align-justify>void sendValue(int x)</p><p class=ql-align-justify>{</p><p class=ql-align-justify>Value = x;</p><p class=ql-align-justify>COMPILER_BARRIER(); // prevent reordering of stores</p><p class=ql-align-justify>IsPublished = 1;</p><p class=ql-align-justify>}</p><p class=ql-align-justify>int tryRecvValue()</p><p class=ql-align-justify>{</p><p class=ql-align-justify>if (IsPublished)</p><p class=ql-align-justify>{</p><p class=ql-align-justify>COMPILER_BARRIER(); // prevent reordering of loads</p><p class=ql-align-justify>return Value;</p><p class=ql-align-justify>}</p><p class=ql-align-justify>return -1; // or some other value to mean not yet received</p><p class=ql-align-justify>}</p><p class=ql-align-justify>```</p><p class=ql-align-justify>下面也是一個編譯器亂序的例子(在Gcc4.8.5下 gcc -O2 -c -S compile_reordering.cpp)：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c3ac3950dc7484a82d4ceecc885027b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>可以看出，在開啟-o2編譯器優化選項時，內存會發生亂序，在寫變量A之前會先寫變量B。</p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>6.1.2 運行期亂序</strong></p><p class=ql-align-justify>下面看一個運行期CPU亂序的例子：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c3ac3950dc7484a82d4ceecc885027b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>可以看出在22W多次迭代後檢測到一次亂序，亂序間隔在搖擺不定。</p><p class=ql-align-justify><strong>6.2 Why Memory Barriers？</strong></p><p class=ql-align-justify>6.2.1 現代處理器cache架構</p><p class=ql-align-justify>通過上面，我們知道存在兩種類型的Memory Barriers：編譯器的Memory Barrier、處理器的Memory Barrier。對於編譯器的Memory Barrier比較好理解，就是防止編譯器為了優化而將代碼執行調整亂序。而處理器的Memory Barrier是防止CPU怎樣的亂序呢？CPU的內存亂序是怎麼來的？</p><p class=ql-align-justify>亂序會有問題本質上是讀到了老的數據，或者是一部分讀到新的一部分讀到老的數據，例如：上面的例子中，已經讀到了IsPublished的新值，卻還是讀到了Value老的值，從而引起問題。這種數據不一致怎麼來的呢？相信這個時候大家腦海裡已經浮現出一個詞了：Cache。</p><p class=ql-align-justify>首先我們來看看現代處理器基本的cache架構</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9012d62f52e94ffea32de0ed6892d669><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>現代處理器為了彌補內存速度低下的缺陷，引入Cache來提高處理器訪問程序和數據的速度，Cache作為連接內核和內存的橋樑，極大提升了程序的運行速度。為什麼處理器內部加一個速度快，容量小的cache就能提速呢？這裡基於程序的兩個特性：時間的局部性(Temporal locality)和空間的局部性(Spatial)</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] 時間的局部性(Temporal locality)：如果某個數據被訪問了，那麼不久的將來它很有可能被再次訪問到。典型的例子就是循環，循環的代碼被處理器重複執行，將循環代碼放在Cache中，那麼只是在第一次的時候需要耗時較長去內存取，以後這些代碼都能被內核從cache中快速訪問到。</p><p class=ql-align-justify>[2] 空間的局部性(Spatial)：如果某個數據被訪問了，那麼它相臨的數據很可能很快被訪問到。典型的例子就是數組，數組中的元素常常安裝順序依次被程序訪問。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>現代處理器一般是多個核心Core，每個Core在併發執行不同的代碼和訪問不同的數據，為了隔離影響，每個core都會有自己私有的cache(如圖的L1和L2)，同時也在容量和存儲速度上進行一個平衡(容量也大存儲速度越慢，速度：L1>L2>L3， 容量：L3>L2>L1)，於是就出現圖中的層次化管理。Cache的層次化必然帶來一個cache一致性的問題：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/deb960b3af4e44c1aeb2d5cb2259d2ba><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>如圖的例子，變量X(初始值是3)被cache在Core 0和Core 1的私有cache中，這時core 0將X修改成5，如果core 1不知道X已經被修改了，繼續使用cache中的舊值，那麼可能會導致嚴重的問題，這就是Cache的不一致導致的。為了保證Cache的一致性，處理器提供兩個保證Cache一致性的底層操作：Write Invalidate和Write Update。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>Write Invalidate(置無效)：當一個CPU Core修改了一份數據X，那麼它需要通知其他core將他們的cache中的X設置為無效(invalid)(如果cache中有的話)，如下圖</p><p class=ql-align-justify>```</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9012d62f52e94ffea32de0ed6892d669><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>```</p><p class=ql-align-justify>Write Update(寫更新)：當一個CPU Core修改了一份數據X，那麼它需要通知其他core將他們的cache中的X更新到最新值(如果cache中有的話)，如下圖</p><p class=ql-align-justify>```</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9012d62f52e94ffea32de0ed6892d669><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>Write Invalidate和Write Update的比較：Write Invalidate是一種更為簡單和輕量的實現方式，它不需要立刻將數據更新到存儲中(這時一個耗時過程)，如果後續Core 0繼續需要修改X而Core 1和Core 2又不再使用數據X了，那麼這個Update過程就有點做了無用功，而採用write invalidate就更為輕量和有效。不過，由於valid標誌是對應一個Cache line的，將valid標誌設置為invalid後，這個cache line的其他本來有效的數據也不能被使用了，如果處理不好容易出現前面提到的False sharing(偽共享)和Cache pingpong問題。</p><p class=ql-align-justify><strong>6.2.2 cache一致性協議MESI</strong></p><p class=ql-align-justify>由於Write Invalidate比較簡單和輕量，大多數現代處理器都採用Write Invalidate策略，基於Write Invalidate處理器會有一套完整的協議來保證Cache的一致性，比較經典的當屬MESI協議，奔騰處理器採用它，很多其他處理器都是採用它的一個小變種。</p><p class=ql-align-justify>每個核的Cache中的每個Cache Line都有2個標誌位：dirty標誌和valid標誌位，兩個標誌位分別描述了Cache和Memory間的數據關係(數據是否有效，數據是否被修改)，而在多核處理器中，多個核會共享一些數據，MESI協議就包含了描述共享的狀態。</p><p class=ql-align-justify>這樣在MESI協議中，每個Cache line都有4個狀態，可用2個bit來表示(也就是，每個cache line除了物理地址和具體的數據之外，還有一個2-bit的tag來標識該cacheline的4種不同的狀態)：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] M(Modified): cache line數據有效，但是數據被修改過了，本Cache中的數據是最新的，內存的數據是老的，需要在適當時候將Cache數據寫回內存。因此，處於modified狀態的cacheline也可以說是被該CPU獨佔。而又因為只有該CPU的cache保存了最新的數據（最終的memory中都沒有更新），所以，該cache需要對該數據負責到底。例如根據請求，該cache將數據及其控制權傳遞到其他cache中，或者cache需要負責將數據寫回到memory中，而這些操作都需要在reuse該cache line之前完成。</p><p class=ql-align-justify>[2] E(Exclusive)：cache line數據有效，並且cache和memory中的數據是一致的，同時數據只在本cache中有效。exclusive狀態和modified狀態非常類似，唯一的區別是對應CPU還沒有修改cacheline中的數據，也正因為還沒有修改數據，因此memory中對應的data也是最新的。在exclusive狀態下，cpu也可以不通知其他CPU cache而直接對cacheline進行操作，因此，exclusive狀態也可以被認為是被該CPU獨佔。由於memory中的數據和cacheline中的數據都是最新的，因此，cpu不需對exclusive狀態的cacheline執行寫回的操作或者將數據以及歸屬權轉交其他cpu cache，而直接reuse該cacheline（將cacheine中的數據丟棄，用作他用）。</p><p class=ql-align-justify>[3] S(Shared)：cache line的數據有效，並且cache和memory中的數據是一致的，同時該數據在多個cpu cache中也是有效的。和exclusive狀態類似，處於share狀態的cacheline對應的memory中的數據也是最新的，因此，cpu也可以直接丟棄cacheline中的數據而不必將其轉交給其他CPU cache或者寫回到memory中。</p><p class=ql-align-justify>[4] I(Invalid)：本cache line的數據已經是無效的。處於invalid狀態的cacheline是空的，沒有數據。當新的數據要進入cache的時候，優選狀態是invalid的cacheline，之所以如此是因為如果選中其他狀態的cacheline，則說明需要替換cacheline數據，而未來如果再次訪問這個被替換掉的cacheline數據的時候將遇到開銷非常大的cache miss。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>在MESI協議中，每個CPU都會監聽總線(bus)上的其他CPU對每個Cache line的所有操作，因此該協議也稱為監聽(snoop)協議，監聽協議比較簡單，被多少處理器使用，不過監聽協議的溝通成本比較高。有另外一種協議叫目錄協議，他採用集中管理的方式，將cache共享的信息集中在一起，類似一個目錄，只有共享的Cache line才會交互數據，這種協議溝通成本就大大減少了。在基於snoop的處理器中，所有的CPU都是在一個共享的總線上，多個CPU之間需要相互通信以保證Cache line在M、E、S、I四個狀態間正確的轉換，從而保證數據的一致性。通常情況下，CPU需要以下幾個通信message即可：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] Read消息：read message用來獲取指定物理地址上的cacheline數據。</p><p class=ql-align-justify>[2] Read Response消息：該消息攜帶了read message請求的數據。read response可能來自memory，也可能來自其他的cache。例如：如果一個cache有read message請求的數據並且該cacheline的狀態是modified，那麼該cache必須以read response迴應這個read message，因為該cache中保存了最新的數據。</p><p class=ql-align-justify>[3] Invalidate消息：該命令用來將其他cpu cache中的數據設定為無效。該命令攜帶物理地址的參數，其他CPU cache在收到該命令後，必須進行匹配，發現自己的cacheline中有該物理地址的數據，那麼就將其移除並用Invalidate Acknowledge迴應。</p><p class=ql-align-justify>[4] Invalidate Acknowledge消息： 收到invalidate message的cpu cache，在移除了其cache line中的特定數據之後，必須發送invalidate acknowledge消息。</p><p class=ql-align-justify>[5] Read Invalidate消息： 該message中也包括了物理地址這個參數，以便說明其想要讀取哪一個cacheline數據。此外，該message還同時有invalidate message的功效，即其他的cache在收到該命令後，移除自己cacheline中的數據。因此，Read Invalidate message實際上就是read ＋ invalidate。發送Read Invalidate之後，cache期望收到一個read response以及多個invalidate acknowledge。</p><p class=ql-align-justify>[6] Writeback消息： 該message包括兩個參數，一個是地址，另外一個是寫回的數據。該消息用在modified狀態的cacheline被驅逐出境（給其他數據騰出地方）的時候發出，該命名用來將最新的數據寫回到memory（或者其他的CPU cache中）。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>根據protocol message的發送和接收情況，cacheline會在“modified”, “exclusive”, “shared”, 和 “invalid”這四個狀態之間遷移，具體如下圖所示：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/40254eb9892841e29a556db2b7480b97><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>對上圖中的狀態遷移解釋如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[a] Transition (a)：cache可以通過writeback transaction將一個cacheline的數據寫回到memory中（或者下一級cache中），這時候，該cacheline的狀態從Modified遷移到Exclusive狀態。對於cpu而言，cacheline中的數據仍然是最新的，而且是該cpu獨佔的，因此可以不通知其他cpu cache而直接修改之。</p><p class=ql-align-justify>[b] Transition (b)：在Exclusive狀態下，cpu可以直接將數據寫入cacheline，不需要其他操作。相應的，該cacheline狀態從Exclusive狀態遷移到Modified狀態。這個狀態遷移過程不涉及bus上的Transaction（即無需MESI Protocol Messages的交互）。</p><p class=ql-align-justify>[c] Transition (c)：CPU 在總線上收到一個read invalidate的請求，同時，該請求是針對一個處於modified狀態的cacheline，在這種情況下，CPU必須該cacheline狀態設置為無效，並且用read response”和“invalidate acknowledge來回應收到的read invalidate的請求，完成整個bus transaction。一旦完成這個transaction，數據被送往其他cpu cache中，本地的copy已經不存在了。</p><p class=ql-align-justify>[d] Transition (d)：CPU需要執行一個原子的readmodify-write操作，並且其cache中沒有緩存數據，這時候，CPU就會在總線上發送一個read invalidate用來請求數據，同時想獨自霸佔對該數據的所有權。該CPU的cache可以通過read response獲取數據並加載cacheline，同時，為了確保其獨佔的權利，必須收集所有其他cpu發來的invalidate acknowledge之後（其他cpu沒有local copy），完成整個bus transaction。</p><p class=ql-align-justify>[e] Transition (e)：CPU需要執行一個原子的readmodify-write操作，並且其local cache中有read only的緩存數據（cacheline處於shared狀態），這時候，CPU就會在總線上發送一個invalidate請求其他cpu清空自己的local copy，以便完成其獨自霸佔對該數據的所有權的夢想。同樣的，該cpu必須收集所有其他cpu發來的invalidate acknowledge之後，才算完成整個bus transaction。</p><p class=ql-align-justify>[f] Transition (f)：在本cpu獨自享受獨佔數據的時候，其他的cpu發起read請求，希望獲取數據，這時候，本cpu必須以其local cacheline的數據迴應，並以read response迴應之前總線上的read請求。這時候，本cpu失去了獨佔權，該cacheline狀態從Modified狀態變成shared狀態（有可能也會進行寫回的動作）。</p><p class=ql-align-justify>[g] Transition (g)：這個遷移和f類似，只不過開始cacheline的狀態是exclusive，cacheline和memory的數據都是最新的，不存在寫回的問題。總線上的操作也是在收到read請求之後，以read response迴應。</p><p class=ql-align-justify>[h] Transition (h)：如果cpu認為自己很快就會啟動對處於shared狀態的cacheline進行write操作，因此想提前先霸佔上該數據。因此，該cpu會發送invalidate敦促其他cpu清空自己的local copy，當收到全部其他cpu的invalidate acknowledge之後，transaction完成，本cpu上對應的cacheline從shared狀態切換exclusive狀態。還有另外一種方法也可以完成這個狀態切換：當所有其他的cpu對其local copy的cacheline進行寫回操作，同時將cacheline中的數據設為無效（主要是為了為新的數據騰些地方），這時候，本cpu坐享其成，直接獲得了對該數據的獨佔權。</p><p class=ql-align-justify>[i] Transition (i)：其他的CPU進行一個原子的read-modify-write操作，但是，數據在本cpu的cacheline中，因此，其他的那個CPU會發送read invalidate，請求對該數據以及獨佔權。本cpu回送read response”和“invalidate acknowledge”，一方面把數據轉移到其他cpu的cache中，另外一方面，清空自己的cacheline。</p><p class=ql-align-justify>[j] Transition (j)：cpu想要進行write的操作但是數據不在local cache中，因此，該cpu首先發送了read invalidate啟動了一次總線transaction。在收到read response迴應拿到數據，並且收集所有其他cpu發來的invalidate acknowledge之後（確保其他cpu沒有local copy），完成整個bus transaction。當write操作完成之後，該cacheline的狀態會從Exclusive狀態遷移到Modified狀態。</p><p class=ql-align-justify>[k] Transition (k)：本CPU執行讀操作，發現local cache沒有數據，因此通過read發起一次bus transaction，來自其他的cpu local cache或者memory會通過read response迴應，從而將該cacheline從Invalid狀態遷移到shared狀態。</p><p class=ql-align-justify>[l] Transition (l)：當cacheline處於shared狀態的時候，說明在多個cpu的local cache中存在副本，因此，這些cacheline中的數據都是read only的，一旦其中一個cpu想要執行數據寫入的動作，必須先通過invalidate獲取該數據的獨佔權，而其他的CPU會以invalidate acknowledge迴應，清空數據並將其cacheline從shared狀態修改成invalid狀態。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>下面通過幾個例子，說明一下MESI協議是怎麼工作的。CPU執行序列如下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c25e2ba499d54f9eb7143a949e77b757><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>第一列是操作序列號，第二列是執行操作的CPU，第三列是具體執行哪一種操作，第四列描述了各個cpu local cache中的cacheline的狀態（用meory address/狀態表示），最後一列描述了內存在0地址和8地址的數據內容的狀態：V表示是最新的，和cpu cache一致，I表示不是最新的內容，最新的內容保存在cpu cache中。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] sequence 0：初始狀態下，內存地址0和8保存了最新的數據，而4個CPU的cache line都是invalid(沒cache任何數據或cache的數據都是過期無效的)。</p><p class=ql-align-justify>[2] sequence 1：CPU 0對內存地址0執行load操作，這樣內存地址0的數據被加載到CPU 0的cache line中，CPU 0的cache line從Invalid狀態切換到Share狀態(這個時候，CPU 0的cache line和內存地址0都是相同的最新數據)。</p><p class=ql-align-justify>[3] sequence 2：CPU 3也對內存地址0執行load操作，這樣內存地址0的數據被加載到CPU 3的cache line中，CPU 3的cache line從Invalid狀態切換到Share狀態(這個時候，CPU 0、CPU 3的cache line和內存地址0都是相同的最新數據)。</p><p class=ql-align-justify>[4] sequence 3：CPU 0執行對內存地址8的load操作，(內存地址0和8共用一個cache line set)由於cache line已經存放了內存地址0的數據，這個時候，CPU 0需要將cache line的數據清理掉(Invalidation)以便騰出空間存放內存地址8的數據。由於，當前cache line的狀態是Share，CPU 0不需要通知其他CPU，CPU 0在Invalidation cache line的數據後，就加載內存地址8的數據到cache line中，並將cache line狀態改成Share。</p><p class=ql-align-justify>[5] sequence 4：CPU 2對內存地址0執行load操作，由於CPU 2知道程序隨後會修改該值，它需要獨佔該數據，因此CPU 2向總線發送了read invalidate命令，一方面獲取該數據(自己的local cache中沒有地址0的數據)，另外，CPU 2想獨佔該數據（因為隨後要write）。這個操作導致CPU 3的cacheline遷移到invalid狀態。當然，這時候，memory仍然是最新的有效數據。</p><p class=ql-align-justify>[6] sequence 5：CPU 2對內存地址0執行Store操作，由於CPU 2的cache line是Exclusive狀態(對內存地址0的數據是獨佔狀態的)，於是CPU 2可以直接將新的值寫入cache line覆蓋老值，cache line狀態轉換成Modified狀態。(這個時候，內存地址0中的數據已經是Invalid的，其他CPU如果想load內存地址0的數據，不能直接從內存地址0加載數據了，需要嗅探(snoop)的方式從CPU 2的local cache中獲取。</p><p class=ql-align-justify>[7] sequence 6：CPU 1對內存地址0執行一個原子加操作。這時候CPU 1會發出read invalidate命令，將地址0的數據從CPU 2的cache line中嗅探得到，同時通過invalidate其他CPU local cache的內容而獲得獨佔性的數據訪問權。這時候，CPU 2中的cache line狀態變成invalid狀態，而CPU 1的cache line將從invalid狀態遷移到modified狀態。</p><p class=ql-align-justify>[8] sequence 7：CPU 1對內存地址8執行load操作。由於cache line已經存放了內存地址0的數據，並且該狀態是modified的，CPU 1需要將cache line的數據寫回地址0，於是執行write back操作將地址0的數據寫回到memory(這個時候，內存地址0中的數據從Invalid變成有效的)。接著，CPU 1發出read命令，從CPU 0中得到內存地址8的數據，並寫入自己的cache line，cache line狀態轉換成Share。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>通過上面的例子，我們發現，對於某些特定地址的數據（在一個cache line中）重複的進行讀寫，這種結構可以獲得很好的性能(例如，在sequence 5，CPU 2反覆對內存地址0進行store操作將獲得很好的性能，因為，每次store操作，CPU 2僅僅需要將新值寫入自己的local cache即可)，不過，對於第一次寫，其性能非常差，如圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9012d62f52e94ffea32de0ed6892d669><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>cpu 0發起一次對某個地址的寫操作，但是local cache沒有數據，該數據在CPU 1的local cache中，因此，為了完成寫操作，CPU 0發出invalidate的命令，invalidate其他CPU的cache數據。只有完成了這些總線上的transaction之後，CPU 0才能正在發起寫的操作，這是一個漫長的等待過程。</p><p class=ql-align-justify><strong>6.2.3 Store Buffer</strong></p><p class=ql-align-justify>對於CPU 0來說，這樣的漫長等待顯得有點沒必要，因為，CPU 1中的cache line保存有什麼樣子的數據，其實都沒有意義，這個值都會被CPU 0新寫入的值覆蓋的。為了給CPU 0提速，需要將這種同步阻塞等待，變成異步處理。於是，硬件工程師，修改CPU架構，在CPU和cache之間增加store buffer這個HW block，如下圖所示：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f3741312233345419bb2fbb136730110><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>一旦增加了store buffer，那麼cpu 0無需等待其他CPU的相應，只需要將要修改的內容放入store buffer，然後繼續執行就OK了。當cache line完成了bus transaction，並更新了cache line的狀態後，要修改的數據將從store buffer進入cache line。引入了store buff，帶來了一些複雜性，一不小心，會帶來本地數據不一致的問題。我們先看看下面的代碼：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1 a = 1;</p><p class=ql-align-justify>2 b = a + 1;</p><p class=ql-align-justify>3 assert(b == 2);</p><p class=ql-align-justify>a和b都是初始化為0，並且變量a在CPU 1的cache line中，變量b在CPU 0的cacheline中。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>如果cpu執行上述代碼，那麼第三行的assert不應該失敗，不過，如果CPU設計者使用上圖中的那個非常簡單的store buffer結構，那麼你應該會遇到“驚喜”（assert失敗了）。具體的執行序列過程如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] CPU 0執行a=1的賦值操作, CPU 0遇到cache miss</p><p class=ql-align-justify>[2] CPU 0發送read invalidate消息以便從CPU 1那裡獲得數據，並invalid其他cpu保存a數據的local cache line。</p><p class=ql-align-justify>[3] 由於store buff的存在，CPU 0把要寫入的數據“1”放入store buffer</p><p class=ql-align-justify>[4] CPU 1收到read invalidate後迴應，把本地cache line的數據發送給CPU 0並清空本地cache中a的數據。</p><p class=ql-align-justify>[5] CPU 0執行b = a + 1</p><p class=ql-align-justify>[6] CPU 0 收到來自CPU 1的數據，該數據是“0”</p><p class=ql-align-justify>[7] CPU 0從cache line中加載a，獲得0值</p><p class=ql-align-justify>[8] CPU 0將store buffer中的值寫入cache line，這時候cache中的a值是“1”</p><p class=ql-align-justify>[9] CPU 0執行a＋1，得到1並將該值寫入b</p><p class=ql-align-justify>[10] CPU 0 executes assert(b == 2), which fails. OMG，你期望b等於2，但是實際上b等於了1</p><p class=ql-align-justify>```</p><p class=ql-align-justify>導致這個問題的根本原因是我們有兩個a值，一個在cache line中，一個在store buffer中。store buffer的引入，違反了每個CPU按照其視角來觀察自己的行為的時候必須是符合program order的原則。一旦違背這個原則，對軟件工程師而言就是災難。還好，有”好心“的硬件工程師幫助我們，修改了CPU的設計如下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9012d62f52e94ffea32de0ed6892d669><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>這種設計叫做store forwarding，當CPU執行load操作的時候，不但要看cache，還有看store buffer是否有內容，如果store buffer有該數據，那麼就採用store buffer中的值。有了store forwarding的設計，上面的步驟[7]中就可以在store buffer獲取正確的a值是”1“而不是”0“，因此計算得到的b的結果就是2，和我們預期的一致了。</p><p class=ql-align-justify>store forwarding解決了CPU 0的cache line和store buffer間的數據一致性問題，但是，在CPU 1的角度來看，是否也能看到一致的數據呢？我們來看下一個例子：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1 void foo(void)</p><p class=ql-align-justify>2 {</p><p class=ql-align-justify>3 a = 1;</p><p class=ql-align-justify>4 b = 1;</p><p class=ql-align-justify>5 }</p><p class=ql-align-justify>6</p><p class=ql-align-justify>7 void bar(void)</p><p class=ql-align-justify>8 {</p><p class=ql-align-justify>9 while (b == 0) continue;</p><p class=ql-align-justify>10 assert(a == 1);</p><p class=ql-align-justify>11 }</p><p class=ql-align-justify>同樣的，a和b都是初始化成0.</p><p class=ql-align-justify>```</p><p class=ql-align-justify>我們假設CPU 0執行foo函數，CPU 1執行bar函數，a變量在CPU 1的cache中，b在CPU 0 cache中，執行的操作序列如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] CPU 0執行a=1的賦值操作，由於a不在local cache中，因此，CPU 0將a值放到store buffer中之後，發送了read invalidate命令到總線上去。</p><p class=ql-align-justify>[2] CPU 1執行 while (b == 0) 循環，由於b不在CPU 1的cache中，因此，CPU發送一個read message到總線上，看看是否可以從其他cpu的local cache中或者memory中獲取數據。</p><p class=ql-align-justify>[3] CPU 0繼續執行b=1的賦值語句，由於b就在自己的local cache中（cacheline處於modified狀態或者exclusive狀態），因此CPU0可以直接操作將新的值1寫入cache line。</p><p class=ql-align-justify>[4] CPU 0收到了read message，將最新的b值”1“回送給CPU 1，同時將b cacheline的狀態設定為shared</p><p class=ql-align-justify>[5] CPU 1收到了來自CPU 0的read response消息，將b變量的最新值”1“值寫入自己的cacheline，狀態修改為shared。</p><p class=ql-align-justify>[6] 由於b值等於1了，因此CPU 1跳出while (b == 0)的循環，繼續前行。</p><p class=ql-align-justify>[7] CPU 1執行assert(a == 1)，這時候CPU 1的local cache中還是舊的a值，因此assert(a == 1)失敗。</p><p class=ql-align-justify>[8] CPU 1收到了來自CPU 0的read invalidate消息，以a變量的值進行迴應，同時清空自己的cacheline，但是這已經太晚了。</p><p class=ql-align-justify>[9] CPU 0收到了read response和invalidate ack的消息之後，將store buffer中的a的最新值”1“數據寫入cacheline，然並卵，CPU 1已經assertion fail了。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>CPU 1出現異常的assertion fail的根本原因是，CPU 0在發出read invalidate message後，並沒有等待CPU 1收到，就繼續執行將b改寫為1，也就是store buffer的存在導致了CPU 1先看到了b修改為1，後看到a被修改為1。遇到這樣的問題，CPU設計者也不能直接幫什麼忙(除非去掉store buffer)，畢竟CPU並不知道哪些變量有相關性，這些變量是如何相關的。不過CPU設計者可以間接提供一些工具讓軟件工程師來控制這些相關性。這些工具就是memory-barrier指令。要想程序正常運行，必須增加一些memory barrier的操作，具體如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1 void foo(void)</p><p class=ql-align-justify>2 {</p><p class=ql-align-justify>3 a = 1;</p><p class=ql-align-justify>4 smp_mb();</p><p class=ql-align-justify>5 b = 1;</p><p class=ql-align-justify>6 }</p><p class=ql-align-justify>7</p><p class=ql-align-justify>8 void bar(void)</p><p class=ql-align-justify>9 {</p><p class=ql-align-justify>10 while (b == 0) continue;</p><p class=ql-align-justify>11 assert(a == 1);</p><p class=ql-align-justify>12}</p><p class=ql-align-justify>```</p><p class=ql-align-justify>smp_mb() 這個內存屏障的操作會在執行後續的store操作之前，首先flush store buffer（也就是將之前的值寫入到cacheline中）。達到這個目標有兩種方法：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] CPU遇到smp_mb內存屏障後，需要等待store buffer中的數據完成transaction並將strore buffer中的數據寫入cache line；</p><p class=ql-align-justify>[2] CPU在遇到smp_mb內存屏障後，可以繼續前行，但是需要記錄一下store buffer中的數據順序，在store buffer中的數據嚴格按順序全部寫回cache line之前，其他數據不能先更新cache line，需要按照順序先寫到store buffer才能繼續前行。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>通常採用的是方法[2]，增加了smp_mb()後，執行序列如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] CPU 0執行a=1的賦值操作，由於a不在local cache中，因此，CPU 0將a值放到store buffer中之後，發送了read invalidate命令到總線上去。</p><p class=ql-align-justify>[2] CPU 1執行 while (b == 0) 循環，由於b不在CPU 1的cache中，因此，CPU發送一個read message到總線上，看看是否可以從其他cpu的local cache中或者memory中獲取數據。</p><p class=ql-align-justify>[3] CPU 0執行smp_mb()函數，給目前store buffer中的所有項做一個標記（後面我們稱之marked entries）。當然，針對我們這個例子，store buffer中只有一個marked entry就是“a=1”。</p><p class=ql-align-justify>[4] CPU 0繼續執行b=1的賦值語句，雖然b就在自己的local cache中（cacheline處於modified狀態或者exclusive狀態），不過在store buffer中有marked entry，因此CPU 0不能直接操作將新的值1寫入cache line，取而代之是b的新值'1'被寫入store buffer(CPU 0也可以不執行b=1語句，等到a的transaction完成並寫回cache line，在執行b=1，將b的新值'1'寫入cache line)，當然是unmarked狀態。</p><p class=ql-align-justify>[5] CPU 0收到了read message，將b值”0“（新值”1“還在store buffer中）回送給CPU 1，同時將b cacheline的狀態設定為shared。</p><p class=ql-align-justify>[6] CPU 1收到了來自CPU 0的read response消息，將b變量的值（'0'）寫入自己的cacheline，狀態修改為shared。</p><p class=ql-align-justify>[7] 由於smp_mb內存屏障的存在，b的新值'1'隱藏在CPU 0的store buffer中，CPU 1只能看到b的舊值'0'，這時CPU 1處於死循環中。</p><p class=ql-align-justify>[8] CPU 1收到了來自CPU 0的read invalidate消息，以a變量的值進行迴應，同時清空自己的cacheline。</p><p class=ql-align-justify>[9] CPU 0收到CPU 1的響應msg，完成了a的賦值transaction，CPU 0將store buffer中的a值寫入cacheline，並且將cacheline狀態修改為modified狀態。</p><p class=ql-align-justify>[10] 由於store buffer只有一項marked entry（對應a=1），因此，完成step 9之後，store buffer的b也可以進入cacheline了。不過需要注意的是，當前b對應的cache line的狀態是shared。</p><p class=ql-align-justify>[11] CPU 0想將store buffer中的b的新值'1'寫回cache line。由於b的cache line是share的。CPU 0需要發送invalidate消息，請求b數據的獨佔權。</p><p class=ql-align-justify>[12] CPU 1收到invalidate消息，清空自己b的 cache line，並回送acknowledgement給CPU 0。</p><p class=ql-align-justify>[13] CPU 1的某次循環執行到while (b == 0)，這時發現b的cache line是Invalid的了，於是CPU 1發送read消息，請求獲取b的數據。</p><p class=ql-align-justify>[14] CPU 0收到acknowledgement消息，將b對應的cache line修改成exclusive狀態，這時候，CPU 0終於可以將b的新值1寫入cache line了。</p><p class=ql-align-justify>[15] CPU 0收到read消息，將b的新值1回送給CPU 1，同時將其local cache中b對應的cacheline狀態修改為shared。</p><p class=ql-align-justify>[16] CPU 1獲取來自CPU 0的b的新值，將其放入cache line中。</p><p class=ql-align-justify>[17] 由於b值等於1了，因此CPU 1跳出while (b == 0)的循環，繼續前行。</p><p class=ql-align-justify>[18] CPU 1執行assert(a == 1)，不過這時候a值沒有在自己的cache line中，因此需要通過cache一致性協議從CPU 0那裡獲得，這時候獲取的是a的最新值，也就是1值，因此assert成功。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>從上面的執行序列可以看出，在調用memory barrier指令之後，使得CPU 0遲遲不能將b的新值'1'寫回cache line，從而使得CPU 1一直不能觀察到b的新值'1'，造成CPU 1一直不能繼續前行。直觀上CPU 0似乎不受什麼影響，因為CPU 0可以繼續前行，只是將b的新值'1'寫到store buffer而不能寫回cache line。不幸的是：每個cpu的store buffer不能實現的太大，其entry的數目不會太多。當cpu 0以中等的頻率執行store操作的時候（假設所有的store操作導致了cache miss），store buffer會很快的被填滿。在這種狀況下，CPU 0只能又進入等待狀態，直到cache line完成invalidation和ack的交互之後，可以將store buffer的entry寫入cacheline，從而為新的store讓出空間之後，CPU 0才可以繼續執行。這種狀況恰恰在調用了memory barrier指令之後，更容易發生，因為一旦store buffer中的某個entry被標記了，那麼隨後的store都必須等待invalidation完成，因此不管是否cache miss，這些store都必須進入store buffer，這樣就很容易塞滿store buffer。</p><p class=ql-align-justify><strong>6.2.4 Invalidate Queue</strong></p><p class=ql-align-justify>store buffer之所以很容易被填充滿，主要是其他CPU迴應invalidate acknowledge比較慢，如果能夠加快這個過程，讓store buffer儘快進入cache line，那麼也就不會那麼容易填滿了。</p><p class=ql-align-justify>invalidate acknowledge不能儘快回覆的主要原因是invalidate cacheline的操作沒有那麼快完成，特別是cache比較繁忙的時候，這時，CPU往往進行密集的loading和storing的操作，而來自其他CPU的，對本CPU local cacheline的操作需要和本CPU的密集的cache操作進行競爭，只要完成了invalidate操作之後，本CPU才會發生invalidate acknowledge。此外，如果短時間內收到大量的invalidate消息，CPU有可能跟不上處理，從而導致其他CPU不斷的等待。</p><p class=ql-align-justify>要想達到快速回復acknowledgement，一個解決方法是，引入一個緩衝隊列，接收到invalidate請求，可以先將請求入隊緩衝隊列，就可以回覆acknowledgement消息了，後面在異步完成invalidate操作。於是硬件工程師，引入一個invalidate queue，有invalidate queue的系統結構如下圖所示：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=中篇｜說說無鎖(Lock-Free)編程那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9012d62f52e94ffea32de0ed6892d669><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>異步延後處理，也需要有個度才行。一旦將一個invalidate（例如針對變量a的cacheline）消息放入CPU的Invalidate Queue，實際上該CPU就等於作出這樣的承諾：在處理完該invalidate消息之前，不會發送任何相關（即針對變量a的cacheline）的MESI協議消息。為什麼是在發出某個變量a的MESI協議消息的時候，需求去檢查invalidate queue看是否有變量a的invalidate消息呢？而不是在對該變量的任何操作都需要檢查以下invalidate queue呢？其實這樣在保證MESI協議正確性的情況下，進一步保證性能的折中方案。</p><p class=ql-align-justify>因為，在單純考慮性能的情況下，少去檢查invalidate queue，週期性(一定時間，cpu沒那麼繁忙、invalidate queue容量達到一定)批量處理invalidate queue中的消息，這樣性能能夠達到最佳。但是，這樣在某些情況下，使得MESI協議失效。例如：在一個4核的機器上，變量a初始值是'0'，它cache在CPU 0和CPU 1的cache line中，狀態都是Share。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] CPU 0需要修改變量a的值為'1'，CPU 0發送invalidate消息給其他CPU(1~3).</p><p class=ql-align-justify>[2] 其他CPU(1~3)將invalidate消息放入invalidate queue，然後都回復給CPU 0.</p><p class=ql-align-justify>[3] CPU 0收到響應後，將a的新值'1'寫入cache line並修改狀態為Modified。</p><p class=ql-align-justify>[4] CPU 2需要讀取a的時候遇到cache miss，於是CPU 2發送read消息給其他CPU，請求獲取a的數據。</p><p class=ql-align-justify>[5] CPU 1收到read請求，由於a在自己的cache line並且是share狀態的，於是CPU 1將a的invalid值'0'響應給CPU 2。</p><p class=ql-align-justify>[6] CPU 2通過一個read消息獲取到一個過期的非法的值，這樣MESI協議無法保證數據一致性了。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>於是，為了保證MESI協議的正確性，CPU在需要發出某個變量的a的MESI協議消息的時候，需要檢查invalidate queue中是否有該變量a的invalidate消息，如果有需要先出來完成這個invliadte消息後，才能發出正確的MESI協議消息。在合適的時候，發出正確的MESI協議是保證了不向其他CPU傳遞錯誤的信息，從而保證數據的一致性。但是，對於本CPU是否也可以高枕無憂呢？我們來看同上面一樣的一個例子：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1 void foo(void)</p><p class=ql-align-justify>2 {</p><p class=ql-align-justify>3 a = 1;</p><p class=ql-align-justify>4 smp_mb();</p><p class=ql-align-justify>5 b = 1;</p><p class=ql-align-justify>6 }</p><p class=ql-align-justify>7</p><p class=ql-align-justify>8 void bar(void)</p><p class=ql-align-justify>9 {</p><p class=ql-align-justify>10 while (b == 0) continue;</p><p class=ql-align-justify>11 assert(a == 1);</p><p class=ql-align-justify>12 }</p><p class=ql-align-justify>```</p><p class=ql-align-justify>在上面的代碼片段中，我們假設a和b初值是0，並且a在CPU 0和CPU 1都有緩存的副本，即a變量對應的CPU0和CPU 1的cacheline都是shared狀態。b處於exclusive或者modified狀態，被CPU 0獨佔。我們假設CPU 0執行foo函數，CPU 1執行bar函數，執行序列如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] CPU 0執行a=1的賦值操作，由於a在CPU 0 local cache中的cacheline處於shared狀態，因此，CPU 0將a的新值“1”放入store buffer，並且發送了invalidate消息去清空CPU 1對應的cacheline。</p><p class=ql-align-justify>[2] CPU 1執行while (b == 0)的循環操作，但是b沒有在local cache，因此發送read消息試圖獲取該值。</p><p class=ql-align-justify>[3] CPU 1收到了CPU 0的invalidate消息，放入Invalidate Queue，並立刻回送Ack。</p><p class=ql-align-justify>[4] CPU 0收到了CPU 1的invalidate ACK之後，即可以越過程序設定內存屏障（第四行代碼的smp_mb() ），這樣a的新值從store buffer進入cacheline，狀態變成Modified。</p><p class=ql-align-justify>[5] CPU 0 越過memory barrier後繼續執行b=1的賦值操作，由於b值在CPU 0的local cache中，因此store操作完成並進入cache line。</p><p class=ql-align-justify>[6] CPU 0收到了read消息後將b的最新值“1”回送給CPU 1，並修正該cache line為shared狀態。</p><p class=ql-align-justify>[7] CPU 1收到read response，將b的最新值“1”加載到local cacheline。</p><p class=ql-align-justify>[8] 對於CPU 1而言，b已經等於1了，因此跳出while (b == 0)的循環，繼續執行後續代碼</p><p class=ql-align-justify>[9] CPU 1執行assert(a == 1)，但是由於這時候CPU 1 cache的a值仍然是舊值0，因此assertion 失敗</p><p class=ql-align-justify>[10] 該來總會來，Invalidate Queue中針對a cacheline的invalidate消息最終會被CPU 1執行，將a設定為無效，但，大錯已經釀成。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>CPU 1出現assert失敗，是因為沒有及時處理invalidate queue中的a的invalidate消息，導致使用了本cache line中的一個已經是invalid的一箇舊的值，這是典型的cache帶來的一致性問題。這個時候，我們也需要一個memory barrier指令來告訴CPU，這個時候應該需要處理invalidate queue中的消息了，否則可能會讀到一個invalid的舊值。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>當CPU執行memory barrier指令的時候，對當前Invalidate Queue中的所有的entry進行標註，這些被標註的項被稱為marked entries，而隨後CPU執行的任何的load操作都需要等到Invalidate Queue中所有marked entries完成對cacheline的操作之後才能進行</p><p class=ql-align-justify>```</p><p class=ql-align-justify>因此，要想保證程序邏輯正確，我們需要給bar函數增加內存屏障的操作，具體如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1 void foo(void)</p><p class=ql-align-justify>2 {</p><p class=ql-align-justify>3 a = 1;</p><p class=ql-align-justify>4 smp_mb();</p><p class=ql-align-justify>5 b = 1;</p><p class=ql-align-justify>6 }</p><p class=ql-align-justify>7</p><p class=ql-align-justify>8 void bar(void)</p><p class=ql-align-justify>9 {</p><p class=ql-align-justify>10 while (b == 0) continue;</p><p class=ql-align-justify>11 smp_mb();</p><p class=ql-align-justify>12 assert(a == 1);</p><p class=ql-align-justify>13 }</p><p class=ql-align-justify>```</p><p class=ql-align-justify>bar()函數添加smp_mb內存屏障後，執行序列如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>[1] ~ [8] 同上</p><p class=ql-align-justify>[9] CPU 1遇到smp_mb內存屏障，發現下一條語句是load a，這個時候CPU 1不能繼續執行代碼，只能等待，直到Invalidate Queue中的message被處理完成</p><p class=ql-align-justify>[10] CPU 1處理Invalidate Queue中緩存的Invalidate消息，將a對應的cacheline設置為無效。</p><p class=ql-align-justify>[11] 由於a變量在local cache中無效，因此CPU 1在執行assert(a == 1)的時候需要發送一個read消息去獲取a值。</p><p class=ql-align-justify>[12] CPU 0用a的新值1迴應來自CPU 1的請求。</p><p class=ql-align-justify>[13] CPU 1獲得了a的新值，並放入cacheline，這時候assert(a == 1)不會失敗了。</p><p class=ql-align-justify>```</p><p class=ql-align-justify>在我們上面的例子中，memory barrier指令對store buffer和invalidate queue都進行了標註，不過，在實際的代碼片段中，foo函數不需要mark invalidate queue，bar函數不需要mark store buffer。因此，許多CPU architecture提供了弱一點的memory barrier指令只mark其中之一。如果只mark invalidate queue，那麼這種memory barrier被稱為read memory barrier。相應的，write memory barrier只mark store buffer。一個全功能的memory barrier會同時mark store buffer和invalidate queue。</p><p class=ql-align-justify>我們一起來看看讀寫內存屏障的執行效果：對於read memory barrier指令，它只是約束執行CPU上的load操作的順序，具體的效果就是CPU一定是完成read memory barrier之前的load操作之後，才開始執行read memory barrier之後的load操作。read memory barrier指令象一道柵欄，嚴格區分了之前和之後的load操作。同樣的，write memory barrier指令，它只是約束執行CPU上的store操作的順序，具體的效果就是CPU一定是完成write memory barrier之前的store操作之後，才開始執行write memory barrier之後的store操作。全功能的memory barrier會同時約束load和store操作，當然只是對執行memory barrier的CPU有效。</p><p class=ql-align-justify>現在，我們可以改一個用讀寫內存屏障的版本了，具體如下：</p><p class=ql-align-justify>```</p><p class=ql-align-justify>1 void foo(void)</p><p class=ql-align-justify>2 {</p><p class=ql-align-justify>3 a = 1;</p><p class=ql-align-justify>4 smp_wmb();</p><p class=ql-align-justify>5 b = 1;</p><p class=ql-align-justify>6 }</p><p class=ql-align-justify>7</p><p class=ql-align-justify>8 void bar(void)</p><p class=ql-align-justify>9 {</p><p class=ql-align-justify>10 while (b == 0) continue;</p><p class=ql-align-justify>11 smp_rmb();</p><p class=ql-align-justify>12 assert(a == 1);</p><p class=ql-align-justify>13 }</p><p class=ql-align-justify>```</p><p class=ql-align-justify>可見，memory barrier需要成對使用才能保證程序的正確性。什麼情況下使用memory barrier，使用怎樣的memory barrier，和CPU架構有那些相關性呢？</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>無鎖</a></li><li><a>Lock</a></li><li><a>Free</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/63d4e3cb.html alt="Nord-Lock - 洛帝牢原創防鬆墊圈" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/97f60078d35a4b7dbc1f1e2aac1f7d6f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/63d4e3cb.html title="Nord-Lock - 洛帝牢原創防鬆墊圈">Nord-Lock - 洛帝牢原創防鬆墊圈</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/acade886.html alt="不說再見，「Free! DF」最終話暗示2020年有新作？！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1538035322430fe71f56086 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/acade886.html title="不說再見，「Free! DF」最終話暗示2020年有新作？！">不說再見，「Free! DF」最終話暗示2020年有新作？！</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/fb213f8.html alt="《Free!-Dive to the Future-》追加聲優陣容公開" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1528957258678f1303239cb style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/fb213f8.html title="《Free!-Dive to the Future-》追加聲優陣容公開">《Free!-Dive to the Future-》追加聲優陣容公開</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/cfffcfa.html alt="《Free！》第3季動畫公佈新視覺圖等情報 7月11日開播" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1529027783459032785269c style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/cfffcfa.html title="《Free！》第3季動畫公佈新視覺圖等情報 7月11日開播">《Free！》第3季動畫公佈新視覺圖等情報 7月11日開播</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/463a25e.html alt="是大學生啦！「Free!Dive to the Future」7月11日開播！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/15299151493068bb26d1674 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/463a25e.html title="是大學生啦！「Free!Dive to the Future」7月11日開播！">是大學生啦！「Free!Dive to the Future」7月11日開播！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>