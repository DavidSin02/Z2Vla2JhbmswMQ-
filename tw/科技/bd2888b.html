<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>阿里巴巴Java開發手冊（編程規約） | 极客快訊</title><meta property="og:title" content="阿里巴巴Java開發手冊（編程規約） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/8a3c300c57ee458d82c8222963f3fdd1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd2888b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd2888b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bd2888b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd2888b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd2888b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bd2888b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bd2888b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd2888b.html><meta property="article:published_time" content="2020-10-29T21:01:26+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:26+08:00"><meta name=Keywords content><meta name=description content="阿里巴巴Java開發手冊（編程規約）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/bd2888b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>阿里巴巴Java開發手冊（編程規約）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>李豔鵬</p><div class=pgc-img><img alt=阿里巴巴Java開發手冊（編程規約） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a3c300c57ee458d82c8222963f3fdd1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt=阿里巴巴Java開發手冊（編程規約） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/83fd01b326c3407885deb64b49a0ce84><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>研發流程管理</p><p>最近，阿里巴巴發佈了《阿里巴巴Java開發手冊》，總結了阿里人多年一線實戰中積累的研發流程規範，這些流程規範在一定程度上能夠保證最終的項目交付質量，通過限制開發人員的編程風格、實現方式來避免研發人員在實踐中容易犯的錯誤，同樣的問題大家使用同樣的模式解決，便於後期維護和擴展，確保最終在大規模協作的項目中達成既定目標。</p><p>無獨有偶，筆者去年在公司裡負責升級和制定研發流程、設計模板、設計標準、代碼標準等規範，並在實際工作中進行了應用和推廣，收效頗豐，也總結了適合支付平臺的技術規範，由於阿里巴巴Java開發手冊本身定位為規約和規範，語言簡單、精煉，沒有太多的解讀和示例，有些條款對於一般開發人員理解起來比較困難，本文藉著阿里巴巴發佈的Java開發手冊，詳細解讀Java平臺下開發規範和標準的制定和實施，強調那些在開發過程中需要重點關注的技術點，特別是解決某類已識別問題的模式和反模式。</p><p>《阿里巴巴Java開發手冊》分為編程規約、異常日誌、MySQL規約、工程規約、安全規約五大部分，本系列文章以這五部分主題為主線，分為五篇文章發佈，本文為系列文章的第一篇-編程規約，後續會盡快發佈其餘的文章。</p><p><strong>1 命名規約</strong></p><ol><li>【強制】 代碼中的命名均不能以下劃線或美元符號開始，也不能以下劃線或美元符號結束。</li><li>反例: _name / _<em>name / $Object / name</em> / name$ / Object$</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這條不夠嚴格，普通的變量、類名、方法名必須使用駝峰式命名，最好不要使用下劃線和美元符號，否則看起來像腳本語言似得，常量可以使用下劃線，但是也不要放在常量開頭和結尾。</li></ul><ol><li>【強制】 代碼中的命名嚴禁使用拼音與英文混合的方式，更不允許直接使用中文的方式。</li><li>說明: 正確的英文拼寫和語法可以讓閱讀者易於理解，避免歧義。注意，即使純拼音命名方式 也要避免採用。</li><li>反例: DaZhePromotion [打折] / getPingfenByName() [評分] / int 某變量 = 3</li><li>正例: alibaba / taobao / youku / hangzhou 等國際通用的名稱，可視同英文。</li><li><strong>白話：</strong></li></ol><ul><li>中英混合的人種咱不歧視，變量名混合太醜了。</li><li class=ql-indent-1><br></li><li>Java編譯器支持Unicode（UTF-8)，允許中文命名變量，不過打中文還是沒有英文快。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>英文！英文起名，洋氣、大方、高大上...</li></ul><ol><li>【強制】類名使用 UpperCamelCase 風格，必須遵從駝峰形式，但以下情形例外:(領域模型 的相關命名)DO / BO / DTO / VO等。</li><li>正例:MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</li><li>反例:macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>約定俗成的名稱或者縮寫例外。</li></ul><ol><li>【強制】方法名、參數名、成員變量、局部變量都統一使用 lowerCamelCase 風格，必須遵從駝峰形式。</li><li>正例: localValue / getHttpMessage() / inputUserId</li><li><strong>白話：</strong></li></ol><ul><li>約定俗稱的名稱或者縮寫例外。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>ID為簡寫，Id和ID均可。</li></ul><ol><li>【強制】常量命名全部大寫，單詞間用下劃線隔開，力求語義表達完整清楚，不要嫌名字長。</li><li>正例: MAX_STOCK_COUNT</li><li>反例: MAX_COUNT</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>必須全部大寫，除了字母數字只可以使用下劃線，並且不能用在開頭和結尾。</li></ul><ol><li>【強制】抽象類命名使用 Abstract 或 Base 開頭;異常類命名使用 Exception 結尾;測試類命名以它要測試的類的名稱開始，以 Test 結尾。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>家裡放一瓶敵敵畏，上面不寫標籤，萬一喝大了、渴了、喝了、就慘了，你懂的。</li></ul><ol><li>【強制】中括號是數組類型的一部分，數組定義如下:String[] args;</li><li>反例: 使用String args[]的方式來定義。</li><li><strong>白話：</strong></li></ol><ul><li>這種語法編譯器也認，但是我們畢竟寫Java程序，而不是寫C/C++程序。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>這怪Java編譯器小組，一開始就不應該支持這種語法。</li></ul><ol><li>【強制】POJO 類中布爾類型的變量，都不要加 is，否則部分框架解析會引起序列化錯誤。</li><li>反例: 定義為基本數據類型Boolean isSuccess;的屬性，它的方法也是isSuccess()，RPC 框架在反向解析的時候，“以為”對應的屬性名稱是 success，導致屬性獲取不到，進而拋出異常。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>一些框架使用getter和setter做序列化，有的根據屬性本身取值，帶了is前綴就找不到了，變量名不要帶be動詞，語法不對，英文補考！</li></ul><ol><li>【強制】包名統一使用小寫，點分隔符之間有且僅有一個自然語義的英語單詞。包名統一使用 單數形式，但是類名如果有複數含義，類名可以使用複數形式。</li><li>正例: 應用工具類包名為com.alibaba.open.util、類名為MessageUtils(此規則參考 spring 的框架結構)</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>包名大寫、帶下劃線等，不專業、難看、不高大上。</li></ul><ol><li>【強制】杜絕完全不規範的縮寫，避免望文不知義。</li><li>反例: AbstractClass“縮寫”命名成 AbsClass;condition“縮寫”命名成 condi，此類 隨意縮寫嚴重降低了代碼的可閱讀性。</li><li><strong>白話：</strong></li></ol><ul><li>不要太摳，不是太長的名字直接寫上就好，編譯器編譯優化後變量名將不存在，會編譯成相對於方法堆棧bp指針地址的相對地址，長變量名不會佔用更多空間。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>英文中的縮寫有個慣例，去掉元音留下輔音即可，不能亂縮寫。</li></ul><ol><li>【推薦】如果使用到了設計模式，建議在類名中體現出具體模式。</li><li>說明: 將設計模式體現在名字中，有利於閱讀者快速理解架構設計思想。</li><li>正例: public class OrderFactory;</li><li>public class LoginProxy;</li><li>public class ResourceObserver;</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>讓全世界都知道你會設計模式，這是個崇尚顯擺的社會。</li></ul><ol><li>【推薦】接口類中的方法和屬性不要加任何修飾符號(public 也不要加)，保持代碼的簡潔 性，並加上有效的 Javadoc 註釋。儘量不要在接口裡定義變量，如果一定要定義變量，肯定是與接口方法相關，並且是整個應用的基礎常量。</li><li>正例: 接口方法簽名:void f();</li><li>接口基礎常量表示:String COMPANY = "alibaba";</li><li>反例: 接口方法定義:public abstract void f();</li><li>說明:JDK8 中接口允許有默認實現，那麼這個 default 方法，是對所有實現類都有價值的默 認實現。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>脫了褲子放屁始終有點麻煩。</li></ul><ol><li>接口和實現類的命名有兩套規則:</li><li>1)【強制】對於 Service 和 DAO 類，基於 SOA 的理念，暴露出來的服務一定是接口，內部的實現類用 Impl 的後綴與接口區別。</li><li>正例: CacheServiceImpl 實現 CacheService 接口。</li><li>2)【推薦】 如果是形容能力的接口名稱，取對應的形容詞做接口名(通常是–able 的形式)。</li><li>正例: AbstractTranslator 實現 Translatable。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>嚴重同意！可是想想Observer和Observable，我就不說話了。</li></ul><ol><li>【參考】枚舉類名建議帶上 Enum 後綴，枚舉成員名稱需要全大寫，單詞間用下劃線隔開。</li><li>說明: 枚舉其實就是特殊的常量類，且構造方法被默認強制是私有。</li><li>正例: 枚舉名字:DealStatusEnum，成員名稱: SUCCESS / UNKOWN_REASON。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>不要駝峰！記住枚舉不要駝峰！總是有好多人枚舉用駝峰。</li></ul><ol><li>【參考】各層命名規約:</li><li>A) Service/DAO層方法命名規約</li><li class=ql-indent-1>獲取單個對象的方法用get做前綴。</li><li class=ql-indent-1>獲取多個對象的方法用list做前綴。</li><li class=ql-indent-1>獲取統計值的方法用count做前綴。</li><li class=ql-indent-1>插入的方法用save(推薦)或insert做前綴。</li><li class=ql-indent-1>刪除的方法用remove(推薦)或delete做前綴。</li><li>修改的方法用update做前綴。</li><li class=ql-indent-1>B) 領域模型命名規約</li><li class=ql-indent-1>數據對象:xxxDO，xxx即為數據表名。</li><li class=ql-indent-1>數據傳輸對象:xxxDTO，xxx為業務領域相關的名稱。</li><li class=ql-indent-1>展示對象:xxxVO，xxx一般為網頁名稱。</li><li class=ql-indent-1>POJO是DO/DTO/BO/VO的統稱，禁止命名成xxxPOJO。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>大家都這麼認為很重要。</li></ul><p><strong>2 常量定義</strong></p><ol><li>【強制】不允許出現任何魔法值(即未經定義的常量)直接出現在代碼中。</li><li>反例: String key = "Id#taobao_"+tradeId; cache.put(key, value);</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這個不用說了，隨地吐痰和隨地大小便是不應該的，新加坡是要鞭刑的！</li></ul><ol><li>【強制】long 或者 Long 初始賦值時，必須使用大寫的 L，不能是小寫的 l，小寫容易跟數字 1 混淆，造成誤解。</li><li>說明: Long a = 2l; 寫的是數字的21，還是Long型的2?</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>看看區塊鏈中用了base58，而不是base64，秒懂什麼是從用戶角度考慮產品設計！</li></ul><ol><li>【推薦】不要使用一個常量類維護所有常量，應該按常量功能進行歸類，分開維護。如:緩存相關的常量放在類: CacheConsts 下; 系統配置相關的常量放在類: ConfigConsts 下。</li><li>說明: 大而全的常量類，非得使用查找功能才能定位到修改的常量，不利於理解和維護。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>儘量讓功能自閉包，標準是一個小模塊拷貝出去直接就能用，而不是缺這缺那的，是不是讀者很多時候拷貝了一套類，運行時候發現不能用，缺常量，把常量類拷貝過來，發現常量類中有很多不相關的常量，還得清理。</li></ul><ol><li>【推薦】常量的複用層次有五層: 跨應用共享常量、應用內共享常量、子工程內共享常量、包內共享常量、類內共享常量。</li><li>跨應用共享常量: 放置在二方庫中，通常是client.jar中的constant目錄下。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>應用內共享常量: 放置在一方庫的modules中的constant目錄下。</li><li>反例: 易懂變量也要統一定義成應用內共享常量，兩位攻城師在兩個類中分別定義了表示 “是”的變量:</li><li>類A中: public static final String YES = "yes";</li><li>類B中: public static final String YES = "y"; A.YES.equals(B.YES)，預期是 true，但實際返回為 false，導致產生線上問題。</li><li>子工程內部共享常量: 即在當前子工程的constant目錄下。</li><li class=ql-indent-1><br></li><li>包內共享常量: 即在當前包下單獨的constant目錄下。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>類內共享常量: 直接在類內部private static final定義。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>一方庫、二方庫、三方庫，叫法很專業，放在離自己最近的上面一個層次即可。</li></ul><ol><li>【推薦】如果變量值僅在一個範圍內變化用 Enum 類。如果還帶有名稱之外的延伸屬性，必須 使用 Enum 類，下面正例中的數字就是延伸信息，表示星期幾。</li><li>正例: public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);}</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>枚舉值需要定義延伸屬性的場景通常是要持久數據庫，或者顯示在界面上。</li></ul><p><strong>3 格式規約</strong></p><ol><li>【強制】大括號的使用約定。如果是大括號內為空，則簡潔地寫成{}即可，不需要換行; 如果 是非空代碼塊則:</li><li class=ql-indent-1>左大括號前不換行。</li><li class=ql-indent-1>左大括號後換行。</li><li class=ql-indent-1>右大括號前換行。</li><li class=ql-indent-1>右大括號後還有else等代碼則不換行;表示終止右大括號後必須換行。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>好風格，討厭那種左大括號前換行的，看不慣。</li></ul><ol><li>【強制】 左括號和後一個字符之間不出現空格; 同樣，右括號和前一個字符之間也不出現空 格。詳見第 5 條下方正例提示。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>程序寫完可以用編輯器的格式化功能格式化，Eclipse中快捷鍵是shift+alt+f，筆者寫程序的時候有個習慣，每次謝了一段代碼都會按ctrl+alt+o、ctrl+alt+f、ctrl+s，相信會有相同習慣的同行。</li></ul><ol><li>【強制】if/for/while/switch/do 等保留字與左右括號之間都必須加空格。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>程序寫完可以用編輯器的格式化功能格式化，Eclipse中快捷鍵是shift+alt+f，筆者寫程序的時候有個習慣，每次謝了一段代碼都會按ctrl+alt+o、ctrl+alt+f、ctrl+s，相信會有相同習慣的同行。</li></ul><ol><li>【強制】任何運算符左右必須加一個空格。</li><li>說明: 運算符包括賦值運算符=、邏輯運算符&&、加減乘除符號、三目運算符等。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>程序寫完可以用編輯器的格式化功能格式化，Eclipse中快捷鍵是shift+alt+f，筆者寫程序的時候有個習慣，每次謝了一段代碼都會按ctrl+alt+o、ctrl+alt+f、ctrl+s，相信會有相同習慣的同行。</li></ul><ol><li>【強制】縮進採用 4 個空格，禁止使用 tab 字符。</li><li>說明: 如果使用 tab 縮進，必須設置 1 個 tab 為 4 個空格。IDEA 設置 tab 為 4 個空格時，請勿勾選Use tab character; 而在 eclipse 中，必須勾選 insert spaces for tabs。</li><li>正例: (涉及1-5點)</li></ol><pre>public static void main(String[] args) { // 縮進 4 個空格 String say = "hello"; // 運算符的左右必須有一個空格 int flag = 0; // 關鍵詞 if 與括號之間必須有一個空格，括號內的 f 與左括號，0 與右括號不需要空格  if (flag == 0) { System.out.println(say); } // 左大括號前加空格且不換行;左大括號後換行  if (flag == 1) { System.out.println("world"); // 右大括號前換行，右大括號後有 else，不用換行 } else { System.out.println("ok"); // 在右大括號後直接結束，則必須換行 }}</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這樣看慣了，怎麼看怎麼清晰。</li></ul><ol><li>【強制】單行字符數限制不超過 120 個，超出需要換行，換行時遵循如下原則:</li><li class=ql-indent-1>第二行相對第一行縮進 4 個空格，從第三行開始，不再繼續縮進，參考示例。</li><li class=ql-indent-1>運算符與下文一起換行。</li><li class=ql-indent-1>方法調用的點符號與下文一起換行。</li><li class=ql-indent-1>在多個參數超長，逗號後進行換行。</li><li class=ql-indent-1>在括號前不要換行，見反例。</li><li>正例:</li></ol><pre>StringBuffer sb = new StringBuffer();//超過 120 個字符的情況下，換行縮進 4 個空格，並且方法前的點符號一起換行 sb.append("zi").append("xin")... .append("huang")... .append("huang")... .append("huang");</pre><ol><li>反例:</li></ol><pre>StringBuffer sb = new StringBuffer();//超過 120 個字符的情況下，不要在括號前換行 sb.append("zi").append("xin")...append ("huang"); //參數很多的方法調用可能超過 120 個字符，不要在逗號前換行 method(args1, args2, args3, ..., argsX);</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>一行代碼儘量不要寫太長，長了拆開不就得了。</li></ul><ol><li>【強制】方法參數在定義和傳入時，多個參數逗號後邊必須加空格。</li><li>正例: 下例中實參的"a", 後邊必須要有一個空格。</li></ol><pre>method("a", "b", "c");</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>不加空格太擠了，就像人沒長開似得。</li></ul><ol><li>【強制】IDE的text file encoding設置為UTF-8; IDE中文件的換行符使用Unix格式， 不要使用 windows 格式。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>請不要用GB字符集，換了環境總有問題，Java程序多數跑在Linux上，當然要用Unix換行符。</li></ul><ol><li>【推薦】沒有必要增加若干空格來使某一行的字符與上一行的相應字符對齊。</li><li>正例:</li></ol><pre>int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer();</pre><ol><li>說明: 增加 sb 這個變量，如果需要對齊，則給 a、b、c 都要增加幾個空格，在變量比較多的 情況下，是一種累贅的事情。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>沒必要，沒必要，那樣反而不好看。</li></ul><ol><li>【推薦】方法體內的執行語句組、變量的定義語句組、不同的業務邏輯之間或者不同的語義</li><li>之間插入一個空行。相同業務邏輯和語義之間不需要插入空行。</li></ol><p>說明: 沒有必要插入多行空格進行隔開。</p><p><strong>白話：</strong></p><ul><li>和我的習慣一樣一樣的，一段邏輯空一行。</li></ul><p><strong>4 OOP 規約</strong></p><ol><li>【強制】避免通過一個類的對象引用訪問此類的靜態變量或靜態方法，無謂增加編譯器解析成</li><li>本，直接用類名來訪問即可。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>也不直觀，看調用代碼看不出來是靜態方法，容易誤解。</li></ul><ol><li>【強制】所有的覆寫方法，必須加@Override 註解。</li><li>反例:getObject()與 get0bject()的問題。一個是字母的 O，一個是數字的 0，加@Override 可以準確判斷是否覆蓋成功。另外，如果在抽象類中對方法簽名進行修改，其實現類會馬上編譯報錯。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>Java和C++不一樣，C++是在父類先聲明虛擬函數子類才覆寫，Java是任何方法都能覆寫，也可以不覆寫，所以覆寫不覆寫是沒有編譯器檢查的，除非接口中某一個方法完全沒有被實現才會編譯報錯。</li></ul><ol><li>【強制】相同參數類型，相同業務含義，才可以使用 Java 的可變參數，避免使用 Object。</li><li>說明: 可變參數必須放置在參數列表的最後。(提倡同學們儘量不用可變參數編程)</li><li>正例: public User getUsers(String type, Integer... ids)</li><li><strong>白話：</strong></li></ol><ul><li>用處不大，可以用重載方法或者數組參數代替。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>一般應用在日誌的 API 定義上，用於傳不定的日誌參數。</li></ul><ol><li>【強制】外部正在調用或者二方庫依賴的接口，不允許修改方法簽名，避免對接口調用方產生 影響。接口過時必須加@Deprecated 註解，並清晰地說明採用的新接口或者新服務是什麼。</li><li><strong>白話：</strong></li></ol><ul><li>設計時沒有考慮周全，需要改造接口，需要通過增加新接口，遷移後下線老接口的方式實現。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>REST接口只能增加參數，不能減少參數，返回值的內容也是隻增不減。</li></ul><ol><li>【強制】不能使用過時的類或方法。</li><li>說明: java.net.URLDecoder 中的方法 decode(String encodeStr) 這個方法已經過時，應該使用雙參數 decode(String source, String encode)。接口提供方既然明確是過時接口，那麼有義務同時提供新的接口; 作為調用方來說，有義務去考證過時方法的新實現是什麼。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>明確了責任和義務，接口提供方也有義務推動接口使用方儘早遷移，不要積累技術負債。</li></ul><ol><li>【強制】Object 的 equals 方法容易拋空指針異常，應使用常量或確定有值的對象來調用 equals。</li><li>正例: "test".equals(object);</li><li>反例: object.equals("test");</li><li>說明: 推薦使用java.util.Objects#equals (JDK7引入的工具類)</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>常量比變量，永遠都不變的原則。</li></ul><ol><li>【強制】所有的相同類型的包裝類對象之間值的比較，全部使用 equals 方法比較。</li><li>說明: 對於Integer var = ?在-128至127之間的賦值，Integer對象是在 IntegerCache.cache 產生，會複用已有對象，這個區間內的 Integer 值可以直接使用==進行 判斷，但是這個區間之外的所有數據，都會在堆上產生，並不會複用已有對象，這是一個大坑， 推薦使用 equals 方法進行判斷。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>Java世界裡相等請用equals方法，==表示對象相等，一般在框架開發中會用到。</li></ul><ol><li>關於基本數據類型與包裝數據類型的使用標準如下:</li><li class=ql-indent-1>【強制】所有的POJO類屬性必須使用包裝數據類型。</li><li class=ql-indent-1>【強制】RPC方法的返回值和參數必須使用包裝數據類型。</li><li class=ql-indent-1>【推薦】所有的局部變量使用基本數據類型。</li><li>說明: POJO 類屬性沒有初值是提醒使用者在需要使用時，必須自己顯式地進行賦值，任何</li><li>NPE 問題，或者入庫檢查，都由使用者來保證。</li><li>正例: 數據庫的查詢結果可能是 null，因為自動拆箱，用基本數據類型接收有 NPE 風險。</li><li>反例: 比如顯示成交總額漲跌情況，即正負 x%，x 為基本數據類型，調用的 RPC 服務，調用不成功時，返回的是默認值，頁面顯示:0%，這是不合理的，應該顯示成中劃線-。所以包裝數據類型的 null 值，能夠表示額外的信息，如:遠程調用失敗，異常退出。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>其實包裝數據類型與基本數據類型相比，增加了一個null的狀態，可以攜帶更多的語義。</li></ul><ol><li>【強制】定義 DO/DTO/VO 等 POJO 類時，不要設定任何屬性默認值。</li><li>反例: POJO類的gmtCreate默認值為new Date(); 但是這個屬性在數據提取時並沒有置入具體值，在更新其它字段時又附帶更新了此字段，導致創建時間被修改成當前時間。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>雖然這裡反例不太容易看懂，但是要記得持久領域對象之前由應用層統一賦值gmtCreate和gmtModify字段。</li></ul><ol><li>【強制】序列化類新增屬性時，請不要修改 serialVersionUID 字段，避免反序列失敗; 如 果完全不兼容升級，避免反序列化混亂，那麼請修改 serialVersionUID 值。</li><li>說明:注意 serialVersionUID 不一致會拋出序列化運行時異常。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>不到萬不得已不要使用JDK自身的序列化，機制很重，信息冗餘有版本。</li></ul><ol><li>【強制】構造方法裡面禁止加入任何業務邏輯，如果有初始化邏輯，請放在 init 方法中。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這樣做一種是規範，代碼清晰，還有就是異常堆棧上更容易識別出錯的方法和語句。</li></ul><ol><li>【強制】POJO 類必須寫 toString 方法。使用 IDE 的中工具:source> generate toString 時，如果繼承了另一個 POJO 類，注意在前面加一下 super.toString。</li><li>說明: 在方法執行拋出異常時，可以直接調用 POJO 的 toString()方法打印其屬性值，便於排 查問題。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這裡還有一個大坑，寫toString的時候要保證不會發生NPE，有的時候toString調用實例變量的toString，實例變量由於某些原因為null，導致NPE，代碼沒有處理好就終止，這個問題坑了好多次。</li></ul><ol><li>【推薦】使用索引訪問用 String 的 split 方法得到的數組時，需做最後一個分隔符後有無內容的檢查，否則會有拋 IndexOutOfBoundsException 的風險。</li><li>說明:</li></ol><pre>String str = "a,b,c,,"; String[] ary = str.split(","); //預期大於 3，結果是 3 System.out.println(ary.length); </pre><ol><li><strong>白話：</strong></li></ol><ul><li>編程要留心眼，任何不確定的地方都要判斷、處理，否則掉到坑裡了自己爬出來很費勁。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>Java編程判空的思想要實施縈繞在每個開發人員的腦海裡。</li></ul><ol><li>【推薦】當一個類有多個構造方法，或者多個同名方法，這些方法應該按順序放置在一起， 便於閱讀。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這規範說的咋就和我的習慣一模一樣呢！</li></ul><ol><li>【推薦】 類內方法定義順序依次是: 公有方法或保護方法 > 私有方法 > getter/setter</li><li>方法。</li><li>說明: 公有方法是類的調用者和維護者最關心的方法，首屏展示最好; 保護方法雖然只是子類 關心，也可能是“模板設計模式”下的核心方法; 而私有方法外部一般不需要特別關心，是一個黑盒實現; 因為方法信息價值較低，所有 Service 和 DAO 的 getter/setter 方法放在類體最 後。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>我推薦把一套邏輯的共有方法、保護方法、私有方法放在一起，所有getter/setter放在最後，這樣感覺更有邏輯！</li></ul><ol><li>【推薦】setter 方法中，參數名稱與類成員變量名稱一致，this.成員名 = 參數名。在</li><li>getter/setter 方法中，儘量不要增加業務邏輯，增加排查問題的難度。</li><li>反例:</li></ol><pre>public Integer getData() {  if (true) { return data + 100;  } else { return data - 100; } }</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>雙手贊成。</li></ul><ol><li>【推薦】循環體內，字符串的連接方式，使用 StringBuilder 的 append 方法進行擴展。</li><li>反例:</li></ol><pre> String str = "start"; for (int I = 0; I &lt; 100; i++) { str = str + "hello";  }</pre><ol><li>說明: 反編譯出的字節碼文件顯示每次循環都會 new 出一個 StringBuilder 對象，然後進行 append 操作，最後通過 toString 方法返回 String 對象，造成內存資源浪費。</li><li><strong>白話：</strong></li></ol><ul><li>一定使用StringBuilder，不要使用StringBuffer，StringBuffer是線程安全的，太重。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>我就一直想不明白Java編譯器為什麼不做個優化呢？</li></ul><ol><li>【推薦】下列情況，聲明成 final 會更有提示性:</li><li class=ql-indent-1>不需要重新賦值的變量，包括類屬性、局部變量。</li><li class=ql-indent-1>對象參數前加final，表示不允許修改引用的指向。</li><li class=ql-indent-1>類方法確定不允許被重寫。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>儘量多使用final關鍵字，保證編譯器的校驗機制起作用，也體現了“契約式編程”的思想。</li></ul><ol><li>【推薦】慎用 Object 的 clone 方法來拷貝對象。</li><li>說明: 對象的 clone 方法默認是淺拷貝，若想實現深拷貝需要重寫 clone 方法實現屬性對象的拷貝。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>最好是使用構造函數來重新構造對象，使用clone淺拷貝的時候，對象引用關係可能很複雜，不直觀，不好理解。</li></ul><ol><li>【推薦】類成員與方法訪問控制從嚴:</li><li class=ql-indent-1>如果不允許外部直接通過new來創建對象，那麼構造方法必須是private。</li><li class=ql-indent-1>工具類不允許有public或default構造方法。</li><li class=ql-indent-1>類非static成員變量並且與子類共享，必須是protected。</li><li class=ql-indent-1>類非static成員變量並且僅在本類使用，必須是private。</li><li class=ql-indent-1>類static成員變量如果僅在本類使用，必須是private。</li><li class=ql-indent-1>若是static成員變量，必須考慮是否為final。</li><li class=ql-indent-1>類成員方法只供類內部調用，必須是private。</li><li class=ql-indent-1>類成員方法只對繼承類公開，那麼限制為protected。</li><li>說明: 任何類、方法、參數、變量，嚴控訪問範圍。過寬泛的訪問範圍，不利於模塊解耦。</li><li>思考: 如果是一個 private 的方法，想刪除就刪除，可是一個 public 的 Service 方法，或者一個 public 的成員變量，刪除一下，不得手心冒點汗嗎?變量像自己的小孩，儘量在自己的視 線內，變量作用域太大，如果無限制的到處跑，那麼你會擔心的。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>沒什麼好說的，兩個詞，高內聚，低耦合，功能模塊閉包，哦，是三個詞。</li></ul><p><strong>5 集合處理</strong></p><ol><li>【強制】關於 hashCode 和 equals 的處理，遵循如下規則:</li><li class=ql-indent-1>只要重寫equals，就必須重寫hashCode。</li><li class=ql-indent-1>因為Set存儲的是不重複的對象，依據hashCode和equals進行判斷，所以Set存儲的對象必須重寫這兩個方法。</li><li class=ql-indent-1>如果自定義對象做為Map的鍵，那麼必須重寫hashCode和equals。</li><li>說明: String 重寫了 hashCode 和 equals 方法，所以我們可以非常愉快地使用 String 對象作為 key 來使用。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>Hash是個永恆的話題，大家可以看下times33和Murmurhash算法。</li></ul><ol><li>【強制】ArrayList的subList結果不可強轉成ArrayList，否則會拋出ClassCastException</li><li>異常: java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;</li><li>說明: subList 返回的是 ArrayList 的內部類 SubList，並不是 ArrayList ，而是 ArrayList 的一個視圖，對於SubList子列表的所有操作最終會反映到原列表上。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這種問題本來測試可以測試到，但是開發永遠都不要有依賴測試的想法，一切靠自己，當然我們的測試人員都是很靠譜的。</li></ul><ol><li>【強制】 在 subList 場景中，高度注意對原集合元素個數的修改，會導致子列表的遍歷、增 加、刪除均產生ConcurrentModificationException 異常。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>如果一定要更改子列表，重新構造新的ArrayList，使用public ArrayList(Collection&lt;? extends E> c)。</li></ul><ol><li>【強制】使用集合轉數組的方法，必須使用集合的toArray(T[] array)，傳入的是類型完全 一樣的數組，大小就是 list.size()。</li><li>說明: 使用 toArray 帶參方法，入參分配的數組空間不夠大時，toArray 方法內部將重新分配內存空間，並返回新數組地址; 如果數組元素大於實際所需，下標為[ list.size() ]的數組元素將被置為 null，其它數組元素保持原值，因此最好將方法入參數組大小定義與集合元素個數一致。</li><li>正例:</li></ol><pre>List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add("guan");list.add("bao");String[] array = new String[list.size()]; array = list.toArray(array);</pre><ol><li>反例: 直接使用 toArray 無參方法存在問題，此方法返回值只能是 Object[]類，若強轉其它類型數組將出現 ClassCastException 錯誤。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>搞不懂Java編譯器為什麼不做優化，人用邏輯能推導的，程序一定可以自動實現。</li></ul><ol><li>【強制】使用工具類 Arrays.asList()把數組轉換成集合時，不能使用其修改集合相關的方 法，它的 add/remove/clear 方法會拋出 UnsupportedOperationException 異常。</li><li>說明: asList 的返回對象是一個 Arrays 內部類，並沒有實現集合的修改方法。Arrays.asList 體現的是適配器模式，只是轉換接口，後臺的數據仍是數組。</li></ol><pre>String[] str = new String[] { "a", "b" };List list = Arrays.asList(str);</pre><ol><li>第一種情況: list.add("c"); 運行時異常。</li><li>第二種情況: str[0] = "gujin"; 那麼list.get(0)也會隨之修改。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>如果需要對asList返回的List做更改，可以構造新的ArrayList，使用public ArrayList(Collection&lt;? extends E> c)構造器。</li></ul><ol><li>【強制】泛型通配符&lt;? extends T>來接收返回的數據，此寫法的泛型集合不能使用add方 法，而&lt;? super T>不能使用get方法，做為接口調用賦值時易出錯。</li><li>說明: 擴展說一下PECS(Producer Extends Consumer Super)原則: 1)頻繁往外讀取內容的，適合用上界 Extends。 2)經常往裡插入的，適合用下界 Super。</li><li><strong>白話：</strong></li></ol><ul><li>&lt;? extends T>， ? 必須是T或T的子類</li><li>集合寫(add)： 因為不能確定集合實例化時用的是T或T的子類，所以沒有辦法寫。例如：List&lt;? extends Number> foo = new ArrayList&lt;Number/Integer/Double>()，你不能add Number，因為也可能是Integer或Double的List， 同理也不能add Integer或Double，即，extends T， 不能集合add。</li><li class=ql-indent-1>集合讀(get)： 只能讀出T類型的數據。</li><li>&lt;? super T>， ? 必須是T或T的父類</li><li>集合寫(add)： 可以add T或T的子類。</li><li class=ql-indent-1>集合讀(get)： 不能確定從集合裡讀出的是哪個類型（可能是T也可能是T的父類，或者Object），所以沒有辦法使用get。例如：List&lt;? super Integer> foo3 = new ArrayList&lt;Integer/Number/Object>(); 只能保證get出來是Object。</li></ul><ol><li>下面是示例，test1和test2在編譯時都有錯誤提示。</li></ol><pre>package com.robert.javaspec;import java.util.LinkedList;import java.util.List;/** * Created by WangMeng on 2017-04-13. * FIX ME */public class Main { public static void main(String[] args) { } public void test1(){ List&lt;? extends A&gt; childofa=new LinkedList&lt;&gt;(); B b=new B(); A a=new A(); childofa.add(a); childofa.add(b); A ta= childofa.get(0); } public void test2(){ List&lt;? super B&gt; superOfb = new LinkedList&lt;&gt;(); B b = new B(); A a = new A(); superOfb.add(a); superOfb.add(b); A ta = superOfb.get(0); B tb = superOfb.get(0); }}class A { @Override public String toString() { return "A"; }}class B extends A { @Override public String toString() { return "B"; }}</pre><ol><li>【強制】不要在 foreach 循環裡進行元素的 remove/add 操作。remove 元素請使用 Iterator 方式，如果併發操作，需要對 Iterator 對象加鎖。</li><li>反例:</li></ol><pre>List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("1");a.add("2");for (String temp : a) { if ("1".equals(temp)) {  a.remove(temp); } }</pre><ol><li>說明: 以上代碼的執行結果肯定會出乎大家的意料，那麼試一下把“1”換成“2”，會是同樣的</li><li>結果嗎?</li><li>正例:</li></ol><pre>Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) { String temp = it.next();  if (刪除元素的條件) { it.remove(); }}</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>修改一定要使用Iterator。</li><li class=ql-indent-1>反例中改成2，拋出ConcurrentModificationException，因為2是數組的結束邊界。</li></ul><ol><li>【強制】 在 JDK7 版本及以上，Comparator 要滿足如下三個條件，不然 Arrays.sort， Collections.sort 會報 IllegalArgumentException 異常。</li><li>說明:</li><li>1) x，y的比較結果和y，x的比較結果相反。</li><li>2) x>y，y>z，則x>z。</li><li>3) x=y，則x，z比較結果和y，z比較結果相同。</li><li>反例: 下例中沒有處理相等的情況，實際使用中可能會出現異常:</li></ol><pre>new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { return o1.getId() &gt; o2.getId() ? 1 : -1;  }}</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>除非邏輯混亂，否則這些條件都能滿足。</li></ul><ol><li>【推薦】集合初始化時，儘量指定集合初始值大小。</li><li>說明: ArrayList儘量使用ArrayList(int initialCapacity) 初始化。</li><li><strong>白話：</strong></li></ol><ul><li>預估數組大小，能夠提高程序效率，寫代碼的時候腦袋裡面要有運行的思想。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>想了解性能和容量評估，請參考互聯網性能與容量評估的方法論和典型案例。</li></ul><ol><li>【推薦】使用 entrySet 遍歷 Map 類集合 KV，而不是 keySet 方式進行遍歷。</li><li>說明: keySet 其實是遍歷了 2 次，一次是轉為 Iterator 對象，另一次是從 hashMap 中取出 key 所對應的 value。而 entrySet 只是遍歷了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。</li><li>正例: values()返回的是 V 值集合，是一個 list 集合對象;keySet()返回的是 K 值集合，是一個 Set 集合對象; entrySet()返回的是 K-V 值組合集合。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>寫代碼其實就是在程序員腦袋裡執行代碼的過程，直覺就是兩次肯定不如一次做完事更快。</li></ul><ol><li>【推薦】高度注意 Map 類集合 K/V 能不能存儲 null 值的情況，如下表格:</li><li class=ql-align-center><br></li></ol><div class=pgc-img><img alt=阿里巴巴Java開發手冊（編程規約） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/93e7eb2a96b045b184a8811a9304fd80><p class=pgc-img-caption></p></div><ol><li class=ql-align-center><br></li><li class=ql-align-center>集合對照表</li><li>反例: 由於 HashMap 的干擾，很多人認為 ConcurrentHashMap 是可以置入 null 值，注意存儲 null 值時會拋出 NPE 異常。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>存儲null值場景不多，在防止緩存穿透的情況下，有的時候會緩存null key</li></ul><ol><li>【參考】合理利用好集合的有序性(sort)和穩定性(order)，避免集合的無序性(unsort)和 不穩定性(unorder)帶來的負面影響。</li><li>說明: 有序性是指遍歷的結果是按某種比較規則依次排列的。穩定性指集合每次遍歷的元素次 序是一定的。如:ArrayList 是 order/unsort;HashMap 是 unorder/unsort;TreeSet 是 order/sort。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>大體上同意，但是對於HashMap理論上是無序的沒有問題，我做了個試驗，每次輸出都是穩定的。</li></ul><ol><li>數值：</li></ol><pre>HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(3, 3);map.put(1, 1);map.put(2, 2);map.put(4, 4);for (Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { System.out.println(entry.getKey());}</pre><ol><li>事實證明，每次輸出也是1、2、3、4，有序並且穩定的。</li><li>字符串值：</li></ol><pre>HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("3000", "3");map.put("1000", "1");map.put("2000", "2");map.put("4000", "4");for (Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { System.out.println(entry.getKey());}</pre><ol><li>事實證明，每次輸出也是4000、1000、2000、3000，無序但是穩定的。</li><li>與阿里專家諮詢，這裡HashMap不穩定性是指rehash後輸出順序則會變化。</li><li>【參考】利用 Set 元素唯一的特性，可以快速對一個集合進行去重操作，避免使用 List 的 contains 方法進行遍歷、對比、去重操作。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>如果不需要精確去重，參考布隆過濾器（Bloom Filter）。</li></ul><p><strong>6 併發處理</strong></p><ol><li>【強制】獲取單例對象需要保證線程安全，其中的方法也要保證線程安全。</li><li>說明: 資源驅動類、工具類、單例工廠類都需要注意。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>如果延遲加載實現的單例需要併發控制；如果初始化的時候new單例對象，本身是線程安全的，取得實例方法不需要同步。</li></ul><ol><li>【強制】創建線程或線程池時請指定有意義的線程名稱，方便出錯時回溯。</li><li>正例:</li></ol><pre>public class TimerTaskThread extends Thread {  public TimerTaskThread() { super.setName("TimerTaskThread");  ...  }}</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>寫代碼的時候就要想到查bug的時候要用到什麼信息，然後決定如何命名、打印日誌等。</li></ul><ol><li>【強制】線程資源必須通過線程池提供，不允許在應用中自行顯式創建線程。</li><li>說明: 使用線程池的好處是減少在創建和銷燬線程上所花的時間以及系統資源的開銷，解決資 源不足的問題。如果不使用線程池，有可能造成系統創建大量同類線程而導致消耗完內存或者 “過度切換”的問題。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>一個是使用線程池緩存線程可以提高效率，另外線程池幫我們做了管理線程的事情，提供了優雅關機、interrupt等待IO的線程，飽和策略等功能。</li></ul><ol><li>【強制】線程池不允許使用 Executors 去創建，而是通過 ThreadPoolExecutor 的方式，這樣的處理方式讓寫的同學更加明確線程池的運行規則，規避資源耗盡的風險。</li><li>說明: Executors 返回的線程池對象的弊端如下:</li><li>1)FixedThreadPool 和 SingleThreadPool: 允許的請求隊列長度為 Integer.MAX_VALUE，可能會堆積大量的請求，從而導致 OOM。</li><li>2)CachedThreadPool 和 ScheduledThreadPool: 允許的創建線程數量為 Integer.MAX_VALUE，可能會創建大量的線程，從而導致 OOM。</li><li><strong>白話：</strong></li></ol><ul><li>線程池如果沒有限制最大數量，線程池撐開的時候，由於內存不夠或者系統配置的最大線程數超出，都會產生oom: unalbe to create native thread。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>一個組件的核心參數最好要顯式的傳入，不要默認，就像你交給屬下一個任務，任務的目標、原則、時間點、邊界都要明確，不能模糊處理一樣，免得扯皮。</li></ul><ol><li>【強制】SimpleDateFormat 是線程不安全的類，一般不要定義為static變量，如果定義為</li><li>static，必須加鎖，或者使用 DateUtils 工具類。</li><li>正例: 注意線程安全，使用 DateUtils。亦推薦如下處理:</li><li>private static final ThreadLocal&lt;DateFormat> df = new ThreadLocal&lt;DateFormat>() {</li><li>@Override</li><li>protected DateFormat initialValue() {</li><li>return new SimpleDateFormat("yyyy-MM-dd");</li><li>}</li><li>};</li><li>說明: 如果是 JDK8 的應用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar， DateTimeFormatter 代替 Simpledateformatter，官方給出的解釋: simple beautiful strong immutable thread-safe。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>記住，打死你，我也不會把SimpleDateFormat共享到類中。</li></ul><ol><li>【強制】高併發時，同步調用應該去考量鎖的性能損耗。能用無鎖數據結構，就不要用鎖; 能鎖區塊，就不要鎖整個方法體; 能用對象鎖，就不要用類鎖。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>優先無鎖，不用鎖能解決的一定不要用鎖，即使用鎖也要控制粒度，越細越好。</li></ul><ol><li>【強制】對多個資源、數據庫表、對象同時加鎖時，需要保持一致的加鎖順序，否則可能會造 成死鎖。</li><li>說明: 線程一需要對錶 A、B、C 依次全部加鎖後才可以進行更新操作，那麼線程二的加鎖順序也必須是 A、B、C，否則可能出現死鎖。</li><li><strong>白話：</strong></li></ol><ul><li>解決死鎖的方法：按順序鎖資源、超時、優先級、死鎖檢測等。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>可參考哲學家進餐問題學習更深入的併發機制。</li></ul><ol><li>【強制】併發修改同一記錄時，避免更新丟失，需要加鎖。要麼在應用層加鎖，要麼在緩存加 鎖，要麼在數據庫層使用樂觀鎖，使用 version 作為更新依據。</li><li>說明: 如果每次訪問衝突概率小於 20%，推薦使用樂觀鎖，否則使用悲觀鎖。樂觀鎖的重試次 數不得小於 3 次。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>狀態流轉、維護可用餘額等最好直接利用數據庫的行級鎖，不需要顯式的加鎖。</li></ul><ol><li>【強制】多線程並行處理定時任務時，Timer 運行多個 TimerTask 時，只要其中之一沒有捕獲拋出的異常，其它任務便會自動終止運行，使用 ScheduledExecutorService 則沒有這個問題。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>線程執行體、任務最上層等一定要抓住Throwable並進行相應的處理，否則會使線程終止。</li></ul><ol><li>【推薦】使用 CountDownLatch 進行異步轉同步操作，每個線程退出前必須調用 countDown 方法，線程執行代碼注意 catch 異常，確保 countDown 方法可以執行，避免主線程無法執行至 await 方法，直到超時才返回結果。</li><li>說明: 注意，子線程拋出異常堆棧，不能在主線程 try-catch 到。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>請在try...finally語句裡執行countDown方法，與關閉資源類似。</li></ul><ol><li>【推薦】避免 Random 實例被多線程使用，雖然共享該實例是線程安全的，但會因競爭同一 seed 導致的性能下降。</li><li>說明: Random 實例包括 java.util.Random 的實例或者 Math.random()實例。</li><li>正例: 在 JDK7 之後，可以直接使用 API ThreadLocalRandom，在 JDK7 之前，可以做到每個線程一個實例。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>可以把Random放在ThreadLocal裡，只在本線程中使用。</li></ul><ol><li>【推薦】在併發場景下，通過雙重檢查鎖(double-checked locking)實現延遲初始化的優 化問題隱患(可參考 The "Double-Checked Locking is Broken" Declaration)，推薦問 題解決方案中較為簡單一種(適用於 JDK5 及以上版本)，將目標屬性聲明為 volatile 型。</li><li>反例:</li></ol><pre>class Foo { private Helper helper = null;  public Helper getHelper() { if (helper == null)  synchronized(this) {  if (helper == null) helper = new Helper(); } return helper;  } // other functions and members...}</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>網上對雙檢鎖有N多討論，這裡很負責任的告訴大家，只要不是特別老的JDK版本(1.4以下)，雙檢鎖是沒問題的。</li></ul><ol><li>【參考】volatile 解決多線程內存不可見問題。對於一寫多讀，是可以解決變量同步問題， 但是如果多寫，同樣無法解決線程安全問題。如果是 count++操作，使用如下類實現: AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推薦使用 LongAdder 對象，比 AtomicLong 性能更好(減少樂觀鎖的重試次數)。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>volatile只有內存可見性語義，synchronized有互斥語義，一寫多讀使用volatile就可以，多寫就必須使用synchronized，fetch-mod-get也必須使用synchronized。</li></ul><ol><li>【參考】 HashMap 在容量不夠進行 resize 時由於高併發可能出現死鏈，導致 CPU 飆升，在開發過程中注意規避此風險。</li><li><strong>白話：</strong></li></ol><ul><li>開發程序的時候要預估使用量，根據使用量來設置初始值。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>resize需要重建hash表，嚴重影響性能，會讓程序產生長尾的響應時間。</li></ul><ol><li>【參考】ThreadLocal 無法解決共享對象的更新問題，ThreadLocal 對象建議使用 static 修飾。這個變量是針對一個線程內所有操作共有的，所以設置為靜態變量，所有此類實例共享此靜態變量 ，也就是說在類第一次被使用時裝載，只分配一塊存儲空間，所有此類的對象(只 要是這個線程內定義的)都可以操控這個變量。</li><li><strong>白話：</strong></li></ol><ul><li>ThreadLocal實際上是一個從線程ID到變量的Map，每次取得ThreadLocal變量，實際上是先取得當前線程ID，再用當前線程ID取得關聯的變量。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>ThreadLocal使用了WeakHashMap，在key被回收的時候，value也被回收了，不用擔心內存洩露。</li></ul><p><strong>7 控制語句</strong></p><ol><li>【強制】在一個 switch 塊內，每個 case 要麼通過 break/return 等來終止，要麼註釋說明程序將繼續執行到哪一個 case 為止;在一個 switch 塊內，都必須包含一個 default 語句並且放在最後，即使它什麼代碼也沒有。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>最好每個case都用break結束，不要組合幾個分支到一個邏輯，太不直觀。</li></ul><ol><li>【強制】在 if/else/for/while/do 語句中必須使用大括號，即使只有一行代碼，避免使用 下面的形式:if (condition) statements;</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這條有歧義，個人認為有的時候就一行語句不加也可以。</li></ul><ol><li>【推薦】推薦儘量少用 else， if-else 的方式可以改寫成:</li></ol><pre>if (condition) { ... return obj; }// 接著寫 else 的業務邏輯代碼;</pre><ol><li>說明: 如果非得使用if()...else if()...else...方式表達邏輯，【強制】請勿超過3層， 超過請使用狀態設計模式。</li><li>正例: 邏輯上超過 3 層的 if-else 代碼可以使用衛語句，或者狀態模式來實現。</li><li><strong>白話：</strong></li></ol><ul><li>朋友說超過三層考慮狀態設計模式也不完全正確，大概可以理解為多層的邏輯嵌套不是好的代碼風格，需要使用對應的重構方法做出優化，而每種壞味都有對應的優化方法和步驟，以及優缺點限制條件。</li><li class=ql-indent-1><br></li><li class=ql-indent-1>寫程序一定要遵守紅花綠葉原則，主邏輯放在主方法中，這是紅花，子邏輯封裝成小方法調用，這是綠葉，不要把不同層次的邏輯寫在一個大方法體裡，很難理解，就像綠葉把紅花擋住了，誰還能看到。舉例說明：</li></ul><pre>public void handleProcess() { // 骨架邏輯 validate(); doProcess(); declareResource();}</pre><ul><li class=ql-indent-1>普及一下，如下類似排比句的代碼就是衛語句，以前每天都這麼寫但是還真是剛剛知道這叫衛語句:)</li></ul><pre>public double getPayAmount() {  if (isDead()) return deadPayAmount();  if (isSeparated()) return separatedPayAmount();  if (isRetired()) return retiredPayAmount();  return normalPayAmount();  }</pre><ol><li>不提倡的寫法：</li></ol><pre>public double getPayAmount() {  if (isDead())  return deadPayAmount();  else if (isSeparated())  return separatedPayAmount();  else if (isRetired()) return retiredPayAmount();  else  return normalPayAmount(); }</pre><ol><li>【推薦】除常用方法(如 getXxx/isXxx)等外，不要在條件判斷中執行其它複雜的語句，將復 雜邏輯判斷的結果賦值給一個有意義的布爾變量名，以提高可讀性。</li><li>說明: 很多 if 語句內的邏輯相當複雜，閱讀者需要分析條件表達式的最終結果，才能明確什麼 樣的條件執行什麼樣的語句，那麼，如果閱讀者分析邏輯表達式錯誤呢?</li><li>正例:</li></ol><pre>//偽代碼如下boolean existed = (file.open(fileName, "w") != null) &amp;&amp; (...) || (...); if (existed) { ... }</pre><ol><li>反例:</li></ol><pre>if ((file.open(fileName, "w") != null) &amp;&amp; (...) || (...)) { ...}</pre><ol><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這個反例真的經常見到，寫這個代碼的人自己不覺得這樣很難看嗎？</li></ul><ol><li>【推薦】循環體中的語句要考量性能，以下操作儘量移至循環體外處理，如定義對象、變量、</li><li>獲取數據庫連接，進行不必要的 try-catch 操作(這個 try-catch 是否可以移至循環體外)。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>切記，循環體內儘量不要獲取資源、不要處理異常。</li></ul><ol><li>【推薦】接口入參保護，這種場景常見的是用於做批量操作的接口。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>用白話說，就是控制批量參數的數量，一次不能太多，否則內存溢出。</li></ul><ol><li>【參考】方法中需要進行參數校驗的場景:</li><li class=ql-indent-1>調用頻次低的方法。</li><li>執行時間開銷很大的方法，參數校驗時間幾乎可以忽略不計，但如果因為參數錯誤導致</li><li class=ql-indent-1>中間執行回退，或者錯誤，那得不償失。</li><li class=ql-indent-1>需要極高穩定性和可用性的方法。</li><li class=ql-indent-1>對外提供的開放接口，不管是RPC/API/HTTP接口。</li><li class=ql-indent-1>敏感權限入口。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>在這個框框內，根據業務適當調整是可以的。</li></ul><ol><li>【參考】方法中不需要參數校驗的場景:</li><li>極有可能被循環調用的方法，不建議對參數進行校驗。但在方法說明裡必須註明外部參</li><li class=ql-indent-1>數檢查要求。</li><li>底層的方法調用頻度都比較高，一般不校驗。畢竟是像純淨水過濾的最後一道，參數錯</li><li class=ql-indent-1>誤不太可能到底層才會暴露問題。一般 DAO 層與 Service 層都在同一個應用中，部署在同一 臺服務器中，所以 DAO 的參數校驗，可以省略。</li><li class=ql-indent-1>被聲明成private只會被自己代碼所調用的方法，如果能夠確定調用方法的代碼傳入參數已經做過檢查或者肯定不會有問題，此時可以不校驗參數。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>在這個框框呢，根據業務適當調整是可以的。</li></ul><p><strong>8 註釋規約</strong></p><ol><li>【強制】類、類屬性、類方法的註釋必須使用 Javadoc 規範，使用/*<em>內容</em>/格式，不得使用 //xxx 方式。</li><li>說明:在 IDE 編輯窗口中，Javadoc 方式會提示相關注釋，生成 Javadoc 可以正確輸出相應注 釋; 在 IDE 中，工程調用方法時，不進入方法即可懸浮提示方法、參數、返回值的意義，提高閱讀效率。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>開發環境編輯器可保證這一條。</li></ul><ol><li>【強制】所有的抽象方法(包括接口中的方法)必須要用 Javadoc 註釋、除了返回值、參數、 異常說明外，還必須指出該方法做什麼事情，實現什麼功能。</li><li>說明: 對子類的實現要求，或者調用注意事項，請一併說明。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>文檔還要涵蓋校驗，線程安全等，重要方法要給出調用示例。</li></ul><ol><li>【強制】所有的類都必須添加創建者信息。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>做好事要留名，要不誰知道是你乾的，方法可參考雷鋒，雷鋒每次做好事不留名，每次時間地點都被記下來了。</li></ul><ol><li>【強制】方法內部單行註釋，在被註釋語句上方另起一行，使用//註釋。方法內部多行註釋</li><li>使用/* */註釋，注意與代碼對齊。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>關鍵的地方做註釋，也不要太多，代碼最好是自文檔化，看代碼就能讓人理解，這是境界。</li></ul><ol><li>【強制】所有的枚舉類型字段必須要有註釋，說明每個數據項的用途。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>枚舉是個非常重要的類型，業務代碼中大量存在，註釋是必須的。</li></ul><ol><li>【推薦】與其“半吊子”英文來註釋，不如用中文註釋把問題說清楚。專有名詞與關鍵字保持英文原文即可。</li><li>反例:“TCP 連接超時”解釋成“傳輸控制協議連接超時”，理解反而費腦筋。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>還是那句話，脫了褲子放屁還是累，又沒人感激你翻譯了。</li></ul><ol><li>【推薦】代碼修改的同時，註釋也要進行相應的修改，尤其是參數、返回值、異常、核心邏輯 等的修改。</li><li>說明: 代碼與註釋更新不同步，就像路網與導航軟件更新不同步一樣，如果導航軟件嚴重滯後， 就失去了導航的意義。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>很多線上發生的應急事故都是技術債積累到一定程度，量變導致質變，才發生了重大的災難型事件。因此，代碼要與時俱進，代碼改變，註釋要改變，文檔要改變，要周知相關方。問題是很難實現，因為這是反人性的，做了這個事情對個人沒有什麼利益，有些人就不做，只有對代碼有潔癖的人才會這麼做。</li></ul><ol><li>【參考】註釋掉的代碼儘量要配合說明，而不是簡單的註釋掉。</li><li>說明: 代碼被註釋掉有兩種可能性:1)後續會恢復此段代碼邏輯。2)永久不用。前者如果沒 有備註信息，難以知曉註釋動機。後者建議直接刪掉(代碼倉庫保存了歷史代碼)。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>儘量不要留下注釋掉的代碼，曾經發生合併代碼的時候不小心把註釋的代碼打開了，於是，悲劇了，源代碼管理工具，例如：git、svn都有歷史記錄可查詢的，沒必要註釋代碼並留在源碼中。</li></ul><ol><li>【參考】對於註釋的要求: 第一、能夠準確反應設計思想和代碼邏輯;第二、能夠描述業務含義，使別的程序員能夠迅速瞭解到代碼背後的信息。完全沒有註釋的大段代碼對於閱讀者形同天書，註釋是給自己看的，即使隔很長時間，也能清晰理解當時的思路;註釋也是給繼任者看的，使其能夠快速接替自己的工作。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>還是那句話，這個是反人性的，註釋好了又有什麼用，可以讓更多的人掌握我的代碼嗎？職場上似乎不是一個好事 :)，不過專業的程序員更願意碼好每一段代碼是毋庸置疑的。</li></ul><ol><li>【參考】好的命名、代碼結構是自解釋的，註釋力求精簡準確、表達到位。避免出現註釋的</li><li>一個極端: 過多過濫的註釋，代碼的邏輯一旦修改，修改註釋是相當大的負擔。</li><li>反例:</li></ol><pre> // put elephant into fridge put(elephant, fridge);</pre><ol><li>方法名put，加上兩個有意義的變量名 elephant 和 fridge，已經說明了這是在幹什麼，語</li><li>義清晰的代碼不需要額外的註釋。</li></ol><p><strong>白話：</strong></p><ul><li>寫註釋的最高境界是不用註釋，代碼一目瞭然，看了就懂。</li></ul><ol><li>【參考】特殊註釋標記，請註明標記人與標記時間。注意及時處理這些標記，通過標記掃描， 經常清理此類標記。線上故障有時候就是來源於這些標記處的代碼。</li><li>待辦事宜(TODO):( 標記人，標記時間，[預計處理時間]) 表示需要實現，但目前還未實現的功能。這實際上是一個 Javadoc 的標籤，目前的 Javadoc</li><li class=ql-indent-1>還沒有實現，但已經被廣泛使用。只能應用於類，接口和方法(因為它是一個 Javadoc 標籤)。</li><li>錯誤，不能工作(FIXME):(標記人，標記時間，[預計處理時間])</li><li class=ql-indent-1>在註釋中用 FIXME 標記某代碼是錯誤的，而且不能工作，需要及時糾正的情況。</li></ol><p><strong>白話：</strong></p><ul><li>我很負責人的說，經常使用TODO和FIXME的程序員都是好程序員。</li></ul><p><strong>9 其他</strong></p><ol><li>【強制】在使用正則表達式時，利用好其預編譯功能，可以有效加快正則匹配速度。</li><li>說明: 不要在方法體內定義:Pattern pattern = Pattern.compile(規則);</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>Pattern和Random都是線程安全的，而MessageDigest, SimpleDateFormat不是線程安全的。</li></ul><ol><li>【強制】velocity 調用 POJO 類的屬性時，建議直接使用屬性名取值即可，模板引擎會自動按規範調用 POJO 的 getXxx()，如果是 boolean 基本數據類型變量(boolean 命名不需要加 is 前綴)，會自動調用 isXxx()方法。</li><li>說明: 注意如果是 Boolean 包裝類對象，優先調用 getXxx()的方法。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>屬性前不要加is，這類變量最好用形容詞表達。</li></ul><ol><li>【強制】後臺輸送給頁面的變量必須加$!{var}——中間的感嘆號。 說明:如果 var=null 或者不存在，那麼${var}會直接顯示在頁面上。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>這裡說的是velocity，${var}在var為null的時候，直接把代碼${var}打印在界面上，太不專業，也有安全問題，必須使用${var}代替。</li></ul><ol><li>【強制】注意 Math.random() 這個方法返回是 double 類型，注意取值的範圍 0≤x&lt;1(能夠取到零值，注意除零異常)，如果想獲取整數類型的隨機數，不要將 x 放大 10 的若干倍然後 取整，直接使用 Random 對象的 nextInt 或者 nextLong 方法。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>毋庸置疑，用專業的工具幹專業的事兒。</li></ul><ol><li>【強制】獲取當前毫秒數 System.currentTimeMillis(); 而不是 new Date().getTime();</li><li>說明: 如果想獲取更加精確的納秒級時間值，用 System.nanoTime()。在 JDK8 中，針對統計時間等場景，推薦使用 Instant 類。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>Date內部也是使用System.currentTimeMillis實現的，使用Date還得多構造一個對象，在量級很大的時候會有一些性能損耗。</li></ul><ol><li>【推薦】儘量不要在 velocity 模板中加入變量聲明、邏輯運算符，更不要在模板中加入任何複雜的邏輯。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>MVC！視圖的職責是展示，不要搶人家模型和控制器的活！</li></ul><ol><li>【推薦】任何數據結構的構造或初始化，都應指定大小，避免數據結構無限增長吃光內存。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>尤其是集合、批量參數、數據庫表都要有最大數量的限制，否則就為OOM埋下隱患。</li></ul><ol><li>【推薦】對於“明確停止使用的代碼和配置”，如方法、變量、類、配置文件、動態配置屬性</li><li>等要堅決從程序中清理出去，避免造成過多垃圾。</li><li><strong>白話：</strong></li></ol><ul><li class=ql-indent-1>要保持衛生，屋子太亂了也影響生活的情趣，代碼也要定期捯飭一下。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>開發</a></li><li><a>手冊</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b9ea38.html alt=阿里Java開發手冊學習筆記第一篇——編程規約 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533128627726638b80ffce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b9ea38.html title=阿里Java開發手冊學習筆記第一篇——編程規約>阿里Java開發手冊學習筆記第一篇——編程規約</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1372a13.html alt="阿里巴巴 Java 開發手冊之MySQL 規約" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/81da5f8f3c294941a3c532e4763b7d80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1372a13.html title="阿里巴巴 Java 開發手冊之MySQL 規約">阿里巴巴 Java 開發手冊之MySQL 規約</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/71dee9de.html alt=Java程序員高效開發必備的五個IDE神器，重點是還免費！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8b3de7f6f0f94aff934f597f3a99914f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/71dee9de.html title=Java程序員高效開發必備的五個IDE神器，重點是還免費！>Java程序員高效開發必備的五個IDE神器，重點是還免費！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d45f797.html alt="阿里 Java 手冊系列教程：為啥強制子類、父類變量名不同？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/143cf36cabd7406e8b58921a37b6db72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d45f797.html title="阿里 Java 手冊系列教程：為啥強制子類、父類變量名不同？">阿里 Java 手冊系列教程：為啥強制子類、父類變量名不同？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0177512.html alt=《阿里巴巴JAVA開發手冊》發佈詳盡版，新增16條設計規約 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1528263437076b2e032783a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0177512.html title=《阿里巴巴JAVA開發手冊》發佈詳盡版，新增16條設計規約>《阿里巴巴JAVA開發手冊》發佈詳盡版，新增16條設計規約</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ec70a97.html alt=美女程序員揭祕《阿里巴巴Android開發手冊》｜提供更新下載 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1521777113028bab406734a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ec70a97.html title=美女程序員揭祕《阿里巴巴Android開發手冊》｜提供更新下載>美女程序員揭祕《阿里巴巴Android開發手冊》｜提供更新下載</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e009900.html alt=阿里巴巴Java開發規約插件P3C，擼代碼飛起！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/40100000c14f73516642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e009900.html title=阿里巴巴Java開發規約插件P3C，擼代碼飛起！>阿里巴巴Java開發規約插件P3C，擼代碼飛起！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f022a54.html alt=Java開發必殺技能之PageHelper分頁組件使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/28eb14bae7a34990b00b01a9400ca98a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f022a54.html title=Java開發必殺技能之PageHelper分頁組件使用>Java開發必殺技能之PageHelper分頁組件使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/188bbb3.html alt="輕鬆理解 Java開發中的依賴注入(DI)和控制反轉(IOC)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/9b2ad1bd-0065-4a9e-90d8-ebbe6c06d152 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/188bbb3.html title="輕鬆理解 Java開發中的依賴注入(DI)和控制反轉(IOC)">輕鬆理解 Java開發中的依賴注入(DI)和控制反轉(IOC)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e5c612.html alt="【乾貨】Java 程序員開發常用的工具（二）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/89b851a90b9749b8b3669bbf874a8c33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e5c612.html title="【乾貨】Java 程序員開發常用的工具（二）">【乾貨】Java 程序員開發常用的工具（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a980c6f3.html alt=教你從頭學前端開發——第一個網頁（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c44113d83f24f5db93c8353aff0c670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a980c6f3.html title=教你從頭學前端開發——第一個網頁（一）>教你從頭學前端開發——第一個網頁（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1f5a66a.html alt=網頁開發網頁的相關概念你知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8ca7902bdcb14bc5a25a88be4953edd6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1f5a66a.html title=網頁開發網頁的相關概念你知道嗎？>網頁開發網頁的相關概念你知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html alt="軟件開發中數據庫必備基礎01 - 圖解事務基礎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4e00ac778db451792b955bde23add02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html title="軟件開發中數據庫必備基礎01 - 圖解事務基礎">軟件開發中數據庫必備基礎01 - 圖解事務基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>