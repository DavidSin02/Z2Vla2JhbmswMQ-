<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>瞭解volatile、內存與happens-before規則 | 极客快訊</title><meta property="og:title" content="瞭解volatile、內存與happens-before規則 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/ba24b5e9a1534078be74121e479c1db5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bde39813.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bde39813.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bde39813.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bde39813.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bde39813.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bde39813.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bde39813.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bde39813.html><meta property="article:published_time" content="2020-11-14T21:00:35+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:35+08:00"><meta name=Keywords content><meta name=description content="瞭解volatile、內存與happens-before規則"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/bde39813.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>瞭解volatile、內存與happens-before規則</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>大家都知道，在阿里巴巴泰山版開發手冊中有這一段，在併發情況下使用延遲初始化的方法實現單例模式時，需要將目標屬性聲明為volatile。</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ba24b5e9a1534078be74121e479c1db5><p class=pgc-img-caption></p></div><p><br></p><p>volatile關鍵字在 Java 中的作用是<strong>保證變量的可見性</strong>和<strong>防止指令重排</strong>。</p><h1 class=pgc-h-arrow-right>一、保證變量的可見性</h1><p>在知道volatile是如何保證變量的可見性之前，我們先要知道內存不可見的兩個原因：</p><p>1、CPU的運行速度是遠遠高於內存的讀寫速度的，為了不讓CPU等待讀寫內存數據，現代CPU和內存之間都存在一個高速緩存cache（實際上是一個多級寄存器），如下圖：</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a28ee95e3fbb4d9697e05f25eeb5606f><p class=pgc-img-caption></p></div><p>線程在運行的過程中會把主內存的數據拷貝一份到線程內部cache中，其實就是訪問自己的內部cache。如果線程B把數據加載進內部緩存cache中，線程A再修改了數據。即使重新寫入主內存，但是線程B不會重新從主內存加載變量，看到的還是自己cache中的變量，所以線程B是讀取不到線程A更新後的值。</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f0adb1a490d34c26a6ea932aa43cb961><p class=pgc-img-caption></p></div><p>在多處理器下，為了保證各個處理器的緩存是一致的，就會實現<strong>緩存一致性協議</strong>，每個處理器通過<strong>嗅探在總線上傳播的數據來檢查自己緩存的值是不是過期了</strong>，<strong>當處理器發現自己緩存行對應的內存地址被修改，就會將當前處理器的緩存行設置成無效狀態，當處理器對這個數據進行修改操作的時候，會重新從系統內存中把數據讀到處理器緩存裡</strong>。volatile變量通過這樣的機制就使得每個線程都能獲得該變量的最新值。 但是，我們也都知道volatile只能保證可見性，不能保證原子性。多個線程同時讀取這個共享變量的值，就算保證其他線程修改的可見性，也不能保證線程之間讀取到同樣的值然後相互覆蓋對方的值的情況。</p><h1 class=pgc-h-arrow-right>二、防止指令重排</h1><p>我們再來看指令重排。</p><h1 class=pgc-h-arrow-right>1、定義</h1><p>指令重排是指在程序執行過程中, <strong>為了性能考慮, 編譯器和CPU可能會對指令重新排序</strong>。</p><p>介紹指令重排之前，首先介紹一下內存交互操作的8種指令吧。虛擬機實現必須保證每一個操作都是原子的，不可再分的（對於double和long類型的變量來說，load、store、read和write操作在某些平臺上允許例外）</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a7b7dd0bf554270b77adba6ff8b5e04><p class=pgc-img-caption></p></div><p>如圖所示：</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ea67adf356cb4a22bbc148c8df9f2f47><p class=pgc-img-caption></p></div><p><br></p><p>既然操作可以被分解為很多步驟, 那麼多條操作指令就不一定依次序執行，因為每次只執行一條指令, 依次執行效率太低了。就像小時候學習的煮飯燒水任務時間分配一樣，內存也會很聰明的分配時間。</p><p>本來想給大家整一個指令重排序的例子的，但是不管是我自己寫還是用別人的代碼，我的電腦都沒辦法讓它重排序。但是我們都知道，指令重排是確實存在的（CPU確實會進行重排序，但是這種重排序是無法被我們觀測到和控制的）。</p><p>一般重排序可以分為如下三種：</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d98bdfcd0b1f489c9ae1630c5496b5a5><p class=pgc-img-caption></p></div><p><br></p><ul><li>1、<strong>編譯器優化的重排序</strong>。編譯器在不改變單線程程序語義的前提下，可以重新安排語句的執行順序；</li><li>2、<strong>指令級並行的重排序</strong>。現代處理器採用了指令級並行技術來將多條指令重疊執行。如果不存在數據依賴性，處理器可以改變語句對應機器指令的執行順序；</li><li>3、<strong>內存系統的重排序</strong>。由於處理器使用緩存和讀/寫緩衝區，這使得加載和存儲操作看上去可能是在亂序執行的。</li></ul><h1 class=pgc-h-arrow-right>2、原理</h1><p>我們來看加了volatile前後的代碼,用的就是阿里規約提供給我們的雙重檢查鎖的代碼。我們分別編譯了兩次，第一個是沒有使用volatile關鍵字修飾的，第二個是使用volatile關鍵字來修飾，然後取出他們的的彙編代碼（實在是設計的地方太底層，其實這裡算是用到了策略模式了）</p><blockquote><p>未使用volatile修飾</p></blockquote><pre><code>  0x000000010d29e93b: mov    %rax,%r10  0x000000010d29e93e: shr    $0x3,%r10  0x000000010d29e942: mov    %r10d,0x68(%rsi)  0x000000010d29e946: shr    $0x9,%rsi  0x000000010d29e94a: movabs $0xfe403000,%rax  0x000000010d29e954: movb   $0x0,(%rsi,%rax,1)                                                 複製代碼</code></pre><blockquote><p>使用volatile修飾</p></blockquote><pre><code>  0x0000000114353959: mov    %rax,%r10  0x000000011435395c: shr    $0x3,%r10  0x0000000114353960: mov    %r10d,0x68(%rsi)  0x0000000114353964: shr    $0x9,%rsi  0x0000000114353968: movabs $0x10db6e000,%rax  0x0000000114353972: movb   $0x0,(%rsi,%rax,1)  0x0000000114353976: lock addl $0x0,(%rsp)    複製代碼</code></pre><p>很明顯，在movb操作後，加了volatile修飾的彙編代碼後面多了一條彙編指令<strong>lock addl $0x0,(%rsp)</strong>，這個操作相當於一個<strong>內存屏障</strong>，指令重排時不能把後面的指令重排序到內存屏障之前的位置。<strong>lock前綴會強制執行原子操作，它的作用是是的本CPU的cache寫入了內存，該寫入動作會引起別的CPU無效化其cache。所以通過這樣一個空操作，可讓前面volatile變量的便是對其他CPU可見</strong>。</p><p>從硬件架構上講，指令重排序是指CPU將多條指令不按程序規定的順序分開發送給各相應的點，但並不是指令任意重排，CPU需要能正確處理指令，以保障程序能得出正確的執行結果。lock addl $0x0,(%rsp) 指令把修改同步到內存時，意味著所有值錢的操作都已經執行完成，這樣便形成了<strong>指令重排序無法越過內存屏障</strong>的效果。</p><h1 class=pgc-h-arrow-right>三、內存屏障</h1><p>既然指令重排和可見性都依賴了lock，同時lock指令引出了內存屏障，我們就來學習一下什麼是內存屏障。</p><h1 class=pgc-h-arrow-right>1、定義</h1><blockquote><p>內存屏障：保證屏障前的讀寫指令必須在屏障後的讀寫指令之前執行，通知被Volatile修飾的值，每次讀取都從主存中讀取，每次寫入都同步寫入主存。</p></blockquote><p>內存屏障具體又分為寫屏障和讀屏障 寫屏障（Store Memory Barrier）：<strong>強制將緩存中的內容寫入到緩存中</strong>或者<strong>將該指令之後的寫操作寫入緩存直到之前的內容被刷入到緩存中</strong>，也被稱之為<strong>smp_wmb</strong> 讀屏障（Load Memory Barrier）：<strong>強制將無效隊列（volatile寫操作之後使其作廢）中的內容處理完畢</strong>，也被稱之為<strong>smp_rmb</strong></p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/61599758fe6e4d5685b4279e7a2be5be><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2、原理</h1><p><strong>內存屏障在Java中的體現</strong>：</p><ul><li>1、volatile讀之後，所有變量讀寫操作都不會重排序到其前面。</li><li>2、volatile讀之前，所有volatile讀寫操作都已完成。</li><li>3、volatile寫之後，volatile變量讀寫操作都不會重排序到其前面。</li><li>4、volatile寫之前，所有變量的讀寫操作都已完成。</li></ul><p><strong>根據JMM規則，結合內存屏障的相關分析得出以下結論</strong>：</p><ul><li>1、在每一個volatile寫操作前面插入一個StoreStore屏障。這確保了在進行volatile寫之前前面的所有普通的寫操作都已經刷新到了內存。</li><li>2、在每一個volatile寫操作後面插入一個StoreLoad屏障。這樣可以避免volatile寫操作與後面可能存在的volatile讀寫操作發生重排序。</li><li>3、在每一個volatile讀操作後面插入一個LoadLoad屏障。這樣可以避免volatile讀操作和後面普通的讀操作進行重排序。</li><li>4、在每一個volatile讀操作後面插入一個LoadStore屏障。這樣可以避免volatile讀操作和後面普通的寫操作進行重排序。</li></ul><p>如下圖所示：</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/58c45822c20d4c42b78d9e61ea373a5f><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>3、as-if-serial語義</h1><p>但是用了volatile關鍵字，程序的運行速度必然會受到影響，那麼除了volatile關鍵字以外什麼時候不會發生重排序呢？這裡就要引入as-if-serial語義。</p><p>as-if-serial語義的意思是：<strong>不管怎麼重排序（編譯器和處理器為了提供並行度），（單線程）程序的執行結果不能被改變。</strong></p><p>如果兩個操作訪問同一個變量，且這兩個操作有一個為寫操作，此時<strong>這兩個操作就存在數據依賴性這裡就存在三種情況：1. 讀後寫；2.寫後寫；3. 寫後讀，這三種操作都是存在數據依賴性的</strong>。如果重排序會對最終執行結果會存在影響，編譯器和處理器在重排序時，會遵守數據依賴性，編譯器和處理器不會改變存在數據依賴性關係的兩個操作的執行順序。</p><pre><code>int a=1;int b=2;int c =a+b;複製代碼</code></pre><p><strong>as-if-serial語義</strong>把單線程程序保護了起來，遵守<strong>as-if-serial語義</strong>的編譯器，runtime和處理器共同為編寫單線程程序的程序員創建了一個幻覺：單線程程序是按程序的順序來執行的。比如上面計算的代碼，在單線程中，會讓人感覺代碼是一行一行順序執行上，實際上a,b兩行不存在數據依賴性可能會進行重排序，即a，b不是順序執行的。<strong>as-if-serial語義</strong>使程序員不必擔心單線程中重排序的問題干擾他們，也無需擔心內存可見性問題。</p><p>說到底，<strong>as-if-serial語義</strong>不過是一種最基礎的架構定義,可以類比地球上氧氣的比例約為21%。</p><p>重排序可以分為兩類：</p><p><strong>會改變程序執行結果的重排序。</strong></p><p><strong>不會改變程序執行結果的重排序。</strong></p><p>JMM對這兩種不同性質的重排序，採取了不同的策略。</p><ul><li>對於會改變程序執行結果的重排序，JMM要求編譯器和處理器必須禁止這種重排序。</li><li>對於不會改變程序執行結果的重排序，JMM對編譯器和處理器不做要求（JMM允許進行優化重排序）</li></ul><p>volatile就是通過對內存語義的封裝實現了對volatile關鍵字讀寫時的順序和可見。保證了我們所謂的多線程下的可見性，但是還是沒辦法保證多線程下修改數據的同步，因為同步除了有序和可見還需要滿足原子性。</p><h1 class=pgc-h-arrow-right>四、happens-before規則</h1><p>在Java內存模型中，如果要確保有序性可以靠volatile和synchronized來實現，但是如果所有的有序性都僅僅依靠這兩個關鍵字來完成，那麼有一些操作將會變得很繁瑣，但是我們在編寫Java代碼的時候並沒有感覺到這一點，這是因為Java語言中有一個“先行發生(happens-before)”的原則。那麼happens-before到底是什麼呢？</p><p>happens-before的概念最初由Leslie Lamport在其一篇影響深遠的論文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。JSR-133（即JavaTM內存模型與線程規範,由JSR-133專家組開發）使用happens-before的概念來指定兩個操作之間的執行順序。</p><h1 class=pgc-h-arrow-right>1、定義</h1><p>happens-before表示的是前一個操作的結果對於後續操作是可見的，它是一種表達多個線程之間對於內存的可見性。所以我們可以認為在JMM中，如果一個操作執行的結果需要對另一個操作可見，那麼這兩個操作必須要存在happens-before關係。</p><p><strong>具體的定義為：</strong></p><ul><li>1、如果一個操作happens-before另一個操作，那麼第一個操作的執行結果將對第二個操作可見，而且第一個操作的執行順序排在第二個操作之前。</li><li>2、兩個操作之間存在happens-before關係，並不意味著Java平臺的具體實現必須要按照happens-before關係指定的順序來執行。如果重排序之後的執行結果，與按happens-before關係來執行的結果一致，那麼這種重排序並不非法（也就是說，JMM允許這種重排序）。</li></ul><h1 class=pgc-h-arrow-right>2、happens-before的8條規則</h1><p><strong>8條規則定義：</strong></p><ul><li>1、程序順序規則：一個線程中的每個操作，happens-before於該線程中的任意後續操作。（在一個線程內一段代碼的執行結果是有序的）</li><li>3、監視器鎖規則：對一個鎖的解鎖，happens-before於隨後對這個鎖的加鎖。(先加鎖後解鎖)</li><li>3、volatile變量規則：對於volatile修飾的變量的寫的操作，一定happen-before後續對於volatile變量的讀操作。(讀寫不會重排序，寫操作的結果一定對讀的這個線程可見)</li><li>4、傳遞性：如果A happens-before B，且B happens-before C，那麼A happens-before C。</li><li>5、start()規則：如果線程A執行操作ThreadB.start()（啟動線程B），那麼A線程的ThreadB.start()操作happens-before於線程B中的任意操作。</li><li>6、Join()規則：如果線程A執行操作ThreadB.join()併成功返回，那麼線程B中的任意操作happens-before於線程A從ThreadB.join()操作成功返回。</li><li>7、程序中斷規則：對線程interrupted()方法的調用先行於被中斷線程的代碼檢測到中斷時間的發生。</li><li>8、對象finalize規則：一個對象的初始化完成（構造函數執行結束）先行於發生它的finalize()方法的開始。</li></ul><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/82236602dc5741feb1128cf815b1c663><p class=pgc-img-caption></p></div><p>JMM對編譯器和處理器的束縛已經儘可能少。從上面的分析可以看出，<strong>JMM其實是在遵循一個基本原則：只要不改變程序的執行結果（指的是單線程程序和正確同步的多線程程序），編譯器和處理器怎麼優化都行</strong>。例如，如果編譯器經過細緻的分析後，認定一個鎖只會被單個線程訪問，那麼這個鎖可以被消除。再如，如果編譯器經過細緻的分析後，認定一個volatile變量只會被單個線程訪問，那麼編譯器可以把這個volatile變量當作一個普通變量來對待。這些優化既不會改變程序的執行結果，又能提高程序的執行效率。</p><h1 class=pgc-h-arrow-right>3、happens-before與JMM的關係</h1><p>一個happens-before規則對應於一個或多個編譯器和處理器重排序規則。對於Java程序員來說，happens-before規則簡單易懂。</p><div class=pgc-img><img alt=瞭解volatile、內存與happens-before規則 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1febcbc0e0b84ee8a6d011f2a4792411><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>結語</h1><blockquote><p>這段時間為了寫這篇文章也是看了很多的文章和視頻，很多文章都互相有衝突，很多點我也沒有辦法保證完全正確，只能自己拿著JSR133的文檔去看，看完了以後我推薦大家不要去看orz，真的是學的越多懂得越多不懂的也就更多了。不過學習如逆水行舟，不進則退，如果沒有跳出舒適區（包括學一些很難的東西）的勇氣，那學習這一條路也就到頭了吧~一起加油吧！</p></blockquote><p><br>作者：南橘ryc<br>鏈接：https://juejin.im/post/6887838347726290951<br>來源：掘金<br>著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>瞭解</a></li><li><a>volatile</a></li><li><a>內存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html alt=內存容量如何計算，瞭解一些基礎知識，你就懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d9065c724be64660aee58a3257a23534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html title=內存容量如何計算，瞭解一些基礎知識，你就懂了！>內存容量如何計算，瞭解一些基礎知識，你就懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html alt=兩分鐘瞭解低損耗電纜結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9af84f52bbed4ee39f3825e0f43e619b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html title=兩分鐘瞭解低損耗電纜結構>兩分鐘瞭解低損耗電纜結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html alt=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/decf8edb02a34404b92b86681378575f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html title=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html alt=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcdae811e636496d948cf5a745f470fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html title=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html alt=「瞭解」房屋的層高和淨高怎麼算？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1526054178152a496189726 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html title=「瞭解」房屋的層高和淨高怎麼算？>「瞭解」房屋的層高和淨高怎麼算？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2db74f7c.html alt=瞭解鍋爐循環泵與換熱站循環泵的佈置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533630871099dca28f1fe7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2db74f7c.html title=瞭解鍋爐循環泵與換熱站循環泵的佈置>瞭解鍋爐循環泵與換熱站循環泵的佈置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html alt=做跨境電商站外推廣，你必須瞭解的Facebook像素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2df772dcb2d747f8b55ff9e4610cbcad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html title=做跨境電商站外推廣，你必須瞭解的Facebook像素>做跨境電商站外推廣，你必須瞭解的Facebook像素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed10eec0.html alt=瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/79d0cee860504ee48c8e419052ceab23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed10eec0.html title=瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？>瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html alt=瞭解生成對抗網絡（GAN） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/634604de44ad4d17931ccc0bcf3e46ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html title=瞭解生成對抗網絡（GAN）>瞭解生成對抗網絡（GAN）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2f3b02a.html alt=牆繪知識來了，帶你一分鐘瞭解丙烯顏料 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f33c910d91a847bdb6baabc3ab01e0cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2f3b02a.html title=牆繪知識來了，帶你一分鐘瞭解丙烯顏料>牆繪知識來了，帶你一分鐘瞭解丙烯顏料</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6114a4bb.html alt=格鬥周：帶你瞭解各類格鬥術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/46b75604edfa491990901ac982573db9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6114a4bb.html title=格鬥周：帶你瞭解各類格鬥術>格鬥周：帶你瞭解各類格鬥術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/444cae24.html alt=瞭解房屋建築圈樑 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/154043230417821ced6ef46 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/444cae24.html title=瞭解房屋建築圈樑>瞭解房屋建築圈樑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57257e28.html alt=你對鋼製文件櫃瞭解多少呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad059f36d954de2b5517d99057887f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57257e28.html title=你對鋼製文件櫃瞭解多少呢>你對鋼製文件櫃瞭解多少呢</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>