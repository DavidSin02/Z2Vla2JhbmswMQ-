<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ | 极客快訊</title><meta property="og:title" content="大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be7d76b3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be7d76b3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/be7d76b3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be7d76b3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be7d76b3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/be7d76b3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/be7d76b3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be7d76b3.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/be7d76b3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>二叉樹（Binary Tree）</strong></h1><h1 class=pgc-h-arrow-right>回顧</h1><p style=text-align:start>在前面的文章中，我們對於二叉樹的一些基本概念進行了回顧，同時對比了線性結構與樹形結構，總結了一些常見的二叉樹的性質，像二叉樹，真二叉樹，完全二叉樹，以及滿二叉樹等等，但是，我們僅僅是在概念上對於二叉樹有所瞭解，並沒有進行編碼工作，今天來完善一下這一步的操作</p><p style=text-align:start>直接進入二叉樹的設計與編碼。</p><h1 class=pgc-h-arrow-right>設計</h1><h1 class=pgc-h-arrow-right><strong>屬性與節點</strong></h1><p style=text-align:start>首先，我們的二叉樹是用來存放元素的，同時它還需要知道自己的父節點與子節點的關係，那麼，很容易想到的是使用節點類，那麼二叉樹的節點類該如何設計呢，同時我的二叉樹類該有哪些基本元素呢？</p><pre><code>//樹節點的數量protected int size;//樹的根結點protected Node&lt;E&gt; root;</code></pre><p style=text-align:start>這裡我們先不說訪問修飾符為什麼是protected，先來說一說節點類該怎麼設計，我們需要知道一個節點的父節點，以及左右子節點的關係，同時還有節點中存儲的元素element,那麼我們的節點應該是這樣：</p><pre><code>/** * 自定義節點類，用於維護二叉樹 * @param &lt;E&gt; */protected static class Node&lt;E&gt;{    E element;    Node&lt;E&gt; left;    Node&lt;E&gt; right;    Node&lt;E&gt; parent;    /**     * 構造函數，添加節點時，要指定元素     * 父節點的，但不一定有左右子節點     * @param element     * @param parent     */    public Node(E element,Node&lt;E&gt; parent){        this.element = element;        this.parent = parent;    }    /**     * 判斷是否為葉子節點     * @return     */    public boolean isLeaf() {        return left == null &amp;&amp; right == null;    }    /**     * 判斷是否左右子節點都具備     * @return     */    public boolean hasTwoChildren() {        return left != null &amp;&amp; right != null;    }}</code></pre><p style=text-align:start>該節點類，提供了一個構造函數以及兩個特有的方法，對於構造函數而言，初始化的時候，我們需要指定節點存儲的元素以及父節點，為什麼左右子節點不初始化呢，因為你添加一個節點時，是一定要知道其父節點的，但是你並不知道它有沒有子節點。</p><p style=text-align:start>對於另外兩個方法，我覺得這是節點類所特有的行為，因為節點的概念在二叉樹中是通用的，所以直接封裝在節點類中，而不是在後面，對於每一種獨特的二叉樹，需要用到判斷葉子節點以及度為 2 的節點的時候，再去編寫，那樣就太繁瑣了</p><p style=text-align:start>針對前面說到的size,root,以及節點類，這些應該是二叉樹的內部邏輯，對外是不公開的，外界不知道節點類的，它只需要指定節點，也就是二叉樹存儲的類型就可以了，但是我們需要對外界開放接口，通過接口來使用二叉樹，也就是說你只要知道怎麼用就好了，不需要知道我是怎麼實現的。</p><p style=text-align:start><strong>公共接口</strong></p><p style=text-align:start>對於二叉樹，我們提供給外界的方法應該有以下方法：</p><p style=text-align:start>public int size() —— 獲取元素節點的數量</p><p style=text-align:start>public boolean isEmpty() —— 判斷樹是否為空樹</p><p style=text-align:start>public void clear() —— 清空樹的所有元素</p><p style=text-align:start>public void preorder() —— 前序遍歷</p><p style=text-align:start>public void inorder() —— 中序遍歷</p><p style=text-align:start>public void postorder() —— 後序遍歷</p><p style=text-align:start>public void levelOrder() —— 層序遍歷</p><p style=text-align:start>public int height() —— 計算樹的高度</p><p style=text-align:start>public boolean isComplete() —— 判斷是否為完全二叉樹</p><p style=text-align:start>public boolean isProper () —— 判斷是否為真二叉樹</p><p style=text-align:start>public String toString() —— 重新toString方法，樹狀打印二叉樹</p><p style=text-align:start>我們對外界提供的方法大致就是這些了，那麼問題來了，我們可以有疑惑了，既然二叉樹是用來存放元素的，為什麼沒有add、remove添加以及移除節點的方法的呢，那麼這樣的一棵樹new出來之後就是一棵空樹呀，是不是忘記了？很明確說明，沒有忘了，就是不給提供添加、移除的方法。</p><p style=text-align:start>我們來思考一下，有下面這麼一段代碼：</p><pre><code>BinaryTree&lt;Integer&gt; bTree = new BinaryTree&lt;&gt;();bTree.add(9);bTree.add(5);bTree.add(8);</code></pre><p style=text-align:start>可以明確的是第一個添加的元素9就是根節點，那麼問題來了，接下來的 5，是要作為 9 的左子節點還是右子節點，8 應該是 5 的兄弟節點還是左右子節點其中一個，是的，我們並沒有明確二叉樹的添加規則，寫起來是很麻煩也是沒有意義的，當然，我們也可以默認一致往左或者往右添加，但是這樣沒有多大意義，沒有明確的規則，那就是普通的二叉樹，是沒有什麼用處的，規則就是樹的特性，像二叉搜索樹，紅黑樹，AV樹等等，都是有明確的規則的。實際上，我們是在普通的二叉樹加一些自定義的邏輯和規則，所以這裡的二叉樹類BinaryTree實際上應該是基類，而添加以及移除等特有的規則，應該在繼承普通二叉樹的基礎上編寫的，而二叉樹提供的就是一些通用的方法。這也是前面將BinaryTree的類的屬性的訪問修飾符設計為protected的原因</p><h1 class=pgc-h-arrow-right>簡單方法</h1><p style=text-align:start>public int size() —— 獲取元素節點的數量</p><pre><code>/** * 獲取元素節點的數量 * @return */public int size() {    return size;}</code></pre><p style=text-align:start>public boolean isEmpty() —— 判斷樹是否為空樹</p><pre><code>/** * 判斷樹是否為空樹 * @return */public boolean isEmpty() {    return size == 0;}</code></pre><p style=text-align:start>public void clear() —— 清空樹的所有元素</p><pre><code>/** * 清空樹的所有元素 */public void clear() {    root = null;    size = 0;}</code></pre><p style=text-align:start>簡單的方法直接放出來，直接瞄一眼即可</p><h1 class=pgc-h-arrow-right>有趣的遍歷</h1><p style=text-align:start>對於數組，鏈表等數據結構，我們都能遍歷，獲取到所有元素，線性數據結構的遍歷比較簡單 — 正序遍歷與逆序遍歷，對於我們的二叉樹，同樣也應該提供遍歷的方法</p><p style=text-align:start>根據節點訪問順序的不同，二叉樹的常見遍歷方式有4種常見的遍歷方式（Preorder Traversal）：</p><ul><li>前序遍歷（Preorder Traversal）</li><li>中序遍歷（Inorder Traversal）</li><li>後序遍歷（Postorder Traversal）</li><li>層序遍歷（Level Order Traversal）</li></ul><p style=text-align:start>我們以二叉搜索樹 —— {7,4,9,2,5,8,11,3,12,1}為例，分別分析這四種遍歷方式</p><h1 class=pgc-h-arrow-right><strong>前序遍歷</strong></h1><p style=text-align:start>訪問順序：<strong>根節點</strong>、前序遍歷<strong>左子樹</strong>、前序遍歷<strong>右子樹</strong> — <strong>（根節點訪問在前）</strong></p><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>遍歷結果是：7、4、2、1、3、5、9、8、11、10、12</p><p style=text-align:start>前序遍歷、中序遍歷、後序遍歷用遞歸遍歷的方式實現都很簡單，這裡就不放出來佔篇幅了，但是有提供，如果想看的話，後面會將完整代碼上傳Github,需要再去下載下來即可，下載的時候，注意選擇dev分支，那邊才是最新的代碼</p><p style=text-align:start><strong>實現步驟：</strong></p><ul><li>利用棧先進後出的特性：</li><li>設置node = root，將root入棧，循環執行以下操作，直到棧為空</li><li>彈出棧頂節點top，進行訪問</li><li>將top.right入棧將top.left入棧</li></ul><pre><code>/** * 迭代法實現 —— 前序遍歷 */private void preorderByIteration(){    if (root == null) return;    Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();    stack.push(root);    while (!stack.isEmpty()) {        Node&lt;E&gt; node = stack.pop();        System.out.print(node.element + "  ");        if (node.right != null){            stack.push(node.right);        }        if (node.left != null){            stack.push(node.left);        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>中序遍歷</strong></h1><p style=text-align:start>訪問順序： — （<strong>根節點訪問在中</strong>）</p><p style=text-align:start>1、中序遍歷左子樹、根節點、中序遍歷右子樹 （如果是二叉搜索樹，結果升序）</p><p style=text-align:start>2、中序遍歷右子樹、根節點、中序遍歷左子樹 （如果是二叉搜索樹，結果降序）</p><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/30d1dbe929ec4e0b9f2559a61bd7964c><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>遍歷結果是：1、2、3、4、5、7、8、9、10、11、12 （升序）</p><p style=text-align:start><strong>實現步驟：</strong></p><ul><li>利用棧先進後出的特性：</li><li>設置node = root，將root入棧，循環執行以下操作，直到棧為空</li><li>如果node！= null將node入棧，設置node = node.left</li><li>如果node == null如果棧為空，結束遍歷，如果棧不為空，彈出棧頂元素並賦值給node，對node進行訪問</li><li>設置node = node.right</li></ul><pre><code>/** * 迭代法實現 —— 中序遍歷 */private void inorderByIteration(){    if (root == null) return;    Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();    Node&lt;E&gt; node = root;    while (node != null || !stack.isEmpty()) {        while (node != null){            stack.push(node);            node = node.left;        }        node = stack.pop();        System.out.print(node.element + "  ");        node = node.right;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>後序遍歷</strong></h1><p style=text-align:start>訪問順序：後序遍歷左子樹、後序遍歷右子樹、根節點 — （<strong>根節點訪問在後</strong>）</p><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/159ad1c3eaa54dc6b0995d74927a194b><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>遍歷結果是：1、3、2、5、4、8、10、12、11、9、7</p><p style=text-align:start><strong>實現步驟：</strong></p><ul><li>利用棧先進後出的特性：</li><li>設置node = root，將root入棧，循環執行以下操作，直到棧為空</li><li>如果棧頂節點是<strong>葉子節點</strong>或者上一次訪問的節點是棧頂節點的<strong>子節點</strong>，彈出棧頂節點，進行訪問</li><li>否則，將棧頂節點的right、left按順序入棧</li></ul><pre><code>/** * 迭代法實現 —— 後序遍歷 */private void postorderByIteration(){    if (root == null) return;    Node&lt;E&gt; node = root;    //記錄上一次訪問的節點    Node&lt;E&gt; lastVisited = null;    Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();    while (node != null || !stack.isEmpty()) {        while (node != null){            stack.push(node);            node = node.left;        }        node = stack.pop();        //棧頂節點是葉子節點或者上一次訪問的節點是棧頂節點的子節點        if (node.right == null || node.right == lastVisited){            System.out.print(node.element + "  ");            lastVisited = node;            //這裡node沒有改變指向，所以需要指向null，否則會死循環            node = null;        }else {            //既不是子節點且上一次訪問的節點又不是棧頂節點的子節點話，代表是符節點，重新進棧            stack.push(node);            node = node.right;        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>層序遍歷</strong></h1><p style=text-align:start>訪問順序：從上到下、從左到右依次訪問每一個節點</p><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f6ffb336ba84e33a60c32a8004da58d><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>遍歷結果是：7、4、9、2、5、8、11、1、3、10、12</p><p style=text-align:start>層序遍歷採用迭代的方式實現，利用隊列的先進先出性質，能很好的做到層序遍歷</p><p style=text-align:start><strong>實現步驟：</strong></p><ul><li>利用隊列先進先出的特性：</li><li>將根節點root入隊，循環執行以下操作，直到隊列為空</li><li>將隊頭節點node出隊，進行訪問，將node的左子節點入隊，將node的右子節點入隊</li></ul><p style=text-align:start>畫一波圖解：</p><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a3ab0559d5a145eb818bb8e000eed911><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>結合圖解，看代碼，很清晰</p><pre><code>/** * 層序遍歷，迭代方式 */public void levelOrderTraversal(){    if (root == null) return;    Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();    //入隊    queue.offer(root);    while (!queue.isEmpty()){        Node&lt;E&gt; node = queue.poll();        System.out.print(node.element + "  ");        //如果有左子節點，入隊        if (node.left != null){            queue.offer(node.left);        }        //如果有右子節點，入隊        if (node.right != null){            queue.offer(node.right);        }    }}</code></pre><h1 class=pgc-h-arrow-right>補充</h1><p style=text-align:start>如果對於二叉樹的四種遍歷方式還是比較迷惑的話，我只是畫了靜態圖的順序，可能閱讀起來理解不夠到位，但是有時候畫圖解的時間很長，看一下圖解，再回來閱讀，相信會好一些</p><h1 class=pgc-h-arrow-right>增強遍歷接口</h1><p style=text-align:start><strong>對比：</strong> 上面四種遍歷的方法都編寫出來了，但是你覺得這樣的遍歷，功能夠嗎？ 或者說，你覺得這個對比我們前面在動態數組，鏈表、棧和隊列中的遍歷有什麼區別？沒有閱讀過動手編寫 —— 動態數組，鏈表，棧和隊列的同學，有興趣的可以點擊關鍵詞看看</p><p style=text-align:start>我們簡單寫一下JDK數組或者動態鏈表遍歷的代碼:</p><pre><code>//遍歷數組int[] arr = {1,2,3,4,5,6,7,8,9};for (int value:arr) {    System.out.println(value);}//遍歷鏈表List&lt;Integer&gt; list = new LinkedList&lt;&gt;(){{    add(1);add(2);add(3);add(4);add(5);}};for (int value:list) {    System.out.println(value);}</code></pre><p style=text-align:start>這樣看起來好像沒有什麼問題，二叉樹遍歷是System.out.print(node.element);</p><p style=text-align:start>而數組和鏈表是System.out.println(value); 都是打印呀，能有什麼區別呀。可能上面的代碼具備迷惑性，我們再來看看另一個代碼：</p><pre><code>int[] arr = {1,2,3,4,5,6,7,8,9};for (int value:arr) {    System.out.println(value + "--&gt;" + "Kalton是帥哥");}</code></pre><p style=text-align:start>嗨，這樣就醒目點了，數組可以打印出節點存儲的元素的同時，補上一句Kalton是帥哥，而上面二叉樹的遍歷卻是做不到的，因為一個是寫死在類裡面的，一個是在類外部編寫的。</p><p style=text-align:start>這樣的區別就是，二叉樹的遍歷只是打印一遍元素，並沒有真正獲取到存在在二叉樹的元素，而數組、鏈表的遍歷是獲取到每一個元素，至於做什麼，打印還是增加，還是說Kalton是帥哥，這些遍歷規則都是由調用者自定義的，而不是寫死了，所以我們的二叉樹內部應該做到能夠遍歷的同時將節點元素傳給調用者，由用戶自定義遍歷規則，我們的做法是，在二叉樹編寫一個抽象內部類Visitor：</p><pre><code>/** * 提供外部使用的遍歷器接口 * @param &lt;E&gt; */public abstract static class Visitor&lt;E&gt;{    //遍歷停止遍歷的標記    boolean stop;    /**     * visit方法將節點元素傳給調用者     * @param element     * @return 如果返回true，結束遍歷     */    abstract boolean visit(E element);}</code></pre><p style=text-align:start>visit方法方法參數為E element,在遍歷的時候接收節點元素，傳給外部調用者，返回值如果是true，表示用戶希望結束遍歷，我們以前序遍歷為例，實現我們的邏輯：</p><pre><code>/** * 迭代法實現 —— 前序遍歷 * @param visitor */public void preorderByIteration(Visitor&lt;E&gt; visitor){    if (root == null || visitor == null) return;    Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();    stack.push(root);    while (!stack.isEmpty()) {        Node&lt;E&gt; node = stack.pop();        //傳給外部調用者,如果條件成立，停止遍歷        if (visitor.visit(node.element)) return;        if (node.right != null){            stack.push(node.right);        }        if (node.left != null){            stack.push(node.left);        }    }}</code></pre><p style=text-align:start>實際上，就是用戶在調用前序遍歷preorderByIteration，需要傳入自定義的遍歷規則類Visitor,然後在我們原來的方法打印元素的地方改為if (visitor.visit(node.element)) return;，即將節點元素返回給方法調用者，使用調用的遍歷規則，同時返回給二叉樹類一個boolean變量值，用stop接收，告知是否結束遍歷，所以什麼時候結束遍歷也是有用戶自定義規則的</p><p style=text-align:start>但是有一點不好的是，這樣我們調用二叉樹的遍歷方法時，需要強制傳入一個遍歷規則類，同時我們遍歷的方法是遞歸還是迭代都對調用者暴露了，所以我做了一下小小的封裝：</p><pre><code>/** * 前序遍歷 —— 如果用戶沒有傳遍歷規則，默認打印元素 */public void preorder(){    preorder(new Visitor&lt;&gt;() {        @Override        boolean visit(E element) {            System.out.print(element + " ");            return false;        }    });}/** * 增強前序遍歷，提供調用者編寫自己的遍歷規則 * @param visitor */public void preorder(Visitor&lt;E&gt; visitor) {    if (visitor == null) return;    /**     * 底層使用遞歸法     */    //preorderByRecursive(root, visitor);    /**     * 底層使用迭代法     */    preorderByIteration(visitor);    System.out.println();}</code></pre><p style=text-align:start>public void preorder()方法不需要傳參，默認遍歷規則是打印節點元素，而用戶需要自定義比較規則則調用public void preorder(Visitor&lt;E> visitor)，傳入比較器，至於是使用preorderByRecursive遞歸還是preorderByIteration，用戶並不知道，由我們在設計時決定，其他 3 種遍歷也是一樣的邏輯，代碼比較長，不必要的展示，我就沒有貼出來，會在後面給出GitHub地址，需要的話，大家自行下載閱讀</p><h1 class=pgc-h-arrow-right>樹的判定</h1><p style=text-align:start>在二叉樹前奏中，我們已經講了<strong>完全二叉樹</strong>，<strong>真二叉樹</strong>的特點以及性質，這裡就不再複述了，實際上，對於他們的判定以及計算樹的高度，都是以<strong>層序遍歷</strong>方法為基礎，所完成的，所以層序遍歷是很重要的，最好是給我收手寫出來</p><h1 class=pgc-h-arrow-right>完全二叉樹的判定</h1><p style=text-align:start><strong>實現步驟：</strong></p><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/778eaa36f14949db9e7c455436b21831><p class=pgc-img-caption></p></div><p><br></p><pre><code>/** * 判斷是否為完全二叉樹 —— (層序遍歷) * @return */public boolean isComplete() {    if (root == null) return false;    Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    boolean leaf = false;    while (!queue.isEmpty()) {        Node&lt;E&gt; node = queue.poll();        if (leaf &amp;&amp; !node.isLeaf()) return false;        if (node.left != null) {            queue.offer(node.left);        } else if (node.right != null) {            //相當於node.left == null &amp;&amp; node.right != null            return false;        }        if (node.right != null) {            queue.offer(node.right);        } else {            //node.left == null &amp;&amp; node.right == null            //node.left ！= null &amp;&amp; node.right == null            // 後面遍歷的節點都必須是葉子節點            leaf = true;        }    }    return true;}</code></pre><h1 class=pgc-h-arrow-right>真二叉樹的判定</h1><p style=text-align:start><strong>實現步驟：</strong></p><p style=text-align:start>1、利用隊列<strong>先進先出</strong>的特性</p><p style=text-align:start>2、利用真二叉樹的節點，要麼度為0，要麼度為2的特點</p><p style=text-align:start>3、在層序遍歷的時候，判斷每層的節點數量，如果levelSize % 2 != 0，返回flase</p><p style=text-align:start>4、結合上面層序遍歷的圖解，就會發現，每一層的節點遍歷完後，隊列中的節點數量size等於下一層的節點數量，而第一層只有根節點</p><pre><code>/** * 判斷是否為真二叉樹 —— (層序遍歷) * @return */public boolean isProper (){    if (root == null) return false;    // 存儲著每一層的元素數量    int levelSize = 1;    Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty()) {        Node&lt;E&gt; node = queue.poll();        levelSize--;        if (node.left != null) {            queue.offer(node.left);        }        if (node.right != null) {            queue.offer(node.right);        }        // 意味著即將要訪問下一層        if (levelSize == 0) {            //每一層訪問完後，下一層的節點個數是隊列的size            levelSize = queue.size();            if (levelSize % 2 != 0) return false;        }    }    return true;}</code></pre><h1 class=pgc-h-arrow-right>樹的高度</h1><p style=text-align:start>樹的高度實際上就是樹的層數，與上面的判定真二叉樹很接近，只需要在設置一個height，在遍歷完每一層的時候，height++,結束遍歷後，返回的就是樹的高度</p><p style=text-align:start>樹的高度實際上所有子節點的高度中最大的一個，然後再 + 1，這樣的思路，很容易以遞歸的方式實現，所以計算樹的高度，有遞歸和迭代兩種方法，這裡貼出遞歸的方法，因為迭代的方法就是上面判定二叉樹的方法做點小改動，就不貼出來了，需要的話，自行下載源碼。</p><pre><code>/** * 計算樹的高度 * @return */public int height(){    //遞歸法    return heightByRecursive(root);    //迭代法    //return heightByIteration();}/** * (遞歸法)獲取傳入節點的高度 * @param node * @return */private int heightByRecursive(Node&lt;E&gt; node){    if (node == null) return 0;    return 1 + Math.max(heightByRecursive(node.left),heightByRecursive(node.right));}</code></pre><h1 class=pgc-h-arrow-right>前驅與後繼</h1><h1 class=pgc-h-arrow-right>尋找前驅節點</h1><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/679fc48237dd4822bc57c48bee6c41b2><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>根據上面的判定條件給出實現代碼：</p><pre><code>/** * 獲取傳入節點的前驅節點 * @param node * @return */protected Node&lt;E&gt; predecessor(Node&lt;E&gt; node) {    if (node == null) return null;    // 前驅節點在左子樹當中（left.right.right.right....）    Node&lt;E&gt; p = node.left;    if (p != null) {        while (p.right != null) {            p = p.right;        }        return p;    }    // 從父節點、祖父節點中尋找前驅節點    while (node.parent != null &amp;&amp; node == node.parent.left) {        node = node.parent;    }    // node.parent == null    // node == node.parent.right    return node.parent;}</code></pre><h1 class=pgc-h-arrow-right>尋找後繼節點</h1><div class=pgc-img><img alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d77f79527de44a59af836545cc7fd90><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>根據上面的判定條件給出實現代碼：</p><pre><code>/** * 獲取傳入節點的後繼節點 * @param node * @return */protected Node&lt;E&gt; successor(Node&lt;E&gt; node) {    if (node == null) return null;    // 前驅節點在左子樹當中（right.left.left.left....）    Node&lt;E&gt; p = node.right;    if (p != null) {        while (p.left != null) {            p = p.left;        }        return p;    }    // 從父節點、祖父節點中尋找前驅節點    while (node.parent != null &amp;&amp; node == node.parent.right) {        node = node.parent;    }    return node.parent;}</code></pre><p style=text-align:start>現在我們可能會比較疑惑，這兩個方法，找出前驅或者後繼節點有什麼用，不知道你有沒有看到方法的訪問修飾符：protected，實際上這兩個方法都不是給用戶調用的，正如我們的疑惑一樣，用戶不知道怎麼用，用來幹嘛，實際上這是為繼承二叉樹BinaryTree類的子類所使用的，其作用是在刪除度為 2 的時，將找到的前驅或者後繼節點用來替代的，這在下一篇，二叉搜索樹的時候會說到。</p><h1 class=pgc-h-arrow-right>小結</h1><p style=text-align:start>到這裡為止，已經將二叉樹的基本概念複習以及通用方法的設計編寫，對於二叉樹的結構有了一定的認識，但知識有時候總是在你覺得記住的時候偷偷溜走，因此，將所學的知識總結成筆記，以便後來翻閱，加深印象。</p><h1 class=pgc-h-arrow-right>最後</h1><p style=text-align:start>大家看完有什麼不懂的可以在下方留言討論.<br>謝謝你的觀看。<br>覺得文章對你有幫助的話記得關注我點個贊支持一下！</p><blockquote><p>作者：衍方<br>原文鏈接：https://www.cnblogs.com/kalton/p/13689985.html</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>大無語</a></li><li><a>面試</a></li><li><a>必問</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html alt=面試必問的HashMap，你真的瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/19a8d23522b640b4a8d8a927514eca33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html title=面試必問的HashMap，你真的瞭解嗎？>面試必問的HashMap，你真的瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f192b47.html alt=大廠面試必問的數據結構--棧和隊列基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c7607ef07fe84842957cc74a9be92140 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f192b47.html title=大廠面試必問的數據結構--棧和隊列基礎知識>大廠面試必問的數據結構--棧和隊列基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9f6e5f.html alt=面試必問：設計模式遵循的面向對象設計原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0ffba50d7eb54d3a9b1b4ead627eeb35 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9f6e5f.html title=面試必問：設計模式遵循的面向對象設計原則>面試必問：設計模式遵循的面向對象設計原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45389c0.html alt=面試必問：嵌套函數、閉包與裝飾器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c892cd4d30114fbea6fb40a071aa43c6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45389c0.html title=面試必問：嵌套函數、閉包與裝飾器>面試必問：嵌套函數、閉包與裝飾器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html alt="不怕面試被問了！二叉樹算法大盤點 | 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html title="不怕面試被問了！二叉樹算法大盤點 | 原力計劃">不怕面試被問了！二叉樹算法大盤點 | 原力計劃</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>