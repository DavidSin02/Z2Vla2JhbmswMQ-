<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式 | 极客快訊</title><meta property="og:title" content="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1782762585094875aed77595aea842ab"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bef9dc9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bef9dc9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bef9dc9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bef9dc9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bef9dc9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bef9dc9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bef9dc9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bef9dc9.html><meta property="article:published_time" content="2020-10-29T21:04:29+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:29+08:00"><meta name=Keywords content><meta name=description content="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/bef9dc9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>在這一部分中，我們將探討RabbitMQ和Apache Kafka以及它們的消息傳遞方法。每種技術在設計的每個方面都做出了截然不同的決定，每種方面都有優點和缺點。我們不會在這一部分得出任何有力的結論，而是將其視為技術的入門，以便我們可以深入探討該系列的後續部分。</p><h1>RabbitMQ</h1><p>RabbitMQ是一個分佈式消息隊列系統。分佈式，因為它通常作為節點集群運行，其中隊列分佈在節點上，並可選擇複製以實現容錯和高可用性。它原生地實現了AMQP 0.9.1，並通過插件提供其他協議，如STOMP，MQTT和HTTP。</p><p>RabbitMQ同時採用經典和新穎方式。從某種意義上來說，它是面向消息隊列的經典，並且具有高度靈活的路由功能。正是這種路由功能才是其殺手級功能。構建快速，可擴展，可靠的分佈式消息傳遞系統本身就是一項成就，但消息路由功能使其在眾多消息傳遞技術中脫穎而出。</p><p><strong>交換機（</strong>exchanges）<strong>和隊列</strong></p><p>超簡化概述：</p><ul><li>發佈者向<strong>交換機（</strong>exchanges）發送消息</li><li>將消息路由到隊列和其他<strong>交換機（</strong>exchanges）</li><li>RabbitMQ在收到消息時向發佈者發送確認</li><li>消費者與RabbitMQ保持持久的TCP連接，並聲明他們使用哪個隊列</li><li>RabbitMQ將消息推送給消費者</li><li>消費者發送成功/失敗的確認</li><li>成功使用後，消息將從隊列中刪除</li></ul><p>隱藏在該列表中的是開發人員和管理員應該採取的大量決策，以獲得他們想要的交付保證，性能特徵等，我們將在本系列的後續部分中介紹所有這些決策。</p><p>我們來看看單個發佈者，<strong>交換機（</strong>exchanges），隊列和消費者：</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1782762585094875aed77595aea842ab><p class=pgc-img-caption>Fig 1 - Single publisher and single consumer</p></div><p>如果您有多個同一消息的發佈者怎麼辦？ 如果我們有多個消費者每個人都希望消費每條消息呢？</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87c14a64615d4b1489e603738d93d8ab><p class=pgc-img-caption>Fig 2 - Multiple publishers, multiple independent</p></div><p>如您所見，發佈者將其消息發送到同一個<strong>交換機（</strong>exchanges），該<strong>交換機（</strong>exchanges）將每條消息路由到三個隊列，每個隊列都有一個消費者。 使用RabbitMQ，隊列使不同的消費者能夠使用每條消息。 與下圖對比：</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7b2fa670e4634766b8b03ebbb6d6f126><p class=pgc-img-caption>Fig 3 - Multiple publishers, one queue with multip</p></div><p>在圖3中，我們有三個消費者都在單個隊列中消費。 這些是競爭的消費者，即他們競爭消費單個隊列的消息。 人們可以預期，平均而言，每個消費者將消耗該隊列消息的三分之一。 我們使用競爭消費者來擴展我們的消息處理，使用RabbitMQ它非常簡單，只需按需添加或刪除消費者。 無論您擁有多少競爭消費者，RabbitMQ都將確保消息僅傳遞給單個消費者。</p><p>我們可以將圖2和圖3組合在一起，使多組競爭消費者，每組消費每條消息。</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f5b80f7394ec49daa836d41e6bb04b0a><p class=pgc-img-caption>Fig 4 - Multiple publishers, multiple queues with</p></div><p>交換和隊列之間的箭頭稱為綁定，我們將仔細研究本系列第2部分中的箭頭。</p><p><strong>擔保</strong></p><p>RabbitMQ提供“最多一次交付”和“至少一次交付”但不提供“完全一次交付”保證。我們將在本系列的第4部分中深入研究消息傳遞保證。</p><p>消息按照到達隊列的順序傳遞（畢竟是隊列的定義）。當您擁有競爭消費者時，這並不能保證完成與完全相同順序的消息處理匹配。這不是RabbitMQ的錯，而是並行處理有序消息集的基本現實。通過使用Consistent Hashing Exchange可以解決此問題，您將在下一部分中看到模式和拓撲。</p><p><strong>推和消費者預選</strong></p><p>RabbitMQ將消息推送到流中的消費者。有一個Pull API，但它的性能很糟糕，因為每條消息需要一個請求/響應往返（注意，由於Shiva Kumar的評論，我更新了這一段）。</p><p>如果消息到達隊列的速度快於消費者可以處理的速度，那麼基於推送的系統可能會使消費者感到壓力。因此，為了避免這種情況，每個消費者都可以配置預取限制（也稱為QoS限制）。這基本上是消費者在任何時候都可以擁有的未確認消息的數量。當消費者開始落後時，這可以作為安全切斷開關。</p><p>為什麼推而不拉？首先，它對於低延遲非常有用。其次，理想情況下，當我們擁有單個隊列的競爭消費者時，我們希望在它們之間均勻分配負載。如果每個消費者都會收到消息，那麼根據他們拉動工作分佈的數量，可能會變得非常不平衡。消息分佈越不均勻，延遲越多，處理時消息順序的丟失越多。因此，RabbitMQ的Pull API只允許一次提取一條消息，但這會嚴重影響性能。這些因素使RabbitMQ傾向於推動機制。這是RabbitMQ的縮放限制之一。通過將確認組合在一起可以改善它。</p><p><strong>路由</strong></p><p>交換基本上是到隊列和/或其他交換的消息的路由器。為了使消息從交換機傳送到隊列或其他交換機，需要綁定。不同的交換需要不同的綁定。有四種類型的交換和相關綁定：</p><ul><li>扇出（<strong>Fanout</strong>）。路由到具有綁定到交換的所有隊列和交換。標準的pub子模型。</li><li>直接。根據發佈者設置的消息隨附的路由密鑰路由消息。路由鍵是一個短字符串。直接交換將消息路由到具有與路由密鑰完全匹配的綁定密鑰的隊列/交換機。</li><li>話題。根據路由密鑰路由消息，但允許通配符匹配。</li><li>頭。 RabbitMQ允許將自定義標頭添加到消息中。標頭根據這些標頭值交換路由消息。每個綁定包括完全匹配標頭值。可以將多個值添加到具有匹配所需的ANY或ALL值的綁定。</li><li>一致的哈希。這是一個哈希路由密鑰或郵件頭並僅路由到一個隊列的交換。當您需要使用擴展的消費者處理訂單保證時，這非常有用。</li></ul><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a649901b46cb4151aa1bd33b582f709a><p class=pgc-img-caption>Fig 5. Topic exchange example</p></div><p>我們將在第2部分中更仔細地研究路由，但上面是主題交換的示例。發佈者使用路由密鑰格式<strong>LEVEL.AppName</strong>發佈錯誤日誌。</p><ul><li>隊列1將使用多字＃通配符接收所有消息。</li><li>隊列2將接收ECommerce.WebUI應用程序的任何日誌級別。它使用覆蓋日誌級別的單字*通配符。</li><li>隊列3將查看來自任何應用程序的所有ERROR級別消息。它使用多字＃通配符來覆蓋所有應用程序。</li></ul><p>通過四種路由消息的方式，以及允許交換路由到其他交換，RabbitMQ提供了一組功能強大且靈活的消息傳遞模式。接下來我們將討論死信交換，短暫交換和隊列，您將開始看到RabbitMQ的強大功能。</p><p><strong>死信交換機（Dead Letter Exchanges）</strong></p><p>我們可以配置隊列在以下條件下向交換機發送消息：</p><ul><li>隊列超過配置的消息數。</li><li>隊列超出配置的字節數。</li><li>消息生存時間（TTL）已過期。發佈者可以設置消息的生命週期，隊列也可以有消息TTL。哪個更短適用。</li></ul><p>我們創建一個綁定到死信交換的隊列，這些消息將存儲在那裡直到採取行動。在另一篇文章中，我描述了我已經實現的拓撲，其中所有死信的消息都發送到中央清算所，支持團隊可以在此決定採取何種措施。</p><p>與許多RabbitMQ功能一樣，死信交換提供了最初未考慮的額外模式。我們可以使用消息TTL和死信交換來實現延遲隊列和重試隊列，包括指數退避。請參閱我之前的帖子。</p><p><strong>短暫的交流和隊列（Ephemeral Exchanges and Queues）</strong></p><p>可以動態創建交換和隊列，並賦予自動刪除特徵。經過一段時間後，他們可以自我毀滅。這允許諸如用於基於消息的RPC的ephermal回覆隊列之類的模式。</p><p><strong>插件</strong></p><p>您要安裝的第一個插件是Management Plug-In，它提供HTTP服務器，Web UI和REST API。它非常易於安裝，併為您提供易於使用的UI，以幫助您啟動和運行。通過REST API進行腳本部署也非常簡單。</p><p>其他一些插件包括：</p><ul><li>一致的哈希交換，Sharding Exchange等</li><li>像STOMP和MQTT這樣的協議</li><li>網絡鉤子</li><li>額外的交換類型</li><li>SMTP集成</li></ul><p>RabbitMQ還有很多東西，但這是一本很好的入門書，讓您瞭解RabbitMQ可以做些什麼。現在我們來看看Kafka，它採用了完全不同的消息傳遞方法，並且具有驚人的功能。</p><h1>Apache Kafka</h1><p>Kafka是一個分佈式複製的提交日誌。 Kafka沒有隊列的概念，因為它主要用作消息系統，所以最初可能看起來很奇怪。長期以來，隊列一直是消息傳遞系統的代名詞。讓我們分解一下“<strong>分佈式，複製的提交日誌</strong>”：</p><ul><li>分佈式，因為Kafka被部署為節點集群，用於容錯和擴展</li><li>複製，因為消息通常跨多個節點（服務器）複製。</li><li>提交日誌因為消息存儲在分區中，所以只追加稱為主題的日誌。這種日誌概念是Kafka的主要殺手特徵。</li></ul><p>瞭解日誌（主題）及其分區是理解Kafka的關鍵。那麼分區日誌與一組隊列有什麼不同呢？讓我們想象一下吧。</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ad0d6b172e124864b6449e0e0c3cdb80><p class=pgc-img-caption>Fig 6 One producer, one partition, one consumer</p></div><p>Kafka不是將消息放入FIFO隊列並跟蹤像RabbitMQ那樣在隊列中跟蹤該消息的狀態，而是將其附加到日誌中，就是這樣。無論消耗一次還是一千次，該消息都會保留。它根據數據保留策略（通常是窗口時間段）刪除。那麼主題如何被消費？每個消費者跟蹤它在日誌中的位置，它有一個指向消耗的最後消息的指針，該指針稱為偏移量。消費者通過客戶端庫維護此偏移量，並且根據Kafka的版本，偏移量存儲在ZooKeeper或Kafka本身中。 ZooKeeper是一種分佈式共識技術，被許多分佈式系統用於領導者選舉等領域。 Kafka依靠ZooKeeper來管理集群的狀態。</p><p>這個日誌模型的驚人之處在於它立即消除了消息傳遞狀態的大量複雜性，更重要的是消費者，它允許它們倒回並返回並消耗先前偏移量的消息。例如，假設您部署了一個計算髮票的服務，該發票消耗了客戶預訂。該服務有一個錯誤，並在24小時內錯誤地計算所有發票。最好使用RabbitMQ，您需要以某種方式重新發布這些預訂，並僅發送給發票服務。但是對於Kafka，您只需將該消費者的偏移量移回24小時。</p><p>因此，讓我們看一下具有單個分區和兩個消費者的主題的情況，每個消費者都需要消費每條消息。從現在開始，我已經開始為消費者貼上標籤，因為它不是那麼清晰（如RabbitMQ圖），它們是獨立的，也是競爭對手的消費者。</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3b11fa399dfe429bb63c1e1e3d86c050><p class=pgc-img-caption>Fig 7 One producer, one partition, two independent</p></div><p>從圖中可以看出，兩個獨立的消費者都使用相同的分區，但他們正在從不同的偏移中讀取。 也許發票服務處理消息所需的時間比推送通知服務要長，或者發票服務可能會停機一段時間並且趕上，或者可能存在錯誤並且其偏移量必須移回幾個小時。</p><p>現在讓我們說發票服務需要擴展到三個實例，因為它無法跟上消息速度。 使用RabbitMQ，我們只需部署兩個發票服務應用程序，這些應用程序將使用預訂發票服務隊列。 但是Kafka不支持單個分區上的競爭消費者，Kafka的並行單元就是分區本身。 因此，如果我們需要三個發票消費者，我們至少需要三個分區。 所以現在我們有：</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/39761863159c487ab747279bf22dfff0><p class=pgc-img-caption>Fig 8 Three partitions and two sets of three consu</p></div><p>因此，這意味著您至少需要與最大規模的消費者一樣多的分區。我們來談談分區。</p><p><strong>分區和消費者組</strong></p><p>每個分區都是一個單獨的數據文件，可保證消息排序。這一點很重要：消息排序只能保證在一個分區內。這可能會在消息排序需求和性能需求之間引入一些緊張，因為並行單元也是分區。一個分區不能支持競爭消費者，因此我們的發票應用程序只能有一個實例消耗每個分區。</p><p>消息可以循環方式或通過散列函數路由到分區：散列（消息密鑰）％分區數。使用散列函數有一些好處，因為我們可以設計消息密鑰，使得同一實體的消息（例如預訂）始終轉到同一分區。這可以實現許多模式和消息排序保證。</p><p>消費者群體就像RabbitMQ的競爭消費者。組中的每個使用者都是同一應用程序的實例，並將處理主題中所有消息的子集。儘管RabbitMQ的競爭消費者都使用相同的隊列，但消費者群體中的每個消費者都使用同一主題的不同分區。因此，在上面的示例中，發票服務的三個實例都屬於同一個使用者組。</p><p>在這一點上，RabbitMQ看起來更加靈活，它保證了隊列中的消息順序，以及它應對不斷變化的競爭消費者數量的無縫能力。使用Kafka，如何對日誌進行分區非常重要。</p><p>Kafka從一開始就有一個微妙而重要的優勢，即RabbitMQ後來添加的關於消息順序和並行性的優點。 RabbitMQ維護整個隊列的全局順序，但在並行處理該隊列期間無法維護該順序。 Kafka無法提供該主題的全局排序，但它確實提供了分區級別的排序。因此，如果您只需要訂購相關消息，那麼Kafka提供有序消息傳遞和有序消息處理。想象一下，您有消息顯示客戶預訂的最新狀態，因此您希望始終按順序（按時間順序）處理該預訂的消息。如果您按預訂ID進行分區，那麼給定預訂的所有消息都將到達單個分區，我們會在其中進行消息排序。因此，您可以創建大量分區，使您的處理高度並行化，並獲得消息排序所需的保證。</p><p>RabbitMQ中也存在此功能，它通過Consistent Hashing交換機以相同的方式在隊列上分發消息。雖然Kafka強制執行此有序處理，因為每個使用者組只有一個使用者可以使用單個分區，並且當協調器節點為您完成所有工作以確保遵守此規則時，可以輕鬆實現。而在RabbitMQ中，您仍然可以讓競爭消費者從一個“分區”隊列中消費，並且您必須完成工作以確保不會發生這種情況。</p><p>這裡還有一個問題，當你改變分區數量時，訂單Id 1000的那些消息現在轉到另一個分區，因此訂單Id 1000的消息存在於兩個分區中。根據您處理郵件的方式，這會引起頭疼。現在存在消息不按順序處理的情況。</p><p>我們將在本系列的第4部分“消息傳遞語義和保證”部分中更詳細地介紹此主題。</p><p><strong>PUSH VS PULL</strong></p><p>RabbitMQ使用推送模型，並通過消費者配置的預取限制來防止壓倒性的消費者。這對於低延遲消息傳遞非常有用，並且適用於RabbitMQ基於隊列的架構。另一方面，Kafka使用拉模型，消費者從給定的偏移量請求批量消息。當沒有超出當前偏移量的消息時，為了避免緊密循環，Kafka允許進行長輪詢。</p><p>由於其分區，拉模型對Kafka有意義。由於Kafka在沒有競爭消費者的分區中保證消息順序，我們可以利用消息批處理來實現更高效的消息傳遞，從而為我們提供更高的吞吐量。這對RabbitMQ沒有多大意義，因為理想情況下我們希望儘可能快地分配一個消息，以確保工作均勻並行處理，並且消息處理接近它們到達隊列的順序。但是對於Kafka來說，分區是並行和消息排序的單位，所以這兩個因素都不是我們關注的問題。</p><p><strong>發佈訂閱</strong></p><p>Kafka支持基本的pub sub，其中包含一些與日誌相關的額外模式，它是一個日誌並具有分區。生成器將消息附加到日誌分區的末尾，並且消費者可以在分區中的任何位置放置它們的偏移量。</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c156baaa39264aee818285d32467782c><p class=pgc-img-caption>Fig 9. Consumers with different offsets</p></div><p>當存在多個分區和使用者組時，這種風格的圖表不容易快速解釋，因此對於Kafka的其餘圖表，我將使用以下樣式：</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f509209987e44190ac407f3df8fa8c06><p class=pgc-img-caption>Fig 10. One producer, three partitions and one con</p></div><p>我們的消費者群體中沒有與分區相同數量的消費者：</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/746b9a6f40614554a61450371496da9f><p class=pgc-img-caption>Fig 11. Sone consumers read from more than one par</p></div><p>一個消費者組中的消費者將協調分區的消耗，確保一個分區不被同一個消費者組的多個消費者使用。</p><p>同樣，如果我們擁有的消費者多於分區，那麼額外的消費者將保持閒置狀態。</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb6e8d7f2f8848a0b702beaaddd7cb90><p class=pgc-img-caption>Fig 12. One idle consumer</p></div><p>添加和刪除消費者後，消費者群體可能會變得不平衡。 重新平衡會在分區中儘可能均勻地重新分配使用者。</p><div class=pgc-img><img alt="[架構選型 ]RabbitMQ vs Kafka第1部分 - 兩種不同的消息傳遞方式" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/abe736581eed47259d59f911098eea3f><p class=pgc-img-caption>Fig 13. Addition of new consumers requires rebalan</p></div><p>在以下情況之後自動觸發重新平衡：</p><ul><li>消費者加入消費者群體</li><li>消費者離開消費者群體（它關閉或被視為死亡）</li><li>添加了新分區</li></ul><p>重新平衡將導致短時間的額外延遲，同時消費者停止閱讀批量消息並分配到不同的分區。消費者維護的任何內存狀態現在都可能無效。 Kafka的消費模式之一是能夠將給定實體的所有消息（如給定的預訂）指向同一個分區，從而導致同一個消費者。這稱為數據局部性。在重新平衡任何內存中有關該數據的數據將是無用的，除非將消費者分配回同一分區。因此，維持國家的消費者需要在外部堅持下去。</p><p><strong>日誌壓縮</strong></p><p>標準數據保留策略是基於時間和空間的策略。存儲到最後一週的消息或最多50GB，例如。但是存在另一種類型的數據保留策略 - 日誌壓縮。壓縮日誌時，結果是僅保留每個消息密鑰的最新消息，其餘消息將被刪除。</p><p>讓我們假設我們收到一條消息，其中包含用戶預訂的當前狀態。每次更改預訂時，都會根據預訂的當前狀態生成新事件。該主題可能包含一些預訂的消息，這些消息表示自創建以來預訂的狀態。在主題被壓縮之後，將僅保留與該預訂相關的最新消息。</p><p>根據預訂量和每次預訂的大小，理論上可以將所有預訂永久存儲在主題中。通過定期壓縮主題，我們確保每個預訂只存儲一條消息。</p><p>日誌壓縮可以實現一些不同的模式，我們將在第3部分中探討。</p><p><strong>有關消息排序的更多信息</strong></p><p>我們已經討論過，RabbitMQ和Kafka都可以擴展和維護消息排序，但是Kafka使它變得容易多了。使用RabbitMQ，我們必須使用Consistent Hashing Exchange並使用像ZooKeeper或Consul這樣的分佈式共識服務自己手動實現使用者組邏輯。</p><p>但RabbitMQ有一個有趣的功能，卡夫卡沒有。 RabbitMQ本身並不特別，但任何基於發佈 - 訂閱隊列的消息傳遞系統。能力是這樣的：基於隊列的消息系統允許訂戶訂購任意事件組。</p><p>讓我們再深入瞭解一下。不同的應用程序無法共享隊列，因為它們會競爭使用消息。他們需要自己的隊列。這使應用程序可以自由地配置他們認為合適的隊列。他們可以將多個主題中的多個事件類型路由到其隊列中。這允許應用程序維護相關事件的順序。它想要組合的事件可以針對每個應用程序進行不同的配置。</p><p>使用像Kafka這樣的基於日誌的消息傳遞系統是不可能的，因為日誌是共享資源。多個應用程序從同一日誌中讀取。因此，將相關事件分組到單個主題中是在更廣泛的系統架構級別做出的決策。</p><p>所以這裡沒有勝利者。 RabbitMQ允許您維護任意事件集的相對排序，Kafka提供了一種維持大規模排序的簡單方法。</p><p>更新：我已經構建了一個名為Rebalanser的庫，它為RabbitMQ for .NET應用程序提供了使用者組邏輯。查看它上面的帖子和GitHub repo。如果人們表現出任何興趣，那麼我就會用其他語言製作版本。讓我知道。</p><h1>結論</h1><p>RabbitMQ由於其提供的各種功能，提供了瑞士軍刀的消息模式。憑藉其強大的路由功能，它可以消除消費者在只需要一個子集時檢索，反序列化和檢查每條消息的需要。它易於使用，通過簡單地添加和刪除消費者來完成擴展和縮小。它的插件架構允許它支持其他協議並添加新功能，例如Consistent散列交換，這是一個重要的補充。</p><p>卡夫卡的分佈式日誌與消費者抵消使得時間旅行成為可能。它能夠將相同密鑰的消息按順序路由到同一個消費者，從而實現高度並行化的有序處理。 Kafka的日誌壓縮和數據保留允許RabbitMQ無法提供的新模式。最後是的，Kafka可以比RabbitMQ進一步擴展，但是我們大多數人都處理一個可以輕鬆處理的消息量。</p><p>在下一部分中，我們將使用RabbitMQ仔細研究消息傳遞模式和拓撲。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>架構</a></li><li><a>選型</a></li><li><a>RabbitMQ</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/4381e5d0.html alt=數據架構選型必讀：4月數據庫產品技術解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/R6OpXljEQ3D1Yz style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4381e5d0.html title=數據架構選型必讀：4月數據庫產品技術解析>數據架構選型必讀：4月數據庫產品技術解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html alt=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0670cbc9828449c782ac323a238b99e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html title=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效>朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html alt=活動文件櫃的架構是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/104d3629a97947b19d62b03dc3b8d82f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html title=活動文件櫃的架構是什麼>活動文件櫃的架構是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb03cd29.html alt=氧氣傳感器的選型目錄 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2186a708231b414483e05aa2ee2c80fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb03cd29.html title=氧氣傳感器的選型目錄>氧氣傳感器的選型目錄</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a8fcb28.html alt=溶氧儀的分類及選型指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1ca64e1e97b4f159a9813463fc769d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a8fcb28.html title=溶氧儀的分類及選型指南>溶氧儀的分類及選型指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html alt=九年新浪架構師整理PHP架構核心技術教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b3a3c32254344742b6746996f7fab54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html title=九年新浪架構師整理PHP架構核心技術教程>九年新浪架構師整理PHP架構核心技術教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be38071c.html alt=溫度傳感器選型技巧：如何選擇熱電阻和熱電偶傳感器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8530c0cd8cac44fca052d478338aa348 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be38071c.html title=溫度傳感器選型技巧：如何選擇熱電阻和熱電偶傳感器>溫度傳感器選型技巧：如何選擇熱電阻和熱電偶傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html alt=Kafka整體架構圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/05ae540358854cb3ba0aa4577709330d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html title=Kafka整體架構圖解>Kafka整體架構圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html alt=MyBatis整體架構分析：基礎支持層、核心處理層和接口層 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d6a0b300b114d07b2f3fe66d7ef7005 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html title=MyBatis整體架構分析：基礎支持層、核心處理層和接口層>MyBatis整體架構分析：基礎支持層、核心處理層和接口層</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html alt=K8S整體架構解析，簡單明瞭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/37380f3294a54bbf8c6bec1de3e08ba0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html title=K8S整體架構解析，簡單明瞭>K8S整體架構解析，簡單明瞭</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html alt=支付系統：整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1d94fa40459462fa825d407a1904c7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html title=支付系統：整體架構>支付系統：整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html alt=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bd78fffbaaf54bd79c6e463d5b69ed9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html title=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？>「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html alt=微服務分佈式架構中，如何實現日誌鏈路跟蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3a2cecaee304124a86a864a75c38b5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html title=微服務分佈式架構中，如何實現日誌鏈路跟蹤？>微服務分佈式架構中，如何實現日誌鏈路跟蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/64601dfa.html alt=自控工程設計：膜片壓力錶與隔膜壓力錶的原理和選型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5eba28ddcb3e400c9f981750bfda67b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/64601dfa.html title=自控工程設計：膜片壓力錶與隔膜壓力錶的原理和選型>自控工程設計：膜片壓力錶與隔膜壓力錶的原理和選型</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>