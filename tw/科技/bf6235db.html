<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java 代碼自動生成器 auto-code | 极客快訊</title><meta property="og:title" content="Java 代碼自動生成器 auto-code - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d60ae1d716bd4e22babd7a068ccc3577"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><meta property="article:published_time" content="2020-11-14T20:55:22+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:22+08:00"><meta name=Keywords content><meta name=description content="Java 代碼自動生成器 auto-code"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/bf6235db.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java 代碼自動生成器 auto-code</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>auto-code</h1><p>歡迎使用auto-code代碼自動生成引擎, 2.0重大升級.支持單表, 一對一, 一對多 ,多對多代碼生成 源碼地址</p><div class=pgc-img><img alt="Java 代碼自動生成器 auto-code" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d60ae1d716bd4e22babd7a068ccc3577><p class=pgc-img-caption></p></div><p>項目介紹</p><p>項目的優勢在哪裡</p><blockquote><p>1.目前市面上的代碼生成工具絕大多數僅僅支持生成單表,該項目支持 單表, 一對一, 一對多 ,多對多 代碼生成.大大簡化了開發的工作量</p><p>2.只要目前你的項目採用 springMVC+spring+mybatis架構的項目都適用(傳統工程和springBoot工程都適用). 不管一次開發還是二次開發.該項目僅僅只是幫你生成單表以及多表的增刪改查,不做任何底層的改動.</p></blockquote><p>什麼情況選擇該項目</p><blockquote><p>1.該項目只生成接口(controller,service,serviceImpl,dao,xml), 不生成頁面.所以如果項目是採用前後臺分離,不需要寫頁面.該項目會適合你</p><p>2.如果還想生成頁面請看該項目,這個項目基於本項目.擴展了頁面生成.適合後臺使用 源碼地址 演示地址 賬號 ztp 密碼 111111</p></blockquote><p>為何會發起該項目?</p><blockquote><p>絕大多數時候我們都是在做增刪改查.每次創建一張表.然後我們需要重新寫一次增刪改查, 寫雖然簡單,不過極度耗時(controller,server,serverImpl,dao,xml) 所以才有了該項目,該項目能幫助你減少70%的工作量,讓你專注於業務的實現.</p></blockquote><p>項目地址</p><div class=pgc-img><img alt="Java 代碼自動生成器 auto-code" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01e824540f3b487e8bfc0ee035d2ba5b><p class=pgc-img-caption></p></div><p>集成教程</p><blockquote><p>集成非常簡單,只需要在自己的web工程或者spring-boot工程引入jar包即可. 請在pom寫上</p></blockquote><pre> &lt;dependency&gt; &lt;groupId&gt;com.zengtengpeng&lt;/groupId&gt; &lt;artifactId&gt;auto-code&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt;</pre><p>使用教程</p><p>準備工作</p><blockquote><p>1 首先先準備數據庫(理論上支持所有關係型數據庫,目前只做了mysql的測試)</p><p>2 創建數據庫 auto_code (可以隨意取名稱,只要和下面yaml裡面的數據庫名稱對應上就行)</p><p>3 準備完畢,開始進入正題</p></blockquote><p>單表生成</p><blockquote><p>假設我們要生成一張單表</p></blockquote><pre>CREATE TABLE `test_code` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '測試生成代碼', `name` varchar(50) DEFAULT NULL COMMENT '名稱', `age` int(3) DEFAULT NULL COMMENT '年齡', `status` int(2) DEFAULT NULL COMMENT '{"name":"狀態","1":"啟用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '備註', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '創建時間', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='測試生成代碼';</pre><blockquote><p>1.先在資源根路徑(src/main/resources)創建 auto-code_simple.yaml 文件,具體內容如下</p></blockquote><pre>datasourceConfig: #驅動名稱 driverClassName: com.mysql.jdbc.Driver #數據庫名稱 name: auto_code #jdbc鏈接 url: jdbc:mysql://127.0.0.1:3306/auto_code #數據庫用戶名 username: root #數據庫密碼 password: 111111globalConfig: #數據庫表配置 tableNames: #表名稱 - dataName: test_code #別名 不寫默認採用駝峰命名法 test_code-&gt;TestCode# aliasName: SysLoginLog #如果用多張表,請按照如下寫法,繼續往下寫.# - dataName: test_code2# aliasName: DDDDDDD #生成代碼的項目路徑 parentPath: f:/core #生成代碼的父包 如父包是com.zengtengpeng.test controller將在com.zengtengpeng.test.controller下 bean 將在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆蓋生成文件 如果為true將會把以前的文件覆蓋掉 cover: false #xml存放的文件夾默認 mybatisMapper xmlPath: mybatisMapper</pre><blockquote><p>2.執行代碼生成語句</p></blockquote><pre>import com.zengtengpeng.autoCode.StartCode;public class Demo1simple { public static void main(String[] args) { //lambda表達式寫法 二選一 StartCode startCode=t-&gt;{}; //普通寫法 二選一// StartCode startCode=new StartCode() {// @Override// public void custom(AutoCodeConfig autoCodeConfig) {//// }// }; startCode.start(StartCode.saxYaml("auto-code_simple.yaml")); }}</pre><blockquote><p>3.生成完畢 主要生成六個接口</p></blockquote><pre>//根據id刪除記錄deleteByPrimaryKey//保存(主鍵為空則增加 否則 修改)save //根據主鍵查詢selectByPrimaryKey//根據條件查詢(所有的實體屬性都是條件,如果為空則忽略該字段)selectByCondition//分頁查詢 (所有的實體屬性都是條件,如果為空則忽略該字段) 詳見Page類.所以的實體都繼承該類 默認page=1 pageSize=10selectAllByPaging//導出excelexport</pre><p>生成的文件如下:</p><div class=pgc-img><img alt="Java 代碼自動生成器 auto-code" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cd2d3104444d471da3c162e612320fdf><p class=pgc-img-caption></p></div><p>一對一代碼生成 one-to-one (代碼採用追加的方式.無需擔心代碼被覆蓋)</p><blockquote><p>假如 一個用戶 test_user 一個用戶 對應 test_class 一個班級</p></blockquote><pre> CREATE TABLE `test_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(50) DEFAULT NULL COMMENT '名稱', `age` int(3) DEFAULT NULL COMMENT '年齡', `status` int(2) DEFAULT NULL COMMENT '{"name":"狀態","1":"啟用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '備註', `mun` decimal(20,2) DEFAULT NULL COMMENT '數字', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '創建時間', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新時間', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='測試用戶'; CREATE TABLE `test_class` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '班級id', `user_id` int(11) DEFAULT NULL COMMENT '用戶id', `class_name` varchar(50) DEFAULT NULL COMMENT '班級名稱', `quantity` int(11) DEFAULT NULL COMMENT '班級人數', `create_time` datetime DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='班級'</pre><blockquote><p>1.同理先在 資源根路徑(src/main/resources)創建 auto-code_one-to-one.yaml 文件(名字隨意定默認使用 auto-code.yaml),具體內容如下</p></blockquote><pre>請注意relationConfig這裡描述的是關係配置, 注意generate和existParentPackage字段.如果該表已經生成了.請將 generate置為 false 同時填寫 existParentPackage 該表所對應的父包(一對多,多對多有實例)datasourceConfig: #驅動名稱 driverClassName: com.mysql.jdbc.Driver #數據庫名稱 name: auto_code #jdbc鏈接 url: jdbc:mysql://127.0.0.1:3306/auto_code #數據庫用戶名 username: root #數據庫密碼 password: 111111globalConfig: #生成代碼的項目路徑 parentPath: E:\resource\workspaceJDB\auto-code-springboot-demo #生成代碼的父包 如父包是com.zengtengpeng.test controller將在com.zengtengpeng.test.controller下 bean 將在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆蓋生成文件 如果為true將會把以前的文件覆蓋掉 cover: false #xml存放的文件夾默認 mybatisMapper xmlPath: mybatisMapper # 表關係配置 一對一 一對多 多對多 代碼生成 採用追加的方式 relationConfig: #主表 primary: #數據庫表名 dataName: test_user #別名: 如果不設置將採用駝峰命名法 test_user=TestUser beanName: User #主鍵名稱 primaryKey: id #是否生成單表代碼# generate: false#如果單表代碼已經生成,請填寫代碼的父包,沒有則generate置為true 如 com.zengtengpeng.test.bean.TestUser 請填寫 com.zengtengpeng.test# existParentPackage: com.zengtengpeng.test #備註 remark: "用戶" #外表 foreign: #數據庫表名 dataName: test_class #別名: 如果不設置將採用駝峰命名法 test_user=TestUser beanName: Clazz #外鍵名稱 就是已哪個字段和主表關聯 填寫數據庫字段名稱 foreignKey: user_id #是否生成單表代碼# generate: false#如果單表代碼已經生成,請填寫代碼的父包,沒有則generate置為true 如 com.zengtengpeng.test.bean.TestUser 請填寫 com.zengtengpeng.test# existParentPackage: com.zengtengpeng.test #備註 remark: "班級"</pre><blockquote><p>2.執行代碼</p></blockquote><pre>import com.zengtengpeng.autoCode.StartCode;import com.zengtengpeng.autoCode.config.AutoCodeConfig;import com.zengtengpeng.relation.oneToOne.BuildOneToOne;import com.zengtengpeng.relation.utils.RelationUtils;import com.zengtengpeng.autoCode.StartCode;import com.zengtengpeng.relation.utils.RelationUtils;public class Demo2OneToOne { public static void main(String[] args) { //普通寫法// RelationUtils.oneToOne(StartCode.saxYaml(), new StartCode() {// @Override// public void custom(AutoCodeConfig autoCodeConfig) {// }// }, new BuildOneToOne() {// @Override// public void custom(AutoCodeConfig autoCodeConfig) {// }// }); //lambda表達式寫法 二選一 RelationUtils.oneToOne(StartCode.saxYaml("auto-code_one-to-one.yaml"), t-&gt;{}, rt -&gt; {}); }}</pre><ul><li>生成完畢 一對多會在單表的基礎上再增加6個接口(採用追加代碼的方式,不用擔心代碼覆蓋問題) 主表3個 外表3個 ClazzController 新增</li></ul><pre> /** * 級聯查詢(帶分頁) 用戶--班級 */ @ResponseBody @RequestMapping("clazz/selectUserAndClazz") public DataRes selectUserAndClazz(Clazz clazz,HttpServletRequest request,HttpServletResponse response){ return DataRes.success(clazzService.selectUserAndClazz(clazz)); } /** 	 * 級聯條件查詢 用戶--班級 	 */ 	@ResponseBody 	@RequestMapping("clazz/selectUserAndClazzByCondition") 	public DataRes selectUserAndClazzByCondition(Clazz clazz,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(clazzService.selectUserAndClazzByCondition(clazz)); 	} 	/** 	 * 級聯刪除(根據主鍵刪除) 用戶--班級 	 */ 	@ResponseBody 	@RequestMapping("clazz/deleteUserAndClazz") 	public DataRes deleteUserAndClazz(Clazz clazz,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(clazzService.deleteUserAndClazz(clazz)); 	}</pre><p>UserController 增加</p><pre> /** 	 * 級聯查詢(帶分頁) 用戶--班級 	 */ 	@ResponseBody 	@RequestMapping("user/selectUserAndClazz") 	public DataRes selectUserAndClazz(User user,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(userService.selectUserAndClazz(user)); 	}   	/** 	 * 級聯條件查詢 用戶--班級 	 */ 	@ResponseBody 	@RequestMapping("user/selectUserAndClazzByCondition") 	public DataRes selectUserAndClazzByCondition(User user,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(userService.selectUserAndClazzByCondition(user)); 	}   	/** 	 * 級聯刪除(根據主鍵刪除) 用戶--班級 	 */ 	@ResponseBody 	@RequestMapping("user/deleteUserAndClazz") 	public DataRes deleteUserAndClazz(User user,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(userService.deleteUserAndClazz(user)); 	}</pre><p>生成的文件如下</p><div class=pgc-img><img alt="Java 代碼自動生成器 auto-code" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5f6373752c34e8cadb16453fc75c025><p class=pgc-img-caption></p></div><p>一對多 代碼生成 one-to-Many (代碼採用追加的方式.無需擔心代碼被覆蓋)</p><blockquote><p>假如 test_user 一個用戶 對應 test_addr 多個收貨地址</p></blockquote><pre> CREATE TABLE `test_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(50) DEFAULT NULL COMMENT '名稱', `age` int(3) DEFAULT NULL COMMENT '年齡', `status` int(2) DEFAULT NULL COMMENT '{"name":"狀態","1":"啟用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '備註', `mun` decimal(20,2) DEFAULT NULL COMMENT '數字', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '創建時間', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新時間', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='測試用戶'; CREATE TABLE `test_addr` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用戶收貨地址id', `user_id` int(11) DEFAULT NULL COMMENT '用戶id', `addr_name` varchar(10) DEFAULT NULL COMMENT '姓名', `phone` varchar(30) DEFAULT NULL COMMENT '手機號碼', `addr` varchar(30) DEFAULT NULL COMMENT '收貨地址', `status` int(11) DEFAULT NULL COMMENT '{"name":"狀態","1":"啟用","2":"刪除"}', `create_time` datetime DEFAULT NULL COMMENT '創建時間', `update_time` datetime DEFAULT NULL COMMENT '更新時間', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='用戶收貨地址'</pre><blockquote><p>1.同理先在 資源根路徑(src/main/resources)創建 auto-code_one-to-many.yaml 文件,具體內容如下</p></blockquote><pre>由於TestUser已經在一對一生成過代碼了.所以 generate: false同時寫上已經存在的父包 existParentPackage: com.zengtengpeng.test datasourceConfig: #驅動名稱 driverClassName: com.mysql.jdbc.Driver #數據庫名稱 name: auto_code #jdbc鏈接 url: jdbc:mysql://127.0.0.1:3306/auto_code #數據庫用戶名 username: root #數據庫密碼 password: 111111 globalConfig: #生成代碼的項目路徑 parentPath: E:\resource\workspaceJDB\auto-code-springboot-demo #生成代碼的父包 如父包是com.zengtengpeng.test controller將在com.zengtengpeng.test.controller下 bean 將在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆蓋生成文件 如果為true將會把以前的文件覆蓋掉 cover: false #xml存放的文件夾默認 mybatisMapper xmlPath: mybatisMapper # 表關係配置 一對一 一對多 多對多 代碼生成 採用追加的方式 relationConfig: #主表 primary: #數據庫表名 dataName: test_user #別名: 如果不設置將採用駝峰命名法 test_user=TestUser beanName: User #主鍵名稱 primaryKey: id #是否生成單表代碼 generate: false #如果單表代碼已經生成,請填寫代碼的父包,沒有則不填寫 如 com.zengtengpeng.test.bean.TestUser 請填寫 com.zengtengpeng.test existParentPackage: com.zengtengpeng.test #備註 remark: "用戶" #外表 foreign: #數據庫表名 dataName: test_addr #別名: 如果不設置將採用駝峰命名法 test_user=TestUser beanName: Addr #外鍵名稱 就是已哪個字段和主表關聯 填寫數據庫字段名 foreignKey: user_id #是否生成單表代碼 默認是true # generate: true #如果單表代碼已經生成,請填寫代碼的父包,沒有則不填寫 如 com.zengtengpeng.test.bean.TestUser 請填寫 com.zengtengpeng.test # existParentPackage: com.zengtengpeng.test #備註 remark: "收貨地址" </pre><blockquote><p>2.執行生成代碼</p></blockquote><pre> import com.zengtengpeng.autoCode.StartCode; import com.zengtengpeng.relation.utils.RelationUtils; /** * 一對多生成實例 test_user 一個用戶 對應 test_addr 多個收貨地址 */ public class Demo3OneToMany { public static void main(String[] args) { //普通寫法 二選一 // RelationUtils.oneToMany(StartCode.saxYaml(), new StartCode() { // @Override // public void custom(AutoCodeConfig autoCodeConfig) { // // } // }, new BuildOneToMany() { // @Override // public void custom(AutoCodeConfig autoCodeConfig) { // // } // }); //lambda表達式寫法 二選一 RelationUtils.oneToMany(StartCode.saxYaml("auto-code_one-to-many.yaml"), t -&gt; {}, rt -&gt; {}); } }</pre><blockquote><p>3.生成完畢 接口和一對一一樣</p></blockquote><p>多對多 代碼生成 many-to-many (代碼採用追加的方式.無需擔心代碼被覆蓋)</p><blockquote><p>假如 test_user 多個用戶 對應 test_role 多個角色</p></blockquote><pre> CREATE TABLE `test_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(50) DEFAULT NULL COMMENT '名稱', `age` int(3) DEFAULT NULL COMMENT '年齡', `status` int(2) DEFAULT NULL COMMENT '{"name":"狀態","1":"啟用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '備註', `mun` decimal(20,2) DEFAULT NULL COMMENT '數字', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '創建時間', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新時間', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='測試用戶'; CREATE TABLE `test_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '測試角色', `name` varchar(100) NOT NULL COMMENT '角色名稱', `status` int(2) DEFAULT '0' COMMENT '{"name":"狀態","0":"啟用","1":"禁用"}', `create_user_id` int(11) DEFAULT NULL COMMENT '創建者', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '創建時間', `update_user_id` int(11) DEFAULT NULL COMMENT '更新者', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新時間', `dels` int(2) DEFAULT '0' COMMENT '{"name":"是否刪除","0":"正常","1":"刪除"}', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COMMENT='測試角色';  CREATE TABLE `test_user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用戶角色關係表', `user_id` int(11) DEFAULT NULL COMMENT '用戶id', `role_id` int(11) DEFAULT NULL COMMENT '角色id', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '創建時間', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8 COMMENT='測試用戶角色';</pre><blockquote><p>1.同理先在 資源根路徑(src/main/resources)創建 auto-code.yaml 文件,具體內容如下</p></blockquote><pre> 1.由於TestUser已經在一對一生成過代碼了.所以 generate: false 同時寫上 TestUser存在的父包 existParentPackage: com.zengtengpeng.test 2.注意多對多的外表的 foreignKey 同樣是該表的主鍵 3.thirdparty為多對多的第三表primaryKey對應主表(primary)的primaryKey.  foreignKey對應外表(foreign)的foreignKey datasourceConfig: #驅動名稱 driverClassName: com.mysql.jdbc.Driver #數據庫名稱 name: auto_code #jdbc鏈接 url: jdbc:mysql://127.0.0.1:3306/auto_code #數據庫用戶名 username: root #數據庫密碼 password: 111111 globalConfig: #生成代碼的項目路徑 parentPath: E:\resource\workspaceJDB\auto-code-springboot-demo #生成代碼的父包 如父包是com.zengtengpeng.test controller將在com.zengtengpeng.test.controller下 bean 將在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆蓋生成文件 如果為true將會把以前的文件覆蓋掉 cover: false #xml存放的文件夾默認 mybatisMapper xmlPath: mybatisMapper # 表關係配置 一對一 一對多 多對多 代碼生成 採用追加的方式 relationConfig: #主表 primary: #數據庫表名 dataName: test_user #別名: 如果不設置將採用駝峰命名法 test_user=TestUser beanName: User #主鍵名稱 primaryKey: id #是否生成 單表 代碼 generate: false #如果單表代碼已經生成,請填寫代碼的父包 如 com.zengtengpeng.test.bean.TestUser 請填寫 com.zengtengpeng.test existParentPackage: com.zengtengpeng.test #備註 remark: "用戶" #外表 foreign: #數據庫表名 dataName: test_role #別名: 如果不設置將採用駝峰命名法 test_user=TestUser beanName: Role #外鍵名稱 就是已哪個字段和主表關聯 填寫數據庫字段名 foreignKey: id #備註 remark: "角色" #第三表 -當生成多對多代碼時該參數必填.否則會忽略該參數 thirdparty: #數據庫表名 dataName: test_user_role #主鍵名稱 該字段將和主表關聯起來 primaryKey: user_id #外鍵名稱 該字段將和外表配置關聯起來 foreignKey: role_id #備註 remark: "用戶角色"</pre><blockquote><p>2 .執行代碼</p></blockquote><pre>import com.zengtengpeng.autoCode.StartCode;import com.zengtengpeng.relation.utils.RelationUtils;/** * 多對多生成實例 test_user 多個用戶 對應 test_role 多個角色 */public class Demo4ManyToMany { public static void main(String[] args) { //普通寫法 /*RelationUtils.manyToMany(StartCode.saxYaml(), new StartCode() { @Override public void custom(AutoCodeConfig autoCodeConfig) { } }, new BuildManyToMany() { @Override public void custom(AutoCodeConfig autoCodeConfig) { } });*/ //lambda表達式寫法 二選一 RelationUtils.manyToMany(StartCode.saxYaml("auto-code_many-to-many.yaml"), t-&gt;{}, rt -&gt; {}); }}</pre><blockquote><p>3.生成完畢 接口在一對一的基礎上增加了2個方法 主表</p></blockquote><pre>//根據外表id查詢主表表所有數據(帶分頁)@RequestMapping("testUs/selectTestUsByTestRo")	@ResponseBody	public DataRes selectTestUsByTestRo(HttpServletRequest request,HttpServletResponse response,TestUs testUs){		return DataRes.success(testUsService.selectTestUsByTestRo(testUs));	}</pre><p>外表</p><pre> /** 	 * 根據主表id查詢外表所有數據(帶分頁) 	 */ 	@Auth("testRo/selectAllByPaging") 	@RequestMapping("testRo/selectTestRoByTestUs") 	@ResponseBody 	public DataRes selectTestRoByTestUs(HttpServletRequest request,HttpServletResponse response,TestRo testRo){ 		return DataRes.success(testRoService.selectTestRoByTestUs(testRo)); 	}</pre><p>生成代碼注意事項</p><pre>1.創建表結構時如果寫上表與字段的註釋將大大增加程序的可讀性.我會將註釋寫到bean上面.2.配置文件 auto-code.yaml名稱隨意定.默認使用 auto-code.yaml 當使用 auto-code.yaml時StartCode.saxYaml("auto-code_many-to-many.yaml") 可以直接寫成 StartCode.saxYaml().4.如果註釋為json鍵值對字符串我將會在實體類生成一個字典方法如: {"1":"啟用","0":"禁用"} 將會在實體類裡面生成: public String getStatus_(){		if(MyStringUtils.isEmpty(status)){			 return "";		}else if(status.equals("1")){			return "啟用";		}else if(status.equals("0")){			return "禁用";		}		return "";	}</pre><p>spring-boot如何使用 實例地址</p><blockquote><p>1.集成mybatis-spring-boot-starter,spring-boot-starter-web 這裡就不再闡述</p><p>2.由於分頁插件使用了 pageHelper 所以需要集成下,不集成將導致分頁失效,集成非常簡單 官方SpringBoot集成地址</p></blockquote><pre>1.加入pom.xml jar包&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt;&lt;/dependency&gt;2.在application.properties加入配置#pagehelper插件#logging.level.com.example.demo.dao=DEBUGpagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSqlpagehelper.page-size-zero=true3.至此集成完畢</pre><p>java-web 實例地址</p><blockquote><p>由於分頁插件使用了 pageHelper 所以需要集成下,不集成將導致分頁失效 官方傳統web工程集成地址</p></blockquote><pre>1.由於工程中以及引入pageHelper的jar包所以直接在MyBatis-Configuration.xml中加入&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;/plugin&gt;&lt;/plugins&gt;2.集成完畢</pre><p>進階篇 如何自定義方法 代碼地址</p><p>單表如何自定義</p><blockquote><p>在 com.zengtengpeng.autoCode.create包下,有6個接口類 BuildBean,BuildController,BuildDao,BuildService,BuildServiceImpl,BuildXml.每個接口底下都有個未實現的 custom 方法. 實現custom就可以,如下代碼就是自定義Controller代碼,其他的接口同理</p></blockquote><pre>import com.zengtengpeng.autoCode.bean.BuildJavaField;import com.zengtengpeng.autoCode.bean.BuildJavaMethod; import com.zengtengpeng.autoCode.config.AutoCodeConfig;import com.zengtengpeng.autoCode.config.BuildJavaConfig;import com.zengtengpeng.autoCode.create.BuildController;import java.util.ArrayList;import java.util.List;/** * 重寫controller 自定義配置 */public class TestBuildController implements BuildController { @Override public BuildJavaConfig custom(AutoCodeConfig autoCodeConfig) { BuildJavaConfig buildJavaConfig=new BuildJavaConfig(); List&lt;String&gt; imports=new ArrayList&lt;&gt;(); imports.add("java.util.HashMap"); imports.add("java.util.Hashtable"); imports.add("java.util.Collections"); //自定義需要導入的類 buildJavaConfig.setImports(imports); List&lt;BuildJavaMethod&gt; methods=new ArrayList&lt;&gt;(); BuildJavaMethod method=new BuildJavaMethod(); method.setContent("\nSystem.out.println(\"生成完畢\");"); method.setMethodName("test"); method.setMethodType("public"); method.setReturnType("void"); List&lt;String&gt; params=new ArrayList&lt;&gt;(); params.add("String test"); method.setParams(params); method.setRemark("測試生成方法"); List&lt;String&gt; ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); method.setAnnotation(ann); methods.add(method); //自定義方法 將在類生成如下方法 //@SuppressWarnings("") //	public void test(String test){ // //System.out.println("生成完畢"); //	} buildJavaConfig.setBuildJavaMethods(methods); List&lt;BuildJavaField&gt; fileds=new ArrayList&lt;&gt;(); BuildJavaField jf=new BuildJavaField(); jf.setFiledType("private"); jf.setReturnType("String"); jf.setFiledName("test"); jf.setRemark("測試生成字段"); jf.setInit("\"初始化字段\""); ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); jf.setAnnotation(ann); fileds.add(jf); //自定義字段 將在類生成如下字段 //@SuppressWarnings("") //	private String test ="初始化字段"; buildJavaConfig.setBuildJavaFields(fileds); //自定義繼承 類單繼承 接口多繼承 List&lt;String&gt; ex=new ArrayList&lt;&gt;(); ex.add("Object"); buildJavaConfig.setExtend(ex); //自定義 實現 類多實現, 接口沒有實現// buildJavaConfig.setImplement(null); return buildJavaConfig; }}</pre><blockquote><p>StartCode 為生成單表的總開關,裡面有 BuildBean,BuildController,BuildDao,BuildService, BuildServiceImpl,BuildXml 幾個接口的默認實現.如需自定義,重寫默認實現的方法.</p></blockquote><pre>/** * 自定義單表方法 */public class CustomSimple { public static void main(String[] args) { StartCode startCode=new StartCode() { @Override public void custom(AutoCodeConfig autoCodeConfig) { }  @Override public BuildController BuildController() { //自定義Controller方法 return new TestBuildController(); } }; startCode.start(StartCode.saxYaml("auto-code_simple.yaml")); }}</pre><p>表關係自定義</p><blockquote><p>表關係在單表的基礎上擴展了 主表,外表 代碼在 com.zengtengpeng.relation 下的 manyToMany(多對多),oneToMany(一對多),oneToOne(一對一)子包,每個子包有六個生成類的接口.重寫也是只需要實現對應的接口的 custom 方法就行.下面舉例重寫一對一的controller方法</p></blockquote><pre>import com.zengtengpeng.autoCode.bean.BuildJavaField;import com.zengtengpeng.autoCode.bean.BuildJavaMethod;import com.zengtengpeng.autoCode.config.AutoCodeConfig;import com.zengtengpeng.autoCode.config.BuildJavaConfig;import com.zengtengpeng.relation.oneToOne.BuildOneToOneController;import java.util.ArrayList;import java.util.List;/** * 自定義one-to-one controller */public class TestBuildOneToOneController implements BuildOneToOneController { @Override public void custom(AutoCodeConfig autoCodeConfig, BuildJavaConfig primaryBuildJavaConfig, BuildJavaConfig foreignBuildJavaConfig) { List&lt;String&gt; imports=new ArrayList&lt;&gt;(); imports.add("java.util.HashMap"); imports.add("java.util.Hashtable"); imports.add("java.util.Collections"); //自定義需要導入的類 primaryBuildJavaConfig.setImports(imports); List&lt;BuildJavaMethod&gt; methods=new ArrayList&lt;&gt;(); BuildJavaMethod method=new BuildJavaMethod(); method.setContent("\nSystem.out.println(\"生成完畢\");"); method.setMethodName("test"); method.setMethodType("public"); method.setReturnType("void"); List&lt;String&gt; params=new ArrayList&lt;&gt;(); params.add("String test"); method.setParams(params); method.setRemark("測試生成方法"); List&lt;String&gt; ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); method.setAnnotation(ann); methods.add(method); //自定義方法 將在類生成如下方法 //@SuppressWarnings("") //	public void test(String test){ // //System.out.println("生成完畢"); //	} primaryBuildJavaConfig.setBuildJavaMethods(methods); List&lt;BuildJavaField&gt; fileds=new ArrayList&lt;&gt;(); BuildJavaField jf=new BuildJavaField(); jf.setFiledType("private"); jf.setReturnType("String"); jf.setFiledName("test"); jf.setRemark("測試生成字段"); jf.setInit("\"初始化字段\""); ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); jf.setAnnotation(ann); fileds.add(jf); //自定義字段 將在類生成如下字段 //@SuppressWarnings("") //	private String test ="初始化字段"; primaryBuildJavaConfig.setBuildJavaFields(fileds); //自定義繼承 類單繼承 接口多繼承 List&lt;String&gt; ex=new ArrayList&lt;&gt;(); ex.add("Object"); primaryBuildJavaConfig.setExtend(ex); }}</pre><blockquote><p>BuildManyToMany(構建多對多),BuildOneToMany(構建一對多),BuildOneToOne(構建一對一) 是各個表關係實現的總開關. 裡面有 Build...Controller Build...Bean 等六個相關接口的具體實現.我們也是隻要重寫對應的方法就行 如下重寫一對一的controller.只需要重寫 BuildOneToOne下的 buildOneToOneController具體實現即可.其他的同理</p></blockquote><pre> import com.zengtengpeng.autoCode.StartCode; import com.zengtengpeng.autoCode.config.AutoCodeConfig; import com.zengtengpeng.demo.test.TestBuildOneToOneController; import com.zengtengpeng.relation.oneToOne.BuildOneToOne; import com.zengtengpeng.relation.oneToOne.BuildOneToOneController; import com.zengtengpeng.relation.utils.RelationUtils;  /** * 多表自定義 */ public class CustomRelation { public static void main(String[] args) { //如果單表想要自定義請參見 CustomSimple 類. 裡面是如果定義單表的 StartCode startCode = t -&gt; { };  //多表自定義 BuildOneToOne buildOneToOne = new BuildOneToOne() { @Override public void custom(AutoCodeConfig autoCodeConfig) {  } @Override public BuildOneToOneController buildOneToOneController() { //Controller autoCodeConfig 全局配置 primaryBuildJavaConfig主表的自定義配置 foreignBuildJavaConfig 外表的自定義配置 return new TestBuildOneToOneController(); } }; RelationUtils.oneToOne(StartCode.saxYaml("auto-code_one-to-one.yaml"), startCode, buildOneToOne); } }</pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>生成器</a></li><li><a>Java</a></li><li><a>代碼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef985079.html alt="Java 通用代碼生成器光 1.5.0 Kama (頓悟)發佈，內含開發者手冊" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/00f13030-6d86-4a2f-9ba4-698b919cf0fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef985079.html title="Java 通用代碼生成器光 1.5.0 Kama (頓悟)發佈，內含開發者手冊">Java 通用代碼生成器光 1.5.0 Kama (頓悟)發佈，內含開發者手冊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42068cfe.html alt="代碼生成器 code-builder" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d87b11fca7a4a0b86f7d59932d55bdd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42068cfe.html title="代碼生成器 code-builder">代碼生成器 code-builder</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af0de2ce.html alt="Java Web 模板代碼生成器的設計與實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b963f9c3758447ad9436b6c3928a66ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af0de2ce.html title="Java Web 模板代碼生成器的設計與實現">Java Web 模板代碼生成器的設計與實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ff82fcd.html alt=如何寫一個Java代碼生成器讓自己解脫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/780859caf3a14eb7bf080330ef0f287c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ff82fcd.html title=如何寫一個Java代碼生成器讓自己解脫>如何寫一個Java代碼生成器讓自己解脫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34650943.html alt=bee智能化代碼生成器，一分鐘實現前後端系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/779a3c6870034b71878df2d929b8a51e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34650943.html title=bee智能化代碼生成器，一分鐘實現前後端系統>bee智能化代碼生成器，一分鐘實現前後端系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fdd891c7.html alt=代碼生成器的簡單思路（java） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fdd891c7.html title=代碼生成器的簡單思路（java）>代碼生成器的簡單思路（java）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52beafc2.html alt=基於SpringCloud的代碼生成器「附源碼+文檔+視頻」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/37c6b060-ec35-447d-8e35-572e425882d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52beafc2.html title=基於SpringCloud的代碼生成器「附源碼+文檔+視頻」>基於SpringCloud的代碼生成器「附源碼+文檔+視頻」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dfd0f295.html alt="基於代碼生成器的快速開發平臺 JEECG" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4aeffdb09064482b869992492d42e640 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dfd0f295.html title="基於代碼生成器的快速開發平臺 JEECG">基於代碼生成器的快速開發平臺 JEECG</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ffb341a.html alt=開源的Java代碼生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/12bf121fc6c44641858a42543c3706d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ffb341a.html title=開源的Java代碼生成器>開源的Java代碼生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67cb0624.html alt="基於代碼生成器的 J2EE 開發平臺 Jeecg-Boot" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4f2321b6024404bb37207266cb6563d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67cb0624.html title="基於代碼生成器的 J2EE 開發平臺 Jeecg-Boot">基於代碼生成器的 J2EE 開發平臺 Jeecg-Boot</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f48bce.html alt=Java：基於代碼實戰的File類和文件隨機訪問類RandomAccessFile class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3c7a0005031473ab9806 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f48bce.html title=Java：基於代碼實戰的File類和文件隨機訪問類RandomAccessFile>Java：基於代碼實戰的File類和文件隨機訪問類RandomAccessFile</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c271e4.html alt=Java代碼獲取數據庫表名、字段名、字段類型及註釋等信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d8d691ba-a551-42f4-8252-ab4a753618d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c271e4.html title=Java代碼獲取數據庫表名、字段名、字段類型及註釋等信息>Java代碼獲取數據庫表名、字段名、字段類型及註釋等信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d051f82.html alt=如何診斷Java代碼中常見的數據庫性能熱點問題？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15217840990949360ecee7a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d051f82.html title=如何診斷Java代碼中常見的數據庫性能熱點問題？>如何診斷Java代碼中常見的數據庫性能熱點問題？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html alt=python安全開發軍規之四：使用安全的隨機數生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bbda123b84db44148aca9d3e26ddf119 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html title=python安全開發軍規之四：使用安全的隨機數生成器>python安全開發軍規之四：使用安全的隨機數生成器</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>