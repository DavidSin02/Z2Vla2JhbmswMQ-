<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android View 繪製流程詳解 | 极客快訊</title><meta property="og:title" content="Android View 繪製流程詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/63c43360ea7c492e9eccf90add48d9c1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c018dddf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c018dddf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c018dddf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c018dddf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c018dddf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c018dddf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c018dddf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c018dddf.html><meta property="article:published_time" content="2020-10-29T21:08:51+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:51+08:00"><meta name=Keywords content><meta name=description content="Android View 繪製流程詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c018dddf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android View 繪製流程詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>View 繪製機制</strong></p><p><strong>一、 View 樹的繪圖流程</strong></p><p>當 Activity 接收到焦點的時候，它會被請求繪製佈局,該請求由 Android framework 處理.繪製是從根節點開始，對佈局樹進行 measure 和 draw。整個 View 樹的繪圖流程在ViewRoot.java類的performTraversals()函數展開，該函數所做 的工作可簡單概況為是否需要重新計算視圖大小(measure)、是否需要重新安置視圖的位置(layout)、以及是否需要重繪(draw)，流程圖如下：</p><div class=pgc-img><img alt="Android View 繪製流程詳解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/63c43360ea7c492e9eccf90add48d9c1><p class=pgc-img-caption></p></div><p><strong>View 繪製流程函數調用鏈</strong></p><div class=pgc-img><img alt="Android View 繪製流程詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/18737e91946c4fccb7ddc45a5467021f><p class=pgc-img-caption></p></div><p>需要說明的是，用戶主動調用 request，只會出發 measure 和 layout 過程，而不會執行 draw 過程</p><p><strong>二、 概念</strong></p><p><strong>1. measure 和 layout</strong></p><p>從整體上來看 Measure 和 Layout 兩個步驟的執行：</p><div class=pgc-img><img alt="Android View 繪製流程詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34a6986fbb0b44a29f21a31968832c56><p class=pgc-img-caption></p></div><p>樹的遍歷是有序的，由父視圖到子視圖，每一個 ViewGroup 負責測繪它所有的子視圖，而最底層的 View 會負責測繪自身。</p><p><strong>2. 具體分析</strong></p><p>measure 過程由measure(int, int)方法發起，從上到下有序的測量 View，在 measure 過程的最後，每個視圖存儲了自己的尺寸大小和測量規格。</p><p>layout 過程由layout(int, int, int, int)方法發起，也是自上而下進行遍歷。在該過程中，每個父視圖會根據 measure 過程得到的尺寸來擺放自己的子視圖。</p><p>measure 過程會為一個 View 及所有子節點的 mMeasuredWidth 和 mMeasuredHeight 變量賦值，該值可以通過 getMeasuredWidth()和getMeasuredHeight()方法獲得。而且這兩個值必須在父視圖約束範圍之內，這樣才可以保證所有的父視圖都接收所有子視圖的測量。如果子視圖對於 Measure 得到的大小不滿意的時候，父視圖會介入並設置測量規則進行第二次 measure。比如，父視圖可以先根據未給定的 dimension 去測量每一個子視圖，如果最終子視圖的未約束尺寸太大或者太小的時候，父視圖就會使用一個確切的大小再次對子視圖進行 measure。</p><p><strong>3. measure 過程傳遞尺寸的兩個類</strong></p><ul><li>ViewGroup.LayoutParams （View 自身的佈局參數）</li><li>MeasureSpecs 類（父視圖對子視圖的測量要求）</li></ul><p><strong>ViewGroup.LayoutParams</strong></p><p>這個類我們很常見，就是用來指定視圖的高度和寬度等參數。對於每個視圖的 height 和 width，你有以下選擇：</p><ul><li>具體值</li></ul><pre>MATCH_PARENT 表示子視圖希望和父視圖一樣大(不包含 padding 值)WRAP_CONTENT 表示視圖為正好能包裹其內容大小(包含 padding 值)</pre><p>ViewGroup 的子類有其對應的 ViewGroup.LayoutParams 的子類。比如 RelativeLayout 擁有的 ViewGroup.LayoutParams 的子類 RelativeLayoutParams。</p><p>有時我們需要使用 view.getLayoutParams() 方法獲取一個視圖 LayoutParams，然後進行強轉，但由於不知道其具體類型，可能會導致強轉錯誤。其實該方法得到的就是其所在父視圖類型的 LayoutParams，比如 View 的父控件為 RelativeLayout，那麼得到的 LayoutParams 類型就為 RelativeLayoutParams。</p><p><strong>MeasureSpecs</strong></p><p>測量規格，包含測量要求和尺寸的信息，有三種模式:</p><pre>UNSPECIFIED</pre><ul><li>父視圖不對子視圖有任何約束，它可以達到所期望的任意尺寸。比如 ListView、ScrollView，一般自定義 View 中用不到，</li></ul><pre>EXACTLY</pre><ul><li>父視圖為子視圖指定一個確切的尺寸，而且無論子視圖期望多大，它都必須在該指定大小的邊界內，對應的屬性為 match_parent 或具體值，比如 100dp，父控件可以通過MeasureSpec.getSize(measureSpec)直接得到子控件的尺寸。</li></ul><pre>AT_MOST</pre><ul><li>父視圖為子視圖指定一個最大尺寸。子視圖必須確保它自己所有子視圖可以適應在該尺寸範圍內，對應的屬性為 wrap_content，這種模式下，父控件無法確定子 View 的尺寸，只能由子控件自己根據需求去計算自己的尺寸，這種模式就是我們自定義視圖需要實現測量邏輯的情況。</li></ul><p><strong>三、 measure 核心方法</strong></p><pre>measure(int widthMeasureSpec, int heightMeasureSpec)</pre><ul><li>該方法定義在View.java類中，為 final 類型，不可被複寫，但 measure 調用鏈最終會回調 View/ViewGroup 對象的 onMeasure()方法，因此自定義視圖時，只需要複寫 onMeasure() 方法即可。</li></ul><pre>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</pre><ul><li>該方法就是我們自定義視圖中實現測量邏輯的方法，該方法的參數是父視圖對子視圖的 width 和 height 的測量要求。在我們自身的自定義視圖中，要做的就是根據該 widthMeasureSpec 和 heightMeasureSpec 計算視圖的 width 和 height，不同的模式處理方式不同。</li></ul><pre>setMeasuredDimension()</pre><ul><li>測量階段終極方法，在 onMeasure(int widthMeasureSpec, int heightMeasureSpec) 方法中調用，將計算得到的尺寸，傳遞給該方法，測量階段即結束。該方法也是必須要調用的方法，否則會報異常。在我們在自定義視圖的時候，不需要關心繫統複雜的 Measure 過程的，只需調用setMeasuredDimension()設置根據 MeasureSpec 計算得到的尺寸即可，你可以參考 ViewPagerIndicator的 onMeasure 方法。</li></ul><p>下面我們取 ViewGroup 的 measureChildren（int widthMeasureSpec, int heightMeasureSpec) 方法對複合 View 的 Measure 流程做一個分析：</p><p>MeasureChild 的方法調用流程圖：</p><div class=pgc-img><img alt="Android View 繪製流程詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e183341ecf634df59c4bbfd197447c81><p class=pgc-img-caption></p></div><p>源碼分析</p><pre> /** * 請求所有子 View 去 measure 自己，要考慮的部分有對子 View 的測繪要求 MeasureSpec 以及其自身的 padding * 這裡跳過所有為 GONE 狀態的子 View，最繁重的工作是在 getChildMeasureSpec 方法中處理的 * * @param widthMeasureSpec 對該 View 的 width 測繪要求 * @param heightMeasureSpec 對該 View 的 height 測繪要求 */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } } protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams();//獲取 Child 的 LayoutParams final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,// 獲取 ChildView 的 widthMeasureSpec mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,// 獲取 ChildView 的 heightMeasureSpec mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } /**  * 該方法是 measureChildren 中最繁重的部分，為每一個 ChildView 計算出自己的 MeasureSpec。 * 目標是將 ChildView 的 MeasureSpec 和 LayoutParams 結合起來去得到一個最合適的結果。 * * @param spec 對該 View 的測繪要求 * @param padding 當前 View 在當前唯獨上的 paddingand，也有可能含有 margins * * @param childDimension 在當前維度上（height 或 width）的具體指 * @return 子視圖的 MeasureSpec  */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) { ......... // 根據獲取到的子視圖的測量要求和大小創建子視圖的 MeasureSpec return MeasureSpec.makeMeasureSpec(resultSize, resultMode);  } /** * * 用於獲取 View 最終的大小，父視圖提供了寬、高的約束信息 * 一個 View 的真正的測量工作是在 onMeasure(int, int) 中，由該方法調用。 * 因此，只有 onMeasure(int, int) 可以而且必須被子類複寫 * * @param widthMeasureSpec 在水平方向上，父視圖指定的的 Measure 要求 * @param heightMeasureSpec 在豎直方向上，控件上父視圖指定的 Measure 要求 * */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... } protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</pre><p><strong>四、 layout 相關概念及核心方法</strong></p><p>首先要明確的是，子視圖的具體位置都是相對於父視圖而言的。View 的 onLayout 方法為空實現，而 ViewGroup 的 onLayout 為 abstract 的，因此，如果自定義的 View 要繼承 ViewGroup 時，必須實現 onLayout 函數。</p><p>在 layout 過程中，子視圖會調用getMeasuredWidth()和getMeasuredHeight()方法獲取到 measure 過程得到的 mMeasuredWidth 和 mMeasuredHeight，作為自己的 width 和 height。然後調用每一個子視圖的layout(l, t, r, b)函數，來確定每個子視圖在父視圖中的位置。</p><p><strong>LinearLayout 的 onLayout 源碼分析</strong></p><pre> @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } /** * 遍歷所有的子 View，為其設置相對父視圖的座標 */ void layoutVertical(int left, int top, int right, int bottom) { for (int i = 0; i &lt; count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) {//不需要立即展示的 View 設置為 GONE 可加快繪製 final int childWidth = child.getMeasuredWidth();//measure 過程確定的 Width final int childHeight = child.getMeasuredHeight();//measure 過程確定的 height ...確定 childLeft、childTop 的值 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); } } } private void setChildFrame(View child, int left, int top, int width, int height) {  child.layout(left, top, left + width, top + height); }  View.java public void layout(int l, int t, int r, int b) { ... setFrame(l, t, r, b) } /** * 為該子 View 設置相對其父視圖上的座標 */ protected boolean setFrame(int left, int top, int right, int bottom) { ... }</pre><p><strong>五、 繪製流程相關概念及核心方法</strong></p><p>先來看下與 draw 過程相關的函數：</p><pre>View.draw(Canvas canvas)：</pre><ul><li>由於 ViewGroup 並沒有複寫此方法，因此，所有的視圖最終都是調用 View 的 draw 方法進行繪製的。在自定義的視圖中，也不應該複寫該方法，而是複寫 onDraw(Canvas) 方法進行繪製，如果自定義的視圖確實要複寫該方法，那麼請先調用 super.draw(canvas)完成系統的繪製，然後再進行自定義的繪製。</li></ul><pre>View.onDraw()：</pre><ul><li>View 的onDraw（Canvas）默認是空實現，自定義繪製過程需要複寫的方法，繪製自身的內容。</li></ul><pre>dispatchDraw()</pre><ul><li>發起對子視圖的繪製。View 中默認是空實現，ViewGroup 複寫了dispatchDraw()來對其子視圖進行繪製。該方法我們不用去管，自定義的 ViewGroup 不應該對dispatchDraw()進行復寫。</li></ul><p>繪製流程圖</p><div class=pgc-img><img alt="Android View 繪製流程詳解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fa6d180f1e2e4f82b2bc12fa5769cc2e><p class=pgc-img-caption></p></div><p>View.draw(Canvas) 源碼分析</p><pre>/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered.  * * 根據給定的 Canvas 自動渲染 View（包括其所有子 View）。在調用該方法之前必須要完成 layout。當你自定義 view 的時候， * 應該去是實現 onDraw(Canvas) 方法，而不是 draw(canvas) 方法。如果你確實需要複寫該方法，請記得先調用父類的方法。 */ public void draw(Canvas canvas) { / * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background if need * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children (dispatchDraw) * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // we're done... return; } // Step 2, save the canvas' layers ... // Step 3, draw the content if (!dirtyOpaque)  onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); }</pre><p>由上面的處理過程，我們也可以得出一些優化的小技巧：當不需要繪製 Layer 的時候第二步和第五步會跳過。因此在繪製的時候，能省的 layer 儘可省，可以提高繪製效率</p><p><strong>ViewGroup.dispatchDraw() 源碼分析</strong></p><pre>dispatchDraw(Canvas canvas){... if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) {//處理 ChildView 的動畫 final boolean buildCache = !isHardwareAccelerated(); for (int i = 0; i &lt; childrenCount; i++) { final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) {//只繪製 Visible 狀態的佈局，因此可以通過延時加載來提高效率 final LayoutParams params = child.getLayoutParams(); attachLayoutAnimationParameters(child, params, i, childrenCount);// 添加布局變化的動畫 bindLayoutAnimation(child);//為 Child 綁定動畫 if (cache) { child.setDrawingCacheEnabled(true); if (buildCache) { child.buildDrawingCache(true); } } } } final LayoutAnimationController controller = mLayoutAnimationController; if (controller.willOverlap()) { mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE; } controller.start();// 啟動 View 的動畫} // 繪製 ChildView for (int i = 0; i &lt; childrenCount; i++) { int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) { more |= drawChild(canvas, child, drawingTime); } }...}protected boolean drawChild(Canvas canvas, View child, long drawingTime) { return child.draw(canvas, this, drawingTime);}/** * This method is called by ViewGroup.drawChild() to have each child view draw itself. * This draw() method is an implementation detail and is not intended to be overridden or * to be called from anywhere else other than ViewGroup.drawChild(). */ boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) { ... }</pre><pre>drawChild(canvas, this, drawingTime)</pre><p>直接調用了 View 的child.draw(canvas, this,drawingTime)方法，文檔中也說明了，除了被ViewGroup.drawChild()方法外，你不應該在其它任何地方去複寫或調用該方法，它屬於ViewGroup。而View.draw(Canvas)方法是我們自定義控件中可以複寫的方法，具體可以參考上述對view.draw(Canvas)的說明。從參數中可以看到，child.draw(canvas, this, drawingTime)肯定是處理了和父視圖相關的邏輯，但 View 的最終繪製，還是View.draw(Canvas)方法。</p><pre>invalidate()</pre><p>請求重繪 View 樹，即 draw 過程，假如視圖發生大小沒有變化就不會調用layout()過程，並且只繪製那些調用了invalidate()方法的 View。</p><pre>requestLayout()</pre><p>當佈局變化的時候，比如方向變化，尺寸的變化，會調用該方法，在自定義的視圖中，如果某些情況下希望重新測量尺寸大小，應該手動去調用該方法，它會觸發measure()和layout()過程，但不會進行 draw。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Android</a></li><li><a>View</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f1d8806.html alt="Android View繪製原理：繪製流程調度、測算等" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f1d8806.html title="Android View繪製原理：繪製流程調度、測算等">Android View繪製原理：繪製流程調度、測算等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/364ae4ea.html alt="Android 矢量圖詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4089cede16d64e73a6cd807ba37280e8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/364ae4ea.html title="Android 矢量圖詳解">Android 矢量圖詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html alt=詳解13項鋼筋安裝質量標準及通病防治 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fd3ff534941a487884c7a67361337cfb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html title=詳解13項鋼筋安裝質量標準及通病防治>詳解13項鋼筋安裝質量標準及通病防治</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html alt=史上最全電路圖詳解！老電工都收藏了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533138404073909636bf43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html title=史上最全電路圖詳解！老電工都收藏了！>史上最全電路圖詳解！老電工都收藏了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html alt=每一滴油力爭做到不浪費，詳解各種燃油噴射方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3ed00001d75ac552f05c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html title=每一滴油力爭做到不浪費，詳解各種燃油噴射方式>每一滴油力爭做到不浪費，詳解各種燃油噴射方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html alt="Excel萬金油套路詳解 單條件查找返回多行數據" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2633664673fd439a862a2527763e82c7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html title="Excel萬金油套路詳解 單條件查找返回多行數據">Excel萬金油套路詳解 單條件查找返回多行數據</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html alt=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7360fe7df5e241e7af4b15f75f6474fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html title=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍>詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>