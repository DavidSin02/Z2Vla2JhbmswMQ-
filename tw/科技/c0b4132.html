<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>十分鐘學會有限狀態機的實現原理 | 极客快訊</title><meta property="og:title" content="十分鐘學會有限狀態機的實現原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/67db0a1f58fe43878523eb9e1b738b2c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0b4132.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0b4132.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c0b4132.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0b4132.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0b4132.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c0b4132.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c0b4132.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0b4132.html><meta property="article:published_time" content="2020-10-29T20:59:15+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:15+08:00"><meta name=Keywords content><meta name=description content="十分鐘學會有限狀態機的實現原理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c0b4132.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>十分鐘學會有限狀態機的實現原理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=十分鐘學會有限狀態機的實現原理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/67db0a1f58fe43878523eb9e1b738b2c><p class=pgc-img-caption></p></div><p>在學習狀態機實現原理之前，我們先了解狀態機的五個定義如下：</p><ul><li>定義一：有限的狀態</li><li>定義二：有限的事件</li><li>定義三：一個初始狀態</li><li>定義四：變換器（給定當前狀態 + 事件，可以得出下個狀態）</li><li>定義五：若干個（或無）的最終狀態</li></ul><p>然後我們依據狀態機的定義進行逐個分析。</p><h2 class=pgc-h-arrow-right>定義解讀</h2><h3 class=pgc-h-arrow-right>定義一：有限的狀態</h3><p>狀態機之所以這樣命名，大略都可以理解為管理“狀態”的機器。從工業生產可用性的角度來看，任何事物都是可以 <strong>近似</strong> 看做有限的狀態的。</p><p>怎麼理解呢？比如一杯水的溫度可以算作它的狀態，理論上溫度的值是無限的，比如我可以說水的溫度從 30° 升到了 30.0001° 也算是狀態變化，但是我們在普遍場景下，對水的溫度精度並不會要求很高。</p><p>因此我們可以定義為水的每 1° 就是一個狀態，並且我們只關注 0° ~ 100°。因此水的溫度狀態就只有 100 個，從而表達了 <strong>有限</strong> 的概念。</p><p>對於設計實現來說，我們拿燈泡舉例子，假設燈泡有亮、不亮、壞掉三個狀態，我們僅僅用一個數組就可以表達完這個事情。</p><pre><code>const lightBulbStates = ['LIT', 'UNLIT', 'BROKEN'];</code></pre><p>當然，在實際開發中，我們也可以用哈希表或者 enum 枚舉所有狀態。</p><pre><code>const lightBulbStates = {  lit: 'LIT',  unlit: 'UNLIT',  broken: 'BROKEN',};</code></pre><h3 class=pgc-h-arrow-right>定義二：有限的事件</h3><p>什麼是事件？</p><p>舉個例子：比如說小明心如止水地在工作，突然隔壁同事給了他一巴掌，小明氣炸了，準備擼起袖子去打架。</p><p>這裡小明就是一個狀態機，他從 <strong>心如止水</strong> 的狀態，轉換到了 <strong>氣炸了</strong> 的狀態，全因發生了 <strong>被同事扇了一巴掌</strong> 的事件，並且產生了 <strong>準備去幹架</strong> 的行為副作用。公式如下：</p><p>心如止水（狀態） + 被扇一巴掌（事件） = 氣炸了（新的狀態）+ 準備幹架（副作用）。</p><p>當然同事之間還是要團結友愛啦，君子動口不動手，我們要以理服人，是吧。</p><p>基於上述的例子，我們進行抽象，總結得出公式如下：</p><pre><code>state + event = newState + effect</code></pre><p>因此，因為狀態是有限的，所以當然事件也是有限的。就比如圖有三個頂點，點之間的連線如果有向，那也只有六條線（2 ^ 3 = 6），這很好理解。</p><p>再結合到我們的燈泡狀態機來看，它的事件有如下幾種：</p><pre><code>unlit + TOGGLE = lit + effectlit + TOGGLE = unlit + effectunlit + BREAK = broken + effectlit + BREAK = broken + effect</code></pre><p>我們整理一下，用 JavaScript 對象來表述這個事情：</p><pre><code>const lightBulbEventMap = {  unlit: {    on: {      TOGGLE: 'lit',      BREAK: 'broken',    },  },  lit: {    on: {      TOGGLE: 'unlit',      BREAK: 'broken',    },  },  broken: {},};</code></pre><p>這樣狀態與事件之間的關係就一目瞭然了。</p><h3 class=pgc-h-arrow-right>定義三：一個初始狀態</h3><p>盤古開天、女媧造人、伊甸園裡的亞當夏娃，萬事萬物都有一個初始狀態。就像人的一生也會從呱呱落地開始，到化作一抔黃土結束，整個過程是隨時間流逝而不斷變換的，我們不可能直接繞過開始，直接到中間某個節點。</p><p>對於狀態機來說也是如此。燈泡買回來一般處於未點亮的狀態（正常來說）。因此，我們還是用 JavaScript 對象來表述這個事情：</p><pre><code>const lightBulbMachine = {  initial: 'unlit',  states: {    unlit: {      on: {        TOGGLE: 'lit',        BREAK: 'broken',      },    },    lit: {      on: {        TOGGLE: 'unlit',        BREAK: 'broken',      },    },    broken: {},  },};</code></pre><h3 class=pgc-h-arrow-right>定義四：變換器（給定當前狀態 + 事件，可以得出下個狀態）</h3><p>其實到這裡我們已經把燈泡的狀態、事件都定義完了。但我們仍然需要給出變換器的實現，用以實現狀態與狀態之前的過渡。</p><p>變換器實現複雜麼？不，一點也不。請看：</p><pre><code>function transition(state, event) {  return machine.states[state].on[event];}</code></pre><p>然後我們可以用變換器函數對燈泡的狀態進行運算</p><pre><code>const newState = transition('unlit', 'TOGGLE'); // lit</code></pre><p>或者~</p><pre><code>const newState = transition('lit', 'BREAK'); // broken</code></pre><p>假如燈泡壞了，我們還是想點亮它，怎麼辦？</p><pre><code>const newState = transition('broken', 'TOGGLE'); // Throw error</code></pre><p>狀態機告訴你，痴心妄想！</p><h3 class=pgc-h-arrow-right>定義五：若干個（或無）的最終狀態</h3><p>前面說到萬事萬物都有起點，所以按道理來說，應該也必然有終點。但是考慮到實際應用中，其實抽象來說未必需要一個終點。就比如網站用戶可以登錄、漫遊、退出、再登錄、再漫遊等等，它並沒有一個實際的終點。</p><p>但是也可以有終點。比如 Promise 請求，從 init 到 pending，再返回 resolve 代表成功，或者 reject 代表失敗。它有兩個終點。</p><p>比如人從出生到逝去，宏觀上來說，分別對應著初始狀態、最終狀態。</p><p>我們還是回到我們的燈泡狀態機，broken 就是它的最終狀態。狀態機一旦抵達到最終的狀態，就相當於結束了。</p><pre><code>const lightBulbMachine = {  initial: 'unlit',  states: {    // ...    broken: {      type: 'final',    },  },};</code></pre><h2 class=pgc-h-arrow-right>狀態機最簡單實現</h2><p>來，讓我們實現一個狀態機吧！</p><pre><code>function createMachine({ initial, states }) {  const machine = {    initialState: initial,    transition: (state, event) =&gt; states[state].on[event]  };  return machine;}</code></pre><p>同學們肯定會覺得，就這麼簡單麼？其實本質上就這樣。雖然如此簡單的實現，是絕對不能支撐起我們複雜的業務場景需求的。但是一旦只要明白了本質，擴展的實現理解起來也不會很困難。</p><h2 class=pgc-h-arrow-right>副作用</h2><p>上文的狀態機實現其實本質上是個純函數，但我們仔細觀察上文提到過的公式。</p><pre><code>state + event = newState + effect</code></pre><p>關於副作用我們卻隻字未提。在大型的應用中，副作用是到處存在的，比如網絡請求、本地日誌存儲、錯誤輸出、DOM 操作、數據庫寫入、事件註冊監聽。</p><p>純函數可以提高我們代碼的質量，但是卻不能表達複雜的業務。</p><p>狀態機也是如此。狀態機可以通過註冊活動（Activities）、上下文（context）、訂閱狀態機服務（Service.subscribe）等方式進行表達副作用。</p><p>這些都可以去 <strong>XState Docs</strong> XState 官網進行學習瞭解。</p><h2 class=pgc-h-arrow-right>源碼解讀</h2><p>這裡貼上了最簡單的狀態機實現（@xstate/fsm）的註釋。除了包含了上述最基本的五個定義、還有擴展上下文（context）、條件守護（cond）、狀態機解釋服務（service）等。</p><p>對狀態機更進一步實現感興趣的同學可以閱讀。</p><pre><code>// xstate.jsimport {  toTransitionObject, toActionObject, toEventObject, toArray, isString, isFunction} from './util';const INIT_EVENT = { type: 'xstate.init' };const ASSIGN_ACTION = 'xstate.assign';function createMatcher(value) {  return stateValue =&gt; value === stateValue;}function createUnchangedState(value, context) {  return {    value,    context,    actions: [],    changed: false,    matches: createMatcher(value)  };}export function assign(assignment) {  return {    type: ASSIGN_ACTION,    assignment  }}export function execActions(state, event) {  state.actions.forEach(({ exec }) =&gt; {    exec &amp;&amp; exec(state.context, event);  });}// 通過約定的狀態機配置，生產一個有限狀態機// 狀態機定義如下：// - 定義一：有限的狀態// - 定義二：有限的事件// - 定義三：一個初始狀態// - 定義四：變換器（給定當前狀態 + 事件，可以得出下個狀態）// - 定義五：若干個（或無）的最終狀態export function createMachine(fsmConfig, options = {}) {  function getCombinedActions({ states, initial }) {    const entryAction = states[initial].entry;    return toArray(      entryAction    ).map(action =&gt; toActionObject(action, options.actions));  }  function getContext() {    return fsmConfig.context || {};  }  const machine = {    _options: options,    config: fsmConfig,    // 實現定義三 - 一個初始狀態節點    initialState: {      // 狀態值      value: fsmConfig.initial,      // 事件      actions: getCombinedActions(fsmConfig),      // 上下文      context: getContext(),      // 狀態匹配判斷方法      matches: createMatcher(fsmConfig.initial)    },    // 實現定義四 - 變換器    transition: (state, event) =&gt; {      const { value, context } = isString(state) ?        { value: state, context: getContext() } : state;      const eventObject = toEventObject(event);      const stateConfig = fsmConfig.states[value];      if (stateConfig.on) {        // 根據事件類型取得對應的變換器        const transitions = toArray(stateConfig.on[eventObject.type]);        for (const transtion of transitions) {          // 實際上沒有任何變換器、或使用 undefined 中斷了變換器          if (transtion === undefined) {            return createUnchangedState(value, context);          }          const { target = value, actions = [], cond = () =&gt; true } = toTransitionObject(transtion);          let nextContext = context;          // 條件守護，只要滿足一個變換器，直接退出          if (cond(context, eventObject)) {            // 判斷上下文是否被修改            let assigned = false;            // 獲取下個狀態對象節點            const nextStateConfig = fsmConfig.states[target];            const allActions = []              // 依次進行當前狀態的 Exit Action、當前狀態的 Action 集合、下個狀態的 Entry Action              .concat(                stateConfig.exit, actions, nextStateConfig.entry              )              // 過濾假值              .filter(a =&gt; a)              // 尋找 Action 配置，返回統一格式的 Action 對象              .map(action =&gt; toActionObject(action, machine._options.actions))              // 內部事件，支持 assign 函數修改上下文              .filter(action =&gt; {                if (action.type === ASSIGN_ACTION) {                  assigned = true;                  let tmpContext = Object.assign({}, nextContext);                  if (isFunction(action.assignment)) {                    tmpContext = action.assignment(nextContext, eventObject);                  } else {                    Object.keys(action.assignment).forEach(key =&gt; {                      const assignment = action.assignment[key];                      tmpContext[key] = isFunction(assignment) ? assignment(nextContext, eventObject) : assignment                    });                  }                  nextContext = tmpContext;                  return false;                }                return true;              });            return {              value: target,              context: nextContext,              actions: allActions,              changed: target !== value || allActions.length &gt; 0 || assigned,              matches: createMatcher(target)            };          }        }      }      // 狀態節點未註冊任何變換器、條件守護未滿足，導致停留在原本的狀態節點      return createUnchangedState(value, context);    }  };  return machine;}// 狀態機服務的狀態export const INTERPRETER_STATUS = {  NotStarted: 0,  Running: 1,  Stopped: 2};// 將 Machine 解釋為一個狀態機服務，應用於實際生產環境export function interpret(machine) {  let state = machine.initialState;  let status = INTERPRETER_STATUS.NotStarted;  // 用以訂閱狀態機服務  const listeners = new Set();  const service = {    _machine: machine,    send(event) {      // 狀態機服務未啟動時，不允許發送事件      if (status !== INTERPRETER_STATUS.Running) {        return;      }      // 通過變換器更新狀態      state = machine.transition(state, event);      // 執行當前狀態的所有 Action（Action 集合在 Machine 中已進行計算）      execActions(state, toEventObject(event));      listeners.forEach((listener) =&gt; listener(state));      return service;    },    subscribe: (listener) =&gt; {      listeners.add(listener);      listener(state);      return {        unsubscribe: () =&gt; listeners.delete(listener)      };    },    // 狀態機服務啟動    start: () =&gt; {      status = INTERPRETER_STATUS.Running;      execActions(state, INIT_EVENT);      return service;    },    // 狀態機服務暫停    stop: () =&gt; {      status = INTERPRETER_STATUS.Stopped;      listeners.clear();      return service;    },    get state() {      return state;    },    get status() {      return status;    }  };  return service;}export const Machine = createMachine;</code></pre><pre><code>// util.jsexport function toArray(item) {  return item === undefined ? [] : [].concat(item);}export function isString(o) {  return typeof o === 'string';}export function isFunction(o) {  return typeof o === 'function';}export function toActionObject(action, actionMap = {}) {  action = isString(action) &amp;&amp; actionMap[action] ?    actionMap[action] : action;  if (isString(action)) {    return {      type: action    };  } else if (isFunction(action)) {    return {      type: action.name,      exec: action    }  } else {    return action;  }}export function toEventObject(event) {  return isString(event) ? { type: event } : event;}export function toTransitionObject(transition) {  return isString(transition) ? { target: transition } : transition;}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>鐘學會</a></li><li><a>狀態機</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef75f18.html alt=用C語言實現有限狀態機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef75f18.html title=用C語言實現有限狀態機>用C語言實現有限狀態機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html alt="廣西鐵路出海大通道 全面實現電氣化運營" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html title="廣西鐵路出海大通道 全面實現電氣化運營">廣西鐵路出海大通道 全面實現電氣化運營</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7c3d9f70.html alt=新穎的混合材料或有助於實現高效的下一代顯示器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/47050004da4f36dcec1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7c3d9f70.html title=新穎的混合材料或有助於實現高效的下一代顯示器>新穎的混合材料或有助於實現高效的下一代顯示器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d93e49d.html alt=教程：採用梯度下降算法實現線性迴歸！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1537162000876f4501fb1c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d93e49d.html title=教程：採用梯度下降算法實現線性迴歸！>教程：採用梯度下降算法實現線性迴歸！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8e17d90.html alt=重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RtbWBYL9koJMmN style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8e17d90.html title=重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別>重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1b218e68.html alt=圖像拼接算法及實現（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534489824878547eee8fc2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1b218e68.html title=圖像拼接算法及實現（一）>圖像拼接算法及實現（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9eb3d63.html alt=PHP實現各種經典算法詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15357595091626cf296dc3e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9eb3d63.html title=PHP實現各種經典算法詳解>PHP實現各種經典算法詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>