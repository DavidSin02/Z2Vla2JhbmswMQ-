<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文帶你瞭解操作系統核心概念 | 极客快訊</title><meta property="og:title" content="一文帶你瞭解操作系統核心概念 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/463d0489-e0ac-42ff-9d2c-4e358110ed2f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0f0eb9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0f0eb9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c0f0eb9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0f0eb9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0f0eb9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c0f0eb9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c0f0eb9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c0f0eb9.html><meta property="article:published_time" content="2020-10-29T21:05:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:04+08:00"><meta name=Keywords content><meta name=description content="一文帶你瞭解操作系統核心概念"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c0f0eb9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文帶你瞭解操作系統核心概念</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/463d0489-e0ac-42ff-9d2c-4e358110ed2f><p class=pgc-img-caption></p></div><p>操作系統概念</p><p>大部分操作系統提供了特定的基礎概念和抽象，例如進程、地址空間、文件等，它們是需要理解的核心內容。下面我們會簡要介紹一些基本概念，為了說明這些概念，我們會不時的從 UNIX 中提出示例，相同的示例也會存在於其他系統中，我們後面會進行介紹。</p><h3 class=pgc-h-arrow-right>進程</h3><p>操作系統一個很關鍵的概念就是 進程(Process)。進程的本質就是操作系統執行的一個程序。與每個進程相關的是地址空間(address space)，這是從某個最小值的存儲位置(通常是零)到某個最大值的存儲位置的列表。在這個地址空間中，進程可以進行讀寫操作。地址空間中存放有可執行程序，程序所需要的數據和它的棧。與每個進程相關的還有資源集，通常包括寄存器(registers)（寄存器一般包括程序計數器(program counter)和堆棧指針(stack pointer)）、打開文件的清單、突發的報警、有關的進程清單和其他需要執行程序的信息。你可以把進程看作是容納運行一個程序所有信息的一個容器。</p><p>對進程建立一種直觀感覺的方式是考慮建立一種多程序的系統。考慮下面這種情況：用戶啟動一個視頻編輯程序，指示它按照某種格式轉換視頻，然後再去瀏覽網頁。同時，一個檢查電子郵件的後臺進程被喚醒並開始運行，這樣，我們目前就會有三個活動進程：視頻編輯器、Web 瀏覽器和電子郵件接收程序。操作系統週期性的掛起一個進程然後啟動運行另一個進程，這可能是由於過去一兩秒鐘程序用完了 CPU 分配的時間片，而 CPU 轉而運行另外的程序。</p><p>像這樣暫時中斷進程後，下次應用程序在此啟動時，必須要恢復到與中斷時刻相同的狀態，這在我們用戶看起來是習以為常的事情，但是操作系統內部卻做了巨大的事情。<strong>這就像和足球比賽一樣，一場完美精彩的比賽是可以忽略裁判的存在的</strong>。這也意味著在掛起時該進程的所有信息都要被保存下來。例如，進程可能打開了多個文件進行讀取。與每個文件相關聯的是提供當前位置的指針（即下一個需要讀取的字節或記錄的編號）。當進程被掛起時，必須要保存這些指針，以便在重新啟動進程後執行的 read調用將能夠正確的讀取數據。在許多操作系統中，與一個進程有關的所有信息，除了該進程自身地址空間的內容以外，均存放在操作系統的一張表中，稱為 進程表(process table)，進程表是數組或者鏈表結構，當前存在每個進程都要佔據其中的一項。</p><p>所以，一個掛起的進程包括：進程的地址空間（往往稱作磁芯映像， core image，紀念過去的磁芯存儲器），以及對應的進程表項（其中包括寄存器以及稍後啟動該進程所需要的許多其他信息）。</p><p>與進程管理有關的最關鍵的系統調用往往是決定著進程的創建和終止的系統調用。考慮一個典型的例子，有一個稱為 命令解釋器(command interpreter) 或 shell 的進程從終端上讀取命令。此時，用戶剛鍵入一條命令要求編譯一個程序。shell 必須先創建一個新進程來執行編譯程序，當編譯程序結束時，它執行一個系統調用來終止自己的進程。</p><p>如果一個進程能夠創建一個或多個進程（稱為子進程），而且這些進程又可以創建子進程，則很容易找到進程數，如下所示</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/352b4c62bdc8421d9764ab0a87dc740b><p class=pgc-img-caption></p></div><p>上圖表示一個進程樹的示意圖，進程 A 創建了兩個子進程 B 和進程 C，子進程 B 又創建了三個子進程 D、E、F。</p><p>合作完成某些作業的相關進程經常需要彼此通信來完成作業，這種通信稱為進程間通信(interprocess communication)。我們在後面會探討進程間通信。</p><p>其他可用的進程系統調用包括：申請更多的內存（或釋放不再需要的內存），等待一個子進程結束，用另一個程序覆蓋該程序。</p><p>有時，需要向一個正在運行的進程傳遞信息，而該進程並沒有等待接收信息。例如，一個進程通過網絡向另一臺機器上的進程發送消息進行通信。為了保證一條消息或消息的應答不丟失。發送者要求它所在的操作系統在指定的若干秒後發送一個通知，這樣如果對方尚未收到確認消息就可以進行重新發送。在設定該定時器後，程序可以繼續做其他工作。</p><p>在限定的時間到達後，操作系統會向進程發送一個 警告信號(alarm signal)。這個信號引起該進程暫時掛起，無論該進程正在做什麼，系統將其寄存器的值保存到堆棧中，並開始重新啟動一個特殊的信號處理程，比如重新發送可能丟失的消息。這些信號是軟件模擬的硬件中斷，除了定時器到期之外，該信號可以通過各種原因產生。許多由硬件檢測出來的陷阱，如執行了非法指令或使用了無效地址等，也被轉換成該信號並交給這個進程。</p><p>系統管理器授權每個進程使用一個給定的 UID(User IDentification)。每個啟動的進程都會有一個操作系統賦予的 UID，子進程擁有與父進程一樣的 UID。用戶可以是某個組的成員，每個組也有一個 GID(Group IDentification)。</p><p>在 UNIX 操作系統中，有一個 UID 是 超級用戶(superuser)，或者 Windows 中的管理員(administrator)，它具有特殊的權利，可以違背一些保護規則。在大型系統中，只有系統管理員掌握著那些用戶可以稱為超級用戶。</p><h3 class=pgc-h-arrow-right>地址空間</h3><p>每臺計算機都有一些主存用來保存正在執行的程序。在一個非常簡單的操作系統中，僅僅有一個應用程序運行在內存中。為了運行第二個應用程序，需要把第一個應用程序移除才能把第二個程序裝入內存。</p><p>複雜一些的操作系統會允許多個應用程序同時裝入內存中運行。為了防止應用程序之間相互干擾（包括操作系統），需要有某種保護機制。雖然此機制是在硬件中實現，但卻是由操作系統控制的。</p><p>上述觀點涉及對計算機主存的管理和保護。另一種同等重要並與存儲器有關的內容是管理進程的地址空間。通常，每個進程有一些可以使用的地址集合，典型值從 0 開始直到某個最大值。一個進程可擁有的最大地址空間小於主存。在這種情況下，即使進程用完其地址空間，內存也會有足夠的內存運行該進程。</p><p>但是，在許多 32 位或 64 位地址的計算機中，分別有 2^32 或 2^64 字節的地址空間。如果一個進程有比計算機擁有的主存還大的地址空間，而且該進程希望使用全部的內存，那該怎麼處理？在早期的計算機中是無法處理的。但是現在有了一種虛擬內存的技術，正如前面講到過的，操作系統可以把部分地址空間裝入主存，部分留在磁盤上，並且在需要時來回交換它們。</p><h3 class=pgc-h-arrow-right>文件</h3><p>幾乎所有操作系統都支持的另一個關鍵概念就是文件系統。如前所述，操作系統的一項主要功能是屏蔽磁盤和其他 I/O 設備的細節特性，給程序員提供一個良好、清晰的獨立於設備的抽象文件模型。<strong>創建文件、刪除文件、讀文件和寫文件</strong> 都需要系統調用。在文件可以讀取之前，必須先在磁盤上定位和打開文件，在文件讀過之後應該關閉該文件，有關的系統調用則用於完成這類操作。</p><p>為了提供保存文件的地方，大多數個人計算機操作系統都有目錄(directory) 的概念，從而可以把文件分組。比如，學生可以給每個課程都創建一個目錄，用於保存該學科的資源，另一個目錄可以存放電子郵件，再有一個目錄可以存放萬維網主頁。這就需要系統調用創建和刪除目錄、將已有文件放入目錄中，從目錄中刪除文件等。目錄項可以是文件或者目錄，目錄和目錄之間也可以嵌套，這樣就產生了文件系統</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3aa4a7b9302346bcacefdcd64c40e7ab><p class=pgc-img-caption></p></div><p>進程和文件層次都是以樹狀的結構組織，但這兩種樹狀結構有不少不同之處。一般進程的樹狀結構層次不深（很少超過三層），而文件系統的樹狀結構要深一些，通常會到四層甚至五層。進程樹層次結構是暫時的，通常最多存在幾分鐘，而目錄層次則可能存在很長時間。進程和文件在權限保護方面也是有區別的。一般來說，父進程能控制和訪問子進程，而在文件和目錄中通常存在一種機制，使文件所有者之外的其他用戶也能訪問該文件。</p><p>目錄層結構中的每一個文件都可以通過從目錄的頂部即 根目錄(Root directory) 開始的路徑名(path name) 來確定。絕對路徑名包含了從根目錄到該文件的所有目錄清單，它們之間用斜槓分隔符分開，在上面的大學院系文件系統中，文件 CS101 的路徑名是 /Faculty/Prof.Brown/Courses/CS101。最開始的斜槓分隔符代表的是根目錄 /，也就是文件系統的絕對路徑。</p><blockquote><p>出於歷史原因，Windows 下面的文件系統以 \ 來作為分隔符，但是 Linux 會以 / 作為分隔符。</p></blockquote><p>在上面的系統中，每個進程會有一個 工作目錄(working directory)，對於沒有以斜線開頭給出絕對地址的路徑，將在這個工作目錄下尋找。如果 /Faculty/Prof.Brown 是工作目錄，那麼 /Courses/CS101 與上面給定的絕對路徑名錶示的是同一個文件。進程可以通過使用系統調用指定新的工作目錄，從而變更其工作目錄。</p><p>在讀寫文件之前，首先需要打開文件，檢查其訪問權限。若權限許可，系統將返回一個小整數，稱作文件描述符(file descriptor)，供後續操作使用。若禁止訪問，系統則返回一個錯誤碼。</p><p>在 UNIX 中，另一個重要的概念是 特殊文件(special file)。提供特殊文件是為了使 I/O 設備看起來像文件一般。這樣，就像使用系統調用讀寫文件一樣，I/O 設備也可以通過同樣的系統調用進行讀寫。特殊文件有兩種，一種是塊兒特殊文件(block special file) 和 字符特殊文件(character special file)。塊特殊文件指那些由可隨機存取的塊組成的設備，如磁盤等。比如打開一個塊特殊文件，然後讀取第4塊，程序可以直接訪問設備的第4塊而不必考慮存放在該文件的文件系統結構。類似的，字符特殊文件用於打印機、調製解調起和其他接受或輸出字符流的設備。按照慣例，特殊文件保存在 /dev 目錄中。例如，/devv/lp 是打印機。</p><p>還有一種與進程和文件相關的特性是管道，管道(pipe) 是一種虛文件，他可以連接兩個進程</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/df8f165ef37846d0af7cbff35e3acb1f><p class=pgc-img-caption></p></div><p>如果 A 和 B 希望通過管道對話，他們必須提前設置管道。當進程 A 相對進程 B 發送數據時，它把數據寫到管道上，相當於管道就是輸出文件。這樣，在 UNIX 中兩個進程之間的通信就非常類似於普通文件的讀寫了。</p><h3 class=pgc-h-arrow-right>保護</h3><p>計算機中含有大量的信息，用戶希望能夠對這些信息中有用而且重要的信息加以保護，這些信息包括電子郵件、商業計劃等，管理這些信息的安全性完全依靠操作系統來保證。例如，文件提供授權用戶訪問。</p><p>比如 UNIX 操作系統，UNIX 操作系統通過對每個文件賦予一個 9 位二進制保護代碼，對 UNIX 中的文件實現保護。該保護代碼有三個位子段，一個用於所有者，一個用於與所有者同組（用戶被系統管理員劃分成組）的其他成員，一個用於其他人。每個字段中有一位用於讀訪問，一位用於寫訪問，一位用於執行訪問。這些位就是著名的 rwx位。例如，保護代碼 rwxr-x--x 的含義是所有者可以讀、寫或執行該文件，其他的組成員可以讀或執行（但不能寫）此文件、而其他人可以執行（但不能讀和寫）該文件。</p><h3 class=pgc-h-arrow-right>shell</h3><p>操作系統是執行系統調用的代碼。編輯器、編譯器、彙編程序、鏈接程序、使用程序以及命令解釋符等，儘管非常重要，非常有用，但是它們確實不是操作系統的組成部分。下面我們著重介紹一下 UNIX 下的命令提示符，也就是 shell，shell 雖然有用，但它也不是操作系統的一部分，然而它卻能很好的說明操作系統很多特性，下面我們就來探討一下。</p><p>shell 有許多種，例如 <strong>sh、csh、ksh 以及 bash</strong>等，它們都支持下面這些功能，最早起的 shell 可以追溯到 sh</p><p>用戶登錄時，會同時啟動一個 shell，它以終端作為標準輸入和標準輸出。首先顯示提示符(prompt)，它可能是一個美元符號($)，提示用戶 shell 正在等待接收命令，假如用戶輸入</p><pre><code>date</code></pre><p>shell 會創建一個子進程，並運行 date 做為子進程。在該子進程運行期間，shell 將等待它結束。在子進程完成時，shell 會顯示提示符並等待下一行輸入。</p><p>用戶可以將標準輸出重定向到一個文件中，例如</p><pre><code>date &gt; file</code></pre><p>同樣的，也可以將標準輸入作為重定向</p><pre><code>sort &lt;file1&gt; file2</code></pre><p>這會調用 sort 程序來接收 file1 的內容並把結果輸出到 file2。</p><p>可以將一個應用程序的輸出通過管道作為另一個程序的輸入，因此有</p><pre><code>cat file1 file2 file3 | sort &gt; /dev/lp</code></pre><p>這會調用 cat 應用程序來合併三個文件，將其結果輸送到 sort 程序中並按照字典進行排序。sort 應用程序又被重定向到 /dev/lp ，顯然這是一個打印操作。</p><h2 class=pgc-h-arrow-right>系統調用</h2><p>我們已經可以看到操作系統提供了兩種功能：為用戶提供應用程序抽象和管理計算機資源。對於大部分在應用程序和操作系統之間的交互主要是應用程序的抽象，例如創建、寫入、讀取和刪除文件。計算機的資源管理對用戶來說基本上是透明的。因此，用戶程序和操作系統之間的接口主要是處理抽象。為了真正理解操作系統的行為，我們必須仔細的分析這個接口。</p><p>多數現代操作系統都有功能相同但是細節不同的系統調用，引發操作系統的調用依賴於計算機自身的機制，而且必須用匯編代碼表達。<strong>任何單 CPU 計算機一次執行執行一條指令</strong>。如果一個進程在用戶態下運行用戶程序，例如從文件中讀取數據。那麼如果想要把控制權交給操作系統控制，那麼必須執行一個異常指令或者系統調用指令。操作系統緊接著需要參數檢查找出所需要的調用進程。操作系統緊接著進行參數檢查找出所需要的調用進程。然後執行系統調用，把控制權移交給系統調用下面的指令。大致來說，系統調用就像是執行了一個特殊的過程調用，但是隻有<strong>系統調用能夠進入內核態而過程調用則不能進入內核態</strong>。</p><p>為了能夠了解具體的調用過程，下面我們以 read 方法為例來看一下調用過程。像上面提到的那樣，會有三個參數，第一個參數是指定文件、第二個是指向緩衝區、第三個參數是給定需要讀取的字節數。就像幾乎所有系統調用一樣，它通過使用與系統調用相同的名稱來調用一個函數庫，從而從C程序中調用：read。</p><pre><code>count = read(fd,buffer,nbytes);</code></pre><p>系統調用在 count 中返回實際讀出的字節數。這個值通常與 nbytes 相同，但也可能更小。比如在讀過程中遇到了文件尾的情況。</p><p>如果系統調用不能執行，不管是因為無效的參數還是磁盤錯誤，count 的值都會被置成 -1，然後在全局變量 errno 中放入錯誤信號。程序應該進場檢查系統調用的結果以瞭解是否出錯。</p><p>系統調用是通過一系列的步驟實現的，為了更清楚的說明這個概念，我們還以 read 調用為例，在準備系統調用前，首先會把參數壓入堆棧，如下所示</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a7de76e044334b94ad2ed7ab0f3aa6e5><p class=pgc-img-caption></p></div><p>C 和 C++ 編譯器使用逆序（必須把第一個參數賦值給 printf(格式字符串)，放在堆棧的頂部）。第一個參數和第三個參數都是值調用，但是第二個參數通過引用傳遞，即傳遞的是緩衝區的地址（由 & 指示），而不是緩衝的內容。然後是 C 調用系統庫的 read 函數，這也是第四步。</p><p>在由彙編語言寫成的庫過程中，一般把系統調用的編號放在操作系統所期望的地方，如寄存器（第五步）。然後執行一個 TRAP 指令，將用戶態切換到內核態，並在內核中的一個固定地址開始執行第六步。TRAP 指令實際上與過程調用指令非常相似，它們後面都跟隨一個來自遠處位置的指令，以及供以後使用的一個保存在棧中的返回地址。</p><p>TRAP 指令與過程調用指令存在兩個方面的不同</p><ul><li>TRAP 指令會改變操作系統的狀態，由用戶態切換到內核態，而過程調用不改變模式</li><li>其次，TRAP 指令不能跳轉到任意地址上。根據機器的體系結構，要麼跳轉到一個單固定地址上，或者指令中有一 8 位長的字段，它給定了內存中一張表格的索引，這張表格中含有跳轉地址，然後跳轉到指定地址上。</li></ul><p>跟隨在 TRAP 指令後的內核代碼開始檢查系統調用編號，然後dispatch給正確的系統調用處理器，這通常是通過一張由系統調用編號所引用的、指向系統調用處理器的指針表來完成第七步。此時，系統調用處理器運行第八步，一旦系統調用處理器完成工作，控制權會根據 TRAP 指令後面的指令中返回給函數調用庫第九步。這個過程接著以通常的過程調用返回的方式，返回到客戶應用程序，這是第十步。然後調用完成後，操作系統還必須清除用戶堆棧，然後增加堆棧指針(increment stackpointer)，用來清除調用 read 之前壓入的參數。從而完成整個 read 調用過程。</p><p>在上面的第九步中我們說道，控制可能返回 TRAP 指令後面的指令，把控制權再移交給調用者這個過程中，系統調用會發生阻塞，從而避免應用程序繼續執行。這麼做是有原因的。例如，如果試圖讀鍵盤，此時並沒有任何輸入，那麼調用者就必須被阻塞。在這種情形下，操作系統會檢查是否有其他可以運行的進程。這樣，當有用戶輸入 時候，進程會提醒操作系統，然後返回第 9 步繼續運行。</p><p>下面，我們會列出一些常用的 POSIX 系統調用，POSIX 系統調用大概有 100 多個，它們之中最重要的一些調用見下表</p><p><strong>進程管理</strong></p><p>調用說明pid = fork()創建與父進程相同的子進程pid = waitpid(pid, &statloc,options)等待一個子進程終止s = execve(name,argv,environp)替換一個進程的核心映像exit(status)終止進程執行並返回狀態</p><p><strong>文件管理</strong></p><p>調用說明fd = open(file, how,...)打開一個文件使用讀、寫s = close(fd)關閉一個打開的文件n = read(fd,buffer,nbytes)把數據從一個文件讀到緩衝區中n = write(fd,buffer,nbytes)把數據從緩衝區寫到一個文件中position = iseek(fd,offset,whence)移動文件指針s = stat(name,&buf)取得文件狀態信息</p><p><strong>目錄和文件系統管理</strong></p><p>調用說明s = mkdir(nname,mode)創建一個新目錄s = rmdir(name)刪去一個空目錄s = link(name1,name2)創建一個新目錄項 name2,並指向 name1s = unlink(name)刪去一個目錄項s = mount(special,name,flag)安裝一個文件系統s = umount(special)卸載一個文件系統</p><p><strong>其他</strong></p><p>調用說明s = chdir(dirname)改變工作目錄s = chmod(name,mode)修改一個文件的保護位s = kill(pid, signal)發送信號給進程seconds = time(&seconds)獲取從 1970 年1月1日至今的時間</p><p>上面的系統調用參數中有一些公共部分，例如 pid 系統進程 id，fd 是文件描述符，n 是字節數，position 是在文件中的偏移量、seconds 是流逝時間。</p><p>從宏觀角度上看，這些系統調所提供的服務確定了多數操作系統應該具有的功能，下面分別來對不同的系統調用進行解釋</p><h3 class=pgc-h-arrow-right>用於進程管理的系統調用</h3><p>在 UNIX 中，fork 是唯一可以在 POSIX 中創建進程的途徑，它創建一個原有進程的副本，包括所有的文件描述符、寄存器等內容。在 fork 之後，原有進程以及副本（父與子）就分開了。在 fork 過程中，所有的變量都有相同的值，雖然父進程的數據通過複製給子進程，但是後續對其中任何一個進程的修改不會影響到另外一個。fork 調用會返回一個值，在子進程中該值為 0 ，並且在父進程中等於子進程的 進程標識符(Process IDentified,PID)。使用返回的 PID，就可以看出來哪個是父進程和子進程。</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/12b589dcf1a24da18e6a833c97f0965c><p class=pgc-img-caption></p></div><p>在多數情況下， 在 fork 之後，子進程需要執行和父進程不一樣的代碼。從終端讀取命令，創建一個子進程，等待子進程執行命令，當子進程結束後再讀取下一個輸入的指令。為了等待子進程完成，父進程需要執行 waitpid 系統調用，父進程會等待直至子進程終止（若有多個子進程的話，則直至任何一個子進程終止）。waitpid 可以等待一個特定的子進程，或者通過將第一個參數設為 -1 的方式，等待任何一個比較老的子進程。當 waitpid 完成後，會將第二個參數 statloc 所指向的地址設置為子進程的退出狀態（正常或異常終止以及退出值）。有各種可使用的選項，它們由第三個參數確定。例如，如果沒有已經退出的子進程則立刻返回。</p><p>那麼 shell 該如何使用 fork 呢？在鍵入一條命令後，shell 會調用 fork 命令創建一個新的進程。這個子進程會執行用戶的指令。通過使用 execve 系統調用可以實現系統執行，這個系統調用會引起整個核心映像被一個文件所替代，該文件由第一個參數給定。下面是一個簡化版的例子說明 fork、waitpid 和 execve 的使用</p><pre><code>#define TRUE 1while(TRUE){                                                                /* 一直循環下去 */    type_prompt();                                                      /* 在屏幕上顯示提示符 */    read_command(command,parameters)                    /* 從終端讀取輸入 */    if(fork() != 0){                                                    /* fork 子進程 */        /* 父代碼 */        waitpid(-1, &amp;status, 0);                                /* 等待子進程執行完畢 */    }else{        /* 子代碼 */        execve(command,parameters,0)                        /* 執行命令 */    }}</code></pre><p>一般情況下，execve 有三個參數：將要執行的文件名稱，一個指向變量數組的指針，以及一個指向環境數組的指針。這裡對這些參數做一個簡要的說明。</p><p>先看一個 shell 指令</p><pre><code>cp file1 file2</code></pre><p>此命令把 file1 複製到 file2 文件中，在 shell 執行 fork 之後，子進程定位並執行文件拷貝，並將源文件和目標文件的名稱傳遞給它。</p><p>cp 的主程序（以及包含其他大多數 C 程序的主程序）包含聲明</p><pre><code>main(argc,argv,envp)</code></pre><p>其中 argc 是命令行中參數數目的計數，包括程序名稱。對於上面的例子，argc 是3。第二個參數argv 是數組的指針。該數組的元素 i 是指向該命令行第 i 個字符串的指針。在上面的例子中，argv[0] 指向字符串 cp，argv[1] 指向字符串 file1，argv[2] 指向字符串 file2。main 的第三個參數是指向環境的指針，該環境是一個數組，含有 name = value 的賦值形式，用以將諸如終端類型以及根目錄等信息傳送給程序。這些變量通常用來確定用戶希望如何完成特定的任務（例如，使用默認打印機）。在上面的例子中，沒有環境參數傳遞給 execve ，所以環境變量是 0 ，所以 execve 的第三個參數為 0 。</p><p>可能你覺得 execve 過於複雜，這時候我要鼓勵一下你，execve 可能是 POSIX 的全部系統調用中最複雜的一個了，其他都比較簡單。作為一個簡單的例子，我們再來看一下 exit ，這是進程在執行完成後應執行的系統調用。這個系統調用有一個參數，它的退出狀態是 0 - 255 之間，它通過 waitpid 系統調用中的 statloc 返回給父級。</p><p>UNIX 中的進程將內存劃分成三個部分：text segment,文本區，例如程序代碼，data segment，數據區，例如變量，stack segment，棧區域。數據向上增長而堆棧向下增長，如下圖所示</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44673d3d458f4fdcb219e97aa8d224c9><p class=pgc-img-caption></p></div><p>上圖能說明三個部分的內存分配情況，夾在中間的是空閒區，也就是未分配的區域，堆棧在需要時自動的擠壓空閒區域，不過數據段的擴展是顯示地通過系統調用 brk 進行的，在數據段擴充後，該系統調用指向一個新地址。但是，這個調用不是 POSIX 標準中定義的，對於存儲器的動態分配，鼓勵程序員使用 malloc 函數，而 malloc 的內部實現則不是一個適合標準化的主題，因為幾乎沒有程序員直接使用它。</p><h3 class=pgc-h-arrow-right>用於文件管理的系統調用</h3><p>許多系統調用都與文件系統有關，要讀寫一個文件，必須先將其打開。這個系統調用通過絕對路徑名或指向工作目錄的相對路徑名指定要打開文件的名稱，而代碼 O_RDONLY、 O_WRONLY 或 O_RDWR 的含義分別是隻讀、只寫或者兩者都可以，為了創建一個新文件，使用 O_CREATE 參數。然後可使用返回的文件描述符進行讀寫操作。接著，可以使用 close 關閉文件，這個調用使得文件描述符在後續的 open 中被再次使用。</p><p>最常用的調用還是 read 和 write，我們再前面探討過 read 調用，write 具有與 read 相同的參數。</p><p>儘管多數程序頻繁的讀寫文件，但是仍有一些應用程序需要能夠隨機訪問一個文件的任意部分。與每個文件相關的是一個指向文件當前位置的指針。在順序讀寫時，該指針通常指向要讀出（寫入）的下一個字節。Iseek 調用可以改變該位置指針的值，這樣後續的 read 或 write 調用就可以在文件的任何地方開始。</p><p>Iseek 有三個參數，position = iseek(fd,offset,whence)，第一個是文件描述符，第二個是文件位置，第三個是說明該文件位置是相對於文件起始位置，當前位置還是文件的結尾。在修改了指針之後，Iseek 所返回的值是文件中的絕對位置。</p><p>UNIX 為每個文件保存了該文件的類型（普通文件、特殊文件、目錄等）、大小，最後修改時間以及其他信息，程序可以通過 stat 系統調用查看這些信息。s = stat(name,&buf)，第一個參數指定了被檢查的文件；第二個參數是一個指針，該指針指向存放這些信息的結構。對於一個打開的文件而言，fstat 調用完成同樣的工作。</p><h3 class=pgc-h-arrow-right>用於目錄管理的系統調用</h3><p>下面我們探討目錄和整個文件系統的系統調用，上面探討的是和某個文件有關的系統調用。 mkdir 和 rmdir 分別用於創建s = mkdir(nname,mode) 和刪除 s = rmdir(name) 空目錄，下一個調用是 s = link(name1,name2) 它的作用是允許同一個文件以兩個或者多個名稱出現，多數情況下是在不同的目錄中使用 link ，下面我們探討一下 link 是如何工作的</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90cb0701637248aeb81bfafc06536faf><p class=pgc-img-caption></p></div><p>圖中有兩個用戶 ast 和 jim，每個用戶都有他自己的一個目錄和一些文件，如果 ast 要執行一個包含下面系統調用的應用程序</p><pre><code>link("/usr/jim/memo", "/usr/ast/note");</code></pre><p>jim 中的 memo 文件現在會進入到 ast 的目錄中，在 note 名稱下。此後，/usr/jim/memo和 /usr/ast/note 會有相同的名稱。</p><blockquote><p>用戶目錄是保存在 /usr，/user，/home 還是其他位置，都是由本地系統管理員決定的。</p></blockquote><p>要理解 link 是如何工作的需要清楚 link 做了什麼操作。UNIX 中的每個文件都有一個獨一無二的版本，也稱作 i - number，i-編號，它標示著不同文件的版本。這個 i - 編號是 i-nodes,i-節點 表的索引。每個文件都會表明誰擁有這個文件，這個磁盤塊的位置在哪，等等。目錄只是一個包含一組（i編號，ASCII名稱）對應的文件。UNIX 中的第一個版本中，每個目錄項都會有 16 個字節，2 個字節對應 i - 編號和 14 個字節對應其名稱。現在需要一個更復雜的結構需要支持長文件名，但是從概念上講一個目錄仍是一系列（i-編號，ASCII 名稱）的集合。在上圖中，mail 的 i-編號為 16，依此類推。link 只是利用某個已有文件的 i-編號，創建一個新目錄項（也許用一個新名稱）。在上圖 b 中，你會發現有兩個相同的 70 i-編號的文件，因此它們需要有相同的文件。如果其中一個使用了 unlink系統調用的話，其中一個會被移除，另一個將保留。如果兩個文件都移除了，則 UNIX 會發現該文件不存在任何沒有目錄項（i-節點中的一個域記錄著指向該文件的目錄項），就會把該文件從磁盤中移除。</p><p>就像我們上面提到過的那樣，mount 系統 s = mount(special,name,flag) 調用會將兩個文件系統合併為一個。通常的情況是將根文件系統分佈在硬盤（子）分區上，並將用戶文件分佈在另一個（子）分區上，該根文件系統包含常用命令的二進制（可執行）版本和其他使用頻繁的文件。然後，用戶就會插入可讀取的 USB 硬盤。</p><p>通過執行 mount 系統調用，USB 文件系統可以被添加到根文件系統中，</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ac43a3695c3a48009d32e203ba942a5e><p class=pgc-img-caption></p></div><p>如果用 C 語言來執行那就是</p><pre><code>mount("/dev/sdb0","/mnt",0)</code></pre><p>這裡，第一個參數是 USB 驅動器 0 的塊特殊文件名稱，第二個參數是被安裝在樹中的位置，第三個參數說明將要安裝的文件系統是可讀寫的還是隻讀的。</p><p>當不再需要一個文件系統時，可以使用 umount 移除之。</p><h3 class=pgc-h-arrow-right>其他系統調用</h3><p>除了進程、文件、目錄系統調用，也存在其他系統調用的情況，下面我們來探討一下。我們可以看到上面其他系統調用只有四種，首先來看第一個 chdir，chdir 調用更改當前工作目錄，在調用</p><pre><code>chdir("/usr/ast/test");</code></pre><p>後，打開 xyz 文件，會打開 /usr/ast/test/xyz 文件，工作目錄的概念消除了總是需要輸入長文件名的需要。</p><p>在 UNIX 系統中，每個文件都會有保護模式，這個模式會有一個讀-寫-執行位，它用來區分所有者、組和其他成員。chmod 系統調用提供改變文件模式的操作。例如，要使一個文件除了對所有者之外的用戶可讀，你可以執行</p><pre><code>chmod("file",0644); </code></pre><p>kill 系統調用是用戶和用戶進程發送信號的方式，如果一個進程準備好捕捉一個特定的信號，那麼在信號捕捉之前，會運行一個信號處理程序。如果進程沒有準備好捕捉特定的信號，那麼信號的到來會殺掉該進程（此名字的由來）。</p><p>POSIX 定義了若干時間處理的進程。例如，time 以秒為單位返回當前時間，0 對應著 1970 年 1月 1日。在一臺 32 位字的計算機中，time 的最大值是 (2^32) - 1秒，這個數字對應 136 年多一點。所以在 2106 年，32 位的 UNIX 系統會發飆。如果讀者現在有 32 位 UNIX 系統，建議在 2106 年更換位 64 位操作系統（偷笑～）。</p><h3 class=pgc-h-arrow-right>Win 32 API</h3><p>上面我們提到的都是 UNIX 系統調用，現在我們來聊聊 Win 32 中的系統調用。Windows 和 UNIX 在各自的編程方式上有著根本的不同。UNIX 程序由執行某些操作或執行其他操作的代碼組成，進行系統調用以執行某些服務。Windows 系統則不同，Windows 應用程序通常是由事件驅動的。主程序會等待一些事件發生，然後調用程序去處理。最簡單的事件處理是鍵盤敲擊和鼠標滑過，或者是鼠標點擊，或者是插入 USB 驅動，然後操作系統調用處理器去處理事件，更新屏幕和更新程序內部狀態。這是與 UNIX 不同的設計風格。</p><p>當然，Windows 也有系統調用。在 UNIX 中，系統調用（比如 read）和系統調用所使用的調用庫（例如 read）幾乎是一對一的關係。而在 Windows 中，情況則大不相同。首先，函數庫的調用和實際的系統調用幾乎是不對應的。微軟定義了一系列過程，稱為 Win32應用編程接口(Application Programming Interface)，程序員通過這套標準的接口來實現系統調用。這個接口支持從 Windows 95 版本以來所有的 Windows 版本。</p><p>Win32 API 調用的數量是非常巨大的，有數千個多。但這些調用並不都是在內核態的模式下運行時，有一些是在用戶態的模型下運行。Win32 API 有大量的調用，用來管理視窗、幾何圖形、文本、字體、滾動條、對話框、菜單以及 GUI 的其他功能。為了使圖形子系統在內核態下運行，需要系統調用，否則就只有函數庫調用。</p><p>我們把關注點放在和 Win32 系統調用中來，我們可以簡單看一下 Win32 API 中的系統調用和 UNIX 中有什麼不同（並不是所有的系統調用）</p><p>UNIXWin32說明forkCreateProcess創建一個新進程waitpidWaitForSingleObject等待一個進程退出execvenoneCraeteProcess = fork + servviceexitExitProcess終止執行openCreateFile創建一個文件或打開一個已有的文件closeCloseHandle關閉文件readReadFile從單個文件中讀取數據writeWriteFile向單個文件寫數據lseekSetFilePointer移動文件指針statGetFileAttributesEx獲得不同的文件屬性mkdirCreateDirectory創建一個新的目錄rmdirRemoveDirectory移除一個空的目錄linknoneWin32 不支持 linkunlinkDeleteFile銷燬一個已有的文件mountnoneWin32 不支持 mountumountnoneWin32 不支持 mount，所以也不支持mountchdirSetCurrentDirectory切換當前工作目錄chmodnoneWin32 不支持安全killnoneWin32 不支持信號timeGetLocalTime獲取當前時間</p><p>上表中是 UNIX 調用大致對應的 Win32 API 系統調用，簡述一下上表。CreateProcess 用於創建一個新進程，它把 UNIX 中的 fork 和 execve 兩個指令合成一個，一起執行。它有許多參數用來指定新創建進程的性質。Windows 中沒有類似 UNIX 中的進程層次，所以不存在父進程和子進程的概念。在進程創建之後，創建者和被創建者是平等的。WaitForSingleObject 用於等待一個事件，等待的事件可以是多種可能的事件。如果有參數指定了某個進程，那麼調用者將等待指定的進程退出，這通過 ExitProcess 來完成。</p><p>然後是6個文件操作，在功能上和 UNIX 的調用類似，然而在參數和細節上是不同的。和 UNIX 中一樣，文件可以打開，讀取，寫入，關閉。SetFilePointer 和 GetFileAttributesEx 設置文件的位置並取得文件的屬性。</p><p>Windows 中有目錄，目錄分別用 CreateDirectory 以及 RemoveDirectory API 調用創建和刪除。也有對當前的目錄的標記，這可以通過 SetCurrentDirectory 來設置。使用GetLocalTime 可獲得當前時間。</p><p>Win32 接口中沒有文件的鏈接、文件系統的 mount、umount 和 stat ，當然， Win32 中也有大量 UNIX 中沒有的系統調用，特別是對 GUI 的管理和調用。</p><h2 class=pgc-h-arrow-right>操作系統結構</h2><p>下面我們會探討操作系統的幾種結構，主要包括<strong>單體結構、分層系統、微內核、客戶-服務端系統、虛擬機和外核</strong>等。下面以此來探討一下</p><h3 class=pgc-h-arrow-right>單體系統</h3><p>到目前為止，在大多數系統中，整個系統在內核態以單一程序的方式運行。整個操作系統是以程序集合來編寫的，鏈接在一塊形成一個大的二進制可執行程序。使用此技術時，如果系統中的每個過程都提供了前者所需的一些有用的計算，則它可以自由調用任何其他過程。在單體系統中，調用任何一個所需要的程序都非常高效，但是上千個不受限制的彼此調用往往非常臃腫和笨拙，而且單體系統必然存在單體問題，那就是隻要系統發生故障，那麼任何系統和應用程序將不可用，這往往是災難性的。</p><p>在單體系統中構造實際目標程序時，會首先編譯所有單個過程（或包含這些過程的文件），然後使用系統鏈接器將它們全部綁定到一個可執行文件中</p><p>對於單體系統，往往有下面幾種建議</p><ul><li>需要有一個主程序，用來調用請求服務程序</li><li>需要一套服務過程，用來執行系統調用</li><li>需要一套服務程序，用來輔助服務過程調用</li></ul><p>在單體系統中，對於每個系統調用都會有一個服務程序來保障和運行。需要一組實用程序來彌補服務程序需要的功能，例如從用戶程序中獲取數據。可將各種過程劃分為一個三層模型</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/da3c7405f33b4bfb94ca60a38a5e6d53><p class=pgc-img-caption></p></div><p>除了在計算機初啟動時所裝載的核心操作系統外，許多操作系統還支持額外的擴展。比如 I/O 設備驅動和文件系統。這些部件可以按需裝載。在 UNIX 中把它們叫做 共享庫(shared library)，在 Windows 中則被稱為 動態鏈接庫(Dynamic Link Library,DLL)。他們的擴展名為 .dll，在 C:\Windows\system32 目錄下存在 1000 多個 DLL 文件，所以不要輕易刪除 C 盤文件，否則可能就炸了哦。</p><h3 class=pgc-h-arrow-right>分層系統</h3><p>分層系統使用層來分隔不同的功能單元。每一層只與該層的上層和下層通信。每一層都使用下面的層來執行其功能。層之間的通信通過預定義的固定接口通信。</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/acbba9bafcfa4cbf97c52ac52979335c><p class=pgc-img-caption></p></div><p>分層系統是由 E.W.Dijkstar 和他的學生在荷蘭技術學院所開發的 THE 系統。</p><p>把上面單體系統進一步通用化，就變為了一個層次式結構的操作系統，它的上層軟件都是在下層軟件的基礎之上構建的。該系統分為六層，如下所示</p><p>層號功能5操作員4用戶程序3輸入/輸出管理2操作員-進程通信1存儲器和磁鼓管理0處理器分配和多道程序編程</p><p>處理器在 0 層運行，當中斷髮生或定時器到期時，由該層完成進程切換；在第 0 層之上，系統由一些連續的進程組成，編寫這些進程時不用再考慮在單處理器上多進程運行的細節。內存管理在第 1 層，它分配進程的主存空間。第 1 層軟件保證一旦需要訪問某一頁面，該頁面必定已經在內存中，並且在頁面不需要的時候將其移出。</p><p>第 2 層處理進程與操作員控制檯（即用戶）之間的通信。第 3 層管理 I/O 設備和相關的信息流緩衝區。第 4 層是用戶程序層，用戶程序不用考慮進程、內存、控制檯或 I/O 設備管理等細節。系統操作員在第 5 層。</p><h3 class=pgc-h-arrow-right>微內核</h3><p>在分層方式中，設計者要確定在哪裡劃分 內核-用戶 的邊界。傳統上，所有的層都在內核中，但是這樣做沒有必要。事實上，儘可能減少內核態中功能可能是更好的做法。因為內核中的錯誤很難處理，一旦內核態中出錯誤會拖累整個系統。</p><p>所以，為了實現高可靠性，將操作系統劃分成小的、層級之間能夠更好定義的模塊是很有必要的，只有一個模塊 --- 微內核 --- 運行在內核態，其餘模塊可以作為普通用戶進程運行。由於把每個設備驅動和文件系統分別作為普通用戶進程，這些模塊中的錯誤雖然會使這些模塊崩潰，但是不會使整個系統死機。</p><p>MINIX 3 是微內核的代表作，它的具體結構如下</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ef68b536dd2467faa2958faf3a8badc><p class=pgc-img-caption></p></div><p>在內核的外部，系統的構造有三層，它們都在用戶態下運行，最底層是設備驅動器。由於它們都在用戶態下運行，所以不能物理的訪問 I/O 端口空間，也不能直接發出 I/O 命令。相反，為了能夠對 I/O 設備編程，驅動器構建一個結構，指明哪個參數值寫到哪個 I/O 端口，並聲稱一個內核調用，這樣就完成了一次調用過程。</p><p>位於用戶態的驅動程序上面是服務器層，包含有服務器，它們完成操作系統的多數工作。由一個或多個文件服務器管理著文件系統，進程管理器創建、銷燬和管理進程。服務器中有一個特殊的服務器稱為 再生服務器(reincarnation server)，它的任務就是檢查服務器和驅動程序的功能是否正確，一旦檢查出來錯誤，它就會補上去，無需用戶干預。這種方式使得系統具有可恢復性，並具有較高的可靠性。</p><p>微內核中的內核還具有一種 機制 與 策略 分離的思想。比如系統調度，一個比較簡單的調度算法是，對每個進程賦予一個優先級，並讓內核執行具有最高優先級的進程。這裡，內核機制就是尋找最高的優先級進程並運行。而策略（賦予進程優先級）可以在用戶態中的進程完成。在這種模式中，策略和機制是分離的，從而使內核變得更小。</p><h3 class=pgc-h-arrow-right>客戶-服務器模式</h3><p>微內核思想的策略是把進程劃分為兩類：服務器，每個服務器用來提供服務；客戶端，使用這些服務。這個模式就是所謂的 客戶-服務器模式。</p><p>客戶-服務器模式會有兩種載體，一種情況是一臺計算機既是客戶又是服務器，在這種方式下，操作系統會有某種優化；但是普遍情況下是客戶端和服務器在不同的機器上，它們通過局域網或廣域網連接。</p><div class=pgc-img><img alt=一文帶你瞭解操作系統核心概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/61b00a395a514f6cbacc39e7a470aae5><p class=pgc-img-caption></p></div><p>客戶通過發送消息與服務器通信，客戶端並不需要知道這些消息是在本地機器上處理，還是通過網絡被送到遠程機器上處理。對於客戶端而言，這兩種情形是一樣的：都是發送請求並得到迴應。</p><p>越來越多的系統，包括家裡的 PC，都成為客戶端，而在某地運行的大型機器則成為服務器。許多 web 就是以這種方式運行的。一臺 PC 向某個服務器請求一個 Web 頁面，服務器把 Web 頁面返回給客戶端，這就是典型的客服-服務器模式</p><p>文章參考：</p><p>《現代操作系統》第四版</p><p>https://baike.baidu.com/item/操作系統/192?fr=aladdin</p><p>《Modern Operating System》forth edition</p><p>http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm</p><p>https://www.computerhope.com/jargon/c/clockcyc.htm</p><p>《B站-操作系統》</p><p>https://www.bilibili.com/video/av9555596?from=search&seid=8107077283516919308</p><p>https://en.wikipedia.org/wiki/System_call</p><p>http://c.biancheng.net/cpp/html/238.html</p><p>http://www.dossier-andreas.net/software_architecture/layers.html</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>瞭解</a></li><li><a>系統</a></li><li><a>一文</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/99e5cb36.html alt=瞭解PLC系統的基本構成 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab09bbed8066468e9d53996846985765 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99e5cb36.html title=瞭解PLC系統的基本構成>瞭解PLC系統的基本構成</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd75dea8.html alt="系統瞭解 Linux 文件系統" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3b15000077fa0e231516 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd75dea8.html title="系統瞭解 Linux 文件系統">系統瞭解 Linux 文件系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e50d611f.html alt=UNin操作系統你知道多少，瞭解一下？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6bea708b87314356b1ed20f889a251ff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e50d611f.html title=UNin操作系統你知道多少，瞭解一下？>UNin操作系統你知道多少，瞭解一下？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af32b586.html alt=學長帶你瞭解操作系統之處理機調度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af32b586.html title=學長帶你瞭解操作系統之處理機調度>學長帶你瞭解操作系統之處理機調度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3e92d92.html alt="Linux系統移植之——不瞭解GNU gcc glibc你好意思說是搞Linux的" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c78ac1103bdd4229af9175525588ce08 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3e92d92.html title="Linux系統移植之——不瞭解GNU gcc glibc你好意思說是搞Linux的">Linux系統移植之——不瞭解GNU gcc glibc你好意思說是搞Linux的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d7631924.html alt=你對移動通信系統瞭解多少 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/959a9f204b3b4232853bd12bc2c498f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d7631924.html title=你對移動通信系統瞭解多少>你對移動通信系統瞭解多少</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96cbd3b.html alt=系統瞭解水磨石地坪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4775eea4b57446fc846384880517374e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96cbd3b.html title=系統瞭解水磨石地坪>系統瞭解水磨石地坪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96b6051.html alt=三分鐘瞭解制動系統，追尾事故能減少70% class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/26e70004dc23608c2c43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96b6051.html title=三分鐘瞭解制動系統，追尾事故能減少70%>三分鐘瞭解制動系統，追尾事故能減少70%</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dff8286.html alt=3分鐘帶你瞭解系統建模的本質｜《規模》 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1536829302662ecee0bf8c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dff8286.html title=3分鐘帶你瞭解系統建模的本質｜《規模》>3分鐘帶你瞭解系統建模的本質｜《規模》</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42a29bc.html alt=十大物聯網操作系統，你瞭解多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0f4baad2699c413fbc793600e4dd6965 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42a29bc.html title=十大物聯網操作系統，你瞭解多少？>十大物聯網操作系統，你瞭解多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a59082a.html alt=一文帶你入門操作系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/69a8ed9d146848388d790a8f4a22e99c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a59082a.html title=一文帶你入門操作系統>一文帶你入門操作系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e1d886.html alt=「你真的知道嗎」一文帶你全面瞭解光纖的“祕密” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d8c90f34cdf942ce814879fab5568e26 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e1d886.html title=「你真的知道嗎」一文帶你全面瞭解光纖的“祕密”>「你真的知道嗎」一文帶你全面瞭解光纖的“祕密”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f4f434.html alt=一文帶你瞭解噪聲係數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c2a4158f9322457db0431955cc6e9925 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f4f434.html title=一文帶你瞭解噪聲係數>一文帶你瞭解噪聲係數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html alt=兩分鐘瞭解低損耗電纜結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9af84f52bbed4ee39f3825e0f43e619b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html title=兩分鐘瞭解低損耗電纜結構>兩分鐘瞭解低損耗電纜結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html alt=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/decf8edb02a34404b92b86681378575f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html title=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>