<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 | 极客快訊</title><meta property="og:title" content="大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/a0a360ea-5629-4382-b8f0-87c9b83083de"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><meta property="article:published_time" content="2020-10-29T21:09:16+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:16+08:00"><meta name=Keywords content><meta name=description content="大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c15b9453.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/a0a360ea-5629-4382-b8f0-87c9b83083de><p class=pgc-img-caption></p></div><p><strong>List和Set比較，各自的子類比較</strong></p><p><strong>對比一：</strong> <strong>Arraylist與LinkedList的比較</strong></p><p>1、ArrayList是實現了基於動態數組的數據結構,因為地址連續，一旦數據存儲好了，查詢操作效率會比較高（在內存裡是連著放的）。</p><p>2、因為地址連續， ArrayList要移動數據,所以插入和刪除操作效率比較低。</p><p>3、LinkedList基於鏈表的數據結構,地址是任意的，所以在開闢內存空間的時候不需要等一個連續的地址，對於新增和刪除操作add和remove，LinedList比較佔優勢。</p><p>4、因為LinkedList要移動指針,所以查詢操作性能比較低。</p><p><strong>適用場景分析：</strong></p><p>當需要對數據進行對此訪問的情況下選用ArrayList，當需要對數據進行多次增加刪除修改時採用LinkedList。</p><p><strong>對比二：</strong> <strong>ArrayList與Vector的比較</strong></p><p>1、Vector的方法都是同步的，是線程安全的，而ArrayList的方法不是，由於線程的同步必然要影響性能。因此，ArrayList的性能比Vector好。</p><p>2、當Vector或ArrayList中的元素超過它的初始大小時，Vector會將它的容量翻倍，而ArrayList只增加50%的大小，這樣。ArrayList就有利於節約內存空間。</p><p>3、大多數情況不使用Vector，因為性能不好，但是它支持線程的同步，即某一時刻只有一個線程能夠寫Vector，避免多線程同時寫而引起的不一致性。</p><p>4、Vector可以設置增長因子，而ArrayList不可以。</p><p><strong>適用場景分析：</strong></p><p>1、Vector是線程同步的，所以它也是線程安全的，而ArrayList是線程異步的，是不安全的。如果不考慮到線程的安全因素，一般用ArrayList效率比較高。</p><p>2、如果集合中的元素的數目大於目前集合數組的長度時，在集合中使用數據量比較大的數據，用Vector有一定的優勢。</p><p><strong>對比三：</strong> <strong>HashSet與TreeSet的比較</strong></p><p>1.TreeSet 是二叉樹實現的，Treeset中的數據是自動排好序的，不允許放入null值 。</p><p>2.HashSet 是哈希表實現的，HashSet中的數據是無序的，可以放入null，但只能放入一個null，兩者中的值都不能重複，就如數據庫中唯一約束 。</p><p>3.HashSet要求放入的對象必須實現HashCode()方法，放入的對象，是以hashcode碼作為標識的，而具有相同內容的String對象，hashcode是一樣，所以放入的內容不能重複。但是同一個類的對象可以放入不同的實例。</p><p><strong>適用場景分析：</strong></p><p>HashSet是基於Hash算法實現的，其性能通常都優於TreeSet。我們通常都應該使用HashSet，在我們需要排序的功能時，我們才使用TreeSet。</p><p><strong>HashMap和ConcurrentHashMap的區別</strong></p><p>1、HashMap不是線程安全的，而ConcurrentHashMap是線程安全的。</p><p>2、ConcurrentHashMap採用鎖分段技術，將整個Hash桶進行了分段segment，也就是將這個大的數組分成了幾個小的片段segment，而且每個小的片段segment上面都有鎖存在，那麼在插入元素的時候就需要先找到應該插入到哪一個片段segment，然後再在這個片段上面進行插入，而且這裡還需要獲取segment鎖。</p><p>3、ConcurrentHashMap讓鎖的粒度更精細一些，併發性能更好。</p><p>至於兩者的底層實現，你如果想通過一篇文章就理解了，那就too young了，好好找些博文+看源碼去吧。</p><p><strong>HashTable和ConcurrentHashMap的區別</strong></p><p>它們都可以用於多線程的環境，但是當Hashtable的大小增加到一定的時候，性能會急劇下降，因為迭代時需要被鎖定很長的時間。因為ConcurrentHashMap引入了分割(segmentation)，不論它變得多麼大，僅僅需要鎖定map的某個部分，而其它的線程不需要等到迭代完成才能訪問map。簡而言之，在迭代的過程中，ConcurrentHashMap僅僅鎖定map的某個部分，而Hashtable則會鎖定整個map。</p><p><strong>String,StringBuffer和StringBuilder的區別</strong></p><p>1、運行速度，或者說是執行速度，在這方面運行速度快慢為：StringBuilder > StringBuffer > String。</p><p>2、線程安全上，StringBuilder是線程不安全的，而StringBuffer是線程安全的。</p><p><strong>適用場景分析：</strong></p><p>String：適用於少量的字符串操作的情況</p><p>StringBuilder：適用於單線程下在字符緩衝區進行大量操作的情況</p><p>StringBuffer：適用多線程下在字符緩衝區進行大量操作的情況</p><div class=pgc-img><img alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/553805eb-fd78-4117-a341-72f82467334c><p class=pgc-img-caption></p></div><hr><p><strong>wait和sleep的區別</strong></p><p>1、sleep()方法是屬於Thread類中的，而wait()方法，則是屬於Object類中的。</p><p>2、sleep()方法導致了程序暫停執行指定的時間，讓出cpu給其他線程，但是他的監控狀態依然保持著，當指定的時間到了又會自動恢復運行狀態。所以在調用sleep()方法的過程中，線程不會釋放對象鎖。</p><p>3、調用wait()方法的時候，線程會放棄對象鎖，進入等待此對象的等待鎖定池，只有針對此對象調用notify()方法後本線程才進入對象鎖定池準備獲取對象鎖進入運行狀態。</p><p><strong>JVM的內存結構</strong></p><p>根據 JVM 規範，JVM 內存共分為虛擬機棧、堆、方法區、程序計數器、本地方法棧五個部分。</p><p><strong>1、Java虛擬機棧：</strong></p><p>線程私有；每個方法在執行的時候會創建一個棧幀，存儲了局部變量表，操作數棧，動態連接，方法返回地址等；每個方法從調用到執行完畢，對應一個棧幀在虛擬機棧中的入棧和出棧。</p><p><strong>2、堆：</strong></p><p>線程共享；被所有線程共享的一塊內存區域，在虛擬機啟動時創建，用於存放對象實例。</p><p><strong>3、方法區：</strong></p><p>線程共享；被所有線程共享的一塊內存區域；用於存儲已被虛擬機加載的類信息，常量，靜態變量等。</p><p><strong>4、程序計數器：</strong></p><p>線程私有；是當前線程所執行的字節碼的行號指示器，每條線程都要有一個獨立的程序計數器，這類內存也稱為“線程私有”的內存。</p><p><strong>5、本地方法棧：</strong></p><p>線程私有；主要為虛擬機使用到的Native方法服務。</p><p><strong>強引用，軟引用和弱引用的區別</strong></p><p><strong>強引用：</strong></p><p>只有這個引用被釋放之後，對象才會被釋放掉，只要引用存在，垃圾回收器永遠不會回收，這是最常見的New出來的對象。</p><p><strong>軟引用：</strong></p><p>內存溢出之前通過代碼回收的引用。軟引用主要用戶實現類似緩存的功能，在內存足夠的情況下直接通過軟引用取值，無需從繁忙的真實來源查詢數據，提升速度；當內存不足時，自動刪除這部分緩存數據，從真正的來源查詢這些數據。</p><p><strong>弱引用：</strong></p><p>第二次垃圾回收時回收的引用，短時間內通過弱引用取對應的數據，可以取到，當執行過第二次垃圾回收時，將返回null。弱引用主要用於監控對象是否已經被垃圾回收器標記為即將回收的垃圾，可以通過弱引用的isEnQueued方法返回對象是否被垃圾回收器標記。</p><p><strong>數組在內存中如何分配</strong></p><p>1、簡單的值類型的數組，每個數組成員是一個引用（指針），引用到棧上的空間（因為值類型變量的內存分配在棧上）</p><p>2、引用類型，類類型的數組，每個數組成員仍是一個引用（指針），引用到堆上的空間（因為類的實例的內存分配在堆上）</p><p><strong>springmvc的核心是什麼，請求的流程是怎麼處理的，控制反轉怎麼實現的</strong></p><p><strong>核心：</strong></p><p>控制反轉和麵向切面</p><p><strong>請求處理流程：</strong></p><p>1、首先用戶發送請求到前端控制器，前端控制器根據請求信息（如URL）來決定選擇哪一個頁面控制器進行處理並把請求委託給它，即以前的控制器的控制邏輯部分；</p><p>2、頁面控制器接收到請求後，進行功能處理，首先需要收集和綁定請求參數到一個對象，並進行驗證，然後將命令對象委託給業務對象進行處理；處理完畢後返回一個ModelAndView（模型數據和邏輯視圖名）；</p><p>3、前端控制器收回控制權，然後根據返回的邏輯視圖名，選擇相應的視圖進行渲染，並把模型數據傳入以便視圖渲染；</p><p>4、前端控制器再次收回控制權，將響應返回給用戶。</p><p><strong>控制反轉如何實現：</strong></p><p>我們每次使用spring框架都要配置xml文件，這個xml配置了bean的id和class。</p><p>spring中默認的bean為單實例模式，通過bean的class引用反射機制可以創建這個實例。</p><p>因此，spring框架通過反射替我們創建好了實例並且替我們維護他們。</p><p>A需要引用B類，spring框架就會通過xml把B實例的引用傳給了A的成員變量。</p><p><strong>mybatis如何處理結果集</strong></p><p>MyBatis的結果集是通過反射來實現的。並不是通過get/set方法。在實體類中無論是否定義get/set()方法，都是可以接收到的。</p><p>如果面試只是考你這個點的話就恭喜了。如果繼續深問流程，那就需要自己找一些源碼來閱讀了。</p><p><strong>java的多態表現在哪裡</strong></p><p>主要有兩種表現形式：重載和重寫</p><p><strong>重載：</strong></p><p>是發生在同一類中，具有相同的方法名，主要是看參數的個數，類型，順序不同實現方法的重載的，返回值的類型可以不同。</p><p><strong>重寫：</strong></p><p>是發生在兩個類中（父類和子類），具有相同的方法名，主要看方法中參數，個數，類型必須相同，返回值的類型必須相同。</p><hr><p><strong>接口有什麼用</strong></p><p>1、通過接口可以實現不相關類的相同行為，而不需要了解對象所對應的類。</p><p>2、通過接口可以指明多個類需要實現的方法。</p><p>3、通過接口可以瞭解對象的交互界面，而不需瞭解對象所對應的類。</p><p>另：Java是單繼承，接口可以使其實現多繼承的功能。</p><hr><p><strong>說說http,https協議</strong></p><p><strong>HTTP：</strong></p><p>是互聯網上應用最為廣泛的一種網絡協議，是一個客戶端和服務器端請求和應答的標準（TCP），用於從WWW服務器傳輸超文本到本地瀏覽器的傳輸協議，它可以使瀏覽器更加高效，使網絡傳輸減少。</p><p><strong>HTTPS：</strong></p><p>是以安全為目標的HTTP通道，簡單講是HTTP的安全版，即HTTP下加入SSL層，HTTPS的安全基礎是SSL，因此加密的詳細內容就需要SSL。</p><p><strong>區別：</strong></p><p>1、https協議需要到ca申請證書，一般免費證書較少，因而需要一定費用。</p><p>2、http是超文本傳輸協議，信息是明文傳輸，https則是具有安全性的ssl加密傳輸協議。</p><p>3、http和https使用的是完全不同的連接方式，用的端口也不一樣，前者是80，後者是443。</p><p>4、http的連接很簡單，是無狀態的；HTTPS協議是由SSL+HTTP協議構建的可進行加密傳輸、身份認證的網絡協議，比http協議安全。</p><hr><p><strong>說說tcp/ip協議族</strong></p><p>TCP/IP協議族是一個四層協議系統，自底而上分別是數據鏈路層、網絡層、傳輸層和應用層。每一層完成不同的功能，且通過若干協議來實現，上層協議使用下層協議提供的服務。</p><p>1、數據鏈路層負責幀數據的傳遞。</p><p>2、網絡層責數據怎樣傳遞過去。</p><p>3、傳輸層負責傳輸數據的控制（準確性、安全性）</p><p>4、應用層負責數據的展示和獲取。</p><hr><p><strong>tcp五層網絡協議</strong></p><p><strong>物理層：</strong></p><p>為數據端設備提供傳送數據的通路，數據通路可以是一個物理媒體，也可以是多個物理媒體連接而成。</p><p><strong>數據鏈路層：</strong></p><p>為網絡層提供數據傳送服務。</p><p><strong>網絡層：</strong></p><p>路由選擇和中繼、激活,終止網絡連接、在一條數據鏈路上覆用多條網絡連接,多采取分時複用技術 、差錯檢測與恢復、排序,流量控制、服務選擇、網絡管理 。</p><p><strong>傳輸層：</strong></p><p>傳輸層是兩臺計算機經過網絡進行數據通信時,第一個端到端的層次，具有緩衝作用。</p><p><strong>應用層：</strong></p><p>應用層嚮應用程序提供服務</p><hr><p><strong>TCP與UDP的區別</strong></p><p>1、基於連接與無連接</p><p>2、TCP要求系統資源較多，UDP較少；</p><p>3、UDP程序結構較簡單</p><p>4、流模式（TCP）與數據報模式(UDP);</p><p>5、TCP保證數據正確性，UDP可能丟包</p><p>6、TCP保證數據順序，UDP不保證</p><hr><p><strong>cookie和session的區別，分佈式環境怎麼保存用戶狀態</strong></p><p>1、cookie數據存放在客戶的瀏覽器上，session數據放在服務器上。</p><p>2、cookie不是很安全，別人可以分析存放在本地的COOKIE並進行COOKIE欺騙，考慮到安全應當使用session。</p><p>3、session會在一定時間內保存在服務器上。當訪問增多，會比較佔用你服務器的性能，考慮到減輕服務器性能方面，應當使用COOKIE。</p><p>4、單個cookie保存的數據不能超過4K，很多瀏覽器都限制一個站點最多保存20個cookie。</p><p><strong>分佈式環境下的session（舉例兩種）：</strong></p><p><strong>服務器session複製</strong></p><p>原理：任何一個服務器上的session發生改變（增刪改），該節點會把這個 session的所有內容序列化，然後廣播給所有其它節點，不管其他服務器需不需要session，以此來保證Session同步。</p><p>優點：可容錯，各個服務器間session能夠實時響應。</p><p>缺點：會對網絡負荷造成一定壓力，如果session量大的話可能會造成網絡堵塞，拖慢服務器性能。</p><p><strong>session共享機制</strong></p><p>使用分佈式緩存方案比如memcached、redis，但是要求Memcached或Redis必須是集群。</p><hr><p><strong>GIT和SVN的區別</strong></p><p>1、GIT是分佈式的，SVN不是。</p><p>2、GIT把內容按元數據方式存儲，而SVN是按文件。</p><p>3、GIT分支和SVN的分支不同。</p><p>4、GIT沒有一個全局的版本號，而SVN有。</p><p>5、GIT的內容完整性要優於SVN。</p><p>（一般問會不會用，知道這些區別貌似也沒卵用）</p><p><strong>請寫一段棧溢出、堆溢出的代碼</strong></p><p>遞歸調用可以導致棧溢出</p><p>不斷創建對象可以導致堆溢出</p><p>代碼如下：</p><div class=pgc-img><img alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/57c03a8954874240a88b9a0a4b99e666><p class=pgc-img-caption></p></div><p><strong>BIO、NIO和AIO的區別</strong></p><p>Java BIO ： 同步並阻塞，服務器實現模式為一個連接一個線程，即客戶端有連接請求時服務器端就需要啟動一個線程進行處理，如果這個連接不做任何事情會造成不必要的線程開銷，當然可以通過線程池機制改善。</p><p>Java NIO ： 同步非阻塞，服務器實現模式為一個請求一個線程，即客戶端發送的連接請求都會註冊到多路複用器上，多路複用器輪詢到連接有I/O請求時才啟動一個線程進行處理。</p><p>Java AIO： 異步非阻塞，服務器實現模式為一個有效請求一個線程，客戶端的I/O請求都是由OS先完成了再通知服務器應用去啟動線程進行處理。</p><p><em>NIO比BIO的改善之處是把一些無效的連接擋在了啟動線程之前，減少了這部分資源的浪費（因為我們都知道每創建一個線程，就要為這個線程分配一定的內存空間）</em></p><p><em>AIO比NIO的進一步改善之處是將一些暫時可能無效的請求擋在了啟動線程之前，比如在NIO的處理方式中，當一個請求來的話，開啟線程進行處理，但這個請求所需要的資源還沒有就緒，此時必須等待後端的應用資源，這時線程就被阻塞了。</em></p><p><strong>適用場景分析：</strong></p><p>BIO方式適用於連接數目比較小且固定的架構，這種方式對服務器資源要求比較高，併發侷限於應用中，JDK1.4以前的唯一選擇，但程序直觀簡單易理解，如之前在Apache中使用。</p><p>NIO方式適用於連接數目多且連接比較短（輕操作）的架構，比如聊天服務器，併發侷限於應用中，編程比較複雜，JDK1.4開始支持，如在 Nginx，Netty中使用。</p><p>AIO方式使用於連接數目多且連接比較長（重操作）的架構，比如相冊服務器，充分調用OS參與併發操作，編程比較複雜，JDK7開始支持，在成長中，Netty曾經使用過，後來放棄。</p><hr><p><strong>java中常說的堆和棧，分別是什麼數據結構；另外，為什麼要分為堆和棧來存儲數據</strong></p><p>棧是一種具有後進先出性質的數據結構，也就是說後存放的先取，先存放的後取。</p><p>堆是一種經過排序的樹形數據結構，每個結點都有一個值。通常我們所說的堆的數據結構，是指二叉堆。堆的特點是根結點的值最小（或最大），且根結點的兩個子樹也是一個堆。由於堆的這個特性，常用來實現優先隊列，堆的存取是隨意的。</p><p><strong>為什麼要劃分堆和棧</strong></p><p>1、從軟件設計的角度看，棧代表了處理邏輯，而堆代表了數據。這樣分開，使得處理邏輯更為清晰。</p><p>2、堆與棧的分離，使得堆中的內容可以被多個棧共享。一方面這種共享提供了一種有效的數據交互方式(如：共享內存)，另一方面，堆中的共享常量和緩存可以被所有棧訪問，節省了空間。</p><p>3、棧因為運行時的需要，比如保存系統運行的上下文，需要進行地址段的劃分。由於棧只能向上增長，因此就會限制住棧存儲內容的能力。而堆不同，堆中的對象是可以根據需要動態增長的，因此棧和堆的拆分，使得動態增長成為可能，相應棧中只需記錄堆中的一個地址即可。</p><p>4、體現了Java面向對象這一核心特點（也可以繼續說一些自己的理解）</p><hr><p><strong>為什麼要用</strong></p><div class=pgc-img><img alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/fdfeee7f-450c-47cf-9565-ed77702661ae><p class=pgc-img-caption></p></div><p><strong>那先要明白什麼是線程池</strong></p><p>線程池是指在初始化一個多線程應用程序過程中創建一個線程集合，然後在需要執行新的任務時重用這些線程而不是新建一個線程。</p><p><strong>使用線程池的好處</strong></p><p>1、線程池改進了一個應用程序的響應時間。由於線程池中的線程已經準備好且等待被分配任務，應用程序可以直接拿來使用而不用新建一個線程。</p><p>2、線程池節省了CLR 為每個短生存週期任務創建一個完整的線程的開銷並可以在任務完成後回收資源。</p><p>3、線程池根據當前在系統中運行的進程來優化線程時間片。</p><p>4、線程池允許我們開啟多個任務而不用為每個線程設置屬性。</p><p>5、線程池允許我們為正在執行的任務的程序參數傳遞一個包含狀態信息的對象引用。</p><p>6、線程池可以用來解決處理一個特定請求最大線程數量限制問題。</p><hr><p><strong>msyql優化經驗</strong></p><p>1、對查詢進行優化，應儘量避免全表掃描，首先應考慮在 where 及 order by 涉及的列上建立索引。</p><p>2、應儘量避免在 where 子句中使用!=或&lt;>操作符，否則引擎將放棄使用索引而進行全表掃描。</p><p>3、儘量使用數字型字段，若只含數值信息的字段儘量不要設計為字符型，這會降低查詢和連接的性能，並會增加存儲開銷。這是因為引擎在處理查詢和連接時會逐個比較字符串中每一個字符，而對於數字型而言只需要比較一次就夠了。</p><p>4、任何地方都不要使用 select * from t ，用具體的字段列表代替“*”，不要返回用不到的任何字段。</p><p>5、避免頻繁創建和刪除臨時表，以減少系統表資源的消耗。諸如此類，等等等等......</p><p><strong>悲觀鎖和樂觀鎖的區別，怎麼實現</strong></p><p>悲觀鎖：一段執行邏輯加上悲觀鎖,不同線程同時執行時,只能有一個線程執行,其他的線程在入口處等待,直到鎖被釋放。</p><p>樂觀鎖：一段執行邏輯加上樂觀鎖,不同線程同時執行時,可以同時進入執行,在最後更新數據的時候要檢查這些數據是否被其他線程修改了(版本和執行初是否相同),沒有修改則進行更新,否則放棄本次操作。</p><p>悲觀鎖的實現：</p><div class=pgc-img><img alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5417a560f15d4fcd90e6e3c5403c0b41><p class=pgc-img-caption></p></div><p>樂觀鎖的實現：</p><div class=pgc-img><img alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5dabdbe7e9064720918e6481f8fac7ac><p class=pgc-img-caption></p></div><p><strong>最後</strong></p><p>針對於互聯網公司java程序員涉及到的絕大部分難題我做成了文檔和架構視頻資料免費分享給大家（包括Dubbo、Redis、Netty、zookeeper、Spring cloud、分佈式、高併發等架構技術資料），希望能幫助到且找到一個好的工作，也節省大家在網上搜索資料的時間來學習，也可以關注我一下以後會有更多幹貨分享。</p><p><strong>領取方式：關注+轉發+收藏後私信我【面試資料】即可免費獲取哦！</strong></p><p><strong>關注+轉發+收藏後在私信哦！</strong></p><div class=pgc-img><img alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99442bb9a16e4f8dbd5f63716b1f70f2><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>京東</a></li><li><a>Java</a></li><li><a>面試題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html alt=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15208700392878e896bf9c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html title=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理>Java面試題：詳細說明一下可重入鎖ReentrantLock的原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38f9fcd1.html alt=2020新版Java集合容器面試題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38f9fcd1.html title=2020新版Java集合容器面試題>2020新版Java集合容器面試題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cefbea7b.html alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aa8f670cc244471e91fa0a25af703002 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cefbea7b.html title=「Java面試題精華集」1w字的Java集合框架篇（2020最新版）>「Java面試題精華集」1w字的Java集合框架篇（2020最新版）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>