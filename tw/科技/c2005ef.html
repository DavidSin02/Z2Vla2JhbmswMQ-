<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>程序員學Python算法編程中常見的問題和算法 | 极客快訊</title><meta property="og:title" content="程序員學Python算法編程中常見的問題和算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c2005ef.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c2005ef.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c2005ef.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c2005ef.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c2005ef.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c2005ef.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c2005ef.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c2005ef.html><meta property="article:published_time" content="2020-10-29T21:05:28+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:28+08:00"><meta name=Keywords content><meta name=description content="程序員學Python算法編程中常見的問題和算法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c2005ef.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>程序員學Python算法編程中常見的問題和算法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>一些著名問題與算法</h1><blockquote><p><strong><em>如果您的飛船破了一個洞，我只能深表同情，因為我所解決的99個問題裡唯獨沒有這個問題。</em></strong></p><strong>——<em>匿名者</em>1</strong></blockquote><p>本文提到的所有問題與算法，因為有一些算法僅僅是為了試圖說明某個原理，而有一些問題僅僅是為了某個算法而創造的。然而，作為索引，這裡會列舉出學習中最重要的<span>那些問題</span>與算法。</p><p>在本文大多數描述中，<em>n</em>代表的是問題規模，如一個序列中的元素數量。而在圖論問題中，<em>n</em>表示的是節點的數量，<em>m</em>則表示邊的數量。</p><h1>問題部分</h1><p><strong>分團問題與獨立集</strong>：分團圖是每對頂點之間都有邊相連的一種圖結構。我們對該問題的興趣主要在於，怎樣在一個較大的圖中，找到它的分團圖（也就是說，分團圖實際上是一種子圖）。而獨立集則指的是圖結構中互相沒有邊與之相連的點。換句話說，找獨立集的過程基本等價於將圖中每兩點之間的連接關係倒轉，然後找出該圖的分團圖。找到一個<em>k</em>-分團圖（含有<em>k</em>個節點的分團圖），或者找到某圖結構中的最大分團圖（最大分團圖問題），屬於NP難題。（更多內容請查閱第11章。）</p><p><strong>最近點配對問題</strong>：在幾何平面上給出一些點，找到其中最接近的兩個點。它可以在線性對數級時間內，使用分治策略來解決。（見第6章）</p><p><strong>壓縮問題與最佳決策樹：</strong>哈夫曼樹是葉節點有權重的一種樹結構。權重與節點深度的乘積和越小越好。這種樹結構對於構建壓縮編碼非常有效，而權重可能是節點已知的概率分佈。哈夫曼樹可以使用第7章描述的哈夫曼算法（見清單7-1）來構建。</p><p><strong>連通問題與強連通分量：</strong>如果一個無向圖的每個節點都可以找到通向其他任意節點的路徑，那麼我們把這種圖結構稱為連通圖。如果一個基於有向圖的無向圖是連通的，那麼這個有向圖也是一個連通圖。而連通分量則是圖結構中最大的連通子圖。連通分量可以用遍歷算法來獲得，如DFS（見清單5-5）或者BFS（見清單5-9）。另外，如果在一個有向圖中，每個節點到其他任何一個節點，都可以找到一條有向路徑，那麼這個圖被稱為強連通圖。而強連通組件（SCC）則是一幅連通圖中最大的強連通子圖。SCC可以通過Kosaraju算法（見清單5-10）來找。</p><p><strong>凸包問題：</strong>在幾何平面中，凸包指的是包含所有點的最小凸多邊形區域。通過分治法，凸包問題可以在線性對數級時間內得到解決（見第6章）。</p><p><strong>尋找最小值/最大值/中間值：</strong>通過單次遍歷，我們就可以找到一個序列中的最小值與最大值。通過使用二叉堆，以及線性級時間的準備，我們在常數時間裡可以反覆提取最大值和最小值。通過隨機選擇算法，我們也可能在線性級時間（或預期在線性級時間）內，找到一個序列中的第<em>k</em>小的元素。（更多信息請參考第6章。）</p><p><strong>流量和切割問題：</strong>在圖結構中，如果每條邊上標註了流量，那麼其構成的網絡總流量應該是多少？這就是最大流量問題。與之等價的一個問題是，找到一組能最大化地限制流量的邊。這是最小切割問題。類似的問題存在著數個不同的版本。例如，在邊上標註過路費，然後尋找最省錢的路徑。或在每條邊上標註最小流量，然後尋找可行路徑。甚至可以在節點上標註通過該節點的消耗或是要求。第10章討論了這一系列問題。</p><p><strong>圖著色問題：</strong>首先，我們得嘗試對圖結構中的點進行著色，將每一對直接連接的節點塗成不同的顏色，然後試著對顏色進行分類，儘可能地將著色所用的顏色減到最少。基本上，這是一個NP難題。然而，如果是要判斷某一圖結構的著色是否可以只用兩種顏色（該圖是不是個二分圖），那麼該問題可以在線性級時間內用單次遍歷來解決。另外，尋找分團覆蓋的問題等價於尋找獨立集覆蓋問題，它們都與圖著色問題非常類似。（關於圖著色問題的更多信息，請參見第11章。）</p><p><strong>停機問題：</strong>判定一個給定的算法是否會因某個給定的輸入而終止。這通常情況下是一個不可判定（不可解）的問題（見第7章）。</p><p><strong>哈密頓環路/路徑、TSP</strong>……<strong>和歐拉路徑：</strong>在路徑問題和子圖問題中，確實存在著若干個特定問題的高效解決方式。但不意味著一定存在一種方法，可以訪問所有的節點，並且每個節點只訪問一次。任何有這種限制的問題都被稱為NP難題，包括尋找哈密頓環路（從某個節點出發，僅訪問每個節點一次並且回到出發節點）、哈密頓路徑（從某個節點出發，訪問每個節點一次，但不需要回到出發節點），以及尋找完全圖的最短路徑（旅行商問題）。儘管，無論對於有向圖還是無向圖來說（見第11章），這些問題都屬於NP難題，但它們有一個與之相關的問題：尋找歐拉路徑（從某個節點出發，僅訪問每條邊一次，不需要回到出發節點）則可以在多項式級時間內得到解決（見第5章）。另外，雖然TSP問題仍然是NP難題，但在某些特定情況下，例如您想計算在平面上的幾何距離，我們可以將因子規約於1.5之內，然後用其他矩陣距離來解決它。然而，這並不影響其他大多數類似的TSP問題是NP難解的。（更多信息請參見第11章。）</p><p><strong>揹包問題和整數規劃：</strong>揹包問題是一個在某種限制條件下，根據某種邊界值摘選某集合子集的問題。在（有限）分數情況下，我們會擁有幾種物品，它們各有不同的質量，並且在單位質量上的價值也不盡相同，而我們要將這些物品放入一個揹包中。這時候，我們採用的（貪心）解決方案是：從價值最高的物品開始放，儘可能多地放即可。而對於整數揹包問題來說，我們必須把一種物品整個放進去，不能僅放入這個物品的幾分之幾。每種物品都有質量和價值，對於有限制的情況（所謂的0-1揹包問題）來說，每種物品都有一定的數量。（另一種同類型的問題是，您有一些固定的物品集合，您可以選擇要不要這些集合，但不能拆分任一集合。）而在物品數量不限的情況下，您可以想取多少物品就取多少物品（當然，也要考慮揹包容量）。例如，子集和問題就是這種情況的一個特例。它描述瞭如何從一個數集中取出一個子集，使得子集中元素的和為一個指定的數。這些問題都是NP難題（見第11章），但使用動態規劃的話，可以在偽多項式級時間內得到解（見第8章）。而揹包問題，甚至可以通過貪心算法，在多項式級時間內解決（見第7章）。整數規劃在一定程度上是一般化的揹包問題（所以很明顯是NP難題）。它只是變量為整數的線性規劃問題。</p><p><strong>最長遞增子序列問題</strong>：尋找給定的序列中長度最長的遞增序列，該問題可以用動態規劃（見第8章）在線性對數級時間內解決。</p><p><strong>匹配問題：</strong>匹配問題有很多種，其中最典型的就是對象互相鏈接的問題。本書中所討論的問題主要是二分匹配問題、開銷最小化的二分匹配問題（見第10章）以及穩定婚配問題（見第7章）。二分匹配問題（或最大化的二分匹配問題）主要涉及的是在一個二分圖中尋找邊的最大子集，這個子集中不能有兩條邊的任意兩個端點重合。這個問題還有另一個版本：為該圖中所有的邊標註權值，然後找出權值最大的且符合此條件的子集。穩定婚配問題則與此稍有不同。在該問題中，每個人都會對所有的異性打分，然後根據分數來為他們分配配偶，使得任意兩個異性都不會出現寧願孤獨終老也不願意與對方婚配的情況。</p><p><strong>最小生成樹問題：</strong>生成樹實際上是一種子圖，該子圖要是一棵包含其原圖所有的節點的樹。最小生成樹是在邊上有權值的情況下，總權值最小的生成樹。尋找最小生成樹可以用Kruskal算法（見清單7-4）或Prim算法（見清單7-5）。例如，由於邊的數量是固定的，最大生成樹可以通過取消邊的權來找到。</p><p><strong>分割問題與裝箱問題</strong>：分割問題指的是將一個數的集合一分為二，使得兩個子集的和相等。而裝箱問題則是指將一個集合中的數放入若干個“箱子”，使每個箱子內的總數值都不超過某個值，並同時儘可能減少所用的箱子數。這兩個問題都屬於NP難題。（見第11章）</p><p><strong>SAT 、Circuit-SAT、k-CNF-SAT：</strong>這些都屬於可滿足性問題（SAT）的變體，它會要求我們給定一個用來判定真值的邏輯（布爾型）公式。當然，前提是我們可以按照自己的意願設置真值變量。不過，Circuit-SAT問題通常直接應用於邏輯環路中，而不是公式。而<em>k</em>-CNF-SAT問題主要涉及的是公取範式當中的公式。當<em>k</em> = 2時，後者可以在多項式級時間內得到解決。而對於<em>k</em> > 2的其他情況，這就是一個NP完全問題了（見第11章）。</p><p><strong>搜索問題：</strong>這是一個非常普遍而又非常重要的問題：通過某個鍵找到對應的值。這本身就是Python這類動態語言的變量運作方式。在當今互聯網世界，這幾乎也是尋找所有信息的方式。對此，目前大致上有兩種解決方案，即散列表（見第2章）及二分查找/搜索樹（見第6章）。而如果數據集中的元素存在概率分佈的話，我們也可以用動態語言創建最佳搜索樹，以優化查詢。</p><p><strong>序列比對問題：</strong>對比兩個序列，並找出它們之間相同（或不同）的元素。解決此類問題的方法之一是尋找兩個序列中的最長公用子序列，或尋找從一個序列變換到另一個序列所需的最少基本編輯數（Levenshtein distance算法）。這兩個問題是等價的。更多信息詳見第8章。</p><p><strong>序列修改問題：</strong>向鏈表中插入元素的時間複雜度非常小（常數級時間），但查找指定元素的時間複雜度卻很大（線性級時間）。而對於數組而言，情況則剛好相反（查找時間為常數級，而插入時間為線性級，因為元素插入位置之後的所有元素都需要移動）。但是向兩者末端插入元素的時間都非常小（見第2章相關的黑盒子專欄）。</p><p><strong>集合與頂點覆蓋問題：</strong>頂點覆蓋集是指能夠覆蓋圖中所有的邊的頂點集合（每條邊至少有一個頂點在頂點覆蓋集中）。如果將這個概念中的頂點換為子集，則可以引申出集合覆蓋的概念。這個問題的重點在於限制或最小化頂點與子集的數量。這兩個問題都是NP難題。（見第11章）</p><p><strong>最短路徑問題：</strong>該問題的具體形式包括一個節點到另一個節點之間的最短路徑、一個節點前往其他所有節點（反向也可以）的最短路徑，以及圖中各個節點到其他節點的最短路徑。其中，一對一、一對多或多對一的解決方式基本相同。通常使用的是基於未加權圖的BFS算法。如果是DAG圖的話，則採用DAG最短路徑算法，權值非負的情況採用Dijkstra算法，一般情況則採用Bellman–Ford算法。另外，在實踐中，為了加快算法的速度（雖然無法提升其最壞情況的運行時間），我們也可以採用雙向Dijkstra算法，即A*算法。而對於問題的最後一種情況，可選的算法主要有Floyd–Warshall算法、Johnson算法（適用於稀疏圖）。如果邊的權為非負值，Johnson算法則（漸近）等價於對每個點使用Dijkstra算法（後者更為高效）。關於最短路徑算法的更多信息，見第5章和第9章。另外值得注意的是，（一般圖的）最長路徑問題通常被用於尋找哈密頓路徑。也就是說，這是個NP難題。事實上，這也意味著，對於一般情況而言，最短路徑問題也是NP難的。然而，如果我們刪去圖中的負環，我們的算法即可在多項式級時間內解決問題。</p><p><strong>排序問題與元素重複性：</strong>排序是非常重要的一種操作，也是其他許多算法的基礎所在。在Python中，我們一般會藉助list.sort()方法或者sorted()函數來完成排序操作，兩者都使用了time排序算法的高效實現。其他算法還包括插入排序法、選擇排序法及gnome排序法（這些都屬於平方級時間的算法）。除此之外，還有堆排序、歸併排序及快速排序（這些都屬於線性對數級算法，儘管這只是快速排序算法在平均水平下的表現）。關於平方級運行時間的排序算法，更多信息可以參考第5章的相關內容。而對於線性對數級（使用分治法）的算法，我們則可以參考第6章的相關內容。另外，一個實數集是否存在重複值，也直接決定了它的排序時間（在最壞情況下）是否能好於線性對數級。這裡需要的是一些歸簡操作，而不只是排序。</p><p><strong>拓撲排序問題：</strong>將DAG圖中的節點按照某種規則排序，使得所有的邊指向同樣的方向。如果說邊代表的是依賴關係，那麼拓撲排序就代表了按照這種依賴關係為節點制定的順序。使用引用計數（見第4章）或DFS（見第5章）可以解決這個問題。</p><p><strong>遍歷問題：</strong>該問題主要涉及的是如何在某種連通結構中訪問到所有的對象。通常情況下，這個問題都會被表述為圖或樹結構中的節點遍歷。它既可能要求您訪問到每個節點，也可能只需要訪問其中的某些節點。對於後者，即忽略圖或者樹結構某一部分的策略，我們通常稱之為修剪，往往用於搜索樹和分支定界策略中。更多信息請參考第5章。</p><h1>算法與數據結構部分</h1><p><strong>2-3樹：</strong>平衡樹結構，支持插入、刪除、搜索操作。這些操作在最壞情況下需要的時間為Θ(lg <em>n</em>)。其內部節點可以有2～3個子節點。並且，該樹結構在節點拆分、插入的過程中需要始終保持平衡（見第6章）。</p><p><strong>A*算法：</strong>啟發式的單源最短路徑算法。它比較適用於大型搜索空間。所以我們不（像Dijkstra算法那樣）是根據最短距離值來選擇節點的，用的是節點的最低啟發值（其等於實際距離值加上剩餘距離估計值）。該算法在最壞情況下的運行時間與Dijkstra算法相同。（見清單9-10）</p><p><strong>AA樹：</strong>該結構是一棵多層二叉樹中的2-3樹節點翻轉的結果。該算法在最壞情況下插入、刪除、搜索的運行時間為Θ(lg <em>n</em>)。（見清單6-6）</p><p><strong>Bellman–Ford算法：</strong>用於找出加權圖中某一節點到其他所有節點的最短路徑。其查找的途徑是沿著每一條邊走<em>n</em>次。除非這是一個負向環路，否則其正確答案應該可以在<em>n</em>-1次迭代之後得到確認。如果其在最後一輪迭代中仍有改進的餘地，那麼它就應該被當成一個負向環路刪除掉，並放棄這個運行時間為Θ(ln <em>m</em>)的算法。（見清單9-2）</p><p><strong>雙源Dijkstra算法：</strong>在起點和終點同時運行Dijkstra算法，並在這兩個算法實例之間交叉迭代。當它們在中間相遇時（雖然這個中間點有些地方值得探討），最短路徑就被找到了。該算法在最壞情況下的運行時間與Dijkstra算法相同。（見清單9-8與清單9-9）</p><p><strong>二分搜索樹：</strong>二分搜索樹上的每個節點都會有一個鍵（通常還會有一個對應的值）。並且，經由這些節點的鍵，我們才能對其子節點的鍵進行區分。較小的鍵通常放在左子樹中，而較大的則放在右子樹中。平均而言，任何節點所在的深度就等於其對數，因而其插入、搜索操作的時間複雜度為Θ(lg <em>n</em>)。如果（像AA樹那樣）去掉其中的平衡成本，雖然樹結構有可能會失去平衡，但可以得到線性級運行時間。（見清單6-2）</p><p><strong>二分法與二分搜索：</strong>一種起源於搜索樹的搜索方式。其會在一個已排序的序列中，根據自己的興趣將序列依次減半。在減半過程中，算法將通過對序列中間元素的檢測來決定要偏向左半邊還是右半邊。該算法的運行時間為Θ(lg <em>n</em>)。Python程序員可以在bisect模塊中找到一份非常高效的實現。（見第6章）</p><p><strong>分支定界法：</strong>這是一種通用的算法設計方法。它主要構建一個局部評估方案，然後我們將其作為一個方案空間，用深度優先或最佳優先策略來進行搜索。在此過程中，保守的估值會被當成最佳方案保留下來，而樂觀的估值則會被當作局部方案來計算。如果該樂觀性估值比保守性估值糟糕，我們就不會擴展該局部方案，同時回溯該算法。這種算法設計通常用於解決NP難題。（見清單11-2，那是一個用分支定界法解決0-1揹包問題的範例。）</p><p><strong>廣度優先搜索（BFS）：</strong>一種逐層遍歷圖結構（也可能是樹結構），以找出其（不加權的）最短路徑的搜索方式。其在實現中將用一個FIFO隊列來記錄探索到的節點。算法運行時間為Θ(<em>n+m</em>)。（見清單5-9）</p><p><strong>桶式排序法：</strong>該算法所要排序的數值將均勻分佈在一組區間內，這些區間都是一些大小尺寸相等的、用於存放相關值的桶。預計這些桶的大小是恆定的，所以它們本身也可以用插入排序法這樣的算法來進行排序。算法的整體運行時間為Θ(<em>n</em>)。（見第4章）</p><p><strong>Busacker–Gowen算法：</strong>該算法希望尋找的是一個網絡中在最低成本條件下所能達到的最大流量（或該網絡在給定流量值下所能做到的最低成本），它採用的是來自Ford–Fulkerson方法中的、最低成本的增廣路徑。而這些路徑的查找則可以通過Bellman–Ford算法或（經過某些加權處理的）Dijkstra算法來解決。在一般情況下，算法的運行時間取決於最大流量值，為偽多項式級時間。如果其最大流量值為<em>k</em>，其運行時間（假設它採用的是Dijkstra算法）就應該為<em>O</em>(<em>km</em> lg <em>n</em>)。（見清單10-5）</p><p><strong>Christofides算法：</strong>主要針對度量型的TSP問題的一種近似算法（近似比大約綁定在1.5），其尋找的是某種最小生成樹結構，以及該樹奇數節點的最小匹配<strong>2</strong>，併為相應的圖結構構建一個有效的短迴路。（見第11章）</p><p><strong>計數排序法：</strong>該算法能在Θ(<em>n</em>)時間內完成對某個小型整數區間（最多能有Θ(<em>n</em>)個連續值）的排序。其工作原理是對出現的數字進行計數，並直接根據該累計值來安排結果中的數字，然後持續更新。（見第4章）</p><p><strong>DAG的最短路徑：</strong>尋找某DAG中某個節點到其他所有節點的最短路徑。其工作原理是先對節點進行拓撲排序，然後從左至右鬆弛化每一個節點的所有出向邊（或者改成所有入向邊也行）。（在無環路的情況下）該算法也可以用來尋找最長路徑。運行時間為Θ(<em>n+m</em>)。（見清單8-4）</p><p><strong>深度優先搜索（DFS）：</strong>一種不斷深入並回溯圖結構（也可能是樹結構）的遍歷方式。其在實現中將用一個LIFO隊列來記錄探索到的節點。由於可以對探索及完成時間進行記錄，DFS也可以被用來充當其他算法的一個子程序（如拓撲排序、Kosaraju算法等）。算法運行時間為Θ(<em>n+m</em>)。（見清單5-4、清單5-5與清單5-6）</p><p><strong>Dijkstra算法：</strong>該算法可用於尋找某加權圖中某一節點前往其他所有節點的最短路徑，但前提是圖中不能有權值為負的邊。它會在遍歷圖的過程中，不斷地通過優先隊列（heap）來選取下一個節點。其優先級來自於對節點當前距離的評估值，而這些評估值的更新又來自於當下在已訪問節點中找到的短路徑。算法的運行時間為Θ((<em>m</em>+<em>n</em>) lg <em>n</em>)。但如果這是一個連通圖，時間複雜度就可以簡化至Θ(<em>m</em> lg <em>n</em>)。</p><p><strong>雙向隊列：</strong>FIFO隊列通常用鏈表（或數組的鏈表）來實現，因此其在任何一段插入與提取對象都可在常數時間內完成。Python程序員可以在collections.deque類中得到一份非常高效的實現。（請參考第5章中相關的黑盒子專欄話題。）</p><p><strong>動態數組、向量：</strong>這是一種讓數組擁有額外容量的思路，有助於提高追加元素的操作效率。當該結構被填滿時，可以通過某個常數因子擴充成更大的數組。因此在平均水平下，它可以在常數時間內完成追加操作。（見第2章）</p><p><strong>Edmonds–Karp算法：</strong>採用BFS進行遍歷的Floyd–Warshall方法實例。該算法可在Θ(<em>nm</em>2)時間內找到相關網絡的最低成本流。（見清單10-4）</p><p><strong>Floyd–Warshall方法：</strong>該方法用於尋找圖中各個節點前往其他所有節點的最短路徑。該算法在第<em>k</em>輪迭代中，沿路只能（按某種順序）經過前<em>k</em>箇中間節點。從第<em>k</em>-1個節點的延伸將取決於其是否能通過最短路徑的檢查，檢查當前從<em>k</em>節點到前<em>k</em>-1個節點的路徑是否比直接通往這些節點的路徑更短。（也就是<em>k</em>節點是否可被用於最短路徑。）算法的運行時間為Θ(<em>n</em>3)。（見清單9-6）</p><p><strong>Ford–Fulkerson方法：</strong>一種最大流問題的通用解決方案。該方法會通過圖的重複遍歷來找出所謂的增廣路徑，這是一種會隨著流量增長（增廣）的路徑。而其中的流量又會隨著其經過的或所回退的邊數（取消訪問）而增長，前提是每一條邊中都帶來額外容量，並且只要經過它們就會產生流量。因此，我們的遍歷同時包含了有向邊中的前進和回退兩種情況，取決於它們共同產生的流量。具體算法的運行時間取決於我們所採用的遍歷策略。（見清單10-4）</p><p><strong>Gale–Shapley算法：</strong>該算法致力於對一組男女進行優先排序，然後從中找出穩定的婚配組合。任何一個尚未婚配的男士都會被推薦給一個女士，以作為最佳的婚配對象，而每個女士可以在她當下的追求者中間挑選（其中可能就有她的未婚夫）。算法實現應該在平方級時間內完成這些事。（請參見第7章中“求婚者與穩定婚姻”專欄中的內容。）</p><p><strong>侏儒排序法：</strong>一種簡單的平方級排序算法。您在實踐中可能不會用到該算法。（見清單3-1）</p><p><strong>散列操作與散列表：</strong>散列是一種通過鍵值來查找相應值的操作（與搜索樹類似）。相關的元素項通常存儲在一個數組中，所在的位置將取決於某種（偽隨機的或有序的）計算得出的散列鍵值。只要有一個良好的散列函數和足夠的數組空間，散列表的插入、刪除以及查詢操作都可在Θ(1)時間內完成。（見第2章）</p><p><strong>堆與堆排序：</strong>堆是一種高效的優先級隊列。通過某些線性級的預處理，一個最小（或最大）堆可以讓我們在常數級時間內查找到結構中最小（或最大）的元素，並且在對數級時間內完成元素的提取或替換。另外，元素的添加也可在對數級時間裡完成。從概念上來說，堆實際上是一個完全二叉樹結構，樹上的每一個節點都小於（或大於）其自身的子節點。當該結構被修改時，修復其屬性是一個Θ(lg <em>n</em>)時間的操作。但在實踐中，堆通常是用數組來實現的（節點的概念用數組元素的某種編排來表現）。對此，Python程序員可以在heapq模塊中找到一份非常高效的實現。Heapsort的執行過程與選擇排序法非常類似，只不過它所要排序的是一個堆結構罷了，所以該算法<em>n</em>次查找最大元素的總運行時間為Θ(<em>n</em> lg <em>n</em>)。（請參見第6章的黑盒子專欄“堆結構與heapq、Heapsort”。）</p><p><strong>哈夫曼算法：</strong>該算法用於構建哈夫曼樹，以便進而構建出最佳前綴碼之用。在初始階段，算法會將每一個元素（如字母表中的字母）製作成一個單節點的樹結構，這時它們的權值等於其出現的頻率。然後在每一輪迭代中，都會有兩個權值最輕的樹被挑選出來，合併成一個新的樹結構。該樹的權值等於之前兩棵樹的權值之和。這一切都可以在線性對數級時間內完成（或者說在出現頻率已經完成預排序的情況下，它事實上可以在線性級時間內完成）。（見清單7-1）</p><p><strong>插入排序法：</strong>一種簡單的平方級運行時間的排序算法。它的工作原理就是反覆地向數組中已排序的段落中插入下一個未排序的元素。對於小型數據集來說，這實際上可能是比歸併排序法或快速排序法更為優秀（甚至是最佳）的算法。（但在Python中，我們還是應該儘可能地調用list.sort()或sorted()。）（見清單4-3）</p><p><strong>插值搜索法：</strong>該算法與普通的二分搜索法非常類似，但它用來猜測當前位置的是其內部端點之間的內部插值，而不再是簡單地查找中間元素。雖然該算法在最壞情況下的運行時間依然是Θ(lg <em>n</em>)，但它在平均水平下，面對分佈均勻數據時的運行時間變成了Θ(lg lg <em>n</em>)。（請參見第6章“如果您感興趣……”一節中所提到的內容。）</p><p><strong>深度迭代的DFS：</strong>該算法會反覆地進行DFS，但每次遍歷得多遠都會有一定的限制。對於某些扇出型結構來說，算法的運行時間與DFS或BFS基本相同（Θ(<em>n</em>+<em>m</em>)）。關鍵在於它既能發揮出BFS的優勢（善於尋找最短路徑以及探索大型的固有狀態空間），又能像DFS那樣具有佔用內存少的特點。（見清單5-8）</p><p><strong>Johnson算法：</strong>該算法致力於尋找圖中每一個節點前往其他所有節點的最短路徑，其基本工作原理就是基於每一個節點運行Dijkstra算法。但該算法在這中間使用了一個技巧，以使得它可用來處理負權值的邊。首先，它會在某個（能到達圖中所有節點的）新起點上運行Bellman–Ford算法，然後用得到的距離值來修改圖中各條邊的權值。修改之後，所有邊的權值都變成了非負值，但原始圖中的最短路徑在修改圖中依然會是最短路徑。算法的運行時間為Θ(<em>mn</em> lg <em>n</em>)。（見清單9-4）</p><p><strong>Kosaraju算法：</strong>該算法致力於通過DFS來尋找強連通分量。首先，節點要按照它們的完成時間排好序。然後，反轉它們的邊，另行運行DFS，按照最先的順序選擇起點。算法運行時間為Θ(<em>n+m</em>)。（見清單5-11）</p><p><strong>Kruskal算法：</strong>該算法致力於通過反覆添加不會導致環路的最小剩餘來尋找最小生成樹。其環路檢查可以得到非常有效的執行（當然，這需要一些小聰明），所以算法的運行時間取決於邊的順序。總體而言，大致為Θ(<em>m </em>lg <em>n</em>)。（見清單7-4）</p><p><strong>鏈表：</strong>一種可替代數組的序列表現結構。雖然在鏈表中只要找到了元素，修改操作的成本很低（只需常數級時間），但查找本身是一個線性級操作。鏈表的實現像是一條路徑，每一個節點都指向下一個節點，另外需要提醒的是，Python中的list類型是用一個數組來實現的，它並不是一個鏈表。（見第2章）</p><p><strong>歸併排序法：</strong>典型的分治類算法。它在排序時會始終將序列從中間分開，然後繼續對那兩半部分進行遞歸，最後在線性時間內將排序好的那兩半合併起來。算法的總運行時間應為Θ(<em>n </em>lg <em>n</em>)。（見清單6-5）</p><p><strong>Ore算法：</strong>人們通過標記通道入口與出口來遍歷實體迷宮的一種算法。其在多數情況下類似於基於深度迭代的DFS或BFS。（見第5章）</p><p><strong>Prim算法：</strong>該算法致力於通過反覆添加與樹最接近的節點來使其成長為一棵最小生成樹。其核心部分與Dijkstra算法類似，由一個遍歷算法與一個優先級隊列組合而成。（見清單7-5）</p><p><strong>基數排序法：</strong>該算法將從最低有效位起，通過（元素的）數位來對數字序列（或其他類型的序列）進行排序。只要數位的個數是恆定的，並且數位能在線性時間完成排序（如通過計數排序法），算法的總運行時間應為線性級。該排序算法的側重點基於數位的穩定性。（見第4章）</p><p><strong>隨機選取法：</strong>該算法致力於查找中間數，或者通常情況下的第<em>k</em>順位的某個數（第<em>k</em>小的元素）。其工作原理就像是“半個快速排序法”。它會隨機（或者說任意）選擇一個分割點元素，將其餘元素劃分到它的左邊（更小的元素）或右邊（更大的元素）。然後在各部分繼續搜索，整個過程或多或少與二分搜索有些類似。完美平分雖不能保證，但預計的運行時間依然是線性級的。（見清單6-3）</p><p><strong>選取法：</strong>雖然相當不現實，但該算法確實可以保證在線性級時間內對兄弟節點進行隨機選取。其工作原理如下：先將目標序列劃分成五個組，然後分別用插入排序法找到它們各自的中間值，接著用選取法遞歸地找出這五個中間值中的中間值，再以該中間值的中間值為分割點劃分元素。現在，我們就可以在合適的那一半元素上進行選取了。換言之，它與隨機選取很相似——不同之處在於，現在我們可以確保分割點兩側存在著一定的比例關係，避免了完全不平衡的情況。這不是一個我們實踐中真正會的算法，但瞭解它依然有著重要的意義。（見第6章）</p><p><strong>選擇排序法：</strong>一種簡單的平方級排序算法。它的工作原理與插入排序法非常類似，只不過這回不是將下一個元素插入到已排序的區段中，而是找出（選取）未排序區段中最大的那個元素（並交換它與最後一個未排序元素的位置）。（見清單4-4）</p><p><strong>Tim排序法：</strong>這是一種非常棒的、基於歸併排序法的就地型排序算法。除了一些被明確聲明條件的、未經處理的特殊情況外，它甚至能對已排序的序列做出針對性處理，包括那些反序的序列段。因此，它對某些真實世界中的序列來說，排序速度可能要比通常的情況更快一些。其在list.sort()與sorted()的實現中也確實很快，所以您會需要用到它們。（請參考第6章黑盒子專欄“Tim排序法”中的相關內容。）</p><p><strong>基於引用計數的拓撲排序法：</strong>該算法用於對DAG的節點進行排序，使其所有邊呈現從左向右的形態。整個過程將通過對每個節點的入向邊計數來完成。入向邊數為0的節點將會被保存到一個隊列（也可以只是一個集合，順序無關緊要）中。這些節點將從該隊列中被取出，並放入拓撲排序的順序當中。當我們這樣做時，我們就是在遞減相關節點入向邊的計數。當它們減到0的時候，就可以放到隊列中去了。（見第4章）</p><p><strong>基於DFS的拓撲排序法：</strong>另一種用DAG拓撲排序的算法。該算法的思路很簡單，即執行DFS，然後在完成時反轉節點的順序。另外，如果想更輕易取得線性級的運行時間，我們也可以直接在DFS的過程中，在每個節點完成遍歷時就將其添加到結果順序中。（見清單5-7）</p><p><strong>Tremaux算法：</strong>與Ore算法一樣，這是一種為讓人們能步行穿越迷宮而設計的算法。在該算法執行過程中，人們所用的跟蹤模式其實基本上就等同於DFS。（見第5章）</p><p><strong>繞樹兩週算法：</strong>一種針對公制TSP問題的近似算法，它可以確保我們得到解決方案的成本最多是最佳方案的兩倍。首先，它會構建一棵最小生成樹（它的成本小於最佳方案），然後它會在該樹上“繞行”，並且走捷徑以避免重複訪問相同的邊。由於採用公制的原因，它可以確保自己的操作成本低於每條邊被訪問兩次的成本。至於最後一次的遍歷，則只需用現成的DFS來實現即可。（見清單11-1）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>算法</a></li><li><a>員學</a></li><li><a>Python</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b80cd2f.html alt="Python代碼實現算法筆記 #6 貪婪算法、分而治之、動態規劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f131750540d84085b88daf0f66b28d59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b80cd2f.html title="Python代碼實現算法筆記 #6 貪婪算法、分而治之、動態規劃">Python代碼實現算法筆記 #6 貪婪算法、分而治之、動態規劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html alt=算法小專欄：散列表（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a831970b0ccf4e4cbe591777ebd3f2a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html title=算法小專欄：散列表（二）>算法小專欄：散列表（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html alt=七大查找算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html title=七大查找算法>七大查找算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html alt=掌握算法-散列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html title=掌握算法-散列>掌握算法-散列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html alt=Python爬蟲教程，利用Python採集QQ群成員信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d6cce76ad48405c9dbb960d4617bcef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html title=Python爬蟲教程，利用Python採集QQ群成員信息>Python爬蟲教程，利用Python採集QQ群成員信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html alt=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5d4a0000046e1bea8b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html title=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？>Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html alt=Python中的多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49dd44b999924b69bd3396709ecacaf4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html title=Python中的多進程>Python中的多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html alt=C#算法系列（1）——二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html title=C#算法系列（1）——二叉樹>C#算法系列（1）——二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html alt="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html title="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結">Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fa274c2.html alt="七十九、Python | Leetcode 二叉樹系列（上篇）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a6c9fa6432a3419a8a60bd334f978a11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fa274c2.html title="七十九、Python | Leetcode 二叉樹系列（上篇）">七十九、Python | Leetcode 二叉樹系列（上篇）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>