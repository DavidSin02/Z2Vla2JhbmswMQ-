<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據結構與算法（5）棧 | 极客快訊</title><meta property="og:title" content="數據結構與算法（5）棧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/64b8a77987c34980862b62b33586c54e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><meta property="article:published_time" content="2020-10-29T21:05:31+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:31+08:00"><meta name=Keywords content><meta name=description content="數據結構與算法（5）棧"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c3e3bf2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據結構與算法（5）棧</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=數據結構與算法（5）棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64b8a77987c34980862b62b33586c54e><p class=pgc-img-caption></p></div><p class=ql-align-justify><strong>前言</strong></p><p class=ql-align-justify><strong>棧</strong>（<strong>stack</strong>）又稱為<strong>堆棧或堆疊</strong>，棧作為一種數據結構，是一種只能在一端進行插入和刪除操作的特殊<strong>線性表</strong>，也就是棧是一種<strong>操作受限</strong>的線性表。它按照<strong>先進後出</strong>的原則存儲數據，先進入的數據被壓入棧底，最後的數據在棧頂，需要讀數據的時候從棧頂開始彈出數據（最後一個數據被第一個讀出來）。棧具有記憶作用，對棧的插入與刪除操作中，不需要改變棧底指針。</p><p class=ql-align-justify><strong>基本概念</strong></p><p class=ql-align-justify>棧是允許在同一端進行插入和刪除操作的特殊線性表。允許進行插入和刪除操作的一端稱為<strong>棧頂(top)</strong>，另一端為<strong>棧底(bottom)</strong>；棧底固定，而棧頂浮動；棧中元素個數為零時稱為<strong>空棧</strong>。插入一般稱為<strong>進棧（PUSH）</strong>，刪除則稱為<strong>退棧（POP）</strong>。</p><p class=ql-align-justify>由於堆疊數據結構只允許在一端進行操作，因而按照<strong>後進先出</strong>（<strong>LIFO</strong>, Last In First Out）的原理運作。<strong>棧也稱為後進先出表</strong>。</p><p class=ql-align-justify>生活中使用棧的場景很多，這裡以羽毛球筒為例，羽毛球筒就是一個棧，剛開始羽毛球筒是空的，也就是空棧，然後我們一個一個放入羽毛球，也就是一個一個<strong>push進棧</strong>，當我們需要使用羽毛球的時候，從筒裡面拿，也就是<strong>pop出棧</strong>，但是第一個拿到的羽毛球是我們最後放進去的。</p><p class=ql-align-justify><strong>與內存中棧的區別</strong></p><ul><li class=ql-align-justify>內存中的堆棧和數據結構堆棧不是一個概念，可以說內存中的堆棧是真實存在的物理區，數據結構中的堆棧是抽象的數據存儲結構。</li><li class=ql-align-justify>內存空間在邏輯上分為三部分：<strong>代碼區</strong>、<strong>靜態數據區</strong>和<strong>動態數據區</strong>，動態數據區又分為<strong>棧區</strong>和<strong>堆區</strong>。</li><li class=ql-align-justify>代碼區：存儲方法體的二進制代碼。高級調度（作業調度）、中級調度（內存調度）、低級調度（進程調度）控制代碼區執行代碼的切換。</li><li class=ql-align-justify>靜態數據區：存儲全局變量、靜態變量、常量，常量包括final修飾的常量和String常量。系統自動分配和回收。</li><li class=ql-align-justify>棧區：存儲運行方法的形參、局部變量、返回值。由系統自動分配和回收。</li><li class=ql-align-justify>堆區：new一個對象的引用或地址存儲在棧區，指向該對象存儲在堆區中的真實數據。</li></ul><p class=ql-align-justify><strong>棧的實現</strong></p><p class=ql-align-justify>首先我們需要了解下棧都有哪些操作：</p><p class=ql-align-justify>通過查看JDK中棧的源代碼<strong>java.util.Stack&lt;E></strong>，我們知道棧至少有下面幾個操作：</p><ul><li class=ql-align-justify><strong>push 入棧</strong></li><li class=ql-align-justify><strong>pop 出棧</strong></li><li class=ql-align-justify><strong>peek 訪問棧頂元素</strong></li><li class=ql-align-justify><strong>empty 判斷棧是否為空</strong></li><li class=ql-align-justify><strong>search 查找站內元素</strong></li></ul><p class=ql-align-justify>棧即可用數組實現，也可以用鏈表實現，用數組實現的棧，叫做<strong>順序棧</strong>，用鏈表實現的棧，叫做<strong>鏈式棧</strong>。不管是順序棧還是鏈式棧，入棧、出棧只涉及棧頂數據的操作，所以時間複雜度都是<strong>O(1)</strong>。</p><p class=ql-align-justify><strong>乞丐版（固定大小）</strong></p><p class=ql-align-justify><strong>數組實現棧</strong></p><pre>//基於數組實現的順序棧public class ArrayStack { private String[] items; // 數組 private int count; // 棧中元素個數 private int n; // 棧的大小 // 初始化數組，申請一個大小為 n 的數組空間 public ArrayStack(int n) { this.items = new String[n]; this.n = n; this.count = 0; } // 入棧操作 public boolean push(String item) { // 數組空間不夠了，直接返回 false，入棧失敗。 if (count == n) return false; // 將 item 放到下標為 count 的位置，並且 count 加一 items[count] = item; ++count; return true; } // 出棧操作 public String pop() { // 棧為空，則直接返回 null if (count == 0) return null; // 返回下標為 count-1 的數組元素，並且棧中元素個數 count 減一 String tmp = items[count - 1]; --count; return tmp; }}</pre><p class=ql-align-justify><strong>鏈表實現棧</strong></p><pre>public static class LinkedListBasedStack { private int size; private Node top;  static Node createNode(String data, Node next) { return new Node(data, next); } public void clear() { this.top = null; this.size = 0; } public void push(String data) { Node node = createNode(data, this.top); this.top = node; this.size++; } public String pop() { Node popNode = this.top; if (popNode == null) { System.out.println("Stack is empty."); return null; } this.top = popNode.next; if (this.size &gt; 0) { this.size--; } return popNode.data; } public String getTopData() { if (this.top == null) { return null; } return this.top.data; } public int size() { return this.size; } public void print() { System.out.println("Print stack:"); Node currentNode = this.top; while (currentNode != null) { String data = currentNode.getData(); System.out.print(data + "\t"); currentNode = currentNode.next; } System.out.println(); } public static class Node { private String data; private Node next; public Node(String data) { this(data, null); } public Node(String data, Node next) { this.data = data; this.next = next; } public void setData(String data) { this.data = data; } public String getData() { return this.data; } public void setNext(Node next) { this.next = next; } public Node getNext() { return this.next; } }}</pre><p><strong>增強版（動態擴容）</strong></p><p>上面我們實現的棧，都是固定大小的，也就是說，在初始化棧時需要制定棧的大小，而且一旦初始化，後邊是不能擴容的，當棧滿了以後，就不能再往棧裡添加數據了。儘管鏈式棧的大小不受限，但是需要存儲指針，內存消耗會比較多。</p><p>在學習數組的時候，我們實現了一個支持動態擴容的數組，就是當數組空間不夠用時，重新申請一塊更大的內存，將原來數組彙總的數據拷貝進去，這樣就實現了一個支持動態擴容的數組。同理，動態擴容的棧也可以這樣做，當棧滿了以後，就申請一個更大的數組將原來的數據搬移到新的數據中，我們可以看下JDK源碼中對棧進行擴容的部分：</p><pre>/** * This implements the unsynchronized semantics of ensureCapacity. * Synchronized methods in this class can internally call this * method for ensuring capacity without incurring the cost of an * extra synchronization. * * @see #ensureCapacity(int) */private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);}/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;}</pre><p>是不是很熟悉，鏈表就是這麼幹的，其實底層都是用的數組拷貝。現在我們已經知道如何實現一個動態擴容的棧了：</p><pre>import java.util.Arrays;import java.util.EmptyStackException;public class ArrayBasedStackUp { // 存儲元素的數組,聲明為Object類型能存儲任意類型的數據 private Object[] elementData; // 指向棧頂的指針 private int top; // 棧的總容量 private int size; // 默認構造一個容量為10的棧 public ArrayBasedStackUp() { this.elementData = new Object[10]; this.top = -1; this.size = 10; } public ArrayBasedStackUp(int initialCapacity) { if (initialCapacity &lt; 0) { throw new IllegalArgumentException("棧初始容量不能小於0: " + initialCapacity); } this.elementData = new Object[initialCapacity]; this.top = -1; this.size = initialCapacity; } // 壓入元素 public Object push(Object item) { // 是否需要擴容 isGrow(top + 1); elementData[++top] = item; return item; } // 彈出棧頂元素 public Object pop() { Object obj = peek(); remove(top); return obj; } // 獲取棧頂元素 public Object peek() { if (top == -1) { throw new EmptyStackException(); } return elementData[top]; } // 判斷棧是否為空 public boolean isEmpty() { return (top == -1); } // 刪除棧頂元素 public void remove(int top) { // 棧頂元素置為null elementData[top] = null; this.top--; } /** * 是否需要擴容，如果需要，則擴大一倍並返回true，不需要則返回false *  * @param minCapacity * @return */ public boolean isGrow(int minCapacity) { int oldCapacity = size; // 如果當前元素壓入棧之後總容量大於前面定義的容量，則需要擴容 if (minCapacity &gt;= oldCapacity) { // 定義擴大之後棧的總容量 int newCapacity = 0; // 棧容量擴大兩倍(左移一位)看是否超過int類型所表示的最大範圍 if ((oldCapacity &lt;&lt; 1) - Integer.MAX_VALUE &gt; 0) { newCapacity = Integer.MAX_VALUE; } else { newCapacity = (oldCapacity &lt;&lt; 1);// 左移一位，相當於*2 } this.size = newCapacity; elementData = Arrays.copyOf(elementData, size); return true; } else { return false; } }}</pre><p class=ql-align-justify>我們來分析下支持動態擴容的順序棧的入棧、出棧操作的時間複雜度。對於出棧操作來說，不會涉及內存的重新申請和數據的搬移，所以時間複雜度還是O(1)，但是，對於入棧來說就不一樣了，當棧中有空餘空間時，入棧的操作時間複雜度就是O(1)，但是當空間不夠時，就需要重新申請內存和數據搬移，時間複雜度就成了O(n)。因為只有極少數情況才會進行數據搬移（只有棧滿才會搬移），少數服從多數，所以平均時間複雜度就是O(1)。</p><p class=ql-align-justify><strong>棧的應用</strong></p><p class=ql-align-justify><strong>函數調用棧</strong></p><p class=ql-align-justify>函數調用棧是非常經典的應用場景，我們知道，操作系統給每個線程分配了一塊獨立的內存空間，這塊內存空間被組織成棧這種結構，用來存儲函數調用時的臨時變量，每進入一個函數，會將臨時變量作為一個棧幀入棧，函數調用完成後，將這個函數對應的棧幀出棧。來看下邊這段代碼：</p><pre>public static void main(String[] args) { int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; System.out.println(res);}public static int add(int x, int y) { int sum = 0; sum = x + y; return sum;}</pre><p>main函數調用add函數，獲取到add函數的計算結果，並且與臨時變量a相加，然後打印res的值。下圖是執行到add函數時，函數調用棧的使用情況：</p><div class=pgc-img><img alt=數據結構與算法（5）棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b154bb72493f44cfa7a0217669720bac><p class=pgc-img-caption></p></div><p>為什麼函數調用要用“棧”來保存臨時變量呢？用其他數據結構不行嗎？</p><p>其實，我們不一定非要用棧來保存臨時變量，只不過如果這個函數調用符合後進先出的特性，用棧這種數據結構來實現，是最順理成章的選擇。</p><p>從調用函數進入被調用函數，對於數據來說，變化的是什麼呢？是作用域。所以根本上，只要能保證每進入一個新的函數，都是一個新的作用域就可以。而要實現這個，用棧就非常方便。在進入被調用函數的時候，分配一段棧空間給這個函數的變量，在函數結束的時候，將棧頂復位，正好回到調用函數的作用域內。</p><p><strong>表達式求值</strong></p><p>20世紀50年代，波蘭邏輯學家Jan Łukasiewicz想到了一種不需要括號的後綴表達法，即<strong>逆波蘭</strong>（Reverse Polish Notation）表示，這一表示方式，巧妙地解決了程序實現四則運算的難題。</p><p>在計算機中，表達式求值是利用兩個棧來實現的，一個棧保存操作數，一個棧保存運算符，我們從左到右遍歷表達式，當遇到數字時，就直接壓入操作數棧，當遇到運算符時，就與運算符棧的棧頂元素進行比較，如果比運算符棧的棧頂元素優先級高，就將當前運算符壓入棧，如果比運算符棧的棧頂元素優先級相同，從運算符棧中取出棧頂運算符，從操作數棧中取棧頂兩個操作數，然後進行計算，再把計算的結果壓入操作數棧，繼續比較。</p><p>我們以3+5*8-6為例，理解下上面的過程：</p><div class=pgc-img><img alt=數據結構與算法（5）棧 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/071f8bb8b25f47e5baa36e29ab2b9152><p class=pgc-img-caption></p></div><pre>import java.util.Scanner;import java.util.Stack;/** * 程序代碼來源於：https://blog.csdn.net/guying_2016/article/details/82348464 * 思路參考：https://blog.csdn.net/u011446177/article/details/42389511?locationNum=15&amp;fps=1 * 四則運算的兩個操作過程及其他輔助判斷 *  * 使用棧實現四則運算 * 1.中綴表達式 --&gt; 後綴表達式  * 思路：從左到右遍歷中綴表達式的每個數字和符號  * 若是數字，直接輸出（或保存到某一鏈表中） * 若是符號，則判斷其與棧頂符號的優先級 是 右括號 或 優先級不高於 棧頂符號的優先級，則棧頂元素依次出棧並輸出 並將當前符號進棧，一直到最終輸出後綴表達式為止。 * 注意：棧頂元素與當前符號優先級相同也要輸出！ * 2.後綴表達式進行四則運算 * 思路：把數字壓入堆棧，遇到操作符就從棧中取出兩個數進行相關運算，把結果在存放入棧中直到最後操作完成，輸出最終結果 */public class ArithmeticExp { // 成員變量 private String prefixExp; // 前綴表達式 private String infixExp; // 中綴表達式 private String postfixExp; // 後綴表達式 /** * 構造方法 */ public ArithmeticExp() { } public ArithmeticExp(String infixExp) { this.infixExp = infixExp; } public String getPrefixExp() { return prefixExp; } public void setPrefixExp(String prefixExp) { this.prefixExp = prefixExp; } public String getInfixExp() { return infixExp; } public void setInfixExp(String infixExp) { this.infixExp = infixExp; } public String getPostfixExp() { return postfixExp; } public void setPostfixExp(String postfixExp) { this.postfixExp = postfixExp; } /** * 1.轉化成後綴表達式（逆波蘭表達式） */ public void cover2PostfixExp() { // 創建堆棧 Stack&lt;Character&gt; ls = new Stack&lt;Character&gt;(); this.postfixExp = ""; // 遍歷表達式的每一個字符 for (int i = 0; this.infixExp != null &amp;&amp; i &lt; this.infixExp.length(); i++) { char ch = this.infixExp.charAt(i); if (' ' != ch) { // 當前字符不為空 時的操作 if (isLeftBracket(ch)) { // 是左括號，壓棧 ls.push(ch); } else if (isRightBracket(ch)) { // 是右括號，將所有操作符出棧，直到遇到一個左括號，並將這個左括號丟棄 char topOperator = ls.pop(); while (!isLeftBracket(topOperator)) { postfixExp += (topOperator + " "); // 使用空格 隔開 topOperator = ls.pop(); } } else if (isOperator(ch)) { // 是操作符，要判斷優先級，再決定是否需要入棧 /** * 如果棧為空，直接進棧。如果棧非空，則需要將棧頂運算符的優先級和要入棧的運算符的優先級進行比較 * 將棧中比要入棧的運算符優先級高的運算符都出棧，然後將該運算符入棧 */ if (!ls.isEmpty()) { // 如果棧非空 // 獲取棧頂的運算符 Character topOperator = ls.peek(); while (topOperator != null &amp;&amp; priority(topOperator.charValue()) &gt;= priority(ch)) { postfixExp += (ls.pop() + " "); if (!ls.isEmpty()) { topOperator = ls.peek(); } else { break; } } } // 將當前操作符 壓棧 ls.push(ch); } else { if (i &gt; 0 &amp;&amp; isNumber(infixExp.charAt(i - 1))) { postfixExp = postfixExp.substring(0, postfixExp.length() - 1) + ch + " "; } else { postfixExp += ch + " "; } } } } while (!ls.isEmpty()) { postfixExp += (ls.pop() + " "); } // 去除表達式中的最後一個空格 // postfixExp = postfixExp.substring(0, postfixExp.length() - 1); postfixExp = postfixExp.trim(); } /** * 運算符優先級比較 *  * @param charValue * @return */ public int priority(char charValue) { switch (charValue) { case '+': case '-': return 1; case '*': case '/': case '%': return 2; case '^': return 3; } return 0; } /** * 判斷是否是操作符 *  * @param ch * @return */ public boolean isOperator(char ch) { if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^' || ch == '%') { return true; } return false; } /** * 2.使用後綴表達式 進行 四則運算 */ public int calculateExpResult() { String[] strs = this.postfixExp.split(" "); Stack&lt;Integer&gt; ls = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; strs.length; i++) { // 如果是操作符，從堆棧獲取兩個值，進行運算 if (strs[i].length() == 1 &amp;&amp; isOperator(strs[i].charAt(0))) { int num2 = ls.pop(); int num1 = ls.pop(); ls.push(calculate2Numbers(num1, num2, strs[i].charAt(0))); } else { // 如果是數字，壓入堆棧 ls.push(Integer.parseInt(strs[i])); } } return ls.pop(); } /** * 兩數的運算操作 *  * @param num1 * @param num2 * @param operator * @return */ public Integer calculate2Numbers(int num1, int num2, char operator) { switch (operator) { case '+': return num1 + num2; case '-': return num1 - num2; case '*': return num1 * num2; case '/': return num1 / num2; case '%': return num1 % num2; case '^': return num1 ^ num2; } return null; } /** * 判斷是否是左括號 *  * @param ch * @return 布爾值 */ public boolean isLeftBracket(char ch) { if (ch == '(') { return true; } return false; } /** * 判斷是否是右括號 *  * @param ch * @return 布爾值 */ public boolean isRightBracket(char ch) { if (ch == ')') { return true; } return false; } /** * 判斷是否是數字 *  * @param ch * @return */ public boolean isNumber(char ch) { if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { return true; } return false; } // 中綴表達式：9+(3-1)*3+10/2 public static void main(String[] args) { // 從控制檯獲取中綴表達式 Scanner sc = new Scanner(System.in); String infixExp = sc.nextLine(); sc.close(); // 創建對象，進行後續操作 ArithmeticExp ae = new ArithmeticExp(infixExp); System.out.println("中綴表達式：" + ae.getInfixExp()); // 轉化為後綴表達式 ae.cover2PostfixExp(); System.out.println("後綴表達式：" + ae.getPostfixExp()); System.out.println(ae.getPostfixExp().length()); // 使用後綴表達式 進行 四則運算 int calculateExpResult = ae.calculateExpResult(); // 結果輸出 System.out.println("計算結果：" + calculateExpResult); }}</pre><p><strong>棧實現字符串逆序</strong></p><p>我們知道棧是後進先出，我們可以將一個字符串分隔為單個的字符，然後將字符一個一個push()進棧，在一個一個pop()出棧就是逆序顯示了。如下：</p><pre>// 利用棧反轉字符串public void testStringReversal() { ArrayBasedStackUp stack = new ArrayBasedStackUp(); String str = "how are you"; char[] cha = str.toCharArray(); for (char c : cha) { stack.push(c); } while (!stack.isEmpty()) { System.out.print(stack.pop()); }}</pre><p><strong>判斷括號匹配</strong></p><p>寫XML或者HTML標籤時，括號都是成對出現的，比如&lt;和>就是匹配的一對，對於 12&lt;a[b{c}]>，我們可以將字符一次入棧，遇到匹配正確的就消除，最後棧中的內容為空則匹配成功，否則匹配失敗。如下圖所示：</p><div class=pgc-img><img alt=數據結構與算法（5）棧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4bc39ff76fdd4d48bd8cebc143798bcf><p class=pgc-img-caption></p></div><pre>// 利用棧判斷括號是否匹配public void testMatch() { ArrayBasedStackUp stack = new ArrayBasedStackUp(3); String str = "12&lt;a[b{c}]&gt;"; char[] cha = str.toCharArray(); for (char c : cha) { switch (c) { case '{': case '[': case '&lt;': stack.push(c); break; case '}': case ']': case '&gt;': if (!stack.isEmpty()) { char ch = stack.pop().toString().toCharArray()[0]; if (c == '}' &amp;&amp; ch != '{' || c == ']' &amp;&amp; ch != '[' || c == ')' &amp;&amp; ch != '(') { System.out.println("Error:" + ch + "-" + c); } } break; default: break; } }}</pre><p><strong>棧實現瀏覽器前進後退</strong></p><p>實現瀏覽器的前進後退功能，需要用兩個棧，棧X和棧Y，我們把首次瀏覽的頁面依次加入棧X，當點擊後退按鈕時，再依次從棧X中出棧，將出棧的數據依次放入棧Y，當按前進按鈕時，依次從棧Y中取出數據，放入棧X中，當棧X中沒有數據時，說明沒有頁面可以進行後退了，當Y中沒有數據時，說明沒有頁面可以前進瀏覽了。如果在回退瀏覽的過程中，跳入了棧中不存在的頁面，這時候就要清空棧Y中的數據。</p><pre>public class SampleBrowser { public static void main(String[] args) { SampleBrowser browser = new SampleBrowser(); browser.open("http://www.baidu.com"); browser.open("http://news.baidu.com/"); browser.open("http://news.baidu.com/ent"); browser.goBack(); browser.goBack(); browser.goForward(); browser.open("http://www.qq.com"); browser.goForward(); browser.goBack(); browser.goForward(); browser.goBack(); browser.goBack(); browser.goBack(); browser.goBack(); browser.checkCurrentPage(); } private String currentPage; private LinkedListBasedStack backStack; private LinkedListBasedStack forwardStack; public SampleBrowser() { this.backStack = new LinkedListBasedStack(); this.forwardStack = new LinkedListBasedStack(); } public void open(String url) { if (this.currentPage != null) { this.backStack.push(this.currentPage); this.forwardStack.clear(); } showUrl(url, "Open"); } public boolean canGoBack() { return this.backStack.size() &gt; 0; } public boolean canGoForward() { return this.forwardStack.size() &gt; 0; } public String goBack() { if (this.canGoBack()) { this.forwardStack.push(this.currentPage); String backUrl = this.backStack.pop(); showUrl(backUrl, "Back"); return backUrl; } System.out.println("* Cannot go back, no pages behind."); return null; } public String goForward() { if (this.canGoForward()) { this.backStack.push(this.currentPage); String forwardUrl = this.forwardStack.pop(); showUrl(forwardUrl, "Foward"); return forwardUrl; } System.out.println("** Cannot go forward, no pages ahead."); return null; } public void showUrl(String url, String prefix) { this.currentPage = url; System.out.println(prefix + " page == " + url); } public void checkCurrentPage() { System.out.println("Current page is: " + this.currentPage); }}</pre><div class=pgc-img><img alt=數據結構與算法（5）棧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec3bc67eb8864ca9ad6cd22b6c583016><p class=pgc-img-caption>微信公眾號：行知老王</p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>算法</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/ef6637be.html alt=數據結構與算法——最小生成樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/36b27200eb7c41258d8210393c3e09bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/ef6637be.html title=數據結構與算法——最小生成樹>數據結構與算法——最小生成樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/5f49cdf4.html alt="算法數據結構 | 圖論基礎算法——拓撲排序" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/08463ba999024f5196ee88aa19271453 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/5f49cdf4.html title="算法數據結構 | 圖論基礎算法——拓撲排序">算法數據結構 | 圖論基礎算法——拓撲排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a4da90.html alt=數據結構與算法系列——棧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0d4a7d6b37a44c58a0ea25dcacf791fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a4da90.html title=數據結構與算法系列——棧>數據結構與算法系列——棧</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/cf78e53.html alt=數據結構與算法：算法的時間複雜度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e6eb9908a8c7481089159ead17c42eae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/cf78e53.html title=數據結構與算法：算法的時間複雜度>數據結構與算法：算法的時間複雜度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>