<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 | 极客快訊</title><meta property="og:title" content="計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/34d453e5890040df90f58c905190d656"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><meta property="article:published_time" content="2020-10-29T21:08:28+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:28+08:00"><meta name=Keywords content><meta name=description content="計算機科學史上偉大的成就之一：Dijkstra最短路徑算法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c52e1dd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>計算機科學史上偉大的成就之一：Dijkstra最短路徑算法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>現在，我們準備介紹計算機科學史上偉大的成就之一：Dijkstra最短路徑算法[1]。這個算法適用於邊的長度均不為負數的有向圖，它計算從一個起始頂點到其他所有頂點的最短路徑的長度。在正式定義這個問題（3.1節）之後，我們講解這個算法（3.2節）以及它的正確性證明（3.3節），然後介紹一個簡單直接的實現（3.4節）。在第4章中，我們將看到這種算法的一種令人驚歎的快速實現，它充分利用了堆這種數據結構。</p><h1 class=pgc-h-arrow-right>3.1　單源最短路徑問題</h1><h1 class=pgc-h-arrow-right>3.1.1　問題定義</h1><p style=text-align:start>Dijkstra算法解決了單源最短路徑問題。[2]</p><blockquote><p><strong>問題：單源最短路徑</strong></p><p><strong>輸入：</strong>有向圖<em>G</em>=(<em>V</em>, <em>E</em>)，起始頂點<em>s</em>∈<em>V</em>，並且每條邊<em>e</em>∈<em>E</em>的長度<em>e</em>均為非負值。</p><p><strong>輸出：</strong>每個頂點<em>v</em>∈<em>V</em>的<em>dist</em>(<em>s</em>,<em>v</em>)。</p></blockquote><p style=text-align:start>注意，<em>dist</em>(<em>s</em>,<em>v</em>)這種記法表示從<em>s</em>到<em>v</em>的最短路徑的長度（如果不存在從<em>s</em>到<em>v</em>的路徑，<em>dist</em>(<em>s</em>,<em>v</em>)就是+∞）。所謂路徑的長度，就是組成這條路徑的各條邊的長度之和。例如，在一個每條邊的長度均為1的圖中，路徑的長度就是它所包含的邊的數量。從頂點<em>v</em>到頂點<em>w</em>的最短路徑就是所有從<em>v</em>到<em>w</em>的路徑中長度最短的。</p><p style=text-align:start>例如，如果一個圖表示道路網，每條邊的長度表示從一端到另一端的預期行車時間，那麼單源最短路徑問題就成為計算從一個起始頂點到所有可能的目的地的行車時間的問題。</p><blockquote><p><strong>小測驗3.1</strong></p><p>考慮單源最短路徑問題的下面這個輸入，起始頂點為<em>s</em>，每個邊都有一個標籤標識了它的長度：</p><p>從<em>s</em>出發到<em>s</em>、<em>v</em>、<em>w</em>和<em>t</em>的最短距離分別是多少？</p><p>（a）0，1，2，3</p><p>（b）0，1，3，6</p><p>（c）0，1，4，6</p><p>（d）0，1，4，7</p><p>（正確答案和詳細解釋參見3.1.4節。）</p></blockquote><h1 class=pgc-h-arrow-right>3.1.2　一些前提條件</h1><p style=text-align:start>方便起見，我們假設本章中的輸入圖是有向圖。經過一些微小的戲劇性修改之後，Dijkstra算法同樣適用於無向圖（可以進行驗證）。</p><p style=text-align:start>另一個前提條件比較重要。問題陳述已經清楚地表明：我們假設每條邊的長度是非負的。在許多應用中（例如計算行車路線），邊的長度天然就是非負的（除非涉及時光機器），完全不需要擔心這個問題。但是，我們要記住，圖的路徑也可以表示抽象的決策序列。例如，也許我們希望計算涉及購買和銷售的金融交易序列的利潤。這個問題相當於在一個邊的長度可能為正也可能為負的圖中尋找最短路徑。在邊的長度可能為負的應用中，我們不應該使用Dijkstra算法，具體原因可以參考3.3.1節。[3]</p><h1 class=pgc-h-arrow-right>3.1.3　為什麼不使用寬度優先的搜索</h1><p style=text-align:start>如2.2節所述，寬度優先的搜索的一個“殺手”級應用就是計算從一個起始頂點出發的最短路徑。我們為什麼需要另一種最短路徑算法呢？</p><p style=text-align:start>記住，寬度優先的搜索計算的是從起始頂點到每個其他頂點的邊數最少的路徑，這是單源最短路徑問題中每條邊的長度均為1這種特殊情況。我們在小測驗3.1中看到，對於通用的非負長度邊，最短路徑並不一定是邊數最少的路徑。最短路徑的許多應用，例如計算行車路線或金融交易序列，不可避免地涉及不同長度的邊。</p><p style=text-align:start>但是，讀者可能會覺得，通用的最短路徑問題與這種特殊情況真的存在這麼大的區別嗎？如圖3.1所示，我們不能把一條更長的邊看成3條長度為1的邊組成的路徑嗎？</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34d453e5890040df90f58c905190d656><p class=pgc-img-caption></p></div><p style=text-align:center>圖3.1　路徑</p><p>事實上，“一條長度為正整數</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b27f151295a84b19becca32490248d49><p class=pgc-img-caption></p></div><p>的邊”和“一條由</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b27f151295a84b19becca32490248d49><p class=pgc-img-caption></p></div><p>條長度為1的邊所組成的路徑”之間並沒有本質的區別。在原則上，我們可以把每條邊展開為由多條長度為1的邊組成的路徑，然後應用寬度優先的搜索對圖進行展開來解決單源最短路徑問題。</p><p style=text-align:start>這是把一個問題簡化為另一個問題的一個例子。在這個例子中，就是從邊的長度為正整數的單源最短路徑問題簡化為每條邊的長度均為1的特殊情況。</p><p style=text-align:start>這種簡化所存在的主要問題是它擴大了圖的規模。如果所有邊的長度都是小整數，那麼這種擴張並不是嚴重的問題。但在實際應用中，情況並不一定如此。某條邊的長度很可能比原圖中頂點和邊的總數還要大很多！寬度優先的搜索在擴張後的圖中的運行效率是線性時間，但這種線性時間並不一定接近原圖長度的線性時間。</p><p style=text-align:start>Dijkstra算法可以看成是在擴張後的圖上執行寬度優先的搜索的一種靈活模擬，它只對原始輸入圖進行操作，其運行時間為近似線性。</p><blockquote><p><strong>關於簡化</strong></p><p>如果一種能夠解決問題<em>B</em>的算法可以方便地經過轉換解決問題<em>A</em>，那麼問題<em>A</em>就可以簡化為問題<em>B</em>。例如，計算數組的中位元素的問題可以簡化為對數組進行排序的問題。簡化是算法及其限制的研究中非常重要的概念，具有極強的實用性。</p><p>我們總是應該尋求問題的簡化。當我們遇到一個似乎是新的問題時，總是要問自己：這個問題是不是一個我們已經知道怎樣解決的問題的偽裝版本呢？或者，我們是不是可以把這個問題的通用版本簡化為一種特殊情況呢？</p></blockquote><h1 class=pgc-h-arrow-right>3.1.4　小測驗3.1的答案</h1><p style=text-align:start><strong>正確答案：（b）。</strong>從<em>s</em>到本身的最短路徑的長度為0以及從<em>s</em>到<em>v</em>的最短路徑的長度為1不需要討論。頂點<em>w</em>稍微有趣一點。從<em>s</em>到<em>w</em>的其中一條路徑是有向邊(<em>s</em>,<em>w</em>)，它的長度是4。但是，通過更多的邊可以減少總長度：路徑<em>s</em>→<em>v</em>→<em>w</em>的長度只有1+2=3，它是最短的<em>s</em>−<em>w</em>路徑。類似地，從<em>s</em>到<em>t</em>的每條經過兩次跳躍的路徑的長度為7，而那條更迂迴的路徑的長度只有1+2+3=6。</p><h1 class=pgc-h-arrow-right>3.2　Dijkstra算法</h1><h1 class=pgc-h-arrow-right>3.2.1　偽碼</h1><p style=text-align:start>Dijkstra算法的高層結構與第2章的圖搜索算法相似。[4]它的主循環的每次迭代處理一個新的頂點。這個算法的高級之處在於它採用了一種非常“聰明”的規則選擇接下來處理哪個頂點：就是尚未處理的頂點中看上去最靠近起始頂點的那一個。下面的優雅偽碼精確地描述了這個思路。</p><blockquote><p><strong>Dijkstra算法</strong></p><p><strong>輸入：</strong>鄰接列表表示形式的有向邊<em>G</em>=(<em>V</em>,<em>E</em>)，對於每條邊<em>e</em>∈<em>E</em>，它的長度都大於或等於0。</p><p><strong>完成狀態：</strong>對於每個頂點<em>v</em>，<em>len</em>(<em>v</em>)的值等於真正的最短路徑長度<em>dist</em>(<em>s</em>,<em>v</em>)。</p><p>// 初始化 1 <em>X</em> := {<em>s</em>} 2 <em>len</em>(<em>s</em>) := 0, <em>len</em>(<em>v</em>) := +∞ for每個<em>v</em>≠<em>s</em> // 主循環 3 <strong>while</strong> 存在一條邊(<em>v</em>,<em>w</em>)，<em>v</em>∈<em>X</em>,<em>w</em>∉<em>X</em> <strong>do</strong> 4 (<em>v</em>*, <em>w</em>*) := 具有最小的<em>len</em>(<em>v</em>)+ 的邊 5 把<em>w</em>*加到<em>X</em>中 6 <em>len</em>(<em>w*</em>):=<em> len</em>(<em>v*</em>)+</p></blockquote><p>集合<em>X</em>包含了這個算法已經處理過的頂點。一開始，<em>X</em>只包含了起始頂點（當然，<em>len</em>(<em>s</em>)=0），然後這個集合不斷增長，直到它覆蓋了從<em>s</em>可以到達的所有頂點。當這個算法把一個頂點添加到<em>X</em>時，它同時為這個頂點的<em>len</em>值賦一個有限的值。主循環的每次迭代向<em>X</em>添加一個新頂點，即某條從<em>X</em>跨越到<em>V</em>−<em>X</em>的邊(<em>v</em>,<em>w</em>)的頭頂點（圖3.2）。（如果不存在這樣的邊，算法就會終止，對於所有的</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8de17a7b3f7d4bab9addacd422e813b2><p class=pgc-img-caption></p></div><p>，都有<em>len</em>(<em>v</em>)=+∞。）符合條件的邊可能有多條，Dijkstra算法選擇Dijkstra得分最低的那條邊(<em>v</em>*,<em>w</em>*)，它被定義為</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/733f8c7affbd4ab6bc56ca54c25e64fe><p class=pgc-img-caption></p></div><p style=text-align:right>（3.1）</p><p style=text-align:start>注意，Dijkstra得分是根據邊進行定義的，頂點<em>w</em>∉<em>X</em>可能是許多不同的從<em>X</em>跨越到<em>V</em>−<em>X</em>的邊的頭頂點，這些邊一般具有不同的Dijkstra得分。</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/176159291f93496fab5cb0c089b83bbc><p class=pgc-img-caption></p></div><p style=text-align:center>圖3.2　Dijkstra算法的每次迭代處理一個新頂點，即一條從<em>X</em>跨越到<em>V</em>−<em>X</em>的邊的頭頂點</p><p>我們可以把一條邊(<em>v</em>,<em>w</em>)（<em>v</em>∈<em>X</em>,<em>w</em>∉<em>X</em>）的Dijkstra得分與一個假想相關聯。這個假想就是：從<em>s</em>到<em>w</em>的最短路徑是由一條從<em>s</em>到<em>v</em>的最短路徑（其長度應該是<em>len</em>(<em>v</em>)）和一條緊隨其後的邊(<em>v</em>,<em>w</em>)（其長度為</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57654aaaa9724acba5698ebb25459583><p class=pgc-img-caption></p></div><p>）所組成的。因此，Dijkstra算法根據已經計算的最短路徑的長度，並根據從<em>X</em>跨越到<em>V</em>−<em>X</em>的各條邊的長度，在尚未處理的頂點中選擇添加看上去最靠近<em>s</em>的那個頂點。在把<em>w</em>*添加到<em>X</em>時，這個算法把<em>len</em>(<em>w</em>*)作為從<em>s</em>出發的假想最短路徑的長度，也就是邊(<em>v</em>*,<em>w</em>*)的Dijkstra得分<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p>。後面的定理3.1規範描述的Dijkstra算法的神奇之處就在於這個假想保證是正確的，即使這個算法目前只是觀察了整個圖的很小一部分。[5]</p><h1 class=pgc-h-arrow-right>3.2.2　一個例子</h1><p style=text-align:start>讓我們根據小測驗3.1的例子對Dijkstra算法進行試驗：</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a2f8181eb78a4c83ba69478ed7e58954><p class=pgc-img-caption></p></div><p>一開始，集合<em>X</em>只包含了頂點<em>s</em>，且<em>len</em>(<em>s</em>)=0。在主循環的第1次迭代中，有(<em>s</em>,<em>v</em>)和(<em>s</em>,<em>w</em>)兩條邊從<em>X</em>跨越到<em>V</em>−<em>X</em>（因此它們均可以扮演(<em>v</em>*,<em>w</em>*)的角色）。這兩條邊的Dijkstra得分（由式（3.1）所定義）分別是<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2e46f7ce69e43b0a53572e6026973dd><p class=pgc-img-caption></p></div><p>= 0+1=1和<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/20de1e52ee6a46a99a8d52c90c2f8f9c><p class=pgc-img-caption></p></div><p>=0+4=4。由於前者的得分更低，因此它的頭頂點<em>v</em>就被添加到<em>X</em>中，並且<em>len</em>(<em>v</em>)被賦值為邊(<em>s</em>,<em>v</em>)的Dijkstra得分，其值為1。在第2次迭代時，<em>X</em>={<em>s</em>,<em>v</em>}，有(<em>s</em>,<em>w</em>)、(<em>v</em>,<em>w</em>)和(<em>v</em>,<em>t</em>)共3條邊可以扮演(<em>v</em>*,<em>w</em>*)的角色。它們的Dijkstra得分分別是0+4=4、1+2=3和1+6=7。由於(<em>v</em>,<em>w</em>)具有最低的Dijkstra得分，因此<em>w</em>被添加到<em>X</em>中，<em>len</em>(<em>w</em>)被賦值為3（(<em>v</em>,<em>w</em>)的Dijkstra得分）。我們已經知道哪個頂點會在最後一次迭代中被添加到<em>X</em>（唯一未被處理的頂點<em>t</em>），但仍然需要確定它是因為哪條邊而被添加（為了計算<em>len</em>(<em>t</em>)）。由於(<em>v</em>,<em>t</em>)和(<em>w</em>,<em>t</em>)的Dijkstra得分分別是1+6=7和3+3=6，因此<em>len</em>(<em>t</em>)被設置為較小的值6。現在，集合<em>X</em>包含了所有的頂點，不再有任何邊從<em>X</em>跨越到<em>V</em>−<em>X</em>，因此算法就宣告結束。<em>len</em>(<em>s</em>)=0，<em>len</em>(<em>v</em>)=1，<em>len</em>(<em>w</em>)=3，<em>len</em>(<em>t</em>)=6這幾個值與我們在小測驗3.1中所驗證的真正最短路徑的長度是匹配的。</p><p style=text-align:start>當然，一個算法在一個特定的例子上是正確的並不能就此說明它在所有情況下都是正確的！[6]事實上，Dijkstra算法並不能正確地計算邊的長度可能為負時的最短路徑長度（如3.3.1節所述）。我們在一開始就應該對Dijkstra算法保持懷疑，要求給出它的證明，至少要證明對於邊的長度非負的圖，它能夠正確地解決單源最短路徑問題。</p><h1 class=pgc-h-arrow-right>*3.3　為什麼Dijkstra算法是正確的</h1><h1 class=pgc-h-arrow-right>3.3.1　一種虛假的簡化</h1><p style=text-align:start>讀者可能會覺得奇怪，邊的長度是否為負為什麼會有影響呢？難道不能把每條邊的長度都加上同一個很大的數字，讓所有邊的長度都為非負嗎？</p><p style=text-align:start>這是一個很好的問題，我們總是應該尋求是否能夠把待解決的問題簡化為已經知道怎樣解決的問題。可惜的是，我們不能按照這種方式把通用邊長的單源最短路徑問題簡化為非負邊長的特殊情況。問題在於從一個頂點到另一個頂點的不同路徑並不一定具有相同數量的邊。如果我們把每條邊的長度都加上一個數，不同路徑所增加的數量可能並不相同，新圖的最短路徑可能與原圖並不相同。圖3.3所示的是一個簡單的例子。</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f349d049ec44b9cb8d332b0f6a0676e><p class=pgc-img-caption></p></div><p style=text-align:center>圖3.3　單源最短路徑問題舉例</p><p style=text-align:start>從<em>s</em>到<em>t</em>共有兩條路徑：直接路徑（長度為-2）和經過兩次跳躍的路徑<em>s</em>→<em>v</em>→<em>t</em>（長度為1+(-5)=4）。</p><p style=text-align:start>後者的長度更長（即絕對值更大的負值），因此是最短的<em>s</em>-<em>t</em>路徑。</p><p style=text-align:start>為了使這張圖具有非負的邊長，我們可以把每條邊的長度都加上5，結果如圖3.4所示。</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed0e60f288a5472b86ecc445f546158b><p class=pgc-img-caption></p></div><p style=text-align:center>圖3.4　每條邊長度加5後的路徑</p><p style=text-align:start>從<em>s</em>到<em>t</em>的最短路徑發生了變化，現在是直達的<em>s</em>−<em>t</em>邊（長度為3，小於另一條長度為6的路徑）。在轉換後的圖中運行最短路徑算法所產生的結果與原圖不同。</p><h1 class=pgc-h-arrow-right>3.3.2　Dijkstra算法的一個糟糕例子</h1><p>如果我們在一個某些邊的長度為負的圖（例如3.3.1節中的圖）上運行Dijkstra算法，那麼會發生什麼情況呢？一開始，<em>X</em>={<em>s</em>}且<em>len</em>(<em>s</em>)=0，此時一切正常。但是，在主循環的第1次迭代中，這個算法計算邊(<em>s</em>,<em>v</em>)和(<em>s</em>,<em>t</em>)的Dijkstra得分，其值分別是<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2e46f7ce69e43b0a53572e6026973dd><p class=pgc-img-caption></p></div><p>= 0+1=1和<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/76d4155ec0d64ecfbcb3bf2ea1a39448><p class=pgc-img-caption></p></div><p>=0+(−2) = −2。後者的得分更低，因此這個算法把頂點<em>t</em>添加到<em>X</em>中，並把<em>len</em>(<em>t</em>)賦值為−2。我們已經注意到，從<em>s</em>到<em>t</em>的實際最短路徑（路徑<em>s</em>→<em>v</em>→<em>t</em>）的長度是−4。因此，我們可以得出結論，如果圖中某些邊的長度為負，Dijkstra就無法計算正確的最短路徑長度。</p><h1 class=pgc-h-arrow-right>3.3.3　非負邊長時的正確性</h1><p style=text-align:start>算法的正確性證明多少帶有一點學究氣。對於學生們在直覺上強烈地認為是正確的算法，我常常會略過它們的正確性證明。Dijkstra算法並不是這樣。首先，它不適用於邊的長度為負的圖（即使是非常簡單的圖，如3.3.1節所述）的情況已經讓我們心生疑慮。其次，Dijkstra得分這個概念（見3.1節）看上去有點神祕甚至有點隨意，它為什麼非常重要呢？由於這些疑慮，並且由於它是一種非常重要的基本算法，因此我們需要花點時間仔細地證明它的正確性（在邊的長度非負的圖中）。</p><p style=text-align:start><strong>定理3.1（Dijkstra算法的正確性）　</strong>對於每個有向圖<em>G </em>= (<em>V</em>, <em>E</em>)、每個起始頂點<em>s</em>並且所有邊長均為非負值，對於每個頂點<em>v</em>∈<em>V</em>，Dijkstra算法的結論<em>len</em>(<em>v</em>) = <em>dist</em>(<em>s</em>,<em>v</em>)都成立。</p><h1 class=pgc-h-arrow-right><strong>歸納之旅</strong></h1><p style=text-align:start>我們的計劃是根據主循環的迭代數量進行歸納，逐個計算Dijkstra算法的最短路徑長度的正確性。記住，根據數學歸納法所進行的證明採用了一個相對刻板的模板，它的目的是建立一個對於每個正整數<em>k</em>都成立的斷言<em>P</em>(<em>k</em>)。在定理3.1的證明中，我們把<em>P</em>(<em>k</em>)定義為：“在Dijkstra算法中，對於第<em>k</em>個添加到<em>X</em>中的頂點<em>v</em>，存在<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)。”</p><p style=text-align:start>與遞歸算法類似，通過數學歸納法所進行的證明分為一個基本條件和一個歸納步驟兩個部分。基本條件直接證明了<em>P</em>(1)是正確的。在歸納步驟中，我們假設<em>P</em>(1),…,<em>P</em>(<em>k</em>-1)都是正確的，這稱為歸納假設。我們使用這個假設證明<em>P</em>(<em>k</em>)也是正確的。如果基本條件和歸納步驟得到了證明，那麼<em>P</em>(<em>k</em>)對於每個正整數<em>k</em>肯定也是正確的。根據基本條件，<em>P</em>(1)是正確的。不斷地應用歸納步驟顯示了對於任意大的<em>k</em>值，<em>P</em>(<em>k</em>)都是正確的。</p><blockquote><p><strong>關於證明的閱讀</strong></p><p>數學論證根據前提條件推導出結論。在閱讀證明的時候，總是要保證理解了論證中的每個前提條件的用法，並理解為什麼缺少任何一個前提條件就會導致論證失敗。</p><p>記住這一點之後，仔細觀察定理3.1的證明中兩個關鍵的前提條件所扮演的角色：邊的長度是非負的以及算法總是會選擇具有最低Dijkstra得分的邊。在證明定理3.1時，如果不能支持這兩個前提條件，那麼證明過程必然是失敗的。</p></blockquote><h1 class=pgc-h-arrow-right><strong>定理3.1的證明</strong></h1><p style=text-align:start>我們繼續進行歸納，<em>P</em>(<em>k</em>)表示Dijkstra算法可以正確地計算添加到集合<em>X</em>的第<em>k</em>個頂點的最短路徑的長度。對於基本條件（<em>k </em>=1），我們知道添加到<em>X</em>的第1個頂點是起始頂點<em>s</em>。Dijkstra算法把0賦值給<em>len</em>(<em>s</em>)。由於每條邊都具有非負的長度，因此從<em>s</em>到它本身的最短路徑是一條空路徑，長度為0。因此，<em>len</em>(<em>s</em>)=0=<em>dist</em>(<em>s</em>,<em>s</em>)，這就證明了<em>P</em>(1)是成立的。</p><p>對於歸納步驟，選擇<em>k</em> >1並假設<em>P</em>(1),…,<em>P</em>(<em>k</em>−1)都是正確的，對於Dijkstra算法添加到<em>X</em>的前<em>k</em>−1個頂點，<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)。設<em>w</em>*表示添加到<em>X</em>的第<em>k</em>個頂點，並用(<em>v</em>*,<em>w</em>*)表示在對應的那次迭代中（此時<em>v</em>*必然已經在<em>X</em>中）所選擇的邊。算法把<em>len</em>(<em>w</em>*)賦值為這條邊的Dijkstra得分，即<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p>。我們希望這個值與真正的最短路徑長度<em>dist</em>(<em>s</em>,<em>w</em>*)相同，但事實確實如此嗎？</p><p style=text-align:start>我們分兩個部分論證這個結論的正確性。首先，我們證明真正的長度<em>dist</em>(<em>s</em>,<em>w</em>*)只可能小於算法所推測的<em>len</em>(<em>w</em>*)，即<em>dist</em>(<em>s</em>,<em>w</em>*)≤<em>len</em>(<em>w</em>*)。由於當邊(<em>v</em>*,<em>w</em>*)被選中時，<em>v</em>*已經在<em>X</em>中，因此它是添加到<em>X</em>的前<em>k</em>−1個頂點之一。根據歸納假設，Dijkstra算法正確地計算了<em>v</em>*的最短路徑長度：<em>len</em>(<em>v</em>*)=<em>dist</em>(<em>s</em>,<em>v</em>*)。</p><p>具體地說，存在一條從<em>s</em>到<em>v</em>*的路徑<em>P</em>，它的長度正好是<em>len</em>(<em>v</em>*)。在<em>P</em>的末端添加邊(<em>v</em>*,<em>w</em>*)就產生了一條從<em>s</em>到<em>w</em>*的路徑<em>P</em>*，它的長度是<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p>=<em>len</em>(<em>w</em>*)（圖3.5）。<em>s</em>−<em>w</em>*路徑的最短路徑除了候選路徑<em>P</em>*之外不會再有其他路徑，因此<em>dist</em>(<em>s</em>,<em>w</em>*)不可能大於<em>len</em>(<em>w</em>*)。</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23acc03edce746f5844f1a4ad4d1e1ef><p class=pgc-img-caption></p></div><p>圖3.5　在<em>s</em>−<em>v</em>*最短路徑的末尾添加邊(<em>v</em>*, <em>w</em>*)，產生一條<em>s</em>到<em>w</em>*的最短路徑<em>P</em>*，其長度為<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p style=text-align:start>現在，我們討論反方向的不等式<em>dist</em>(<em>s</em>,<em>w</em>*)≥<em>len</em>(<em>w</em>*)（證明這一點之後就可以滿足<em>len</em>(<em>w</em>*)=<em>dist</em>(<em>s</em>,<em>w</em>*)）。換而言之，我們希望證明圖3.2中的路徑<em>P</em>*確實是<em>s</em>−<em>w</em>*的最短路徑，每條與之競爭的<em>s</em>−<em>w</em>*路徑的長度都不會小於<em>len</em>(<em>w</em>*)。</p><p style=text-align:start>我們隨意選擇一條<em>s</em>−<em>w</em>*的競爭路徑<em>P'</em>。我們對<em>P'</em>所知甚少。但是，我們知道它源於<em>s</em>，終於<em>w</em>*。在迭代之初，<em>s</em>屬於集合<em>X</em>但<em>w</em>*不屬於<em>X</em>。由於它是從<em>X</em>中開始並在<em>X</em>之外結束，因此路徑<em>P'</em>跨越了<em>X</em>和<em>V</em>−<em>X</em>的邊界1次（圖3.6）。設(<em>y</em>, <em>z</em>)表示跨越邊界的<em>P'</em>的第1條邊（<em>y</em>∈<em>X</em>且<em>z</em>∉<em>X</em>）。[7]</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1ffd39f88ec4392b010882e15a3969b><p class=pgc-img-caption></p></div><p style=text-align:center>圖3.6　每條<em>s</em>−<em>w</em>*路徑從<em>X</em>跨越到<em>V</em>−<em>X</em>至少1次</p><p>為了論證<em>P'</em>的長度不會小於<em>len</em>(<em>w</em>*)，我們獨立地考慮它的3個片段：<em>P'</em>從<em>s</em>到<em>y</em>的起始部分、邊(<em>y</em>, <em>z</em>)以及從<em>z</em>到<em>w</em>*的最終部分。起始部分不可能短於從<em>s</em>到<em>y</em>的最短路徑，因此它的長度至少是<em>dist</em>(<em>s</em>, <em>y</em>)。邊(<em>y</em>, <em>z</em>)的長度是</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c768d1c2bf304ce5bae22e05149a9081><p class=pgc-img-caption></p></div><p>。我們對路徑的最終部分並不十分了解，它掩藏在算法尚未觀察的頂點之中。但是，我們知道所有邊的長度都是非負的！也就是說，它的總長度至少是0，如圖3.7所示。</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30a89f0066434f46963ef88096ba846e><p class=pgc-img-caption></p></div><p style=text-align:center>圖3.7　總長度計算</p><p style=text-align:start>把這3個部分的長度下界相加，可以得出：</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/22c91794ffe14171b987b921243f3a0f><p class=pgc-img-caption></p></div><p style=text-align:right>（3.2）</p><p style=text-align:start>最後一個任務是把式（3.2）中的長度下界與指導算法決策的Dijkstra得分進行關聯。由於<em>y</em>∈<em>X</em>，因此它是前<em>k</em>−1個添加到<em>X</em>的頂點之一，歸納假設表明了該算法會正確地計算它的最終路徑長度：<em>dist</em>(<em>s</em>, <em>y</em>)=<em>len</em>(<em>y</em>)。因此，不等式（3.2）可以轉換為</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/321f71a58f6e4fe496b4e1799fdd5e62><p class=pgc-img-caption></p></div><p style=text-align:right>（3.3）</p><p style=text-align:start>式（3.3）的右邊正是邊(<em>y</em>, <em>z</em>)的Dijkstra得分。由於這個算法總是會選擇具有最低Dijkstra得分的邊，並且因為它在這次迭代中選擇了(<em>v</em>*,<em>w</em>*)而不是(<em>y</em>, <em>z</em>)，所以前者的Dijkstra得分更低：</p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/288078fbf7634c27a9f69b608ae3099f><p class=pgc-img-caption></p></div><p style=text-align:start>這樣，我們就完成了歸納步驟的第二部分，並得出結論：對於添加到集合<em>X</em>的每個頂點<em>v</em>，存在<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)。</p><p style=text-align:start>為了進行最終的驗證，考慮一個從來沒有被添加到<em>X</em>的頂點<em>v</em>。當這個算法結束時，<em>len</em>(<em>v</em>) = +∞並且沒有任何邊從<em>X</em>跨越到<em>V</em>−<em>X</em>。這意味著輸入圖中不存在從<em>s</em>到<em>v</em>的路徑，因為這樣的路徑肯定會在某一處跨越邊界。因此，<em>dist</em>(<em>s</em>,<em>v</em>)= +∞。我們可以得出結論，對於每個頂點<em>v</em>，如果<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)，算法就會終止，不管<em>v</em>是否被添加到<em>X</em>。至此，我們就完成了整個證明過程。</p><h1 class=pgc-h-arrow-right>3.4　算法的實現及其運行時間</h1><p style=text-align:start>Dijkstra的最短路徑算法讓我們回想起第2章所討論的線性時間的圖搜索算法。寬度優先和深度優先的搜索算法能夠以線性時間運行（定理2.1和定理2.4）的關鍵原因是它們在決定下一步應該探索哪個頂點時只需要耗費常數級的時間（從隊列或堆棧的頭部移除一個頂點）。需要警惕的是，Dijkstra算法的每次迭代必須在所有跨越邊界的邊中選擇具有最低Dijkstra得分的邊。我們仍然能在線性時間內實現該算法嗎？</p><blockquote><p><strong>小測驗3.2</strong></p><p>下面哪個運行時間最好地描述了應用於鄰接列表表示形式的圖的Dijkstra算法的簡單實現？與往常一樣，<em>n</em>和<em>m</em>分別表示輸入圖的頂點數和邊數。</p><p>（a）<em>O</em>(<em>m</em>+<em>n</em>)</p><p>（b）<em>O</em>(<em>m </em>log <em>n</em>)</p><p>（c）<em>O</em>(<em>n</em>2)</p><p>（d）<em>O</em>(<em>mn</em>)</p><p>（正確答案和詳細解釋如下。）</p></blockquote><p style=text-align:start><strong>正確答案：（d）。</strong>Dijkstra算法的簡單實現通過把一個布爾變量與每個頂點相關聯，記錄哪些頂點在<em>X</em>中。在每次迭代中，它對所有的邊執行一次窮盡式的搜索，計算每條尾頂點在<em>X</em>中且頭頂點在<em>X</em>之外的邊的Dijkstra得分（每條邊需要常數級的時間），並返回具有最低得分值的那條跨越邊界的邊（或確認不存在跨越邊界的邊）。在經過最多<em>n </em>−1次迭代之後，Dijkstra算法已經把所有需要添加的新頂點添加到集合<em>X</em>中。由於迭代的數量是<em>O</em>(<em>n</em>)並且每次迭代需要<em>O</em>(<em>m</em>)的時間，因此整體運行時間是<em>O</em>(<em>mn</em>)。</p><p style=text-align:start><strong>命題3.1（Dijkstra的運行時間（簡單實現））　</strong>對於有向圖<em>G</em>=(<em>V</em>, <em>E</em>)、起始頂點<em>s</em>並且每條邊的長度均為非負值，Dijkstra算法的簡單實現的運行時間為<em>O</em>(<em>mn</em>)，其中<em>m</em>=|<em>E</em>|、<em>n</em>=|<em>V </em>|。</p><p style=text-align:start>這種簡單實現的運行時間還不錯，但不夠優秀。如果頂點的數量只有幾百個或者一兩千個，它的效率還算不錯。但是，對於那些極為龐大的圖，這種實現的效率就不能盡如人意。我們能不能做得更好？算法設計的至高榮譽就是實現線性時間的算法（或近似於它），我們希望單源最短路徑問題也能夠實現這樣的目標。這樣的算法在一臺家用筆記本計算機上就可以處理具有數百萬個頂點的圖。</p><p style=text-align:start>我們並不需要一種更好的算法實現該問題近似線性時間的解決方案，而是只需要Dijkstra算法的一種更好實現。在寬度優先和深度優先的搜索的線性時間實現中，數據結構（隊列和堆棧）扮演了一個關鍵的角色。類似地，Dijkstra算法也可以在正確的數據結構的幫助下，在它的主循環中實現反覆的最小值計算，從而實現近似線性的運行時間。這種數據結構稱為堆，它是第4章的主題。</p><h1 class=pgc-h-arrow-right>3.5　本章要點</h1><ul><li>在單源最短路徑問題中，問題的輸入由一個圖、一個起始頂點和每條邊的長度所組成。它的目標是計算從起始頂點到其他每個頂點的最短路徑的長度。</li><li>Dijkstra算法逐個處理頂點，總是在尚未處理的頂點中選擇看上去最靠近起始頂點的那個頂點。</li><li>通過數學歸納法可以證明Dijkstra算法能夠正確地解決當輸入圖的邊長都為非負值時的單源最短路徑問題。</li><li>當輸入圖中有些邊的長度為負值時，Dijkstra算法就無法正確地解決單源最短路徑問題。</li><li>Dijkstra算法的簡單實現的運行時間是<em>O</em>(<em>mn</em>)，其中<em>m</em>和<em>n</em>分別表示輸入圖的邊數和頂點數。</li></ul><p><strong>本文摘自《算法詳解 卷2 圖算法和數據結構(異步圖書出品)》</strong></p><div class=pgc-img><img alt=計算機科學史上偉大的成就之一：Dijkstra最短路徑算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8791714a92cb4ed3bebf16a9882cbbbe><p class=pgc-img-caption></p></div><p>本書將幫助讀者熟悉幾種不同的數據結構，它們用於維護不斷變化的具有鍵的對象集合。我們的基本目標是培養一種能力，也就是能夠判斷哪種數據結構比較適合自己的應用。選讀的高級章節對如何從頭實現這些數據結構提供了一些指導方針。</p><p style=text-align:start>我們首先討論堆，它可以快速識別它所存儲對象中具有最小鍵值的對象，適用於排序、實現優先隊列以及以線性時間實現Dijkstra算法。搜索樹可以維護它所存儲對象的整體鍵順序，並支持更豐富的數組操作。散列表對超級快速的查找方式進行了優化，在現代程序中具有極其廣泛的應用。我們還將討論布隆過濾器，它是散列表的“近親”。布隆過濾器的空間需求較散列表更低，但它偶爾會出現錯誤。</p><p style=text-align:start>關於本書內容的更詳細介紹，可以閱讀每章的“本章要點”，它對每一章的內容，特別是那些重要的概念進行了總結。書中帶星號的章節是難度較高的章節。時間較為緊張的讀者在第一遍閱讀時可以跳過這些章節，這並不會影響本書閱讀的連續性。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>計算機</a></li><li><a>科學史</a></li><li><a>上偉大</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html alt=計算機中數字、文字、圖像、聲音和視頻的表示與編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8d1d3ec88f2c4a158c7efe55b21d6ed7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html title=計算機中數字、文字、圖像、聲音和視頻的表示與編碼>計算機中數字、文字、圖像、聲音和視頻的表示與編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8582e44e.html alt="計算機實驗室之樹莓派：課程 7 屏幕02" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa8f776ea6c84f08b0fbfaad451371e0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8582e44e.html title="計算機實驗室之樹莓派：課程 7 屏幕02">計算機實驗室之樹莓派：課程 7 屏幕02</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html alt="“頂點”計算機面世 登頂超級計算機榜首" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15287045778959b8cdf2283 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html title="“頂點”計算機面世 登頂超級計算機榜首">“頂點”計算機面世 登頂超級計算機榜首</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html alt=美媒揭祕最新世界最快超級計算機“頂點” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html title=美媒揭祕最新世界最快超級計算機“頂點”>美媒揭祕最新世界最快超級計算機“頂點”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html alt=計算機求解微分方程的六大數值計算方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5b33cbb521894b5aa7f4cf8e1c795cf2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html title=計算機求解微分方程的六大數值計算方法>計算機求解微分方程的六大數值計算方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html alt=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a03090d0e5804e88b4003fdcdfa7a301 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html title=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？>你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html alt=第一臺通用數字電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html title=第一臺通用數字電子計算機>第一臺通用數字電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html alt=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f30831efce324fd8ad5055d5c3312dfe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html title=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四>第一臺電子計算機的發明者諾依曼，中外發明家故事之十四</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html alt=計算機發展全歷程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/68bbbb84608c4db28b2cf2687596239a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html title=計算機發展全歷程>計算機發展全歷程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbc9d4e3.html alt=電子計算機的類別有些什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0a5e8724-b70f-4cdf-bebb-1091bfcd66d7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbc9d4e3.html title=電子計算機的類別有些什麼？>電子計算機的類別有些什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d2a4dab.html alt=五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/78bc8448e150430b99df693674b71771 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d2a4dab.html title=五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大>五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cf191e1.html alt=古代也有黑科技：周朝的智能機器人，元朝的電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b254baabbed34cccbcc700e6fb6fcbf3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cf191e1.html title=古代也有黑科技：周朝的智能機器人，元朝的電子計算機>古代也有黑科技：周朝的智能機器人，元朝的電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2346757d.html alt="揭祕新中國首臺電子計算機：佔地40平 每秒運算30次" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a0d9b66e59d04cb0a5e0c52df3a72993 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2346757d.html title="揭祕新中國首臺電子計算機：佔地40平 每秒運算30次">揭祕新中國首臺電子計算機：佔地40平 每秒運算30次</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30e4f36e.html alt=核武器研製並非全靠算盤，電子計算機擔當主力，運算能力你想不到 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a0396a228aea47449d977817792de281 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30e4f36e.html title=核武器研製並非全靠算盤，電子計算機擔當主力，運算能力你想不到>核武器研製並非全靠算盤，電子計算機擔當主力，運算能力你想不到</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62052e23.html alt=科技知識分享：現代電子計算機的發展史，分為幾個階段？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/11aea52a116e4c499e16ba32d2c36725 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62052e23.html title=科技知識分享：現代電子計算機的發展史，分為幾個階段？>科技知識分享：現代電子計算機的發展史，分為幾個階段？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>