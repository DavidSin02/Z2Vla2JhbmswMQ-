<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試必備：HashMap源碼解析 | 极客快訊</title><meta property="og:title" content="面試必備：HashMap源碼解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c538446f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="面試必備：HashMap源碼解析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c538446f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試必備：HashMap源碼解析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><pre><code>認真寫文章，用心做分享。公眾號：Java耕耘者</code></pre><p>整個HashMap示意圖：</p><div class=pgc-img><img alt=面試必備：HashMap源碼解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e><p class=pgc-img-caption></p></div><p>HashMap的源碼中，充斥個各種位運算代替常規運算的地方，以提升效率：</p><ul><li>與運算替代模運算。用 hash & (table.length-1) 替代 hash % (table.length)</li><li>用if ((e.hash & oldCap) == 0)判斷擴容後，節點e處於低區還是高區。</li></ul><h2 class=pgc-h-arrow-right>3 鏈表節點Node</h2><p>在開始之前，我們先看一下掛載在哈希表上的元素，鏈表的結構：</p><pre><code>    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;//哈希值        final K key;//key        V value;//value        Node&lt;K,V&gt; next;//鏈表後置節點        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        }        public final K getKey()        { return key; }        public final V getValue()      { return value; }        public final String toString() { return key + "=" + value; }        //每一個節點的hash值，是將key的hashCode 和 value的hashCode 亦或得到的。        public final int hashCode() {            return Objects.hashCode(key) ^ Objects.hashCode(value);        }        //設置新的value 同時返回舊value        public final V setValue(V newValue) {            V oldValue = value;            value = newValue;            return oldValue;        }        public final boolean equals(Object o) {            if (o == this)                return true;            if (o instanceof Map.Entry) {                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                if (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                    return true;            }            return false;        }    }</code></pre><p><strong>由此可知，這是一個單鏈表~。<br>每一個節點的hash值，是將key的hashCode 和 value的hashCode 亦或得到的。</strong></p><h2 class=pgc-h-arrow-right>4 構造函數</h2><pre><code>    //最大容量 2的30次方    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    //默認的加載因子    static final float DEFAULT_LOAD_FACTOR = 0.75f;    //哈希桶，存放鏈表。 長度是2的N次方，或者初始化時為0.    transient Node&lt;K,V&gt;[] table;    //加載因子，用於計算哈希表元素數量的閾值。  threshold = 哈希桶.length * loadFactor;    final float loadFactor;    //哈希表內元素數量的閾值，當哈希表內元素數量超過閾值時，會發生擴容resize()。    int threshold;    public HashMap() {        //默認構造函數，賦值加載因子為默認的0.75f        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted    }    public HashMap(int initialCapacity) {        //指定初始化容量的構造函數        this(initialCapacity, DEFAULT_LOAD_FACTOR);    }    //同時指定初始化容量 以及 加載因子， 用的很少，一般不會修改loadFactor    public HashMap(int initialCapacity, float loadFactor) {        //邊界處理        if (initialCapacity &lt; 0)            throw new IllegalArgumentException("Illegal initial capacity: " +                                               initialCapacity);        //初始容量最大不能超過2的30次方        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        //顯然加載因子不能為負數        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException("Illegal load factor: " +                                               loadFactor);        this.loadFactor = loadFactor;        //設置閾值為  》=初始化容量的 2的n次方的值        this.threshold = tableSizeFor(initialCapacity);    }    //新建一個哈希表，同時將另一個map m 裡的所有元素加入表中    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {        this.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, false);    }</code></pre><pre><code>    //根據期望容量cap，返回2的n次方形式的 哈希桶的實際容量 length。 返回值一般會&gt;=cap     static final int tableSizeFor(int cap) {    //經過下面的 或 和位移 運算， n最終各位都是1。        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        //判斷n是否越界，返回 2的n次方作為 table（哈希桶）的閾值        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }</code></pre><pre><code>    //將另一個Map的所有元素加入表中，參數evict初始化時為false，其他情況為true    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {        //拿到m的元素數量        int s = m.size();        //如果數量大於0        if (s &gt; 0) {            //如果當前表是空的            if (table == null) { // pre-size                //根據m的元素數量和當前表的加載因子，計算出閾值                float ft = ((float)s / loadFactor) + 1.0F;                //修正閾值的邊界 不能超過MAXIMUM_CAPACITY                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);                //如果新的閾值大於當前閾值                if (t &gt; threshold)                    //返回一個 》=新的閾值的 滿足2的n次方的閾值                    threshold = tableSizeFor(t);            }            //如果當前元素表不是空的，但是 m的元素數量大於閾值，說明一定要擴容。            else if (s &gt; threshold)                resize();            //遍歷 m 依次將元素加入當前表中。            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false, evict);            }        }    }</code></pre><div class=pgc-img><img alt=面試必備：HashMap源碼解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/071243af-fdce-413e-bf2e-c572a9263352><p class=pgc-img-caption></p></div><pre><code>    //將另一個Map的所有元素加入表中，參數evict初始化時為false，其他情況為true    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {        //拿到m的元素數量        int s = m.size();        //如果數量大於0        if (s &gt; 0) {            //如果當前表是空的            if (table == null) { // pre-size                //根據m的元素數量和當前表的加載因子，計算出閾值                float ft = ((float)s / loadFactor) + 1.0F;                //修正閾值的邊界 不能超過MAXIMUM_CAPACITY                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);                //如果新的閾值大於當前閾值                if (t &gt; threshold)                    //返回一個 》=新的閾值的 滿足2的n次方的閾值                    threshold = tableSizeFor(t);            }            //如果當前元素表不是空的，但是 m的元素數量大於閾值，說明一定要擴容。            else if (s &gt; threshold)                resize();            //遍歷 m 依次將元素加入當前表中。            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false, evict);            }        }    }</code></pre><p>先看一下擴容函數： 這是一個重點！重點！重點！<br><strong>初始化或加倍哈希桶大小。如果是當前哈希桶是null,分配符合當前閾值的初始容量目標。<br>否則，因為我們擴容成以前的兩倍。<br>在擴容時，要注意區分以前在哈希桶相同index的節點，現在是在以前的index裡，還是index+oldlength 裡</strong></p><pre><code>final Node&lt;K,V&gt;[] resize() {        //oldTab 為當前表的哈希桶        Node&lt;K,V&gt;[] oldTab = table;        //當前哈希桶的容量 length        int oldCap = (oldTab == null) ? 0 : oldTab.length;        //當前的閾值        int oldThr = threshold;        //初始化新的容量和閾值為0        int newCap, newThr = 0;        //如果當前容量大於0        if (oldCap &gt; 0) {            //如果當前容量已經到達上限            if (oldCap &gt;= MAXIMUM_CAPACITY) {                //則設置閾值是2的31次方-1                threshold = Integer.MAX_VALUE;                //同時返回當前的哈希桶，不再擴容                return oldTab;            }//否則新的容量為舊的容量的兩倍。             else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//如果舊的容量大於等於默認初始容量16                //那麼新的閾值也等於舊的閾值的兩倍                newThr = oldThr &lt;&lt; 1; // double threshold        }//如果當前表是空的，但是有閾值。代表是初始化時指定了容量、閾值的情況        else if (oldThr &gt; 0) // initial capacity was placed in threshold            newCap = oldThr;//那麼新表的容量就等於舊的閾值        else {}//如果當前表是空的，而且也沒有閾值。代表是初始化時沒有任何容量/閾值參數的情況               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;//此時新表的容量為默認的容量 16            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//新的閾值為默認容量16 * 默認加載因子0.75f = 12        }        if (newThr == 0) {//如果新的閾值是0，對應的是  當前表是空的，但是有閾值的情況            float ft = (float)newCap * loadFactor;//根據新表容量 和 加載因子 求出新的閾值            //進行越界修復            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        //更新閾值         threshold = newThr;        @SuppressWarnings({"rawtypes","unchecked"})        //根據新的容量 構建新的哈希桶            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        //更新哈希桶引用        table = newTab;        //如果以前的哈希桶中有元素        //下面開始將當前哈希桶中的所有節點轉移到新的哈希桶中        if (oldTab != null) {            //遍歷老的哈希桶            for (int j = 0; j &lt; oldCap; ++j) {                //取出當前的節點 e                Node&lt;K,V&gt; e;                //如果當前桶中有元素,則將鏈表賦值給e                if ((e = oldTab[j]) != null) {                    //將原哈希桶置空以便GC                    oldTab[j] = null;                    //如果當前鏈表中就一個元素，（沒有發生哈希碰撞）                    if (e.next == null)                        //直接將這個元素放置在新的哈希桶裡。                        //注意這裡取下標 是用 哈希值 與 桶的長度-1 。 由於桶的長度是2的n次方，這麼做其實是等於 一個模運算。但是效率更高                        newTab[e.hash &amp; (newCap - 1)] = e;                        //如果發生過哈希碰撞 ,而且是節點數超過8個，轉化成了紅黑樹（暫且不談 避免過於複雜， 後續專門研究一下紅黑樹）                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    //如果發生過哈希碰撞，節點數小於8個。則要根據鏈表上每個節點的哈希值，依次放入新哈希桶對應下標位置。                    else { // preserve order                        //因為擴容是容量翻倍，所以原鏈表上的每個節點，現在可能存放在原來的下標，即low位， 或者擴容後的下標，即high位。 high位=  low位+原哈希桶容量                        //低位鏈表的頭結點、尾節點                        Node&lt;K,V&gt; loHead = null, loTail = null;                        //高位鏈表的頭節點、尾節點                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;//臨時節點 存放e的下一個節點                        do {                            next = e.next;                            //這裡又是一個利用位運算 代替常規運算的高效點： 利用哈希值 與 舊的容量，可以得到哈希值去模後，是大於等於oldCap還是小於oldCap，等於0代表小於oldCap，應該存放在低位，否則存放在高位                            if ((e.hash &amp; oldCap) == 0) {                                //給頭尾節點指針賦值                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }//高位也是相同的邏輯                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }//循環直到鏈表結束                        } while ((e = next) != null);                        //將低位鏈表存放在原index處，                        if (loTail != null) {                            loTail.next = null;                            newTab[j] = loHead;                        }                        //將高位鏈表存放在新index處                        if (hiTail != null) {                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }</code></pre><p>再看一下 往哈希表裡插入一個節點的putVal函數,如果參數onlyIfAbsent是true，那麼不會覆蓋相同key的值value。如果evict是false。那麼表示是在初始化時調用的</p><pre><code>    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        //tab存放 當前的哈希桶， p用作臨時鏈表節點          Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        //如果當前哈希表是空的，代表是初始化        if ((tab = table) == null || (n = tab.length) == 0)            //那麼直接去擴容哈希表，並且將擴容後的哈希桶長度賦值給n            n = (tab = resize()).length;        //如果當前index的節點是空的，表示沒有發生哈希碰撞。 直接構建一個新節點Node，掛載在index處即可。        //這裡再囉嗦一下，index 是利用 哈希值 &amp; 哈希桶的長度-1，替代模運算        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else {//否則 發生了哈希衝突。            //e            Node&lt;K,V&gt; e; K k;            //如果哈希值相等，key也相等，則是覆蓋value操作            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;//將當前節點引用賦值給e            else if (p instanceof TreeNode)//紅黑樹暫且不談                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else {//不是覆蓋操作，則插入一個普通鏈表節點                //遍歷鏈表                for (int binCount = 0; ; ++binCount) {                    if ((e = p.next) == null) {//遍歷到尾部，追加新節點到尾部                        p.next = newNode(hash, key, value, null);                        //如果追加節點後，鏈表數量》=8，則轉化為紅黑樹                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    }                    //如果找到了要覆蓋的節點                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                }            }            //如果e不是null，說明有需要覆蓋的節點，            if (e != null) { // existing mapping for key                //則覆蓋節點值，並返回原oldValue                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                //這是一個空實現的函數，用作LinkedHashMap重寫使用。                afterNodeAccess(e);                return oldValue;            }        }        //如果執行到了這裡，說明插入了一個新的節點，所以會修改modCount，以及返回null。        //修改modCount        ++modCount;        //更新size，並判斷是否需要擴容。        if (++size &gt; threshold)            resize();        //這是一個空實現的函數，用作LinkedHashMap重寫使用。        afterNodeInsertion(evict);        return null;    }</code></pre><p>newNode如下：構建一個鏈表節點</p><pre><code>    // Create a regular (non-tree) node    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {        return new Node&lt;&gt;(hash, key, value, next);    }</code></pre><pre><code>    // Callbacks to allow LinkedHashMap post-actions    void afterNodeAccess(Node&lt;K,V&gt; p) { }    void afterNodeInsertion(boolean evict) { }</code></pre><p>小結：</p><ul><li>運算儘量都用<strong>位運算</strong>代替<strong>，更高效</strong>。</li><li>對於<strong>擴容</strong>導致需要新建數組存放更多元素時，除了要將老數組中的元素遷移過來，也記得將<strong>老數組中的引用置null</strong>，以便<strong>GC</strong></li><li>取下標 是用 <strong>哈希值 與運算 （桶的長度-1）</strong> i = (n - 1) & hash。 由於桶的長度是2的n次方，這麼做其實是等於 一個<strong>模運算</strong>。但是<strong>效率更高</strong></li><li>擴容時，如果發生過哈希碰撞，節點數小於8個。則要根據鏈表上每個節點的哈希值，依次放入新哈希桶對應下標位置。</li><li>因為擴容是容量翻倍，所以原鏈表上的每個節點，現在可能存放在原來的下標，即low位， 或者擴容後的下標，即high位。 high位= low位+原哈希桶容量</li><li>利用<strong>哈希值 與運算 舊的容量</strong> ，if ((e.hash & oldCap) == 0),可以得到哈希值去模後，是大於等於oldCap還是小於oldCap，等於0代表小於oldCap，<strong>應該存放在低位，否則存放在高位</strong>。這裡又是一個利用位運算 代替常規運算的高效點</li><li>如果追加節點後，鏈表數量》=8，則轉化為紅黑樹</li><li>插入節點操作時，有一些空實現的函數，用作LinkedHashMap重寫使用。</li></ul><div class=pgc-img><img alt=面試必備：HashMap源碼解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/e4da6289-875b-4f33-92d6-c5449e91eadb><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>5 增、改</h2><h3 class=pgc-h-arrow-right>1往表中插入或覆蓋一個key-value</h3><pre><code>    public V put(K key, V value) {        //先根據key，取得hash值。 再調用上一節的方法插入節點        return putVal(hash(key), key, value, false, true);    }</code></pre><p>這個根據key取hash值的函數也要關注一下，它稱之為“擾動函數”，關於這個函數的用處 開頭已經總結過了：</p><pre><code>    static final int hash(Object key) {        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }</code></pre><p>而key的hash值，並不僅僅只是key對象的hashCode()方法的返回值，還會經過<strong>擾動函數</strong>的擾動，以使hash值更加均衡。<br>因為hashCode()是int類型，取值範圍是40多億，只要哈希函數映射的比較均勻鬆散，碰撞機率是很小的。<br>但就算原本的hashCode()取得很好，每個key的hashCode()不同，但是由於HashMap的哈希桶的長度遠比hash取值範圍小，默認是16，所以當對hash值以桶的長度取餘，以找到存放該key的桶的下標時，由於取餘是通過與操作完成的，會忽略hash值的高位。因此只有hashCode()的低位參加運算，發生不同的hash值，但是得到的index相同的情況的機率會大大增加，這種情況稱之為<strong>hash碰撞。</strong> 即，碰撞率會增大。</p><p><strong>擾動函數</strong>就是為了解決hash碰撞的。它會綜合hash值高位和低位的特徵，並存放在低位，因此在與運算時，相當於高低位一起參與了運算，以減少hash碰撞的概率。（在JDK8之前，擾動函數會擾動四次，JDK8簡化了這個操作）</p><h3 class=pgc-h-arrow-right>2往表中批量增加數據</h3><pre><code>    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {        //這個函數上一節也已經分析過。//將另一個Map的所有元素加入表中，參數evict初始化時為false，其他情況為true        putMapEntries(m, true);    }</code></pre><h3 class=pgc-h-arrow-right>3 只會往表中插入 key-value, 若key對應的value之前存在，不會覆蓋。（jdk8增加的方法）</h3><pre><code>    @Override    public V putIfAbsent(K key, V value) {        return putVal(hash(key), key, value, true, true);    }</code></pre><h2 class=pgc-h-arrow-right>6 刪</h2><h3 class=pgc-h-arrow-right>以key為條件刪除</h3><p>如果key對應的value存在，則刪除這個鍵值對。 並返回value。如果不存在 返回null。</p><pre><code>    public V remove(Object key) {        Node&lt;K,V&gt; e;        return (e = removeNode(hash(key), key, null, false, true)) == null ?            null : e.value;    }</code></pre><p>//從哈希表中刪除某個節點， 如果參數matchValue是true，則必須key 、value都相等才刪除。<br>//如果movable參數是false，在刪除節點時，不移動其他節點</p><pre><code>    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                               boolean matchValue, boolean movable) {        // p 是待刪除節點的前置節點        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;        //如果哈希表不為空，則根據hash值算出的index下 有節點的話。        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (p = tab[index = (n - 1) &amp; hash]) != null) {            //node是待刪除節點            Node&lt;K,V&gt; node = null, e; K k; V v;            //如果鏈表頭的就是需要刪除的節點            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                node = p;//將待刪除節點引用賦給node            else if ((e = p.next) != null) {//否則循環遍歷 找到待刪除節點，賦值給node                if (p instanceof TreeNode)                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);                else {                    do {                        if (e.hash == hash &amp;&amp;                            ((k = e.key) == key ||                             (key != null &amp;&amp; key.equals(k)))) {                            node = e;                            break;                        }                        p = e;                    } while ((e = e.next) != null);                }            }            //如果有待刪除節點node，  且 matchValue為false，或者值也相等            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                                 (value != null &amp;&amp; value.equals(v)))) {                if (node instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);                else if (node == p)//如果node ==  p，說明是鏈表頭是待刪除節點                    tab[index] = node.next;                else//否則待刪除節點在表中間                    p.next = node.next;                ++modCount;//修改modCount                --size;//修改size                afterNodeRemoval(node);//LinkedHashMap回調函數                return node;            }        }        return null;    }</code></pre><pre><code>    void afterNodeRemoval(Node&lt;K,V&gt; p) { }複製代碼</code></pre><h3 class=pgc-h-arrow-right>以key value 為條件刪除</h3><pre><code>    @Override    public boolean remove(Object key, Object value) {        //這裡傳入了value 同時matchValue為true        return removeNode(hash(key), key, value, true, true) != null;    }</code></pre><h2 class=pgc-h-arrow-right>7 查</h2><h3 class=pgc-h-arrow-right>以key為條件，找到返回value。沒找到返回null</h3><pre><code>    public V get(Object key) {        Node&lt;K,V&gt; e;        //傳入擾動後的哈希值 和 key 找到目標節點Node        return (e = getNode(hash(key), key)) == null ? null : e.value;    }</code></pre><pre><code>    //傳入擾動後的哈希值 和 key 找到目標節點Node    final Node&lt;K,V&gt; getNode(int hash, Object key) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;        //查找過程和刪除基本差不多， 找到返回節點，否則返回null        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (first = tab[(n - 1) &amp; hash]) != null) {            if (first.hash == hash &amp;&amp; // always check first node                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))                return first;            if ((e = first.next) != null) {                if (first instanceof TreeNode)                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);                do {                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        return e;                } while ((e = e.next) != null);            }        }        return null;    }</code></pre><h3 class=pgc-h-arrow-right>判斷是否包含該key</h3><pre><code>    public boolean containsKey(Object key) {        return getNode(hash(key), key) != null;    }</code></pre><h3 class=pgc-h-arrow-right>判斷是否包含value</h3><pre><code>    public boolean containsValue(Object value) {        Node&lt;K,V&gt;[] tab; V v;        //遍歷哈希桶上的每一個鏈表        if ((tab = table) != null &amp;&amp; size &gt; 0) {            for (int i = 0; i &lt; tab.length; ++i) {                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {                    //如果找到value一致的返回true                    if ((v = e.value) == value ||                        (value != null &amp;&amp; value.equals(v)))                        return true;                }            }        }        return false;    }</code></pre><h3 class=pgc-h-arrow-right>java8新增，帶默認值的get方法</h3><p>以key為條件，找到了返回value。否則返回defaultValue</p><pre><code>    @Override    public V getOrDefault(Object key, V defaultValue) {        Node&lt;K,V&gt; e;        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;    }</code></pre><h3 class=pgc-h-arrow-right>遍歷</h3><pre><code>    //緩存 entrySet    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;     */    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;    }</code></pre><pre><code>    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {        public final int size()                 { return size; }        public final void clear()               { HashMap.this.clear(); }        //一般我們用到EntrySet，都是為了獲取iterator        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {            return new EntryIterator();        }        //最終還是調用getNode方法        public final boolean contains(Object o) {            if (!(o instanceof Map.Entry))                return false;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;            Object key = e.getKey();            Node&lt;K,V&gt; candidate = getNode(hash(key), key);            return candidate != null &amp;&amp; candidate.equals(e);        }        //最終還是調用removeNode方法        public final boolean remove(Object o) {            if (o instanceof Map.Entry) {                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;                Object key = e.getKey();                Object value = e.getValue();                return removeNode(hash(key), key, value, true, true) != null;            }            return false;        }        //。。。    }</code></pre><p>//EntryIterator的實現：</p><pre><code>    final class EntryIterator extends HashIterator        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {        public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }    }</code></pre><pre><code>    abstract class HashIterator {        Node&lt;K,V&gt; next;        // next entry to return        Node&lt;K,V&gt; current;     // current entry        int expectedModCount;  // for fast-fail        int index;             // current slot        HashIterator() {            //因為hashmap也是線程不安全的，所以要保存modCount。用於fail-fast策略            expectedModCount = modCount;            Node&lt;K,V&gt;[] t = table;            current = next = null;            index = 0;            //next 初始時，指向 哈希桶上第一個不為null的鏈表頭            if (t != null &amp;&amp; size &gt; 0) { // advance to first entry                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);            }        }        public final boolean hasNext() {            return next != null;        }        //由這個方法可以看出，遍歷HashMap時，順序是按照哈希桶從低到高，鏈表從前往後，依次遍歷的。屬於無序集合。        final Node&lt;K,V&gt; nextNode() {            Node&lt;K,V&gt;[] t;            Node&lt;K,V&gt; e = next;            //fail-fast策略            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            if (e == null)                throw new NoSuchElementException();            //依次取鏈表下一個節點，            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {                //如果當前鏈表節點遍歷完了，則取哈希桶下一個不為null的鏈表頭                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);            }            return e;        }        public final void remove() {            Node&lt;K,V&gt; p = current;            if (p == null)                throw new IllegalStateException();            ////fail-fast策略            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            current = null;            K key = p.key;            //最終還是利用removeNode 刪除節點            removeNode(hash(key), key, null, false, false);            expectedModCount = modCount;        }    }</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>必備</a></li><li><a>HashMap</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/473f3fde.html alt=面試必備--Linux文件系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3a3f553730564e71a9aef13c31d7b2b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/473f3fde.html title=面試必備--Linux文件系統>面試必備--Linux文件系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/61ae03dd.html alt=面試必備：支持向量機（SVM）重要知識點總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/61ae03dd.html title=面試必備：支持向量機（SVM）重要知識點總結>面試必備：支持向量機（SVM）重要知識點總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html alt=HashMap面試專題：常問六題深入解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/75bf5de0-37fd-469c-b6b3-8067c551568a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html title=HashMap面試專題：常問六題深入解析>HashMap面試專題：常問六題深入解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html alt=一個HashMap能跟面試官扯上半個小時 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3c09bf1ad1b54adaab3db4be30c10c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html title=一個HashMap能跟面試官扯上半個小時>一個HashMap能跟面試官扯上半個小時</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html alt=HashMap？面試？我是誰？我在哪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8aa437a2fb3143e7a345a46a36d2c81e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html title=HashMap？面試？我是誰？我在哪>HashMap？面試？我是誰？我在哪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html alt=「最完整系列」JAVA-容器篇-HashMap面試最詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/71d7c60ccb9e4e57acda3ded903a1fd5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html title=「最完整系列」JAVA-容器篇-HashMap面試最詳解>「最完整系列」JAVA-容器篇-HashMap面試最詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html alt=面試必問的HashMap，你真的瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/19a8d23522b640b4a8d8a927514eca33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html title=面試必問的HashMap，你真的瞭解嗎？>面試必問的HashMap，你真的瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ff690c4.html alt=面試必備-分佈式事務方案-兩階段提交 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6e7df1e7193f4f8a8b2a4be269f569fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ff690c4.html title=面試必備-分佈式事務方案-兩階段提交>面試必備-分佈式事務方案-兩階段提交</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0ff6432.html alt=鋼結構必備知識38問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0ff6432.html title=鋼結構必備知識38問>鋼結構必備知識38問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb258a5a.html alt=鋼結構必備知識38問，你的晉級之路！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1535975955779bcac330762 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb258a5a.html title=鋼結構必備知識38問，你的晉級之路！>鋼結構必備知識38問，你的晉級之路！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4e33540.html alt="收藏 | 這些航測必備的知識點你瞭解嗎？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4e33540.html title="收藏 | 這些航測必備的知識點你瞭解嗎？">收藏 | 這些航測必備的知識點你瞭解嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>