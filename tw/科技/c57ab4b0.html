<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>第五章:函數 | 极客快訊</title><meta property="og:title" content="第五章:函數 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/2466a268-feac-46a2-9bfa-ea0a5723a32f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c57ab4b0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c57ab4b0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c57ab4b0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c57ab4b0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c57ab4b0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c57ab4b0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c57ab4b0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c57ab4b0.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="第五章:函數"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c57ab4b0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>第五章:函數</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>&lt;div align="left">&lt;span style="color:#cc0000;">&lt;strong>概述&lt;/strong>&lt;/span>&lt;br />&lt;br />　　在第一章中已經介紹過，Ｃ源程序是由函數組成的。 雖然在前面各章的程序中都只有一個主函數main()， 但實用程序往往由多個函數組成。函數是Ｃ源程序的基本模塊， 通過對函數模塊的調用實現特定的功能。Ｃ語言中的函數相當於其它高級語言的子程序。 Ｃ語言不僅提供了極為豐富的庫函數(如Turbo C，MS C 都提供了三百多個庫函數)，還允許用戶建立自己定義的函數。用戶可把自己的算法編成一個個相對獨立的函數模塊，然後用調用的方法來使用函數。&lt;br />&lt;br />　　可以說Ｃ程序的全部工作都是由各式各樣的函數完成的， 所以也把Ｃ語言稱為函數式語言。 由於採用了函數模塊式的結構， Ｃ語言易於實現結構化程序設計。使程序的層次結構清晰，便於程序的編寫、閱讀、調試。&lt;br />&lt;br />　　在Ｃ語言中可從不同的角度對函數分類。&lt;br />&lt;br />1. 從函數定義的角度看，函數可分為庫函數和用戶定義函數兩種。&lt;br />&lt;br />(1)庫函數&lt;br />　　由Ｃ系統提供，用戶無須定義， 也不必在程序中作類型說明，只需在程序前包含有該函數原型的頭文件即可在程序中直接調用。在前面各章的例題中反覆用到printf 、 scanf 、 getchar 、putchar、gets、puts、strcat等函數均屬此類。&lt;br />&lt;br />(2)用戶定義函數&lt;br />　　由用戶按需要寫的函數。對於用戶自定義函數， 不僅要在程序中定義函數本身， 而且在主調函數模塊中還必須對該被調函數進行類型說明，然後才能使用。&lt;br />&lt;br />2. Ｃ語言的函數兼有其它語言中的函數和過程兩種功能，從這個角度看，又可把函數分為有返回值函數和無返回值函數兩種。&lt;br />&lt;br />(1)有返回值函數&lt;br />　　此類函數被調用執行完後將向調用者返回一個執行結果， 稱為函數返回值。如數學函數即屬於此類函數。 由用戶定義的這種要返回函數值的函數，必須在函數定義和函數說明中明確返回值的類型。&lt;br />&lt;br />(2)無返回值函數&lt;br />　　此類函數用於完成某項特定的處理任務， 執行完成後不向調用者返回函數值。這類函數類似於其它語言的過程。 由於函數無須返回值，用戶在定義此類函數時可指定它的返回為“空類型”， 空類型的說明符為“void”。&lt;br />&lt;br />3. 從主調函數和被調函數之間數據傳送的角度看又可分為無參函數和有參函數兩種。&lt;br />&lt;br />(1)無參函數&lt;br />　　函數定義、函數說明及函數調用中均不帶參數。 主調函數和被調函數之間不進行參數傳送。 此類函數通常用來完成一組指定的功能，可以返回或不返回函數值。&lt;br />&lt;br />(2)有參函數&lt;br />　　也稱為帶參函數。在函數定義及函數說明時都有參數， 稱為形式參數(簡稱為形參)。在函數調用時也必須給出參數， 稱為實際參數(簡稱為實參)。 進行函數調用時，主調函數將把實參的值傳送給形參，供被調函數使用。&lt;br />&lt;br />4. Ｃ語言提供了極為豐富的庫函數， 這些庫函數又可從功能角度作以下分類。&lt;br />(1)字符類型分類函數&lt;br />　　用於對字符按ASCII碼分類：字母，數字，控制字符，分隔符，大小寫字母等。&lt;br />(2)轉換函數&lt;br />　　用於字符或字符串的轉換；在字符量和各類數字量 (整型， 實型等)之間進行轉換；在大、小寫之間進行轉換。&lt;br />(3)目錄路徑函數&lt;br />　　用於文件目錄和路徑操作。&lt;br />(4)診斷函數&lt;br />　　用於內部錯誤檢測。&lt;br />(5)圖形函數&lt;br />　　用於屏幕管理和各種圖形功能。 &lt;br />(6)輸入輸出函數&lt;br />　　用於完成輸入輸出功能。&lt;br />(7)接口函數&lt;br />　　用於與DOS，BIOS和硬件的接口。&lt;br />(8)字符串函數 &lt;br />　　用於字符串操作和處理。&lt;br />(9)內存管理函數&lt;br />　　用於內存管理。&lt;br />(10)數學函數&lt;br />　　用於數學函數計算。&lt;br />(11)日期和時間函數&lt;br />　　用於日期，時間轉換操作。&lt;br />(12)進程控制函數&lt;br />　　用於進程管理和控制。&lt;br />(13)其它函數&lt;br />　　用於其它各種功能。&lt;br />　　&lt;br />　　以上各類函數不僅數量多，而且有的還需要硬件知識才會使用，因此要想全部掌握則需要一個較長的學習過程。 應首先掌握一些最基本、 最常用的函數，再逐步深入。由於篇幅關係，本書只介紹了很少一部分庫函數， 其餘部分讀者可根據需要查閱有關手冊。&lt;br />&lt;br />　　還應該指出的是，在Ｃ語言中，所有的函數定義，包括主函數main在內，都是平行的。也就是說，在一個函數的函數體內， 不能再定義另一個函數， 即不能嵌套定義。但是函數之間允許相互調用，也允許嵌套調用。習慣上把調用者稱為主調函數。 函數還可以自己調用自己，稱為遞歸調用。main 函數是主函數，它可以調用其它函數，而不允許被其它函數調用。 因此，Ｃ程序的執行總是從main函數開始， 完成對其它函數的調用後再返回到main函數，最後由main函數結束整個程序。一個Ｃ源程序必須有，也只能有一個主函數main。&lt;br />　　&lt;br />&lt;span style="color:#ff0000;">函數定義的一般形式&lt;/span>&lt;br />&lt;br />1.無參函數的一般形式 &lt;br />類型說明符 函數名() &lt;br />{ &lt;br />類型說明 &lt;br />語句 &lt;br />}&lt;br />　　其中類型說明符和函數名稱為函數頭。 類型說明符指明瞭本函數的類型，函數的類型實際上是函數返回值的類型。 該類型說明符與第二章介紹的各種說明符相同。 函數名是由用戶定義的標識符，函數名後有一個空括號，其中無參數，但括號不可少。{} 中的內容稱為函數體。在函數體中也有類型說明， 這是對函數體內部所用到的變量的類型說明。在很多情況下都不要求無參函數有返回值， 此時函數類型符可以寫為void。&lt;br />我們可以改為一個函數定義： &lt;br />&lt;span style="color:#009900;">void Hello()&lt;br />{&lt;br />printf ("Hello,world \n");&lt;br />}&lt;br />&lt;/span>　這裡，只把main改為Hello作為函數名，其餘不變。Hello 函數是一個無參函數，當被其它函數調用時，輸出Hello world字符串。&lt;br />&lt;br />2.有參函數的一般形式 &lt;br />類型說明符 函數名(形式參數表) &lt;br />型式參數類型說明 &lt;br />{ &lt;br />類型說明 &lt;br />語句 &lt;br />}&lt;br />　　有參函數比無參函數多了兩個內容，其一是形式參數表， 其二是形式參數類型說明。在形參表中給出的參數稱為形式參數， 它們可以是各種類型的變量， 各參數之間用逗號間隔。在進行函數調用時，主調函數將賦予這些形式參數實際的值。 形參既然是變量，當然必須給以類型說明。例如，定義一個函數， 用於求兩個數中的大數，可寫為：&lt;br />&lt;span style="color:#009900;">int max(a,b)&lt;br />int a,b;&lt;br />{&lt;br />if (a>b) return a;&lt;br />else return b;&lt;br />} &lt;br />&lt;/span>　　第一行說明max函數是一個整型函數，其返回的函數值是一個整數。形參為a,b。第二行說明a,b均為整型量。 a,b 的具體值是由主調函數在調用時傳送過來的。在{}中的函數體內， 除形參外沒有使用其它變量，因此只有語句而沒有變量類型說明。 上邊這種定義方法稱為“傳統格式”。 這種格式不易於編譯系統檢查，從而會引起一些非常細微而且難於跟蹤的錯誤。ANSI C 的新標準中把對形參的類型說明合併到形參表中，稱為“現代格式”。&lt;br />　　例如max函數用現代格式可定義為：&lt;br />&lt;span style="color:#009900;">int max(int a,int b)&lt;br />{&lt;br />if(a>b) return a;&lt;br />else return b;&lt;br />} &lt;br />&lt;/span>　　現代格式在函數定義和函數說明(後面將要介紹)時， 給出了形式參數及其類型，在編譯時易於對它們進行查錯， 從而保證了函數說明和定義的一致性。例1.3即採用了這種現代格式。 在max函數體中的return語句是把a(或b)的值作為函數的值返回給主調函數。有返回值函數中至少應有一個return語句。 在Ｃ程序中，一個函數的定義可以放在任意位置， 既可放在主函數main之前，也可放在main之後。例如例1.3中定義了一個max 函數，其位置在main之後， 也可以把它放在main之前。&lt;br />修改後的程序如下所示。&lt;br />&lt;span style="color:#009900;">int max(int a,int b)&lt;br />{&lt;br />if(a>b)return a;&lt;br />else return b;&lt;br />}&lt;br />void main()&lt;br />{&lt;br />int max(int a,int b);&lt;br />int x,y,z;&lt;br />printf("input two numbers:\n");&lt;br />scanf("%d%d",&x,&y);&lt;br />z=max(x,y);&lt;br />printf("maxmum=%d",z);&lt;br />}&lt;/span>&lt;br />　　現在我們可以從函數定義、 函數說明及函數調用的角度來分析整個程序，從中進一步瞭解函數的各種特點。程序的第1行至第5行為max函數定義。進入主函數後，因為準備調用max函數，故先對max函數進行說明(程序第8行)。函數定義和函數說明並不是一回事，在後面還要專門討論。 可以看出函數說明與函數定義中的函數頭部分相同，但是末尾要加分號。程序第12 行為調用max函數，並把x,y中的值傳送給max的形參a,b。max函數執行的&lt;br />結果 (a或b)將返回給變量z。最後由主函數輸出z的值。&lt;br />&lt;br />　　函數調用的一般形式前面已經說過，在程序中是通過對函數的調用來執行函數體的，其過程與其它語言的子程序調用相似。Ｃ語言中， 函數調用的一般形式為： &lt;br />&lt;br />　　函數名(實際參數表) 對無參函數調用時則無實際參數表。 實際參數表中的參數可以是常數，變量或其它構造類型數據及表達式。 各實參之間用逗號分隔。'Next of Page在Ｃ語言中，可以用以下幾種方式調用函數：&lt;br />1.函數表達式&lt;br />　　函數作表達式中的一項出現在表達式中，以函數返回值參與表達式的運算。這種方式要求函數是有返回值的。例如： z=max(x,y)是一個賦值表達式，把max的返回值賦予變量z。'Next of Page&lt;br />2.函數語句&lt;br />　　函數調用的一般形式加上分號即構成函數語句。例如： printf ("%D",a);scanf ("%d",&b);都是以函數語句的方式調用函數。&lt;br />3.函數實參&lt;br />　　函數作為另一個函數調用的實際參數出現。 這種情況是把該函數的返回值作為實參進行傳送，因此要求該函數必須是有返回值的。例如： printf("%d",max(x,y)); 即是把max調用的返回值又作為printf函數的實參來使用的。在函數調用中還應該注意的一個問題是求值順序的問題。 所謂求值順序是指對實參表中各量是自左至右使用呢，還是自右至左使用。 對此， 各系統的規定不一定相同。在3.1.3節介紹printf 函數時已提&lt;br />到過，這裡從函數調用的角度再強調一下。 看例5.2程序。&lt;br />&lt;span style="color:#009900;">void main()&lt;br />{&lt;br />int i=8;&lt;br />printf("%d\n%d\n%d\n%d\n",++i,--i,i++,i--);&lt;br />}&lt;br />&lt;/span>如按照從右至左的順序求值。例5.2的運行結果應為：&lt;br />8&lt;br />7&lt;br />7&lt;br />8&lt;br />如對printf語句中的++i，--i，i++，i--從左至右求值，結果應為：&lt;br />9&lt;br />8&lt;br />8&lt;br />9&lt;br />　　應特別注意的是，無論是從左至右求值， 還是自右至左求值，其輸出順序都是不變的， 即輸出順序總是和實參表中實參的順序相同。由於Turbo C現定是自右至左求值，所以結果為8，7，7，8。上述問題如還不理解，上機一試就明白了。函數的參數和函數的值&lt;br />一、函數的參數&lt;br />　　前面已經介紹過，函數的參數分為形參和實參兩種。 在本小節中，進一步介紹形參、實參的特點和兩者的關係。 形參出現在函數定義中，在整個函數體內都可以使用， 離開該函數則不能使用。實參出現在主調函數中，進入被調函數後，實參變量也不能使用。 形參和實參的功能是作數據傳送。發生函數調用時， 主調函數把實參的值傳送給被調函數的形參從而實現主調函數向被調函數的數據傳送。&lt;br />&lt;br />　　函數的形參和實參具有以下特點：&lt;br />1.形參變量只有在被調用時才分配內存單元，在調用結束時， 即刻釋放所分配的內存單元。因此，形參只有在函數內部有效。 函數調用結束返回主調函數後則不能再使用該形參變量。&lt;br />&lt;br />2.實參可以是常量、變量、表達式、函數等， 無論實參是何種類型的量，在進行函數調用時，它們都必須具有確定的值， 以便把這些值傳送給形參。 因此應預先用賦值，輸入等辦法使實參獲得確定值。&lt;br />&lt;br />3.實參和形參在數量上，類型上，順序上應嚴格一致， 否則會發生“類型不匹配”的錯誤。&lt;br />&lt;br />4.函數調用中發生的數據傳送是單向的。 即只能把實參的值傳送給形參，而不能把形參的值反向地傳送給實參。 因此在函數調用過程中，形參的值發生改變，而實參中的值不會變化。例5.3可以說明這個問題。&lt;br />&lt;span style="color:#009900;">void main()&lt;br />{&lt;br />int n;&lt;br />printf("input number\n");&lt;br />scanf("%d",&n);&lt;br />s(n);&lt;br />printf("n=%d\n",n);&lt;br />}&lt;br />int s(int n)&lt;br />{&lt;br />int i;&lt;br />for(i=n-1;i>=1;i--)&lt;br />n=n+i;&lt;br />printf("n=%d\n",n);&lt;br />}&lt;br />&lt;/span>本程序中定義了一個函數s，該函數的功能是求∑ni=1i 的值。在主函數中輸入n值，並作為實參，在調用時傳送給s 函數的形參量n( 注意，本例的形參變量和實參變量的標識符都為n， 但這是兩個不同的量，各自的作用域不同)。 在主函數中用printf 語句輸出一次n值，這個n值是實參n的值。在函數s中也用printf 語句輸出了一次n值，這個n值是形參最後取得的n值0。從運行情況看，輸入n值為100。即實參n的值為100。把此值傳給函數s時，形參 n 的初值也為100，在執行函數過程中，形參n的值變為5050。 返回主函數之後，輸出實參n的值仍為100。可見實參的值不隨形參的變化而變化。&lt;br />&lt;br />&lt;span style="color:#ff0000;">二、函數的值&lt;/span>&lt;br />&lt;br />　　函數的值是指函數被調用之後， 執行函數體中的程序段所取得的並返回給主調函數的值。如調用正弦函數取得正弦值，調用例5.1的max函數取得的最大數等。對函數的值(或稱函數返回值)有以下一些說明：&lt;br />&lt;br />1. 函數的值只能通過return語句返回主調函數。return 語句的一般形式為： &lt;br />return 表達式； &lt;br />或者為：&lt;br />return (表達式)；&lt;br />該語句的功能是計算表達式的值，並返回給主調函數。 在函數中允許有多個return語句，但每次調用只能有一個return 語句被執行， 因此只能返回一個函數值。&lt;br />&lt;br />2. 函數值的類型和函數定義中函數的類型應保持一致。 如果兩者不一致，則以函數類型為準，自動進行類型轉換。&lt;br />&lt;br />3. 如函數值為整型，在函數定義時可以省去類型說明。&lt;br />&lt;br />4. 不返回函數值的函數，可以明確定義為“空類型”， 類型說明符為“void”。如例5.3中函數s並不向主函數返函數值，因此可定義為：&lt;br />&lt;span style="color:#009900;">void s(int n)&lt;br />{ ……&lt;br />}&lt;br />&lt;/span>&lt;br />　　一旦函數被定義為空類型後， 就不能在主調函數中使用被調函數的函數值了。例如，在定義s為空類型後，在主函數中寫下述語句 sum=s(n); 就是錯誤的。為了使程序有良好的可讀性並減少出錯， 凡不要求返回值的函數都應定義為空類型。函數說明在主調函數中調用某函數之前應對該被調函數進行說明， 這與使用變量之前要先進行變量說明是一樣的。 在主調函數中對被調函數作說明的目的是使編譯系統知道被調函數返回值的類型， 以便在主調函數中按此種類型對返回值作相應的處理。 對被調函數的說明也有兩種格式，一種為傳統格式，其一般格式為： 類型說明符 被調函數名()； 這種格式只給出函數返回值的類型，被調函數名及一個空括號。&lt;br />&lt;br />　　這種格式由於在括號中沒有任何參數信息， 因此不便於編譯系統進行錯誤檢查，易於發生錯誤。另一種為現代格式，其一般形式為： &lt;br />類型說明符 被調函數名(類型 形參，類型 形參…)； &lt;br />或為：&lt;br />類型說明符 被調函數名(類型，類型…)； &lt;br />　　現代格式的括號內給出了形參的類型和形參名， 或只給出形參類型。這便於編譯系統進行檢錯，以防止可能出現的錯誤。例5.1 main函數中對max函數的說明若&lt;br />用傳統格式可寫為：&lt;br />int max();&lt;br />用現代格式可寫為：&lt;br />int max(int a,int b);&lt;br />或寫為:&lt;br />int max(int,int)；&lt;br />　　Ｃ語言中又規定在以下幾種情況時可以省去主調函數中對被調函數的函數說明。&lt;br />1. 如果被調函數的返回值是整型或字符型時， 可以不對被調函數作說明，而直接調用。這時系統將自動對被調函數返回值按整型處理。例5.3的主函數中未對函數s作說明而直接調用即屬此種情形。&lt;br />&lt;br />2. 當被調函數的函數定義出現在主調函數之前時， 在主調函數中也可以不對被調函數再作說明而直接調用。例如例5.1中， 函數max的定義放在main 函數之前，因此可在main函數中省去對 max函數的函數說明int max(int a,int b)。&lt;br />&lt;br />3. 如在所有函數定義之前， 在函數外預先說明了各個函數的類型，則在以後的各主調函數中，可不再對被調函數作說明。例如：&lt;br />&lt;span style="color:#009900;">char str(int a);&lt;br />float f(float b);&lt;br />main()&lt;br />{&lt;br />……&lt;br />}&lt;br />char str(int a)&lt;br />{&lt;br />……&lt;br />}&lt;br />float f(float b)&lt;br />{&lt;br />……&lt;br />}&lt;br />&lt;/span>其中第一，二行對str函數和f函數預先作了說明。 因此在以後各函數中無須對str和f函數再作說明就可直接調用。&lt;br />&lt;br />4. 對庫函數的調用不需要再作說明， 但必須把該函數的頭文件用include命令包含在源文件前部。數組作為函數參數數組可以作為函數的參數使用，進行數據傳送。 數組用作函數參數有兩種形式，一種是把數組元素(下標變量)作為實參使用； 另一種是把數組名作為函數的形參和實參使用。一、數組元素作函數實參數組元素就是下標變量，它與普通變量並無區別。 因此它作為函數實參使用與普通變量是完全相同的，在發生函數調用時， 把作為實參的數組元素的值傳送給形參，實現單向的值傳送。例5.4說明了這種情況。[例5.4]判別一個整數數組中各元素的值，若大於0 則輸出該值，若小於等於0則輸出0值。編程如下：&lt;br />&lt;span style="color:#009900;">void nzp(int v)&lt;br />{&lt;br />if(v>0)&lt;br />printf("%d ",v);&lt;br />else&lt;br />printf("%d ",0);&lt;br />}&lt;br />main()&lt;br />{&lt;br />int a[5],i;&lt;br />printf("input 5 numbers\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />{&lt;br />scanf("%d",&a);&lt;br />nzp(a);&lt;br />}&lt;br />}void nzp(int v)&lt;br />{ ……&lt;br />}&lt;br />main()&lt;br />{&lt;br />int a[5],i;&lt;br />printf("input 5 numbers\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />{ scanf("%d",&a);&lt;br />nzp(a);&lt;br />}&lt;br />}&lt;/span> &lt;br />　　本程序中首先定義一個無返回值函數nzp，並說明其形參v 為整型變量。在函數體中根據v值輸出相應的結果。在main函數中用一個for 語句輸入數組各元素， 每輸入一個就以該元素作實參調用一次nzp函數，即把a的值傳送給形參v，供nzp函數使用。&lt;br />&lt;br />&lt;span style="color:#ff0000;">二、數組名作為函數參數&lt;/span>&lt;br />&lt;br />　　用數組名作函數參數與用數組元素作實參有幾點不同：&lt;br />1. 用數組元素作實參時，只要數組類型和函數的形參變量的類型一致，那麼作為下標變量的數組元素的類型也和函數形參變量的類型是一致的。因此， 並不要求函數的形參也是下標變量。 換句話說，對數組元素的處理是按普通變量對待的。用數組名作函數參數時， 則要求形參和相對應的實參都必須是類型相同的數組，都必須有明確的數組說明。當形參和實參二者不一致時，即會發生錯誤。&lt;br />&lt;br />2. 在普通變量或下標變量作函數參數時，形參變量和實參變量是由編譯系統分配的兩個不同的內存單元。在函數調用時發生的值傳送是把實參變量的值賦予形參變量。在用數組名作函數參數時，不是進行值的傳送，即不是把實參數組的每一個元素的值都賦予形參數組的各個元素。因為實際上形參數組並不存在，編譯系統不為形參數組分配內存。那麼，數據的傳送是如何實現的呢? 在第四章中我們曾介紹過，數組名就是數組的首地址。因此在數組名作函數參數時所進行的傳送只是地址的傳送， 也就是說把實參數組的首地址賦予形參數組名。形參數組名取得該首地址之後，也就等於有了實在的數組。實際上是形參數組和實參數組為同一數組，共同擁有一段內存空間。圖5.1說明了這種情形。圖中設a為實參數組，類型為整型。a佔有以2000 為首地址的一塊內存區。b為形參數組名。當發生函數調用時，進行地址傳送， 把實參數 組a的首地址傳送給形參數組名b，於是b也取得該地址2000。 於是a，b兩數組共同佔有以2000 為首地址的一段連續內存單元。從圖中還可以看出a和b下標相同的元素實際上也佔相同的兩個內&lt;br />存單元(整型數組每個元素佔二字節)。例如a[0]和b[0]都佔用2000和2001單元，當然a[0]等於b[0]。類推則有a等於b。&lt;br />[例5.5]數組a中存放了一個學生5門課程的成績，求平均成績。float aver(float a[5])&lt;br />&lt;span style="color:#009900;">{&lt;br />int i;&lt;br />float av,s=a[0]; &lt;br />for(i=1;i&lt;5;i++) &lt;br />s=s+a;&lt;br />av=s/5;&lt;br />return av;&lt;br />}&lt;br />void main()&lt;br />{&lt;br />float sco[5],av;&lt;br />int i;&lt;br />printf("\ninput 5 scores:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />scanf("%f",&sco);&lt;br />av=aver(sco);&lt;br />printf("average score is %5.2f",av);&lt;br />}&lt;br />float aver(float a[5])&lt;br />{ ……&lt;br />}&lt;br />void main()&lt;br />{&lt;br />……&lt;br />for(i=0;i&lt;5;i++)&lt;br />scanf("%f",&sco);&lt;br />av=aver(sco);&lt;br />……&lt;br />}&lt;/span> &lt;br />　　本程序首先定義了一個實型函數aver，有一個形參為實型數組a，長度為5。在函數aver中，把各元素值相加求出平均值，返回給主函數。主函數main 中首先完成數組sco的輸入，然後以sco作為實參調用aver函數，函數返回值送av，最後輸出av值。 從運行情況可以看出，程序實現了所要求的功能&lt;br />&lt;br />3. 前面已經討論過，在變量作函數參數時，所進行的值傳送是單向的。即只能從實參傳向形參，不能從形參傳回實參。形參的初值和實參相同， 而形參的值發生改變後，實參並不變化， 兩者的終值是不同的。例5.3證實了這個結論。 而當用數組名作函數參數時，情況則不同。 由於實際上形參和實參為同一數組， 因此當形參數組發生變化時，實參數組也隨之變化。 當然這種情況不能理解為發生了“雙向”的值傳遞。但從實際情況來看，調用函數之後實參數組的值將由於形參數組值的變化而變化。為了說明這種情況，把例5.4改為例5.6的形式。[例5.6]題目同5.4例。改用數組名作函數參數。&lt;br />&lt;span style="color:#009900;">void nzp(int a[5])&lt;br />{&lt;br />int i;&lt;br />printf("\nvalues of array a are:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />{&lt;br />if(a&lt;0) a=0;&lt;br />printf("%d ",a);&lt;br />}&lt;br />}&lt;br />main()&lt;br />{&lt;br />int b[5],i;&lt;br />printf("\ninput 5 numbers:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />scanf("%d",&b);&lt;br />printf("initial values of array b are:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />printf("%d ",b);&lt;br />nzp(b);&lt;br />printf("\nlast values of array b are:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />printf("%d ",b);&lt;br />}&lt;br />void nzp(int a[5])&lt;br />{ …… &lt;br />}&lt;br />main()&lt;br />{&lt;br />int b[5],i;&lt;br />……&lt;br />nzp(b);&lt;br />……&lt;br />}&lt;/span>&lt;br />　　本程序中函數nzp的形參為整數組a，長度為 5。 主函數中實參數組b也為整型，長度也為5。在主函數中首先輸入數組b的值，然後輸出數組b的初始值。 然後以數組名b為實參調用nzp函數。在nzp中，按要求把負值單元清0，並輸出形參數組a的值。 返回主函數之後，再次輸出數組b的值。從運行結果可以看出，數組b 的初值和終值是不同的，數組b 的終值和數組a是相同的。這說明實參形參為同一數組，它們的值同時得以改變。 用數組名作為函數參數時還應注意以下幾點：&lt;br />a. 形參數組和實參數組的類型必須一致，否則將引起錯誤。&lt;br />b. 形參數組和實參數組的長度可以不相同，因為在調用時，只傳送首地址而不檢查形參數組的長度。當形參數組的長度與實參數組不一致時，雖不至於出現語法錯誤(編譯能通過)，但程序執行結果將與實際不符，這是應予以注意的。如把例5.6修改如下：&lt;br />&lt;span style="color:#009900;">void nzp(int a[8])&lt;br />{&lt;br />int i;&lt;br />printf("\nvalues of array aare:\n");&lt;br />for(i=0;i&lt;8;i++)&lt;br />{&lt;br />if(a&lt;0)a=0;&lt;br />printf("%d",a);&lt;br />}&lt;br />}&lt;br />main()&lt;br />{&lt;br />int b[5],i;&lt;br />printf("\ninput 5 numbers:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />scanf("%d",&b);&lt;br />printf("initial values of array b are:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />printf("%d",b);&lt;br />nzp(b);&lt;br />printf("\nlast values of array b are:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />printf("%d",b);&lt;br />}&lt;br />&lt;/span>　　本程序與例5.6程序比，nzp函數的形參數組長度改為8，函數體中，for語句的循環條件也改為i&lt;8。因此，形參數組 a和實參數組b的長度不一致。編譯能夠通過，但從結果看，數組a的元素a[5]，a[6]，a[7]顯然是無意義的。c. 在函數形參表中，允許不給出形參數組的長度，或用一個變量來表示數組元素的個數。&lt;br />例如：可以寫為：&lt;br />void nzp(int a[])&lt;br />或寫為&lt;br />void nzp(int a[]，int n)&lt;br />　　其中形參數組a沒有給出長度，而由n值動態地表示數組的長度。n的值由主調函數的實參進行傳送。&lt;br />由此，例5.6又可改為例5.7的形式。&lt;br />&lt;span style="color:#009900;">[例5.7]void nzp(int a[],int n)&lt;br />{&lt;br />int i;&lt;br />printf("\nvalues of array a are:\n");&lt;br />for(i=0;i&lt;n;i++)&lt;br />{&lt;br />if(a&lt;0) a=0;&lt;br />printf("%d ",a);&lt;br />}&lt;br />}&lt;br />main()&lt;br />{&lt;br />int b[5],i;&lt;br />printf("\ninput 5 numbers:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />scanf("%d",&b);&lt;br />printf("initial values of array b are:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />printf("%d ",b);&lt;br />nzp(b,5);&lt;br />printf("\nlast values of array b are:\n");&lt;br />for(i=0;i&lt;5;i++)&lt;br />printf("%d ",b);&lt;br />}&lt;br />void nzp(int a[],int n)&lt;br />{ ……&lt;br />}&lt;br />main()&lt;br />{&lt;br />……&lt;br />nzp(b,5);&lt;br />……&lt;br />}&lt;br />　　&lt;/span>本程序nzp函數形參數組a沒有給出長度，由n 動態確定該長度。在main函數中，函數調用語句為nzp(b，5)，其中實參5將賦予形參n作為形參數組的長度。&lt;br />d. 多維數組也可以作為函數的參數。 在函數定義時對形參數組可以指定每一維的長度，也可省去第一維的長度。因此，以下寫法都是合法的。 &lt;br />int MA(int a[3][10])&lt;br />或&lt;br />int MA(int a[][10])&lt;br />&lt;br />&lt;span style="color:#ff0000;">函數的嵌套調用&lt;/span>&lt;br />&lt;br />　　Ｃ語言中不允許作嵌套的函數定義。因此各函數之間是平行的，不存在上一級函數和下一級函數的問題。 但是Ｃ語言允許在一個函數的定義中出現對另一個函數的調用。 這樣就出現了函數的嵌套調用。即在被調函數中又調用其它函數。 這與其它語言的子程序嵌套的情形是類似的。其關係可表示如圖5.2。&lt;br />&lt;br />　　圖5.2表示了兩層嵌套的情形。其執行過程是：執行main函數中調用a函數的語句時，即轉去執行a函數，在a函數中調用b 函數時，又轉去執行b函數，b函數執行完畢返回a函數的斷點繼續執行，a 函數執行完畢返回main函數的斷點繼續執行。&lt;br />[例5.8]計算s=2?2!+3?2!&lt;br />本題可編寫兩個函數，一個是用來計算平方值的函數f1， 另一個是用來計算階乘值的函數f2。主函數先調f1計算出平方值， 再在f1中以平方值為實參，調用 f2計算其階乘值，然後返回f1，再返回主函數，在循環程序中計算累加和。&lt;br />&lt;span style="color:#009900;">long f1(int p)&lt;br />{&lt;br />int k;&lt;br />long r;&lt;br />long f2(int);&lt;br />k=p*p;&lt;br />r=f2(k);&lt;br />return r;&lt;br />}&lt;br />long f2(int q)&lt;br />{&lt;br />long c=1;&lt;br />int i;&lt;br />for(i=1;i&lt;=q;i++)&lt;br />c=c*i;&lt;br />return c;&lt;br />}&lt;br />main()&lt;br />{&lt;br />int i;&lt;br />long s=0;&lt;br />for (i=2;i&lt;=3;i++)&lt;br />s=s+f1(i);&lt;br />printf("\ns=%ld\n",s);&lt;br />}&lt;br />long f1(int p)&lt;br />{&lt;br />……&lt;br />long f2(int);&lt;br />r=f2(k);&lt;br />……&lt;br />}&lt;br />long f2(int q)&lt;br />{ &lt;br />……&lt;br />}&lt;br />main()&lt;br />{ ……&lt;br />s=s+f1(i);&lt;br />……&lt;br />}&lt;br />&lt;/span>　　在程序中，函數f1和f2均為長整型，都在主函數之前定義， 故不必再在主函數中對f1和f2加以說明。在主程序中， 執行循環程序依次把i值作為實參調用函數f1求i?2值。在f1中又發生對函數f2的調用，這時是把i?2的值作為實參去調f2，在f2 中完成求i?2! 的計算。f2執行完畢把C值(即i?2!)返回給f1，再由f1 返回主函數實現累加。至此，由函數的嵌套調用實現了題目的要求。 由於數值很大， 所以函數和一些變量的類型都說明為長整型，否則會造成計算錯誤。&lt;br />&lt;br />&lt;span style="color:#ff0000;">函數的遞歸調用&lt;/span>&lt;br />&lt;br />　　一個函數在它的函數體內調用它自身稱為遞歸調用。 這種函數稱為遞歸函數。Ｃ語言允許函數的遞歸調用。在遞歸調用中， 主調函數又是被調函數。執行遞歸函數將反覆調用其自身。 每調用一次就進入新的一層。例如有函數f如下：&lt;br />&lt;span style="color:#009900;">int f (int x)&lt;br />{&lt;br />int y;&lt;br />z=f(y);&lt;br />return z;&lt;br />}&lt;br />&lt;/span>　　這個函數是一個遞歸函數。 但是運行該函數將無休止地調用其自身，這當然是不正確的。為了防止遞歸調用無終止地進行， 必須在函數內有終止遞歸調用的手段。常用的辦法是加條件判斷， 滿足某種條件後就不再作遞歸調用，然後逐層返回。 下面舉例說明遞歸調用的執行過程。&lt;br />[例5.9]用遞歸法計算n!用遞歸法計算n!可用下述公式表示：&lt;br />n!=1 (n=0,1)&lt;br />n×(n-1)! (n>1)&lt;br />按公式可編程如下：&lt;br />&lt;span style="color:#009900;">long ff(int n)&lt;br />{&lt;br />long f;&lt;br />if(n&lt;0) printf("n&lt;0,input error");&lt;br />else if(n==0||n==1) f=1;&lt;br />else f=ff(n-1)*n;&lt;br />return(f);&lt;br />}&lt;br />main()&lt;br />{&lt;br />int n;&lt;br />long y;&lt;br />printf("\ninput a inteager number:\n");&lt;br />scanf("%d",&n);&lt;br />y=ff(n);&lt;br />printf("%d!=%ld",n,y);&lt;br />}&lt;br />long ff(int n)&lt;br />{ ……&lt;br />else f=ff(n-1)*n;&lt;br />……&lt;br />}&lt;br />main()&lt;br />{ ……&lt;br />y=ff(n);&lt;br />……&lt;br />}&lt;/span> &lt;br />　　程序中給出的函數ff是一個遞歸函數。主函數調用ff 後即進入函數ff執行，如果n&lt;0,n==0或n=1時都將結束函數的執行，否則就遞歸調用ff函數自身。由於每次遞歸調用的實參為n-1，即把n-1 的值賦予形參n，最後當n-1的值為1時再作遞歸調用，形參n的值也為1，將使遞歸終止。然後可逐層退回。下面我們再舉例說明該過程。 設執行本程序時輸入為5， 即求 5!。在主函數中的調用語句即為y=ff(5)，進入ff函數後，由於n=5,不等於0或1，故應執行f=ff(n-1)*n,即f=ff(5-1)*5。該語句對ff作遞歸調用即ff(4)。 逐次遞歸展開如圖5.3所示。進行四次遞歸調用後，ff函數形參取得的值變為1，故不再繼續遞歸調用而開始逐層返回主調函數。ff(1)的函數返回值為1，ff(2)的返回值為1*2=2，ff(3)的返回值為2*3=6，ff(4) 的返&lt;br />回值為6*4=24，最後返回值ff(5)為24*5=120。&lt;br />&lt;br />　　例5. 9也可以不用遞歸的方法來完成。如可以用遞推法，即從1開始乘以2，再乘以3…直到n。遞推法比遞歸法更容易理解和實現。但是有些問題則只能用遞歸算法才能實現。典型的問題是Hanoi塔問題。&lt;br />　　&lt;br />　　[例5.10]Hanoi塔問題&lt;br />一塊板上有三根針，A，B，C。A針上套有64個大小不等的圓盤， 大的在下，小的在上。如圖5.4所示。要把這64個圓盤從A針移動C針上，每次只能移動一個圓盤，移動可以藉助B針進行。但在任何時候，任何針上的圓盤都必須保持大盤在下，小盤在上。求移動的步驟。&lt;br />本題算法分析如下，設A上有n個盤子。&lt;br />如果n=1，則將圓盤從A直接移動到C。&lt;br />如果n=2，則：&lt;br />1.將A上的n-1(等於1)個圓盤移到B上；&lt;br />2.再將A上的一個圓盤移到C上；&lt;br />3.最後將B上的n-1(等於1)個圓盤移到C上。&lt;br />如果n=3，則：&lt;br />A. 將A上的n-1(等於2，令其為n`)個圓盤移到B(藉助於C)， &lt;br />步驟如下：&lt;br />(1)將A上的n`-1(等於1)個圓盤移到C上，見圖5.5(b)。&lt;br />(2)將A上的一個圓盤移到B，見圖5.5(c)&lt;br />(3)將C上的n`-1(等於1)個圓盤移到B，見圖5.5(d)&lt;br />B. 將A上的一個圓盤移到C，見圖5.5(e)&lt;br />C. 將B上的n-1(等於2，令其為n`)個圓盤移到C(藉助A)，&lt;br />步驟如下：&lt;br />(1)將B上的n`-1(等於1)個圓盤移到A，見圖5.5(f)&lt;br />(2)將B上的一個盤子移到C，見圖5.5(g)&lt;br />(3)將A上的n`-1(等於1)個圓盤移到C，見圖5.5(h)。&lt;br />到此，完成了三個圓盤的移動過程。&lt;br />從上面分析可以看出，當n大於等於2時， 移動的過程可分解為&lt;br />三個步驟：&lt;br />第一步 把A上的n-1個圓盤移到B上；&lt;br />第二步 把A上的一個圓盤移到C上；&lt;br />第三步 把B上的n-1個圓盤移到C上；其中第一步和第三步是類同的。 &lt;br />當n=3時，第一步和第三步又分解為類同的三步，即把n`-1個圓盤從一個針移到另一個針上，這裡的n`=n-1。 顯然這是一個遞歸過&lt;br />程，據此算法可編程如下：&lt;br />&lt;span style="color:#009900;">move(int n,int x,int y,int z)&lt;br />{&lt;br />if(n==1)&lt;br />printf("%c-->%c\n",x,z);&lt;br />else&lt;br />{&lt;br />move(n-1,x,z,y);&lt;br />printf("%c-->%c\n",x,z);&lt;br />move(n-1,y,x,z);&lt;br />}&lt;br />}&lt;br />main()&lt;br />{&lt;br />int h;&lt;br />printf("\ninput number:\n");&lt;br />scanf("%d",&h);&lt;br />printf("the step to moving %2d diskes:\n",h);&lt;br />move(h,'a','b','c');&lt;br />}&lt;br />move(int n,int x,int y,int z)&lt;br />{&lt;br />if(n==1)&lt;br />printf("%-->%c\n",x,z);&lt;br />else&lt;br />{&lt;br />move(n-1,x,z,y);&lt;br />printf("%c-->%c\n",x,z);&lt;br />move(n-1,y,x,z);&lt;br />}&lt;br />}&lt;br />main()&lt;br />{ ……&lt;br />move(h,'a','b','c');&lt;br />}&lt;br />&lt;/span>　　從程序中可以看出,move函數是一個遞歸函數，它有四個形參n,x,y,z。n表示圓盤數，x,y,z分別表示三根針。move 函數的功能是把x上的n個圓盤移動到z 上。當n==1時，直接把x上的圓盤移至z上，輸出x→z。如n!=1則分為三步：遞歸調用move函數，把n-1個圓盤從x移到y；輸出x→z；遞歸調用move函數，把n-1個圓盤從y移到z。在遞歸調用過程中n=n-1，故n的值逐次遞減，最後n=1時，終止遞歸，逐層返回。當n=4 時程序運行的結果為&lt;br />&lt;span style="color:#009900;">input number:&lt;br />4&lt;br />the step to moving 4 diskes:&lt;br />a→b&lt;br />a→c&lt;br />b→c&lt;br />a→b&lt;br />c→a&lt;br />c→b&lt;br />a→b&lt;br />a→c&lt;br />b→c&lt;br />b→a&lt;br />c→a&lt;br />b→c&lt;br />a→b&lt;br />a→c&lt;br />b→c&lt;/span>&lt;br />&lt;br />&lt;span style="color:#ff0000;">變量的作用域&lt;/span>&lt;br />&lt;br />　　在討論函數的形參變量時曾經提到， 形參變量只在被調用期間才分配內存單元，調用結束立即釋放。 這一點表明形參變量只有在函數內才是有效的， 離開該函數就不能再使用了。這種變量有效性的範圍稱變量的作用域。不僅對於形參變量， Ｃ語言中所有的量都有自己的作用域。變量說明的方式不同，其作用域也不同。 Ｃ語言中的變量，按作用域範圍可分為兩種， 即局部變量和全局變量。&lt;br />&lt;br />&lt;span style="color:#ff0000;">一、局部變量&lt;/span>&lt;br />&lt;br />　　局部變量也稱為內部變量。局部變量是在函數內作定義說明的。其作用域僅限於函數內， 離開該函數後再使用這種變量是非法的。&lt;br />例如：&lt;br />&lt;span style="color:#009900;">int f1(int a) /*函數f1*/&lt;br />{&lt;br />int b,c; &lt;br />……&lt;br />}a,b,c作用域&lt;br />int f2(int x) /*函數f2*/&lt;br />{&lt;br />int y,z; &lt;br />}x,y,z作用域&lt;br />main()&lt;br />{&lt;br />int m,n; &lt;br />}&lt;/span>&lt;span style="color:#ff0000;">&lt;br />&lt;/span>m,n作用域 在函數f1內定義了三個變量，a為形參，b,c為一般變量。在 f1的範圍內a,b,c有效，或者說a,b,c變量的作用域限於f1內。同理，x,y,z的作用域限於f2內。 m,n的作用域限於main函數內。關於局部變量的作用域還要說明以下幾點：&lt;br />&lt;br />1. 主函數中定義的變量也只能在主函數中使用，不能在其它函數中使用。同時，主函數中也不能使用其它函數中定義的變量。因為主函數也是一個函數，它與其它函數是平行關係。這一點是與其它語言不同的，應予以注意。&lt;br />&lt;br />2. 形參變量是屬於被調函數的局部變量，實參變量是屬於主調函數的局部變量。&lt;br />&lt;br />3. 允許在不同的函數中使用相同的變量名，它們代表不同的對象，分配不同的單元，互不干擾，也不會發生混淆。如在例5.3 中，形參和實參的變量名都為n，是完全允許的。4. 在複合語句中也可定義變量，其作用域只在複合語句範圍內。例如：&lt;br />&lt;span style="color:#009900;">main()&lt;br />{&lt;br />int s,a;&lt;br />……&lt;br />{&lt;br />int b;&lt;br />s=a+b; &lt;br />……b作用域 &lt;br />}&lt;br />……s,a作用域&lt;br />}[例5.11]main()&lt;br />{&lt;br />int i=2,j=3,k;&lt;br />k=i+j;&lt;br />{&lt;br />int k=8;&lt;br />if(i==3) printf("%d\n",k);&lt;br />}&lt;br />printf("%d\n%d\n",i,k);&lt;br />}&lt;br />main()&lt;br />{&lt;br />int i=2,j=3,k;&lt;br />k=i+j;&lt;br />{&lt;br />int k=8;&lt;br />if(i=3) printf("%d\n",k);&lt;br />}&lt;br />printf("%d\n%d\n",i,k);&lt;br />}&lt;/span> &lt;br />　　本程序在main中定義了i,j,k三個變量，其中k未賦初值。 而在複合語句內又定義了一個變量k，並賦初值為8。應該注意這兩個k不是同一個變量。在複合語句外由main定義的k起作用，而在複合語句內則由在複合語句內定義的k起作用。因此程序第4行的k為main所定義，其值應為5。第7行輸出k值，該行在複合語句內，由複合語句內定義的k起作用，其初值為8，故輸出值為8，第9行輸出i，k值。i是在整個程序中有效的，第7行對i賦值為3，故以輸出也為3。而第9行已在複合語句之外，輸出的k應為main所定義的k，此k值由第4 行已獲得為5，故輸出也為5。&lt;br />&lt;br />&lt;span style="color:#ff0000;">二、全局變量&lt;/span>&lt;br />&lt;br />全局變量也稱為外部變量，它是在函數外部定義的變量。 它不屬於哪一個函數，它屬於一個源程序文件。其作用域是整個源程序。在函數中使用全局變量，一般應作全局變量說明。 只有在函數內經過說明的全局變量才能使用。全局變量的說明符為extern。 但在一個函數之前定義的全局變量，在該函數內使用可不再加以說明。 例如：&lt;br />&lt;span style="color:#009900;">int a,b; /*外部變量*/&lt;br />void f1() /*函數f1*/&lt;br />{&lt;br />……&lt;br />}&lt;br />float x,y; /*外部變量*/ &lt;br />int fz() /*函數fz*/&lt;br />{&lt;br />……&lt;br />}&lt;br />main() /*主函數*/&lt;br />{&lt;br />……&lt;br />}/*全局變量x,y作用域 全局變量a,b作用域*/&lt;br />&lt;/span>　　從上例可以看出a、b、x、y 都是在函數外部定義的外部變量，都是全局變量。但x,y 定義在函數f1之後，而在f1內又無對x,y的說明，所以它們在f1內無效。 a,b定義在源程序最前面，因此在f1,f2及main內不加說明也可使用。&lt;br />&lt;br />[例5.12]輸入正方體的長寬高l,w,h。求體積及三個面x*y,x*z,y*z的面積。&lt;br />&lt;span style="color:#009900;">int s1,s2,s3;&lt;br />int vs( int a,int b,int c)&lt;br />{&lt;br />int v;&lt;br />v=a*b*c;&lt;br />s1=a*b;&lt;br />s2=b*c;&lt;br />s3=a*c;&lt;br />return v;&lt;br />}&lt;br />main()&lt;br />{&lt;br />int v,l,w,h;&lt;br />printf("\ninput length,width and height\n");&lt;br />scanf("%d%d%d",&l,&w,&h);&lt;br />v=vs(l,w,h);&lt;br />printf("v=%d s1=%d s2=%d s3=%d\n",v,s1,s2,s3);&lt;br />}&lt;br />&lt;/span>　　本程序中定義了三個外部變量s1,s2,s3， 用來存放三個面積，其作用域為整個程序。函數vs用來求正方體體積和三個面積， 函數的返回值為體積v。由主函數完成長寬高的輸入及結果輸出。由於Ｃ語言規定函數返回值只有一個， 當需要增加函數的返回數據時，用外部變量是一種很好的方式。本例中，如不使用外部變量， 在主函數中就不可能取得v,s1,s2,s3四個值。而採用了外部變量， 在函數vs中求得的s1,s2,s3值在main 中仍然有效。因此外部變量是實現函數之間數據通訊的有效手段。對於全局變量還有以下幾點說明：&lt;br />&lt;br />1. 對於局部變量的定義和說明，可以不加區分。而對於外部變量則不然，外部變量的定義和外部變量的說明並不是一回事。外部變量定義必須在所有的函數之外，且只能定義一次。其一般形式為： [extern] 類型說明符 變量名，變量名… 其中方括號內的extern可以省去不寫。&lt;br />例如： int a,b;&lt;br />等效於：&lt;br />extern int a,b;&lt;br />　　而外部變量說明出現在要使用該外部變量的各個函數內， 在整個程序內，可能出現多次，外部變量說明的一般形式為： extern 類型說明符 變量名，變量名，…； 外部變量在定義時就已分配了內存單元， 外部變量定義可作初始賦值，外部變量說明不能再賦初始值， 只是表明在函數內要使用某外部變量。&lt;br />&lt;br />2. 外部變量可加強函數模塊之間的數據聯繫， 但是又使函數要依賴這些變量，因而使得函數的獨立性降低。從模塊化程序設計的觀點來看這是不利的， 因此在不必要時儘量不要使用全局變量。&lt;br />&lt;br />3. 在同一源文件中，允許全局變量和局部變量同名。在局部變量的作用域內，全局變量不起作用。&lt;span style="color:#009900;">&lt;br />[例5.13]int vs(int l,int w)&lt;br />{&lt;br />extern int h;&lt;br />int v;&lt;br />v=l*w*h;&lt;br />return v;&lt;br />}&lt;br />main()&lt;br />{&lt;br />extern int w,h;&lt;br />int l=5;&lt;br />printf("v=%d",vs(l,w));&lt;br />}&lt;br />int l=3,w=4,h=5;&lt;br />&lt;/span>　　本例程序中，外部變量在最後定義， 因此在前面函數中對要用的外部變量必須進行說明。外部變量l，w和vs函數的形參l，w同名。外部變量都作了初始賦值，mian函數中也對l作了初始化賦值。執行程序時，在printf語句中調用vs函數，實參l的值應為main中定義的l值，等於5，外部變量l在main內不起作用；實參w的值為外部變量w的值為4，進入vs後這兩個值傳送給形參l，wvs函數中使用的h 為外部變量，其值為5，因此v的計算結果為100，返回主函數後輸出。變量的存儲類型各種變量的作用域不同， 就其本質來說是因變量的存儲類型相同。所謂存儲類型是指變量佔用內存空間的方式， 也稱為存儲方式。&lt;br />&lt;br />&lt;span style="color:#ff0000;">變量的存儲方式可分為“靜態存儲”和“動態存儲”兩種。&lt;/span> &lt;br />&lt;br />　　靜態存儲變量通常是在變量定義時就分定存儲單元並一直保持不變， 直至整個程序結束。5.5.1節中介紹的全局變量即屬於此類存儲方式。動態存儲變量是在程序執行過程中，使用它時才分配存儲單元， 使用完畢立即釋放。 典型的例子是函數的形式參數，在函數定義時並不給形參分配存儲單元，只是在函數被調用時，才予以分配， 調用函數完畢立即釋放。如果一個函數被多次調用，則反覆地分配、 釋放形參變量的存儲單元。從以上分析可知， 靜態存儲變量是一直存在的， 而動態存儲變量則時而存在時而消失。我們又把這種由於變量存儲方式不同而產生的特性稱變量的生存期。 生存期表示了變量存在的時間。 生存期和作用域是從時間和空間這兩個不同的角度來描述變量的特性，這兩者既有聯繫，又有區別。 一個變量究竟屬於哪一種存儲方式， 並不能僅從其作用域來判斷，還應有明確的存儲類型說明。&lt;br />&lt;br />　　在Ｃ語言中，對變量的存儲類型說明有以下四種：&lt;br />auto　　　　 自動變量&lt;br />register 　　寄存器變量&lt;br />extern 　　　外部變量&lt;br />static 　　　靜態變量 &lt;br />　　自動變量和寄存器變量屬於動態存儲方式， 外部變量和靜態變量屬於靜態存儲方式。在介紹了變量的存儲類型之後， 可以知道對一個變量的說明不僅應說明其數據類型，還應說明其存儲類型。 因此變量說明的完整形式應為： 存儲類型說明符 數據類型說明符 變量名，變量名…； 例如：&lt;br />static int a,b; 　　　　　　　　　 說明a,b為靜態類型變量&lt;br />auto char c1,c2; 　　　　　　　　　說明c1,c2為自動字符變量&lt;br />static int a[5]={1,2,3,4,5}; 　　　說明a為靜整型數組&lt;br />extern int x,y; 　　　　　　　　　 說明x,y為外部整型變量&lt;br />下面分別介紹以上四種存儲類型：&lt;br />&lt;br />一、自動變量的類型說明符為auto。&lt;br />　　這種存儲類型是Ｃ語言程序中使用最廣泛的一種類型。Ｃ語言規定， 函數內凡未加存儲類型說明的變量均視為自動變量， 也就是說自動變量可省去說明符auto。 在前面各章的程序中所定義的變量凡未加存儲類型說明符的都是自動變量。例如：&lt;br />&lt;span style="color:#009900;">{ int i,j,k;&lt;br />char c;&lt;br />……&lt;br />}等價於： { auto int i,j,k;&lt;br />auto char c;&lt;br />……&lt;br />}&lt;br />&lt;/span>　　自動變量具有以下特點：&lt;br />1. 自動變量的作用域僅限於定義該變量的個體內。在函數中定義的自動變量，只在該函數內有效。在複合語句中定義的自動變量只在該複合語句中有效。 例如： &lt;br />&lt;span style="color:#009900;">int kv(int a)&lt;br />{&lt;br />auto int x,y;&lt;br />{ auto char c; &lt;br />} /*c的作用域*/&lt;br />……&lt;br />} /*a,x,y的作用域*/&lt;br />&lt;/span>&lt;br />2. 自動變量屬於動態存儲方式，只有在使用它，即定義該變量的函數被調用時才給它分配存儲單元，開始它的生存期。函數調用結束，釋放存儲單元，結束生存期。因此函數調用結束之後，自動變量的值不能保留。在複合語句中定義的自動變量，在退出複合語句後也不能再使用，否則將引起錯誤。例如以下程序： &lt;br />&lt;span style="color:#009900;">main()&lt;br />{ auto int a,s,p;&lt;br />printf("\ninput a number:\n");&lt;br />scanf("%d",&a);&lt;br />if(a>0){&lt;br />s=a+a;&lt;br />p=a*a;&lt;br />}&lt;br />printf("s=%d p=%d\n",s,p);&lt;br />}&lt;br />{ auto int a;&lt;br />printf("\ninput a number:\n");&lt;br />scanf("%d",&a);&lt;br />if(a>0){&lt;br />auto int s,p;&lt;br />s=a+a;&lt;br />p=a*a;&lt;br />}&lt;br />printf("s=%d p=%d\n",s,p);&lt;br />}&lt;br />&lt;/span>s,p是在複合語句內定義的自動變量，只能在該複合語句內有效。而程序的第9行卻是退出複合語句之後用printf語句輸出s,p的值，這顯然會引起錯誤。&lt;br />&lt;br />3. 由於自動變量的作用域和生存期都侷限於定義它的個體內( 函數或複合語句內)， 因此不同的個體中允許使用同名的變量而不會混淆。 即使在函數內定義的自動變量也可與該函數內部的複合語句中定義的自動變量同名。例5.14表明了這種情況。&lt;br />[例5.14]&lt;br />&lt;span style="color:#009900;">main()&lt;br />{&lt;br />auto int a,s=100,p=100;&lt;br />printf("\ninput a number:\n");&lt;br />scanf("%d",&a);&lt;br />if(a>0)&lt;br />{&lt;br />auto int s,p;&lt;br />s=a+a;&lt;br />p=a*a;&lt;br />printf("s=%d p=%d\n",s,p);&lt;br />}&lt;br />printf("s=%d p=%d\n",s,p);&lt;br />}&lt;br />&lt;/span>　　本程序在main函數中和複合語句內兩次定義了變量s,p為自動變量。按照Ｃ語言的規定，在複合語句內，應由複合語句中定義的s,p起作用，故s的值應為a+ a，p的值為a*a。退出複合語句後的s,p 應為main所定義的s,p，其值在初始化時給定，均為100。從輸出結果可以分析出兩個s和兩個p雖變量名相同， 但卻是兩個不同的變量。&lt;br />&lt;br />4. 對構造類型的自動變量如數組等，不可作初始化賦值。&lt;br />&lt;br />&lt;span style="color:#ff0000;">二、外部變量外部變量的類型說明符為extern。&lt;/span>&lt;br />&lt;br />在前面介紹全局變量時已介紹過外部變量。這裡再補充說明外部變量的幾個特點：&lt;br />1. 外部變量和全局變量是對同一類變量的兩種不同角度的提法。全局變是是從它的作用域提出的，外部變量從它的存儲方式提出的，表示了它的生存期。&lt;br />&lt;br />2. 當一個源程序由若干個源文件組成時， 在一個源文件中定義的外部變量在其它的源文件中也有效。例如有一個源程序由源文件F1.C和F2.C組成： &lt;span style="color:#009900;">F1.C&lt;br />int a,b; /*外部變量定義*/&lt;br />char c; /*外部變量定義*/&lt;br />main()&lt;br />{ &lt;br />……&lt;br />}&lt;br />F2.C&lt;br />extern int a,b; /*外部變量說明*/&lt;br />extern char c; /*外部變量說明*/&lt;br />func (int x,y)&lt;br />{&lt;br />……&lt;br />}&lt;br />&lt;/span>在F1.C和F2.C兩個文件中都要使用a,b,c三個變量。在F1.C文件中把a,b,c都定義為外部變量。在F2.C文件中用extern把三個變量說明為外部變量，表示這些變量已在其它文件中定義，並把這些變量的類型和變量名，編譯系統不再為它們分配內存空間。 對構造類型的外部變量， 如數組等可以在說明時作初始化賦值，若不賦初值，則系統自動定義它們的初值為0。&lt;br />&lt;span style="color:#ff0000;">&lt;br />三、靜態變量&lt;/span>&lt;br />&lt;br />　　靜態變量的類型說明符是static。 靜態變量當然是屬於靜態存儲方式，但是屬於靜態存儲方式的量不一定就是靜態變量， 例如外部變量雖屬於靜態存儲方式，但不一定是靜態變量，必須由 static加以定義後才能成為靜態外部變量，或稱靜態全局變量。 對於自動變量，前面已經介紹它屬於動態存儲方式。 但是也可以用static定義它為靜態自動變量，或稱靜態局部變量，從而成為靜態存儲方式。&lt;br />由此看來， 一個變量可由static進行再說明，並改變其原有的存儲方式。&lt;br />&lt;br />1. 靜態局部變量&lt;br />　　在局部變量的說明前再加上static說明符就構成靜態局部變量。&lt;br />例如：&lt;br />static int a,b;&lt;br />static float array[5]={1,2,3,4,5}；&lt;br />　　&lt;br />　　靜態局部變量屬於靜態存儲方式，它具有以下特點：&lt;br />(1)靜態局部變量在函數內定義，但不象自動變量那樣，當調用時就存在，退出函數時就消失。靜態局部變量始終存在著，也就是說它的生存期為整個源程序。&lt;br />&lt;br />(2)靜態局部變量的生存期雖然為整個源程序，但是其作用域仍與自動變量相同，即只能在定義該變量的函數內使用該變量。退出該函數後， 儘管該變量還繼續存在，但不能使用它。&lt;br />&lt;br />(3)允許對構造類靜態局部量賦初值。在數組一章中，介紹數組初始化時已作過說明。若未賦以初值，則由系統自動賦以0值。&lt;br />&lt;br />(4)對基本類型的靜態局部變量若在說明時未賦以初值，則系統自動賦予0值。而對自動變量不賦初值，則其值是不定的。 根據靜態局部變量的特點， 可以看出它是一種生存期為整個源程序的量。雖然離開定義它的函數後不能使用，但如再次調用定義它的函數時，它又可繼續使用， 而且保存了前次被調用後留下的值。 因此，當多次調用一個函數且要求在調用之間保留某些變量的值時，可考慮採用靜態局部變量。雖然用全局變量也可以達到上述目的，但全局變量有時會造成意外的副作用，因此仍以採用局部靜態變量為宜。&lt;br />&lt;span style="color:#009900;">[例5.15]main()&lt;br />{&lt;br />int i;&lt;br />void f(); /*函數說明*/&lt;br />for(i=1;i&lt;=5;i++)&lt;br />f(); /*函數調用*/&lt;br />}&lt;br />void f() /*函數定義*/&lt;br />{&lt;br />auto int j=0;&lt;br />++j;&lt;br />printf("%d\n",j);&lt;br />}&lt;br />&lt;/span>　　程序中定義了函數f，其中的變量j 說明為自動變量並賦予初始值為0。當main中多次調用f時，j均賦初值為0，故每次輸出值均為1。現在把j改為靜態局部變量，程序如下：&lt;br />&lt;span style="color:#009900;">main()&lt;br />{&lt;br />int i;&lt;br />void f();&lt;br />for (i=1;i&lt;=5;i++)&lt;br />f();&lt;br />}&lt;br />void f()&lt;br />{&lt;br />static int j=0;&lt;br />++j;&lt;br />printf("%d\n",j);&lt;br />}&lt;br />void f()&lt;br />{&lt;br />static int j=0;&lt;br />++j;&lt;br />printf("%d/n",j);&lt;br />}&lt;/span>&lt;br />由於j為靜態變量，能在每次調用後保留其值並在下一次調用時繼續使用，所以輸出值成為累加的結果。讀者可自行分析其執行過程。&lt;br />&lt;br />2.靜態全局變量&lt;br />　　全局變量(外部變量)的說明之前再冠以static 就構成了靜態的全局變量。全局變量本身就是靜態存儲方式， 靜態全局變量當然也是靜態存儲方式。 這兩者在存儲方式上並無不同。這兩者的區別雖在於非靜態全局變量的作用域是整個源程序， 當一個源程序由多個源文件組成時，非靜態的全局變量在各個源文件中都是有效的。 而靜態全局變量則限制了其作用域， 即只在定義該變量的源文件內有效， 在同一源程序的其它源文件中不能使用它。由於靜態全局變量的作用域侷限於一個源文件內，只能為該源文件內的函數公用， 因此可以避免在其它源文件中引起錯誤。從以上分析可以看出， 把局部變量改變為靜態變量後是改變了它的存儲方式即改變了它的生存期。把全局變量改變為靜態變量後是改變了它的作用域， 限制了它&lt;br />的使用範圍。因此static 這個說明符在不同的地方所起的作用是不同的。應予以注意。&lt;br />&lt;br />&lt;span style="color:#ff0000;">四、寄存器變量&lt;/span>&lt;br />&lt;br />　　上述各類變量都存放在存儲器內， 因此當對一個變量頻繁讀寫時，必須要反覆訪問內存儲器，從而花費大量的存取時間。 為此，Ｃ語言提供了另一種變量，即寄存器變量。這種變量存放在CPU的寄存器中，使用時，不需要訪問內存，而直接從寄存器中讀寫， 這樣可提高效率。寄存器變量的說明符是register。 對於循環次數較多的循環控制變量及循環體內反覆使用的變量均可定義為寄存器變量。&lt;br />&lt;span style="color:#009900;">[例5.16]求∑200i=1imain()&lt;br />{&lt;br />register i,s=0;&lt;br />for(i=1;i&lt;=200;i++)&lt;br />s=s+i;&lt;br />printf("s=%d\n",s);&lt;br />}&lt;br />&lt;/span>本程序循環200次，i和s都將頻繁使用，因此可定義為寄存器變量。&lt;br />對寄存器變量還要說明以下幾點：&lt;br />&lt;br />1. 只有局部自動變量和形式參數才可以定義為寄存器變量。因為寄存器變量屬於動態存儲方式。凡需要採用靜態存儲方式的量不能定義為寄存器變量。&lt;br />&lt;br />2. 在Turbo C，MS C等微機上使用的Ｃ語言中， 實際上是把寄存器變量當成自動變量處理的。因此速度並不能提高。 而在程序中允許使用寄存器變量只是為了與標準C保持一致。3. 即使能真正使用寄存器變量的機器，由於CPU 中寄存器的個數是有限的，因此使用寄存器變量的個數也是有限的。&lt;br />&lt;br />&lt;span style="color:#ff0000;">內部函數和外部函數&lt;/span>&lt;br />&lt;br />　　函數一旦定義後就可被其它函數調用。 但當一個源程序由多個源文件組成時， 在一個源文件中定義的函數能否被其它源文件中的函數調用呢?為此，Ｃ語言又把函數分為兩類：&lt;br />&lt;br />一、內部函數&lt;br />&lt;br />　　如果在一個源文件中定義的函數只能被本文件中的函數調用，而不能被同一源程序其它文件中的函數調用， 這種函數稱為內部函 &lt;br />數。定義內部函數的一般形式是： static 類型說明符 函數名(形參表) 例如：&lt;br />static int f(int a,int b) 內部函數也稱為靜態函數。但此處靜態static 的含義已不是指存儲方式，而是指對函數的調用範圍只侷限於本文件。 因此在不同的源文件中定義同名的靜態函數不會引起混淆。&lt;br />&lt;br />二、外部函數&lt;br />　　外部函數在整個源程序中都有效，其定義的一般形式為： extern 類型說明符 函數名(形參表) 例如：&lt;br />extern int f(int a,int b)如在函數定義中沒有說明extern或static則隱含為extern。在一個源文件的函數中調用其它源文件中定義的外部函數時，應 用extern說明被調函數為外部函數。例如：&lt;br />&lt;span style="color:#009900;">F1.C (源文件一)&lt;br />main()&lt;br />{&lt;br />extern int f1(int i); /*外部函數說明，表示f1函&lt;br />數在其它源文件中*/&lt;br />……&lt;br />}&lt;br />F2.C (源文件二)&lt;br />extern int f1(int i); /*外部函數定義*/&lt;br />{&lt;br />……&lt;br />}&lt;br />&lt;/span>&lt;br />&lt;strong>&lt;span style="color:#cc0000;">本章小結&lt;/span>&lt;/strong>&lt;br />&lt;br />1. 函數的分類&lt;br />(1)庫函數：由C系統提供的函數；&lt;br />(2)用戶定義函數：由用戶自己定義的函數；&lt;br />(3)有返回值的函數向調用者返回函數值，應說明函數類型( 即返回值的類型 )；&lt;br />(4)無返回值的函數：不返回函數值，說明為空(void)類型；&lt;br />(5)有參函數：主調函數向被調函數傳送數據；&lt;br />(6)無參函數：主調函數與被調函數間無數據傳送；&lt;br />(7)內部函數：只能在本源文件中使用的函數；&lt;br />(8)外部函數：可在整個源程序中使用的函數。&lt;br />&lt;br />2. 函數定義的一般形式 &lt;br />[extern/static] 類型說明符 函數名([形參表]) 方括號內為可選項。&lt;br />&lt;br />3. 函數說明的一般形式 [extern] 類型說明符 函數名([形參表])； &lt;br />&lt;br />4. 函數調用的一般形式 函數名([實參表]) &lt;br />&lt;br />5. 函數的參數分為形參和實參兩種，形參出現在函數定義中，實參出現在函數調用中，發生函數調用時，將把實參的值傳送給形參。&lt;br />&lt;br />6. 函數的值是指函數的返回值，它是在函數中由return語句返回的。&lt;br />&lt;br />7. 數組名作為函數參數時不進行值傳送而進行地址傳送。形參和實參實際上為同一數組的兩個名稱。因此形參數組的值發生變化，實參數組的值當然也變化。&lt;br />&lt;br />8. Ｃ語言中，允許函數的嵌套調用和函數的遞歸調用。&lt;br />&lt;br />9. 可從三個方面對變量分類，即變量的數據類型，變量作用域和變量的存儲類型。在第二章中主要介紹變量的數據類型，本章中介紹了變量的作用域和變量的存儲類型。&lt;br />&lt;br />10.變量的作用域是指變量在程序中的有效範圍， 分為局部變量和全局變量。&lt;br />&lt;br />11.變量的存儲類型是指變量在內存中的存儲方式，分為靜態存儲和動態存儲，表示了變量的生存期。&lt;br />&lt;br />12.變量分類特性表存儲方式存儲類型說明符何處定義生存期作用域賦值前的值可賦初值類型動態存儲自動變量 auto 寄存器變量　register 函數或複合語句內被調用時在定義它的函數或複合語句內不定基本類型int或char外部變量extern函數之外整個源程序整個源程序靜態局部變量static 函數或複合語句內靜態全局變量static 函數之外整個源程序在定義它的函數或複合語句內在定義它的源文件內0任何類型&lt;br />&lt;/div><br>&lt;div>&lt;/div></p><div class=pgc-img><img alt=第五章:函數 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/2466a268-feac-46a2-9bfa-ea0a5723a32f><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>函數</a></li><li><a>第五章</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e087ca41.html alt=偏導數和函數的梯度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9d20a1e4cbff42a094d57df057fe9597 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e087ca41.html title=偏導數和函數的梯度>偏導數和函數的梯度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fc113b1.html alt=梯度原理：梯度在每一點上都指向函數增長最快的方向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cdb8db41d5024f38a2e490e66baebdb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fc113b1.html title=梯度原理：梯度在每一點上都指向函數增長最快的方向>梯度原理：梯度在每一點上都指向函數增長最快的方向</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/408d3387.html alt=EXCEL:VLOOKUP函數綜合運用，實現供應商每月數據自動查詢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/03e79d133c994f9f8a386b20b04b3da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/408d3387.html title=EXCEL:VLOOKUP函數綜合運用，實現供應商每月數據自動查詢>EXCEL:VLOOKUP函數綜合運用，實現供應商每月數據自動查詢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/526a98f3.html alt=Excel條件求和函數那麼多，高手一直都在用這一個，而你卻沒聽過 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b2fd76f54f9b46c8bd79500ba4dac2fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/526a98f3.html title=Excel條件求和函數那麼多，高手一直都在用這一個，而你卻沒聽過>Excel條件求和函數那麼多，高手一直都在用這一個，而你卻沒聽過</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2664a94c.html alt=excel中的DSUM函數——條件求和原來如此簡單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0dc7aeaa9b61467e86dbaeae6dfeaaa4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2664a94c.html title=excel中的DSUM函數——條件求和原來如此簡單>excel中的DSUM函數——條件求和原來如此簡單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48f18e97.html alt=excel常用函數用法解析第四篇——COLUMN、ROW函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4c3daf45857e4f169def37fc08d652fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48f18e97.html title=excel常用函數用法解析第四篇——COLUMN、ROW函數>excel常用函數用法解析第四篇——COLUMN、ROW函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b9de5637.html alt=比Sum函數好用10倍，它才是Excel求和函數中的NO.1 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d492e720108a4daf94a3411b6868bd6f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b9de5637.html title=比Sum函數好用10倍，它才是Excel求和函數中的NO.1>比Sum函數好用10倍，它才是Excel求和函數中的NO.1</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cc21918b.html alt=難點解析丨求一次函數中參數的值（6種解法） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f611ff11a88043ddb35b0ca455618731 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cc21918b.html title=難點解析丨求一次函數中參數的值（6種解法）>難點解析丨求一次函數中參數的值（6種解法）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9ed0ee97.html alt=邏輯函數中IF函數判斷是與不是，NOT函數對參數值求反 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4757b6dd22c84a46b4bfaa7ee6165d20 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9ed0ee97.html title=邏輯函數中IF函數判斷是與不是，NOT函數對參數值求反>邏輯函數中IF函數判斷是與不是，NOT函數對參數值求反</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75a5bee4.html alt=你不知道的階乘與gamma函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7d184211b19a4de18223836f70286b08 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75a5bee4.html title=你不知道的階乘與gamma函數>你不知道的階乘與gamma函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/23bfdd0e.html alt=11個函數，8種操作，詳述日期、時間的提取判定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5de047b4187246eb9f853770badb197c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/23bfdd0e.html title=11個函數，8種操作，詳述日期、時間的提取判定>11個函數，8種操作，詳述日期、時間的提取判定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6df935a0.html alt=Excel中最常用的函數公式——提取出生年月：TEXT+MID函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/de02ae9e43c0456fad1f5a53a8524523 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6df935a0.html title=Excel中最常用的函數公式——提取出生年月：TEXT+MID函數>Excel中最常用的函數公式——提取出生年月：TEXT+MID函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a1acbc3.html alt=Excel函數太麻煩？提升效率，教你輕鬆提取表格內的日期信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/19ba957bdbb24f7697e357b7c31479aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a1acbc3.html title=Excel函數太麻煩？提升效率，教你輕鬆提取表格內的日期信息>Excel函數太麻煩？提升效率，教你輕鬆提取表格內的日期信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c74e6564.html alt=Excel如何用函數公式提取每天第一次和最後一次打卡時間？你會嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/84768c3ad5c247d9be13da82c67c843b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c74e6564.html title=Excel如何用函數公式提取每天第一次和最後一次打卡時間？你會嗎>Excel如何用函數公式提取每天第一次和最後一次打卡時間？你會嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9488a431.html alt=Excel日期與時間函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1835b57460704e35bc048fe6340e5f41 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9488a431.html title=Excel日期與時間函數>Excel日期與時間函數</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>