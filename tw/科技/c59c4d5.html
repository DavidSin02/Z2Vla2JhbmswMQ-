<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux kernel的中斷子系統之（一）：綜述 | 极客快訊</title><meta property="og:title" content="Linux kernel的中斷子系統之（一）：綜述 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/02dc0d76247f44929c552cb097f9e3a0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c59c4d5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c59c4d5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c59c4d5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c59c4d5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c59c4d5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c59c4d5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c59c4d5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c59c4d5.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="Linux kernel的中斷子系統之（一）：綜述"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c59c4d5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux kernel的中斷子系統之（一）：綜述</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>一、前言</h1><p>一個合格的linux驅動工程師需要對kernel中的中斷子系統有深刻的理解，只有這樣，在寫具體driver的時候才能：</p><p>1、正確的使用linux kernel提供的的API，例如最著名request_threaded_irq（request_irq）接口</p><p>2、正確使用同步機制保護驅動代碼中的臨界區</p><p>3、正確的使用kernel提供的softirq、tasklet、workqueue等機制來完成具體的中斷處理</p><p>基於上面的原因，我希望能夠通過一系列的文檔來描述清楚linux kernel中的中斷子系統方方面面的知識。一方面是整理自己的思緒，另外一方面，希望能夠對其他的驅動工程師（或者想從事linux驅動工作的工程師）有所幫助。</p><h1>二、中斷系統相關硬件描述</h1><p>中斷硬件系統主要有三種器件參與，各個外設、中斷控制器和CPU。各個外設提供irq request line，在發生中斷事件的時候，通過irq request line上的電氣信號向CPU系統請求處理。外設的irq request line太多，CPU需要一個小夥伴幫他，這就是Interrupt controller。Interrupt Controller是連接外設中斷系統和CPU系統的橋樑。根據外設irq request line的多少，Interrupt Controller可以級聯。CPU的主要功能是運算，因此CPU並不處理中斷優先級，那是Interrupt controller的事情。對於CPU而言，一般有兩種中斷請求，例如：對於ARM，是IRQ和FIQ信號線，分別讓ARM進入IRQ mode和FIQ mode。對於X86，有可屏蔽中斷和不可屏蔽中斷。</p><p>本章節不是描述具體的硬件，而是使用了HW block這樣的概念。例如CPU HW block是隻ARM core或者X86這樣的實際硬件block的一個邏輯描述，實際中，可能是任何可能的CPU block。</p><h1>1、HW中斷系統的邏輯block圖</h1><p>我對HW中斷系統之邏輯block diagram的理解如下圖所示：</p><div class=pgc-img><img alt="Linux kernel的中斷子系統之（一）：綜述" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/02dc0d76247f44929c552cb097f9e3a0><p class=pgc-img-caption></p></div><p>系統中有若干個CPU block用來接收中斷事件並進行處理，若干個Interrupt controller形成樹狀的結構，彙集系統中所有外設的irq request line，並將中斷事件分發給某一個CPU block進行處理。從接口層面看，主要有兩類接口，一種是中斷接口。有的實現中，具體中斷接口的形態就是一個硬件的信號線，通過電平信號傳遞中斷事件（ARM以及GIC組成的中斷系統就是這麼設計的）。有些系統採用了其他的方法來傳遞中斷事件，比如x86＋APIC（Advanced Programmable Interrupt Controller）組成的系統，每個x86的核有一個Local APIC，這些Local APIC們通過ICC（Interrupt Controller Communication）bus連接到IO APIC上。IO APIC收集各個外設的中斷，並翻譯成總線上的message，傳遞給某個CPU上的Local APIC。因此，上面的紅色線條也是邏輯層面的中斷信號，可能是實際的PCB上的銅線（或者SOC內部的銅線），也可能是一個message而已。除了中斷接口，CPU和Interrupt Controller之間還需要有控制信息的交流。Interrupt Controller會開放一些寄存器讓CPU訪問、控制。</p><h1>2、多個Interrupt controller和多個cpu之間的拓撲結構</h1><p>Interrupt controller有的是支持多個CPU core的（例如GIC、APIC等），有的不支持（例如S3C2410的中斷控制器，X86平臺的PIC等）。如果硬件平臺中只有一個GIC的話，那麼通過控制該GIC的寄存器可以將所有的外設中斷，分發給連接在該interrupt controller上的CPU。如果有多個GIC呢（或者級聯的interrupt controller都支持multi cpu core）？假設我們要設計一個非常複雜的系統，系統中有8個CPU，有2000個外設中斷要處理，這時候你如何設計系統中的interrupt controller？如果使用GIC的話，我們需要兩個GIC（一個GIC最多支持1024箇中斷源），一個是root GIC，另外一個是secondary GIC。這時候，你有兩種方案：</p><p>（1）把8個cpu都連接到root GIC上，secondary GIC不接CPU。這時候原本掛接在secondary GIC的外設中斷會輸出到某個cpu，現在，只能是（通過某個cpu interface的irq signal）輸到root GIC的某個SPI上。對於軟件而言，這是一個比較簡單的設計，secondary GIC的cpu interface的設定是固定不變的，永遠是從一個固定的CPU interface輸出到root GIC。這種方案的壞處是：這時候secondary GIC的PPI和SGI都是沒有用的了。此外，在這種設定下，所有連接在secondary GIC上的外設中斷要送達的target CPU是統一處理的，要麼送去cpu0，要麼cpu 5，不能單獨控制。</p><p>（2）當然，你也可以讓每個GIC分別連接4個CPU core，root GIC連接CPU0~CPU3，secondary GIC連接CPU4~CPU7。這種狀態下，連接在root GIC的中斷可以由CPU0~CPU3分擔處理，連接在secondary GIC的中斷可以由CPU4~CPU7分擔處理。但這樣，在中斷處理方面看起來就體現不出8核的威力了。</p><p>注：上一節中的邏輯block示意圖採用的就是方案一。</p><h1>3、Interrupt controller把中斷事件送給哪個CPU？</h1><p>毫無疑問，只有支持multi cpu core的中斷控制器才有這種幸福的煩惱。一般而言，中斷控制器可以把中斷事件上報給一個CPU或者一組CPU（包括廣播到所有的CPU上去）。對於外設類型的中斷，當然是送到一個cpu上就OK了，我看不出來要把這樣的中斷送給多個CPU進行處理的必要性。如果送達了多個cpu，實際上，也應該只有一個handler實際和外設進行交互，另外一個cpu上的handler的動作應該是這樣的：發現該irq number對應的中斷已經被另外一個cpu處理了，直接退出handler，返回中斷現場。IPI的中斷不存在這個限制，IPI更像一個CPU之間通信的機制，對這種中斷廣播應該是毫無壓力。</p><p>實際上，從用戶的角度看，其需求是相當複雜的，我們的目標可能包括：</p><p>（1）讓某個IRQ number的中斷由某個特定的CPU處理</p><p>（2）讓某個特定的中斷由幾個CPU輪流處理</p><p>……</p><p>當然，具體的需求可能更加複雜，但是如何區分軟件和硬件的分工呢？讓硬件處理那麼複雜的策略其實是不合理的，複雜的邏輯如果由硬件實現，那麼就意味著更多的晶體管，更多的功耗。因此，最普通的做法就是為Interrupt Controller支持的每一箇中斷設定一個target cpu的控制接口（當然應該是以寄存器形式出現，對於GIC，這個寄存器就是Interrupt processor target register）。系統有多個cpu，這個控制接口就有多少個bit，每個bit代表一個CPU。如果該bit設定為1，那麼該interrupt就上報給該CPU，如果為0，則不上報給該CPU。這樣的硬件邏輯比較簡單，剩餘的控制內容就交給軟件好了。例如如果系統有兩個cpu core，某中斷想輪流由兩個CPU處理。那麼當CPU0相應該中斷進入interrupt handler的時候，可以將Interrupt processor target register中本CPU對應的bit設定為0，另外一個CPU的bit設定為1。這樣，在下次中斷髮生的時候，interupt controller就把中斷送給了CPU1。對於CPU1而言，在執行該中斷的handler的時候，將Interrupt processor target register中CPU0的bit為設置為1，disable本CPU的比特位，這樣在下次中斷髮生的時候，interupt controller就把中斷送給了CPU0。這樣軟件控制的結果就是實現了特定中斷由2個CPU輪流處理的算法。</p><h1>4、更多的思考</h1><p>面對這個HW中斷系統之邏輯block diagram，我們其實可以提出更多的問題：</p><p>（1）中斷控制器發送給CPU的中斷是否可以收回？重新分發給另外一個CPU？</p><p>（2）系統中的中斷如何分發才能獲得更好的性能呢？</p><p>（3）中斷分發的策略需要考慮哪些因素呢？</p><p>……</p><p>很多問題其實我也沒有答案，慢慢思考，慢慢逼近真相吧。</p><h1>二、中斷子系統相關的軟件框架</h1><p>linux kernel的中斷子系統相關的軟件框架圖如下所示：</p><p>由上面的block圖，我們可知linux kernel的中斷子系統分成4個部分：</p><div class=pgc-img><img alt="Linux kernel的中斷子系統之（一）：綜述" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0e7345e8363c4184961deb327e8752a6><p class=pgc-img-caption></p></div><p>（1）硬件無關的代碼，我們稱之Linux kernel通用中斷處理模塊。無論是哪種CPU，哪種controller，其中斷處理的過程都有一些相同的內容，這些相同的內容被抽象出來，和HW無關。此外，各個外設的驅動代碼中，也希望能用一個統一的接口實現irq相關的管理（不和具體的中斷硬件系統以及CPU體系結構相關）這些“通用”的代碼組成了linux kernel interrupt subsystem的核心部分。</p><p>（2）CPU architecture相關的中斷處理。 和系統使用的具體的CPU architecture相關。</p><p>（3）Interrupt controller驅動代碼 。和系統使用的Interrupt controller相關。</p><h1>三、中斷子系統文檔規劃</h1><p>中斷相關的文檔規劃如下：</p><p>1、linux kernel的中斷子系統之（一），也就是本文，其實是一個導論，沒有實際的內容，主要是給讀者一個大概的軟硬件框架。</p><p>2、linux kernel的中斷子系統之（二）：irq domain介紹。主要描述如何將一個HW interrupt ID轉換成IRQ number。</p><p>3、linux kernel的中斷子系統之（三）：IRQ number和中斷描述符。主要描述中斷描述符相關的數據結構和接口API。</p><p>4、linux kernel的中斷子系統之（四）：high level irq event handler。</p><p>5、linux kernel的中斷子系統之（五）：driver API。主要以一個普通的驅動程序為視角，看待linux interrupt subsystem提供的API，如何利用這些API，分配資源，是否資源，如何處理中斷相關的同步問題等等。</p><p>6、linux kernel的中斷子系統之（六）：ARM中斷處理過程，這份文檔以ARM CPU為例，描述ARM相關的中斷處理過程</p><p>7、linux kernel的中斷子系統之（七）：GIC代碼分析，這份文檔是以一個具體的interrupt controller為例，描述irq chip driver的代碼構成情況。</p><p>8、linux kernel的中斷子系統之（八）：softirq</p><p>9、linux kernel的中斷子系統之（九）：tasklet</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>kernel</a></li><li><a>中斷子</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/907ac78.html alt="Linux kernel中常見的宏整理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/907ac78.html title="Linux kernel中常見的宏整理">Linux kernel中常見的宏整理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html alt=Linux系統常用命令大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html title=Linux系統常用命令大全>Linux系統常用命令大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47743f68.html alt=嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/44355de4180a4af4beeda86cd1696601 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47743f68.html title=嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》>嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2f8e01a.html alt="Linux C 字符串函數 sprintf()、snprintf() 詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2f8e01a.html title="Linux C 字符串函數 sprintf()、snprintf() 詳解">Linux C 字符串函數 sprintf()、snprintf() 詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html alt=Linux高級網絡編程篇-UDP丟包問題總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html title=Linux高級網絡編程篇-UDP丟包問題總結>Linux高級網絡編程篇-UDP丟包問題總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>