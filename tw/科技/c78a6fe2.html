<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>HashMap的底層實現 | 极客快訊</title><meta property="og:title" content="HashMap的底層實現 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><meta property="article:published_time" content="2020-11-14T21:07:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:42+08:00"><meta name=Keywords content><meta name=description content="HashMap的底層實現"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c78a6fe2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>HashMap的底層實現</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><ol start=1><li>存儲結構</li></ol><ul><li>Node[]為哈希桶數組，本質是鍵值對映射，當鏈表長度大於8時，採用紅黑樹存儲，TreeNode表示一個節點；</li><li>HashMap是基於哈希表存儲，HashMap採用鏈地址法解決hash衝突；</li></ul><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc><p class=pgc-img-caption></p></div><ol start=2><li>元素查找（index）</li></ol><ul><li>步驟：取key的hashCode：任意給定的對象，進行多次hashCode()返回值相同高位運算：取高16位取模運算：對數組長度取模；</li></ul><p><span style="color:#a50;--tt-darkmode-color: #AA5500">//方法一：</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">static</span> <span style="color:#708;--tt-darkmode-color: #E844FF">final</span> int hash(Object key) { <span style="color:#a50;--tt-darkmode-color: #AA5500">//jdk1.8 & jdk1.7</span><br>int h;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// h = key.hashCode() 為第一步 取hashCode值</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">// h ^ (h >>> 16) 為第二步 高位參與運算</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> (key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span> 0 : (h <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> key.hashCode()) ^ (h <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>>></span> 16);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//方法二：</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">static</span> int indexFor(int h, int length) { <span style="color:#a50;--tt-darkmode-color: #AA5500">//jdk1.7的源碼，jdk1.8沒有這個方法，但是實現原理一樣的</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> h <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> (length<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span>1); <span style="color:#a50;--tt-darkmode-color: #AA5500">//第三步 取模運算</span><br>}</p><ul><li>示例，n為table的長度：</li></ul><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee4a0cff50e54acd92665f89259ea33d><p class=pgc-img-caption></p></div><ol start=3><li>元素存放（put）</li></ol><ul><li>步驟：</li></ul><p>①.判斷鍵值對數組table[i]是否為空或為null，否則執行resize()進行擴容；</p><p>②.根據鍵值key計算hash值得到插入的數組索引i，如果table[i]==null，直接新建節點添加，轉向⑥，如果table[i]不為空，轉向③；</p><p>③.判斷table[i]的首個元素是否和key一樣，如果相同直接覆蓋value，否則轉向④，這裡的相同指的是hashCode以及equals；</p><p>④.判斷table[i] 是否為treeNode，即table[i] 是否是紅黑樹，如果是紅黑樹，則直接在樹中插入鍵值對，否則轉向⑤；</p><p>⑤.遍歷table[i]，判斷鏈表長度是否大於8，大於8的話把鏈表轉換為紅黑樹，在紅黑樹中執行插入操作，否則進行鏈表的插入操作；遍歷過程中若發現key已經存在直接覆蓋value即可；</p><p>⑥.插入成功後，判斷實際存在的鍵值對數量size是否超多了最大容量threshold，如果超過，進行擴容 ；</p><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9a960cee3d7b44c2b63403a0769a708c><p class=pgc-img-caption></p></div><p><span style="color:#708;--tt-darkmode-color: #E844FF">public</span> V put(K key, V value) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 對key的hashCode()做hash</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> putVal(hash(key), key, value, false, true);<br>}<br><br><span style="color:#708;--tt-darkmode-color: #E844FF">final</span> V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>boolean evict) {<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] tab; Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> p; int n, i;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步驟①：tab為空則創建</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((tab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> table) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> (n <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> tab.length) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0)<br>n <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (tab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> resize()).length;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步驟②：計算index，並對null做處理</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((p <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> tab[i <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (n <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span> 1) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> hash]) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>tab[i] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newNode(hash, key, value, null);<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> {<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> e; K k;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步驟③：節點key存在，直接覆蓋value</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (p.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>((k <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> p.key) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> (key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> key.equals(k))))<br>e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> p;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步驟④：判斷該鏈為紅黑樹</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (p <span style="color:#708;--tt-darkmode-color: #E844FF">instanceof</span> TreeNode)<br>e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> ((TreeNode<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>)p).putTreeVal(<span style="color:#708;--tt-darkmode-color: #E844FF">this</span>, tab, hash, key, value);<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步驟⑤：該鏈為鏈表</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> {<br><span style="color:#708;--tt-darkmode-color: #E844FF">for</span> (int binCount <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> 0; ; <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>binCount) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> p.next) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null) {<br>p.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newNode(hash, key,value,null);<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//鏈表長度大於8轉換為紅黑樹進行處理</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (binCount <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> TREEIFY_THRESHOLD <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span> 1) <span style="color:#a50;--tt-darkmode-color: #AA5500">// -1 for 1st</span><br>treeifyBin(tab, hash);<br><span style="color:#708;--tt-darkmode-color: #E844FF">break</span>;<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// key已經存在直接覆蓋value</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>((k <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e.key) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> (key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> key.equals(k)))) <span style="color:#708;--tt-darkmode-color: #E844FF">break</span>;<br>p <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>}<br>}<br><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) { <span style="color:#a50;--tt-darkmode-color: #AA5500">// existing mapping for key</span><br>V oldValue <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e.value;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!</span>onlyIfAbsent <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> oldValue <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>e.value <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> value;<br>afterNodeAccess(e);<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> oldValue;<br>}<br><br><span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>modCount;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步驟⑥：超過最大容量 就擴容</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>size <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> threshold)<br>resize();<br>afterNodeInsertion(evict);<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> null;<br>}</p><ol start=4><li>擴容機制（resize）</li></ol><ul><li>步驟：</li></ul><p>1）擴容數組：如果超過了數組的最大容量，那麼就直接將閾值設置為整數最大值，然後如果沒有超過，那就擴容為原來的2倍；</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">//第一部分：擴容</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> MAXIMUM_CAPACITY) {<br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> Integer.MAX_VALUE;<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> oldTab;<br>}<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> DEFAULT_INITIAL_CAPACITY)<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1; <span style="color:#a50;--tt-darkmode-color: #AA5500">// double threshold</span><br>}</p><p>2）設置閾值：第一個else if表示如果閾值已經初始化過了，那就直接使用舊的閾值，然後第二個else表示如果沒有初始化，那就初始化一個新的數組容量和新的閾值；</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">//第二部分：設置閾值</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) <span style="color:#a50;--tt-darkmode-color: #AA5500">//閾值已經初始化了，就直接使用</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> { <span style="color:#a50;--tt-darkmode-color: #AA5500">// 沒有初始化閾值那就初始化一個默認的容量和閾值</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> DEFAULT_INITIAL_CAPACITY;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (int)(DEFAULT_LOAD_FACTOR <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> DEFAULT_INITIAL_CAPACITY);<br>}<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">float</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> loadFactor;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span><br>(int)ft : Integer.MAX_VALUE);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//為當前的容量閾值賦值</span><br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newThr;<br><span style="color:#555;--tt-darkmode-color: #555555">@SuppressWarnings</span>({<span style="color:#a11;--tt-darkmode-color: #E92727">"rawtypes"</span>,<span style="color:#a11;--tt-darkmode-color: #E92727">"unchecked"</span>})<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] newTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[])<span style="color:#708;--tt-darkmode-color: #E844FF">new</span> Node[newCap];<br>table <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newTab;</p><p>3）將舊數據複製到新數組裡面，設計rehash過程（詳情見3））：</p><p>A：擴容後，若hash值新增參與運算的位=0，那麼元素在擴容後的位置=原始位置</p><p>B：擴容後，若hash值新增參與運算的位=1，那麼元素在擴容後的位置=原始位置+擴容後的舊位置；</p><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0c11e6ed68be4f518da773500a05d14a><p class=pgc-img-caption></p></div><p><span style="color:#708;--tt-darkmode-color: #E844FF">final</span> Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] resize() {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//先將老的Table取別名，這樣利於後面的操作。</span><br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] oldTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> table;<br>int oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (oldTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span> 0 : oldTab.length;<br>int oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> threshold;<br>int newCap, newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> 0;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示之前的數組容量不為空。</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 如果 此時的數組容量大於最大值</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> MAXIMUM_CAPACITY) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 擴容 闕值為 Int類型的最大值，這種情況很少出現</span><br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> Integer.MAX_VALUE;<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> oldTab;<br>}<br><br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示 old數組的長度沒有那麼大，進行擴容，兩倍（這裡也是有講究的）對闕值也進行擴容</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> DEFAULT_INITIAL_CAPACITY)<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1; <span style="color:#a50;--tt-darkmode-color: #AA5500">// double threshold</span><br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示之前的容量是0 但是之前的闕值卻大於零， 此時新的hash表長度等於此時的闕值</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) <span style="color:#a50;--tt-darkmode-color: #AA5500">// initial capacity was placed in threshold</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> { <span style="color:#a50;--tt-darkmode-color: #AA5500">// zero initial threshold signifies using defaults</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示是初始化時候，採用默認的 數組長度* 負載因子</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> DEFAULT_INITIAL_CAPACITY;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (int)(DEFAULT_LOAD_FACTOR <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> DEFAULT_INITIAL_CAPACITY);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//此時表示若新的闕值為0 就得用 新容量* 加載因子重新進行計算。</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">float</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> loadFactor;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span><br>(int)ft : Integer.MAX_VALUE);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 開始對新的hash表進行相對應的操作。</span><br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newThr;<br><span style="color:#555;--tt-darkmode-color: #555555">@SuppressWarnings</span>({<span style="color:#a11;--tt-darkmode-color: #E92727">"rawtypes"</span>,<span style="color:#a11;--tt-darkmode-color: #E92727">"unchecked"</span>})<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] newTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[])<span style="color:#708;--tt-darkmode-color: #E844FF">new</span> Node[newCap];<br>table <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newTab;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//遍歷舊的hash表，將之內的元素移到新的hash表中。</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">for</span> (int j <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> 0; j <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> oldCap<span style="color:#a50;--tt-darkmode-color: #AA5500">/***此時舊的hash表的闕值*/</span>; <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>j) {<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldTab[j]) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示這個格子不為空</span><br>oldTab[j] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 表示當前只有一個元素，重新做hash散列並賦值計算。</span><br>newTab[e.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> (newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span> 1)] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e <span style="color:#708;--tt-darkmode-color: #E844FF">instanceof</span> TreeNode)<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 如果在舊哈希表中，這個位置是樹形的</span><span style="color:#a50;--tt-darkmode-color: #AA5500">結果</span><span style="color:#a50;--tt-darkmode-color: #AA5500">，就要把新hash表中也變成樹形結構，</span><br>((TreeNode<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>)e).split(<span style="color:#708;--tt-darkmode-color: #E844FF">this</span>, newTab, j, oldCap);<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> { <span style="color:#a50;--tt-darkmode-color: #AA5500">// preserve order</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">//保留 舊hash表中是鏈表的順序</span><br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> loHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null, loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> hiHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null, hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> next;<br><span style="color:#708;--tt-darkmode-color: #E844FF">do</span> {<span style="color:#a50;--tt-darkmode-color: #AA5500">// 遍歷當前Table內的Node 賦值給新的Table。</span><br>next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e.next;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((e.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> oldCap) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>loHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span><br>loTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引+oldCap</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>hiHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span><br>hiTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>}<br>} <span style="color:#708;--tt-darkmode-color: #E844FF">while</span> ((e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> next) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null);<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引放到bucket裡面</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br>loTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>newTab[j] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> loHead;<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引+oldCap 放到bucket裡面</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br>hiTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>newTab[j <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">+</span> oldCap] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> hiHead;<br>}<br>}<br>}<br>}<br>}<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> newTab;<br>}</p><ul><li>示例：假設哈希桶數組長度為2，依次插入key為5、7、3，負載因子為1：</li></ul><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00a8f9a0f9df4b398867dd0184a29f3d><p class=pgc-img-caption></p></div><ul><li>JDK1.8對rehash的優化</li></ul><p>1）n為table的長度，圖（a）表示擴容前的key1和key2兩種key確定索引位置的示例，圖（b）表示擴容後key1和key2兩種key確定索引位置的示例，其中hash1是key1對應的哈希與高位運算結果，key2元素在重新計算hash之後，因為n變為2倍，那麼n-1的mask範圍在高位多1bit(紅色)，因此新的index就會發生這樣的變化；</p><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7fa355e394d2429383b8b18ec6a17998><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/456194205a8345f8a492ea74c822c021><p class=pgc-img-caption></p></div><p>2）JDK1.8擴充HashMap的時候，<strong>不需要像JDK1.7的實現那樣重新計算hash</strong>，只需要看看原來的hash值新增的那個bit是1還是0就好了，是0的話索引沒變，是1的話索引變成“原索引+oldCap”，可以看看下圖為16擴充為32的resize示意圖：</p><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2e470e8a163e4fc8aca55283b5c7e620><p class=pgc-img-caption></p></div><ul><li>解決hash衝突的方法開放</li></ul><p>1）地址法</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">#H(key)為哈希函數，m為哈希表表長，di為增量序列，i為已發生衝突的次數</span><br>Hi <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (H(key) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">+</span> di) MOD m，其中i<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span>1,2,…,k(k&lt;<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span>m-1)</p><p>A：線性探查法（Linear Probing）：di = 1,2,3,…,m-1</p><p>B：平方探測法（Quadratic Probing）：di = ±12, ±22，±32，…，±k2（k≤m/2）</p><p>C：偽隨機探測法：di = 偽隨機數序列</p><p>2）再哈希法</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">#RHi()函數是不同於H()的哈希函數，用於同義詞發生地址衝突時，計算出另一個哈希函數地址，直到不發生衝突位置；</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">#這種方法不容易產生</span><span style="color:#a50;--tt-darkmode-color: #AA5500">堆集</span><span style="color:#a50;--tt-darkmode-color: #AA5500">，但是會增加計算時間</span><br>Hi <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> RHi(key), 其中i<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span>1,2,…,k</p><p>3）建立公共溢出區</p><p>假設哈希函數的值域為[0, m-1]，設向量HashTable[0,…,m-1]為基本表，每個分量存放一個記錄，另外還設置了向量OverTable[0,…,v]為溢出表。基本表中存儲的是關鍵字的記錄，一旦發生衝突，不管他們哈希函數得到的哈希地址是什麼，都填入溢出表；缺點：查找衝突數據的時候，需要遍歷溢出表才能得到數據；</p><p>4）<strong>鏈地址法（拉鍊法）</strong></p><p>將衝突位置的元素構造成鏈表；在添加數據的時候，如果哈希地址與哈希表上的元素衝突，就放在這個位置的鏈表上；優點：平均查找長度較短、適合造表前無法確定表長的情況、刪除結點操作易於實現；缺點：需要額外的存儲空間；</p><ul><li>HashMap的加載因子為什麼是0.75</li></ul><p>1）衝突：填充程度高，空間利用率高，但是哈希衝突頻繁；填充程度低，衝突發生率減少，但是空間利用率不高；加載因子表示Hash表的元素填充程度；</p><p>2）泊松分佈：描述單位時間內隨機事件發生的次數的概率分佈；</p><p>3）在理想情況下，使用隨機哈希碼，在擴容閾值（加載因子）為0.75的情況下，節點出現在頻率在Hash桶（表）中遵循參數平均為0.5的泊松分佈；當一個Node中的鏈表長度達到8個元素的時候，概率為0.00000006，幾乎是一個不可能事件；</p><p>4）加載因子是特別重要因素，應嚴格限制在0.7-0.8以下。超過0.8，查表時的CPU緩存不命中（cache missing）按照指數曲線上升；</p><ul><li>為什麼HashMap的長度是2的整數次冪</li></ul><p>①加快哈希計算</p><p>&lt;1>為了找打key的位置，需要進行hash(key)%length操作，但是%計算比&慢很多；</p><p>&lt;2>使用&代替%有兩個條件：求&的length比%的length要減一，即hash(KEY) & (length - 1)、length需要為2的整數次冪；</p><p>&lt;3>根據&計算方法，元素哈希值不變；而通過 % 計算的方式會因為 length 的變化導致計算出來的 hash 桶的位置不斷變化，數據一致在漂移，影響性能</p><p>②減少衝突</p><p>&lt;1>length 為偶數時，length-1 為奇數，奇數的二進制最後一位是 1，這樣便保證了 hash &(length-1) 的最後一位可能為 0，也可能為 1，即 & 運算後的結果可能為偶數，也可能為奇數，這樣便可以保證散列的均勻性；</p><p>&lt;2>length 為奇數時，length-1 為偶數，它的最後一位是 0，這樣 hash & (length-1) 的最後一位肯定為 0，即只能為偶數，這樣任何 hash 值都只會被散列到數組的偶數下標位置上，這浪費了近一半的空間；</p><ul><li>JDK8對HshMap的優化</li></ul><p>1）鏈表的長度超過了8，那麼鏈表將轉換為紅黑樹（桶的數量必須大於64，小於64的時候只會擴容）；</p><p>2）發生hash碰撞時，java 1.7會在鏈表的頭部插入，而java 1.8會在鏈表的尾部插入；</p><p>3）java 1.7的Entry被java 1.8的Node替代；</p><p>4）在插入時，java 1.7先判斷是否需要擴容，再插入，java 1.8先進行插入，插入完成再判斷是否需要擴容；</p><ul><li>JDK1.7頭插法擴容的問題</li></ul><p>1）頭插法會使鏈表發生反轉，多線程環境下會產生環；</p><p>2）A線程在插入節點B，B線程也在插入，遇到容量不夠開始擴容，重新hash，放置元素，採用頭插法，後遍歷到的B節點放入了頭部，這樣形成了環；</p><div class=pgc-img><img alt=HashMap的底層實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa1439011e074207b97cee38fc89bc88><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>HashMap</a></li><li><a>底層</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3dd6ded.html alt=深入解析HashMap實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49faff220ef84a3787f9b9e0836f857c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3dd6ded.html title=深入解析HashMap實現原理>深入解析HashMap實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html alt=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/470f515e8fe44c6184b07227fdb51333 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html title=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）>《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html alt="廣西鐵路出海大通道 全面實現電氣化運營" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html title="廣西鐵路出海大通道 全面實現電氣化運營">廣西鐵路出海大通道 全面實現電氣化運營</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html alt="為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6cbd09e4427c44c082e15ec40e24b6f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html title="為什麼 HashMap 的加載因子是0.75？">為什麼 HashMap 的加載因子是0.75？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>