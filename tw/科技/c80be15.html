<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從封裝變化的角度看設計模式——對象創建 | 极客快訊</title><meta property="og:title" content="從封裝變化的角度看設計模式——對象創建 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c80be15.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c80be15.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c80be15.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c80be15.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c80be15.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c80be15.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c80be15.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c80be15.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="從封裝變化的角度看設計模式——對象創建"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c80be15.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從封裝變化的角度看設計模式——對象創建</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=pgc-h-arrow-right>封裝變化之對象創建</h2><p>在對象創建的過程中，經常會出現的一個問題就是通過顯示地指定一個類來創建對象，從而導致緊耦合。這是因為創建對象時指定類名將使你受特定實現的約束而不是特定接口的約束。這會使未來的變化更加複雜。要避免這種情況，就應該間接地創建對象。</p><p>這種緊耦合的問題很大程度是由new關鍵字帶來的，由於new的緊耦合出現，使得緊耦合的類很難獨立地被複用，因為它們之間是相互依賴的。並且緊耦合產生單塊的系統，要改變或者刪掉一個類，就必須要理解和改變其他許多類。這也是導致系統難以維護和移植的一個重要原因。</p><p>所以可以通過“對象創建”模式繞開new，從而避免在對象創建（new）過程中所導致的緊耦合（依賴具體的類），以此支持對象創建的穩定。</p><p>那麼如何避免new呢？舉個例子！</p><pre><code>    public void fun1(){        //...        Product p = new Product(); //改為：Product p = productFactory.createProduct();        //...    }</code></pre><p>這樣的方式就是通過一個工廠調用一個方法來創建相應的產品，但是可能大家又會產生一個問題，這樣操作雖然解決了Product的new操作，但是對於ProductFactory而言不是也需要通過new來產生嗎？</p><p>對於這個問題，我想是很多人在接觸到設計模式的時候都會去思考的問題，既然ProductFactory還是要用到new，那工廠類還有存在的必要嗎？這時，我們可以會想到兩種解決方式，一是將createProdyct()方法寫成靜態方法，這樣調用的時候自然不需要new了。二是通過注入的方式，比如在應用類當中通過setter或是構造方法傳入一個工廠類的對象。</p><p>對於靜態方法而言，簡單地說，即使是使用靜態方法，那Product p = ProductFactory.createProduct()這樣依然是一種緊耦合的方式，因為工廠類無法替換，和直接new出產品區別不大。</p><p>對於注入方式，大家更多的是疑惑，既然可以傳入一個工廠類對象，那為什麼不直接傳入相應的產品，不是更簡單直接嗎？當然不是的，首先需要明白的是，工廠類的作用是作為一個籠子，這個籠子需要幫助我們束縛住 ‘未來的變化’ ，要知道一個產品的變化可能總是大於工廠的變化。在這種情況下，舉出一個最簡單的例子，你在編碼的過程中，可能會用到不只一個產品，那你就可能需要很多setter或者修改構造方法；但是如果這些產品都可以通過這個工廠來獲取，是不是就相當於用籠子關住了變化，使其在一個範圍中跳動。</p><p>在學習設計模式時，永遠要記住的一句話就是“設計模式是用來教會我們如何應對未來可能的變化”。如果你能夠確定自己的系統未來沒有變化，那自然用不到設計模式；或者你的系統未來全是變化，那也用不到設計模式，設計模式做的就是隔離穩定與變化，如果沒有穩定，那就用不到設計模式。</p><p>‘new’是一種硬編碼，究竟 ’硬‘ 在那裡，同樣一個簡單的理由，如果未來構造方法發生變化或者說構造參數增加（減少），而在源碼中有很多地方都是通過new來獲取實例對象，找到並修改源碼將會是一項很大的工作。</p><p>在解決這樣的 “對象創建” 問題中就有工廠方法、抽象工廠、原型模式和建造者模式等相關設計模式。</p><h2 class=pgc-h-arrow-right>工廠方法（Factory Method)</h2><ol start=1><li><strong>意圖</strong>定義一個用於創建對象的接口，讓子類決定實例化哪一個類。FactoryMethod使得一個類的實例化延遲到其子類。</li><li><strong>實例</strong>Factory Method相對於簡單工廠而言，完全遵循了“不改代碼”的原則，但是其使用情形相比抽象工廠使用條件沒有那麼高，因此可以說是使用最多的創建型模式之一了。考慮這樣一個應用，它可以向用戶顯示多種文檔，比如word、pdf、txt等等。在這個框架中，首先，想到的可能就是應用簡單工廠模式。public interface Document{ public void open(); public void close(); public void save(); // ...... } public class PdfDocument implements Document{ @Override public void open(){ //open pdfDocument code System.out.println("open pdf!"); } @Override public void close() { System.out.println("close pdf!"); } @Override public void save() { System.out.println("save pdf!"); } // ...... } public class TxtDocument implements Document{ //Txt實現代碼,同PdfDocument ...... } public class DocumentFactory{ public Document createDocument(String type){ if(type=="pdf"){ return new PdfDocument(); }else if(type=="txt"){ return new TxtDocument(); }else { return null; } } } //簡單工廠模式在客戶類當中的調用 public class Client { public static void main(String[] args) { DocumentFactory factory = new DocumentFactory(); Document pdfDocument = factory.createDocument("pdf"); pdfDocument.open(); pdfDocument.save(); pdfDocument.close(); Document txtDocument = factory.createDocument("txt"); txtDocument.open(); txtDocument.save(); txtDocument.close(); } } 這樣簡單工廠模式，在不考慮未來新文檔類型的情況下，確實是一種不錯的實現方法。但是在後續的擴展過程當中，如果需要增加新的文檔類，就需要去修改DocumentFactory中的createDocument()方法，增加新的類別，並且客戶還必須知道這些類別才能使用。為了應對這種情況，就出現了工廠方法。工廠方法就直接將工廠抽象出來，每個產品對應一個工廠，消除工廠模式中的條件分支結構（其實還有一種消除條件語句的模式，就是之前“組件協作”當中的策略模式）。//Document部分不變 public interface Document{ public void open(); public void close(); public void save(); ...... } public class PdfDocument implements Document{ public void open(){ //open pdfDocument code } // close 和 save ...... } public class TxtDocument implements Document{ //Txt實現代碼 ...... } //並且後續可以擴展新的文檔類 ...... //修改factory部分如下 public interface DocumentFactory{ public Document createDocument(); } public class PdfDocumentFactory implements DocumentFactory { @Override public Document createDocument() { return new PdfDocument(); } } public class TxtDocumentFactory implements DocumentFactory { @Override public Document createDocument() { return new TxtDocument(); } } //如果後續有新的產品，直接再實現DocumentFactory,得到新的工廠 ...... //調用過程可做如下修改： public class Client { public static void main(String[] args) { //利用多態性質，直接生成相應的factory子類 //消除了控制耦合 DocumentFactory factory = new PdfDocumentFactory(); Document pdfDocument = factory.createDocument(); pdfDocument.open(); pdfDocument.save(); pdfDocument.close(); factory = new TxtDocumentFactory(); Document txtDocument = factory.createDocument(); txtDocument.open(); txtDocument.save(); txtDocument.close(); } } 有人可能會有疑問，這樣不是還沒完全消除new嗎？首先這裡的客戶類已經到最高的調用層次了，這個過程當中是必然會有new的出現，不然怎樣進行程序調用呢？我們所說的消除new的過程是指main與factory之間，產生的一箇中間層次（如下面的App）中去消除new。//這樣的代碼中，就消除了new的存在 //具體的注入過程可以由其他的形式完成，比如Spring中的DI public class App{ private DocumentFactory factory; public void setFactory(DocumentFactory factory) { this.factory = factory; } public void operateDoc(){ Document document = factory.createDocument(); document.open(); document.save(); document.close(); } } //main中的代碼是最高層次，也是變化最頻繁的層次，這裡是不可能消除new的 public class Client { public static void main(String[] args) { DocumentFactory factory = new PdfDocumentFactory(); App app = new App(); app.setFactory(factory); app.operateDoc(); //同樣對於其他的工廠類也是可以採用同樣的方式調用。 ...... } } 這樣修改代碼的好處在那裡呢？第一，顯而易見的就是完全實現了“開閉原則”的思想，擴展時不再需要去修改源碼。第二，有些對象的創建過程可能比較複雜，因此如果直接在應用程序當中使用new或者其他形式創建很麻煩，通過工廠創建之後，就不再需要去關注那些複雜的創建過程。第三，通過new創建，始終是一種硬編碼的形式，如果在應用程序當中過多的使用這種方式，那麼一旦某對象的創建方式發生改變，修改源碼必然是很繁瑣的。</li><li><strong>結構——類創建型模式</strong></li><li><strong>參與者Product（Document）</strong>定義工廠方法中工廠創建的對象的接口。<strong>ConcreteProduct（PdfDocument、TxtDocument）</strong>實現Product的接口。<strong>Creator（DocumentFactory）</strong>聲明工廠方法——createProduct()，可以調用該方法返回一個Product類型的對象。<strong>ConcreteCreator（PdfDocumentFactory、TxtDocumentFactory）</strong>重定義工廠方法以返回具體的ConcreteProduct。<strong>Client（客戶類）</strong>使用工廠和產品，工廠方法模式中，客戶類也是一個重要的參與者，因為工廠方法主要的作用就是分離開客戶類與產品類之間的耦合關係，所以脫離客戶類去談工廠方法模式時，總會覺得差了些什麼東西，無法完全體會到工廠方法模式的優勢。</li><li><strong>適用性</strong>在下列情況下可以使用Factory Method模式：當一個類不知道它所必須創建的對象的類的時候。當一個類希望由它的子類來指定它所創建的對象的時候。當類將創建對象的職責委託給多個幫助子類中的某一個，並且你希望將哪一個幫助子類是代理者這一信息局部化的時候。簡單地說，就是使用過程中只需要聲明一個抽象工廠類的引用，具體調用那個工廠去生成那個對象，是由調用者去確定的。</li><li><strong>相關模式</strong>Abstract Factory經常用工廠方法來實現，抽象工廠創建產品的過程就可以使用工廠方法來完成。工廠方法通常在Template Method中被調用，這一點在“組件協作”當中也提到過。</li><li><strong>思考Creator的兩種實現情況。</strong>第一種情況，Creator只作為抽象層，也就是隻聲明接口，不做任何的實現；這種情況就必須要子類來實現。第二種情況，Creator作為一個具體的實現類，而不是抽象類，這種情況下，Creator可以提供一個缺省的實現接口，這樣即使沒有子類重寫它，客戶可以通過這樣一個缺省的實現完成任務。<strong>靈活運用工廠方法模式。</strong>作為一種創建類模式，在任何需要生成複雜對象的地方，都可以使用工廠方法模式。有一點需要注意的地方就是複雜對象適合使用工廠方法模式，而簡單對象，特別是只需要通過 new 就可以完成創建的對象（這也是為什麼工廠方法講解用到的例子總是無法說服人的原因之一），無需使用工廠方法模式；因為使用工廠方法模式，就需要引入一個工廠類，會增加系統的複雜度。</li></ol><h2 class=pgc-h-arrow-right>抽象工廠(Abstract Factory)</h2><ol start=1><li><strong>意圖</strong>提供一個創建一系列相關或相互依賴對象的接口，而無需指定他們具體的類。</li><li><strong>實例</strong>假定存在這樣一個服務層，該層當中需要做的就是訪問數據庫中的數據，並且執行一系列的相關操作。根據面向接口編程的思想，可以先作這樣一個代碼編寫。//對數據庫進行訪問的三個接口 //先建立連接，再執行相關操作，最後返回相應結果 public interface DBConnection{} public interface DBCommand{} public interface DBDataReader{} //對於MySql，可以建立以下實現 public class MySqlDBConnection implements DBConnection{} public class MySqlDBCommand implements DBCommand{} public class MySqlDBDataReader implements DBDataReader{} //同樣對於Sql Server，Oricle也是這樣的實現 ...... 這樣的實現下，我們可以說是滿足了面向接口編程的一個思想；並且在實現中，我們可以為每個接口，按照工廠方法模式，為其創建一個工廠。//工廠接口 public interface DBConnectionFactory{ public DBConnection createDBConnetion(); } public interface DBCommandFactory{ public DBCommand createDBCommand(); } public interface DBDataReaderFactory{ public DBDataReader createDBDataReader(); } //然後對於每個具體的數據庫，實現不同的具體工廠 //以MySql為例 public class MySqlDBConnetionFactory implements DBConnectionFactory { @Override public DBConnection createDBConnetion() { return new MySqlDBConnection(); } } public class MySqlDBCommandFactory implements DBCommandFactory { @Override public DBDBCommand createDBCommand() { return new MySqlDBCommand(); } } public class MySqlDataReaderFactory implements DataReaderFactory { @Override public DBDataReader createDataReader() { return new MySqlDataReader(); } } //剩下的Orcle,Sql Server也是如此 ...... 工廠模式方法的調用就不再演示，區別和工廠方法中的Document例子中差別不大。對於這樣的實現，雖然我們很好的利用了工廠方法模式，<strong>但是也引入了工廠方法模式的一個弊端——大量的對象和類（本例當中，三個系列，每個系列三個產品，光產品就是9個子類；每個產品再對應一個工廠，一共就是18個子類）</strong>。在使用的過程中，反而能夠明顯的感覺到系統複雜度不減反增。並且，DBConnection、DBCommand和DBDataReader明顯是有著一定的關係的，換句話說，MySql建立的DBConnection是和MySqlDBCommand、MySqlDBDataReader一起使用的，如果出現MySqlDBConnection、OricleDBCommand、SqlServerDBDataReader這種組合肯定是無法正常執行的。這時抽象工廠的出現，就很好的解決了這樣的問題。//首先，具體的產品類不會發生變化，簡化的主要是工廠層次 //先抽象出抽象工廠，將產品系列的創建方法合併到一個接口中 public interface DBFactory{ public DBConnection createDBConnetion(); public DBCommand createDBCommand(); public DBDataReader createDBDataReader(); } //根據不同的具體工廠，創建具體的對象 public class MySqlDBFactory implements DBFactory { @Override public DBConnection createDBConnetion() { return new MySqlDBConnection(); } @Override public DBCommand createDBCommand() { return new MySqlDBCommand(); } @Override public DBDataReader createDBDataReader() { return new MySqlDBDataReader(); } } //Oricle,sql server的工廠，同樣如此 ...... 抽象工廠主要是對工廠層次的簡化，這樣修改下來，對比工廠方法模式，減少了2/3的工廠子類創建，只需要3個工廠（有多少個產品系列就有多少個工廠子類）就可以完成產品的創建。這樣的一種創建工廠方式，不僅減少了工廠的數量，而且使得產品的一致性得以保證，它可以保證，一次只能使用同一個系列當中的對象。public class Client { public static void main(String[] args) { DBFactory factory = new MySqlDBFactory(); App app = new App(); app.setFactory(factory); app.operate(); //同樣對於其他的工廠類也是可以採用同樣的方式調用。 // ...... } } class App{ private DBFactory factory; public void setFactory(DBFactory factory) { this.factory = factory; } public void operate(){ DBConnection connection = factory.createDBConnetion(); DBCommand command = factory.createDBCommand(); DBDataReader reader = factory.createDBDataReader(); //執行相關操作 ..... } } 這樣的應用程序代碼，在一定程度上就減少了工廠子類的數量，並且在operate()中保證了產品系列的一致性，使得MysqlDBFactory生成的產品，只會是與MySql相關的。</li><li><strong>結構——對象創建型模式</strong></li><li><strong>參與者AbstractFactory（DBFactory）</strong>聲明一個創建抽象產品對象的操作接口。<strong>ConcreteFactory（MySqlDBFactory）</strong>實現創建具體產品對象的操作。<strong>AbstractProduct（DBConnection、DBCommand、DBDataReader）</strong>為一類產品對象聲明一個接口。<strong>ConcreteProduct（MySqlDBConection、MySqlDBCommand、MySqlDBDataReader）</strong>定義一個將被相應的具體工廠創建的產品對象，並實現抽象產品的相應接口。<strong>Client</strong>調用抽象工廠和抽象產品提供的接口。在創建者模式當中，客戶類也是重要的參與成員，因為對創建模式的理解容易混亂的點正是在客戶類中的調用過程 （new） 產生的，關於這個問題，已經在前面做過很多解釋了，不再多說。</li><li><strong>適用性</strong>以下情況可以使用AbstractFactory模式：一個系統要獨立於它的產品的創建、組合和表示時。一個系統要由多個產品系列中的一個來配置時。當你要強調一系列相關的產品對象的設計以便進行聯合使用時。當你提供一個產品類庫，而只想顯示它們的接口而非實現時。</li><li><strong>相關模式</strong>Singleton：一個具體的工廠通常會是一個單件。因為在一個應用中，一般每個產品系列只需要一個具體工廠。Factory Method：在Abstract Factory中，僅僅是聲明一個創建對象的接口，真正的創建過程是由具體工廠實現的。這時，可以為每一個方法對應的具體對象之間再定義一個工廠方法。但其問題就在於，這樣的做法就像是在工廠方法上再套上一層抽象工廠，從而又增加了系統的複雜度。</li><li><strong>思考難以支持新種類的產品</strong> 對於工廠模式而言，它的最大優點就在於保證了產品的一致性，但也正是如此，這就使得它的產品系列需要保持穩定，如果在後續的過程中出現新的產品，比如在實例當中需要增加一個新的功能系列，就需要去擴展DBFactory接口，並且涉及到DBFactory及其子類的改變。<strong>定義可擴展的工廠</strong> 這是對於新種類產品創建靈活性的提高，但是不太安全；就是給創建 對象的操作增加一個參數，該參數來指定將被創建的對象種類。使用這種方式，抽象工廠就只需要一個“Create”方法和一個標識符參數即可完成創建操作。但問題就在於，客戶需要完全瞭解所有的參數才能更好使用工廠創建自己所需要的對象。</li></ol><h2 class=pgc-h-arrow-right>原型模式（Prototype）</h2><ol start=1><li><strong>意圖</strong>用原型實例指定對象的創建種類，並且通過拷貝這些原型創建新的對象。</li><li><strong>實例</strong>Prototype模式，有點像是對工廠方法模式中產品與工廠的合併。怎麼說呢?看下面的代碼：//工廠方法模式中的產品類與工廠方法類 public interface Document{ public void open(); public void close(); public void save(); ...... } public interface DocumentFactory{ public Document createDocument(); } 這是在Factory Method中使用的創建方式，而原型做的事就是，不再用工廠來進行創建，而是轉而克隆的方式。變成下面這樣：//合併Document和DocumentFactory public abstract class Document implements Cloneable{ public void open(); public void close(); public void save(); ...... //相當於Factory中的createDocument(); public Object clone() { Object clone = null; try { clone = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return clone; } } public class PdfDocument implements Document{ @Override public void open(){ //open pdfDocument code System.out.println("open pdf!"); } @Override public void close() { System.out.println("close pdf!"); } @Override public void save() { System.out.println("save pdf!"); } //...... } //文檔類的實現與工廠方法中的一樣 ...... 那麼在具體的客戶類當中就是通過這樣一種方式來進行調用：public class App{ //在工廠方法模式當中，這裡是documentFactory private Document prototype; public void setDoucument(Document document){ prototype = document; } public void useDocument(){ //documentFactory.createDocument(); Document doc = prototype.clone(); //然後使用prototype克隆出來的doc進行操作 doc.open(); ...... } } //在客戶類中調用表現 public class Client { public static void main(String[] args) { Document doc = new PdfDocument(); App app = new App(); app.setFactory(doc); app.useDocument(); //同樣對於其他的工廠類也是可以採用同樣的方式調用。 //...... } } 問題來了，為什麼不直接用原型（prototype），而是要多一步克隆？解決這個問題，首先要明白的是，我們<strong>使用原型的目的不是將原型作為客戶類的一個屬性去使用，而是一個創建者</strong>。既然是一個創建者，那麼在使用的過程中，就不只一個地方會用到同樣類型的對象；如果在不同的地方都直接使用原型，可能會在某個地方修改了原型的值，從而使得其他直接使用原型的方法出現不可預知的錯誤。</li><li><strong>結構——對象創建型模式</strong></li><li><strong>參與者Prototype（Document）</strong>聲明一個克隆自身的接口。<strong>ConcretePrototype（PdfDocument...）</strong>繼承Prototype並實現克隆自身的接口。<strong>Client</strong>讓一個原型克隆自身從而創建一個新的對象。</li><li><strong>適用性</strong>當一個系統應該獨立於它的產品創建、構成和表示時，可以使用Prototype模式。當要實例化的類是在運行時候指定時，比如動態裝載。為了避免創建一個產品類平行的工廠類層次時。當一個類的實例只能有幾種不同狀態組合中的一種時，建立相應數目的原型並克隆他們可以比每次用合適的狀態手工實例化該類更方便一些。</li><li><strong>相關模式</strong>Abstract Factory和Prototype在某種方面是相互競爭的，但是在某種情況下也是可以一起使用，比如，在抽象工廠中存儲一個被克隆的產品集合，在使用時，直接根據集合中的對象返回相應的產品。大量使用Composite（組合模式）和Decorator（裝飾器模式）的設計上也可以採用Protorype來減少Composite或Decorator對象的創建。</li><li><strong>思考減少了子類的構造</strong>。實例當中就可以看出，原型模式簡化了工廠方法模式中的工廠類，因此，減少了許多子類的創建。<strong>資源優化</strong>。類初始化可能需要消化非常多的資源，這個資源包括數據、硬件資源等等，使用原型模式就可以減少這樣一個初始化過程。<strong>深、淺拷貝的問題</strong>。對於java而言，淺拷貝實現 Cloneable，深拷貝是通過實現 Serializable 讀取二進制流。</li></ol><h2 class=pgc-h-arrow-right>建造者模式( Builder)</h2><ol start=1><li><strong>意圖</strong>將一個複雜對象的構建與它的表示分離，使得同樣的構建過程可以有不同的表示。</li><li><strong>實例</strong>在遊戲場景當中，尤其是3d場景中，必不可少就是建築物，比如說房子。對房子的構建肯定不是一下全部構建完成的，而是會分成幾個部分，比如牆、窗戶、地板、房頂、門，一部分、一部分地去構建。public abstract class House{ //房子屬性，紋理、材質... private Texture texture; private Material material; ...... //牆、窗戶、地板、房頂、門 public Wall buildWall(); public Window buildWindow(); public Floor buildFloor(); public Door buildDoor(); public Roof buildRoof(); //房子構建過程 public void buildHouse(){ buildFloor(); Wall[] walls = new Wall[4]; for(int i=0;i&lt;walls.length;i++) walls[i] = buildWall(); Window window = buildWindow(); wall[1].setWindow(window); Door door = builDoor(); wall[2].setDoor(door); buildRoof(); } } 這種構建方式，採用的明顯就是模板方法（Template Method），這種實現方式還可以根據不同的房子類型，實現具體的細節。//石頭屋 public class StoneHouse extends House{ //具體實現細節 ....... } //茅草屋 public class ThatchedHouse extends House{ //具體實現細節 ....... } //按照模板主方法在客戶類中的調用形式表現： public class Client{ public static void main(String[] args){ //只需要生成一個相應對象即可在遊戲場景中完成相應類型房子的創建 House house = new StoneHouse(); house.buildHouse(); //生成石頭屋 house = new ThatchedHouse(); house.buildHouse(); //生成茅草屋 } } 這種實現有什麼問題呢？類太臃腫了，對吧~這樣的實現過程，可以體現複用的思想，但是問題之一就在於所有的內容全部都放在了一個類中，體現不出單一職責和類的信息與行為集中；這時就可以將創建過程分離出來，形成一個Builder，由這樣一個Builder來專門負責創建。//Director public class House{ //房子屬性，紋理、材質... private Texture texture; private Material material; ...... //增加builder的引入 private HouseBuilder houseBuilder; public void setHouseBuilder(HouseBuilder hBuilder){ houseBuilder = hbuilder; } //房子構建過程 public void buildHouse(){ houseBuilder.buildFloor(); Wall[] walls = new Wall[4]; for(int i=0;i&lt;walls.length;i++) walls[i] = houseBuilder.buildWall(); Window window = houseBuilder.buildWindow(); wall[1].setWindow(window); Door door = houseBuilder.builDoor(); wall[2].setDoor(door); houseBuilder.buildRoof(); } } //分離出來的builder public interface HouseBuilder{ //牆、窗戶、地板、房頂、門 public Wall buildWall(); public Window buildWindow(); public Floor buildFloor(); public Door buildDoor(); public Roof buildRoof(); } public class StoneHouseBuilder implements HouseBuilder{ //具體實現細節 ....... } public class ThatchedHouseBuilder implements HouseBuilder{ //具體實現細節 ....... } //修改過後，在客戶類中的調用形式表現： public class Client{ public static void main(String[] args){ //只需要生成一個相應對象即可在遊戲場景中完成相應類型房子的創建 House house = new House(); HouseBuilder builder = new StoneHouseBuilder(); house.setHouseBuilder(builder); house.buildHouse(); builder = new ThatchedHouseBuilder(); //這個set過程可以運行時完成 house.setHouseBuilder(builder); house.buildHouse(); } } 通過這樣一種方式，實現複雜對象構建與表示的分離，並且，對於不同的房子對象，如果房子其他參數沒有任何差別，就只需要傳入相應的builder即可，而不需要再生成各種各樣的子類（如StoneHouse、ThatchedHouse）。一旦生成對象，只需要修改其builder就可以馬上改變其對象表示，而不需要新生成對象。並且這種修改過程，是可以動態完成的，就如果Spring當中的依賴注入過程一樣，可以在運行時刻完成，而不一定是一開始就確定的</li><li><strong>結構——對象創建型模式</strong></li><li><strong>參與者Builder（HouseBuilder）</strong>為創建一個Product對象的各個部件指定抽象接口。<strong>ConcreteBuilder（StoneHouseBuilder、ThatchedHouseBuilder）</strong>實現Builder的接口以構造各裝配該產品的各個部件。定義並明確它所創建的表示。<strong>Director（House）</strong>構造一個使用builder的對象。<strong>Product（Wall、Window...）</strong>包含了定義組成部件的類以及被構造的複雜對象等。</li><li><strong>適用性</strong>Builder的適用情況：當創建複雜對象的算法應該獨立於該對象的組成部分，以及它們的裝配方式時。當構造過程必須允許被構造的對象的不同的表示時。Builder模式更多的是體現的一種思想，而不是具體的過程，這種思想就是，當一個類的信息與行為過於臃腫時，也許可以採用Builder這種方式對類的信息與行為進行重新劃分，從而使得類看起來更加的“輕” 。</li><li><strong>相關模式</strong>Abstract Factory和Builder都是對複雜對象的創建封裝，但二者的區別在於，Builder著重於一步一步構建一個複雜對象，而Abstract Factory著重於多個系列產品對象的創建，並且系列對象之間有著某種聯繫。Composite模式中對象通常情況下就是用Builder生成的。</li><li><strong>思考可以改變產品的內部表示</strong> Builder對象提供給Director一個構造產品對象的內部接口，從而使得產品的表示和內部結構得以隱藏。因此，在構建過程中，只需要替換不同的Builder就可以得到不同的表示。<strong>Builder中的方法可以缺省為空</strong> 這樣在具體的實現過程中，客戶可以只實現他們感興趣的操作，這種方式其實在很多模式中都可以應用，其最主要的思想就是能用默認配置當然是最好的。</li></ol></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>封裝</a></li><li><a>變化</a></li><li><a>設計</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cdcb055.html alt=路面材料設計參數的變化與試驗方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6ec78785daa04c9694a1f76043b96b2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cdcb055.html title=路面材料設計參數的變化與試驗方法>路面材料設計參數的變化與試驗方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf5369f.html alt=芯片封裝設計：用於異構集成的重新分發層 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d861347adbd4069be1d290ec4b486c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf5369f.html title=芯片封裝設計：用於異構集成的重新分發層>芯片封裝設計：用於異構集成的重新分發層</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html alt=鋼構人福利——鋼結構設計經典問題解讀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a72bd60ea48d471b8ce03ebf0ce15869 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html title=鋼構人福利——鋼結構設計經典問題解讀>鋼構人福利——鋼結構設計經典問題解讀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html alt=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153569494612546362474a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html title=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先>鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html alt=38個鋼結構設計問題，都很常見 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f1181ce8-cf01-4194-b9c2-362f43894ddb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html title=38個鋼結構設計問題，都很常見>38個鋼結構設計問題，都很常見</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html alt=步步解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d88dd927b4f2474fbe4ea261c2397ba8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html title=步步解析橋樑設計計算，不可錯過的一篇乾貨>步步解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html alt=結構設計、校對、審核三字經，速速收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html title=結構設計、校對、審核三字經，速速收藏>結構設計、校對、審核三字經，速速收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html alt=解析橋樑設計計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa4d0bcf2a204a2fac9b37978b1b0713 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html title=解析橋樑設計計算>解析橋樑設計計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html alt=解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af9ca7f120da4e23b0ca589375e05dd2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html title=解析橋樑設計計算，不可錯過的一篇乾貨>解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html alt=設計師解析橋樑設計計算，錯過了就沒有機會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e01645937bda4ae7a7f148666ff89117 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html title=設計師解析橋樑設計計算，錯過了就沒有機會>設計師解析橋樑設計計算，錯過了就沒有機會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html alt=經典設計延續至今的烏尼莫克403萬能卡車 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/132ba54553374c7eb2c0a9c155bba041 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html title=經典設計延續至今的烏尼莫克403萬能卡車>經典設計延續至今的烏尼莫克403萬能卡車</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69536588.html alt=線纜設計初級課程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532759411210988051a0cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69536588.html title=線纜設計初級課程>線纜設計初級課程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/219919c3.html alt=梯度效果的創意Logo設計案例分享（1） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15226471428904df67cc724 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/219919c3.html title=梯度效果的創意Logo設計案例分享（1）>梯度效果的創意Logo設計案例分享（1）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/29b61120.html alt=梯度效果的創意Logo設計案例分享（2） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1522647184765cbbd0b4dcd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/29b61120.html title=梯度效果的創意Logo設計案例分享（2）>梯度效果的創意Logo設計案例分享（2）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>