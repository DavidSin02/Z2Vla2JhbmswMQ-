<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>異步編程提升服務性能 | 极客快訊</title><meta property="og:title" content="異步編程提升服務性能 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/15260210063976700d35c2d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="異步編程提升服務性能"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c81ec36.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>異步編程提升服務性能</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>龐大複雜的系統通常會採用服務化組件來實現。系統越複雜，組件之間的依賴和調用關係也會越複雜。對於處於底層的基礎服務，直接和間接的調用所帶來的流量壓力非常大。處於中間層的聚合型服務，面對的挑戰則是依賴的服務太多，後端個別服務的性能延遲就會影響其吞吐量。性能優化是我們系統穩定性中的重要一環，這其中，調用所依賴的RPC服務或後端數據是重點之一。</p><p>目前，除了傳統JDBC這樣從API到主流驅動實現就是阻塞式的類庫之外，其他常用的RPC/HTTP服務、MQ、Redis、Mongodb、Kafka等系統都提供了成熟的基於NIO的客戶端庫，也有相應的異步API。</p><p>但是目前交易平臺的大多數中臺服務系統，還在習慣性使用著這些庫的同步API，並不能充分的利用CPU，這也給我們帶來了一定的優化空間。從16年開始我們在一些核心的但是服務邏輯相對簡單的系統中使用異步方式來實現，雖然暫時還做不到完全的異步化，但是也取得了比較好的效果。這篇文章雖然更多是一個簡介性質，但是也涵蓋了我們在異步編程中需要關注的要點。希望大家能夠習慣和擁抱異步編程。</p><p><strong>一、相關概念介紹</strong></p><p>同步(Synchronous)/異步(Asynchronous)，通常是指函數調用中的消息通信的兩種不同模式。</p><p><strong>1、異步和同步的區別</strong></p><p>函數調用發生時，消息(參數)從caller傳遞到callee，控制權(指令執行)從caller轉移到callee。調用返回時，控制權從callee轉移到caller。兩者的區別在於，callee是否需要等待執行完成才將控制權轉移給caller。</p><p>在RPC這種更復雜的場景下，本質上並沒有不同。</p><p>◆ 同步</p><p><img alt=異步編程提升服務性能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15260210063976700d35c2d></p><p>1.callee執行完成才返回</p><p>2.返回值即結果</p><p>◆ 異步</p><p><img alt=異步編程提升服務性能 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1526021006860927b1feca3></p><p>1.callee不需要執行完成就可返回</p><p>2.caller要獲取結果，需要通過輪詢、回調等機制</p><p>◆ 同步RPC</p><p><img alt=異步編程提升服務性能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15260210065070b97e26186></p><p>◆ 異步RPC</p><p><img alt=異步編程提升服務性能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/152602100651271869c2752></p><p>可以看到，在異步RPC的場景下，客戶端和服務端用於處理IO的CPU能得到充分利用，通常只需要遠低於caller請求數量的線程就可以了，這就是多路複用。</p><p><strong>2、callee執行機制</strong></p><p>上圖中callee的background execute通常是採用池化線程來完成的，比如ThreadPoolExecutor或EventLoop1。</p><p><strong>3、caller獲取執行結果</strong></p><p>caller調用callee時，如果需要獲取執行結果（消息雙向傳遞），或者獲知執行是否完成（消息單向傳遞無返回值），在異步模式下，主要依靠下面兩種機制。</p><p>◆ 輪詢(Polling)</p><p>比如Java的Future就提供了isDone()這種詢問機制。</p><pre>1.//Caller.java2.void call() {3. Future&lt;Void&gt; f = callee.asyncCall(param);4. // do some other things5. while(true) {6. if (f.isDone()) break;7. //do some other things or sleep or timeout8. }9.}</pre><p>或阻塞版本</p><pre>1.//Caller.java2.void call() {3. Future&lt;Void&gt; f = callee.asyncCall(param);4. // do some other things5. f.get(timeout, TimeUnit.SECONDS);6.}</pre><p>輪詢的控制邏輯在caller端。</p><p>◆ 回調(Callback)</p><p>caller設置一個回調函數，供callee執行完成後調用這個函數。回調的控制是反轉的，通常由callee端控制。</p><pre>1.//Caller.java2.void call() {3. callee.asyncCall(param, new AsyncHandler&lt;Response&lt;Message&gt;&gt;() {4. @Override public void handleResponse(Response&lt;Message&gt; response) {5. msg = response.get();6. // process the msg...7. }8. });9. // do some other things10.}</pre><p><strong>4、異步模式的場景</strong></p><p>◆ 阻塞</p><p>阻塞(Blocking)/非阻塞(Non-Blocking)是用來描述，在等待調用結果時caller線程的狀態。阻塞，通常意味著caller線程不再使用CPU時間，處於可被OS調度的狀態(注意與Java線程狀態2的區別)。 磁盤IO和網絡IO是常見的會引起線程阻塞的場景3。受制於底層OS的同步阻塞式IO系統函數，調用Java OIO(Old blocking IO) API無疑是會阻塞的。對於DiskIO，Java NIO2提供了異步API。對於SocketIO，Java NIO2以及NIO框架Netty，都提供了異步API。</p><blockquote><p>◆ Linux提供了異步IO系統函數，只能用於DiskIO，還有一些限制4，Java NIO2 AsynchronousFileChannel內部仍然使用線程池+阻塞式API的實現。</p><p>◆ Linux為SocketIO準備就緒階段提供了非阻塞式API(select/poll/epoll)，但是IO執行階段仍然是同步阻塞的，因此主流的Java NIO框架的Reactor模式內部實現使用了線程池。</p></blockquote><p>◆ 並行</p><p>比如需要調用多個沒有依賴關係的服務，或者訪問分散在多個存儲分片中的數據，如果服務接口或數據訪問接口實現了異步API，那麼就很方便實現並行調用，減少總體調用耗時。</p><p>◆ 速度不匹配</p><p>使用中間隊列解偶caller和callee的速度不匹配問題，削峰填谷。</p><p>◆ 批量</p><p>使用中間隊列解偶caller和callee的速度不匹配問題，削峰填谷。</p><p><strong>二、異步API的幾種風格</strong></p><p><strong>1、Callback</strong></p><p>這個比較傳統，比如zookeeper客戶端提供的基於回調的異步API:</p><pre>1.try {2. zookeeper.create(path, data, acl, createMode, new StringCallback() {3. public void processResult(int rc, String path, Object ctx, String name) {4. if (rc != KeeperException.Code.OK.intValue()) {5. // error handle6. } else {7. // success process8. // 如果需要在成功後再發起基於回調的異步調用，會形成callback hell9. }10. }11. }, ctx);12.} catch( Throwable e) {13. // error handle</pre><blockquote><p>◆ Callback通常是無狀態的</p><p>◆ 要獲取Callback的計算結果，通常需要closure</p><p>◆ 異常處理比較分散</p><p>◆ 在有多個異步調用鏈的時候，容易造成Callback hell</p></blockquote><p><strong>2、Future/Promise</strong></p><p>Promise是callee給caller的憑證，代表未完成但承諾完成（成功或失敗）的結果。Promise本身是有狀態的，通常由callee端維護。其狀態轉移如下（術語參考Promise/A+和ES6）：</p><blockquote><p>Promise的狀態只能轉移一次，因此如果有callback，那麼.then(callback)或.catch(callback)也只被執行一次。</p></blockquote><p>JDK5的Future只能用輪詢或者阻塞的方式獲取結果，caller端處理比較繁瑣。Guava的ListenableFuture，特別是JDK8的CompletableFuture，則是完整實現了Promise風格的異步API。 個人認為Promise是更好的Callback，ListenableFuture接口只是比Future多了一個void addListener(Runnable, Executor)方法。 Promise提供了比Callback更易用更清晰的編程模式，尤其是涉及多個異步API的串行調用（chaining或pipelining )、組合調用（並行、合併）、異常處理等方面有很大的優勢。</p><blockquote><p><strong>引申閱讀</strong></p><p>◆ 這篇文章談到了Future和Promise的細微區別、相關歷史和技術。</p><p>◆ 這裡有一些討論：Aren’t promises just callbacks?,Is there really a fundamental difference between callbacks and Promises?。</p><p>◆ Promise借鑑了函數式中的一些概念: 從函數式編程到Promise。</p><p>◆ 這篇文章簡要對比了幾種語言中的Promise框架。</p></blockquote><p><strong>3、ReactiveX</strong></p><p>其官方網站的介紹</p><blockquote><p>An API for asynchronous programming with observable streams</p></blockquote><p>其關鍵的概念Observable比較Promise來說：</p><p>◆ Promise代表一個異步計算值，而Observable代表著一系列值(stream)。</p><p>◆ Promise的值只能產生一次，而Observable的事件可以不斷產生。因此Rx首先流行在前端UI場景：事件來源多，數據變化影響多個UI組件的變更。</p><p>Rx的學習曲線比Promise要高得多，而且目前Promise風格的異步編程能夠滿足我們大部分的服務端開發場景，因此我們這裡主要關注Promise。</p><p><strong>三、Promise在服務端的應用</strong></p><p>下面穿插著以JDK8的CompletableFuture和Guava的ListenableFuture（適用JDK6）為例介紹Promise的用法。</p><p><strong>1、符合Promise風格的方法簽名</strong></p><p>Promise風格的方法簽名，有個不成文的規則是不拋出異常，因為異常是Promise對象本身就能攜帶的兩種狀態之一。比如我們想把一個Callback風格的異步API包裝成Promise風格的（通常在使用一個較老的類庫時需要這樣的包裝），可以這樣：</p><pre>1.//caller.java2.CompletableFuture&lt;String&gt; asyncCall(final String msg) {3. CompletableFuture&lt;String&gt; promise = new CompletableFuture&lt;&gt;();4. try {5. callee.asyncCall(msg, new Callback&lt;String&gt;() {6. public void onSuccess(String r) { promise.complete(r); }7. public void onFail(Throwable t) { promise.completeExceptionally(t); }8. });9. } catch (Throwable e) {10. promise.completeExceptionally(t);11. }12. return promise;13.}</pre><p>下面是使用ListenableFuture的實現異步發送消息的API。</p><pre>1.//LocalMessageEngine.java2.static class WriteTask {3. // SettableFuture是Guava中一種可設置狀態的Promise類型。4. final SettableFuture&lt;Boolean&gt; promise = SettableFuture.create();5. final byte[] message;6. WriteTask(byte[] message) {7. this.message = message;8. }9.}10.public Producer createProducer() {11. return new Producer() {12. public ListenableFuture&lt;Boolean&gt; asyncProduce(byte[] message) {13. if (!Engine.this.started) {14. // 返回前已完成15. return Futures.immediateFailedFuture(new IllegalStateException("Message engine was stopped or not started"));16. }17.18. WriteTask task = new WriteTask(message);19. boolean queued = writeTaskQueue.offer(task);20. if (!queued) {21. task.promise.set(Boolean.FALSE);22. }23. return task.promise;24. }25. };26.}</pre><p>上面兩個例子，描述瞭如何創建一個Promise對象返回給caller，以及如何在callee端fulfill或reject這個Promise。你可能會發現，返回給caller之前Promise是可以處於完成狀態的。在繼續下面的使用介紹前，先簡單的看下ListenableFuture和CompletableFuture的幾個主要API。</p><p><img alt=異步編程提升服務性能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15260210065997b2aa4be68></p><p><strong>2、串行調用</strong></p><p>ListenableFuture沒有提供then方法，而是通過Futures的一系列靜態方法來實現Promise風格的API。由於兩者有大部分的API是可以相互轉化的，限於篇幅下面就不全部演示了。Promse的callback就是其then或catch方法的函數型參數，當Promise被resolve時執行這個callback函數。這個callback函數的輸入，就是Promise的resolved值。根據callback函數的輸出的不同，需要採取不同的then方法。</p><p>◆ callback無輸出</p><p>Futures.addCallback和CompletableFuture.thenAccept接受無輸出的callback。</p><pre>1.// Guava2.ListenableFuture&lt;QueryResult&gt; promise1 = ...;3.Futures.addCallback(promise1, new FutureCallback&lt;QueryResult&gt;() {4. public void onSuccess(QueryResult result) {5. storeInLocalCache(result);6. }7. public void onFailure(Throwable t) {8. reportError(t);9. }10.});</pre><pre>1.// CompletableFuture2.CompletableFuture&lt;QueryResult&gt; promise1 = ...;3.CompletableFuture&lt;Void&gt; promise2 = promise1.thenAccept(result -&gt; storeInLocalCache(result));4.return promise2;5.//return promise1.thenAccept(result -&gt; storeInLocalCache(result));//thenAccept返回另一個Promise實例</pre><p>先忽略異常處理。對比下這種場景下的ListenableFuture和CompletableFuture：前者採取了更傳統的callback風格，後者則返回一個新的Promise實例，callback計算完畢則promise2被fulfilled，很容易通過promise2來獲取callback執行完畢與否，不需要closure。</p><p>◆ callback輸出一個普通計算值</p><p>這種情況下callback就是一個轉換函數，輸入是前一個Promise的fulfilled值，輸出則作為新Promise的fulfilled值。Futures.transform和CompletableFuture.thenApply接收這樣的callback函數。</p><pre>1.// CompletableFuture2.CompletableFuture&lt;QueryResult&gt; queryFuture = ...;3.CompletableFuture&lt;List&lt;Row&gt;&gt; rowsFuture = queryFuture.thenApply(result -&gt; result.getRows());4.return rowsFuture;</pre><p>◆ callback輸出一個異步計算值，即一個Promise</p><p>乍一看，這種情況下的輸出跟上一種好像沒什麼區別。但實際上，輸出一個Promise值和輸出一個普通的值有根本的區別。還記得吧，Promise代表著一個未完成的並且承諾完成的值。通常這種情況下，意味著callback裡調用了另外一個Promise風格的異步API。比如下面的例子中indexService.lookUp和dataService.read方法，由於涉及到IO，都設計為異步API。</p><pre>1.//Guava2.ListenableFuture&lt;RowKey&gt; rowKeyFuture = indexService.lookUp(query);3.AsyncFunction&lt;RowKey, QueryResult&gt; queryFunction = new AsyncFunction&lt;RowKey, QueryResult&gt;() {4. public ListenableFuture&lt;QueryResult&gt; apply(RowKey rowKey) {5. return dataService.read(rowKey);6. }7.};8.ListenableFuture&lt;QueryResult&gt; queryFuture = Futures.transformAsync(rowKeyFuture, queryFunction);9.return queryFuture;</pre><p>Futures.transformAsync和CompletableFuture.thenCompose接收這樣的callback函數。</p><p>設想一下，如果某個邏輯中需要調用的多個Promise風格的異步方法（比如多個RPC調用），並且有先後依賴關係，即上一個方法的執行結果作為下一個方法的輸入。就可以用thenCompose把他們串起來。</p><pre>1.//CompletableFuture2.CompletableFuture&lt;RPC4Result&gt; promise4 = rpc1.call(input) //promise13. .thenCompose(rpc1Result -&gt; rpc2.call(rpc1Result)) //promise24. .thenCompose(rpc2Result -&gt; rpc3.call(rpc2Result)) //promise35. .thenCompose(rpc3Result -&gt; rpc4.call(rpc3Result)) //promise46.return promise4;</pre><p>不要被鏈式調用給忽悠了，你還是可以正常使用普通的風格。</p><p>單純看來，上述的串行調用場景下使用Promise風格的API好像只是消除了Callback hell。那麼採用同步API就既沒有Callback hell的問題，又符合數據依賴關係。可是，你會發現，上面的舉例中結尾都返回了Promise，就是說，包含這段代碼的方法被設計為異步API。而使用同步API，則會強制這個方法的調用者只能使用同步方式調用。</p><p><strong>3、並行調用</strong></p><p>異步API很適合並行調用。caller在調用多個沒有依賴關係的異步API時，可以先依次發起調用而不用等待每個調用真正執行完成，從callee的角度來講，執行是並行的。caller可以對調用結果進行合併處理，關鍵是，合併也是異步風格的。</p><pre>1.//Guava2.List&lt;ListenableFuture&lt;QueryResult&gt;&gt; partialPromises = new ArrayList&lt;ListenableFuture&lt;QueryResult&gt;&gt;(nodes.size());3.for (Node node : nodes) {4. partialPromises.add(lookupHandler(node).query());5.}6.ListenableFuture&lt;List&lt;Row&gt;&gt; mergedPromise = Futures.transform(Futures.allAsList(partialPromises), new Function&lt;List&lt;List&lt;Row&gt;&gt;, List&lt;Row&gt;&gt;() {7. @Override public Long apply(List&lt;List&lt;Row&gt;&gt; input) {8. return merge(input);9. }10.})11.return mergedPromise;</pre><p>Futures.allAsList是並行執行所有的promises，若有一個promise異常完成則嘗試reject尚未resolved的promise。也可以使用Futures.successfulAsList，區別在於後者並不會reject尚未resolved的promise。CompletableFuture的對應物是allOf和anyOf。</p><p><strong>4、調用編排</strong></p><p>合併結果設計為異步風格的好處在於，很方便做合併、串行混合調用編排，比如某個邏輯中需要調用四個個RPC服務A、B、C、D，其中：A的輸出作為B、C的輸入，B、C可並行，B、C的輸出合併後作為D的輸入。</p><pre>1.//CompletableFuture2.CompletableFuture&lt;AResult&gt; promiseA = rpcA.call(input);3.CompletableFuture&lt;DResult&gt; promiseD = promiseA.thenCompose(aResult -&gt; {4. CompletableFuture&lt;BResult&gt; promiseB = rpcB.call(aResult);5. CompletableFuture&lt;CResult&gt; promiseC = rpcC.call(aResult);6. CompletableFuture&lt;MergedResult&gt; mergedPromise = promiseB.thenCombine(promiseC, (bResult, cResult) -&gt; {7. return merge(bResult, cResult)8. });9. return mergedPromise;10.}).thenCompose(mergedResult -&gt; rpcD.call(mergedResult));11.return promiseD;</pre><p><strong>5、異常處理</strong></p><p>上面提到過Callback風格的異步API，異常處理比較分散。而Promise風格的異常處理則優雅得多。我們需要記住，異常是Promise攜帶的兩種狀態之一。那麼異常可以作為callback函數的輸入。</p><p>◆ 通用異常處理</p><p>Futures.catching和CompletableFuture.exceptionally接收異常值為參數的callback函數。</p><pre>1.//Guava2.ListenableFuture&lt;Integer&gt; fetchCounterPromise = ...;3.// Falling back to a zero counter in case an exception happens when4.// processing the RPC to fetch counters.5.ListenableFuture&lt;Integer&gt; faultTolerantPromise = Futures.catching(6. fetchCounterPromise, FetchException.class,7. new Function&lt;FetchException, Integer&gt;() {8. public Integer apply(FetchException e) {9. return 0;10. }11. });</pre><p>我們再看一個更復雜的例子。</p><pre>1.//CompletableFuture2.CompletableFuture&lt;FaultTolerantResult&gt; faultTolerantPromise = rpc1.call(input) //promise13. .thenCompose(rpc1Result -&gt; rpc2.call(rpc1Result)) //promise24. .thenCompose(rpc2Result -&gt; rpc3.call(rpc2Result)) //promise35. .thenCompose(rpc3Result -&gt; rpc4.call(rpc3Result)) //promise46. .exceptionally(err -&gt; {7. // process err8. return faultTolerantValue;9. }); //faultTolerantPromise10.return faultTolerantPromise;</pre><p>再提醒一遍，不要被鏈式調用迷惑了。這個例子裡面，rpc1/rpc2/rpc3/rpc4都有可能發生異常，但我們只需要在最後統一處理（返回異常值或轉換為一個默認正常值）。比如rpc2發生異常，那麼rpc3/rpc4的邏輯（接收正常值的callback函數）都不會執行，但是rpc2的異常會傳遞給promise3/promise4。</p><p>◆ 恢復</p><p>假設在讀取某個數據存儲發生異常，我們需要某種恢復機制，比如讀取另一個backup的數據存儲（某種重試），那麼可以使用Futures.cachingAsync和CompletableFuture.handle。</p><pre>1.//CompletableFuture2.public &lt;V&gt; CompletableFuture&lt;V&gt; dispatch(final Command&lt;V&gt; command) {3. final CompletableFuture&lt;V&gt; dispatched = loadbalance.selectHandler().dispatch(command);4. if (maxTries &gt; 0) {5. final AtomicInteger leftTries = new AtomicInteger(maxTries);6. final BiFunction&lt;CompletableFuture&lt;V&gt;, Throwable, CompletableFuture&lt;V&gt;&gt; fallback = new BiFunction&lt;CompletableFuture&lt;V&gt;, Throwable, CompletableFuture&lt;V&gt;&gt;() {7. @Override8. public CompletableFuture&lt;V&gt; apply(CompletableFuture&lt;V&gt; input, Throwable cause) {9. if (cause == null) return input;10. if (cause instanceof RecoverableException &amp;&amp; leftTries.getAndDecrement() &gt; 0) {11. final CompletableFuture&lt;V&gt; next = loadbalance.selectHandler().dispatch(new Command&lt;V&gt;(command.type, command.args));12. return next.handle((v, err) -&gt; err).thenCompose(err -&gt; apply(next, err));13. }14. CompletableFuture&lt;V&gt; errFuture = new CompletableFuture&lt;&gt;();15. errFuture.completeExceptionally(cause);16. return errFuture;17. }18. };19. return dispatched.handle((v, err) -&gt; err).thenCompose(err -&gt; fallback.apply(dispatched, err));20. }21. return dispatched;22.}</pre><p>◆ 超時</p><p>Promise是一個承諾完成（成功或失敗）的結果，但是並不承諾完成時間。所以，通常需要一種超時機制，幸運的是ListenableFuture和CompletableFuture都實現了Future接口。</p><pre>1.CompletableFuture&lt;FaultTolerantResult&gt; faultTolerantPromise = ...;2.try {3. FaultTolerantResult result = faultTolerantPromise.get(1000, TimeUnit.SECONDS);4. // process result5.} catch (TimeoutException e) {6. //嘗試取消執行尚未開始的callback函數7. faultTolerantPromise.cancel(false); 8.}</pre><p><strong>四、Promise異步編程的注意點</strong></p><p>異步編程比同步編程困難。異步編程通常主要解決一小部分問題，比如阻塞。Promise借鑑了函數式編程的風格，大量的邏輯會分散在各種callback函數來實現。因此對於習慣了同步編程的OO式或命令式編程風格的開發人員，需要一定的習慣時間。</p><p>上面談到callee執行機制的時候，談到了線程池，那麼callee計算完成時，callback函數的執行通常是池中resolve Promise的線程執行。但是，如果caller在設置callback的時候，Promise已經完成，那麼callback的執行線程則是caller線程。因此，請特別關注callback函數的執行線程的差別。請遵循：</p><p>◆ callback儘量輕量</p><p>◆ callback避免阻塞</p><p>◆ 否則請指定執行線程</p><p>如果callback執行了大量的計算，甚至執行了阻塞式操作，那麼就很有可能阻塞住Promise的resolve線程，通常這類線程都是極少的，比如執行IO的EventLoop線程，有可能造成其他Promise得不到執行。</p><blockquote><p>摘自ListenableFuture的文檔：</p><p>Note: For fast, lightweight listeners that would be safe to execute in any thread, consider MoreExecutors.directExecutor. Otherwise, avoid it. Heavyweight directExecutor listeners can cause problems, and these problems can be difficult to reproduce because they depend on timing. For example:</p><p>◆ The listener may be executed by the caller of addListener. That caller may be a UI thread or other latency-sensitive thread. This can harm UI responsiveness.</p><p>◆ The listener may be executed by the thread that completes this Future. That thread may be an internal system thread such as an RPC network thread. Blocking that thread may stall progress of the whole system. It may even cause a deadlock.</p><p>◆ The listener may delay other listeners, even listeners that are not themselves directExecutor listeners.</p></blockquote><p>我們也的確碰到過使用MoreExecutors.directExecutor時，由於編寫了太過複雜的callback鏈，導致線程死鎖的問題。</p><p>CompletableFuture和ListenableFuture都有指定callback執行線程的方法：</p><pre>1.//使用內置的通用ForkJoin線程池2.completableFuture.thenAcceptAsync(callback);3.//使用指定的線程執行器4.completableFuture.thenAcceptAsync(callback, executor);5.//使用指定的線程執行器6.Futures.transform(input, callback, executor);</pre><p>正因為異步編程的複雜性，因此目前我們也儘量在業務邏輯相對簡單的應用上進行異步化改造。後續，我們也會評估Quasar等協程框架。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>異步</a></li><li><a>編程</a></li><li><a>服務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd08b19.html alt=異步編程：協作性多任務處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/dbd0ddd7-eda4-430a-8176-da9804319771 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd08b19.html title=異步編程：協作性多任務處理>異步編程：協作性多任務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html alt="Java 異步編程導論" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3c356b1aa9b4416ca7b35a07f3033e13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f74b39f.html title="Java 異步編程導論">Java 異步編程導論</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cb74cd.html alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b9d102263d0f46a0b5b203d7b6cd4a2e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cb74cd.html title="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記">Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/852c87e.html alt="有了 CompletableFuture，使得異步編程沒有那麼難了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e66a7bcfded64b34b43ebc1565b3e557 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/852c87e.html title="有了 CompletableFuture，使得異步編程沒有那麼難了">有了 CompletableFuture，使得異步編程沒有那麼難了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e8c3b8.html alt=詳解編程中的同步和異步 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b292fb03b256422bb94215ce3ec3bbaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e8c3b8.html title=詳解編程中的同步和異步>詳解編程中的同步和異步</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a0dfd7.html alt="異步編程實例：Java8 API的理解和CompletableFuture類的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522150125651deaa9d51b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a0dfd7.html title="異步編程實例：Java8 API的理解和CompletableFuture類的實現">異步編程實例：Java8 API的理解和CompletableFuture類的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/720d6d3b.html alt=北海人民不能錯過的掌上生活服務辦理平臺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ad2c0c816b5a4c94982e13f61805144f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/720d6d3b.html title=北海人民不能錯過的掌上生活服務辦理平臺>北海人民不能錯過的掌上生活服務辦理平臺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03d16469.html alt=阿里雲彈性伸縮服務簡介，彈性伸縮服務入門掃盲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1538214769522e3e469ade5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03d16469.html title=阿里雲彈性伸縮服務簡介，彈性伸縮服務入門掃盲>阿里雲彈性伸縮服務簡介，彈性伸縮服務入門掃盲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html alt=「編程基礎」PHP基礎教程（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17685aad04c54d02928724fb99fea026 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html title=「編程基礎」PHP基礎教程（二）>「編程基礎」PHP基礎教程（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html alt=「編程基礎」PHP基礎教程（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/355d0f0c0f274bdfaeb90747dbd918fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html title=「編程基礎」PHP基礎教程（一）>「編程基礎」PHP基礎教程（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html alt=零基礎如何學PHP編程語言？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html title=零基礎如何學PHP編程語言？>零基礎如何學PHP編程語言？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html alt=遊戲引擎編程需要哪些基本數學知識？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f6ca97249fa468db6982c44a024979d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html title=遊戲引擎編程需要哪些基本數學知識？>遊戲引擎編程需要哪些基本數學知識？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html alt=UG編程獨當一面，如何提高鑽孔精度方法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532093430052c29be7656f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html title=UG編程獨當一面，如何提高鑽孔精度方法？>UG編程獨當一面，如何提高鑽孔精度方法？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>