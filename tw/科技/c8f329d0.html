<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一個合格的程序員必會Hash詳解 | 极客快訊</title><meta property="og:title" content="一個合格的程序員必會Hash詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/0139af5bf4374f9583277f384c9c343c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c8f329d0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c8f329d0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c8f329d0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c8f329d0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c8f329d0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c8f329d0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c8f329d0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c8f329d0.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="一個合格的程序員必會Hash詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/c8f329d0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一個合格的程序員必會Hash詳解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><ul><li><strong>1. 哈希表的基本思想</strong></li><li><strong>2. 哈希表的相關基本概念</strong></li><li><strong>3. 哈希表的實現方法</strong></li><li><strong>4. 哈希表“定址”的方法</strong></li><li><strong>5. 哈希表“解決衝突”的方法</strong></li><li><strong>6. 哈希表“定址”和“解決衝突”之間的權衡</strong></li><li><strong>7. 哈希表實例</strong></li></ul><p>哈希表（Hash Table）是一種特殊的數據結構，它最大的特點就是可以快速實現查找、插入和刪除。因為它獨有的特點，Hash表經常被用來解決大數據問題，也因此被廣大的程序員所青睞。為了能夠更加靈活地使用Hash來提高我們的代碼效率，今天，我們就談一談Hash的那點事。</p><blockquote><p><strong>1. 哈希表的基本思想</strong></p></blockquote><p><strong></strong>我們知道，數組的最大特點就是：尋址容易，插入和刪除困難；而鏈表正好相反，尋址困難，而插入和刪除操作容易。那麼如果能夠結合兩者的優點，做出一種尋址、插入和刪除操作同樣快速容易的數據結構，那該有多好。這就是哈希表創建的基本思想，而實際上哈希表也實現了這樣的一個“夙願”，<strong>哈希表就是這樣一個集查找、插入和刪除操作於一身的數據結構。</strong></p><p class=ql-align-right>回到頂部</p><blockquote><p><strong>2. 哈希表的相關基本概念</strong></p></blockquote><p>在介紹Hash之前，首先我們要搞明白幾個概念：</p><p><strong>哈希表（Hash Table）</strong>：也叫散列表，是根據關鍵碼值（Key-Value）而直接進行訪問的數據結構，也就是我們常用到的map。</p><p><strong>哈希函數</strong>：也稱為是散列函數，是Hash表的映射函數，它可以把任意長度的輸入變換成固定長度的輸出，該輸出就是哈希值。哈希函數能使對一個數據序列的訪問過程變得更加迅速有效，通過哈希函數數據元素能夠被很快的進行定位。</p><p>哈希表和哈希函數的標準定義：</p><ul><li>若關鍵字為k，則其值存放在f(k)的存儲位置上。由此，不需比較便可直接取得所查記錄。稱這個對應關係f為哈希函數，按這個思想建立的表為哈希表。</li></ul><p>設所有可能出現的關鍵字集合記為U(簡稱全集)。實際發生(即實際存儲)的關鍵字集合記為K（|K|比|U|小得多）。</p><p>散列方法是使用函數h將U映射到表T[0..m-1]的下標上（m=O(|U|)）。這樣以U中關鍵字為自變量，以h為函數的運算結果就是相應結點的存儲地址。從而達到在O(1)時間內就可完成查找。</p><p>其中：</p><p>① h：U→{0，1，2，…，m-1} ，通常稱h為哈希函數(Hash Function)。哈希函數h的作用是壓縮待處理的下標範圍，使待處理的|U|個值減少到m個值，從而降低空間開銷。</p><p>② T為哈希表(Hash Table)。</p><p>③ h(Ki)(Ki∈U)是關鍵字為Ki結點存儲地址(亦稱散列值或散列地址)。</p><p>④ 將結點按其關鍵字的哈希地址存儲到哈希表中的過程稱為散列(Hashing)</p><p><strong>1）衝突：</strong></p><p><strong></strong>兩個不同的關鍵字，由於散列函數值相同，因而被映射到同一表位置上。該現象稱為衝突(Collision)或碰撞。發生衝突的兩個關鍵字稱為該散列函數的同義詞(Synonym)。</p><p>2）安全避免衝突的條件：</p><p>最理想的解決衝突的方法是安全避免衝突。要做到這一點必須滿足兩個條件：</p><p>①其一是|U|≤m</p><p>②其二是選擇合適的散列函數。</p><p>這隻適用於|U|較小，且關鍵字均事先已知的情況，此時經過精心設計散列函數h有可能完全避免衝突。</p><p><strong>3）衝突不可能完全避免</strong></p><p>通常情況下，h是一個壓縮映像。雖然|K|≤m，但|U|>m，故無論怎樣設計h，也不可能完全避免衝突。因此，只能在設計h時儘可能使衝突最少。同時還需要確定解決衝突的方法，使發生衝突的同義詞能夠存儲到表中。</p><p><strong>4）影響衝突的因素</strong></p><p>衝突的頻繁程度除了與h相關外，還與表的填滿程度相關。</p><p>設m和n分別表示表長和表中填入的結點數，則將α=n/m定義為散列表的裝填因子(Load Factor)。α越大，表越滿，衝突的機會也越大。通常取α≤1。</p><p class=ql-align-right>回到頂部</p><blockquote><p><strong>3. 哈希表的實現方法</strong></p></blockquote><p>我們之前說了，哈希表是一個集查找、插入和刪除操作於一身的數據結構。那這麼完美的數據結構到底是怎麼實現的呢？<strong>哈希表有很多種不同的實現方法，為了實現哈希表的創建，這些所有的方法都離不開兩個問題——“定址”和“解決衝突”。</strong></p><p>在這裡，我們通過詳細地介紹哈希表最常用的方法——取餘法（定值）+拉鍊法（解決衝突），來一起窺探一下哈希表強大的優點。</p><p>取餘法大家一定不會感覺陌生，就是我們經常說的取餘數的操作。</p><p>拉鍊法是什麼，“拉鍊”說白了就是“鏈表數組”。我這麼一解釋，大家更暈了，啥是“鏈表數組”啊？為了更好地解釋“鏈表數組”，我們用下圖進行解釋：圖中的主幹部分是一個順序存儲結構數組，但是有的數組元素為空，有的對應一個值，有的對應的是一個鏈表，這就是“鏈表數組”。比如數組0的位置對應一個鏈表，鏈表有兩個元素“496”和“896”，這說明元素“496”和“896”有著同樣的Hash地址，這就是我們上邊介紹的“衝突”或者“碰撞”。但是“鏈表數組”的存儲方式很好地解決了Hash表中的衝突問題，發生衝突的元素會被存在一個對應Hash地址指向的鏈表中。實際上，“鏈表數組”就是一個指針數組，每一個指針指向一個鏈表的頭結點，鏈表可能為空，也可能不為空。</p><div class=pgc-img><img alt=一個合格的程序員必會Hash詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0139af5bf4374f9583277f384c9c343c><p class=pgc-img-caption></p></div><p>說完這些，大家肯定已經理解了“鏈表數組”的概念，那我們就一起看看Hash表是如何根據“取餘法+拉鍊法”構建的吧。</p><p>將所有關鍵字為同義詞的結點鏈接在同一個鏈表中。若選定的散列表長度為m，則可將散列表定義為一個由m個頭指針組成的指針數組T[0..m-1]。凡是散列地址為i的結點，均插入到以T[i]為頭指針的單鏈表中。T中各分量的初值均應為空指針。在拉鍊法中，裝填因子α可以大於1，但一般均取α≤1。</p><p>舉例說明拉鍊法的執行過程，設有一組關鍵字為(26，36，41，38，44，15，68，12，6，51)，用取餘法構造散列函數，初始情況如下圖所示：</p><div class=pgc-img><img alt=一個合格的程序員必會Hash詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2d6a433af5945b293b32626898594e3><p class=pgc-img-caption></p></div><p>最終結果如下圖所示：</p><div class=pgc-img><img alt=一個合格的程序員必會Hash詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddc8740b4491424794015bbd18edde01><p class=pgc-img-caption></p></div><p>理解了Hash表的創建，那根據建立的Hash表進行查找就很容易被理解了。</p><p>查找操作，如果理解了插入和刪除，查找操作就比較簡單了，令待查找的關鍵字是x，也可分為幾種情況：</p><p>1）x所屬的Hash地址未被佔用，即不存在與x相同的Hash地址關鍵字，當然也不存在x了；</p><p>2）x所屬的Hash地址被佔用了，但它所存的關鍵不屬於這個Hash地址，與1）相同，不存在與x相同Hash地址的關鍵字；</p><p>3）x所屬的Hash地址被佔用了，且它所存的關鍵屬於這個Hash地址，即存在與x相同sHash地址的關鍵字，只是不知這個關鍵字是不是x，需要進一步查找。</p><p>由此可見，Hash表插入、刪除和插入操作的效率都相當的高。</p><p><strong>思考一個問題：如果關鍵字是字符串怎麼辦？我們怎麼根據字符串建立Hash表？</strong></p><p>通常都是將元素的key轉換為數字進行散列，如果key本身就是整數，那麼散列函數可以採用keymod tablesize（要保證tablesize是質數）。而在實際工作中經常用字符串作為關鍵字，例如身姓名、職位等等。這個時候需要設計一個好的散列函數進程處理關鍵字為字符串的元素。參考《數據結構與算法分析》第5章，有以下幾種處理方法：</p><p><strong>方法1：</strong>將字符串的所有的字符的ASCII碼值進行相加，將所得和作為元素的關鍵字。設計的散列函數如下所示：</p><pre>int hash(const string&amp; key,int tablesize){ int hashVal = 0; for(int i=0;i&lt;key.length();i++) hashVal += key[i]; return hashVal % tableSize;}</pre><p>此方法的缺點是不能有效的分佈元素，例如假設關鍵字是有8個字母構成的字符串，散列表的長度為10007。字母最大的ASCII碼為127，按照方法1可得到關鍵字對應的最大數值為127×8=1016，也就是說通過散列函數映射時只能映射到散列表的槽0-1016之間，這樣導致大部分槽沒有用到，分佈不均勻，從而效率低下。</p><p><strong>方法2：</strong>假設關鍵字至少有三個字母構成，散列函數只是取前三個字母進行散列。設計的散列函數如下所示：</p><pre>int hash(const string&amp; key,int tablesize){ //27 represents the number of letters plus the blank return (key[0]+27*key[1]+729*key[2])%tablesize;}</pre><p>該方法只是取字符串的前三個字符的ASCII碼進行散列，最大的得到的數值是2851，如果散列的長度為10007，那麼只有28%的空間被用到，大部分空間沒有用到。因此如果散列表太大，就不太適用。</p><p><strong>方法3</strong>：藉助Horner's 規則，構造一個質數（通常是37）的多項式，（非常的巧妙，不知道為何是37）。計算公式為:key[keysize-i-1]*37<sup>i</sup>, 0&lt;=i&lt;keysize求和。設計的散列函數如下所示：</p><pre>int hash(const string &amp; key,int tablesize){ int hashVal = 0; for(int i =0;i&lt;key.length();i++) hashVal = 37*hashVal + key[i]; hashVal %= tableSize; if(hashVal&lt;0) //計算的hashVal溢出 hashVal += tableSize; return hashVal;}</pre><p>該方法存在的問題是如果字符串關鍵字比較長，散列函數的計算過程就變長，有可能導致計算的hashVal溢出。針對這種情況可以採取字符串的部分字符進行計算，例如計算偶數或者奇數位的字符。</p><p class=ql-align-right>回到頂部</p><blockquote><p><strong>4. 哈希表“定址”的方法</strong></p></blockquote><p>其實常用的“定址”的手法有“五種”：</p><p><strong>1）直接定址法</strong></p><p>很容易理解，key=Value+C；這個“C"是常量。Value+C其實就是一個簡單的哈希函數。</p><p><strong>2）除法取餘法</strong></p><p>key=value%C</p><p><strong>3）數字分析法</strong></p><p>這種蠻有意思，比如有一組value1=112233，value2=112633，value3=119033，針對這樣的數我們分析數中間兩個數比較波動，其他數不變。那麼我們取key的值就可以是key1=22,key2=26,key3=90。</p><p><strong>4）平方取中法</strong></p><p><strong>5）摺疊法</strong></p><p>舉個例子，比如value=135790，要求key是2位數的散列值。那麼我們將value變為13+57+90=160，然後去掉高位“1”,此時key=60，哈哈，這就是他們的哈希關係，這樣做的目的就是key與每一位value都相關，來做到“散列地址”儘可能分散的目地。</p><p>影響哈希查找效率的一個重要因素是哈希函數本身。當兩個不同的數據元素的哈希值相同時，就會發生衝突。為減少發生衝突的可能性，哈希函數應該將數據儘可能分散地映射到哈希表的每一個表項中。</p><p class=ql-align-right>回到頂部</p><blockquote><p><strong>5. 哈希表“解決衝突”的方法</strong></p></blockquote><p>Hash表解決衝突的方法主要有以下兩種：</p><p>1）開放地址法</p><p>如果兩個數據元素的哈希值相同，則在哈希表中為後插入的數據元素另外選擇一個表項。當程序查找哈希表時，如果沒有在第一個對應的哈希表項中找到符合查找要求的數據元素，程序就會繼續往後查找，直到找到一個符合查找要求的數據元素，或者遇到一個空的表項。</p><p>開放地址法包括線性探測、二次探測以及雙重散列等方法。其中線性探測法示意圖如下：</p><div class=pgc-img><img alt=一個合格的程序員必會Hash詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dd4a2aedbeb54dda972ac3a6ad0a8846><p class=pgc-img-caption></p></div><p>散列過程如下圖所示：</p><div class=pgc-img><img alt=一個合格的程序員必會Hash詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9bcb1ea080984182b0795717283196a9><p class=pgc-img-caption></p></div><p>2）鏈地址法</p><p>將哈希值相同的數據元素存放在一個鏈表中，在查找哈希表的過程中，當查找到這個鏈表時，必須採用線性查找方法。</p><p class=ql-align-right>回到頂部</p><blockquote><p><strong>6. 哈希表“定址”和“解決衝突”之間的權衡</strong></p></blockquote><p>雖然哈希表是在關鍵字和存儲位置之間建立了對應關係，但是由於衝突的發生，哈希表的查找仍然是一個和關鍵字比較的過程，不過哈希表平均查找長度比順序查找要小得多，比二分查找也小。</p><p><strong>查找過程中需和給定值進行比較的關鍵字個數取決於下列三個因素：哈希函數、處理衝突的方法和哈希表的裝填因子。</strong></p><p>哈希函數的"好壞"首先影響出現衝突的頻繁程度，但如果哈希函數是均勻的，則一般不考慮它對平均查找長度的影響。</p><p>對同一組關鍵字，設定相同的哈希函數，但使用不同的衝突處理方法，會得到不同的哈希表，它們的平均查找長度也不同。</p><p>一般情況下，處理衝突方法相同的哈希表，其平均查找長度依賴於哈希表的裝填因子α。顯然，α越小，產生衝突的機會就越大；但α過小，空間的浪費就過多。通過選擇一個合適的裝填因子α，可以將平均查找長度限定在一個範圍內。</p><p>總而言之，哈希表“定址”和“解決衝突”之間的權衡決定了哈希表的性能。</p><p class=ql-align-right>回到頂部</p><blockquote><p><strong>7. 哈希表實例</strong></p></blockquote><p>一個哈希表實現的C++實例，在此設計的散列表針對的是關鍵字為字符串的元素，採用字符串散列函數方法3進行設計散列函數，採用鏈接方法處理碰撞，然後採用根據裝載因子（指定為1，同時將n個元素映射到一個鏈表上，即n==m時候）進行再散列。採用C++，藉助vector和list，設計的hash表框架如下：</p><pre>template &lt;class T&gt;class HashTable{public: HashTable(int size = 101); int insert(const T&amp; x); int remove(const T&amp; x); int contains(const T&amp; x); void make_empty(); void display()const;private: vector&lt;list&lt;T&gt; &gt; lists; int currentSize;//當前散列表中元素的個數 int hash(const string&amp; key); int myhash(const T&amp; x); void rehash();};</pre><p>實現的完整程序如下所示：</p><pre>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int nextPrime(const int n);template &lt;class T&gt;class HashTable{public: HashTable(int size = 101); int insert(const T&amp; x); int remove(const T&amp; x); int contains(const T&amp; x); void make_empty(); void display()const;private: vector&lt;list&lt;T&gt; &gt; lists; int currentSize; int hash(const string&amp; key); int myhash(const T&amp; x); void rehash();};template &lt;class T&gt;HashTable&lt;T&gt;::HashTable(int size){ lists = vector&lt;list&lt;T&gt; &gt;(size); currentSize = 0;}template &lt;class T&gt;int HashTable&lt;T&gt;::hash(const string&amp; key){ int hashVal = 0; int tableSize = lists.size(); for(int i=0;i&lt;key.length();i++) hashVal = 37*hashVal+key[i]; hashVal %= tableSize; if(hashVal &lt; 0) hashVal += tableSize; return hashVal;}template &lt;class T&gt;int HashTable&lt;T&gt;:: myhash(const T&amp; x){ string key = x.getName(); return hash(key);}template &lt;class T&gt;int HashTable&lt;T&gt;::insert(const T&amp; x){ list&lt;T&gt; &amp;whichlist = lists[myhash(x)]; if(find(whichlist.begin(),whichlist.end(),x) != whichlist.end()) return 0; whichlist.push_back(x); currentSize = currentSize + 1; if(currentSize &gt; lists.size()) rehash(); return 1;}template &lt;class T&gt;int HashTable&lt;T&gt;::remove(const T&amp; x){ typename std::list&lt;T&gt;::iterator iter; list&lt;T&gt; &amp;whichlist = lists[myhash(x)]; iter = find(whichlist.begin(),whichlist.end(),x); if( iter != whichlist.end()) { whichlist.erase(iter); currentSize--; return 1; } return 0;}template &lt;class T&gt;int HashTable&lt;T&gt;::contains(const T&amp; x){ list&lt;T&gt; whichlist; typename std::list&lt;T&gt;::iterator iter; whichlist = lists[myhash(x)]; iter = find(whichlist.begin(),whichlist.end(),x); if( iter != whichlist.end()) return 1; return 0;}template &lt;class T&gt;void HashTable&lt;T&gt;::make_empty(){ for(int i=0;i&lt;lists.size();i++) lists[i].clear(); currentSize = 0; return 0;}template &lt;class T&gt;void HashTable&lt;T&gt;::rehash(){ vector&lt;list&lt;T&gt; &gt; oldLists = lists; lists.resize(nextPrime(2*lists.size())); for(int i=0;i&lt;lists.size();i++) lists[i].clear(); currentSize = 0; for(int i=0;i&lt;oldLists.size();i++) { typename std::list&lt;T&gt;::iterator iter = oldLists[i].begin(); while(iter != oldLists[i].end()) insert(*iter++); }}template &lt;class T&gt;void HashTable&lt;T&gt;::display()const{ for(int i=0;i&lt;lists.size();i++) { cout&lt;&lt;i&lt;&lt;": "; typename std::list&lt;T&gt;::const_iterator iter = lists[i].begin(); while(iter != lists[i].end()) { cout&lt;&lt;*iter&lt;&lt;" "; ++iter; } cout&lt;&lt;endl; }}int nextPrime(const int n){ int ret,i; ret = n; while(1) { int flag = 1; for(i=2;i&lt;sqrt(ret);i++) if(ret % i == 0) { flag = 0; break; } if(flag == 1) break; else { ret = ret +1; continue; } } return ret;}class Employee{public: Employee(){} Employee(const string n,int s=0):name(n),salary(s){ } const string &amp; getName()const { return name; } bool operator == (const Employee &amp;rhs) const { return getName() == rhs.getName(); } bool operator != (const Employee &amp;rhs) const { return !(*this == rhs); } friend ostream&amp; operator &lt;&lt;(ostream&amp; out,const Employee&amp; e) { out&lt;&lt;"("&lt;&lt;e.name&lt;&lt;","&lt;&lt;e.salary&lt;&lt;") "; return out; }private: string name; int salary;};int main(){ Employee e1("Tom",6000); Employee e2("Anker",7000); Employee e3("Jermey",8000); Employee e4("Lucy",7500); HashTable&lt;Employee&gt; emp_table(13); emp_table.insert(e1); emp_table.insert(e2); emp_table.insert(e3); emp_table.insert(e4); cout&lt;&lt;"Hash table is: "&lt;&lt;endl; emp_table.display(); if(emp_table.contains(e4) == 1) cout&lt;&lt;"Tom is exist in hash table"&lt;&lt;endl; if(emp_table.remove(e1) == 1) cout&lt;&lt;"Removing Tom form the hash table successfully"&lt;&lt;endl; if(emp_table.contains(e1) == 1) cout&lt;&lt;"Tom is exist in hash table"&lt;&lt;endl; else cout&lt;&lt;"Tom is not exist in hash table"&lt;&lt;endl; //emp_table.display(); exit(0);}</pre><blockquote><p><strong>作者：Poll的筆記</strong></p><p><strong>原文：http://www.cnblogs.com/maybe2030/p/4719267.html</strong></p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>一個</a></li><li><a>必會</a></li><li><a>Hash</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html alt=30分鐘教你搭建一個網站（一）：購買和配置服務器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5f26f1582a564e93bde33a7dd9448c3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html title=30分鐘教你搭建一個網站（一）：購買和配置服務器>30分鐘教你搭建一個網站（一）：購買和配置服務器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html alt=不會買服務器？一個辦法讓你輕鬆搭網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84d9c54578de46058796824f1bcb6a9b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html title=不會買服務器？一個辦法讓你輕鬆搭網站>不會買服務器？一個辦法讓你輕鬆搭網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html alt=使用服務器搭建一個網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/63a6cc0eb4d146e0890515500c0040ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html title=使用服務器搭建一個網站>使用服務器搭建一個網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html alt=做一個小型網站，服務器需要什麼配置的呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html title=做一個小型網站，服務器需要什麼配置的呢？>做一個小型網站，服務器需要什麼配置的呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html alt=搭建一個網站，租服務器大概多少錢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html title=搭建一個網站，租服務器大概多少錢？>搭建一個網站，租服務器大概多少錢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html alt=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5e7b0005767168b2b87d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html title=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！>素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html alt=一個男人每天24小時跟妻子在一起，久而久之會怎樣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8359cc22f03e478a8cdb889dcfea3f99 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html title=一個男人每天24小時跟妻子在一起，久而久之會怎樣>一個男人每天24小時跟妻子在一起，久而久之會怎樣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html alt=每天一個好習慣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RKdGgquJFM6gnc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html title=每天一個好習慣>每天一個好習慣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html alt=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/3fd8ec4e-64c1-446a-adfa-38088fb06c01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html title=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點>奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html alt=又一個走上不歸路的搬磚人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bf471da0a06441f88bce49b959234257 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html title=又一個走上不歸路的搬磚人>又一個走上不歸路的搬磚人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html alt=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/833949926ebf49b89c5fb4075a9cffdd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html title=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏>多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/917424fc.html alt=一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5b430002414bdad7cc1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/917424fc.html title=一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位>一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25157041.html alt=聖胡安（波多黎各）：一個很不美國的美國城市 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d049f3231cda4890ae11c23b2c8f8f70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25157041.html title=聖胡安（波多黎各）：一個很不美國的美國城市>聖胡安（波多黎各）：一個很不美國的美國城市</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2ca7396.html alt=人工智能的下一個春天：情緒和情感計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ReV1j945oIOAmo style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2ca7396.html title=人工智能的下一個春天：情緒和情感計算>人工智能的下一個春天：情緒和情感計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f649e4a6.html alt=舊廠房孵化新科技——一個國家級高新區的“雙創”見聞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f649e4a6.html title=舊廠房孵化新科技——一個國家級高新區的“雙創”見聞>舊廠房孵化新科技——一個國家級高新區的“雙創”見聞</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>