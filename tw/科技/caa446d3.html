<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高中生一年從0到0day的祕密 | 极客快訊</title><meta property="og:title" content="高中生一年從0到0day的祕密 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/002dfa18f7e94f0f9e19ef4a8c155e68"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/caa446d3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/caa446d3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/caa446d3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/caa446d3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/caa446d3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/caa446d3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/caa446d3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/caa446d3.html><meta property="article:published_time" content="2020-11-14T21:00:51+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:51+08:00"><meta name=Keywords content><meta name=description content="高中生一年從0到0day的祕密"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/caa446d3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高中生一年從0到0day的祕密</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>在第35屆混沌通信大會上 (35C3)，今年上大一的 Jonathan Jacobi 發表了題為《從0到 0day》講述了自己如何從安全基礎幾乎為零的情況下，用了一年多點的時間在 Edge 瀏覽器中找到了自己的首個 0day 漏洞。他希望對有志於從事安全事業的新手帶來一些幫助，同時希望對學習更多關於瀏覽器漏洞和利用知識的老手帶來一些啟發。以下是360代碼衛士團隊根據他的演講視頻整理的內容：</strong></p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/002dfa18f7e94f0f9e19ef4a8c155e68><p class=pgc-img-caption></p></div><p><strong>我是誰？</strong></p><p>大家好，我叫 Jonathan，現在18歲，是一名計算機科學和數學專業的學生，對漏洞研究感興趣，也是微軟 MSRC-IL 的一名安全研究員。我也打 CTF 比賽，所在團隊是 Perfect Blue。</p><p>我在去年才開始接觸安全研究，這次演講的第一部分主要說一下我在一年中都學了什麼以及是如何學的；第二部分說一下我是如何從 ChakraCore 中找到第一個 0day 漏洞（JIT類型混淆漏洞）的。可能你剛剛接觸安全領域，只知道一些基礎的編程知識，但可能你也能聽懂。雖然我會講很多代碼，但還好，不是太複雜。最後，我們看下演示。好的，我們開始吧。</p><p><strong>知識和實踐準備</strong></p><p>我為什麼要研究漏洞？對我而言，漏洞就像是一個謎，非常具有挑戰性的東西。我們必須找到開發人員未考慮到的一些缺陷。至少對我而言這很具有挑戰性，也非常有意思。我覺得挖漏洞是個很棒的事情。</p><p>那麼，什麼是漏洞呢？關於漏洞的定義很多。當你想了解某件事的時候，你就會去維基百科上搜索。上面有很多不同的解釋，而且有一些看起來很古怪，比如有一個解釋是這麼說的，“某資產無法抵禦威脅攻擊動作的可能性”。我不懂它到底說的是什麼。我的理解是，漏洞就是程序中出現的各種缺陷，你可以用來改變程序的控制流。這就是我對漏洞的理解，但定義沒有告訴我如何找到一個漏洞。</p><p>那麼，我們怎麼才能找到漏洞呢？我當時開始找漏洞時有一些編程基礎，我不是寫程序最優秀的開發，也就是“還行”的水平，知道C語言、彙編語言，學了一些操作系統內部知識，瞭解操作系統是會如何運作的，能讀一些 python 代碼。所以我雖然並不是最優秀的開發，但我具備一些相關知識。比如，我從一本很不錯的希伯來語書中瞭解了一些 C++ 語言的知識，以便我真正地開展漏洞研究。</p><p>下一步，我瞭解了一些漏洞的基礎知識，如一些基礎的漏洞類型像典型的堆緩衝溢出問題、整數溢出等。之後我就開始通過模擬演習開始實踐自己所學的知識。模擬演習是可以在線下解決的安全挑戰，這些挑戰問題包括找到漏洞並利用它。最開始的時候我敗得一塌糊塗，但隨著時間的推移，我認為失敗了也沒關係，因為我看了解決方案、write-up，我知道了如何寫解決方案，如何解決問題。所以最開始失敗沒關係，因為我們每個人都是這樣過來的。之後我開始參加 CTF 比賽。</p><blockquote><p>CTF 比賽要求團隊作戰，這就是我找到團隊成員的方式，我們通過 CTF 相識，然後一起打比賽。有時候我們輸得很慘，有時候我們打得不錯進了決賽，還一起周遊世界，因為有時候賽事主辦方會支付差旅費，哈哈。我們去了很多很酷的地方，真的很爽。</p></blockquote><p>我認為 CTF 比賽是進入安全領域的一個很好的方式。</p><p>之後我決定“潛入深水區”。一旦你瞭解了基礎知識之後，不要在“淺水區”停留太長的時間，這一點很重要，我們要給自己一些挑戰。剛開始我害怕失敗，但是隨著時間的流逝，我想明白了，失敗也沒什麼可怕的。失敗後我能找到解決問題的技術。所以我認為這一點很重要：不要害怕失敗，即使失敗了，我們也能從別人的解決方案中學到東西。</p><blockquote><p>LiveOverflow 發的一條推文說得很好：學到基礎後，儘快去做自己不懂的更難的事；不斷地接觸自己不懂的事情，然後重新來看自以為懂但實際上不懂的事情；然後從各種資源瞭解信息，學習從多個角度和方向一步步解決問題。</p></blockquote><p>我認為這樣做很重要。LiveOverFlow 也有 YouTube 頻道，我也在看，講的是漏洞和安全問題。推薦大家也可以關注他。</p><p>我具備一些知識後，通過 CTF 比賽、模擬演示等不斷實踐、實踐、再實踐。不斷實踐、自己解決問題很重要，因為這樣你才能知道解決問題的技巧，然後再自己解決遇到的問題。一些漏洞是有特定模式的，要了解這些模式，你就需要多看幾次。發現這些模式的一種好方法就是不斷解決問題。這也是我為什麼喜歡解決真實漏洞問題的原因，很多網站提供不少這樣的途徑，比如 Project Zero 的 0day 項目，你可以讀取一些漏洞信息等。</p><p>我還發現CTF 和真實環境中的漏洞之間存在很大的關聯，它們同時存在於 CTF 和真實世界中。漏洞實際上就是由 bug引起的。你在真正著手開始進行研究時遇到的最大問題就是代碼庫過於龐大（因此你可能會頭大）。但實際上即使代碼框架很龐大，但漏洞還是在具體某處。所以，不要發愁看代碼庫，因為漏洞很可能就恰好在你開始查看具體的某些代碼時出現。之後你可以開始嘗試解決問題，即開始瞭解真正的代碼庫。</p><p>經過一些實踐後，我在想我們如何發現漏洞呢？當我們開始真正重複解決問題、實踐的過程後，我發現漏洞研究就是關於找到 bug，而我們是通過讀代碼實現這個目標的。因此，審計代碼很重要，因為我們想從中找到漏洞，對吧？而這需要我們真正審計代碼，需要實踐。因此實踐在漏洞研究中起著非常重要的作用。因此我們搞砸了的時候可能就是更接近找到漏洞的時候。因此我認為實踐很重要。</p><p>那我是如何發現漏洞的？我之前說過漏洞存在模式，而模式是通過時間的積累發現的。但我並沒有研究很長的時間，只有短短的一年，那麼我是如何發現漏洞的？實際上就是通過不斷實踐發現的。像我之前說過的那樣，多實踐能彌補開始晚的問題。我發現漏洞裡面有一些模式，比如編程錯誤像整數溢出或類型混淆問題，這些問題實際上是存在的，因為人總是會犯錯的。人類會犯錯，我們並不是完美的。下面的代碼就是一個很好的例子。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/370ee8d1a11e413690369ff999052f26><p class=pgc-img-caption></p></div><p>第3行有一個整數溢出漏洞。很多開發人員都瞭解這些漏洞，但仍然可能會犯錯。就像我之前說過的，人總會犯錯。所以不要懼怕在繁雜的代碼框架中去審計代碼。這種類型的漏洞實際上是真實的存在於代碼框架中，而不僅僅侷限於 CTF 比賽，所以，只要不懼怕找漏洞的難度，你就能發現這類簡單的漏洞。</p><p>CTF 和真實環境中的漏洞之間存在一個很大的不同之處。在 CTF 比賽中，通常當你發現問題時，你就大概知道該怎麼處理它、如何去利用它等。比如，遇到溢出問題時，你需要去覆寫變量或返回地址等。所以當你在 CTF 比賽中遇到漏洞時，大多數時候你知道怎麼處理它，而在真實環境中，你有的只是像 “state（狀態）”這樣的詞，以及一些原語 (premitives)，而原語是攻擊者具備的一些能力，因此我們需要鏈接 (chain) 這些原語，做一些影響更大的事情，從而觸發更大的漏洞。我在 Chakra 中找到的就是這種漏洞。這些就是我在開始查看 Chakra 之前所瞭解到的漏洞研究和安全研究知識。</p><p><strong>Chakra 0day 相關背景知識</strong></p><p>我們說說 JavaScript。先說 JavaScript 引擎。有人會說你之前沒說你學過 JavaScript 啊。我確實沒說，因為我真的沒學過。JS 是一種非常可靠的語言，當你學會一些編程語言後，學習 JavaScript 的過程可能會更順暢一些。因此，做到這一點應該不會太難。</p><p>JavaScript 引擎負責運行開發編寫的 JS 代碼。它由很多部分組成，對我們而言最重要的是 JIT 編譯器，它的作用是當有些函數變得很熱門被調用很多次時，它會把這個函數編譯成機器代碼來改進它的性能。JIT 編譯器還負責優化代碼。它具有很多針對代碼的假設，它不希望這些假設崩潰。我們隨後會講講 JIT 編譯器中出現的相關漏洞問題。</p><p>來了解下 JavaScript 的基礎知識，它是一種動態輸入語言，可讀性尚可。JS 對象具有“原型”，用於從其它對象中繼承各種功能，它在漏洞發現過程中很重要。它可通過 _proto_ 屬性更改對象的原型進行修改。 Proxy 是可用於重新定義基礎操作的對象。我們可以通過這些基礎操作，將調用限制在 getter 和 setter 等函數中。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2bd2e407c99c43038a8ac0e502dafa75><p class=pgc-img-caption></p></div><p>來看下 ChakraCore。JavaScript 具有數組，而 ChakraCore 具有類型數組。我們來看看第一種類型 JavascriptNativeIntArray。它用於存儲整數，每個元素具有四個字節。（舉例： varint_arr=[1]）另外一種類型是 JavascriptNativeFloatArray，它用於存儲浮點數，和C語言不同，它的每個元素具有8個字節（舉例 varfloat_arr=[13.37]）。 JavascriptArray 用於存儲對象（主要是指針），每個元素具有8個字節（舉例： varobject_arr=[{}]）。</p><p>我們來看下如何轉換這些類型。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d30b4f7655414b19b8376aef05249e7a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/160119e635ee4e28b2d33a7c42e7153d><p class=pgc-img-caption></p></div><p>其中最後一種 (也就是 aray2._proto_=array1 中的 array1 直接轉換為 JavascriptArray) 轉換在 JavaScript 引擎很少見，但對於我們今天講的主題很重要。當我們有兩個數組，並將其中一個設置為另外一個的原型，那麼充當原型的這個數組就會被直接轉換為 JavascriptArray。這一點我們稍後再著重講。</p><p>我們再來看看這些數組在內存中是什麼樣的。舉個例子：</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/12630cb54fd24358a677ca5b987cedec><p class=pgc-img-caption></p></div><p>我們來看看實際在內存中，當調試如下樣本代碼時，可以看到我們剛才提到的字段狀態 (vararr=[0xaaaaaa,0x31377];)。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4a7e812d711d4b3cb60b12e15728c4fa><p class=pgc-img-caption></p></div><p>紅框部分是 JavascriptArray 屬性，我們能看到數組的初始值，也就是 ArrayFlags 的值。綠框部分是實際的片段屬性，它有長度、大小。藍框是片段的內存佈局（包括元素，下圖的地址是 pArr->head）。圖中右下角我們定義了兩個片段。那麼什麼是 ArrayFlags ？它們是提示數組的某些東西的一些 flag。在這個案例中，它被定義為一個枚舉類型。我們感興趣的字段是 JavascriptArray 的 arrayFlags 字段 HasNoMissingValues（如下圖）。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2790dd42c8048088747cff1110f8279><p class=pgc-img-caption></p></div><p>在我們的例子中，被我們定義為 ArrayFlags 的 InitialArrayValue 實際上由兩個不同的 flag 組成：一個是 ObjectArrayFlagsTag flag，它和我們講的內容不重要就不講了；我們將重點看第二個 HasNoMissingValues flag，它說明數組並不存在缺失的值，也就是說數組中不存在任何洞 (holes)。那麼，“洞”是什麼意思？我們創建一個數組，元素之間有一些值。在 ChakraCore 案例中，它有三個元素，但中間的一個元素是缺失的。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/28550d7966d84a56a3b6d29ee77ac8b6><p class=pgc-img-caption></p></div><p>放在這裡的值，它們在內存中表示為這些常數。我舉這個例子是因為這樣我們更容易地能在內存佈局中發現它們。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1b3676ed72c248b4a647dec555c16881><p class=pgc-img-caption></p></div><p>像這裡（如上圖）就存在一個“洞”，它並沒有開啟 HasNoMissingValues，也就是說數組中存在洞，數組中確實存在缺失的值。這看似很合理，但當我們查看內存佈局時，我們會發現一些奇怪之處。我們來看下這些所謂的“缺失的值”是如何在內存中表示的。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1d49a803e89b4161afa134221bea34a3><p class=pgc-img-caption></p></div><p>這（上圖）是片段的內存轉儲，紅色部分是數組的元素。我們看到 deadbeef deadbeef ，但在中間即“缺失的值”（“洞”）的位置，我們看到了一些 Magic 常數。 0xfff80002fff80002是從哪裡來的？這些常數代表的是“缺失的值”或者說數組中的“洞”似乎能說得通。但如之前所述，我們已經知道有一些東西能代表“缺失的值”，就是沒有 HasNoMissingValues flag。而現在我們似乎發現了另外一種表示方法，就是數組的內容（上面提到的 Magic 常量）。</p><p>這很奇怪，也引發了很多問題：數組的 flag 和數組的內容不匹配怎麼辦？ HasNoMissingValues 設為真，那麼就意味著不存在任何“洞”；但是 數組中實際上存在一個“缺失的值”。另外，我們在某種程度上把“數據”和“元數據”混為一談了，因為如果把常量當作控制流，那麼我們如果能夠偽造它的話就很有意思了。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a784699f63b0427eaad8837daee96366><p class=pgc-img-caption></p></div><p>事實證明，我們真的能夠偽造這個“缺失的值”。這是由 @s0rryMybad 和 @lokihardt 發現的漏洞（如上圖），獲得了CVE 編號 CVE-2018-8505。他們就是把我們之前看到的常量轉換為浮點數數組，從而偽造了“缺失的值”，進而發現了漏洞。緩解這個漏洞的方法有很多，可以通過不斷更改這個Magic值常量或增加更多的檢查加固安全性。</p><p>我們上面講的是如何能將這些奇怪的狀態轉變為我們實際上能利用的漏洞。首先我們先來看看一些有意思的東西。之前@s0rryMybad 和 @lokihardt 發現的漏洞是原生的浮點數數組。顯然，JavascriptArray 並不直接將浮點數組存儲為真正的浮點數，而是這些值被 “boxed”，然後以常量進行 XORed （下圖）。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b644ff77db114ba38ef66165ac3116f3><p class=pgc-img-caption></p></div><p>那麼問題就變成，我們能否在 JavascriptArray 中使用同樣的“缺失的值”技巧？如果能的話，那麼常數會改變嗎？因為我們從上面的例子看到，我們更改了值的代表方式，我們才能表示新的值。從理論上來講，引擎應當能改變常量，否則我們就可能表示它。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7c51199d0bac43a6a8d32e45fabd3b69><p class=pgc-img-caption></p></div><p>而事實上，常量並沒有改變，因此我們就能表示它。首先對其進行 boxing，然後通過之前的常量值（ 0xfff80002fff80002）對常量進行 XORed（ xor(magic,FlatTag_Value)）。這樣，我們得到的常量還是原始值，因此值就是原始值。當你 XORed 三個元素，其中兩個元素是相同的，這樣做是不允許的，它會給你原始的值。但如果我們讓其中的一個的值是 0xFFFcull&lt;&lt;48，那麼我們就能返回 Magic 值表示值。</p><p>而正是在這裡，我找到了漏洞。我們依靠的是 JavaScript 引擎的基礎知識，而boxing 就是我們最先會學到的東西。我們使用 boxing 的想法，利用這種應該不會被利用的狀態找到了漏洞。</p><p>那麼我們是如何把這種奇怪的狀態轉變為漏洞的？先來看看什麼是 JIT 類型混淆漏洞。我們現在常見的 JIT 漏洞是類型混淆。JIT 類型混淆實際上是兩種類型的混淆，是指因 JIT 做出了錯誤的假設而發生的漏洞，最常見的是發生“Side-Effect”，也就是發生了一些 JIT 並未意識到的事情。例如，JITed 函數調用函數 foo()，更改了某些對象比如是數組的類型，而 JITed 函數並不知道轉換已發生，使用了數組之前的類型，從而導致 JITed 代碼中出現類型混淆情況，從而可能導致 RCE 漏洞的發生。舉個例子：（如下圖）</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27bdc6058ebf443a96e3ba29bc26427d><p class=pgc-img-caption></p></div><p><strong>我如何發現 Chakra 0day？</strong></p><p>Loki 和 S0rryMybad 發現 Array.prototype.concat 具有一個有意思的代碼路徑，它同時考慮了 HasNoMissingValues 和數組元素的值，而兩人成功讓 HasNoMissingValues 和數組值不匹配。他們成功在數組中偽造一個“缺失的值（以下稱為 buggy）”後，以下代碼就會觸發一個有意思的流：</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a9eab6625f6b4fd9acd9898e79e4ef64><p class=pgc-img-caption></p></div><p>之後，我們看到如下 if 語句：</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dd54bd9755f3401c822dc0e97d4999cc><p class=pgc-img-caption></p></div><p>首先我們來看函數 ConcatArgs。這裡的 aItem 就是偽造的數組，也就是 buggy。我們想讓 isFillFromPrototypes 返回假值，如果 HasNoMissingVlues 已設置如下。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/996e68c8b7dc47dd84bb3cab24b67918><p class=pgc-img-caption></p></div><p>isFillFromPrototyps 檢查數組只有一個片段，也就是通過檢查下一個頭部片段是否為空，沒有“缺失的值”。它確保長度匹配，也就是數組的長度和片段的長度相等。因此這個片段就是數組中的唯一一個片段。這是它做的第一個檢查。它做的第二個檢查是 flag 將 HasNoMissingValues 設為真，這一點可被輕鬆繞過。這樣我們就能讓 isFillFromPrototypes() 返回假值，然後進入 if 語句。</p><p>通過 isFillFromPrototypes() 檢查後，我們看到如下的 else 語句，因為我們的數組並非原生數組。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f268b2697fbf4643a3e512ac7456aaa1><p class=pgc-img-caption></p></div><p>如下圖， srcArray 就是我們創建的虛假的“缺失的值”數組（也就是我們說的 buggy）。首先讓數組本身進行迭代，當且只當沒有找到所有的元素時，才在數組的原型上進行迭代。 Enumerator 會枚舉數組中的所有的元素。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fac7fc89bc9e45149272fdfc043fd550><p class=pgc-img-caption></p></div><p>我們看下它是如何實現的。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d4d7e34bb0e741b59ef45c3c13e7e964><p class=pgc-img-caption></p></div><p>通過 ArrayElementEnumerator 迭代源數組，如果值是“缺失的值（ ==0xfff80002fff80002）”，則會跳過該元素。這裡發生了什麼呢？就是我們每次進入 while 循環時，如果發現是“缺失的值”，則會跳過它。迭代器會跳過缺失的值，所以它的計數和數組中的元素數目不一致。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/847fc219f65647e09979c82c57c7158a><p class=pgc-img-caption></p></div><p>還有一個函數也很有意思。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c699c63cdbf34b22bfd2aec39a8cc401><p class=pgc-img-caption></p></div><p>它做的第一件事就是在原型 (prototype) 鏈之間循環。我們之前說過，原型可以是繼承功能的對象。那麼我們可以自己創建一個原型、另外一個原型，從而偽造一個原型鏈。這個函數首先進行循環原型鏈，然後調用帶有 prototype 參數的這個具有很長名字的函數。這個原型是一個 JavaScriptArray，然後我們對其進行循環。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5838a0af1e4f4c0d95a756600a557d63><p class=pgc-img-caption></p></div><p>所以， ForEachOwnMissingArrayIndexOfObject 為原型鏈中的每個原型調用了 EnsureNonNativeArray。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4f570693caf3443682f546ebfa8a3523><p class=pgc-img-caption></p></div><p>我們來快速回顧一下。如果我們創建一個帶有偽造的 MissingValue 的數字，但設置了 HasNoMissingValue flag，那麼我們就能得到來自 Array.prototype.concat() 的有意思的代碼流。它會循環偽造數組的原型鏈，並保證這個鏈中的每個原型都是一個 Non-native 數組（也就是 JavascriptArray）。記住，如果某些對象是另外一個對象的直接原型，那麼這個原型就被轉換為一個 JavascriptArray。所以，從理論上來講，如果我們的原型是一個原生數組，那麼我們就能將其轉換為 JavascriptArray，而 JIT 並不知道這一點，這和我們之前解釋過的“平常的” Side-Effect JIT 漏洞類似。</p><p>幸運的是，已經存在造成這一後果的技術了！我們可以使用代理限制 GetPrototype() 調用，但如果我們編寫函數的話，它會被檢測為 side-effect。 Object.prototype.valueOf 不會產生 Side-Effect，這是 Lokihardt 使用的已知的技術。我們來看個例子。</p><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c8b6f71e5c6a4c57a3c8b13fa92d2d2a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b5e3a76efbe7413bad163d863a3bac1b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7da258a213d14fb09520a15656d689f7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/af8597868ea848639b8949caecac41d1><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3b0f9e381f31407c82a57c3e04717573><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4e2b7e3080148f4874b17d94b1a9711><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e907a83303df469eb3c5833fa78756ed><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=高中生一年從0到0day的祕密 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/12d36c3877b54600a6ecc97566eadf11><p class=pgc-img-caption></p></div><p>要利用這個漏洞，我們首先偽造了一個 DataView 對象，從而能讓我們任意讀/寫。我們的利用代碼基於 Pwn.js 庫，這是一個很好的庫，但我們需要修復一下才能使用。我們通過一種已知技術洩漏了一個棧地址，因而能夠通過從 ThreadContext 讀取一些數據而獲取棧指針。之後，我們 ROP 並恢復我們的覆寫，就能獲得合法的進程繼續。</p><p>我們本來打算在 Edge 瀏覽器上實際執行我們的代碼，我們在沙箱環境下執行了代碼，它不允許我們彈出計算器等東西。我們無法進行演示。於是我們編譯了 Linux 版本的 Chakra，在 Linux 上進行了演示。在 Linux 上利用該漏洞也是類似的。</p><p>(注：最後, Jonathan 成功地在 Linux 版本的 Chakra 上進行了演示。接著掌聲雷動。）</p><p>希望我的演講能給想進入安全領域的人帶來一些幫助，同時也給只想聽技術部分的觀眾帶來一些幫助。</p><p>謝謝大家。</p><p><strong>大家怎麼說</strong></p><blockquote><p>大一的學生挖掘到價值頗大（天府杯8萬美金獎勵）的漏洞，我覺得這學生很厲害，膜拜之。從文章可以看出該同學基礎紮實、功底深厚，對調試、內存佈局、編譯、C++、漏洞類型、代碼審計等知識的掌握具有一定的深度，所以能夠從0到0 day且成功利用漏洞只需要1年的時間。Chakra 的漏洞挖掘難點挺大，該同學的研究思路、研究方法對於漏洞挖掘的學習具有很好的幫助。</p><p>看到Magic Value其實算是很熟悉的，在5月份的時候最初看到lokihardt公開的第一個漏洞的時候，很驚訝！因為這個漏洞並不是傳統的通過操作回調過程的方式造成的類型混淆，而是通過一個特殊的值。第一時間分析後，很明顯的就是代碼和數據沒有區分。</p><p><strong>此時想到三個問題</strong></p><p>1.Magic Value是什麼？</p><p>2.這是一個新的類型混淆漏洞的轉化點。</p><p>3.為什麼引擎中要定義一個Magic Value？</p><p>研究過patch之後，發現對StElem指令這塊做了檢查。也就是(作者提到的使用原生浮點數組)無法直接通過賦值的這種方式在Array中生成Magic Value。</p><p>Jacobi 的演講中也是這樣的思路，他舉了一個例子說明Magic Value在內存中的樣子。初步認識了Magic Value，然後通過其他的方式去偽造一個Magic Value繞過之前補丁的檢查，作者通過concat的方式進行了一種實現，發現了一個新的0day。</p><p>但我大膽猜測concat是他多次嘗試成功的一個方法，這個問題可以抽象成如何生成一個新的包含Magic Value的數組，且不通過直接賦值的方式。類似copywithin，concat,push…等等方法。作者在構造PoC時提到比較多的技巧，比如Object.prototype.valueOf 不會產生 Side-Effect。這都建立在他長期第一時間對這個領域知識的積累上。</p><p>這其中的嚴謹踏實的求真、勤于思考的積累、和清晰完善的思路，都值得去學習。</p><p>相比人家的大一，我大一在玩泥巴。</p><p><strong>他從驗證地方著手找漏洞蠻有借鑑意義的，只要驗證少了就可以有問題。</strong></p><p>相比找到程序中的缺陷，一步步突破限制將其轉化為利用是更難的過程，關鍵是不輕易放棄。</p><p>文章中有一段話感觸很深，學到基礎後，儘快去做自己不懂的更難的事；不斷地接觸自己不懂的事情，然後重新來看自以為懂但實際上不懂的事情。從0到0day最重要的是鼓起勇氣去挑戰自己以為的不可能。夢想多晚都不算晚。</p><p>潛入深水區，脫離舒適區，保持初入的學習勁頭，通過新的知識，重新審視與加強以往的知識，獲得進步；不害怕發愁看代碼框架，不斷的實踐，交流與學習；這種學習研究的思路，對於各個方向都是共通的，要學習實踐這種精神，夯實基礎，積極參與，努力提升。</p><p>死磕到底。</p><p>其實很多學習的方法都大同小異，大家都是知道的，Jonathan在一年的時間裡能取得這樣的成績，我覺得他的執行力更值得我們學習，確定目標之後就盡情投入，這很讓人欽佩。</p><p>從0到0day最重要的是鼓起勇氣去挑戰自己以為的不可能。在有了一定得基礎後，不能固步自封，對更深層次的知識望而卻步。要保持學習的熱情和動力，不斷進步，勇往直前。</p><p>即便只有基礎知識，也敢於去迎接各種挑戰，需要莫大的勇氣，直面失敗，善於利用失敗，從失敗中學到東西，這種心態和學習方法很值得我們初學者去學習借鑑。</p><p>安全涵蓋的方面很廣，在瞭解這個專業後，專注自己感興趣的一方面往裡鑽。這個學生就是想辦法把一件事做到極致，再加上自己本身牢固的基礎功底，直到自己佩服自己的地步。對於Jonathan 從安全基礎為0，到找到edge瀏覽器0day漏洞只使用了一年時間，對於我來說，是一種激勵，向他學習。</p></blockquote><p><strong>歡迎在留言區分享你的看法~</strong></p><p><strong>原文鏈接</strong></p><p>https://media.ccc.de/v/35c3-9657-from_zero_to_zero_day</p><p><strong>*本文作者：360代碼衛士，轉載請註明來自FreeBuf.COM</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>0day</a></li><li><a>高中生</a></li><li><a>一年</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b609e29.html alt=光陰瞬息又一年 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/48d6bb8fd63c42f89ba318f2ca85e026 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b609e29.html title=光陰瞬息又一年>光陰瞬息又一年</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aef60594.html alt=那一年我離開了家鄉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8fe794b27fdc485e8eea2404762c6c41 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aef60594.html title=那一年我離開了家鄉>那一年我離開了家鄉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3b910ae.html alt=小學一年級課本註釋詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b8f923ee794044558326f031cb76bfdc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3b910ae.html title=小學一年級課本註釋詳解>小學一年級課本註釋詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/0a594812.html alt=又是一年粽子飄香時！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1529201850679dd688885c6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/0a594812.html title=又是一年粽子飄香時！>又是一年粽子飄香時！</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/fc16ab68.html alt=2020年，是特別的一年 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/8a2a88d2-be10-4f00-922d-81f2c67fae2b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/fc16ab68.html title=2020年，是特別的一年>2020年，是特別的一年</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/100a9af2.html alt=趕花會｜開了一年又一年的鴨跖草 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/a06d0000b58c6f05f5f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/100a9af2.html title=趕花會｜開了一年又一年的鴨跖草>趕花會｜開了一年又一年的鴨跖草</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d909fee.html alt=一年的時光成就的生命——一年蓬 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/436300003289d7596e24 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d909fee.html title=一年的時光成就的生命——一年蓬>一年的時光成就的生命——一年蓬</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c1990ce.html alt=層層花開的一年蓬 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d2bc7f7bcd5d4213ab0be9b33364a3b8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c1990ce.html title=層層花開的一年蓬>層層花開的一年蓬</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c1a51b10.html alt=野草閒花一年蓬 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/eae2d07dad774426ace222f05a92d99d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c1a51b10.html title=野草閒花一年蓬>野草閒花一年蓬</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/af4375eb.html alt=今天：二哥去世整一年 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15313812516640bd08a8554 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/af4375eb.html title=今天：二哥去世整一年>今天：二哥去世整一年</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/e4f9fdc8.html alt=我眼中的這一年：95年 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/e4f9fdc8.html title=我眼中的這一年：95年>我眼中的這一年：95年</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e780650.html alt=臨朐故障碼和它的一年輪迴 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e780650.html title=臨朐故障碼和它的一年輪迴>臨朐故障碼和它的一年輪迴</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e89a2b99.html alt=又一年，清空自己，讓心歸零 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f4c99171e56946b383cb35ef4f29ba12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e89a2b99.html title=又一年，清空自己，讓心歸零>又一年，清空自己，讓心歸零</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12561b3a.html alt=又到一年觀潮時，我在鹽官，等你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R69auHd2iZov72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12561b3a.html title=又到一年觀潮時，我在鹽官，等你>又到一年觀潮時，我在鹽官，等你</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/38b7163.html alt=養牛賺錢嗎？養牛一年純利潤多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/207df7fdd8284262a31fdb1a32b6ae70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/38b7163.html title=養牛賺錢嗎？養牛一年純利潤多少？>養牛賺錢嗎？養牛一年純利潤多少？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>