<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文悟透備受爭議的 Go 語言錯誤處理 | 极客快訊</title><meta property="og:title" content="一文悟透備受爭議的 Go 語言錯誤處理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ef348845d8ca49dc901f4b2579af36f5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb93201.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb93201.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb93201.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb93201.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb93201.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb93201.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb93201.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb93201.html><meta property="article:published_time" content="2020-10-29T21:04:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:55+08:00"><meta name=Keywords content><meta name=description content="一文悟透備受爭議的 Go 語言錯誤處理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/cb93201.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文悟透備受爭議的 Go 語言錯誤處理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>寫過 C 的同學知道，C 語言中常常返回整數錯誤碼（errno）來表示函數處理出錯，通常用 -1 來表示錯誤，用 0 表示正確。</p><p class=ql-align-justify>而在 Go 中，我們使用 error 類型來表示錯誤，不過它不再是一個整數類型，是一個接口類型：</p><pre class=ql-align-justify>type error interface { Error() string}</pre><p class=ql-align-justify>它表示那些能用一個字符串就能說清的錯誤。</p><p class=ql-align-justify>我們最常用的就是 errors.New() 函數，非常簡單：</p><pre class=ql-align-justify>// src/errors/errors.gofunc New(text string) error {	return &amp;errorString{text}}type errorString struct {	s string}func (e *errorString) Error() string {	return e.s}</pre><p class=ql-align-justify>使用 New 函數創建出來的 error 類型實際上是 errors 包裡未導出的 errorString 類型，它包含唯一的一個字段 s，並且實現了唯一的方法：Error() string。</p><p class=ql-align-justify>通常這就夠了，它能反映當時“出錯了”，但是有些時候我們需要更加具體的信息，例如：</p><pre class=ql-align-justify>func Sqrt(f float64) (float64, error) { if f &lt; 0 { return 0, errors.New("math: square root of negative number") } // implementation}</pre><p class=ql-align-justify>當調用者發現出錯的時候，只知道傳入了一個負數進來，並不清楚到底傳的是什麼值。在 Go 裡：</p><blockquote>It is the error implementation’s responsibility to summarize the context.</blockquote><p class=ql-align-justify>它要求返回這個錯誤的函數要給出具體的“上下文”信息，也就是說，在 Sqrt 函數裡，要給出這個負數到底是什麼。</p><p class=ql-align-justify>所以，如果發現 f 小於 0，應該這樣返回錯誤：</p><pre class=ql-align-justify>if f &lt; 0 { return 0, fmt.Errorf("math: square root of negative number %g", f)}</pre><p class=ql-align-justify>這就用到了 fmt.Errorf 函數，它先將字符串格式化，再調用 errors.New 函數來創建錯誤。</p><p class=ql-align-justify>當我們想知道錯誤類型，並且打印錯誤的時候，直接打印 error：</p><pre class=ql-align-justify>fmt.Println(err)</pre><p class=ql-align-justify>或者：</p><pre class=ql-align-justify>fmt.Println(err.Error)</pre><p class=ql-align-justify>fmt 包會自動調用 err.Error() 函數來打印字符串。</p><p class=ql-align-justify>通常，我們將 error 放到函數返回值的最後一個，沒什麼好說的，大家都這樣做，約定俗成。</p><p class=ql-align-justify>參考資料【Tony Bai】這篇文章提到，構造 error 的時候，要求傳入的字符串首字母小寫，結尾不帶標點符號，這是因為我們經常會這樣使用返回的 error：</p><pre class=ql-align-justify>... err := errors.New("error example")fmt.Printf("The returned error is %s.\n", err)</pre><h1 class=ql-align-justify>error 的困局</h1><blockquote>In Go, error handling is important. The language’s design and conventions encourage you to explicitly check for errors where they occur (as distinct from the convention in other languages of throwing exceptions and sometimes catching them).</blockquote><p class=ql-align-justify>在 Go 語言中，錯誤處理是非常重要的。它從語言層面要求我們需要明確地處理遇到的錯誤。而不是像其他語言，類如 Java，使用 try-catch- finally 這種“把戲”。</p><p class=ql-align-justify>這就造成代碼裡 “error” 滿天飛，顯得非常冗長拖沓。</p><p class=ql-align-justify>而為了代碼健壯性考慮，對於函數返回的每一個錯誤，我們都不能忽略它。因為出錯的同時，很可能會返回一個 nil 類型的對象。如果不對錯誤進行判斷，那下一行對 nil 對象的操作百分之百會引發一個 panic。</p><p class=ql-align-justify>這樣，Go 語言中詬病最多的就是它的錯誤處理方式似乎回到了上古 C 語言時代。</p><pre class=ql-align-justify>rr := doStuff1()if err != nil { //handle error...}err = doStuff2()if err != nil { //handle error...}err = doStuff3()if err != nil { //handle error...}</pre><blockquote>Go authors 之一的 Russ Cox 對於這種觀點進行過駁斥：當初選擇返回值這種錯誤處理機制而不是 try-catch，主要是考慮前者適用於大型軟件，後者更適合小程序。</blockquote><p class=ql-align-justify>在參考資料【Go FAQ】裡也提到，try-catch 會讓代碼變得非常混亂，程序員會傾向將一些常見的錯誤，例如，failing to open a file，也拋到異常裡，這會讓錯誤處理更加冗長繁瑣且易出錯。</p><p class=ql-align-justify>而 Go 語言的多返回值使得返回錯誤異常簡單。對於真正的異常，Go 提供 panic-recover 機制，也使得代碼看起來非常簡潔。</p><blockquote>當然 Russ Cox 也承認 Go 的錯誤處理機制對於開發人員的確有一定的心智負擔。</blockquote><p class=ql-align-justify>參考資料【Go 語言的錯誤處理機制是一個優秀的設計嗎？】是知乎上的一個回答，闡述了 Go 對待錯誤和異常的不同處理方式，前者使用 error，後者使用 panic，這樣的處理比較 Java 那種錯誤異常一鍋端的做法更有優勢。</p><p class=ql-align-justify>【如何優雅的在Golang中進行錯誤處理】對於在業務上如何處理 error，給出了一些很好的示例。</p><h1 class=ql-align-justify>嘗試破局</h1><p class=ql-align-justify>這部分的內容主要來自 Dave cheney GoCon 2016 的演講，參考資料可以直達原文。</p><p class=ql-align-justify>經常聽到 Go 有很多“箴言”，說得很順口，但理解起來並不是太容易，因為它們大部分都是有故事的。例如，我們常說：</p><blockquote>Don’t communicating by sharing memory, share memory by communicating.</blockquote><p class=ql-align-justify>文中還列舉了很多，都很有意思：</p><div class=pgc-img><img alt="一文悟透備受爭議的 Go 語言錯誤處理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ef348845d8ca49dc901f4b2579af36f5><p class=pgc-img-caption></p></div><p class=ql-align-justify>下面我們講三條關於 error 的“箴言”。</p><h1 class=ql-align-justify>Errors are just values</h1><p class=ql-align-justify>Errors are just values 的實際意思是隻要實現了 Error 接口的類型都可以認為是 Error，重要的是要理解這些“箴言”背後的道理。</p><p class=ql-align-justify>作者把處理 error 的方式分為三種：</p><ul><li class=ql-align-justify>Sentinel errors</li><li class=ql-align-justify>Error Types</li><li class=ql-align-justify>Opaque errors</li></ul><p class=ql-align-justify>我們來挨個說。首先 Sentinel errors，Sentinel 來自計算機中常用的詞彙，中文意思是“哨兵”。以前在學習快排的時候，會有一個“哨兵”，其他元素都要和“哨兵”進行比較，它劃出了一條界限。</p><p class=ql-align-justify>這裡 Sentinel errors 實際想說的是這裡有一個錯誤，暗示處理流程不能再進行下去了，必須要在這裡停下，這也是一條界限。而這些錯誤，往往是提前約定好的。</p><p class=ql-align-justify>例如，io 包裡的 io.EOF，表示“文件結束”錯誤。但是這種方式處理起來，不太靈活：</p><pre class=ql-align-justify>func main() {	r := bytes.NewReader([]byte("0123456789"))		_, err := r.Read(make([]byte, 10))	if err == io.EOF {		log.Fatal("read failed:", err)	}}</pre><p class=ql-align-justify>必須要判斷 err 是否和約定好的錯誤 io.EOF 相等。</p><p class=ql-align-justify>再來一個例子，當我想返回 err 並且加上一些上下文信息時，就麻煩了：</p><div class=pgc-img><img alt="一文悟透備受爭議的 Go 語言錯誤處理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bd515024691a4bf59e2773c2d11f4ca1><p class=pgc-img-caption></p></div><p class=ql-align-justify>在 readfile 函數裡判斷 err 不為空，則用 fmt.Errorf 在 err 前加上具體的 file 信息，返回給調用者。返回的 err 其實還是一個字符串。</p><p class=ql-align-justify>造成的後果時，調用者不得不用字符串匹配的方式判斷底層函數 readfile 是不是出現了某種錯誤。當你必須要這樣才能判斷某種錯誤時，代碼的“壞味道”就出現了。</p><p class=ql-align-justify>順帶說一句，err.Error() 方法是給程序員而非代碼設計的，也就是說，當我們調用 Error 方法時，結果要寫到文件或是打印出來，是給程序員看的。在代碼裡，我們不能根據 err.Error() 來做一些判斷，就像上面的 main 函數裡做的那樣，不好。</p><p class=ql-align-justify>Sentinel errors 最大的問題在於它在定義 error 和使用 error 的包之間建立了依賴關係。比如要想判斷 err == io.EOF 就得引入 io 包，當然這是標準庫的包，還 Ok。如果很多用戶自定義的包都定義了錯誤，那我就要引入很多包，來判斷各種錯誤。麻煩來了，這容易引起循環引用的問題。</p><p class=ql-align-justify>因此，我們應該儘量避免 Sentinel errors，僅管標準庫中有一些包這樣用，但建議還是別模仿。</p><p class=ql-align-justify>第二種就是 Error Types，它指的是實現了 error 接口的那些類型。它的一個重要的好處是，類型中除了 error 外，還可以附帶其他字段，從而提供額外的信息，例如出錯的行數等。</p><p class=ql-align-justify>標準庫有一個非常好的例子：</p><pre class=ql-align-justify>// PathError records an error and the operation and file path that caused it.type PathError struct {	Op string	Path string	Err error}</pre><p class=ql-align-justify>PathError 額外記錄了出錯時的文件路徑和操作類型。</p><p class=ql-align-justify>通常，使用這樣的 error 類型，外層調用者需要使用類型斷言來判斷錯誤：</p><pre class=ql-align-justify>// underlyingError returns the underlying error for known os error types.func underlyingError(err error) error {	switch err := err.(type) {	case *PathError:		return err.Err	case *LinkError:		return err.Err	case *SyscallError:		return err.Err	}	return err}</pre><p class=ql-align-justify>但是這又不可避免地在定義錯誤和使用錯誤的包之間形成依賴關係，又回到了前面的問題。</p><p class=ql-align-justify>即使 Error types 比 Sentinel errors 好一些，因為它能承載更多的上下文信息，但是它仍然存在引入包依賴的問題。因此，也是不推薦的。至少，不要把 Error types 作為一個導出類型。</p><p class=ql-align-justify>最後一種，Opaque errors。翻譯一下，就是“黑盒 errors”，因為你能知道錯誤發生了，但是不能看到它內部到底是什麼。</p><p class=ql-align-justify>譬如下面這段偽代碼：</p><pre class=ql-align-justify>func fn() error {	x, err := bar.Foo()	if err != nil {		return err	}		// use x	return nil}</pre><p class=ql-align-justify>作為調用者，調用完 Foo 函數後，只用知道 Foo 是正常工作還是出了問題。也就是說你只需要判斷 err 是否為空，如果不為空，就直接返回錯誤。否則，繼續後面的正常流程，不需要知道 err 到底是什麼。</p><p class=ql-align-justify>這就是處理 Opaque errors 這種類型錯誤的策略。</p><p class=ql-align-justify>當然，在某些情況下，這樣做並不夠用。例如，在一個網絡請求中，需要調用者判斷返回的錯誤類型，以此來決定是否重試。這種情況下，作者給出了一種方法：</p><blockquote>In this case rather than asserting the error is a specific type or value, we can assert that the error implements a particular behaviour.</blockquote><p class=ql-align-justify>就是說，不去判斷錯誤的類型到底是什麼，而是去判斷錯誤是否具有某種行為，或者說實現了某個接口。</p><p class=ql-align-justify>來個例子：</p><pre class=ql-align-justify>type temporary interface {	Temporary() bool}func IsTemporary(err error) bool {	te, ok := err.(temporary)	return ok &amp;&amp; te.Temporary()}</pre><p class=ql-align-justify>拿到網絡請求返回的 error 後，調用 IsTemporary 函數，如果返回 true，那就重試。</p><p class=ql-align-justify>這麼做的好處是在進行網絡請求的包裡，不需要 import 引用定義錯誤的包。</p><h1 class=ql-align-justify>handle not just check errors</h1><p class=ql-align-justify>這一節要說第二句箴言：“Don’t just check errors, handle them gracefully”。</p><pre class=ql-align-justify>func AuthenticateRequest(r *Request) error { err := authenticate(r.User) if err != nil { return err } return nil}</pre><p class=ql-align-justify>上面這個例子中的代碼是有問題的，直接優化成一句就可以了：</p><pre class=ql-align-justify>func AuthenticateRequest(r *Request) error { return authenticate(r.User)}</pre><p class=ql-align-justify>還有其他的問題，在函數調用鏈的最頂層，我們得到的錯誤可能是：No such file or directory。</p><p class=ql-align-justify>這個錯誤反饋的信息太少了，不知道文件名、路徑、行號等等。</p><p class=ql-align-justify>嘗試改進一下，增加一點上下文：</p><pre class=ql-align-justify>func AuthenticateRequest(r *Request) error { err := authenticate(r.User) if err != nil { return fmt.Errorf("authenticate failed: %v", err) } return nil}</pre><p class=ql-align-justify>這種做法實際上是先錯誤轉換成字符串，再拼接另一個字符串，最後，再通過 fmt.Errorf 轉換成錯誤。這樣做破壞了相等性檢測，即我們無法判斷錯誤是否是一種預先定義好的錯誤了。</p><p class=ql-align-justify>應對方案是使用第三方庫：github.com/pkg/errors。提供了友好的界面：</p><pre class=ql-align-justify>// Wrap annotates cause with a message.func Wrap(cause error, message string) error// Cause unwraps an annotated error.func Cause(err error) error</pre><p class=ql-align-justify>通過 Wrap 可以將一個錯誤，加上一個字符串，“包裝”成一個新的錯誤；通過 Cause 則可以進行相反的操作，將裡層的錯誤還原。</p><p class=ql-align-justify>有了這兩個函數，就方便很多：</p><pre class=ql-align-justify>func ReadFile(path string) ([]byte, error) {	f, err := os.Open(path)	if err != nil {		return nil, errors.Wrap(err, "open failed")	}	defer f.Close()		buf, err := ioutil.ReadAll(f)	if err != nil {		return nil, errors.Wrap(err, "read failed")	}	return buf, nil}</pre><p class=ql-align-justify>這是一個讀文件的函數，先嚐試打開文件，如果出錯，則返回一個附加上了 “open failed” 的錯誤信息；之後，嘗試讀文件，如果出錯，則返回一個附加上了 “read failed” 的錯誤。</p><p class=ql-align-justify>當在外層調用 ReadFile 函數時：</p><pre class=ql-align-justify>func main() {	_, err := ReadConfig()	if err != nil {		fmt.Println(err)		os.Exit(1)	}}func ReadConfig() ([]byte, error) {	home := os.Getenv("HOME")	config, err := ReadFile(filepath.Join(home, ".settings.xml"))	return config, errors.Wrap(err, "could not read config")}</pre><p class=ql-align-justify>這樣我們在 main 函數裡就能打印出這樣一個錯誤信息：</p><pre class=ql-align-justify>could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</pre><p class=ql-align-justify>它是有層次的，非常清晰。而如果我們用 pkg/errors 庫提供的打印函數：</p><pre class=ql-align-justify>func main() {	_, err := ReadConfig()	if err != nil {		errors.Print(err)		os.Exit(1)	}}</pre><p class=ql-align-justify>能得到更有層次、更詳細的錯誤：</p><pre class=ql-align-justify>readfile.go:27: could not read configreadfile.go:14: open failedopen /Users/dfc/.settings.xml: no such file or directory</pre><p class=ql-align-justify>上面講的是 Wrap 函數，接下來看一下 “Cause” 函數，以前面提到的 temporary 接口為例：</p><pre class=ql-align-justify>type temporary interface {	Temporary() bool}// IsTemporary returns true if err is temporary.func IsTemporary(err error) bool {	te, ok := errors.Cause(err).(temporary)	return ok &amp;&amp; te.Temporary()}</pre><p class=ql-align-justify>判斷之前先使用 Cause 取出錯誤，做斷言，最後，遞歸地調用 Temporary 函數。如果錯誤沒實現 temporary 接口，就會斷言失敗，返回 false。</p><h1 class=ql-align-justify>Only handle errors once</h1><p class=ql-align-justify>什麼叫“處理”錯誤：</p><blockquote>Handling an error means inspecting the error value, and making a decision.</blockquote><p class=ql-align-justify>意思是查看了一下錯誤，並且做出一個決定。</p><p class=ql-align-justify>例如，如果不做任何決定，相當於忽略了錯誤：</p><pre class=ql-align-justify>func Write(w io.Writer, buf []byte) { w.Write(buf)	w.Write(buf)}</pre><p class=ql-align-justify>w.Write(buf) 會返回兩個結果，一個表示寫成功的字節數，一個是 error，上面的例子中沒有對這兩個返回值做任何處理。</p><p class=ql-align-justify>下面這個例子卻又處理了兩次錯誤：</p><pre class=ql-align-justify>func Write(w io.Writer, buf []byte) error { 	_, err := w.Write(buf)	if err != nil {		// annotated error goes to log file		log.Println("unable to write:", err)			// unannotated error returned to caller return err		return err	}	return nil}</pre><p class=ql-align-justify>第一次處理是將錯誤寫進了日誌，第二次處理則是將錯誤返回給上層調用者。而調用者也可能將錯誤寫進日誌或是繼續返回給上層。</p><p class=ql-align-justify>這樣一來，日誌文件中會有很多重複的錯誤描述，並且在最上層調用者（如 main 函數）看來，它拿到的錯誤卻還是最底層函數返回的 error，沒有任何上下文信息。</p><p class=ql-align-justify>使用第三方的 error 包就可以比較完美的解決問題：</p><pre class=ql-align-justify>func Write(w io.Write, buf []byte) error {	_, err := w.Write(buf)	return errors.Wrap(err, "write failed")}</pre><p class=ql-align-justify>返回的錯誤，對於人和機器而言，都是友好的。</p><h1 class=ql-align-justify>小結</h1><p class=ql-align-justify>這一部分主要講了處理 error 的一些原則，引入了第三方的 errors 包，使得錯誤處理變得更加優雅。</p><p class=ql-align-justify>作者最後給出了一些結論：</p><ul><li class=ql-align-justify>errors 就像對外提供的 API 一樣，需要認真對待。</li><li class=ql-align-justify>將 errors 看成黑盒，判斷它的行為，而不是類型。</li><li class=ql-align-justify>儘量不要使用 sentinel errors。</li><li class=ql-align-justify>使用第三方的錯誤包來包裹 error（errors.Wrap），使得它更好用。</li><li class=ql-align-justify>使用 errors.Cause 來獲取底層的錯誤。</li></ul><h1 class=ql-align-justify>胎死腹中的 try 提案</h1><p class=ql-align-justify>之前已經出現用 “check & handle” 關鍵字和 “try 內置函數”改進錯誤處理流程的提案，目前 try 內置函數的提案已經被官方提前拒絕，原因是社區裡一邊倒地反對聲音。</p><p class=ql-align-justify>關於這兩個提案的具體內容見參考資料【check & handle】和【try 提案】。</p><h1 class=ql-align-justify>go 1.13 的改進</h1><p class=ql-align-justify>有一些 Go 語言失敗的嘗試，比如 Go 1.5 引入的 vendor 和 internal 來管理包，最後被濫用而引發了很多問題。因此 Go 1.13 直接拋棄了 GOPATH 和 vendor 特性，改用 module 來管理包。</p><p class=ql-align-justify>柴大在《Go 語言十年而立，Go2 蓄勢待發》一文中表示：</p><blockquote>比如最近 Go 語言之父之一 Robert Griesemer 提交的通過 try 內置函數來簡化錯誤處理就被否決了。失敗的嘗試是一個好的現象，它表示 Go 語言依然在一些新興領域的嘗試 —— Go 語言依然處於活躍期。</blockquote><p class=ql-align-justify>今年 9 月 3 號，Go 發佈 1.13 版本，除了 module 特性轉正之外，還改進了數字字面量。比較重要的還有 defer 性能提升 30%，將更多的對象從堆上移動到棧上以提升性能，等等。</p><blockquote>還有一個重大的改進發生在 errors 標準庫中。errors 庫增加了 Is/As/Unwrap三個函數，這將用於支持錯誤的再次包裝和識別處理，為 Go 2 中新的錯誤處理改進提前做準備。</blockquote><p class=ql-align-justify>1.13 支持了 error 包裹（wrapping）：</p><blockquote>An error e can wrap another error w by providing an Unwrap method that returns w. Both e and w are available to programs, allowing e to provide additional context to w or to reinterpret it while still allowing programs to make decisions based on w.</blockquote><p class=ql-align-justify>為了支持 wrapping，fmt.Errorf 增加了 %w 的格式，並且在 error 包增加了三個函數：errors.Unwrap，errors.Is，errors.As。</p><h1 class=ql-align-justify>fmt.Errorf</h1><p class=ql-align-justify>使用 fmt.Errorf 加上 %w 格式符來生成一個嵌套的 error，它並沒有像 pkg/errors 那樣使用一個 Wrap 函數來嵌套 error，非常簡潔。</p><h1 class=ql-align-justify>Unwrap</h1><pre class=ql-align-justify>func Unwrap(err error) error</pre><p class=ql-align-justify>將嵌套的 error 解析出來，多層嵌套需要調用 Unwrap 函數多次，才能獲取最裡層的 error。</p><p class=ql-align-justify>源碼如下：</p><pre class=ql-align-justify>func Unwrap(err error) error { // 判斷是否實現了 Unwrap 方法	u, ok := err.(interface {		Unwrap() error	})	// 如果不是，返回 nil	if !ok {		return nil	}	// 調用 Unwrap 方法返回被嵌套的 error	return u.Unwrap()}</pre><p class=ql-align-justify>對 err 進行斷言，看它是否實現了 Unwrap 方法，如果是，調用它的 Unwrap 方法。否則，返回 nil。</p><h1 class=ql-align-justify>Is</h1><pre class=ql-align-justify>func Is(err, target error) bool</pre><p class=ql-align-justify>判斷 err 是否和 target 是同一類型，或者 err 嵌套的 error 有沒有和 target 是同一類型的，如果是，則返回 true。</p><p class=ql-align-justify>源碼如下：</p><div class=pgc-img><img alt="一文悟透備受爭議的 Go 語言錯誤處理" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/52f8dcb30ce94d1bbc66241390ef215f><p class=pgc-img-caption></p></div><p class=ql-align-justify>通過一個無限循環，使用 Unwrap 不斷地將 err 裡層嵌套的 error 解開，再看被解開的 error 是否實現了 Is 方法，並且調用它的 Is 方法，當兩者都返回 true 的時候，整個函數返回 true。</p><p class=ql-align-justify>As</p><pre class=ql-align-justify>func As(err error, target interface{}) bool</pre><p class=ql-align-justify>從 err 錯誤鏈裡找到和 target 相等的並且設置 target 所指向的變量。</p><p class=ql-align-justify>源碼如下：</p><div class=pgc-img><img alt="一文悟透備受爭議的 Go 語言錯誤處理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ef5ebe1587d47c6af251fc448e987a8><p class=pgc-img-caption></p></div><p class=ql-align-justify>返回 true 的條件是錯誤鏈裡的 err 能被賦值到 target 所指向的變量；或者 err 實現的 As(interface{}) bool 方法返回 true。</p><p class=ql-align-justify>前者，會將 err 賦給 target 所指向的變量；後者，由 As 函數提供這個功能。</p><p class=ql-align-justify>如果 target 不是一個指向“實現了 error 接口的類型或者其它接口類型”的非空的指針的時候，函數會 panic。</p><p class=ql-align-justify>這一部分的內容，飛雪無情大佬的文章【飛雪無情 分析 1.13 錯誤】寫得比較好，推薦閱讀。</p><h1 class=ql-align-justify>總結</h1><p class=ql-align-justify>Go 語言使用 error 和 panic 處理錯誤和異常是一個非常好的做法，比較清晰。至於是使用 error 還是 panic，看具體的業務場景。</p><p class=ql-align-justify>當然，Go 中的 error 過於簡單，以至於無法記錄太多的上下文信息，對於錯誤包裹也沒有比較好的辦法。當然，這些可以通過第三方庫來解決。官方也在新發布的 go 1.13 中對這一塊作出了改進，相信在 Go 2 裡會有更進一步的優化。</p><p class=ql-align-justify>本文還列舉了一些處理 error 的示例，例如不要兩次處理一個錯誤，判斷錯誤的行為而不是類型等等。</p><p class=ql-align-justify>參考資料裡列舉了很多錯誤處理相關的示例，這篇文章作為一個引子。</p><h1 class=ql-align-justify>參考資料</h1><p class=ql-align-justify>【Go 2 錯誤提案】https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</p><p class=ql-align-justify>【check & handle】https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md</p><p class=ql-align-justify>【錯誤討論的 issue】https://github.com/golang/go/issues/29934</p><p class=ql-align-justify>【error value 的 FAQ】https://github.com/golang/go/wiki/ErrorValueFAQ</p><p class=ql-align-justify>【error 包】https://golang.org/pkg/errors/</p><p class=ql-align-justify>【飛雪無情的博客 錯誤處理】https://www.flysnow.org/2019/01/01/golang-error-handle-suggestion.html</p><p class=ql-align-justify>【飛雪無情 分析 1.13 錯誤】https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html</p><p class=ql-align-justify>【Tony Bai Go語言錯誤處理】https://tonybai.com/2015/10/30/error-handling-in-go/</p><p class=ql-align-justify>【Go 官方 error 使用教程】https://blog.golang.org/error-handling-and-go</p><p class=ql-align-justify>【Go FAQ】https://golang.org/doc/faq#exceptions</p><p class=ql-align-justify>【ethancai 錯誤處理】https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/</p><p class=ql-align-justify>【Dave cheney GoCon 2016 演講】https://dave.cheney.net/paste/gocon-spring-2016.pdf</p><p class=ql-align-justify>【Morsing’s Blog Effective error handling in Go】http://morsmachine.dk/error-handling</p><p class=ql-align-justify>【如何優雅的在Golang中進行錯誤處理】https://www.ituring.com.cn/article/508191</p><p class=ql-align-justify>【Go 2 錯誤處理提案：try 還是 check？】https://toutiao.io/posts/uh9qo7/preview</p><p class=ql-align-justify>【try 提案】https://github.com/golang/go/issues/32437</p><p class=ql-align-justify>【否決 try 提案】https://github.com/golang/go/issues/32437#issuecomment-512035919</p><p class=ql-align-justify>【Go 語言的錯誤處理機制是一個優秀的設計嗎？】https://www.zhihu.com/question/27158146/answer/44676012</p><blockquote><p><strong>本文作者：</strong>饒全成，原創授權發佈</p><p><strong>本文鏈接：</strong>https://qcrao.com/2019/09/18/golang-error-break-through/</p><p><strong>版權聲明：</strong>本文章著作權歸作者所有，任何形式的轉載都請註明出處。</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>透備</a></li><li><a>受爭議</a></li><li><a>Go</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/85697d72.html alt="我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/47dfbe87bec844cf988f2e497c78641a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/85697d72.html title="我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的">我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/317308ae.html alt="Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/35e73626e50e4835a1eacdc0f5f74a69 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/317308ae.html title="Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗">Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e187bc3.html alt=Go語言之父帶你重新認識字符串、字節、rune和字符 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/52e46ed353da4c058a36fb1153b3bf17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e187bc3.html title=Go語言之父帶你重新認識字符串、字節、rune和字符>Go語言之父帶你重新認識字符串、字節、rune和字符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/288f86f6.html alt=Go語言實現：常見排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3a6d9a4e785e4fa097b0adf18620d616 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/288f86f6.html title=Go語言實現：常見排序算法>Go語言實現：常見排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/73f8e8da.html alt=Go語言學習基礎-生成進程、替換進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0006f0b743b040789141c4474d31a24c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/73f8e8da.html title=Go語言學習基礎-生成進程、替換進程>Go語言學習基礎-生成進程、替換進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cc38087.html alt="Go 如何獲取當前執行文件所在的目錄？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4d316ba5638c47e391011bce4e28f6a8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cc38087.html title="Go 如何獲取當前執行文件所在的目錄？">Go 如何獲取當前執行文件所在的目錄？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/190ae162.html alt="如何在 Go 中寫出高效的單元測試" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ed1aef2573fe45c582af69ef44638521 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/190ae162.html title="如何在 Go 中寫出高效的單元測試">如何在 Go 中寫出高效的單元測試</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2122bafb.html alt="對比著學 Go 語言-基礎：面向對象編程之接口" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2122bafb.html title="對比著學 Go 語言-基礎：面向對象編程之接口">對比著學 Go 語言-基礎：面向對象編程之接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/27147bdc.html alt=沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d906b089a5b448f9cc8c13c1031d4c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/27147bdc.html title=沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要>沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d6b5eb9f.html alt="詳細介紹 Go 中如何實現 bitset" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/aa4b2de8-ff82-4bfc-a72e-77a49dc17c63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d6b5eb9f.html title="詳細介紹 Go 中如何實現 bitset">詳細介紹 Go 中如何實現 bitset</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af44354f.html alt=使用Go基於WebSocket構建千萬級視頻直播彈幕系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f89b8532845242149b2510d6fe6b0bec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af44354f.html title=使用Go基於WebSocket構建千萬級視頻直播彈幕系統>使用Go基於WebSocket構建千萬級視頻直播彈幕系統</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/5ad9b6f8.html alt="Ready Go!陸軍邊海防學院首屆軍事比武運動會“一觸即發”" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15264415386849b8f4ba53d style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/5ad9b6f8.html title="Ready Go!陸軍邊海防學院首屆軍事比武運動會“一觸即發”">Ready Go!陸軍邊海防學院首屆軍事比武運動會“一觸即發”</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/d01dbd86.html alt=《八佰》中備受爭議的殺日本俘虜情節，到底有無必要？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d979da1244fa4c9ea8fe70f5bdaa8ace style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/d01dbd86.html title=《八佰》中備受爭議的殺日本俘虜情節，到底有無必要？>《八佰》中備受爭議的殺日本俘虜情節，到底有無必要？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/df1659b7.html alt="Go 語言在極小硬件上的運用（二）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e76fc77d34ef460bbe3f5fddb64b0f57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/df1659b7.html title="Go 語言在極小硬件上的運用（二）">Go 語言在極小硬件上的運用（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be5b02ae.html alt="Go：Goroutine 的切換過程實際上涉及了什麼" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/57e063b10f50450190fde2fe07d4d666 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be5b02ae.html title="Go：Goroutine 的切換過程實際上涉及了什麼">Go：Goroutine 的切換過程實際上涉及了什麼</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>