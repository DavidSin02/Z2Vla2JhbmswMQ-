<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java基礎知識總結 - 超詳細篇(下) | 极客快訊</title><meta property="og:title" content="Java基礎知識總結 - 超詳細篇(下) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/0a2c5c74ea004348be7d53c613226e92"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbd7408a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbd7408a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbd7408a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbd7408a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbd7408a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbd7408a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbd7408a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbd7408a.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="Java基礎知識總結 - 超詳細篇(下)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/cbd7408a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java基礎知識總結 - 超詳細篇(下)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>java.lang.Object</strong></p><p><strong>Object：</strong>所有類的直接或者間接父類，Java認為所有的對象都具備一些基本的共性內容，這些內容可以不斷的向上抽取，最終就抽取到了一個最頂層的類中的，該類中定義的就是所有對象都具備的功能。</p><p><strong>具體方法：</strong></p><p><strong>boolean equals(Object obj)：</strong>用於比較兩個對象是否相等，<strong>其實內部比較的就是兩個對象地址。</strong></p><p><strong>2，String toString()：</strong>將對象變成字符串；默認返回的格式：類名@哈希值 = getClass().getName() + '@' + Integer.toHexString(hashCode())</p><p>為了對象對應的字符串內容有意義，可以通過複寫，建立該類對象自己特有的字符串表現形式。</p><p>public String toString(){</p><p>return "person : "+age;</p><p>}</p><p><strong>3，Class getClass()：</strong>獲取任意對象運行時的所屬字節碼文件對象。</p><p><strong>4，int hashCode()：</strong>返回該對象的哈希碼值。支持此方法是為了提高哈希表的性能。將該對象的內部地址轉換成一個整數來實現的。</p><p><strong>通常equals，toString，hashCode，在應用中都會被複寫，建立具體對象的特有的內容。</strong></p><p>-------------------------------------------------------------------------------------</p><p><strong>內部類：</strong>如果A類需要直接訪問B類中的成員，而B類又需要建立A類的對象。這時,為了方便設計和訪問，直接將A類定義在B類中。就可以了。A類就稱為<strong>內部類</strong>。內部類可以直接訪問外部類中的成員。而外部類想要訪問內部類，必須要建立內部類的對象。</p><p>-----------------------------------------------------</p><p>class Outer{</p><p>int num = 4;</p><p><strong>class Inner</strong> {</p><p>void show(){</p><p>System.out.println("inner show run "+num);</p><p>}</p><p>}</p><p>public void method(){</p><p>Inner in = new Inner();//創建內部類的對象。</p><p>in.show();//調用內部類的方法。//<strong>內部類直接訪問外部類成員，用自己的實例對象；</strong></p><p><strong></strong>} //<strong>外部類訪問內部類要定義內部類的對象；</strong></p><p>}</p><p>-------------------------------------------------------</p><p><strong>當內部類定義在外部類中的成員位置上，可以使用一些成員修飾符修飾 private、static。</strong></p><p>1：默認修飾符。</p><p><strong>直接訪問內部類格式：外部類名.內部類名 變量名 = 外部類對象.內部類對象;</strong></p><p><strong>Outer.Inner in = new Outer.new Inner();//這種形式很少用。</strong></p><p>但是這種應用不多見，因為內部類之所以定義在內部就是為了封裝。<strong>想要獲取內部類對象通常都通過外部類的方法來獲取。這樣可以對內部類對象進行控制。</strong></p><p>2：私有修飾符。</p><p>通常內部類被封裝，都會被私有化，因為封裝性不讓其他程序直接訪問。</p><p>3：靜態修飾符。</p><p><strong>如果內部類被靜態修飾，相當於外部類</strong>，會出現訪問侷限性，只能訪問外部類中的靜態成員。</p><p>注意；<strong>如果內部類中定義了靜態成員，那麼該內部類必須是靜態的。</strong></p><p><strong>內部類編譯後的文件名為："外部類名$內部類名.java"；</strong></p><p><strong>為什麼內部類可以直接訪問外部類中的成員呢？</strong></p><p>那是因為內部中都持有一個外部類的引用。這個是引用是 <strong>外部類名.this</strong></p><p>內部類可以定義在外部類中的成員位置上，也可以定義在外部類中的局部位置上。</p><p><strong>當內部類被定義在局部位置上，只能訪問局部中被final修飾的局部變量。</strong></p><p><strong>匿名內部類（對象）：</strong>沒有名字的內部類。就是內部類的簡化形式。一般只用一次就可以用這種形式。匿名內部類其實就是一個<strong>匿名子類對象</strong>。<strong>想要定義匿名內部類：需要前提，內部類必須繼承一個類或者實現接口。</strong></p><p><strong>匿名內部類的格式：</strong>new 父類名&接口名(){ 定義子類成員或者覆蓋父類方法 }.方法。</p><p><strong>匿名內部類的使用場景：</strong></p><p>當函數的參數是接口類型引用時，如果接口中的方法不超過3個。可以通過匿名內部類來完成參數的傳遞。</p><p>其實就是在創建匿名內部類時，該類中的封裝的方法不要過多，最好兩個或者兩個以內。</p><p>--------------------------------------------------------</p><p>//面試</p><p><strong>//1</strong></p><p>new Object(){</p><p>void show(){</p><p>System.out.println("show run");</p><p>}</p><p>}<strong>.show(); //寫法和編譯都沒問題</strong></p><p><strong>//2</strong></p><p>Object obj = new Object(){</p><p>void show(){</p><p>System.out.println("show run");</p><p>}</p><p>};</p><p><strong>obj.show(); //寫法正確，編譯會報錯</strong></p><p>1和2的寫法正確嗎？有區別嗎？說出原因。</p><p>寫法是正確，1和2都是在通過匿名內部類建立一個Object類的子類對象。</p><p>區別：</p><p>第一個可是編譯通過，並運行。</p><p>第二個編譯失敗，因為匿名內部類是一個子類對象，當用Object的obj引用指向時，就被提升為了Object類型，而編譯時會檢查Object類中是否有show方法，此時編譯失敗。</p><h2 class=pgc-h-arrow-right>異 常：★★★★</h2><p><strong>--java.lang.Throwable：</strong></p><p><strong>Throwable：</strong>可拋出的。</p><p><strong>|--Error：</strong>錯誤，一般情況下，不編寫針對性的代碼進行處理，通常是jvm發生的，需要對程序進行修正。</p><p><strong>|--Exception：</strong>異常，可以有針對性的處理方式</p><p><strong>這個體系中的所有類和對象都具備一個獨有的特點；就是可拋性。</strong></p><p><strong>可拋性的體現：</strong>就是這個體系中的類和對象都可以被throws和throw兩個關鍵字所操作。</p><p><strong>throw與throws區別：</strong></p><p>throws是用來聲明一個方法可能拋出的所有異常信息，而throw則是指拋出的一個具體的異常類型。此外throws是將異常聲明但是不處理，而是將異常往上傳，誰調用我就交給誰處理。</p><p>throw用於拋出異常對象，後面跟的是異常對象；throw用在函數<strong>內</strong>。</p><p>throws用於拋出異常類，後面跟的異常類名，可以跟多個，用逗號隔開。throws用在函數<strong>上</strong>。</p><p>throws格式：方法名（參數）throws 異常類1，異常類2，.....</p><p>throw：就是自己進行異常處理，處理的時候有兩種方式，要麼自己捕獲異常（也就是try catch進行捕捉），要麼聲明拋出一個異常（就是throws 異常~~）。</p><p><strong>處理方式有兩種：1、捕捉；2、拋出。</strong></p><p>對於捕捉：java有針對性的語句塊進行處理。</p><p><strong>try {</strong></p><p><strong>需要被檢測的代碼；</strong></p><p><strong>}</strong></p><p><strong>catch(異常類 變量名){</strong></p><p><strong>異常處理代碼；</strong></p><p><strong>}</strong></p><p><strong>fianlly{</strong></p><p><strong>一定會執行的代碼；</strong></p><p><strong>}</strong></p><p><strong>定義異常處理時，什麼時候定義try，什麼時候定義throws呢？</strong></p><p><strong>功能內部如果出現異常，如果內部可以處理，就用try；</strong></p><p><strong>如果功能內部處理不了，就必須聲明出來，讓調用者處理。使用throws拋出，交給調用者處理。誰調用了這個功能誰就是調用者；</strong></p><p><strong>自定義異常的步驟：</strong></p><p>1：定義一個子類繼承Exception或RuntimeException，讓該類具備可拋性(既可以使用throw和throws去調用此類)。</p><p>2：通過throw 或者throws進行操作。</p><p><strong>異常的轉換思想：</strong>當出現的異常是調用者處理不了的，就需要將此異常轉換為一個調用者可以處理的異常拋出。</p><p><strong>try catch finally的幾種結合方式：</strong></p><div class=pgc-img><img alt="Java基礎知識總結 - 超詳細篇(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0a2c5c74ea004348be7d53c613226e92><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="Java基礎知識總結 - 超詳細篇(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8bc1944e2e6348cbbbfd4f8faee1ea7e><p class=pgc-img-caption></p></div><p>1，</p><p>try</p><p>catch</p><p>finally</p><p>這種情況，如果出現異常，並不處理，但是資源一定關閉，所以<strong>try finally集合只為關閉資源</strong>。</p><p><strong>記住：</strong>finally很有用，主要用戶關閉資源。無論是否發生異常，資源都必須進行關閉。</p><p><strong>System.exit(0);</strong> //退出jvm，只有這種情況finally不執行。</p><p><strong>注意：</strong></p><p><strong>如果父類或者接口中的方法沒有拋出過異常，那麼子類是不可以拋出異常的，如果子類的覆蓋的方法中出現了異常，只能try不能throws。</strong></p><p><strong>如果這個異常子類無法處理，已經影響了子類方法的具體運算，這時可以在子類方法中，通過throw拋出RuntimeException異常或者其子類，這樣，子類的方法上是不需要throws聲明的。</strong></p><h2 class=pgc-h-arrow-right>多線程：★★★★</h2><p>返回當前線程的名稱：<strong>Thread.currentThread().getName()</strong></p><p>線程的名稱是由：Thread-編號定義的。編號從0開始。</p><p>線程要運行的代碼都統一存放在了<strong>run方法</strong>中。</p><p>線程要運行必須要通過類中指定的方法開啟。<strong>start方法</strong>。（啟動後，就多了一條執行路徑）</p><p><strong>start方法：</strong>1）、啟動了線程；2）、讓jvm調用了run方法。</p><p><strong>Thread類中run()和start()方法的區別：</strong></p><p>start()：用start方法來啟動線程，真正實現了多線程運行，這時無需等待run方法體代碼執行完畢而直接繼續執行下面的代碼。通過調用Thread類的start()方法來啟動一個線程，這時此線程處於就緒（可運行）狀態，並沒有運行，一旦得到cpu時間片，就開始執行run()方法，這裡方法run()稱為線程體，它包含了要執行的這個線程的內容，Run方法運行結束，此線程隨即終止。</p><p>run()：run()方法只是類的一個普通方法而已，如果直接調用Run方法，程序中依然只有主線程這一個線程，其程序執行路徑還是隻有一條，還是要順序執行，還是要等待run方法體執行完畢後才可繼續執行下面的代碼，這樣就沒有達到寫線程的目的。</p><p>總結：start()方法最本質的功能是從CPU中申請另一個線程空間來執行 run()方法中的代碼,它和當前的線程是兩條線,在相對獨立的線程空間運行,也就是說,如果你直接調用線程對象的run()方法,當然也會執行,但那是 在當前線程中執行,run()方法執行完成後繼續執行下面的代碼.而調用start()方法後,run()方法的代碼會和當前線程併發(單CPU)或並行 (多CPU)執行。所以請記住一句話：調用線程對象的run方法不會產生一個新的線程，雖然可以達到相同的執行結果,但執行過程和執行效率不同</p><p><strong>創建線程的第一種方式：繼承Thread ，由子類複寫run方法。</strong></p><p>步驟：</p><p>1，定義類繼承Thread類；</p><p>2，目的是複寫run方法，將要讓線程運行的代碼都存儲到run方法中；</p><p>3，通過創建Thread類的子類對象，創建線程對象；</p><p>4，調用線程的start方法，開啟線程，並執行run方法。</p><p><strong>線程狀態：</strong></p><p><strong>被創建：</strong>start()</p><p><strong>運行：</strong>具備執行資格，同時具備執行權；</p><p><strong>凍結：</strong>sleep(time),wait()—notify()喚醒；線程釋放了執行權，同時釋放執行資格；</p><p><strong>臨時阻塞狀態：</strong>線程具備cpu的執行資格，沒有cpu的執行權；</p><p><strong>消亡：</strong>stop()</p><div class=pgc-img><img alt="Java基礎知識總結 - 超詳細篇(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7f2db57fa4f946408f7e1082befe506e><p class=pgc-img-caption></p></div><p><strong>創建線程的第二種方式：實現一個接口Runnable。</strong></p><p>步驟：</p><p>1，定義類實現Runnable接口。</p><p>2，覆蓋接口中的run方法（用於封裝線程要運行的代碼）。</p><p>3，通過Thread類創建線程對象；</p><p>4，<strong>將實現了Runnable接口的子類對象作為實際參數傳遞給Thread類中的構造函數。</strong></p><p>為什麼要傳遞呢？因為要讓線程對象明確要運行的run方法所屬的對象。</p><p>5，調用Thread對象的start方法。開啟線程，並運行Runnable接口子類中的run方法。</p><p><strong>Ticket t = new Ticket();</strong></p><p>/*</p><p>直接創建Ticket對象，並不是創建線程對象。</p><p>因為創建對象只能通過new Thread類，或者new Thread類的子類才可以。</p><p>所以最終想要創建線程。既然沒有了Thread類的子類，就只能用Thread類。</p><p>*/</p><p><strong>Thread t1 = new Thread(t);</strong> //創建線程。</p><p>/*</p><p>只要將t作為Thread類的構造函數的實際參數傳入即可完成線程對象和t之間的關聯</p><p>為什麼要將t傳給Thread類的構造函數呢？其實就是為了明確線程要運行的代碼run方法。</p><p>*/</p><p><strong>t1.start();</strong></p><p><strong>為什麼要有Runnable接口的出現？</strong></p><p><strong>1：</strong>通過繼承Thread類的方式，可以完成多線程的建立。但是這種方式有一個侷限性，如果一個類已經有了自己的父類，就不可以繼承Thread類，因為<strong>java單繼承</strong>的侷限性。</p><p>可是該類中的還有部分代碼需要被多個線程同時執行。這時怎麼辦呢？</p><p>只有對該類進行額外的功能擴展，java就提供了一個接口Runnable。這個接口中定義了run方法，其實run方法的定義就是為了存儲多線程要運行的代碼。</p><p>所以，通常創建線程都用第二種方式。</p><p><strong>因為實現Runnable接口可以避免單繼承的侷限性。</strong></p><p><strong>2：</strong>其實是將不同類中需要被多線程執行的代碼進行抽取。將多線程要運行的代碼的位置單獨定義到接口中。為其他類進行功能擴展提供了前提。</p><p>所以Thread類在描述線程時，內部定義的run方法，也來自於Runnable接口。</p><p><strong>實現Runnable接口可以避免單繼承的侷限性。</strong>而且，繼承Thread，是可以對Thread類中的方法，進行子類複寫的。但是不需要做這個複寫動作的話，只為定義線程代碼存放位置，實現Runnable接口更方便一些。所以<strong>Runnable接口將線程要執行的任務封裝成了對象</strong>。</p><p>-------------------------------------------------------</p><p><strong>//面試</strong></p><p>new Thread(new Runnable(){ //匿名</p><p>public void run(){</p><p>System.out.println("runnable run");</p><p>}</p><p>})</p><p>{</p><p>public void run(){</p><p>System.out.println("subthread run");</p><p>}</p><p>}.start(); //<strong>結果：subthread run</strong></p><p>---------------------------------------------------------</p><p><strong>synchroni</strong>zed關鍵字（一）</p><p>一、當兩個併發線程訪問同一個對象object中的這個synchronized(this)同步代碼塊時，一個時間內只能有一個線程得到執行。另一個線程必須等待當前線程執行完這個代碼塊以後才能執行該代碼塊。</p><p>二、然而，當一個線程訪問object的一個synchronized(this)同步代碼塊時，另一個線程仍然可以訪問該object中的非synchronized(this)同步代碼塊。</p><p>三、尤其關鍵的是，當一個線程訪問object的一個synchronized(this)同步代碼塊時，其他線程對object中所有其它synchronized(this)同步代碼塊的訪問將被阻塞。</p><p>四、第三個例子同樣適用其它同步代碼塊。也就是說，當一個線程訪問object的一個synchronized(this)同步代碼塊時，它就獲得了這個object的對象鎖。結果，其它線程對該object對象所有同步代碼部分的訪問都被暫時阻塞。</p><p>五、以上規則對其它對象鎖同樣適用.</p><p>package ths;</p><p>public class Thread1 implements Runnable {</p><p>public void run() {</p><p>synchronized(this) {</p><p>for (int i = 0; i &lt; 5; i++) {</p><p>System.out.println(Thread.currentThread().getName()+"synchronized loop " + i);</p><p>}</p><p>}</p><p>}</p><p>}</p><p><strong>synchronized關鍵字（二）</strong></p><p>synchronized 關鍵字，它包括兩種用法：synchronized 方法和 synchronized 塊。</p><p>1. synchronized 方法：通過在方法聲明中加入 synchronized關鍵字來聲明 synchronized 方法。如：</p><p>public synchronized void accessVal(int newVal);</p><p>synchronized 方法控制對類成員變量的訪問：每個類實例對應一把鎖，每個 synchronized 方法都必須獲得調用該方法的類實例的鎖方能執行，否則所屬線程阻塞，方法一旦執行，就獨佔該鎖，直到從該方法返回時才將鎖釋放，此後被阻塞的線程方能獲得該鎖，重新進入可執行狀態。這種機制確保了同一時刻對於每一個類實例，其所有聲明為 synchronized 的成員函數中至多隻有一個處於可執行狀態（因為至多隻有一個能夠獲得該類實例對應的鎖），從而有效避免了類成員變量的訪問衝突（只要所有可能訪問類成員變量的方法均被聲明為 synchronized）。</p><p>在 Java 中，不光是類實例，每一個類也對應一把鎖，這樣我們也可將類的靜態成員函數聲明為 synchronized ，以控制其對類的靜態成員變量的訪問。</p><p>synchronized 方法的缺陷：若將一個大的方法聲明為synchronized 將會大大影響效率，典型地，若將線程類的方法 run() 聲明為synchronized ，由於在線程的整個生命期內它一直在運行，因此將導致它對本類任何 synchronized 方法的調用都永遠不會成功。當然我們可以通過將訪問類成員變量的代碼放到專門的方法中，將其聲明為 synchronized ，並在主方法中調用來解決這一問題，但是 Java 為我們提供了更好的解決辦法，那就是 synchronized 塊。</p><p>2. synchronized 塊：通過 synchronized關鍵字來聲明synchronized 塊。語法如下：</p><p>synchronized(syncObject) {</p><p>//允許訪問控制的代碼</p><p>}</p><p>synchronized 塊是這樣一個代碼塊，其中的代碼必須獲得對象 syncObject （如前所述，可以是類實例或類）的鎖方能執行，具體機制同前所述。由於可以針對任意代碼塊，且可任意指定上鎖的對象，故靈活性較高。</p><p>對synchronized(this)的一些理解</p><p>一、當兩個併發線程訪問同一個對象object中的這個synchronized(this)同步代碼塊時，一個時間內只能有一個線程得到執行。另一個線程必須等待當前線程執行完這個代碼塊以後才能執行該代碼塊。</p><p>二、然而，當一個線程訪問object的一個synchronized(this)同步代碼塊時，另一個線程仍然可以訪問該object中的非synchronized(this)同步代碼塊。</p><p>三、尤其關鍵的是，當一個線程訪問object的一個synchronized(this)同步代碼塊時，其他線程對object中所有其它synchronized(this)同步代碼塊的訪問將被阻塞。</p><p>四、第三個例子同樣適用其它同步代碼塊。也就是說，當一個線程訪問object的一個synchronized(this)同步代碼塊時，它就獲得了這個object的對象鎖。結果，其它線程對該object對象所有同步代碼部分的訪問都被暫時阻塞。</p><p>五、以上規則對其它對象鎖同樣適用。</p><p><strong>解決安全問題的原理</strong>：</p><p>只要將操作共享數據的語句在某一時段讓一個線程執行完，在執行過程中，其他線程不能進來執行就可以解決這個問題。</p><p>如何保障共享數據的線程安全呢？</p><p><strong>java中提供了一個解決方式：就是同步代碼塊。</strong></p><p>格式：</p><p><strong>synchronized(對象) { //任意對象都可以。這個對象就是共享數據。</strong></p><p><strong>需要被同步的代碼；</strong></p><p><strong>}</strong></p><p>---------------------------------------------------------------</p><p><strong>同步：★★★★★</strong></p><p><strong>好處：</strong>解決了線程安全問題。Synchronized</p><p><strong>弊端</strong>：相對降低性能，因為判斷鎖需要消耗資源，產生了死鎖。</p><p>同步的第二種表現形式： <strong>//對共享資源的方法定義同步</strong></p><p><strong>同步函數</strong>：其實就是將同步關鍵字定義在函數上，讓函數具備了同步性。</p><p><strong>同步函數是用的哪個鎖呢？ //synchronized(this)用以定義需要進行同步的某一部分代碼塊</strong></p><p>通過驗證，函數都有自己所屬的對象this，所以同步函數所使用的鎖就是this鎖。<strong>This.方法名</strong></p><p><strong>當同步函數被static修飾時，這時的同步用的是哪個鎖呢？</strong></p><p>靜態函數在加載時所屬於類，這時有可能還沒有該類產生的對象，但是該類的字節碼文件加載進內存就已經被封裝成了對象，這個對象就是<strong>該類的字節碼文件對象</strong>。</p><p>所以靜態加載時，只有一個對象存在，那麼靜態同步函數就使用的這個對象。</p><p>這個對象就是 <strong>類名.class</strong></p><p><strong>同步代碼塊和同步函數的區別？</strong></p><p>同步代碼塊使用的鎖可以是任意對象。</p><p><strong>同步函數使用的鎖是this，靜態同步函數的鎖是該類的字節碼文件對象</strong>。</p><p><strong>在一個類中只有一個同步的話，可以使用同步函數。如果有多同步，必須使用同步代碼塊，來確定不同的鎖。所以同步代碼塊相對靈活一些。</strong></p><p>-------------------------------------------------------</p><p><strong>★考點問題：請寫一個延遲加載的單例模式？寫懶漢式；當出現多線程訪問時怎麼解決？加同步，解決安全問題；效率高嗎？不高；怎樣解決？通過雙重判斷的形式解決。</strong></p><p>//懶漢式：延遲加載方式。</p><p>當多線程訪問懶漢式時，因為懶漢式的方法內對共性數據進行多條語句的操作。所以容易出現線程安全問題。為了解決，加入同步機制，解決安全問題。但是卻帶來了效率降低。</p><p><strong>為了效率問題，通過雙重判斷的形式解決。</strong></p><p>class Single{</p><p>private static Single s = null;</p><p>private Single(){}</p><p>public static Single getInstance(){ //<strong>鎖是誰？字節碼文件對象；</strong></p><p><strong>if(s == null){</strong></p><p><strong>synchronized(Single.class){</strong></p><p><strong>if(s == null)</strong></p><p><strong>s = new Single();</strong></p><p><strong>}</strong></p><p><strong>}</strong></p><p>return s;</p><p>}</p><p>}</p><p>---------------------------------------------------------</p><p><strong>等待喚醒機制：</strong>涉及的方法：</p><p><strong>wait:</strong>將同步中的線程處於凍結狀態。釋放了執行權，釋放了資格。同時將線程對象存儲到線程池中。</p><p><strong>notify：</strong>喚醒線程池中某一個等待線程。</p><p><strong>notifyAll:</strong>喚醒的是線程池中的所有線程。</p><p>注意：</p><p>1：<strong>這些方法都需要定義在同步中</strong>。</p><p>2：因為這些方法必須要標示所屬的鎖。</p><p>你要知道 A鎖上的線程被wait了,那這個線程就相當於處於A鎖的線程池中，只能A鎖的notify喚醒。</p><p>3：這三個方法都定義在Object類中。為什麼操作線程的方法定義在Object類中？</p><p>因為這三個方法都需要定義同步內，並標示所屬的同步鎖，既然被鎖調用，而鎖又可以是任意對象，那麼能被任意對象調用的方法一定定義在Object類中。</p><p><strong>wait和sleep區別：</strong> 分析這兩個方法：從執行權和鎖上來分析：</p><p>wait：可以指定時間也可以不指定時間。不指定時間，只能由對應的notify或者notifyAll來喚醒。</p><p>sleep：必須指定時間，時間到自動從凍結狀態轉成運行狀態(臨時阻塞狀態)。</p><p><strong>wait：線程會釋放執行權，而且線程會釋放鎖。</strong></p><p><strong>sleep：線程會釋放執行權，但不是不釋放鎖。</strong></p><p><strong>線程的停止</strong>：通過stop方法就可以停止線程。但是這個方式過時了。</p><p>停止線程：原理就是：讓線程運行的代碼結束，也就是結束run方法。</p><p>怎麼結束run方法？一般run方法裡肯定定義循環。所以只要結束循環即可。</p><p>第一種方式：<strong>定義循環的結束標記。</strong></p><p>第二種方式：如果線程處於了凍結狀態，是不可能讀到標記的，這時就需要<strong>通過Thread類中的interrupt方法，將其凍結狀態強制清除</strong>。讓線程恢復具備執行資格的狀態，讓線程可以讀到標記，並結束。</p><p><strong>---------&lt; java.lang.Thread >----------</strong></p><p><strong>interrupt()：</strong>中斷線程。</p><p><strong>setPriority(int newPriority)：</strong>更改線程的優先級。</p><p><strong>getPriority()：</strong>返回線程的優先級。</p><p><strong>toString()：</strong>返回該線程的字符串表示形式，包括線程名稱、優先級和線程組。</p><p><strong>Thread.yield()：</strong>暫停當前正在執行的線程對象，並執行其他線程。</p><p><strong>setDaemon(true)：</strong>將該線程標記為守護線程或用戶線程。將該線程標記為守護線程或用戶線程。當正在運行的線程都是守護線程時，Java 虛擬機退出。該方法必須在啟動線程前調用。</p><p><strong>join</strong>：臨時加入一個線程的時候可以使用join方法。</p><p>當A線程執行到了B線程的join方式。A線程處於凍結狀態，釋放了執行權，B開始執行。A什麼時候執行呢？只有當B線程運行結束後，A才從凍結狀態恢復運行狀態執行。</p><p><strong>LOCK的出現替代了同步：lock.lock();………lock.unlock();</strong></p><p><strong>Lock接口：多線程在JDK1.5版本升級時，推出一個接口Lock接口。</strong></p><p>解決線程安全問題使用同步的形式，(同步代碼塊，要麼同步函數)其實最終使用的都是鎖機制。</p><p>到了後期版本，直接將鎖封裝成了對象。線程進入同步就是具備了鎖，執行完，離開同步，就是釋放了鎖。</p><p>在後期對鎖的分析過程中，發現，獲取鎖，或者釋放鎖的動作應該是鎖這個事物更清楚。所以將這些動作定義在了鎖當中，並把鎖定義成對象。</p><p>所以<strong>同步是隱示的鎖操作，而Lock對象是顯示的鎖操作</strong>，它的出現就替代了同步。</p><p>在之前的版本中使用Object類中wait、notify、notifyAll的方式來完成的。那是因為同步中的鎖是任意對象，所以操作鎖的等待喚醒的方法都定義在Object類中。</p><p>而現在鎖是指定對象Lock。所以查找等待喚醒機制方式需要通過Lock接口來完成。而Lock接口中並沒有直接操作等待喚醒的方法，而是將這些方式又單獨封裝到了一個對象中。這個對象就是<strong>Condition</strong>，將Object中的三個方法進行單獨的封裝。並提供了功能一致的方法<strong> await()、signal()、signalAll()</strong>體現新版本對象的好處。</p><p>&lt; java.util.concurrent.locks > Condition接口：await()、signal()、signalAll()；</p><p>--------------------------------------------------------</p><p><br></p><pre><code>class BoundedBuffer {final Lock lock = new ReentrantLock();final Condition notFull = lock.newCondition();final Condition notEmpty = lock.newCondition();final Object[] items = new Object[100];int putptr, takeptr, count;public void put(Object x) throws InterruptedException {lock.lock();try {while (count == items.length)notFull.await();items[putptr] = x;if (++putptr == items.length) putptr = 0;++count;notEmpty.signal();}   finally {lock.unlock();}}public Object take() throws InterruptedException {lock.lock();try {while (count == 0)notEmpty.await();Object x = items[takeptr];if (++takeptr == items.length) takeptr = 0;--count;notFull.signal();return x;}finally {lock.unlock();}}}</code></pre><p><br></p><h2 class=pgc-h-arrow-right>集合框架</h2><p><strong>集合框架：★★★★★，</strong>用於存儲數據的容器。</p><p>對於集合容器，有很多種。因為每一個容器的自身特點不同，其實原理在於每個容器的內部數據結構不同。</p><p>集合容器在不斷向上抽取過程中。出現了集合體系。</p><p><strong>在使用一個體系時，原則：參閱頂層內容。建立底層對象。</strong></p><div class=pgc-img><img alt="Java基礎知識總結 - 超詳細篇(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7b8b8a13b225417e89fded408fbf17a1><p class=pgc-img-caption></p></div><p>------------------------------------------------------------</p><p><strong>--&lt; java.util >-- List接口：</strong></p><p>List本身是Collection接口的子接口，具備了Collection的所有方法。現在學習List體系特有的共性方法，查閱方法發現List的特有方法都有索引，這是該集合最大的特點。</p><p><strong>List：有序(元素存入集合的順序和取出的順序一致)，元素都有索引。元素可以重複。</strong></p><p><strong>|--ArrayList：底層的數據結構是數組,線程不同步，ArrayList替代了Vector，查詢元素的速度非常快。</strong></p><p><strong>|--LinkedList：底層的數據結構是鏈表，線程不同步，增刪元素的速度非常快。</strong></p><p><strong>|--Vector：底層的數據結構就是數組，線程同步的，Vector無論查詢和增刪都巨慢。</strong></p><p><strong>可變長度數組的原理：</strong></p><p>當元素超出數組長度，會產生一個新數組，將原數組的數據複製到新數組中，再將新的元素添加到新數組中。</p><p>ArrayList：是按照原數組的50%延長。構造一個初始容量為 10 的空列表。</p><p>Vector：是按照原數組的100%延長。</p><p>------------------------------------------------------------</p><p><strong>--&lt; java.util >-- Set接口</strong>：</p><p>數據結構：數據的存儲方式；</p><p>Set接口中的方法和Collection中方法一致的。Set接口取出方式只有一種，<strong>迭代器</strong>。</p><p><strong>|--HashSet：</strong>底層數據結構是哈希表，線程<strong>是不同步的</strong>。<strong>無序，高效；</strong></p><p><strong>HashSet集合保證元素唯一性</strong>：通過元素的hashCode方法，和equals方法完成的。</p><p>當元素的hashCode值相同時，才繼續判斷元素的equals是否為true。</p><p>如果為true，那麼視為相同元素，不存。如果為false，那麼存儲。</p><p>如果hashCode值不同，那麼不判斷equals，從而提高對象比較的速度。</p><p><strong>|--LinkedHashSet：有序，hashset的子類。</strong></p><p><strong>|--TreeSet：</strong>對Set集合中的元素的進行指定順序的排序。<strong>不同步</strong>。TreeSet底層的數據結構就是二叉樹。</p><p><strong>對於ArrayList集合，判斷元素是否存在，或者刪元素底層依據都是equals方法。</strong></p><p><strong>對於HashSet集合，判斷元素是否存在，或者刪除元素，底層依據的是hashCode方法和equals方法。</strong></p><p>------------------------------------------------------------</p><p><strong>Map集合：</strong></p><p><strong>|--Hashtable：</strong>底層是哈希表數據結構，是<strong>線程同步</strong>的。不可以存儲null鍵，null值。</p><p><strong>|--HashMap：</strong>底層是哈希表數據結構，是<strong>線程不同步</strong>的。可以存儲null鍵，null值。替代了Hashtable.</p><p><strong>|--TreeMap：</strong>底層是二叉樹結構，可以對map集合中的鍵進行指定順序的排序。</p><p>Map集合存儲和Collection有著很大不同：</p><p>Collection一次存一個元素；Map一次存一對元素。</p><p>Collection是單列集合；Map是雙列集合。</p><p>Map中的存儲的一對元素：一個是鍵，一個是值，<strong>鍵與值之間有對應(映射)關係。</strong></p><p><strong>特點：要保證map集合中鍵的唯一性。</strong></p><p><strong>5，想要獲取map中的所有元素：</strong></p><p><strong>原理：</strong>map中是沒有迭代器的，collection具備迭代器，只要將map集合轉成Set集合，可以使用迭代器了。之所以轉成set，是因為map集合具備著鍵的唯一性，其實set集合就來自於map，set集合底層其實用的就是map的方法。</p><p><strong>把map集合轉成set的方法：</strong></p><p><strong>Set keySet();</strong></p><p><strong>Set entrySet();</strong>//取的是鍵和值的映射關係。</p><p>Entry就是Map接口中的內部接口；</p><p>為什麼要定義在map內部呢？entry是訪問鍵值關係的入口，是map的入口，訪問的是map中的鍵值對。</p><p>---------------------------------------------------------</p><p><strong>取出map集合中所有元素的方式一：keySet()方法。</strong></p><p>可以將map集合中的鍵都取出存放到set集合中。對set集合進行迭代。迭代完成，再通過get方法對獲取到的鍵進行值的獲取。</p><pre><code>Set keySet = map.keySet();       Iterator it = keySet.iterator();       while(it.hasNext()) {           Object key = it.next();           Object value = map.get(key);           System.out.println(key+":"+value);       }</code></pre><p><br></p><p>--------------------------------------------------------</p><p><strong>取出map集合中所有元素的方式二：entrySet()方法。</strong></p><pre><code>Set entrySet = map.entrySet();       Iterator it = entrySet.iterator();       while(it.hasNext()) {           Map.Entry me = (Map.Entry)it.next();           System.out.println(me.getKey()+"::::"+me.getValue());       }</code></pre><p>-------------------------------------------------------</p><p><strong>將非同步集合轉成同步集合的方法：Collections中的 </strong>XXX</p><pre><code>synchronizedXXX(XXX);List synchronizedList(list);Map synchronizedMap(map);public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) {return new SynchronizedMap&lt;K,V&gt;(m);}</code></pre><p><br></p><p><strong>原理：定義一個類，將集合所有的方法加同一把鎖後返回。</strong></p><p>List list = Collections.synchronizedList(new ArrayList());</p><p>Map&lt;String,String> synmap = Collections.synchronizedMap(map);</p><p><strong>Collection 和 Collections的區別：</strong></p><p>Collections是個java.util下的類，是針對集合類的一個工具類,提供一系列靜態方法,實現對集合的查找、排序、替換、線程安全化（將非同步的集合轉換成同步的）等操作。</p><p>Collection是個java.util下的接口，它是各種集合結構的父接口，繼承於它的接口主要有Set和List,提供了關於集合的一些操作,如插入、刪除、判斷一個元素是否其成員、遍歷等。</p><p>-------------------------------------------------------</p><p><strong>自動拆裝箱：</strong>java中數據類型分為兩種 ：基本數據類型 引用數據類型(對象)</p><p>在 java程序中所有的數據都需要當做對象來處理，針對8種基本數據類型提供了包裝類，如下：</p><p>int --> Integer</p><p>byte --> Byte</p><p>short --> Short</p><p>long --> Long</p><p>char --> Character</p><p>double --> Double</p><p>float --> Float</p><p>boolean --> Boolean</p><p>jdk5以前基本數據類型和包裝類之間需要互轉：</p><p>基本---引用 Integer x = new Integer(x);</p><p>引用---基本 int num = x.intValue();</p><p>1)、Integer x = 1; x = x + 1; 經歷了什麼過程？<strong>裝箱 à 拆箱 à 裝箱</strong>；</p><p>2)、為了優化，虛擬機為包裝類提供了緩衝池，<strong>Integer池的大小 -128~127 一個字節的大小</strong>；</p><p>3)、<strong>String池：</strong>Java為了優化字符串操作 提供了一個緩衝池；</p><p>----------------------------------------------------------</p><p><strong>泛型：</strong>jdk1.5版本以後出現的一個安全機制。表現格式：<strong>&lt; ></strong></p><p><strong>好處：</strong></p><p><strong>1：將運行時期的問題ClassCastException問題轉換成了編譯失敗，體現在編譯時期，程序員就可以解決問題。</strong></p><p><strong>2：避免了強制轉換的麻煩。</strong></p><p><strong>泛型中的通配符：</strong>可以解決當具體類型不確定的時候，這個通配符就是 <strong>?</strong> ；當操作類型時，不需要使用類型的具體功能時，只使用Object類中的功能。那麼可以用 ? 通配符來表未知類型。</p><p>-------------------------------------------------------------------------------------------------------------------------------</p><h2 class=pgc-h-arrow-right>反射技術</h2><p><strong>反射技術：</strong>其實就是動態加載一個指定的類，並獲取該類中的所有的內容。並將字節碼文件中的內容都封裝成對象，這樣便於操作這些成員。簡單說：<strong>反射技術可以對一個類進行解剖。</strong></p><p><strong>反射的好處：</strong>大大的增強了程序的擴展性。</p><p><strong>反射的基本步驟：</strong></p><p><strong>1、獲得Class對象，就是獲取到指定的名稱的字節碼文件對象。</strong></p><p><strong>2、實例化對象，獲得類的屬性、方法或構造函數。</strong></p><p><strong>3、訪問屬性、調用方法、調用構造函數創建對象。</strong></p><p><strong>獲取這個Class對象，有三種方式：</strong></p><p>1：通過每個對象都具備的方法getClass來獲取。弊端：必須要創建該類對象，才可以調用getClass方法。</p><p>2：每一個數據類型(基本數據類型和引用數據類型)都有一個<strong>靜態的屬性class</strong>。弊端：必須要先明確該類。</p><p>前兩種方式不利於程序的擴展，因為都需要在程序使用具體的類來完成。</p><p>3：使用的Class類中的方法，<strong>靜態的forName方法</strong>。</p><p>指定什麼類名，就獲取什麼類字節碼文件對象，這種方式的擴展性最強，只要將類名的字符串傳入即可。</p><p><strong>// 1. 根據給定的類名來獲得 用於類加載</strong></p><p>String classname = "cn.itcast.reflect.Person";// 來自配置文件</p><p>Class clazz = Class.forName(classname);// 此對象代表Person.class</p><p><strong>// 2. 如果拿到了對象，不知道是什麼類型 用於獲得對象的類型</strong></p><p>Object obj = new Person();</p><p>Class clazz1 = obj.getClass();// 獲得對象具體的類型</p><p><strong>// 3. 如果是明確地獲得某個類的Class對象 主要用於傳參</strong></p><p>Class clazz2 = Person.class;</p><p><strong>反射的用法</strong>：</p><p>1）、需要獲得java類的各個組成部分，首先需要獲得類的Class對象，獲得Class對象的三種方式：</p><p><strong>Class.forName(classname)</strong> 用於做類加載</p><p>obj.getClass() 用於獲得對象的類型</p><p>類名.class 用於獲得指定的類型，傳參用</p><p>2)、反射類的成員方法：</p><p>Class clazz = Person.class;</p><p>Method method = clazz.getMethod(methodName, new Class[]{paramClazz1, paramClazz2});</p><p>method.invoke();</p><p>3)、反射類的構造函數：</p><p>Constructor con = clazz.getConstructor(new Class[]{paramClazz1, paramClazz2,...})</p><p>con.newInstance(params...)</p><p>4)、反射類的屬性：</p><p>Field field = clazz.getField(fieldName);</p><p>field.setAccessible(true);</p><p>field.setObject(value);</p><p><strong>獲取了字節碼文件對象後，最終都需要創建指定類的對象：</strong></p><p><strong>創建對象的兩種方式(其實就是對象在進行實例化時的初始化方式)：</strong></p><p>1，調用空參數的構造函數：使用了Class類中的<strong>newInstance()</strong>方法。</p><p>2，調用帶參數的構造函數：先要獲取指定參數列表的構造函數對象，然後通過該構造函數的<strong>對象的newInstance(實際參數) </strong>進行對象的初始化。</p><p>綜上所述，第二種方式，必須要先明確具體的構造函數的參數類型，不便於擴展。<strong>所以一般情況下，被反射的類，內部通常都會提供一個公有的空參數的構造函數。</strong></p><p>------------------------------------------------------</p><p><strong>// 如何生成獲取到字節碼文件對象的實例對象。</strong></p><p>Class clazz = Class.forName("cn.itcast.bean.Person");<strong>//類加載</strong></p><p>// 直接獲得指定的類型</p><p>clazz = Person.<strong>class</strong>;</p><p>// 根據對象獲得類型</p><p>Object obj = <strong>new</strong> Person("zhangsan", 19);</p><p>clazz = obj.getClass();</p><p>Object obj = clazz.newInstance();//該實例化對象的方法調用就是指定類中的空參數構造函數，給創建對象進行初始化。當指定類中沒有空參數構造函數時，該如何創建該類對象呢？請看method_2();</p><p>public static void method_2() throws Exception {</p><p>Class clazz = Class.forName("cn.itcast.bean.Person");</p><p>//既然類中沒有空參數的構造函數,那麼只有獲取指定參數的構造函數,用該函數來進行實例化。</p><p><strong>//獲取一個帶參數的構造器。</strong></p><p>Constructor constructor = clazz.<strong>getConstructor</strong>(String.class,int.class);</p><p><strong>//想要對對象進行初始化，使用構造器的方法newInstance();</strong></p><p>Object obj = constructor.newInstance("zhagnsan",30);</p><p><strong>//獲取所有構造器。</strong></p><p>Constructor[] constructors = clazz.getConstructors();//只包含公共的</p><p>constructors = clazz.getDeclaredConstructors();//包含私有的</p><p>for(Constructor con : constructors) {</p><p>System.out.println(con);</p><p>}</p><p>}</p><p>------------------------------------------------------</p><p><strong>反射指定類中的方法：</strong></p><p><strong>//獲取類中所有的方法。</strong></p><p>public static void method_1() throws Exception {</p><p>Class clazz = Class.forName("cn.itcast.bean.Person");</p><p>Method[] methods = clazz.<strong>getMethods</strong>();<strong>//獲取的是該類中的公有方法和父類中的公有方法。</strong></p><p>methods = clazz.<strong>getDeclaredMethods</strong>();<strong>//獲取本類中的方法，包含私有方法。</strong></p><p>for(Method method : methods) {</p><p>System.out.println(method);</p><p>}</p><p>}</p><p><strong>//獲取指定方法；</strong></p><p>public static void method_2() throws Exception {</p><p>Class clazz = Class.forName("cn.itcast.bean.Person");</p><p><strong>//獲取指定名稱的方法。</strong></p><p>Method method = clazz.getMethod("show", int.class,String.class);</p><p><strong>//想要運行指定方法，當然是方法對象最清楚，為了讓方法運行，調用方法對象的invoke方法即可，但是方法運行必須要明確所屬的對象和具體的實際參數。</strong></p><p>Object obj = clazz.newInstance();</p><p>method.<strong>invoke</strong>(obj, 39,"hehehe");<strong>//執行一個方法</strong></p><p>}</p><p><strong>//想要運行私有方法。</strong></p><p>public static void method_3() throws Exception {</p><p>Class clazz = Class.forName("cn.itcast.bean.Person");</p><p><strong>//想要獲取私有方法。必須用getDeclearMethod();</strong></p><p>Method method = clazz.getDeclaredMethod("method", null);</p><p><strong>// 私有方法不能直接訪問，因為權限不夠。非要訪問，可以通過暴力的方式。</strong></p><p><strong>method.setAccessible(true);</strong>//一般很少用，因為私有就是隱藏起來，所以儘量不要訪問。</p><p>}</p><p><strong>//反射靜態方法。</strong></p><p>public static void method_4() throws Exception {</p><p>Class clazz = Class.forName("cn.itcast.bean.Person");</p><p>Method method = clazz.getMethod("function",null);</p><p>method.invoke(null,null);</p><p>}</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>基礎</a></li><li><a>知識</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a398feda.html alt=「Java基礎知識」J2EE基礎知識，快看看和Java基礎的差別吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ae630290a7243d28f4c0dc08d22b88f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a398feda.html title=「Java基礎知識」J2EE基礎知識，快看看和Java基礎的差別吧>「Java基礎知識」J2EE基礎知識，快看看和Java基礎的差別吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html alt=素描五官基礎知識，學素描的同學可參考 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99b7762898d34e2f9a667c431fc7da6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html title=素描五官基礎知識，學素描的同學可參考>素描五官基礎知識，學素描的同學可參考</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18bd39d8.html alt=齒輪基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b8e178319e2c4b88a1865f903306a26b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18bd39d8.html title=齒輪基礎知識>齒輪基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html alt=SQL基礎知識——事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/773e21df09dc4e3e8403a0a62994039d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html title=SQL基礎知識——事務>SQL基礎知識——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a12da43e.html alt="金屬材料學 一些基礎知識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac00002279849cb698 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a12da43e.html title="金屬材料學 一些基礎知識">金屬材料學 一些基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09bdf3b9.html alt=高考數學基礎知識鞏固專題：同角三角函數的基本關係和誘導公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4ad700017a27db3c428d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09bdf3b9.html title=高考數學基礎知識鞏固專題：同角三角函數的基本關係和誘導公式>高考數學基礎知識鞏固專題：同角三角函數的基本關係和誘導公式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72199127.html alt=「鋼筋知識」0基礎學鋼筋 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/9e06a03e-e475-4bc2-8bf9-539c7335c2cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72199127.html title=「鋼筋知識」0基礎學鋼筋>「鋼筋知識」0基礎學鋼筋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ade09ce0.html alt=電工基礎知識電路圖 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5b7d7f6b7a8746e48eb6e87875924731 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ade09ce0.html title=電工基礎知識電路圖>電工基礎知識電路圖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e0965e2.html alt=電路圖的基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/089a32c7bb1e4cb7aa6d83ee18113344 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e0965e2.html title=電路圖的基礎知識>電路圖的基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75a3b95c.html alt=配電房佈置的基礎知識詳解（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad303237b614457bba8b5db81c06cf4a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75a3b95c.html title=配電房佈置的基礎知識詳解（一）>配電房佈置的基礎知識詳解（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cef7ae85.html alt=工程造價基礎知識你瞭解多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/046439fc0e5a4cd7a5cdcadb9000d8cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cef7ae85.html title=工程造價基礎知識你瞭解多少？>工程造價基礎知識你瞭解多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02e2580a.html alt=工程造價基礎知識，新手務必人手一份 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7cc086b6b2a047b0a023233e5d8c4f16 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02e2580a.html title=工程造價基礎知識，新手務必人手一份>工程造價基礎知識，新手務必人手一份</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57302aed.html alt=電工基礎知識-配電室安全須知 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a653289e83ba4c59b0416ab25e9b0d1e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57302aed.html title=電工基礎知識-配電室安全須知>電工基礎知識-配電室安全須知</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5bd339f.html alt=數組基礎知識：100萬成員的數組取第一和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dfc9869dbc274741b7ff68e0877cb33a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5bd339f.html title=數組基礎知識：100萬成員的數組取第一和最後一個有性能差距嗎？>數組基礎知識：100萬成員的數組取第一和最後一個有性能差距嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>