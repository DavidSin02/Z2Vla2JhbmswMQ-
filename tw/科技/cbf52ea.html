<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 | 极客快訊</title><meta property="og:title" content="極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/7227b6203bd743bc90c8a3373d290911"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><meta property="article:published_time" content="2020-10-29T20:53:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:41+08:00"><meta name=Keywords content><meta name=description content="極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/cbf52ea.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>目錄</p><ul><li>緩存引爆鏈表</li><li>鏈表單鏈表雙向鏈表循環鏈表雙向循環鏈表</li><li>LinkedHashMap實現LRU緩存，源碼解析（JDK1.8）</li><li>算法 爬樓梯</li><li>算法 反轉鏈表</li><li>算法 鏈表環檢測</li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>緩存引爆鏈表</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7227b6203bd743bc90c8a3373d290911><p class=pgc-img-caption></p></div><p>存儲結構</p><p>上一篇說的是數組，然後現在來說說鏈表。鏈表有個經典應用，就是實現LRU緩存淘汰算法，緩存的作用大家肯定都知道，常見的Redis緩存，CPU緩存，數據庫緩存，瀏覽器緩存，預熱緩存等等緩存技術。緩存大小有限，當緩存滿了，需要淘汰策略來決定哪些數據出局，常見緩存算法有三種，這裡以緩存中數據命中率來評判緩存算法的優劣來看三種淘汰算法：</p><ol start=1><li>FIFO（First in, First out），先進先出策略，不管你是誰，排好隊一個一個來，這種做法簡單粗暴公平，但是顯然是沒有考慮緩存數據的使用頻率問題了，所以這種算法使用不多；</li><li>LFU（Least Frequently Used），最近最不頻繁使用策略，即最近最少使用到的數據出局，是從時間和數據使用頻率來決定的，</li></ol><ul><li>實現：LFU的每個數據塊都有一個引用計數，所有數據塊按照引用計數排序，具有相同引用計數的數據塊則按照時間排序；</li><li>缺點：需要記錄所有數據的訪問記錄，內存消耗較高；需要基於引用計數排序，時間消耗較高；</li></ul><ol start=3><li>LRU（Least Recently Used），最近最久未使用策略，主要是從時間來進行淘汰，如果一個數據在最近一段時間沒有被訪問到，那麼可以認為在將來它被訪問的可能性也很小，把這些數據淘汰掉。</li></ol><ul><li>實現： 不就是需要根據時間來淘汰嘛，最容易想到的就是 數組+時間戳，但是這樣實現不用想也知道效率賊低。因此java 中的 <strong>「LinkedHashMap」</strong> 源碼就是使用這種緩存算法，底層用 雙向鏈表（LinkedList）+哈希表（HashMap）實現（鏈表用來表示位置，哈希表用來存儲和查找），下面我會把這部分源碼進行剖析；</li><li>應用：現在使用最廣泛的分佈式緩存系統如Redis，Memchached，容器如LinkedHashMap 就使用了這種緩存算法，</li></ul><ol start=4><li>LRU 和LFU 區別：</li></ol><p>LRU:活在當下。比如在公司中，一個新員工做出新業績，馬上會得到重用。</p><p>LFU:以史為鏡。還是比如在公司中，新員工必須做出比老員工累計更多更好的業績才可以受到老闆重視，這樣的方式比較尊重“前輩”。</p><p>因此，我們可以就知道鏈表的偉大貢獻了，看到了作用我才去學你懂你，這是我一貫的作風，要不然我學你做什麼。</p><h1 class=pgc-h-arrow-right><strong>鏈表</strong></h1><p>上一節說數組的時候，我一直強調要一段連續的空間，鏈表就不需要，他是通過“指針”將一組零散的內存塊串聯起來使用，不需要連續只要有空間就夠了。所以鏈表結點除了數據之外，比數組多存儲了個“指針”，數組是靠數組下標偏移量（計算出地址偏移位）找數據，鏈表是靠指針（直接存儲地址）找數據。</p><p>在操作鏈表的時候，要格外注意二點：</p><ol start=1><li>邊界問題，例如插入有頭插尾插中間插入，要注意額外的操作；</li><li>代碼順序，防止丟失指針</li></ol><h1 class=pgc-h-arrow-right><strong>單鏈表</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a77dd78786a44e2bb95ad8886b11e3bf><p class=pgc-img-caption></p></div><p>鏈表</p><p>首先理解兩個概念：</p><ul><li>頭指針：通常使用“頭指針”來標識一個鏈表，如單鏈表L，頭指針為NULL的時表示一個空鏈表。</li><li>頭結點：在單鏈表的第一個結點之前附加一個結點，稱為頭結點。頭結點的Data域可以不設任何信息，也可以記錄表長等相關信息。</li></ul><p>不管你有沒有頭結點，頭指針始終是有的，代表了鏈表的基地址，有基地址才能遍歷。頭指針始終指向第一個結點，有頭結點就指向頭結點。</p><p><strong>「帶頭結點好處」</strong></p><ol start=1><li>方便第一個位置的插入和刪除</li><li>統一空表和非空表的處理</li></ol><p>有頭結點可以簡化很多邊界問題的考慮，將邊界問題轉化為正常的結點處理。</p><p>最後一個是尾結點，尾結點不指向下一個結點，而是指向空地址NULL，代表這個鏈表結束了。</p><h1 class=pgc-h-arrow-right><strong>中間插入</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b1c5a9d28cb466087061311a85ca147><p class=pgc-img-caption></p></div><p>中間插入</p><p>注意點： 防止指針丟失和內存洩漏</p><p>“=”是賦值，習慣性從右往左讀，例插入之前是 p->next = q，q 賦值給 p->next。</p><p>錯誤實現：</p><pre><code>p-&gt;next = x; // 將p的next指針指向x結點;x-&gt;next = p-&gt;next; // 將x的結點的next指針指向b結點;</code></pre><p>第一步之後p->next = x，p->next指向了x結點，第二步相當於將 x賦值給 x->next，即相當於x->next = x，自己指向自己，顯而易見的問題：q 的地址丟失了，從 q 往後的結點都訪問不到，鏈表斷成了兩截。後面的地址弄丟了，JAVA有垃圾回收機制還好，C這樣的語言程序員如果沒有手動釋放那些結點佔的內存，就產生了內存洩漏，同時刪除結點的時候如果不把結點的空間釋放也會內存洩漏。</p><p>正確實現：</p><pre><code>x-&gt;next = p-&gt;next; // 將x的結點的next指針指向b結點;p-&gt;next = x; // 將p的next指針指向x結點;</code></pre><p>順序調換一下，先將q的地址存儲好放到x結點，然後x結點再鏈接到p結點就好了。</p><p>這個問題開始重視起來是在大三找實習一家遊戲公司總監問到，讓我把這個地方再說一遍，我暗地裡虎軀一震菊花一緊表面上卻穩如泰山，最後用溫柔的微笑讓他如沐春風從而化解了這個尷尬，馬上改口。</p><h1 class=pgc-h-arrow-right><strong>頭插入</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/225b99217c9c4edea0f0671834d37a1e><p class=pgc-img-caption></p></div><p>頭插法</p><pre><code>x-&gt;next = head-&gt;next; // 將x的結點的next指針指向b結點;head-&gt;next = x; // 將p的next指針指向x結點;</code></pre><p>可知有了頭結點，頭插入代碼和中間插入代碼是一樣的，只不過上一個p結點變成了head 結點。</p><h1 class=pgc-h-arrow-right><strong>尾插入</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7f573ea62dab478d88f43e2c2864131e><p class=pgc-img-caption></p></div><p>尾插法</p><pre><code>x.next = null;tail.next = x;</code></pre><h1 class=pgc-h-arrow-right><strong>頭插法 VS 尾插法</strong></h1><p>HashMap 源碼中，jdk8之前hash衝突時候用的都是頭插法，jdk1.8之後用的尾插法，不知道你是否還有印象，主要原因是防止擴容的時候頭插法造成鏈表環化，具體的讀者有興趣看看擴容源碼。</p><p>頭插法：遍歷時候得到的數據順序和插入的時候是相反的，原因是你第一次插進去的數據實際上成為了鏈表的尾巴；</p><p>尾插法：遍歷得到的數據和插入的順序是一致的。</p><h1 class=pgc-h-arrow-right><strong>刪除結點</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e0683cdab4e4deab238b6b8a867e6d6><p class=pgc-img-caption></p></div><p>刪除中間結點</p><p>p->next = p->next->next; 一行代碼就可以</p><h1 class=pgc-h-arrow-right><strong>雙向鏈表</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45c9425990e74b329e6d11a97f2d99a9><p class=pgc-img-caption></p></div><p>雙向鏈表</p><p>單鏈表的插入、刪除操作的時間複雜度已經是O(1)了，為什麼還要雙向鏈表呢？優點在哪裡。</p><p>還是從插入，刪除，查找來看，拿刪除操作來分析，無非兩種情況：</p><ol start=1><li>刪除給定指針指向的結點</li><li>刪除結點中值等於xxx的結點</li></ol><p>第二種，對於單鏈表和雙鏈表都需要先進行遍歷，直到找到值等於給定值的結點，然後刪除；</p><p>第一種，區別就來了，我們已經找到了要刪除的結點，但是刪除某個結點q需要知道其前驅結點，單鏈表找前驅結點還是需要遍歷先找到前驅結點，雙鏈表就可以直接拿到前驅結點；</p><p>然後實際應用中，例如容器 HashMap，都是知道指針，第一種操作比較多，刪除插入操作就是指針的操作，值都是動態變得不可能告訴你一個值再讓你刪除，所以這種結構的重要性不言而喻了，插入操作這裡不再分析了。</p><h1 class=pgc-h-arrow-right><strong>循環鏈表</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4b5a4a5df3c41c98c70ece6718cb390><p class=pgc-img-caption></p></div><p>循環鏈表</p><p>和單鏈表相比，循環鏈表的優點是從鏈尾到鏈頭比較方便。當要處理的數據具有環型結構特點時，就特別適合採用循環鏈表。比如著名的約瑟夫問題。儘管用單鏈表也可以實現，但是用循環鏈表實現的話，代碼就會簡潔很多。</p><blockquote><p>❝</p><p>約瑟夫問題 據說著名猶太歷史學家Josephus有過以下的故事：在羅馬人佔領喬塔帕特後，39 個猶太人與Josephus及他的朋友躲到一個洞中，39個猶太人決定寧願死也不要被敵人抓到，於是決定了一個自殺方式，41個人排成一個圓圈，由第1個人開始報數，每報數到第3人該人就必須自殺，然後再由下一個重新報數，直到所有人都自殺身亡為止。然而Josephus 和他的朋友並不想遵從。首先從一個人開始，越過k-2個人（因為第一個人已經被越過），並殺掉第k個人。接著，再越過k-1個人，並殺掉第k個人。這個過程沿著圓圈一直進行，直到最終只剩下一個人留下，這個人就可以繼續活著。問題是，給定了和，一開始要站在什麼地方才能避免被處決？Josephus要他的朋友先假裝遵從，他將朋友與自己安排在第16個與第31個位置，於是逃過了這場死亡遊戲。</p><p>❞</p></blockquote><h1 class=pgc-h-arrow-right><strong>雙向循環鏈表</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f9d21916b4ef4659aef74cbddfec2182><p class=pgc-img-caption></p></div><p>雙向循環鏈表</p><h1 class=pgc-h-arrow-right><strong>LinkedHashMap實現LRU緩存，源碼解析（JDK1.8）</strong></h1><pre><code>/** * A cache implementing a least recently used policy. */public class LRUCache&lt;K, V&gt; implements Cache&lt;K, V&gt; {    private final LinkedHashMap&lt;K, V&gt; cache;    public LRUCache(final int maxSize) {        cache = new LinkedHashMap&lt;K, V&gt;(16, .75f, true) {            @Override            protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {                return size() &gt; maxSize;            }        };    }    方法偽代碼：    public V get(K key)    public void put(K key, V value)    public boolean remove(K key)    public long size()    }</code></pre><p>可以得知 LRUCache 緩存就是使用 LinkedHashMap 結構實現的。</p><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec625a29e480413492c2d11d98bac4f2><p class=pgc-img-caption></p></div><p>LinkedHashMap結構圖</p><p>LinkedHashMap 繼承了 HashMap（jdk1.8），總的結構還是 數據+鏈表+紅黑樹，為了簡化思想圖裡面沒有紅黑樹的，就這樣看哦；</p><pre><code>public class LinkedHashMap&lt;K,V&gt;    extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt;{    /**     * HashMap.Node subclass for normal LinkedHashMap entries.     */    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {        Entry&lt;K,V&gt; before, after;        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {            super(hash, key, value, next);        }    }    private static final long serialVersionUID = 3801124242820219131L;    //雙向鏈表頭結點    transient LinkedHashMap.Entry&lt;K,V&gt; head;    //雙向鏈表尾結點    transient LinkedHashMap.Entry&lt;K,V&gt; tail;       //如果accessOrder為flase的話，則按插入順序來遍歷，默認fasle    /**     true  基於訪問順序    當accessOrder設置為true時，被訪問的數據，將會被移到鏈表的尾部，put使用的也是尾插法；同時get是從尾部開始訪問，所以等於越常使用的數據，遍歷的時間越短。    **/    final boolean accessOrder;</code></pre><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cc1eb8a4d61d42c98c680519beb85cc3><p class=pgc-img-caption></p></div><p>LRU 初始化啟動 true</p><p>LRU 緩存初始化的時候，就用了這個 accessOrder，設置為true，從而最近被訪問到的數據放到了鏈表末尾，鏈表前面的數據是長時間沒有使用的，從鏈表末尾開始訪問的話，鏈表頭部開始的長久沒有訪問的數據就被淘汰掉了，從而實現LRU緩存。</p><pre><code>Map 的 Entry 結點內容static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        }        ·······}// LinkedHashMap 的 Entry，可以看到比Map的結點多了兩個指針 before,afterstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {        Entry&lt;K,V&gt; before, after;        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {            super(hash, key, value, next);        }}</code></pre><pre><code>//生成一個新的結點Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {        LinkedHashMap.Entry&lt;K,V&gt; p =            new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);        //結點尾插法放入鏈表最後        linkNodeLast(p);        return p;    }    //尾插法，把新結點插入鏈表末尾private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {    // 尾結點賦值給 last 指針    LinkedHashMap.Entry&lt;K,V&gt; last = tail;    // P 結點賦值給尾結點    tail = p;    // 如果尾部節點為空，說明是空鏈表，那麼插入的就是第一個節點。這個時候新加入的數據賦給頭部節點    if (last == null)        head = p;    // 不是空鏈表，將新結點放到末尾        else {        p.before = last;        last.after = p;    }}</code></pre><p>LinkedHashMap是繼承的HashMap，插入刪除都是直接用的HashMap的插入刪除方法，只不過它重寫了三個回調方法，來實現他需要的額外操作，如下：</p><pre><code>// 在hashmap正常刪除一個結點之後進行回調void afterNodeRemoval(Node&lt;K,V&gt; e) {         /**定義了一個結點p，將傳遞進來的的e結點賦值給p，把傳進來的e結點賦值給p結點，並且定義p的前驅結點b，後繼結點a **/        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.before = p.after = null;        // 如果前一個結點是null，那麼這是個空鏈表        if (b == null)            head = a;        else            b.after = a;        if (a == null)            tail = b;        else            a.before = b;    }</code></pre><pre><code>//在hashmap正常插入一個結點之後進行回調，插入一個結點可能緩存滿了，因此需要移除最久沒有使用的結點即第一個結點（前面講了LRU的調度算法，不明白的可以回頭去看）/**//根據evict,也就是前文linkedHashMap構造函數中的accessOrder，來判斷是否刪除雙向鏈表中最老的元素，這個是實現lru需要用到的。**/void afterNodeInsertion(boolean evict) { // possibly remove eldest        LinkedHashMap.Entry&lt;K,V&gt; first;        if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {            K key = first.key;            // hashmap的移除結點方法，傳key第一個結點過去進行刪除            removeNode(hash(key), key, null, false, true);        }    }</code></pre><pre><code>// 最常用是hashmap正常putVal之後調用，將新加入的結點移動到鏈表末尾void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last        LinkedHashMap.Entry&lt;K,V&gt; last;        if (accessOrder &amp;&amp; (last = tail) != e) {        // 把傳進來的e結點賦值給p結點，並且定義p的前驅結點b，後繼結點a            LinkedHashMap.Entry&lt;K,V&gt; p =                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;            p.after = null;            if (b == null)                head = a;            else                b.after = a;            if (a != null)                a.before = b;            else                last = b;            if (last == null)                head = p;            else {                p.before = last;                last.after = p;            }            // 把p結點賦值給尾結點            tail = p;            ++modCount;        }    }</code></pre><p>afterNodeAccess()方法圖解：</p><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76575c327db840e1afdda0727926a1bd><p class=pgc-img-caption></p></div><p>afterNodeAccess 方法圖解</p><p>還是挺複雜的，畫了一個多小時這張圖。</p><h1 class=pgc-h-arrow-right><strong>算法 爬樓梯</strong></h1><p>上一篇的遺留算法：</p><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/77ad256f001745d8b80f0c25b3273e69><p class=pgc-img-caption></p></div><p>爬樓梯</p><p>超哥說，<strong>「解決所有問題的法則」</strong>：</p><ol start=1><li>找最近重複的子問題；</li><li>為什麼？因為寫程序我們只能寫if，else，for，while，recursion（遞歸）；</li><li>計算機是人類發明的，計算機肯定是沒有人腦那麼強的，它其實就是一個簡單的重複式機器那麼計算機運行的程序也是同理，它是用重複的東西來解決問題的；</li><li>如果我們遇到算法題的時候，就是需要我們用程序去解決的問題，那問題的本身就是可重複的；</li><li>無論是算法中的回溯、分治、動態規劃、遞歸等，全部都是在找重複性的原理所以重點都是“找規律”；</li></ol><p>分析問題：</p><ol start=1><li>剛剛拿到，沒有思路，先暴力舉例 一階（1種）：1</li></ol><p>二階（2種）：1+1，2</p><p>三階（3種）：1+1+1，2+1，1+2 即二階的走法+1和一階的走法+2</p><p>四階（5種）：1+1+1+1，1+2+1，2+1+1，1+1+2，2+2，即三階的走法+1和二階的走法+2，共五種</p><p>五階（8種）：1+1+1+1+1，1+2+1，2+1+1，1+1+2+1，2+2+1，1+1+1+2，2+1+2，1+2+2 即四階的走法+1和三階的走法+2，共八種</p><p>......</p><p>思想：例如一共10階，那麼有兩種方法，要不就是你走到了第八階跨2步，或者走到第九階了跨1步，再也沒有別的實現了，因為你一次性只能跨兩步或者一步，所以最終次數就是到達第八階次數+到達第九階的次數，f(10)=f(9)+f(8),每一層都是如此情況，即在上一個臺階走2步或者走1步到達終點，可知這其實是個斐波拉契問題。</p><p><strong>「實現：」</strong></p><ol start=1><li>斐波拉契，遞歸</li></ol><pre><code>    public static int climbStairs(int n) {        if (n &lt;= 1)            return 1;        if (n &lt; 3)            return n;        return climbStairs(n - 1) + climbStairs(n - 2);    }</code></pre><p>但是這種方法，會一直遞歸，重複計算很多，例如我再代碼裡面打印一下就能看到：</p><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fa9010378358405395470f3b8661b853><p class=pgc-img-caption></p></div><p>重複計算</p><p>圖解：</p><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d72f2c6b161042ce9afdd285cecae3a4><p class=pgc-img-caption></p></div><p>Fib6</p><p>由圖解可知，很多都被重複計算了多次，下面進行優化</p><ol start=2><li>循環</li></ol><pre><code> public int climbStairs(int n) {        if (n &lt;= 1)            return 1;        int[] dp = new int[n + 1];        dp[1] = 1;        dp[2] = 2;        for (int i = 3; i &lt;= n; i++) {            dp[i] = dp[i - 1] + dp[i - 2];        }        return dp[n];    }</code></pre><p>用數組將每一階的到達次數給存儲，直接拿前面兩個數據的和即可。</p><ol start=3><li>循環優化</li></ol><p>可以不用數組存儲每一階的到達次數，直接定義兩個變量就可以，節省了空間</p><ol start=4><li>公式實現</li></ol><p>這個需要推導公式，非大佬不行，感興趣自行百科。</p><h1 class=pgc-h-arrow-right><strong>算法 反轉鏈表</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92e6c09d84bc4802be1329ec0645a00d><p class=pgc-img-caption></p></div><p>反轉鏈表</p><h1 class=pgc-h-arrow-right><strong>算法 鏈表環檢測</strong></h1><div class=pgc-img><img alt=極客算法訓練筆記(三)，鏈表詳細圖解，別再逃避了朋友 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b4befbbfd5714117b79e51cf53214936><p class=pgc-img-caption></p></div><p>鏈表環檢測</p><p>拿到題感覺是題目意圖都很清晰，沒有那麼多花裡胡哨的，但是真正要動筆還得掉些發，寫這些用了洪荒之力了，下一篇再寫這兩題。</p><p><strong>「鏈表重要練習彙總：」</strong></p><ol start=1><li>單鏈表反轉</li><li>鏈表中環的檢測</li><li>兩個有序的鏈表合併</li><li>刪除鏈表倒數第n個結點</li><li>求鏈表的中間結點</li></ol><p>公眾號《阿甘的碼路》關注我，一起成長～</p><p>參考資料： 數據結構與算法之美 極客算法訓練營視頻</p><p>往期推薦： 極客算法訓練筆記(二)，你所不知道的數組</p><p>極客算法訓練筆記(一)，算法學習方法篇</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>極客</a></li><li><a>訓練</a></li><li><a>筆記</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ff19cd8.html alt=中小學作文訓練之描寫專題（九）場面描寫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/75eab302c96d43e8a680908253f96bcc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ff19cd8.html title=中小學作文訓練之描寫專題（九）場面描寫>中小學作文訓練之描寫專題（九）場面描寫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html alt=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13adbab9c7f94c7fa81d49a98861b051 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html title=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式>機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0926be43.html alt="筋膜放鬆練習 - 按摩滾輪訓練方法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8d39047a8ef48fdbc8ca96ec24e1957 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0926be43.html title="筋膜放鬆練習 - 按摩滾輪訓練方法">筋膜放鬆練習 - 按摩滾輪訓練方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1bc38f3.html alt=HTMLCSS學習筆記（六）——元素類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb5988349894ce9bf568c6418f85b7d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1bc38f3.html title=HTMLCSS學習筆記（六）——元素類型>HTMLCSS學習筆記（六）——元素類型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f977c9c.html alt="讀書筆記｜《Think in Java》Ⅷ 多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/6ee50002bf049682647d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f977c9c.html title="讀書筆記｜《Think in Java》Ⅷ 多態">讀書筆記｜《Think in Java》Ⅷ 多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c489c1e2.html alt="為了買一個馬桶，我做了十幾頁的筆記... 馬桶選購原來水這麼深！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6ebfc0f61b9d44818571c56f832e3c84 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c489c1e2.html title="為了買一個馬桶，我做了十幾頁的筆記... 馬桶選購原來水這麼深！">為了買一個馬桶，我做了十幾頁的筆記... 馬桶選購原來水這麼深！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/112d1b5f.html alt=一造學習筆記—管理篇（2）：工程造價管理的組織和內容 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/9e65b076-038f-4720-96ff-182898f42dee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/112d1b5f.html title=一造學習筆記—管理篇（2）：工程造價管理的組織和內容>一造學習筆記—管理篇（2）：工程造價管理的組織和內容</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b44919b.html alt=《功》《功率》《功的原理》同步筆記，你需要的都在裡面 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a4501e1feed641e5a3365966d82e6ca9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b44919b.html title=《功》《功率》《功的原理》同步筆記，你需要的都在裡面>《功》《功率》《功的原理》同步筆記，你需要的都在裡面</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/401f6ef6.html alt=初中物理力學基礎筆記—功率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7c84079dc684d77a3aa3be18ad1a469 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/401f6ef6.html title=初中物理力學基礎筆記—功率>初中物理力學基礎筆記—功率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d134100.html alt=物理電功率筆記分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d0780b6601c049a692e5506b05f0ae63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d134100.html title=物理電功率筆記分享>物理電功率筆記分享</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a02618e.html alt=某教程學習筆記（一）：17、php漏洞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/6d21bdb33b0a49e8b6eaa2c2a725a1d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a02618e.html title=某教程學習筆記（一）：17、php漏洞>某教程學習筆記（一）：17、php漏洞</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d2ba470.html alt=材料力學筆記：材料與結構疲勞（附贈教材） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d2ba470.html title=材料力學筆記：材料與結構疲勞（附贈教材）>材料力學筆記：材料與結構疲勞（附贈教材）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cae82d75.html alt="優課筆記 | 如何成為一名優秀的項目經理？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/19c06151f3c440d08ec4f2f851a9beef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cae82d75.html title="優課筆記 | 如何成為一名優秀的項目經理？">優課筆記 | 如何成為一名優秀的項目經理？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a9e6452.html alt=李政道《對稱與不對稱》書摘與筆記第四節：標度對稱性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2a21ea9b3c78487583256929fc23334d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a9e6452.html title=李政道《對稱與不對稱》書摘與筆記第四節：標度對稱性>李政道《對稱與不對稱》書摘與筆記第四節：標度對稱性</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>