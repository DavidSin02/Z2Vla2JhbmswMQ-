<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Golang | Go語言多態的實現與interface使用 | 极客快訊</title><meta property="og:title" content="Golang | Go語言多態的實現與interface使用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/393a21fa99c449788584d1941f53a5a6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd14650.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd14650.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd14650.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd14650.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd14650.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd14650.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd14650.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd14650.html><meta property="article:published_time" content="2020-10-29T20:58:49+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:49+08:00"><meta name=Keywords content><meta name=description content="Golang | Go語言多態的實現與interface使用"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/cd14650.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Golang | Go語言多態的實現與interface使用</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>今天是<strong>golang專題</strong>的第11篇文章，我們一起來聊聊golang當中多態的這個話題。</p><p><br></p><p>如果大家系統的學過C++、Java等語言以及面向對象的話，相信應該對<strong>多態</strong>不會陌生。</p><p><br></p><p>多態是<strong>面向對象範疇</strong>當中經常使用並且非常好用的一個功能，如果你之前沒有學過的話也沒有關係，我們用一個簡單的例子來說明一下。多態主要是用在強類型語言當中，像是Python這樣的弱類型語言，變量的類型可以隨意變化，也沒有任何限制，其實區別不是很大。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>多態的含義</strong></h1><p><br></p><p>對於Java或者是C++而言，我們在使用變量的時候，<strong>變量的類型是明確的</strong>。但是如果我們希望它可以寬鬆一點，比如說我們用父類指針或引用去調用方法，但是在執行的時候，能夠<strong>根據子類的類型去執行子類當中的方法</strong>。也就是說實現我們用相同的調用方式調出不同結果或者是功能的情況，這種情況就叫做多態。</p><p><br></p><p>舉個非常經典的例子，比如說貓、狗和人都是哺乳動物。這三個類都有一個say方法，大家都知道貓、狗以及人類的say是不一樣的，貓可能是喵喵叫，狗是汪汪叫，人類則是說話。</p><p><br></p><pre><code>class Mammal {    public void say() {        System.out.println("do nothing")    }}class Cat extends Mammal{ public void say() {  System.out.println("meow"); }}class Dog extends Mammal{ public void say() {  System.out.println("woof"); }}class Human extends Mammal{ public void say() {  System.out.println("speak"); }}</code></pre><p><br></p><p>這段代碼大家應該都不難看懂，這三個類都是Mammal的子類，假設這個時候我們有一系列實例，它們都是Mammal的子類的實例，但是這三種類型都有，我們希望用一個循環來一起全都調用了。雖然我們接收變量的時候是用的Mammal的父類類型去接收的，但是我們調用的時候卻會獲得各個子類的運行結果。</p><p><br></p><p>比如這樣：</p><p><br></p><pre><code>class Main {    public static void main(String[] args) {        List&lt;Mammal&gt; mammals = new ArrayList&lt;&gt;();        mammals.add(new Human());        mammals.add(new Dog());        mammals.add(new Cat());                for (Mammal mammal : mammals) {            mammal.say();        }    }}</code></pre><p><br></p><p>不知道大家有沒有get到精髓，我們創建了一個父類的List，將它各個子類的實例放入了其中。然後通過了一個循環用父類對象來接收，並且調用了say方法。我們希望雖然我們用的是父類的引用來調用的方法，但是它可以自動根據子類的類型調用對應不同子類當中的方法。</p><p><br></p><p>也就是說我們得到的結果應該是：</p><p><br></p><pre><code>speakwoofmeow</code></pre><p><br></p><p>這種功能就是多態，說白了我們可以<strong>在父類當中定義方法，在子類當中創建不同的實現</strong>。但是在調用的時候依然還是用父類的引用去調用，編譯器會自動替我們做好內部的映射和轉化。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>抽象類與接口</strong></h1><p><br></p><p>這樣實現當然是可行的，但其實有一個小小的問題，就是<strong>Mammal類當中的say方法多餘了</strong>。因為我們使用的只會是它的子類，並不會用到Mammal這個父類。所以我們沒必要實現父類Mammal中的say方法，<strong>做一個標記，表示有這麼一個方法</strong>，子類實現的時候需要實現它就可以了。</p><p><br></p><p>這就是抽象類和抽象方法的來源，我們可以把Mammal做成一個抽象類，聲明say是一個抽象方法。抽象類是不能直接創建實例的，只能創建子類的實例，並且抽象方法也不用實現，只需要標記好參數和返回就行了。具體的實現都在子類當中進行。說白了<strong>抽象方法就是一個標記</strong>，告訴編譯器凡是繼承了這個類的子類必須要實現抽象方法，父類當中的方法不能調用。那<strong>抽象類就是含有抽象方法的類</strong>。</p><p><br></p><p>我們寫出Mammal變成抽象類之後的代碼：</p><p><br></p><pre><code>abstract class Mammal {    abstract void say();}</code></pre><p><br></p><p>很簡單，因為我們只需要定義方法的參數就可以了，<strong>不需要實現方法的功能</strong>，方法的功能在子類當中實現。由於我們標記了say這個方法是一個抽象方法，凡是繼承了Mammal的子類都必須要實現這個方法，否則一定會報錯。</p><p><br></p><p>抽象類其實是一個擦邊球，我們可以在抽象類中定義抽象的方法也就是隻聲明不實現，<strong>也可以在抽象類中實現具體的方法</strong>。在抽象類當中非抽象的方法子類的實例是可以直接調用的，和子類調用父類的普通方法一樣。但假如我們不需要父類實現方法，我們提出提取出來的父類中的所有方法都是抽象的呢？針對這一種情況，Java當中還有一個概念叫做接口，也就是interface，<strong>本質上來說interface就是抽象類，只不過是只有抽象方法的抽象類</strong>。</p><p><br></p><p>所以剛才的Mammal也可以寫成：</p><p><br></p><pre><code>interface Mammal {    void say();}</code></pre><p><br></p><p>把Mammal變成了interface之後，子類的實現沒什麼太大的差別，只不過將extends關鍵字換成了implements。另外，子類只能繼承一個抽象類，但是可以實現多個接口。早先的Java版本當中，interface只能夠定義方法和常量，在Java8以後的版本當中，我們也可以在接口當中實現一些默認方法和靜態方法。</p><p><br></p><p>接口的好處是很明顯的，我們可以<strong>用接口的實例來調用所有實現了這個接口的類</strong>。也就是說接口和它的實現是一種要寬泛許多的繼承關係，大大增加了靈活性。</p><p><br></p><p>以上雖然全是Java的內容，但是講的其實是面向對象的內容，如果沒有學過Java的小夥伴可能看起來稍稍有一點點吃力，但總體來說問題不大，沒必要細扣當中的語法細節，get到核心精髓就可以了。</p><p><br></p><p>講這麼一大段的目的是為了釐清面向對象當中的一些概念，以及接口的使用方法和理念，後面才是本文的重頭戲，也就是Go語言當中接口的使用以及理念。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>Golang中的接口</strong></h1><p><br></p><p>Golang當中也有接口，但是它的理念和使用方法和Java稍稍有所不同，它們的使用場景以及實現的目的是類似的，本質上都是為了抽象。通過接口提取出了一些方法，所有繼承了這個接口的類都必然帶有這些方法，那麼我們通過接口獲取這些類的實例就可以使用了，大大增加了靈活性。</p><p><br></p><p>但是Java當中的接口有一個很大的問題就是<strong>侵入性</strong>，說白了就是會顛倒供需關係。舉個簡單的例子，假設你寫了一個爬蟲從各個網頁上爬取內容。爬蟲爬到的內容的類別是很多的，有圖片、有文本還有視頻。假設你想要抽象出一個接口來，在這個接口當中定義你規定的一些提取數據的方法。這樣不論獲取到的數據的格式是什麼，你都可以用這個接口來調用。這本身也是接口的使用場景，但問題是處理圖片、文本以及視頻的<strong>組件可能是開源或者是第三方的</strong>，並不是你開發的。你定義接口並沒有什麼卵用，別人的代碼可不會繼承這個接口。</p><p><br></p><p>當然這也是可以解決的， 比如你可以在這些第三方工具庫外面自己封裝一層，實現你定義的接口。這樣當然是OK的，但是顯然比較麻煩。</p><p><br></p><p>Golang當中的接口解決了這個問題，也就是說它<strong>完全拿掉了原本弱化的繼承關係</strong>，只要接口中定義的方法能對應的上，那麼就可以認為這個類實現了這個接口。</p><p><br></p><p>我們先來創建一個interface，當然也是通過type關鍵字：</p><p><br></p><pre><code>type Mammal interface { Say()}</code></pre><p><br></p><p>我們定義了一個Mammal的接口，當中聲明瞭一個Say函數。也就是說<strong>只要是擁有這個函數的結構體就可以用這個接口來接收</strong>，我們和剛才一樣，定義Cat、Dog和Human三個結構體，分別實現各自的Say方法：</p><p><br></p><pre><code>type Dog struct{}type Cat struct{}type Human struct{}func (d Dog) Say() { fmt.Println("woof")}func (c Cat) Say() { fmt.Println("meow")}func (h Human) Say() { fmt.Println("speak")}</code></pre><p><br></p><p>之後，我們嘗試使用這個接口來接收各種結構體的對象，然後調用它們的Say方法：</p><p><br></p><pre><code>func main() { var m Mammal m = Dog{} m.Say() m = Cat{} m.Say() m = Human{} m.Say()}</code></pre><p><br></p><p>出來的結果當然和我們預想的一樣：</p><p><br></p><div class=pgc-img><img alt="Golang | Go語言多態的實現與interface使用" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/393a21fa99c449788584d1941f53a5a6><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>總結</strong></h1><p><br></p><p>今天我們一起<strong>聊了面向對象中多態以及接口</strong>的概念，藉此進一步瞭解了為什麼golang中的接口設計非常出色，因為它<strong>解耦了接口和實現類之間的聯繫</strong>，使得進一步增加了我們編碼的靈活度，解決了供需關係顛倒的問題。但是世上沒有絕對的好壞，golang中的接口在方便了我們編碼的同時也帶來了一些問題，比如說由於沒了接口和實現類的強綁定，其實也一定程度上增加了開發和維護的成本。</p><p><br></p><p>總體來說這是一個仁者見仁的改動，有些寫慣了Java的同學可能會覺得沒有必要，這是過度解綁，有些人之前深受其害的同學可能覺得這個進步非常關鍵。但不論你怎麼看，這都不影響我們學習它，畢竟<strong>學習本身是不帶立場的</strong>。今天的內容當中包含一些Java和麵向對象的概念，只是用來引出後面golang的內容，如果存在部分不理解的地方，希望大家抓大放小，理解核心關鍵就好了，不需要細扣每一個細節。</p><p><br></p><p>今天的文章到這裡就結束了，如果喜歡本文的話，請來一波<strong>素質三連</strong>，給我一點支持吧（<strong>關注、轉發、點贊</strong>）。</p><p><br></p><p>本文始發於公眾號：<strong>TechFlow</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Golang</a></li><li><a>Go</a></li><li><a>語言多態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/85697d72.html alt="我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/47dfbe87bec844cf988f2e497c78641a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/85697d72.html title="我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的">我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a9b1eec.html alt="Golang 入門 : 理解併發與並行" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cf0d86c0222b4f50ad5ba925231b361e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a9b1eec.html title="Golang 入門 : 理解併發與並行">Golang 入門 : 理解併發與並行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/317308ae.html alt="Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/35e73626e50e4835a1eacdc0f5f74a69 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/317308ae.html title="Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗">Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e187bc3.html alt=Go語言之父帶你重新認識字符串、字節、rune和字符 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/52e46ed353da4c058a36fb1153b3bf17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e187bc3.html title=Go語言之父帶你重新認識字符串、字節、rune和字符>Go語言之父帶你重新認識字符串、字節、rune和字符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e45b3d7b.html alt="Golang 彙編器快速指南" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/91a99ad4-fbdd-4b7f-aeb8-fa4ad47695d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e45b3d7b.html title="Golang 彙編器快速指南">Golang 彙編器快速指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adf558e7.html alt="查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/60bc9160b4bd4c319ed419be29146606 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adf558e7.html title="查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼">查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/288f86f6.html alt=Go語言實現：常見排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3a6d9a4e785e4fa097b0adf18620d616 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/288f86f6.html title=Go語言實現：常見排序算法>Go語言實現：常見排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/73f8e8da.html alt=Go語言學習基礎-生成進程、替換進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0006f0b743b040789141c4474d31a24c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/73f8e8da.html title=Go語言學習基礎-生成進程、替換進程>Go語言學習基礎-生成進程、替換進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cc38087.html alt="Go 如何獲取當前執行文件所在的目錄？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4d316ba5638c47e391011bce4e28f6a8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cc38087.html title="Go 如何獲取當前執行文件所在的目錄？">Go 如何獲取當前執行文件所在的目錄？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/190ae162.html alt="如何在 Go 中寫出高效的單元測試" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ed1aef2573fe45c582af69ef44638521 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/190ae162.html title="如何在 Go 中寫出高效的單元測試">如何在 Go 中寫出高效的單元測試</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2122bafb.html alt="對比著學 Go 語言-基礎：面向對象編程之接口" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2122bafb.html title="對比著學 Go 語言-基礎：面向對象編程之接口">對比著學 Go 語言-基礎：面向對象編程之接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/27147bdc.html alt=沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d906b089a5b448f9cc8c13c1031d4c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/27147bdc.html title=沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要>沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad97b7c4.html alt=Golang還是Python？哪種語言更適合AI？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a43cda7020540a8ae69546866c11792 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad97b7c4.html title=Golang還是Python？哪種語言更適合AI？>Golang還是Python？哪種語言更適合AI？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d6b5eb9f.html alt="詳細介紹 Go 中如何實現 bitset" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/aa4b2de8-ff82-4bfc-a72e-77a49dc17c63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d6b5eb9f.html title="詳細介紹 Go 中如何實現 bitset">詳細介紹 Go 中如何實現 bitset</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af44354f.html alt=使用Go基於WebSocket構建千萬級視頻直播彈幕系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f89b8532845242149b2510d6fe6b0bec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af44354f.html title=使用Go基於WebSocket構建千萬級視頻直播彈幕系統>使用Go基於WebSocket構建千萬級視頻直播彈幕系統</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>