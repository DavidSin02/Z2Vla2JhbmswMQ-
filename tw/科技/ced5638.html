<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SpringBoot｜第二十章：異步開發之異步請求 | 极客快訊</title><meta property="og:title" content="SpringBoot｜第二十章：異步開發之異步請求 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/06812bbf96624d6a94aad8694d5f523e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ced5638.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="SpringBoot｜第二十章：異步開發之異步請求"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ced5638.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SpringBoot｜第二十章：異步開發之異步請求</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>前言</p><blockquote><p><em>關於web開發的相關知識點，後續有補充時再開續寫了。比如webService服務、發郵件等，這些一般上覺得不完全屬於web開發方面的，而且目前webService作為一個接口來提供服務的機會應該比較小了吧。所以本章節開始，開始講解關於異步開發過程中會使用到的一些知識點。本章節就來講解下異步請求相關知識點。</em></p></blockquote><p>一點知識</p><p>何為異步請求</p><p>在Servlet 3.0之前，Servlet採用Thread-Per-Request的方式處理請求，即每一次Http請求都由某一個線程從頭到尾負責處理。如果一個請求需要進行IO操作，比如訪問數據庫、調用第三方服務接口等，那麼其所對應的線程將<strong>同步地等待<em>**</em></strong>IO操作完成， 而IO操作是<strong>非常慢</strong>的，所以此時的線程並不能及時地釋放回線程池以供後續使用，在併發量越來越大的情況下，這將帶來嚴重的性能問題。其請求流程大致為：</p><div class=pgc-img><img alt=SpringBoot｜第二十章：異步開發之異步請求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/06812bbf96624d6a94aad8694d5f523e><p class=pgc-img-caption></p></div><p>而在Servlet3.0發佈後，提供了一個新特性：<strong>異步處理請求</strong>。可以<strong>先釋放</strong>容器分配給請求的線程與相關資源，減輕系統負擔，釋放了容器所分配線程的請求，其<strong>響應將被延後</strong>，可以在耗時處理完成（例如長時間的運算）時再對客戶端進行響應。其請求流程為：</p><div class=pgc-img><img alt=SpringBoot｜第二十章：異步開發之異步請求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e8151d8ab8e54bb192e6a7e9e3c021b4><p class=pgc-img-caption></p></div><p>在Servlet 3.0後，我們可以從HttpServletRequest對象中獲得一個<strong>AsyncContext</strong>對象，該對象構成了異步處理的上下文，Request和Response對象都可從中獲取。AsyncContext可以從當前線程傳給另外的線程，並在新的線程中完成對請求的處理並返回結果給客戶端，初始線程便可以還回給容器線程池以處理更多的請求。如此，通過將請求從一個線程傳給另一個線程處理的過程便構成了Servlet 3.0中的異步處理。</p><hr><p><strong>多說幾句：</strong></p><p>隨著Spring5發佈，提供了一個響應式Web框架：Spring WebFlux。之後可能就不需要Servlet容器的支持了。以下是其先後對比圖：</p><div class=pgc-img><img alt=SpringBoot｜第二十章：異步開發之異步請求 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0ad197fa49a84a0cab3c4fbe2110d30b><p class=pgc-img-caption></p></div><p>左側是傳統的基於Servlet的Spring Web MVC框架，右側是5.0版本新引入的基於Reactive Streams的Spring WebFlux框架，從上到下依次是<strong>Router Functions</strong>，<strong>WebFlux</strong>，<strong>Reactive Streams</strong>三個新組件。</p><p>對於其發展前景還是拭目以待吧。有時間也該去了解下Spring5了。</p><hr><p>原生異步請求API說明</p><p>在編寫實際代碼之前，我們來了解下一些關於異步請求的api的調用說明。</p><ul><li>獲取AsyncContext：根據HttpServletRequest對象獲取。</li></ul><p class=ql-align-right>AsyncContext asyncContext = request.startAsync();</p><ul><li>設置監聽器:可設置其開始、完成、異常、超時等事件的回調處理</li></ul><p>其監聽器的接口代碼：</p><p><strong>public</strong> <strong>interface</strong> AsyncListener <strong>extends</strong> EventListener {</p><p><strong>void</strong> onComplete(AsyncEvent event) <strong>throws</strong> IOException;</p><p><strong>void</strong> onTimeout(AsyncEvent event) <strong>throws</strong> IOException;</p><p><strong>void</strong> onError(AsyncEvent event) <strong>throws</strong> IOException;</p><p><strong>void</strong> onStartAsync(AsyncEvent event) <strong>throws</strong> IOException;</p><p>}</p><p><strong>說明：</strong></p><ol><li>onStartAsync：異步線程開始時調用</li><li>onError：異步線程出錯時調用</li><li>onTimeout：異步線程執行超時調用</li><li>onComplete：異步執行完畢時調用</li></ol><p>一般上，我們在超時或者異常時，會返回給前端相應的提示，比如說超時了，請再次請求等等，根據各業務進行自定義返回。同時，在異步調用完成時，一般需要執行一些清理工作或者其他相關操作。</p><p>需要注意的是只有在調用request.startAsync前將監聽器添加到AsyncContext，監聽器的onStartAsync方法才會起作用，而調用startAsync前AsyncContext還不存在，所以第一次調用startAsync是不會被監聽器中的onStartAsync方法捕獲的，只有在超時後又重新開始的情況下onStartAsync方法才會起作用。</p><ul><li>設置超時：通過setTimeout方法設置，單位：毫秒。</li></ul><p><strong>一定要設置超時時間</strong>，不能無限等待下去，不然和正常的請求就一樣了。。</p><p>Servlet方式實現異步請求</p><p>前面已經提到，可通過HttpServletRequest對象中獲得一個<strong>AsyncContext</strong>對象，該對象構成了異步處理的上下文。所以，我們來實際操作下。</p><p>0.編寫一個簡單控制層</p><p>/**</p><p>* 使用servlet方式進行異步請求</p><p>* @author oKong</p><p>*</p><p>*/</p><p>@Slf4j</p><p>@RestController</p><p><strong>public</strong> <strong>class</strong> ServletController {</p><p>@RequestMapping("/servlet/orig")</p><p><strong>public</strong> <strong>void</strong> todo(HttpServletRequest request,</p><p>HttpServletResponse response) <strong>throws</strong> Exception {</p><p>//這裡來個休眠</p><p>Thread.sleep(100);</p><p>response.getWriter().println("這是【正常】的請求返回");</p><p>}</p><p>@RequestMapping("/servlet/async")</p><p><strong>public</strong> <strong>void</strong> todoAsync(HttpServletRequest request,</p><p>HttpServletResponse response) {</p><p>AsyncContext asyncContext = request.startAsync();</p><p>asyncContext.addListener(<strong>new</strong> AsyncListener() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onTimeout(AsyncEvent event) <strong>throws</strong> IOException {</p><p>log.info("超時了：");</p><p>//做一些超時後的相關操作</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onStartAsync(AsyncEvent event) <strong>throws</strong> IOException {</p><p>// TODO Auto-generated method stub</p><p>log.info("線程開始");</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onError(AsyncEvent event) <strong>throws</strong> IOException {</p><p>log.info("發生錯誤：",event.getThrowable());</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onComplete(AsyncEvent event) <strong>throws</strong> IOException {</p><p>log.info("執行完成");</p><p>//這裡可以做一些清理資源的操作</p><p>}</p><p>});</p><p>//設置超時時間</p><p>asyncContext.setTimeout(200);</p><p>//也可以不使用start 進行異步調用</p><p>// new Thread(new Runnable() {</p><p>//</p><p>// @Override</p><p>// public void run() {</p><p>// 編寫業務邏輯</p><p>//</p><p>// }</p><p>// }).start();</p><p>asyncContext.start(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p><strong>try</strong> {</p><p>Thread.sleep(100);</p><p>log.info("內部線程：" + Thread.currentThread().getName());</p><p>asyncContext.getResponse().setCharacterEncoding("utf-8");</p><p>asyncContext.getResponse().setContentType("text/html;charset=UTF-8");</p><p>asyncContext.getResponse().getWriter().println("這是【異步】的請求返回");</p><p>} <strong>catch</strong> (Exception e) {</p><p>log.error("異常：",e);</p><p>}</p><p>//異步請求完成通知</p><p>//此時整個請求才完成</p><p>//其實可以利用此特性 進行多條消息的推送 把連接掛起。。</p><p>asyncContext.complete();</p><p>}</p><p>});</p><p>//此時之類 request的線程連接已經釋放了</p><p>log.info("線程：" + Thread.currentThread().getName());</p><p>}</p><p>}</p><p><strong>注意：異步請求時，可以利用ThreadPoolExecutor自定義個線程池。</strong></p><p>1.啟動下應用，查看控制檯輸出就可以獲悉是否在同一個線程裡面了。同時，可設置下等待時間，之後就會調用超時回調方法了。大家可自己試試。</p><p>2018-08-15 23:03:04.082 INFO 6732 --- [nio-8080-exec-1] c.l.l.s.controller.ServletController : 線程：http-nio-8080-exec-1</p><p>2018-08-15 23:03:04.183 INFO 6732 --- [nio-8080-exec-2] c.l.l.s.controller.ServletController : 內部線程：http-nio-8080-exec-2</p><p>2018-08-15 23:03:04.190 INFO 6732 --- [nio-8080-exec-3] c.l.l.s.controller.ServletController : 執行完成</p><p><strong>使用過濾器時，需要加入asyncSupported為true配置，開啟異步請求支持。</strong></p><p class=ql-align-right>1</p><p class=ql-align-right>2</p><p>@WebServlet(urlPatterns = "/okong", asyncSupported = <strong>true</strong> )</p><p><strong>public</strong> <strong>class</strong> AsyncServlet <strong>extends</strong> HttpServlet ...</p><p><strong>題外話：</strong>其實我們可以利用在未執行asyncContext.complete()方法時請求未結束這特性，可以做個簡單的文件上傳進度條之類的功能。但注意請求是會超時的，需要設置超時的時間下。</p><p>Spring方式實現異步請求</p><blockquote><p><em>在Spring中，有多種方式實現異步請求，比如callable、DeferredResult或者WebAsyncTask。每個的用法略有不同，可根據不同的業務場景選擇不同的方式。以下主要介紹一些常用的用法</em></p></blockquote><p>Callable</p><blockquote><p><em>使用很簡單，直接返回的參數包裹一層callable即可。</em></p></blockquote><p>用法</p><p>@RequestMapping("/callable")</p><p><strong>public</strong> Callable&lt;String> callable() {</p><p>log.info("外部線程：" + Thread.currentThread().getName());</p><p><strong>return</strong> <strong>new</strong> Callable&lt;String>() {</p><p>@Override</p><p><strong>public</strong> String call() <strong>throws</strong> Exception {</p><p>log.info("內部線程：" + Thread.currentThread().getName());</p><p><strong>return</strong> "callable!";</p><p>}</p><p>};</p><p>}</p><p>控制檯輸出：</p><p>2018-08-15 23:32:22.317 INFO 15740 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : 外部線程：http-nio-8080-exec-2</p><p>2018-08-15 23:32:22.323 INFO 15740 --- [ MvcAsync1] c.l.l.s.controller.SpringController : 內部線程：MvcAsync1</p><p>超時、自定義線程設置</p><p>從控制檯可以看見，異步響應的線程使用的是名為：MvcAsync1的線程。第一次再訪問時，就是MvcAsync2了。若採用默認設置，會無限的創建新線程去處理異步請求，所以正常都需要配置一個線程池及超時時間。</p><p>編寫一個配置類：CustomAsyncPool.java</p><p class=ql-align-right><br></p><p>@Configuration</p><p><strong>public</strong> <strong>class</strong> CustomAsyncPool <strong>extends</strong> WebMvcConfigurerAdapter{</p><p>/**</p><p>* 配置線程池</p><p>* @return</p><p>*/</p><p>@Bean(name = "asyncPoolTaskExecutor")</p><p><strong>public</strong> ThreadPoolTaskExecutor getAsyncThreadPoolTaskExecutor() {</p><p>ThreadPoolTaskExecutor taskExecutor = <strong>new</strong> ThreadPoolTaskExecutor();</p><p>taskExecutor.setCorePoolSize(20);</p><p>taskExecutor.setMaxPoolSize(200);</p><p>taskExecutor.setQueueCapacity(25);</p><p>taskExecutor.setKeepAliveSeconds(200);</p><p>taskExecutor.setThreadNamePrefix("callable-");</p><p>// 線程池對拒絕任務（無線程可用）的處理策略，目前只支持AbortPolicy、CallerRunsPolicy；默認為後者</p><p>taskExecutor.setRejectedExecutionHandler(<strong>new</strong> ThreadPoolExecutor.CallerRunsPolicy());</p><p>taskExecutor.initialize();</p><p><strong>return</strong> taskExecutor;</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> configureAsyncSupport(<strong>final</strong> AsyncSupportConfigurer configurer) {</p><p>//處理 callable超時</p><p>configurer.setDefaultTimeout(60*1000);</p><p>configurer.registerCallableInterceptors(timeoutInterceptor());</p><p>configurer.setTaskExecutor(getAsyncThreadPoolTaskExecutor());</p><p>}</p><p>@Bean</p><p><strong>public</strong> TimeoutCallableProcessor timeoutInterceptor() {</p><p><strong>return</strong> <strong>new</strong> TimeoutCallableProcessor();</p><p>}</p><p>}</p><p>自定義一個超時異常處理類：CustomAsyncRequestTimeoutException.java</p><p>/**</p><p>* 自定義超時異常類</p><p>* @author oKong</p><p>*</p><p>*/</p><p><strong>public</strong> <strong>class</strong> CustomAsyncRequestTimeoutException <strong>extends</strong> RuntimeException {</p><p>/**</p><p>*</p><p>*/</p><p><strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 8754629185999484614L;</p><p><strong>public</strong> CustomAsyncRequestTimeoutException(String uri){</p><p><strong>super</strong>(uri);</p><p>}</p><p>}</p><p>同時，在<strong>統一異常</strong>處理加入對CustomAsyncRequestTimeoutException類的處理即可，這樣就有個統一的配置了。</p><p>之後，再運行就可以看見使用了自定義的線程池了，超時的可以自行模擬下：</p><p>2018-08-15 23:48:29.022 INFO 16060 --- [nio-8080-exec-1] c.l.l.s.controller.SpringController : 外部線程：http-nio-8080-exec-1</p><p>2018-08-15 23:48:29.032 INFO 16060 --- [ oKong-1] c.l.l.s.controller.SpringController : 內部線程：oKong-1</p><p>DeferredResult</p><p>相比於callable，DeferredResult可以處理一些相對複雜一些的業務邏輯，最主要還是可以在另一個線程裡面進行業務處理及返回，即可在兩個完全不相干的線程間的通信。</p><p>/**</p><p>* 線程池</p><p>*/</p><p><strong>public</strong> <strong>static</strong> ExecutorService FIXED_THREAD_POOL = Executors.newFixedThreadPool(30);</p><p>@RequestMapping("/deferredresult")</p><p><strong>public</strong> DeferredResult&lt;String> deferredResult(){</p><p>log.info("外部線程：" + Thread.currentThread().getName());</p><p>//設置超時時間</p><p>DeferredResult&lt;String> result = <strong>new</strong> DeferredResult&lt;String>(60*1000L);</p><p>//處理超時事件 採用委託機制</p><p>result.onTimeout(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>log.error("DeferredResult超時");</p><p>result.setResult("超時了!");</p><p>}</p><p>});</p><p>result.onCompletion(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>//完成後</p><p>log.info("調用完成");</p><p>}</p><p>});</p><p>FIXED_THREAD_POOL.execute(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>//處理業務邏輯</p><p>log.info("內部線程：" + Thread.currentThread().getName());</p><p>//返回結果</p><p>result.setResult("DeferredResult!!");</p><p>}</p><p>});</p><p><strong>return</strong> result;</p><p>}</p><p>控制檯輸出：</p><p>2018-08-15 23:52:27.841 INFO 12984 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : 外部線程：http-nio-8080-exec-2</p><p>2018-08-15 23:52:27.843 INFO 12984 --- [pool-1-thread-1] c.l.l.s.controller.SpringController : 內部線程：pool-1-thread-1</p><p>2018-08-15 23:52:27.872 INFO 12984 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : 調用完成</p><p><strong>注意：返回結果時記得調用下setResult方法。</strong></p><p><strong>題外話：利用DeferredResult可實現一些長連接的功能，比如當某個操作是異步時，我們可以保存這個DeferredResult對象，當異步通知回來時，我們在找回這個DeferredResult對象，之後在setResult會結果即可。提高性能。</strong></p><p>WebAsyncTask</p><p>使用方法都類似，只是WebAsyncTask是直接返回了。覺得就是寫法不同而已，更多細節希望大神解答！</p><p>@RequestMapping("/webAsyncTask")</p><p><strong>public</strong> WebAsyncTask&lt;String> webAsyncTask() {</p><p>log.info("外部線程：" + Thread.currentThread().getName());</p><p>WebAsyncTask&lt;String> result = <strong>new</strong> WebAsyncTask&lt;String>(60*1000L, <strong>new</strong> Callable&lt;String>() {</p><p>@Override</p><p><strong>public</strong> String call() <strong>throws</strong> Exception {</p><p>log.info("內部線程：" + Thread.currentThread().getName());</p><p><strong>return</strong> "WebAsyncTask!!!";</p><p>}</p><p>});</p><p>result.onTimeout(<strong>new</strong> Callable&lt;String>() {</p><p>@Override</p><p><strong>public</strong> String call() <strong>throws</strong> Exception {</p><p>// TODO Auto-generated method stub</p><p><strong>return</strong> "WebAsyncTask超時!!!";</p><p>}</p><p>});</p><p>result.onCompletion(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>//超時後 也會執行此方法</p><p>log.info("WebAsyncTask執行結束");</p><p>}</p><p>});</p><p><strong>return</strong> result;</p><p>}</p><p>控制檯輸出：</p><p>2018-08-15 23:55:02.568 INFO 2864 --- [nio-8080-exec-1] c.l.l.s.controller.SpringController : 外部線程：http-nio-8080-exec-1</p><p>2018-08-15 23:55:02.587 INFO 2864 --- [ oKong-1] c.l.l.s.controller.SpringController : 內部線程：oKong-1</p><p>2018-08-15 23:55:02.615 INFO 2864 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : WebAsyncTask執行結束</p><p>參考資料</p><ol><li>https://blog.csdn.net/paincupid/article/details/52266905</li><li>https://docs.spring.io/spring/docs/4.3.18.RELEASE/spring-framework-reference/htmlsingle/#mvc-ann-async</li></ol><p>總結</p><blockquote><p><em>本章節主要是講解了異步請求的使用及相關配置，如超時，異常等處理。設置異步請求時，記得不要忘記設置超時時間。</em><strong><em>異步請求只是提高了服務的吞吐量，提高單位時間內處理的請求數，並不會加快處理效率的，這點需要注意。</em></strong><em>。下一章節，講講使用@Async進行異步調用相關知識。</em></p></blockquote><p>最後</p><blockquote><p><em>目前互聯網上很多大佬都有SpringBoot系列教程，如有雷同，請多多包涵了。若文中有所錯誤之處，還望提出，謝謝。</em></p></blockquote><div class=pgc-img><img alt=SpringBoot｜第二十章：異步開發之異步請求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a8cdeaee49e4ff48025779c5de9a619><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>異步</a></li><li><a>SpringBoot</a></li><li><a>開發</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb3dea9.html alt=SpringBoot中異步請求和異步調用（看這一篇就夠了） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f7f2ca86c513422bb316aacfbb8b29e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb3dea9.html title=SpringBoot中異步請求和異步調用（看這一篇就夠了）>SpringBoot中異步請求和異步調用（看這一篇就夠了）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a980c6f3.html alt=教你從頭學前端開發——第一個網頁（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c44113d83f24f5db93c8353aff0c670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a980c6f3.html title=教你從頭學前端開發——第一個網頁（一）>教你從頭學前端開發——第一個網頁（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1f5a66a.html alt=網頁開發網頁的相關概念你知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8ca7902bdcb14bc5a25a88be4953edd6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1f5a66a.html title=網頁開發網頁的相關概念你知道嗎？>網頁開發網頁的相關概念你知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html alt=SpringBoot事務詳細簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html title=SpringBoot事務詳細簡介>SpringBoot事務詳細簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html alt="軟件開發中數據庫必備基礎01 - 圖解事務基礎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4e00ac778db451792b955bde23add02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html title="軟件開發中數據庫必備基礎01 - 圖解事務基礎">軟件開發中數據庫必備基礎01 - 圖解事務基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html alt=python安全開發軍規之四：使用安全的隨機數生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bbda123b84db44148aca9d3e26ddf119 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html title=python安全開發軍規之四：使用安全的隨機數生成器>python安全開發軍規之四：使用安全的隨機數生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8dd83b90.html alt=常用最全正則表達式整理(開發必備) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5127ac984657471b853b307afe52b2fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8dd83b90.html title=常用最全正則表達式整理(開發必備)>常用最全正則表達式整理(開發必備)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html alt=給JAVA開發人員的正則表達式入門課 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html title=給JAVA開發人員的正則表達式入門課>給JAVA開發人員的正則表達式入門課</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a278a157.html alt=中國尚未被開發的海島，遊客甚少景色美爆，距江浙滬超近 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6150f65415b047acad00ca52441a93ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a278a157.html title=中國尚未被開發的海島，遊客甚少景色美爆，距江浙滬超近>中國尚未被開發的海島，遊客甚少景色美爆，距江浙滬超近</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html alt=測試開發專題：spring-boot統一異常捕獲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/135918e30e2f4a2ea248b539eb383688 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html title=測試開發專題：spring-boot統一異常捕獲>測試開發專題：spring-boot統一異常捕獲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html alt=三相異步電動機絕緣處理的目的及方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c439a15bdf64f1f975914c96a2c66e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html title=三相異步電動機絕緣處理的目的及方法>三相異步電動機絕緣處理的目的及方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html alt=異步電機典型結構簡述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349080656472f5dd62512 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html title=異步電機典型結構簡述>異步電機典型結構簡述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html alt=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/56930005e593537411b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html title=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹>繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html alt=單相異步電機如何轉起來？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/66c6000099c8d7f13f98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html title=單相異步電機如何轉起來？>單相異步電機如何轉起來？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>