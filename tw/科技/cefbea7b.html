<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「Java面試題精華集」1w字的Java集合框架篇（2020最新版） | 极客快訊</title><meta property="og:title" content="「Java面試題精華集」1w字的Java集合框架篇（2020最新版） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/aa8f670cc244471e91fa0a25af703002"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cefbea7b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cefbea7b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cefbea7b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cefbea7b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cefbea7b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cefbea7b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cefbea7b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cefbea7b.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="「Java面試題精華集」1w字的Java集合框架篇（2020最新版）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/cefbea7b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「Java面試題精華集」1w字的Java集合框架篇（2020最新版）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><h1 class=pgc-h-arrow-right>1. 剖析面試最常見問題之 Java 集合框架</h1><h2 class=pgc-h-arrow-right>1.1. 集合概述</h2><h3 class=pgc-h-arrow-right>1.1.1. Java 集合概覽</h3><p>從下圖可以看出，在 Java 中除了以 Map 結尾的類之外， 其他類都實現了 Collection 接口。</p><p>並且，以 Map 結尾的類都實現了 Map 接口。</p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aa8f670cc244471e91fa0a25af703002><p class=pgc-img-caption></p></div><p>image</p><h3 class=pgc-h-arrow-right>1.1.2. 說說 List,Set,Map 三者的區別？</h3><ul><li>List(對付順序的好幫手)： 存儲的元素是有序的、可重複的。</li><li>Set(注重獨一無二的性質): 存儲的元素是無序的、不可重複的。</li><li>Map(用 Key 來搜索的專家): 使用鍵值對（kye-value）存儲，類似於數學上的函數 y=f(x)，“x”代表 key，"y"代表 value，Key 是無序的、不可重複的，value 是無序的、可重複的，每個鍵最多映射到一個值。</li></ul><h3 class=pgc-h-arrow-right>1.1.3. 集合框架底層數據結構總結</h3><p>先來看一下 Collection 接口下面的集合。</p><h4 class=pgc-h-arrow-right>1.1.3.1. List</h4><ul><li>Arraylist： Object[]數組</li><li>Vector：Object[]數組</li><li>LinkedList： 雙向鏈表(JDK1.6 之前為循環鏈表，JDK1.7 取消了循環)</li></ul><h4 class=pgc-h-arrow-right>1.1.3.2. Set</h4><ul><li>HashSet（無序，唯一）: 基於 HashMap 實現的，底層採用 HashMap 來保存元素</li><li>LinkedHashSet：LinkedHashSet 是 HashSet 的子類，並且其內部是通過 LinkedHashMap 來實現的。有點類似於我們之前說的 LinkedHashMap 其內部是基於 HashMap 實現一樣，不過還是有一點點區別的</li><li>TreeSet（有序，唯一）： 紅黑樹(自平衡的排序二叉樹)</li></ul><p>再來看看 Map 接口下面的集合。</p><h4 class=pgc-h-arrow-right>1.1.3.3. Map</h4><ul><li>HashMap： JDK1.8 之前 HashMap 由數組+鏈表組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的（“拉鍊法”解決衝突）。JDK1.8 以後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為 8）（將鏈表轉換成紅黑樹前會判斷，如果當前數組的長度小於 64，那麼會選擇先進行數組擴容，而不是轉換為紅黑樹）時，將鏈表轉化為紅黑樹，以減少搜索時間</li><li>LinkedHashMap： LinkedHashMap 繼承自 HashMap，所以它的底層仍然是基於拉鍊式散列結構即由數組和鏈表或紅黑樹組成。另外，LinkedHashMap 在上面結構的基礎上，增加了一條雙向鏈表，使得上面的結構可以保持鍵值對的插入順序。同時通過對鏈表進行相應的操作，實現了訪問順序相關邏輯。詳細可以查看：<strong>《LinkedHashMap 源碼詳細分析（JDK1.8）》</strong></li><li>Hashtable： 數組+鏈表組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的</li><li>TreeMap： 紅黑樹（自平衡的排序二叉樹）</li></ul><h3 class=pgc-h-arrow-right>1.1.4. 如何選用集合?</h3><p>主要根據集合的特點來選用，比如我們需要根據鍵值獲取到元素值時就選用 Map 接口下的集合，需要排序時選擇 TreeMap,不需要排序時就選擇 HashMap,需要保證線程安全就選用 ConcurrentHashMap。</p><p>當我們只需要存放元素值時，就選擇實現Collection 接口的集合，需要保證元素唯一時選擇實現 Set 接口的集合比如 TreeSet 或 HashSet，不需要就選擇實現 List 接口的比如 ArrayList 或 LinkedList，然後再根據實現這些接口的集合的特點來選用。</p><h3 class=pgc-h-arrow-right>1.1.5. 為什麼要使用集合？</h3><p>當我們需要保存一組類型相同的數據的時候，我們應該是用一個容器來保存，這個容器就是數組，但是，使用數組存儲對象具有一定的弊端， 因為我們在實際開發中，存儲的數據的類型是多種多樣的，於是，就出現了“集合”，集合同樣也是用來存儲多個數據的。</p><p>數組的缺點是一旦聲明之後，長度就不可變了；同時，聲明數組時的數據類型也決定了該數組存儲的數據的類型；而且，數組存儲的數據是有序的、可重複的，特點單一。 但是集合提高了數據存儲的靈活性，Java 集合不僅可以用來存儲不同類型不同數量的對象，還可以保存具有映射關係的數據</p><h3 class=pgc-h-arrow-right>1.1.6. Iterator 迭代器</h3><h4 class=pgc-h-arrow-right>1.1.6.1. 迭代器 Iterator 是什麼？</h4><pre><code>public interface Iterator&lt;E&gt; {    //集合中是否還有元素    boolean hasNext();    //獲得集合中的下一個元素    E next();    ......}</code></pre><p>Iterator 對象稱為迭代器（設計模式的一種），迭代器可以對集合進行遍歷，但每一個集合內部的數據結構可能是不盡相同的，所以每一個集合存和取都很可能是不一樣的，雖然我們可以人為地在每一個類中定義 hasNext() 和 next() 方法，但這樣做會讓整個集合體系過於臃腫。於是就有了迭代器。</p><p>迭代器是將這樣的方法抽取出接口，然後在每個類的內部，定義自己迭代方式，這樣做就規定了整個集合體系的遍歷方式都是 hasNext()和next()方法，使用者不用管怎麼實現的，會用即可。迭代器的定義為：提供一種方法訪問一個容器對象中各個元素，而又不需要暴露該對象的內部細節。</p><h4 class=pgc-h-arrow-right>1.1.6.2. 迭代器 Iterator 有啥用？</h4><p>Iterator 主要是用來遍歷集合用的，它的特點是更加安全，因為它可以確保，在當前遍歷的集合元素被更改的時候，就會拋出 ConcurrentModificationException 異常。</p><h4 class=pgc-h-arrow-right>1.1.6.3. 如何使用？</h4><p>我們通過使用迭代器來遍歷 HashMap，演示一下 迭代器 Iterator 的使用。</p><pre><code>Map&lt;Integer, String&gt; map = new HashMap();map.put(1, "Java");map.put(2, "C++");map.put(3, "PHP");Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) {  Map.Entry&lt;Integer, String&gt; entry = iterator.next();  System.out.println(entry.getKey() + entry.getValue());}</code></pre><h3 class=pgc-h-arrow-right>1.1.7. 有哪些集合是線程不安全的？怎麼解決呢？</h3><p>我們常用的 Arraylist ,LinkedList,Hashmap,HashSet,TreeSet,TreeMap，PriorityQueue 都不是線程安全的。解決辦法很簡單，可以使用線程安全的集合來代替。</p><p>如果你要使用線程安全的集合的話， java.util.concurrent 包中提供了很多併發容器供你使用：</p><ol start=1><li>ConcurrentHashMap: 可以看作是線程安全的 HashMap</li><li>CopyOnWriteArrayList:可以看作是線程安全的 ArrayList，在讀多寫少的場合性能非常好，遠遠好於 Vector.</li><li>ConcurrentLinkedQueue:高效的併發隊列，使用鏈表實現。可以看做一個線程安全的 LinkedList，這是一個非阻塞隊列。</li><li>BlockingQueue: 這是一個接口，JDK 內部通過鏈表、數組等方式實現了這個接口。表示阻塞隊列，非常適合用於作為數據共享的通道。</li><li>ConcurrentSkipListMap :跳錶的實現。這是一個Map，使用跳錶的數據結構進行快速查找。</li></ol><h2 class=pgc-h-arrow-right>1.2. Collection 子接口之 List</h2><h3 class=pgc-h-arrow-right>1.2.1. Arraylist 和 Vector 的區別?</h3><ol start=1><li>ArrayList 是 List 的主要實現類，底層使用 Object[ ]存儲，適用於頻繁的查找工作，線程不安全 ；</li><li>Vector 是 List 的古老實現類，底層使用 Object[ ]存儲，線程安全的。</li></ol><h3 class=pgc-h-arrow-right>1.2.2. Arraylist 與 LinkedList 區別?</h3><ol start=1><li><strong>是否保證線程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保證線程安全；</li><li><strong>底層數據結構：</strong> Arraylist 底層使用的是 <strong>Object 數組</strong>；LinkedList 底層使用的是 <strong>雙向鏈表</strong> 數據結構（JDK1.6 之前為循環鏈表，JDK1.7 取消了循環。注意雙向鏈表和雙向循環鏈表的區別，下面有介紹到！）</li><li><strong>插入和刪除是否受元素位置的影響：</strong> ① <strong>ArrayList 採用數組存儲，所以插入和刪除元素的時間複雜度受元素位置的影響。</strong> 比如：執行add(E e)方法的時候， ArrayList 會默認在將指定的元素追加到此列表的末尾，這種情況時間複雜度就是 O(1)。但是如果要在指定位置 i 插入和刪除元素的話（add(int index, E element)）時間複雜度就為 O(n-i)。因為在進行上述操作的時候集合中第 i 和第 i 個元素之後的(n-i)個元素都要執行向後位/向前移一位的操作。 ② <strong>LinkedList 採用鏈表存儲，所以對於add(E e)方法的插入，刪除元素時間複雜度不受元素位置的影響，近似 O(1)，如果是要在指定位置i插入和刪除元素的話（(add(int index, E element)） 時間複雜度近似為o(n))因為需要先移動到指定位置再插入。</strong></li><li><strong>是否支持快速隨機訪問：</strong> LinkedList 不支持高效的隨機元素訪問，而 ArrayList 支持。快速隨機訪問就是通過元素的序號快速獲取元素對象(對應於get(int index)方法)。</li><li><strong>內存空間佔用：</strong> ArrayList 的空 間浪費主要體現在在 list 列表的結尾會預留一定的容量空間，而 LinkedList 的空間花費則體現在它的每一個元素都需要消耗比 ArrayList 更多的空間（因為要存放直接後繼和直接前驅以及數據）。</li></ol><h4 class=pgc-h-arrow-right>1.2.2.1. 補充內容:雙向鏈表和雙向循環鏈表</h4><p><strong>雙向鏈表：</strong> 包含兩個指針，一個 prev 指向前一個節點，一個 next 指向後一個節點。</p><blockquote><p>“</p><p>另外推薦一篇把雙向鏈表講清楚的文章：<strong>https://juejin.im/post/5b5d1a9af265da0f47352f14</strong></p></blockquote><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e59dbc5ac2534313a232de89033e569f><p class=pgc-img-caption></p></div><p>雙向鏈表</p><p><strong>雙向循環鏈表：</strong> 最後一個節點的 next 指向 head，而 head 的 prev 指向最後一個節點，構成一個環。</p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/beaa9a74f010485e81c77b6b0d41ee9a><p class=pgc-img-caption></p></div><p>雙向循環鏈表</p><h4 class=pgc-h-arrow-right>1.2.2.2. 補充內容:RandomAccess 接口</h4><pre><code>public interface RandomAccess {}</code></pre><p>查看源碼我們發現實際上 RandomAccess 接口中什麼都沒有定義。所以，在我看來 RandomAccess 接口不過是一個標識罷了。標識什麼？ 標識實現這個接口的類具有隨機訪問功能。</p><p>在 binarySearch（) 方法中，它要判斷傳入的 list 是否 RamdomAccess 的實例，如果是，調用indexedBinarySearch()方法，如果不是，那麼調用iteratorBinarySearch()方法</p><pre><code>    public static &lt;T&gt;    int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)            return Collections.indexedBinarySearch(list, key);        else            return Collections.iteratorBinarySearch(list, key);    }</code></pre><p>ArrayList 實現了 RandomAccess 接口， 而 LinkedList 沒有實現。為什麼呢？我覺得還是和底層數據結構有關！ArrayList 底層是數組，而 LinkedList 底層是鏈表。數組天然支持隨機訪問，時間複雜度為 O(1)，所以稱為快速隨機訪問。鏈表需要遍歷到特定位置才能訪問特定位置的元素，時間複雜度為 O(n)，所以不支持快速隨機訪問。，ArrayList 實現了 RandomAccess 接口，就表明了他具有快速隨機訪問功能。 RandomAccess 接口只是標識，並不是說 ArrayList 實現 RandomAccess 接口才具有快速隨機訪問功能的！</p><h3 class=pgc-h-arrow-right>1.2.3. 說一說 ArrayList 的擴容機制吧</h3><p>詳見筆主的這篇文章:<strong>通過源碼一步一步分析 ArrayList 擴容機制</strong></p><h2 class=pgc-h-arrow-right>1.3. Collection 子接口之 Set</h2><h3 class=pgc-h-arrow-right>1.3.1. comparable 和 Comparator 的區別</h3><ul><li>comparable 接口實際上是出自java.lang包 它有一個 compareTo(Object obj)方法用來排序</li><li>comparator接口實際上是出自 java.util 包它有一個compare(Object obj1, Object obj2)方法用來排序</li></ul><p>一般我們需要對一個集合使用自定義排序時，我們就要重寫compareTo()方法或compare()方法，當我們需要對某一個集合實現兩種排序方式，比如一個 song 對象中的歌名和歌手名分別採用一種排序方法的話，我們可以重寫compareTo()方法和使用自制的Comparator方法或者以兩個 Comparator 來實現歌名排序和歌星名排序，第二種代表我們只能使用兩個參數版的 Collections.sort().</p><h4 class=pgc-h-arrow-right>1.3.1.1. Comparator 定製排序</h4><pre><code>        ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();        arrayList.add(-1);        arrayList.add(3);        arrayList.add(3);        arrayList.add(-5);        arrayList.add(7);        arrayList.add(4);        arrayList.add(-9);        arrayList.add(-7);        System.out.println("原始數組:");        System.out.println(arrayList);        // void reverse(List list)：反轉        Collections.reverse(arrayList);        System.out.println("Collections.reverse(arrayList):");        System.out.println(arrayList);        // void sort(List list),按自然排序的升序排序        Collections.sort(arrayList);        System.out.println("Collections.sort(arrayList):");        System.out.println(arrayList);        // 定製排序的用法        Collections.sort(arrayList, new Comparator&lt;Integer&gt;() {            @Override            public int compare(Integer o1, Integer o2) {                return o2.compareTo(o1);            }        });        System.out.println("定製排序後：");        System.out.println(arrayList);</code></pre><p>Output:</p><pre><code>原始數組:[-1, 3, 3, -5, 7, 4, -9, -7]Collections.reverse(arrayList):[-7, -9, 4, 7, -5, 3, 3, -1]Collections.sort(arrayList):[-9, -7, -5, -1, 3, 3, 4, 7]定製排序後：[7, 4, 3, 3, -1, -5, -7, -9]</code></pre><h4 class=pgc-h-arrow-right>1.3.1.2. 重寫 compareTo 方法實現按年齡來排序</h4><pre><code>// person對象沒有實現Comparable接口，所以必須實現，這樣才不會出錯，才可以使treemap中的數據按順序排列// 前面一個例子的String類已經默認實現了Comparable接口，詳細可以查看String類的API文檔，另外其他// 像Integer類等都已經實現了Comparable接口，所以不需要另外實現了public  class Person implements Comparable&lt;Person&gt; {    private String name;    private int age;    public Person(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    /**     * T重寫compareTo方法實現按年齡來排序     */    @Override    public int compareTo(Person o) {        if (this.age &gt; o.getAge()) {            return 1;        }        if (this.age &lt; o.getAge()) {            return -1;        }        return 0;    }}</code></pre><pre><code>    public static void main(String[] args) {        TreeMap&lt;Person, String&gt; pdata = new TreeMap&lt;Person, String&gt;();        pdata.put(new Person("張三", 30), "zhangsan");        pdata.put(new Person("李四", 20), "lisi");        pdata.put(new Person("王五", 10), "wangwu");        pdata.put(new Person("小紅", 5), "xiaohong");        // 得到key的值的同時得到key所對應的值        Set&lt;Person&gt; keys = pdata.keySet();        for (Person key : keys) {            System.out.println(key.getAge() + "-" + key.getName());        }    }</code></pre><p>Output：</p><pre><code>5-小紅10-王五20-李四30-張三</code></pre><h3 class=pgc-h-arrow-right>1.3.2. 無序性和不可重複性的含義是什麼</h3><p>1、什麼是無序性？無序性不等於隨機性 ，無序性是指存儲的數據在底層數組中並非按照數組索引的順序添加 ，而是根據數據的哈希值決定的。</p><p>2、什麼是不可重複性？不可重複性是指添加的元素按照 equals()判斷時 ，返回 false，需要同時重寫 equals()方法和 HashCode()方法。</p><h3 class=pgc-h-arrow-right>1.3.3. 比較 HashSet、LinkedHashSet 和 TreeSet 三者的異同</h3><p>HashSet 是 Set 接口的主要實現類 ，HashSet 的底層是 HashMap，線程不安全的，可以存儲 null 值；</p><p>LinkedHashSet 是 HashSet 的子類，能夠按照添加的順序遍歷；</p><p>TreeSet 底層使用紅黑樹，能夠按照添加元素的順序進行遍歷，排序的方式有自然排序和定製排序。</p><h2 class=pgc-h-arrow-right>1.4. Map 接口</h2><h3 class=pgc-h-arrow-right>1.4.1. HashMap 和 Hashtable 的區別</h3><ol start=1><li><strong>線程是否安全：</strong> HashMap 是非線程安全的，HashTable 是線程安全的,因為 HashTable 內部的方法基本都經過synchronized 修飾。（如果你要保證線程安全的話就使用 ConcurrentHashMap 吧！）；</li><li><strong>效率：</strong> 因為線程安全的問題，HashMap 要比 HashTable 效率高一點。另外，HashTable 基本被淘汰，不要在代碼中使用它；</li><li><strong>對 Null key 和 Null value 的支持：</strong> HashMap 可以存儲 null 的 key 和 value，但 null 作為鍵只能有一個，null 作為值可以有多個；HashTable 不允許有 null 鍵和 null 值，否則會拋出 NullPointerException。</li><li><strong>初始容量大小和每次擴充容量大小的不同 ：</strong> ① 創建時如果不指定容量初始值，Hashtable 默認的初始大小為 11，之後每次擴充，容量變為原來的 2n+1。HashMap 默認的初始化大小為 16。之後每次擴充，容量變為原來的 2 倍。② 創建時如果給定了容量初始值，那麼 Hashtable 會直接使用你給定的大小，而 HashMap 會將其擴充為 2 的冪次方大小（HashMap 中的tableSizeFor()方法保證，下面給出了源代碼）。也就是說 HashMap 總是使用 2 的冪作為哈希表的大小,後面會介紹到為什麼是 2 的冪次方。</li><li><strong>底層數據結構：</strong> JDK1.8 以後的 HashMap 在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為 8）（將鏈表轉換成紅黑樹前會判斷，如果當前數組的長度小於 64，那麼會選擇先進行數組擴容，而不是轉換為紅黑樹）時，將鏈表轉化為紅黑樹，以減少搜索時間。Hashtable 沒有這樣的機制。</li></ol><p><strong>HashMap 中帶有初始容量的構造函數：</strong></p><pre><code>    public HashMap(int initialCapacity, float loadFactor) {        if (initialCapacity &lt; 0)            throw new IllegalArgumentException("Illegal initial capacity: " +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException("Illegal load factor: " +                                               loadFactor);        this.loadFactor = loadFactor;        this.threshold = tableSizeFor(initialCapacity);    }     public HashMap(int initialCapacity) {        this(initialCapacity, DEFAULT_LOAD_FACTOR);    }</code></pre><p>下面這個方法保證了 HashMap 總是使用 2 的冪作為哈希表的大小。</p><pre><code>    /**     * Returns a power of two size for the given target capacity.     */    static final int tableSizeFor(int cap) {        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }</code></pre><h3 class=pgc-h-arrow-right>1.4.2. HashMap 和 HashSet 區別</h3><p>如果你看過 HashSet 源碼的話就應該知道：HashSet 底層就是基於 HashMap 實現的。（HashSet 的源碼非常非常少，因為除了 clone()、writeObject()、readObject()是 HashSet 自己不得不實現之外，其他方法都是直接調用 HashMap 中的方法。</p><p><strong>HashMap</strong> <strong>HashSet</strong> 實現了 Map 接口 實現 Set 接口 存儲鍵值對 僅存儲對象 調用 put()向 map 中添加元素 調用 add()方法向 Set 中添加元素 HashMap 使用鍵（Key）計算 Hashcode HashSet 使用成員對象來計算 hashcode 值，對於兩個對象來說 hashcode 可能相同，所以 equals()方法用來判斷對象的相等性，</p><h3 class=pgc-h-arrow-right>1.4.3. HashMap 和 TreeMap 區別</h3><p>TreeMap 和HashMap 都繼承自AbstractMap ，但是需要注意的是TreeMap它還實現了NavigableMap接口和SortedMap 接口。</p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b446417afb0b46b38760fc21c7fc68b7><p class=pgc-img-caption></p></div><p>image</p><p>實現 NavigableMap 接口讓 TreeMap 有了對集合內元素的搜索的能力。</p><p>實現SortMap接口讓 TreeMap 有了對集合中的元素根據鍵排序的能力。默認是按 key 的升序排序，不過我們也可以指定排序的比較器。示例代碼如下：</p><pre><code>/** * @author shuang.kou * @createTime 2020年06月15日 17:02:00 */public class Person {    private Integer age;    public Person(Integer age) {        this.age = age;    }    public Integer getAge() {        return age;    }    public static void main(String[] args) {        TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() {            @Override            public int compare(Person person1, Person person2) {                int num = person1.getAge() - person2.getAge();                return Integer.compare(num, 0);            }        });        treeMap.put(new Person(3), "person1");        treeMap.put(new Person(18), "person2");        treeMap.put(new Person(35), "person3");        treeMap.put(new Person(16), "person4");        treeMap.entrySet().stream().forEach(personStringEntry -&gt; {            System.out.println(personStringEntry.getValue());        });    }}</code></pre><p>輸出:</p><pre><code>person1person4person2person3</code></pre><p>可以看出，TreeMap 中的元素已經是按照 Person 的 age 字段的升序來排列了。</p><p>上面，我們是通過傳入匿名內部類的方式實現的，你可以將代碼替換成 Lambda 表達式實現的方式：</p><pre><code>TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;((person1, person2) -&gt; {  int num = person1.getAge() - person2.getAge();  return Integer.compare(num, 0);});</code></pre><p><strong>綜上，相比於HashMap來說 TreeMap 主要多了對集合中的元素根據鍵排序的能力以及對集合內元素的搜索的能力。</strong></p><h3 class=pgc-h-arrow-right>1.4.4. HashSet 如何檢查重複</h3><p>當你把對象加入HashSet時，HashSet 會先計算對象的hashcode值來判斷對象加入的位置，同時也會與其他加入的對象的 hashcode 值作比較，如果沒有相符的 hashcode，HashSet 會假設對象沒有重複出現。但是如果發現有相同 hashcode 值的對象，這時會調用equals()方法來檢查 hashcode 相等的對象是否真的相同。如果兩者相同，HashSet 就不會讓加入操作成功。（摘自我的 Java 啟蒙書《Head fist java》第二版）</p><p><strong>hashCode()與 equals()的相關規定：</strong></p><ol start=1><li>如果兩個對象相等，則 hashcode 一定也是相同的</li><li>兩個對象相等,對兩個 equals 方法返回 true</li><li>兩個對象有相同的 hashcode 值，它們也不一定是相等的</li><li>綜上，equals 方法被覆蓋過，則 hashCode 方法也必須被覆蓋</li><li>hashCode()的默認行為是對堆上的對象產生獨特值。如果沒有重寫 hashCode()，則該 class 的兩個對象無論如何都不會相等（即使這兩個對象指向相同的數據）。</li></ol><p><strong>==與 equals 的區別</strong></p><p>對於基本類型來說，== 比較的是值是否相等；</p><p>對於引用類型來說，== 比較的是兩個引用是否指向同一個對象地址（兩者在內存中存放的地址（堆內存地址）是否指向同一個地方）；</p><p>對於引用類型（包括包裝類型）來說，equals 如果沒有被重寫，對比它們的地址是否相等；如果 equals()方法被重寫（例如 String），則比較的是地址裡的內容。</p><h3 class=pgc-h-arrow-right>1.4.5. HashMap 的底層實現</h3><h4 class=pgc-h-arrow-right>1.4.5.1. JDK1.8 之前</h4><p>JDK1.8 之前 HashMap 底層是 <strong>數組和鏈表</strong> 結合在一起使用也就是 <strong>鏈表散列</strong>。<strong>HashMap 通過 key 的 hashCode 經過擾動函數處理過後得到 hash 值，然後通過 (n - 1) & hash 判斷當前元素存放的位置（這裡的 n 指的是數組的長度），如果當前位置存在元素的話，就判斷該元素與要存入的元素的 hash 值以及 key 是否相同，如果相同的話，直接覆蓋，不相同就通過拉鍊法解決衝突。</strong></p><p><strong>所謂擾動函數指的就是 HashMap 的 hash 方法。使用 hash 方法也就是擾動函數是為了防止一些實現比較差的 hashCode() 方法 換句話說使用擾動函數之後可以減少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源碼:</strong></p><p>JDK 1.8 的 hash 方法 相比於 JDK 1.7 hash 方法更加簡化，但是原理不變。</p><pre><code>    static final int hash(Object key) {      int h;      // key.hashCode()：返回散列值也就是hashcode      // ^ ：按位異或      // &gt;&gt;&gt;:無符號右移，忽略符號位，空位都以0補齊      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);  }</code></pre><p>對比一下 JDK1.7 的 HashMap 的 hash 方法源碼.</p><pre><code>static int hash(int h) {    // This function ensures that hashCodes that differ only by    // constant multiples at each bit position have a bounded    // number of collisions (approximately 8 at default load factor).    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}</code></pre><p>相比於 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能會稍差一點點，因為畢竟擾動了 4 次。</p><p>所謂 <strong>“拉鍊法”</strong> 就是：將鏈表和數組相結合。也就是說創建一個鏈表數組，數組中每一格就是一個鏈表。若遇到哈希衝突，則將衝突的值加到鏈表中即可。</p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6a1da47358e54cf893e99f9176de8d90><p class=pgc-img-caption></p></div><p>jdk1.8之前的內部結構-HashMap</p><h4 class=pgc-h-arrow-right>1.4.5.2. JDK1.8 之後</h4><p>相比於之前的版本， JDK1.8 之後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為 8）（將鏈表轉換成紅黑樹前會判斷，如果當前數組的長度小於 64，那麼會選擇先進行數組擴容，而不是轉換為紅黑樹）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b462384f7989405fafc593893d273d4c><p class=pgc-img-caption></p></div><p>jdk1.8之後的內部結構-HashMap</p><blockquote><p>“</p><p>TreeMap、TreeSet 以及 JDK1.8 之後的 HashMap 底層都用到了紅黑樹。紅黑樹就是為了解決二叉查找樹的缺陷，因為二叉查找樹在某些情況下會退化成一個線性結構。</p></blockquote><h3 class=pgc-h-arrow-right>1.4.6. HashMap 的長度為什麼是 2 的冪次方</h3><p>為了能讓 HashMap 存取高效，儘量較少碰撞，也就是要儘量把數據分配均勻。我們上面也講到了過了，Hash 值的範圍值-2147483648 到 2147483647，前後加起來大概 40 億的映射空間，只要哈希函數映射得比較均勻鬆散，一般應用是很難出現碰撞的。但問題是一個 40 億長度的數組，內存是放不下的。所以這個散列值是不能直接拿來用的。用之前還要先做對數組的長度取模運算，得到的餘數才能用來要存放的位置也就是對應的數組下標。這個數組下標的計算方法是“ (n - 1) & hash”。（n 代表數組長度）。這也就解釋了 HashMap 的長度為什麼是 2 的冪次方。</p><p><strong>這個算法應該如何設計呢？</strong></p><p>我們首先可能會想到採用%取餘的操作來實現。但是，重點來了：<strong>“取餘(%)操作中如果除數是 2 的冪次則等價於與其除數減一的與(&)操作（也就是說 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 並且 <strong>採用二進制位操作 &，相對於%能夠提高運算效率，這就解釋了 HashMap 的長度為什麼是 2 的冪次方。</strong></p><h3 class=pgc-h-arrow-right>1.4.7. HashMap 多線程操作導致死循環問題</h3><p>主要原因在於併發下的 Rehash 會造成元素之間會形成一個循環鏈表。不過，jdk 1.8 後解決了這個問題，但是還是不建議在多線程下使用 HashMap,因為多線程下使用 HashMap 還是會存在其他問題比如數據丟失。併發環境下推薦使用 ConcurrentHashMap 。</p><p>詳情請查看：<strong>https://coolshell.cn/articles/9606.html</strong></p><h3 class=pgc-h-arrow-right>1.4.8. HashMap 有哪幾種常見的遍歷方式?</h3><p><strong>HashMap 的 7 種遍歷方式與性能分析！</strong></p><h3 class=pgc-h-arrow-right>1.4.9. ConcurrentHashMap 和 Hashtable 的區別</h3><p>ConcurrentHashMap 和 Hashtable 的區別主要體現在實現線程安全的方式上不同。</p><ul><li><strong>底層數據結構：</strong> JDK1.7 的 ConcurrentHashMap 底層採用 <strong>分段的數組+鏈表</strong> 實現，JDK1.8 採用的數據結構跟 HashMap1.8 的結構一樣，數組+鏈表/紅黑二叉樹。Hashtable 和 JDK1.8 之前的 HashMap 的底層數據結構類似都是採用 <strong>數組+鏈表</strong> 的形式，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的；</li><li><strong>實現線程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的時候，ConcurrentHashMap（分段鎖）</strong> 對整個桶數組進行了分割分段(Segment)，每一把鎖只鎖容器其中一部分數據，多線程訪問容器裡不同數據段的數據，就不會存在鎖競爭，提高併發訪問率。 <strong>到了 JDK1.8 的時候已經摒棄了 Segment 的概念，而是直接用 Node 數組+鏈表+紅黑樹的數據結構來實現，併發控制使用 synchronized 和 CAS 來操作。（JDK1.6 以後 對 synchronized 鎖做了很多優化）</strong> 整個看起來就像是優化過且線程安全的 HashMap，雖然在 JDK1.8 中還能看到 Segment 的數據結構，但是已經簡化了屬性，只是為了兼容舊版本；② <strong>Hashtable(同一把鎖)</strong> :使用 synchronized 來保證線程安全，效率非常低下。當一個線程訪問同步方法時，其他線程也訪問同步方法，可能會進入阻塞或輪詢狀態，如使用 put 添加元素，另一個線程不能使用 put 添加元素，也不能使用 get，競爭會越來越激烈效率越低。</li></ul><p><strong>兩者的對比圖：</strong></p><p><strong>HashTable:</strong></p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0bee46595abe4078994be4bb5fc3a048><p class=pgc-img-caption></p></div><p>HashTable全表鎖</p><p>http://www.cnblogs.com/chengxiao/p/6842045.html></p><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1bfb2113bc246238e8386ca2d4f8b60><p class=pgc-img-caption></p></div><p>JDK1.7的ConcurrentHashMap</p><p>http://www.cnblogs.com/chengxiao/p/6842045.html></p><p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/969b4c242fac401e92dd084527fd40c3><p class=pgc-img-caption></p></div><p>JDK1.8 的 ConcurrentHashMap</p><p>JDK1.8 的 ConcurrentHashMap 不在是 <strong>Segment 數組 + HashEntry 數組 + 鏈表</strong>，而是 <strong>Node 數組 + 鏈表 / 紅黑樹</strong>。不過，Node 只能用於鏈表的情況，紅黑樹的情況需要使用 <strong>TreeNode</strong>。當衝突鏈表達到一定長度時，鏈表會轉換成紅黑樹。</p><h3 class=pgc-h-arrow-right>1.4.10. ConcurrentHashMap 線程安全的具體實現方式/底層具體實現</h3><h4 class=pgc-h-arrow-right>1.4.10.1. JDK1.7（上面有示意圖）</h4><p>首先將數據分為一段一段的存儲，然後給每一段數據配一把鎖，當一個線程佔用鎖訪問其中一個段數據時，其他段的數據也能被其他線程訪問。</p><p><strong>ConcurrentHashMap 是由 Segment 數組結構和 HashEntry 數組結構組成</strong>。</p><p>Segment 實現了 ReentrantLock,所以 Segment 是一種可重入鎖，扮演鎖的角色。HashEntry 用於存儲鍵值對數據。</p><pre><code>static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {}</code></pre><p>一個 ConcurrentHashMap 裡包含一個 Segment 數組。Segment 的結構和 HashMap 類似，是一種數組和鏈表結構，一個 Segment 包含一個 HashEntry 數組，每個 HashEntry 是一個鏈表結構的元素，每個 Segment 守護著一個 HashEntry 數組裡的元素，當對 HashEntry 數組的數據進行修改時，必須首先獲得對應的 Segment 的鎖。</p><h4 class=pgc-h-arrow-right>1.4.10.2. JDK1.8 （上面有示意圖）</h4><p>ConcurrentHashMap 取消了 Segment 分段鎖，採用 CAS 和 synchronized 來保證併發安全。數據結構跟 HashMap1.8 的結構類似，數組+鏈表/紅黑二叉樹。Java 8 在鏈表長度超過一定閾值（8）時將鏈表（尋址時間複雜度為 O(N)）轉換為紅黑樹（尋址時間複雜度為 O(log(N))）</p><p>synchronized 只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要 hash 不衝突，就不會產生併發，效率又提升 N 倍。</p><h2 class=pgc-h-arrow-right>1.5. Collections 工具類</h2><p>Collections 工具類常用方法:</p><ol start=1><li>排序</li><li>查找,替換操作</li><li>同步控制(不推薦，需要線程安全的集合類型時請考慮使用 JUC 包下的併發集合)</li></ol><h3 class=pgc-h-arrow-right>1.5.1. 排序操作</h3><pre><code>void reverse(List list)//反轉void shuffle(List list)//隨機排序void sort(List list)//按自然排序的升序排序void sort(List list, Comparator c)//定製排序，由Comparator控制排序邏輯void swap(List list, int i , int j)//交換兩個索引位置的元素void rotate(List list, int distance)//旋轉。當distance為正數時，將list後distance個元素整體移到前面。當distance為負數時，將 list的前distance個元素整體移到後面</code></pre><h3 class=pgc-h-arrow-right>1.5.2. 查找,替換操作</h3><pre><code>int binarySearch(List list, Object key)//對List進行二分查找，返回索引，注意List必須是有序的int max(Collection coll)//根據元素的自然順序，返回最大的元素。 類比int min(Collection coll)int max(Collection coll, Comparator c)//根據定製排序，返回最大元素，排序規則由Comparatator類控制。類比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。int frequency(Collection c, Object o)//統計元素出現次數int indexOfSubList(List list, List target)//統計target在list中第一次出現的索引，找不到則返回-1，類比int lastIndexOfSubList(List source, list target).boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替換舊元素</code></pre><h3 class=pgc-h-arrow-right>1.5.3. 同步控制</h3><p>Collections 提供了多個synchronizedXxx()方法·，該方法可以將指定集合包裝成線程同步的集合，從而解決多線程併發訪問集合時的線程安全問題。</p><p>我們知道 HashSet，TreeSet，ArrayList,LinkedList,HashMap,TreeMap 都是線程不安全的。Collections 提供了多個靜態方法可以把他們包裝成線程同步的集合。</p><p><strong>最好不要用下面這些方法，效率非常低，需要線程安全的集合類型時請考慮使用 JUC 包下的併發集合。</strong></p><p>方法如下：</p><pre><code>synchronizedCollection(Collection&lt;T&gt;  c) //返回指定 collection 支持的同步（線程安全的）collection。synchronizedList(List&lt;T&gt; list)//返回指定列表支持的同步（線程安全的）List。synchronizedMap(Map&lt;K,V&gt; m) //返回由指定映射支持的同步（線程安全的）Map。synchronizedSet(Set&lt;T&gt; s) //返回指定 set 支持的同步（線程安全的）set。</code></pre><h2 class=pgc-h-arrow-right>1.6. 其他重要問題</h2><h3 class=pgc-h-arrow-right>1.6.1. 什麼是快速失敗(fail-fast)？</h3><p><strong>快速失敗(fail-fast)</strong> 是 Java 集合的一種錯誤檢測機制。<strong>在使用迭代器對集合進行遍歷的時候，我們在多線程下操作非安全失敗(fail-safe)的集合類可能就會觸發 fail-fast 機制，導致拋出 ConcurrentModificationException 異常。 另外，在單線程下，如果在遍歷過程中對集合對象的內容進行了修改的話也會觸發 fail-fast 機制。</strong></p><blockquote><p>“</p><p>注：增強 for 循環也是藉助迭代器進行遍歷。</p></blockquote><p>舉個例子：多線程下，如果線程 1 正在對集合進行遍歷，此時線程 2 對集合進行修改（增加、刪除、修改），或者線程 1 在遍歷過程中對集合進行修改，都會導致線程 1 拋出 ConcurrentModificationException 異常。</p><p><strong>為什麼呢？</strong></p><p>每當迭代器使用 hashNext()/next()遍歷下一個元素之前，都會檢測 modCount 變量是否為 expectedModCount 值，是的話就返回遍歷；否則拋出異常，終止遍歷。</p><p>如果我們在集合被遍歷期間對其進行修改的話，就會改變 modCount 的值，進而導致 modCount != expectedModCount ，進而拋出 ConcurrentModificationException 異常。</p><blockquote><p>“</p><p>注：通過 Iterator 的方法修改集合的話會修改到 expectedModCount 的值，所以不會拋出異常。</p></blockquote><pre><code>final void checkForComodification() {    if (modCount != expectedModCount)        throw new ConcurrentModificationException();}</code></pre><p>好吧！相信大家已經搞懂了快速失敗(fail-fast)機制以及它的原理。</p><p>我們再來趁熱打鐵，看一個阿里巴巴手冊相關的規定：</p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/738600fb8e9f4fc3ae3ab9eb2b4754b2><p class=pgc-img-caption></p></div><p>有了前面講的基礎，我們應該知道：使用 Iterator 提供的 remove 方法，可以修改到 expectedModCount 的值。所以，才不會再拋出ConcurrentModificationException 異常。</p><h3 class=pgc-h-arrow-right>1.6.2. 什麼是安全失敗(fail-safe)呢？</h3><p>明白了快速失敗(fail-fast)之後，安全失敗(fail-safe)我們就很好理解了。</p><p>採用安全失敗機制的集合容器，在遍歷時不是直接在集合內容上訪問的，而是先複製原有集合內容，在拷貝的集合上進行遍歷。所以，在遍歷過程中對原集合所作的修改並不能被迭代器檢測到，故不會拋 ConcurrentModificationException 異常。</p><h3 class=pgc-h-arrow-right>1.6.3. Arrays.asList()避坑指南</h3><p>最近使用Arrays.asList()遇到了一些坑，然後在網上看到這篇文章：<strong>Java Array to List Examples</strong> 感覺挺不錯的，但是還不是特別全面。所以，自己對於這塊小知識點進行了簡單的總結。</p><h4 class=pgc-h-arrow-right>1.6.3.1. 簡介</h4><p>Arrays.asList()在平時開發中還是比較常見的，我們可以使用它將一個數組轉換為一個 List 集合。</p><pre><code>String[] myArray = { "Apple", "Banana", "Orange" }；List&lt;String&gt; myList = Arrays.asList(myArray);//上面兩個語句等價於下面一條語句List&lt;String&gt; myList = Arrays.asList("Apple","Banana", "Orange");</code></pre><p>JDK 源碼對於這個方法的說明：</p><pre><code>/** *返回由指定數組支持的固定大小的列表。此方法作為基於數組和基於集合的API之間的橋樑，與           Collection.toArray()結合使用。返回的List是可序列化並實現RandomAccess接口。 */public static &lt;T&gt; List&lt;T&gt; asList(T... a) {    return new ArrayList&lt;&gt;(a);}</code></pre><h4 class=pgc-h-arrow-right>1.6.3.2. 《阿里巴巴 Java 開發手冊》對其的描述</h4><p>Arrays.asList()將數組轉換為集合後,底層其實還是數組，《阿里巴巴 Java 開發手冊》對於這個方法有如下描述：</p><div class=pgc-img><img alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57b8df9daf084cfd8482a5bfcc28f497><p class=pgc-img-caption></p></div><p>阿里巴巴Java開發手-Arrays.asList()方法</p><h4 class=pgc-h-arrow-right>1.6.3.3. 使用時的注意事項總結</h4><p><strong>傳遞的數組必須是對象數組，而不是基本類型。</strong></p><p>Arrays.asList()是泛型方法，傳入的對象必須是對象數組。</p><pre><code>int[] myArray = { 1, 2, 3 };List myList = Arrays.asList(myArray);System.out.println(myList.size());//1System.out.println(myList.get(0));//數組地址值System.out.println(myList.get(1));//報錯：ArrayIndexOutOfBoundsExceptionint [] array=(int[]) myList.get(0);System.out.println(array[0]);//1</code></pre><p>當傳入一個原生數據類型數組時，Arrays.asList() 的真正得到的參數就不是數組中的元素，而是數組對象本身！此時 List 的唯一元素就是這個數組，這也就解釋了上面的代碼。</p><p>我們使用包裝類型數組就可以解決這個問題。</p><pre><code>Integer[] myArray = { 1, 2, 3 };</code></pre><p><strong>使用集合的修改方法:add()、remove()、clear()會拋出異常。</strong></p><pre><code>List myList = Arrays.asList(1, 2, 3);myList.add(4);//運行時報錯：UnsupportedOperationExceptionmyList.remove(1);//運行時報錯：UnsupportedOperationExceptionmyList.clear();//運行時報錯：UnsupportedOperationException</code></pre><p>Arrays.asList() 方法返回的並不是 java.util.ArrayList ，而是 java.util.Arrays 的一個內部類,這個內部類並沒有實現集合的修改方法或者說並沒有重寫這些方法。</p><pre><code>List myList = Arrays.asList(1, 2, 3);System.out.println(myList.getClass());//class java.util.Arrays$ArrayList</code></pre><p>下圖是java.util.Arrays$ArrayList的簡易源碼，我們可以看到這個類重寫的方法有哪些。</p><pre><code>  private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements RandomAccess, java.io.Serializable    {        ...        @Override        public E get(int index) {          ...        }        @Override        public E set(int index, E element) {          ...        }        @Override        public int indexOf(Object o) {          ...        }        @Override        public boolean contains(Object o) {           ...        }        @Override        public void forEach(Consumer&lt;? super E&gt; action) {          ...        }        @Override        public void replaceAll(UnaryOperator&lt;E&gt; operator) {          ...        }        @Override        public void sort(Comparator&lt;? super E&gt; c) {          ...        }    }</code></pre><p>我們再看一下java.util.AbstractList的remove()方法，這樣我們就明白為啥會拋出UnsupportedOperationException。</p><pre><code>public E remove(int index) {    throw new UnsupportedOperationException();}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>最新版</a></li><li><a>面試題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe336513.html alt=Java異常面試題含答案（2020最新版） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe336513.html title=Java異常面試題含答案（2020最新版）>Java異常面試題含答案（2020最新版）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html alt=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15208700392878e896bf9c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html title=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理>Java面試題：詳細說明一下可重入鎖ReentrantLock的原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38f9fcd1.html alt=2020新版Java集合容器面試題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38f9fcd1.html title=2020新版Java集合容器面試題>2020新版Java集合容器面試題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c15b9453.html alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/a0a360ea-5629-4382-b8f0-87c9b83083de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c15b9453.html title=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較>大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>