<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試阿里，美團都會被問到的Spring ,從基礎到源碼統統幫你搞定 | 极客快訊</title><meta property="og:title" content="面試阿里，美團都會被問到的Spring ,從基礎到源碼統統幫你搞定 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/0ca013e258664cbb94ab2d6883b0fd97"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="面試阿里，美團都會被問到的Spring ,從基礎到源碼統統幫你搞定"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/cf7f98c8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試阿里，美團都會被問到的Spring ,從基礎到源碼統統幫你搞定</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1 前言</h1><ol start=1><li>Spring是一個輕量級開源框架，它是為了解決企業應用開發的複雜性而創建的。框架的主要優勢之一就是其分層架構，分層架構允許使用者選擇使用哪一個組件，同時為 J2EE 應用程序開發提供集成的框架。</li><li>Spring是眾多優秀設計模式的組合（工廠、單例、代理、適配器、包裝器、觀察者、模板、策略）。</li><li>Spring的用途不僅限於服務器端的開發。從簡單性、可測試性和鬆耦合的角度而言，任何Java應用都可以從Spring中受益。</li><li>Spring並未替代現有框架產品，而是將眾多框架進行有機整合，簡化企業級開發，俗稱"膠水框架"。</li></ol><h1 class=pgc-h-arrow-right>2 Spring架構組成</h1><p>Spring架構由諸多模塊組成，可分類為</p><ul><li>核心技術：依賴注入，事件，資源，i18n，驗證，數據綁定，類型轉換，SpEL，AOP。</li><li>測試：模擬對象，TestContext框架，Spring MVC測試，WebTestClient。</li><li>數據訪問：事務，DAO支持，JDBC，ORM，封送XML。</li><li>Spring MVC和 Spring WebFlux Web框架。</li><li>集成：遠程處理，JMS，JCA，JMX，電子郵件，任務，調度，緩存。</li><li>語言：Kotlin，Groovy，動態語言。</li><li>List item</li></ul><p>Spring架構組成如下圖</p><p><br></p><div class=pgc-img><img alt="面試阿里，美團都會被問到的Spring ,從基礎到源碼統統幫你搞定" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0ca013e258664cbb94ab2d6883b0fd97><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>3 Spring環境搭建</h1><h1 class=pgc-h-arrow-right>3.1 pom.xml中引入Spring常用依賴</h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation=         "http://maven.apache.org/POM/4.0.0           http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.qf&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- Spring常用依賴 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h1 class=pgc-h-arrow-right>3.2 創建Spring配置文件</h1><p>命名無限制，約定俗成命名有：spring-context.xml、applicationContext.xml、beans.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right>4 Spring工廠編碼（入門程序）</h1><h1 class=pgc-h-arrow-right>4.1 定義目標Bean類型</h1><pre><code>public class MyClass{    public void show(){        System.out.println("HelloWorld");    }}</code></pre><h1 class=pgc-h-arrow-right>4.2spring-context.xml中的&lt; beans >內部配置bean</h1><p>在spring-context.xml中配置MyClass的bean後，當項目啟動時，spring容器會自動創建MyClass實例，這個實例名字叫mc</p><pre><code>&lt;!-- 配置實例（id:“唯一標識”  class="需要被創建的目標對象全限定名"） --&gt;&lt;bean id="mc" class="com.qf.spring.part1.factory.MyClass" /&gt;</code></pre><p>測試代碼</p><pre><code>public class TestFactory{    /**     * 程序中的對象都交由Spring的ApplicationContext工廠進行創建。     */    public static void main(String[] args){        //1\. 讀取配置文件中所需創建的bean對象，並獲得工廠對象        ApplicationContext ctx = new ClassPathXmlApplicationContext("spring-context.xml");        //2\. 通過id獲取bean對象        MyClass mc = (MyClass) ctx.getBean("mc");        //3\. 使用對象        mc.show();    }}</code></pre><h1 class=pgc-h-arrow-right>5 IoC（Inversion of Control ）控制反轉</h1><p>控制反轉是Spring框架的核心，所謂控制反轉就是應用本身不負責依賴對象的創建及維護，依賴對象的創建及維護是由外部容器負責的， 這樣控制權就由應用轉移到了外部容器，控制權的轉移就是所謂反轉。這樣就由之前的自己創建依賴對象，變為由spring容器創建。(變主動為被動，即反轉)。控制反轉解決了具有依賴關係的組件之間的強耦合，使得項目形態更加穩健。</p><h1 class=pgc-h-arrow-right>5.1 項目中強耦合問題</h1><pre><code>public class UserDAOImpl implements UserDAO{....}</code></pre><pre><code>public class UserServiceImpl implements UserService {    // 通過傳統的new方式強耦合了UserDAOImpl!!!,使得UserServiceImpl變得不穩健!!    private UserDAO userDAO= new UserDAOImpl();    @Override    public User queryUser() {        return userDAO.queryUser();    }    ....}</code></pre><h1 class=pgc-h-arrow-right>5.2 解決方案</h1><pre><code>// 不引用任何一個具體的組件(實現類)，在需要其他組件的位置預留存取值入口(set/get)public class UserServiceImpl implements UserService {    // !!!不再耦合任何DAO實現!!!,消除不穩健因素!!    private UserDAO userDAO；    // 為userDAO定義set/get,允許userDAO屬性接收spring賦值    //Getters And Setters    @Override    public User queryUser() {        return userDAO.queryUser();    }    ....}</code></pre><p>在spring配置文件中配置UserDAO和UserService對應的bean</p><pre><code>&lt;bean id="userDAO" class="com.qf.spring.part1.injection.UserDaoImpl"&gt;&lt;/bean&gt;&lt;!-- UserServiceImpl組件 --&gt;&lt;bean id="userService" class="com.qf.spring.part1.injection.UserServiceImpl"&gt;    &lt;!-- 由spring為userDAO屬性賦值，值為id="userDAO"的bean --&gt;    &lt;property name="userDAO" ref="userDAO"/&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6 DI（Dependency Injection）依賴注入</h1><h1 class=pgc-h-arrow-right>6.1 概念</h1><p>在Spring創建對象的同時，為其屬性賦值，稱之為依賴注入,注入方式主要有以下2種</p><ul><li>構造函數注入</li><li>Setter方法注入</li></ul><h1 class=pgc-h-arrow-right>6.2 Setter方法注入</h1><p>創建對象時，Spring工廠會通過Setter方法為對象的屬性賦值。</p><h1 class=pgc-h-arrow-right>6.2.1 定義目標Bean類型</h1><pre><code>public class User {    private Integer id;    private String password;    private String sex;    private Integer age;    private Date bornDate;    private String[] hobbys;    private Set&lt;String&gt; phones;    private List&lt;String&gt; names;    private Map&lt;String,String&gt; countries;    private Properties files;    //Getters And Setters}</code></pre><h1 class=pgc-h-arrow-right>6.2.2 基本類型 + 字符串類型 + 日期類型</h1><pre><code>&lt;bean id="u1" class="com.qf.spring.part1.injection.User"&gt;    &lt;!--base field--&gt;    &lt;property name="id" value="1001" /&gt;    &lt;property name="password" value="123456" /&gt;    &lt;property name="sex" value="male" /&gt;    &lt;property name="age" value="20" /&gt;    &lt;property name="bornDate" value="1990/1/1" /&gt;&lt;!--注意格式"/"--&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6.2.3 容器類型（list,set,map,Properties）</h1><pre><code>&lt;bean id="u1" class="com.qf.spring.part1.injection.User"&gt;       &lt;!--Array--&gt;    &lt;property name="hobbys"&gt;        &lt;array&gt;            &lt;value&gt;Run&lt;/value&gt;            &lt;value&gt;Swim&lt;/value&gt;            &lt;value&gt;Climb&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!--Set--&gt;    &lt;property name="phones"&gt;        &lt;set&gt;            &lt;value&gt;13777777777&lt;/value&gt;            &lt;value&gt;13888888888&lt;/value&gt;            &lt;value&gt;13999999999&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!--List--&gt;    &lt;property name="names"&gt;        &lt;list&gt;            &lt;value&gt;tom&lt;/value&gt;            &lt;value&gt;jack&lt;/value&gt;            &lt;value&gt;marry&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!--Map--&gt;    &lt;property name="countries"&gt;        &lt;map&gt;            &lt;entry key="CN" value="China" /&gt;            &lt;entry key="US" value="America" /&gt;            &lt;entry key="KR" value="Korea" /&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;!--Properties--&gt;    &lt;property name="files"&gt;        &lt;props&gt;            &lt;prop key="first"&gt;One&lt;/prop&gt;            &lt;prop key="second"&gt;Two&lt;/prop&gt;            &lt;prop key="third"&gt;Three&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6.2.4 自定義類型</h1><pre><code>&lt;!--次要bean，被作為屬性--&gt;&lt;bean id="addr" class="com.qf.spring.part1.injection.Address"&gt;    &lt;property name="position" value="北京市海淀區" /&gt;    &lt;property name="zipCode" value="100001" /&gt;&lt;/bean&gt;&lt;!--主要bean，操作的主體--&gt;&lt;bean id="u2" class="com.qf.spring.part1.injection.User"&gt;    &lt;property name="address" ref="addr" /&gt;&lt;!--address屬性引用addr對象--&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6.3 構造注入</h1><p>創建對象時，Spring工廠會通過構造方法為對象的屬性賦值。</p><h1 class=pgc-h-arrow-right>6.3.1 定義目標Bean類型</h1><pre><code>public class Student {    private Integer id;    private String name;    private String sex;    private Integer age;    //Constructors    public Student(Integer id , String name , String sex , Integer age){        this.id = id;        this.name = name;        this.sex = sex;        this.age = age;    }}複製代碼</code></pre><h1 class=pgc-h-arrow-right>6.3.2 注入</h1><pre><code> &lt;!--構造注入--&gt;&lt;bean id="u3" class="com.qf.zcg.spring.day1.t2.ioc.Student"&gt;    &lt;constructor-arg name="id" value="1234" /&gt; &lt;!-- 除標籤名稱有變化，其他均和Set注入一致 --&gt;    &lt;constructor-arg name="name" value="tom" /&gt;    &lt;constructor-arg name="age" value="20" /&gt;    &lt;constructor-arg name="sex" value="male" /&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>7 Spring工廠特性</h1><h1 class=pgc-h-arrow-right>7.1 餓漢式創建優勢</h1><p>工廠創建之後，會將Spring配置文件中的所有對象都創建完成（餓漢式），提高程序運行效率，避免多次IO，減少對象創建時間。（概念接近連接池，一次性創建好，使用時直接獲取）</p><h1 class=pgc-h-arrow-right>7.2 生命週期方法</h1><ul><li>自定義初始化方法：添加“init-method”屬性，Spring則會在創建對象之後，調用此方法。</li><li>自定義銷燬方法：添加“destroy-method”屬性，Spring則會在銷燬對象之前，調用此方法。</li><li>銷燬：工廠的close()方法被調用之後，Spring會毀掉所有已創建的單例對象。</li><li>分類：Singleton對象由Spring容器銷燬、Prototype對象由JVM銷燬。</li></ul><h1 class=pgc-h-arrow-right>7.3 生命週期註解</h1><pre><code>import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@PostConstruct //初始化 public void init(){    System.out.println("init method executed");}@PreDestroy //銷燬public void destroy(){    System.out.println("destroy method executed");}</code></pre><h1 class=pgc-h-arrow-right>7.4 生命週期階段</h1><p>單例bean：singleton</p><p>隨工廠啟動創建 ==》 構造方法 ==》 set方法(注入值) ==》 init(初始化) ==》 構建完成 ==》隨工廠關閉銷燬</p><p>多例bean：prototype</p><p>被使用時創建 ==》 構造方法 ==》 set方法(注入值) ==》 init(初始化) ==》 構建完成 ==》JVM垃圾回收銷燬</p><h1 class=pgc-h-arrow-right>8 代理設計模式</h1><h1 class=pgc-h-arrow-right>8.1 概念</h1><p>將核心功能與輔助功能（事務、日誌、性能監控代碼）分離，達到核心業務功能更純粹、輔助業務功能可複用。</p><p><br></p><div class=pgc-img><img alt="面試阿里，美團都會被問到的Spring ,從基礎到源碼統統幫你搞定" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1c33a6fb3c684f86912ca073acada557><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>8.2 靜態代理設計模式</h1><p>通過代理類的對象，為原始類的對象（目標類的對象）添加輔助功能，更容易更換代理實現類、利於維護。</p><ul><li>代理類 = 實現原始類相同接口 + 添加輔助功能 + 調用原始類的業務方法。</li><li>靜態代理的問題 代理類數量過多，不利於項目的管理。 多個代理類的輔助功能代碼冗餘，修改時，維護性差。</li></ul><h1 class=pgc-h-arrow-right>8.3 動態代理設計模式</h1><h1 class=pgc-h-arrow-right>8.3.1 JDK動態代理實現（基於接口）</h1><pre><code>//目標final OrderService os = new OrderServiceImpl();//額外功能InvocationHandler handler = new InvocationHandler(){//1.設置回調函數（額外功能代碼）    @Override    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable {        System.out.println("start...");        method.invoke(os, args);         System.out.println("end...");        return null;    }};//2.創建動態代理類Object proxyObj = Proxy.newProxyInstance(ClassLoader , Interfaces , InvocationHandler);</code></pre><h1 class=pgc-h-arrow-right>8.3.2 CGlib動態代理實現（基於繼承）</h1><pre><code>final OrderService os = new OrderServiceImpl();Enhancer cnh = new Enhancer();//1.創建字節碼曾強對象enh.setSuperclass(os.getClass());//2.設置父類（等價於實現原始類接口）enh.setCallback(new InvocationHandler(){//3.設置回調函數（額外功能代碼）    @Override    public Object invoke(Object proxy , Method method, Object[] args) throws Throwable{        System.out.println("start...");        Object ret = method.invoke(os,args);        System.out.println("end...");        return ret;    }});OrderService proxy = (OrderService)enh.create();//4.創建動態代理類proxy,createOrder();</code></pre><h1 class=pgc-h-arrow-right>9 面向切面編程</h1><h1 class=pgc-h-arrow-right>9.1 概念</h1><p>AOP（Aspect Oriented Programming），即面向切面編程，利用一種稱為"橫切"的技術，剖開封裝的對象內部，並將那些影響了多個類的公共行為封裝到一個可重用模塊，並將其命名為"Aspect"，即切面。所謂"切面"，簡單說就是那些與業務無關，卻為業務模塊所共同調用的邏輯或責任封裝起來，便於減少系統的重複代碼，降低模塊之間的耦合度，並有利於未來的可操作性和可維護性。</p><p>通俗的概念來講，所謂的面向切面編程就是針對被代理對象的方法在某個特定的執行時機(方法調用之前、方法調用之後、方法拋出異常)，做出一些額外的橫向的處理。好處在於：1. 可以在不修改原有代碼基礎上橫向擴展我們的內容；2. 將一些方法中的通用邏輯進行統一化的處理。</p><p>OOP(面向對象編程)和AOP(面向切面編程)的區別：oop是對類縱向的擴展；aop是橫向的擴展。</p><h1 class=pgc-h-arrow-right>9.2 AOP開發術語</h1><ul><li>連接點(Joinpoint)：連接點是程序類中客觀存在的方法，可被Spring攔截並切入內容。</li><li>切入點(Pointcut)：被切入連接點。</li><li>通知、增強(Advice)：可以為切入點添加額外功能，分為：前置通知、後置通知、異常通知、環繞通知等。</li><li>目標對象(Target)：代理的目標對象</li><li>織入(Weaving)：把通知應用到具體的類，進而創建新的代理類的過程。</li><li>代理(Proxy)：被AOP織入通知後，產生的結果類。</li><li>切面(Aspect)：由切點和通知組成，將橫切邏輯織入切面所指定的連接點中。</li></ul><h1 class=pgc-h-arrow-right>9.3 作用</h1><p>Spring的AOP編程即是通過動態代理類為原始類的方法添加輔助功能。</p><h1 class=pgc-h-arrow-right>9.4 環境搭建</h1><p>引入AOP相關依賴</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>spring-context.xml引入AOP命名空間</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       "&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right>9.5 開發流程</h1><p>定義原始類</p><pre><code>package com.qf.aaron.aop.basic;public interface UserService {    public void save();}複製代碼</code></pre><pre><code>package com.qf.aaron.aop.basic;public class UserServiceImpl implements UserService {    public void save() {        System.out.println("save method executed...");    }}</code></pre><p>定義通知類（添加額外功能</p><pre><code>package com.qf.aaron.aop.basic;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class MyAdvice implements MethodBeforeAdvice { //實現前置通知接口    public void before(Method method, Object[] args, Object target) throws Throwable {        System.out.println("before advice executed...");    }}</code></pre><p>定義bean標籤</p><pre><code>&lt;!--原始對象--&gt;&lt;bean id="us" class="com.qf.aaron.aop.basic.UserServiceImpl" /&gt;&lt;!--輔助對象--&gt;&lt;bean id="myAdvice" class="com.qf.aaron.aop.basic.MyAdvice" /&gt;</code></pre><p>定義切入點（PointCut）</p><p>形成切面（Aspect）</p><pre><code>&lt;aop:config&gt;    &lt;!--切點--&gt;    &lt;aop:pointcut id="myPointCut" expression="execution(* save())" /&gt;&lt;/aop:config&gt;```java&lt;aop:config&gt;    &lt;!--組裝切面 --&gt;    &lt;aop:advisor advice-ref="myAdvice" pointcut-ref="myPointCut" /&gt;&lt;/aop:config&gt;</code></pre><h1 class=pgc-h-arrow-right>9.6 通知類</h1><p>可定義的通知類有6種，可以按需求選擇通知類。</p><pre><code>前置通知：MethodBeforeAdvice後置通知：AfterAdvice後置通知：AfterReturningAdvice //有異常不執行，方法會因異常而結束，無返回值異常通知：ThrowsAdvice環繞通知：MethodInterceptor</code></pre><h1 class=pgc-h-arrow-right>9.7 JDK動態代理和CGLIB動態代理的選擇</h1><ul><li>spring底層，包含了jdk代理和cglib代理兩種動態代理生成機制</li><li>基本規則是：目標業務類如果有接口則用JDK代理，沒有接口則用CGLib代理</li></ul><p>但是spring中默認開啟JDK動態代理，當需要使用CGLIB動態代理時，需要在spring配置文件中配置。</p><pre><code>&lt;!--  使用cglib的方式實現aop --&gt;    &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</code></pre><h1 class=pgc-h-arrow-right>10 基於aspectJ的AOP實現</h1><p>編寫aspectJ通知代碼:</p><pre><code>@Aspectpublic class AspectJAdvisor {    // 環繞通知    @Around("execution(* org.example.service.impl.*.*(..))")    public Object timer(ProceedingJoinPoint pjp) throws Throwable{        System.out.println("前置通知");        Object o = pjp.proceed();        System.out.println("【後置通知】");        return o;    }    // 後置通知    @After("execution(* org.example.service.impl.*.*(..))")    public void after(JoinPoint jp) throws Throwable{        System.out.println("====After method invokded====");    }    // 前置通知    @Before("execution(* org.example.service.impl.*.*(..))")    public void before(JoinPoint jp){        System.out.println("====before method invoked====");    }    // 正常返回的通知    @AfterReturning("execution(* org.example.service.impl.*.*(..))")    public void afterReturning(JoinPoint jp){        System.out.println("====after value return====");    }    // 拋出異常後的通知，方法的異常必須與代理類拋出的異常一致，throwing的值要與異常的形參名保持一致    @AfterThrowing(value = "execution(* org.example.service.impl.*.*(..))", throwing="npe")    public void afterThrowException(JoinPoint jp, NullPointerException npe){        System.out.println("====after exception throwing====");    }}</code></pre><p>配置</p><pre><code>&lt;bean id="userService" class="org.example.service.impl.UserServiceImpl"&gt;&lt;/bean&gt;&lt;bean id="throwsAdvisor" class="org.example.advisor.AspectJAdvisor"&gt;&lt;/bean&gt;&lt;!--- aspectJ是使用cglib來實現動態代理的 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><h1 class=pgc-h-arrow-right>11 基於註解開發</h1><h1 class=pgc-h-arrow-right>11.1 聲明bean</h1><p>用於替換自建類型組件的 &lt;bean…>標籤；可以更快速的聲明bean</p><ul><li>@Service 業務類專用 @Repository dao實現類專用 @Controller web層專用</li><li>@Component 通用</li><li>@Scope 用戶控制bean的創建模式</li></ul><pre><code>// @Service說明 此類是一個業務類，需要將此類納入工廠  等價替換掉 &lt;bean class="xxx.UserServiceImpl"&gt;// @Service默認beanId == 首字母小寫的類名"userServiceImpl"// @Service("userService") 自定義beanId為"userService"@Service //聲明bean，且id="userServiceImpl"@Scope("singleton") //聲明創建模式，默認為單例模式 ；@Scope("prototype")即可設置為多例模式public class UserServiceImpl implements UserService {    ...   }</code></pre><h1 class=pgc-h-arrow-right>11.2 注入(DI)</h1><p>用於完成bean中屬性值的注入</p><ul><li>@Autowired 基於類型自動注入</li><li>@Resource 基於名稱自動注入</li><li>@Qualifier(“userDAO”) 限定要自動注入的bean的id，一般和@Autowired聯用</li><li>@Value 注入簡單類型數據 (jdk8種+String)</li></ul><pre><code>@Servicepublic class UserServiceImpl implements UserService {    @Autowired //注入類型為UserDAO的bean    @Qualifier("userDAO2") //如果有多個類型為UserDAO的bean，可以用此註解從中挑選一個    private UserDAO userDAO;}</code></pre><pre><code>@Servicepublic class UserServiceImpl implements UserService {    @Resource("userDAO3") //注入id=“userDAO3”的bean    private UserDAO userDAO;    /*    @Resource //注入id=“userDAO”的bean    private UserDAO userDAO;    */}</code></pre><pre><code>public class XX{    @Value("100") //注入數字    private Integer id;    @Value("shine") //注入String    private String name;}</code></pre><h1 class=pgc-h-arrow-right>11.3 事務控制</h1><p>用於控制事務切入</p><ul><li>@Transactional</li><li>工廠配置中的 &lt;tx:advice… 和 &lt;aop:config… 可以省略 !!</li></ul><pre><code>//類中的每個方法都切入事務(有自己的事務控制的方法除外)@Transactional(isolation=Isolation.READ_COMMITTED,propagation=Propagation.REQUIRED,readOnly=false,rollbackFor=Exception.class,timeout = -1)public class UserServiceImpl implements UserService {    ...    //該方法自己的事務控制，僅對此方法有效    @Transactional(propagation=Propagation.SUPPORTS)    public List&lt;User&gt; queryAll() {        return userDao.queryAll();    }    public void save(User user){        userDao.save(user);    }}</code></pre><h1 class=pgc-h-arrow-right>11.4 註解所需配置</h1><pre><code>&lt;!-- 告知spring，哪些包中 有被註解的類、方法、屬性 --&gt;&lt;!-- &lt;context:component-scan base-package="com.qf.a,com.xx.b"&gt;&lt;/context:component-scan&gt; --&gt;&lt;context:component-scan base-package="com.qf"&gt;&lt;/context:component-scan&gt;&lt;!-- 告知spring，@Transactional在定製事務時，基於txManager=DataSourceTransactionManager --&gt;&lt;tx:annotation-driven transaction-manager="txManager"/&gt;</code></pre><h1 class=pgc-h-arrow-right>11.5 AOP開發</h1><h1 class=pgc-h-arrow-right>11.5.1 註解使用</h1><pre><code>import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Aspect // 聲明此類是一個切面類：會包含切入點(pointcut)和通知(advice)@Component //聲明組件，進入工廠public class MyAspect {    // 定義切入點    @Pointcut("execution(* com.qf.spring.service.UserServiceImpl.*(..))")    public void pc(){}    @Before("pc()") // 前置通知    public void mybefore(JoinPoint a) {        System.out.println("target:"+a.getTarget());        System.out.println("args:"+a.getArgs());        System.out.println("method's name:"+a.getSignature().getName());        System.out.println("before~~~~");    }    @AfterReturning(value="pc()",returning="ret") // 後置通知    public void myAfterReturning(JoinPoint a,Object ret){        System.out.println("after~~~~:"+ret);    }    @Around("pc()") // 環繞通知    public Object myInterceptor(ProceedingJoinPoint p) throws Throwable {        System.out.println("interceptor1~~~~");        Object ret = p.proceed();        System.out.println("interceptor2~~~~");        return ret;    }    @AfterThrowing(value="pc()",throwing="ex") // 異常通知    public void myThrows(JoinPoint jp,Exception ex){        System.out.println("throws");        System.out.println("===="+ex.getMessage());    }}</code></pre><h1 class=pgc-h-arrow-right>11.5.2 配置</h1><pre><code>&lt;!-- 添加如下配置,啟用aop註解 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><h1 class=pgc-h-arrow-right>12 Spring單元測試</h1><h1 class=pgc-h-arrow-right>12.1 導入依賴</h1><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 class=pgc-h-arrow-right>12.2 測試編碼</h1><p>可以免去工廠的創建過程；</p><p>可以直接將要測試的組件注入到測試類。</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class) //由SpringJUnit4ClassRunner啟動測試@ContextConfiguration("classpath:applicationContext.xml") //spring的配置文件位置public class SpringTest{//當前測試類也會被納入工廠中，所以其中屬性可以注入    @Autowired // 注入要測試的組件    @Qualifier("userDAO")    private UserDAO userDAO;    @Test    public void test(){        // 測試使用userDAO        userDAO.queryUser();        ....    }}最後</code></pre><h1 class=pgc-h-arrow-right>內容就先寫到這裡。</h1><h1 class=pgc-h-arrow-right>最後覺得文章對你有幫助的話記得給我點個贊。</h1><h1 class=pgc-h-arrow-right>歡迎大家<strong>關注</strong>和<strong>轉發</strong>文章！</h1></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>美團</a></li><li><a>問到</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html alt="不怕面試被問了！二叉樹算法大盤點 | 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html title="不怕面試被問了！二叉樹算法大盤點 | 原力計劃">不怕面試被問了！二叉樹算法大盤點 | 原力計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html title="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~">別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html title=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a819fbd.html alt=面試三連二叉樹，原來二叉樹還可以講的這麼簡單，不看看嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afef1f6cac3540d785def8bbf641f8d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a819fbd.html title=面試三連二叉樹，原來二叉樹還可以講的這麼簡單，不看看嗎？>面試三連二叉樹，原來二叉樹還可以講的這麼簡單，不看看嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>