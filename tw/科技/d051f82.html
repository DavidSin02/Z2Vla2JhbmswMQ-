<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何診斷Java代碼中常見的數據庫性能熱點問題？ | 极客快訊</title><meta property="og:title" content="如何診斷Java代碼中常見的數據庫性能熱點問題？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/15217840990949360ecee7a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d051f82.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d051f82.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d051f82.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d051f82.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d051f82.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d051f82.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d051f82.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d051f82.html><meta property="article:published_time" content="2020-10-29T20:58:59+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:59+08:00"><meta name=Keywords content><meta name=description content="如何診斷Java代碼中常見的數據庫性能熱點問題？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d051f82.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何診斷Java代碼中常見的數據庫性能熱點問題？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>如何應用的java性能診斷和優化？看兩種西藥處方。如果您有更好的療效處方，請在評審區歡迎我們。</p><p>當我幫助一些開發商或建築師分析和優化java應用程序的性能，關鍵不在於調整個人的方法來保存一個或兩個微秒的執行時間。雖然對於某些軟件來說，微秒的優化是非常重要的，但我不認為這是眼睛。在我2015年的數百個應用程序中進行了分析，發現大多數性能和可伸縮性問題都來自於不良的體系結構決策、幀錯誤配置、數據庫訪問模式、過度日誌記錄以及垃圾回收所造成的內存消耗過大造成的影響。</p><p>在我看來，性能工程的基礎是通過大量的觀察將關鍵的體系結構指標、可伸縮性度量和性能指標聯繫起來。通過分析各結構的結果和不同負載的性能，找出系統中存在的迴歸缺陷或瓶頸。下圖中的儀表板用作示例：</p><p><img alt=如何診斷Java代碼中常見的數據庫性能熱點問題？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15217840990949360ecee7a></p><p>通過關聯繫統負載、響應時間和SQL語句執行次數，可以得到一些性能工程問題的根本原因。</p><p>頂層的稱為“層分解”圖，它顯示了應用程序中每個邏輯組件的總執行時間，如Web服務、數據庫訪問、業務邏輯、Web服務器等。紅色部分表示在後端Web服務上花費的時間，很明顯這裡產生了一個組件熱點。</p><p>同時，我們也可以發現Web服務不受異常負載的影響，因為從第二個圖中，應用程序處理的請求數量相對穩定。一般來說，大部分的響應時間都是在數據層中消耗的，但這並不意味著數據庫本身是慢的！我理解低效的數據庫訪問常常是性能不佳的主要原因，因此通常將其組合起來分析SQL語句執行的次數。在本例中，可以清楚地看到它與大多數響應時間的峰值有關。</p><p>我觀察到的最常見的模式是糟糕的數據庫訪問模式，除了服務調用、太細粒度共享壞數據訪問共享、過度日誌記錄、垃圾收集和內存洩漏造成的崩潰以及大量的對象創建效果或應用程序。</p><p>可選的診斷工具</p><p>在本文中，我將重點討論數據庫問題，因為我非常確信您的所有應用程序都是由這些訪問模式之一造成的。你可以選擇各種性能診斷、跟蹤或APM的工具在市場上，但我的選擇是自由的dynaTrace個人許可證。Java itself also provides a variety of excellent tools, such as Java Mission Control, and so on. 許多提供數據訪問功能的框架經常通過其日誌輸出提供各種診斷選項，如Hibernate或Spring，等等。</p><p>在這些跟蹤工具的使用，通常不需要對代碼做任何修改，因為他們使用JVMTI（JVM工具界面）捕捉各級代碼級別的信息，甚至可以跨遠程呼叫跟蹤，這是分佈式的（微）是非常實用的應用服務。您所要做的就是修改JVM引導命令行選項來加載這些工具。</p><p>一些工具的開發人員還提供了與IDE的集成，您只需簡單地在運行時顯示“打開XYZ性能診斷”即可。我在YouTube上製作了一個簡單的視頻指南，演示如何跟蹤Eclipse中啟動的應用程序。（https://www. youtube.com/watch？V = unrey8wfq-m和清單= plqt2rd0eew1bmdn54e2_m2uvbhm_wxy_6 &指數= 14）</p><p>查找數據庫的性能熱點</p><p>即使您發現應用程序的響應時間過長的主要原因是數據庫，也不要輕易地指責數據庫和DBA。數據庫繁忙的原因可能如下：</p><ul class=list-paddingleft-2><li><p>數據庫的使用效率太低：錯誤的查詢設計，糟糕的應用程序邏輯，以及數據訪問框架的不正確配置。</p></li><li><p>錯誤的數據庫設計和數據結構：表關聯、慢速存儲視圖、缺少或不正確的索引、過期的表統計信息</p></li><li><p>不恰當的數據庫配置，如內存、磁盤、表空間、連接池等。</p></li></ul><p>在本文中，我將重點討論如何最小化在應用程序端訪問數據庫所消耗的時間。</p><p>診斷不良的數據庫訪問模式</p><p>當我診斷一個問題的應用程序時，我通常檢查幾個數據庫訪問模式。我將逐一分析應用程序請求，並將這些問題放在下面的“DB問題模式”分類表中：</p><ul class=list-paddingleft-2><li><p>過多的SQL執行（多表）：執行大量（大於500）不同的SQL語句</p></li><li><p>n + 1查詢問題（n + 1查詢）：同一SQL語句的多個（大於20）執行</p></li><li><p>單個SQL語句執行緩慢（慢單SQL）：單個SQL語句執行時間佔響應時間的80%以上。</p></li><li><p>數據驅動的問題（數據驅動）：相同的請求，因為不同的輸入參數，執行不同的SQL語句</p></li><li><p>數據庫繁忙（數據庫重）：數據庫執行的總時間佔總響應時間的60%以上。</p></li><li><p>unpreprocessed聲明（準備報告）：聲明不預處理時相同的SQL執行</p></li><li><p>連接池資源利用（池耗竭）：因為連接太長時間（getConnection超過executestatement）</p></li><li><p>無效連接池訪問（低效池訪問）：訪問連接池數太高（調用getConnection超過50%的executestatement電話號碼）。</p></li><li><p>數據庫服務服務器過載（重載數據庫服務器）：來自各種應用程序的過度請求，導致數據庫服務器超載</p></li></ul><p>示例1：自主設計的O / R映射生成了太多SQL</p><p>我的第一個例子是一個Web應用程序，它提供建築物中會議室的信息。會議室的信息保存在數據庫中。每當用戶生成會議室信息報告時，就調用自定義數據訪問層訪問數據庫。</p><p>在分析單個請求時，我總是檢查所謂的事務流（事務流）。事務流是顯示應用程序處理請求過程的可視化選項。對於會議室信息報告的要求，可以看出，請求首先轉到Web服務器層（圖左），然後進入應用服務層（圖），然後啟動對數據層的調用（圖右）。這些層之間的“鏈接”顯示了這些層之間的交互數量，例如單個請求執行了多少SQL查詢。</p><p>從這個屏幕中，我們可以立即發現導致問題的前兩種模式，即過多的SQL執行模式和數據庫繁忙模式。讓我們來分析一下。</p><p>很容易看出，這個請求生成大量SQL語句，並具有繁忙的數據庫效應：它總共執行了24889個SQL語句！完成整個執行過程花費了40.27秒（佔整個請求時間的66.51%）！</p><p>如果我們分析單個SQL語句，我們會看到這個請求的另一個問題，即，n + 1查詢和低效的連接池訪問。</p><p>通過優化數據庫索引，無法解決這種不良訪問模式。</p><p>我已經見過這個問題很多次了。應用程序的邏輯需要在一個對象列表上迭代，但它不能選擇緊急加載的方式。它使用延遲加載。這種選擇可能來自於O／R映射框架，如Hibernate或Spring，或者來自自開發的框架，如上面所示。本例採用了一種自行開發的開發方式。它將加載每個會議室對象，並通過獨立的SQL查詢獲取每個會議室的所有屬性。</p><p>每個SQL查詢在連接池的JDBC連接中執行，然後在每個查詢完成後返回。這也解釋了為什麼請求將產生12444組列出的操作，因為Sybase的JDBC驅動程序將提交這一請求每次請求連接到連接池。這就是問題所在！其它的JDBC驅動程序可能不會產生組列出的呼喚。你可以檢查調用getConnection的數量，這也反映了這個問題。</p><p>對於n + 1查詢本身，使用連接查詢可以很容易地避免這個問題。在這個會議室和屬性的示例中，可以使用以下連接查詢：</p><pre>select r.*, p.*from meeting_rooms as rinner join room_properties as p on p.room_id = r.room_id</pre><p>結果是整個執行過程只有1個查詢執行時間，不超過12000次！它也消除了12000通電話訪問“列出”。</p><p>示例2：錯誤的Hibernate配置會導致太多SQL執行</p><p>據我所知，Hibernate或其他O／R映射器有很多用戶。我想提醒您的是，O／R映射器提供的延遲加載和貪婪加載選項以及各種緩存層存在的原因。對於特定的用例，您需要確保您正確地使用了這些特性和選項。</p><p>在下面的示例中，延遲加載不是一個好的選擇，因為加載2000個對象及其屬性可能導致4000多個SQL查詢。考慮到我們總是需要獲取所有對象，最好的方法是加載這些對象，然後考慮緩存它們。前提是這些對象不會經常更改。</p><p>當使用諸如Hibernate或Spring的O／R映射器時，需要選擇正確的加載和緩存選項。你需要了解他們是如何幕後工作的。</p><p>大多數O／R映射將通過日誌記錄提供優秀的診斷選項，並且還可以查看在線社區中的內容，以瞭解各種最佳實踐。建議您閱讀一系列的博客文章，Alois Reitbauer寫的，誰做了它的一個很深的研究，在早期的冬眠。在本系列中，他強調了如何有效地使用緩存和加載選項。</p><p>示例3：自定義DB訪問代碼中使用的語句未經過預處理。</p><p>當數據庫引擎完成對某條SQL語句的解析，並創建了數據訪問的執行計劃後，該結果會被保存在數據庫中的一個緩存區域中以便重用，而無需重新解析這一語句（語句解析是數據庫中最耗費CPU時間的操作）。用於在緩存中找到某個查詢的鍵是語句的全文本。這也意味著，如果你調用了1000次相同的語句，卻為其傳了100個不同的參數值（例如where語句中的值），那麼在緩存中就會產生1000個不同的條目，而使用了新參數的第1001次查詢也必須被再次解析。這種工作方式非常低效。</p><p>因此，我們提出了預處理語句的概念：在預處理和解析之後，將一個句子存儲在緩存中，並表示佔位符中的變量。在這句話的實際執行，這些佔位符將實際值替換，而無需解決的陳述了一遍，以便我們能找到直接從緩存執行計劃。</p><p>數據庫訪問框架通常在這一點上做得很好，並且對查詢語句進行預處理。但在自定義代碼中，我發現開發人員常常忽略了這一點。在下面的示例中，只有一小部分SQL執行預處理過程：</p><p><img alt=如何診斷Java代碼中常見的數據庫性能熱點問題？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15217840991577799cf51a8></p><p>通過對SQL執行的SQL執行已預處理的數量，unpreprocessed數據庫訪問是發現問題。</p><p>如果你要開發自己的數據庫訪問代碼，再確認一下，你叫preparestatement正確。例如，如果你調用一個查詢超過1次，最好是常常可以使用預處理語句。如果您選擇使用框架訪問數據，請再次確認這些框架的行為，在優化和執行生成的SQL時可以選擇哪些配置選項。最簡單的方法是實現這一監控時代executestatement和preparestatement數執行。如果為每個SQL查詢重複相同的監視，很容易找到優化熱點。</p><p>例4：由於一個耗時的後端SQL報告執行，連接池不能有效調整。</p><p>我經常發現一些應用程序使用默認連接池大小，如每個池的10或20個連接。開發人員總是忽略連接池大小的優化，因為它們不進行必要的大規模負載測試，也不知道有多少用戶將使用這些新功能，甚至不知道並行DB訪問將導致什麼結果。也可能是從預發佈環境到生產環境的部署，當連接池的配置信息丟失時，這將導致生產環境中應用服務器中的默認配置。</p><p>通過JMX的索引信息，便於監視連接池的使用。每個應用服務器（Tomcat、JBoss，Websphere，等等）將提供這些指標，但一些服務器需要你明確開啟此功能。下圖顯示了一組服務器連接池的使用。您可以看到，在三個應用服務器中的三個中，“活動連接的數量”達到了最大值。</p><p>確保您正確地調整了連接池的大小，並且不要使用與您期望的負載不匹配的默認設置。</p><p>這個問題的根本原因不是訪問量的峰值。在本文的開頭，系統加載/響應時間/數據庫執行時間表明應用程序沒有生成特殊的流量峰值。據發現，每天下午2點，一個運行報告的計劃在這個時候成立。它需要執行許多具有長運行時間的更新語句，每個語句使用不同的連接。這將在幾分鐘內阻塞其他連接，導致應用程序在正常流量下的性能問題。因為用戶的請求不能得到數據庫的連接。</p><p>個別SQL執行阻塞其他連接幾分鐘，造成池資源耗盡的問題。</p><p>如果您已經瞭解到有些請求將掛斷連接很長一段時間，您可以選擇以下選項：</p><ul class=list-paddingleft-2><li><p>將這些請求發送到單獨的服務器，以避免影響其他用戶</p></li><li><p>僅當它不影響其他人的時間時重新配置其執行時間。</p></li><li><p>增加連接池的大小，以確保在正常訪問時有足夠的連接可用。</p></li></ul><p>但是，首先必須確保這些查詢是優化的。對SQL查詢執行計劃進行分析，以找出哪些操作是最耗時的。今天，大多數APM工具允許您以某種方式獲得SQL語句的執行計劃。如果沒有可用的工具，最簡單的方法是使用數據庫命令行工具，或者諮詢DBA，以便他可以幫助您生成執行計劃。</p><p>通過學習SQL查詢執行計劃來優化SQL語句</p><p>執行計劃可以顯示DB引擎處理SQL語句的方式。SQL語句執行緩慢的原因是多種多樣的。它不侷限於缺乏索引或使用索引的方式。在許多情況下，它是由設計、結構或連接查詢引起的。如果您不是SQL專家，您可以向DBA或SQL請求幫助。</p><p>生產環境中負載測試和監視的技巧和技術</p><p>除了分析所有請求並指出這些問題之外，我還將重點關注應用程序在負載下的長期趨勢。除了我在本文開頭展示的儀表板，我還將指出數據驅動行為的變化，並驗證數據緩存操作的正確性。</p><p>檢查點1：由於數據緩存的存在，對DB的訪問數量應該逐漸減少。</p><p>下面的圖表顯示SQL語句執行的平均時間（綠色）和SQL語句執行的總次數（藍色）。我們對應用程序進行了兩小時的性能測試，以使負載保持在較高的水平。我期望的結果是，平均次數逐漸減少，總次數趨於穩定。因為，根據我的假設，從DB獲得的大部分數據是靜態的，或者緩存在不同的層中。</p><p>如果應用程序不滿足這種期望，那麼它可能是數據驅動的性能問題或緩存問題。</p><p>假設，正如我前面所展示的，在應用程序中存在一個常見的n + 1查詢問題。然後，隨著DB中最終用戶生成的數據數量的增加，應用程序生成的SQL平均數量也會增加，因為這些查詢返回的數據也會增加。因此，一定要注意這些數字。</p><p>檢查點2：按類別指出SQL訪問模式</p><p>示例4顯示了每天下午二點執行後臺報告所造成的問題。類似地，我還將注意sql訪問隨時間變化的模式。我的關注點不僅包括總執行時間，還包括選擇、插入、更新和刪除執行次數。因此，我會指出一些特殊的活動是否會在一定的時間內進行，例如通過後臺工作來更新大量的數據。</p><p>通過觀察總執行時間和選擇、插入、更新和刪除執行次數來了解應用程序的數據庫訪問行為。</p><p>為大量更新操作執行批處理作業需要一定的時間來完成，特別是對於包含大量行的表。如果整個表被鎖定，則此表的其他請求，即使只有其中的一些請求被更新，也必須等待釋放鎖。您應該考慮在沒有其他用戶的在線時間的情況下運行這些任務，或者實現一些不同的鎖定邏輯，以實現單行的鎖定、更新和釋放操作。</p><p>檢查點3：數據庫實例的運行狀態</p><p>在本文中，我重點對數據庫性能問題大多數與數據庫服務器本身的分析速度慢是無關緊要的，但主要由最糟糕的數據庫訪問模式的使用（N + 1的查詢，無需預處理語句等）應用程序代碼或配置錯誤（連接池訪問、數據驅動造成的低效的問題）。</p><p>但是如果我們完全忽視數據庫本身，那是不明智的。因此，我總是檢查關鍵數據庫性能指標。大多數的數據庫將通過特殊的系統性能表提供了豐富的信息，如Oracle將提供一些v$表和視圖，訪問關鍵績效指標數據庫（會話、等待時間、分析時間、執行時間、等）或信息表鎖和運行時間慢的SQL，這些信息共享數據庫實例，每個應用程序。</p><p>我通常看兩個儀表盤我當數據庫健康檢查，你可以從這裡看到這些性能指標數據表。</p><p>觀察數據庫是否處於健康狀態，或受應用程序實例應用程序所產生的過度負載的影響。</p><p>通過使用諸如表鎖之類的信息，可以確定執行中的SQL語句是否對服務器甚至對應用程序產生負面影響。</p><p>連續集成過程中數據庫度量的自動檢測</p><p>在我向您介紹一些關鍵數據庫指標和用例的新思想之前，我希望首先彌補一個遺漏的主題，這就是我們應該考慮的，自動化。</p><p>我建議您不要手動執行這些檢查步驟，而是通過連續集成工具檢查這些指標，並將此步驟與單元測試、集成測試、REST API或其他功能測試步驟相結合。如果您設計了一組用於檢查REST API或新特性的各種功能的測試用例，為什麼不在每次測試執行期間捕獲這些指示器呢？這種方法可以帶來以下好處：</p><ol class=list-paddingleft-2><li><p>讓代碼評審過程關注於這些度量，而不是一遍又一遍地閱讀每一行代碼。</p></li><li><p>如果代碼檢查導致此問題，則發出通知。</p></li></ol><p>下面的屏幕截圖顯示了每次構建和每次測試時對這些指標的跟蹤，並在異常情況下給出警告。您可以將這些指標集成到您的構建管道中，並且當代碼更改受到影響時，您可以通過通知信息瞭解情況，然後立即修復它，並避免在將代碼發佈到生產環境時發生系統崩潰。</p><p>將這些指標添加到您的持續集成過程中，並觀察指標的變化，以自動識別各種不良數據庫訪問模式！</p><p>性能問題遠遠超過數據庫。</p><p>在這篇文章中，我們關注數據庫中的熱點問題。但在我的工作中，我也發現了其他領域的許多性能問題。在2015，我參加了一個項目，將集成的應用程序遷移到一個（微）服務中，在那裡發現了一個巨大的峰值問題。這個問題類似於我們分析過的一些模式，比如N + 1查詢問題，因為某個示例會議會調用幾百次特定的後端服務。</p><p>在大多數情況下，這個問題是由不良的界面設計造成的，並沒有考慮到當一個本地調用方法執行在Docker容器或雲計算環境。網絡問題將突然出現，包括通過網絡傳輸的信息和新的連接池（這意味著您需要考慮線程和套接字）。這些是你必須處理的問題。</p><p><img alt=如何診斷Java代碼中常見的數據庫性能熱點問題？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15217864063161433d1f775></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>診斷</a></li><li><a>Java</a></li><li><a>代碼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf6235db.html alt="Java 代碼自動生成器 auto-code" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d60ae1d716bd4e22babd7a068ccc3577 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf6235db.html title="Java 代碼自動生成器 auto-code">Java 代碼自動生成器 auto-code</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef985079.html alt="Java 通用代碼生成器光 1.5.0 Kama (頓悟)發佈，內含開發者手冊" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/00f13030-6d86-4a2f-9ba4-698b919cf0fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef985079.html title="Java 通用代碼生成器光 1.5.0 Kama (頓悟)發佈，內含開發者手冊">Java 通用代碼生成器光 1.5.0 Kama (頓悟)發佈，內含開發者手冊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f48bce.html alt=Java：基於代碼實戰的File類和文件隨機訪問類RandomAccessFile class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3c7a0005031473ab9806 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f48bce.html title=Java：基於代碼實戰的File類和文件隨機訪問類RandomAccessFile>Java：基於代碼實戰的File類和文件隨機訪問類RandomAccessFile</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c271e4.html alt=Java代碼獲取數據庫表名、字段名、字段類型及註釋等信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d8d691ba-a551-42f4-8252-ab4a753618d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c271e4.html title=Java代碼獲取數據庫表名、字段名、字段類型及註釋等信息>Java代碼獲取數據庫表名、字段名、字段類型及註釋等信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>