<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表 | 极客快訊</title><meta property="og:title" content="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/192fc396ba5f43debc3c79908bbc09ae"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d064499.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d064499.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d064499.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d064499.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d064499.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d064499.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d064499.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d064499.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d064499.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/192fc396ba5f43debc3c79908bbc09ae><p class=pgc-img-caption></p></div><p><strong>前言</strong></p><ul><li>基礎知識就像是一座大樓的地基，它決定了我們的技術高度。</li><li>我們應該多掌握一些可移值的技術或者再過十幾年應該都不會過時的技術，數據結構與算法就是其中之一。</li></ul><p>棧、隊列、鏈表、堆 是數據結構與算法中的基礎知識，是程序員的地基。</p><p>筆者寫的 <strong>JavaScript 數據結構與算法之美</strong> 系列用的語言是 <strong>JavaScript</strong> ，旨在入門數據結構與算法和方便以後複習。</p><p><strong>1. 線性表與非線性表</strong></p><p><strong>線性表</strong>（Linear List）：就是數據排成像一條線一樣的結構。每個線性表上的數據最多隻有前和後兩個方向。數組、鏈表、隊列、棧 等就是線性表結構。</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dedc983470264af9b11941d18d41dc91><p class=pgc-img-caption></p></div><p><strong>非線性表</strong>：數據之間並不是簡單的前後關係。二叉樹、堆、圖 就是非線性表。</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0913cdce42224703ab41b7f2460cdb2b><p class=pgc-img-caption></p></div><p>本文主要講線性表，非線性表會在後面章節講。</p><p><strong>2. 數組</strong></p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a0ca97790a0b4c6d9642026c221cacd9><p class=pgc-img-caption></p></div><p><strong>定義</strong></p><ul><li>數組 (Array) 是一個有序的數據集合，我們可以通過數組名稱 (name) 和索引 (index) 進行訪問。</li><li>數組的索引是從 0 開始的。</li></ul><p><strong>特點</strong></p><ul><li><strong>數組是用一組連續的內存空間來存儲的</strong>。</li><li>所以數組支持 <strong>隨機訪問</strong>，根據下標隨機訪問的時間複雜度為 O(1)。</li><li><strong>低效的插入和刪除</strong>。</li><li>數組為了保持內存數據的連續性，會導致插入、刪除這兩個操作比較低效，因為底層通常是要進行大量的數據搬移來保持數據的連續性。</li><li>插入與刪除的時間複雜度如下：</li><li>插入：從最好 O(1) ，最壞 O(n) ，平均 O(n)</li><li>刪除：從最好 O(1) ，最壞 O(n) ，平均 O(n)</li></ul><p><strong>注意</strong></p><p>但是因為 JavaScript 是<strong>弱類型</strong>的語言，弱類型則允許隱式類型轉換。</p><p><strong>隱式</strong>：是指源碼中沒有明顯的類型轉換代碼。也就是說，一個變量，可以賦值字符串，也可以賦值數值。</p><pre>let str = "string"str = 123 console.log(str) // 123</pre><p>你還可以直接讓字符串類型的變量和數值類型的變量相加，雖然得出的最終結果未必是你想象的那樣，但一定不會報錯。</p><pre>let a = 123let b = "456"let c = a + b// 數值加字符串，結果是字符串console.log(c) // "123456"</pre><p>數組的每一項可以是不同的類型，比如：</p><pre>// 數組的類型有 數值、字符串，還可以隨意變更類型const arr = [ 12, 34, "abc" ]arr[2] = { "key": "value" } // 把數組的第二項變成對象console.log(arr) // [ 12, 34, { "key": "value"} ]</pre><p>定義的數組的大小是可變的，不像強類型語言，定義某個數組變量的時候就要定義該變量的大小。</p><pre>const arr = [ 12, 34, "abc"] arr.push({ "key": "value" }) // 添加一項 對象consolelog(arr) // [ 12, 34, "abc", { "key": "value" } ]</pre><p><strong>實現</strong></p><p>JavaScript 原生支持數組，而且提供了很多操作方法，這裡不展開講。</p><p><strong>3. 棧</strong></p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/36994f4d2c76481b88261ac42095accf><p class=pgc-img-caption></p></div><p><strong>定義</strong></p><ol><li>後進者先出，先進者後出，簡稱 <strong>後進先出</strong>（LIFO），這就是典型的棧結構。</li><li>新添加的或待刪除的元素都保存在棧的末尾，稱作棧頂，另一端就叫棧底。</li><li>在棧裡，新元素都靠近棧頂，舊元素都接近棧底。</li><li>從棧的操作特性來看，是一種 操作受限的線性表，只允許在一端插入和刪除數據。</li><li>不包含任何元素的棧稱為空棧。</li></ol><p>棧也被用在編程語言的編譯器和內存中保存變量、方法調用等，比如函數的調用棧。</p><p><strong>實現</strong></p><p>棧的方法：</p><ul><li>push(element)：添加一個（或幾個）新元素到棧頂。</li><li>pop()：移除棧頂的元素，同時返回被移除的元素。</li><li>peek()：返回棧頂的元素，不對棧做任何修改。</li><li>isEmpty()：如果棧裡沒有任何元素就返回 true，否則返回 false。</li><li>clear()：移除棧裡的所有元素。</li><li>size()：返回棧裡的元素個數。</li></ul><pre>// Stack類function Stack() { this.items = []; // 添加新元素到棧頂 this.push = function(element) { this.items.push(element); }; // 移除棧頂元素，同時返回被移除的元素 this.pop = function() { return this.items.pop(); }; // 查看棧頂元素 this.peek = function() { return this.items[this.items.length - 1]; }; // 判斷是否為空棧 this.isEmpty = function() { return this.items.length === 0; }; // 清空棧 this.clear = function() { this.items = []; }; // 查詢棧的長度 this.size = function() { return this.items.length; }; // 打印棧裡的元素 this.print = function() { console.log(this.items.toString()); };}</pre><p>測試：</p><pre>// 創建Stack實例var stack = new Stack();console.log(stack.isEmpty()); // truestack.push(5); // undefinedstack.push(8); // undefinedconsole.log(stack.peek()); // 8stack.push(11); // undefinedconsole.log(stack.size()); // 3console.log(stack.isEmpty()); // falsestack.push(15); // undefinedstack.pop(); // 15console.log(stack.size()); // 3stack.print(); // 5,8,11stack.clear(); // undefinedconsole.log(stack.size()); // 0</pre><p>棧的應用實例：JavaScript 數據結構與算法之美 - 實現一個前端路由，如何實現瀏覽器的前進與後退 ？</p><p><strong>4. 隊列</strong></p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a79768d4721a4e5fbf17dc3f937ccfa8><p class=pgc-img-caption></p></div><p><strong>普通隊列</strong></p><p><strong>定義</strong></p><ul><li>隊列是遵循 FIFO（First In First Out，<strong>先進先出</strong>）原則的一組有序的項。</li><li>隊列在尾部添加新元素，並從頂部移除元素。</li><li>最新添加的元素必須排在隊列的末尾。</li><li>隊列只有 入隊 push() 和出隊 pop()。</li></ul><p><strong>實現</strong></p><p>隊列裡面有一些聲明的輔助方法：</p><ul><li>enqueue(element)：向隊列尾部添加新項。</li><li>dequeue()：移除隊列的第一項，並返回被移除的元素。</li><li>front()：返回隊列中第一個元素，隊列不做任何變動。</li><li>isEmpty()：如果隊列中不包含任何元素，返回 true，否則返回 false。</li><li>size()：返回隊列包含的元素個數，與數組的 length 屬性類似。</li><li>print()：打印隊列中的元素。</li><li>clear()：清空整個隊列。</li></ul><p>代碼：</p><pre>// Queue類function Queue() { this.items = []; // 向隊列尾部添加元素 this.enqueue = function(element) { this.items.push(element); }; // 移除隊列的第一個元素，並返回被移除的元素 this.dequeue = function() { return this.items.shift(); }; // 返回隊列的第一個元素 this.front = function() { return this.items[0]; }; // 判斷是否為空隊列 this.isEmpty = function() { return this.items.length === 0; }; // 獲取隊列的長度 this.size = function() { return this.items.length; }; // 清空隊列 this.clear = function() { this.items = []; }; // 打印隊列裡的元素 this.print = function() { console.log(this.items.toString()); };}</pre><p>測試：</p><pre>// 創建Queue實例var queue = new Queue();console.log(queue.isEmpty()); // truequeue.enqueue('John'); // undefinedqueue.enqueue('Jack'); // undefinedqueue.enqueue('Camila'); // undefinedqueue.print(); // "John,Jack,Camila"console.log(queue.size()); // 3console.log(queue.isEmpty()); // falsequeue.dequeue(); // "John"queue.dequeue(); // "Jack"queue.print(); // "Camila"queue.clear(); // undefinedconsole.log(queue.size()); // 0</pre><p><strong>優先隊列</strong></p><p><strong>定義</strong></p><p>優先隊列中元素的添加和移除是依賴優先級的。</p><p><strong>應用</strong></p><ul><li>一個現實的例子就是機場登機的順序。頭等艙和商務艙乘客的優先級要高於經濟艙乘客。</li><li>再比如：火車，老年人、孕婦和帶小孩的乘客是享有優先檢票權的。</li></ul><p><strong>優先隊列分為兩類</strong></p><ul><li>最小優先隊列</li><li>最大優先隊列</li></ul><p>最小優先隊列是把優先級的值最小的元素被放置到隊列的最前面（代表最高的優先級）。</p><p>比如：有四個元素："John", "Jack", "Camila", "Tom"，他們的優先級值分別為 4，3，2，1。</p><p>那麼最小優先隊列排序應該為："Tom"，"Camila"，"Jack"，"John"。</p><p>最大優先隊列正好相反，把優先級值最大的元素放置在隊列的最前面。</p><p>以上面的為例，最大優先隊列排序應該為："John", "Jack", "Camila", "Tom"。</p><p><strong>實現</strong></p><p>實現一個優先隊列，有兩種選項：</p><ol><li class=ql-indent-1>設置優先級，根據優先級正確添加元素，然後和普通隊列一樣正常移除</li></ol><ul><li><br></li></ul><ol><li class=ql-indent-1>設置優先級，和普通隊列一樣正常按順序添加，然後根據優先級移除</li></ol><p>這裡最小優先隊列和最大優先隊列我都採用第一種方式實現，大家可以嘗試一下第二種。</p><p>下面只重寫 enqueue() 方法和 print() 方法，其他方法和上面的普通隊列完全相同。</p><p><strong>實現最小優先隊列</strong></p><pre>// 定義最小優先隊列function MinPriorityQueue () { this.items = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.isEmpty = isEmpty; this.size = size; this.clear = clear; this.print = print;}</pre><p>實現最小優先隊列 enqueue() 方法和 print() 方法：</p><pre>// 優先隊列添加元素，要根據優先級判斷在隊列中的插入順序function enqueue (element, priority) { var queueElement = { element: element, priority: priority }; if (this.isEmpty()) { this.items.push(queueElement); } else { var added = false; for (var i = 0; i &lt; this.size(); i++) { if (queueElement.priority &lt; this.items[i].priority) { this.items.splice(i, 0, queueElement); added = true; break ; } } if (!added) { this.items.push(queueElement); } }}// 打印隊列裡的元素function print () { var strArr = []; strArr = this.items.map(function (item) { return `${item.element}-&gt;${item.priority}`; }); console.log(strArr.toString());}</pre><p>最小優先隊列測試：</p><pre>// 創建最小優先隊列minPriorityQueue實例var minPriorityQueue = new MinPriorityQueue();console.log(minPriorityQueue.isEmpty()); // trueminPriorityQueue.enqueue("John", 1); // undefinedminPriorityQueue.enqueue("Jack", 3); // undefinedminPriorityQueue.enqueue("Camila", 2); // undefinedminPriorityQueue.enqueue("Tom", 3); // undefinedminPriorityQueue.print(); // "John-&gt;1,Camila-&gt;2,Jack-&gt;3,Tom-&gt;3"console.log(minPriorityQueue.size()); // 4console.log(minPriorityQueue.isEmpty()); // falseminPriorityQueue.dequeue(); // {element: "John", priority: 1}minPriorityQueue.dequeue(); // {element: "Camila", priority: 2}minPriorityQueue.print(); // "Jack-&gt;3,Tom-&gt;3"minPriorityQueue.clear(); // undefinedconsole.log(minPriorityQueue.size()); // 0</pre><p><strong>實現最大優先隊列</strong></p><pre>// 最大優先隊列 MaxPriorityQueue 類function MaxPriorityQueue () { this.items = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.isEmpty = isEmpty; this.size = size; this.clear = clear; this.print = print;}// 優先隊列添加元素，要根據優先級判斷在隊列中的插入順序function enqueue (element, priority) { var queueElement = { element: element, priority: priority }; if (this.isEmpty()) { this.items.push(queueElement); } else { var added = false; for (var i = 0; i &lt; this.items.length; i++) { // 注意，只需要將這裡改為大於號就可以了 if (queueElement.priority &gt; this.items[i].priority) { this.items.splice(i, 0, queueElement); added = true; break ; } } if (!added) { this.items.push(queueElement); } }}</pre><p>最大優先隊列測試：</p><pre>// 創建最大優先隊列maxPriorityQueue實例var maxPriorityQueue = new MaxPriorityQueue();console.log(maxPriorityQueue.isEmpty()); // truemaxPriorityQueue.enqueue("John", 1); // undefinedmaxPriorityQueue.enqueue("Jack", 3); // undefinedmaxPriorityQueue.enqueue("Camila", 2); // undefinedmaxPriorityQueue.enqueue("Tom", 3); // undefinedmaxPriorityQueue.print(); // "Jack-&gt;3,Tom-&gt;3,Camila-&gt;2,John-&gt;1"console.log(maxPriorityQueue.size()); // 4console.log(maxPriorityQueue.isEmpty()); // falsemaxPriorityQueue.dequeue(); // {element: "Jack", priority: 3}maxPriorityQueue.dequeue(); // {element: "Tom", priority: 3}maxPriorityQueue.print(); // "Camila-&gt;2,John-&gt;1"maxPriorityQueue.clear(); // undefinedconsole.log(maxPriorityQueue.size()); // 0</pre><p><strong>循環隊列</strong></p><p><strong>定義</strong></p><p>循環隊列，顧名思義，它長得像一個環。把它想像成一個圓的鐘就對了。</p><p>關鍵是：確定好隊空和隊滿的判定條件。</p><p>循環隊列的一個例子就是擊鼓傳花遊戲（Hot Potato）。在這個遊戲中，孩子們圍城一個圓圈，擊鼓的時候把花盡快的傳遞給旁邊的人。某一時刻擊鼓停止，這時花在誰的手裡，誰就退出圓圈直到遊戲結束。重複這個過程，直到只剩一個孩子（勝者）。</p><p>下面我們在普通隊列的基礎上，實現一個模擬的擊鼓傳花遊戲，下面只寫擊鼓傳花的代碼片段：</p><pre>// 實現擊鼓傳花function hotPotato (nameList, num) { var queue = new Queue(); for (var i = 0; i &lt; nameList.length; i++) { queue.enqueue(nameList[i]); } var eliminated = ''; while (queue.size() &gt; 1) { // 循環 num 次，隊首出來去到隊尾 for (var i = 0; i &lt; num; i++) { queue.enqueue(queue.dequeue()); } // 循環 num 次過後，移除當前隊首的元素 eliminated = queue.dequeue(); console.log(`${eliminated} 在擊鼓傳花中被淘汰！`); } // 最後只剩一個元素 return queue.dequeue();}// 測試var nameList = ["John", "Jack", "Camila", "Ingrid", "Carl"];var winner = hotPotato(nameList, 10);console.log(`最後的勝利者是：${winner}`);</pre><p>執行結果為：</p><pre>// John 在擊鼓傳花中被淘汰！// Ingrid 在擊鼓傳花中被淘汰！ // Jack 在擊鼓傳花中被淘汰！// Camila 在擊鼓傳花中被淘汰！// 最後的勝利者是：Carl</pre><p><strong>隊列小結</strong></p><p>一些具有某些額外特性的隊列，比如：循環隊列、阻塞隊列、併發隊列。它們在很多偏底層系統、框架、中間件的開發中，起著關鍵性的作用。</p><p>以上隊列的代碼要感謝 leocoder351。</p><p><strong>5. 鏈表</strong></p><p><strong>定義</strong></p><ul><li>鏈表存儲有序的元素集合，但不同於數組，鏈表中的元素在內存中並不是連續放置的，它是通過 <strong>指針</strong> 將 <strong>零散的內存塊</strong> 串連起來的。</li><li>每個元素由一個存儲元素本身的 <strong>節點</strong> 和一個指向下一個元素的 <strong>引用</strong>（也稱指針或鏈接）組成。</li></ul><p>簡單的鏈接結構圖：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44a2de338bf143a49e60dab9b759a7b1><p class=pgc-img-caption></p></div><p>其中，data 中保存著數據，next 保存著下一個鏈表的引用。</p><p>上圖中，我們說 data2 跟在 data1 後面，而不是說 data2 是鏈表中的第二個元素。值得注意的是，我們將鏈表的尾元素指向了 null 節點，表示鏈接結束的位置。</p><p><strong>特點</strong></p><ul><li><strong>鏈表是通過指針將零散的內存塊串連起來的</strong>。</li><li>所以鏈表不支持 <strong>隨機訪問</strong>，如果要找特定的項，只能從頭開始遍歷，直到找到某個項。</li><li>所以訪問的時間複雜度為 O(n)。</li><li><strong>高效的插入和刪除</strong>。</li><li>鏈表中插入或者刪除一個數據，我們並不需要為了保持內存的連續性而搬移結點，因為鏈表的存儲空間本身就不是連續的，只需要考慮相鄰結點的指針改變。</li><li>所以，在鏈表中插入和刪除一個數據是非常快速的，時間複雜度為 O(1)。</li></ul><p>三種最常見的鏈表結構，它們分別是：</p><ul><li>單鏈表</li><li>雙向鏈表</li><li>循環鏈表</li></ul><p><strong>單鏈表</strong></p><p><strong>定義</strong></p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44a2de338bf143a49e60dab9b759a7b1><p class=pgc-img-caption></p></div><p>由於鏈表的起始點的確定比較麻煩，因此很多鏈表的實現都會在鏈表的最前面添加一個特殊的節點，稱為 <strong>頭節點</strong>，表示鏈表的頭部。</p><p>經過改造，鏈表就成了如下的樣子：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d01dcdf803e44355acc60374108758f3><p class=pgc-img-caption></p></div><p>針對鏈表的插入和刪除操作，我們只需要考慮相鄰結點的指針改變，所以插入與刪除的時間複雜度為 O(1)。</p><p>在 d2 節點後面插入 d4 節點：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/19d0e2e3f6474009932e60d35586e6c7><p class=pgc-img-caption></p></div><p>刪除 d4 節點：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/66f72b98c0a54e2697f5ac43564fdcee><p class=pgc-img-caption></p></div><p><strong>實現</strong></p><ul><li>Node 類用來表示節點。</li><li>LinkedList 類提供插入節點、刪除節點等一些操作。</li></ul><p>單向鏈表的八種常用操作：</p><ul><li>append(element)：尾部添加元素。</li><li>insert(position, element)：特定位置插入一個新的項。</li><li>removeAt(position)：特定位置移除一項。</li><li>remove(element)：移除一項。</li><li>indexOf(element)：返回元素在鏈表中的索引。如果鏈表中沒有該元素則返回 -1。</li><li>isEmpty()：如果鏈表中不包含任何元素，返回 true，如果鏈表長度大於 0，返回 false。</li><li>size()：返回鏈表包含的元素個數，與數組的 length 屬性類似。</li><li>getHead()：返回鏈表的第一個元素。</li><li>toString()：由於鏈表使用了 Node 類，就需要重寫繼承自 JavaScript 對象默認的 toString() 方法，讓其只輸出元素的值。</li><li>print()：打印鏈表的所有元素。</li></ul><p>具體代碼：</p><pre>// 單鏈表function SinglyLinkedList() { // 節點 function Node(element) { this.element = element; // 當前節點的元素 this.next = null; // 下一個節點指針 } var length = 0; // 鏈表的長度 var head = null; // 鏈表的頭部節點 // 向鏈表尾部添加一個新的節點 this.append = function(element) { var node = new Node(element); var currentNode = head; // 判斷是否為空鏈表 if (head === null) { // 是空鏈表，就把當前節點作為頭部節點 head = node; } else { // 從 head 開始一直找到最後一個 node while (currentNode.next) { // 後面還有 node currentNode = currentNode.next; } // 把當前節點的 next 指針 指向 新的節點 currentNode.next = node; } // 鏈表的長度加 1 length++; }; // 向鏈表特定位置插入一個新節點 this.insert = function(position, element) { if (position &lt; 0 || position &gt; length) { // 越界 return false; } else { var node = new Node(element); var index = 0; var currentNode = head; var previousNode; // 在最前插入節點 if (position === 0) { node.next = currentNode; head = node; } else { // 循環找到位置 while (index &lt; position) { index++; previousNode = currentNode; currentNode = currentNode.next; } // 把前一個節點的指針指向新節點，新節點的指針指向當前節點，保持連接性 previousNode.next = node; node.next = currentNode; } length++; return true; } }; // 從鏈表的特定位置移除一項 this.removeAt = function(position) { if ((position &lt; 0 &amp;&amp; position &gt;= length) || length === 0) { // 越界 return false; } else { var currentNode = head; var index = 0; var previousNode; if (position === 0) { head = currentNode.next; } else { // 循環找到位置 while (index &lt; position) { index++; previousNode = currentNode; currentNode = currentNode.next; } // 把當前節點的 next 指針 指向 當前節點的 next 指針，即是 刪除了當前節點 previousNode.next = currentNode.next; } length--; return true; } }; // 從鏈表中移除指定項 this.remove = function(element) { var index = this.indexOf(element); return this.removeAt(index); }; // 返回元素在鏈表的索引，如果鏈表中沒有該元素則返回 -1 this.indexOf = function(element) { var currentNode = head; var index = 0; while (currentNode) { if (currentNode.element === element) { return index; } index++; currentNode = currentNode.next; } return -1; }; // 如果鏈表中不包含任何元素，返回 true，如果鏈表長度大於 0，返回 false this.isEmpty = function() { return length === 0; }; // 返回鏈表包含的元素個數，與數組的 length 屬性類似 this.size = function() { return length; }; // 獲取鏈表頭部元素 this.getHead = function() { return head.element; }; // 由於鏈表使用了 Node 類，就需要重寫繼承自 JavaScript 對象默認的 toString() 方法，讓其只輸出元素的值 this.toString = function() { var currentNode = head; var string = ''; while (currentNode) { string += ',' + currentNode.element; currentNode = currentNode.next; } return string.slice(1); }; // 打印鏈表數據 this.print = function() { console.log(this.toString()); }; // 獲取整個鏈表 this.list = function() { console.log('head: ', head); return head; };}</pre><p>測試：</p><pre>// 創建單向鏈表實例var singlyLinked = new SinglyLinkedList();console.log(singlyLinked.removeAt(0)); // falseconsole.log(singlyLinked.isEmpty()); // truesinglyLinked.append('Tom');singlyLinked.append('Peter');singlyLinked.append('Paul');singlyLinked.print(); // "Tom,Peter,Paul"singlyLinked.insert(0, 'Susan');singlyLinked.print(); // "Susan,Tom,Peter,Paul"singlyLinked.insert(1, 'Jack');singlyLinked.print(); // "Susan,Jack,Tom,Peter,Paul"console.log(singlyLinked.getHead()); // "Susan"console.log(singlyLinked.isEmpty()); // falseconsole.log(singlyLinked.indexOf('Peter')); // 3console.log(singlyLinked.indexOf('Cris')); // -1singlyLinked.remove('Tom');singlyLinked.removeAt(2);singlyLinked.print(); // "Susan,Jack,Paul"singlyLinked.list(); // 具體控制檯</pre><p>整個鏈表數據在 JavaScript 裡是怎樣的呢 ？</p><p>為了看這個數據，特意寫了個 list 函數：</p><pre>// 獲取整個鏈表 this.list = function() { console.log('head: ', head); return head; };</pre><p>重點上上面的最後一行代碼： singlyLinked.list() ，打印的數據如下：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/95bc066bbf6245efa82354512096e1c6><p class=pgc-img-caption></p></div><p>所以，在 JavaScript 中，單鏈表的真實數據有點類似於對象，實際上是 Node 類生成的實例。</p><p><strong>雙向鏈表</strong></p><p>單向鏈表只有一個方向，結點只有一個後繼指針 next 指向後面的結點。</p><p>而雙向鏈表，它支持兩個方向，每個結點不止有一個後繼指針 next 指向後面的結點，還有一個前驅指針 prev 指向前面的結點。</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86f5e1f83e294417b752a407edf44783><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7cdd1502b73c40479e1948b9c17494f8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c9692b6763a4a2c9a7c784779837186><p class=pgc-img-caption></p></div><p><strong>單向鏈表與又向鏈表比較</strong></p><ul><li>雙向鏈表需要額外的兩個空間來存儲後繼結點和前驅結點的地址。</li><li>所以，如果存儲同樣多的數據，雙向鏈表要比單鏈表佔用更多的內存空間。</li><li>雖然兩個指針比較浪費存儲空間，但可以支持雙向遍歷，這樣也帶來了雙向鏈表操作的靈活性。</li><li>雙向鏈表提供了兩種迭代列表的方法：<strong>從頭到尾，或者從尾到頭</strong>。</li><li>我們可以訪問一個特定節點的下一個或前一個元素。</li><li>在單向鏈表中，如果迭代鏈表時錯過了要找的元素，就需要回到鏈表起點，重新開始迭代。</li><li>在雙向鏈表中，可以從任一節點，向前或向後迭代，這是雙向鏈表的一個優點。</li><li>所以，雙向鏈表可以支持 O(1) 時間複雜度的情況下找到前驅結點，正是這樣的特點，也使雙向鏈表在某些情況下的插入、刪除等操作都要比單鏈表簡單、高效。</li></ul><p><strong>實現</strong></p><p>具體代碼：</p><pre>// 創建雙向鏈表 DoublyLinkedList 類function DoublyLinkedList() { function Node(element) { this.element = element; //當前節點的元素 this.next = null; //下一個節點指針 this.previous = null; //上一個節點指針 } var length = 0; // 鏈表長度 var head = null; // 鏈表頭部 var tail = null; // 鏈表尾部 // 向鏈表尾部添加一個新的項 this.append = function(element) { var node = new Node(element); var currentNode = tail; // 判斷是否為空鏈表 if (currentNode === null) { // 空鏈表 head = node; tail = node; } else { currentNode.next = node; node.prev = currentNode; tail = node; } length++; }; // 向鏈表特定位置插入一個新的項 this.insert = function(position, element) { if (position &lt; 0 &amp;&amp; position &gt; length) { // 越界 return false; } else { var node = new Node(element); var index = 0; var currentNode = head; var previousNode; if (position === 0) { if (!head) { head = node; tail = node; } else { node.next = currentNode; currentNode.prev = node; head = node; } } else if (position === length) { this.append(element); } else { while (index &lt; position) { index++; previousNode = currentNode; currentNode = currentNode.next; } previousNode.next = node; node.next = currentNode; node.prev = previousNode; currentNode.prev = node; } length++; return true; } }; // 從鏈表的特定位置移除一項 this.removeAt = function(position) { if ((position &lt; 0 &amp;&amp; position &gt;= length) || length === 0) { // 越界 return false; } else { var currentNode = head; var index = 0; var previousNode; if (position === 0) { // 移除第一項 if (length === 1) { head = null; tail = null; } else { head = currentNode.next; head.prev = null; } } else if (position === length - 1) { // 移除最後一項 if (length === 1) { head = null; tail = null; } else { currentNode = tail; tail = currentNode.prev; tail.next = null; } } else { while (index &lt; position) { index++; previousNode = currentNode; currentNode = currentNode.next; } previousNode.next = currentNode.next; previousNode = currentNode.next.prev; } length--; return true; } }; // 從鏈表中移除指定項 this.remove = function(element) { var index = this.indexOf(element); return this.removeAt(index); }; // 返回元素在鏈表的索引，如果鏈表中沒有該元素則返回 -1 this.indexOf = function(element) { var currentNode = head; var index = 0; while (currentNode) { if (currentNode.element === element) { return index; } index++; currentNode = currentNode.next; } return -1; }; // 如果鏈表中不包含任何元素，返回 true ，如果鏈表長度大於 0 ，返回 false this.isEmpty = function() { return length == 0; }; // 返回鏈表包含的元素個數，與數組的 length 屬性類似 this.size = function() { return length; }; // 獲取鏈表頭部元素 this.getHead = function() { return head.element; }; // 由於鏈表使用了 Node 類，就需要重寫繼承自 JavaScript 對象默認的 toString() 方法，讓其只輸出元素的值 this.toString = function() { var currentNode = head; var string = ''; while (currentNode) { string += ',' + currentNode.element; currentNode = currentNode.next; } return string.slice(1); }; this.print = function() { console.log(this.toString()); }; // 獲取整個鏈表 this.list = function() { console.log('head: ', head); return head; };}</pre><p>測試：</p><pre>// 創建雙向鏈表var doublyLinked = new DoublyLinkedList();console.log(doublyLinked.isEmpty()); // truedoublyLinked.append('Tom');doublyLinked.append('Peter');doublyLinked.append('Paul');doublyLinked.print(); // "Tom,Peter,Paul"doublyLinked.insert(0, 'Susan');doublyLinked.print(); // "Susan,Tom,Peter,Paul"doublyLinked.insert(1, 'Jack');doublyLinked.print(); // "Susan,Jack,Tom,Peter,Paul"console.log(doublyLinked.getHead()); // "Susan"console.log(doublyLinked.isEmpty()); // falseconsole.log(doublyLinked.indexOf('Peter')); // 3console.log(doublyLinked.indexOf('Cris')); // -1doublyLinked.remove('Tom');doublyLinked.removeAt(2);doublyLinked.print(); // "Susan,Jack,Paul"doublyLinked.list(); // 請看控制檯輸出</pre><p>整個鏈表數據在 JavaScript 裡是怎樣的呢 ？</p><pre>// 獲取整個鏈表 this.list = function() { console.log('head: ', head); return head; };</pre><p>調用 doublyLinked.list(); .</p><p>控制檯輸出如下：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/386f25a4eb43438d9bc9995a19f74c4e><p class=pgc-img-caption></p></div><p>鏈表代碼實現的關鍵是弄清楚：前節點與後節點與邊界。</p><p><strong>循環鏈表</strong></p><p>循環鏈表是一種特殊的單鏈表。</p><p>循環鏈表和單鏈表相似，節點類型都是一樣。</p><p>唯一的區別是，在創建循環鏈表的時候，讓其頭節點的 next 屬性指向它本身。</p><p>即：</p><pre>head.next = head;</pre><p>這種行為會導致鏈表中每個節點的 next 屬性都指向鏈表的頭節點，換句話說，也就是<strong>鏈表的尾節點指向了頭節點，形成了一個循環鏈表</strong>。如下圖所示：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3dd662fd74fd4295b64dd4939dd50916><p class=pgc-img-caption></p></div><p><strong>循環鏈表</strong>：在單鏈表的基礎上，將尾節點的指針指向頭結點，就構成了一個循環鏈表。環形鏈表從任意一個節點開始，都可以遍歷整個鏈表。</p><p>代碼：</p><pre>// 循環鏈表function CircularLinkedList() { // 節點 function Node(element) { this.element = element; // 當前節點的元素 this.next = null; // 下一個節點指針 } var length = 0, head = null; this.append = function(element) { var node = new Node(element), current; if (!head) { head = node; // 頭的指針指向自己 node.next = head; } else { current = head; while (current.next !== head) { current = current.next; } current.next = node; // 最後一個節點指向頭節點 node.next = head; } length++; return true; }; this.insert = function(position, element) { if (position &gt; -1 &amp;&amp; position &lt; length) { var node = new Node(element), index = 0, current = head, previous; if (position === 0) { // 頭節點指向自己 node.next = head; head = node; } else { while (index++ &lt; position) { previous = current; current = current.next; } previous.next = node; node.next = current; } length++; return true; } else { return false; } }; this.removeAt = function(position) { if (position &gt; -1 &amp;&amp; position &lt; length) { var current = head, previous, index = 0; if (position === 0) { head = current.next; } else { while (index++ &lt; position) { previous = current; current = current.next; } previous.next = current.next; } length--; return current.element; } else { return false; } }; this.remove = function(element) { var current = head, previous, indexCheck = 0; while (current &amp;&amp; indexCheck &lt; length) { if (current.element === element) { if (indexCheck == 0) { head = current.next; length--; return true; } else { previous.next = current.next; length--; return true; } } else { previous = current; current = current.next; indexCheck++; } } return false; }; this.remove = function() { if (length === 0) { return false; } var current = head, previous, indexCheck = 0; if (length === 1) { head = null; length--; return current.element; } while (indexCheck++ &lt; length) { previous = current; current = current.next; } previous.next = head; length--; return current.element; }; this.indexOf = function(element) { var current = head, index = 0; while (current &amp;&amp; index &lt; length) { if (current.element === element) { return index; } else { index++; current = current.next; } } return -1; }; this.isEmpty = function() { return length === 0; }; this.size = function() { return length; }; // 由於鏈表使用了 Node 類，就需要重寫繼承自 JavaScript 對象默認的 toString() 方法，讓其只輸出元素的值 this.toString = function() { var current = head, string = '', indexCheck = 0; while (current &amp;&amp; indexCheck &lt; length) { string += ',' + current.element; current = current.next; indexCheck++; } return string.slice(1); }; // 獲取鏈表頭部元素 this.getHead = function() { return head.element; }; // 打印鏈表數據 this.print = function() { console.log(this.toString()); }; // 獲取整個鏈表 this.list = function() { console.log('head: ', head); return head; };}</pre><p>測試：</p><pre>// 創建單向鏈表實例var circularLinked = new CircularLinkedList();console.log(circularLinked.removeAt(0)); // falseconsole.log(circularLinked.isEmpty()); // truecircularLinked.append('Tom');circularLinked.append('Peter');circularLinked.append('Paul');circularLinked.print(); // "Tom,Peter,Paul"circularLinked.insert(0, 'Susan');circularLinked.print(); // "Susan,Tom,Peter,Paul"circularLinked.insert(1, 'Jack');circularLinked.print(); // "Susan,Jack,Tom,Peter,Paul"console.log(circularLinked.getHead()); // "Susan"console.log(circularLinked.isEmpty()); // falseconsole.log(circularLinked.indexOf('Peter')); // 3console.log(circularLinked.indexOf('Cris')); // -1circularLinked.remove('Tom');circularLinked.removeAt(2);circularLinked.print(); // "Susan,Jack,Paul"circularLinked.list(); // 具體控制檯</pre><p>整個鏈表數據在 JavaScript 裡是怎樣的呢 ？</p><pre>// 獲取整個鏈表 this.list = function() { console.log('head: ', head); return head; };</pre><p>調用 circularLinked.list() 。</p><p>控制檯輸出如下：</p><div class=pgc-img><img alt="JavaScript 數據結構與算法之美 - 線性表 數組、棧、隊列、鏈表" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/00871f593aa44ba385fc15e51aaf854f><p class=pgc-img-caption></p></div><p>你知道大家發現沒有，為什麼從 1 - 4 - 1 了，還有 next 節點，而且是還可以一直點 next ，重複的展開下去，這正是 <strong>循環</strong> 的原因。</p><p><strong>鏈表總結</strong></p><ul><li>寫鏈表代碼是最考驗邏輯思維能力的，要熟練鏈表，只有 <strong>多寫多練，沒有捷徑</strong>。</li><li>因為，鏈表代碼到處都是指針的操作、邊界條件的處理，稍有不慎就容易產生 Bug。</li><li>鏈表代碼寫得好壞，可以看出一個人寫代碼是否夠細心，考慮問題是否全面，思維是否縝密。</li><li>所以，這也是很多面試官喜歡讓人手寫鏈表代碼的原因。</li><li>一定要自己寫代碼實現一下，才有效果。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JavaScript</a></li><li><a>數據</a></li><li><a>結構</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html alt=一文看懂編程中的基本數據結構與算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html title=一文看懂編程中的基本數據結構與算法思想>一文看懂編程中的基本數據結構與算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html alt=數據結構與算法（7）遞歸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html title=數據結構與算法（7）遞歸>數據結構與算法（7）遞歸</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>