<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高併發和高性能系統中進程、線程、協程、隊列（如何調度的） | 极客快訊</title><meta property="og:title" content="高併發和高性能系統中進程、線程、協程、隊列（如何調度的） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f41e7ed497b44b618a1df64c6aaa2295"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0b69a5b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0b69a5b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d0b69a5b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0b69a5b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0b69a5b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d0b69a5b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d0b69a5b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0b69a5b.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="高併發和高性能系統中進程、線程、協程、隊列（如何調度的）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d0b69a5b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高併發和高性能系統中進程、線程、協程、隊列（如何調度的）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>這個問題太複雜，我2天時間也沒想明白，這是我大體思路</p><ul><li>第一步知道併發（concurrency） vs 並行（parallelism）區別</li><li>第2️⃣ 步 同步IO和異步IO的區別</li><li>第3️⃣步 需要了解的是 進程 線程</li><li>第四知道的 什麼協程序</li><li>第四liunx 如何調度的</li><li>第五golang 調度實現</li><li>第六FQA</li></ul><div class=pgc-img><img alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f41e7ed497b44b618a1df64c6aaa2295><p class=pgc-img-caption>系統最大支持多少進程，線程，協程</p></div><div class=pgc-img><img alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74868a7f1fca4c428bad4a46af538ba1><p class=pgc-img-caption></p></div><p><strong>end 結束 ，我理解正在碼字中</strong></p><p><strong>下面別人總結，基本的說明，但是沒說點子上。</strong></p><hr><p>互聯網應用系統開發肯定經常會看到高併發和高性能這兩個詞，可謂是耳熟能詳，而具體的含義和關係真的如你所想的，真正的理解了嗎？</p><p>這次，我也結合自己的理解，來跟大家分享一下。</p><div class=pgc-img><img alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a8540e9830147e6b448cd64cf789409><p class=pgc-img-caption></p></div><h1>先來看一個例子：</h1><p>一個蓄水池，是1m*1m*1m=1立方米大小，有一個出水口，出水口每秒鐘流出0.1立方米，那麼這個蓄水池的併發量是1立方米，出水速度是0.1立方米/秒。</p><p>如果增加一個出水口，都是每秒鐘流出0.1立方米，那麼這個蓄水池的併發量沒變，但是出水速度變成了0.2立方米/秒。</p><p>同理，增大了出水口，蓄水池的出水速度也變快了。</p><p>上面我們很容易知道，併發量是一個容量的概念，性能就是出水速度，而且有下面這些結果。</p><p>1 增大蓄水池的長寬高，可以增加併發能力。</p><p>2 出水口如果擴大了出口大小，則可以提高出水的速度，也就是性能提高了。</p><p>3 增加出水口的數量，則是增加了並行處理的能力，同樣可以提高性能。</p><h1>那麼對照我們計算機中，我們的系統中，是怎麼樣的結果呢？</h1><blockquote><p>1 增加服務器的內存大小，可以增加併發量。因為內存增加了，就可以開更多的進程，更多的線程，也可以擴大任務隊列的大小。</p><p>2 提高cpu的主頻速度，優化程序，可以提高性能。cpu更快了，程序優化的更好了，處理單個任務的時間也就更短了。</p><p>3 增加多核甚至分佈式服務器數量，也可以提高性能，同時提高併發量。</p></blockquote><p>如果只是性能提高了，併發量是否也能提高呢？</p><p>如果我們靜態的理解併發量，那它是不會提高的。</p><p>而我更願意動態的來理解併發量，即：單位時間內可以進來的最大數量。</p><p>那麼提高性能，是可以線性提高併發量的，因為單位時間內，進來的同時也有出去。</p><p>接下來，再來具體的分析下，上面的幾種結果，是不是真的可以實現呢？是不是完全正確呢？</p><p>我們先來做一個假設，單個進程內存佔用10M，單個線程內存佔用2M，單個協程內存佔用20K，隊列任務內存佔用2K，我們下面來看看內存與併發量的關係。</p><p>（具體的內存佔用大小在不同的應用場景中會有很大的不同，所以這裡只是為了方便計算而做的一個假設）</p><blockquote><p>內存量 進程數 線程數 協程 隊列任務</p><p>1G 100 500 50K 500K</p><p>2G 200 1000 100K 1000K</p><p>4G 400 2000 200K 2000K</p><p>8G 800 4000 400K 4000K</p></blockquote><p>對應的幾種運行模式</p><p>多<strong>進程： php fast-cgi</strong></p><p><strong>多線程： java web</strong></p><p><strong>協程： go</strong></p><p><strong>隊列： nginx</strong></p><p>從上面的結果中，我們可以很直觀的看出來，併發能力在不同的運行模式中的巨大區別。</p><ul><li>多進程和多線程的模式，不僅是內存開銷巨大，而且在數量不斷增加的情況下，對CPU的壓力也是非常巨大，這也是為什麼這類系統在併發量大的情況下會很不穩定，甚至宕機。</li></ul><p>上面假設中計算出來的數據，都是靜態的容量，如果所有任務都不處理，那麼肯定都是會很快就被撐爆。</p><p>所以要達到更高的併發量，就需要有更快的處理速度，即做好性能優化。</p><h1>下面，再來做一個假設。</h1><p>我們現在有一臺服務器，配置是8核16G內存。</p><blockquote><p>如果我們的應用是計算密集型，純運算的系統，如：數據索引查詢、排序等操作。</p><p>而且還要假設，這個應用在多核並行運算時不存在鎖競爭的情況（只讀）。</p></blockquote><p>qps=1000ms/單個請求耗時*8</p><p>如果單個請求（任務）耗時100ms，那麼我們可以計算出來</p><p>qps=1000ms/100ms*8=80個/秒</p><p>如果我們優化處理的算法，單個請求耗時降低到10ms，那麼</p><p>qps=1000ms/10ms*8=800個/秒</p><p>如果可以繼續優化，將單個請求耗時降低到1ms，那麼</p><p>qps就可以達到更高的8k。</p><p>上面的情況和優化的效果理解起來應該很容易，因為對服務器資源的依賴更多是CPU的運算能力和數量。</p><h1>【進程介紹】</h1><p>每一個應用運行起來都會有自己的進程，因為進程是系統資源分配的基本單位。</p><p>在線程出現之前，進程也是CPU調度的基本單位。</p><p>每一個進程創建出來，都會分配三種基本的<strong>內存資源，分別是代碼段、數據段和堆棧段</strong>。</p><p>代碼段和數據段分別保存著應用的執行代碼和全局變量、常量、靜態變量，這些就是不會變化或者很少變化的內容，當然內存佔用相對也會比較少。</p><p>而應用運行起來，需要的更多資源就會在堆棧中用到。</p><p>其中堆空間是存放各種變量數據的地方，內存大小也是可以動態調整的。</p><p>而棧空間是子任務（線程、協程）獨立存放自己的數據地方，比如：函數調用、參數、返回值和局部變量。</p><p>這樣一來，子任務（線程、協程）之間就可以獨立運行，而且還可以共享堆空間中的變量數據。</p><div class=pgc-img><img alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8fe20d75eef0446099f393981d64ff47><p class=pgc-img-caption></p></div><h1>【線程介紹】</h1><p>線程在新的操作系統中，也稱為輕量級進程，因為現在的線程已經是CPU調度的基本單位了。</p><p>操作系統不僅僅維持一個進程表，而且還會維持一個線程表，這樣操作系統就可以把線程作為調度單位。</p><p>線程是進程內創建，可以共享進程的資源，所以，線程自身獨立的資源依賴就會少很多，因為只需要為每個線程分配獨立的棧空間。</p><p>而線程的棧空間是固定大小的，如果程序比較複雜，或者裡面的數據量大，為了不出現“棧空間不足”的錯誤，就必須把棧空間設置的足夠大才行。</p><p>於是，線程是固定的棧空間S（足夠大），總共運行多少線程T，佔用總的棧空間就可以簡單計算出來=T*S。</p><p>這個資源佔用量相對T個進程來說，還是少了很多的，畢竟線程是共享了進程的代碼段、數據段和堆空間。</p><div class=pgc-img><img alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2f608414106f44a0b5e7dd197613aa06><p class=pgc-img-caption></p></div><h1>【協程介紹】</h1><p>協程是可以在應用態協作的程序，它的調度不是操作系統處理，而是應用系統自己來調度處理，也稱為輕量級線程。</p><p>在操作系統可以獨立調度線程之前，在線程還是作為應用的程序包，有應用程序自己調度和管理的時候，其實那種線程也就跟現在的協程是一個概念了。</p><p>所以，這裡我們就不再講以前的那種應用內的線程，只講新的協程。</p><p>如果說到線程，就是新的可以被操作系統獨立調度的線程。</p><p>協程作為應用系統內調度的子任務單元，當然也是會共享進程的各種資源，除了自己的棧空間（函數調用、參數、返回值、局部變量）。</p><p>而協程與線程主要的區別有兩個，最大的就是調度方式，線程是操作系統調度，協程是應用系統自己調度。</p><p>另外一個區別，協程的棧空間是可以動態調整的，這樣空間利用率就可以更高，一個任務需要2K空間就分配2K內存，一個任務需要20M空間就分配20M，而不用擔心棧空間不夠或者空間浪費。</p><p>由於上面的兩個原因，協程的優勢也就凸顯出來。</p><p>1 協程可以更好的利用CPU，不用把CPU浪費在線程調度和上下文切換上。</p><p>2 協程可以更好的利用內存，不用全都分配一個偏大的空間，只需要分配需要的對應空間即可。</p><div class=pgc-img><img alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f85b4cf4ec24f9ba51fea8fdf25f216><p class=pgc-img-caption></p></div><p>libco的特性</p><ul><li>無需侵入業務邏輯，把多進程、多線程服務改造成協程服務，併發能力得到百倍提升;</li><li>支持CGI框架，輕鬆構建web服務(New);</li><li>支持gethostbyname、mysqlclient、ssl等常用第三庫(New);</li><li>可選的共享棧模式，單機輕鬆接入千萬連接(New);</li><li>完善簡潔的協程編程接口</li><li>類pthread接口設計，通過co_create、co_resume等簡單清晰接口即可完成協程的創建與恢復；</li><li>__thread的協程私有變量、協程間通信的協程信號量co_signal (New);</li><li>語言級別的lambda實現，結合協程原地編寫並執行後臺異步任務 (New);</li><li>基於epoll/kqueue實現的小而輕的網絡框架，基於時間輪盤實現的高性能定時器;</li></ul><p>【隊列介紹】</p><p>這裡的隊列不是獨立的消息隊列服務，而只是應用中維持數據的一個隊列，很多時候會是一個數組或者鏈表。</p><p>隊列裡面保存的也不是一個子任務，而只是一個數據，具體這個數據拿出來之後要啟動什麼子任務，這個隊列是不關心的。</p><p>隊列只是一個緩衝帶，把更多的獨立數據先臨時保持住，應用系統有多大的能力消化吸收就從裡面用多快的速度進行處理。</p><p>從上面可以看出，隊列比協程還要簡單，都沒有所謂各自獨立的子任務，也就沒有了獨立的棧空間。</p><p>所以，這樣的簡化，也就帶來了更少的資源開銷，更少的任務調度。</p><p>接下來，我們結合實際中的幾種運行模式來介紹下現狀和發展。</p><h1>【多進程：php fast-cgi】</h1><p>php在使用fast-cgi之前，更多是多線程模式，為什麼轉而回到多進程模式呢？</p><p>多線程模式是為每個網絡請求創建一個線程來處理這個請求，當請求執行結束，再銷燬這個線程。</p><p>於是，當網站的請求量高的時候，意味著反覆的為這些請求創建和銷燬線程，這個開銷就變得比較大，效率也就下降了。</p><p>在多進程模式下，進程是複用的，不會反覆的創建和銷燬，所以就沒有之前多線程模式那樣大的資源浪費了。</p><p>當然，多進程的問題就像上面說到的，內存開銷大，系統調度開銷大，所以也就意味著併發量相對就會比較小。</p><p>所以，新的php swoole框架也把協程引入進來，同時把多路複用的epoll網絡模型引入進來，這樣就帶來了很明顯的好處。</p><p>1 協程佔用內存小，可以同時維持更多的併發請求。</p><p>2 epoll網絡模型非阻塞而且系統開銷少，可以更好的利用CPU資源，同時避免了網絡IO阻塞影響整體的任務執行。</p><h1>【多線程：java web】</h1><p>java多線程的運行模式用到線程池的技術，並不是每個請求都會啟動一個線程來處理，而是複用線程池中的線程，這樣也就類似上面php fast-cgi模式，很好的避免了線程頻繁創建和銷燬所帶來的損耗。</p><p>線程比進程更輕量，所以單個線程的內存佔用會比單個進程少，但是因為線程棧空間固定，在一些個別請求中，數據量很大，也可能會不得已要設置較大的棧空間，這樣一來，內存浪費也是會比較嚴重了。</p><p>在之前的文章《認識IO的問題才能更好的設計和開發出高併發和高性能的系統》，也有提到，java中更好支持IO密集型的框架，可以用netty，同樣是支持多路複用的epoll模型，也簡化了自己去實現NIO的過程。</p><p>kotlin.corouties 瞭解一下，簡化的JAVA，1.3版本會發布協程的正式線上支持。</p><h1>【協程：go】</h1><p>go原生的支持協程，並且有完善的協程調度器，讓協程在開發和運行時變得更加簡單和高效。</p><p>作為新的開發語言，普及還需要時間，在網絡編程的系統中，還是非常有競爭力的。</p><p>一步到位的支持高併發和高性能，說的太多就怕它驕傲了（站在巨人肩膀上，新思維、新技術）。</p><h1>【隊列：nginx】</h1><p>nginx實際是一個master+多個worker，也算是多進程模式。但是work是單線程的，卻可以支持超高的網絡併發量，這就是nginx內部實際就是一個網絡事件隊列。</p><p>每個請求進來都是一個connection，然後這個connection就通過epoll_ctl註冊到系統的網絡IO事件中，當connection的網絡事件準備好了才通過回調函數放到已就緒隊列中。</p><p>而nginx就是epoll_wait不斷的輪詢這個就緒隊列，然後再處理這裡的事件。</p><p>網絡請求的處理又有很多的階段，每個階段又可以有多個nginx模塊來處理，這些nginx模塊就是各個真正的任務處理系統。</p><p>nginx除了反向代理以及作為靜態WEB服務器，也可以作為應用服務器，比如利用ngx_lua模塊，就可以對WEB請求做實時動態的處理，來完成一個動態服務。</p><p>這樣一來，nginx把網絡請求放到事件隊列中，ngx_lua利用協程把各個請求動態執行，也就可以高效的達到一個應用服務器的效果了，而且併發、性能也非常好。</p><p>【總結】</p><p>從上面幾種模式中，我們都看到協程在新的框架、模塊中用的越來越多，而且也確實能非常明顯的提高系統的併發量。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>系統</a></li><li><a>進程</a></li><li><a>線程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html alt="PHP 線程，進程和併發" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7a700a857098411d884a928d6b5f5e01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html title="PHP 線程，進程和併發">PHP 線程，進程和併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html alt=一文讀懂什麼是進程、線程、協程（建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6ba8b142-925e-418e-b20c-71e8f3c20663 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html title=一文讀懂什麼是進程、線程、協程（建議收藏）>一文讀懂什麼是進程、線程、協程（建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html alt=併發最基本要理解的進程、線程、協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f756a3627164d4f93883dd7c0e0bac5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html title=併發最基本要理解的進程、線程、協程>併發最基本要理解的進程、線程、協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/79e23cb7.html alt=如何理解：程序、進程、線程、併發、並行、高併發？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b101e22357854a56abf29c0745b5d9c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/79e23cb7.html title=如何理解：程序、進程、線程、併發、並行、高併發？>如何理解：程序、進程、線程、併發、並行、高併發？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf2fb099.html alt=看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/12861a08-8f52-48c2-9b25-46df51894677 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf2fb099.html title=看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏）>看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c40a49b9.html alt=線程與進程的區別以及對多線程併發的理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/813488ac38be43b29140e4917ff1e0b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c40a49b9.html title=線程與進程的區別以及對多線程併發的理解>線程與進程的區別以及對多線程併發的理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f2bf674.html alt=進程、線程、協程的選擇與文件併發操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/622e63700f544942809d9a374757630e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f2bf674.html title=進程、線程、協程的選擇與文件併發操作>進程、線程、協程的選擇與文件併發操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fc01cfc.html alt=進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fc01cfc.html title=進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫>進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b8a6681.html alt=進程與線程的區別和併發編程要素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b8a6681.html title=進程與線程的區別和併發編程要素>進程與線程的區別和併發編程要素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b97e222b.html alt=進程、線程、並行與併發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5e04293de8fb49f19388e78a9812cce4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b97e222b.html title=進程、線程、並行與併發>進程、線程、並行與併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/713e034e.html alt=《操作系統原理》實驗一：進程調度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ab086232c51f49b3a24e3ade7c99d9ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/713e034e.html title=《操作系統原理》實驗一：進程調度>《操作系統原理》實驗一：進程調度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9911d0f.html alt=程序，進程，線程與併發和並行設計實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/165d54ca-9361-4365-9d4b-12a56bebfc33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9911d0f.html title=程序，進程，線程與併發和並行設計實現>程序，進程，線程與併發和並行設計實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36bccf4.html alt=操作系統之進程的描述與控制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1543401449766b1a896001c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36bccf4.html title=操作系統之進程的描述與控制>操作系統之進程的描述與控制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/399bf08.html alt="線程，進程，協程， 併發，並行，同步，異步概念解析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/41ca5e6e9b914e628478b8262ae96e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/399bf08.html title="線程，進程，協程， 併發，並行，同步，異步概念解析">線程，進程，協程， 併發，並行，同步，異步概念解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html alt=電廠直流系統調試方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e8200036f19e04c25bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html title=電廠直流系統調試方案>電廠直流系統調試方案</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>