<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java必背綜合知識點總結(業務場景篇) | 极客快訊</title><meta property="og:title" content="java必背綜合知識點總結(業務場景篇) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0ea0395.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0ea0395.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d0ea0395.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0ea0395.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0ea0395.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d0ea0395.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d0ea0395.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d0ea0395.html><meta property="article:published_time" content="2020-10-29T21:12:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:38+08:00"><meta name=Keywords content><meta name=description content="java必背綜合知識點總結(業務場景篇)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d0ea0395.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java必背綜合知識點總結(業務場景篇)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>業務場景篇</strong></h1><p><strong>一、Spring的概述</strong></p><p>Spring 是完全面向接口的設計，降低程序耦合性，主要是事務控制並創建bean實例對象。在ssh整合時，充當黏合劑的作用。IOC(Inversion of Control) 控制反轉/依賴注入，又稱DI(Dependency Injection) (依賴注入)</p><p>IOC的作用：產生對象實例，所以它是基於工廠設計模式的</p><p>Spring IOC的注入</p><p>通過屬性進行注入，通過構造函數進行注入，</p><p>注入對象數組 注入List集合</p><p>注入Map集合 注入Properties類型</p><p>Spring IOC 自動綁定模式：</p><p>可以設置autowire按以下方式進行綁定</p><p>按byType只要類型一致會自動尋找，</p><p>按byName自動按屬性名稱進行自動查找匹配.</p><p>AOP 面向方面（切面）編程</p><p>AOP是OOP的延續，是Aspect Oriented Programming的縮寫，</p><p>意思是面向方面(切面)編程。</p><p>注：OOP(Object-Oriented Programming ) 面向對象編程</p><p>AOP 主要應用於日誌記錄，性能統計，安全控制,事務處理（項目中使用的）等方面。</p><p>Spring中實現AOP技術：</p><p>在Spring中可以通過代理模式來實現AOP</p><p>代理模式分為</p><p>靜態代理：一個接口，分別有一個真實實現和一個代理實現。</p><p>動態代理：通過代理類的代理，接口和實現類之間可以不直接發生聯繫，而 可以在運行期（Runtime）實現動態關聯。</p><p>動態代理有兩種實現方式，可以通過jdk的動態代理實現也可以通過cglib</p><p>來實現而AOP默認是通過jdk的動態代理來實現的。jdk的動態代理必須要有</p><p>接口的支持，而cglib不需要，它是基於類的。</p><p>Spring AOP事務的描述：</p><p>在spring-common.xml裡通過aop:config裡面先設定一個表達式，設定對service裡那些方法 如：對add* ,delete*,update*等開頭的方法進行事務攔截。我們需要配置事務的傳播（propagation=“REQUIRED”）特性,通常把增,刪,改以外的操作需要配置成只讀事務（read-only=“true”）.只讀事務可以提高性能。之後引入tx:advice,在tx:advice引用 transactionManager（事務管理）,在事務管理裡再引入sessionFactory,sessionFactory注入 dataSource，最後通過aop:config 引入txAdvice。</p><p>Spring實現ioc控制反轉描述：</p><p>原來需要我們自己進行bean的創建以及注入，而現在交給</p><p>spring容器去完成bean的創建以及注入。</p><p>所謂的“控制反轉”就是 對象控制權的轉移，</p><p>從程序代碼本身轉移到了外部容器。</p><p>官方解釋:</p><p>控制反轉即IoC (Inversion of Control)，</p><p>它把傳統上由程序代碼直接操控的對象的調用權交給容器，</p><p>通過容器來實現對象組件的裝配和管理。</p><p>所謂的“控制反轉”概念就是對組件對象控制權的轉移，</p><p>從程序代碼本身轉移到了外部容器。</p><p><strong>二、事務概述</strong></p><p>在數據庫中,所謂事務是指一組邏輯操作單元即一組sql語句。當這個單元中的一部分操作失敗,整個事務回滾，只有全部正確才完成提交。</p><p>判斷事務是否配置成功的關鍵點在於出現異常時事務是否會回滾</p><p>事務的ACID屬性</p><ol><li>原子性（Atomicity）</li><li>原子性是指事務是一個不可分割的工作單位，事務中的操作要麼都發生，</li><li>要麼都不發生。</li><li>一致性（Consistency）</li><li>事務必須使數據庫從一個一致性狀態變換到另外一個一致性狀態。(數據不被破壞)</li><li>隔離性（Isolation）</li><li>事務的隔離性是指一個事務的執行不能被其他事務干擾.</li><li>持久性（Durability）</li></ol><p>持久性是指一個事務一旦被提交，</p><p>它對數據庫中數據的改變就是永久性的.即使系統重啟也不會丟失.</p><p>在JDBC中，</p><p>事務默認是自動提交的，</p><p>每次執行一個 SQL 語句時，如果執行成功，</p><p>就會向數據庫自動提交，而不能回滾</p><p>為了讓多個 SQL 語句作為一個事務執行：</p><p>（1）執行語句前調用 Connection 對象的 setAutoCommit(false);</p><p>以取消自動提交事務</p><p>（2）在所有的 SQL 語句都成功執行後，調用 commit(); 方法提交事務</p><p>（3）在出現異常時，調用 rollback(); 方法回滾事務。</p><p><strong>三、權限概述</strong></p><p>權限涉及到5張表：</p><p>用戶表，角色表，權限表(菜單表)，用戶角色關聯表，角色權限關聯表</p><p>當用戶登錄時，根據用戶名和密碼到用戶表驗證信息是否合法，如果合法</p><p>則獲取用戶信息，之後根據用戶id再到用戶角色關聯表中得到相關連的角色</p><p>id集合,之後根據角色id再到角色權限關聯表中獲取該角色所擁有的權限id集合，</p><p>然後再根據權限id集合到權限表（菜單表）中獲取具體的菜單，展現給當前</p><p>登錄用戶，從而達到不同用用戶看到不同的菜單權限。</p><p>我們通過ZTree來給角色賦權並且通過ZTree來展示菜單，以及通過ZTree來管 理菜單即增加和編輯菜單。</p><p>我們做的權限控制到url級別,為了防止用戶不登錄直接輸入url訪問的這個弊端，通過攔截器進行攔截驗證。</p><p><strong>四、OSCache業務場景</strong></p><p>在我以前的項目中，我們考慮了系統性能問題，這個時候我們採用了Oscache緩存，剛開始把這個功能交給了項目組中的另外一個同事來做的，但是他做完的時候他發現緩存中明明已經緩存了數據，但是在取得時候發現沒有數據，我們項目經理讓我去幫忙看看這個問題，我閱讀完他的代碼之後，我發現了他每次緩存的時候都是調用一個新的緩存對象的方法，結果出現了明明已經走了緩存的方法而取不到數據的問題，通過我多年的工作經驗，我就想到了應該用單例模式去封裝一個單例工具類來調用oscache。但是，在後來的測試過程中，發現當併發訪問的時候也會出現上述的問題，這個時候我直接採取的DCL（雙重判定鎖）單例模式封裝了工具類，既解決了線程安全問題，相對的性能問題也考慮到了，這個問題才得到了完善的解決。</p><p><strong>五、線程概述</strong></p><p>線程的狀態以及狀態之間的相互轉換：</p><p>1、新建狀態(New)：新創建了一個線程對象。</p><p>2、就緒狀態(Runnable)：線程對象創建後，其他線程調用了該對象的start()方法。該狀態的線程位於可運行線程池中，變得可運行，等待獲取CPU的使用權。</p><p>3、運行狀態(Running)：就緒狀態的線程獲取了CPU，執行程序代碼。</p><p>4、阻塞狀態(Blocked)：阻塞狀態是線程因為某種原因放棄CPU使用權，暫時停止運行。直到線程進入就緒狀態，才有機會轉到運行狀態。阻塞的情況分三種：</p><p>(一)、等待阻塞：運行的線程執行wait()方法，JVM會把該線程放入等待池中。</p><p>(二)、同步阻塞：運行的線程在獲取對象的同步鎖時，若該同步鎖被別的線程佔用，則JVM會把該線程放入鎖池中。</p><p>(三)、其他阻塞：運行的線程執行sleep()或join()方法，或者發出了I/O請求時，JVM會把該線程置為阻塞狀態。當sleep()狀態超時、join()等待線程終止或者超時、或者I/O處理完畢時，線程重新轉入就緒狀態。</p><p>5、死亡狀態(Dead)：線程執行完了或者因異常退出了run()方法，該線程結束生命週期。</p><p>實現線程的兩種方式：</p><p>是繼承Thread類或實現Runnable接口，但不管怎樣，當new了這個對象後，線程就已經進入了初始狀態</p><p>wait和sleep的區別：</p><p>線程訪問：</p><p>鎖池狀態，之後等待鎖釋放，然後訪問代碼</p><p>wait</p><p>等待隊列(釋放資源)—>調用notify或者notifyall之後鎖池狀態—>( 等待鎖釋放)—>可運行狀態—>運行狀態---->訪問代碼</p><p>sleep,join</p><p>不釋放資源–>結束後直接進入可運行狀態—>運行狀態---->訪問代碼</p><p>一個java控制檯程序，默認運行兩個線程，一個主線程，一個垃圾回收線程。</p><p>線程與進程的區別：</p><p>1.線程(Thread)與進程(Process)</p><p>進程定義的是應用程序與應用程序之間的邊界，通常來說一個進程就代表一個與之對應 的應用程序。不同的進程之間不能共享代碼和數據空間，而同一進程的不同線程可以共 享代碼和數據空間。</p><p>2.一個進程可以包括若干個線程，同時創建多個線程來完成某項任務，便是多線程。</p><p><strong>六、Ajax請求Session超時問題</strong></p><p>我在做項目時有時會遇到session超時問題，如果session超時，平常請求沒有什麼問題，通過攔截器可以正確跳到登陸頁面，可是你如果用ajax請求的話這就出現問題了，因為ajax是異步的，局部刷新，所以登陸界面不會再全頁面中顯示，他只會顯示到頁面的一部分當中。所以根據我這幾年的經驗找到了我認為比較好的一種方法。因為那我用的框架是和struts2集成的，所以就在攔截器中進行設置：</p><p>首先判斷session是否為空就是判斷session是否超時，如果超時就取出請求的head頭信息request.getHeader(“x-requested-with”)，如果不為空就和XMLHttpRequest(Ajax標識)進行比較 (request.getHeader(“x-requested-with”).equalsIgnoreCase(“XMLHttpRequest”))) 如果相等說明此請求是ajax請求。</p><p>如果是ajax請求就可以用response.setHeader(“鍵”,“值”)來設置一個標識來告訴用戶這是ajax請求並且session超時時發出的，這樣我就可以在回調函數中取出自己設置的那個唯一標識：XMLHttpRequest.getResponseHeader("");如果取出的值是和自己在後臺中設置的值一樣的話，就證明session已經超時，這樣就可以設置window.location.replace(“登陸界面”)，來跳轉到登陸界面了。</p><p>這樣做雖然解決了問題，但是，會在每個回調函數中寫入那些代碼，這樣的話代碼就會顯得特別零散，所以就想能不能定義一個全局的設置所以就找到了jqery的ajaxSetUp方法，通過ajaxSetUp對jqery的ajax進行全局的判斷(ajaxSetUp就相當於ajax的攔截器)，通過設置ajaxSetUp裡的complete，它就相當於回調函數，這樣那就彌補了上一方法的不足。</p><p>我做項目時還用到(document).ajaxStart()，這是ajax請求時的事件；</p><p>(<em>document</em>).<em>ajaxStart</em>()，這是<em>ajax</em>請求時的事件；(document).ajaxSuccess()，這是AJAX請求成功後的事件。我一般用他們來顯示遮罩層和隱藏遮罩層用的加遮罩層是為了不讓用戶重複提交，更提高了用戶體驗度，讓用戶知道已經提交了。</p><p><strong>七：java線程池概述</strong></p><p>java線程池的工作原理和數據庫連接池的差不多，因為每次重新創建線程</p><p>都是很耗資源的操作，所以我們可以建立一個線程池，這樣當需要用到線程</p><p>進行某些操作時，就可以直接去線程池裡面找到空閒的線程，這樣就可以直接</p><p>使用，而不用等到用到的時候再去創建，用完之後可以把該線程重新放入線程池</p><p>供其他請求使用從而提高應用程序的性能。</p><p>線程池的核心流程:</p><p>1.構建一個 ThreadPoolExecutor 並指定默認要創建的線程的數量</p><p>2.通過 threadPool.execute()</p><p>去添加一個個要執行的線程即實現了Runable接口的java類</p><p>3.在實現了Runable接口的java類的run方法中寫入具體的業務代碼</p><p>線程池的業務場景：</p><p>我在工作的時候，當時一個同事給我提了一個需求，目前有大量的圖片</p><p>需要處理生產縮略圖並進行加水印，因為按照普通的處理方法一個個的</p><p>進行處理太慢了，問我有沒有好的解決方案，這個時候我就想到了java中</p><p>的線程池，我構建了一個線程數為5個線程池，然後採用分段批量提取的</p><p>方式每500條為一組數據進行圖片信息的提取，然後再把這些通過Threadpool的</p><p>execute方法交給線程池中的線程進行處理，即充分使用了CPU硬件資源又加快</p><p>了大數據情況下程序的處理效率。</p><p>我當時在工作的過程中，認識一個做電商的朋友，他們當時公司才起步，很多</p><p>技術都不成熟，所以就常常和我探討一些技術問題，有次他向我請教一個問題，</p><p>問我如何才能提高網站的性能，我根據自己在項目中的經驗以及自己以前閱讀的</p><p>關於優化方面的資料給他提出了很多建議，如用lucene進行全文檢索，用memcached</p><p>進行分佈式緩存，以及通過spring定時器結合freeMarker模板引擎來生成靜態</p><p>頁面，由於要生成的頁面的數量比較多，考慮到程序的性能，我建議他結合</p><p>java的線程池進行工作，這樣就可以充分使用了CPU硬件資源又加快</p><p>了大數據情況下程序的處理效率。</p><p><strong>八、OSCache概述</strong></p><p>oscache是一個高性能的j2ee框架，可以和任何java代碼進行集成，並且還可以通過標籤對頁面內容進行緩存，還以緩存請求。</p><p>我們通常將那些頻繁訪問但是又不是經常改變的數據進行緩存。為了保證緩存數據的有效性，在數據發生改變的時候，我們要刷新緩存，避免髒數據的出現。刷新緩存的策略有兩種，一種是定時刷新，一種手動刷新。</p><p>緩存數據的時機通常也分為兩種，即在tomcat(web容器)啟動時候加載數據進行緩存，另外也可以在用戶第一次訪問數據的時候進行緩存，這個相當於緩存的立即加載和按需加載。</p><p>緩存的層次如下:jsp–>action–>service–>dao,緩存越靠前對性能的提升越大</p><p>一個action裡面可以有多個service,一個service中可以有多個dao或者多個service</p><p>任何類之間都可以進行相互調用，可以通過構造函數傳參，set,get傳參或者是方法傳 參將相關的類連接起來。</p><p><strong>九、OSCache+autocomplete+單例業務場景</strong></p><p>在我以前做某項目的過程中，其中我們在做產品列表的查詢的時候為了提高用戶的體驗度，我們使用了autocomplete插件來代替select進行品牌的選擇，才開始的時候每次都要根據用戶輸入的信息去查詢數據庫進行模糊匹配返回結果，後來我們考慮到系統的性能，因此我們採用了oscache緩存，才開始這個功能是交給我們項目組中的另外一個同事來做的，但是他做完後，我們在使用這個工具類的時候，發現有時緩存中明明已經有時我們需要的數據，但是從緩存裡面取的時候，發現沒有，之後項目經理讓我去幫這個同事看看這個問題，我經過閱讀他的代碼發現，它裡面在使用緩存的時候，針對於每次方法的調用都產生一個新的實例，結果導致了上面的問題，這個時候我想起了可以使用設計模式中的單例模式來解決這個問題，才開始我直接採用了普通的單列模式，但是後來在測試的過程中，發現當用戶併發量大的時候還是會出現上面的問題，之後我再次考慮了代碼，最後發現是因為沒有給單列模式加鎖的原因，從而導致了大用戶併發的時候，線程安全的問題，之後我便在方法上加上了synchronized關鍵字，解決上述的問題，但是後來測試人員反饋，覺的這段的性能有問題，我考慮之後便採用在方法體內加鎖並結合雙重判定的方式解決了上面的問題。我們是將數據在tomcat啟動的時候加載到緩存中，之後用戶進行查詢的時候直接從緩存中獲取數據，根據前綴匹配進行查詢，將結果返回給用戶。這樣在提高用戶體驗度的同時也提高性能。</p><p><strong>十、緩存概述</strong></p><p>應用程序為了提高性能，可以通過使用緩存來達到目的，緩存的存儲介質可以</p><p>內存或者硬盤，通常將數據存儲在內存裡，確切的說是jvm的內存中，緩存是</p><p>基於Map這種思想構建的，以鍵值對的方式進行存取，之所以還可以將</p><p>緩存的數據存儲在硬盤中，是因為內存資源相當有限和寶貴，所以當內存資源</p><p>不足的時候，就可以將其存儲到硬盤中，雖然硬盤的存取速度比內存要慢，但是</p><p>因為減少了網絡通信量，所以還是提高程序的性能。緩存可以分為客戶端緩存和</p><p>服務器端緩存，所謂的客戶端緩存通常指的是IE瀏覽器的緩存，服務器端緩存指</p><p>的web服務器的緩存，通常可以通過第三方組件實現，如oscache,memcache</p><p>我們通常將那些頻繁訪問但是又不是經常改變的數據進行緩存。為了保證緩存數據的</p><p>有效性，在數據發生改變的時候，我們要刷新緩存，避免髒數據的出現。刷新緩存的</p><p>策略有兩種，一種是定時刷新，一種手動刷新。</p><p>緩存的層次如下:jsp–>action–>service(通常放置在service)–>dao,</p><p>緩存越靠前對性能的提升越大</p><p>緩存的策略:(緩存空間不足需要進行清理的時候使用)</p><p>LRU:最近最少使用原則.(理解:存儲書)</p><p>FIFO:先進先出的緩存策略.(理解:排隊)</p><p>你來說說緩存？說說你對緩存的理解（如果遇到重複的，就可以省略）</p><p>我們在項目中使用緩存的目的是為了提高應用程序的性能，減少訪問數據庫</p><p>的次數，從而提高應用程序的吞吐量。我們通常將權限，菜單,組織機構</p><p>這些頻繁訪問但是不經常改變的基礎數據進行緩存，其中我在做()某某項目的時候</p><p>就通過oscache對ZTree的樹形菜單進行了緩存，並且在做的時候和單列設計</p><p>模式進行結合，考慮到多線程下的安全問題，還對單例模式加入了雙重判定鎖</p><p>的檢查方式。</p><p><strong>十一、實現頁面靜態化業務場景</strong></p><p>我們在做某項目時，涉及到程序訪問的性能問題，這時候我們想到可以通過靜態化來提高用戶訪問時候的性能，所以我們就採用了freemarker模板引擎，考慮到頁面也是要有動態的變化的，所以我們採用spring定時器在每天晚上2點鐘的時候定時再次生成html靜態頁面，考慮發佈時候的性能問題，我們又採取線程池技術，讓多個線程同時發佈，從而縮減發佈時間。</p><p><strong>十二、servlet線程安全描述</strong></p><p>servlet是單列的，對於所有請求都使用一個實例，所以如果有全局變量被多</p><p>線程使用的時候，就會出現線程安全問題。</p><p>解決這個問題有三種方案:</p><p>1.實現singleThreadModel接口，這樣對於每次請求都會創建一個新的servlet實例，這樣就會消耗服務端內存，降低性能，但是這個接口已經過時，不推薦使用。</p><p>2.可以通過加鎖(synchroniezd關鍵字)來避免線程安全問題。這個時候雖然還是單列，但是對於多線程的訪問，每次只能有一個請求進行方法體內執行，只有執行完畢後，其他線程才允許訪問，降低吞吐量。</p><p>3.避免使用全局變量，使用局部變量可以避免線程安全問題，強烈推薦使用此方法來解決servlet線程安全的問題。</p><p><strong>十三、(jbpm4)工作流引擎描述:</strong></p><p>JPBM是JBOSS旗下的一個開源的基於hibernate的工作流引擎。工作流就是在日常生活中，我們一些常見的如請假流程、採購流程、入職流程，通俗的來講就是一些在現實生活中的流程以信息化以程序的方式實現。</p><p>一個工作流首先需要進行流程定義，流程定義是由節點和跳轉組成的，節點又可以稱為環節、活動節點、活動環節，並且節點也可以分為兩大類型：人工節點和自動節點，人工節點有start開始節點、end結束節點、task任務節點，自動節點有decision判斷節點、fork分支節點、join聚合節點和state狀態節點，並且一個流程有且只有一個開始節點，但可以有多個結束節點。</p><p>流程定義是靜止的，它在運行狀態時會轉換成流程實例，一個流程定義可以對應多個流程實例。流程運行後，會產生兩個文件，<em>.jdpl.xml文件和</em>.png圖片文件，也會生成18張數據庫表，常用且核心的表有JBPM4_LOB 存儲表，主要存儲xml文件和png圖片、JBPM4_TASK 任務表、JBPM4_EXECUTION 流程實例表、JBPM4_VARIABLE變量表。</p><p>圖形化的靈活定製（主動說）</p><p>可以根據需求進行流程圖的改變的，即定義的流程圖是可以根據需要改變的，而不是死的。</p><p>可以進行圖形化的監控(主動說)</p><p>輸出圖片</p><p>獲取活動節點的座標</p><p>進行疊加</p><p>判斷節點:(主動說，也可以瞭解)</p><p>實現implements DecisionHandler接口並重寫decide方法,</p><p>返回的字符串要和xml中配置的transition的name保持一致。</p><p>分支判定節點</p><p>JBPM有五大核心類：</p><p>ProcessEngine：主要獲取各種的Service</p><p>RepositoryService：主要發佈流程定義</p><p>ExecutionService：主要操作流程實例</p><p>TaskService：主要操作人工服務</p><p>HistoryService：主要操作歷史服務。</p><p>核心方法：</p><p>讀取jbpm定義的文件生成zip包存到lob表中：createDeployment()</p><p>獲取流程定義列表：createProcessDefinitionQuery</p><p>根據定義的key或id來啟動流程實例：startProcessInstanceByKey(id)</p><p>獲取待辦任務列表：findPersonalTasks(userName)</p><p>完成指定任務列表：completeTask(*.getActivityId())</p><p>獲取歷史任務列表：createHistoryTaskQuery()</p><p>獲取流程實例的ID：task.getExecutionId()</p><p>(瞭解的表)</p><p>JBPM4_HIST_ACTINST 流程活動(節點) 實例表</p><p>JBPM4_HIST_DETAIL 流程歷史詳細表</p><p>JBPM4_HIST_PROCINST 流程實例歷史表</p><p>JBPM4_HIST_TASK 流程任務實例歷史表</p><p>JBPM4_HIST_VAR 流程變量( 上下文) 歷史表</p><p><strong>十四、JPBM業務場景</strong></p><p>首先進行請假的流程定義，我們流程的定義是（員工提交請假單—》經理審批—》總監審批—》總經理審批—》結束），通過repositoryService將其發佈部署到jbpm4_lob表中，</p><p>之後獲取流程定義列表，選中請假的流程定義，員工開始進行請假單的填寫，保存並通過executionService開啟流程實例，然後用taskService獲取經理的待辦任務列表，選中待辦任務，進行審批，通過調用taskService.completeTask()進入到總監審批環節，然後用總監進行登錄，同樣獲取待辦任務列表，然後調用taskService.completeTask()進入總經理審批環節，總經理審批之後，結束流程。在這個過程中我們還可以根據historyService查看當前登錄人已辦的任務列表。</p><p><strong>十五、Ant描述</strong></p><p>Ant是apache旗下的對項目進行自動打包、編譯、部署的構建工具，他主要具有 輕量級並且跨平臺的特性，而且基於jvm，默認文件名為build.xml</p><p>Ant主要的標籤：</p><p>Project 根標籤，</p><p>target 任務標籤，</p><p>property 屬性標籤，自定義鍵/值 供多次使用，</p><p>java 執行編譯後的java文件</p><p>javac 編譯java文件</p><p>war 打成war包</p><p>其它標籤：copy，delete，mkdir，move，echo等。</p><p><strong>十六、FreeMarker描述</strong></p><p>FreeMarker是一個用Java語言編寫的模板引擎，它是基於模板來生成文本輸出的通用工具。Freemarker可以生成HTML， XML，JSP或Java等多種文本輸出。</p><p>工作原理：定義模板文件，嵌入數據源，通過模板顯示準備的數據</p><p>（數據 + 模板 = 輸出）</p><p>我們在使用模板中發現freemarker具有許多優點，它徹底的分離表現層和業務邏輯，模板只負責數據在頁面中的表現，不涉及任何的邏輯代碼，所以使得開發過程中的人員分工更加明確，作為界面開發人員，只需專心創建HTML文件、圖像以及Web頁面的其他可視化方面，不用理會數據；而程序開發人員則專注於系統實現，負責為頁面準備要顯示的數據。</p><p>如果使用jsp來展示，開發階段進行功能調適時，需要頻繁的修改JSP，每次修改都要編譯和轉換，浪費了大量時間，FreeMarker模板技術不存在編譯和轉換的問題，在開發過程中，我們在不必在等待界面設計開發人員完成頁面原型後再來開發程序。由此使用freemarker還可以大大提高開發效率。</p><p><strong>十七、webService描述</strong></p><p>（主動說）</p><p>webservice是SOA（面向服務編程）的一種實現，</p><p>主要是用來實現異構平臺通信也就</p><p>是不同平臺不同項目之間的數據傳輸，從而避免了信息孤島的問題，</p><p>它之所以能夠</p><p>進行異構平臺通信是因為它是完全基於xml的，</p><p>所以說，webService是跨平臺，</p><p>跨語言，跨框架的，在java中通常有三種技術框架分別是xfire,cxf,axis2。</p><p>我們為了保證</p><p>webservice的安全性，採用了基於</p><p>WS-Security標準的安全驗證(使用回調函數)。</p><p>（沒必要主動說）</p><p>webservice的三要素分別是：</p><p>wsdl（webservice description language）</p><p>用來描述發佈的接口（服務）</p><p>soap(simple object access protocol)</p><p>是xml和http的結合，是webservice數據通信的協議</p><p>uddi 用來管理，查詢webService的服務</p><p>（沒必要主動說）</p><p>webservice的具體三種實現方式（框架）或者三種實現框架的區別</p><ol><li>Axis2:可以用多種語言開發，</li><li>是一個重量級框架，功能非常強大，</li><li>但是它的性能比較低。</li><li>Xfire：它相比Axis2來說是一個輕量級框架，</li><li>它的性能要比Axis2高。</li><li>cxf：是Xfire的升級版，就好比是，</li><li>struts2是webwork的升級，</li><li>然後cxf和spring集成起來非常方便，簡易，</li><li>性能方面也要比Xfire高。</li><li>【注】jdk6 自帶的webservice jws</li></ol><p>（主動說）</p><p>業務場景</p><p>我在以前做項目的時候，其中遇到一個功能，</p><p>需要進行兩個項目之間的數據的傳輸，</p><p>項目經理讓我去完成這個任務，我根據以往的項目經驗，</p><p>想到兩種解決方案，第一種</p><p>就是開放另外一個項目的數據庫的權限給我，</p><p>然後我直接通過訪問另外一個項目的數據</p><p>庫，來得到需要的信息，但後來我分析了下，覺的這種方式不安全，</p><p>而且因為當時</p><p>這個項目是另外一家公司負責在做，所以數據庫裡面的表結構，</p><p>以及以後牽涉</p><p>到的責任問題都很多，所以我就採用了第二種方案，</p><p>即通過webservices的方式，進行</p><p>異構系統之間數據信息的傳遞，webservices的具體實現，</p><p>有xfire,cxf,axis2,</p><p>我根據以往的項目經驗，瞭解到cxf是xfire的升級版本，適用於java語言，</p><p>xfire/cxf 性能比axis2要高，並且和spring整合起來也比較方便，</p><p>而axis2支持更多的語言，</p><p>性能相對於cxf要低，通過上面分析，</p><p>結合我們目前的兩個項目都是基於java</p><p>語言的，所以我採用cxf這種方式實現了兩個項目之間數據的傳遞，</p><p>我們為了保證</p><p>webservice的安全性我們採用了基於</p><p>WS-Security標準的安全驗證(使用CXF回調函數)。</p><p>（沒必要主動說）</p><p>webservice服務端配置流程</p><p>首先在web.xml中引入cxfServlet核心類，</p><p>指定對以/cxf開頭的url路徑提供webservice服務，</p><p>之後我們在要發佈成webservice接口上添加@Webservice 註解，</p><p>而且還要在實現類上添加同樣的webservice註解並且要說明實現了哪個接口，</p><p>之後在spring-webservice.xml中發佈webservice服務，</p><p>通過jaxws:endpoint這個標籤，</p><p>並且在標籤配置implementor和address來表明實現服務的類，</p><p>以及發佈的地址，</p><p>最後在瀏覽器中輸入相關的webservice地址?wsdl來驗證服務是否發佈成功。</p><p>（沒必要主動說）</p><p>webservice客戶端的配置</p><p>首先通過wsdl2java根據發佈的webservice服務端地址的wsdl</p><p>生成客戶端調用的中間橋樑java類，</p><p>將生成的java類拷貝到客戶端項目中，</p><p>配置spring-client.xml文件，</p><p>通過jaxws:client定義一個bean,</p><p>並通過address屬性指明要訪問的webservice的服務地址，</p><p>通過serviceClass指明充當中間橋樑的服務類，之後獲取該bean,</p><p>就可以通過它來訪問發佈的webservice接口中的方法。</p><p><strong>十八、oracle索引概述</strong></p><p>索引呢 是與表相關的一個可選結構，可以提高sql語句的檢索效率，相當於我們的字典目錄 ，可以快速進行定位 ，所以可以減少磁盤I/O, 但是因為索引在物理與邏輯上都是獨立於表的數據 它會佔用一定的物理空間(額外磁盤空間) 所以並不是索引越多越好,而我們應該根據業務需求去創建索引,而且進行增刪改操作時 oracle又要自動維護索引 所以在一定程度上也降低了維護速度，而且我們在創建索引和維護索引要耗費時間，這種時間隨著數據量的增加而增加，我們一般創建索引呢 是這樣創建的 create index 索引名 on 表名(字段)，索引又分為普通索引 唯一索引(unique) 單個索引 複合索引(又叫組合索引，在索引建立語句中同時可包含多個字段名)，順序索引，散列索引,位圖索引。</p><p><strong>十九、oracle存儲過程</strong></p><p>存儲過程就是封裝一些sql的集合，也就是一條條的sql語句，過程的優點就是簡化了sql命令加上它是預編譯的，所以它的執行效率和性能較高，再者，如果不調用過程的話就要和數據庫發生多次交互，調用過程只需傳一個命令所有的那些執行邏輯都在數據庫端執行，所以說它降低了網絡的通信量，其次，存儲過程大大提高了安全性，這就是優點</p><p>缺點呢，就是不同的數據庫對過程支持的關鍵字支持的關鍵字都是不一樣的，所以它的移植性是非常差的，再者，它的維護性難度也比較大，因為它沒有專業的調試和維護工具，所以說它維護起來比較麻煩，這就是存儲過程的基本概述.</p><p><strong>二十、Junit 業務場景</strong></p><p>在我們開發項目的時候為了提高代碼的性能和保證邏輯正確性，在我們編寫代碼後往往都要進行單元測試，來驗證代碼，當時我們公司開發人員全部使用的main方法來進行驗證，但是使用mian的最大缺點就是不能將多個類同時進行驗證，驗證的結果不直觀，測試複雜（每個類都要寫main方法，單個運行），一定程度上浪費時間，所有我和項目經理提議使用專業測試工具Junit來進行測試，因為Junit是一個Java語言的單元測試框架 ，測試簡單，不僅可以提供工作效率和代碼的質量，也提高團隊的合作能力，我提議後我們進行了Junit的培訓使用Junit4加註解的方式來測試。</p><p><strong>二十一、Apache+Tomcat 實現負載均衡及seesion複製</strong></p><p>當我們tomcat訪問量大,線程連接數不夠時,我們考慮到了tomcat的負載均衡來分擔過多的訪問.性能方面負載均衡也能利用多臺tomcat來增大內存量,</p><p>流程,準備工作apache,Jk_mod,tomcat,在apache的conf/httpd.conf文件中 使用include 標籤引入我們自定義的一個mood_jl.conf,在modules中引入下載的k_mod-apache-X.X.XX.so文件,在其中引入我們的.so,及work.properties文件,及指定負載分配控制器controller,在work.properties文件中worker.list=controller,tomcat1,tomcat2指定service,worker.tomcat1.port Ajp端口號,type 是ajp,host為指定ip,lbfactor 指定分配權重值越大分擔請求越多,worker.controller.type=lbworker.controller.balanced_workers=tomcat1,tomcat2 指定分擔請求的tomcat Session的複製在tomcat中service.xml中Engine標籤加入 jvmRoute 值為work,properties中指定的tomcat名稱,然後打開&lt;Cluster標籤的註釋,最後在應用中程序的web.xml文件中增加。</p><p>我們在做這個項目時，我們考慮到服務器性能的問題，我們最開始想到使用縱向擴展，來增加硬件的配置提高其性能，但這樣做比較耗費資金，而且服務器內存空間也是有限的；所以後來就想到使用橫向擴展來達到這一目的</p><p>當時我們的apache是通過jk藉助於ajp協議與tomcat進行通信的，在我們不進行負載均衡之前，那所有的請求都由一臺tomcat進行處理，這樣會使我們的tomcat所承受的壓力增大，而我們進行負載均衡之後，同樣數量的請求經過apache和jk將其分發到多臺tomcat進行處理，從而降低每臺tomcat所承受的壓力,而且當其中一臺機器宕機時，其他機器還可以繼續提供服務，保證服務不間斷。</p><p>在這個過程中，我們遇到了session問題，然後我此昂到用session複製來解決這個問題；</p><p>在apache的配置文件中增加session粘帶特性:</p><pre>worker.lb.sticky_session=1worker.lb.sticky_session_force=0</pre><p>Tomcat的配置</p><p>修改server.xml文件：</p><pre>&lt;Engine name="Catalina" defaultHost="localhost" jvmRoute="tomcat2"&gt;</pre><p>增加jvmRoute=”tomcat2” *. jvmRoute賦的值為worker.properties中配置的相應的server名一致</p><pre>&lt;Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"/&gt; 將此配置的註釋去掉</pre><p>修改應用的web.xml文件</p><p>在應用中的web.xml文件中增加。</p><p>如果這樣做，當第一次訪問的時候，會把所以數據全部緩存到第一臺服務器上，通過web配置文件，會把第一臺緩存的數據全部複製到第二胎服務器上，這樣做就加大網路通信量，導致阻塞，所以我們就想到了可以通過memcached分佈式緩存來存取session從而解決上述問題。</p><p><strong>二十二、Ant業務場景</strong></p><p>Ant是基於java語言編寫的，因此具有跨平臺的特性，此外還具有簡潔方便，靈活</p><p>配置的特性，因此我就在XX項目中使用ant進行項目的編譯，打包，部署操作。使用ant</p><p>之後，如果我們在客戶那裡修改代碼後，就可以直接使用ant進行編譯，打包，部署，而不需要為了編譯，打包，部署專門在客戶那裡安裝eclipse.此外使用ant也可以直接和svn進行交互，下載源碼的同時進行編譯，打包，部署。</p><p><strong>二十三、maven業務場景</strong></p><p><strong>maven業務場景</strong></p><p>前段時間在研究maven，知道maven是一個項目管理工具，其核心特點就是通過maven可以進行包的依賴管理，保證jar包版本的一致性，以及可以使多個項目共享jar包，從而能夠在開發大型j2ee應用的時候，減小項目的大小，並且和ant比起來，maven根據“約定優於配置”的特性，可以對其項目的編譯打包部署進行了更為抽象的封裝，使得自己不需要像ant那樣進行詳細配置文件的編寫，直接使用系統預定好的mvn clean,compile,test,package等命令進行項目的操作。於是我就在XX項目中採用了maven,為了保證團隊中的成員能夠節省下載jar包所需要的時間，於是我就採用nexus搭建了在局域網內的maven私服，然後通過配置settings.xml中建立mirror鏡像，將所有下載jar包的請求都轉發到maven私服上，之後通過在pom.xml即(project object model)中配置項目所依賴的jar包，從而達到在構建項目的時候，先從本地倉庫中查找，如果不存在從內部私服查找，如果不存在最後再從外網central服務器查找的機制，達到了節省下載帶寬，提高開發效率，以及jar包重用的目的。</p><p><strong>ant業務場景</strong></p><p>ant是基於java語言編寫的，因此具有跨平臺的特性，此外還具有簡潔方便，靈活</p><p>配置的特性，因此我就在XX項目中使用ant進行項目的編譯，打包，部署操作。使用ant</p><p>之後，如果我們在客戶那裡修改代碼後，就可以直接使用ant進行編譯，打包，部署，</p><p>而不需要為了編譯，打包，部署專門在客戶那裡安裝eclipse.此外使用ant也可以</p><p>直接和svn進行交互，下載源碼的同時進行編譯，打包，部署。</p><p><strong>maven的常用命令</strong></p><p>mvn eclipse:clean eclipse:eclipse -Dwtpversion=2.0</p><p>mvn clean package</p><p>maven的生命週期是獨立的，但是生命週期下的階段是相互關聯並且延續的。</p><p><strong>maven的生命週期</strong></p><p>clean(清理):clean;default(默認):compile,test,packageinstall;site(站點)</p><p><strong>二十四、Servlet的概述：</strong></p><p>Servlet是一個web容器，我們通常用的servlet是httpservlet，而httpservlet又是繼承於genericservlet，而genericservlet又實現了servlet接口</p><p>servlet的生命週期是 ：先進行實例化，然後是初始化，然後是提高服務，然後銷燬，最後不可用，在這五個生命週期，其中，初始化是調用的init方法，這個方法只有一個，而提高服務的時候調用的是service方法，而我們具體在我們所寫的這個方法中，因為我們繼承了httpservlet，其實就是對應了doGet（），doPost(),這種方法，然後據我瞭解，servlet是單例的。非線程安全的，我們通常有一下幾種方案來解決：</p><p>第一種，繼承SingleThreadModel但是這樣每次都會創建一個新的servlet實例，但這樣消耗服務器的內存，降低了性能，並且這個接口現在已經過時了，不推薦使用。</p><p>第二種：我們儘量避免使用全局變量，就我個人而言，我比較喜歡使用這種方法。</p><p>第三種，我們可以通過使用ThreadLocal， 內部結構是一個Map結構，用當前線程作為key,他會創建多個副本。get,set方法</p><p>第四種，我們當然還可以來加鎖，進行解決線程問題。</p><p>而且我還知道，向我們這種常用的MVC框架，struts1，spring這些MVC框架，都是基於servlet發展而來的，就比如struts1 的核心總控制器是ActionServlet，而springMVC的前端總控制器是dispatchServlet，在項目我們曾經用serlet來生成 圖片驗證碼的，防止用戶進行暴力破解</p><p>（別人問了，再回答）</p><p>servlet的配置文件 web.xml</p><pre>&lt;servlet&gt;&lt;servlet-name&gt;ImageCodeServlet&lt;/servlet-name&gt; 	&lt;servlet-class&gt;org.leopard.code.ImageCodeServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;ImageCodeServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/d&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</pre><p>描述：</p><p>我在web.xml中，我首先需要寫一個servlet標籤，servlet標籤中有兩個子標籤，一個叫servlet-name，這個name可以隨便起，但是要保證唯一性，除此之外，在這個servlet-name下有一個servlet-class，這個servlet-class對應的就是我後臺提高服務的servlet，除此之外還有一個servlet-mapping，這個裡邊首先有一個servl-name。，這個servl-name首先要保證和上邊的servlet-name保持一致，除此之外還有一個url-pattern，這是一個虛擬路徑，是用來發送請求的url地址</p><p><strong>二十五、bugfree的操作步驟</strong></p><p>我們在使用bugfree的時候我們首先登陸的時候是以測試員的身份登陸的，也就是系統管理員用戶；測試員在登陸後首先應該給要測試的項目的相關負責人，每人創建一個賬號（也就是在登陸後的頁面的後臺管理中創建用戶），用戶都新建完成之後就新建組，把要測試的項目的用戶添加到組中。最後就新建項目並且新建該項目的模塊。新建完項目之後就是開始測試程序，在程序中遇到bug以後就把錯誤截圖，在到bugfree中新建bug填寫相關的信息和要指派的人（出錯模塊的負責人）和把剛才的錯誤截圖作為附件一併傳送過去。</p><p>開發人員每天早上上班的第一件事就是用自己的用戶登錄bugfree，然後輸入查詢條件看看前一天有沒有指派給自己的bug需要解決的如果有就進行解決。</p><p>開發人員把對應的bug解決之後就去bugfree上把bug對應的狀態改成已解決狀態，然後進行保存提交，這樣bug的狀態就變成已解決狀態。測試人員上線查看已解決狀態的bug並再次進行測試，如果經過測試bug的問題已解決，就可以把bug關閉；如果經過測試，發現仍然存在bug，就把bug激活；這樣等開發人員再次登錄的時候就可以再次看到這個未解決的bug，再次進行解決，如此反覆直到bug全部解決，因為bugfree對bug的修改都有保留，所有我們可以看到bug的一步步的完善，直到最後把bug關閉。</p><p>Bug的三種狀態：未解決(Active)（測試人員）、已解決(Resolved)(開發人員)、關閉(Closed)（測試人員）</p><p><strong>二十六、Axis2 的配置</strong></p><p>axis2服務端配置流程</p><p>1.引入相關的jar包並且在web.xml中配置axis2的核心控制器 axisServlet</p><p>2.在web-inf下建立相關的三層文件夾結構:</p><p>services–>自定義文件夾名–>META-INF–>servies.xml</p><p>3.在servies.xml中配置service的name以及對應的springBeanName</p><p>4.在瀏覽器中輸入webservice的服務端地址並加上?wsdl來進行測試，看</p><p>是否發佈成功</p><p>axis2客戶端配置流程</p><p>1.通過wsdl2java根據webservice服務端的url生成客戶端代碼</p><p>2.將代碼引入項目的文件夾中進行正常訪問</p><p><strong>二十六、spring定時器</strong></p><p>每隔固定的時間執行</p><p>1.建立一個triggers觸發器集合</p><p>2.建立SimpleTriggerBean並且指定每次間隔的時間以及執行的次數以及要執行的目標</p><p>3.通過 targetObject以及targetMethod找到要執行的具體類的具體方法</p><p>目標對象是一個普通的java類</p><p>每到指定的時間執行</p><p>1.建立一個triggers觸發器集合.</p><p>2.建立CronTriggerBean指定cron表達式以及要執行的目標</p><p>3.通過 targetObject以及targetMethod找到要執行的具體類的具體方法</p><p>目標對象是一個普通的java類</p><p><strong>二十七、Ext概述</strong></p><p>據我瞭解Ext是一個用js編寫RIA框架，它可以和各種後臺語言結合使用。我在項目中用Ext來完成的模塊大概情況是這個樣子，首先我通過layout等於border的這種方式來進行佈局，分為上下左右中，然後在左邊用exttree來進行菜單的展示，之後在中間區域通過tabs來加入選項卡，而在選項卡中就是一個個的grid以及form，其中我在做grid的時候，首先通過store來存取後臺返回的符合model格式數據集，store是通過proxy和後臺的contoller進行交互，之後把store賦值給grid的store屬性並且通過renderTO在指定的位置進行渲染展示。</p><p>Grid問題:</p><p>當時我在做grid的時候，發現數據沒有展示出來，</p><p>我通過f12進行跟蹤，發現壓根就沒有發送請求，後來我分析了下，發現因為沒有調用store的loadPage方法，所以導致了這個問題。除此之外在我們做項目的過程中，我手底下帶的一個人同樣在負責grid的時候，數據可以正常展示，但分頁信息沒有展示，通過跟蹤他的代碼發現是因為他沒有把store屬性賦值給分頁工具條，所以才導致了這個問題。</p><p>tabs選項卡：</p><p>當我在做tab選項卡這一模塊的時候，我首先在加載頁面的時候用TabPanel創建了一個tab頁面，讓它展示在中間位置，然後點擊左邊Tree菜單調用add方法動態添加一個個的tab選項卡，但是做的過程中出現了相同的選項卡會重複添加的問題，</p><p>我查了一些相關資料，最後通過tab的id或者一個唯一標識判斷tab是否選中，如果選中則調用setActiveTab來激活該選項卡，讓它選中，否則就添加一個tab。最後達到了tab不存在就添加，存在就選中的效果。</p><p><strong>瞭解:</strong></p><p><strong>Ext4.0也支持前端的MVC開發模式.</strong></p><p>為啥沒采用mvc的開發模式？</p><p>我們當時因為時間方面的原因，項目經理就決定用普通的這種開發模式進行開發，並沒有採用Ext4.0這種mvc模式的特性。但我認為他們的核心操作流程是一致的所以對我來說去學習和使用這種方式並沒有什麼難度。</p><p><strong>二十八、lucene的概述</strong></p><p>lucene是一個全文檢索引擎，在進行模糊匹配的時候，他可以用來替代數據庫中的like,從而在匹配準確性以及性能進行大幅度</p><p>的提高。我在做XX項目的XX模塊的時候，就是用lucene來進行全文檢索用IK分詞器來進行分詞。從而實現了高亮顯示關鍵詞，分頁，排序，多字段，多條件的高性能搜索。在從數據中取數據生成索引的時候，因為表中的數據量比較大，防止一次取出所導致內存溢出問題，我採用了分段批量提取的方式進行，除此之外我們對後續增加的數據根據優先級的不同採取不同的策略，對於那些需要及時顯示的數據我們通過spring定時器 在短時間內(30分鐘)進行增量索引的生成，對於那些不需要及時展示的數據,我們通過spring定時器在每天晚上凌晨的時候進行索引的重新生成。</p><p><strong>二十九、線程池作用</strong></p><p>1.減少了創建和銷燬線程的次數，每個線程都可以被重複利用，可執行多個任務。</p><p>2.可以根據系統的承受能力，調整線程池中線程的數目，防止因為消耗過多的內存，而導致服務器宕機(每個線程需要大約1MB內存，線程開的越多，消耗的內存也就越大，最後宕機)。</p><p>通常我們使用的線程池是實現了ExecutorService的ThreadPoolExecutor。</p><p><strong>三十、jbpm是如何和spring進行整合</strong></p><p>1.通過在spring-common.xml配置文件中配置springHelper，通過springHelper創建processEngine，再通過processEngine獲取各種工作流的Service，</p><p>如repositoryService，executionService，historyService，taskService</p><p>2.在src根目錄下新建jbpm.cfg.xml文件</p><p><strong>三十一、Tomcat優化</strong></p><p>增大內存(堆，持久代)並開啟server模式</p><p>我在做XXX項目時,用到了poi導入和導出數據,由於公司的業務比較繁多,數據量很大,測試時報內存溢出,經過我的分析再結合上網查閱資料,發現可能是tomcat內存不足,需要增大,修改配置文件後測試不再報錯.</p><p>tomcat增大內存的方式通過修改tomcat配置文件</p><p>window下， 在bin/catalina.bat文件中最前面添加：</p><pre>set JAVA_OPTS=-XX:PermSize=64M -XX:MaxPermSize=128m –Xms1024m -Xmx1024m</pre><p>linux下，在catalina.sh最前面增加：</p><pre>JAVA_OPTS="-XX:PermSize=64M -XX:MaxPermSize=128m –Xms1024m -Xmx1024m "-client –service</pre><p>當我們在cmd中運行-java時,黑窗口會出現-client -service這兩參數.其作用是設置虛擬機運行模式;client模式啟動比較快，但運行時性能和內存管理效率不如server模式，通常用於客戶端應用程序。server模式啟動比client慢，但可獲得更高的運行性能。Windows默認為client，如果要使用server模式，就需要在啟動虛擬機時加-server參數，以獲得更高性能，對服務器端應用，推薦採用server模式，尤其是多個CPU的系統。在Linux，Solaris上,默認值為server模式.</p><p>JDK版本</p><p>影響虛擬機還有JDK的版本,JDK分為32位,64位兩種版本,32位裝在32位系統,64位系統可以裝32位和64位JDK.64位JDK性能優於32位JDK.</p><p>測試的命令 java -xmx數值m –version 報錯配置大小失敗,反之成功</p><p>增加Tomcat最大連接數</p><p>使用場景</p><p>我在做完一個XXX項目後,測試時發現併發數量增加到一定程度就會很卡,於是我想到了是不是tomcat最大連接數設置有限制.果不其然,配置文件中最大值才500,於是我更改了最大連接數,根據業務我修改了連接數為2000,完美的解決了這個問題;</p><p>修改方法在conf/service.xml中默認值</p><pre>&lt;Connector port="8080" maxHttpHeaderSize="8192" maxThreads="1500"minSpareThreads="30" maxSpareThreads="75" enableLookups="false"redirectPort="8443" acceptCount="100" connectionTimeout="20000"disableUploadTimeout="true" /&gt;,修改maxthreads的值即可</pre><p>tomcat進行gzip壓縮從而降低網絡傳輸量</p><p>tomcat 壓縮設置tomcat壓縮gzip啟用</p><p>HTTP 壓縮可以大大提高瀏覽網站的速度，它的原理是，</p><p>在客戶端請求服務器對應資源後，從服務器端將資源文件壓縮，</p><p>再輸出到客戶端，由客戶端的瀏覽器負責解壓縮並瀏覽。</p><p>相對於普通的瀏覽過程HTML ,CSS,Javascript , Text ，</p><p>它可以節省60%左右的流量。更為重要的是，它可以對動態生成的，</p><p>包括CGI、PHP , JSP , ASP , Servlet,SHTML等輸出的網頁也能進行壓縮，</p><p>壓縮效率也很高。</p><p>啟用tomcat 的gzip壓縮</p><p>要使用gzip壓縮功能，你需要在Connector節點中加上如下屬性</p><pre>compression="on" 打開壓縮功能compressionMinSize="50" 啟用壓縮的輸出內容大小，默認為2KBnoCompressionUserAgents="gozilla, traviata" 對於以下的瀏覽器，不啟用壓縮compressableMimeType="text/html,text/xml,text/javascript,text/css,text/plain"　哪些資源類型需要壓縮&lt;Connector port="80" protocol="HTTP/1.1"connectionTimeout="20000"redirectPort="8443" executor="tomcatThreadPool" URIEncoding="utf-8"compression="on"compressionMinSize="50" noCompressionUserAgents="gozilla, traviata"compressableMimeType="text/html,text/xml,text/javascript,text/css,text/plain" /&gt;</pre><p><strong>三十二、memcached的介紹</strong></p><p>memcached是一個用C語言開發的分佈式的緩存，內部基於類似hashMap的結構。</p><p>它的優點是協議簡單，內置內存存儲，並且他的分佈式算法是在客戶端完成的，不需要服務器端進行通信，我們當時在做項目的時候因為考慮到項目的高可用性高擴展性，因此在服務器部署方面採用了apache+jk+tomcat這種負載均衡的方式，但是也帶來了一個問題就是session共享的問題，雖然可以通過session複製來解決這個問題，但是在性能方面存在缺陷，所以最後我們採用了用memcached來存儲session，這樣既解決了session共享問題，也解決了session複製那種方式所產生的性能問題。</p><p>瞭解(不必主動說，但別人問的話一定要知道)</p><p>memcached是以KEY-VALUE的方式進行數據存儲的，</p><p>KEY的大小限制：Key（max）&lt;=250個字符；</p><p>VALUE在存儲時有限制：Value（max）&lt;= 1M；</p><p>根據最近最少使用原則刪除對象即LRU.</p><p>memcached默認過期時間：ExpiresTime（max）= 30（days）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>java</a></li><li><a>必背</a></li><li><a>綜合</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/745227e1.html alt=綜合佈線與弱電工程：跳線、尾纖、光纖接口，一文講明白 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/70370b3c8fc348e2ab70ef1e28a16c77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/745227e1.html title=綜合佈線與弱電工程：跳線、尾纖、光纖接口，一文講明白>綜合佈線與弱電工程：跳線、尾纖、光纖接口，一文講明白</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d2be915.html alt=寧夏、內蒙古自治區黃河的綜合治理措施 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/217d033a478c468f928df0367a082186 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d2be915.html title=寧夏、內蒙古自治區黃河的綜合治理措施>寧夏、內蒙古自治區黃河的綜合治理措施</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html alt=java相關知識(10)總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/84649e6ba0f8442a8b10584403bf6635 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html title=java相關知識(10)總結>java相關知識(10)總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html alt=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d69c7c9d8b85444da9360e334ba6555d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html title=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID>java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html alt=多態的本質，java動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac000493fbc8532b5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html title=多態的本質，java動態綁定>多態的本質，java動態綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html alt=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/54d45b20ef6a4a3f960411db61474538 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html title=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到>java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/162efaea.html alt=詳解綜合佈線中屏蔽線纜有何作用！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535790948669d855fe1265 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/162efaea.html title=詳解綜合佈線中屏蔽線纜有何作用！>詳解綜合佈線中屏蔽線纜有何作用！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a71711d1.html alt=溫榆河綜合治理工程主體完工，新增120個垂釣點位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7e1611ffc1a24354805bac415c11f715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a71711d1.html title=溫榆河綜合治理工程主體完工，新增120個垂釣點位>溫榆河綜合治理工程主體完工，新增120個垂釣點位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a3eebcb.html alt=一文看懂綜合佈線接地與聯結技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c3d6eac2b6de41e580192c4b79134c35 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a3eebcb.html title=一文看懂綜合佈線接地與聯結技術>一文看懂綜合佈線接地與聯結技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4e851be.html alt=弱電綜合佈線中，到底採用屏蔽雙絞線還是非屏蔽雙絞線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/fe0df606f4e2459aa108632c8e84d24b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4e851be.html title=弱電綜合佈線中，到底採用屏蔽雙絞線還是非屏蔽雙絞線>弱電綜合佈線中，到底採用屏蔽雙絞線還是非屏蔽雙絞線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c6d9cc9.html alt=綜合佈線系統精華知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/87f59c95f1c14aefa8143a8f7625984c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c6d9cc9.html title=綜合佈線系統精華知識>綜合佈線系統精華知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/31d75a5b.html alt=綜合佈線系統選擇指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/68f0e405-6ec2-403f-8b1e-bbcb418ebe63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/31d75a5b.html title=綜合佈線系統選擇指南>綜合佈線系統選擇指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4345a9b.html alt=網絡工程｜綜合佈線整體解決方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4345a9b.html title=網絡工程｜綜合佈線整體解決方案>網絡工程｜綜合佈線整體解決方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa473c75.html alt=轉彎機皮帶綜合性能測評，技術乾貨不能錯過 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15410451431617002f26d8a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa473c75.html title=轉彎機皮帶綜合性能測評，技術乾貨不能錯過>轉彎機皮帶綜合性能測評，技術乾貨不能錯過</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html alt="java 常用的正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1540129072390e6c4c05126 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html title="java 常用的正則表達式">java 常用的正則表達式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>