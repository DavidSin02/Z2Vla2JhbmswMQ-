<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試總結-Java高級篇 | 极客快訊</title><meta property="og:title" content="面試總結-Java高級篇 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1d10456.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1d10456.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d1d10456.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1d10456.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1d10456.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d1d10456.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d1d10456.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1d10456.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="面試總結-Java高級篇"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d1d10456.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試總結-Java高級篇</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>Java面試總結</p><p>1.你用過哪些集合類？</p><blockquote><p>大公司最喜歡問的Java集合類面試題</p><p>40個Java集合面試問題和答案</p><p>java.util.Collections 是一個包裝類。它包含有各種有關集合操作的靜態多態方法。</p><p>java.util.Collection 是一個集合接口。它提供了對集合對象進行基本操作的通用接口方法。</p></blockquote><p>Collection</p><p>├List</p><p>│├LinkedList</p><p>│├ArrayList</p><p>│└Vector</p><p>│　└Stack</p><p>└Set</p><p>Map</p><p>├Hashtable</p><p>├HashMap</p><p>└WeakHashMap</p><hr><blockquote><p>ArrayList、HashMap、TreeMap和HashTable類提供對元素的隨機訪問。</p></blockquote><p><strong>線程安全</strong></p><blockquote><p>Vector</p><p>HashTable(不允許插空值)</p></blockquote><p><strong>非線程安全</strong></p><blockquote><p>ArrayList</p><p>LinkedList</p><p>HashMap(允許插入空值)</p><p>HashSet</p><p>TreeSet</p><p>TreeMap(基於紅黑樹的Map實現)</p></blockquote><p>2.你說說 arraylist 和 linkedlist 的區別？</p><blockquote><p>ArrayList和LinkedList兩者都實現了List接口，但是它們之間有些不同。</p><p>（1）ArrayList是由Array所支持的基於一個索引的數據結構，所以它提供對元素的隨機訪問</p><p>（2）與ArrayList相比，在LinkedList中插入、添加和刪除一個元素會更快</p><p>（3）LinkedList比ArrayList消耗更多的內存，因為LinkedList中的每個節點存儲了前後節點的引用</p></blockquote><p>3.HashMap 底層是怎麼實現的？還有什麼處理哈希衝突的方法？</p><p><strong>處理哈希衝突的方法</strong>:</p><blockquote><p>解決HashMap一般沒有什麼特別好的方式，要不擴容重新hash要不優化衝突的鏈表結構</p></blockquote><p>1.開放定地址法-線性探測法</p><p>2.開放定地址法-平方探查法</p><p>3.鏈表解決-可以用紅黑樹提高查找效率</p><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5><p class=pgc-img-caption></p></div><blockquote><p>HashMap簡介</p><p>HashMap 是一個散列表，它存儲的內容是鍵值對(key-value)映射。</p><p>HashMap 繼承於AbstractMap，實現了Map、Cloneable、java.io.Serializable接口。</p><p>HashMap 的實現不是同步的，這意味著它不是線程安全的,但可以用 Collections的synchronizedMap方法使HashMap具有線程安全的能力。<strong>它的key、value都可以為null</strong>。此外，HashMap中的映射不是有序的。</p><p>HashMap 的實例有兩個參數影響其性能：“初始容量” 和 “加載因子”。<strong>初始容量默認是16。默認加載因子是 0.75,</strong> 這是在時間和空間成本上尋求一種折衷。加載因子過高雖然減少了空間開銷，但同時也增加了查詢成本.</p><p>HashMap是數組+鏈表+紅黑樹（JDK1.8增加了紅黑樹部分）實現的,當鏈表長度太長（默認超過8）時，鏈表就轉換為紅黑樹.</p><p><strong>Java8系列之重新認識HashMap</strong></p><p><strong>功能實現-方法</strong></p></blockquote><ul><li>確定哈希桶數組索引位置 :這裡的Hash算法本質上就是三步：取key的hashCode值、高位運算、取模運算。</li></ul><pre>1234567891011方法一：static final int hash(Object key) { //jdk1.8 &amp; jdk1.7int h;// h = key.hashCode() 為第一步 取hashCode值// h ^ (h &gt;&gt;&gt; 16) 為第二步 高位參與運算return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}方法二：static int indexFor(int h, int length) { //jdk1.7的源碼，jdk1.8沒有這個方法，但是實現原理一樣的return h &amp; (length-1); //第三步 取模運算}</pre><ul><li>分析HashMap的put方法</li><li><strong>擴容機制：原來的兩倍</strong></li></ul><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4b0300027fd065064d9b><p class=pgc-img-caption></p></div><p>4.熟悉什麼算法，還有說說他們的時間複雜度？</p><blockquote><p><strong>經典排序算法總結與實現</strong></p></blockquote><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4b0300027fcf711645bd><p class=pgc-img-caption></p></div><p>5.ArrayList和Vector的底層代碼和他們的增長策略,它們是如何進行擴容的？</p><blockquote><p>ArrayList 默認數組大小是10，其中ensureCapacity擴容，trimToSize容量調整到適中，擴展後數組大小為（(原數組長度1.5）與傳遞參數中較大者.</p><p>Vector的擴容，是可以指定擴容因子，同時Vector擴容策略是：1.原來容量的2倍,2.原來容量+擴容參數值。</p><p>*詳細內容可以配合閱讀源碼</p></blockquote><p>6.jvm 原理。程序運行區域劃分</p><blockquote><p>問：Java運行時數據區域？</p><p>回答：包括程序計數器、JVM棧、本地方法棧、方法區、堆</p><p>問：方法區裡存放什麼？</p><p>本地方法棧：和jvm棧所發揮的作用類似，區別是jvm棧為jvm執行java方法（字節碼）服務，而本地方法棧為jvm使用的native方法服務。</p><p>JVM棧：局部變量表、操作數棧、動態鏈接、方法出口。</p><p>方法區：用於存儲已被虛擬機加載的類信息，常量、靜態變量、即時編譯器編譯後的代碼等。</p><p>堆：存放對象實例。</p></blockquote><p>7.minor GC 與 Full GC，分別什麼時候會觸發？ 。分別採用哪種垃圾回收算法？簡單介紹算法</p><blockquote><p>GC（或Minor GC）：收集 生命週期短的區域(Young area)。</p><p>Full GC （或Major GC）：收集生命週期短的區域(Young area)和生命週期比較長的區域(Old area)對整個堆進行垃圾收集。</p><p>新生代通常存活時間較短基於Copying算法進行回收,將可用內存分為大小相等的兩塊，每次只使用其中一塊；當這一塊用完了，就將還活著的對象複製到另一塊上，然後把已使用過的內存清理掉。在HotSpot裡，考慮到大部分對象存活時間很短將內存分為Eden和兩塊Survivor，默認比例為8:1:1。代價是存在部分內存空間浪費，適合在新生代使用；</p><p>老年代與新生代不同，老年代對象存活的時間比較長、比較穩定，因此採用標記(Mark)算法來進行回收,所謂標記就是掃描出存活的對象，然後再進行回收未被標記的對象，回收後對用空出的空間要麼進行合併、要麼標記出來便於下次進行分配，總之目的就是要減少內存碎片帶來的效率損耗。</p><p>在執行機制上JVM提供了串行GC(Serial MSC)、並行GC(Parallel MSC)和併發GC(CMS)。</p></blockquote><p><strong>Minor GC ，Full GC 觸發條件</strong></p><ul><li>Minor GC觸發條件：當Eden區滿時，觸發Minor GC。</li><li><strong>Full GC觸發條件：</strong></li><li>（1）調用System.gc時，系統建議執行Full GC，但是不必然執行</li><li>（2）老年代空間不足</li><li>（3）方法去空間不足</li><li>（4）通過Minor GC後進入老年代的平均大小大於老年代的可用內存</li><li>（5）由Eden區、From Space區向To Space區複製時，對象大小大於To Space可用內存，則把該對象轉存到老年代，且老年代的可用內存小於該對象大小</li></ul><p>8.HashMap 實現原理</p><blockquote><p>在java編程語言中，最基本的結構就是兩種，一個是數組，另外一個是模擬指針（引用），所有的數據結構都可以用這兩個基本結構來構造的，HashMap也不例外。HashMap實際上是一個“鏈表散列”的數據結構，即數組和鏈表的結合體。</p></blockquote><p>9.java.util.concurrent 包下使用過哪些</p><blockquote><p>1.阻塞隊列 BlockingQueue( ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue,SynchronousQueue,LinkedTransferQueue,LinkedBlockingDeque)</p><p>2.ConcurrentHashMap</p><p>3.Semaphore–信號量</p><p>4.CountDownLatch–閉鎖</p><p>5.CyclicBarrier–柵欄</p><p>6.Exchanger–交換機</p><p>7.Executor->ThreadPoolExecutor,ScheduledThreadPoolExecutor</p></blockquote><pre>12345Semaphore semaphore = new Semaphore(1);//critical section semaphore.acquire();...semaphore.release();</pre><blockquote><p>8.鎖 Lock–ReentrantLock,ReadWriteLock,Condition,LockSupport</p></blockquote><pre>1234Lock lock = new ReentrantLock();lock.lock();//critical section lock.unlock();</pre><p>10.concurrentMap 和 HashMap 區別</p><blockquote><p>1.<strong>hashMap可以有null的鍵</strong>，concurrentMap不可以有</p><p>2.hashMap是線程不安全的，在多線程的時候需要Collections.synchronizedMap(hashMap),ConcurrentMap使用了重入鎖保證線程安全。</p><p>3.在刪除元素時候，兩者的算法不一樣。</p><p>ConcurrentHashMap和Hashtable主要區別就是圍繞著鎖的粒度以及如何鎖,可以簡單理解成把一個大的HashTable分解成多個，形成了鎖分離。</p></blockquote><p>11.信號量是什麼，怎麼使用?volatile關鍵字是什麼？</p><blockquote><p>信號量-semaphore：荷蘭著名的計算機科學家Dijkstra 於1965年提出的一個同步機制。是在多線程環境下使用的一種設施, 它負責協調各個線程, 以保證它們能夠正確、合理的使用公共資源。</p><p>整形信號量：表示共享資源狀態，且只能由特殊的原子操作改變整型量。</p><p>同步與互斥：同類進程為互斥關係（打印機問題），不同進程為同步關係(消費者生產者)。</p></blockquote><hr><blockquote><p>使用volatile關鍵字是解決同步問題的一種有效手段。 java volatile關鍵字預示著這個變量始終是“存儲進入了主存”。更精確的表述就是每一次讀一個volatile變量，都會從主存讀取，而不是CPU的緩存。同樣的道理，每次寫一個volatile變量，都是寫回主存，而不僅僅是CPU的緩存。</p><p>Java 保證volatile關鍵字保證變量的改變對各個線程是可見的。</p></blockquote><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4b0000045c136b7aaa3f><p class=pgc-img-caption></p></div><p>12.阻塞隊列了解嗎？怎麼使用</p><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/4b0000045c148f12d576><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4afe0004abffd1ad3ed1><p class=pgc-img-caption></p></div><blockquote><p>阻塞隊列 (BlockingQueue)是Java util.concurrent包下重要的數據結構，BlockingQueue提供了線程安全的隊列訪問方式：當阻塞隊列進行插入數據時，如果隊列已滿，線程將會阻塞等待直到隊列非滿；從阻塞隊列取數據時，如果隊列已空，線程將會阻塞等待直到隊列非空。併發包下很多高級同步類的實現都是基於BlockingQueue實現的。</p></blockquote><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4b0000045c157765fc39><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/4b0000045c1df53051f6><p class=pgc-img-caption></p></div><p><strong>以ArrayBlockingQueue為例，我們先來看看代碼：</strong></p><pre>123456789101112public void put(E e) throws InterruptedException {if (e == null) throw new NullPointerException();final ReentrantLock lock = this.lock;lock.lockInterruptibly();try {while (count == items.length)notFull.await();enqueue(e);} finally {lock.unlock();}}</pre><p>從put方法的實現可以看出，它先獲取了鎖，並且獲取的是可中斷鎖，然後判斷當前元素個數是否等於數組的長度，如果相等，則調用notFull.await()進行等待，當被其他線程喚醒時，通過enqueue(e)方法插入元素，最後解鎖。</p><pre>12345678910111213/*** Inserts element at current put position, advances, and signals.* Call only when holding lock.*/private void enqueue(E x) {// assert lock.getHoldCount() == 1;// assert items[putIndex] == null;final Object[] items = this.items;items[putIndex] = x;if (++putIndex == items.length) putIndex = 0;count++;notEmpty.signal();}</pre><p>插入成功後，通過notEmpty喚醒正在等待取元素的線程。</p><p>13.Java中的NIO，BIO，AIO分別是什麼？</p><blockquote><p>IO的方式通常分為幾種，同步阻塞的BIO、同步非阻塞的NIO、異步非阻塞的AIO</p></blockquote><p>1.<strong>BIO</strong>，同步阻塞式IO，簡單理解：一個連接一個線程.BIO方式適用於連接數目比較小且固定的架構，這種方式對服務器資源要求比較高，併發侷限於應用中，JDK1.4以前的唯一選擇，但程序直觀簡單易理解。</p><blockquote><p>在JDK1.4之前，用Java編寫網絡請求，都是建立一個ServerSocket，然後，客戶端建立Socket時就會詢問是否有線程可以處理，如果沒有，要麼等待，要麼被拒絕。即：一個連接，要求Server對應一個處理線程。</p></blockquote><p>2.<strong>NIO</strong>，同步非阻塞IO，簡單理解：一個請求一個線程.NIO方式適用於連接數目多且連接比較短（輕操作）的架構，比如聊天服務器，併發侷限於應用中，編程比較複雜，JDK1.4開始支持。</p><blockquote><p>NIO本身是基於事件驅動思想來完成的，其主要想解決的是BIO的大併發問題： 在使用同步I/O的網絡應用中，如果要同時處理多個客戶端請求，或是在客戶端要同時和多個服務器進行通訊，就必須使用多線程來處理。也就是說，將每一個客戶端請求分配給一個線程來單獨處理。這樣做雖然可以達到我們的要求，但同時又會帶來另外一個問題。由於每創建一個線程，就要為這個線程分配一定的內存空間（也叫工作存儲器），而且操作系統本身也對線程的總數有一定的限制。如果客戶端的請求過多，服務端程序可能會因為不堪重負而拒絕客戶端的請求，甚至服務器可能會因此而癱瘓。</p></blockquote><p>3.<strong>AIO</strong>，異步非阻塞IO，簡單理解：一個有效請求一個線程.AIO方式使用於連接數目多且連接比較長（重操作）的架構，比如相冊服務器，充分調用OS參與併發操作，編程比較複雜，JDK7開始支持。</p><p>14.類加載機制是怎樣的</p><blockquote><p>JVM中類的裝載是由ClassLoader和它的子類來實現的,Java ClassLoader是一個重要的Java運行時系統組件。它負責在運行時查找和裝入類文件的類。</p><p>類加載的五個過程：加載、驗證、準備、解析、初始化。</p></blockquote><p>從類被加載到虛擬機內存中開始，到卸御出內存為止，它的整個生命週期分為7個階段，加載(Loading)、驗證(Verification)、準備(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中驗證、準備、解析三個部分統稱為連接。</p><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/4b0100044b5fb68d6337><p class=pgc-img-caption></p></div><p>15.什麼是冪等性</p><p>所謂冪等，簡單地說，就是對接口的多次調用所產生的結果和調用一次是一致的。</p><p>那麼我們為什麼需要接口具有冪等性呢？設想一下以下情形：</p><ul><li>在App中下訂單的時候，點擊確認之後，沒反應，就又點擊了幾次。在這種情況下，如果無法保證該接口的冪等性，那麼將會出現重複下單問題。</li><li>在接收消息的時候，消息推送重複。如果處理消息的接口無法保證冪等，那麼重複消費消息產生的影響可能會非常大。</li></ul><p>16.有哪些 JVM 調優經驗</p><blockquote><p>Jvm參數總結：http://linfengying.com/?p=2470</p></blockquote><ul><li>內存參數</li></ul><p>參數作用</p><p>-Xmx堆大小的最大值。當前主流虛擬機的堆都是可擴展的</p><p>-Xms堆大小的最小值。可以設置成和 -Xmx 一樣的值</p><p>-Xmn新生代的大小。現代虛擬機都是“分代”的，因此堆空間由新生代和老年代組成。新生代增大，相應地老年代就減小。Sun官方推薦新生代佔整個堆的3/8</p><p>-Xss每個線程的堆棧大小。該值影響一臺機器能夠創建的線程數上限</p><p>-XX:MaxPermSize=永久代的最大值。永久代是 HotSpot 特有的，HotSpot 用永久代來實現方法區</p><p>-XX:PermSize=永久代的最小值。可以設置成和 -XX:MaxPermSize 一樣的值</p><p>-XX:SurvivorRatio=Eden 和 Survivor 的比值。基於“複製”的垃圾收集器又會把新生代分為一個 Eden 和兩個 Survivor，如果該參數為8，就表示 Eden佔新生代的80%，而兩個 Survivor 各佔10%。默認值為8-XX:PretenureSizeThreshold=直接晉升到老年代的對象大小。大於這個參數的對象將直接在老年代分配。默認值為0，表示不啟用</p><p>-XX:HandlePromotionFailure=是否允許分配擔保失敗。在 JDK 6 Update 24 後該參數已經失效。</p><p>-XX:MaxTenuringThreshold=對象晉升到老年代的年齡。對象每經過一次 Minor GC 後年齡就加1，超過這個值時就進入老年代。默認值為15</p><p>-XX:MaxDirectMemorySize=直接內存的最大值。對於頻繁使用 nio 的應用，應該顯式設置該參數，默認值為0</p><ul><li>GC參數</li></ul><p>垃圾收集器參數備註Serial（新生代）-XX:+UseSerialGC虛擬機在 Client 模式下的默認值，打開此開關後，使用 Serial + Serial Old 的收集器組合。Serial 是一個單線程的收集器ParNew（新生代）-XX:+UseParNewGC強制使用 ParNew，打開此開關後，使用 ParNew + Serial Old 的收集器組合。ParNew 是一個多線程的收集器，也是 server 模式下首選的新生代收集器-XX:ParallelGCThreads=垃圾收集的線程數Parallel Scavenge（新生代）-XX:+UseParallelGC虛擬機在 Server 模式下的默認值，打開此開關後，使用 Parallel Scavenge + Serial Old 的收集器組合-XX:MaxGCPauseMillis=單位毫秒，收集器儘可能保證單次內存回收停頓的時間不超過這個值。-XX:GCTimeRatio=總的用於 gc 的時間佔應用程序的百分比，該參數用於控制程序的吞吐量-XX:+UseAdaptiveSizePolicy設置了這個參數後，就不再需要指定新生代的大小（-Xmn）、 Eden 和 Survisor 的比例（-XX:SurvivorRatio）以及晉升老年代對象的年齡（-XX:PretenureSizeThreshold）了，因為該收集器會根據當前系統的運行情況自動調整。當然前提是先設置好前兩個參數。Serial Old（老年代）無Serial Old 是 Serial 的老年代版本，主要用於 Client 模式下的老生代收集，同時也是 CMS 在發生 Concurrent Mode Failure 時的後備方案Parallel Old（老年代）-XX:+UseParallelOldGC打開此開關後，使用 Parallel Scavenge + Parallel Old 的收集器組合。Parallel Old 是 Parallel Scavenge 的老年代版本，在注重吞吐量和 CPU 資源敏感的場合，可以優先考慮這個組合CMS（老年代）-XX:+UseConcMarkSweepGC打開此開關後，使用 ParNew + CMS 的收集器組合。-XX:CMSInitiatingOccupancyFraction=CMS 收集器在老年代空間被使用多少後觸發垃圾收集-XX:+UseCMSCompactAtFullCollection在完成垃圾收集後是否要進行一次內存碎片整理-XX:CMSFullGCsBeforeCompaction=在進行若干次垃圾收集後才進行一次內存碎片整理</p><p><strong>附圖：可以配合使用的收集器組合</strong></p><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4b0000045c1cd7d710f5><p class=pgc-img-caption></p></div><blockquote><p>上面有7中收集器，分為兩塊，上面為新生代收集器，下面是老年代收集器。如果兩個收集器之間存在連線，就說明它們可以搭配使用。</p></blockquote><ul><li>其他參數</li></ul><p>參數作用-verbose:class打印類加載過程-XX:+PrintGCDetails發生垃圾收集時打印 gc 日誌，該參數會自動帶上 -verbose:gc 和 -XX:+PrintGC-XX:+PrintGCDateStamps / -XX:+PrintGCTimeStamps打印 gc 的觸發事件，可以和 -XX:+PrintGC 和 -XX:+PrintGCDetails 混用-Xloggc:gc 日誌路徑-XX:+HeapDumpOnOutOfMemoryError出現 OOM 時 dump 出內存快照用於事後分析-XX:HeapDumpPath=堆轉儲快照的文件路徑</p><p>17.分佈式 CAP 瞭解嗎？</p><blockquote><p>一致性(Consistency)</p><p>可用性(Availability)</p><p>分區容忍性(Partition tolerance)</p></blockquote><p>18.Java中HashMap的key值要是為類對象則該類需要滿足什麼條件？</p><p>需要同時重寫該類的hashCode()方法和它的equals()方法。</p><blockquote><p>當程序試圖將一個 key-value 對放入 HashMap 中時，程序首先根據該 key 的 hashCode() 返回值決定該 Entry 的存儲位置：如果兩個 Entry 的 key 的 hashCode() 返回值相同，那它們的存儲位置相同。如果這兩個 Entry 的 key 通過 equals 比較返回 true，新添加 Entry 的 value 將覆蓋集合中原有 Entry 的 value，但 key 不會覆蓋。如果這兩個 Entry 的 key 通過 equals 比較返回 false，新添加的 Entry 將與集合中原有 Entry 形成 Entry 鏈，而且新添加的 Entry 位於 Entry 鏈的頭部——具體說明繼續看 addEntry() 方法的說明。</p></blockquote><p>19.java 垃圾回收會出現不可回收的對象嗎？怎麼解決內存洩露問題？怎麼定位問題源？</p><p>一般不會有不可回收的對象，因為現在的GC會回收不可達內存。</p><p>20.終止線程有幾種方式？終止線程標記變量為什麼是 valotile 類型？</p><blockquote><p>1.線程正常執行完畢，正常結束</p><p>2.監視某些條件，結束線程的不間斷運行</p><p>3.使用interrupt方法終止線程</p></blockquote><p>在定義exit時，使用了一個Java關鍵字volatile，這個關鍵字的目的是使exit同步，也就是說在同一時刻只能由一個線程來修改exit的值</p><p>21.用過哪些併發的數據結構？ cyclicBarrier 什麼功能？信號量作用？數據庫讀寫阻塞怎麼解決</p><ul><li>主要有鎖機制，然後基於CAS的concurrent包。</li><li>CyclicBarrier的字面意思是可循環使用（Cyclic）的屏障（Barrier）。它要做的事情是，讓一組線程到達一個屏障（也可以叫同步點）時被阻塞，直到最後一個線程到達屏障時，屏障才會開門，所有被屏障攔截的線程才會繼續幹活。CyclicBarrier默認的構造方法是CyclicBarrier(int parties)，其參數表示屏障攔截的線程數量，每個線程調用await方法告訴CyclicBarrier我已經到達了屏障，然後當前線程被阻塞。</li><li><strong>CountDownLatch的計數器只能使用一次。而CyclicBarrier的計數器可以使用reset() 方法重置。</strong></li><li><strong>Semaphore（信號量）是用來控制同時訪問特定資源的線程數量，它通過協調各個線程，以保證合理的使用公共資源。</strong>很多年以來，我都覺得從字面上很難理解Semaphore所表達的含義，只能把它比作是控制流量的紅綠燈，比如XX馬路要限制流量，只允許同時有一百輛車在這條路上行使，其他的都必須在路口等待，所以前一百輛車會看到綠燈，可以開進這條馬路，後面的車會看到紅燈，不能駛入XX馬路，但是如果前一百輛中有五輛車已經離開了XX馬路，那麼後面就允許有5輛車駛入馬路，這個例子裡說的車就是線程，駛入馬路就表示線程在執行，離開馬路就表示線程執行完成，看見紅燈就表示線程被阻塞，不能執行。</li></ul><p>22.關於抽象類和接口的關係</p><blockquote><p>簡言之抽象類是一種功能不全的類，接口只是一個抽象方法聲明和靜態不能被修改的數據的集合，兩者都不能被實例化。</p><p>從某種意義上說，接口是一種特殊形式的抽象類，在java語言中抽象類表示的是一種繼承關係，一個類只能繼承繼承一個抽象類，而一個類卻可以實現多個接口。在許多情況下，接口確實可以代替抽象類，如果你不需要刻意表達屬性上的繼承的話。</p></blockquote><p>23.堆內存和棧內存的區別</p><blockquote><p><strong>寄存器</strong>：JVM內部虛擬寄存器，存取速度非常快，程序不可控制。</p><p><strong>棧</strong>：保存局部變量的值包括：1.保存基本數據類型的值；2.保存引用變量，即堆區對象的引用(指針)。也可以用來保存加載方法時的幀。</p><p><strong>堆</strong>：用來存放動態產生的數據，比如new出來的對象。注意創建出來的對象只包含屬於各自的成員變量，並不包括成員方法。因為同一個類的對象擁有各自的成員變量，存儲在各自的堆中，但是他們共享該類的方法，並不是每創建一個對象就把成員方法複製一次。</p><p><strong>常量池</strong>：JVM為每個已加載的類型維護一個常量池，常量池就是這個類型用到的常量的一個有序集合。包括直接常量(基本類型，String)和對其他類型、方法、字段的符號引用(1)。池中的數據和數組一樣通過索引訪問。由於常量池包含了一個類型所有的對其他類型、方法、字段的符號引用，所以常量池在Java的動態鏈接中起了核心作用。常量池存在於堆中。</p><p><strong>代碼段</strong>：用來存放從硬盤上讀取的源程序代碼。</p><p><strong>數據段</strong>：用來存放static修飾的靜態成員（在java中static的作用就是說明該變量，方法，代碼塊是屬於類的還是屬於實例的）。</p></blockquote><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/4afd0004b0b7f266bb36><p class=pgc-img-caption></p></div><p>24.關於Java文件的內部類的解釋？匿名內部類是什麼？如何訪問在其外面定義的變量？</p><blockquote><p>java中的內部類總結</p><p>靜態內部類不能訪問外部類非靜態的成員</p><p>###25.關於重載和重寫的區別</p><p>重載是overload，是一個類中同方法名的不同具體實現。然後重寫是override，是子類重寫父類中的方法。</p></blockquote><p>26.String、StringBuffer與StringBuilder之間區別</p><blockquote><p>1.三者在執行速度方面的比較：StringBuilder > StringBuffer > String</p><p>String：字符串常量</p><p>StringBuffer：字符串變量</p><p>StringBuilder：字符串變量</p><p>2.StringBuilder：線程非安全的,StringBuffer：線程安全的</p><p><strong>對於三者使用的總結：</strong></p><p>1.如果要操作少量的數據用 = String</p><p>2.單線程操作字符串緩衝區 下操作大量數據 = StringBuilder</p><p>3.多線程操作字符串緩衝區 下操作大量數據 = StringBuffer</p></blockquote><p>27.運行時異常與一般異常有何異同？常見異常</p><blockquote><p>Java提供了兩類主要的異常:runtime exception和checked exception</p><p>常見異常：NullPointerException、IndexOutOfBoundsException、ClassNotFoundException，IllegalArgumentException，ClassCastException(數據類型轉換異常)</p></blockquote><p>###28.error和exception有什麼區別?</p><blockquote><p>error 表示恢復不是不可能但很困難的情況下的一種嚴重問題。比如說內存溢出。不可能指望程序能處理這樣的情況。</p><p>exception表示一種設計或實現問題。也就是說，它表示如果程序運行正常，從不會發生的情況。</p></blockquote><p>###29.Java異常處理機制</p><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/4b0000045c1ed0c04542><p class=pgc-img-caption></p></div><blockquote><p>1.捕獲異常：try、catch 和 finally</p><p>2.拋出異常</p><p>2.1. throws拋出異常</p></blockquote><pre>12methodname throws Exception1,Exception2,..,ExceptionN{ }</pre><p>30.java中有幾種方法可以實現一個線程?</p><blockquote><p>Java多線程學習（吐血超詳細總結）</p><p>40個Java多線程問題總結</p></blockquote><hr><blockquote><p>1.class Thread1 extends Thread{},然後重寫run方法</p><p>2.class Thread2 implements Runnable{},然後重寫run方法</p><p>3.class Thread3 implements Callable{},然後new FutureTask(thread3),再用new Thread(future)封裝。</p></blockquote><pre>123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Thread1 extends Thread {private String name;public Thread1(String name) {this.name = name;}@Overridepublic void run() {for (int i = 0; i &lt; 5; i++) {System.out.println(name + "運行---&gt;&gt;&gt;" + i);}}public static void main(String[] args) {Thread1 mTh11=new Thread1("A");Thread1 mTh12=new Thread1("B");mTh1.start();mTh2.start();}}class Thread2 implements Runnable {private String name;private int count = 15;public Thread2() {}public Thread2(String name) {this.name = name;}public void run() {for (int i = 0; i &lt; 5; i++) {System.out.println(Thread.currentThread().getName() + "運行 : " + count--);}}public static void main(String[] args) {Thread2 mTh2 = new Thread2();new Thread(mTh2, "C").start();new Thread(mTh2, "D").start();}}class MyCallableThread implements Callable&lt;Integer&gt;{public Integer call() throws Exception {int i = 0;for(;i&lt;100;i++){System.out.println(Thread.currentThread().getName()+" "+i);}return i;}public static void main(String[] args) {MyCallableThread mct = new MyCallableThread();FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(mct);for(int i = 0;i &lt; 100;i++){System.out.println(Thread.currentThread().getName()+" 的循環變量i的值"+i);if(i==20){new Thread(ft,"有返回值的線程").start();}}try{System.out.println("子線程的返回值："+ft.get());} catch (InterruptedException e){e.printStackTrace();} catch (ExecutionException e){e.printStackTrace();}}}</pre><blockquote><p><strong>如果一個類繼承Thread，則不適合資源共享。但是如果實現了Runable接口的話，則很容易的實現資源共享。</strong></p></blockquote><p>31.Java中常用的類，包，接口。</p><blockquote><p>class: ‘Date’,’System’,’Calender’,’Math’,’ArrayList’,’HashMap’</p><p>package: ‘java.lang’,’java.util’,’java.io’,’java.sql’,’java.net’</p><p>interface: ‘Collection’,’Map’,’List’,’Runnable’,’Callable’</p></blockquote><p>32.java在處理線程同步時，常用方法有：</p><blockquote><p>1、synchronized關鍵字。</p><p>2、Lock顯示加鎖。</p><p>3、信號量Semaphore。</p><p>4、CAS算法</p><p>5、concurrent包</p></blockquote><p>33.Spring IOC/AOP？</p><blockquote><p>回答了IOC/DI、AOP的概念。</p><p>AOP（Aspect-OrientedProgramming，面向方面編程），可以說是OOP（Object-Oriented Programing，面向對象編程）的補充和完善。</p><p>OOP引入封裝、繼承和多態性等概念來建立一種對象層次結構，用以模擬公共行為的一個集合。當我們需要為分散的對象引入公共行為的時候，OOP則顯得無能為力。</p><p>也就是說，OOP允許你定義從上到下的關係，但並不適合定義從左到右的關係。例如日誌功能。日誌代碼往往水平地散佈在所有對象層次中，而與它所散佈到的對象的核心功能毫無關係。</p><p>對於其他類型的代碼，如安全性、異常處理和透明的持續性也是如此。這種散佈在各處的無關的代碼被稱為橫切（cross-cutting）代碼，</p><p>在OOP設計中，它導致了大量代碼的重複，而不利於各個模塊的重用。</p><p>依賴注入(Dependency Injection)和控制反轉(Inversion of Control)是同一個概念。</p><p>當某個角色(可能是一個Java實例，調用者)需要另一個角色(另一個Java實例，被調用者)的協助時，在傳統的程序設計過程中，通常由調用者來創建被調用者的實例。</p><p>但在Spring裡，創建被調用者的工作不再由調用者來完成，因此稱為控制反轉;創建被調用者 實例的工作通常由Spring容器來完成，然後注入調用者，因此也稱為依賴注入。</p><p>不管是依賴注入，還是控制反轉，都說明Spring採用動態、靈活的方式來管理各種對象。對象與對象之間的具體實現互相透明。</p><p>在理解依賴注入之前，看如下這個問題在各種社會形態裡如何解決:一個人(Java實例，調用者)需要一把斧子(Java實例，被調用者)。</p></blockquote><p>34.對JVM的垃圾回收的認識?</p><p>垃圾回收器的作用是查找和回收（清理）無用的對象。以便讓JVM更有效的使用內存。</p><p>35.進程與線程的區別，及其通信方式</p><blockquote><p>線程與進程的區別及其通信方式</p><p>區別</p><p>1.一個程序至少有一個進程,一個進程至少有一個線程.</p><p>2.進程在執行過程中擁有獨立的內存單元，而多個線程共享內存</p><p>3.線程是進程的一個實體,是CPU調度和分派的基本單位</p></blockquote><ul><li>進程間通信</li></ul><pre>1234561.管道（Pipe）及有名管道（named pipe）2.信號（Signal）3.消息隊列（Message）4.共享內存5.信號量（semaphore）6.套接口（Socket）</pre><p>36.JVM如何GC，新生代，老年代，持久代，都存儲哪些東西？</p><p>JVM的GC算法有：引用計數器算法，根搜索方法</p><p>新生成的對象首先都是放在年輕代的。年輕代的目標就是儘可能快速的收集掉那些生命週期短的對象。</p><p>在年輕代中經歷了N次垃圾回收後仍然存活的對象，就會被放到年老代中。因此，可以認為年老代中存放的都是一些生命週期較長的對象。</p><p>持久代主要存放的是Java類的類信息</p><p>37.JVM分為哪些區，每一個區幹嘛的？</p><p>問：Java運行時數據區域？</p><p>回答：包括程序計數器、JVM棧、本地方法棧、方法區、堆</p><p>問：方法區裡存放什麼？</p><p>本地方法棧：和jvm棧所發揮的作用類似，區別是jvm棧為jvm執行java方法（字節碼）服務，而本地方法棧為jvm使用的native方法服務。</p><p>JVM棧：局部變量表、操作數棧、動態鏈接、方法出口。</p><p>方法區：用於存儲已被虛擬機加載的類信息，常量、靜態變量、即時編譯器編譯後的代碼等。</p><p>堆：存放對象實例。</p><p>38.GC用的引用可達性分析算法中，哪些對象可作為GC Roots對象？</p><ul><li>虛擬機棧（棧幀中的本地變量表）中引用的對象；</li><li>方法區中類靜態屬性引用的對象；</li><li>方法區中常量引用的對象；</li><li>本地方法棧中JNI（即一般說的Native方法）引用的對象</li></ul><p>39.用什麼工具調試程序？jmap、jstack,JConsole，用過嗎？</p><p>虛擬機性能監控與調優實戰–博客</p><p>40.線程池用過嗎？</p><blockquote><p>線程池–併發編程網 - ifeve.com</p></blockquote><p>線程池（Thread Pool）對於限制應用程序中同一時刻運行的線程數很有用。因為每啟動一個新線程都會有相應的性能開銷，每個線程都需要給棧分配一些內存等等。</p><p>我們可以把併發執行的任務傳遞給一個線程池，來替代為每個併發執行的任務都啟動一個新的線程。只要池裡有空閒的線程，任務就會分配給一個線程執行。在線程池的內部，任務被插入一個阻塞隊列（Blocking Queue ），線程池裡的線程會去取這個隊列裡的任務。當一個新任務插入隊列時，一個空閒線程就會成功的從隊列中取出任務並且執行它。</p><p>41.操作系統如何進行分頁調度？–<strong>要考LRU</strong></p><blockquote><p>1.最講置換原則-OPT</p><p>2.先進先出原則-FIFO</p><p>3.最近最少使用置換算法-LRU</p><p>4.時鐘置換算法</p></blockquote><pre>12345678910111213141516171819//擴展一下LinkedHashMap這個類，讓他實現LRU算法class LRULinkedHashMap&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt;{//定義緩存的容量private int capacity;private static final long serialVersionUID = 1L;//帶參數的構造器LRULinkedHashMap(int capacity){//調用LinkedHashMap的構造器，傳入以下參數super(16,0.75f,true);//傳入指定的緩存最大容量this.capacity=capacity;}//實現LRU的關鍵方法，如果map裡面的元素個數大於了緩存最大容量，則刪除鏈表的頂端元素@Overridepublic boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest){System.out.println(eldest.getKey() + "=" + eldest.getValue());return size()&gt;capacity;}}</pre><p>42.講講LinkedHashMap</p><blockquote><p>Java8 LinkedHashMap工作原理及實現</p></blockquote><p>LinkedHashMap是通過哈希表和鏈表實現的，它通過維護一個鏈表來保證對哈希表迭代時的有序性，而這個有序是指鍵值對插入的順序。</p><p>LinkedHashMap 的大致實現如下圖所示，當然鏈表和哈希表中相同的鍵值對都是指向同一個對象，這裡把它們分開來畫只是為了呈現出比較清晰的結構。</p><div class=pgc-img><img alt=面試總結-Java高級篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/4b020002f82b65325b05><p class=pgc-img-caption></p></div><p>LinkedHashMap是Hash表和鏈表的實現，並且依靠著雙向鏈表保證了迭代順序是插入的順序。</p><p><strong>三個重點實現的函數</strong></p><p>在HashMap中提到了下面的定義：</p><pre>1234567// Callbacks to allow LinkedHashMap post-actions//1.把當前節點e移至鏈表的尾部。因為使用的是雙向鏈表，所以在尾部插入可以以O（1）的時間複雜度來完成。並且只有當accessOrder設置為true時，才會執行這個操作。在HashMap的putVal方法中，就調用了這個方法。void afterNodeAccess(Node&lt;K,V&gt; p) { }//2.afterNodeInsertion方法是在哈希表中插入了一個新節點時調用的，它會把鏈表的頭節點刪除掉，刪除的方式是通過調用HashMap的removeNode方法。通過afterNodeInsertion方法和afterNodeAccess方法，是不是就可以簡單的實現一個基於最近最少使用（LRU）的淘汰策略了？當然，我們還要重寫removeEldestEntry方法，因為它默認返回的是false。void afterNodeInsertion(boolean evict) { }//3.這個方法是當HashMap刪除一個鍵值對時調用的，它會把在HashMap中刪除的那個鍵值對一併從鏈表中刪除，保證了哈希表和鏈表的一致性。void afterNodeRemoval(Node&lt;K,V&gt; p) { }</pre><p>LinkedHashMap繼承於HashMap，因此也重新實現了這3個函數，顧名思義這三個函數的作用分別是：節點訪問後、節點插入後、節點移除後做一些事情。</p><p>43.線程同步與阻塞的關係？同步一定阻塞嗎？阻塞一定同步嗎？,同步和異步有什麼區別？</p><blockquote><p>同步與非同步：主要是保證<strong>互斥的訪問臨界資源</strong>的情況</p><p>阻塞與非阻塞：主要是從 CPU 的消耗上來說的</p></blockquote><p>44.int與Integer的區別，分別什麼場合使用</p><pre>12341、Integer是int提供的封裝類，而int是Java的基本數據類型2、Integer默認值是null，而int默認值是0；3、聲明為Integer的變量需要實例化，而聲明為int的變量不需要實例化；4、Integer是對象，用一個引用指向這個對象，而int是基本類型，直接存儲數值。</pre><p>int是基本數據類型，Integer是包裝類，類似HashMap這樣的結構必須使用包裝類，因為包裝類繼承自Object,都需要實現HashCode，所以可以使用在HashMap這類數據結構中。</p><p>45.RPC的詳細過程</p><blockquote><p>RPC主要的重點有：</p><p>動態代理,主要是invoke反射原理</p><p>序列化,使用Thrift的效率高</p><p>通信方式,使用Netty的NIO能提高效率</p><p>服務發現,使用zookeeper可以實現</p></blockquote><ul><li>1）服務消費方（client）調用以本地調用方式調用服務；</li><li>2）client stub接收到調用後負責將方法、參數等組裝成能夠進行網絡傳輸的消息體；</li><li>3）client stub找到服務地址，並將消息發送到服務端；</li><li>4）server stub收到消息後進行解碼；</li><li>5）server stub根據解碼結果調用本地的服務；</li><li>6）本地服務執行並將結果返回給server stub；</li><li>7）server stub將返回結果打包成消息併發送至消費方；</li><li>8）client stub接收到消息，並進行解碼；</li><li>9）服務消費方得到最終結果。</li></ul><p>關注我：私信回覆“架構資料”獲取往期Java高級架構資料、源碼、筆記、視頻</p><p>Dubbo、Redis、設計模式、Netty、zookeeper、Spring cloud、分佈式、</p><p>高併發等架構技術</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>總結</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6886951d.html alt="IT面試---Java基礎：Collection 和 Collections 有什麼區別？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a61f90ddf82c41ffb6fb3b30b86ea5bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6886951d.html title="IT面試---Java基礎：Collection 和 Collections 有什麼區別？">IT面試---Java基礎：Collection 和 Collections 有什麼區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1b27915.html alt=Java總結之容器家族--Collection class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/88ce4e8325964ee3aac0b015656a3c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1b27915.html title=Java總結之容器家族--Collection>Java總結之容器家族--Collection</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7b89313.html alt=十年程序員總結：Java之集合Collection總覽 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ff7018c5f0c247fe9e1065846beba6f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7b89313.html title=十年程序員總結：Java之集合Collection總覽>十年程序員總結：Java之集合Collection總覽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7816c067.html alt=Java高級面試寶典，必備分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7816c067.html title=Java高級面試寶典，必備分享>Java高級面試寶典，必備分享</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68200806.html alt=面試官：兄弟，說說Java到底是值傳遞還是引用傳遞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8427a88278d4440e90b95ad363ecad34 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68200806.html title=面試官：兄弟，說說Java到底是值傳遞還是引用傳遞>面試官：兄弟，說說Java到底是值傳遞還是引用傳遞</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/419b9a44.html alt=熬了7天，總結出來了Java中動態規則的實現方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/419b9a44.html title=熬了7天，總結出來了Java中動態規則的實現方式>熬了7天，總結出來了Java中動態規則的實現方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/754c19ae.html alt=Java集合框架常見面試問題剖析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/74010d4d11bc4d0494947b59936d6a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/754c19ae.html title=Java集合框架常見面試問題剖析>Java集合框架常見面試問題剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af89575d.html alt=面試官：熟悉Java集合？那來聊聊HashMap吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3d5272f4ff3046ba946d292d85ef92b7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af89575d.html title=面試官：熟悉Java集合？那來聊聊HashMap吧>面試官：熟悉Java集合？那來聊聊HashMap吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8da88db.html alt="Java面試官：請說下java向上轉型和向下轉型 程序汪：不清楚啊" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e3a0cd7f20054843a3e8559998a96263 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8da88db.html title="Java面試官：請說下java向上轉型和向下轉型 程序汪：不清楚啊">Java面試官：請說下java向上轉型和向下轉型 程序汪：不清楚啊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ee3fbb9.html alt=Java面試都會涉及到哪些內容？Java筆試題庫（三） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/17503d30-904f-41c0-b073-bfcb1ee363ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ee3fbb9.html title=Java面試都會涉及到哪些內容？Java筆試題庫（三）>Java面試都會涉及到哪些內容？Java筆試題庫（三）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc996cea.html alt=Java面試基礎回顧05-子類繼承父類的注意點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc996cea.html title=Java面試基礎回顧05-子類繼承父類的注意點>Java面試基礎回顧05-子類繼承父類的注意點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc35e6bd.html alt=一文總結Java中原子類相關實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2dfc593b3b104a499d6d736518072928 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc35e6bd.html title=一文總結Java中原子類相關實現>一文總結Java中原子類相關實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/015102c.html alt=Java面試基礎回顧17-多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6c2ec55fb7c24df2858c3d9da1a00019 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/015102c.html title=Java面試基礎回顧17-多態>Java面試基礎回顧17-多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>