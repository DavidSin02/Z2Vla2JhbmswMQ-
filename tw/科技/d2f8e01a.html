<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux C 字符串函數 sprintf()、snprintf() 詳解 | 极客快訊</title><meta property="og:title" content="Linux C 字符串函數 sprintf()、snprintf() 詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2f8e01a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2f8e01a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d2f8e01a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2f8e01a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2f8e01a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d2f8e01a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d2f8e01a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2f8e01a.html><meta property="article:published_time" content="2020-11-14T21:05:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:09+08:00"><meta name=Keywords content><meta name=description content="Linux C 字符串函數 sprintf()、snprintf() 詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d2f8e01a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux C 字符串函數 sprintf()、snprintf() 詳解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>一、sprintf() 函數詳解</h1><p>在將各種類 型的數據構造成字符串時，sprintf 的強大功能很少會讓你失望。</p><p>由於 sprintf 跟 printf 在用法上幾乎一樣，只是打印的目的地不同而已，前者打印到字符串中，後者則直接在命令行上輸出。這也導致 sprintf 比 printf 有用得多。所以本文著重介紹 sprintf，有時也穿插著用用 pritnf。</p><p>sprintf是個變參函數，定義如下：</p><blockquote><p>int sprintf( char *buffer, const char *format [, argument] … );</p></blockquote><p>除了前兩個參數類型固定外，後面可以接任意多個參數。而它的精華，顯然就在第二個參數：格式化字符串上。</p><p>printf 和 sprintf 都使用格式化字符串來指 定串的格式，在格式串內部使用一些以“%”開頭的格式說明符（format specifications）來佔據一個位置，在後邊的變參列表中提供相應的變量，最終函數就會用相應位置的變量來替代那個說明符，產生一個調用者想要 的字符串。</p><p><strong>1、格式化數字字符串</strong></p><p>sprintf最常見的應用之一莫過於把整數打印到字符串中，所以，spritnf 在大多數場合可以替代itoa。如：</p><p>// 把整數123打印成一個字符串保存在s中。</p><pre>sprintf(s, "%d", 123); // 產生"123"</pre><p>可以指定寬度，不足的左邊補空格：</p><pre>sprintf(s, "%8d%8d", 123, 4567); // 產生：" 123 4567"</pre><p>當然也可以左對齊：</p><pre>sprintf(s, "%-8d%8d", 123, 4567); // 產生："123 4567"</pre><p>也可以按照16進制打印：</p><pre>sprintf(s, "%8x", 4567); // 小寫16進制，寬度佔8個位置，右對齊sprintf(s, "%-8X", 4568); // 大寫16進制，寬度佔8個位置，左對齊</pre><p>這樣，一個整數的16進制字符串就很容易得到，但我們在打印16進制內容時，通常想要一種左邊補0的等寬格式，那該怎麼做呢？很簡單，在表示寬度的數字前面加個0就可以了。</p><pre>sprintf(s, "%08X", 4567); // 產生："000011D7"</pre><p>上面以 "%d" 進行的10進制打印同樣也可以使用這種左邊補0的方式。</p><p>這裡要注意一個符號擴展的問題：比如，假如我們想打印短整數（short）-1的內存16進製表示形式，在Win32平臺上，一個 short 型佔2個字節，所以我們自然希望用4個16進制數字來打印它：</p><pre>short si = -1;sprintf(s, "%04X", si);</pre><p>產生 "FFFFFFFF"，怎麼回事？因為 spritnf 是個變參函數，除了前面兩個參數之外，後面的參數都不是類型安全的，函數更沒有辦法僅僅通過一個“%X”就能得知當初函數調用前參數壓棧時 被壓進來的到底是個4字節的整數還是個2字節的短整數，所以採取了統一4字節的處理方式，導致參數壓棧時做了符號擴展，擴展成了32位的整數-1，打印時 4個位置不夠了，就把32位整數-1的8位16進制都打印出來了。如果你想看si的本來面目，那麼就應該讓編譯器做0擴展而不是符號擴展（擴展時二進制左 邊補0而不是補符號位）：</p><pre>sprintf(s, "%04X", (unsigned short)si);</pre><p>就可以了。或者：</p><pre>unsigned short si = -1;sprintf(s, "%04X", si);</pre><p>sprintf 和 printf 還可以按8進制打印整數字符串，使用“%o”。注意8進制和16進制都不會打印出負數，都是無符號的，實際上也就是變量的內部編碼的直接的16進制或8進製表示。</p><p><strong>2、控制浮點數打印格式</strong></p><p>浮點數的打印和格式控制是 sprintf 的又一大常用功能，浮點數使用格式符“%f”控制，默認保留小數點後6位數字，比如：</p><pre>sprintf(s, "%f", 3.1415926); // 產生 "3.141593"</pre><p>但有時我們希望自己控制打印的寬度和小數位數，這時就應該使用：“%m.nf”格式，其中m表示打印的寬度，n表示小數點後的位數。比如：</p><pre>sprintf(s, "%10.3f", 3.1415626);	// 產生：" 3.142″sprintf(s, "%-10.3f", 3.1415626);	// 產生："3.142 "sprintf(s, "%.3f", 3.1415626);		// 不指定總寬度，產生："3.142"</pre><p>注意一個問題，你猜</p><pre>int i = 100;sprintf(s, "%.2f", i);</pre><p>會打出什麼東東來？“100.00”？對嗎？自己試試就知道了，同時也試試下面這個：</p><pre>sprintf(s, "%.2f", (double)i);</pre><p>第一個打出來的肯定不是正確結果，原因跟前面提到的一樣，參數壓棧時調用者並不知道跟i相對應的格式控制符是個“%f”。而函數執行時函數本身則並不知道當年被壓入棧裡的是個整數，於是可憐的保存整數i的那4個字節就被不由分說地強行作為浮點數格式來解釋了，整個亂套了。</p><p>不過，如果有人有興趣使用手工編碼一個浮點數，那麼倒可以使用這種方法來檢驗一下你手工編排的結果是否正確。</p><p><strong>字符/Ascii碼對照</strong></p><p>我們知道，在C/C++語言中，char也是一種普通 的scalable類型，除了字長之外，它與short，int，long這些類型沒有本質區別，只不過被大家習慣用來表示字符和字符串而已。</p><p>（或許當年 該把這個類型叫做“byte”，然後現在就可以根據實際情況，使用 byte 或 short 來把 char 通過 typedef 定義出來，這樣更合適些）</p><p>於是，使用“%d”或者“%x”打印一個字符，便能得 出它的10進制或16進制的ASCII碼；反過來，使用“%c”打印一個整數，便可以看到它所對應的ASCII字符。以下程序段把所有可見字符的 ASCII碼對照表打印到屏幕上（這裡採用printf，注意“#”與“%X”合用時自動為16進制數增加“0X”前綴）：</p><pre>for (int i = 32; i &lt; 127; i++){	printf("[ %c ]: %3d 0x%#04X/n", i, i, i);}</pre><p><strong>3、連接字符串</strong></p><p>sprintf的格式控制串中既然可以插入各種東西，並最終把它們“連成一串”，自然也就能夠連接字符串，從而在許多場合可以替代 strcat，但 sprintf 能夠一次連接多個字符串（自然也可以同時在它們中間插入別的內容，總之非常靈活）。比如：</p><pre>char *who = "I";char *whom = "52PHP";sprintf(s, "%s love %s.", who, whom); // 產生："I love 52PHP. "</pre><p>strcat 只能連接字符串（一段以 '\0' 結尾的字 符數組或叫做字符緩衝，null-terminated-string），但有時我們有兩段字符緩衝區，他們並不是以 '\0' 結尾。比如許多從第三方庫函 數中返回的字符數組，從硬件或者網絡傳輸中讀進來的字符流，它們未必每一段字符序列後面都有個相應的 '\0' 來結尾。如果直接連接，不管是 sprintf 還是 strcat 肯定會導致非法內存操作，而 strncat 也至少要求第一個參數是個 null-terminated-string，那該怎麼辦呢？我們 自然會想起前面介紹打印整數和浮點數時可以指定寬度，字符串也一樣的。比如：</p><pre>char a1[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};char a2[] = {'H', 'I', 'J', 'K', 'L', 'M', 'N'};</pre><p>如果：</p><pre>sprintf(s, "%s%s", a1, a2); // Don’t do that!</pre><p>十有八九要出問題了。是否可以改成：</p><pre>sprintf(s, "%7s%7s", a1, a2);</pre><p>也沒好到哪兒去，正確的應該是：</p><pre>sprintf(s, "%.7s%.7s", a1, a2); // 產生："ABCDEFGHIJKLMN"</pre><p>這可以類比打印浮點數的“%m.nf”，在“%m.ns”中，m表示佔用寬度（字符串長度不足時補空格，超出了則按照實際寬度打印），n才表示從相應的字符串中最多取用的字符數。通常在打印字符串時m沒什麼大用，還是點號後面的n用的多。自然，也可以前後都只取部分字符：</p><pre>sprintf(s, "%.6s%.5s", a1, a2); // 產生："ABCDEFHIJKL"</pre><p>在許多時候，我們或許還希望這些格式控制符中用以指定 長度信息的數字是動態的，而不是靜態指定的，因為許多時候，程序要到運行時才會清楚到底需要取字符數組中的幾個字符，這種動態的寬度/精度設置功能在 sprintf 的實現中也被考慮到了，sprintf 採用“*”來佔用一個本來需要一個指定寬度或精度的常數數字的位置，同樣，而實際的寬度或精度就可以 和其它被打印的變量一樣被提供出來，於是，上面的例子可以變成：</p><pre>sprintf(s, "%.*s%.*s", 7, a1, 7, a2);</pre><p>或者：</p><pre>sprintf(s, "%.*s%.*s", sizeof(a1), a1, sizeof(a2), a2);</pre><p>實際上，前面介紹的打印字符、整數、浮點數等都可以動態指定那些常量值，比如：</p><pre>sprintf(s, "%-*d", 4, 'A');				// 產生 "65 "sprintf(s, "%#0*X", 8, 128);			// 產生 "0X000080″，"#"產生0Xsprintf(s, "%*.*f", 10, 2, 3.1415926);	// 產生" 3.14″</pre><p><strong>4、打印地址信息</strong></p><p>有時調試程序時，我們可能想查看某些變量或者成員的地址，由於地址或者指針也不過是個32位的數，你完全可以使用打印無符號整數的“%u”把他們打印出來：</p><pre>sprintf(s, "%u", &amp;i);</pre><p>不過通常人們還是喜歡使用16進制而不是10進制來顯示一個地址：</p><pre>sprintf(s, "%08X", &amp;i);</pre><p>然而，這些都是間接的方法，對於地址打印，sprintf 提供了專門的“%p”：</p><pre>sprintf(s, "%p", &amp;i);</pre><p>我覺得它實際上就相當於：</p><pre>sprintf(s, "%0*x", 2 * sizeof(void *), &amp;i);</pre><p><strong>5、利用sprintf的返回值</strong></p><p>較少有人注意 printf/sprintf 函數的返回值，但有時它卻是有用的，spritnf 返回了本次函數調用最終打印到字符緩衝區中的字符數目。也就是說每當一次 sprinf 調用結束以後，你無須再調用一次strlen 便已經知道了結果字符串的長度。如：</p><pre>int len = sprintf(s, "%d", i);</pre><p>對於正整數來說，len便等於整數i的10進制位數。</p><p>下面的是個完整的例子，產生10個[0, 100)之間的隨機數，並將他們打印到一個字符數組s中，以逗號分隔開。</p><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main(int argc, char **argv){	srand(time(0));	char s[64];	int offset = 0;	for (int i = 0; i &lt; 10; i++)	{		offset += sprintf(s + offset, "%d, ", rand() % 100);	}	s[offset - 1] = '\n'; // 將最後一個逗號換成換行符。	printf(s);	return 0;}</pre><p>設想當你從數據庫中取出一條記錄，然後希望把他們的各 個字段按照某種規則連接成一個字符串時，就可以使用這種方法，從理論上講，他應該比不斷的 strcat 效率高，因為 strcat 每次調用都需要先找到最後 的那個 '\0' 的位置，而在上面給出的例子中，我們每次都利用 sprintf 返回值把這個位置直接記下來了。</p><p><strong>6、使用 sprintf 的常見問題</strong></p><p>sprintf是個變參函數，使用時經常出問題，而且只要出問題通常就是能導致程序崩潰的內存訪問錯誤，但好在由sprintf誤用導致的問題雖然嚴重，卻很容易找出，無非就是那麼幾種情況，通常用眼睛再把出錯的代碼多看幾眼就看出來了。</p><p><strong>?? 緩衝區溢出</strong></p><p>第一個參數的長度太短了，沒的說，給個大點的地方吧。當然也可能是後面的參數的問題，建議變參對應一定要細心，而打印字符串時，儘量使用“%.ns”的形式指定最大字符數。</p><p><strong>?? 忘記了第一個參數</strong></p><p>低級得不能再低級問題，用 printf 用得太慣了。// 偶就常犯。</p><p><strong>?? 變參對應出問題</strong></p><p>通常是忘記了提供對應某個格式符的變參，導致以後的參數統統錯位，檢查檢查吧。尤其是對應“*”的那些參數，都提供了嗎？不要把一個整數對應一個“%s”，編譯器會覺得你欺她太甚了。</p><hr><h1>二、snprintf() 詳解</h1><p>函數原型：</p><blockquote><p>int snprintf(char *restrict buf, size_t n, const char * restrict format, ...);</p></blockquote><p>函數說明：最多從源串中拷貝 n－1 個字符到目標串中，然後再在後面加一個 '\0'。所以如果目標串的大小為 n 的話，將不會溢出。</p><p>函數返回值：若成功則返回欲寫入的字符串長度，若出錯則返回負值。</p><p><strong>1、推薦的用法</strong></p><pre>#include &lt;stdio.h&gt;int main(int argc, char **argv){	char str[10] = {0,};	snprintf(str, sizeof(str), "0123456789012345678");	printf("str=%s\n", str);	return 0;}</pre><p>輸出：</p><blockquote><p>str=012345678</p></blockquote><p><strong>2、不推薦的用法</strong></p><pre>#include &lt;stdio.h&gt;int main(int argc, char **argv){	char str[10] = {0,};	snprintf(str, 18, "0123456789012345678");	printf("str=%s/n", str);	return 0;}</pre><p>輸出：</p><blockquote><p>str=01234567890123456</p></blockquote><p><strong>3、snprintf() 函數返回值的測試：</strong></p><pre>#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv){	char str1[10] = {0,};	char str2[10] = {0,};	int ret1 = 0, ret2 = 0;	ret1 = snprintf(str1, sizeof(str1), "%s", "abc");	ret2 = snprintf(str2, 4, "%s", "aaabbbccc");	printf("aaabbbccc length=%d\n", strlen("aaabbbccc"));	printf("str1=%s,ret1=%d\n", str1, ret1);	printf("str2=%s,ret2=%d\n", str2, ret2);	return 0;}</pre><p>輸出：</p><blockquote><p>aaabbbccc length=9</p><p>str1=abc,ret1=3</p><p>str2=aaa,ret2=9</p></blockquote><p><strong>特別注意：</strong></p><p>snprintf() 的返回值是欲寫入的字符串長度，而不是實際寫入的字符串度。如：</p><pre>#include &lt;stdio.h&gt;int main(int argc, char **argv){	char test[8];	int ret = snprintf(test, 5, "1234567890");	printf("%d|%s\n", ret, test);	return 0;}</pre><p>輸出：</p><blockquote><p>10|1234</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>函數</a></li><li><a>sprintf</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e087ca41.html alt=偏導數和函數的梯度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9d20a1e4cbff42a094d57df057fe9597 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e087ca41.html title=偏導數和函數的梯度>偏導數和函數的梯度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fc113b1.html alt=梯度原理：梯度在每一點上都指向函數增長最快的方向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cdb8db41d5024f38a2e490e66baebdb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fc113b1.html title=梯度原理：梯度在每一點上都指向函數增長最快的方向>梯度原理：梯度在每一點上都指向函數增長最快的方向</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/408d3387.html alt=EXCEL:VLOOKUP函數綜合運用，實現供應商每月數據自動查詢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/03e79d133c994f9f8a386b20b04b3da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/408d3387.html title=EXCEL:VLOOKUP函數綜合運用，實現供應商每月數據自動查詢>EXCEL:VLOOKUP函數綜合運用，實現供應商每月數據自動查詢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/526a98f3.html alt=Excel條件求和函數那麼多，高手一直都在用這一個，而你卻沒聽過 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b2fd76f54f9b46c8bd79500ba4dac2fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/526a98f3.html title=Excel條件求和函數那麼多，高手一直都在用這一個，而你卻沒聽過>Excel條件求和函數那麼多，高手一直都在用這一個，而你卻沒聽過</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2664a94c.html alt=excel中的DSUM函數——條件求和原來如此簡單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0dc7aeaa9b61467e86dbaeae6dfeaaa4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2664a94c.html title=excel中的DSUM函數——條件求和原來如此簡單>excel中的DSUM函數——條件求和原來如此簡單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48f18e97.html alt=excel常用函數用法解析第四篇——COLUMN、ROW函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4c3daf45857e4f169def37fc08d652fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48f18e97.html title=excel常用函數用法解析第四篇——COLUMN、ROW函數>excel常用函數用法解析第四篇——COLUMN、ROW函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b9de5637.html alt=比Sum函數好用10倍，它才是Excel求和函數中的NO.1 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d492e720108a4daf94a3411b6868bd6f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b9de5637.html title=比Sum函數好用10倍，它才是Excel求和函數中的NO.1>比Sum函數好用10倍，它才是Excel求和函數中的NO.1</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cc21918b.html alt=難點解析丨求一次函數中參數的值（6種解法） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f611ff11a88043ddb35b0ca455618731 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cc21918b.html title=難點解析丨求一次函數中參數的值（6種解法）>難點解析丨求一次函數中參數的值（6種解法）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>