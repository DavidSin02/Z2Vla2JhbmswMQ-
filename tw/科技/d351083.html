<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>linux系統中socket錯誤碼：eintr和eagain的處理方法 | 极客快訊</title><meta property="og:title" content="linux系統中socket錯誤碼：eintr和eagain的處理方法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/f47eacd32fb946aa903e72921d4458a4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d351083.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d351083.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d351083.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d351083.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d351083.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d351083.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d351083.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d351083.html><meta property="article:published_time" content="2020-10-29T21:04:54+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:54+08:00"><meta name=Keywords content><meta name=description content="linux系統中socket錯誤碼：eintr和eagain的處理方法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d351083.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>linux系統中socket錯誤碼：eintr和eagain的處理方法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1、什麼是慢系統調用？</p><p>該術語適用於那些可能永遠阻塞的系統調用。永遠阻塞的系統調用是指調用永遠無法返回，多數網絡支持函數都屬於這一類。如：若沒有客戶連接到服務器上，那麼服務器的accept調用就會永遠阻塞。</p><p>慢系統調用可以被永久阻塞，包括以下幾個類別：</p><p>（1）讀寫‘慢’設備（包括pipe，終端設備，網絡連接等）。讀時，數據不存在，需要等待；寫時，緩衝區滿或其他原因，需要等待。</p><p>（2）當打開某些特殊文件時，需要等待某些條件，才能打開。例如：打開中斷設備時，需要等到連接設備的modem響應才能完成。</p><p>（3）pause和wait函數。pause函數使調用進程睡眠，直到捕獲到一個信號。wait等待子進程終止。</p><p>（4）某些ioctl操作。</p><p>（5）某些IPC操作。</p><p>2、EINTR錯誤產生的原因-（阻塞的系統調用、或者非阻塞的系統調用）</p><p>如果進程在一個慢系統調用(slow system call)中阻塞時，當捕獲到某個信號且相應信號處理函數返回時，這個系統調用不再阻塞而是被中斷，就會調用返回錯誤（一般為-1）&&設置errno為EINTR（相應的錯誤描述為“Interrupted system call”）。</p><p>如下表所示的系統調用就會產生EINTR錯誤，當然不同的函數意義也不同。</p><div class=pgc-img><img alt=linux系統中socket錯誤碼：eintr和eagain的處理方法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f47eacd32fb946aa903e72921d4458a4><p class=pgc-img-caption></p></div><p>3、解決辦法</p><p>既然系統調用會被中斷，那麼別忘了要處理被中斷的系統調用。有三種處理方式：</p><p>解決方法1：重啟被中斷的系統調用</p><p>當碰到EINTR錯誤的時候，有一些可以重啟的系統調用要進行重啟，而對於有一些系統調用是不能夠重啟的。例如：accept、read、write、select、和open之類的函數來說，是可以進行重啟的。不過對於套接字編程中的connect函數是不能重啟的，若connect函數返回一個EINTR錯誤的時候，我們不能再次調用它，否則將立即返回一個錯誤。針對connect不能重啟的處理方法是，必須調用select來等待連接完成。</p><p>理解“重啟”？一些IO系統調用執行時，如 read 等待輸入期間，如果收到一個信號，系統將中斷read， 轉而執行信號處理函數. 當信號處理返回後， 系統遇到了一個問題： 是重新開始這個系統調用? 還是讓系統調用失敗?早期UNIX系統的做法是：中斷系統調用，並讓系統調用失敗， 比如read返回 -1， 同時設置 errno 為EINTR中斷了的系統調用是沒有完成的調用，它的失敗是臨時性的，如果再次調用則可能成功，這並不是真正的失敗，所以要對這種情況進行處理， 典型的方式為“重啟”，採用accept函數為例子，代碼如下</p><p><strong>需要C/C++ Linux服務器架構師學習資料私信“資料”（資料包括C/C++，Linux，golang技術，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒體，CDN，P2P，K8S，Docker，TCP/IP，協程，DPDK，ffmpeg等），免費分享</strong></p><div class=pgc-img><img alt=linux系統中socket錯誤碼：eintr和eagain的處理方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/643889d760064d9db4baa7849d6c0597><p class=pgc-img-caption></p></div><pre><code>ACCEPT:    clifd = accept(srvfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     if (clifd == -1) {        if (errno == EINTR) {            goto ACCEPT;        } else {            fprintf(stderr, "accept fail,error:%s\n", strerror(errno));            return -1;        }    }</code></pre><p>解決方法2：安裝信號時設置 SA_RESTART屬性（該方法對有的系統調用無效）</p><pre><code>struct sigaction action;         action.sa_handler = handler_func;    sigemptyset(&amp;action.sa_mask);    action.sa_flags = 0;    /* 設置SA_RESTART屬性 */    action.sa_flags |= SA_RESTART;         sigaction(SIGALRM, &amp;action, NULL); </code></pre><p>解決方法3： 忽略信號（讓系統不產生信號中斷）</p><pre><code>struct sigaction action;         action.sa_handler = SIG_IGN;    sigemptyset(&amp;action.sa_mask);         sigaction(SIGALRM, &amp;action, NULL); </code></pre><p>EAGAIN-（一般用於非阻塞的系統調用）</p><p>非阻塞的系統調用，由於資源限制/不滿足條件，導致返回值為EAGAIN</p><p>在Linux環境下開發經常會碰到很多錯誤(設置errno)，其中EAGAIN是其中比較常見的一個錯誤(比如用在非阻塞操作中)。</p><p>如：首先是把套接字設置為異步的了，然後在使用write發送數據時採取的方式是循環發送大量的數據；由於是異步的，write\send將要發送的數據提交到發送緩衝區後是立即返回的，並不需要對端確認數據已接收。在這種情況下是很有可能出現發送緩衝區被填滿，導致write\send無法再向緩衝區提交要發送的數據。因此就產生了Resource temporarily unavailable的錯誤（資源暫時不可用），EAGAIN 的意思也很明顯，就是要你再次嘗試。</p><p>從字面上來看，是提示再試一次。這個錯誤經常出現在當應用程序進行一些非阻塞(non-blocking)操作(對文件或socket)的時候。</p><p>如：以 O_NONBLOCK的標誌打開文件/socket/FIFO，如果連續做read操作而沒有數據可讀。此時程序不會阻塞起來等待數據準備就緒返回，read函數會返回一個錯誤EAGAIN，提示你的應用程序現在沒有數據可讀請稍後再試。</p><p>又例如，當一個系統調用(比如fork)因為沒有足夠的資源(比如虛擬內存)而執行失敗，返回EAGAIN提示其再調用一次(也許下次就能成功)。</p><p>Linux - 非阻塞socket編程處理EAGAIN錯誤</p><p>在linux進行非阻塞的socket接收數據時經常出現Resource temporarily unavailable，errno代碼為11(EAGAIN)，這是什麼意思？ ⇒ ⇒ ⇒ 這表明在非阻塞模式下調用了阻塞操作，在該操作沒有完成就返回這個錯誤，這個錯誤不會破壞socket的同步，不用管它，下次循環接著recv就可以。對非阻塞socket而言，EAGAIN不是一種錯誤。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。</p><pre><code>iReadSizeOnce=read(iOpenCom,RxBuf+iReadSize,1024);if (iReadSizeOnce != ZERO){    if (iReadSizeOnce != EAGAIN)    {        continue;    }    else    {        //stCComApiLog.LogError("讀串口操作錯誤");        return(FUN_ERROR);    }}</code></pre><p>慢系統調用：可能永遠阻塞的系統調用，這很關鍵，不適用於非諸塞的情況。永遠阻塞的系統調用是指調用永遠無法返回，多數網絡支持函數都屬於這一類。如：若沒有客戶連接到服務器上，那麼服務器的accept調用就會一直阻塞。</p><p>EINTR說明：如果進程在一個慢系統調用(slow system call)中阻塞時，當捕獲到某個信號且相應信號處理函數返回時，這個系統調用被中斷，調用返回錯誤，設置errno為EINTR（相應的錯誤描述為“Interrupted system call”）。</p><p>怎麼看哪些系統條用會產生EINTR錯誤呢？man 7 signal，在ubuntu 10.04上可以查看，哪些系統調用會產生 EINTR錯誤。</p><p>如何處理被中斷的系統調用</p><p>既然系統調用會被中斷，那麼別忘了要處理被中斷的系統調用。有三種處理方式：</p><p>◆ 人為重啟被中斷的系統調用</p><p>◆ 安裝信號時設置 SA_RESTART屬性（該方法對有的系統調用無效）</p><p>◆ 忽略信號（讓系統不產生信號中斷）</p><p>人為重啟被中斷的系統調用</p><p>人為當碰到EINTR錯誤的時候，有一些可以重啟的系統調用要進行重啟，而對於有一些系統調用是不能夠重啟的。例如：accept、read、write、select、和open之類的函數來說，是可以進行重啟的。不過對於套接字編程中的connect函數我們是不能重啟的，若connect函數返回一個EINTR錯誤的時候，我們不能再次調用它，否則將立即返回一個錯誤。針對connect不能重啟的處理方法是，必須調用select來等待連接完成。</p><p>這裡的“重啟”怎麼理解？</p><p>一些IO系統調用執行時，如 read 等待輸入期間，如果收到一個信號，系統將中斷read， 轉而執行信號處理函數. 當信號處理返回後， 系統遇到了一個問題： 是重新開始這個系統調用， 還是讓系統調用失敗？早期UNIX系統的做法是， 中斷系統調用，並讓系統調用失敗， 比如read返回 -1， 同時設置 errno 為EINTR中斷了的系統調用是沒有完成的調用，它的失敗是臨時性的，如果再次調用則可能成功，這並不是真正的失敗，所以要對這種情況進行處理， 典型的方式為：</p><p>connect處理方式，抄襲3原文，沒有測試過，處理方法是對的。</p><p>connect的問題，當connect遇到EINTR錯誤時，不能向上面那樣重新進入循環處理，原因是，connect的請求已經發送向對方，正在等待對方迴應，這是如果重新調用connect，而對方已經接受了上次的connect請求，這一次的connect就會被拒絕，因此，需要使用select或poll調用來檢查socket的狀態，如果socket的狀態就緒，則connect已經成功，否則，視錯誤原因，做對應的處理。</p><div class=pgc-img><img alt=linux系統中socket錯誤碼：eintr和eagain的處理方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/772bf7d43cf34aa38ee2cdca3ae7a60d><p class=pgc-img-caption></p></div><pre><code>#include poll.h int check_conn_is_ok(socket_t sock) {	struct pollfd fd;	int ret = 0;	socklen_t len = 0; 	fd.fd = sock;	fd.events = POLLOUT; 	while ( poll (&amp;fd, 1, -1) == -1 ) {		if( errno != EINTR ){			perror("poll");			return -1;		}	} 	len = sizeof(ret);	if ( getsockopt (sock, SOL_SOCKET, SO_ERROR,                     &amp;ret,                     &amp;len) == -1 ) {    	        perror("getsockopt");		return -1;	} 	if(ret != 0) {		fprintf (stderr, "socket %d connect failed: %s\n",                 sock, strerror (ret));		return -1;	} 	return 0;}</code></pre><p>在調用connect時，這樣使用：</p><pre><code>#include erron.h ....if(connnect()) {    if(errno == EINTR) {        if(check_conn_is_ok() &lt; 0) {              perror();              return -1;        }        else {             printf("connect is success!\n");        }    }    else {         perror("connect");         return -1;    }}</code></pre><p>我一般使用continue或者goto來處理。</p><p>安裝信號時設置 SA_RESTART屬性</p><p>我們還可以從信號的角度來解決這個問題， 安裝信號的時候， 設置 SA_RESTART屬性，那麼當信號處理函數返回後， 不會讓系統調用返回失敗，而是讓被該信號中斷的系統調用將自動恢復。</p><pre><code>struct sigaction action;     action.sa_handler = handler_func;  sigemptyset(&amp;action.sa_mask);  action.sa_flags = 0;  /* 設置SA_RESTART屬性 */  action.sa_flags |= SA_RESTART;     sigaction(SIGALRM, &amp;action, NULL);  </code></pre><p>但注意，並不是所有的系統調用都可以自動恢復。如msgsnd喝msgrcv就是典型的例子，msgsnd/msgrcv以block方式發送/接收消息時，會因為進程收到了信號而中斷。此時msgsnd/msgrcv將返回-1，errno被設置為EINTR。且即使在插入信號時設置了SA_RESTART，也無效。在man msgrcv中就有提到這點：</p><p>msgsnd and msgrcv are never automatically restarted after being interrupted by a signal handler, regardless of the setting of the SA_RESTART flag when establishing a signal handler.</p><p></p><p>忽略信號</p><p>當然最簡單的方法是忽略信號，在安裝信號時，明確告訴系統不會產生該信號的中斷。</p><pre><code>struct sigaction action;     action.sa_handler = SIG_IGN;  sigemptyset(&amp;action.sa_mask);     sigaction(SIGALRM, &amp;action, NULL);  </code></pre><pre><code>#include   #include   #include   #include   #include   #include      void sig_handler(int signum)  {      printf("in handler\n");      sleep(1);      printf("handler return\n");  }     int main(int argc, char **argv)  {      char buf[100];      int ret;      struct sigaction action, old_action;         action.sa_handler = sig_handler;      sigemptyset(&amp;action.sa_mask);      action.sa_flags = 0;      /* 版本1:不設置SA_RESTART屬性      * 版本2:設置SA_RESTART屬性 */      //action.sa_flags |= SA_RESTART;         sigaction(SIGALRM, NULL, &amp;old_action);      if (old_action.sa_handler != SIG_IGN) {          sigaction(SIGALRM, &amp;action, NULL);      }      alarm(3);           bzero(buf, 100);         ret = read(0, buf, 100);      if (ret == -1) {          perror("read");      }         printf("read %d bytes:\n", ret);      printf("%s\n", buf);         return 0;  }  </code></pre><p>在linux測試結果：</p><p>不設置SA_RESTART，執行結果如下：</p><div class=pgc-img><img alt=linux系統中socket錯誤碼：eintr和eagain的處理方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b6782ea767b34a3b9568b04fc43489a3><p class=pgc-img-caption></p></div><p>說明接受信號處理完成以後，主函數收到EINTR信號，read函數返回-1，退出</p><p>設置SA_RESTART，執行結果如下：</p><div class=pgc-img><img alt=linux系統中socket錯誤碼：eintr和eagain的處理方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47596798163e40f69294fb2202ef134d><p class=pgc-img-caption></p></div><p>說明設置SA_RESTART參數以後，自動重新調用read函數，沒有體現在應用層代碼中，在應用層看來，這個EINTR沒有造成任何影響。</p><p>總結：</p><p>慢系統調用(slow system call)會被信號中斷，系統調用函數返回失敗，並且errno被置為EINTR（錯誤描述為“Interrupted system call”）。</p><p>處理方法有以下三種：①人為重啟被中斷的系統調用；②安裝信號時設置 SA_RESTART屬性；③忽略信號（讓系統不產生信號中斷）。</p><p>有時我們需要捕獲信號，但又考慮到第②種方法的侷限性（設置 SA_RESTART屬性對有的系統無效，如msgrcv），所以在編寫代碼時，一定要“人為重啟被中斷的系統調用”。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>linux</a></li><li><a>系統</a></li><li><a>socket</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7ca5569.html alt=linux系統中如何添加路由 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7ca5569.html title=linux系統中如何添加路由>linux系統中如何添加路由</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/15e31bc6.html alt=linux文件系統詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ca9c61bb58f74db5bb05d2067cd581b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15e31bc6.html title=linux文件系統詳解>linux文件系統詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/01ef527c.html alt=詳解linux系統架構--文件系統體系 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13183b27d114479589173ced128508b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/01ef527c.html title=詳解linux系統架構--文件系統體系>詳解linux系統架構--文件系統體系</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e97f2ef.html alt=linux系統編程—深入理解線程安全和可重入函數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1ee6cfb4a26146468f84f34dc34ebbdf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e97f2ef.html title=linux系統編程—深入理解線程安全和可重入函數>linux系統編程—深入理解線程安全和可重入函數</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/b9996341.html alt=linux系統編程之文件的內核結構file和dup實現重定向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2083db3dd90d4239bc06386a79bc693c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/b9996341.html title=linux系統編程之文件的內核結構file和dup實現重定向>linux系統編程之文件的內核結構file和dup實現重定向</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09027003.html alt="一 linux操作系統複習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66b900045bf5657b4d3a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09027003.html title="一 linux操作系統複習筆記">一 linux操作系統複習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c1f4dc9.html alt="二 linux操作系統複習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66bc00032a43fdf87a92 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c1f4dc9.html title="二 linux操作系統複習筆記">二 linux操作系統複習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d6cb3b.html alt=自動化搭建微型linux系統ftp服務器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/19488a5f7b8446ab94cedd3303c0f7d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d6cb3b.html title=自動化搭建微型linux系統ftp服務器>自動化搭建微型linux系統ftp服務器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html alt=電廠直流系統調試方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e8200036f19e04c25bf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/031eafc4.html title=電廠直流系統調試方案>電廠直流系統調試方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html alt=一文讀懂智能客服：發展歷程、系統搭建、市場推廣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RbYMTZ55OrJUgU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc3b4b2c.html title=一文讀懂智能客服：發展歷程、系統搭建、市場推廣>一文讀懂智能客服：發展歷程、系統搭建、市場推廣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html alt=生活垃圾焚燒發電及蒸汽系統優化改造項目公告 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RcblrbTDBokV23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51410370.html title=生活垃圾焚燒發電及蒸汽系統優化改造項目公告>生活垃圾焚燒發電及蒸汽系統優化改造項目公告</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html alt=電驅動橋系統或加快電氣化進程，多個案例共同說明問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539571595921bc5b27eff6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4913b56.html title=電驅動橋系統或加快電氣化進程，多個案例共同說明問題>電驅動橋系統或加快電氣化進程，多個案例共同說明問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html alt=基於混沌系統的偽隨機數發生器設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a7b7719.html title=基於混沌系統的偽隨機數發生器設計>基於混沌系統的偽隨機數發生器設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html alt=win10系統打印機打印不了顯示已暫停的解決方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10d0de369d4746c7a0c220ff59bd2470 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99558abe.html title=win10系統打印機打印不了顯示已暫停的解決方法>win10系統打印機打印不了顯示已暫停的解決方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html alt=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2564328d.html title=虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案>虛設投資交易系統吸引投資 成都破獲一特大團夥詐騙案</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>