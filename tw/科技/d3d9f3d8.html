<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>搞懂Linux內存管理，僅此一篇 | 极客快訊</title><meta property="og:title" content="搞懂Linux內存管理，僅此一篇 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3d9f3d8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3d9f3d8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3d9f3d8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3d9f3d8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3d9f3d8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3d9f3d8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3d9f3d8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3d9f3d8.html><meta property="article:published_time" content="2020-11-14T21:06:35+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:35+08:00"><meta name=Keywords content><meta name=description content="搞懂Linux內存管理，僅此一篇"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>搞懂Linux內存管理，僅此一篇</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>內存管理應該是Linux內核中非常重要的子系統，之前一直在構思怎麼去寫一篇Linux內存管理的文章，由於內容實在過於龐大複雜，要想要通俗易懂而且不丟失專業性的闡述真的是一種考驗。瞭解內管管理的實現原理不管對內核開發人員還是應用程序開發人員來說都幫助極大。本文也致力於用簡單生動的語言帶領大家認識內存管理的原理，當然也少不了一些理論知識的鋪墊。我們的目的不是探討理論，而是為了更加全面的理解原理，必要時我們會深入理論，窺探理論知識的背後。</p><h1><strong>進程和內存</strong></h1><p class=ql-align-justify>我們都知道，進程運行需要內存。它主要是用來存放從存儲介質中（磁盤/flash/...）載入的程序代碼和進程運行所需要的數據內容。在我的另一篇文章中怎樣深入理解堆和棧有對進程的組成講解。對於一個進程來說都會有5中不同的數據段。</p><ol><li class=ql-align-justify>代碼段（text）：代碼段是用來存放可執行文件的操作指令，也就是說它存放的是可執行程序中在內存中的鏡像。代碼段是不允許修改的，所以只能進行讀操作，而不允許寫入的操作。</li><li class=ql-align-justify>數據段（data）：數據段主要用來存放已經初始化的全局變量，也就是說存放程序靜態分配的變量（<strong>靜態分配內存就是編譯器在編譯程序的時候根據源程序來分配內存. 動態分配內存就是在程序編譯之後, 運行時調用運行時刻庫函數來分配內存的. 靜態分配由於是在程序運行之前,所以速度快, 效率高, 但是侷限性大. 動態分配在程序運行時執行, 所以速度慢, 但靈活性高.</strong>）和全局變量。</li><li class=ql-align-justify>bss段：bss段包含了程序中未初始化的全局變量，在內存中bss段會全部統一清零。（<strong>延伸：這就是為什麼沒有初始化的全局變量，都會被清零的原因</strong>）</li><li class=ql-align-justify>堆（heap）：堆是用來存儲進程動態分配的內存，它的大小並不固定。具體可參考怎樣深入理解堆和棧</li><li class=ql-align-justify>棧（stack）：棧是用來存放臨時變量的地方，也就是C程序中{}中的變量，不包括static聲明的變量（雖然static是局部變量，它的作用範圍在{}中，但是它的生存週期是整個程序生命週期，它存放在數據段中）。程序在函數調用時，參數個數過多的函數會通過棧的方式，將參數壓入棧中，並且在調用結束後，函數的返回值也會通過棧來返回。從這個意義上講，我們可以把棧看成一個寄存，交換臨時數據的內存區。詳細可以參考文章怎樣深入理解堆和棧。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify>通過程序對內存的不同用途，分為了上述5種不同的段，那這些段在內存是怎樣組織的呢？看下圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=搞懂Linux內存管理，僅此一篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>從圖中我們不難發現，堆棧好像是挨在一起的，他們一個向下“長”（i386體系結構中棧向下、堆向上），一個向上“長”，相對而生。但你不必擔心他們會碰頭，因為他們之間間隔真的很大。</p><p>從用戶態向內核態看，我們所使用的內存形式的變化：</p><div class=pgc-img><img alt=搞懂Linux內存管理，僅此一篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/84a8b8cfd2d64cb2ad76a44bb9de5600><p class=pgc-img-caption></p></div><p>邏輯地址經段機制轉化成線性地址；線性地址又經過頁機制轉化為物理地址。（但是我們要知道Linux系統雖然保留了段機制，但是將所有程序的段地址都定死為0-4G，所以雖然邏輯地址和線性地址是兩種不同的地址空間，但在Linux中邏輯地址就等於線性地址，它們的值是一樣的）。沿著這條線索，我們所研究的主要問題也就集中在下面幾個問題。</p><ol><li class=ql-align-justify>進程地址空間如何管理？</li><li class=ql-align-justify>進程地址如何映射物理內存呢？</li><li class=ql-align-justify>物理內存又是如何被管理的呢？</li></ol><p>下面我們就來看看吧。</p><h1><strong>進程地址空間</strong></h1><p class=ql-align-justify>現代的操作系統基本是採用虛擬內存管理技術，當然Linux作為先進的os也不例外，每個進程都有自己的進程地址空間。該空間為4G的線性虛擬空間。用戶態接觸到的都是虛擬地址，根本無法看到物理地址，也不用關心物理地址。利用這種虛擬地址的方式，可以保護內存資源，起到隔離的作用。而且對於用戶程序來說，始終是4G的大小，可以在程序編譯的時候就能確定代碼段地址。我們應該知道三件事情：</p><ol><li class=ql-align-justify>4G的進程地址空間被人為的分為兩個部分——用戶空間與內核空間。用戶空間從0到3G（0xC0000000），內核空間佔據3G到4G。用戶進程通常情況下只能訪問用戶空間的虛擬地址，不能訪問內核空間虛擬地址。只有用戶進程進行系統調用（代表用戶進程在內核態執行）等時刻可以訪問到內核空間。</li><li class=ql-align-justify>每當進程切換，用戶空間就會變化，而內核空間是內核負責映射的。它不隨著進程的變化而變化。內核空間有自己的對應的頁表（init_mm.pgd），用戶進程有各自的頁表。</li><li class=ql-align-justify>每個進程的用戶空間都是獨立的。</li></ol><p class=ql-align-justify><br></p><h1><strong>進程內存管理</strong></h1><p class=ql-align-justify>進程內存管理的對象是進程線性地址空間上的內存鏡像，這些內存鏡像其實就是進程使用的虛擬內存區域（memory region）。進程虛擬空間是個32或64位的“平坦”（獨立的連續區間）地址空間（空間的具體大小取決於體系結構）。要統一管理這麼大的平坦空間可絕非易事，為了方便管理，虛擬空間被劃分為許多大小可變的(但必須是4096的倍數)內存區域，這些區域在進程線性地址中像停車位一樣有序排列。這些區域的劃分原則是“將訪問屬性一致的地址空間存放在一起”，所謂訪問屬性在這裡無非指的是“可讀、可寫、可執行等”。</p><p class=ql-align-justify>如果你要查看某個進程佔用的內存區域，可以使用命令<strong>cat /proc/&lt;pid>/maps</strong>獲得（pid是進程號），你會發現如下所示列表：</p><pre class=ql-align-justify>08048000 - 08049000 r-xp 00000000 03:03 439029 /home/mm/src/example​08049000 - 0804a000 rw-p 00000000 03:03 439029 /home/mm/src/example​……………​bfffe000 - c0000000 rwxp ffff000 00:00 0</pre><p class=ql-align-justify>每行數據格式如下：</p><p class=ql-align-justify><strong>（內存區域）開始－結束 訪問權限 偏移 主設備號：次設備號 i節點 文件。</strong></p><p class=ql-align-justify><strong>注意點：</strong><em>你一定會發現進程空間只包含三個內存區域，似乎沒有上面所提到的堆、bss等，其實並非如此，程序內存段和進程地址空間中的內存區域是種模糊對應，也就是說，堆、bss、數據段（初始化過的）都在進程空間中由數據段內存區域表示。</em></p><p class=ql-align-justify>在Linux內核中表示內存區域的數據結構是<strong>vm_area_struct</strong>，內核將每個內存區域作為單獨的內存對象管理。採用面向對象方法使VMA結構體可以代表多種類型的內存區域，包括內存映射文件和進程用戶空間棧等等，這些區域的操作方法也不盡相同。</p><p class=ql-align-justify><strong>vm_area_strcut</strong>結構比較複雜，關於它的詳細結構請參閱相關資料。我們這裡只對它的組織方法做一點補充說明。<strong>vm_area_struct</strong>是描述進程地址空間的基本管理單元，對於一個進程來說往往需要多個內存區域來描述它的虛擬空間，<strong>如何關聯這些不同的內存區域呢？</strong>大家可能都會想到使用鏈表，的確<strong>vm_area_struct</strong>結構確實是以鏈表形式鏈接，不過為了方便查找，<strong>內核又以紅黑樹（以前的內核使用平衡樹）的形式組織內存區域</strong>，以便降低搜索耗時。並存的兩種組織形式，並非冗餘：鏈表用於需要遍歷全部節點的時候用，而紅黑樹適用於在地址空間中定位特定內存區域的時候。內核為了內存區域上的各種不同操作都能獲得高性能，所以同時使用了這兩種數據結構。</p><p class=ql-align-justify>下圖反映了進程地址空間的管理模型：</p><div class=pgc-img><img alt=搞懂Linux內存管理，僅此一篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06caf07ef29a44b194eae7b1e2954a5e><p class=pgc-img-caption></p></div><p class=ql-align-justify><strong>進程的地址空間對應的描述結構是“內存描述結構”，它表示進程的全部地址空間，包含了和進程地址空間有關的全部信息，其中當然包含進程的內存區域。</strong></p><h1><strong>進程內存到底是怎樣分配與回收？</strong></h1><p class=ql-align-justify><strong>我們知道的一些系統調用，例如：創建進程fork（），程序載入execve()，映射文件mmap（），動態內存分配 brk()</strong> 等等都是需要分配內存給進程。但是這時進程獲取的還不是實際物理的內存，只是虛擬內存，其實在內核中只是表示的是“內存區域”。進程對內存區域的分配最終是在內核中的do_mmap()函數上執行的（brk除外）。</p><p class=ql-align-justify></p><p class=ql-align-justify>內核使用do_mmap()函數創建一個新的線性地址區間。然後會將一個地址區間加入到進程的地址空間中，可能是創建一個新的區域或者是擴展以存在的內存區域。當然釋放對應的內存區域是使用函數do_ummap()。</p><h1><strong>內存如何由虛變實呢？</strong></h1><p class=ql-align-justify>從上面已經看到進程所能直接操作的地址都為虛擬地址。當進程需要內存時，從內核獲得的僅僅是虛擬的內存區域，而不是實際的物理地址，進程並沒有獲得物理內存（物理頁面——頁的概念請大家參考硬件基礎一章），獲得的僅僅是對一個新的線性地址區間的使用權。實際的物理內存只有當進程真的去訪問新獲取的虛擬地址時，才會由“請求頁機制”產生“缺頁”異常，從而進入分配實際頁面的函數。</p><p class=ql-align-justify>該異常是虛擬內存機制賴以存在的基本保證——它會告訴內核去真正為進程分配物理頁，並建立對應的頁表，這之後虛擬地址才實實在在地映射到了系統的物理內存上。（當然，如果頁被換出到磁盤，也會產生缺頁異常，不過這時不用再建立頁表了）</p><p class=ql-align-justify>這種請求頁機制把頁面的分配推遲到不能再推遲為止，並不急於把所有的事情都一次做完（這種思想有點像設計模式中的代理模式（proxy））。之所以能這麼做是利用了內存訪問的“局部性原理”，請求頁帶來的好處是節約了空閒內存，提高了系統的吞吐率。要想更清楚地瞭解請求頁機制，可以看看《深入理解linux內核》一書。</p><p class=ql-align-justify>這裡我們需要說明在內存區域結構上的nopage操作。當訪問的進程虛擬內存並未真正分配頁面時，該操作便被調用來分配實際的物理頁，併為該頁建立頁表項。在最後的例子中我們會演示如何使用該方法。</p><h1><strong>物理內存怎樣管理？</strong></h1><p class=ql-align-justify>雖然應用程序操作的對象是映射到物理內存之上的虛擬內存，但是處理器直接操作的卻是物理內存。所以當應用程序訪問一個虛擬地址時，首先必須將虛擬地址轉化成物理地址，然後處理器才能解析地址訪問請求。地址的轉換工作需要通過查詢頁表才能完成，概括地講，地址轉換需要將虛擬地址分段，使每段虛地址都作為一個索引指向頁表，而頁表項則指向下一級別的頁表或者指向最終的物理頁面。</p><p class=ql-align-justify>每個進程都有自己的頁表。進程描述符的pgd域指向的就是進程的頁全局目錄。下面我們借用《<strong>linux設備驅動程序</strong>》中的一幅圖大致看看進程地址空間到物理頁之間的轉換關係。</p><div class=pgc-img><img alt=搞懂Linux內存管理，僅此一篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/33feab49da6b4064b717900d935f4f5a><p class=pgc-img-caption></p></div><p class=ql-align-justify>上面的過程說起來簡單，做起來難呀。因為在虛擬地址映射到頁之前必須先分配物理頁——也就是說必須先從內核中獲取空閒頁，並建立頁表。下面我們介紹一下內核管理物理內存的機制。</p><p class=ql-align-justify>Linux內核管理物理內存是通過分頁機制實現的，它將整個內存劃分成無數個4k（在i386體系結構中）大小的頁，從而分配和回收內存的基本單位便是內存頁了。利用分頁管理有助於靈活分配內存地址，因為分配時不必要求必須有大塊的連續內存，系統可以東一頁、西一頁的湊出所需要的內存供進程使用。雖然如此，但是實際上系統使用內存時還是傾向於分配連續的內存塊，因為分配連續內存時，頁表不需要更改，因此能降低TLB的刷新率（頻繁刷新會在很大程度上降低訪問速度）。</p><p class=ql-align-justify>鑑於上述需求，內核分配物理頁面時為了儘量減少不連續情況，採用了“夥伴”關係來管理空閒頁面。夥伴關係分配算法大家應該不陌生，如果不明白可以參看有關資料。這裡只需要大家明白Linux中空閒頁面的組織和管理利用了夥伴關係，因此空閒頁面分配時也需要遵循夥伴關係，最小單位只能是2的冪倍頁面大小。內核中分配空閒頁面的基本函數是<strong>get_free_page/get_free_pages</strong>，它們或是分配單頁或是分配指定的頁面（2、4、8…512頁）。</p><p class=ql-align-justify><em>注意：get_free_page是在內核中分配內存，不同於malloc在用戶空間中分配，malloc利用堆動態分配，實際上是調用brk()系統調用，該調用的作用是擴大或縮小進程堆空間（它會修改進程的brk域）。如果現有的內存區域不夠容納堆空間，則會以頁面大小的倍數為單位，擴張或收縮對應的內存區域，但brk值並非以頁面大小為倍數修改，而是按實際請求修改。因此Malloc在用戶空間分配內存可以以字節為單位分配,但內核在內部仍然會是以頁為單位分配的。</em></p><p class=ql-align-justify>另外,需要說的是，物理頁在系統中由頁結構struct page描述，系統中所有的頁面都存儲在數組mem_map[]中，可以通過該數組找到系統中的每一頁（空閒或非空閒）。而其中的空閒頁面則可由上述提到的以夥伴關係組織的空閒頁鏈表（free_area[MAX_ORDER]）來索引。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=搞懂Linux內存管理，僅此一篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/74515b26fdd84f2cae3c71370e200dba><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1><strong>何為slab？</strong></h1><p class=ql-align-justify>以頁為最小單位分配內存對於內核管理系統中的物理內存來說的確比較方便，但內核自身最常使用的內存卻往往是很小（遠遠小於一頁）的內存塊——比如存放文件描述符、進程描述符、虛擬內存區域描述符等行為所需的內存都不足一頁。這些用來存放描述符的內存相比頁面而言，就好比是麵包屑與麵包。一個整頁中可以聚集多個這些小塊內存；而且這些小塊內存塊也和麵包屑一樣頻繁地生成/銷燬。</p><p class=ql-align-justify>為了滿足內核對這種小內存塊的需要，Linux系統採用了一種被稱為slab分配器的技術。Slab分配器的實現相當複雜，但原理不難，其核心思想就是“存儲池”的運用。內存片段（小塊內存）被看作對象，當被使用完後，並不直接釋放而是被緩存到“存儲池”裡，留做下次使用，這無疑避免了頻繁創建與銷燬對象所帶來的額外負載。</p><p class=ql-align-justify>Slab技術不但避免了內存內部分片）帶來的不便（引入Slab分配器的主要目的是為了減少對夥伴系統分配算法的調用次數——頻繁分配和回收必然會導致內存碎片——難以找到大塊連續的可用內存），而且可以很好地利用硬件緩存提高訪問速度。</p><p class=ql-align-justify>Slab並非是脫離夥伴關係而獨立存在的一種內存分配方式，slab仍然是建立在頁面基礎之上，換句話說，Slab將頁面（來自於夥伴關係管理的空閒頁面鏈表）撕碎成眾多小內存塊以供分配，slab中的對象分配和銷燬使用<strong>kmem_cache_alloc</strong>與<strong>kmem_cache_free</strong>。</p><h1><strong>kmalloc()</strong></h1><p class=ql-align-justify>lab分配器不僅僅只用來存放內核專用的結構體，它還被用來處理內核對小塊內存的請求。當然鑑於Slab分配器的特點，一般來說內核程序中對小於一頁的小塊內存的請求才通過Slab分配器提供的接口Kmalloc來完成（雖然它可分配32 到131072字節的內存）。從內核內存分配的角度來講，kmalloc可被看成是get_free_page（s）的一個有效補充，內存分配粒度更靈活了。</p><p class=ql-align-justify>有興趣的話，可以到/proc/slabinfo中找到內核執行現場使用的各種slab信息統計，其中你會看到系統中所有slab的使用信息。從信息中可以看到系統中除了專用結構體使用的slab外，還存在大量為Kmalloc而準備的Slab（其中有些為dma準備的）</p><h1><strong>vmalloc()</strong></h1><p class=ql-align-justify>夥伴關係也好、slab技術也好，從內存管理理論角度而言目的基本是一致的，它們都是為了防止“分片”，不過分片又分為外部分片和內部分片之說，所謂內部分片是說系統為了滿足一小段內存區（連續）的需要，不得不分配了一大區域連續內存給它，從而造成了空間浪費；外部分片是指系統雖有足夠的內存，但卻是分散的碎片，無法滿足對大塊“連續內存”的需求。無論何種分片都是系統有效利用內存的障礙。slab分配器使得一個頁面內包含的眾多小塊內存可獨立被分配使用，避免了內部分片，節約了空閒內存。夥伴關係把內存塊按大小分組管理，一定程度上減輕了外部分片的危害，因為頁框分配不在盲目，而是按照大小依次有序進行，不過夥伴關係只是減輕了外部分片，但並未徹底消除。你自己比劃一下多次分配頁面後，空閒內存的剩餘情況吧。</p><p class=ql-align-justify>所以避免外部分片的最終思路還是落到了如何利用不連續的內存塊組合成“看起來很大的內存塊”——這裡的情況很類似於用戶空間分配虛擬內存，內存邏輯上連續，其實映射到並不一定連續的物理內存上。Linux內核借用了這個技術，允許內核程序在內核地址空間中分配虛擬地址，同樣也利用頁表（內核頁表）將虛擬地址映射到分散的內存頁上。以此完美地解決了內核內存使用中的外部分片問題。內核提供vmalloc函數分配內核虛擬內存，該函數不同於kmalloc，它可以分配較Kmalloc大得多的內存空間（可遠大於128K，但必須是頁大小的倍數），但相比Kmalloc來說,Vmalloc需要對內核虛擬地址進行重映射，必須更新內核頁表，因此分配效率上要低一些（用空間換時間）。</p><p class=ql-align-justify>vmalloc分配的內核虛擬內存與kmalloc/get_free_page分配的內核虛擬內存位於不同的區間，不會重疊。因為內核虛擬空間被分區管理，各司其職。進程空間地址分佈從０到３G(其實是到PAGE_OFFSET, 在0x86中它等於0xC0000000)，從3G到vmalloc_start這段地址是物理內存映射區域（該區域中包含了內核鏡像、物理頁面表mem_map等等）比如我使用的系統內存是64M(可以用free看到)，那麼(3G——3G+64M)這片內存就應該映射到物理內存，而vmalloc_start位置應在3G+64M附近（說"附近"因為是在物理內存映射區與vmalloc_start期間還會存在一個8M大小的gap來防止躍界）,vmalloc_end的位置接近4G(說"接近"是因為最後位置系統會保留一片128k大小的區域用於專用頁面映射，還有可能會有高端內存映射區，這些都是細節，這裡我們不做糾纏)。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=搞懂Linux內存管理，僅此一篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f6f915a8e91e4341b35fb3630984a6c1><p class=pgc-img-caption>內存分佈的模糊輪廓</p></div><p class=ql-align-center><br></p><p class=ql-align-center>由get_free_page或Kmalloc函數所分配的連續內存都陷於物理映射區域，所以它們返回的內核虛擬地址和實際物理地址僅僅是相差一個偏移量（PAGE_OFFSET），你可以很方便的將其轉化為物理內存地址，同時內核也提供了virt_to_phys（）函數將內核虛擬空間中的物理映射區地址轉化為物理地址。要知道，物理內存映射區中的地址與內核頁表是有序對應的，系統中的每個物理頁面都可以找到它對應的內核虛擬地址（在物理內存映射區中的）。</p><p class=ql-align-justify>而vmalloc分配的地址則限於vmalloc_start與vmalloc_end之間。每一塊vmalloc分配的內核虛擬內存都對應一個vm_struct結構體（可別和vm_area_struct搞混，那可是進程虛擬內存區域的結構），不同的內核虛擬地址被4k大小的空閒區間隔，以防止越界——見下圖）。與進程虛擬地址的特性一樣，這些虛擬地址與物理內存沒有簡單的位移關係，必須通過內核頁表才可轉換為物理地址或物理頁。它們有可能尚未被映射，在發生缺頁時才真正分配物理頁面。</p><h1 class=ql-align-justify>參考</h1><blockquote>http://www.kerneltravel.net/journal/v/mem.htm</blockquote><h1 class=ql-align-justify>END</h1><p class=ql-align-justify><strong>覺得不錯，記得轉發，關注！</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>搞懂</a></li><li><a>Linux</a></li><li><a>內存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d71eada.html alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1235a07ccdc42cc8fd086f246d5aaa6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d71eada.html title="深入分析Linux內核源代碼6-Linux 內存管理（1）">深入分析Linux內核源代碼6-Linux 內存管理（1）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1608906.html alt="深入分析Linux內核源代碼6-Linux 內存管理（2）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/40298caf1d2f414797e260a43b4f0e0b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1608906.html title="深入分析Linux內核源代碼6-Linux 內存管理（2）">深入分析Linux內核源代碼6-Linux 內存管理（2）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ec734b.html alt=淺談Linux內存管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4443462f6dbd4ae5a5257ef9f329d755 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ec734b.html title=淺談Linux內存管理>淺談Linux內存管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html alt=20個機械設計知識點總結，搞懂也是半個行家 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html title=20個機械設計知識點總結，搞懂也是半個行家>20個機械設計知識點總結，搞懂也是半個行家</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html alt=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/47783c95e3a34185be9ff00f54b4fe7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html title=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？>電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html alt=軸承保持架斷裂原因，終於搞懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/926568ad42794eac8db9ccfc13716933 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html title=軸承保持架斷裂原因，終於搞懂了！>軸承保持架斷裂原因，終於搞懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html alt=「工程造價」搞懂這41個問題，你就是造價大神 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/61e6d766-6c64-42b0-8adc-44437be425ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html title=「工程造價」搞懂這41個問題，你就是造價大神>「工程造價」搞懂這41個問題，你就是造價大神</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dccc27aa.html alt=搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/45dfe66dfe2b42088ca53ab0c5d316b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dccc27aa.html title=搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏>搞懂鋰電池阻抗譜(EIS)不容易，這篇文章值得收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/142b983a.html alt=一文搞懂常用鋼材型號、性能特性，收藏隨時查看！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533653259067c6eef0dcc2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/142b983a.html title=一文搞懂常用鋼材型號、性能特性，收藏隨時查看！>一文搞懂常用鋼材型號、性能特性，收藏隨時查看！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00a88a85.html alt="沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rd1uElWC8gP2we style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00a88a85.html title="沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃">沒搞懂承重牆or非承重牆，你就敢胡亂拆？| 最家計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/187187bc.html alt="技術趣講 | 60 分鐘搞懂「正則表達式」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/eaee8d2e512c44168627b8f244fb5e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/187187bc.html title="技術趣講 | 60 分鐘搞懂「正則表達式」">技術趣講 | 60 分鐘搞懂「正則表達式」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>