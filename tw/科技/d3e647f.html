<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java面向對象設計的六大原則，中高級面試常問 | 极客快訊</title><meta property="og:title" content="Java面向對象設計的六大原則，中高級面試常問 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/a7a601a3-a2ec-4a79-9c37-70956207d016"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3e647f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3e647f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3e647f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3e647f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3e647f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3e647f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3e647f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3e647f.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="Java面向對象設計的六大原則，中高級面試常問"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d3e647f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java面向對象設計的六大原則，中高級面試常問</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Java面向對象設計的六大原則，中高級面試常問 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/a7a601a3-a2ec-4a79-9c37-70956207d016><p class=pgc-img-caption></p></div><p>這篇文章主要講的是面向對象設計中，我們應該遵循的六大原則。只有掌握了這些原則，我們才能更好的理解設計模式。我們接下來要介紹以下6個內容。</p><ul><li>單一職責原則——SRP</li><li>開閉原則——OCP</li><li>裡式替換原則——LSP</li><li>依賴倒置原則——DIP</li><li>接口隔離原則——ISP</li><li>迪米特原則——LOD</li></ul><h1 class=pgc-h-arrow-right>單一職責原則</h1><p>單一職責原則的定義是就一個類而言，應該僅有一個引起他變化的原因。也就是說一個類應該只負責一件事情。如果一個類負責了方法M1,方法M2兩個不同的事情，當M1方法發生變化的時候，我們需要修改這個類的M1方法，但是這個時候就有可能導致M2方法不能工作。這個不是我們期待的，但是由於這種設計卻很有可能發生。所以這個時候，我們需要把M1方法，M2方法單獨分離成兩個類。讓每個類只專心處理自己的方法。</p><p>單一職責原則的好處如下：</p><blockquote><p>可以降低類的複雜度，一個類只負責一項職責，這樣邏輯也簡單很多 提高類的可讀性，和系統的維護性，因為不會有其他奇怪的方法來干擾我們理解這個類的含義 當發生變化的時候，能將變化的影響降到最小，因為只會在這個類中做出修改。</p></blockquote><h1 class=pgc-h-arrow-right>開閉原則</h1><p>開閉原則和單一職責原則一樣，是非常基礎而且一般是常識的原則。開閉原則的定義是軟件中的對象(類，模塊，函數等)應該對於擴展是開放的，但是對於修改是關閉的。</p><p>當需求發生改變的時候，我們需要對代碼進行修改，這個時候我們應該儘量去擴展原來的代碼，而不是去修改原來的代碼，因為這樣可能會引起更多的問題。</p><p>這個準則和單一職責原則一樣，是一個大家都這樣去認為但是又沒規定具體該如何去做的一種原則。</p><p>開閉原則我們可以用一種方式來確保他，我們用抽象去構建框架，用實現擴展細節。這樣當發生修改的時候，我們就直接用抽象了派生一個具體類去實現修改。</p><h1 class=pgc-h-arrow-right>里氏替換原則</h1><p>里氏替換原則是一個非常有用的一個概念。他的定義</p><blockquote><p>如果對每一個類型為T1的對象o1,都有類型為T2的對象o2,使得以T1定義的所有程序P在所有對象o1都替換成o2的時候，程序P的行為都沒有發生變化，那麼類型T2是類型T1的子類型。</p></blockquote><p>這樣說有點複雜，其實有一個簡單的定義</p><blockquote><p>所有引用基類的地方必須能夠透明地使用其子類的對象。</p></blockquote><p>里氏替換原則通俗的去講就是：子類可以去擴展父類的功能，但是不能改變父類原有的功能。他包含以下幾層意思：</p><ul><li>子類可以實現父類的抽象方法，但是不能覆蓋父類的非抽象方法。</li><li>子類可以增加自己獨有的方法。</li><li>當子類的方法重載父類的方法時候，方法的形參要比父類的方法的輸入參數更加寬鬆。</li><li>當子類的方法實現父類的抽象方法時，方法的返回值要比父類更嚴格。</li></ul><p>里氏替換原則之所以這樣要求是因為繼承有很多缺點，他雖然是複用代碼的一種方法，但同時繼承在一定程度上違反了封裝。父類的屬性和方法對子類都是透明的，子類可以隨意修改父類的成員。這也導致了，如果需求變更，子類對父類的方法進行一些複寫的時候，其他的子類無法正常工作。所以里氏替換法則被提出來。</p><p>確保程序遵循里氏替換原則可以要求我們的程序建立抽象，通過抽象去建立規範，然後用實現去擴展細節，這個是不是很耳熟，對，里氏替換原則和開閉原則往往是相互依存的。</p><h1 class=pgc-h-arrow-right>依賴倒置原則</h1><p>依賴倒置原則指的是一種特殊的解耦方式，使得高層次的模塊不應該依賴於低層次的模塊的實現細節的目的，依賴模塊被顛倒了。這也是一個讓人難懂的定義，他可以簡單來說就是</p><blockquote><p>高層模塊不應該依賴底層模塊，兩者都應該依賴其抽象 抽象不應該依賴細節 細節應該依賴抽象</p></blockquote><p>在Java 中抽象指的是接口或者抽象類，兩者皆不能實例化。而細節就是實現類，也就是實現了接口或者繼承了抽象類的類。他是可以被實例化的。高層模塊指的是調用端，底層模塊是具體的實現類。在Java中，依賴倒置原則是指模塊間的依賴是通過抽象來發生的，實現類之間不發生直接的依賴關係，其依賴關係是通過接口是來實現的。這就是俗稱的面向接口編程。</p><p>我們下面有一個例子來講述這個問題。這個例子是工人用錘子來修理東西。我們的代碼如下：</p><pre><code>public class Hammer {    public String function(){        return "用錘子修理東西";    }}public class Worker {    public void fix(Hammer hammer){        System.out.println("工人" + hammer.function());    }    public static void main(String[] args) {        new Worker().fix(new Hammer());    }}</code></pre><p>這個是一個很簡單的例子，但是如果我們要新增加一個功能，工人用 螺絲刀來修理東西，在這個類，我們發現是很難做的。因為我們Worker類依賴於一個具體的實現類Hammer。所以我們用到面向接口編程的思想，改成如下的代碼：</p><pre><code>public interface Tools {    public String function();}</code></pre><p>然後我們的Worker是通過這個接口來於其他細節類進行依賴。代碼如下：</p><pre><code>public class Worker {    public void fix(Tools tool){        System.out.println("工人" + tool.function());    }    public static void main(String[] args) {        new Worker().fix(new Hammer());        new Worker().fix(new Screwdriver());    }}</code></pre><p>我們的Hammer類與Screwdriver類實現這個接口</p><pre><code>public class Hammer implements Tools{    public String function(){        return "用錘子修理東西";    }}public class Screwdriver implements Tools{    @Override    public String function() {        return "用螺絲刀修理東西";    }}</code></pre><p>這樣，通過面向接口編程，我們的代碼就有了很高的擴展性，降低了代碼之間的耦合度，提高了系統的穩定性。</p><h1 class=pgc-h-arrow-right>接口隔離原則</h1><p>接口隔離原則的定義是</p><blockquote><p>客戶端不應該依賴他不需要的接口</p></blockquote><p>換一種說法就是類間的依賴關係應該建立在最小的接口上。這樣說好像更難懂。我們通過一個例子來說明。我們知道在Java中一個具體類實現了一個接口，那必然就要實現接口中的所有方法。如果我們有一個類A和類B通過接口I來依賴，類B是對類A依賴的實現，這個接口I有5個方法。但是類A與類B只通過方法1,2,3依賴，然後類C與類D通過接口I來依賴，類D是對類C依賴的實現但是他們卻是通過方法1,4,5依賴。那麼是必在實現接口的時候，類B就要有實現他不需要的方法4和方法5 而類D就要實現他不需要的方法2，和方法3。這簡直就是一個災難的設計。</p><p>所以我們需要對接口進行拆分，就是把接口分成滿足依賴關係的最小接口，類B與類D不需要去實現與他們無關接口方法。比如在這個例子中，我們可以把接口拆成3個，第一個是僅僅由方法1的接口，第二個接口是包含2,3方法的，第三個接口是包含4,5方法的。這樣，我們的設計就滿足了接口隔離原則。</p><p>以上這些設計思想用英文的第一個字母可以組成SOLID ，滿足這個5個原則的程序也被稱為滿足了SOLID準則。</p><h1 class=pgc-h-arrow-right>迪米特原則</h1><p>迪米特原則也被稱為最小知識原則，他的定義</p><blockquote><p>一個對象應該對其他對象保持最小的瞭解。</p></blockquote><p>因為類與類之間的關係越密切，耦合度越大，當一個類發生改變時，對另一個類的影響也越大，所以這也是我們提倡的軟件編程的總的原則：低耦合，高內聚。迪米特法則還有一個更簡單的定義</p><blockquote><p>只與直接的朋友通信。首先來解釋一下什麼是直接的朋友：每個對象都會與其他對象有耦合關係，只要兩個對象之間有耦合關係，我們就說這兩個對象之間是朋友關係。耦合的方式很多，依賴、關聯、組合、聚合等。其中，我們稱出現成員變量、方法參數、方法返回值中的類為直接的朋友，而出現在局部變量中的類則不是直接的朋友。也就是說，陌生的類最好不要作為局部變量的形式出現在類的內部。</p></blockquote><p>這裡我們可以用一個現實生活中的例子來講解一下。比如我們需要一張CD,我們可能去音像店去問老闆有沒有我們需要的那張CD，老闆說現在沒有，等有的時候你們來拿就行了。在這裡我們不需要關心老闆是從哪裡，怎麼獲得的那張CD，我們只和老闆（直接朋友）溝通，至於老闆從他的朋友那裡通過何種條件得到的CD，我們不關心，我們不和老闆的朋友（陌生人）進行通信，這個就是迪米特的一個應用。說白了，就是一種中介的方式。我們通過老闆這個中介來和真正提供CD的人發生聯繫。</p><h1 class=pgc-h-arrow-right>總結</h1><p>到這裡，面向對象的六大原則，就寫完了。我們看出來，這些原則其實都是應對不斷改變的需求。每當需求變化的時候，我們利用這些原則來使我們的代碼改動量最小，而且所造成的影響也是最小的。</p><p>但是我們在看這些原則的時候，我們會發現很多原則並沒有提供一種公式化的結論，而即使提供了公式化的結論的原則也只是建議去這樣做。這是因為，這些設計原則本來就是從很多實際的代碼中提取出來的，他是一個經驗化的結論。怎麼去用它，用好他，就要依靠設計者的經驗。</p><p>否則意味著去使用設計原則可能會使代碼出現過度設計的情況。大多數的原則都是通過提取出抽象和接口來實現，如果發生過度的設計，就會出現很多抽象類和接口，增加了系統的複雜度。讓本來很小的項目變得很龐大，當然這也是Java的特性（任何的小項目都會做成中型的項目）。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>對象</a></li><li><a>設計</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html alt=Java程序設計-面向對象思路（筆記） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9fcc6e3cac554acc8790d6b14e6aceaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d929289.html title=Java程序設計-面向對象思路（筆記）>Java程序設計-面向對象思路（筆記）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f2113c8.html alt="這樣設計 Java 異常更優雅，趕緊學習吧" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/f55e4e93-073c-48d4-803e-699c75a9e084 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f2113c8.html title="這樣設計 Java 異常更優雅，趕緊學習吧">這樣設計 Java 異常更優雅，趕緊學習吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html alt=面向對象設計原則之開閉原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ff63803ae3d4638b01095d32682fa70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html title=面向對象設計原則之開閉原則>面向對象設計原則之開閉原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html alt=面向對象設計的七大原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd44e43836e64ae3b2c4d6e9ffa9f033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e00f029.html title=面向對象設計的七大原則>面向對象設計的七大原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f2e3fb3f.html alt=Java面向對象之接口——interface class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/671e9bb3-9c58-4a73-8660-359947cb74f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f2e3fb3f.html title=Java面向對象之接口——interface>Java面向對象之接口——interface</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html alt=面向對象設計之依賴倒置原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html title=面向對象設計之依賴倒置原則>面向對象設計之依賴倒置原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html alt=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/93686fc2-2a36-4161-8664-03ae59f6e71e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html title=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺>面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/1026b24f.html alt=《Java語言程序設計》在線作業題目與答案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/1026b24f.html title=《Java語言程序設計》在線作業題目與答案>《Java語言程序設計》在線作業題目與答案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d50be9a.html alt=高薪Java工程師必備技能分享：設計模式與框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/847d89520ef24bb0a34a7a73628f7234 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d50be9a.html title=高薪Java工程師必備技能分享：設計模式與框架>高薪Java工程師必備技能分享：設計模式與框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html alt=C++面向對象設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c001c4074d3f4c658dfea942671f0ea6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30b98e49.html title=C++面向對象設計>C++面向對象設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html alt=Python面向對象設計和麵向對象編程解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html title=Python面向對象設計和麵向對象編程解析>Python面向對象設計和麵向對象編程解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html alt=什麼是“面向對象”程序設計-以Python為例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/12f1d2422ce145819ebe4973dcfa2b89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd8a828f.html title=什麼是“面向對象”程序設計-以Python為例>什麼是“面向對象”程序設計-以Python為例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3924ddd.html alt=軟考自查：面向對象設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8fc841fb0334a72ba00b8186b247534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3924ddd.html title=軟考自查：面向對象設計>軟考自查：面向對象設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c10ee1cd.html alt=關於面向對象程序設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c10ee1cd.html title=關於面向對象程序設計>關於面向對象程序設計</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>