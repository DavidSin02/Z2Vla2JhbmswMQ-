<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基於Spring Boot搭建應用開發框架——基礎架構 | 极客快訊</title><meta property="og:title" content="基於Spring Boot搭建應用開發框架——基礎架構 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/afeba6d083bb4e78ada213e1b6cd513c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><meta property="article:published_time" content="2020-11-14T20:59:18+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:18+08:00"><meta name=Keywords content><meta name=description content="基於Spring Boot搭建應用開發框架——基礎架構"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d4207bf0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基於Spring Boot搭建應用開發框架——基礎架構</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>一、創建項目</strong></h1><p style=text-align:start>這一節創建項目的基礎結構，按照spring boot的思想，將各個不同的功能按照starter的形式拆分開來，做到靈活組合，並簡單介紹下Spring Boot相關的東西。</p><h1 class=pgc-h-arrow-right><strong>1、創建工程</strong></h1><p style=text-align:start>① 通過File > New > Project，新建工程，選擇Spring Initializr，然後Next。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/afeba6d083bb4e78ada213e1b6cd513c><p class=pgc-img-caption></p></div><p style=text-align:start>② 儘量為自己的框架想個好點的名字，可以去申請個自己的域名。我這裡項目名稱為Sunny，項目路徑為com.lyyzoo.sunny。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6fa8dd68fbe849a299f374092faca7ec><p class=pgc-img-caption></p></div><p style=text-align:start>③ 這裡先什麼都不選，後面再去集成。注意我的Spring Boot版本為1.5.9。Next</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92cc9fdf32b4482fad8b6c5a2ff21858><p class=pgc-img-caption></p></div><p style=text-align:start>④ 定義好工程的目錄，用一個專用目錄吧，不要在一個目錄下和其它東西雜在一起。之後點擊Finish。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1c3567321a87411abb5f2074b4317f9b><p class=pgc-img-caption></p></div><p style=text-align:start>上面說的這麼詳細，只有一個目的，從一個開始就做好規範。</p><p style=text-align:start>⑤ 生成的項目結構如下，可以自己去看下pom.xml裡的內容。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5624772bbcc04c4b8e0556e9e2909adf><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、創建Starter</strong></h1><p style=text-align:start>先創建一個core核心、cache緩存、security授權認證，其它的後面再集成進去。</p><p style=text-align:start>跟上面一樣的方式，在Sunny下創建sunny-starter-core、sunny-starter-cache、sunny-starter-security子模塊。</p><p style=text-align:start>這樣分模塊後，我們以後需要哪個模塊就引入哪個模塊即可，如果哪個模塊不滿足需求，還可以重寫該模塊。</p><p style=text-align:start>最終的項目結構如下：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b12e1cd5f28a4714afb95ac7e3a56846><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3、啟動項目</strong></h1><p style=text-align:start>首先在core模塊下來啟動並瞭解SpringBoot項目。</p><p style=text-align:start>① 在com.lyyzoo.core根目錄下，有一個SunnyStarterCoreApplication，這是SpringBoot的入口類，通常是*Application的命名。</p><p style=text-align:start>入口類裡有一個main方法，其實就是一個標準的Java應用的入口方法。在main方法中使用SpringApplication.run啟動Spring Boot項目。</p><p style=text-align:start>然後看看@SpringBootApplication註解，@SpringBootApplication是Spring Boot的核心註解，是一個組合註解。</p><p style=text-align:start>@EnableAutoConfiguration讓Spring Boot根據類路徑中的jar包依賴為當前項目進行自動配置。</p><p style=text-align:start>Spring Boot會自動掃描@SpringBootApplication所在類的同級包以及下級包裡的Bean。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bebb443c477b480eada9bcc1f27a08df><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f5acdcd55b1449718ff6f4acd2ac8cf8><p class=pgc-img-caption></p></div><p style=text-align:start>② 先啟動項目，這裡可以看到有一個Spring Boot的啟動程序，點擊右邊的按鈕啟動項目。看到控制檯Spring的標誌，就算是啟動成功了。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/080f6f714cb64da1b0559f324e88efad><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a378d372bc684260a84a38cbaf63883d><p class=pgc-img-caption></p></div><p style=text-align:start>③ 替換默認的banner</p><p style=text-align:start>可以到http://patorjk.com/software/taag/這個網站生成一個自己項目的banner。創建banner.txt並放到resources根目錄下。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/017c9b97717b4003a0e9fd1d41061619><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>4、Spring Boot 配置</strong></h1><p style=text-align:start>① 配置文件</p><p style=text-align:start>Spring Boot使用一個全局的配置文件application.properties或application.yaml，放置在src/main/resources目錄下。我們可以在這個全局配置文件中對一些默認的配置值進行修改。</p><p style=text-align:start>具體有哪些配置可到官網查找，有非常多的配置，不過大部分使用默認即可。Common application properties</p><p style=text-align:start>然後，需要為不同的環境配置不同的配置文件，全局使用application-{profile}.properties指定不同環境配置文件。</p><p style=text-align:start>我這裡增加了開發環境(dev)和生產環境(prod)的配置文件，並通過在application.properties中設置spring.profiles.active=dev來指定當前環境。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5f96ac354f944314b22d28d49d398794><p class=pgc-img-caption></p></div><p style=text-align:start>② starter pom</p><p style=text-align:start>Spring Boot為我們提供了簡化開發絕大多數場景的starter pom，只要使用了應用場景所需的starter pom，無需繁雜的配置，就可以得到Spring Boot為我們提供的自動配置的Bean。</p><p style=text-align:start>後面我們將會通過加入這些starter來一步步集成我們想要的功能。具體有哪些starter，可以到官網查看：Starters</p><p style=text-align:start>③ 自動配置</p><p style=text-align:start>Spring Boot關於自動配置的源碼在spring-boot-autoconfigure中如下：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9dd1e00f0c3442dcacc087d67043dce0><p class=pgc-img-caption></p></div><p style=text-align:start>我們可以在application.properties中加入debug=true，查看當前項目中已啟用和未啟用的自動配置。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa0933c119d34ee2b24c0b0c6689b0ad><p class=pgc-img-caption></p></div><p style=text-align:start>我們在application.properties中的配置其實就是覆蓋spring-boot-autoconfigure裡的默認配置，比如web相關配置在web包下。</p><p style=text-align:start>常見的如HttpEncodingProperties配置http編碼，裡面自動配置的編碼為UTF-8。</p><p style=text-align:start>MultipartProperties，上傳文件的屬性，設置了上傳最大文件1M。</p><p style=text-align:start>ServerProperties，配置內嵌Servlet容器，配置端口、contextPath等等。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ac3b6dc92d9746d9b5fa48aa5293d131><p class=pgc-img-caption></p></div><p style=text-align:start>之前說@SpringBootApplication是Spring Boot的核心註解，但他的核心功能是由@EnableAutoConfiguration註解提供的。</p><p style=text-align:start>@EnableAutoConfiguration註解通過@Import導入配置功能，在AutoConfigurationImportSelector中，通過SpringFactoriesLoader.loadFactoryNames掃描META-INF/spring.factories文件。</p><p style=text-align:start>在spring.factories中，配置了需要自動配置的類，我們也可以通過這種方式添加自己的自動配置。</p><p style=text-align:start>在spring-boot-autoconfigure下就有一個spring.factories，如下：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a1da94117b741e8aac34ee5c81f8f0e><p class=pgc-img-caption></p></div><p style=text-align:start>說了這麼多，只為說明一點，Spring Boot為我們做了很多自動化的配置，搭建快速方便。</p><p style=text-align:start>但是，正因為它為我們做了很多事情，就有很多坑，有時候，出了問題，我們可能很難找出問題所在，這時候，我們可能就要考慮下是否是自動配置導致的，有可能配置衝突了，或者沒有使用上自定義的配置等等。</p><h1 class=pgc-h-arrow-right><strong>5、項目結構劃分</strong></h1><p style=text-align:start>core是項目的核心模塊，結構初步規劃如下：</p><p style=text-align:start>　base是項目的基礎核心，定義一些基礎類，如BaseController、BaseService等；</p><p style=text-align:start>cache是緩存相關；<br></p><p style=text-align:start>config是配置中心，模塊所有的配置放到config裡統一管理；</p><p style=text-align:start>constants裡定義系統的常量。<br></p><p style=text-align:start>exception裡封裝一些基礎的異常類；</p><p style=text-align:start>　system是系統模塊；</p><p style=text-align:start>util裡則是一些通用工具類；</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c58b67900e5489ba3739bdb9fd5d9d1><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>二、基礎結構功能</strong></h1><h1 class=pgc-h-arrow-right><strong>1、web支持</strong></h1><p style=text-align:start>只需在pom.xml中加入spring-boot-starter-web的依賴即可。</p><p style=text-align:start>之後，查看POM的依賴樹(插件：Maven Helper)，可以看到引入了starter、tomcat、web支持等。可以看出，Sping Boot內嵌了servlet容器，默認tomcat。</p><p style=text-align:start>自動配置在WebMvcAutoConfiguration和WebMvcProperties裡，可自行查看源碼，一般我們不需添加其他配置就可以啟動這個web項目了。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d5fa67f78f4671aabc1dacd96b185c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7fff38eeea2d4e29b71f3ec5c6713087><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、基礎功能</strong></h1><p style=text-align:start>在core中添加一些基礎的功能支持。</p><p style=text-align:start>① 首先引入一些常用的依賴庫，主要是一些常用工具類，方便以後的開發。</p><p>View Code</p><p style=text-align:start>版本號如下：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e2cc51b1851a475d9ad766bffcb1d55d><p class=pgc-img-caption></p></div><p style=text-align:start>② 在base添加一個Result類，作為前端的返回對象，Controller的直接返回對象都是Result。</p><p>View Code</p><p style=text-align:start>之後在util添加生成Result的工具類Results，用於快速方便的創建Result對象。</p><p>View Code</p><p style=text-align:start>③ 在base添加BaseEnum&lt;K, V>枚舉接口，定義了獲取值和描述的接口。</p><p>View Code</p><p style=text-align:start>然後在constants下定義一個基礎枚舉常量類，我們把一些描述信息維護到枚舉裡面，儘量不要在代碼中直接出現魔法值(如一些編碼、中文等)，以後的枚舉常量類也可以按照這種模式來寫。</p><p>View Code</p><p style=text-align:start>④ 再添加一個常用的日期工具類對象，主要包含一些常用的日期時間格式化，後續可再繼續往裡面添加一些公共方法。</p><p>View Code</p><p style=text-align:start>⑤ Constants定義系統級的通用常量。</p><p>View Code</p><p style=text-align:start>⑥ 在base添加空的BaseController、BaseDTO、Service、Mapper，先定義好基礎結構，後面再添加功能。</p><p style=text-align:start>BaseDTO：標準的who字段、版本號、及10個擴展字段。</p><p style=text-align:start>因為這裡用到了@Transient註解，先引入java持久化包：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74ab01d4f6c14329887418e3f9bee2be><p class=pgc-img-caption></p></div><p>View Code</p><p style=text-align:start>同時，重寫了toString方法，增加了toJsonString方法，使得可以格式化輸出DTO的數據：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6179fed5ce71402f8c683962cb3dde8e><p class=pgc-img-caption></p></div><p style=text-align:start>直接打印DTO，輸出的格式大概就是這個樣子：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b0f9e73eb5d4bf39bd4ba18964c05d1><p class=pgc-img-caption></p></div><p style=text-align:start>⑦ 在exception添加BaseException，定義一些基礎異常類</p><p style=text-align:start>基礎異常類都繼承自運行時異常類(RunntimeException)，儘可能把受檢異常轉化為非受檢異常，更好的面向接口編程，提高代碼的擴展性、穩定性。</p><p style=text-align:start>BaseException：添加了一個錯誤編碼，其它自定義的異常應當繼承該類。</p><p>View Code</p><p style=text-align:start>ServiceException：繼承BaseException，Service層往Controller拋出的異常。</p><p>View Code</p><h1 class=pgc-h-arrow-right><strong>3、添加系統用戶功能，使用Postman測試接口</strong></h1><p style=text-align:start>① 在system模塊下，再分成dto、controller、service、mapper、constants子包，以後一個模塊功能開發就是這樣一個基礎結構。</p><p style=text-align:start>User：系統用戶</p><p>View Code</p><p style=text-align:start>UserController：用戶控制層；用@RestController註解，前後端分離，因為無需返回視圖，採用Restful風格，直接返回數據。</p><p>View Code</p><p style=text-align:start>② Postman請求：請求成功，基礎的HTTP服務已經實現了。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3794fb206e3642eebbf53359ae82a536><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/296da66f81a84edd9475dc0548c25c4e><p class=pgc-img-caption></p></div><p style=text-align:start></p><p>回到頂部</p><h1 class=pgc-h-arrow-right><strong>三、集成MyBatis，實現基礎Mapper和Service<br></strong></h1><h1 class=pgc-h-arrow-right><strong>1、添加JDBC、配置數據源</strong></h1><p style=text-align:start>添加spring-boot-starter-jdbc以支持JDBC訪問數據庫，然後添加MySql的JDBC驅動mysql-connector-java；</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/68dc677552554238b7f74dbc2b594d24><p class=pgc-img-caption></p></div><p style=text-align:start>在application.properties裡配置mysql的數據庫驅動</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/41d3b5f0e08a42f081c7c44fc7c66095><p class=pgc-img-caption></p></div><p style=text-align:start>之後在application-dev.properties裡配置開發環境數據庫的連接信息，添加之後，Springboot就會自動配置數據源了。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2060a60e90e84e02824eb8c305eaadf9><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、集成MyBatis</strong></h1><p style=text-align:start>MyBatis官方為了方便Springboot集成MyBatis，專門提供了一個符合Springboot規範的starter項目，即mybatis-spring-boot-starter。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bf7132c543d4c50bd975b587105f45c><p class=pgc-img-caption></p></div><p style=text-align:start>在application.properties裡添加mybatis映射配置：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/83d5253648a74d69bfd39464dcd231d5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3、添加MyBatis通用Mapper</strong></h1><p style=text-align:start>通用Mapper可以極大的簡化開發，極其方便的進行單表的增刪改查。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ded6f170aae34da89873040098e5195f><p class=pgc-img-caption></p></div><p style=text-align:start>關於通用Mapper，參考網站地址：</p><p style=text-align:start>　　MyBatis通用Mapper</p><p style=text-align:start>　　MyBatis 相關工具</p><p style=text-align:start>之後，在core.base下創建自定義的Mapper，按需選擇接口。</p><p style=text-align:start>具體可參考：根據需要自定義接口</p><p>View Code</p><p style=text-align:start>定義好基礎Mapper後，就具有下圖中的基本通用方法了。每個實體類對應的*Mapper繼承Mapper&lt;T>來獲得基本的增刪改查的通用方法。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44c6b1d48ad74bdb899286fec2911192><p class=pgc-img-caption></p></div><p style=text-align:start>在application.properties裡配置自定義的基礎Mapper</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e4c6eb71ff284f619ba27c7a4dba96f8><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>4、添加分頁插件PageHelper</strong></h1><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1099bc49a5f84a5188cd2e9bc4cd9102><p class=pgc-img-caption></p></div><p style=text-align:start>參考地址：</p><p style=text-align:start>　　MyBatis 分頁插件 - PageHelper</p><p style=text-align:start>　　分頁插件使用方法</p><p style=text-align:start>分頁插件配置，一般情況下，不需要做任何配置。</p><p style=text-align:start>之後，我們就可以在代碼中使用 PageHelper.startPage(1, 10) 對緊隨其後的一個查詢進行分頁查詢，非常方便。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a46c694715de487ea929316700da77ba><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>5、配置自動掃描Mapper</strong></h1><p style=text-align:start>在config下創建MyBatisConfig配置文件，通過mapperScannerConfigurer方法配置自動掃描Mapper文件。</p><p>View Code</p><p style=text-align:start>注意這裡的 MapperScannerConfigurer 是tk.mybatis.spring.mapper.MapperScannerConfigurer，而不是org.mybatis，否則使用通用Mapper的方法時會報類似下面的這種錯誤</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c81b3c4056354486a0aa17c29e763a70><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>6、定義基礎Service</strong></h1><p style=text-align:start>一般來說，我們不能在Controller中直接訪問Mapper，因此我們需要加上Service，通過Service訪問Mapper。</p><p style=text-align:start>首先定義基礎Service&lt;T>接口，根據Mapper定義基本的增刪改查接口方法。</p><p>View Code</p><p style=text-align:start>然後是實現類BaseService，以後的開發中，Service接口實現Service&lt;T>，Service實現類繼承BaseService&lt;T>。</p><p>View Code</p><p style=text-align:start>BaseService的實現用到了反射工具類Reflections：</p><p>View Code</p><h1 class=pgc-h-arrow-right><strong>7、獲取AOP代理</strong></h1><p style=text-align:start>Spring 只要引入aop則是默認開啟事務的，一般我們只要在需要事務管理的地方加上@Transactional註解即可支持事務，一般我們會加在Service的類或者具體的增加、刪除、更改的方法上。</p><p style=text-align:start>我這裡要說的是獲取代理的問題。Service的事務管理是AOP實現的，AOP的實現用的是JDK動態代理或CGLIB動態代理。所以，如果你想在你的代理方法中以 this 調用當前接口的另一個方法，另一個方法的事務是不會起作用的。因為事務的方法是代理對象的，而 this 是當前類對象，不是一個代理對象，自然事務就不會起作用了。這是我在不久前的開發中遇到的實際問題，我自定義了一個註解，加在方法上，使用AspectJ來攔截該註解，卻沒攔截到，原因就是這個方法是被另一個方法以 this 的方式調用的，所以AOP不能起作用。</p><p style=text-align:start>更詳細的可參考：Spring AOP無法攔截內部方法調用</p><p style=text-align:start>所以添加一個獲取自身代理對象的接口，以方便獲取代理對象來操作當前類方法。Service接口只需要繼承該接口，T為接口本身即可，就可以通過self()獲取自身的代理對象了。</p><p>View Code</p><p style=text-align:start>還需要開啟開啟 exposeProxy = true，暴露代理對象，否則 AopContext.currentProxy() 會拋出異常。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1657e42500e843259f7dedbe90b3bf1c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>8、數據持久化測試</strong></h1><p style=text-align:start>① 實體映射</p><p style=text-align:start>實體類按照如下規則和數據庫表進行轉換，註解全部是JPA中的註解：</p><ul><li>表名默認使用類名，駝峰轉下劃線(只對大寫字母進行處理)，如UserInfo默認對應的表名為user_info</li><li>表名可以使@Table(name = "tableName")進行指定，對不符合第一條默認規則的可以通過這種方式指定表名。</li><li>字段默認和@Column一樣，都會作為表字段，表字段默認為Java對象的Field名字駝峰轉下劃線形式。</li><li>可以使用@Column(name = "fieldName")指定不符合第3條規則的字段名。</li><li><strong>使用@Transient註解可以忽略字段，添加該註解的字段不會作為表字段使用，注意，如果沒有與表關聯，一定要用@Transient標註。</strong></li><li><strong>建議一定是有一個@Id註解作為主鍵的字段,可以有多個@Id註解的字段作為聯合主鍵。</strong></li><li><strong>默認情況下，實體類中如果不存在包含@Id註解的字段,所有的字段都會作為主鍵字段進行使用(這種效率極低)。</strong></li><li>由於基本類型，如int作為實體類字段時會有默認值0，而且無法消除，所以實體類中建議不要使用基本類型。</li></ul><p style=text-align:start>User實體主要加了@Table註解，映射表名；然後在userId上標註主鍵註解；其它字段如果沒加@Transient註解的默認都會作為表字段。</p><p>View Code</p><p style=text-align:start>② 創建表結構</p><p>View Code</p><p style=text-align:start>③ 創建UserMapper</p><p style=text-align:start>在system.mapper下創建UserMapper接口，繼承Mapper&lt;User>：</p><p>View Code</p><p style=text-align:start>④ 創建UserService</p><p style=text-align:start>在system.service下創建UserService接口，只需繼承Service&lt;User>接口即可。</p><p>View Code</p><p style=text-align:start>在system.service.impl下創建UserServiceImpl實現類，繼承BaseService&lt;User>類，實現UserService接口。同時加上@Service註解。</p><p>View Code</p><p style=text-align:start>⑤ 修改UserController，注入UserService，增加一些測試API</p><p>View Code</p><p style=text-align:start>⑥ 測試結果</p><p style=text-align:start>查詢所有：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/db225fc7f24c4b6896bbc5678917e5b9><p class=pgc-img-caption></p></div><p style=text-align:start>批量保存/修改：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab18afa74b2948dd9d7fce39cd0f1669><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>9、代碼生成器</strong></h1><p style=text-align:start>使用代碼生成器來生成基礎的代碼結構，生成DTO、XML等等。</p><p style=text-align:start>MyBatis官方提供了代碼生成器MyBatis Generator，但一般需要定製化。MyBatis Generator</p><p style=text-align:start>我這裡從網上找了一個使用起來比較方便的界面工具，可生成DTO、Mapper、Mapper.xml，生成之後還需做一些小調整。另需要自己創建對應的Service、Controller。之後有時間再重新定製化一個符合本項目的代碼生成器。</p><p style=text-align:start>mybatis-generator界面工具</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/755e220fe07643df85eb28345ce18d73><p class=pgc-img-caption></p></div><p style=text-align:start></p><p>回到頂部</p><h1 class=pgc-h-arrow-right><strong>四、日誌及全局異常處理</strong></h1><p style=text-align:start>在前面的測試中，會發現控制檯輸出的日誌不怎麼友好，有很多日誌也沒有輸出，不便於查找排查問題。對於一個應用程序來說日誌記錄是必不可少的一部分。線上問題追蹤，基於日誌的業務邏輯統計分析等都離不日誌。</p><p style=text-align:start>先貼出一些參考資料：</p><p style=text-align:start>　　logback 配置詳解</p><p style=text-align:start>　　日誌組件slf4j介紹及配置詳解</p><p style=text-align:start>　　Java常用日誌框架介紹</p><h1 class=pgc-h-arrow-right><strong>1、日誌框架簡介</strong></h1><p style=text-align:start>Java有很多常用的日誌框架，如Log4j、Log4j 2、Commons Logging、Slf4j、Logback等。有時候你可能會感覺有點混亂，下面簡單介紹下。</p><ul><li>Log4j：Apache Log4j是一個基於Java的日誌記錄工具，是Apache軟件基金會的一個項目。</li><li>Log4j 2：Apache Log4j 2是apache開發的一款Log4j的升級產品。</li><li>Commons Logging：Apache基金會所屬的項目，是一套Java日誌接口。</li><li>Slf4j：類似於Commons Logging，是一套簡易Java日誌門面，本身並無日誌的實現。（Simple Logging Facade for Java，縮寫Slf4j）。</li><li>Logback：一套日誌組件的實現(slf4j陣營)。</li></ul><p style=text-align:start>Commons Logging和Slf4j是日誌門面，提供一個統一的高層接口，為各種loging API提供一個簡單統一的接口。log4j和Logback則是具體的日誌實現方案。可以簡單的理解為接口與接口的實現，調用者只需要關注接口而無需關注具體的實現，做到解耦。</p><p style=text-align:start>比較常用的組合使用方式是Slf4j與Logback組合使用，Commons Logging與Log4j組合使用。</p><p style=text-align:start>基於下面的一些優點，選用Slf4j+Logback的日誌框架：</p><ul><li>更快的執行速度，Logback重寫了內部的實現，在一些關鍵執行路徑上性能提升10倍以上。而且logback不僅性能提升了，初始化內存加載也更小了</li><li>自動清除舊的日誌歸檔文件，通過設置TimeBasedRollingPolicy 或者 SizeAndTimeBasedFNATP的 maxHistory 屬性，你就可以控制日誌歸檔文件的最大數量</li><li>Logback擁有遠比log4j更豐富的過濾能力，可以不用降低日誌級別而記錄低級別中的日誌。</li><li>Logback必須配合Slf4j使用。由於Logback和Slf4j是同一個作者，其兼容性不言而喻。</li><li>默認情況下，Spring Boot會用Logback來記錄日誌，並用INFO級別輸出到控制檯。</li></ul><h1 class=pgc-h-arrow-right><strong>2、配置日誌</strong></h1><p style=text-align:start>可以看到，只要集成了spring-boot-starter-web，就引入了spring-boot-starter-logging，即slf4j和logback。</p><p style=text-align:start>其它的幾個包：jcl-over-slf4j，代碼直接調用common-logging會被橋接到slf4j；jul-to-slf4j，代碼直接調用java.util.logging會被橋接到slf4j；log4j-over-slf4j，代碼直接調用log4j會被橋接到slf4j。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e649f2778b2e44d8b354706200efd382><p class=pgc-img-caption></p></div><p style=text-align:start>還需引入janino，如果不加入這個包會報錯。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/72f2f98c70ec4e21bbb52f01c98dbfa9><p class=pgc-img-caption></p></div><p style=text-align:start>在resources下添加logback.xml配置文件，Logback默認會查找classpath下的logback.xml文件。<br></p><p style=text-align:start>具體配置如下，有較詳細的註釋，很容易看懂。可以通過application.properties配置日誌記錄級別、日誌輸出文件目錄等。<br></p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44a6db0ff9e14f9093ed709eceaac45a><p class=pgc-img-caption></p></div><p>View Code</p><p style=text-align:start>加入配置文件後，就可以看到控制檯格式化後的日誌輸出，還可以看到具體代碼行數等，比之前的友好多了。</p><p style=text-align:start>同時，將日誌滾動輸出到日誌文件，保留歷史記錄。可通過logback.rolling=false控制是否需要輸出日誌到文件。</p><h1 class=pgc-h-arrow-right><strong>3、使用Logger</strong></h1><p style=text-align:start>配置好之後，就可以使用Logger來輸出日誌了，使用起來也是非常方便。</p><p style=text-align:start>* 可以看到引入的包是slf4j.Logger，代碼裡並沒有引用任何一個跟 Logback 相關的類，這便是使用 Slf4j的好處，在需要將日誌框架切換為其它日誌框架時，無需改動已有的代碼。</p><p style=text-align:start>* LoggerFactory 的 getLogger() 方法接收一個參數，以這個參數決定 logger 的名字，比如第二圖中的日誌輸出。在為 logger 命名時，用類的全限定類名作為 logger name 是最好的策略，這樣能夠追蹤到每一條日誌消息的來源</p><p style=text-align:start>* 可以看到，可以通過提供佔位符，以參數化的方式打印日誌，避免字符串拼接的不必要損耗，也無需通過logger.isDebugEnabled()這種方式判斷是否需要打印。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/56b7dadeee6f4c0aa22354a06300ea5d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f75041d629e43e6863654d93eceec5a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>4、全局異常處理</strong></h1><p style=text-align:start>現在有一個問題，當日志級別設置到INFO級別後，只會輸出INFO以上的日誌，如INFO、WARN、ERROR，這沒毛病，問題是，程序中拋出的異常堆棧(運行時異常)都沒有打印了，不利於排查問題。</p><p style=text-align:start>而且，在某些情況下，我們在Service中想直接把異常往Controller拋出不做處理，但我們不能直接把異常信息輸出到客戶端，這是非常不友好的。</p><p style=text-align:start>所以，在config下建一個GlobalExceptionConfig作為全局統一異常處理。主要處理了自定義的ServiceException、AuthorityException、BaseException，以及系統的NoHandlerFoundException和Exception異常。</p><p>View Code</p><p style=text-align:start>看上面的代碼，@ControllAdvice(@RestControllerAdvice可以返回ResponseBody)，可看做Controller增強器，可以在@ControllerAdvice作用類下添加@ExceptionHandler，@InitBinder，@ModelAttribute註解的方法來增強Controller，都會作用在被 @RequestMapping 註解的方法上。</p><p style=text-align:start>使用@ExceptionHandler 攔截異常，我們可以通過該註解實現自定義異常處理。在每個處理方法中，封裝Result，返回對應的消息及狀態碼等。</p><p style=text-align:start>通過Logger打印對應級別的日誌，也可以看到控制檯及日誌文件中有異常堆棧的輸出了。注意除了BaseException、Exception，其它的都只是打印了簡單信息，且為INFO級別。Exception是ERROR級別，且打印了堆棧信息。</p><p style=text-align:start>NoHandlerFoundException 是404異常，這裡注意要先關閉DispatcherServlet的NotFound默認異常處理。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/db0f0f1b17224dbb87fde7ee1ef3e8ec><p class=pgc-img-caption></p></div><p style=text-align:start>測試如下：這種返回結果就比較友好了。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/80356e09da404b949e072a75f3ee0a45><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/687ff4443a9545a88f88729c7773fbd5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>五、數據庫樂觀鎖</strong></h1><h1 class=pgc-h-arrow-right><strong>1、樂觀</strong><strong>鎖</strong></h1><p style=text-align:start>在併發修改同一條記錄時，為避免更新丟失，需要加鎖。要麼在應用層加鎖，要麼在緩存層加鎖，要麼在數據庫層使用樂觀鎖，使用version作為更新依據【強制】。 —— 《阿里巴巴Java開發手冊》</p><p style=text-align:start>樂觀鎖，基於數據版本(version)記錄機制實現，為數據庫表增加一個"version"字段。讀取出數據時，將此版本號一同讀出，之後更新時，對此版本號加一。提交數據時，提交的版本數據與數據庫表對應記錄的當前版本信息進行比對，如果提交的數據版本號大於數據庫表當前版本號，則予以更新，否則認為是過期數據。</p><p style=text-align:start>因此，這節就來處理BaseDTO中的"version"字段，通過增加一個mybatis插件來實現更新時版本號自動+1。</p><h1 class=pgc-h-arrow-right><strong>2、MyBatis插件介紹</strong></h1><p style=text-align:start>MyBatis 允許在己映射語句執行過程中的某一點進行攔截調用。默認情況下， MyBatis 允許使用插件來攔截的接口和方法包括以下幾個：<br></p><ul><li>Executor (update 、query 、flushStatements 、commit 、rollback 、getTransaction 、close 、isClosed)</li><li>ParameterHandler (getParameterObject 、setParameters)</li><li>ResultSetHandler (handleResul tSets 、handleCursorResultSets、handleOutputParameters)</li><li>StatementHandler (prepare 、parameterize 、batch update 、query)<br></li></ul><p style=text-align:start>MyBatis 插件實現攔截器接口Interceptor，在實現類中對攔截對象和方法進行處理 。<br></p><ul><li>setProperties：傳遞插件的參數，可以通過參數來改變插件的行為。</li><li>plugin：參數 target 就是要攔截的對象，作用就是給被攔截對象生成一個代理對象，並返回。</li><li>intercept：會覆蓋所攔截對象的原方法，Invocation參數可以反射調度原來對象的方法，可以獲取到很多有用的東西。</li></ul><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04d66f7ce11e4b1dad9679d0cf27a6c4><p class=pgc-img-caption></p></div><p style=text-align:start>除了需要實現攔截器接口外，還需要給實現類配置攔截器簽名。 使用 @Intercepts 和 @Signature 這兩個註解來配置攔截器要攔截的接口的方法，接口方法對應的簽名基本都是固定的。</p><p style=text-align:start>@Intercepts 註解的屬性是一個 ＠Signature 數組，可以在同 一個攔截器中同時攔截不同的接口和方法。</p><p style=text-align:start>@Signature 註解包含以下三個屬性。</p><ul><li>type：設置攔截的接口，可選值是前面提到的4個接口 。</li><li>method：設置攔截接口中的方法名， 可選值是前面4個接口對應的方法，需要和接口匹配 。</li><li>args：設置攔截方法的參數類型數組，通過方法名和參數類型可以確定唯一一個方法 。<br></li></ul><h1 class=pgc-h-arrow-right><strong>3、數據版本插件</strong></h1><p style=text-align:start>要實現版本號自動更新，我們需要在SQL被執行前修改SQL，因此我們需要攔截的就是 StatementHandler 接口的 prepare 方法，該方法會在數據庫執行前被調用，優先於當前接口的其它方法而被執行。</p><p style=text-align:start>在 core.plugin 包下新建一個VersionPlugin插件，實現Interceptor攔截器接口。</p><p style=text-align:start>該接口方法簽名如下：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/745773dfb8a54c51a9565e987e72c9fb><p class=pgc-img-caption></p></div><p style=text-align:start>在 interceptor 方法中對 UPDATE 類型的操作，修改原SQL，加入version，修改後的SQL類似下圖，更新時就會自動將version+1。同時帶上version條件，如果該版本號小於數據庫記錄版本號，則不會更新。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72628d69c1d04d69875c344602225073><p class=pgc-img-caption></p></div><p style=text-align:start>VersionInterceptor插件：</p><p>View Code</p><p style=text-align:start>之後還需配置該插件，只需要在MyBatisConfig中加入該配置即可。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee6465562b324b0481f6578815425cd7><p class=pgc-img-caption></p></div><p style=text-align:start>最後，如果版本不匹配，更新失敗，需要往外拋出異常提醒，所以修改BaseService的update方法，增加檢查更新是否失敗。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/37a205be5fcd4cec95714f8737b98925><p class=pgc-img-caption></p></div><p style=text-align:start>最後，能不用插件儘量不要用插件，因為它將修改MyBatis的底層設計。插件生成的是層層代理對象的責任鏈模式，通過反射方法運行，會有一定的性能消耗。</p><p style=text-align:start>我們也可以修改 tk.mapper 生成SQL的方法，加入version，這裡通過插件方式實現樂觀鎖主要是不為了去修改 mapper 的底層源碼，比較方便。</p><h1 class=pgc-h-arrow-right><strong>六、Druid數據庫連接池</strong></h1><p style=text-align:start>創建數據庫連接是一個很耗時的操作，也很容易對數據庫造成安全隱患。對數據庫連接的管理能顯著影響到整個應用程序的伸縮性和健壯性，影響程序的性能指標。</p><p style=text-align:start>數據庫連接池負責分配、管理和釋放數據庫連接，它允許應用程序重複使用一個現有的數據庫連接，而不是再重新建立一個；釋放空閒時間超過最大空閒時間的數據庫連接來避免因為沒有釋放數據庫連接而引起的數據庫連接遺漏。數據庫連接池能明顯提高對數據庫操作的性能。</p><p style=text-align:start>參考：</p><p style=text-align:start>　　Druid常見問題集錦</p><p style=text-align:start>　　常用數據庫連接池 (DBCP、c3p0、Druid) 配置說明</p><h1 class=pgc-h-arrow-right><strong>1、Druid</strong></h1><p style=text-align:start>Druid首先是一個數據庫連接池，但它不僅僅是一個數據庫連接池，它還包含一個ProxyDriver，一系列內置的JDBC組件庫，一個SQLParser。Druid支持所有JDBC兼容的數據庫，包括Oracle、MySql、Derby、Postgresql、SQLServer、H2等等。 Druid針對Oracle和MySql做了特別優化，比如Oracle的PSCache內存佔用優化，MySql的ping檢測優化。Druid在監控、可擴展性、穩定性和性能方面都有明顯的優勢。Druid提供了Filter-Chain模式的擴展API，可以自己編寫Filter攔截JDBC中的任何方法，可以在上面做任何事情，比如說性能監控、SQL審計、用戶名密碼加密、日誌等等。</p><h1 class=pgc-h-arrow-right><strong>2、配置</strong></h1><p style=text-align:start>Druid配置到core模塊下，只需在application.properties中添加如下配置即可，大部分配置是默認配置，可更改。有詳細的註釋，比較容易理解。</p><p>View Code</p><p style=text-align:start>之後啟動項目在地址欄輸入/druid/index.html並登錄就可以看到Druid監控頁面：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c3bb76819f934cddbc468ee048a80e3c><p class=pgc-img-caption></p></div><p style=text-align:start></p><p>回到頂部</p><h1 class=pgc-h-arrow-right><strong>七、Redis緩存</strong></h1><p style=text-align:start>對於如今的一箇中小型系統來說，至少也需要一個緩存來緩存熱點數據，加快數據的訪問數據，這裡選用Redis做緩存數據庫。在以後可以使用Redis做分佈式緩存、做Session共享等。</p><h1 class=pgc-h-arrow-right><strong>1、SpringBoot的緩存支持</strong></h1><p style=text-align:start>Spring定義了org.springframework.cache.CacheManager和org.springframework.cache.Cache接口來統一不同的緩存技術。CacheManager是Spring提供的各種緩存技術抽象接口，Cache接口包含緩存的各種操作。</p><p style=text-align:start>針對不同的緩存技術，需要實現不同的CacheManager，Redis緩存則提供了RedisCacheManager的實現。</p><p style=text-align:start>我將redis緩存功能放到sunny-starter-cache模塊下，cache模塊下可以有多種緩存技術，同時，對於其它項目來說，緩存是可插拔的，想用緩存直接引入cache模塊即可。</p><p style=text-align:start>首先引入Redis的依賴：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/489b4c2728c44e92abfb426a3290be1a><p class=pgc-img-caption></p></div><p style=text-align:start>SpringBoot已經默認為我們自動配置了多個CacheManager的實現，在autoconfigure.cache包下。在Spring Boot 環境下，使用緩存技術只需在項目中導入相關的依賴包即可。</p><p style=text-align:start>在 RedisCacheConfiguration 裡配置了默認的 CacheManager；SpringBoot提供了默認的redis配置，RedisAutoConfiguration 是Redis的自動化配置，比如創建連接池、初始化RedisTemplate等。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4ede4c6d778e496cbb8d94161859a1bf><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/396ca36c024d4afc99e47871713c0d97><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、Redis 配置及聲明式緩存支持</strong></h1><p style=text-align:start>Redis 默認配置了 RedisTemplate 和 StringRedisTemplate ，其使用的序列化規則是 JdkSerializationRedisSerializer，緩存到redis後，數據都變成了下面這種樣式，非常不易於閱讀。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f252ee7117d498791378fed59f079d7><p class=pgc-img-caption></p></div><p style=text-align:start>因此，重新配置RedisTemplate，使用 Jackson2JsonRedisSerializer 來序列化 Key 和 Value。同時，增加HashOperations、ValueOperations等Redis數據結構相關的操作，這樣比較方便使用。</p><p>View Code</p><p style=text-align:start>同時，使用@EnableCaching開啟聲明式緩存支持，這樣就可以使用基於註解的緩存技術。註解緩存是一個對緩存使用的抽象，通過在代碼中添加下面的一些註解，達到緩存的效果。</p><ul><li>@Cacheable：在方法執行前Spring先查看緩存中是否有數據，如果有數據，則直接返回緩存數據；沒有則調用方法並將方法返回值放進緩存。</li><li>@CachePut：將方法的返回值放到緩存中。</li><li>@CacheEvict：刪除緩存中的數據。</li></ul><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/089252fe31fe43b8915319bbf6184377><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4f6eb29e15ba4cc3bd6ca1e77d799a0f><p class=pgc-img-caption></p></div><p style=text-align:start>Redis服務器相關的一些配置可在application.properties中進行配置：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b67920b985ad48aaa8ea018bfc32646a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3、Redis工具類</strong></h1><p style=text-align:start>添加一個Redis的統一操作工具，主要是對redis的常用數據類型操作類做了一個歸集。</p><p style=text-align:start>ValueOperations用於操作String類型，HashOperations用於操作hash數據，ListOperations操作List集合，SetOperations操作Set集合，ZSetOperations操作有序集合。</p><p style=text-align:start>關於redis的key命令和數據類型可參考我的學習筆記：</p><p style=text-align:start>Redis 學習(一) —— 安裝、通用key操作命令</p><p style=text-align:start>Redis 學習(二) —— 數據類型及操作</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44a6db0ff9e14f9093ed709eceaac45a><p class=pgc-img-caption></p></div><p>View Code</p><p style=text-align:start></p><p>回到頂部</p><h1 class=pgc-h-arrow-right><strong>八、Swagger支持API文檔</strong></h1><h1 class=pgc-h-arrow-right><strong>1、Swagger</strong></h1><p style=text-align:start>做前後端分離，前端和後端的唯一聯繫，變成了API接口；API文檔變成了前後端開發人員聯繫的紐帶，變得越來越重要，swagger就是一款讓你更好的書寫API文檔的框架。</p><p style=text-align:start>Swagger是一個簡單又強大的能為你的Restful風格的Api生成文檔的工具。在項目中集成這個工具，根據我們自己的配置信息能夠自動為我們生成一個api文檔展示頁，可以在瀏覽器中直接訪問查看項目中的接口信息，同時也可以測試每個api接口。</p><h1 class=pgc-h-arrow-right><strong>2、配置</strong></h1><p style=text-align:start>我這裡直接使用別人已經整合好的swagger-spring-boot-starter，快速方便。</p><p style=text-align:start>參考：spring-boot-starter-swagger</p><p style=text-align:start>新建一個sunny-starter-swagger模塊，做到可插拔。</p><p style=text-align:start>根據文檔，一般只需要做些簡單的配置即可：</p><p style=text-align:start>但如果想要顯示swagger-ui.html文檔展示頁，還必須注入swagger資源：</p><p>View Code</p><h1 class=pgc-h-arrow-right><strong>3、使用</strong></h1><p>一般只需要在Controller加上swagger的註解即可顯示對應的文檔信息，如@Api、@ApiOperation、@ApiParam等。</p><p>常用註解參考：swagger-api-annotations</p><p>View Code</p><p>之後訪問swagger-ui.html頁面就可以看到API文檔信息了。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/599344da23fc4cd4a518ee1a22e71ddb><p class=pgc-img-caption></p></div><p>如果不需要swagger，在配置文件中配置swagger.enabled=false，或移除sunny-starter-swagger的依賴即可。</p><h1 class=pgc-h-arrow-right><strong>九、項目優化調整</strong></h1><p>到這裡，項目最基礎的一些功能就算完成了，但由於前期的一些設計不合理及未考慮周全等因素，對項目做一些調整。並參考《阿里巴巴Java開發手冊》對代碼做了一些優化。</p><h1 class=pgc-h-arrow-right><strong>1、項目結構</strong></h1><p>目前項目分為5個模塊：</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/10ee19cb93fb4b13ac6853798858e2f2><p class=pgc-img-caption></p></div><p>最外層的Sunny作為聚合模塊負責管理所有子模塊，方便統一構建。並且繼承 spring-boot-starter-parent ，其它子模塊則繼承該模塊，方便統一管理 Spring Boot 及本項目的版本。這裡已經把Spring Boot的版本升到 1.5.10.RELEASE。</p><p>View Code</p><p>sunny-starter 則引入了其餘幾個模塊，在開發項目時，只需要繼承或引入sunny-starter即可，而無需一個個引入各個模塊。</p><p>View Code</p><p>對於一個Spring Boot項目，應該只有一個入口，即 @SpringBootApplication 註解的類。經測試，其它的模塊的配置文件application.properties的配置不會生效，應該是引用了入口模塊的配置文件。</p><p>所以為了讓各個模塊的配置文件都能生效，只需使用 @PropertySource 引入該配置文件即可，每個模塊都如此。在主模塊定義的配置會覆蓋其它模塊的配置。</p><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/70e87c9209e0405ab2d27e95b59702f8><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、開發規範</strong></h1><div class=pgc-img><img alt="基於Spring Boot搭建應用開發框架——基礎架構" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eb3f52f4e9c649918aaba36d64ee6f68><p class=pgc-img-caption></p></div><p></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>Boot</a></li><li><a>應用</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html alt="Spring Boot 統一異常這樣處理和剖析，安否？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/95dd8dbd-33ff-4c32-a4b5-fd78e6126995 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html title="Spring Boot 統一異常這樣處理和剖析，安否？">Spring Boot 統一異常這樣處理和剖析，安否？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html alt="Spring Boot中文參考指南（2.1.6）90、熱交換" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52221486045249f1a4a361d34e84016e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html title="Spring Boot中文參考指南（2.1.6）90、熱交換">Spring Boot中文參考指南（2.1.6）90、熱交換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe46907e.html alt="Spring Boot實現xml數據格式傳輸" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0d7162206c2444189f24fc0f5fcd469e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe46907e.html title="Spring Boot實現xml數據格式傳輸">Spring Boot實現xml數據格式傳輸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b61684e.html alt="「Spring Boot專題」CORS跨域" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/49f28dea215a4273af5112e80bd79c03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b61684e.html title="「Spring Boot專題」CORS跨域">「Spring Boot專題」CORS跨域</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4bf763b.html alt="基礎篇：Spring Boot入門體驗（圖文教程）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RwsEOXvIHX7bQq style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4bf763b.html title="基礎篇：Spring Boot入門體驗（圖文教程）">基礎篇：Spring Boot入門體驗（圖文教程）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/245fb59.html alt="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9050c2396d10468ba999f16bd70ce041 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/245fb59.html title="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心">聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ad16f9.html alt="Spring Boot 入門系列（二十五）讀取配置文件的三種方式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ad16f9.html title="Spring Boot 入門系列（二十五）讀取配置文件的三種方式">Spring Boot 入門系列（二十五）讀取配置文件的三種方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3312eb6.html alt="Spring Boot 在啟動時進行配置文件加解密" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/677858a9ea4e455e840b8fb8dc7656b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3312eb6.html title="Spring Boot 在啟動時進行配置文件加解密">Spring Boot 在啟動時進行配置文件加解密</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07c6935.html alt="Spring Boot配置文件yml格式詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c60ba743367141da8cddac4cb8bd7412 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07c6935.html title="Spring Boot配置文件yml格式詳解">Spring Boot配置文件yml格式詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ff10d3.html alt="Spring Boot 異步請求和異步調用，一文搞定" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3c824262b5b0401cbf72463bf246c13b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ff10d3.html title="Spring Boot 異步請求和異步調用，一文搞定">Spring Boot 異步請求和異步調用，一文搞定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b748ad6.html alt="使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ae11deaa7ce44232a1fa67b224125bb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b748ad6.html title="使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？">使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/cd142eb.html alt="Spring Boot入門系列（十三）如何實現事務，極簡版！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/15d70cf19e1c4967afc5d49a10def1ce style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/cd142eb.html title="Spring Boot入門系列（十三）如何實現事務，極簡版！">Spring Boot入門系列（十三）如何實現事務，極簡版！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e4be374.html alt=鈦及鈦合金鑄件的應用領域​ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/Rca7hqUCttQBq0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e4be374.html title=鈦及鈦合金鑄件的應用領域​>鈦及鈦合金鑄件的應用領域​</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/958c038a.html alt=鑄造鋁合金應用現狀及未來前景分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8dcaa42ff9a64e2cad814e4e025fc52c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/958c038a.html title=鑄造鋁合金應用現狀及未來前景分析>鑄造鋁合金應用現狀及未來前景分析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>