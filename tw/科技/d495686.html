<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>架構師經典分享：面向對象的設計原則你瞭解幾個？ | 极客快訊</title><meta property="og:title" content="架構師經典分享：面向對象的設計原則你瞭解幾個？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/a74a616a-6491-4801-b892-7b2bd6914584"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d495686.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d495686.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d495686.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d495686.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d495686.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d495686.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d495686.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d495686.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="架構師經典分享：面向對象的設計原則你瞭解幾個？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d495686.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>架構師經典分享：面向對象的設計原則你瞭解幾個？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>前言</strong></p><p>在面向對象的軟件設計中，只有儘量降低各個模塊之間的耦合度，才能提高代碼的複用率，系統的可維護性、可擴展性才能提高。面向對象的軟件設計中，有23種經典的設計模式，是一套前人代碼設計經驗的總結，如果把設計模式比作武功招式，那麼設計原則就好比是內功心法。常用的設計原則有七個，下文將具體介紹。</p><div class=pgc-img><img alt=架構師經典分享：面向對象的設計原則你瞭解幾個？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/a74a616a-6491-4801-b892-7b2bd6914584><p class=pgc-img-caption></p></div><p><strong>設計原則簡介</strong></p><ul><li>單一職責原則： 專注降低類的複雜度，實現類要職責單一；</li><li>開放關閉原則： 所有面向對象原則的核心，設計要對擴展開發，對修改關閉；</li><li>裡式替換原則： 實現開放關閉原則的重要方式之一，設計不要破壞繼承關係；</li><li>依賴倒置原則： 系統抽象化的具體實現，要求面向接口編程，是面向對象設計的主要實現機制之一；</li><li>接口隔離原則： 要求接口的方法儘量少，接口儘量細化；</li><li>迪米特法則： 降低系統的耦合度，使一個模塊的修改儘量少的影響其他模塊，擴展會相對容易；</li><li>組合複用原則： 在軟件設計中，儘量使用組合/聚合而不是繼承達到代碼複用的目的。</li></ul><p>這些設計原則並不說我們一定要遵循他們來進行設計，而是根據我們的實際情況去怎麼去選擇使用他們，來讓我們的程序做的更加的完善。</p><div class=pgc-img><img alt=架構師經典分享：面向對象的設計原則你瞭解幾個？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/89c2d18e-c40e-468a-82d8-ebbf6638c8ac><p class=pgc-img-caption></p></div><p><strong>裡式替換原則</strong></p><p>定義 ：</p><p>如果對每一個類型為T1的對象o1，都有類型為T2的對象o2，使得以T1定義的所有程序P在所有的對象o1都代換成o2 時，程序P的行為沒有發生變化，那麼類型 T2 是類型 T1 的子類型。</p><p>換句話來說，一個軟件實體如果使用一個基類的話，那麼一定適用於其子類，而且它根本不會察覺出基類對象和子類對象的區別。</p><p>比如說，假設有兩個類，一個是Base類，另一個是Derived類，並且Derived類是Base的子類，那麼一個方法如果可以接受一個基類對象b的話： method(Base b) ,那麼它必然可以接受一個子類對象d，可以有 method1(d)</p><p>裡式替換原則是繼承複用的基石，只有當衍生類可以替換掉基類，軟件單位的功能不會受到影響的時候，基類才能真正被複用，而衍生類也才能夠在基類的基礎上增加新的行為。</p><p>我們通過一個例子來理解一下：</p><p>《西遊記》中，美猴王下地府橋段，個位應該有印象把，到達閻王殿之後，拿到生死簿，把生死簿上所有的包括自己，還有其他的獼猴，所有的猴子猴算都給劃了，這也是導致之後真假美猴王橋段的前序。</p><p>畫個圖理解</p><p class=ql-align-center></p><div class=pgc-img><img alt=架構師經典分享：面向對象的設計原則你瞭解幾個？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0ba812e46e6946ce842ff166bac7a902><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>很顯然，地府管理一切生靈的生死的方法都是通過類來進行區分的，比如孫悟空就是石猴，之後出現的那個六耳獼猴就是獼猴，但是他們都是屬於同一個類，猴類，就像下圖中。</p><p class=ql-align-center></p><div class=pgc-img><img alt=架構師經典分享：面向對象的設計原則你瞭解幾個？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6ecd3d95e09b493095e28ae9697a2693><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>因此，孫悟空把猴類中有姓名的都從生死簿勾掉之後，顯然是因為勾魂小鬼們並不區分石猴類與獼猴類，就像下圖：</p><p class=ql-align-center></p><div class=pgc-img><img alt=架構師經典分享：面向對象的設計原則你瞭解幾個？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d7ba39425a02437eb55dd742bbb0ab29><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>換句話來說，只要是猴類適用的，獼猴和石猴都適用，這其實就是裡式替換原則。</p><p>這是第一種解釋，還有第二個更加通俗易懂的解釋： 所有引用基類的地方必須能透明地使用其子類的對象。</p><p>第二種定義比較通俗，容易理解：只要有父類出現的地方，都可以用子類來替代，而且不會出現任何錯誤和異常。但是反過來則不行，有子類出現的地方，不能用其父類替代。</p><p>實例代碼 ：</p><p>public class TestA {</p><p>public void fun(int a,int b){</p><p>System.out.println(a+"+"+b+"="+(a+b));</p><p>}</p><p>public static void main(String[] args) {</p><p>System.out.println("父類的運行結果");</p><p>TestA a=new TestA();</p><p>a.fun(1,2);</p><p>//父類存在的地方，可以用子類替代</p><p>//子類B替代父類A</p><p>System.out.println("子類替代父類後的運行結果");</p><p>TestB b=new TestB();</p><p>b.fun(1,2);</p><p>}</p><p>}</p><p>class TestB extends TestA{</p><p>@Override</p><p>public void fun(int a, int b) {</p><p>System.out.println(a+"-"+b+"="+(a-b));</p><p>}</p><p>}</p><p>大家肯定也都能猜出來結果是什麼樣子的</p><p>父類的運行結果</p><p>1+2=3</p><p>子類替代父類後的運行結果</p><p>1-2=-1</p><p>Process finished with exit code 0</p><p>我們想要的結果是“1+2=3”。可以看到，方法重寫後結果就不是了我們想要的結果了，也就是這個程序中子類B不能替代父類A。這違反了里氏替換原則原則，從而給程序造成了錯誤。</p><p>子類中可以增加自己特有的方法</p><p>這個很容易理解，子類繼承了父類，擁有了父類和方法，同時還可以定義自己有，而父類沒有的方法。這是在繼承父類方法的基礎上進行功能的擴展，符合里氏替換原則。</p><p>public class TestA {</p><p>public void fun(int a,int b){</p><p>System.out.println(a+"+"+b+"="+(a+b));</p><p>}</p><p>public static void main(String[] args) {</p><p>System.out.println("父類的運行結果");</p><p>TestA a=new TestA();</p><p>a.fun(1,2);</p><p>//父類存在的地方，可以用子類替代</p><p>//子類B替代父類A</p><p>System.out.println("子類替代父類後的運行結果");</p><p>TestB b=new TestB();</p><p>b.fun(1,2);</p><p>b.newFun();</p><p>}</p><p>}</p><p>class TestB extends TestA{</p><p>public void newFun(){</p><p>System.out.println("這是子類的新方法...");</p><p>}</p><p>}</p><p>這次運行出來的代碼結果就是我們意料中的內容了</p><p>父類的運行結果</p><p>1+2=3</p><p>子類替代父類後的運行結果</p><p>1+2=3</p><p>這是子類的新方法...</p><p>Process finished with exit code 0</p><p>AVA語言對裡式替換原則支持的侷限 ：</p><p>JAVA編譯器的檢查是有侷限性的，為什麼呢？舉個例子來說，描述一個物體大小的量有精度和準確度兩種屬性。所謂的精度，就是這個量的有效數字有多少位；而所謂的精準度，是這個量與真實的物體大小相符合到什麼程度。</p><p>一個量可以有很高的精度，但是卻無法與真實物體的情況相吻合，JAVA語言編譯器能夠檢查的，僅僅是相當於精度的屬性而已，它沒有辦法去檢查這個量與真實物體的差距。</p><p>換一句話來說，JAVA編譯器不能檢查一個系統在實現和商業邏輯上是否滿足裡式替換原則。</p><p>而裡式替換原則在設計模式中也有體現，請關注我們的知識星球，鏈接在文末，我們將每週更新一篇關於設計模式的文章。</p><p><strong>依賴倒置原則</strong></p><p>如果說實現開閉原則的關鍵事抽象化，是面向對象設計的目標的話，依賴倒置原則就是這個面向對象設計的主要機制。</p><p>定義 ：</p><p>抽象不應該依賴於細節，細節應當依賴於抽象。換言之，要針對接口編程，而不是針對實現編程。</p><p>為什麼要實現倒置？這也是我們看這個定義的時候產生的一些問題，那麼我們就來說說。</p><p>簡單的來說，傳統的過程性系統的設計辦法傾向於使高層次的模塊依賴於低層次的模塊，抽象層依賴於具體層次，倒置原則是要把這個錯誤的依賴關係倒轉過來，這就是依賴倒置原則的由來。也是為什麼要進行依賴倒置。</p><div class=pgc-img><img alt=架構師經典分享：面向對象的設計原則你瞭解幾個？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/9b0b8756-b23e-41ac-9b59-6e948b60beb4><p class=pgc-img-caption></p></div><p>依賴倒置原則的實現方法</p><p>依賴倒置原則的目的是通過要面向接口的編程來降低類間的耦合性，所以我們在實際編程中只要遵循以下4點，就能在項目中滿足這個規則:</p><ul><li>每個類儘量提供接口或抽象類，或者兩者都具備。</li><li>變量的聲明類型儘量是接口或者是抽象類。</li><li>任何類都不應該從具體類派生。</li><li>使用繼承時儘量遵循里氏替換原則。</li></ul><p>下面我們通過一些代碼實例(商品售賣)來進行理解：</p><p>class BeijingShop implements Shop{</p><p>public String sell(){</p><p>return "北京商店售賣：北京烤鴨，稻香村月餅";</p><p>}</p><p>}</p><p>class ShanDongShop implements Shop{</p><p>@Override</p><p>public String sell() {</p><p>return "山東商店售賣：德州扒雞，煙臺蘋果";</p><p>}</p><p>}</p><p>//如果說顧客去購買商品</p><p>class Customer{</p><p>public void shopping(ShanDongShop shop){</p><p>//購物</p><p>System.out.println(shop.sell());</p><p>}</p><p>｝</p><p>//這是在山東商店購買，如果說是在北京商店購買就會這樣</p><p>class Customer{</p><p>public void shopping(BeijingShop shop) {</p><p>//購物</p><p>System.out.println(shop.sell());</p><p>}</p><p>｝</p><p>這也是這種設計的存在缺陷，顧客每更換一家商店，都要修改一次代碼，這明顯違背了開閉原則。存在以上缺點的原因是：顧客類設計時同具體的商店類綁定了，這違背了依賴倒置原則。解決方式我們可以定義一個共同的接口Shop，就可以這樣了。</p><p>public class TestSale {</p><p>public static void main(String[] args) {</p><p>Customer c = new Customer();</p><p>System.out.println("---顧客購買商品如下---");</p><p>c.shopping(new ShanDongShop());</p><p>c.shopping(new BeijingShop());</p><p>}</p><p>}</p><p>interface Shop{</p><p>//售賣方法</p><p>public String sell();</p><p>}</p><p>class BeijingShop implements Shop{</p><p>public String sell(){</p><p>return "北京商店售賣：北京烤鴨，稻香村月餅";</p><p>}</p><p>}</p><p>class ShanDongShop implements Shop{</p><p>@Override</p><p>public String sell() {</p><p>return "山東商店售賣：德州扒雞，煙臺蘋果";</p><p>}</p><p>}</p><p>class Customer{</p><p>public void shopping(Shop shop) {</p><p>System.out.println(shop.sell());//購物</p><p>}</p><p>}</p><p>程序運行結果</p><p>---顧客購買商品如下---</p><p>山東商店售賣：德州扒雞，煙臺蘋果</p><p>北京商店售賣：北京烤鴨，稻香村月餅</p><p>Process finished with exit code 0</p><p>這樣，不管顧客類 Customer 訪問什麼商店，或者增加新的商店，都不需要修改原有代碼了。</p><p><strong>需要的Java架構師方面的資料可以關注之後私信哈，回覆“資料”領取免費架構視頻資料，記得要點贊轉發噢！！！</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>架構</a></li><li><a>師經典</a></li><li><a>對象</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html alt=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0670cbc9828449c782ac323a238b99e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html title=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效>朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html alt=活動文件櫃的架構是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/104d3629a97947b19d62b03dc3b8d82f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html title=活動文件櫃的架構是什麼>活動文件櫃的架構是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html alt=九年新浪架構師整理PHP架構核心技術教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b3a3c32254344742b6746996f7fab54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html title=九年新浪架構師整理PHP架構核心技術教程>九年新浪架構師整理PHP架構核心技術教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html alt=Kafka整體架構圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/05ae540358854cb3ba0aa4577709330d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html title=Kafka整體架構圖解>Kafka整體架構圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html alt=MyBatis整體架構分析：基礎支持層、核心處理層和接口層 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d6a0b300b114d07b2f3fe66d7ef7005 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html title=MyBatis整體架構分析：基礎支持層、核心處理層和接口層>MyBatis整體架構分析：基礎支持層、核心處理層和接口層</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html alt=K8S整體架構解析，簡單明瞭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/37380f3294a54bbf8c6bec1de3e08ba0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html title=K8S整體架構解析，簡單明瞭>K8S整體架構解析，簡單明瞭</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html alt=支付系統：整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1d94fa40459462fa825d407a1904c7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html title=支付系統：整體架構>支付系統：整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91455082.html alt=AutoCAD中的對象選擇操作方法彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278d76e8d8ad4cf9bd0fb56291e093f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91455082.html title=AutoCAD中的對象選擇操作方法彙總>AutoCAD中的對象選擇操作方法彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/df4050f5.html alt=PPT頁面中對象太多，很難選中真氣人！還好有「選擇窗格」功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/01f297811eb5492495130587fd585ab6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/df4050f5.html title=PPT頁面中對象太多，很難選中真氣人！還好有「選擇窗格」功能>PPT頁面中對象太多，很難選中真氣人！還好有「選擇窗格」功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html alt=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bd78fffbaaf54bd79c6e463d5b69ed9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html title=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？>「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html alt=微服務分佈式架構中，如何實現日誌鏈路跟蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3a2cecaee304124a86a864a75c38b5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html title=微服務分佈式架構中，如何實現日誌鏈路跟蹤？>微服務分佈式架構中，如何實現日誌鏈路跟蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48822193.html alt="「前端架構」前端框架(一部): Angular的內幕" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/efd86e8d12f44e7b97726d738e8d6c1d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48822193.html title="「前端架構」前端框架(一部): Angular的內幕">「前端架構」前端框架(一部): Angular的內幕</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4515b9af.html alt="Uber 架構(1)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/da0e1368146f4614836d85f921a0e4a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4515b9af.html title="Uber 架構(1)">Uber 架構(1)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>