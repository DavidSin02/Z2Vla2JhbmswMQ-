<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>概述、耦合、UML、七大原則，詳細分析總結（基於Java） | 极客快訊</title><meta property="og:title" content="概述、耦合、UML、七大原則，詳細分析總結（基於Java） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d62d63b5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d62d63b5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d62d63b5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d62d63b5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d62d63b5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d62d63b5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d62d63b5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d62d63b5.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="概述、耦合、UML、七大原則，詳細分析總結（基於Java）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d62d63b5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>概述、耦合、UML、七大原則，詳細分析總結（基於Java）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>迷茫了一週，一段時間重複的 CRUD ，著實讓我有點煩悶，最近打算將這些技術棧系列的文章先暫時擱置一下，開啟一個新的篇章《設計模式》，畢竟前面寫了不少 “武功招式” 的文章，也該提升一下內功了</p><h1 class=pgc-h-arrow-right>一 設計模式概述</h1><h1 class=pgc-h-arrow-right>(一) 什麼是設計模式</h1><p>設計模式，即Design Patterns，是指在軟件設計中，被反覆使用的一種代碼設計經驗。使用設計模式的目的是為了可重用代碼，提高代碼的可擴展性和可維護性</p><blockquote><p>1995年，GoF（Gang of Four,四人組/四人幫）合作出版了《設計模式：可複用面向對象軟 件的基礎》一書，收錄了23種設計模式，從此樹立了軟件設計模式領域的里程碑，【GoF設計模式】</p></blockquote><h1 class=pgc-h-arrow-right>(二) 為什麼學習設計模式</h1><p>前面我們學習了 N 種不同的技術，但是歸根結底，也只是 CRUD 與 調用之間的堆砌，或許這個創意亦或是業務很完善、很強大，其中也巧妙運用了各種高效的算法，但是說白了，這也只是為了實現或者說解決某個問題而做的</p><p>還有時候，兩個人同時開發一款相同的產品，均滿足了預期的需求，但是 A 的程序，不僅<strong>代碼健壯性強</strong>，同時<strong>後期維護擴展更是便捷</strong>（這種感覺，我們會在後面具體的設計模式中愈發的感覺到）而 B 的代碼卻是一言難盡啊</p><p>有一句話總結的非常好：</p><ul><li><strong>設計模式的本質是面向對象設計原則的實際運用，是對類的封裝性、繼承性和多態性以及類的關聯關係和組合關係的充分理解</strong></li></ul><p>也就是說，畢竟像例如Java這樣面向對象的語言中，如何實現一個可維護，可維護的代碼，那必然就是要降低代碼耦合度，適當複用代碼，而要實現這一切，就需要充分的利用 OOP 編程的特性和思想</p><p>注:下面第二大點補充【耦合】的相關概念,若不需要跳轉第三四大點【UML類圖及類圖間的關係】/【設計模式七大原則】</p><p>在之前我寫 Spring依賴注入的時候【萬字長文】 Spring框架層層遞進輕鬆入門(0C和D),就是從傳統開發,講到了如何通過工廠模式，以及多例到單例的改進，來一步步實現解耦，有興趣的朋友可以看一下哈</p><p>【萬字長文】Spring框架 層層遞進輕鬆入門 (IOC和DI) juejin.im/post/684490…</p><h1 class=pgc-h-arrow-right>二 什麼是耦合？(高/低)</h1><p>作為一篇新手都能看懂的文章，開始就一堆 IOC AOP等專業名詞扔出去，好像是不太禮貌，我得把需要鋪墊的知識給大家儘量說一說，如果對這塊比較明白的大佬，直接略過就OK了</p><p>耦合，就是模塊間關聯的程度，每個模塊之間的聯繫越多，也就是其耦合性越強，那麼獨立性也就越差了，所以我們在軟件設計中，應該儘量做到<strong>低耦合</strong>，高內聚</p><p><strong>生活中的例子</strong>：家裡有一條串燈，上面有很多燈泡，如果燈壞了，你需要將整個燈帶都換掉，這就是高耦合的表現，因為燈和燈帶之間是緊密相連，不可分割的，但是如果燈泡可以隨意拆卸，並不影響整個燈帶，那麼這就叫做低耦合</p><p><strong>代碼中的例子</strong>：來看一個多態的調用，前提是 B 繼承 A，引用了很多次</p><pre><code>A a = new B();a.method();複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>如果你想要把B變成C，就需要修改所有new B() 的地方為 new C() 這也就是高耦合</p><p>如果如果使用我們今天要說的 spring框架 就可以大大的降低耦合</p><pre><code>A a = BeanFactory().getBean(B名稱);a.method();複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>這個時候，我們只需要將B名稱改為C，同時將配置文件中的B改為C就可以了</p><p>常見的耦合有這些分類：</p><h1 class=pgc-h-arrow-right>(一) 內容耦合</h1><p>當一個模塊直接修改或操作另一個模塊的數據,或者直接轉入另一個模塊時，就發生了內容耦合。此時，被修改的模塊完全依賴於修改它的模塊。 這種耦合性是很高的，最好避免</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/66c44e01058a425f87134ce1a7386027><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p></p><pre><code>public class A {    public int numA = 1;}public class B {    public static A a = new A();    public static void method(){        a.numA += 1;    }    public static void main(String[] args) {       method();       System.out.println(a.numA);    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>(二) 公共耦合</h1><p>兩個以上的模塊共同引用一個全局數據項就稱為公共耦合。大量的公共耦合結構中，會讓你很難確定是哪個模塊給全局變量賦了一個特定的值</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f8b985c1587149fba81ca042f740bd86><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(三) 外部耦合</h1><p>一組模塊都訪問同一全局簡單變量，而且不通過參數表傳遞該全局變量的信息，則稱之為外部耦合 從定義和圖中也可以看出，公共耦合和外部耦合的區別就在於<strong>前者是全局數據結構</strong>，<strong>後者是全局簡單變量</strong></p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1ffe5a42a3074427b17355b88c2bef44><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(四) 控制耦合</h1><p>控制耦合 。一個模塊通過接口向另一個模塊傳遞一個控制信號，接受信號的模塊根據信號值而進行適當的動作，這種耦合被稱為控制耦合，也就是說，模塊之間傳遞的不是數據，而是一些標誌，開關量等等</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f61173b6ac9741889857c07e79baaeac><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(五) 標記耦合</h1><p>標記耦合指兩個模塊之間傳遞的是數據機構，如高級語言的數組名、記錄名、文件名等這些名字即為標記，其實傳遞的是這個數據結構的地址</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fba2f1dec6d14d4493996a91df39cadd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(六) 數據耦合</h1><p>模塊之間通過參數來傳遞數據，那麼被稱為數據耦合。數據耦合是最低的一種耦合形 式，系統中一般都存在這種類型的耦合，因為為了完成一些有意義的功能，往往需要將某些模塊的輸出數據作為另 一些模塊的輸入數據</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77eec573956641fc89f156d03e2bb772><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(七) 非直接耦合</h1><p>兩個模塊之間沒有直接關係，它們之間的聯繫完全是通過主模塊的控制和調用來實現的</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9618cf9a2e244a4bbee297e503c0df8c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>三 UML 類圖及類圖之間的關係</h1><p>在一個相對完善的軟件系統中，每個類都有其責任，類與類之間，類與接口之間同時也存在著各種關係，UML（統一建模語言）從不同的角度定義了多種圖，在軟件建模時非常常用，下面我們說一下在設計模式中涉及相對較多的<strong>類圖</strong>，因為在後面單個設計模式的講解中，我們會涉及到，也算是一個基礎鋪墊。</p><h1 class=pgc-h-arrow-right>(一) 類</h1><p>類是一組相關的屬性和行為的集合，是一個抽象的概念，在UML中，一般用一個分為三層的矩形框來代表類</p><ul><li>第一層：類名稱,是一個字符串，例如 Student</li><li>第二層：類屬性（字段、成員變量）格式如下：[可見性]屬性名:類型[=默認值]例如：-name:String</li><li>第三層：類操作（方法、行為），格式如下：[可見性]名稱(參數列表)[:返回類型]</li><li>例如：+ display():void</li></ul><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/461329db27af401d99004c799296222b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(二) 接口</h1><p>接口，是一種特殊而又常用的類，不可被實例化，定義了一些抽象的操作（方法），但不包含屬性其實能見到接口 UML 描述的有三種形式：</p><ul><li>第一種：使用一個帶有名稱的小圓圈來表示，上面的Dog是接口名，下面是接口定義的方法</li><li>第二種：使用一個“框”來表示，和類很像，但是在最上面特別標註了 &lt;&lt;interface>></li></ul><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/856b5e72d05e4f448128dd69710f1bca><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(三) 關係</h1><h1 class=pgc-h-arrow-right>(1) 依賴關係</h1><p><strong>定義：如果一個元素 A 的變化影響到另一個元素 B，但是反之卻不成立，那麼這兩個元素 B 和 A 就可以稱為 B 依賴 A</strong></p><ul><li>例如：<strong>開門的人</strong> 想要執行<strong>開門</strong>這個動作，就必須藉助於<strong>鑰匙</strong>，這裡也就可以說，這個開門的人，依賴於鑰匙，如果鑰匙發生了什麼變化就會影響到開門的人，但是開門的人變化卻不會影響到鑰匙開門</li><li>例如：動物生活需要氧氣、水分、食物，這就是一個很字面的依賴關係</li></ul><p>依賴關係作為對象之間<strong>耦合度最低</strong>的一種臨時性關聯方式</p><p><strong>在代碼中，某個類的方法通過局部變量、方法的參數或者對靜態方法的調用來訪問另一個類（被依賴類）中的某些方法來完成一些職責。</strong></p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/faf8f763f40c4412b76b31109d8c8d1b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(2) 關聯關係</h1><p><strong>關聯就是類（準確的說是實例化後的對象）之間的關係，也就是說，如果兩個對象需要在一定時間內保持一定的關係，那麼就可以稱為關聯關係。</strong></p><ul><li>例如：學生（Student）在學校（School）學習知識（Knowledge）那麼這三者之間就存一個某種聯繫，可以建立關聯關係</li><li>例如：大雁（WildGoose）年年南下遷徙，因為它知道氣候（climate）規律</li></ul><p>關聯關係的雙方是可以互相通訊的，也就是說，“一個類知道另一個類”</p><p>這種關聯是可以<strong>雙向的</strong>，也可以是單向的</p><ul><li>雙向的關聯可以用帶兩個箭頭或者沒有箭頭的實線來表示</li><li>單向的關聯用帶一個箭頭的實線來表示，箭頭從使用類指向被關聯的類</li><li>也可以在關聯線的兩端標註角色名，代表兩種不同的角色</li></ul><p><strong>在代碼中通常將一個類的對象作為另一個類的成員變量來實現關聯關係</strong></p><p>下圖是一個教師和學生的雙向關聯關係</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcf56e37a864402ab468f4a9d98c3a87><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(3) 聚合關係</h1><p><strong>聚合關係也稱為聚集關係，它是一種特殊的較強關聯關係。表示類（準確的說是實例化後的對象）之間整體與部分的關係，是一種 has-a 的關係</strong></p><ul><li>例如：汽車（Car）有輪胎（Wheel），Car has a Wheel，這就是一個聚合關係，但是輪胎（Wheel）獨立於汽車也可以單獨存在，輪胎還是輪胎</li></ul><p>聚合關係可以用帶<strong>空心菱形</strong>的實線箭頭來表示，菱形指向整體</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7eec1c5153e24198bb6961f64481afca><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(4) 組合關係</h1><p><strong>組合是一種比聚合更強的關聯關係，其也表示類整體和部分之間的關係。但是整體對象可以控制部分對象的生命週期，一旦整體對象消失，部分也就自然消失了，即部分不能獨立存在</strong></p><p>聚合關係可以用帶<strong>實心菱形</strong>的實線箭頭來表示，菱形指向整體</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/91778dbfcfd5402e8b7274d542dad849><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>### (5) 泛化關係</p><p><strong>泛化描述一般與特殊（類圖中“一般”稱為超類或父類，“特殊”稱為子類）的關係，是父類和子類之間的關係，是一種繼承關係，描述了一種 is a kind of 的關係，特別要說明的是，泛化關係</strong><strong>式</strong><strong>對象之間耦合度最大的一種關係</strong></p><p>Java 中 extend 關鍵字就代表著這種關係，通常抽象類作為父類，具體類作為子類</p><ul><li>例如：交通工具為抽象父類，汽車，飛機等就位具體的子類</li></ul><p>泛化關係用帶空心三角箭頭的實線來表示，箭頭從子類指向父類</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b19d353066c0476f81a67c3d5d4223e9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(6) 實現關係</h1><p>實現關係就是接口和實現類之間的關係，實現類中實現了接口中定義的抽象操作</p><p>實現關係使用帶空心三角箭頭的虛線來表示，箭頭從實現類指向接口</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cd1e6e66bbc34e8392a45686446dab8b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>四 設計模式七大原則</h1><h1 class=pgc-h-arrow-right>(一) 開閉原則</h1><p><strong>定義：軟件實體應當對擴展開放，對修改關閉</strong></p><p>我們在開發任何產品的時候，別指望需求是一定不變的，當你不得不更改的你的代碼的時候，一個高質量的程序就體現出其價值了，它只需要在原來的基礎上增加一些擴展，而不至於去修改原先的代碼，因為這樣的做法常常會牽一髮而動全身。</p><p><strong>也就是說，開閉原則要求我們在開發一個軟件（模塊）的時候，要保證可以在不修改原有代碼的模塊的基礎上，然後能擴展其功能</strong></p><p>我們下面來具體談談</p><h1 class=pgc-h-arrow-right>(1) 對修改關閉</h1><p>對修改關閉，即不允許在原來的模塊或者代碼上進行修改。</p><p>A：抽象層次</p><p>例如定義一個接口，不同的定義處理思路，會有怎樣的差別呢</p><p>定義一</p><pre><code>boolean connectServer(String ip, int port, String user, String pwd)複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>定義二</p><pre><code>boolean connectServer(FTP ftp)複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><pre><code>public class FTP{    private String ip;    private int port;    private String user;    private String pwd;    ...... 省略 get set}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>兩種方式看似都是差不多的，也都能實現要求，但是如果我們想要在其基礎上增加一個新的參數</p><ul><li>如果以定義一的做法，一旦接口被修改，所有調用 connectServer 方法的位置都會出現問題</li><li>如果以定義二的做法，我們只需要修改 FTP 這個實體類，添加一個屬性即可這種情況下沒有用到這個新參數的調用處就不會出現問題，即使需要調用這個參數，我們也可以在 FTP 類的構造函數中，對其進行一個默認的賦值處理</li></ul><p>B：具體層次</p><p>對原有的具體層次的代碼進行修改，也是不太好的，雖然帶來的變化可能不如抽象層次的大，或者碰巧也沒問題，但是這種問題有時候是不可預料的，或許一些不經意的修改會帶了和預期完全不一致的結果</p><h1 class=pgc-h-arrow-right>(2) 對擴展開放</h1><p>對擴展開放，也就是我們不需要在原代碼上進行修改，因為我們定義的抽象層已經足夠的合理，足夠的包容，我們只需要根據需求重新派生一個實現類來擴展就可以了</p><h1 class=pgc-h-arrow-right>(3) 開發時如何處理</h1><blockquote><p>無論模塊是多麼“封閉”，都會存在一些無法對之封閉的變化。既然不可能完全封閉，設計人員必須對他設計的模塊應該對那種變化封閉做出選擇，他必須先猜測出最有可能發現的變化種類，然後構造抽象來隔離那些變化 ——《大話設計模式》</p></blockquote><p>預先猜測程序的變化，實際上是有很大難度，或許不完善，亦或者完全是錯誤的，所以為了規避這一點，我們可以選擇在剛開始寫代碼的時候，假設不會有任何變化出現，<strong>但當變化發生的時候，我們就要立即採取行動，通過 “抽象約束，封裝變化” 的方式，創建抽象來隔離發生的同類變化</strong></p><p>舉例：</p><p>例如寫一個加法程序，很容易就可以寫的出來，這個時候變化還沒有發生</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2b1bc042b0b34e0d9142e5a9448799ff><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>如果這個時候讓你增加一個減法或者乘除等的功能，你就發現，你就需要在原來的類上面修改，這顯然違背了 “開閉原則”，所以<strong>變化一旦發生，我們就立即採取行動</strong>，決定重構代碼，首先<strong>創建一個抽象類</strong>的運算類，通過繼承多態等隔離代碼，以後還想添加什麼類型的運算方式，只需要增加一個新的子類就可以了，也就是說，對程序的改動，是通過新代碼進行的，而不是更改現有代碼</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/52f4d848c9b640758b2d5601cab1790a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>小結：</p><ul><li>我們希望開發剛開始就知道可能發生的變化，因為等待發現變化的時間越長，要抽象代碼的代價就越大</li><li>不要刻意的去抽象，拒絕不成熟的抽象和抽象本身一樣重要</li></ul><h1 class=pgc-h-arrow-right>(二) 里氏替換原則</h1><h1 class=pgc-h-arrow-right>(1) 詳細說明</h1><p><strong>定義：繼承必須確保超類所擁有的性質在子類中仍然成立</strong></p><p>里氏替換原則，主要說明了關於繼承的內容，明確了何時使用繼承，亦或使用繼承的一些規定，是對於開閉原則中抽象化的一種補充</p><p>這裡我們主要談一下，繼承帶來的問題：</p><ul><li>繼承是侵入性的，子類繼承了父類，就必須擁有父類的所有屬性和方法，降低了代碼靈活度</li><li>耦合度變高，一旦<strong>父類的屬性和方法被修改</strong>，就需要考慮子類的修改，或許會造成大量代碼重構</li></ul><p>里氏替換原則說簡單一點就是：<strong>它認為，只有當子類可以替換父類，同時程序功能不受到影響，這個父類才算真正被複用</strong></p><p>其核心主要有這麼四點內容：</p><ul><li>① 子類可以實現父類的抽象方法，但不能覆蓋父類的非抽象方法</li><li>② 子類中可以增加自己特有的方法</li><li>③ 當子類的方法重載父類的方法時，子類方法的前置條件（即方法的輸入參數）要比父類的方法更寬鬆</li><li>④ 當子類的方法實現父類的方法時（重寫/重載或實現抽象方法），方法的後置條件（即方法的的輸出/返回值）要比父類的方法更嚴格或相等</li></ul><p>對照簡單的代碼來看一下，就一目瞭然了</p><p><strong>① 子類可以實現父類的抽象方法，但不能覆蓋父類的非抽象方法</strong></p><p>前半句很好理解，如果不實現父類的抽象方法，會編譯報錯</p><p>後半句是這裡的重點，父類中但凡實現好的方法，其實就是在設定整個繼承體系中的一系列規範和默認的契約，例如 鳥類 Bird 中，getFlyingSpeed(double speed) 用來獲取鳥的飛行速度，但幾維鳥作為一種特殊的鳥類，其實是不能飛行的，所以需要重寫繼承的子類方法 getFlyingSpeed(double speed) 將速度置為 0 ，但是會對整個繼承體系造成破壞</p><p>雖然我們平常經常會通過重寫父類方法來完成一些功能，同樣這樣也很簡單，但是一種潛在的繼承複用體系就被打亂了，如果在不適當的地方調用重寫後的方法，或多次運用多態，還可能會造成報錯</p><p>我們看下面的例子：</p><p>父類 Father</p><pre><code>public class Father {    public void speaking(String content){        System.out.println("父類: " + content);    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>子類 Son</p><pre><code>public class Son extends Father {    @Override    public void speaking(String content) {        System.out.println("子類: " + content);    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>子類 Daughter</p><pre><code>public class Daughter extends Father{}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>測試類 Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 直接調用父類運行的結果        Father father = new Father();        father.speaking("speaking方法被調用");        // Son子類替換父類運行的結果        Son son = new Son();        son.speaking("speaking方法被調用");        // Daughter子類替換父類運行的結果        Daughter daughter = new Daughter();        daughter.speaking("speaking方法被調用");    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>運行結果：</p><p>父類: speaking方法被調用 子類: speaking方法被調用 父類: speaking方法被調用</p><p><strong>② 子類中可以增加自己特有的方法</strong></p><p>這句話理解起來很簡單，直接看代碼</p><p>父類 Father</p><pre><code>public class Father {    public void speaking(String content){        System.out.println("父類: " + content);    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>子類 Son</p><pre><code>public class Son extends Father {    public void playGuitar () {        System.out.println("這是Son類playGuitar方法");    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>測試類 Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 直接調用父類運行的結果        Father father = new Father();        father.speaking("speaking方法被調用");        // Son子類替換父類運行的結果        Son son = new Son();        son.speaking("speaking方法被調用");        son.playGuitar();    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>運行結果：</p><p>父類: speaking方法被調用 父類: speaking方法被調用 這是Son類playGuitar方法</p><p><strong>③ 當子類的方法重載父類的方法時，子類方法的前置條件（即方法的輸入參數）要比父類的方法更寬鬆</strong></p><p>這裡要注意，我們說的是<strong>重載</strong>，可不是重寫，下面我們按照里氏替換原則要求的，將父類方法參數範圍設小一點 (ArrayList) ，將子類同名方法參數範圍寫大一些 (List) ，測試後的結果，就是隻會執行父類的方法，不執行父類重載後的方法（注：參數名雖然相同，但是類型不同，還是重載，不是重寫）</p><p>父類 Father</p><pre><code>public class Father {    public void speaking(ArrayList arrayList) {        System.out.println("父類: " + arrayList.get(0));    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>子類 Son</p><pre><code>public class Son extends Father {    public void speaking(List list) {        System.out.println("子類: " + list.get(0));    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>測試類 Test</p><pre><code>public class Test {    public static void main(String[] args) {        ArrayList arrayList = new ArrayList();        arrayList.add("speaking方法被調用");        // 直接調用父類運行的結果        Father father = new Father();        father.speaking(arrayList);        // Son子類替換父類運行的結果        Son son = new Son();        son.speaking(arrayList);    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>運行結果：</p><p>父類: speaking方法被調用 父類: speaking方法被調用</p><p>如果我們將範圍顛倒一下，將父類方法參數範圍設大一些，子類方法參數設小一些，就會發現我明明想做的是重載方法，而不是重寫，但是父類的方法卻被執行了，邏輯完全出錯了，所以這也是這一條的反例，並不滿足里氏替換原則</p><p>父類 Father</p><pre><code>public class Father {    public void speaking(List list) {        System.out.println("父類: " + list.get(0));    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>子類 Son</p><pre><code>public class Son extends Father {    public void speaking(ArrayList arrayList) {        System.out.println("子類: " + arrayList.get(0));    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>測試類 Test</p><pre><code>public class Test {    public static void main(String[] args) {        ArrayList arrayList = new ArrayList();        arrayList.add("speaking方法被調用");        // 直接調用父類運行的結果        Father father = new Father();        father.speaking(arrayList);        // Son子類替換父類運行的結果        Son son = new Son();        son.speaking(arrayList);    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>運行結果：</p><p>父類: speaking方法被調用 子類: speaking方法被調用</p><p><strong>④ 當子類的方法實現父類的方法時（重寫/重載或實現抽象方法），方法的後置條件（即方法的的輸出/返回值）要比父類的方法更嚴格或相等</strong></p><p>父類中定義一個抽象方法，返回值類型是 List，子類中重寫這個方法，返回值類型可以為 List，也可以更精確或更嚴格，例如 ArrayList</p><p>父類 Father</p><pre><code>public abstract class Father {    public abstract List speaking();}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>子類 Son</p><pre><code>public class Son extends Father {    @Override    public ArrayList speaking() {        ArrayList arrayList = new ArrayList();        arrayList.add("speaking方法被調用");        return arrayList;    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>測試類 Test</p><pre><code>public class Test {    public static void main(String[] args) {        Father father = new Son();        System.out.println(father.speaking().get(0));    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>運行結果：</p><p>speaking方法被調用</p><p>但是，如果反過來，將父類抽象方法返回值定義為範圍較小的 ArrayList，將子類重寫方法中，反而將返回值類型方法，設置為 List，那麼程序在編寫的時候就會報錯</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/122595e8704a4d239683b5e9c1974247><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(2) 修正違背里氏替換原則的代碼</h1><p>現在網上幾種比較經典的反例，“幾維鳥不是鳥”，“鯨魚不是魚” 等等</p><p>我打個比方，如果按照慣性和字面意思，如果我們將幾維鳥也繼承鳥類</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/66ba98a7481e48779080847dee31dec7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>但是幾維鳥是不能飛行的，所別的鳥通過 setSpeed 方法都能附一個有效的值，但是幾維鳥就不得不重寫這個 setSpeed 方法，讓其設置 flySpeed 為 0，這樣已經違反了里氏替換原則</p><p>面對子類如果不能完整的實現父類的方法，或者父類的方法已經在子類中發生了“異變”，就例如這裡幾維鳥特殊的 setSpeed 方法，則一般選擇斷開父類和子類的繼承關係，重新設計關係</p><p>例如：</p><p>取消鳥和幾維鳥的繼承關係，定義鳥和幾維鳥更一般的父類，動物類</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/984abf74bf3a482e893cca9013ad4a01><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>(三) 依賴倒置</h1><p><strong>定義：</strong></p><ul><li><strong>① 高層模塊不應該依賴低層模塊，兩者都應該依賴其抽象</strong></li><li><strong>② 抽象不應該依賴細節，細節應該依賴抽象</strong></li></ul><p>先解釋第 ① 點，其實這一點在我們以往的分層開發中，就已經用過了，例如我們的業務層 Service（高層模塊）就沒有依賴數據訪問層 Dao/Mapper（低層模塊），我們都通過 Mapper 的接口進行訪問，這種情況下，如果數據訪問層的細節發生了變化，那麼也不會影響到業務層，但是如果直接依賴於實現，那麼就會影響巨大</p><p>第 ② 點，還是在討論要進行抽象的問題，抽象是高層，具體細節是底層，這和前一點也是契合的，正式說明了一條非常關鍵的原則 “面向接口編程，而非針對現實編程”</p><p>舉個例子</p><p>例如一個 Client 客戶想訪問學校的 readBook 方法，可以這麼寫</p><pre><code>public class Client {    public void read(ASchool aSchool){        System.out.println(aSchool.readBook());    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>但是，這個地方其實就出現了一個比較大的問題，我們就是直接依賴了具體，而不是抽象，當我們想要查看另一個B學校的 readBook 方法，就需要將代碼修改為</p><pre><code>public class Client {    public void read(BSchool bSchool){        System.out.println(bSchool.readBook());    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>但是開閉原則規定，對修改關閉，所以明顯違背了開閉原則，如果我們將代碼抽象出來，以接口訪問就可以解決</p><p>定義學校接口 ISchool （I 是大寫的 i 只是命名習慣問題，無特殊意義）</p><pre><code>public interface ISchool {    String readBook();}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>學校 A 和 B 分別實現這個接口，然後實現接口方法</p><pre><code>public class ASchool implements ISchool {    @Override    public String readBook() {        return "閱讀《Java 編程思想》";    }}public class BSchool implements ISchool {    @Override    public String readBook() {        return "閱讀《代碼整潔之道》";    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>Client 客戶類，調用時，只需要傳入接口參數即可</p><pre><code>public class Client {    public void read(ISchool school){        System.out.println(school.readBook());    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>看一下測試類</p><pre><code>public class Test {    public static void main(String[] args) {        Client client = new Client();        client.read(new ASchool());        client.read(new BSchool());    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>運行結果</p><p>閱讀《Java 編程思想》 閱讀《代碼整潔之道》</p><h1 class=pgc-h-arrow-right>(四) 單一職責原則</h1><p><strong>定義：單一職責原則規定一個類應該有且僅有一個引起它變化的原因，否則類應該被拆分</strong></p><p>一個類，並不應該承擔太多的責任，否則當為了引入類中的 A 職責的時候，就不得不把 B 職責 也引入，所以我們必須滿足其高內聚以及細粒度</p><p>優點：</p><ul><li>降低類的複雜度。一個類只負責一項職責，其邏輯肯定要比負責多項職責簡單得多。</li><li>提高類的可讀性。複雜性降低，自然其可讀性會提高。</li><li>提高系統的可維護性。可讀性提高，那自然更容易維護了。</li><li>變更引起的風險降低。變更是必然的，如果單一職責原則遵守得好，當修改一個功能時，可以顯著降低對其他功能的影響。</li></ul><p>就比如大學老師，負責很多很多工作，但是不管是輔導員，授課老師，行政老師，雖然都可以統稱為老師，但是將大量的內容和職責放到一個類中，顯然是不合理的，不如細分開來</p><p>例如：</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2106e161c6f4ad888368c7a820f6016><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>補充：大家可能看過 “羊呼吸空氣，魚呼吸水” 的例子，這裡我不做演示，做一個說明，有時候，在類簡單的情況下，也可以在代碼或者方法級別上違背單一職責原則，因為即使一定的修改有一定開銷，但是幾乎可以忽略不計了，不過一般情況，我們還是要遵循單一職責原則</p><h1 class=pgc-h-arrow-right>(五) 接口隔離原則</h1><p><strong>定義：</strong></p><ul><li><strong>客戶端不應該被迫依賴於它不使用的方法</strong></li><li><strong>或者——客戶端不應該被迫依賴於它不使用的方法</strong></li></ul><p>其實這一原則的核心就是 “拆” ，如果在一個接口內存放過多的方法等內容，就會十分臃腫，竟可能的細化接口，也就是為每個類創建專用接口，畢竟依賴多個專用接口，比依賴一個綜合接口更加靈活方便，同時，接口作為對外的一個 “入口”，拆散，隔離接口能夠縮小外來因素導致的問題擴散範圍</p><p>還是通過一個例子來展開：</p><p>現在有一個 “好學生的接口和實現類”，還有一個老師的抽象類和其子類，老師能做的，就是去找到好的學生</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/932a69ca8e8c4cacb8ade9ab666f4cd7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>好學生 IGoodStudent 接口</p><pre><code>public interface IGoodStudent {    //學習成績優秀    void goodGrades();    //品德優秀    void goodMoralCharacter();    //良好形象    void goodLooks();}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>好學生 IGoodStudent 接口的實現類 GoodStudentImpl</p><pre><code>public class GoodStudentImpl implements IGoodStudent {    private String name;    public GoodStudentImpl(String  name) {        this.name = name;    }    @Override    public void goodGrades() {        System.out.println("【" +this.name + "】的學習成績優秀");    }    @Override    public void goodMoralCharacter() {        System.out.println("【" +this.name + "】的品德優良");    }    @Override    public void goodLooks() {        System.out.println("【" +this.name + "】的形象良好");    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>老師抽象類 AbstractTeacher</p><pre><code>public abstract class AbstractTeacher {    protected IGoodStudent goodStudent;    public AbstractTeacher(IGoodStudent goodStudent) {        this.goodStudent = goodStudent;    }    public abstract void findGoodStudent();}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>老師類 Teacher</p><pre><code>public class Teacher extends AbstractTeacher {    public Teacher(IGoodStudent goodStudent) {        super(goodStudent);    }    @Override    public void findGoodStudent() {        super.goodStudent.goodGrades();        super.goodStudent.goodMoralCharacter();        super.goodStudent.goodLooks();    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>測試類 Test</p><pre><code>public class Test {    public static void main(String[] args) {        IGoodStudent goodStudent = new GoodStudentImpl("阿文");        AbstractTeacher teacher = new Teacher(goodStudent);        teacher.findGoodStudent();    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>運行結果：</p><p>【阿文】的學習成績優秀 【阿文】的品德優良 【阿文】的形象良好</p><p>一下子看來是沒什麼問題的，不過由於每個人的主觀意識形態不同，或許每個人對於 “好學生” 的定義並不同，就例如就我個人而言，我認識為 “師者，傳道授業解惑也” ，學生能學習其為人處世的道理與主動學習更是難能可貴，至於外貌更屬於無稽之談。針對不同人的不同不同定義，這個 IGoodStudent 接口就顯得有一些龐大且不合時宜了，所以我們根據接口隔離原則，將 “好學生” 的定義進行一定的拆分隔離</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e6a01f84ef844cab8cfe9e34556f7974><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>學習的學生接口</p><pre><code>public interface IGoodGradesStudent {    //學習成績優秀    void goodGrades();}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>品德優秀的學生接口</p><pre><code>public interface IGoodMoralCharacterStudent {    //品德優秀    void goodMoralCharacter();}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>好學生實現多個接口</p><pre><code>public class GoodStudent implements IGoodGradesStudent,IGoodMoralCharacterStudent {    private String name;    public GoodStudent(String name) {        this.name = name;    }    @Override    public void goodGrades() {        System.out.println("【" +this.name + "】的學習成績優秀");    }    @Override    public void goodMoralCharacter() {        System.out.println("【" +this.name + "】的品德優良");    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>(六) 迪米特法則</h1><p><strong>定義：如果兩個類不必要彼此直接通訊，那麼這兩個類就不應當發生直接的相互作用，如果其中一個類需要調用另一個類的某一個方法的話，可以通過第三者轉發這個調用</strong></p><p>這句話的意思就是說，一個類對自己依賴的類知道越少越好，也就是每一個類都應該降低成員的訪問權限，就像封裝的概念中提到的，通過 private 隱藏自己的字段或者行為細節</p><p>迪米特法則中的“朋友”是指：<strong>當前對象本身、當前對象的成員對象、當前對象所創建的對象、當前對象的方法參數等</strong>，<strong>這些對象</strong>同<strong>當前對象</strong>存在<strong>關聯、聚合或組合關係</strong>，可以直接訪問這些對象的方法</p><p>注意：請不要過分的使用迪米特法則，因為其會產生過多的中間類，會導致系統複雜性增大，結構不夠清晰</p><p>下面還是用一個例子來說一下</p><p>假設在學校的一個環境中，校長作為最高的職務所有人，肯定不會直接參與到對於老師和學生的管理中，而是通過一層一層的管理體系來進行統籌規劃，這裡的校長，和老師學生之間就可以理解為陌生關係，而校長和中層的教務主任卻是朋友關係，畢竟教務主任數量少，也可以直接進行溝通</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf4a179e915b4eecaf3a93c0af6ceaf8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>教務主任類 AcademicDirector</p><pre><code>public class AcademicDirector {    private Principal principal;    private Teacher teacher;    private Student student;    public void setPrincipal(Principal principal) {        this.principal = principal;    }    public void setTeacher(Teacher teacher) {        this.teacher = teacher;    }    public void setStudent(Student student) {        this.student = student;    }    public void meetTeacher() {        System.out.println(teacher.getName() + "通過教務主任向" + principal.getName() + "彙報工作");    }    public void meetStudents() {        System.out.println(student.getName() + "通過教務主任與" + principal.getName() + "見面");    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>校長類 Principal</p><pre><code>public class Principal {    private String name;    Principal(String name) {        this.name = name;    }    public String getName() {        return name;    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>老師類 Teacher</p><pre><code>public class Teacher {    private String name;    Teacher(String name) {        this.name = name;    }    public String getName() {        return name;    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>學生類 Student</p><pre><code>public class Student {    private String name;    Student(String name) {        this.name = name;    }    public String getName() {        return name;    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>測試類 Test</p><pre><code>public class Test {    public static void main(String[] args) {        AcademicDirector a = new AcademicDirector();        a.setPrincipal(new Principal("【張校長】"));        a.setTeacher(new Teacher("【王老師】"));        a.setStudent(new Student("【阿文】"));        a.meetTeacher();        a.meetStudents();    }}複製代碼</code></pre><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>補充：迪米特法則在《程序員修煉之道》一書中也有提及到 —— 26 解耦與得墨忒耳法則</p><blockquote><p>函數的得墨忒耳法則試圖使任何給定程序中的模塊之間的耦合減至最少，它設法阻止你為了獲得對第三個對象的方法的訪問而進入某個對象。</p><p>通過使用函數的得墨忒耳法則來解耦 編寫“羞怯”的代碼，我們可以實現我們的目標：</p><p>Minimize Coupling Between Modules</p><p>使模塊之間的耦合減至最少</p></blockquote><h1 class=pgc-h-arrow-right>(七) 合成複用原則</h1><p><strong>定義：在軟件複用時，要儘量先使用組合或者聚合等關聯關係來實現，其次才考慮使用繼承關係來實現</strong></p><p>這一點和里氏替換原則的目的是一致的，都是處理關於繼承的內容，本質都是實現了開閉原則的具體規範</p><p><strong>為什麼用組合/聚合，不用繼承</strong></p><ul><li>繼承破壞了類的封裝性，因為父類對於子類是透明的，而組合/聚合則不會</li><li>繼承父子類之間之間的耦合度比組合/聚合新舊類高</li><li>從父類繼承來的實現是靜態的，運行時不會發生變化，而組合/聚合的複用靈活性高，複用可在運行時動態進行</li></ul><p>如果代碼違背了里氏替換原則，彌補的方式，一個就是我們前面說的，加入一個更普通的抽象超類，一個就是取消繼承，修改為組合/聚合關係</p><p>我們簡單回憶一下</p><ul><li>繼承我們一般都叫做 Is-a 的關係，即一個類是另一個類的一種，比如，狗是一種動物</li><li>組合/聚合都叫做 Has-a，即一個角色擁有一項責任或者說特性</li></ul><p>例如我們來討論一下常見的特殊自行車（即變速自行車），首先按照類型可以分為 山地自行車和公路自行車，按照速度搭配又可以分為 21速自行車 ，24速自行車，27速自行車（簡單分）</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90b4dc3676ba4645a884b1c6aaebca55><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><p>XX速山地自行/公路車，雖然說我們口頭上可能會這麼叫，但是其實這就是將速度這種 Has- a 的關係和 Is-a 的關係搞混了，而且如果通過繼承，會帶來很多的子類，一旦想要增加修改變速自行車種類以及速度類型，就需要修改源代碼，違背了開閉原則，所以修改為組合關係</p><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/47177de2ab5c494786934f54a223336c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=概述、耦合、UML、七大原則，詳細分析總結（基於Java） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60999407096644f88157b9b8d509a5f4><p class=pgc-img-caption></p></div><p>​</p><h1 class=pgc-h-arrow-right>五 結尾</h1><p>這篇文章寫到這裡就結束了，又是一篇 接近1W 字的內容，學習到一定階段，確實會有一些瓶頸，經過對於類似設計模式等 “內功” 的學習，也突然發現開發真不是 CRUD 的不斷重複，一段有質量的代碼，更能讓人有成就感，後面對於常見的設計模式我會一直更新下去，一邊學習，一邊總結，感謝大家的支持。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>UML</a></li><li><a>原則</a></li><li><a>詳細</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html alt=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/decf8edb02a34404b92b86681378575f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html title=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html alt=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcdae811e636496d948cf5a745f470fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html title=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e145517c.html alt=詳細解析變壓器如何接地？接地的主要作用是什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ab7c98a3-daad-418d-8b72-e584bca53b42 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e145517c.html title=詳細解析變壓器如何接地？接地的主要作用是什麼？>詳細解析變壓器如何接地？接地的主要作用是什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c36f4ae6.html alt=手推公式：LSTM單元梯度的詳細的數學推導 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68dcd30ac0c0469a9bb85ea2bc9f3e8c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c36f4ae6.html title=手推公式：LSTM單元梯度的詳細的數學推導>手推公式：LSTM單元梯度的詳細的數學推導</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab2d9a76.html alt=齒輪的前世今生，你瞭解齒輪嗎，詳細講解齒輪乾貨知識大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8efc9a2a67ca4b86816d4ccc86ebeddb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab2d9a76.html title=齒輪的前世今生，你瞭解齒輪嗎，詳細講解齒輪乾貨知識大全>齒輪的前世今生，你瞭解齒輪嗎，詳細講解齒輪乾貨知識大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html alt=SpringBoot事務詳細簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html title=SpringBoot事務詳細簡介>SpringBoot事務詳細簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f75e8bc.html alt=小米CC9詳細配置曝光，除一億像素外還有這些 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/945b634aba484be4b4695eb29ee43be4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f75e8bc.html title=小米CC9詳細配置曝光，除一億像素外還有這些>小米CC9詳細配置曝光，除一億像素外還有這些</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e71fb88c.html alt=和麵、揉麵技巧，視頻詳細講解，10年和麵經驗，全部告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8cd49cb368f1488b8c4a65a3fe556d75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e71fb88c.html title=和麵、揉麵技巧，視頻詳細講解，10年和麵經驗，全部告訴你>和麵、揉麵技巧，視頻詳細講解，10年和麵經驗，全部告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7023d76f.html alt=鋼筋錨固的原則及鋼筋長度計算方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7023d76f.html title=鋼筋錨固的原則及鋼筋長度計算方法>鋼筋錨固的原則及鋼筋長度計算方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a4050af4.html alt=磚牆用磚數量最詳細的計算方法，趕緊收了吧！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15389175813757a3d0f3b61 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a4050af4.html title=磚牆用磚數量最詳細的計算方法，趕緊收了吧！>磚牆用磚數量最詳細的計算方法，趕緊收了吧！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc93b8c.html alt=詳細圖解地球自轉與公轉的黃赤交角如何形成四季更換 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6acd8115d8fe4cf1b1b1bbce7e353cea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc93b8c.html title=詳細圖解地球自轉與公轉的黃赤交角如何形成四季更換>詳細圖解地球自轉與公轉的黃赤交角如何形成四季更換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d8e2c56.html alt=賣出的幾點原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/acee4b45011c471a878255ab10841626 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d8e2c56.html title=賣出的幾點原則>賣出的幾點原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e267ed8.html alt=賣出股票的基本原則，不看吃虧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0490a95690454aa19f895ec6f90a741a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e267ed8.html title=賣出股票的基本原則，不看吃虧>賣出股票的基本原則，不看吃虧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5ca7a848.html alt="質量管理程序文件的編制原則及要點 趕快收藏，可作為培訓使用！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/83100777e6a0411589cbbdb6f31aaed4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5ca7a848.html title="質量管理程序文件的編制原則及要點 趕快收藏，可作為培訓使用！">質量管理程序文件的編制原則及要點 趕快收藏，可作為培訓使用！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c21f6c7.html alt=開關站、配電室工程詳細講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/aafe3cdc82ec496a9a5feb3ed29355b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c21f6c7.html title=開關站、配電室工程詳細講解>開關站、配電室工程詳細講解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>