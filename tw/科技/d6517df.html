<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JDK容器學習之HashMap（二）：讀寫邏輯詳解 | 极客快訊</title><meta property="og:title" content="JDK容器學習之HashMap（二）：讀寫邏輯詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/3f240002ded777fce419"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6517df.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><meta property="article:published_time" content="2020-10-29T20:58:37+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:37+08:00"><meta name=Keywords content><meta name=description content="JDK容器學習之HashMap（二）：讀寫邏輯詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d6517df.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JDK容器學習之HashMap（二）：讀寫邏輯詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>jdk map學習之HashMap (二) ： 讀寫邏輯詳解</strong></h1><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f240002ded777fce419></p><h1><strong>Map讀寫實現邏輯說明</strong></h1><blockquote><p>前一篇博文<a href=http://www.toutiao.com/i6475452022651879950/>JDK容器學習之HashMap (一) ： 底層存儲結構分析</a>分析了HashMap的底層存儲數據結構通過 put(k,v) 方法的分析，說明了為什麼Map底層用數組進行存儲，為什麼 Node 內部有一個 next 節點，這篇則將集中在讀寫方法的具體實現上</p></blockquote><p><strong>本片博文將關注的重點：</strong></p><p>- 通過key獲取 value的實現邏輯</p><p>- 新增一個kv對的實現邏輯</p><p>- table 數組如何自動擴容</p><p>- 如何刪除一個kv對（刪除kv對之後，數組長度是否會縮水 ？）</p><hr><h1>1. 根據key索引</h1><blockquote><p>get(key) 作為map最常用的方法之一，根據key獲取映射表中的value，通常時間複雜度為 o(1)<br></p></blockquote><p>在分析之前，有必要再把 HashMap 的數據結構撈出來看一下</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f260000bd5bb9e35240></p><p>根據上面的結構，如果讓我們自己來實現這個功能，對應的邏輯應該如下：</p><ul class=list-paddingleft-2><li><p>計算key的hash值</p></li><li><p>根據hash確定在 table 數組中的位置</p></li><li><p>判斷數組的Node對象中key是否等同與傳入的key</p></li><li><p>若不是，則一次掃描 next節點的key，直到找到為止</p></li></ul><p>jdk實現如下</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3ecf00040dff296844ef></p><p>上面的邏輯算是比較清晰，再簡單的劃一下重點</p><p>1. 通過key定位table數組中索引的具體邏輯</p><ul class=list-paddingleft-2><li><p>hash(key) & (table.length - 1)</p></li><li><p>key的hash值與(數組長度-1)進行按位與，計算得到下標</p></li></ul><p>2. 判斷Node是否為所查找的目標邏輯</p><ul class=list-paddingleft-2><li><p>node.hash == hash(key) && (node.key == key || (key!=null && key.equals(node.key))</p></li><li><p>首先是hash值必須相等</p></li><li><p>然後是 == or equals</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>== 表示key為同一個對象</p></li><li><p>equals 表示Node的key等價於傳入的key</p></li></ul></ul><p>3. TreeNode 是個什麼鬼</p><blockquote><p>上面的邏輯中，當出現hash碰撞時，會判斷數組中的Node對象是否為TreeNode，如果是則調用TreeNode.getTreeNode(hash,key)方法</p></blockquote><p><strong>那麼這個TreeNode有什麼特殊的地方呢？</strong></p><hr><h1>2.TreeNode分析</h1><blockquote><p>TreeNode依然是HashMap的內部類, 不同於Node的是，它繼承自LinkedHashMap.Entry，相比較與Node對象而言，多了兩個屬性before, after</p></blockquote><p>1. 數據結構</p><p>TreeNode對象中，包含的數據如下（將父類中的字段都集中在下面了）</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f240003eb0929bc1255></p><p>2. 內部方法</p><p>方法比較多，實現也不少，但是看看方法名以及註釋，很容易猜到這是個什麼東西了</p><p><strong>紅黑樹</strong></p><p>具體方法實現身略（對紅黑樹實現有興趣的，就可以到這裡來膜拜教科書的實現方式）</p><p>3. TreeNode 方式的HashMap存儲結構</p><p>普通的Node就是一個單向鏈表，因此HashMap的結構就是上面哪種</p><p>TreeNode是一顆紅黑樹的結構，所以對上面的圖走一下簡單的改造，將單向鏈表改成紅黑樹即可</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/3ed00002d7dc408bc288></p><hr><h1>3. 添加kv對</h1><p>博文 《JDK容器學習之HashMap (一) ： 底層存儲結構分析 》對於添加kv對的邏輯進行了說明，因此這裡將主要集中在數組的擴容上</p><p>擴容的條件：<strong>默認擴容加載因子為(0.75)，臨界點在當HashMap中元素的數量等於table數組長度*加載因子,長度擴為原來的2倍</strong></p><p>數組擴容方法, 實現比較複雜，先擼一把代碼，並加上必要註釋</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f2400047103ddd5ed07></p><p>上面的邏輯主要劃分為兩塊</p><ul class=list-paddingleft-2><li><p>新的數組長度確定，並初始化新的數組</p></li><li><p>將原來的數據遷移到新的數組中</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>遍歷舊數組元素</p></li><li><p>若Node沒有尾節點(Next為null)，則直接塞入新的數組</p></li><li><p>判斷Node的數據結構，紅黑樹和鏈表邏輯有區分</p></li><li><p>對於鏈表格式，新的座標要麼是原來的位置，要麼是原來的位置+原數組長度，鏈表順序不變</p></li></ul></ul><p><strong>說明</strong></p><p>這個擴容的邏輯還是比較有意思的，最後面給一個測試case，來看一下擴容前後的數據位置</p><hr><h1>4. 刪除元素</h1><p>刪除的邏輯和上面的大致類似，顯示確定節點，然後從整個數據結構中移除引用</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3ed0000491b61b8c19af></p><hr><h1>測試</h1><p>上面的幾個常用方法的邏輯大致相同，核心都是在如何找到目標Node節點，其中比較有意思的一點是數組的擴容，舊元素的遷移邏輯，下面寫個測試demo來演示一下</p><p>首先定義一個Deom對象，覆蓋hashCode方法，確保第一次重新分配數組時，正好需要遷移</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3ece0002f5a9508da6fe></p><p>實際演示示意圖</p><p><img alt=JDK容器學習之HashMap（二）：讀寫邏輯詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3ece0002e411567a9cc2></p><hr><h1>小結</h1><p><strong>1. 根據Key定位Node節點</strong></p><ul class=list-paddingleft-2><li><p>key計算hash，hash值對數組長度取餘即為數組中的下標</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>即hash & (len - 1) === hash % len</p></li></ul></ul><ul class=list-paddingleft-2><li><p>以數組中Node為鏈表頭or紅黑樹根節點遍歷，確認目標節點</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>判斷邏輯：</p></li><li><p>hash值相同</p></li><li><p>key1 == key2 or key1.quals(key2)<br></p></li></ul></ul><ul class=list-paddingleft-2></ul><ul class=list-paddingleft-2></ul><p><strong>2. 擴容邏輯</strong></p><ul class=list-paddingleft-2><li><p>當添加元素後，數組的長度超過閥值，實現擴容</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>初始容量為16，閥值為12</p></li></ul></ul><ul class=list-paddingleft-2><li><p>計算新的數組長度，並初始化</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>新的長度為原來的長度 * 2</p></li><li><p>新的閥值為 新的長度 * loadFactor； loadFactory 一般為 0.75</p></li></ul></ul><ul class=list-paddingleft-2><li><p>將原來的數據遷移到新的數組</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>原位置不變 (hash % 原長度 == 0)</p></li><li><p>原位置 + 原數組長度 (hash % 原長度 == 1)<br></p></li></ul></ul><ul class=list-paddingleft-2></ul><ul class=list-paddingleft-2></ul><p><strong>3. 其他</strong></p><ul class=list-paddingleft-2><li><p>jdk1.8 之後，當鏈表長度超過閥值（8）後，轉為紅黑樹</p></li><li><p>新增元素，在添加完畢之後，再判斷是否需要擴容</p></li><li><p>刪除元素不會改變Node對象本身，只是將其從Map的數據結構中<strong>摘</strong>出來</p></li><li><p>Map如何退化為鏈表</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>一個糟糕的hashCode方法即可模擬實現，如我們上面的測試用例</p></li><li><p>紅黑樹會使這種退化的效果不至於變得那麼糟糕</p></li></ul></ul><hr><h1>相關博文</h1><ul class=list-paddingleft-2><li><p><a href=http://www.toutiao.com/i6475452022651879950/>JDK容器學習之HashMap（一）：底層存儲結構分析</a><br></p></li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JDK</a></li><li><a>學習</a></li><li><a>HashMap</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html alt=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13adbab9c7f94c7fa81d49a98861b051 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html title=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式>機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e214e6d7.html alt=深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1540372101455de0fb74774 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e214e6d7.html title=深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開>深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3767255.html alt=講透機器學習中的梯度下降 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5c80301e53424671bc22755be2e4ee33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3767255.html title=講透機器學習中的梯度下降>講透機器學習中的梯度下降</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac12f3a1.html alt=直流鍋爐給水控制學習 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/eba10edcc8d14d9f8cde6fd5b212d90e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac12f3a1.html title=直流鍋爐給水控制學習>直流鍋爐給水控制學習</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1bc38f3.html alt=HTMLCSS學習筆記（六）——元素類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb5988349894ce9bf568c6418f85b7d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1bc38f3.html title=HTMLCSS學習筆記（六）——元素類型>HTMLCSS學習筆記（六）——元素類型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html alt="web前端（從零開始），每天更新學習筆記 HTML5元素分類" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/46d70004fcd55e1ddad3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html title="web前端（從零開始），每天更新學習筆記 HTML5元素分類">web前端（從零開始），每天更新學習筆記 HTML5元素分類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html alt=深入學習MySQL事務：ACID特性的實現原理「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cdc702d66d6943499997d11e931425eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html title=深入學習MySQL事務：ACID特性的實現原理「轉」>深入學習MySQL事務：ACID特性的實現原理「轉」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6b2ef73.html alt=如何學習模擬IC設計？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6b2ef73.html title=如何學習模擬IC設計？>如何學習模擬IC設計？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c56ee116.html alt=小猿圈python學習-三大特性之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad0e8e3777854337abeb7c779ad79a04 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c56ee116.html title=小猿圈python學習-三大特性之多態>小猿圈python學習-三大特性之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03a295fc.html alt=地理學習5——地球的運動（地球的公轉及其地理意義） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b2b74c871eb40beb8ee143627d29611 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03a295fc.html title=地理學習5——地球的運動（地球的公轉及其地理意義）>地理學習5——地球的運動（地球的公轉及其地理意義）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebad378f.html alt=繼續學習打卡，還真心學不會了，努力，堅持 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f36d6d47a06840aaaf78138853b9d9d1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebad378f.html title=繼續學習打卡，還真心學不會了，努力，堅持>繼續學習打卡，還真心學不會了，努力，堅持</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce278cf4.html alt=機器學習時代的哈希算法，將如何更高效地索引數據 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1525617261534ad07c6455c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce278cf4.html title=機器學習時代的哈希算法，將如何更高效地索引數據>機器學習時代的哈希算法，將如何更高效地索引數據</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>