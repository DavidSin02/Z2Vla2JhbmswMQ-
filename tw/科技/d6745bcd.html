<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Map接口概述 | 极客快訊</title><meta property="og:title" content="Map接口概述 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/7e955e46020b4afc85b3d83a8cbd92ca"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="Map接口概述"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d6745bcd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Map接口概述</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1.1Map接口概述</strong></p><p>我們通過查看Map接口描述，發現Map接口下的集合與Collection接口下的集合，它們存儲數據的形式不同，如下圖。</p><ul><li>Collection中的集合，元素是孤立存在的（理解為單身），向集合中存儲元素採用一個個元素的方式存儲。</li><li>Map中的集合，元素是成對存在的(理解為夫妻)。每個元素由鍵與值兩部分組成，通過鍵可以找對所對應的值。</li><li>Collection中的集合稱為單列集合，Map中的集合稱為雙列集合。</li><li>需要注意的是，Map中的集合不能包含重複的鍵，值可以重複；每個鍵只能對應一個值。</li><li>Map中常用的集合為HashMap集合、LinkedHashMap集合。</li></ul><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7e955e46020b4afc85b3d83a8cbd92ca><p class=pgc-img-caption></p></div><p><strong>1.1Map接口中常用集合概述</strong></p><p>通過查看Map接口描述，看到Map有多個子類，這裡我們主要講解常用的HashMap集合、LinkedHashMap集合。</p><ul><li><strong>HashMap\</strong>：存儲數據採用的哈希表結構，元素的存取順序不能保證一致。由於要保證鍵的唯一、不重複，需要重寫鍵的hashCode()方法、equals()方法。</li><li><strong>LinkedHashMap\</strong>：HashMap下有個子類LinkedHashMap，存儲數據採用的哈希表結構+鏈表結構。通過鏈表結構可以保證元素的存取順序一致；通過哈希表結構可以保證的鍵的唯一、不重複，需要重寫鍵的hashCode()方法、equals()方法。</li><li><strong>注意</strong>：Map接口中的集合都有兩個泛型變量\,在使用時，要為兩個泛型變量賦予數據類型。兩個泛型變量\的數據類型可以相同，也可以不同。</li></ul><p><strong>1.1Map接口中的常用方法</strong></p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e2b98c721323458e9a8c3c210991aecd><p class=pgc-img-caption></p></div><ul><li>put方法：將指定的鍵與值對應起來，並添加到集合中方法返回值為鍵所對應的值</li></ul><blockquote><p>使用put方法時，若指定的鍵(key)在集合中沒有，則沒有這個鍵對應的值，返回null，並把指定的鍵值添加到集合中；</p><p>使用put方法時，若指定的鍵(key)在集合中存在，則返回值為集合中鍵對應的值（該值為替換前的值），並把指定鍵所對應的值，替換成指定的新值。</p></blockquote><ul><li>get方法：獲取指定鍵(key)所對應的值(value)</li><li>remove方法：根據指定的鍵(key)刪除元素，返回被刪除元素的值(value)。</li></ul><blockquote><p>Map接口的方法演示</p></blockquote><p><strong>public class</strong> MapDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//創建Map對象</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//給map中添加元素</p><p>map.put("星期一", "Monday");</p><p>map.put("星期日", "Sunday");</p><p>System.out.println(map); // {星期日=Sunday, 星期一=Monday}</p><p>//當給Map中添加元素，會返回key對應的原來的value值，若key沒有對應的值，返回null</p><p>System.out.println(map.put("星期一", "Mon")); // Monday</p><p>System.out.println(map); // {星期日=Sunday, 星期一=Mon}</p><p>//根據指定的key獲取對應的value</p><p>String en = map.get("星期日");</p><p>System.out.println(en); // Sunday</p><p>//根據key刪除元素,會返回key對應的value值</p><p>String value = map.remove("星期日");</p><p>System.out.println(value); // Sunday</p><p>System.out.println(map); // {星期一=Mon}</p><p>}</p><p>}</p><p><strong>1.1Map集合遍歷鍵找值方式</strong></p><blockquote><p>鍵找值方式：即通過元素中的鍵，獲取鍵所對應的值</p><p>操作步驟與圖解：</p><p>1.獲取Map集合中所有的鍵，由於鍵是唯一的，所以返回一個Set集合存儲所有的鍵</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddd9c098c2c742eaad76ae0a19ba47f8><p class=pgc-img-caption></p></div><blockquote><p>2.遍歷鍵的Set集合，得到每一個鍵</p><p>3.根據鍵，獲取鍵所對應的值</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fd3eb988565b40adb922b962d3140d3a><p class=pgc-img-caption></p></div><p>代碼演示：</p><p><strong>public class</strong> MapDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//創建Map對象</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//給map中添加元素</p><p>map.put("鄧超", "孫儷");</p><p>map.put("李晨", "范冰冰");</p><p>map.put("劉德華", "柳巖");</p><p>//獲取Map中的所有key</p><p>Set\ keySet = map.keySet();</p><p>//遍歷存放所有key的Set集合</p><p>Iterator\ it =keySet.iterator();</p><p><strong>while</strong>(it.hasNext()){</p><p>//得到每一個key</p><p>String key = it.next();</p><p>//通過key獲取對應的value</p><p>String value = map.get(key);</p><p>System.out.println(key+"="+value);</p><p>}</p><p>}</p><p>}</p><p><strong>1.1Entry鍵值對對象</strong></p><p>在Map類設計時，提供了一個嵌套接口：Entry。Entry將鍵值對的對應關係封裝成了對象。即鍵值對對象，這樣我們在遍歷Map集合時，就可以從每一個鍵值對（Entry）對象中獲取對應的鍵與對應的值。</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c5849e5713de40adb8d8179f5abce6b6><p class=pgc-img-caption></p></div><ul><li>Entry是Map接口中提供的一個靜態內部嵌套接口。</li></ul><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b96bd7f318f49afb293ecf4eee15cd4><p class=pgc-img-caption></p></div><ul><li>getKey()方法：獲取Entry對象中的鍵</li><li>getValue()方法：獲取Entry對象中的值</li></ul><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0f060a694fa4695bc0a6308083fae3d><p class=pgc-img-caption></p></div><ul><li>entrySet()方法：用於返回Map集合中所有的鍵值對(Entry)對象，以Set集合形式返回。</li></ul><p><strong>1.1Map集合遍歷鍵值對方式</strong></p><blockquote><p>鍵值對方式：即通過集合中每個鍵值對(Entry)對象，獲取鍵值對(Entry)對象中的鍵與值。</p><p>操作步驟與圖解：</p></blockquote><p>1.獲取Map集合中，所有的鍵值對(Entry)對象，以Set集合形式返回。</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ca91ae086c1476c871ce101bb184a96><p class=pgc-img-caption></p></div><p>2.遍歷包含鍵值對(Entry)對象的Set集合，得到每一個鍵值對(Entry)對象</p><p>3.通過鍵值對(Entry)對象，獲取Entry對象中的鍵與值。</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/855123c7b70c4246a10c547ab09c3e6e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5658ecb863f5434e81c6fe004cf5a07c><p class=pgc-img-caption></p></div><p><strong>public class</strong> MapDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//創建Map對象</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//給map中添加元素</p><p>map.put("鄧超", "孫儷");</p><p>map.put("李晨", "范冰冰");</p><p>map.put("劉德華", "柳巖");</p><p>//獲取Map中的所有key與value的對應關係</p><p>Set\> entrySet = map.entrySet();</p><p>//遍歷Set集合</p><p>Iterator\> it =entrySet.iterator();</p><p><strong>while</strong>(it.hasNext()){</p><p>//得到每一對對應關係</p><p>Map.Entry\ entry = it.next();</p><p>//通過每一對對應關係獲取對應的key</p><p>String key = entry.getKey();</p><p>//通過每一對對應關係獲取對應的value</p><p>String value = entry.getValue();</p><p>System.out.println(key+"="+value);</p><p>}</p><p>}</p><p>}</p><p>注意：Map集合不能直接使用迭代器或者foreach進行遍歷。但是轉成Set之後就可以使用了。</p><p><strong>1.1HashMap存儲自定義類型鍵值</strong></p><p>練習：每位學生（姓名，年齡）都有自己的家庭住址。那麼，既然有對應關係，則將學生對象和家庭住址存儲到map集合中。學生作為鍵, 家庭住址作為值。</p><p>注意，學生姓名相同並且年齡相同視為同一名學生。</p><ul><li>學生類</li></ul><p><strong>public class</strong> Student {</p><p><strong>private</strong> String name;</p><p><strong>private int</strong> age;</p><p>//編寫構造方法，文檔中已省略</p><p>//編寫get,set方法，文檔中已省略</p><p>//編寫toString方法，文檔中已省略</p><p>}</p><ul><li>測試類</li></ul><p><strong>public class</strong> HashMapTest {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//1,創建hashmap集合對象。</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//2,添加元素。</p><p>map.put(<strong>new</strong> Student("lisi",28), "上海");</p><p>map.put(<strong>new</strong> Student("wangwu",22), "北京");</p><p>map.put(<strong>new</strong> Student("zhaoliu",24), "成都");</p><p>map.put(<strong>new</strong> Student("zhouqi",25), "廣州");</p><p>map.put(<strong>new</strong> Student("wangwu",22), "南京");</p><p>//3,取出元素。鍵找值方式</p><p>Set\ keySet = map.keySet();</p><p><strong>for</strong>(Student key : keySet){</p><p>String value = map.get(key);</p><p>System.out.println(key.toString()+"....."+value);</p><p>}</p><p>//取出元素。鍵值對方式</p><p>Set\> entrySet = map.entrySet();</p><p><strong>for</strong> (Map.Entry\ entry : entrySet) {</p><p>Student key = entry.getKey();</p><p>String value = entry.getValue();</p><p>System.out.println(key.toString()+"....."+value);</p><p>}</p><p>}</p><p>}</p><ul><li>當給HashMap中存放自定義對象時，如果自定義對象作為key存在，這時要保證對象唯一，必須複寫對象的hashCode和equals方法(如果忘記，請回顧HashSet存放自定義對象)。</li><li>如果要保證map中存放的key和取出的順序一致，可以使用LinkedHashMap集合來存放。</li></ul><p><strong>1.1靜態導入</strong></p><p>在導包的過程中我們可以直接導入靜態部分，這樣某個類的靜態成員就可以直接使用了。在源碼中經常會出現靜態導入。</p><blockquote><p>靜態導入格式：</p></blockquote><p>import static XXX.YYY; 導入後YYY可直接使用。</p><p>例如：Map.Entry的訪問，簡化後為Entry</p><p>import static java.util.Map.Entry;</p><p><strong>public class</strong> HashMapTest {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//1,創建hashmap集合對象。</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//取出元素。鍵值對方式</p><p>//Set\> entrySet = map.entrySet();</p><p>Set\> entrySet = map.entrySet();</p><p>//for (Map.Entry\ entry : entrySet) {</p><p><strong>for</strong> (Entry\ entry : entrySet) {</p><p>Student key = entry.getKey();</p><p>String value = entry.getValue();</p><p>System.out.println(key.toString()+"....."+value);</p><p>}</p><p>}</p><p>}</p><p><strong>1.1可變參數</strong></p><p>在JDK1.5之後，如果我們定義一個方法需要接受多個參數，並且多個參數類型一致，我們可以對其簡化成如下格式：</p><p>修飾符 返回值類型 方法名(參數類型<strong>...</strong> 形參名){ }</p><p>其實這個書寫完全等價與</p><p>修飾符 返回值類型 方法名(參數類型[] 形參名){ }</p><p>只是後面這種定義，在調用時必須傳遞數組，而前者可以直接傳遞數據即可。</p><p>jdk1.5以後。出現了簡化操作。<strong>...</strong> 用在參數上，稱之為可變參數。</p><p>同樣是代表數組，但是在調用這個帶有可變參數的方法時，不用創建數組(這就是簡單之處)，直接將數組中的元素作為實際參數進行傳遞，其實編譯成的class文件，將這些元素先封裝到一個數組中，在進行傳遞。這些動作都在編譯.class文件時，自動完成了。</p><p>代碼演示：</p><p><strong>public class</strong> ParamDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p><strong>int</strong>[] arr = {21,89,32};</p><p><strong>int</strong> sum = add(arr);</p><p>System.out.println(sum);</p><p>sum = add(21,89,32);//可變參數調用形式</p><p>System.out.println(sum);</p><p>}</p><p>//JDK1.5之後寫法</p><p><strong>public static int</strong> add(<strong>int</strong>...arr){</p><p><strong>int</strong> sum = 0;</p><p><strong>for</strong> (<strong>int</strong> i = 0; i \&lt; arr.length; i++) {</p><p>sum += arr[i];</p><p>}</p><p><strong>return</strong> sum;</p><p>}</p><p>//原始寫法</p><p>/*</p><p>public static int add(int[] arr) {</p><p>int sum = 0;</p><p>for (int i = 0; i \&lt; arr.length; i++) {</p><p>sum += arr[i];</p><p>}</p><p>return sum;</p><p>}</p><p>*/</p><p>}</p><ul><li>上述add方法在同一個類中，只能存在一個。因為會發生調用的不確定性</li></ul><p>注意：如果在方法書寫時，這個方法擁有多參數，參數中包含可變參數，可變參數一定要寫在參數列表的末尾位置。</p><p><strong>1.1Collections集合工具類</strong></p><p>Collections是集合工具類，用來對集合進行操作。部分方法如下：</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/45ff50b979f8440e856522141253908b><p class=pgc-img-caption></p></div><ul><li>public static \ void sort(List\ list) // 集合元素排序</li></ul><blockquote><p>//排序前元素list集合元素 [33,11,77,55]</p><p>Collections.sort( list );</p><p>//排序後元素list集合元素 [11,33,55,77]</p></blockquote><ul><li>public static void shuffle(List\&lt;?> list) // 集合元素存儲位置打亂</li></ul><blockquote><p>//list集合元素 [11,33,55,77]</p><p>Collections.shuffle( list );</p><p>//使用shuffle方法後，集合中的元素為[77,33,11,55]，每次執行該方法，集合中存儲的元素位置都會隨機打亂</p><p><strong>1.1集合嵌套</strong></p></blockquote><p>集合嵌套並不是一個新的知識點，僅僅是集合內容又是集合，如Collection集合嵌套、Collection集合與Map集合相互嵌套、Map集合嵌套。</p><ul><li>ArrayList嵌套 ArrayList</li></ul><p>ArrayList\&lt; ArrayList\ ></p><p>Collection\&lt; ArrayList\ ></p><ul><li>Map嵌套 ArrayList</li></ul><p>HashMap\></p><p>ArrayList\&lt; HashMap\></p><ul><li>Map集合嵌套</li></ul><p>HashMap\></p><p>HashMap\></p><p><strong>1.1集合繼承體系的面向對象思想</strong></p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c2fdd8606c2a4d37bad0268d97e1dd1c><p class=pgc-img-caption></p></div><ul><li>接口：用來明確所有集合中該具有的功能，相當於在定義集合功能標準；</li><li>抽象類：把多個集合中功能實現方式相同的方法，抽取到抽象類實現，具體集合不再遍寫，繼承使用即可；</li><li>具體類：繼承抽象類，實現接口，重寫所有抽象方法，達到具備指定功能的集合。每個具體集合類，根據自身的數據存儲結構方式，對接口中的功能方法，進行不同方式的實現。</li></ul><p><strong>第2章模擬鬥地主洗牌發牌</strong></p><p><strong>2.1案例介紹</strong></p><blockquote><p>按照鬥地主的規則，完成洗牌發牌的動作。</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dd627c4cff0743bb8298dc933eab5d16><p class=pgc-img-caption></p></div><blockquote><p>具體規則：</p><p>組裝54張撲克牌</p><p>將54張牌順序打亂</p><p>三個玩家參與遊戲，三人交替摸牌，每人17張牌，最後三張留作底牌。</p><p>查看三人各自手中的牌（按照牌的大小排序）、底牌</p></blockquote><ul><li>手中撲克牌從大到小的擺放順序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</li></ul><p><strong>2.1案例需求分析</strong></p><ul><li>準備牌：</li></ul><blockquote><p>完成數字與紙牌的映射關係：</p><p>使用雙列Map(HashMap)集合，完成一個數字與字符串紙牌的對應關係(相當於一個字典)。</p></blockquote><ul><li>洗牌：</li></ul><blockquote><p>通過數字完成洗牌發牌</p></blockquote><ul><li>發牌：</li></ul><blockquote><p>將每個人以及底牌設計為ArrayList\,將最後3張牌直接存放於底牌，剩餘牌通過對3取模依次發牌。</p><p>存放的過程中要求數字大小與鬥地主規則的大小對應。</p><p>將代表不同紙牌的數字分配給不同的玩家與底牌。</p></blockquote><ul><li>看牌：</li></ul><blockquote><p>通過Map集合找到對應字符展示。</p><p>通過查詢紙牌與數字的對應關係，由數字轉成紙牌字符串再進行展示。</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/18a34b7a85aa43809507702b8600a07d><p class=pgc-img-caption></p></div><p><strong>2.1實現代碼步驟</strong></p><p>首先，要修改java文件編碼，由GBK修改為UTF-8，因為默認的字符編碼GBK沒有我們要的梅花、方片、黑桃、紅桃(♠♥♦♣)等特殊字符。</p><p><strong>import</strong> java.util.ArrayList;</p><p><strong>import</strong> java.util.Collections;</p><p><strong>import</strong> java.util.HashMap;</p><p>/*</p><p>* 鬥地主洗牌發牌排序</p><p>*/</p><p><strong>public class</strong> Poker {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//準備花色</p><p>ArrayList\ color = <strong>new</strong> ArrayList\();</p><p>color.add("♠");</p><p>color.add("♥");</p><p>color.add("♦");</p><p>color.add("♣");</p><p>//準備數字</p><p>ArrayList\ number = <strong>new</strong> ArrayList\();</p><p>Collections.addAll(number,"3","4","5","6","7","8","9","10","J","Q","K","A","2");</p><p>//定義一個map集合：用來將數字與每一張牌進行對應</p><p>HashMap\ map = <strong>new</strong> HashMap\();</p><p><strong>int</strong> index = 0;</p><p><strong>for</strong> (String thisNumber : number) { //1-13</p><p><strong>for</strong> (String thisColor : color) { //1-4</p><p>map.put(index++, thisColor+thisNumber);</p><p>}</p><p>}</p><p>//加入大小王</p><p>map.put(index++, "小☺");</p><p>map.put(index++, "大☻");</p><p>//一副54張的牌 ArrayList裡邊為0-53的數的新牌</p><p>ArrayList\ cards = <strong>new</strong> ArrayList\();</p><p><strong>for</strong> (<strong>int</strong> i = 0; i \&lt;= 53; i++) {</p><p>cards.add(i);</p><p>}</p><p>//洗牌</p><p>Collections.shuffle(cards);</p><p>//創建三個玩家和底牌</p><p>ArrayList\ iPlayer = <strong>new</strong> ArrayList\();</p><p>ArrayList\ iPlayer2 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ iPlayer3 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ itCards = <strong>new</strong> ArrayList\();</p><p>//遍歷這副洗好的牌，遍歷過程中，將牌發到三個玩家和底牌中</p><p><strong>for</strong> (<strong>int</strong> i = 0; i \&lt; cards.size(); i++) {</p><p><strong>if</strong>(i>=51) {</p><p>iCards.add(cards.get(i));</p><p>} <strong>else</strong> {</p><p><strong>if</strong>(i%3==0) {</p><p>iPlayer.add(cards.get(i));</p><p>}<strong>else if</strong>(i%3==1) {</p><p>iPlayer2.add(cards.get(i));</p><p>}<strong>else</strong> {</p><p>iPlayer3.add(cards.get(i));</p><p>}</p><p>}</p><p>}</p><p>//對每個人手中的牌排序</p><p>Collections.sort(iPlayer);</p><p>Collections.sort(iPlayer2);</p><p>Collections.sort(iPlayer3);</p><p>//對應數字形式的每個人手中的牌，定義字符串形式的牌</p><p>ArrayList\ sPlayer = <strong>new</strong> ArrayList\();</p><p>ArrayList\ sPlayer2 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ sPlayer3 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ sCards = <strong>new</strong> ArrayList\();</p><p><strong>for</strong> (Integer key : iPlayer) {</p><p>sPlayer.add(map.get(key));</p><p>}</p><p><strong>for</strong> (Integer key : iPlayer2) {</p><p>sPlayer2.add(map.get(key));</p><p>}</p><p><strong>for</strong> (Integer key : iPlayer3) {</p><p>sPlayer3.add(map.get(key));</p><p>}</p><p><strong>for</strong> (Integer key : iCards) {</p><p>sCards.add(map.get(key));</p><p>}</p><p>//看牌</p><p>System.out.println(sPlayer);</p><p>System.out.println(sPlayer2);</p><p>System.out.println(sPlayer3);</p><p>System.out.println(sCards);</p><p>}</p><p>}</p><p><strong>第3章總結</strong></p><p><strong>3.1知識點總結</strong></p><p>3.HashMap和Hashtable有什麼區別？</p><p>HashMap和Hashtable都實現了Map接口，因此很多特性非常相似。但是，他們有以下不 同點：</p><p>HashMap允許鍵和值是null，而Hashtable不允許鍵或者值是null。</p><p>Hashtable是同步的，而HashMap不是。因此，HashMap更適合於單線程環境，而Hashtable 適合於多線程環境。</p><p>HashMap提供了可供應用迭代的鍵的集合，因此，HashMap是快速失敗的。另一方面， Hashtable提供了對鍵的列舉(Enumeration)。</p><p>一般認為Hashtable是一個遺留的類。</p><ul><li>Map集合:</li></ul><p>map集合中的元素都是成對出現，成對存儲的</p><p>map集合中的元素都是以一對鍵和值的形式組成存在的，稱為鍵值對，理解為夫妻對</p><p>map集合中的鍵不能重複存儲，值可以重複</p><p>map集合中的每一個鍵 對應著一個值</p><ul><li>方法：</li></ul><blockquote><p>V put(K key, V value) 把指定的鍵與指定的值添加到Map集合中</p><p>V remove(Object key) 把指定的鍵 所對應的鍵值對元素 在Map集合中刪除，返回被刪除元素的值</p><p>Set\> entrySet() 獲取到Map集合中所有的鍵值對對象的集合(Set集合)</p><p>V get(Object key) 根據指定的鍵，在Map集合中獲取對應的值</p><p>Set\ keySet() 獲取Map集合中所有的鍵，存儲到Set集合中</p></blockquote><ul><li>Map集合遍歷的兩種方式方式1：根據鍵找值的方式</li></ul><p>//a, 獲取到Map集合中所有的鍵，返回對應的Set集合</p><p>//b, 遍歷鍵的集合，獲取到每一個鍵</p><p>//c, 通過鍵，找到對應的值</p><p>//獲取到Map集合中所有的鍵，返回對應的Set集合</p><p>Set\ keys = map.keySet();</p><p>//遍歷鍵的集合，獲取到每一個鍵</p><p>for (String key : keys) {</p><p>//通過鍵，找到對應的值</p><p>Student s = map.get(key);</p><p>System.out.println( key + "..." + s.getName() + "..." + s.getAge() );</p><p>}</p><ul><li>方式2：根據鍵值對對象找鍵和值的方式</li></ul><p>//a, 獲取Map集合中所有的鍵值對元素,返回對應的Set集合</p><p>//b, 遍歷鍵值對元素集合，獲取到每一個鍵值對元素對象</p><p>//c, 通過鍵值對元素對象，獲取對應的鍵，和對應的值</p><p>//獲取Map集合中所有的鍵值對元素,返回對應的Set集合</p><p>Set\&lt; Map.Entry\> entrySet = map.entrySet();</p><p>//遍歷鍵值對元素集合，獲取到每一個鍵值對元素對象</p><p>for (Map.Entry\ entry : entrySet) {</p><p>//通過鍵值對元素對象，獲取對應的鍵，和對應的值</p><p>//找鍵</p><p>String key = entry.getKey();</p><p>//找值</p><p>Student s = entry.getValue();</p><p>//打印</p><p>System.out.println( key+"..."+s.getName()+"..."+s.getAge() );</p><p>}</p><ul><li>HashMap:特點：</li></ul><p>是Map集合的子集合</p><p>底層採用哈希表結構</p><p>HashMap集合中的key不能重複，通過重寫hashCode() 與 equals()方法來保證鍵的唯一。</p><p>不能保證元素存與取的順序完全一致</p><ul><li>LinkedHashMap:特點：</li></ul><blockquote><p>是HashMap集合的子集合</p><p>底層採用哈希表+鏈表結構</p><p>LinkedHashMap集合中的key不能重複，通過重寫hashCode() 與 equals()方法來保證鍵的唯一。</p></blockquote><ul><li>Collections中的方法：</li></ul><p>public static \ void sort(List\ list) 排序</p><p>public static void shuffle(List\&lt;?> list) 集合中的元素存儲位置隨機打亂</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Map</a></li><li><a>接口</a></li><li><a>概述</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/00145145.html alt=福建省“平潭縣”基本概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e272987dca8b435a8dc733a7d49ef2e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00145145.html title=福建省“平潭縣”基本概述>福建省“平潭縣”基本概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/61de4f95.html alt=蒙特卡羅方法概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/776e8b236f774a14841c556abaae8272 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/61de4f95.html title=蒙特卡羅方法概述>蒙特卡羅方法概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f4f341e.html alt=發電廠動力部分概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f4f341e.html title=發電廠動力部分概述>發電廠動力部分概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26fb9d6f.html alt=鍛造篇——鍛造工藝概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7f5fe4d41e864ae58c2100bde0e44e5c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26fb9d6f.html title=鍛造篇——鍛造工藝概述>鍛造篇——鍛造工藝概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7edb5d1d.html alt=中原官話概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ea60db8e7cf64d14990a3bec5583b024 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7edb5d1d.html title=中原官話概述>中原官話概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dedf2651.html alt=電機繞組概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dedf2651.html title=電機繞組概述>電機繞組概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/843991c7.html alt=液壓控制閥概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1521815441159b9a4824212 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/843991c7.html title=液壓控制閥概述>液壓控制閥概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30d461d9.html alt=換熱器原理與種類概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a79b8508df0d4a609402ffff2c3239b7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30d461d9.html title=換熱器原理與種類概述>換熱器原理與種類概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c69e3d63.html alt=電氣備品備件管理方案概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b8649ba4d3d740ee8682dd2f0a7cf6cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c69e3d63.html title=電氣備品備件管理方案概述>電氣備品備件管理方案概述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d3b937d.html alt=Collection子接口：List接口詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d3b937d.html title=Collection子接口：List接口詳解>Collection子接口：List接口詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8cae3b4.html alt=Collection子接口：Set接口詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8cae3b4.html title=Collection子接口：Set接口詳解>Collection子接口：Set接口詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4539721.html alt=Collection接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4539721.html title=Collection接口>Collection接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62d69e2b.html alt="java 集合Collection 子接口：List接口  set接口   queue 接口" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/c3e85753-f79f-45b8-b6a1-99263b2386a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62d69e2b.html title="java 集合Collection 子接口：List接口  set接口   queue 接口">java 集合Collection 子接口：List接口 set接口 queue 接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65ba507a.html alt=Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e3bf229076045f18e5bb24370a78db0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65ba507a.html title=Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？>Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f27004c.html alt=java中的collection和Map接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f27004c.html title=java中的collection和Map接口>java中的collection和Map接口</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>