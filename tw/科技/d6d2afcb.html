<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>ReentrantReadWriteLock可重入讀寫鎖詳解 | 极客快訊</title><meta property="og:title" content="ReentrantReadWriteLock可重入讀寫鎖詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4f41764bc4f24a9a90b15116c8b1ddf4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6d2afcb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6d2afcb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6d2afcb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6d2afcb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6d2afcb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6d2afcb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6d2afcb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6d2afcb.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="ReentrantReadWriteLock可重入讀寫鎖詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d6d2afcb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>ReentrantReadWriteLock可重入讀寫鎖詳解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=ReentrantReadWriteLock可重入讀寫鎖詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f41764bc4f24a9a90b15116c8b1ddf4><p class=pgc-img-caption>思維導圖</p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>ReentrantLock 鎖回顧</strong></h1><p>在Java5.0之前,只有synchronized(內置鎖)和volatile. Java5.0後引入了顯示鎖ReentrantLock.</p><p>ReentrantLock是可重入的鎖,它不同於內置鎖, 它在每次使用都需要顯示的加鎖和解鎖, 而且提供了更高級的特性:公平鎖, 定時鎖, 有條件鎖, 可輪詢鎖, 可中斷鎖. 可以有效避免死鎖的活躍性問題</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">Lock 接口</span></span></strong></h1><pre><code> public interface Lock {    //阻塞直到獲得鎖或者中斷    void lock();    //阻塞直到獲得鎖或者中斷拋異常    void lockInterruptibly() throws InterruptedException;        //只有鎖可用時才獲得,否則直接返回    boolean tryLock();        //只有鎖在指定時間內可用時才獲得,否則直接返回,中斷時拋異常    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;        void unlock();        //返回一個綁定在這個鎖上的條件    Condition newCondition();}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">使用</span></span></strong></h1><pre><code>Lock lock = new ReentrantLock();lock.lock();try{    //更新對象狀態}finally{    //這裡注意,一定要有finally代碼塊去解鎖    //否則容易造成死鎖等活躍性問題    lock.unlock();}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">輪詢鎖的和定時鎖</span></span></strong></h1><p>可輪詢和可定時的鎖請求是通過tryLock()方法實現的,和無條件獲取鎖不一樣.</p><p>ReentrantLock可以有靈活的容錯機制.死鎖的很多情況是由於順序鎖引起的, 不同線程在試圖獲得鎖的時候阻塞,並且不釋放自己已經持有的鎖, 最後造成死鎖.</p><p>tryLock()方法在試圖獲得鎖的時候,如果該鎖已經被其它線程持有,則按照設置方式立刻返回,而不是一直阻塞等下去,同時在返回後釋放自己持有的鎖.</p><p>可以根據返回的結果進行重試或者取消,進而避免死鎖的發生.</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">公平性</span></span></strong></h1><p>ReentrantLock構造函數中提供公平性鎖和非公平鎖（默認）兩種選擇。</p><p>所謂公平鎖，線程將按照他們發出請求的順序來獲取鎖，不允許插隊；但在非公平鎖上，則允許插隊：當一個線程發生獲取鎖的請求的時刻，如果這個鎖是可用的，那這個線程將跳過所在隊列裡等待線程並獲得鎖。</p><p>我們一般希望所有鎖是非公平的。因為當執行加鎖操作時，公平性將講由於線程掛起和恢復線程時開銷而極大的降低性能。考慮這麼一種情況：A線程持有鎖，B線程請求這個鎖，因此B線程被掛起；A線程釋放這個鎖時，B線程將被喚醒，因此再次嘗試獲取鎖；與此同時，C線程也請求獲取這個鎖，那麼C線程很可能在B線程被完全喚醒之前獲得、使用以及釋放這個鎖。這是種雙贏的局面，B獲取鎖的時刻（B被喚醒後才能獲取鎖）並沒有推遲，C更早地獲取了鎖，並且吞吐量也獲得了提高。</p><p>在大多數情況下，非公平鎖的性能要高於公平鎖的性能。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">可中斷獲鎖獲取操作</span></span></strong></h1><p>lockInterruptibly() 方法能夠在獲取鎖的同時保持對中斷的響應，因此無需創建其它類型的不可中斷阻塞操作。</p><p>對於可重入鎖的回顧就到這裡，更深入地講解，可以閱讀</p><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ReentrantLock 可重入鎖這樣學，面試沒煩惱</span></p></blockquote><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">鎖專題（五）ReentrantLock 深入源碼詳解</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>為什麼需要讀寫鎖</strong></h1><p>在Java併發包中常用的鎖（如：ReentrantLock），基本上都是排他鎖，這些鎖在同一時刻只允許一個線程進行訪問，而讀寫鎖在同一時刻可以允許多個讀線程訪問，但是在寫線程訪問時，所有的讀線程和其他寫線程均被阻塞。</p><p>讀寫鎖維護了一對鎖，一個讀鎖和一個寫鎖，通過分離讀鎖和寫鎖，使得 併發性相比一般的排他鎖有了很大提升。</p><p><strong>除了保證寫操作對讀操作的可見性以及併發性的提升之外，讀寫鎖能夠簡化讀寫交互場景的編程方式。</strong></p><p><br></p><div class=pgc-img><img alt=ReentrantReadWriteLock可重入讀寫鎖詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/ad5dd71c-60d9-4c0f-8ec2-b2e1c49e7c3a><p class=pgc-img-caption></p></div><p><br></p><p>假設在程序中定義一個共享的數據結構用作緩存，它大部分時間提供讀服務（例如：查詢和搜索），而寫操作佔有的時間很少，但是寫操作完成之後的更新需要對後續的讀服務可見。</p><p>在沒有讀寫鎖支持的（Java 5 之前）時候，如果需要完成上述工作就要使用Java的等待通知機制，就是當寫操作開始時，所有晚於寫操作的讀操作均會進入等待狀態，只有寫操作完成並進行通知之後，所有等待的讀操作才能繼續執行（寫操作之間依靠synchronized關鍵字進行同步），這樣做的目的是使讀操作都能讀取到正確的數據，而不會出現髒讀。</p><p>改用讀寫鎖實現上述功能，只需要在讀操作時獲取讀鎖，而寫操作時獲取寫鎖即可，當寫鎖被獲取到時，後續（非當前寫操作線程）的讀寫操作都會被 阻塞，寫鎖釋放之後，所有操作繼續執行，編程方式相對於使用等待通知機制的實現方式而言，變得簡單明瞭。</p><p>一般情況下，讀寫鎖的性能都會比排它鎖要好，因為大多數場景讀是多於寫的。在讀多於寫的情況下，讀寫鎖能夠提供比排它鎖更好的併發性和吞吐量。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">讀寫鎖的優勢</span></span></strong></h1><p>與傳統鎖不同的是讀寫鎖的規則是可以共享讀，但只能一個寫，總結起來為：讀讀不互斥，讀寫互斥，寫寫互斥，</p><p>而一般的獨佔鎖是：讀讀互斥，讀寫互斥，寫寫互斥，而場景中往往讀遠遠大於寫，讀寫鎖就是為了這種優化而創建出來的一種機制。</p><p>注意是讀遠遠大於寫，一般情況下獨佔鎖的效率低來源於高併發下對臨界區的激烈競爭導致線程上下文切換。因此當併發不是很高的情況下，讀寫鎖由於需要額外維護讀鎖的狀態，可能還不如獨佔鎖的效率高。因此需要根據實際情況選擇使用。</p><h1 class=pgc-h-arrow-right><strong>jdk 內置實現 ReentrantReadWriteLock</strong></h1><p>java併發包提供了讀寫鎖的具體實現 ReentrantReadWriteLock，它主要提供了一下特性：</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">特性</span></span></strong></h1><p>公平性選擇：支持公平和非公平（默認）兩種獲取鎖的方式，非公平鎖的吞吐量優於公平鎖；</p><p>可重入：支持可重入，讀線程在獲取讀鎖之後能夠再次獲取讀鎖，寫線程在獲取了寫鎖之後能夠再次獲取寫鎖，同時也可以獲取讀鎖；</p><p>鎖降級：線程獲取鎖的順序遵循獲取寫鎖，獲取讀鎖，釋放寫鎖，寫鎖可以降級成為讀鎖。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">如何保證同步</span></span></strong></h1><p>Java中的可重入讀寫鎖ReentrantReadWriteLock是基於AQS（AbstractQueuedSynchronizer）實現的，查看源碼可以發現內部有一個Sync對象繼承自AbstractQueuedSynchronizer，它用來管理同步機制，java併發包下的類基本都是用它來提供同步機制的。</p><p>再查看AQS的源碼會發現其內部全是native方法及包裝這些方法的一些其他方法。</p><p>這些native方法都是調用本地方法，利用了運行機器CPU的CAS特性。</p><p>CAS（CompareAndSet）是一種非阻塞算法來保證同步，它的效率通常要比加鎖算法高很多，因為它無阻塞，無掛起和恢復，無死鎖。</p><p>簡單來說，比較和替換是使用一個期望值和一個變量的當前值進行比較，如果當前變量的值與我們期望的值相等，就使用一個新值替換當前變量的值，返回true，否則返回false，線程可以選擇繼續做其他事情。</p><p>關於CAS可以參考 鎖專題（四）深入淺出 CAS 算法，樂觀鎖原來這樣實現的。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">如何維護狀態</span></span></strong></h1><p>ReentrantReadWriteLock內部維護的讀寫狀態是由32位碼錶示，高16位為讀狀態，表示持有讀鎖的線程數（sharedCount），低16位為寫狀態，表示寫鎖的重入次數 （exclusiveCount），狀態的改變通過AQS實現，保證同步。</p><p>關於ReentrantReadWriteLock的最核心部分大概就是上述兩點，這裡不再細緻分析具體代碼實現，它注重了效率但實現方式不容易我們理解一個讀寫鎖到底該有什麼東西。因此這裡重點通過一個wait/notify版本的讀寫鎖如何實現來深入瞭解讀寫鎖的原理。</p><h1 class=pgc-h-arrow-right><strong>ReentrantReadWriteLock 源碼分析</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">jdk 版本</span></span></strong></h1><pre><code>java version "1.8.0_191"</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">接口</span></span></strong></h1><pre><code>public class ReentrantReadWriteLock        implements ReadWriteLock, java.io.Serializable </code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">私有屬性</span></span></strong></h1><p>ReadLock與WriteLock使用的是同一個Sync，具體怎麼實現同一個隊列既可以為共享鎖，又可以表示排他鎖下文會具體分析。</p><p>參見 Sync 源碼</p><pre><code> /** Inner class providing readlock */private final ReentrantReadWriteLock.ReadLock readerLock;/** Inner class providing writelock */private final ReentrantReadWriteLock.WriteLock writerLock;/** Performs all synchronization mechanics */final Sync sync;</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">構造器</span></span></strong></h1><pre><code> /** * Creates a new {@code ReentrantReadWriteLock} with * default (nonfair) ordering properties. */public ReentrantReadWriteLock() {    this(false);}/** * Creates a new {@code ReentrantReadWriteLock} with * the given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */public ReentrantReadWriteLock(boolean fair) {    sync = fair ? new FairSync() : new NonfairSync();    readerLock = new ReadLock(this);    writerLock = new WriteLock(this);}</code></pre><h1 class=pgc-h-arrow-right><strong>Sync</strong></h1><p>sync是讀寫鎖實現的核心，sync是基於AQS實現的，在AQS中核心是state字段和雙端隊列，那麼一個一個問題來分析。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">Sync如何同時表示讀鎖與寫鎖？</span></span></strong></h1><ul><li>讀寫鎖狀態獲取</li></ul><pre><code>static final int SHARED_SHIFT = 16;static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;/** Returns the number of shared holds represented in count */static int sharedCount(int c) { return c &gt;&gt;&gt; SHARED_SHIFT; }/** Returns the number of exclusive holds represented in count */static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }</code></pre><p>從代碼中獲取讀寫狀態可以看出其是把state（int32位）字段分成高16位與低16位，其中高16位表示讀鎖個數，低16位表示寫鎖個數，如下圖所示（圖來自Java併發編程藝術）。</p><div class=pgc-img><img alt=ReentrantReadWriteLock可重入讀寫鎖詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f4d87e6ea794d988bcf2dede3f649c4><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">讀寫鎖狀態獲取</span></p><p>該圖表示當前一個線程獲取到了寫鎖，並且重入了兩次，因此低16位是3，並且該線程又獲取了讀鎖，並且重入了一次，所以高16位是2，當寫鎖被獲取時如果讀鎖不為0那麼讀鎖一定是獲取寫鎖的這個線程。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">讀鎖的獲取</span></span></strong></h1><p>讀鎖的獲取主要實現是AQS中的acquireShared方法，其調用過程如下代碼。</p><h1 class=pgc-h-arrow-right><strong>清單3：讀鎖獲取入口</strong></h1><pre><code>// ReadLockpublic void lock() {    sync.acquireShared(1);}// AQSpublic final void acquireShared(int arg) {    if (tryAcquireShared(arg) &lt; 0)        doAcquireShared(arg);}</code></pre><p>其中doAcquireShared(arg)方法是獲取失敗之後AQS中入隊操作，等待被喚醒後重新獲取，那麼關鍵點就是tryAcquireShared(arg)方法，方法有點長，因此先總結出獲取讀鎖所經歷的步驟，獲取的第一部分步驟如下：</p><p>操作1：讀寫需要互斥，因此當存在寫鎖並且持有寫鎖的線程不是該線程時獲取失敗。</p><p>操作2：是否存在等待寫鎖的線程，存在的話則獲取讀鎖需要等待，避免寫鎖飢餓。(寫鎖優先級是比較高的)</p><p>操作3：CAS獲取讀鎖，實際上是state字段的高16位自增。</p><p>操作4：獲取成功後再ThreadLocal中記錄當前線程獲取讀鎖的次數。</p><h1 class=pgc-h-arrow-right><strong>清單4：讀鎖獲取的第一部分</strong></h1><pre><code>protected final int tryAcquireShared(int unused) {    Thread current = Thread.currentThread();    int c = getState();    // 操作1：存在寫鎖，並且寫鎖不是當前線程則直接去排隊    if (exclusiveCount(c) != 0 &amp;&amp;        getExclusiveOwnerThread() != current)        return -1;    int r = sharedCount(c);    // 操作2：讀鎖是否該阻塞，對於非公平模式下寫鎖獲取優先級會高，如果存在要獲取寫鎖的線程則讀鎖需要讓步，公平模式下則先來先到    if (!readerShouldBlock() &amp;&amp;         // 讀鎖使用高16位，因此存在獲取上限為2^16-1        r &lt; MAX_COUNT &amp;&amp;        // 操作3：CAS修改讀鎖狀態，實際上是讀鎖狀態+1        compareAndSetState(c, c + SHARED_UNIT)) {        // 操作4：執行到這裡說明讀鎖已經獲取成功，因此需要記錄線程狀態。        if (r == 0) {            firstReader = current; // firstReader是把讀鎖狀態從0變成1的那個線程            firstReaderHoldCount = 1;        } else if (firstReader == current) {             firstReaderHoldCount++;        } else {            // 這些代碼實際上是從ThreadLocal中獲取當前線程重入讀鎖的次數，然後自增下。            HoldCounter rh = cachedHoldCounter; // cachedHoldCounter是上一個獲取鎖成功的線程            if (rh == null || rh.tid != getThreadId(current))                cachedHoldCounter = rh = readHolds.get();            else if (rh.count == 0)                readHolds.set(rh);            rh.count++;        }        return 1;    }    // 當操作2，操作3失敗時執行該邏輯    return fullTryAcquireShared(current);}</code></pre><p>當操作2，操作3失敗時會執行fullTryAcquireShared(current)，為什麼會這樣寫呢？</p><p>個人認為是一種補償操作，操作2與操作3失敗並不代表當前線程沒有讀鎖的資格，並且這裡的讀鎖是共享鎖，有資格就應該被獲取成功，因此給予補償獲取讀鎖的操作。</p><p>在fullTryAcquireShared(current)中是一個循環獲取讀鎖的過程，大致步驟如下：</p><p>操作5：等同於操作2，存在寫鎖，且寫鎖線程並非當前線程則直接返回失敗</p><p>操作6：當前線程是重入讀鎖，這裡只會偏向第一個獲取讀鎖的線程以及最後一個獲取讀鎖的線程，其他都需要去AQS中排隊。</p><p>操作7：CAS改變讀鎖狀態</p><p>操作8：同操作4，獲取成功後再ThreadLocal中記錄當前線程獲取讀鎖的次數。</p><h1 class=pgc-h-arrow-right><strong>清單5：讀鎖獲取的第二部分</strong></h1><pre><code>final int fullTryAcquireShared(Thread current) {    HoldCounter rh = null;    // 最外層嵌套循環    for (;;) {        int c = getState();        // 操作5：存在寫鎖，且寫鎖並非當前線程則直接返回失敗        if (exclusiveCount(c) != 0) {            if (getExclusiveOwnerThread() != current)                return -1;            // else we hold the exclusive lock; blocking here            // would cause deadlock.        // 操作6：如果當前線程是重入讀鎖則放行        } else if (readerShouldBlock()) {            // Make sure we're not acquiring read lock reentrantly            // 當前是firstReader，則直接放行,說明是已獲取的線程重入讀鎖            if (firstReader == current) {                // assert firstReaderHoldCount &gt; 0;            } else {                // 執行到這裡說明是其他線程，如果是cachedHoldCounter（其count不為0）也就是上一個獲取鎖的線程則可以重入，否則進入AQS中排隊                // **這裡也是對寫鎖的讓步**，如果隊列中頭結點為寫鎖，那麼當前獲取讀鎖的線程要進入隊列中排隊                if (rh == null) {                    rh = cachedHoldCounter;                    if (rh == null || rh.tid != getThreadId(current)) {                        rh = readHolds.get();                        if (rh.count == 0)                            readHolds.remove();                    }                }                // 說明是上述剛初始化的rh，所以直接去AQS中排隊                if (rh.count == 0)                    return -1;            }        }        if (sharedCount(c) == MAX_COUNT)            throw new Error("Maximum lock count exceeded");        // 操作7：修改讀鎖狀態，實際上讀鎖自增操作        if (compareAndSetState(c, c + SHARED_UNIT)) {            // 操作8：對ThreadLocal中維護的獲取鎖次數進行更新。            if (sharedCount(c) == 0) {                firstReader = current;                firstReaderHoldCount = 1;            } else if (firstReader == current) {                firstReaderHoldCount++;            } else {                if (rh == null)                    rh = cachedHoldCounter;                if (rh == null || rh.tid != getThreadId(current))                    rh = readHolds.get();                else if (rh.count == 0)                    readHolds.set(rh);                rh.count++;                cachedHoldCounter = rh; // cache for release            }            return 1;        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">讀鎖的釋放</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>清單6：讀鎖釋放入口</strong></h1><pre><code>// ReadLockpublic void unlock() {    sync.releaseShared(1);}// Syncpublic final boolean releaseShared(int arg) {    if (tryReleaseShared(arg)) {        doReleaseShared(); // 這裡實際上是釋放讀鎖後喚醒寫鎖的線程操作        return true;    }    return false;}</code></pre><p>讀鎖的釋放主要是tryReleaseShared(arg)函數，因此拆解其步驟如下：</p><p>操作1：清理ThreadLocal中保存的獲取鎖數量信息</p><p>操作2：CAS修改讀鎖個數，實際上是自減一</p><h1 class=pgc-h-arrow-right><strong>清單7：讀鎖的釋放流程</strong></h1><pre><code>protected final boolean tryReleaseShared(int unused) {    Thread current = Thread.currentThread();    // 操作1：清理ThreadLocal對應的信息    if (firstReader == current) {;        if (firstReaderHoldCount == 1)            firstReader = null;        else            firstReaderHoldCount--;    } else {        HoldCounter rh = cachedHoldCounter;        if (rh == null || rh.tid != getThreadId(current))            rh = readHolds.get();        int count = rh.count;        // 已釋放完的讀鎖的線程清空操作        if (count &lt;= 1) {            readHolds.remove();            // 如果沒有獲取鎖卻釋放則會報該錯誤            if (count &lt;= 0)                throw unmatchedUnlockException();        }        --rh.count;    }    // 操作2：循環中利用CAS修改讀鎖狀態    for (;;) {        int c = getState();        int nextc = c - SHARED_UNIT;        if (compareAndSetState(c, nextc))            // Releasing the read lock has no effect on readers,            // but it may allow waiting writers to proceed if            // both read and write locks are now free.            return nextc == 0;    }}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">寫鎖的獲取</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>清單8：寫鎖的獲取入口</strong></h1><pre><code>// WriteLockpublic void lock() {  sync.acquire(1);}// AQSpublic final void acquire(int arg) {    // 嘗試獲取，獲取失敗後入隊，入隊失敗則interrupt當前線程    if (!tryAcquire(arg) &amp;&amp;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))        selfInterrupt();}</code></pre><p>寫鎖的獲取也主要是tryAcquire(arg)方法，這裡也拆解步驟：</p><p>操作1：如果讀鎖數量不為0或者寫鎖數量不為0，並且不是重入操作，則獲取失敗。</p><p>操作2：如果當前鎖的數量為0，也就是不存在操作1的情況，那麼該線程是有資格獲取到寫鎖，因此修改狀態，設置獨佔線程為當前線程</p><h1 class=pgc-h-arrow-right><strong>清單9：寫鎖的獲取</strong></h1><pre><code>protected final boolean tryAcquire(int acquires) {    Thread current = Thread.currentThread();    int c = getState();    int w = exclusiveCount(c);    // 操作1：c != 0，說明存在讀鎖或者寫鎖    if (c != 0) {        // (Note: if c != 0 and w == 0 then shared count != 0)          // 寫鎖為0，讀鎖不為0 或者獲取寫鎖的線程並不是當前線程，直接失敗        if (w == 0 || current != getExclusiveOwnerThread())            return false;        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error("Maximum lock count exceeded");        // Reentrant acquire        // 執行到這裡說明是寫鎖線程的重入操作，直接修改狀態，也不需要CAS因為沒有競爭        setState(c + acquires);        return true;    }    // 操作2：獲取寫鎖，writerShouldBlock對於非公平模式直接返回fasle，對於公平模式則線程需要排隊，因此需要阻塞。    if (writerShouldBlock() ||        !compareAndSetState(c, c + acquires))        return false;    setExclusiveOwnerThread(current);    return true;}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">寫鎖的釋放</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>清單10：寫鎖的釋放入口</strong></h1><pre><code>// WriteLockpublic void unlock() {       sync.release(1);}// AQSpublic final boolean release(int arg) {    // 釋放鎖成功後喚醒隊列中第一個線程    if (tryRelease(arg)) {        Node h = head;        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    }    return false;}</code></pre><p>寫鎖的釋放主要是tryRelease(arg)方法，其邏輯就比較簡單了，註釋很詳細。</p><h1 class=pgc-h-arrow-right><strong>清單11：寫鎖的釋放</strong></h1><pre><code>protected final boolean tryRelease(int releases) {     // 如果當前線程沒有獲取寫鎖卻釋放，則直接拋異常     if (!isHeldExclusively())         throw new IllegalMonitorStateException();     // 狀態變更至nextc     int nextc = getState() - releases;     // 因為寫鎖是可以重入，所以在都釋放完畢後要把獨佔標識清空     boolean free = exclusiveCount(nextc) == 0;     if (free)         setExclusiveOwnerThread(null);     // 修改狀態     setState(nextc);     return free;}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">鎖降級操作哪裡體現？</span></span></strong></h1><p>鎖降級操作指的是一個線程獲取寫鎖之後再獲取讀鎖，然後讀鎖釋放掉寫鎖的過程。</p><p>在tryAcquireShared(arg)獲取讀鎖的代碼中有如下代碼。</p><h1 class=pgc-h-arrow-right><strong>清單12：</strong><strong>寫鎖</strong><strong>降級策略</strong></h1><pre><code>Thread current = Thread.currentThread();// 當前狀態int c = getState();// 存在寫鎖，並且寫鎖不等於當前線程時返回，換句話說等寫鎖為當前線程時則可以繼續往下獲取讀鎖。if (exclusiveCount(c) != 0 &amp;&amp;    getExclusiveOwnerThread() != current)    return -1;</code></pre><h1 class=pgc-h-arrow-right><strong>那麼鎖降級有什麼用？</strong></h1><p>答案是為了可見性的保證。</p><p>在ReentrantReadWriteLock的javadoc中有如下代碼，其是鎖降級的一個應用示例。</p><pre><code>class CachedData {  Object data;  volatile boolean cacheValid;  final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();   void processCachedData() {    // 獲取讀鎖    rwl.readLock().lock();    if (!cacheValid) {      // Must release read lock before acquiring write lock，不釋放的話下面寫鎖會獲取不成功，造成死鎖      rwl.readLock().unlock();     // 獲取寫鎖      rwl.writeLock().lock();      try {        // Recheck state because another thread might have        // acquired write lock and changed state before we did.        if (!cacheValid) {          data = ...          cacheValid = true;        }        // Downgrade by acquiring read lock before releasing write lock        // 這裡再次獲取讀鎖，如果不獲取那麼當寫鎖釋放後可能其他寫線程再次獲得寫鎖，導致下方`use(data)`時出現不一致的現象        // 這個操作就是降級        rwl.readLock().lock();      } finally {        rwl.writeLock().unlock(); // Unlock write, still hold read      }    }    try {    // 使用完後釋放讀鎖      use(data);    } finally {      rwl.readLock().unlock();    }  } }}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">公平與非公平的區別</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>清單13：公平下的Sync</strong></h1><pre><code>static final class FairSync extends Sync {     private static final long serialVersionUID = -2274990926593161451L;     final boolean writerShouldBlock() {         return hasQueuedPredecessors(); // 隊列中是否有元素，有則當前操作需要block     }     final boolean readerShouldBlock() {         return hasQueuedPredecessors();// 隊列中是否有元素，有則當前操作需要block     }}</code></pre><p>公平下的Sync實現策略是所有獲取的讀鎖或者寫鎖的線程都需要入隊排隊，按照順序依次去嘗試獲取鎖。</p><h1 class=pgc-h-arrow-right><strong>清單14：非公平下的Sync</strong></h1><pre><code>static final class NonfairSync extends Sync {    private static final long serialVersionUID = -8159625535654395037L;    final boolean writerShouldBlock() {        // 非公平下不考慮排隊，因此寫鎖可以競爭獲取        return false; // writers can always barge    }    final boolean readerShouldBlock() {        /* As a heuristic to avoid indefinite writer starvation,         * block if the thread that momentarily appears to be head         * of queue, if one exists, is a waiting writer.  This is         * only a probabilistic effect since a new reader will not         * block if there is a waiting writer behind other enabled         * readers that have not yet drained from the queue.         */        // 這裡實際上是一個優先級，如果隊列中頭部元素時寫鎖，那麼讀鎖需要等待，避免寫鎖飢餓。        return apparentlyFirstQueuedIsExclusive();    }}</code></pre><p>非公平下由於搶佔式獲取鎖，寫鎖是可能產生飢餓，因此解決辦法就是提高寫鎖的優先級，換句話說獲取寫鎖之前先佔坑。</p><h1 class=pgc-h-arrow-right><strong>小結</strong></h1><p>本文回顧了可重入鎖 ReentrantLock，引入了讀場景多時性能更加優異的可重入讀寫鎖 ReentrantReadWriteLock。</p><p>從類的介紹使用，深入到源碼解析，希望給各位極客們帶來全面的認識。下一節我們將一起學習下比 ReentrantReadWriteLock 性能更好的鎖，你知道是什麼嗎？</p><p>希望本文對你有幫助，如果有其他想法的話，也可以評論區和大家分享哦。</p><p>各位<strong>極客</strong>的點贊收藏轉發，是老馬寫作的最大動力！</p><p><br></p><div class=pgc-img><img alt=ReentrantReadWriteLock可重入讀寫鎖詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca7778677e034d43b558558360331033><p class=pgc-img-caption>深入學習</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>ReentrantReadWriteLock</a></li><li><a>寫鎖</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a99c320f.html alt=理解可重入讀寫鎖ReentrantReadWriteLock的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5cdade2faa5e4a60a437c67c0609b503 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a99c320f.html title=理解可重入讀寫鎖ReentrantReadWriteLock的使用>理解可重入讀寫鎖ReentrantReadWriteLock的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html alt=詳解13項鋼筋安裝質量標準及通病防治 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fd3ff534941a487884c7a67361337cfb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html title=詳解13項鋼筋安裝質量標準及通病防治>詳解13項鋼筋安裝質量標準及通病防治</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html alt=史上最全電路圖詳解！老電工都收藏了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533138404073909636bf43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html title=史上最全電路圖詳解！老電工都收藏了！>史上最全電路圖詳解！老電工都收藏了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html alt=每一滴油力爭做到不浪費，詳解各種燃油噴射方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3ed00001d75ac552f05c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html title=每一滴油力爭做到不浪費，詳解各種燃油噴射方式>每一滴油力爭做到不浪費，詳解各種燃油噴射方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html alt="Excel萬金油套路詳解 單條件查找返回多行數據" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2633664673fd439a862a2527763e82c7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html title="Excel萬金油套路詳解 單條件查找返回多行數據">Excel萬金油套路詳解 單條件查找返回多行數據</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html alt=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7360fe7df5e241e7af4b15f75f6474fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html title=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍>詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2946ed8.html alt=詳解變配電所的佈置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9fe764b6e4db4a01b0f251f70eb4e912 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2946ed8.html title=詳解變配電所的佈置>詳解變配電所的佈置</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>