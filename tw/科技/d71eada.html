<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入分析Linux內核源代碼6-Linux 內存管理（1） | 极客快訊</title><meta property="og:title" content="深入分析Linux內核源代碼6-Linux 內存管理（1） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a1235a07ccdc42cc8fd086f246d5aaa6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d71eada.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d71eada.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d71eada.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d71eada.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d71eada.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d71eada.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d71eada.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d71eada.html><meta property="article:published_time" content="2020-10-29T20:59:05+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:05+08:00"><meta name=Keywords content><meta name=description content="深入分析Linux內核源代碼6-Linux 內存管理（1）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d71eada.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入分析Linux內核源代碼6-Linux 內存管理（1）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a1235a07ccdc42cc8fd086f246d5aaa6><p class=pgc-img-caption></p></div><p>每天十五分鐘，熟讀一個技術點，水滴石穿，一切只為渴望更優秀的你！</p><p>————零聲學院</p><p><br></p><hr><p>存儲器是一種必須仔細管理的重要資源。在理想的情況下，每個程序員都喜歡無窮大、</p><p>快速並且內容不易變（即掉電後內容不會丟失）的存儲器，同時又希望它是廉價的。但不幸</p><p>的是，當前技術沒有能夠提供這樣的存儲器，因此大部分的計算機都有一個存儲器層次結構，</p><p>即少量、快速、昂貴、易變的高速緩存（cache）；若干兆字節的中等速度、中等價格、易變</p><p>的主存儲器（RAM）；數百兆或數千兆的低速、廉價、不易變的磁盤。如圖 6.1 所示，這些資</p><p>源的合理使用與否 ，直接關係著系統的效率。</p><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1b54075a2957434ba0c5b566ebf48732><p class=pgc-img-caption></p></div><p>Linux 內存管理是內核最複雜的任務之一。主要是因為它用到許多 CPU 提供的功能，而</p><p>且和這些功能密切相關。正因為如此，我們在第二章較詳細地介紹了 Intel 386 的段機制和</p><p>頁機制，可以說這是進行內存管理分析的物質基礎 。這一章用大量的篇幅描述了 Linux 內存</p><p>管理所涉及到的各種機制，如內存的初始化機制、地址映射機制、請頁機制、交換機制、內</p><p>存分配和回收機制、緩存和刷新機制以及內存共享機制，最後還分析了程序的創建和執行。</p><hr><p><br></p><h1 class=pgc-h-arrow-right>6.1 Linux 的內存管理概述</h1><p>Linux 是為多用戶多任務設計的操作系統，所以存儲資源要被多個進程有效共享；且由</p><p>於程序規模的不斷膨脹，要求的內存空間比從前大得多。 Linux 內存管理的設計充分利用了</p><p>計算機系統所提供的虛擬存儲技術，真正實現了虛擬存儲器管理。</p><p>第二章介紹的 Intel 386 的段機制和頁機制是 Linux 實現虛擬存儲管理的一種硬件平</p><p>臺。實際上， Linux 2.0 以上的版本不僅僅可以運行在 Intel 系列個人計算機上，還可以運</p><p>行在 Apple 系列、DEC Alpha 系列、MIPS 和 Motorola 68k 等系列上， 這些平臺都支持虛擬</p><p>存儲器管理，我們之所以選擇 Intel 386，是因為它具有代表性和普遍性。</p><p>Linux 的內存管理主要體現在對虛擬內存的管理。我們可以把 Linux 虛擬內存管理功能</p><p>概括為以下幾點：</p><p>• 大地址空間；</p><p>• 進程保護；</p><p>• 內存映射；</p><p>• 公平的物理內存分配；</p><p>• 共享虛擬內存。</p><p>關於這些功能的實現，我們將會陸續介紹。</p><p><br></p><p><strong>6.1.1 Linux 虛擬內存的實現結構</strong></p><p>我們先從整體結構上了解 Linux 對虛擬內存的實現結構，如圖 6.2 所示。</p><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/289eca36f18049e1b63965497c354619><p class=pgc-img-caption></p></div><p>從圖 6.2 中可看到實現虛擬內存的組成模塊。其實現的源代碼大部分放在/mm 目錄下。</p><p>（1）內存映射模塊(mmap)：負責把磁盤文件的邏輯地址映射到虛擬地址，以及把虛擬地</p><p>址映射到物理地址。</p><p>（2）交換模塊（swap）：負責控制內存內容的換入和換出，它通過交換機制，使得在物</p><p>理內存的頁面（RAM 頁）中保留有效的頁 ，即從主存中淘汰最近沒被訪問的頁，保存近來訪</p><p>問過的頁。</p><p>（3）核心內存管理模塊（core）：負責核心內存管理功能，即對頁的分配、回收、釋放</p><p>及請頁處理等，這些功能將被別的內核子系統（如文件系統）使用。</p><p>（4）結構特定的模塊：負責給各種硬件平臺提供通用接口，這個模塊通過執行命令來改</p><p>變硬件 MMU 的虛擬地址映射，並在發生頁錯誤時，提供了公用的方法來通知別的內核子系統。</p><p>這個模塊是實現虛擬內存的物理基礎。</p><p><br></p><p><strong>6.1.2 內核空間和用戶空間</strong></p><p>從第二章我們知道，Linux 簡化了分段機制，使得虛擬地址與線性地址總是一致，因此，</p><p>Linux 的虛擬地址空間也為 0～4G 字節。Linux 內核將這 4G 字節的空間分為兩部分。將最高</p><p>的 1G 字節（從虛擬地址 0xC0000000 到 0xFFFFFFFF），供內核使用，稱為“內核空間”。而將</p><p>較低的 3G 字節（從虛擬地址 0x00000000 到 0xBFFFFFFF），供各個進程使用，稱為“用戶空</p><p>間”。因為每個進程可以通過系統調用進入內核，因此，Linux 內核由系統內的所有進程共享。</p><p>於是，從具體進程的角度來看，每個進程可以擁有 4G 字節的虛擬空間。圖 6.3 給出了進程</p><p>虛擬空間示意圖。</p><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/72c7e50bf1cd4c35a651df245c9e08a2><p class=pgc-img-caption></p></div><p>Linux 使用兩級保護機制：0 級供內核使用，3 級供用戶程序使用。從圖 6.3 中可以看出，</p><p>每個進程有各自的私有用戶空間（0～3G），這個空間對系統中的其他進程是不可見的。最高</p><p>的 1G 字節虛擬內核空間則為所有進程以及內核所共享。</p><p>1．虛擬內核空間到物理空間的映射</p><p>內核空間中存放的是內核代碼和數據，而進程的用戶空間中存放的是用戶程序的代碼和</p><p>數據。不管是內核空間還是用戶空間，它們都處於虛擬空間中。讀者會問，系統啟動時，內</p><p>核的代碼和數據不是被裝入到物理內存嗎？它們為什麼也處於虛擬內存中呢？這和編譯程序</p><p>有關，後面我們通過具體討論就會明白這一點。</p><p>雖然內核空間佔據了每個虛擬空間中的最高 1G 字節，但映射到物理內存卻總是從最低</p><p>地址（0x00000000）開始。如圖 6.4 所示，對內核空間來說，其地址映射是很簡單的線性映</p><p>射，0xC0000000就是物理地址與線性地址之間的位移量，在 Linux代碼中就叫做 PAGE_OFFSET。</p><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7a02d803d8aa4fdbb3c43c4fae77653c><p class=pgc-img-caption></p></div><p>我們來看一下在 include/asm/i386/page.h 中對內核空間中地址映射的說明及定義：</p><pre><code>/** This handles the memory map.. We could make this a config* option, but too many people screw it up, and too few need* it.** A __PAGE_OFFSET of 0xC0000000 means that the kernel has* a virtual address space of one gigabyte, which limits the* amount of physical memory you can use to about 950MB.** If you want more physical memory than this then see the CONFIG_HIGHMEM4G* and CONFIG_HIGHMEM64G options in the kernel configuration.*/#define __PAGE_OFFSET （0xC0000000）……#define PAGE_OFFSET （（unsigned long）__PAGE_OFFSET）#define __pa（x） （（unsigned long）（x）-PAGE_OFFSET）#define __va（x） （（void *）（（unsigned long）（x）+PAGE_OFFSET））</code></pre><p>源代碼的註釋中說明，如果你的物理內存大於 950MB，那麼在編譯內核時就需要加</p><p>CONFIG_HIGHMEM4G 和 CONFIG_HIGHMEM64G 選項，這種情況我們暫不考慮。如果物理內存小</p><p>於950MB，則對於內核空間而言，給定一個虛地址 x，其物理地址為“x- PAGE_OFFSET”，給定</p><p>一個物理地址 x，其虛地址為“x+ PAGE_OFFSET”。</p><p>這裡再次說明，宏__pa()僅僅把一個內核空間的虛地址映射到物理地址，而決不適用於</p><p>用戶空間，用戶空間的地址映射要複雜得多。</p><p>2．內核映像</p><p>在下面的描述中，我們把內核的代碼和數據就叫內核映像（Kernel Image）。當系統啟</p><p>動時，Linux 內核映像被安裝在物理地址 0x00100000 開始的地方，即 1MB 開始的區間(第 1M</p><p>留作它用)。然而，在正常運行時， 整個內核映像應該在虛擬內核空間中，因此，連接程序</p><p>在連接內核映像時，在所有的符號地址上加一個偏移量 PAGE_OFFSET，這樣，內核映像在內</p><p>核空間的起始地址就為 0xC0100000。</p><p>例如，進程的頁目錄 PGD（屬於內核數據結構）就處於內核空間中。在進程切換時，要</p><p>將寄存器 CR3 設置成指向新進程的頁目錄 PGD，而該目錄的起始地址在內核空間中是虛地址，</p><p>但 CR3 所需要的是物理地址，這時候就要用__pa()進行地址轉換。在 mm_context.h 中就有這</p><p>麼一行語句：</p><p>asm volatile（“movl %0,%%cr3”: :”r” （__pa（next->pgd））;</p><p>這是一行嵌入式彙編代碼，其含義是將下一個進程的頁目錄起始地址 next_pgd，通過</p><p>__pa()轉換成物理地址，存放在某個寄存器中，然後用 mov 指令將其寫入 CR3 寄存器中。經</p><p>過這行語句的處理，CR3 就指向新進程 next 的頁目錄表 PGD 了。</p><p><br></p><p><strong>6.1.3 虛擬內存實現機制間的關係</strong></p><p>Linux 虛擬內存的實現需要各種機制的支持，因此，本章我們將對內存的初始化進行描</p><p>述以後，圍繞以下幾種實現機制進行介紹：</p><p>• 內存分配和回收機制；</p><p>• 地址映射機制；</p><p>• 緩存和刷新機制；</p><p>• 請頁機制；</p><p>• 交換機制；</p><p>• 內存共享機制。</p><p>這幾種機制的關係如圖 6.5 所示。</p><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/248ea3034ae141cd9e9bac566de15c11><p class=pgc-img-caption></p></div><p>首先內存管理程序通過映射機制把用戶程序的邏輯地址映射到物理地址，在用戶程序運</p><p>行時如果發現程序中要用的虛地址沒有對應的物理內存時，就發出了請頁要求①；如果有空</p><p>閒的內存可供分配，就請求分配內存②（於是用到了內存的分配和回收），並把正在使用的物</p><p>理頁記錄在頁緩存中③（使用了緩存機制）。如果沒有足夠的內存可供分配，那麼就調用交換</p><p>機制，騰出一部分內存④⑤。另外在地址映射中要通過 TLB（翻譯後援存儲器）來尋找物理</p><p>頁⑧；交換機制中也要用到交換緩存⑥，並且把物理頁內容交換到交換文件中後也要修改頁</p><p>表來映射文件地址⑦。</p><h1 class=pgc-h-arrow-right>6.2 Linux 內存管理的初始化</h1><p>在對內存管理（MM）的各種機制介紹之前，首先需要對 MM 的初始化過程有所瞭解，以</p><p>下介紹的內容是以第二章分段和分頁機制為基礎的，因此，讀者應該先溫習一下相關內容。</p><p>因為在嵌入式操作系統的開發中，內存的初始化是重點關注的內容之一，因此本節將對內存</p><p>的初始化給予詳細描述。</p><p><strong>6.2.1 啟用分頁機制</strong></p><p>當 Linux 啟動時，首先運行在實模式下，隨後就要轉到保護模式下運行。因為在第二章</p><p>段機制中，我們已經介紹了 Linux 對段的設置，在此我們主要討論與分頁機制相關的問題。</p><p>Linux 內核代碼的入口點就是/arch/i386/kernel/head.S 中的 startup_32。</p><p>1．頁表的初步初始化</p><pre><code>/* * The page tables are initialized to only 8MB here - the final page * tables are set up later depending on memory size. */.org 0x2000ENTRY（pg0）.org 0x3000ENTRY（pg1）/* * empty_zero_page must immediately follow the page tables ! （The * initialization loop counts until empty_zero_page） */.org 0x4000ENTRY（empty_zero_page） ／* * Initialize page tables */movl $pg0-__PAGE_OFFSET,%edi /* initialize page tables */ movl $007,%eax /* "007" doesn't mean with right to kill, but PRESENT+RW+USER */ 2: stosl add $0x1000,%eax cmp $empty_zero_page-__PAGE_OFFSET,%edi jne 2b</code></pre><p>內核的這段代碼執行時，因為頁機制還沒有啟用，還沒有進入保護模式，因此指令寄存</p><p>器 EIP 中的地址還是物理地址，但因為 pg0 中存放的是虛擬地址（gcc 編譯內核以後形成的</p><p>符號地址都是虛擬地址），因此，“$pg0-__PAGE_OFFSET ”獲得 pg0 的物理地址，可見 pg0</p><p>存放在相對於內核代碼起點為 0x2000 的地方,即物理地址為 0x00102000，而 pg1 的物理地址</p><p>則為 0x00103000。Pg0 和 pg1 這個兩個頁表中的表項則依次被設置為 0x007、0x1007、0x2007</p><p>等。其中最低的 3 位均為 1，表示這兩個頁為用戶頁，可寫，且頁的內容在內存中（參見圖</p><p>2.24）。所映射的物理頁的基地址則為 0x0、0x1000、0x2000 等，也就是物理內存中的頁面 0、</p><p>1、2、3 等等，共映射 2K 個頁面，即 8MB 的存儲空間。由此可以看出，Linux 內核對物理內</p><p>存的最低要求為 8MB。緊接著存放的是 empty_zero_page 頁(即零頁)，零頁存放的是系統啟</p><p>動參數和命令行參數，具體內容參見第十三章。</p><p>2．啟用分頁機制</p><pre><code>/* * This is initialized to create an identity-mapping at 0-8M （for bootup * purposes） and another mapping of the 0-8M area at virtual address * PAGE_OFFSET. */.org 0x1000ENTRY（swapper_pg_dir） .long 0x00102007 .long 0x00103007 .fill BOOT_USER_PGD_PTRS-2,4,0 /* default: 766 entries */ .long 0x00102007 .long 0x00103007 /* default: 254 entries */ .fill BOOT_KERNEL_PGD_PTRS-2,4,0/* * Enable paging */</code></pre><p>3:</p><pre><code> movl $swapper_pg_dir-__PAGE_OFFSET,%eax movl %eax,%cr3 /* set the page table pointer.. */ movl %cr0,%eax orl $0x80000000,%eax movl %eax,%cr0 /* ..and set paging （PG） bit */ jmp 1f /* flush the prefetch-queue */1: movl $1f,%eaxjmp *%eax /* make sure eip is relocated */1:</code></pre><p>我們先來看這段代碼的功能。這段代碼就是把頁目錄 swapper_pg_dir 的物理地址裝入</p><p>控制寄存器 cr3，並把 cr0 中的最高位置成 1，這就開啟了分頁機制。</p><p><br></p><p>但是，啟用了分頁機制，並不說明 Linux 內核真正進入了保護模式，因為此時，指令寄</p><p>存器 EIP 中的地址還是物理地址，而不是虛地址。“jmp 1f”指令從邏輯上說不起什麼作用，</p><p>但是，從功能上說它起到丟棄指令流水線中內容的作用（這是 Intel 在 i386 技術資料中所建</p><p>議的），因為這是一個短跳轉，EIP 中還是物理地址。緊接著的 mov 和 jmp 指令把第 2 個標號</p><p>為 1 的地址裝入 EAX 寄存器並跳轉到那兒。在這兩條指令執行的過程中, EIP 還是指向物理</p><p>地址“1MB＋某處”。因為編譯程序使所有的符號地址都在虛擬內存空間中，因此，第 2 個標</p><p>號 1 的地址就在虛擬內存空間的某處（PAGE_OFFSET+某處），於是，jmp 指令執行以後，EIP</p><p>就指向虛擬內核空間的某個地址，這就使 CPU 轉入了內核空間，從而完成了從實模式到保護</p><p>模式的平穩過渡。</p><p><br></p><p>然後再看頁目錄 swapper_pg_dir 中的內容。從前面的討論我們知道 pg0 和 pg1 這兩個</p><p>頁表的起始物理地址分別為 0x00102000 和 0x00103000。從圖 2.22 可知，頁目錄項的最低 12</p><p>位用來描述頁表的屬性。因此，在 swapper_pg_dir 中的第 0 和第 1 個目錄項 0x00102007、</p><p>0x00103007，就表示 pg0 和 pg1 這兩個頁表是用戶頁表、可寫且頁表的內容在內存。</p><p>接著，把 swapper_pg_dir 中的第 2～767 共 766 個目錄項全部置為 0。因為一個頁表的</p><p>大小為 4KB，每個表項佔 4 個字節，即每個頁表含有 1024 個表項，每個頁的大小也為 4KB，</p><p>因此這 768 個目錄項所映射的虛擬空間為 768×1024×4K＝3G，也就是 swapper_pg_dir 表中的</p><p>前 768 個目錄項映射的是用戶空間。</p><p><br></p><p>最後，在第 768 和 769 個目錄項中又存放 pg0 和 pg1 這兩個頁表的地址和屬性，而把第</p><p>770～1023 共 254 個目錄項置 0。這 256 個目錄項所映射的虛擬地址空間為 256×1024×4K＝1G，</p><p>也就是 swapper_pg_dir 表中的後 256 個目錄項映射的是內核空間。</p><p>由此可以看出，在初始的頁目錄 swapper_pg_dir 中，用戶空間和內核空間都只映射了</p><p>開頭的兩個目錄項，即 8MB 的空間，而且有著相同的映射，如圖 6.6 所示。</p><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2a63bd78b3ce49a9b59b4659e4efdefd><p class=pgc-img-caption></p></div><p>讀者會問，內核開始運行後運行在內核空間，那麼，為什麼把用戶空間的低區（8M）也</p><p>進行映射，而且與內核空間低區的映射相同？簡而言之，是為了從實模式到保護模式的平穩</p><p>過渡。具體地說，當 CPU 進入內核代碼的起點 startup_32 後，是以物理地址來取指令的。在</p><p>這種情況下，如果頁目錄只映射內核空間，而不映射用戶空間的低區，則一旦開啟頁映射機</p><p>制以後就不能繼續執行了，這是因為，此時 CPU 中的指令寄存器 EIP 仍指向低區，仍會以物</p><p>理地址取指令，直到以某個符號地址為目標作絕對轉移或調用子程序為止。所以，Linux 內</p><p>核就採取了上述的解決辦法。</p><p>但是，在 CPU 轉入內核空間以後，應該把用戶空間低區的映射清除掉。後面讀者將會看</p><p>到，頁目錄 swapper_pg_dir 經擴充後就成為所有內核線程的頁目錄。在內核線程的正常運行</p><p>中，處於內核態的 CPU 是不應該通過用戶空間的虛擬地址訪問內存的。清除了低區的映射以</p><p>後，如果發生 CPU 在內核中通過用戶空間的虛擬地址訪問內存，就可以因為產生頁面異常而</p><p>捕獲這個錯誤。</p><p>3．物理內存的初始分佈</p><p>經過這個階段的初始化，初始化階段頁目錄及幾個頁表在物理空間中的位置如圖 6.7 所</p><p>示。</p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/09825ca901fe49b38a4fcbd0b1e4f8b7><p class=pgc-img-caption></p></div><p>其中 empty_zero_page 中存放的是在操作系統的引導過程中所收集的一些數據，叫做引</p><p>導參數。因為這個頁面開始的內容全為 0，所以叫做“零頁”，代碼中常常通過宏定義 ZERO_PAGE</p><p>來引用這個頁面。不過，這個頁面要到初始化完成，系統轉入正常運行時才會用到。為了後</p><p>面內容介紹的方便，我們看一下複製到這個頁面中的命令行參數和引導參數。這裡假定這些</p><p>參數已被複制到“零頁”，在 setup.c 中定義了引用這些參數的宏：</p><pre><code> /* * This is set up by the setup-routine at boot-time */#define PARAM （（unsigned char *）empty_zero_page）#define SCREEN_INFO （*（struct screen_info *） （PARAM+0））#define EXT_MEM_K （*（unsigned short *） （PARAM+2））#define ALT_MEM_K （*（unsigned long *） （PARAM+0x1e0））#define E820_MAP_NR （*（char*） （PARAM+E820NR））#define E820_MAP （（struct e820entry *） （PARAM+E820MAP））#define APM_BIOS_INFO （*（struct apm_bios_info *） （PARAM+0x40））#define DRIVE_INFO （*（struct drive_info_struct *） （PARAM+0x80））#define SYS_DESC_TABLE （*（struct sys_desc_table_struct*）（PARAM+0xa0））#define MOUNT_ROOT_RDONLY （*（unsigned short *） （PARAM+0x1F2））#define RAMDISK_FLAGS （*（unsigned short *） （PARAM+0x1F8））#define ORIG_ROOT_DEV （*（unsigned short *） （PARAM+0x1FC））#define AUX_DEVICE_INFO （*（unsigned char *） （PARAM+0x1FF））#define LOADER_TYPE （*（unsigned char *） （PARAM+0x210））#define KERNEL_START （*（unsigned long *） （PARAM+0x214））#define INITRD_START （*（unsigned long *） （PARAM+0x218））#define INITRD_SIZE （*（unsigned long *） （PARAM+0x21c））#define COMMAND_LINE （（char *） （PARAM+2048））#define COMMAND_LINE_SIZE 256</code></pre><p>其中宏 PARAM 就是 empty_zero_page 的起始位置，隨著代碼的閱讀，讀者會逐漸理解這</p><p>些參數的用途。這裡要特別對宏 E820_MAP 進行說明。E820_MAP 是個 struct e820entry 數據</p><p>結 構 的 指 針 ， 存 放 在 參 數 塊 中 位 移 為 0x2d0 的 地 方 。 這 個 數 據 結 構 定 義 在</p><p>include/i386/e820.h 中：</p><pre><code>struct e820map { int nr_map; struct e820entry { unsigned long long addr; /* start of memory segment */ unsigned long long size; /* size of memory segment */ unsigned long type; /* type of memory segment */ } map[E820MAX];};extern struct e820map e820;</code></pre><p>其中，E820MAX 被定義為 32。從這個數據結構的定義可以看出，每個 e820entry 都是對</p><p>一個物理區間的描述，並且一個物理區間必須是同一類型。如果有一片地址連續的物理內存</p><p>空間，其一部分是 RAM，而另一部分是 ROM，那就要分成兩個區間。即使同屬 RAM，如果其中</p><p>一部分要保留用於特殊目的，那也屬於不同的分區。在 e820.h 文件中定義了 4 種不同的類型：</p><pre><code>#define E820_RAM 1#define E820_RESERVED 2#define E820_ACPI 3 /* usable as RAM once ACPI tables have been read */#define E820_NVS 4#define HIGH_MEMORY （1024*1024）</code></pre><p>其中 E820_NVS 表示“Non-Volatile Storage”，即“不揮發”存儲器，包括 ROM、EPROM、</p><p>Flash 存儲器等。</p><p>在 PC 中，對於最初 1MB 存儲空間的使用是特殊的。開頭 640KB（0x0~0x9FFFF）為 RAM，</p><p>從 0xA0000 開始的空間則用於 CGA、EGA、VGA 等圖形卡。現在已經很少使用這些圖形卡，但</p><p>是不管是什麼圖形卡，開機時總是工作於 EGA 或 VGA 模式。從 0xF0000 開始到 0xFFFFF，即</p><p>最高的 4KB，就是在 EPROM 或 Flash 存儲器中的 BIOS。所以，只要有 BIOS 存在，就至少有兩</p><p>個區間，如果 nr_map 小於 2，那就一定出錯了。由於 BIOS 的存在，本來連續的 RAM 空間就</p><p>不連續了。當然，現在已經不存在這樣的存儲結構了。1MB 的邊界早已被突破，但因為歷史</p><p>的原因，把 1MB 以上的空間定義為“HIGH_MEMORY”，這個稱呼一直沿用到現在，於是代碼中</p><p>的常數 HIGH_MEMORY 就定義為“1024×1024”。現在，配備了 128MB 的內存已經是很普遍了。</p><p>但是，為了保持兼容，就得留出最初 1MB 的空間。</p><p>這個階段初始化後，物理內存中內核映像的分佈如圖 6.8 所示。</p><p><br></p><div class=pgc-img><img alt="深入分析Linux內核源代碼6-Linux 內存管理（1）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/34c5b1a122334446800e3f66944a4e30><p class=pgc-img-caption></p></div><p>符號_text 對應物理地址 0x00100000，表示內核代碼的第一個字節的地址。內核代碼的</p><p>結束位置用另一個類似的符號_etext 表示。內核數據被分為兩組：初始化過的數據和未初始</p><p>化過的數據。初始化過的數據在_etext 後開始，在_edata 處結束，緊接著是未初始化過的數</p><p>據，其結束符號為_end，這也是整個內核映像的結束符號。</p><p>圖中出現的符號是由編譯程序在編譯內核時產生的。你可以在 System.map 文件中找到</p><p>這些符號的線性地址（或叫虛擬地址），System.map 是編譯內核以後所創建的。</p><p><br></p><p><strong>6.2.2 物理內存的探測</strong></p><p>我們知道，BIOS 不僅能引導操作系統，還擔負著加電自檢和對資源的掃描探測，其中就</p><p>包括了對物理內存的自檢和掃描（你剛開機時所看到的信息就是此階段 BIOS 顯示的信息）。</p><p>對於這個階段中獲得的內存信息可以通過 BIOS 調用“int 0x15”加以檢查。由於 Linux 內核</p><p>不能作 BIOS 調用，因此內核本身就得代為檢查，並根據獲得的信息生成一幅物理內存構成圖，</p><p>這就是上面所介紹的 e820 圖，然後通過上面提到的參數塊傳給內核。使得內核能知道系統中</p><p>內存資源的配置。之所以稱為 e820 圖，是因為在通過”int 0x15”查詢內存的構成時要把調</p><p>用參數之一設置成 0xe820。</p><p>分頁機制啟用以後，與內存管理相關的操作就是調用 init/main.c 中的 start_kernel</p><p>（）函數，start_kernel（）函數要調用一個叫 setup_arch()的函數，setup_arch（）位於</p><p>arch/i386/kernel/setup.c 文件中，我們所關注的與物理內存探測相關的內容就在這個函數</p><p>中。</p><p>1．setup_arch()函數</p><p>這個函數比較繁瑣和冗長，下面我們只對 setup_arch（）中與內存相關的內容給予描述。</p><p>首先調用 setup_memory_region()函數，這個函數處理內存構成圖（map）,並把內存的</p><p>分佈信息存放在全局變量 e820 中，後面會對此函數進行具體描述。</p><p>調用 parse_mem_cmdline(cmdline_p)函數。在特殊的情況下，有的系統可能有特殊的</p><p>RAM 空間結構，此時可以通過引導命令行中的選擇項來改變存儲空間的邏輯結構，使其正確</p><p>反映內存的物理結構。此函數的作用就是分析命令行中的選擇項，並據此對數據結構 e820</p><p>中的內容作出修正，其代碼也在 setup.c 中。</p><p>宏定義：</p><pre><code> #define PFN_UP（x） （（（x） + PAGE_SIZE-1） &gt;&gt; PAGE_SHIFT） #define PFN_DOWN（x） （（x） &gt;&gt; PAGE_SHIFT） #define PFN_PHYS（x） （（x） &lt;&lt; PAGE_SHIFT）</code></pre><p>PFN_UP（） 和 PFN_DOWN（）都是將地址 x 轉換為頁面號（PFN 即 Page Frame Number</p><p>的縮寫），二者之間的區別為：PFN_UP（）返回大於 x 的第 1 個頁面號，而 PFN_DOWN（）返</p><p>回小於 x 的第 1 個頁面號。宏 PFN_PHYS（）返回頁面號 x 的物理地址。</p><p>宏定義</p><pre><code> /* * 128MB for vmalloc and initrd */ #define VMALLOC_RESERVE （unsigned long）（128 &lt;&lt; 20） #define MAXMEM （unsigned long）（-PAGE_OFFSET-VMALLOC_RESERVE） #define MAXMEM_PFN PFN_DOWN（MAXMEM） #define MAX_NONPAE_PFN （1 &lt;&lt; 20）</code></pre><p>對這幾個宏描述如下：</p><p>• VMALLOC_RESERVE：為 vmalloc（）函數訪問內核空間所保留的內存區，大小為 128MB。</p><p>• MAXMEM：內核能夠直接映射的最大 RAM 容量，為 1GB－128MB＝896MB（-PAGE_OFFSET</p><p>就等於 1GB）</p><p>• MAXMEM_PFN：返回由內核能直接映射的最大物理頁面數。</p><p>• MAX_NONPAE_PFN：給出在 4GB 之上第 1 個頁面的頁面號。當頁面擴充（PAE）功能啟</p><p>用時，才能訪問 4GB 以上的內存。</p><p>獲得內核映像之後的起始頁面號：</p><pre><code> /* * partially used pages are not usable - thus * we are rounding upwards: */ start_pfn = PFN_UP（__pa（&amp;_end））;</code></pre><p>在上一節已說明，宏__pa（）返回給定虛擬地址的物理地址。其中標識符_end 表示內核</p><p>映像在內核空間的結束位置。因此，存放在變量 start_pfn 中的值就是緊接著內核映像之後</p><p>的頁面號。</p><p>找出可用的最高頁面號：</p><pre><code>/* * Find the highest page frame number we have available */ max_pfn = 0; for （i = 0; i &lt; e820.nr_map; i++） { unsigned long start, end; /* RAM? */ if （e820.map[i].type != E820_RAM） continue; start = PFN_UP（e820.map[i].addr）; end = PFN_DOWN（e820.map[i].addr + e820.map[i].size）; if （start &gt;= end） continue; if （end &gt; max_pfn） max_pfn = end; }</code></pre><p>上面這段代碼循環查找類型為 E820_RAM（可用 RAM）的內存區，並把最後一個頁面的頁</p><p>面號存放在 max_pfn 中。</p><p>確定最高和最低內存範圍：</p><pre><code> /* * Determine low and high memory ranges: */ max_low_pfn = max_pfn; if （max_low_pfn &gt; MAXMEM_PFN） { max_low_pfn = MAXMEM_PFN; #ifndef CONFIG_HIGHMEM /* Maximum memory usable is what is directly addressable */ printk（KERN_WARNING "Warning only %ldMB will be used.\n", MAXMEM&gt;&gt;20）; if （max_pfn &gt; MAX_NONPAE_PFN） printk（KERN_WARNING "Use a PAE enabled kernel.\n"）; else printk（KERN_WARNING "Use a HIGHMEM enabled kernel.\n"）; #else /* !CONFIG_HIGHMEM */ #ifndef CONFIG_X86_PAE if （max_pfn &gt; MAX_NONPAE_PFN） { max_pfn = MAX_NONPAE_PFN; printk（KERN_WARNING "Warning only 4GB will be used.\n"）; printk（KERN_WARNING "Use a PAE enabled kernel.\n"）; } #endif /* !CONFIG_X86_PAE */ #endif /* !CONFIG_HIGHMEM */ }</code></pre><p>有兩種情況：</p><p>• 如果物理內存 RAM 大於 896MB，而小於 4GB，則選用 CONFIG_HIGHMEM 選項來進行訪問；</p><p>• 如果物理內存 RAM 大於 4GB，則選用 CONFIG_X86_PAE（啟用 PAE 模式）來進行訪問。</p><p>上面這段代碼檢查了這兩種情況，並顯示適當的警告信息。</p><pre><code>#ifdef CONFIG_HIGHMEMhighstart_pfn = highend_pfn = max_pfn;if （max_pfn &gt; MAXMEM_PFN） { highstart_pfn = MAXMEM_PFN; printk（KERN_NOTICE "%ldMB HIGHMEM available.\n", pages_to_mb（highend_pfn - highstart_pfn））; } #endif</code></pre><p>如果使用了 CONFIG_HIGHMEM 選項，上面這段代碼僅僅打印出大於 896MB 的可用物理內</p><p>存數量。</p><p>初始化引導時的分配器</p><pre><code> * Initialize the boot-time allocator （with low memory only）: */ bootmap_size = init_bootmem（start_pfn, max_low_pfn）;</code></pre><p>通過調用 init_bootmem（）函數，為物理內存頁面管理機制的建立做初步準備，為整個</p><p>物理內存建立起一個頁面位圖。這個位圖建立在從 start_pfn 開始的地方，也就是說，把內</p><p>核映像終點_end 上方的若干頁面用作物理頁面位圖。在前面的代碼中已經搞清楚了物理內存</p><p>頂點所在的頁面號為 max_low_pfn，所以物理內存的頁面號一定在 0～max_low_pfn 之間。可</p><p>是，在這個範圍內可能有空洞（hole），另一方面，並不是所有的物理內存頁面都可以動態分</p><p>配。建立這個位圖的目的就是要搞清楚哪一些物理內存頁面可以動態分配的。後面會具體描</p><p>述 bootmem 分配器。</p><p>用 bootmem 分配器，登記全部低區（0～896MB）的可用 RAM 頁面</p><pre><code> /* * Register fully available low RAM pages with the * bootmem allocator. */ for （i = 0; i &lt; e820.nr_map; i++） { unsigned long curr_pfn, last_pfn, size; /* * Reserve usable low memory */ if （e820.map[i].type != E820_RAM） continue; /* * We are rounding up the start address of usable memory: */ curr_pfn = PFN_UP（e820.map[i].addr）; if （curr_pfn &gt;= max_low_pfn） continue; /* * ... and at the end of the usable range downwards: */ last_pfn = PFN_DOWN（e820.map[i].addr + e820.map[i].size）; if （last_pfn &gt; max_low_pfn） last_pfn = max_low_pfn; /* * .. finally, did all the rounding and playing * around just make the area go away? */ if （last_pfn &lt;= curr_pfn）= last_pfn - curr_pfn; free_bootmem（PFN_PHYS（curr_pfn）, PFN_PHYS（size））; }</code></pre><p>這個循環仔細檢查所有可以使用的 RAM，並調用 free_bootmem()函數把這些可用 RAM 標</p><p>記為可用。這個函數調用以後，只有類型為 1（可用 RAM）的內存被標記為可用的，參看後面</p><p>對這個函數的具體描述。</p><p>保留內存：</p><pre><code> /* * Reserve the bootmem bitmap itself as well. We do this in two * steps （first step was init_bootmem（）） because this catches * the （very unlikely） case of us accidentally initializing the * bootmem allocator with an invalid RAM area. */ reserve_bootmem（HIGH_MEMORY, （PFN_PHYS（start_pfn） + bootmap_size + PAGE_SIZE-1） - （HIGH_MEMORY））;</code></pre><p>這個函數把內核和 bootmem 位圖所佔的內存標記為“保留”。 HIGH_MEMORY 為 1MB，即</p><p>內核開始的地方，後面還要對這個函數進行具體描述。</p><p>分頁機制的初始化</p><p>paging_init（）;</p><p>這個函數初始化分頁內存管理所需要的數據結構，參見後面的詳細描述。</p><p>2．setup_memory_region() 函數</p><p>這個函數用來處理 BIOS 的內存構成圖，並把這個構成圖拷貝到全局變量 e820 中。如果</p><p>操作失敗，就創建一個偽內存構成圖。這個函數的主要操作如下所述。</p><p>• 調用 sanitize_e820_map()函數，以刪除內存構成圖中任何重疊的部分，因為 BIOS</p><p>所報告的內存構成圖可能有重疊。</p><p>• 調用 copy_e820_map()進行實際的拷貝。</p><p>• 如果操作失敗，創建一個偽內存構成圖，這個偽構成圖有兩部分：0 到 640K 及 1M 到</p><p>最大物理內存。</p><p>• 打印最終的內存構成圖。</p><p>3．copy_e820_map() 函數</p><p>函數原型為：</p><p>static int __init sanitize_e820_map（struct e820entry * biosmap, char * pnr_map）</p><p>其主要操作如下概述。</p><p>（1）如果物理內存區間小於 2，那肯定出錯。因為 BIOS 至少和 RAM 屬於不同的物理區間。</p><p>if （nr_map &lt; 2）</p><p>return -1;</p><p>（2）從 BIOS 構成圖中讀出一項。</p><pre><code> do { unsigned long long start = biosmap-&gt;addr; unsigned long long size = biosmap-&gt;size; unsigned long long end = start + size;unsigned long type = biosmap-&gt;type;</code></pre><p>（3）進行檢查。</p><pre><code> /* Overflow in 64 bits? Ignore the memory map. */ if （start &gt; end） return -1;</code></pre><p>（4）一些 BIOS 把 640KB～1MB 之間的區間作為 RAM 來用，這是不符合常規的。因為從</p><p>0xA0000 開始的空間用於圖形卡，因此，在內存構成圖中要進行修正。如果一個區的起點在</p><p>0xA0000 以下，而終點在 1MB 之上，就要將這個區間拆開成兩個區間，中間跳過從 0xA0000</p><p>到 1MB 邊界之間的那一部分。</p><pre><code>/* * Some BIOSes claim RAM in the 640k - 1M region. * Not right. Fix it up. */ if （type == E820_RAM） { if （start &lt; 0x100000ULL &amp;&amp; end &gt; 0xA0000ULL） { if （start &lt; 0xA0000ULL） add_memory_region（start, 0xA0000ULL-start, type） if （end &lt;= 0x100000ULL） continue; start = 0x100000ULL; size = end - start; } } add_memory_region（start, size, type）; } while （biosmap++,--nr_map）; return 0;</code></pre><p>4．add_memory_region() 函數</p><p>這個函數的功能就是在 e820 中增加一項，其主要操作如下所述。</p><p>（1）獲得已追加在 e820 中的內存區數。</p><p>int x = e820.nr_map;</p><p>（2）如果數目已達到最大（32），則顯示一個警告信息並返回。</p><pre><code> if （x == E820MAX） { printk（KERN_ERR "Oops! Too many entries in the memory map!\n"）; return; }</code></pre><p>（3）在 e820 中增加一項，並給 nr_map 加 1。</p><pre><code> e820.map[x].addr = start; e820.map[x].size = size; e820.map[x].type = type; e820.nr_map++;</code></pre><p>5．print_memory_map() 函數</p><p>這個函數把內存構成圖在控制檯上輸出，函數本身比較簡單，在此給出一個運行實例。</p><p>例如函數的輸出為（BIOS 所提供的物理 RAM 區間）：</p><p>BIOS-e820: 0000000000000000 - 00000000000a0000 （usable）</p><p>BIOS-e820: 00000000000f0000 - 0000000000100000 （reserved）</p><p>BIOS-e820: 0000000000100000 - 000000000c000000 （usable）</p><p>BIOS-e820: 00000000ffff0000 - 0000000100000000 （reserved）</p><p><br></p><p><strong>6.2.3 物理內存的描述</strong></p><p>為了對內存的初始化內容進行進一步的討論，我們首先要了解 Linux 對物理內存的描述</p><p>機制。</p><p>1．一致存儲結構（UMA）和非一致存儲結構（NUMA）</p><p>在傳統的計算機結構中，整個物理內存都是均勻一致的，CPU 訪問這個空間中的任何一</p><p>個地址所需要的時間都相同，所以把這種內存稱為“一致存儲結構（Uniform Memory</p><p>Architecture）”，簡稱 UMA。可是，在一些新的系統結構中，特別是多 CPU 結構的系統中，</p><p>物理存儲空間在這方面的一致性卻成了問題。這是因為，在多 CPU 結構中，系統中只有一條</p><p>總線（例如，PCI 總線），有多個 CPU 模塊連接在系統總線上，每個 CPU 模塊都有本地的物理</p><p>內存，但是也可以通過系統總線訪問其他 CPU 模塊上的內存。另外，系統總線上還連接著一</p><p>個公用的存儲模塊，所有的 CPU 模塊都可以通過系統總線來訪問它。因此，所有這些物理內</p><p>存的地址可以互相連續而形成一個連續的物理地址空間。</p><p>顯然，就某個特定的 CPU 而言，訪問其本地的存儲器速度是最快的，而穿過系統總線訪</p><p>問公用存儲模塊或其他 CPU 模塊上的存儲器就比較慢，而且還面臨因可能的競爭而引起的不</p><p>確定性。也就是說，在這樣的系統中，其物理存儲空間雖然地址連續，但因為所處“位置”</p><p>不同而導致的存取速度不一致，所以稱為“非一致存儲結構（ Non-Uniform Memory</p><p>Architecture），簡稱 NUMA。</p><p>事實上，嚴格意義上的 UMA 結構幾乎不存在。就拿配置最簡單的單 CPU 來說，其物理存</p><p>儲空間就包括了 RAM、ROM（用於 BIOS），還有圖形卡上的靜態 RAM。但是，在 UMA 中，除主</p><p>存 RAM 之外的存儲器空間都很小，因此可以把它們放在特殊的地址上，在編程時加以特別注</p><p>意就行，那麼，可以認為以 RAM 為主體的主存是 UMA 結構。</p><p>由於 NUMA 的引入，就需要存儲管理機制的支持，因此，Linux 內核從 2.4 版本開始就提</p><p>供了對 NUMA 的支持（作為一個編譯可選項）。為了對 NUMA 進行描述，引入一個新的概念—</p><p>“存儲節點(或叫節點)”，把訪問時間相同的存儲空間就叫做一個“存儲節點”。一般來說，連</p><p>續的物理頁面應該分配在相同的存儲節點上。例如，如果 CPU 模塊 1 要求分配 5 個頁面，但</p><p>是由於本模塊上的存儲空間已經不夠，只能分配 3 個頁面，那麼此時，是把另外兩個頁面分</p><p>配在其他 CPU 模塊上呢，還是把 5 個頁面乾脆分配在一個模塊上？顯然，合理的分配方式因</p><p>該是將這 5 個頁面都分配在公用模塊上。</p><p>Linux把物理內存劃分為 3個層次來管理：存儲節點（Node）、管理區（Zone）和頁面（Page），</p><p>並用 3 個相應的數據結構來描述。</p><p>2．頁面（Page）數據結構</p><p>對一個物理頁面的描述在／include/linux/mm.h 中：</p><pre><code>/* * Each physical page in the system has a struct page associated with * it to keep track of whatever it is we are using the page for at the * moment. Note that we have no way to track which tasks are using * a page. * * Try to keep the most commonly accessed fields in single cache lines * here （16 bytes or greater）. This ordering should be particularly * beneficial on 32-bit processors. * * The first line is data used in page cache lookup, the second line * is used for linear searches （eg. clock algorithm scans）. * * TODO: make this structure smaller, it could be as small as 32 bytes. */typedef struct page { struct list_head list; /* -&gt;mapping has some page lists. */ struct address_space *mapping; /* The inode （or ...） we belong to. */ unsigned long index; /* Our offset within mapping. */ struct page *next_hash; /* Next page sharing our hash bucket in the pagecache hash table. */ atomic_t count; /* Usage count, see below. */ unsigned long flags; /* atomic flags, some possibly updated asynchronously */ struct list_head lru; /* Pageout list, eg. active_list; protected by pagemap_lru_lock !! */ wait_queue_head_t wait; /* Page locked? Stand in line... */ struct page **pprev_hash; /* Complement to *next_hash. */ struct buffer_head * buffers; /* Buffer maps us to a disk block. */ void *virtual; /* Kernel virtual address （NULL if not kmapped, ie. highmem） */ struct zone_struct *zone; /* Memory zone we are in. */} mem_map_t;extern mem_map_t * mem_map；</code></pre><p>源代碼的註釋中對這個數據結構給出了一定的說明，從中我們可以對此結構有一定的理</p><p>解，後面還要對此結構中的每個域給出具體的解釋。</p><p>內核中用來表示這個數據結構的變量常常是 page 或 map。</p><p>當頁面的數據來自一個文件時，index 代表著該頁面中的數據在文件中的偏移量；當頁</p><p>面的內容被換出到交換設備上，則 index 指明瞭頁面的去向。結構中各個成分的次序是有講</p><p>究的，儘量使得聯繫緊密的若干域存放在一起，這樣當這個數據結構被裝入到高速緩存中時，</p><p>聯繫緊密的域就可以存放在同一緩衝行（Cache Line）中。因為同一緩衝行（其大小為 16</p><p>字節）中的內容幾乎可以同時存取，因此，代碼註釋中希望這個數據結構儘量地小到用 32</p><p>個字節可以描述。</p><p>系統中的每個物理頁面都有一個 Page（或 mem_map_t）結構。系統在初始化階段根據內</p><p>存的大小建立起一個 Page 結構的數組 mem_map，數組的下標就是內存中物理頁面的序號。</p><p>3．管理區 Zone</p><p>為了對物理頁面進行有效的管理，Linux 又把物理頁面劃分為 3 個區：</p><p>• 專供 DMA 使用的 ZONE_DMA 區（小於 16MB）;</p><p>• 常規的 ZONE_NORMAL 區（大於 16MB 小於 896MB）;</p><p>• 內核不能直接映射的區 ZONE_HIGME 區（大於 896MB）。</p><p>這裡進一步說明為什麼對 DMA 要單獨設置管理區。首先，DMA 使用的頁面是磁盤 I／O 所</p><p>需的，如果在頁面的分配過程中，所有的頁面全被分配完，那麼頁面及盤區的交換就無法進</p><p>行了，這是操作系統決不允許出現的現象。另外，在 i386 CPU 中，頁式存儲管理的硬件支持</p><p>是在 CPU 內部實現的，而不像有些 CPU 那樣由一個單獨的 MMU 來提供，所以 DMA 對內存的訪</p><p>問不經過 MMU 提供的地址映射。這樣，外部設備就要直接訪問物理頁面的地址。可是，有些</p><p>外設（特別是插在 ISA 總線上的外設接口卡）在這方面往往有些限制，要求用於 DMA 的物理</p><p>地址不能過高。另一方面，當 DMA 所需的緩衝區超過一個物理頁面的大小時，就要求兩個物</p><p>理頁面在物理上是連續的，但因為此時 DMA 控制器不能依靠 CPU 內部的 MMU 將連續的虛存頁</p><p>面映射到物理上也連續的頁面上，因此，用於 DMA 的物理頁面必須加以單獨管理。</p><p>關於管理區的數據結構 zone_struct(或 zone_t)將在後面進行描述。</p><p>4．存儲節點（Node）的數據結構</p><p>存儲節點的數據結構為 pglist_data，定義於 Include/linux/mmzone.h 中：</p><pre><code> typedef struct pglist_data { zone_t node_zones[MAX_NR_ZONES]; zonelist_t node_zonelists[GFP_ZONEMASK+1]; int nr_zones; struct page *node_mem_map; unsigned long *valid_addr_bitmap; struct bootmem_data *bdata; unsigned long node_start_paddr; unsigned long node_start_mapnr; unsigned long node_size; int node_id; struct pglist_data *node_next; } pg_data_t;</code></pre><p>顯然，若干存儲節點的 pglist_data 數據結構可以通過 node_next 形成一個單鏈表隊列。</p><p>每個結構中的 node_mem_map 指向具體節點的 page 結構數組，而數組 node_zone[]就是該節</p><p>點的最多 3 個頁面管理區。</p><p>在 pglist_data 結構裡設置了一個 node_zonelists 數組，其類型定義也在同一文件中：</p><pre><code> typedef struct zonelist_struct { zone_t *zone[MAX_NR_ZONE+1]; //NULL delimited Int gfp_mast; } zonelist_t</code></pre><p>這裡的 zone[]是個指針數組，各個元素按特定的次序指向具體的頁面管理區，表示分配</p><p>頁面時先試 zone[0]所指向的管理區，如果不能滿足要求就試 zone[1]所指向的管理區，等等。</p><p>這些管理區可以屬於不同的存儲節點。關於管理區的分配可以有很多種策略，例如，CPU 模</p><p>塊 1 需要分配 5 個用於 DMA 的頁面，可是它的 ZONE_DMA 只有 3 個頁面，於是就從公用模塊的</p><p>ZONE_DMA 中分配 5 個頁面。就是說，每個 zonelist_t 規定了一種分配策略。然而，每個存</p><p>儲節點不應該只有一種分配策略，所以在 pglist_data 中提供的是一個 zonelist_t 數組，數</p><p>組的大小 NR_GFPINDEX 為 100。</p><hr><p><strong>每日分享15分鐘技術摘要選讀，關注一波，一起保持學習動力！</strong></p><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>核源代碼</a></li><li><a>內存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1608906.html alt="深入分析Linux內核源代碼6-Linux 內存管理（2）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/40298caf1d2f414797e260a43b4f0e0b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1608906.html title="深入分析Linux內核源代碼6-Linux 內存管理（2）">深入分析Linux內核源代碼6-Linux 內存管理（2）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ec734b.html alt=淺談Linux內存管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4443462f6dbd4ae5a5257ef9f329d755 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ec734b.html title=淺談Linux內存管理>淺談Linux內存管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html alt=內存屏障詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html title=內存屏障詳解>內存屏障詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html alt=C語言學習篇(3)-----內存編址和對齊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e039d89a145f4e258f5f6eb28d04809b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html title=C語言學習篇(3)-----內存編址和對齊>C語言學習篇(3)-----內存編址和對齊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html alt=內存按字節編址例題解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/87f6444a27d34916b6e72824f6e98572 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html title=內存按字節編址例題解析>內存按字節編址例題解析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>