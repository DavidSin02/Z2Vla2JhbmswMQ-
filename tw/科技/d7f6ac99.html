<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你的redis分佈式可重入鎖是怎麼設計的(python實現） | 极客快訊</title><meta property="og:title" content="你的redis分佈式可重入鎖是怎麼設計的(python實現） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/19325eb39de0464e81ae82d3555d1126"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="你的redis分佈式可重入鎖是怎麼設計的(python實現）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d7f6ac99.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你的redis分佈式可重入鎖是怎麼設計的(python實現）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-center-line>基本概念</h1><p><br></p><ul><li>分佈式鎖</li></ul><p><br></p><p>分佈式鎖是控制分佈式系統之間同步訪問共享資源的一種方式。在分佈式系統中，常常需要協調他們的動作。如果不同的系統或是同一個系統的不同主機之間共享了一個或一組資源，那麼訪問這些資源的時候，往往需要互斥來防止彼此干擾來保證一致性，在這種情況下，便需要使用到分佈式鎖。</p><p>分佈式鎖一般有三種實現方式：1. 數據庫樂觀鎖；2. 基於Redis的分佈式鎖；3. 基於ZooKeeper的分佈式鎖。本文主要介紹基於redis方式。</p><p><br></p><ul><li>可重入</li></ul><p><br></p><p>可重入鎖指的是同一線程中可重複可遞歸調用的鎖，在外層使用鎖之後，在內層仍然可以使用，如果沒有可重入鎖的支持，在第二次嘗試獲得鎖時將會進入死鎖狀態。</p><p>可重入鎖的要點是對於同一線程可以多次獲取鎖，不同線程之間同一把鎖不能重複獲取，因此理論上需要保存鎖擁有者的線程標識。在Java和python中都可以用 threadlocal變量同來同步同一線程之間的資源。</p><p><br></p><h1 class=pgc-h-center-line>分佈式鎖設計要點</h1><p><br></p><p>一個完整的分佈式鎖，需要滿足以下幾個條件：</p><ul><li>互斥性。在任意時刻，只有一個客戶端能持有鎖。</li><li>不會發生死鎖。即使有一個客戶端在持有鎖的期間崩潰而沒有主動解鎖，也能保證後續其他客戶端能加鎖。這就要求必須為鎖加上超時時間。</li><li>具有容錯性。只要大部分的Redis節點正常運行，客戶端就可以加鎖和解鎖。這點是要求必須能夠保證相關操作的原子性。</li><li>解鈴還須繫鈴人。加鎖和解鎖必須是同一個客戶端，客戶端自己不能把別人加的鎖給解了。這就要求每把鎖必須有自己的標識，在解鎖時通過判斷標識來保證是釋放的自己的鎖。</li></ul><p><br></p><h1 class=pgc-h-center-line>代碼實現</h1><p><br></p><p>Talk is cheap, show me the code。下面是一個分佈式鎖的基本實現：</p><pre><code>class DistributedLock(object):    """    This is not a 100% reliable distributed lock implementation. It is a try best one.    And this distributed lock algorithm is based on the time synchronization between    each node.    But it should be enough for our project.    """​    def __init__(self, lock_name, expire_time=3):        self.name = lock_name + '_distributed_lock'        self.expire_time = expire_time        self.uuid = str(uuid.uuid4())​    @redis_exc    def __enter__(self):        """        If driver is not redis, nothing will happen.        """        redis_conn = driver_manager.get_global_redis_conn()        while True:            if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1:                LOG.debug('Get lock %s' % self.name)                break            LOG.debug('Sleep 0.1s to try to get lock %s' % self.name)            time.sleep(0.1)        return self​    @redis_exc    def __exit__(self, exc_type, exc_val, exc_tb):        redis_conn = driver_manager.get_global_redis_conn()        owner_id = redis_conn.get(self.name)        if owner_id == self.uuid:            redis_conn.delete(self.name)            LOG.debug('Release lock %s' % self.name)        else:            LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name)        return</code></pre><p><br></p><p>可以看到，我們加鎖就一行代碼：redis_conn.set(self.name, self.uuid, ex=self.expire_time, nx=True)，這個set()方法一共有五個形參：</p><ul><li>第一個為key，表示鎖的唯一性標識。</li><li>第二個為value，我們傳的是uuid，很多童鞋可能不明白，有key作為鎖不就夠了嗎，為什麼還要用到value？原因就是我們在上面講到可靠性時，分佈式鎖要滿足第四個條件解鈴還須繫鈴人，通過給value賦值為uuid，我們就知道這把鎖是哪個請求加的了，在解鎖的時候就可以有依據。</li><li>第三個表示鎖的過期時間，如果程序發生意外沒有及時解鎖，也能保證在超時後其他請求能夠正常加鎖</li><li>第四個nx=True，意思是SET IF NOT EXIST，即當key不存在時，我們進行set操作；若key已經存在，則不做任何操作；</li></ul><p>總的來說，執行上面的set()方法就只會導致兩種結果：1. 當前沒有鎖（key不存在），那麼就進行加鎖操作，並對鎖設置個有效期，同時value表示加鎖的客戶端。2. 已有鎖存在，不做任何操作。</p><p>心細的童鞋就會發現了，我們的加鎖代碼滿足我們可靠性裡描述的三個條件。首先，set()加入了NX參數，可以保證如果已有key存在，則函數不會調用成功，也就是隻有一個客戶端能持有鎖，滿足互斥性。其次，由於我們對鎖設置了過期時間，即使鎖的持有者後續發生崩潰而沒有解鎖，鎖也會因為到了過期時間而自動解鎖（即key被刪除），不會發生死鎖。最後，因為我們將value賦值為uuid，代表加鎖的客戶端請求標識，那麼在客戶端在解鎖的時候就可以進行校驗。</p><p>上面分佈式鎖解鎖階段分了兩步，先獲取鎖的owner_id，然後根據owner_id進行解鎖判斷，實際上，一般推薦的都是將兩步操作原子化，使用LUA腳本進行執行，此處暫時未對此做相應優化。</p><p><br></p><h1 class=pgc-h-center-line>分佈式鎖支持可重入</h1><p><br></p><p>上面介紹了一個完整的基於redis的分佈式鎖python實現版本和思路，在實際場景中，對同一個線程或者協程的同一把鎖需要支持可重入，如遞歸調用時不發生死鎖，下面實現版本在上述的分佈式鎖中進行了相關代碼修改。</p><pre><code>_request_store = threading.local()​​def _add_locker_info(lock_name, owner_uuid):    setattr(_request_store, lock_name, owner_uuid)​​def _get_locker_info(lock_name):    return getattr(_request_store, lock_name, None)​​class DistributedLock(object):    """    This is not a 100% reliable distributed lock implementation. It is a try best one.    And this distributed lock algorithm is based on the time synchronization between    each node.    But it should be enough for our project.    """​    def __init__(self, lock_name, expire_time=3):        self.name = lock_name + '_distributed_lock'        self.expire_time = expire_time        self.uuid = str(uuid.uuid4())​    @redis_exc    def __enter__(self):        """        If driver is not redis, nothing will happen.        """        redis_conn = driver_manager.get_global_redis_conn()        while True:            if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1:                _add_locker_info(self.name, self.uuid)                LOG.debug('Get lock %s' % self.name)                break            if _get_locker_info(self.name):                LOG.debug('Get re-entrant lock %s' % self.name)                break            LOG.debug('Sleep 0.1s to try to get lock %s' % self.name)            time.sleep(0.1)        return self​    @redis_exc    def __exit__(self, exc_type, exc_val, exc_tb):        redis_conn = driver_manager.get_global_redis_conn()        owner_id = redis_conn.get(self.name)        if owner_id == self.uuid:            redis_conn.delete(self.name)            LOG.debug('Release lock %s' % self.name)        elif owner_id == _get_locker_info(self.name):            LOG.debug('Quit from re-entrant lock %s, do nothing ' % self.name)        else:            LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name)        return</code></pre><p>python 的threadlocal變量和Java中類似，對同一個線程中的變量進行隔離，因此對可重入鎖的支持只需要判斷下當前線程中是否已經有這把鎖，如果有，則直接返回，否則進行等待鎖釋放或者超時。</p><p><br></p><h1 class=pgc-h-center-line>注意點</h1><p><br></p><ul><li>threadlocal中的內存不主動釋放，會不會內存洩漏？</li></ul><p>不會，因為每個線程對應一個副本字典，當在該線程中 獲取、設置、刪除 ThreadLocal對象的屬性時，會先通過_patch函數，將線程的副本字典，設置成ThreadLocal對象的屬性字典，然後對ThreadLocal對象的屬性的操作，實際上就是對副本字典的操作。當線程結束，線程對象被銷燬時，副本字典的引用計數也會隨之減少，最後被GC掉。</p><ul><li>可重入鎖的counter計數</li></ul><p>一般的設計中都會對可重入鎖維護一個counter計數，也就是在counter小於等於0時進行釋放，由於考慮到自增自減操作的非原子性，沒有通過counter值進行鎖釋放，而是採用誰一開始創建鎖，就最後刪除鎖。可重入鎖的多次重入表現為堆棧，後入先出，也就是說有一開始加鎖的對象進行鎖刪除即可。</p><ul><li>關於threadlocal的線程隔離</li></ul><p>很多情況下都是在同一個進程中起不同的協程去處理API請求，也就是說不同的API請求是有可能在同一個線程中的，實際測試也驗證了這一點。如下打印的日誌，總共有三次API請求，但是線程號是一樣的。</p><pre><code>class DistributedLock(object):   """  This is not a 100% reliable distributed lock implementation. It is a try best one.  And this distributed lock algorithm is based on the time synchronization between  each node.  But it should be enough for our project.  """   def __init__(self, lock_name, expire_time=3):       self.name = lock_name + '_distributed_lock'       self.expire_time = expire_time       self.uuid = str(uuid.uuid4())   @redis_exc   def __enter__(self):       """      If driver is not redis, nothing will happen.      """       redis_conn = driver_manager.get_global_redis_conn()       while True:           if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1:               LOG.debug('Get lock %s' % self.name)               break           LOG.debug('Sleep 0.1s to try to get lock %s' % self.name)           time.sleep(0.1)       return self   @redis_exc   def __exit__(self, exc_type, exc_val, exc_tb):       redis_conn = driver_manager.get_global_redis_conn()       owner_id = redis_conn.get(self.name)       if owner_id == self.uuid:           redis_conn.delete(self.name)           LOG.debug('Release lock %s' % self.name)       else:           LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name)       return</code></pre><p>如果從線程出發，threadlocal的表現應該是在同一個線程內數據共享，如果沒有主動刪除數據，則在線程消亡時釋放內存。由於在加鎖和解鎖時並沒有主動刪除threadlocal中的數據，也就是說同一個線程中的數據應該是會累加的，但是實際上沒有，日誌如下：</p><pre><code>2020-05-14 08:29:06.808 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-7abbea26-d87b-4804-8003-36b723471c6e 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': '7ccfe267-6fce-4ada-9b88-c85de4da8f76', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '073547c0-53d1-477d-ae64-d41dfe992d5b'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.006 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.122 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '32eb9ab3-7e54-4439-bbd0-1ee183aac29d'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.199 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'e840a917-c2d5-414a-8ad1-a9965d654e12_vgw01_distributed_lock': 'b5b14883-9786-484a-860c-82a1a5672744', 'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '32eb9ab3-7e54-4439-bbd0-1ee183aac29d'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:42:33.291 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-4bfc56b5-c3db-4288-a1c3-a993bcf7a3a3 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'fa7ed1b1-a9dc-416b-8419-3043a1c92100'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:42:33.424 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-4bfc56b5-c3db-4288-a1c3-a993bcf7a3a3 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'e840a917-c2d5-414a-8ad1-a9965d654e12_vgw01_distributed_lock': '67741a6a-b89b-4c7f-ad4e-9ae40455f20a', 'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'fa7ed1b1-a9dc-416b-8419-3043a1c92100'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:104</code></pre><p><strong>threadlocal協程隔離</strong></p><p>表現的行為是協程隔離，也就是說兩個API請求雖然處於同一個線程內，但是並沒有共享threadlocal的數據。</p><p>通過定位後發現在項目的eventlet模塊中對通過monkey_patch方式對原生的threading.local進行了改寫，在原生的threading.local 通過如下的函數獲取當前的線程號</p><pre><code>def currentThread():    """Return the current Thread object, corresponding to the caller's thread of control.​    If the caller's thread of control was not created through the threading    module, a dummy thread object with limited functionality is returned.​    """    try:        return _active[_get_ident()]    except KeyError:        ##print "current_thread(): no current thread for", _get_ident()        return _DummyThread()# 獲取線程號函數        _get_ident = thread.get_ident</code></pre><p>在eventlet庫中對該函數進行了改寫，函數currentThread獲取到的是協程號，如下：</p><pre><code>def current_thread():    g = greenlet.getcurrent()    if not g:        # Not currently in a greenthread, fall back to standard function        return _fixup_thread(__orig_threading.current_thread())​    try:        active = __threadlocal.active    except AttributeError:        active = __threadlocal.active = {}​    try:        t = active[id(g)]    except KeyError:        # Add green thread to active if we can clean it up on exit        def cleanup(g):            del active[id(g)]        try:            g.link(cleanup)        except AttributeError:            # Not a GreenThread type, so there's no way to hook into            # the green thread exiting. Fall back to the standard            # function then.            t = _fixup_thread(__orig_threading.currentThread())        else:            t = active[id(g)] = _GreenThread(g)​    return t</code></pre><p>最終調用的如下greenlet庫中的getcurrent獲取當前協程標識</p><pre><code> greenlet.getcurrent() 　　Returns the current greenlet (i.e. the one which called this function).　　返回當前greenlet，也就是誰在調用這個函數。</code></pre><p>相關patch函數在/neutron/common/eventlet_utils.py。</p><p><br></p><h1 class=pgc-h-center-line>附錄：python threading.RLock源碼</h1><p><br></p><pre><code>_allocate_lock = thread.allocate_lock_get_ident = thread.get_identLock = _allocate_lock​def RLock(*args, **kwargs):    """Factory function that returns a new reentrant lock.​    A reentrant lock must be released by the thread that acquired it. Once a    thread has acquired a reentrant lock, the same thread may acquire it again    without blocking; the thread must release it once for each time it has    acquired it.​    """    return _RLock(*args, **kwargs)​class _RLock(_Verbose):    """A reentrant lock must be released by the thread that acquired it. Once a       thread has acquired a reentrant lock, the same thread may acquire it       again without blocking; the thread must release it once for each time it       has acquired it.    """​    def __init__(self, verbose=None):        _Verbose.__init__(self, verbose)        self.__block = _allocate_lock()        self.__owner = None        self.__count = 0​    def __repr__(self):        owner = self.__owner        try:            owner = _active[owner].name        except KeyError:            pass        return "&lt;%s owner=%r count=%d&gt;" % (                self.__class__.__name__, owner, self.__count)​    def acquire(self, blocking=1):        """Acquire a lock, blocking or non-blocking.​        When invoked without arguments: if this thread already owns the lock,        increment the recursion level by one, and return immediately. Otherwise,        if another thread owns the lock, block until the lock is unlocked. Once        the lock is unlocked (not owned by any thread), then grab ownership, set        the recursion level to one, and return. If more than one thread is        blocked waiting until the lock is unlocked, only one at a time will be        able to grab ownership of the lock. There is no return value in this        case.​        When invoked with the blocking argument set to true, do the same thing        as when called without arguments, and return true.​        When invoked with the blocking argument set to false, do not block. If a        call without an argument would block, return false immediately;        otherwise, do the same thing as when called without arguments, and        return true.​        """        me = _get_ident()        if self.__owner == me:            self.__count = self.__count + 1            if __debug__:                self._note("%s.acquire(%s): recursive success", self, blocking)            return 1        rc = self.__block.acquire(blocking)        if rc:            self.__owner = me            self.__count = 1            if __debug__:                self._note("%s.acquire(%s): initial success", self, blocking)        else:            if __debug__:                self._note("%s.acquire(%s): failure", self, blocking)        return rc​    __enter__ = acquire​    def release(self):        """Release a lock, decrementing the recursion level.​        If after the decrement it is zero, reset the lock to unlocked (not owned        by any thread), and if any other threads are blocked waiting for the        lock to become unlocked, allow exactly one of them to proceed. If after        the decrement the recursion level is still nonzero, the lock remains        locked and owned by the calling thread.​        Only call this method when the calling thread owns the lock. A        RuntimeError is raised if this method is called when the lock is        unlocked.​        There is no return value.​        """        if self.__owner != _get_ident():            raise RuntimeError("cannot release un-acquired lock")        self.__count = count = self.__count - 1        if not count:            self.__owner = None            self.__block.release()            if __debug__:                self._note("%s.release(): final release", self)        else:            if __debug__:                self._note("%s.release(): non-final release", self)​    def __exit__(self, t, v, tb):        self.release()​    # Internal methods used by condition variables​    def _acquire_restore(self, count_owner):        count, owner = count_owner        self.__block.acquire()        self.__count = count        self.__owner = owner        if __debug__:            self._note("%s._acquire_restore()", self)​    def _release_save(self):        if __debug__:            self._note("%s._release_save()", self)        count = self.__count        self.__count = 0        owner = self.__owner        self.__owner = None        self.__block.release()        return (count, owner)​    def _is_owned(self):        return self.__owner == _get_ident()</code></pre><p><br></p><ul><li>簡單分析</li></ul><p>python源碼中的可重入鎖相對簡單，加鎖部分，第一次獲取鎖時保存鎖的線程標識，後續再次獲取鎖，先看是否是同一個線程，如果是的話只對鎖計數進行遞增。解鎖時，對鎖計數進行遞減，如果計數為0，最終釋放鎖。</p><p>需要注意的是需要先初始化類，後續加鎖解鎖都應使用同一個對象，而不能每次加鎖和解鎖使用新的RLock對象，這樣會導致owner信息和count信息沒有初始化。這個問題本質上是線程變量同步的問題。</p><p><br></p><h1 class=pgc-h-center-line>參考文檔</h1><ul><li>https://www.cnblogs.com/linjiqin/p/8003838.html</li><li>https://segmentfault.com/a/1190000021199037</li><li>https://github.com/yangfeixxx/python_redis</li><li>https://leaveslm.github.io/2018/08/08/2018-2018-08-08-基於-Redis-實現可重入分佈式鎖/</li><li>https://www.cnblogs.com/xybaby/p/6420873.html</li></ul><p><br></p><div class=pgc-img><img alt=你的redis分佈式可重入鎖是怎麼設計的(python實現） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19325eb39de0464e81ae82d3555d1126><p class=pgc-img-caption>關於微信有更多精彩</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>redis</a></li><li><a>重入鎖</a></li><li><a>怎麼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2146c4b1.html alt=露天樓梯雨棚怎麼做 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R6XWzD87AaIs0W style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2146c4b1.html title=露天樓梯雨棚怎麼做>露天樓梯雨棚怎麼做</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a2e003a.html alt=你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cc30aa4b32114cb7aa98314ba1519473 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a2e003a.html title=你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力>你是怎麼認識曼恩的？在老路說車互動平臺感受曼恩魅力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f24146de.html alt=怎麼租用服務器，哪種建站最好？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/52874987-e2c8-4404-99f4-38f53bad4aec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f24146de.html title=怎麼租用服務器，哪種建站最好？>怎麼租用服務器，哪種建站最好？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b4b1f22.html alt=無人機怎麼做測繪？手把手教你高精度地圖和數字線畫圖的具體操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/479ff6260a5545549cb39946a5cbbd91 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b4b1f22.html title=無人機怎麼做測繪？手把手教你高精度地圖和數字線畫圖的具體操作>無人機怎麼做測繪？手把手教你高精度地圖和數字線畫圖的具體操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0c52137.html alt=作文裡面怎麼進行場面描寫？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/230976bf-ee1d-44c0-8ce9-4a4714b8ad40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0c52137.html title=作文裡面怎麼進行場面描寫？>作文裡面怎麼進行場面描寫？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/40568794.html alt=手機接收不到驗證碼怎麼辦？教你快速解決，學會以備不時之需 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5edf6bf6494e4d2799657427beba8616 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/40568794.html title=手機接收不到驗證碼怎麼辦？教你快速解決，學會以備不時之需>手機接收不到驗證碼怎麼辦？教你快速解決，學會以備不時之需</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed39a73b.html alt=手機收不到短信怎麼回事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4c867ab694d54b19954e5777769cc540 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed39a73b.html title=手機收不到短信怎麼回事>手機收不到短信怎麼回事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a0039e6.html alt=手機收不到短信驗證碼怎麼回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7cd7583238d44cfeb3be6147f9417125 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a0039e6.html title=手機收不到短信驗證碼怎麼回事？>手機收不到短信驗證碼怎麼回事？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b61d16fd.html alt=手機經常收不到消息是怎麼回事？看完你就知道怎麼是什麼原因了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/53f300040692811299c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b61d16fd.html title=手機經常收不到消息是怎麼回事？看完你就知道怎麼是什麼原因了！>手機經常收不到消息是怎麼回事？看完你就知道怎麼是什麼原因了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9f02601.html alt=教你怎麼計算光模塊和光纖跳線數量，學會這個方法，以後不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1bb69fa9b57247babf32efd4a040a7f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9f02601.html title=教你怎麼計算光模塊和光纖跳線數量，學會這個方法，以後不求人>教你怎麼計算光模塊和光纖跳線數量，學會這個方法，以後不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/135c11db.html alt=知道手機基站是怎麼安裝的嗎？工藝有哪些要求 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3dc892aae9c74d6a80d6579347b13473 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/135c11db.html title=知道手機基站是怎麼安裝的嗎？工藝有哪些要求>知道手機基站是怎麼安裝的嗎？工藝有哪些要求</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d3b415c.html alt="招行掌上生活怎麼領取首刷禮技巧 領首刷禮條件流程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rh68nYy2e9LgVS style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d3b415c.html title="招行掌上生活怎麼領取首刷禮技巧 領首刷禮條件流程">招行掌上生活怎麼領取首刷禮技巧 領首刷禮條件流程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/81acd6e9.html alt="掌上生活怎麼領取拉桿箱 支持首刷禮拉桿箱卡種" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rh68nYy2e9LgVS style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/81acd6e9.html title="掌上生活怎麼領取拉桿箱 支持首刷禮拉桿箱卡種">掌上生活怎麼領取拉桿箱 支持首刷禮拉桿箱卡種</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html alt=「瞭解」房屋的層高和淨高怎麼算？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1526054178152a496189726 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html title=「瞭解」房屋的層高和淨高怎麼算？>「瞭解」房屋的層高和淨高怎麼算？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96fad265.html alt=樓房的層高和淨高是怎麼回事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96fad265.html title=樓房的層高和淨高是怎麼回事>樓房的層高和淨高是怎麼回事</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>