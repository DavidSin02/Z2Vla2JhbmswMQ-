<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「集合系列」- 深入淺出分析Collection中的List接口 | 极客快訊</title><meta property="og:title" content="「集合系列」- 深入淺出分析Collection中的List接口 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/592bdfb766d94ddcb9357373d4b2df2f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88578e6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88578e6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d88578e6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88578e6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88578e6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d88578e6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d88578e6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88578e6.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="「集合系列」- 深入淺出分析Collection中的List接口"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/d88578e6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「集合系列」- 深入淺出分析Collection中的List接口</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>在上一章《初探java集合框架圖》中，我相信大部分朋友對java容器整體架構都有了初步的瞭解，那麼本章主要是想詳細的介紹以下List接口實現類之間的區別！</p><h3 class=pgc-h-arrow-right>01、List簡介</h3><blockquote><p>List 的數據結構就是一個序列，存儲內容時直接在內存中開闢一塊連續的空間，然後將空間地址與索引對應。</p></blockquote><p>以下是List集合簡易架構圖</p><p><br></p><div class=pgc-img><img alt="「集合系列」- 深入淺出分析Collection中的List接口" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/592bdfb766d94ddcb9357373d4b2df2f><p class=pgc-img-caption></p></div><p><br></p><p>由圖中的繼承關係，可以知道，ArrayList、LinkedList、Vector、Stack都是List的四個實現類。</p><ul><li>AbstractCollection 是一個抽象類，它唯一實現Collection接口的類。AbstractCollection主要實現了toArray()、toArray(T[] a)、remove()等方法。</li><li>AbstractList 也是一個抽象類，它繼承於AbstractCollection。AbstractList實現List接口中除size()、get(int location)之外的函數，比如特定迭代器ListIterator。</li><li>AbstractSequentialList 是一個抽象類，它繼承於AbstractList。AbstractSequentialList 實現了“鏈表中，根據index索引值操作鏈表的全部函數”。</li><li>ArrayList 是一個動態數組，它由數組實現。隨機訪問效率高，隨機插入、隨機刪除效率低。</li><li>LinkedList 是一個雙向鏈表。它也可以被當作堆棧、隊列或雙端隊列進行操作。LinkedList隨機訪問效率低，但隨機插入、隨機刪除效率高。</li><li>Vector 也是一個動態數組，和ArrayList一樣，也是由數組實現。但是ArrayList是非線程安全的，而Vector是線程安全的。</li><li>Stack 是棧，它繼承於Vector。它的特性是：先進後出(FILO, First In Last Out)。</li></ul><p>下面對各個實現類進行方法剖析！</p><h3 class=pgc-h-arrow-right>02、ArrayList</h3><blockquote><p>ArrayList實現了List接口，也是順序容器，即元素存放的數據與放進去的順序相同，允許放入null元素，底層通過數組實現。 除該類未實現同步外，其餘跟Vector大致相同。</p></blockquote><p>在Java1.5之後，集合還提供了泛型，泛型只是編譯器提供的語法糖，方便編程，對程序不會有實質的影響。因為所有的類都默認繼承至Object，所以這裡的數組是一個Object數組，以便能夠容納任何類型的對象。</p><div class=pgc-img><img alt="「集合系列」- 深入淺出分析Collection中的List接口" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5235f92873244d60a3b4ef26077f33c8><p class=pgc-img-caption></p></div><p><strong>常用方法介紹</strong></p><h4 class=pgc-h-arrow-right>2.1、get方法</h4><p>get()方法同樣很簡單，先判斷傳入的下標是否越界，再獲取指定元素。</p><pre><code>public E get(int index) {        rangeCheck(index);        return elementData(index);}/** * 檢查傳入的index是否越界 */private void rangeCheck(int index) {        if (index &gt;= size)        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}</code></pre><h4 class=pgc-h-arrow-right>2.2、set方法</h4><p>set()方法也非常簡單，直接對數組的指定位置賦值即可。</p><pre><code>public E set(int index, E element) {        rangeCheck(index);        E oldValue = elementData(index);        elementData[index] = element;        return oldValue;}</code></pre><h4 class=pgc-h-arrow-right>2.3、add方法</h4><p>ArrayList添加元素有兩個方法，一個是add(E e)，另一個是add(int index, E e)。 這兩個方法都是向容器中添加新元素，可能會出現容量（capacity）不足，因此在添加元素之前，都需要進行剩餘空間檢查，如果需要則自動擴容。擴容操作最終是通過grow()方法完成的。</p><div class=pgc-img><img alt="「集合系列」- 深入淺出分析Collection中的List接口" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9791e63247194b1992e23343b209e83b><p class=pgc-img-caption></p></div><p><strong>grow方法實現</strong></p><pre><code>private void grow(int minCapacity) {        // overflow-conscious code        int oldCapacity = elementData.length;        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//原來的1.5倍        if (newCapacity - minCapacity &lt; 0)            newCapacity = minCapacity;        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)            newCapacity = hugeCapacity(minCapacity);        // minCapacity is usually close to size, so this is a win:        elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p>添加元素還有另外一個addAll()方法，addAll()方法能夠一次添加多個元素，根據位置不同也有兩個方法，一個是在末尾添加的addAll(Collection&lt;? extends E> c)方法，一個是從指定位置開始插入的addAll(int index, Collection&lt;? extends E> c)方法。</p><p><strong>不同點：addAll()的時間複雜度不僅跟插入元素的多少有關，也跟插入的位置相關，時間複雜度是線性增長！</strong></p><h4 class=pgc-h-arrow-right>2.4、remove方法</h4><p>remove()方法也有兩個版本，一個是remove(int index)刪除指定位置的元素；另一個是remove(Object o)，通過o.equals(elementData[index])來刪除第一個滿足的元素。</p><p>需要將刪除點之後的元素向前移動一個位置。需要注意的是為了讓GC起作用，必須顯式的為最後一個位置賦null值。</p><ul><li>remove(int index)方法</li></ul><pre><code>public E remove(int index) {        rangeCheck(index);        modCount++;        E oldValue = elementData(index);        int numMoved = size - index - 1;        if (numMoved &gt; 0)            System.arraycopy(elementData, index+1, elementData, index,                             numMoved);        elementData[--size] = null; //賦null值，方便GC回收        return oldValue;}</code></pre><ul><li>remove(Object o)方法</li></ul><pre><code>public boolean remove(Object o) {        if (o == null) {            for (int index = 0; index &lt; size; index++)                if (elementData[index] == null) {                    fastRemove(index);                    return true;                }        } else {            for (int index = 0; index &lt; size; index++)                if (o.equals(elementData[index])) {                    fastRemove(index);                    return true;                }        }        return false;}</code></pre><h3 class=pgc-h-arrow-right>03、LinkedList</h3><blockquote><p>在上篇文章中，我們知道LinkedList同時實現了List接口和Deque接口，也就是說它既可以看作一個順序容器，又可以看作一個隊列（Queue），同時又可以看作一個棧（Stack）。</p></blockquote><p>LinkedList底層通過雙向鏈表實現，通過first和last引用分別指向鏈表的第一個和最後一個元素，注意這裡沒有所謂的啞元（某個參數如果在子程序或函數中沒有用到，那就被稱為啞元），當鏈表為空的時候first和last都指向null。</p><div class=pgc-img><img alt="「集合系列」- 深入淺出分析Collection中的List接口" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f724697342be445fbcff235127c6da3c><p class=pgc-img-caption></p></div><pre><code>public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable{	 /**容量*/    transient int size = 0;    /**鏈表第一個元素*/    transient Node&lt;E&gt; first;     /**鏈表最後一個元素*/    transient Node&lt;E&gt; last;		......}</code></pre><pre><code>/** * 內部類Node */private static class Node&lt;E&gt; {    E item;//元素    Node&lt;E&gt; next;//後繼    Node&lt;E&gt; prev;//前驅    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {        this.item = element;        this.next = next;        this.prev = prev;    }}</code></pre><p><strong>常用方法介紹</strong></p><h4 class=pgc-h-arrow-right>3.1、get方法</h4><p>get()方法同樣很簡單，先判斷傳入的下標是否越界，再獲取指定元素。</p><pre><code>public E get(int index) {        checkElementIndex(index);        return node(index).item;}/** * 檢查傳入的index是否越界 */private void checkElementIndex(int index) {        if (!isElementIndex(index))            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));}</code></pre><h4 class=pgc-h-arrow-right>3.2、set方法</h4><p>set(int index, E element)方法將指定下標處的元素修改成指定值，也是先通過node(int index)找到對應下表元素的引用，然後修改Node中item的值。</p><pre><code>public E set(int index, E element) {        checkElementIndex(index);        Node&lt;E&gt; x = node(index);        E oldVal = x.item;        x.item = element;        return oldVal;}</code></pre><h4 class=pgc-h-arrow-right>3.3、add方法</h4><p>同樣的，add()方法有兩方法，一個是add(E e)，另一個是add(int index, E element)。</p><div class=pgc-img><img alt="「集合系列」- 深入淺出分析Collection中的List接口" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6b034820cd31459698c4849b3c13c435><p class=pgc-img-caption></p></div><ul><li>add(E e)方法</li></ul><p>該方法在LinkedList的末尾插入元素，因為有last指向鏈表末尾，在末尾插入元素的花費是常數時間，只需要簡單修改幾個相關引用即可。</p><pre><code>public boolean add(E e) {        linkLast(e);        return true;}/** * 添加元素 */void linkLast(E e) {        final Node&lt;E&gt; l = last;        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);        last = newNode;        if (l == null)			//原來鏈表為空，這是插入的第一個元素            first = newNode;        else            l.next = newNode;        size++;        modCount++;}</code></pre><ul><li>add(int index, E element)方法</li></ul><p>該方法是在指定下表處插入元素，需要先通過線性查找找到具體位置，然後修改相關引用完成插入操作。</p><p>具體分成兩步，1.先根據index找到要插入的位置；2.修改引用，完成插入操作。</p><pre><code>public void add(int index, E element) {        checkPositionIndex(index);        if (index == size)			//調用add方法，直接在末尾添加元素            linkLast(element);        else			//根據index找到要插入的位置            linkBefore(element, node(index));}/** * 插入位置 */void linkBefore(E e, Node&lt;E&gt; succ) {        // assert succ != null;        final Node&lt;E&gt; pred = succ.prev;        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);        succ.prev = newNode;        if (pred == null)            first = newNode;        else            pred.next = newNode;        size++;        modCount++;}</code></pre><p>同樣的，添加元素還有另外一個addAll()方法，addAll()方法能夠一次添加多個元素，根據位置不同也有兩個方法，一個是在末尾添加的addAll(Collection&lt;? extends E> c)方法，另一個是從指定位置開始插入的addAll(int index, Collection&lt;? extends E> c)方法。</p><p>裡面也for循環添加元素，<strong>addAll()的時間複雜度不僅跟插入元素的多少有關，也跟插入的位置相關，時間複雜度是線性增長！</strong></p><h4 class=pgc-h-arrow-right>3.4、remove方法</h4><p>同樣的，remove()方法也有兩個方法，一個是刪除指定下標處的元素remove(int index)，另一個是刪除跟指定元素相等的第一個元素remove(Object o)。</p><div class=pgc-img><img alt="「集合系列」- 深入淺出分析Collection中的List接口" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/26e8780da21d4624b7a729667d04bc88><p class=pgc-img-caption></p></div><p>兩個刪除操作都是，<strong>1.先找到要刪除元素的引用；2.修改相關引用，完成刪除操作</strong>。</p><ul><li>remove(int index)方法</li></ul><p>通過下表，找到對應的節點，然後將其刪除</p><pre><code>public E remove(int index) {        checkElementIndex(index);        return unlink(node(index));}</code></pre><ul><li>remove(Object o)方法</li></ul><p>通過equals判斷找到對應的節點，然後將其刪除</p><pre><code>public boolean remove(Object o) {        if (o == null) {            for (Node&lt;E&gt; x = first; x != null; x = x.next) {                if (x.item == null) {                    unlink(x);                    return true;                }            }        } else {            for (Node&lt;E&gt; x = first; x != null; x = x.next) {                if (o.equals(x.item)) {                    unlink(x);                    return true;                }            }        }        return false;}</code></pre><p>刪除操作都是通過unlink(Node&lt;E> x)方法完成的。這裡需要考慮刪除元素是第一個或者最後一個時的邊界情況。</p><pre><code>/** * 刪除一個Node節點方法 */E unlink(Node&lt;E&gt; x) {        // assert x != null;        final E element = x.item;        final Node&lt;E&gt; next = x.next;        final Node&lt;E&gt; prev = x.prev;				//刪除的是第一個元素        if (prev == null) {            first = next;        } else {            prev.next = next;            x.prev = null;        }		//刪除的是最後一個元素        if (next == null) {            last = prev;        } else {            next.prev = prev;            x.next = null;        }        x.item = null;        size--;        modCount++;        return element;}</code></pre><h3 class=pgc-h-arrow-right>04、Vector</h3><p>Vector類屬於一個挽救的子類，早在jdk1.0的時候，就已經存在此類，但是到了jdk1.2之後重點強調了集合的概念，所以，先後定義了很多新的接口，比如ArrayList、LinkedList，但考慮到早期大部分已經習慣使用Vector類，所以，為了兼容性，java的設計者，就讓Vector多實現了一個List接口，這才將其保留下來。</p><p>在使用方面，Vector的get、set、add、remove方法實現，與ArrayList基本相同，不同的是Vector在方法上加了線程同步鎖synchronized，所以，執行效率方面，會比較慢！</p><h4 class=pgc-h-arrow-right>4.1、get方法</h4><pre><code>public synchronized E get(int index) {        if (index &gt;= elementCount)            throw new ArrayIndexOutOfBoundsException(index);        return elementData(index);}</code></pre><h4 class=pgc-h-arrow-right>4.2、set方法</h4><pre><code>public synchronized E set(int index, E element) {        if (index &gt;= elementCount)            throw new ArrayIndexOutOfBoundsException(index);        E oldValue = elementData(index);        elementData[index] = element;        return oldValue;}</code></pre><h4 class=pgc-h-arrow-right>4.3、add方法</h4><pre><code>public synchronized boolean add(E e) {        modCount++;        ensureCapacityHelper(elementCount + 1);        elementData[elementCount++] = e;        return true;}</code></pre><h4 class=pgc-h-arrow-right>4.4、remove方法</h4><pre><code>public synchronized boolean removeElement(Object obj) {        modCount++;        int i = indexOf(obj);        if (i &gt;= 0) {            removeElementAt(i);            return true;        }        return false;}</code></pre><h3 class=pgc-h-arrow-right>05、Stack</h3><p>在 Java 中 Stack 類表示後進先出（LIFO）的對象堆棧。棧是一種非常常見的數據結構，它採用典型的先進後出的操作方式完成的；<strong>在現實生活中，手槍彈夾的子彈就是一個典型的後進先出的結構。</strong></p><p>在使用方面，主要方法有push 、peek 、pop 。</p><h4 class=pgc-h-arrow-right>5.1、push方法</h4><p>push方法表示，向棧中添加元素</p><pre><code>public E push(E item) {        addElement(item);        return item;}</code></pre><h4 class=pgc-h-arrow-right>5.2、peek方法</h4><p>peek方法表示，查看棧頂部的對象，但不從棧中移除它</p><pre><code>public synchronized E peek() {        int     len = size();        if (len == 0)            throw new EmptyStackException();        return elementAt(len - 1);}</code></pre><h4 class=pgc-h-arrow-right>5.3、pop方法</h4><p>pop方法表示，移除元素，並將要移除的元素方法</p><pre><code>  public synchronized E pop() {        E       obj;        int     len = size();        obj = peek();        removeElementAt(len - 1);        return obj;}</code></pre><p>關於 Java 中 Stack 類，有很多的質疑聲，棧更適合用隊列結構來實現，這使得Stack在設計上不嚴謹，因此，官方推薦使用Deque下的類來是實現棧！</p><h3 class=pgc-h-arrow-right>06、總結</h3><div class=pgc-img><img alt="「集合系列」- 深入淺出分析Collection中的List接口" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d41473c440f64e35a94c86708e5bf79c><p class=pgc-img-caption></p></div><ul><li><strong>ArrayList(動態數組結構)，查詢快（隨意訪問或順序訪問），增刪慢，但在末尾插入，速度與LinkedList相差無幾！</strong></li><li><strong>LinkedList（雙向鏈表結構），查詢慢，增刪快！</strong></li><li><strong>Vector（動態數組結構），相比ArrayList都慢，被ArrayList替代，基本不在使用。優勢是線程安全（函數都是synchronized），如果需要在多線程下使用，推薦使用併發容器中的工具類來操作，效率高！</strong></li><li><strong>Stack（棧結構）繼承於Vector，數據是先進後出，基本不在使用，如果要實現棧，推薦使用Deque下的ArrayDeque，效率比Stack高！</strong></li></ul><h3 class=pgc-h-arrow-right>07、參考</h3><p>1、JDK1.7&JDK1.8 源碼</p><p>2、CarpenterLee - Java集合分析</p><p>3、博客園 - 朽木 - ArrayList、LinkedList、Vector、Stack的比較</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>淺出</a></li><li><a>Collection</a></li><li><a>List</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d3b937d.html alt=Collection子接口：List接口詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d3b937d.html title=Collection子接口：List接口詳解>Collection子接口：List接口詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e18864df.html alt=深入淺出西門子PLC連載一：西門子S7-300/400通信功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d2fa4bebce394c979e42408cab824fdb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e18864df.html title=深入淺出西門子PLC連載一：西門子S7-300/400通信功能>深入淺出西門子PLC連載一：西門子S7-300/400通信功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a088204c.html alt="段永平：最重要的是Stop doing List——發現錯就要停" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153959939786341e7021985 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a088204c.html title="段永平：最重要的是Stop doing List——發現錯就要停">段永平：最重要的是Stop doing List——發現錯就要停</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86bb40ab.html alt=深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RFHu4Sf9eDhDDd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86bb40ab.html title=深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸>深入淺出聊聊相干光通信（上）看看中長距如何實現400G傳輸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b87553dc.html alt=LevelDB深入淺出之整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/125e826e651c48c3911abad6c8d076c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b87553dc.html title=LevelDB深入淺出之整體架構>LevelDB深入淺出之整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/470d0ef7.html alt=如何充分利用多核CPU，計算很大的List中所有整數的和 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5f031909ec724f89918149df43f7977c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/470d0ef7.html title=如何充分利用多核CPU，計算很大的List中所有整數的和>如何充分利用多核CPU，計算很大的List中所有整數的和</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37add9f2.html alt=深入淺出人工智能前沿技術—機器視覺檢測，看清人類智慧工業 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f5ea93dc2cb2482296f29e57b56ea652 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37add9f2.html title=深入淺出人工智能前沿技術—機器視覺檢測，看清人類智慧工業>深入淺出人工智能前沿技術—機器視覺檢測，看清人類智慧工業</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a2942388.html alt="Collection 和 Collections的區別" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aafaef9dc83343998aeeb9bff36af9c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a2942388.html title="Collection 和 Collections的區別">Collection 和 Collections的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8cae3b4.html alt=Collection子接口：Set接口詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8cae3b4.html title=Collection子接口：Set接口詳解>Collection子接口：Set接口詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4539721.html alt=Collection接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4539721.html title=Collection接口>Collection接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a0ff0f5.html alt=Collection接口的四個類及實例方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1523158664337c5c7bb8a02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a0ff0f5.html title=Collection接口的四個類及實例方法>Collection接口的四個類及實例方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6ca1002.html alt=Java中Collection集合ArrayList和HashSet的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6ca1002.html title=Java中Collection集合ArrayList和HashSet的使用>Java中Collection集合ArrayList和HashSet的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfca9a6c.html alt=Java中的List和ListIterator的詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfca9a6c.html title=Java中的List和ListIterator的詳解>Java中的List和ListIterator的詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html alt=Java集合-Collection class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html title=Java集合-Collection>Java集合-Collection</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>