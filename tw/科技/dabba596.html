<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一個HashMap能跟面試官扯上半個小時 | 极客快訊</title><meta property="og:title" content="一個HashMap能跟面試官扯上半個小時 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3c09bf1ad1b54adaab3db4be30c10c8b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dabba596.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dabba596.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dabba596.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dabba596.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dabba596.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dabba596.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dabba596.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dabba596.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="一個HashMap能跟面試官扯上半個小時"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/dabba596.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一個HashMap能跟面試官扯上半個小時</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p>HashMap應該算是Java後端工程師面試的必問題，因為其中的知識點太多，很適合用來考察面試者的Java基礎。</p><h1 class=pgc-h-arrow-right>開場</h1><p><strong>面試官</strong>: 你先自我介紹一下吧！</p><p><strong>安琪拉</strong>: 我是安琪拉，草叢三婊之一，最強中單（鍾馗不服）！哦，不對，串場了，我是**，目前在--公司做--系統開發。</p><p><strong>面試官</strong>: 看你簡歷上寫熟悉Java集合，HashMap用過的吧？</p><p><strong>安琪拉</strong>: 用過的。(還是熟悉的味道)</p><p><strong>面試官</strong>: 那你跟我講講HashMap的內部數據結構？</p><p><strong>安琪拉</strong>: 目前我用的是JDK1.8版本的，內部使用數組 + 鏈表紅黑樹；</p><p><strong>安琪拉</strong>: 方便我給您畫個數據結構圖吧：</p><p><br></p><div class=pgc-img><img alt=一個HashMap能跟面試官扯上半個小時 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3c09bf1ad1b54adaab3db4be30c10c8b><p class=pgc-img-caption></p></div><p><br></p><p><strong>面試官</strong>: 那你清楚HashMap的數據插入原理嗎？</p><p><strong>安琪拉</strong>: 呃[做沉思狀]。我覺得還是應該畫個圖比較清楚，如下：</p><p><br></p><div class=pgc-img><img alt=一個HashMap能跟面試官扯上半個小時 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d28c16f889194efa9787d188b9b67556><p class=pgc-img-caption></p></div><p><br></p><ol start=1><li>判斷數組是否為空，為空進行初始化;</li><li>不為空，計算 k 的 hash 值，通過(n - 1) & hash計算應當存放在數組中的下標 index;</li><li>查看 table[index] 是否存在數據，沒有數據就構造一個Node節點存放在 table[index] 中；</li><li>存在數據，說明發生了hash衝突(存在二個節點key的hash值一樣), 繼續判斷key是否相等，相等，用新的value替換原數據(onlyIfAbsent為false)；</li><li>如果不相等，判斷當前節點類型是不是樹型節點，如果是樹型節點，創造樹型節點插入紅黑樹中；</li><li>如果不是樹型節點，創建普通Node加入鏈表中；判斷鏈表長度是否大於 8， 大於的話鏈表轉換為紅黑樹；</li><li>插入完成之後判斷當前節點數是否大於閾值，如果大於開始擴容為原數組的二倍。</li></ol><p><strong>面試官</strong>: 剛才你提到HashMap的初始化，那HashMap怎麼設定初始容量大小的嗎？</p><p><strong>安琪拉</strong>: [這也算問題？?] 一般如果new HashMap() 不傳值，默認大小是16，負載因子是0.75， 如果自己傳入初始大小k，初始化大小為 大於k的 2的整數次方，例如如果傳10，大小為16。（補充說明:實現代碼如下）</p><pre><code>static final int tableSizeFor(int cap) {  int n = cap - 1;  n |= n &gt;&gt;&gt; 1;  n |= n &gt;&gt;&gt; 2;  n |= n &gt;&gt;&gt; 4;  n |= n &gt;&gt;&gt; 8;  n |= n &gt;&gt;&gt; 16;  return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}複製代碼</code></pre><blockquote><p>補充說明：下圖是詳細過程，算法就是讓初始二進制右移1，2，4，8，16位，分別與自己異或，把高位第一個為1的數通過不斷右移，把高位為1的後面全變為1，111111 + 1 = 1000000 = （符合大於50並且是2的整數次冪 ）</p><p><br></p></blockquote><p><strong>面試官</strong>: 你提到hash函數，你知道HashMap的哈希函數怎麼設計的嗎？</p><p><strong>安琪拉</strong>: [問的還挺細] hash函數是先拿到通過key 的hashcode，是32位的int值，然後讓hashcode的高16位和低16位進行異或操作。</p><p><br></p><div class=pgc-img><img alt=一個HashMap能跟面試官扯上半個小時 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/85f0e0aed3c947fd9cdbaddab771001a><p class=pgc-img-caption></p></div><p><br></p><p><strong>面試官</strong>: 那你知道為什麼這麼設計嗎？</p><p><strong>安琪拉</strong>: [這也要問]，這個也叫擾動函數，這麼設計有二點原因：</p><ol start=1><li>一定要儘可能降低hash碰撞，越分散越好；</li><li>算法一定要儘可能高效，因為這是高頻操作, 因此採用位運算；</li></ol><p><strong>面試官</strong>: 為什麼採用hashcode的高16位和低16位異或能降低hash碰撞？hash函數能不能直接用key的hashcode？</p><p>[這問題有點刁鑽], 安琪拉差點原地了，恨不得出biubiubiu 二一三連招。</p><p><strong>安琪拉</strong>: 因為key.hashCode()函數調用的是key鍵值類型自帶的哈希函數，返回int型散列值。int值範圍為**-2147483648~2147483647**，前後加起來大概40億的映射空間。只要哈希函數映射得比較均勻鬆散，一般應用是很難出現碰撞的。但問題是一個40億長度的數組，內存是放不下的。你想，如果HashMap數組的初始大小才16，用之前需要對數組的長度取模運算，得到的餘數才能用來訪問數組下標。(來自知乎-胖君)</p><p>源碼中模運算就是把散列值和數組長度-1做一個"與"操作，位運算比%運算要快。</p><pre><code>bucketIndex = indexFor(hash, table.length);static int indexFor(int h, int length) {     return h &amp; (length-1);}複製代碼</code></pre><p>順便說一下，這也正好解釋了為什麼HashMap的數組長度要取2的整數冪。因為這樣（數組長度-1）正好相當於一個“低位掩碼”。“與”操作的結果就是散列值的高位全部歸零，只保留低位值，用來做數組下標訪問。以初始長度16為例，16-1=15。2進製表示是00000000 00000000 00001111。和某散列值做“與”操作如下，結果就是截取了最低的四位值。</p><pre><code>  10100101 11000100 00100101&amp; 00000000 00000000 00001111----------------------------------  00000000 00000000 00000101    //高位全部歸零，只保留末四位複製代碼</code></pre><p>但這時候問題就來了，這樣就算我的散列值分佈再鬆散，要是隻取最後幾位的話，碰撞也會很嚴重。更要命的是如果散列本身做得不好，分佈上成等差數列的漏洞，如果正好讓最後幾個低位呈現規律性重複，就無比蛋疼。</p><p>時候“擾動函數”的價值就體現出來了，說到這裡大家應該猜出來了。看下面這個圖，</p><p><br></p><div class=pgc-img><img alt=一個HashMap能跟面試官扯上半個小時 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d37369c5adf746c4b964c84dda3608d5><p class=pgc-img-caption></p></div><p><br></p><p>右位移16位，正好是32bit的一半，自己的高半區和低半區做異或，就是為了混合原始哈希碼的高位和低位，以此來加大低位的隨機性。而且混合後的低位摻雜了高位的部分特徵，這樣高位的信息也被變相保留下來。</p><p>最後我們來看一下Peter Lawley的一篇專欄文章《An introduction to optimising a hashing strategy》裡的的一個實驗：他隨機選取了352個字符串，在他們散列值完全沒有衝突的前提下，對它們做低位掩碼，取數組下標。</p><p><br></p><div class=pgc-img><img alt=一個HashMap能跟面試官扯上半個小時 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6d023da3fb8c453d8cef49225b1db91f><p class=pgc-img-caption></p></div><p><br></p><p>結果顯示，當HashMap數組長度為512的時候（2的9次方），也就是用掩碼取低9位的時候，在沒有擾動函數的情況下，發生了103次碰撞，接近30%。而在使用了擾動函數之後只有92次碰撞。碰撞減少了將近10%。看來擾動函數確實還是有功效的。</p><p>另外Java1.8相比1.7做了調整，1.7做了四次移位和四次異或，但明顯Java 8覺得擾動做一次就夠了，做4次的話，多了可能邊際效用也不大，所謂為了效率考慮就改成一次了。</p><p>下面是1.7的hash代碼：</p><pre><code>static int hash(int h) {    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}複製代碼</code></pre><p><strong>面試官</strong>: 看來做過功課，有點料啊！是不是偷偷看了安琪拉的博客, 你剛剛說到1.8對hash函數做了優化，1.8還有別的優化嗎？</p><p><strong>安琪拉</strong>: 1.8還有三點主要的優化：</p><ol start=1><li>數組+鏈表改成了數組+鏈表或紅黑樹；</li><li>鏈表的插入方式從頭插法改成了尾插法，簡單說就是插入時，如果數組位置上已經有元素，1.7將新元素放到數組中，原始節點作為新節點的後繼節點，1.8遍歷鏈表，將元素放置到鏈表的最後；</li><li>擴容的時候1.7需要對原數組中的元素進行重新hash定位在新數組的位置，1.8採用更簡單的判斷邏輯，位置不變或索引+舊容量大小；</li><li>在插入時，1.7先判斷是否需要擴容，再插入，1.8先進行插入，插入完成再判斷是否需要擴容；</li></ol><p><strong>面試官</strong>: 你分別跟我講講為什麼要做這幾點優化；</p><p><strong>安琪拉</strong>: 【咳咳，果然是連環炮】</p><ol start=1><li>防止發生hash衝突，鏈表長度過長，將時間複雜度由O(n)降為O(logn);</li><li>因為1.7頭插法擴容時，頭插法會使鏈表發生反轉，多線程環境下會產生環； A線程在插入節點B，B線程也在插入，遇到容量不夠開始擴容，重新hash，放置元素，採用頭插法，後遍歷到的B節點放入了頭部，這樣形成了環，如下圖所示： 1.7的擴容調用transfer代碼，如下所示： void transfer(Entry[] newTable, boolean rehash) { int newCapacity = newTable.length; for (Entry&lt;K,V> e : table) { while(null != e) { Entry&lt;K,V> next = e.next; if (rehash) { e.hash = null == e.key ? 0 : hash(e.key); } int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; //A線程如果執行到這一行掛起，B線程開始進行擴容 newTable[i] = e; e = next; } } } 複製代碼</li><li>擴容的時候為什麼1.8 不用重新hash就可以直接定位原節點在新數據的位置呢? 這是由於擴容是擴大為原數組大小的2倍，用於計算數組位置的掩碼僅僅只是高位多了一個1，怎麼理解呢？ 擴容前長度為16，用於計算(n-1) & hash 的二進制n-1為0000 1111，擴容為32後的二進制就高位多了1，為0001 1111。 因為是& 運算，1和任何數 & 都是它本身，那就分二種情況，如下圖：原數據hashcode高位第4位為0和高位為1的情況； 第四位高位為0，重新hash數值不變，第四位為1，重新hash數值比原來大16（舊數組的容量）</li></ol><p><strong>面試官</strong>: 那HashMap是線程安全的嗎？</p><p><strong>安琪拉</strong>: 不是，在多線程環境下，1.7 會產生死循環、數據丟失、數據覆蓋的問題，1.8 中會有數據覆蓋的問題，以1.8為例，當A線程判斷index位置為空後正好掛起，B線程開始往index位置的寫入節點數據，這時A線程恢復現場，執行賦值操作，就把A線程的數據給覆蓋了；還有++size這個地方也會造成多線程同時擴容等問題。</p><pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;  if ((tab = table) == null || (n = tab.length) == 0)    n = (tab = resize()).length;  if ((p = tab[i = (n - 1) &amp; hash]) == null)  //多線程執行到這裡    tab[i] = newNode(hash, key, value, null);  else {    Node&lt;K,V&gt; e; K k;    if (p.hash == hash &amp;&amp;        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))      e = p;    else if (p instanceof TreeNode)      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);    else {      for (int binCount = 0; ; ++binCount) {        if ((e = p.next) == null) {          p.next = newNode(hash, key, value, null);          if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st            treeifyBin(tab, hash);          break;        }        if (e.hash == hash &amp;&amp;            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))          break;        p = e;      }    }    if (e != null) { // existing mapping for key      V oldValue = e.value;      if (!onlyIfAbsent || oldValue == null)        e.value = value;      afterNodeAccess(e);      return oldValue;    }  }  ++modCount;  if (++size &gt; threshold) // 多個線程走到這，可能重複resize()    resize();  afterNodeInsertion(evict);  return null;}複製代碼</code></pre><p><strong>面試官</strong>: 那你平常怎麼解決這個線程不安全的問題？</p><p><strong>安琪拉</strong>: Java中有HashTable、Collections.synchronizedMap、以及ConcurrentHashMap可以實現線程安全的Map。</p><p>HashTable是直接在操作方法上加synchronized關鍵字，鎖住整個數組，粒度比較大，Collections.synchronizedMap是使用Collections集合工具的內部類，通過傳入Map封裝出一個SynchronizedMap對象，內部定義了一個對象鎖，方法內通過對象鎖實現；ConcurrentHashMap使用分段鎖，降低了鎖粒度，讓併發度大大提高。</p><p><strong>面試官</strong>: 那你知道ConcurrentHashMap的分段鎖的實現原理嗎？</p><p><strong>安琪拉</strong>: 【天啦擼! 俄羅斯套娃，一個套一個】ConcurrentHashMap成員變量使用volatile 修飾，免除了指令重排序，同時保證內存可見性，另外使用CAS操作和synchronized結合實現賦值操作，多線程操作只會鎖住當前操作索引的節點。</p><p>如下圖，線程A鎖住A節點所在鏈表，線程B鎖住B節點所在鏈表，操作互不干涉。</p><p><br></p><div class=pgc-img><img alt=一個HashMap能跟面試官扯上半個小時 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b212818aeb294ed8b6fb5264b2ef5235><p class=pgc-img-caption></p></div><p><br></p><p><strong>面試官</strong>: 你前面提到鏈表轉紅黑樹是鏈表長度達到閾值，這個閾值是多少？</p><p><strong>安琪拉</strong>: 閾值是8，紅黑樹轉鏈表閾值為6</p><p><strong>面試官</strong>: 為什麼是8，不是16，32甚至是7 ？又為什麼紅黑樹轉鏈表的閾值是6，不是8了呢？</p><p><strong>安琪拉</strong>: 【你去問作者啊！天啦擼，biubiubiu 真想213連招】因為作者就這麼設計的，哦，不對，因為經過計算，在hash函數設計合理的情況下，發生hash碰撞8次的機率為百萬分之6，概率說話。。因為8夠用了，至於為什麼轉回來是6，因為如果hash碰撞次數在8附近徘徊，會一直髮生鏈表和紅黑樹的轉化，為了預防這種情況的發生。</p><p><strong>面試官</strong>: HashMap內部節點是有序的嗎？</p><p><strong>安琪拉</strong>: 是無序的，根據hash值隨機插入</p><p><strong>面試官</strong>: 那有沒有有序的Map？</p><p><strong>安琪拉</strong>: LinkedHashMap 和 TreeMap</p><p><strong>面試官</strong>: 跟我講講LinkedHashMap怎麼實現有序的？</p><p><strong>安琪拉</strong>: LinkedHashMap內部維護了一個單鏈表，有頭尾節點，同時LinkedHashMap節點Entry內部除了繼承HashMap的Node屬性，還有before 和 after用於標識前置節點和後置節點。可以實現按插入的順序或訪問順序排序。</p><pre><code>/** * The head (eldest) of the doubly linked list.*/transient LinkedHashMap.Entry&lt;K,V&gt; head;/**  * The tail (youngest) of the doubly linked list.*/transient LinkedHashMap.Entry&lt;K,V&gt; tail;//鏈接新加入的p節點到鏈表後端private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {  LinkedHashMap.Entry&lt;K,V&gt; last = tail;  tail = p;  if (last == null)    head = p;  else {    p.before = last;    last.after = p;  }}//LinkedHashMap的節點類static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {  Entry&lt;K,V&gt; before, after;  Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {    super(hash, key, value, next);  }}複製代碼</code></pre><p>示例代碼：</p><pre><code>public static void main(String[] args) {  Map&lt;String, String&gt; map = new LinkedHashMap&lt;String, String&gt;();  map.put("1", "安琪拉");  map.put("2", "的");  map.put("3", "博客");  for(Map.Entry&lt;String,String&gt; item: map.entrySet()){    System.out.println(item.getKey() + ":" + item.getValue());  }}//console輸出1:安琪拉2:的3:博客複製代碼</code></pre><p><strong>面試官</strong>: 跟我講講TreeMap怎麼實現有序的？</p><p><strong>安琪拉</strong>：TreeMap是按照Key的自然順序或者Comprator的順序進行排序，內部是通過紅黑樹來實現。所以要麼key所屬的類實現Comparable接口，或者自定義一個實現了Comparator接口的比較器，傳給TreeMap用戶key的比較。</p><p><strong>面試官</strong>: 前面提到通過CAS 和 synchronized結合實現鎖粒度的降低，你能給我講講CAS 的實現以及synchronized的實現原理嗎？</p><p><strong>安琪拉</strong>: 下一期咋們再約時間，OK？</p><p><strong>面試官</strong>: 好吧，回去等通知吧！</p><p><br></p><div class=tt-column-card data-content='{"new_thumb_url": "http://sf3-ttcdn-tos.pstatp.com/img/pgc-image/aeb711fc195e49c0a3c970e0ac56dbfa", "title": "Java\u9762\u8bd5\u901a\u5173100\u95ee", "url": "", "price": 19.9, "column_id": "6726145310487216397", "content": "", "author_description": "Java\u8bc6\u5802", "share_price": 3.18, "thumb_url": "http://p5.pstatp.com/large/pgc-image/aeb711fc195e49c0a3c970e0ac56dbfa", "sold": 215}'><p class=column-placeholder></p></div><p><br>作者：安琪拉的博客<br>鏈接：https://juejin.im/post/5e6e0ac9e51d4526fb5df679</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>一個</a></li><li><a>HashMap</a></li><li><a>面試</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49fd79dd.html alt=面試官問：一個Java字符串中到底能有多少個字符？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/219afb44975f48c09f4d1cf56b9eed17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49fd79dd.html title=面試官問：一個Java字符串中到底能有多少個字符？>面試官問：一個Java字符串中到底能有多少個字符？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html alt=HashMap面試專題：常問六題深入解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/75bf5de0-37fd-469c-b6b3-8067c551568a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html title=HashMap面試專題：常問六題深入解析>HashMap面試專題：常問六題深入解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd12e50f.html alt=崩潰了，一個HashMap跟面試官扯了半個小時 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/83a08f0db0dc4968b6a2df75a4dc2034 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd12e50f.html title=崩潰了，一個HashMap跟面試官扯了半個小時>崩潰了，一個HashMap跟面試官扯了半個小時</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html alt=面試必備：HashMap源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html title=面試必備：HashMap源碼解析>面試必備：HashMap源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html alt=HashMap？面試？我是誰？我在哪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8aa437a2fb3143e7a345a46a36d2c81e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html title=HashMap？面試？我是誰？我在哪>HashMap？面試？我是誰？我在哪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html alt=「最完整系列」JAVA-容器篇-HashMap面試最詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/71d7c60ccb9e4e57acda3ded903a1fd5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html title=「最完整系列」JAVA-容器篇-HashMap面試最詳解>「最完整系列」JAVA-容器篇-HashMap面試最詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d65b6b54.html alt=崩潰了，一個HashMap跟面試官扯了半個小時（裝逼必備） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7dd363d0da22489d9197549fd7742b33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d65b6b54.html title=崩潰了，一個HashMap跟面試官扯了半個小時（裝逼必備）>崩潰了，一個HashMap跟面試官扯了半個小時（裝逼必備）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html alt=面試必問的HashMap，你真的瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/19a8d23522b640b4a8d8a927514eca33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36eefc47.html title=面試必問的HashMap，你真的瞭解嗎？>面試必問的HashMap，你真的瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/358ab5f.html alt=面試官：問你一個，Spring事務是如何傳播的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6513100097ce4d27b1df49cd347e4d88 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/358ab5f.html title=面試官：問你一個，Spring事務是如何傳播的？>面試官：問你一個，Spring事務是如何傳播的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html alt=30分鐘教你搭建一個網站（一）：購買和配置服務器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5f26f1582a564e93bde33a7dd9448c3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html title=30分鐘教你搭建一個網站（一）：購買和配置服務器>30分鐘教你搭建一個網站（一）：購買和配置服務器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html alt=不會買服務器？一個辦法讓你輕鬆搭網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84d9c54578de46058796824f1bcb6a9b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html title=不會買服務器？一個辦法讓你輕鬆搭網站>不會買服務器？一個辦法讓你輕鬆搭網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html alt=使用服務器搭建一個網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/63a6cc0eb4d146e0890515500c0040ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html title=使用服務器搭建一個網站>使用服務器搭建一個網站</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>