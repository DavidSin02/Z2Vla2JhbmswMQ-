<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java 手寫併發框架（一）異步查詢轉同步的7種實現方式 | 极客快訊</title><meta property="og:title" content="java 手寫併發框架（一）異步查詢轉同步的7種實現方式 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/tos-cn-i-k3u1fbpfcp/1d3022027b8243cabafea485206c0cbe"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/db45996.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/db45996.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/db45996.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/db45996.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/db45996.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/db45996.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/db45996.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/db45996.html><meta property="article:published_time" content="2020-10-29T20:59:18+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:18+08:00"><meta name=Keywords content><meta name=description content="java 手寫併發框架（一）異步查詢轉同步的7種實現方式"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/db45996.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java 手寫併發框架（一）異步查詢轉同步的7種實現方式</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>序言</strong></h1><p>本節將學習一下如何實現異步查詢轉同步的方式，共計介紹了 7 種常見的實現方式。</p><p>思維導圖如下：</p><div class=pgc-img><img alt="java 手寫併發框架（一）異步查詢轉同步的7種實現方式" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/tos-cn-i-k3u1fbpfcp/1d3022027b8243cabafea485206c0cbe><p class=pgc-img-caption></p></div><p><span style="color:#888;--tt-darkmode-color: #888888">思維導圖</span></p><h1 class=pgc-h-arrow-right><strong>異步轉同步</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">業務需求</span></span></strong></h1><p>有些接口查詢反饋結果是異步返回的，無法立刻獲取查詢結果。</p><p>比如業務開發中我們調用其他系統，但是結果的返回確實通知的。</p><p>或者 rpc 實現中，client 調用 server 端，結果也是異步返回的，那麼如何同步獲取調用結果呢？</p><ul><li>正常處理邏輯</li></ul><p>觸發異步操作，然後傳遞一個唯一標識。</p><p>等到異步結果返回，根據傳入的唯一標識，匹配此次結果。</p><ul><li>如何轉換為同步</li></ul><p>正常的應用場景很多，但是有時候不想做數據存儲，只是想簡單獲取調用結果。</p><p>即想達到同步操作的結果，怎麼辦呢？</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">思路</span></span></strong></h1><ol start=1><li>發起異步操作</li><li>在異步結果返回之前，一直等待(可以設置超時)</li><li>結果返回之後，異步操作結果統一返回</li></ol><h1 class=pgc-h-arrow-right><strong>常見的實現方式</strong></h1><ul><li>循環等待</li><li>wait & notify</li><li>使用條件鎖</li><li>使用 CountDownLatch</li><li>使用 CyclicBarrier</li><li>Future</li><li>Spring EventListener</li></ul><p>下面我們一起來學習下這幾種實現方式。</p><h1 class=pgc-h-arrow-right><strong>循環等待</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">說明</span></span></strong></h1><p>循環等待是最簡單的一種實現思路。</p><p>我們調用對方一個請求，在沒有結果之前一直循環查詢即可。</p><p>這個結果可以在內存中，也可以放在 redis 緩存或者 mysql 等數據庫中。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">代碼實現</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>定義抽象父類</strong></h1><p>為了便於後面的其他幾種實現方式統一，我們首先定義一個抽象父類。</p><pre><code>/** * 抽象查詢父類 * @author binbin.hou * @since 1.0.0 */public abstract class AbstractQuery {    private static final Log log = LogFactory.getLog(AbstractQuery.class);    protected String result;    public void asyncToSync() {        startQuery();        new Thread(new Runnable() {            public void run() {                remoteCall();            }        }).start();        endQuery();    }    protected void startQuery() {        log.info("開始查詢...");    }    /**     * 遠程調用     */    protected void remoteCall() {        try {            log.info("遠程調用開始");            TimeUnit.SECONDS.sleep(5);            result = "success";            log.info("遠程調用結束");        } catch (InterruptedException e) {            log.error("遠程調用失敗", e);        }    }    /**     * 查詢結束     */    protected void endQuery() {        log.info("完成查詢，結果為：" + result);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>代碼實現</strong></h1><p>實現還是非常簡單的，在沒有結果之前一直循環。</p><p><span style="color:#ef7060;--tt-darkmode-color: #EF7060">TimeUnit.MILLISECONDS.sleep(10);</span> 這裡循環等待的小睡一會兒是比較重要的，避免 cpu 飆升，也可以降低為 1ms，根據自己的業務調整即可。</p><pre><code>/** * 循環等待 * @author binbin.hou * @since 1.0.0 */public class LoopQuery extends AbstractQuery {    private static final Log log = LogFactory.getLog(LoopQuery.class);    @Override    protected void endQuery() {        try {            while (StringUtil.isEmpty(result)) {                //循環等待一下                TimeUnit.MILLISECONDS.sleep(10);            }            //獲取結果            log.info("完成查詢，結果為：" + result);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>測試</strong></h1><pre><code>LoopQuery loopQuery = new LoopQuery();loopQuery.asyncToSync();</code></pre><ul><li>日誌</li></ul><pre><code>[INFO] [2020-10-08 09:50:43.330] [main] [c.g.h.s.t.d.AbstractQuery.startQuery] - 開始查詢...[INFO] [2020-10-08 09:50:43.331] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用開始[INFO] [2020-10-08 09:50:48.334] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用結束[INFO] [2020-10-08 09:50:48.343] [main] [c.g.h.s.t.d.LoopQuery.endQuery] - 完成查詢，結果為：success</code></pre><p>這裡可以看到遠程調用是 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">Thread-0</span> 線程執行的，遠程調用的耗時為 5S。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">超時特性</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>為什麼需要超時時間</strong></h1><p>上面的實現存在一個問題，那就是循環等待沒有超時時間。</p><p>我們的一個網絡請求，可能存在失敗，也可能對方收到請求之後沒有正確處理。</p><p>所以如果我們一直等待，可能永遠也沒有結果，或者很久之後才有結果。這在業務上是不可忍受的，所以需要添加一個超時時間。</p><h1 class=pgc-h-arrow-right><strong>代碼實現</strong></h1><pre><code>/** * 循環等待-包含超時時間 * @author binbin.hou * @since 1.0.0 */public class LoopTimeoutQuery extends AbstractQuery {    private static final Log log = LogFactory.getLog(LoopTimeoutQuery.class);    /**     * 超時時間     */    private long timeoutMills = 3000;    public LoopTimeoutQuery() {    }    public LoopTimeoutQuery(long timeoutMills) {        this.timeoutMills = timeoutMills;    }    @Override    protected void endQuery() {        try {            final long endTimeMills = System.currentTimeMillis() + timeoutMills;            while (StringUtil.isEmpty(result)) {                // 超時判斷                if(System.currentTimeMillis() &gt;= endTimeMills) {                    throw new RuntimeException("請求超時");                }                //循環等待一下                TimeUnit.MILLISECONDS.sleep(10);            }            //獲取結果            log.info("完成查詢，結果為：" + result);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>測試</strong></h1><pre><code>LoopTimeoutQuery loopQuery = new LoopTimeoutQuery();loopQuery.asyncToSync();</code></pre><p>日誌如下：</p><pre><code>[INFO] [2020-10-08 10:04:58.091] [main] [c.g.h.s.t.d.AbstractQuery.startQuery] - 開始查詢...[INFO] [2020-10-08 10:04:58.092] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用開始Exception in thread "main" java.lang.RuntimeException: 請求超時 at com.github.houbb.sync.test.demo.LoopTimeoutQuery.endQuery(LoopTimeoutQuery.java:38) at com.github.houbb.sync.test.demo.AbstractQuery.asyncToSync(AbstractQuery.java:26) at com.github.houbb.sync.test.demo.LoopTimeoutQuery.main(LoopTimeoutQuery.java:55)[INFO] [2020-10-08 10:05:03.097] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用結束</code></pre><p>超時時間是可以設定的，平時開發中可以根據自己的響應時間設置。</p><p>如果請求超時，考慮對應的兜底方案。</p><h1 class=pgc-h-arrow-right><strong>基於 wait() & notifyAll()</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">簡介</span></span></strong></h1><p>實際上 loop 循環還是比較消耗性能的，對於這種等待特性, jdk 實際上為我們封裝了多種特性。</p><p>比如最常見的 wait() 進入等待，notifyAll() 喚醒等待的組合方式。</p><p>這個同時也是阻塞隊列的實現思想，阻塞隊列我們就不介紹了，我們來看一下 wait+notify 的實現方式。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">java 實現</span></span></strong></h1><pre><code>package com.github.houbb.sync.test.demo;import com.github.houbb.log.integration.core.Log;import com.github.houbb.log.integration.core.LogFactory;/** * wait+notify 實現 * @author binbin.hou * @since 1.0.0 */public class WaitNotifyQuery extends AbstractQuery {    private static final Log log = LogFactory.getLog(WaitNotifyQuery.class);    /**     * 聲明對象     */    private final Object lock = new Object();    @Override    protected void remoteCall() {        super.remoteCall();        synchronized (lock) {            log.info("遠程線程執行完成，喚醒所有等待。");            lock.notifyAll();        }    }    @Override    protected void endQuery() {        try {            // 等待 10s            synchronized (lock) {                log.info("主線程進入等待");                lock.wait(10 * 1000);            }        } catch (InterruptedException e) {            e.printStackTrace();        }        super.endQuery();    }    public static void main(String[] args) {        WaitNotifyQuery query = new WaitNotifyQuery();        query.asyncToSync();    }}</code></pre><p>注意：編程時需要使用 synchronized 保證鎖的持有者線程安全，不然會報錯。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">測試</span></span></strong></h1><p>日誌如下：</p><pre><code>[INFO] [2020-10-08 11:05:50.769] [main] [c.g.h.s.t.d.AbstractQuery.startQuery] - 開始查詢...[INFO] [2020-10-08 11:05:50.770] [main] [c.g.h.s.t.d.WaitNotifyQuery.endQuery] - 主線程進入等待[INFO] [2020-10-08 11:05:50.770] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用開始[INFO] [2020-10-08 11:05:55.772] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用結束[INFO] [2020-10-08 11:05:55.773] [Thread-0] [c.g.h.s.t.d.WaitNotifyQuery.remoteCall] - 遠程線程執行完成，喚醒所有等待。[INFO] [2020-10-08 11:05:55.773] [main] [c.g.h.s.t.d.AbstractQuery.endQuery] - 完成查詢，結果為：success</code></pre><h1 class=pgc-h-arrow-right><strong>基於條件鎖的實現</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">條件鎖簡介</span></span></strong></h1><p>如果你想編寫一個含有多個條件謂詞的併發對象,或者你想獲得比條件隊列的可見性之外更多的控制權,那麼顯式的Lock和Condition的實現類提供了一個<strong>比內部鎖和條件隊列更加靈活的選擇。</strong></p><p>如同Lock提供了比內部加鎖要豐富得多的特徵集一樣,Condition也提供了比內部條件隊列要豐富得多的特徵集:</p><p>每個鎖可以有多個等待集(因await掛起的線程的集合)、可中斷/不可中斷的條件等待、基於時限的等待以及公平/非公平隊列之間的選擇.</p><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">Condition 介紹</span></p></blockquote><p>注意事項:</p><p>wait、notify和notifyAll在Condition對象中的對等體是await、signal和signalAll.</p><p>但是,Condition繼承與Object,這意味著它也有wait和notify方法.</p><p>一定要確保使用了正確的版本–await和signal!</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">java 實現</span></span></strong></h1><p>為了演示簡單，我們直接選擇可重入鎖即可。</p><p>一個Condition和一個單獨的Lock相關聯,就像條件隊列和單獨的內部鎖相關聯一樣;</p><p>調用與Condition相關聯的Lock的Lock.newCondition方法,可以創建一個Condition.</p><pre><code>package com.github.houbb.sync.test.demo;import com.github.houbb.log.integration.core.Log;import com.github.houbb.log.integration.core.LogFactory;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 條件鎖實現 * @author binbin.hou * @since 1.0.0 */public class LockConditionQuery extends AbstractQuery {    private static final Log log = LogFactory.getLog(LockConditionQuery.class);    private final Lock lock = new ReentrantLock();    private final Condition condition = lock.newCondition();    @Override    protected void remoteCall() {        lock.lock();        try{            super.remoteCall();            log.info("遠程線程執行完成，喚醒所有等待線程。");            condition.signalAll();        } finally {            lock.unlock();        }    }    @Override    protected void endQuery() {        lock.lock();        try{            // 等待            log.info("主線程進入等待");            condition.await();            super.endQuery();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public static void main(String[] args) {        LockConditionQuery query = new LockConditionQuery();        query.asyncToSync();    }}</code></pre><p>實現也比較簡單，我們在方法進入，調用 lock.lock() 加鎖，finally 中調用 lock.unlock() 釋放鎖。</p><p><span style="color:#ef7060;--tt-darkmode-color: #EF7060">condition.await();</span> 進入等待；<span style="color:#ef7060;--tt-darkmode-color: #EF7060">condition.signalAll();</span> 喚醒所有等待線程。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">測試日誌</span></span></strong></h1><pre><code>[INFO] [2020-10-08 12:33:40.985] [main] [c.g.h.s.t.d.AbstractQuery.startQuery] - 開始查詢...[INFO] [2020-10-08 12:33:40.986] [main] [c.g.h.s.t.d.LockConditionQuery.endQuery] - 主線程進入等待[INFO] [2020-10-08 12:33:40.987] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用開始[INFO] [2020-10-08 12:33:45.990] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用結束[INFO] [2020-10-08 12:33:45.991] [Thread-0] [c.g.h.s.t.d.LockConditionQuery.remoteCall] - 遠程線程執行完成，喚醒所有等待線程。[INFO] [2020-10-08 12:33:45.993] [main] [c.g.h.s.t.d.AbstractQuery.endQuery] - 完成查詢，結果為：success</code></pre><h1 class=pgc-h-arrow-right><strong>CountDownLatch 閉鎖實現</strong></h1><p>CountDownLatch/Future/CyclicBarrier 這三個都是 jdk 為我們提供的同步工具類，我們此處只做簡單介紹。</p><p>詳情參見：</p><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">JCIP-19-同步工具類。閉鎖/柵欄/信號量/阻塞隊列/FutureTask</span></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">CountDownLatch 簡介</span></span></strong></h1><p>閉鎖是一種同步工具類，可以延遲線程的進度直到其達到終止狀態。</p><p>閉鎖的作用相當於一扇門：在閉鎖到達結束狀態之前，這扇門一直是關閉的，並且沒有任何線程能通過，當到達結束狀態時，這扇門會打開並允許所有的線程通過。</p><p>當閉鎖到達結束狀態後，將不會再改變狀態，因此這扇門將永遠保持打開狀態。</p><p>閉鎖可以用來確保某些活動直到其它活動都完成後才繼續執行。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">java 代碼實現</span></span></strong></h1><pre><code>import com.github.houbb.log.integration.core.Log;import com.github.houbb.log.integration.core.LogFactory;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;/** * CountDownLatch 實現 * @author binbin.hou * @since 1.0.0 */public class CountDownLatchQuery extends AbstractQuery {    private static final Log log = LogFactory.getLog(CountDownLatchQuery.class);    /**     * 閉鎖     * 調用1次，後續方法即可通行。     */    private final CountDownLatch countDownLatch = new CountDownLatch(1);    @Override    protected void remoteCall() {        super.remoteCall();        // 調用一次閉鎖        countDownLatch.countDown();    }    @Override    protected void endQuery() {        try {//            countDownLatch.await();            countDownLatch.await(10, TimeUnit.SECONDS);            log.info("完成查詢，結果為：" + result);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    public static void main(String[] args) {        CountDownLatchQuery loopQuery = new CountDownLatchQuery();        loopQuery.asyncToSync();    }}</code></pre><p>我們在返回結果之前調用 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">countDownLatch.await(10, TimeUnit.SECONDS);</span> 進行等待，這裡可以指定超時時間。</p><p>remoteCall() 遠程完成後，執行一下 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">countDownLatch.countDown();</span>，進而可以讓程序繼續執行下去。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">測試</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>代碼</strong></h1><pre><code>CountDownLatchQuery loopQuery = new CountDownLatchQuery();loopQuery.asyncToSync();</code></pre><h1 class=pgc-h-arrow-right><strong>日誌</strong></h1><pre><code>[INFO] [2020-10-08 10:24:03.348] [main] [c.g.h.s.t.d.AbstractQuery.startQuery] - 開始查詢...[INFO] [2020-10-08 10:24:03.350] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用開始[INFO] [2020-10-08 10:24:08.353] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用結束[INFO] [2020-10-08 10:24:08.354] [main] [c.g.h.s.t.d.CountDownLatchQuery.endQuery] - 完成查詢，結果為：success</code></pre><p>jdk 提供的閉鎖功能還是非常的方便的。</p><h1 class=pgc-h-arrow-right><strong>CyclicBarrier 柵欄</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">簡介</span></span></strong></h1><p>柵欄（Barrier）類似於閉鎖，它能阻塞一組線程直到某個事件發生[CPJ 4.4.3]。閉鎖是一次性對象，一旦進入最終狀態，就不能被重置了。</p><p><strong>柵欄與閉鎖的關鍵區別在於，所有線程必須同時達到柵欄位置，才能繼續執行。閉鎖用於等待事件，而柵欄用於等待其他線程。</strong></p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">java 實現</span></span></strong></h1><pre><code>package com.github.houbb.sync.test.demo;import com.github.houbb.log.integration.core.Log;import com.github.houbb.log.integration.core.LogFactory;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * CyclicBarrier 實現 * @author binbin.hou * @since 1.0.0 */public class CyclicBarrierQuery extends AbstractQuery {    private static final Log log = LogFactory.getLog(CyclicBarrierQuery.class);    private CyclicBarrier cyclicBarrier = new CyclicBarrier(2);    @Override    protected void remoteCall() {        super.remoteCall();        try {            cyclicBarrier.await();            log.info("遠程調用進入等待");        } catch (InterruptedException | BrokenBarrierException e) {            e.printStackTrace();        }    }    @Override    protected void endQuery() {        try {            cyclicBarrier.await();            log.info("主線程進入等待");        } catch (InterruptedException | BrokenBarrierException e) {            e.printStackTrace();        }        super.endQuery();    }}</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">測試</span></span></strong></h1><h1 class=pgc-h-arrow-right><strong>代碼</strong></h1><pre><code>public static void main(String[] args) {    CyclicBarrierQuery cyclicBarrierQuery = new CyclicBarrierQuery();    cyclicBarrierQuery.asyncToSync();}</code></pre><h1 class=pgc-h-arrow-right><strong>日誌</strong></h1><pre><code>[INFO] [2020-10-08 10:39:00.890] [main] [c.g.h.s.t.d.AbstractQuery.startQuery] - 開始查詢...[INFO] [2020-10-08 10:39:00.892] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用開始[INFO] [2020-10-08 10:39:05.894] [Thread-0] [c.g.h.s.t.d.AbstractQuery.remoteCall] - 遠程調用結束[INFO] [2020-10-08 10:39:05.895] [Thread-0] [c.g.h.s.t.d.CyclicBarrierQuery.remoteCall] - 遠程調用進入等待[INFO] [2020-10-08 10:39:05.895] [main] [c.g.h.s.t.d.CyclicBarrierQuery.endQuery] - 主線程進入等待[INFO] [2020-10-08 10:39:05.896] [main] [c.g.h.s.t.d.AbstractQuery.endQuery] - 完成查詢，結果為：success</code></pre><p>可以看出遠程線程 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">Thread-0</span> 執行完之後就進入等待，此時主線程調用，然後也進入等待。</p><p>等主線程 endQuery 等待時，就滿足了兩個線程同時等待，然後執行就結束了。</p><h1 class=pgc-h-arrow-right><strong>基於 Future 實現</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">Future 簡介</span></span></strong></h1><p>Future模式可以這樣來描述：我有一個任務，提交給了Future，Future替我完成這個任務。期間我自己可以去做任何想做的事情。一段時間之後，我就便可以從Future那兒取出結果。就相當於下了一張訂貨單，一段時間後可以拿著提訂單來提貨，這期間可以幹別的任何事情。其中Future 接口就是訂貨單，真正處理訂單的是Executor類，它根據Future接口的要求來生產產品。</p><p>Future接口提供方法來檢測任務是否被執行完，等待任務執行完獲得結果，也可以設置任務執行的超時時間。這個設置超時的方法就是實現Java程序執行超時的關鍵。</p><p>詳細介紹：</p><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">JCIP-26-Executor Future FutureTask</span></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">java 代碼實現</span></span></strong></h1><p>採用 Future 返回和以前的實現差異較大，我們直接覆寫以前的方法即可。</p><pre><code>import com.github.houbb.log.integration.core.Log;import com.github.houbb.log.integration.core.LogFactory;import java.util.concurrent.*;/** * Future 實現 * @author binbin.hou * @since 1.0.0 */public class FutureQuery extends AbstractQuery {    private static final Log log = LogFactory.getLog(FutureQuery.class);    private final ExecutorService executorService = Executors.newSingleThreadExecutor();    @Override    public void asyncToSync() {        //1. 開始調用        super.startQuery();        //2. 遠程調用        Future&lt;String&gt; stringFuture = remoteCallFuture();        //3. 完成結果        try {            String result = stringFuture.get(10, TimeUnit.SECONDS);            log.info("調用結果：{}", result);        } catch (InterruptedException | TimeoutException | ExecutionException e) {            e.printStackTrace();        }    }    /**     * 遠程調用     * @return Future 信息     */    private Future&lt;String&gt; remoteCallFuture() {        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() {            @Override            public String call() throws Exception {                log.info("開始異步調用");                TimeUnit.SECONDS.sleep(5);                log.info("完成異步調用");                return "success";            }        });        executorService.submit(futureTask);        // 關閉線程池        executorService.shutdown();        return futureTask;    }    public static void main(String[] args) {        FutureQuery query = new FutureQuery();        query.asyncToSync();    }}</code></pre><p>遠程調用執行時，是一個 FutureTask，然後提交到線程池去執行。</p><p>獲取結果的時候，<span style="color:#ef7060;--tt-darkmode-color: #EF7060">stringFuture.get(10, TimeUnit.SECONDS)</span> 可以指定獲取的超時時間。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">日誌</span></span></strong></h1><p>測試日誌如下:</p><pre><code>[INFO] [2020-10-08 12:52:05.175] [main] [c.g.h.s.t.d.AbstractQuery.startQuery] - 開始查詢...[INFO] [2020-10-08 12:52:05.177] [pool-1-thread-1] [c.g.h.s.t.d.FutureQuery.call] - 開始異步調用[INFO] [2020-10-08 12:52:10.181] [pool-1-thread-1] [c.g.h.s.t.d.FutureQuery.call] - 完成異步調用[INFO] [2020-10-08 12:52:10.185] [main] [c.g.h.s.t.d.FutureQuery.asyncToSync] - 調用結果：success</code></pre><h1 class=pgc-h-arrow-right><strong>Spring EventListener</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">spring 事件監聽器模式</span></span></strong></h1><p>對於一件事情完成的結果調用，使用觀察者模式是非常適合的。</p><p>spring 為我們提供了比較強大的監聽機制，此處演示下結合 spring 使用的例子。</p><p>ps: 這個例子是2年前的自己寫的例子了，此處為了整個系列的完整性，直接搬過來作為補充。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#fff;--tt-darkmode-color: #FFFFFF"><span style="background-color:#ef7060;--tt-darkmode-bgcolor: #EF7060">代碼實現</span></span></strong></h1><ul><li>BookingCreatedEvent.java</li></ul><p>定義一個傳輸屬性的對象。</p><pre><code>public class BookingCreatedEvent extends ApplicationEvent {    private static final long serialVersionUID = -1387078212317348344L;    private String info;    public BookingCreatedEvent(Object source) {        super(source);    }    public BookingCreatedEvent(Object source, String info) {        super(source);        this.info = info;    }    public String getInfo() {        return info;    }}</code></pre><ul><li>BookingService.java</li></ul><p>說明：當 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">this.context.publishEvent(bookingCreatedEvent);</span> 觸發時， 會被 <span style="color:#ef7060;--tt-darkmode-color: #EF7060">@EventListener</span> 指定的方法監聽到。</p><pre><code>import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class BookingService {    @Autowired    private ApplicationContext context;    private volatile BookingCreatedEvent bookingCreatedEvent;    /**     * 異步轉同步查詢     * @param info     * @return     */    public String asyncQuery(final String info) {        query(info);        new Thread(new Runnable() {            @Override            public void run() {                remoteCallback(info);            }        }).start();        while(bookingCreatedEvent == null) {            //.. 空循環            // 短暫等待。            try {                TimeUnit.MILLISECONDS.sleep(1);            } catch (InterruptedException e) {                //...            }            //2. 使用兩個單獨的 event...        }        final String result = bookingCreatedEvent.getInfo();        bookingCreatedEvent = null;        return result;    }    @EventListener    public void onApplicationEvent(BookingCreatedEvent bookingCreatedEvent) {        System.out.println("監聽到遠程的信息: " + bookingCreatedEvent.getInfo());        this.bookingCreatedEvent = bookingCreatedEvent;        System.out.println("監聽到遠程消息後: " + this.bookingCreatedEvent.getInfo());    }    /**     * 執行查詢     * @param info     */    public void query(final String info) {        System.out.println("開始查詢: " + info);    }    /**     * 遠程回調     * @param info     */    public void remoteCallback(final String info) {        System.out.println("遠程回調開始: " + info);        try {            TimeUnit.SECONDS.sleep(2);        } catch (InterruptedException e) {            e.printStackTrace();        }        // 重發結果事件        String result = info + "-result";        BookingCreatedEvent bookingCreatedEvent = new BookingCreatedEvent(this, result);        //觸發event        this.context.publishEvent(bookingCreatedEvent);    }}</code></pre><ul><li>測試方法</li></ul><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class BookServiceTest {    @Autowired    private BookingService bookingService;    @Test    public void asyncQueryTest() {        bookingService.asyncQuery("1234");    }}</code></pre><ul><li>日誌</li></ul><pre><code>2018-08-10 18:27:05.958  INFO  [main] com.github.houbb.spring.lean.core.ioc.event.BookingService:84 - 開始查詢:12342018-08-10 18:27:05.959  INFO  [Thread-2] com.github.houbb.spring.lean.core.ioc.event.BookingService:93 - 遠程回調開始:1234接收到信息: 1234-result2018-08-10 18:27:07.964  INFO  [Thread-2] com.github.houbb.spring.lean.core.ioc.event.BookingService:73 - 監聽到遠程的信息: 1234-result2018-08-10 18:27:07.964  INFO  [Thread-2] com.github.houbb.spring.lean.core.ioc.event.BookingService:75 - 監聽到遠程消息後: 1234-result2018-08-10 18:27:07.964  INFO  [Thread-2] com.github.houbb.spring.lean.core.ioc.event.BookingService:106 - 已經觸發event2018-08-10 18:27:07.964  INFO  [main] com.github.houbb.spring.lean.core.ioc.event.BookingService:67 - 查詢結果: 1234-result2018-08-10 18:27:07.968  INFO  [Thread-1] org.springframework.context.support.GenericApplicationContext:993 - Closing org.springframework.context.support.GenericApplicationContext@5cee5251: startup date [Fri Aug 10 18:27:05 CST 2018]; root of context hierarchy</code></pre><h1 class=pgc-h-arrow-right><strong>小結</strong></h1><p>本文共計介紹了 7 種異步轉同步的方式，實際上思想都是一樣的。</p><p>在異步執行完成前等待，執行完成後喚醒等待即可。</p><p>當然我寫本文除了總結以上幾種方式以外，還想為後續寫一個異步轉同步的工具提供基礎。</p><p>下一節我們將一起學習下如何將這個功能封裝為一個同步轉換框架，感興趣的可以關注一下，便於實時接收最新內容。</p><p>覺得本文對你有幫助的話，歡迎點贊評論收藏轉發一波。你的鼓勵，是我最大的動力~</p><p>不知道你有哪些收穫呢？或者有其他更多的想法，歡迎留言區和我一起討論，期待與你的思考相遇。</p><h1 class=pgc-h-arrow-right><strong>代碼地址</strong></h1><p>為了便於學習，文中的所有例子都已經開源：</p><p>實現 1-6：</p><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">https://github.com/houbb/sync/tree/master/sync-test/src/main/java/com/github/houbb/sync/test/demo</span></p></blockquote><blockquote class=pgc-blockquote-abstract><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">https://github.com/houbb/spring-framework-learn/tree/master/spring-learn-core/spring-core-ioc/src/main/java/com/github/houbb/spring/lean/core/ioc/event</span></p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>java</a></li><li><a>手寫</a></li><li><a>異步查</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html alt=java相關知識(10)總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/84649e6ba0f8442a8b10584403bf6635 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html title=java相關知識(10)總結>java相關知識(10)總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html alt=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d69c7c9d8b85444da9360e334ba6555d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html title=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID>java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html alt=多態的本質，java動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac000493fbc8532b5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html title=多態的本質，java動態綁定>多態的本質，java動態綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html alt=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/54d45b20ef6a4a3f960411db61474538 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html title=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到>java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html alt="java 常用的正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1540129072390e6c4c05126 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html title="java 常用的正則表達式">java 常用的正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a81470d4.html alt=java常用正則表達式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c811c3c14e4a4fa4825845b2868ee645 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a81470d4.html title=java常用正則表達式>java常用正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d5b99796.html alt=java正則表達式括號的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/88ce74502881405281b2e2e5ae84f5d7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d5b99796.html title=java正則表達式括號的使用>java正則表達式括號的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03619879.html alt="java foreach  對異常的處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/66551f46-dfc4-46b3-8cb2-b3551d77e648 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03619879.html title="java foreach  對異常的處理">java foreach 對異常的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html alt=java反射機制的講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad2c92f100a4d2e8213dcf70d4781c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html title=java反射機制的講解>java反射機制的講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaf6fcd.html alt=手寫壁紙｜你從這邊走向那邊，你避開了我的一生 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535341020756dc1a9b3f3f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaf6fcd.html title=手寫壁紙｜你從這邊走向那邊，你避開了我的一生>手寫壁紙｜你從這邊走向那邊，你避開了我的一生</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ff2ba73c.html alt=java併發編程-學習方法、進程和線程的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/96ffe13dbf2b45109664e14541532812 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ff2ba73c.html title=java併發編程-學習方法、進程和線程的區別>java併發編程-學習方法、進程和線程的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7ce9ac1.html alt=java併發編程之進程狀態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0779ab7cadfe428f8d74d66161aa48b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7ce9ac1.html title=java併發編程之進程狀態>java併發編程之進程狀態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d62f6365.html alt=java併發編程之進程與線程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1b777a6b4c24fc390776034329c92d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d62f6365.html title=java併發編程之進程與線程>java併發編程之進程與線程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16ab9720.html alt=java線程池處理多併發，所有進程執行完後再統一處理結果 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/b0473c60-cc05-42ed-82b1-497bfe51bfcc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16ab9720.html title=java線程池處理多併發，所有進程執行完後再統一處理結果>java線程池處理多併發，所有進程執行完後再統一處理結果</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/527c993b.html alt=手動通過，java通過反射和自定義註解實現後臺參數值的驗證 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1535370707542a7e32b8c63 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/527c993b.html title=手動通過，java通過反射和自定義註解實現後臺參數值的驗證>手動通過，java通過反射和自定義註解實現後臺參數值的驗證</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>