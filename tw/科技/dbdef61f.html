<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java互聯網架構-人情世故併發機制的底層實現原理 | 极客快訊</title><meta property="og:title" content="Java互聯網架構-人情世故併發機制的底層實現原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/56890004e0cc27e42702"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbdef61f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbdef61f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dbdef61f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbdef61f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbdef61f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dbdef61f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dbdef61f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbdef61f.html><meta property="article:published_time" content="2020-11-14T21:00:35+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:35+08:00"><meta name=Keywords content><meta name=description content="Java互聯網架構-人情世故併發機制的底層實現原理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/dbdef61f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java互聯網架構-人情世故併發機制的底層實現原理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>概述</strong></p><p>Java併發機制的底層實現原理</p><p>Java代碼的一生：</p><p>編譯後變成Java字節碼</p><p>字節碼被類加載器加載到jvm</p><p>jvm執行字節碼，最終轉換為彙編指令在CPU上運行</p><p>volatile實現原理</p><p>volatile在併發編程中扮演著重要的角色，volatile就像是輕量級的synchronized，它在多處理器中保證了共享變量的可見性。可見性的意思是當一個線程修改一個共享變量時，其他線程能夠及時讀取到這個修改的值。由於volatile並不會引起線程上下文的切換和調度，所以它比synchronized的使用和執行成本更低。volatile在併發編程中還起著另一個作用---那就是禁止指令重排。我們知道，編譯器在對Java代碼進行優化的時候可能會發生指令重排，指令重排對於CPU來說就是指令亂序執行，這是多條指令在流水線上執行，很好地利用了多處理器。雖然這樣在單線程語義中不會發生什麼錯誤，但是可能在多線程中會出現一些併發性問題，關於這一點我在後面會提到。首先來說說volatile如何保證可見性。</p><p>volatile保證可見性</p><p>Java語言規範第3版中對volatile的定義是這樣的：Java編程語言允許線程訪問共享變量，為了確保共享變量能被準確和一致地更新，線程應該確保通過排他鎖單獨獲得這個變量。Java語言提供了volatile，在某些情況下比鎖要更方便。如果一個字段聲明成volatile，Java線程內存模型確保所有線程看到這個變量的值是一致的。</p><p>那麼volatile是如何保證可見性的呢？</p><p>在對volatile修飾的變量進行寫操作的時，轉變成的彙編代碼會多出一條Lock前綴的指令，Lock前綴的指令在多核處理器下引發了兩件事情：</p><p>將當前處理器緩存行的數據寫回到系統內存；</p><p>這個寫回內存的操作會使其他CPU裡緩存了該內存地址的數據無效。</p><p>為了提高處理速度，處理器不直接與內存進行通信，而是先將系統內存的數據讀到內部緩存後再進行操作，但操作完不知道何時會寫到內存。如果對被volatile聲明的變量進行寫操作，JVM虛擬機就會向處理器發送一條Lock前綴的指令，將這個變量所在緩存行的數據寫回到內存當中。同時為了保證各個處理器的緩存是一致的，就會實現緩存一致性協議，每個處理器通過嗅探在總線上傳播的數據來檢查自己緩存的值是不是過期了，當處理器發現自己緩存行對應的內存地址被修改，就會將當前處理器的緩存行設置成無效狀態，當處理器對這個數據進行修改操作的時候，會重新從系統內存中把數據讀到處理器緩存當中。</p><p>volatile的兩條實現原則底層實現</p><p>Lock前綴指令會引起處理器緩存回寫到內存：Lock前綴指令導致在執行指令期間，聲言處理器的LOCK#信號。在多處理器環境中，LOCK#信號確保在聲言該信號期間，處理器可以獨佔任何共享內存(在以前的處理器當中，這條指令會鎖住總線導致其他CPU無法訪問總線從而限制其他處理器無法訪問系統內存)。但是在現在的處理器中，一般不會鎖總線而是鎖緩存，因為鎖總線的開銷比較大。對於某些處理器來說，它們在鎖操作時，總是在總線上聲言LOCK#信號。但是對於另外一些處理器來說，它們不會聲言LOCK#信號。相反，它會鎖定這塊內存區域的緩存並回寫到內存，並使用緩存一致性機制來確保修改的原子性，此操作被稱為“緩存鎖定”，緩存一致性機制會阻止同時修改由兩個以上處理器緩存的內存區域數據。</p><p>一個處理器的緩存回寫到內存會導致其它處理器的緩存無效：一些處理使用MESI控制協議去維護內部緩存和其他處理器緩存的一致性。在多核處理器系統中進行操作的時候，一些處理器能夠嗅探其他處理器訪問系統內存和它們的內部緩存。處理器使用嗅探技術保證它的內部緩存、系統內存和其他處理器的緩存的數據在總線上保持一致。例如，在某些處理器中如果通過嗅探一個處理器來檢測其它處理器打算寫內存地址，而這個地址當前處於共享狀態，那麼正在嗅探的處理器將使它的緩存無效，在下次訪問相同內存地址時，強制執行緩存行填充。</p><p>volatile禁止指令重排</p><p>volatile為寫-讀建立happens-before關係</p><p>在多處理器對指令進行流水線處理時，不可避免地會發生亂序執行，即指令重排的情況發生。在某些時候，這種優化可能會導致併發性問題。但是volatile能夠禁止指令重排，其底層是通過在讀和寫指令前後插入內存屏障實現的。下面以DCL單例為例進行說明：</p><p><img alt=Java互聯網架構-人情世故併發機制的底層實現原理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/56890004e0cc27e42702></p><p>上面這個DCL懶漢式看起來很美好地實現單例模式----先檢測singleton對象是否為空，如果為空就鎖定Singleton類，接著再次檢測singleton對象是否為空，若為空就進行實例化操作最後返回實例化的對象。但是它會存在不安全發佈的情況---即對象還未完成初始化就發佈出去了，將會引發一系列的問題。</p><p>下面我們詳細說說為什麼會發生不安全發佈的問題</p><p>這裡是singleton對象初始化的過程：</p><p>分配對象的內存空間；</p><p>初始化對象；</p><p>設置singleton指向剛剛分配的內存空間。</p><p>上面是正常初始化一個對象的流程。可是由於指令重排的存在，步驟2和步驟3可能會亂序執行。此時假如有線程A和線程B同時調用上面代碼中的getSingleton()函數，假設A先B一步已經開始進行對象初始化過程了。由於指令重排的存在，A可能先進行步驟3的操作----設置singleton指向分配的內存空間。此時B才開始調用getSingleton()方法，想要獲得一個singleton對象。然後它發現singleton指向的內存區域不為空，就直接返回了singleton。可是此時線程A由於亂序執行的原因，可能尚未進行對象的初始化或者是對象初始化還沒有完成，這就導致了一個沒有完全初始化的對象被髮布了，這可能導致非常嚴重的問題。所以DCL雙鎖單例模式並不完美。</p><p>但是假如把對象用volatile關鍵字修飾，那就可以避免在對象進行初始化的過程中發生指令重排的情況，從而避免對象的不安全發佈現象的發生。</p><p><img alt=Java互聯網架構-人情世故併發機制的底層實現原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/568e0001f46d59f2a229></p><p>既然提到了單例，那麼下面就介紹另一種線程安全的單例模式實現</p><p>基於類初始化的安全單例模式</p><p>JVM在類初始化階段(即在Class被加載後，且被線程使用之前)，會執行類的初始化操作。在執行類的初始化期間，JVM會去獲取一個鎖。這個鎖可以同步多個線程對同一個類的初始化。基於這個特性，可以實現另一種線程安全的延遲初始化方案：</p><p><img alt=Java互聯網架構-人情世故併發機制的底層實現原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/568d000272ba33bcd5e2></p><p>Java語言規範規定，對於每一個類或接口C，都有一個唯一的初始化鎖LC與之對應。從C到LC的映射，由JVM的具體實現去自由實現。JVM在類初始化期間會獲取這個初始化鎖，並且每個線程至少獲取一次鎖來確保這個類已經被初始化了。</p><p>synchronized實現原理</p><p>synchronized在大部分時候是實現同步的基礎：Java中每一個對象都可以作為鎖，具體表現為以下3種形式：</p><p>對於普通同步方法，鎖是當前實例對象；</p><p>對於靜態同步方法，鎖是當前類的Class對象；</p><p>對於同步方法塊，鎖是synchronized括號裡配置的對象。</p><p>關於synchronized底層實現原理，我在這篇博客裡面介紹了。</p><p>Java虛擬機規範</p><p>JVM基於進入和退出Monitor對象來實現方法同步以及代碼塊同步，但兩者的實現細節不太一樣，代碼塊同步是使用monitorenter和monitorexit指令實現的，方法同步是在方法表中添加一個ACC_SYNC的標誌位，但是方法的同步同樣可以使用這兩個指令來實現。</p><p>鎖的升級與對比</p><p>鎖一共有四種狀態，級別由低到高一次是：無鎖狀態、偏向鎖狀態、輕量級鎖狀態、重量級鎖狀態。這幾個狀態會隨著競爭情況逐漸升級，鎖可以升級但不可以降級(這裡和後面提到的ReentrantReadWriteLock中的寫鎖降級為讀鎖不是一回事)，即輕量級鎖升級為重量級鎖之後不能降級成輕量級鎖。這種鎖升級後不能降級的策略的目的是為了提高獲取鎖和釋放鎖的效率。</p><p>偏向鎖</p><p>大多數情況下，鎖不僅不存在多線程競爭，而且總是由同一線程多次獲得，為了讓線程獲得鎖的代價更低而引入了偏向鎖。當一個線程訪問同步塊並獲取鎖時，會在對象頭和棧幀中的鎖記錄當中存儲鎖偏向的線程ID，以後該線程在進入和退出同步塊時不需要進行CAS操作來加鎖和解鎖，只需要簡單地測試一下對象頭的Mark Word裡是否存儲著指向當前線程的偏向鎖。如果測試成功則代表當前線程已經獲得了鎖，如果測試失敗則需要再測試一下Mark Word中偏向鎖的標誌是否設置成為了1(表示當前是偏向鎖)：如果沒有設置，則使用CAS競爭鎖，如果設置了，則嘗試使用CAS將對象頭的偏向鎖指向當前線程。</p><p>偏向鎖的撤銷</p><p>偏向鎖使用了一種等到出現競爭才釋放鎖的機制，所以當其他線程嘗試競爭偏向鎖的時候，持有偏向鎖的線程才會釋放鎖。偏向鎖的撤銷，需要等待全局安全點(在這個時間點上沒有正在執行的字節碼)。它會首先暫停擁有偏向鎖的線程，然後檢查持有偏向鎖的線程是否還活著，如果線程不處於活動狀態，則將對象頭設置為無所狀態；如果線程仍然活著，持有偏向鎖的棧會被執行，遍歷對象的鎖記錄，棧中的鎖記錄和對象頭的Mark Word要麼重新偏向於其他線程，要麼恢復到無鎖或者標記對象不適合所謂偏向鎖，最後喚醒暫停的線程。</p><p>關閉偏向鎖</p><p>偏向鎖在jdk1.6和jdk1.7裡面是默認啟用的，但是它在應用程序啟動幾秒之後才激活，如有必要可使用參數來關閉延遲：-XX:BiasedLockingStartupDelay=0。如果我們確定應用程序裡所有的鎖通常情況下處於競爭狀態，可以通過參數來關閉偏向鎖:-XX:-UseBiasedLocking=false，那麼程序默認會進入輕量級鎖狀態。</p><p>輕量級鎖</p><p>輕量級鎖加鎖</p><p>線程在執行同步塊之前，JVM會先在當前線程的棧幀中創建存儲鎖記錄的空間，並將對象頭中的Mark Word複製到鎖記錄中，即Displaced Mark Word。然後線程嘗試使用CAS將對象頭中的Mark Word替換為指向鎖記錄的指針。若成功，當前線程獲得鎖；若失敗，表示其他線程競爭鎖，當前線程便嘗試使用自旋來獲取鎖。</p><p>輕量級鎖解鎖</p><p>輕量級鎖解鎖時，會使用原子的CAS操作將Displaced Mark Word替換到對象頭。如果成功，則表示沒有競爭發生。如果失敗，表示當前鎖存在競爭，鎖就會膨脹成重量級鎖。</p><p>鎖優點缺點適用場景</p><p>偏向鎖加鎖和解鎖不需要額外的消耗，和執行非同步方法相比僅存在納秒級的差距如果線程間存在鎖競爭，會帶來額外的消耗適用於只有一個線程訪問同步塊場景</p><p>輕量級鎖競爭的線程不會阻塞，提高了程序的響應速度如果始終得不到鎖競爭的線程，使用自旋會消耗CPU追求響應速度，同步塊執行速度非常快</p><p>重量級鎖線程競爭不會自旋，不會消耗CPU資源線程阻塞，響應速度緩慢追求吞吐量，同步塊執行時間比較長</p><p>原子操作實現原理</p><p>處理器如何實現原子操作</p><p>使用總線鎖保證原子性。第一個機制是通過總線鎖保證原子性，所謂總線鎖就是使用處理器提供的一個LOCK#信號，當一個處理器在總線上輸出此信號時，其他處理器的請求將被阻塞住，那麼該處理器可以獨佔共享內存；</p><p>使用緩存鎖保證原子性。因為在同一時刻，我們只需保證對某個內存地址的操作是原子性即可，但總線鎖把CPU和內存之間的通信鎖住了，這使得鎖定期間，其他處理器不能操作其他內存地址的數據，所以總線鎖定的開銷比較大，目前處理器在某些場合下使用緩存鎖定代替總線鎖定來進行優化。</p><p>但是在這兩種情況下處理器不會使用緩存鎖定：</p><p>當操作的數據不能被還存在處理器內部，或操作的數據跨多個緩存行時，處理器會調用總線鎖定；</p><p>有些處理器不支持緩存鎖定。</p><p>Java中如何實現原子操作</p><p>在Java中可以通過鎖和循環CAS來實現原子操作。從jdk1.5開始，JDK的併發包裡面提供了一些類來支持原子操作，如AtomicBoolean(用原子的方式更新的boolean值)、AtomicInteger(用原子方式更新的int值)和AtomicLong等。這些原子包裝類提供了有用的工具方法，例如以原子的方式將當前值自增1或自減1。</p><p>CAS實現原子操作的三大問題</p><p>ABA問題；</p><p>循環時間長開銷大；</p><p>只能保證一個共享變量的原子操作。從jdk1.5開始，JDK提供了AtomicReference類來保證引用對象之間的原子性，就可以把多個變量放在一個對象裡來進行CAS操作。</p><p>使用鎖機制實現原子操作</p><p>鎖機制保證了只有獲得鎖的線程才能操作鎖定的內存區域。JVM內部實現了很多種鎖機制，有偏向鎖、輕量級鎖和互斥鎖。有意思的是，除了偏向鎖，JVM實現鎖的方式都使用了循環CAS，即當一個線程想進入同步塊的時候使用循環CAS的方式來獲取鎖，當它退出同步塊的時候使用循環CAS釋放鎖。</p><p>final的內存語義</p><p>與鎖和volatile相比，對final域的讀寫更像是普通的變量訪問。但其實final在某些時候也可以用來防止對象的不安全發佈，下面來說說final的內存語義。</p><p>final的重排序規則</p><p>對於final域，編譯器和處理器要遵守兩個重排序規則：</p><p>在構造函數內對一個final域的寫入，與隨後把這個構造函數的引用賦值給一個引用的變量，這兩個操作之間不能重排序；</p><p>初次都一個包含final域的對象的引用，與隨後初次讀這個final域，這兩個操作之間不能重排序。</p><p>寫final域的重排序規則</p><p>JMM禁止編譯器把final域的寫重排序到構造函數之外；</p><p>編譯器會在final域的寫之後，構造函數return之前，插入一個StoreStore屏障。這個屏障禁止處理器把final域的寫重排序到構造函數之外。</p><p>讀final域的重排序規則</p><p>讀final域的重排序規則是，在一個線程中，初次讀對象引用與初次讀該對象包含的final域，JMM禁止處理器重排序這兩個操作(這裡要注意，此規則僅僅針對處理器)。編譯器會在讀final域操作的前面插入一個LoadLoad屏障。</p><p>初次讀對象引用與初次讀該對象包含的final域，這兩個操作之間存在間接依賴關係。由於編譯器遵守間接依賴關係，因此編譯器不會重排序這兩個操作。大多數處理器也會遵守間接依賴，也不會遵守重排序這兩個操作。讀final域的重排序規則可以確保：在讀一個對象的final域之前，一定會先讀包含這個final域的對象的引用，如果該引用不為空，那麼引用對象的final域一定已經被A線程初始化過了。</p><p>如果final域為引用類型</p><p>對於引用類型，寫final域的重排序規則對編譯器和處理器做了如下約束：在構造函數內對一個final引用的對象的成員域的寫入，與隨後在構造函數外吧這個被構造對象的引用賦值給一個引用變相，這兩個操作之間不能重排序。</p><p>寫final域的規則可以確保在引用變量為任意線程可見之前，該引用變量指向的對象的final域已經在構造函數中被正確初始化過了。其實要得到這個效果，還需要一個保證：那就是在構造函數內部，不能讓這個被構造對象的引用為其他線程所見，也就是對象引用不能再構造函數中"逸出"，即不能發生this逸出的情況。</p><h1>總結</h1><p>到這裡，人情世故併發機制的底層實現原理就結束了，，不足之處還望大家多多包涵！！覺得收穫的話可以點個關注收藏轉發一波喔，謝謝大佬們支持。（吹一波，233~~）</p><p>下面和大家交流幾點編程的經驗：</p><p>1、多寫多敲代碼，好的代碼與紮實的基礎知識一定是實踐出來的</p><p>2丶 測試、測試再測試，如果你不徹底測試自己的代碼，那恐怕你開發的就不只是代碼，可能還會聲名狼藉。</p><p>3丶 簡化編程，加快速度，代碼風騷，在你完成編碼後，應回頭並且優化它。從長遠來看，這裡或那裡一些的改進，會讓後來的支持人員更加輕鬆。</p><p>最後，每一位讀到這裡的網友，感謝你們能耐心地看完。希望在成為一名更優秀的Java程序員的道路上，我們可以一起學習、一起進步。</p><p>內部交流群569068099 歡迎各位前來交流和分享， 驗證：（007）</p><h1>Java小毛驢，頭條出品，每天一篇乾貨，喜歡就收藏＋關注</h1><p><img alt=Java互聯網架構-人情世故併發機制的底層實現原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/568c00043df17fa1ab60></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>互聯</a></li><li><a>網架構</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/91645749.html alt=Java互聯網架構-P7架構師教你重新認識HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/9fd772ed-1884-405f-8e67-408800d5c62f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91645749.html title=Java互聯網架構-P7架構師教你重新認識HashMap>Java互聯網架構-P7架構師教你重新認識HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>