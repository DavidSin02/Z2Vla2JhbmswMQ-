<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java源碼分析：關於 HashMap 1.8 的重大更新 | 极客快訊</title><meta property="og:title" content="Java源碼分析：關於 HashMap 1.8 的重大更新 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/66c40005d5e8c29e8c31"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dd535810.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dd535810.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dd535810.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dd535810.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dd535810.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dd535810.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dd535810.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dd535810.html><meta property="article:published_time" content="2020-10-29T21:09:21+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:21+08:00"><meta name=Keywords content><meta name=description content="Java源碼分析：關於 HashMap 1.8 的重大更新"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/dd535810.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java源碼分析：關於 HashMap 1.8 的重大更新</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>前言</h1><blockquote><p>HashMap<span>在 </span>Java<span>和 </span>Android<span>開發中非常常見而</span>HashMap 1.8<span>相對於 </span>HashMap 1.7<span>更新多</span><span>今天，我將通過源碼分析</span>HashMap 1.8<span>，從而講解</span>HashMap 1.8<span>相對於 </span>HashMap 1.7<span> 的更新內容，希望你們會喜歡。</span></p></blockquote><p>本文基於版本 <code>JDK 1.8<span>，即 </span>Java 8<span>關於版本 </span>JDK 1.7<span>，即 </span>Java 7<span>，</span></code></p><h1>2. 數據結構</h1><p>2.1 具體描述</p><p><code>HashMap<span>採用的數據結構 = 數組（主） + 單鏈表（副），具體描述如下</span></code></p><br><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c40005d5e8c29e8c31></p><hr><h1></h1><p>1. 簡介</p><ul class=list-paddingleft-2><li><p>類定義</p></li></ul><pre>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable123</pre><ul class=list-paddingleft-2><li><p>主要簡介</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c8000464f356ad5bd6></p><p><code>HashMap<span> 的實現在 </span>JDK 1.7<span>和 </span>JDK 1.8<span>差別較大今天，我將對照 </span>JDK 1.7<span>的源碼，在此基礎上講解 </span>JDK 1.8<span> 中 </span></code><code>HashMap<span>的源碼解析</span></code></p><h1></h1><p>2. 數據結構：引入了 紅黑樹</p><p>2.1 主要介紹</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6c2c0000784d6002fef8></p><p class=pgc-img-caption>紅黑樹</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/66c50005b18009e52a9b></p><p>2.2 存儲流程</p><blockquote><p>注：為了讓大家有個感性的認識，只是簡單的畫出存儲流程，更加詳細 & 具體的存儲流程會在下面源碼分析中給出</p></blockquote><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c50005b1813a94a7d6></p><p><strong>2.3 數組元素 & 鏈表節點的 實現類</strong></p><p><code>HashMap<span>中的數組元素 & 鏈表節點 採用 </span>Node<span>類 實現</span><span>與 </span>JDK 1.7<span>的對比（</span>Entry<span>類），僅僅只是換了名字</span></code></p><ul class=list-paddingleft-2><li><p>該類的源碼分析如下</p><blockquote><p>具體分析請看註釋</p></blockquote></li></ul><pre>/** * Node = HashMap的內部類，實現了Map.Entry接口，本質是 = 一個映射(鍵值對) * 實現了getKey()、getValue()、equals(Object o)和hashCode()等方法 **/  static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; // 哈希值，HashMap根據該值確定記錄的位置 final K key; // key V value; // value Node&lt;K,V&gt; next;// 鏈表下一個節點 // 構造方法 Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } // 返回 與 此項 對應的鍵 public final V getValue() { return value; } // 返回 與 此項 對應的值 public final String toString() { return key + "=" + value; }  public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } /** * hashCode（） */ public final int hashCode() {  return Objects.hashCode(key) ^ Objects.hashCode(value); } /** * equals（） * 作用：判斷2個Entry是否相等，必須key和value都相等，才返回true  */ public final boolean equals(Object o) {  if (o == this)  return true;  if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;  if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))  return true; } return false; } }</pre><p><strong>2.4 紅黑樹節點 實現類</strong><br></p><p><code>HashMap<span>中的紅黑樹節點 採用 </span>TreeNode<span>類 實現</span></code></p><pre>/** * 紅黑樹節點 實現類：繼承自LinkedHashMap.Entry&lt;K,V&gt;類 */ static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {  // 屬性 = 父節點、左子樹、右子樹、刪除輔助節點 + 顏色 TreeNode&lt;K,V&gt; parent;  TreeNode&lt;K,V&gt; left;  TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev;  boolean red;  // 構造函數 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) {  super(hash, key, val, next);  }  // 返回當前節點的根節點  final TreeNode&lt;K,V&gt; root() {  for (TreeNode&lt;K,V&gt; r = this, p;;) {  if ((p = r.parent) == null)  return r;  r = p;  }  } 12345678910111213141516171819202122232425</pre><hr><h1></h1><p>3. 具體使用</p><p>3.1 主要使用API（方法、函數）</p><blockquote><p>與 <code>JDK 1.7</code> 基本相同</p></blockquote><pre>V get(Object key); // 獲得指定鍵的值V put(K key, V value); // 添加鍵值對void putAll(Map&lt;? extends K, ? extends V&gt; m); // 將指定Map中的鍵值對 複製到 此Map中V remove(Object key); // 刪除該鍵值對boolean containsKey(Object key); // 判斷是否存在該鍵的鍵值對；是 則返回trueboolean containsValue(Object value); // 判斷是否存在該值的鍵值對；是 則返回trueSet&lt;K&gt; keySet(); // 單獨抽取key序列，將所有key生成一個SetCollection&lt;V&gt; values(); // 單獨value序列，將所有value生成一個Collectionvoid clear(); // 清除哈希表中的所有鍵值對int size(); // 返回哈希表中所有 鍵值對的數量 = 數組中的鍵值對 + 鏈表中的鍵值對boolean isEmpty(); // 判斷HashMap是否為空；size == 0時 表示為 空 123456789101112131415</pre><p><strong>3.2 使用流程</strong></p><blockquote><p>與 <span>JDK 1.7</span>基本相同</p></blockquote><ul class=list-paddingleft-2><li><p>在具體使用時，主要流程是：</p></li></ul><p>聲明1個 <span>HashMap</span>的對象</p><p>向 <span>HashMap</span><br>添加數據（成對 放入 鍵 - 值對）</p><ol class=list-paddingleft-2><li><p>獲取 <code>HashMap</code> 的某個數據</p></li><li><p>獲取 <code>HashMap</code> 的全部數據：遍歷<code>HashMap</code></p></li></ol><ul class=list-paddingleft-2><li><p>示例代碼</p></li></ul><pre>import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;public class HashMapTest { public static void main(String[] args) { /** * 1. 聲明1個 HashMap的對象 */ Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); /** * 2. 向HashMap添加數據（成對 放入 鍵 - 值對） */ map.put("Android", 1); map.put("Java", 2); map.put("iOS", 3); map.put("數據挖掘", 4); map.put("產品經理", 5); /** * 3. 獲取 HashMap 的某個數據 */ System.out.println("key = 產品經理時的值為：" + map.get("產品經理")); /** * 4. 獲取 HashMap 的全部數據：遍歷HashMap * 核心思想： * 步驟1：獲得key-value對（Entry） 或 key 或 value的Set集合 * 步驟2：遍歷上述Set集合(使用for循環 、 迭代器（Iterator）均可) * 方法共有3種：分別針對 key-value對（Entry） 或 key 或 value */ // 方法1：獲得key-value的Set集合 再遍歷 System.out.println("方法1"); // 1. 獲得key-value對（Entry）的Set集合  Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet(); // 2. 遍歷Set集合，從而獲取key-value // 2.1 通過for循環 for(Map.Entry&lt;String, Integer&gt; entry : entrySet){ System.out.print(entry.getKey()); System.out.println(entry.getValue()); } System.out.println("----------"); // 2.2 通過迭代器：先獲得key-value對（Entry）的Iterator，再循環遍歷 Iterator iter1 = entrySet.iterator(); while (iter1.hasNext()) { // 遍歷時，需先獲取entry，再分別獲取key、value Map.Entry entry = (Map.Entry) iter1.next(); System.out.print((String) entry.getKey()); System.out.println((Integer) entry.getValue()); } // 方法2：獲得key的Set集合 再遍歷 System.out.println("方法2"); // 1. 獲得key的Set集合 Set&lt;String&gt; keySet = map.keySet(); // 2. 遍歷Set集合，從而獲取key，再獲取value // 2.1 通過for循環 for(String key : keySet){ System.out.print(key); System.out.println(map.get(key)); } System.out.println("----------"); // 2.2 通過迭代器：先獲得key的Iterator，再循環遍歷 Iterator iter2 = keySet.iterator(); String key = null; while (iter2.hasNext()) { key = (String)iter2.next(); System.out.print(key); System.out.println(map.get(key)); } // 方法3：獲得value的Set集合 再遍歷 System.out.println("方法3"); // 1. 獲得value的Set集合 Collection valueSet = map.values(); // 2. 遍歷Set集合，從而獲取value // 2.1 獲得values 的Iterator Iterator iter3 = valueSet.iterator(); // 2.2 通過遍歷，直接獲取value while (iter3.hasNext()) { System.out.println(iter3.next()); } }}// 注：對於遍歷方式，推薦使用針對 key-value對（Entry）的方式：效率高// 原因： // 1. 對於 遍歷keySet 、valueSet，實質上 = 遍歷了2次：1 = 轉為 iterator 迭代器遍歷、2 = 從 HashMap 中取出 key 的 value 操作（通過 key 值 hashCode 和 equals 索引） // 2. 對於 遍歷 entrySet ，實質 = 遍歷了1次 = 獲取存儲實體Entry（存儲了key 和 value ）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106</pre><ul class=list-paddingleft-2><li><p>運行結果</p></li></ul><pre>方法1Java2iOS3數據挖掘4Android1產品經理5----------Java2iOS3數據挖掘4Android1產品經理5方法2Java2iOS3數據挖掘4Android1產品經理5----------Java2iOS3數據挖掘4Android1產品經理5方法3</pre><p>下面，我們按照上述的使用過程，對一個個步驟進行源碼解析</p><hr><h1></h1><p>4. 基礎知識：HashMap中的重要參數（變量）</p><ul class=list-paddingleft-2><li><p>在進行真正的源碼分析前，先講解<code>HashMap</code>中的重要參數（變量）</p></li><li><p><code>HashMap</code>中的主要參數 同 <code>JDK 1.7</code> ，即：容量、加載因子、擴容閾值</p></li><li><p>但由於數據結構中引入了 紅黑樹，故加入了 與紅黑樹相關的參數。具體介紹如下：</p></li></ul><pre>/** * 主要參數 同 JDK 1.7 * 即：容量、加載因子、擴容閾值（要求、範圍均相同） */ // 1. 容量（capacity）： 必須是2的冪 &amp; &lt;最大容量（2的30次方） static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 默認容量 = 16 = 1&lt;&lt;4 = 00001中的1向左移4位 = 10000 = 十進制的2^4=16 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 最大容量 = 2的30次方（若傳入的容量過大，將被最大值替換） // 2. 加載因子(Load factor)：HashMap在其容量自動增加前可達到多滿的一種尺度 final float loadFactor; // 實際加載因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默認加載因子 = 0.75 // 3. 擴容閾值（threshold）：當哈希表的大小 ≥ 擴容閾值時，就會擴容哈希表（即擴充HashMap的容量） // a. 擴容 = 對哈希表進行resize操作（即重建內部數據結構），從而哈希表將具有大約兩倍的桶數 // b. 擴容閾值 = 容量 x 加載因子 int threshold; // 4. 其他 transient Node&lt;K,V&gt;[] table; // 存儲數據的Node類型 數組，長度 = 2的冪；數組的每個元素 = 1個單鏈表 transient int size;// HashMap的大小，即 HashMap中存儲的鍵值對的數量 /** * 與紅黑樹相關的參數 */ // 1. 桶的樹化閾值：即 鏈表轉成紅黑樹的閾值，在存儲數據時，當鏈表長度 &gt; 該值時，則將鏈表轉換成紅黑樹 static final int TREEIFY_THRESHOLD = 8; // 2. 桶的鏈表還原閾值：即 紅黑樹轉為鏈表的閾值，當在擴容（resize（））時（此時HashMap的數據存儲位置會重新計算），在重新計算存儲位置後，當原有的紅黑樹內數量 &lt; 6時，則將 紅黑樹轉換成鏈表 static final int UNTREEIFY_THRESHOLD = 6; // 3. 最小樹形化容量閾值：即 當哈希表中的容量 &gt; 該值時，才允許樹形化鏈表 （即 將鏈表 轉換成紅黑樹） // 否則，若桶內元素太多時，則直接擴容，而不是樹形化 // 為了避免進行擴容、樹形化選擇的衝突，這個值不能小於 4 * TREEIFY_THRESHOLD static final int MIN_TREEIFY_CAPACITY = 64;1234567891011121314151617181920212223242526272829303132333435</pre><ul class=list-paddingleft-2><li><p>此處 再次詳細說明 加載因子</p><blockquote><p>同 <code>JDK 1.7</code>，但由於其重要性，故此處再次說明</p></blockquote></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c40005d5e78ac067ca></p><ul class=list-paddingleft-2><li><p>總結 數據結構 & 參數方面與 <code>JDK 1.7</code>的區別</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c600059db5d3b92c0b></p><hr><h1></h1><p>5. 源碼分析</p><ul class=list-paddingleft-2><li><p>本次的源碼分析主要是根據 使用步驟 進行相關函數的詳細分析</p></li><li><p>主要分析內容如下：</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c50005b18388095faa></p><ul class=list-paddingleft-2><li><p>下面，我將對每個步驟內容的主要方法進行詳細分析</p></li></ul><p>步驟1：聲明1個 HashMap的對象</p><blockquote><p>此處主要分析的構造函數 類似 <code>JDK 1.7</code></p></blockquote><pre>/** * 函數使用原型 */ Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); /** * 源碼分析：主要是HashMap的構造函數 = 4個 * 僅貼出關於HashMap構造函數的源碼 */public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable{ // 省略上節闡述的參數 /** * 構造函數1：默認構造函數（無參） * 加載因子 &amp; 容量 = 默認 = 0.75、16 */ public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; } /** * 構造函數2：指定“容量大小”的構造函數 * 加載因子 = 默認 = 0.75 、容量 = 指定大小 */ public HashMap(int initialCapacity) { // 實際上是調用指定“容量大小”和“加載因子”的構造函數 // 只是在傳入的加載因子參數 = 默認加載因子 this(initialCapacity, DEFAULT_LOAD_FACTOR); } /** * 構造函數3：指定“容量大小”和“加載因子”的構造函數 * 加載因子 &amp; 容量 = 自己指定 */ public HashMap(int initialCapacity, float loadFactor) { // 指定初始容量必須非負，否則報錯  if (initialCapacity &lt; 0)  throw new IllegalArgumentException("Illegal initial capacity: " +  initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕傳入的 &gt; 最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 填充比必須為正  if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))  throw new IllegalArgumentException("Illegal load factor: " +  loadFactor);  // 設置 加載因子 this.loadFactor = loadFactor; // 設置 擴容閾值 // 注：此處不是真正的閾值，僅僅只是將傳入的容量大小轉化為：&gt;傳入容量大小的最小的2的冪，該閾值後面會重新計算 // 下面會詳細講解 -&gt;&gt; 分析1 this.threshold = tableSizeFor(initialCapacity); } /** * 構造函數4：包含“子Map”的構造函數 * 即 構造出來的HashMap包含傳入Map的映射關係 * 加載因子 &amp; 容量 = 默認 */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) { // 設置容量大小 &amp; 加載因子 = 默認 this.loadFactor = DEFAULT_LOAD_FACTOR; // 將傳入的子Map中的全部元素逐個添加到HashMap中 putMapEntries(m, false); }} /** * 分析1：tableSizeFor(initialCapacity) * 作用：將傳入的容量大小轉化為：&gt;傳入容量大小的最小的2的冪 * 與JDK 1.7對比：類似於JDK 1.7 中 inflateTable()裡的 roundUpToPowerOf2(toSize) */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394</pre><ul class=list-paddingleft-2><li><p>注：（同<code>JDK 1.7</code>類似）</p></li></ul><ol class=list-paddingleft-2><li><p>此處僅用於接收初始容量大小（<code>capacity</code>）、加載因子(<code>Load factor</code>)，但仍無真正初始化哈希表，即初始化存儲數組<code>table</code></p></li><li><p>此處先給出結論：真正初始化哈希表（初始化存儲數組<code>table</code>）是在第1次添加鍵值對時，即第1次調用<code>put（）</code>時。下面會詳細說明</p></li></ol><p>至此，關於<code>HashMap</code>的構造函數講解完畢。</p><hr><p>步驟2：向HashMap添加數據（成對 放入 鍵 - 值對）</p><ul class=list-paddingleft-2><li><p>在該步驟中，與<code>JDK 1.7</code>的差別較大：</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c40005d5e94511f385></p><blockquote><p>下面會對上述區別進行詳細講解</p></blockquote><ul class=list-paddingleft-2><li><p>添加數據的流程如下</p></li></ul><blockquote><p>注：為了讓大家有個感性的認識，只是簡單的畫出存儲流程，更加詳細 & 具體的存儲流程會在下面源碼分析中給出</p></blockquote><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c50005b1824587d233></p><ul class=list-paddingleft-2><li><p>源碼分析</p></li></ul><pre>/** * 函數使用原型 */ map.put("Android", 1); map.put("Java", 2); map.put("iOS", 3); map.put("數據挖掘", 4); map.put("產品經理", 5); /** * 源碼分析：主要分析HashMap的put函數 */ public V put(K key, V value) { // 1. 對傳入數組的鍵Key計算Hash值 -&gt;&gt;分析1 // 2. 再調用putVal（）添加數據進去 -&gt;&gt;分析2 return putVal(hash(key), key, value, false, true); }1234567891011121314151617</pre><p>下面，將詳細講解 上面的2個主要分析點</p><p>分析1：hash（key）</p><pre> /** * 分析1：hash(key) * 作用：計算傳入數據的哈希碼（哈希值、Hash值） * 該函數在JDK 1.7 和 1.8 中的實現不同，但原理一樣 = 擾動函數 = 使得根據key生成的哈希碼（hash值）分佈更加均勻、更具備隨機性，避免出現hash值衝突（即指不同key但生成同1個hash值） * JDK 1.7 做了9次擾動處理 = 4次位運算 + 5次異或運算 * JDK 1.8 簡化了擾動函數 = 只做了2次擾動 = 1次位運算 + 1次異或運算 */ // JDK 1.7實現：將 鍵key 轉換成 哈希碼（hash值）操作 = 使用hashCode() + 4次位運算 + 5次異或運算（9次擾動） static final int hash(int h) { h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); } // JDK 1.8實現：將 鍵key 轉換成 哈希碼（hash值）操作 = 使用hashCode() + 1次位運算 + 1次異或運算（2次擾動） // 1. 取hashCode值： h = key.hashCode() // 2. 高位參與低位的運算：h ^ (h &gt;&gt;&gt; 16)  static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // a. 當key = null時，hash值 = 0，所以HashMap的key 可為null  // 注：對比HashTable，HashTable對key直接hashCode（），若key為null時，會拋出異常，所以HashTable的key不可為null // b. 當key ≠ null時，則通過先計算出 key的 hashCode()（記為h），然後 對哈希碼進行 擾動處理： 按位 異或（^） 哈希碼自身右移16位後的二進制 } /** * 計算存儲位置的函數分析：indexFor(hash, table.length) * 注：該函數僅存在於JDK 1.7 ，JDK 1.8中實際上無該函數（直接用1條語句判斷寫出），但原理相同 * 為了方便講解，故提前到此講解 */ static int indexFor(int h, int length) {  return h &amp; (length-1); // 將對哈希碼擾動處理後的結果 與運算(&amp;) （數組長度-1），最終得到存儲在數組table的位置（即數組下標、索引） }1234567891011121314151617181920212223242526272829303132333435</pre><ul class=list-paddingleft-2><li><p>總結 計算存放在數組 table 中的位置（即數組下標、索引）的過程</p></li></ul><ol class=list-paddingleft-2><li><p>此處與 <code>JDK 1.7</code>的區別在於：<code>hash</code>值的求解過程中 哈希碼的二次處理方式（擾動處理）</p></li><li><p>步驟1、2 = <code>hash</code>值的求解過程</p></li></ol><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6c2c0000784ee1c19294></p><ul class=list-paddingleft-2><li><p>計算示意圖</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/66c600059db69a50fddc></p><hr><p>在瞭解 如何計算存放數組<code>table</code> 中的位置 後，所謂 知其然 而 需知其所以然，下面我將講解為什麼要這樣計算，即主要解答以下3個問題：</p><p>1. 為什麼不直接採用經過<code>hashCode（）</code>處理的哈希碼 作為 存儲數組<code>table</code>的下標位置？</p><p>2. 為什麼採用 哈希碼 與運算(&) （數組長度-1） 計算數組下標？</p><p>3. 為什麼在計算數組下標前，需對哈希碼進行二次處理：擾動處理？</p><p>在回答這3個問題前，請大家記住一個核心思想：</p><blockquote><p>所有處理的根本目的，都是為了提高 存儲<code>key-value</code>的數組下標位置 的隨機性 & 分佈均勻性，儘量避免出現hash值衝突。即：對於不同<code>key</code>，存儲的數組下標位置要儘可能不一樣</p></blockquote><p>問題1：為什麼不直接採用經過hashCode（）處理的哈希碼 作為 存儲數組table的下標位置？</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c900036919c401d7ea></p><ul class=list-paddingleft-2><li><p>為了解決 “哈希碼與數組大小範圍不匹配” 的問題，<code>HashMap</code>給出瞭解決方案：哈希碼 與運算（&） （數組長度-1），即問題3</p></li></ul><p>問題2：為什麼採用 哈希碼 與運算(&) （數組長度-1） 計算數組下標？</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c700053e563f1db8b8></p><p>問題3：為什麼在計算數組下標前，需對哈希碼進行二次處理：擾動處理？</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c90003691a9f82af6b></p><p>至此，關於怎麼計算 <code>key-value</code> 值存儲在<code>HashMap</code>數組位置 & 為什麼要這麼計算，講解完畢。</p><hr><p>分析2：putVal(hash(key), key, value, false, true);</p><p>此處有2個主要講解點：</p><ul class=list-paddingleft-2><li><p>計算完存儲位置後，具體該如何 存放數據 到哈希表中</p></li><li><p>具體如何擴容，即 擴容機制</p></li></ul><p>主要講解點1：計算完存儲位置後，具體該如何存放數據到哈希表中</p><p>由於數據結構中加入了紅黑樹，所以在存放數據到哈希表中時，需進行多次數據結構的判斷：數組、紅黑樹、鏈表</p><blockquote><p>只需判斷 數組 & 鏈表</p></blockquote><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c2c000078500a45662f></p><pre> /** * 分析2：putVal(hash(key), key, value, false, true) */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 1. 若哈希表的數組tab為空，則 通過resize() 創建 // 所以，初始化哈希表的時機 = 第1次調用put函數時，即調用resize() 初始化創建 // 關於resize（）的源碼分析將在下面講解擴容時詳細分析，此處先跳過 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 2. 計算插入存儲的數組索引i：根據鍵值key計算的hash值 得到 // 此處的數組下標計算方式 = i = (n - 1) &amp; hash，同JDK 1.7中的indexFor（），上面已詳細描述 // 3. 插入時，需判斷是否存在Hash衝突： // 若不存在（即當前table[i] == null），則直接在該數組位置新建節點，插入完畢 // 否則，代表存在Hash衝突，即當前存儲位置已存在節點，則依次往下判斷：a. 當前位置的key是否與需插入的key相同、b. 判斷需插入的數據結構是否為紅黑樹 or 鏈表 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // newNode(hash, key, value, null)的源碼 = new Node&lt;&gt;(hash, key, value, next) else { Node&lt;K,V&gt; e; K k; // a. 判斷 table[i]的元素的key是否與 需插入的key一樣，若相同則 直接用新value 覆蓋 舊value // 判斷原則：equals（） if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // b. 繼續判斷：需插入的數據結構是否為紅黑樹 or 鏈表 // 若是紅黑樹，則直接在樹中插入 or 更新鍵值對 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); -&gt;&gt;分析3 // 若是鏈表,則在鏈表中插入 or 更新鍵值對 // i. 遍歷table[i]，判斷Key是否已存在：採用equals（） 對比當前遍歷節點的key 與 需插入數據的key：若已存在，則直接用新value 覆蓋 舊value // ii. 遍歷完畢後仍無發現上述情況，則直接在鏈表尾部插入數據 // 注：新增節點後，需判斷鏈表長度是否&gt;8（8 = 桶的樹化閾值）：若是，則把鏈表轉換為紅黑樹 else { for (int binCount = 0; ; ++binCount) { // 對於ii：若數組的下1個位置，表示已到表尾也沒有找到key值相同節點，則新建節點 = 插入節點 // 注：此處是從鏈表尾插入，與JDK 1.7不同（從鏈表頭插入，即永遠都是添加到數組的位置，原來數組位置的數據則往後移） if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 插入節點後，若鏈表節點&gt;數閾值，則將鏈表轉換為紅黑樹 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); // 樹化操作 break; } // 對於i if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 更新p指向下一個節點，繼續遍歷 p = e; } } // 對i情況的後續操作：發現key已存在，直接用新value 覆蓋 舊value &amp; 返回舊value if (e != null) { V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 替換舊值時會調用的方法（默認實現為空） return oldValue; } } ++modCount; // 插入成功後，判斷實際存在的鍵值對數量size &gt; 最大容量threshold // 若 &gt; ，則進行擴容 -&gt;&gt;分析4（但單獨講解，請直接跳出該代碼塊） if (++size &gt; threshold) resize(); afterNodeInsertion(evict);// 插入成功時會調用的方法（默認實現為空） return null;} /** * 分析3：putTreeVal(this, tab, hash, key, value) * 作用：向紅黑樹插入 or 更新數據（鍵值對） * 過程：遍歷紅黑樹判斷該節點的key是否與需插入的key 相同： * a. 若相同，則新value覆蓋舊value * b. 若不相同，則插入 */ final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) { Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;  for (TreeNode&lt;K,V&gt; p = root;;) {  int dir, ph; K pk;  if ((ph = p.hash) &gt; h) dir = -1;  else if (ph &lt; h) dir = 1;  else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) {  if (!searched) { TreeNode&lt;K,V&gt; q, ch; searched = true;  if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; } dir = tieBreakOrder(k, pk); } TreeNode&lt;K,V&gt; xp = p;  if ((p = (dir &lt;= 0) ? p.left : p.right) == null) { Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; } } }</pre><ul class=list-paddingleft-2><li><p>總結</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c8000464f47a3041c4></p><p>主要講解點2：擴容機制（即 resize（）函數方法）</p><ul class=list-paddingleft-2><li><p>擴容流程如下</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c2c0000784fefc81fd8></p><ul class=list-paddingleft-2><li><p>源碼分析</p></li></ul><pre> /** * 分析4：resize（） * 該函數有2種使用情況：1.初始化哈希表 2.當前數組容量過小，需擴容 */ final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; // 擴容前的數組（當前數組） int oldCap = (oldTab == null) ? 0 : oldTab.length; // 擴容前的數組的容量 = 長度 int oldThr = threshold;// 擴容前的數組的閾值 int newCap, newThr = 0; // 針對情況2：若擴容前的數組容量超過最大值，則不再擴充 if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 針對情況2：若無超過最大值，就擴充為原來的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // 通過右移擴充2倍 } // 針對情況1：初始化哈希表（採用指定 or 默認值） else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 計算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({"rawtypes","unchecked"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每個bucket都移動到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { // 鏈表優化重hash的代碼塊 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引 + oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket裡 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket裡 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab;}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495</pre><ul class=list-paddingleft-2><li><p>擴容流程（含 與 <code>JDK 1.7</code> 的對比）</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c8000464f5f18ae0f4></p><p>此處主要講解： <code>JDK 1.8</code>擴容時，數據存儲位置重新計算的方式</p><ul class=list-paddingleft-2><li><p>計算結論 & 原因解析</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c600059db8588bc1be></p><ul class=list-paddingleft-2><li><p>結論示意圖</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/66c40005d5ece5607bb5></p><ul class=list-paddingleft-2><li><p>數組位置轉換的示意圖</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c2c00007853b79b150c></p><ul class=list-paddingleft-2><li><p><code>JDK 1.8</code>根據此結論作出的新元素存儲位置計算規則 非常簡單，提高了擴容效率，具體如下圖</p><blockquote>這與 <code>JDK 1.7</code>在計算新元素的存儲位置有很大區別：<code>JDK 1.7</code>在擴容後，都需按照原來方法重新計算，即<p><code>hashCode（）</code>->> 擾動處理 ->><code>（h & length-1）</code>）</p></blockquote></li></ul><p>總結</p><ul class=list-paddingleft-2><li><p>添加數據的流程</p></li><li><p>與 <code>JDK 1.7</code>的區別</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c2c0000785214ec7ce5></p><ul class=list-paddingleft-2><li></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c8000464f67f07873a></p><p>至此，關於 <code>HashMap</code>的添加數據源碼分析 分析完畢。</p><hr><h1></h1><p>步驟3：從HashMap中獲取數據</p><ul class=list-paddingleft-2><li><p>假如理解了上述<code>put（）</code>函數的原理，那麼<code>get（）</code>函數非常好理解，因為二者的過程原理幾乎相同</p></li><li><p><code>get（）</code>函數的流程如下：</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c2c000078512e4cac62></p><ul class=list-paddingleft-2><li><p>源碼分析</p></li></ul><pre>/** * 函數原型 * 作用：根據鍵key，向HashMap獲取對應的值 */ map.get(key)； /** * 源碼分析 */ public V get(Object key) { Node&lt;K,V&gt; e; // 1. 計算需獲取數據的hash值 // 2. 通過getNode（）獲取所查詢的數據 -&gt;&gt;分析1 // 3. 獲取後，判斷數據是否為空 return (e = getNode(hash(key), key)) == null ? null : e.value;}/** * 分析1：getNode(hash(key), key)) */ final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 1. 計算存放在數組table中的位置 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 4. 通過該函數，依次在數組、紅黑樹、鏈表中查找（通過equals（）判斷） // a. 先在數組中找，若存在，則直接返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // b. 若數組中沒有，則到紅黑樹中尋找 if ((e = first.next) != null) { // 在樹中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // c. 若紅黑樹中也沒有，則通過遍歷，到鏈表中尋找 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;}1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950</pre><p>至此，關於 “向 <code>HashMap</code> 獲取數據 “講解完畢。</p><hr><p>步驟4：對HashMap的其他操作</p><blockquote><p>即 對其餘使用<code>API</code>（函數、方法）的源碼分析</p><p>- <code>HashMap</code>除了核心的<code>put（）</code>、<code>get（）</code>函數，還有以下主要使用的函數方法</p></blockquote><pre>void clear(); // 清除哈希表中的所有鍵值對int size(); // 返回哈希表中所有 鍵值對的數量 = 數組中的鍵值對 + 鏈表中的鍵值對boolean isEmpty(); // 判斷HashMap是否為空；size == 0時 表示為 空 void putAll(Map&lt;? extends K, ? extends V&gt; m); // 將指定Map中的鍵值對 複製到 此Map中V remove(Object key); // 刪除該鍵值對boolean containsKey(Object key); // 判斷是否存在該鍵的鍵值對；是 則返回trueboolean containsValue(Object value); // 判斷是否存在該值的鍵值對；是 則返回true1234567891011</pre><ul class=list-paddingleft-2><li><p>關於上述方法的源碼的原理 同 <code>JDK 1.7</code>，此處不作過多描述</p><blockquote><p>感興趣的同學可以參考文章 第5小節 進行類比。</p></blockquote></li></ul><p>至此，關於 <code>HashMap</code>的底層原理 & 主要使用<code>API</code>（函數、方法）講解完畢。</p><hr><h1></h1><p>6. 源碼總結</p><p>下面，用3個圖總結整個源碼內容：</p><blockquote><p>總結內容 = 數據結構、主要參數、添加 & 查詢數據流程、擴容機制</p></blockquote><ul class=list-paddingleft-2><li><p>數據結構 & 主要參數</p></li><li><p>添加 & 查詢數據流程</p></li><li><p>擴容機制</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c50005b185a373c7e6></p><ul class=list-paddingleft-2><li></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c700053e58208851f2></p><ul class=list-paddingleft-2><li></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c2c00007854f33eff3d></p><hr><h1></h1><p>7. 與 <code>JDK 1.7</code> 的區別</p><p><code>HashMap</code> 的實現在 <code>JDK 1.7</code> 和 <code>JDK 1.8</code> 差別較大，具體區別如下</p><blockquote><ol class=list-paddingleft-2><li><p><code>JDK 1.8</code> 的優化目的主要是：減少 <code>Hash</code>衝突 & 提高哈希表的存、取效率</p></li><li><p>關於 <code>JDK 1.7</code> 中 <code>HashMap</code> 的源碼解析請看文章：Java：手把手帶你源碼分析 HashMap 1.7</p></li></ol></blockquote><p><strong>7.1 數據結構</strong></p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c8000464f75719a4c8></p><p>7.2 獲取數據時（獲取數據 類似）</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c600059dba17f56073></p><p>7.3 擴容機制</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c40005d5ee8d724415></p><hr><h1></h1><p>8. 額外補充：關於HashMap的其他問題</p><ul class=list-paddingleft-2><li><p>有幾個小問題需要在此補充</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6c2c00007855d2c3ee07></p><ul class=list-paddingleft-2><li><p>具體如下</p></li></ul><p>8.1 哈希表如何解決Hash衝突</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c40005d5eff1932cc1></p><p>8.2 為什麼HashMap具備下述特點：鍵-值（key-value）都允許為空、線程不安全、不保證有序、存儲位置隨時間變化</p><ul class=list-paddingleft-2><li><p>具體解答如下</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c8000464f8ddda1c6b></p><ul class=list-paddingleft-2><li><p>下面主要講解 <code>HashMap</code> 線程不安全的其中一個重要原因：多線程下容易出現<code>resize（）</code>死循環</p><p>本質 = 併發 執行 <code>put（）</code>操作導致觸發 擴容行為，從而導致 環形鏈表，使得在獲取數據遍歷鏈表時形成死循環，即<code>Infinite Loop</code></p></li><li><p>先看擴容的源碼分析<code>resize（）</code></p><blockquote><p>關於resize（）的源碼分析已在上文詳細分析，此處僅作重點分析：transfer（）</p></blockquote></li></ul><pre>/** * 源碼分析：resize(2 * table.length) * 作用：當容量不足時（容量 &gt; 閾值），則擴容（擴到2倍） */ void resize(int newCapacity) {  // 1. 保存舊數組（old table） Entry[] oldTable = table;  // 2. 保存舊容量（old capacity ），即數組長度 int oldCapacity = oldTable.length; // 3. 若舊容量已經是系統默認最大容量了，那麼將閾值設置成整型的最大值，退出  if (oldCapacity == MAXIMUM_CAPACITY) {  threshold = Integer.MAX_VALUE;  return;  }  // 4. 根據新容量（2倍容量）新建1個數組，即新table  Entry[] newTable = new Entry[newCapacity];  // 5. （重點分析）將舊數組上的數據（鍵值對）轉移到新table中，從而完成擴容 -&gt;&gt;分析1.1 transfer(newTable); // 6. 新數組table引用到HashMap的table屬性上 table = newTable;  // 7. 重新設置閾值  threshold = (int)(newCapacity * loadFactor);}/** * 分析1.1：transfer(newTable); * 作用：將舊數組上的數據（鍵值對）轉移到新table中，從而完成擴容 * 過程：按舊鏈表的正序遍歷鏈表、在新鏈表的頭部依次插入 */ void transfer(Entry[] newTable) { // 1. src引用了舊數組 Entry[] src = table; // 2. 獲取新數組的大小 = 獲取新容量大小  int newCapacity = newTable.length; // 3. 通過遍歷 舊數組，將舊數組上的數據（鍵值對）轉移到新數組中 for (int j = 0; j &lt; src.length; j++) { // 3.1 取得舊數組的每個元素  Entry&lt;K,V&gt; e = src[j];  if (e != null) { // 3.2 釋放舊數組的對象引用（for循環後，舊數組不再引用任何對象） src[j] = null; do { // 3.3 遍歷 以該數組元素為首 的鏈表 // 注：轉移鏈表時，因是單鏈表，故要保存下1個結點，否則轉移後鏈表會斷開 Entry&lt;K,V&gt; next = e.next; // 3.3 重新計算每個元素的存儲位置 int i = indexFor(e.hash, newCapacity); // 3.4 將元素放在數組上：採用單鏈表的頭插入方式 = 在鏈表頭上存放數據 = 將數組位置的原有數據放在後1個指針、將需放入的數據放到數組位置中 // 即 擴容後，可能出現逆序：按舊鏈表的正序遍歷鏈表、在新鏈表的頭部依次插入 e.next = newTable[i]; newTable[i] = e;  // 訪問下1個Entry鏈上的元素，如此不斷循環，直到遍歷完該鏈表上的所有節點 e = next;  } while (e != null); // 如此不斷循環，直到遍歷完數組上的所有數據元素 } }}</pre><p>從上面可看出：在擴容<code>resize（）</code>過程中，在將舊數組上的數據 轉移到 新數組上時，轉移數據操作 = 按舊鏈表的正序遍歷鏈表、在新鏈表的頭部依次插入，即在轉移數據、擴容後，容易出現鏈表逆序的情況</p><blockquote><p>設重新計算存儲位置後不變，即擴容前 = 1->2->3，擴容後 = 3->2->1</p></blockquote><ul class=list-paddingleft-2><li><p>此時若（多線程）併發執行 <code>put（）</code>操作，一旦出現擴容情況，則 容易出現 環形鏈表，從而在獲取數據、遍歷鏈表時 形成死循環（<code>Infinite Loop</code>），即 死鎖的狀態，具體請看下圖：</p></li></ul><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c8000464f97b483cfd></p><p>注：由於 <code>JDK 1.8</code> 轉移數據操作 = 按舊鏈表的正序遍歷鏈表、在新鏈表的尾部依次插入，所以不會出現鏈表 逆序、倒置的情況，故不容易出現環形鏈表的情況。</p><blockquote><p>但 <span>JDK 1.8</span>還是線程不安全，因為 無加同步鎖保護</p></blockquote><p>8.3 為什麼 HashMap 中 String、Integer 這樣的包裝類適合作為 key 鍵</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c50005b186d4ee703e></p><p>8.4 HashMap 中的 <code>key<span>若 </span>Object</code>類型， 則需實現哪些方法？</p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66c90003691b39127b61></p><p>至此，關於<span>HashMap</span>的所有知識講解完畢。</p><h1></h1><p>9. 總結</p><p>本文主要講解 <code>Java<span>的 </span>HashMap</code>源碼 & 相關知識下面我將繼續對<span>Java</span><span>、 </span><span>Android</span></p><p><img alt="Java源碼分析：關於 HashMap 1.8 的重大更新" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66c40005d6c8a8474faa></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>源碼</a></li><li><a>關於</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html alt=源碼分析：Java集合類的AbstractCollection源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html title=源碼分析：Java集合類的AbstractCollection源碼解析>源碼分析：Java集合類的AbstractCollection源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html alt="Java HashMap源碼分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a86461eb8cc4ddb9ddf740c0aa49b00 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html title="Java HashMap源碼分析">Java HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html alt=Java——HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8ad8e7317b3047f28717cf8c6fb816bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html title=Java——HashMap源碼分析>Java——HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html alt=Java中HashMap源碼分析，絕對乾貨！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/593f0003cad0b7c22de4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html title=Java中HashMap源碼分析，絕對乾貨！>Java中HashMap源碼分析，絕對乾貨！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html alt=Java容器系列-HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10798fbb789b4217a4b19b4f307422b1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html title=Java容器系列-HashMap源碼分析>Java容器系列-HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html alt="Java源碼中>>，>>>的區別是啥？我給你徹底講清" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b12aaaf792c8469c91e2a514a666a8cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html title="Java源碼中>>，>>>的區別是啥？我給你徹底講清">Java源碼中>>，>>>的區別是啥？我給你徹底講清</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/813d5912.html alt=關於Facebook像素，這些你瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RM0p5dK51SH9EU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/813d5912.html title=關於Facebook像素，這些你瞭解嗎？>關於Facebook像素，這些你瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>