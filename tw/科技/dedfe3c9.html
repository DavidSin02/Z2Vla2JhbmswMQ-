<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JDK中哈希表這一數據結構的演變，HashMap 底層原理和常用方法 | 极客快訊</title><meta property="og:title" content="JDK中哈希表這一數據結構的演變，HashMap 底層原理和常用方法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f51c3ea7660d4bc78f910292b6aa4540"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dedfe3c9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dedfe3c9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dedfe3c9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dedfe3c9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dedfe3c9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dedfe3c9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dedfe3c9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dedfe3c9.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="JDK中哈希表這一數據結構的演變，HashMap 底層原理和常用方法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/dedfe3c9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JDK中哈希表這一數據結構的演變，HashMap 底層原理和常用方法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=heading>前言</h1><p>面試的時候，當面試官問你 Java 基礎的時候，HashMap 可以說是一個繞不過去的話題，哪怕其他容器（比如 ArrayList，LinkedList）都不問，HashMap 也是不能不問的。不僅僅因為在平時工作中，HashMap 是一個很常用的數據結構，而且由 HashMap 這個數據結構其實能引出很多問題。比如最基本的 get()、put() 方法是吧，get() 就可以聊聊 equals() 方法跟 hashCode() 方法，這算是 Java 基礎了吧；稍微升級一下難度，聊聊擴容過程，線程安全問題，進而引申到 ConcurrentHashMap，引申到多線程，引申到 Synchronized 關鍵字，引申到 JVM 虛擬機是吧，你看這樣一聯想，整個都串到一起了。</p><h1 class=heading>談談哈希錶的歷史</h1><p>哈希表在工作中是個很常用的數據結構，因為較好的兼顧了修改跟查找的性能。JDK1.0 中最早實現這個數據結構的類是 HashTable，而且更貼心的是這個類是線程安全的。理論上，只要想使用哈希表這個數據結構的的地方，用 HashTable 就肯定不會有問題。但是凡事都是有代價的，在實現了線程安全的同時，其實是極大地犧牲了性能的。簡單翻一下 HashTable 的源碼，看 get() 跟 put() 兩個方法，可以看到這兩個方法都被加了synchronized關鍵字，這也是 HashTable 線程安全的原因。</p><p>但是你想，直接把整個對象鎖住，這是不是小題大做了，尤其是在單線程的場景下，就比如一個業務請求進來，在這個請求的處理過程中新建了一個哈希表，去對哈希表進行一些操作的時候，每次都上鎖是不是過分了？其實就他一個線程操作，根本沒必要去上鎖，全程綠燈直接操作就行了。所以在 JDK1.2，我們有了一個新的類，HashMap。這個類並不是線程安全的，也意味著在單線程情況下，他沒有為了保證線程安全而引入的不必要的開銷，所以性能很好。於是，那個時候，沒有線程安全要求的，直接使用 HashMap 就行了，有線程安全要求，比如某些全局變量什麼的多線程訪問的情景，那就直接使用 HashTable。</p><p>但其實前面我們也說了 HashTable 實現線程安全的方式十分簡單粗暴，直接對整個哈希表加了鎖，這就導致在高併發場景下頻繁操作哈希表的時候，性能較差。於是在 JDK1.5 裡面，併發大師 Doug Lea 為我們帶來了 ConcurrentHashMap，通過粒度更細的鎖，減少了鎖的競爭，從而實現了更好的性能。</p><h1 class=heading>HashMap 底層原理</h1><h2 class=heading>HashMap 的變遷</h2><p>在不同版本的 JDK 中，HashMap 是在不停優化的。</p><ul><li>比如 JDK1.6 裡面 new HashMap 時，開闢了內存空間，如果不使用，則浪費內存；JDK1.7 裡面改成了懶加載，new HashMap 並沒有開闢內存空間，節約了內存空間</li><li>1.8 優化了 hashCode 算法：高 16 位異或（XOR）低 16 位 主要是增加了擾動，減少了哈希碰撞的機率</li><li>1.8 裡面優化了 hash 碰撞較多情況下的性能問題（鏈表長度限制為 8，過長時會將鏈表轉換為 TreeNode（紅黑樹））</li></ul><h2 class=heading>類繼承關係</h2><p>Java 為數據結構中的映射定義了一個接口 java.util.Map，此接口主要有四個常用的實現類，分別是 HashMap、Hashtable、LinkedHashMap 和 TreeMap，類繼承關係如下圖所示：</p><p><br></p><div class=pgc-img><img alt="JDK中哈希表這一數據結構的演變，HashMap 底層原理和常用方法" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f51c3ea7660d4bc78f910292b6aa4540><p class=pgc-img-caption></p></div><p><br></p><p>下面簡單介紹一下各個實現類的特點：</p><ul><li>HashMap：它根據鍵的 hashCode 值存儲數據，大多數情況下可以直接定位到它的值，因而具有很快的訪問速度，但遍歷順序卻是不確定的。 HashMap 最多隻允許一條記錄的鍵為 null，允許多條記錄的值為 null。HashMap 非線程安全，即任一時刻可以有多個線程同時寫 HashMap，可能會導致數據的不一致。如果需要滿足線程安全，可以用 Collections 的 synchronizedMap 方法是 HashMap 具有線程安全的能力，或者使用 ConcurrentHashMap。</li><li>Hashtable：Hashtable 是遺留類，很多映射的常用功能與 HashMap 類似，不同的是它承自 Dictionary 類，並且是線程安全的，任一時間只有一個線程能寫 Hashtable，併發性不如 ConcurrentHashMap，因為 ConcurrentHashMap 引入了分段鎖。Hashtable 不建議在新代碼中使用，不需要線程安全的場合可以用 HashMap 替換，需要線程安全的場合可以用 ConcurrentHashMap 替換。</li><li>LinkedHashMap：LinkedHashMap 是 HashMap 的一個子類，保存了記錄的插入順序，在用 Iterator 遍歷 LinkedHashMap 時，先得到的記錄肯定是先插入的，也可以在構造時帶參數，按照訪問次序排序。</li><li>TreeMap：TreeMap 實現 SortedMap 接口，能夠把它保存的記錄根據鍵排序，默認是按鍵值的升序排序，也可以指定排序的比較器，當用 Iterator 遍歷 TreeMap 時，得到的記錄是排過序的。如果使用排序的映射，建議使用 TreeMap。在使用 TreeMap 時，key 必須實現 Comparable 接口或者在構造 TreeMap 傳入自定義的 Comparator，否則會在運行時拋出 java.lang.ClassCastException 類型的異常。</li></ul><p>對於上述四種 Map 類型的類，要求映射中的 key 是不可變對象。不可變對象是指該對象在創建後它的哈希值不會被改變。如果對象的哈希值發生變化，Map 對象很可能就定位不到映射的位置了。</p><h2 class=heading>HashMap 的底層數據結構</h2><p>其實廣義來講，數據結構只有數組跟鏈表兩種，本質上就是看數據在存儲的時候是否連續，其他的各種數據結構，比如棧、隊列、跳錶、樹，都可以用數組或者鏈表來實現。而 HashMap，算是集中了這兩者特點的一種數據結構，在很多地方都會用到。比如 Spring 裡面存放各種 bean 用的容器，用的就是 ConcurrentHashMap。</p><p>下面插入一張我畫的大致的數據結構圖：（下述討論都基於 JDK1.8）</p><p><br></p><div class=pgc-img><img alt="JDK中哈希表這一數據結構的演變，HashMap 底層原理和常用方法" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/56a58f08441542d0999c6c12ea827bfe><p class=pgc-img-caption></p></div><p><br></p><p>但這張圖，其實是有問題的，不知道你發現沒，哈哈哈，我後邊再講。如圖所示，HashMap 底層的數據結構就是數組 + 鏈表。</p><pre><code>transient Node&lt;K,V&gt;[] table;transient int size;int threshold;final float loadFactor;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;    ...}複製代碼</code></pre><p>上述代碼摘自 JDK 1.8 中 HashMap 部分源碼，table 即為我所說的數組，而 Node 即為鏈表的一個節點，裡面有 hash、key、value 以及下一個節點。</p><p>下面分別介紹一下 Node 中的各個字段：</p><ul><li>hash：存儲的鍵值對中 key 的 hash</li><li>key：存儲的鍵值對中的 key</li><li>value：存儲的鍵值對中的 value</li><li>next：指向下一個 Node</li></ul><h2 class=heading>默認配置常量</h2><pre><code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;複製代碼</code></pre><p>HashMap 容器初始化的容量為 16，默認負載因子為 0.75，樹化閾值為 8，反樹化閾值為 6，最小的樹化容量為 64。</p><h2 class=heading>負載因子</h2><p>負載因子（LOAD_FACTOR）結合容量（CAPACITY），其實就得到了 HashMap 擴容的一個閾值，大於這個閾值的時候，HashMap 就會進行 resize() 擴容操作。至於負載因子為什麼是 0.75，源碼裡的註釋簡單提了一嘴，其實就是不說我們也能猜出來。</p><blockquote><p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the <strong>HashMap</strong> class, including <strong>get</strong> and <strong>put</strong>).</p></blockquote><p>其實就是權衡了空間佔用跟查找效率，負載因子太高固然節省空間，但查找效率也會因此下降，包括 get 跟 set 等操作。</p><p>回到上邊那張圖，對於初始容量 16，負載因子 0.75 來說，超過 12，也就是圖中畫的 13 個元素，就會觸發擴容，所以我前面說那張圖有問題。但當時畫的時候隨手畫的，也懶得改了，就隨它去吧。</p><h2 class=heading>Hash 算法</h2><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}複製代碼</code></pre><p>從上述算法可知，HashMap 中可以存放 key 為 null 的值，放在首位。而對於哈希值，是將高 16 位與低 16 位進行異或運算，這樣做的目的主要是儘量保證 hash 值的均勻，通過這樣一個擾動函數，減小了 hash 衝突的概率。</p><p>然後再通過(n - 1) & hash這個 hash 值與數組的長度進行取模運算，決定這個鍵值對該放入 table 中的那個 Node 中。</p><h2 class=heading>擴容過程</h2><p>當容量大於閾值的時候，就會觸發 HashMap 的擴容操作。擴容操作其實就是新建一個容量是原先數組兩倍的新數組，將原先小數組的元素重新哈希到新的數組上。因為容量是 2 的冪，擴容的時候，元素要麼在原位置，要麼往後移動原來的容量大小的位置，這時候使用的是下面這個算法：</p><blockquote><p>e.hash & oldCap</p></blockquote><p>如果得到的結果為零，則在原位置；反之，則將其向高位移動 oldCap 大小的位置。</p><h2 class=heading>哈希衝突</h2><p>教科書上告訴我們，碰到哈希衝突的時候，一般有兩種解決辦法：<strong>開放定址法</strong>跟<strong>鏈表法</strong>。</p><p>HashMap 選擇的是鏈表法來解決哈希衝突的，也十分好理解。簡單來說就是當哈希衝突的時候，將哈希衝突的元素掛到一條鏈表上，至於查找的時候具體是哪個元素，就需要再去鏈表上比較查出來了。</p><h1 class=heading>HashMap 常用方法</h1><h2 class=heading>put 流程</h2><ul><li>對 key 的 hashCode() 做 hash 運算，計算 index；</li><li>如果沒碰撞直接放到 table 裡；</li><li>如果碰撞了，以鏈表的形式存在 table 後；</li><li>如果碰撞導致鏈表過長（大於等於 TREEIFY_THRESHOLD)，就把鏈表轉換成紅黑樹 (JDK1.8 中的改動）；</li><li>如果節點已經存在就替換 old value（保證 key 的唯一性）</li><li>如果 table 滿了（超過 load factor*current capacity)，就要 resize。</li></ul><h2 class=heading>get 流程</h2><ul><li>對 key 的 hashCode() 做 hash 運算，計算 index;</li><li>如果在 table 裡的第一個節點裡直接命中，則直接返回；</li><li>如果有衝突，則通過 key.equals(k) 去查找對應的 Node； 若為樹，則在樹中通過 key.equals(k) 查找，； 若為鏈表，則在鏈表中通過 key.equals(k) 查找，。</li></ul><h2 class=heading>鏈表跟紅黑樹互轉</h2><p>雖然源碼中說了，根據泊松分佈，哈希衝突的概率很低。但是如果真碰到一些極端情況，比如寫死了 HashCode，那麼那個 Node 上的元素過多，是會從鏈表轉換成紅黑樹的。這裡其實有一點就是並不是鏈表長度達到 8 就會轉成紅黑樹。還有另外一個前提條件，就是整個哈希表容量要大於等於樹化閾值，默認的樹化閾值是 64，因為如果哈希表容量過小就用紅黑樹，可能會引起頻繁擴容跟鏈表樹化之間的衝突，性能並不一定比鏈表好。所以，在大容量的哈希表中，最極端的情況也就是通過紅黑樹來查找元素，這種情況下的算法複雜度是</p><p>這裡其實經常容易被問到的另一個問題就是：為什麼用的是紅黑樹，而不是 AVL 樹。</p><p>要回答這個問題就要回到這兩種數據結構的特點上面。紅黑樹的查詢性能略微遜色於 AVL 樹，因為它比 avl 樹會稍微不平衡最多一層，也就是說紅黑樹的查詢性能只比相同內容的 avl 樹最多多一次比較，但是，紅黑樹在插入和刪除上完爆 avl 樹，avl 樹每次插入刪除會進行大量的平衡度計算，而紅黑樹為了維持紅黑性質所做的紅黑變換和旋轉的開銷，相較於 avl 樹為了維持平衡的開銷要小得多。所以，對於 HashMap 這種頻繁讀寫的數據結構，選擇紅黑樹相比 AVL 樹是更好的選擇。</p><h1 class=heading>總結</h1><p>本文簡單總結了 JDK 中哈希表這一數據結構的演變，介紹了 HashMap 的一些底層原理和常用方法，裡面摻雜了大量充滿個人感情色彩的見解，如果有錯誤的地方可以留言一起討論，希望大家都能夠有所收穫。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JDK</a></li><li><a>哈希</a></li><li><a>這一數</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html alt=C++哈希表是如何解決衝突的? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ac4410086e640ea82846bde1dd72c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html title=C++哈希表是如何解決衝突的?>C++哈希表是如何解決衝突的?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html alt=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/54d45b20ef6a4a3f960411db61474538 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ea7884b.html title=java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到>java程序員注意：少有人知的哈希衝突解決策略，學到就是賺到</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c835605d.html alt=互聯網公司面試經，你不得不知道的哈希 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/80891c3b3b5d4f04b84078744a653aeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c835605d.html title=互聯網公司面試經，你不得不知道的哈希>互聯網公司面試經，你不得不知道的哈希</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/01b66ad2.html alt="漫畫 | 什麼是散列表（哈希表）？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e8a38bd3470c4c06befa051c4adbf665 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/01b66ad2.html title="漫畫 | 什麼是散列表（哈希表）？">漫畫 | 什麼是散列表（哈希表）？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b312402f.html alt=程序員面試中常見的哈希表，到底是什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35e957fe50484e03a497b640373bc5ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b312402f.html title=程序員面試中常見的哈希表，到底是什麼？>程序員面試中常見的哈希表，到底是什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/92675aff.html alt=關於哈希表，你該瞭解這些 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d18861a74ac4577abd03b0064a1016b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92675aff.html title=關於哈希表，你該瞭解這些>關於哈希表，你該瞭解這些</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/21474a0e.html alt=一張圖搞定對哈希表的理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a49c66caf9044e7b086f48696b04283 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/21474a0e.html title=一張圖搞定對哈希表的理解>一張圖搞定對哈希表的理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html alt=我是如何閱讀JDK源碼的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25b18fb619994fcbaa58c5e28b7a4e51 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html title=我是如何閱讀JDK源碼的？>我是如何閱讀JDK源碼的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02e75145.html alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e9326cdf61814b6b96f535ed06981f24 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02e75145.html title=模板方法模式，看JDK和Spring是如何優雅複用代碼的>模板方法模式，看JDK和Spring是如何優雅複用代碼的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0c9c582e.html alt=優化哈希策略 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1b02532c75194b26b8dba9c099a52d10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0c9c582e.html title=優化哈希策略>優化哈希策略</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5abd8ee0.html alt=四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/af6b4034b7db48f0907aff6d641e490c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5abd8ee0.html title=四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經>四、JDK1.7中HashMap哈希衝突解決方案-阿里面試經</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26a6aed.html alt=哈希矩陣打造無限擴展的分佈式雲服務協議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dd942b36cc534ab19fd0b6d4df0d333e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26a6aed.html title=哈希矩陣打造無限擴展的分佈式雲服務協議>哈希矩陣打造無限擴展的分佈式雲服務協議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd77fe8.html alt="如何使用 OpenSSL：哈希值、數字簽名等 | Linux 中國" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0459ed9ba8fe4632954f90d1ebef99a7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd77fe8.html title="如何使用 OpenSSL：哈希值、數字簽名等 | Linux 中國">如何使用 OpenSSL：哈希值、數字簽名等 | Linux 中國</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>