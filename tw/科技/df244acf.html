<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>瞭解 JavaScript 的 rest參數與擴展運算符 (ES6) | 极客快訊</title><meta property="og:title" content="瞭解 JavaScript 的 rest參數與擴展運算符 (ES6) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/96f6a301-9c86-48d2-8018-7e600bb152c9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df244acf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><meta property="article:published_time" content="2020-11-14T21:01:00+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:00+08:00"><meta name=Keywords content><meta name=description content="瞭解 JavaScript 的 rest參數與擴展運算符 (ES6)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/df244acf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>瞭解 JavaScript 的 rest參數與擴展運算符 (ES6)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-center-line>引言</h1><p>我們知道，許多 JavaScript 內置函數在調用它們的時候，可以傳入任意數量的參數。</p><p>例如：</p><ul><li>Math.max(arg1, arg2, ..., argN) - 返回最大的那個參數。</li><li>Object.assign(obj, src1, ..., srcN) - 將 src1 .. srcN 這些屬性拷貝到對象 obj<strong> </strong>中。</li><li>諸如此類，還有很多 ... 。</li></ul><p>在本篇文章中，就說說我們自己聲明的函數如何去接收任意多數量的參數，以及如何將一個現成的數組打散成一個參數列表。最後還會討論一下數組及對象的拷貝問題。</p><div class=pgc-img><img alt="瞭解 JavaScript 的 rest參數與擴展運算符 (ES6)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/96f6a301-9c86-48d2-8018-7e600bb152c9><p class=pgc-img-caption></p></div><h1 class=pgc-h-center-line>思考</h1><p>首先，我們先思考一個問題。</p><p>假如我們有一個需求，需要一個函數，通過傳參，返回一個基本的用戶信息組成的一個數組，這個需求目前很簡單，只需要通過參數收集用戶ID和姓名就行了：</p><pre><code>function user(id, username) {  let userArr = [];  userArr.push(id);  userArr.push(username);  return userArr;}console.log(user(1, 'Tom')); // [1, 'Tom']</code></pre><p>這段代碼沒有任何問題，但現在需求改了，我們還需要一個用戶的年齡，於是我可以這麼調用這個函數：</p><pre><code>user(1, 'Tom', 18); // 發現結果還是 [1, 'Tom']</code></pre><p>雖然結果沒有把年齡加進去，但這至少可以肯定一個問題：<strong>“函數可以使用任意數量的參數調用，無論函數的參數是如何定義的，它不會因為 “過剩” 的參數調用而出現錯誤” </strong>，但只有函數聲明中出現在形參位置的參數才會在函數體內被計算。</p><p>這時候要想把年齡也返回，我們必須還要經歷 2 步：</p><ul><li>在聲明函數的時候將它作為形參傳入函數體。</li><li>在函數體內進行一個 push 操作。</li></ul><pre><code>function user(id, username, age) {  let userArr = [];  userArr.push(id);  userArr.push(username);  userArr.push(age);  returnuserArr;}console.log(user(1, 'Tom', 18)); // [1, "Tom", 18]</code></pre><p>這回我們成功了，結果正確了，但現在需求又變了，我們還要添加性別並返回，於是我們還要手動的去重複上面添加年齡的 2 個步驟。隨著業務的發展，我們還要添加諸如職位，工資，保險 ... 等一系列的參數。</p><p>可以說每添加一個參數，就需要我們重複修改函數定義。</p><h1 class=pgc-h-center-line>rest 參數 "..."</h1><p>上面提出的問題該如何解決呢？</p><p>於是 <strong>rest 參數 </strong>的概念出現了，正如我們上面提到的：</p><blockquote><p>隨著業務的發展，我們還要添加諸如職位，工資，保險 ... 等一系列的參數。</p></blockquote><p>引用中的 “諸如 ...” ，這個省略號非常的形象，於是我們的 <strong>rest 參數</strong> 也非常盡如人意，用 <strong>...省略的那些參數</strong> 的表現形式呈現了。</p><p>具體來講，<strong>rest 參數</strong> 可以當作函數的參數使用，它使用 '<strong>...</strong>' 後面接跟著一個保存你所有參數的數組名稱，'<strong>...</strong>' 的意思就是 <strong>將我剩餘的參數收集到一個數組中</strong> 。</p><p>還是我們上面的需求，改成 <strong>rest 參數</strong> 的時候，可以是這樣：</p><pre><code>function user(...userInfos) {  let userArr = [];  for(let info of userInfos) {    userArr.push(info);  }  returnuserArr;}console.log(user(1, 'Tom')); // [1, "Tom"]console.log(user(1, 'Tom', 18)); // [1, "Tom", 18]console.log(user(1, 'Tom', 18, '男')); // [1, "Tom", 18, "男"]</code></pre><p>上面的示例，我們將調用時傳的實參收集到了 userInfos<strong> </strong>的數組中了，函數內部我們可以直接操作這個數組了。</p><p>這個示例和最文章開頭的示例相比，優點不言而喻，最重要的是，如果你這麼做了，你根本不用修改你定義好的數組 (包括聲明的形參與函數體)。</p><p>當然，我們的 <strong>rest 參數</strong> 還可以這麼用：</p><pre><code>function user(userId, username, ...userInfos) {  let userArr = [];  let obj = {    '編號': userId,    '姓名': username  }  // 因為 userInfos是數組，所以可以  // 用 for ... of 循環  for(let info of userInfos) {    userArr.push(info);  }  // 因為 userInfos是數組，所以  // 有 length 屬性  if(userInfos.length) {    obj['備註信息'] = userArr;  }  return obj}console.log(user(1, 'Tom'));console.log(user(2, 'James', 18));console.log(user(3, 'Kylin', 22, '前端開發'));/*  result: 1  {    '編號': 1,    '姓名': 'Tom'  }  result: 2  {    '編號': 2,    '姓名': 'James',    '備註信息': [18]  }  result: 3  {    '編號': 3,    '姓名': 'Kylin',    '備註信息': [22, '前端開發']  }*/</code></pre><p>上面的示例，你可以這樣理解，假如一條用戶記錄有某些字段，在業務需求上是必要的信息，例如上例中函數的形參 userId ，username 等，那麼你就可以將它們作為形參變量，而其餘的參數作為備註信息收集到 userInfos 中。</p><p>這裡關於 <strong>rest 參數</strong> 有一個必須注意的問題：</p><blockquote><p>rest 參數 只能是函數形參的最後一個。</p></blockquote><p>好比這樣的代碼，<strong>rest 參數</strong> 收集了所有剩餘的參數，在 <strong>rest 參數</strong> 後面的參數，就顯得沒有任何意義了。因此下面的操作會導致錯誤：<strong>Rest parameter must be last formal parameter </strong>：</p><pre><code>function user(userId,  ...userInfos, username) {}</code></pre><p>最後一個值得注意的問題，在函數內部，我們可以往<strong> rest 參數 </strong>中增加元素或修改嗎？</p><pre><code>function user(...userInfo) {  let userArr = [];  userInfo.push('男'); // 增加性別  userInfo[0] = 999; // 修改 ID  for(let info of userInfo) {    userArr.push(info);  }  console.log(userArr);}user(1, 'Tom'); // [999, "Tom", "男"]</code></pre><p>上例運行結果，證實，你完全可以這麼做，因為：</p><blockquote><p><strong>rest 參數</strong> 可以當作函數的參數使用，它使用 '<strong>...</strong>' 後面接跟著一個保存你所有參數的數組名稱，'<strong>...</strong>' 的意思就是 <strong>將我剩餘的參數收集到一個數組中</strong> 。</p></blockquote><p><strong>rest 參數 </strong>就是一個數組啊，所以可以用數組的操作方法。</p><h1 class=pgc-h-center-line>"arguments" 對象</h1><p>在 <strong>rest 參數</strong> 出現之前，還有一個名為 <strong>arguments</strong> 的特殊類數組對象，它根據參數的索引包含所有參數：</p><pre><code>function user() {  let userArr = [];  for(let arg of arguments) {    userArr.push(arg);  }  console.log(userArr);}user(1, 'Tom'); // [1, "Tom"]user(1, 'Tom', 18); // [1, "Tom", 18]</code></pre><p>在過去，JavaScript 語言中並不存在 <strong>rest 參數</strong> ，使用 arguments 是獲得函數所有參數的唯一方法。它仍然有效，我們依然可以在一些舊代碼中找到它的蹤跡。</p><p>但 arguments<strong> </strong>也有缺點，例如我們上面提到的：</p><blockquote><p>假如一條用戶記錄有某些字段，在業務需求上是必要的信息，例如上例中函數的形參 userId ，username 等</p></blockquote><p>1、所以，你無法從業務角度出發，從代碼可讀性的視角定義你所需要的必要參數，因為 arguments 總包含所有的參數，它並不像 <strong>rest 參數 </strong>可以部分地捕獲參數。</p><p>2、其次，儘管參數既像數組又可迭代，但它確實不是數組。它不支持數組特有的方法，因此我們不能調用 <strong>arguments.map(…) </strong>、<strong>arguments.every(...) </strong>，這些數組特有的方法，如果你想使用它們，則必須藉助 <strong>call</strong> 、<strong>apply</strong> 這些函數，例如，輸出一組數的平方根，你可以這樣：</p><pre><code>function sqr() {  console.log([].map.call(arguments, Math.sqrt)); }sqr(4, 9, 16, 25); // [2, 3, 4, 5]</code></pre><p>3、再思考一下，arguments 對象可以添加或修改元素自身元素嗎？</p><pre><code>function user() {  // arguments.push('男'); // 增加性別  arguments[0] = 999;  console.log(arguments);}user(1, 'Tom'); // 999</code></pre><p>可以看到，增加不可以，因為它並不是數組，而修改卻可以，如果你確定需要增加元素，請使用 [].push.call(arguments, '男');<strong> 。</strong></p><p>我們再看一下帶參數的情況下我們要想修改元素的值會怎樣？</p><pre><code>function user(id) {  arguments[0] = 999;  console.log([id, arguments[0]]);}user(1);</code></pre><p>上面的代碼，在非嚴格模式下輸出 [999, 999] ，在嚴格模式下輸出 [1, 999] ，這是因為嚴格模式下，arguments 不再追蹤參數的變化了。可見 arguments<strong> </strong>在嚴格模式與非嚴格模式下存在著很多差異，這僅僅是你所看到的其中一點。</p><p>基於以上 3 點原因，如果你還在用 JavaScript 編寫具有此特性的代碼，那麼我極力推薦你將 <strong>rest 參數</strong> 作為你的首選。</p><p>既然談到了 arguments 對象，我們還要說一個話題：箭頭函數中，沒有 arguments<strong> </strong>對象，如果你試圖在箭頭函數中使用 arguments<strong> </strong>對象，程序將報錯：</p><pre><code>function normalFun() {  console.log(arguments[0]);}let arrowFun = () =&gt; {  console.log(arguments[0]);}normalFun('demo'); // demoarrowFun('demo'); // ReferenceError: arguments is not defined</code></pre><p>可以看到，全局中箭頭函數是沒有 arguments 對象的，但如果你試圖在普通的 function<strong> </strong>中聲明的箭頭函數內使用 arguments 對象，那麼它將會從包含它的外部 function 定義的函數獲取，就像下面的代碼一樣：</p><pre><code>function normalFun() {  console.log(arguments[0]);  let arrowFun = () =&gt; {    console.log(arguments[0]); // normalFun 的 arguments對象  }  arrowFun();}normalFun('demo'); // demo demo</code></pre><p>好了，現在我們知道，關於箭頭函數，不僅沒有 this ，而且也沒有 arguments 對象。</p><h1 class=pgc-h-center-line>擴展運算符</h1><p>我們已經瞭解了<strong> rest 參數 </strong>，即如何從函數參數列表中獲取數組。</p><p>但是，有時候我們正好需要一個恰恰相反的操作，即我們要從數組中把元素逐個展開，形成一個列表，這就是 <strong>擴展運算符</strong> 的用途。</p><blockquote><p>學習知識要善於思考，思考，再思。我就是靠這個方法成為科學家的。</p><p><br></p><p>愛因斯坦</p></blockquote><p>好了，再繼續思考，在 JavaScript 中，有一個內置的函數 Math.max ，它用於在一個數字列表中返回最大的那個數：</p><pre><code>console.log(Math.max(1, 2, 3)); // 3</code></pre><p>沒錯，輸出了數字 3 ，好了，我們現在要定義這麼一個列表，這個列表包含很多數字，沒辦法，我們只能使用數組去定義它：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];</code></pre><p>現在，我們把這個列表傳給 Math.max 函數，看看它如何計算我們的列表：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];console.log(Math.max(nums)); // NaN</code></pre><div class=pgc-img><img alt="瞭解 JavaScript 的 rest參數與擴展運算符 (ES6)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/8db9304e-4251-4b24-a952-bc4ef7294761><p class=pgc-img-caption></p></div><p>我以為會執行成功，可結果為 NaN ，Math.max<strong> </strong>無法正常工作，因為 Math.max 需要的是一個數字列表，而不是一個數組，好吧，修改一下：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];// 10console.log(Math.max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]));</code></pre><p>這回，正常了，可是這些代碼簡直是太糟糕了，可讀性是一方面，更關鍵的是，現實中，手動輸入一個數字列表並不現實，我們的數字列表可不止就這些數字，它也許有很多，也許就一個，又或許一個都沒有，這會讓我們的實際情況變得非常糟糕。</p><p><strong>展開運算符 </strong>可以很好的解決這個問題，它和 <strong>rest 參數</strong> 非常相似，也是使用 '<strong>...</strong>' ，但用途恰恰相反。</p><div class=pgc-img><img alt="瞭解 JavaScript 的 rest參數與擴展運算符 (ES6)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/831153eb-1ff9-4678-b6bd-605021c4b96a><p class=pgc-img-caption></p></div><p>當 ...args<strong> </strong>作為一個實參，用於函數調用的參數的時候，它可以遍歷 args 中的所有元素，並將它們轉化為調用函數所需的參數列表，而 <strong>rest 參數</strong> 則用於聲明函數的形參，將剩餘的參數收集成一個數組：</p><pre><code>// rest 參數 用於形參的聲明function user(...rest) {  // rest 是形參組成的數組}// 擴展運算符，用於函數的調用Math.max(...args);// args 是一個數組，但它作為函數調用的實參// 就變成了，將這個數組拆開成一個普通的列表// 這個列表就是 Math.max 的各個參數，如：// Math.max(1,2,3) // ...args =&gt; 1, 2, 3</code></pre><p>還是上面的例子：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];console.log(Math.max(...nums)); // 10</code></pre><p>我們再也不用手動輸入這個數字列表了。</p><p>不光如此，你還可以傳遞多個 <strong>擴展運算符 </strong>，這也很強大：</p><pre><code>let nums1 = [1, 2, 6, 4, 3, 10];let nums2 = [12, -2, 16, 34, -3, 100];console.log(Math.max(...nums1, ...nums2)); // 100</code></pre><p>我們甚至可以將 <strong>擴展運算符</strong> 與正常值一起使用：</p><pre><code>let nums1 = [1, 2, 6, 4, 3, 10];let nums2 = [12, -2, 16, 34, -3, 100];console.log(Math.max(-200, ...nums1, 88, ...nums2, 888)); // 888</code></pre><p>除此之外，我們也可以利用 <strong>擴展運算符</strong> 將兩個數組合併成一個數組：</p><pre><code>let nums1 = [1,2];let nums2 = [3,4];let merged = [-100, ...nums1, ...nums2, 100];console.log(merged); // [-100, 1, 2, 3, 4, 100]</code></pre><p>其實，任何可遍歷的元素，都可以利用 <strong>擴展運算符 </strong>，比如說，字符串可以轉換成字符數組：</p><pre><code>let str = 'hello';console.log([...str]); // ["h", "e", "l", "l", "o"]</code></pre><p>基於 <strong>擴展運算符</strong> 的特性，我們也可以把 <strong>擴展運算符</strong> 叫做 <strong>展開運算符</strong> 。</p><p><strong>擴展運算符</strong> 用途不止如此，你還可以擴展一個對象：</p><pre><code>let person = {name: 'Tom', age: 18};let personCopy = {...person, sex: '男'};console.log(personCopy); // {name: "Tom", age: 18, sex: "男"}</code></pre><p>關於 <strong>擴展運算符</strong> ，還有一點值得注意：</p><pre><code>let nums = [1, 2, 3];let numsCopy = ...nums; // 報錯了</code></pre><p>上面的寫法報錯了，你應該這麼寫：</p><pre><code>let nums = [1, 2, 3];let numsCopy = [...nums];</code></pre><p>像這種在賦值運算符右側的 '<strong>...</strong>' ，也應該當作 <strong>擴展運算符</strong> 使用。</p><h1 class=pgc-h-center-line>數組和對象的拷貝</h1><p>先解釋一下淺拷貝與深拷貝，簡單說：</p><ul><li><strong>淺拷貝</strong>：拷貝對象裡的基本類型，而不拷貝對象裡的引用類型。</li><li><strong>深拷貝</strong>：完全克隆出一個對象，數據相同，但整體拷貝出來的對象與原來的對象具有不同的引用，且修改任何一個對象的子對象不會影響另一個對象。</li></ul><p>好了，首先，有這麼一段代碼：</p><pre><code>let arr1 = [1,2]let arr2 = [...arr1];console.log(arr1 === arr2); // falsearr1[0] = 100;console.log(arr1); // [100, 2]console.log(arr2); // [1, 2]</code></pre><p>很好，完成拷貝了，但它算深拷貝嗎？看一下深拷貝的定義，arr1 與 arr2 的引用確實不同，似乎是深拷貝吧？別急，再看一個例子：</p><pre><code>let arr1 = [1, 2, [3, 4]];let arr2 = [...arr1];console.log(arr1 === arr2); // falsearr1[2][1] = 100;console.log(arr1); // [1, 2, [3, 100]]console.log(arr2); // [1, 2, [3, 100]]</code></pre><p>引用地址雖然不同，但修改了 arr1[2][1] ，結果 arr2<strong> </strong>的結果也變了，這說明 arr2<strong> </strong>數組並沒有拷貝 arr1 數組的子數組引用，因此，這是一個淺拷貝，用圖例看一下在 let arr2 = [...arr1]; 之後的情形：</p><div class=pgc-img><img alt="瞭解 JavaScript 的 rest參數與擴展運算符 (ES6)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/802749b0a438497c8ebce958134f95f0><p class=pgc-img-caption>數組拷貝</p></div><p>就像圖中看到的那樣，即使 arr1<strong> </strong>和 arr2<strong> </strong>各自保存自己的引用，但它們索引為 2 的子元素卻指向了共同的位置，所以，修改它們其中一個，結果也會反映在另一個數組中。</p><p>那如何進行進行數組的深拷貝呢？現在我們來看看：</p><pre><code>let arr1 = [1,2,[3,4]]let arr2 = JSON.parse(JSON.stringify(arr1));console.log([typeof JSON.stringify(arr1), JSON.stringify(arr1)]);console.log([typeof JSON.parse(JSON.stringify(arr1)), JSON.parse(JSON.stringify(arr1))]);console.log(arr1 === arr2); // falsearr1[2][1] = 100;console.log(arr1); // [1, 2, [3, 100]]console.log(arr2); // [1, 2, [3, 4]]</code></pre><p>關鍵在第 2 行代碼，我們先利用 JSON.stringify(arr1); 將數組轉換成一個 JSON 字符串，這樣它就是一個靜態的東西了，不管它裡面寫的什麼，它就是一個靜態的文本，所以不存在引用問題。然後通過 JSON.parse() 方法將這個字符串轉換成 JavaScript 對象，而這個轉換好的 JavaScript 對象就是 arr1 的一個副本了。</p><p>例如，代碼中的第 3 行的顯示是一個字符串：["string", "[1,2,[3,4]]"] ，代碼第 4 行，顯示的是將字符串轉換成 JavaScript 對象的結果：["object", Array(3)] 。</p><p>對象的拷貝與數組類似：</p><pre><code>let person1 = {  name: '張三',  info: {    sex: '男',    age: 18,    score:[70,100,66]  }}let person2 = JSON.parse(JSON.stringify(person1));person2.info.sex = '女';person2.info.age = 26;person2.info.work = '前端開發';person2.info.score[0] = 99;console.log(person1); // {sex: "男", age: 18, score: [70, 100, 66]}console.log(person2); // {sex: "女", age: 26, score: [99, 100, 66], work: "前端開發"}</code></pre><h1 class=pgc-h-center-line>總結</h1><p>當我們在代碼中看到 '…' 時，它要麼是 <strong>rest 參數</strong> ，要麼是 <strong>擴展運算符</strong> 。</p><p>有一個簡單的方法來區別它們：</p><ul><li>當 '<strong>...</strong>' 在函數參數的末尾，它就是一個 <strong>rest 參數 </strong>，它將參數列表的其餘部分收集到一個數組中。</li><li>當 '<strong>…</strong>' 發生在函數調用或賦值運算符右側的情況下，它就是一個 <strong>擴展運算符</strong> ，將數組或對象擴展為一個列表。<strong>擴展運算符 </strong>一般用於將數組傳遞給通常需要多個參數的函數，如 Math.max() 函數。</li></ul><p>文章中的圖片來源於網絡，若有侵權行為，請在後臺與我聯繫。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>算符</a></li><li><a>瞭解</a></li><li><a>JavaScript</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb530714.html alt=每天學點JavaScript--ES6(ECMAScript5)@擴展運算符 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ef546b6d771e45d2a53ec10cf9c0b0ac style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb530714.html title=每天學點JavaScript--ES6(ECMAScript5)@擴展運算符>每天學點JavaScript--ES6(ECMAScript5)@擴展運算符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html alt=兩分鐘瞭解低損耗電纜結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9af84f52bbed4ee39f3825e0f43e619b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html title=兩分鐘瞭解低損耗電纜結構>兩分鐘瞭解低損耗電纜結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html alt=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/decf8edb02a34404b92b86681378575f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html title=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html alt=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcdae811e636496d948cf5a745f470fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html title=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html alt=「瞭解」房屋的層高和淨高怎麼算？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1526054178152a496189726 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html title=「瞭解」房屋的層高和淨高怎麼算？>「瞭解」房屋的層高和淨高怎麼算？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2db74f7c.html alt=瞭解鍋爐循環泵與換熱站循環泵的佈置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533630871099dca28f1fe7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2db74f7c.html title=瞭解鍋爐循環泵與換熱站循環泵的佈置>瞭解鍋爐循環泵與換熱站循環泵的佈置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html alt=做跨境電商站外推廣，你必須瞭解的Facebook像素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2df772dcb2d747f8b55ff9e4610cbcad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b46ca88.html title=做跨境電商站外推廣，你必須瞭解的Facebook像素>做跨境電商站外推廣，你必須瞭解的Facebook像素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed10eec0.html alt=瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/79d0cee860504ee48c8e419052ceab23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed10eec0.html title=瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？>瞭解了“屍填巨港之岸，血滿長城之窟”，還覺得宋代窩囊嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html alt=瞭解生成對抗網絡（GAN） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/634604de44ad4d17931ccc0bcf3e46ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html title=瞭解生成對抗網絡（GAN）>瞭解生成對抗網絡（GAN）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2f3b02a.html alt=牆繪知識來了，帶你一分鐘瞭解丙烯顏料 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f33c910d91a847bdb6baabc3ab01e0cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2f3b02a.html title=牆繪知識來了，帶你一分鐘瞭解丙烯顏料>牆繪知識來了，帶你一分鐘瞭解丙烯顏料</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6114a4bb.html alt=格鬥周：帶你瞭解各類格鬥術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/46b75604edfa491990901ac982573db9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6114a4bb.html title=格鬥周：帶你瞭解各類格鬥術>格鬥周：帶你瞭解各類格鬥術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/444cae24.html alt=瞭解房屋建築圈樑 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/154043230417821ced6ef46 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/444cae24.html title=瞭解房屋建築圈樑>瞭解房屋建築圈樑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57257e28.html alt=你對鋼製文件櫃瞭解多少呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad059f36d954de2b5517d99057887f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57257e28.html title=你對鋼製文件櫃瞭解多少呢>你對鋼製文件櫃瞭解多少呢</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>