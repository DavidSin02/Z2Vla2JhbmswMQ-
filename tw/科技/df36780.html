<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>在Python中實現SIFT | 极客快訊</title><meta property="og:title" content="在Python中實現SIFT - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/4d54a888a82a417f9de8881a364524ef"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df36780.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><meta property="article:published_time" content="2020-10-29T20:51:13+08:00"><meta property="article:modified_time" content="2020-10-29T20:51:13+08:00"><meta name=Keywords content><meta name=description content="在Python中實現SIFT"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/df36780.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>在Python中實現SIFT</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>關於SIFT有很多內容。有很多很好的教程，但每個都似乎缺少一些東西，無論是關於算法還是實現的細節。因此，當我決定為自己實施SIFT時，我發現自己很難從許多來源中提取內容。我完成了一部分任務，現在分享我的過程以及其他教程未提及的一些細節。</p><p><strong>介紹</strong></p><p>對於初學者來說，SIFT是什麼？SIFT是尺度不變特徵變換，是一種用於提取描述圖像的局部斑塊的特徵向量的方法。這些特徵向量不僅具有尺度不變性，而且對於平移，旋轉和光照度也是不變的。幾乎是描述符的聖盃。</p><p>這些描述符對於匹配對象是圖像之間的補丁非常有用。例如，考慮創建全景圖。假設每個圖像都有一些重疊的部分，你需要一些方法來對齊它們，這樣我們就可以將它們拼接在一起。如果我們知道每個圖像中有一些點對應，我們可以使用單應性來扭曲其中一個圖像。SIFT不僅可以自動查找每個圖像中的對應點，還可以自動查找易於匹配的點。</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4d54a888a82a417f9de8881a364524ef><p class=pgc-img-caption>兩個圖像具有重疊區域</p></div><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7705b63956514d88b71dc2e07d36a437><p class=pgc-img-caption>使用SIFT特徵點的單應性轉換一個圖像後的結果</p></div><p><strong>算法描述</strong></p><p>SIFT算法有五個主要步驟：</p><ol><li>尺度空間極值檢測</li><li>關鍵點本地化</li><li>消除邊緣響應</li><li>方向分配</li><li>本地描述符創建</li></ol><p>尺度空間極值檢測</p><p>可以使用標度歸一化的拉普拉斯高斯（LoG）濾波器來檢測特徵的特徵尺度。這就是LoG過濾器的樣子：</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27e9d3b8b67640e3862a3b836294e2b2><p class=pgc-img-caption></p></div><p><strong>負面的</strong></p><p>LoG濾波器在中心處具有高峰值，同時變為略微負的，然後在距離中心一定距離處為零，其特徵在於高斯的標準偏差sigma（∑，σ）。</p><p>因此，LoG濾波器由圓或blob最高度激活，半徑與sigma成比例。然而，高斯是標準化的分佈，即如果你將它整合到所有空間，它總和為1。因此，對於更高的sigma並因此更寬的高斯，LoG濾波器對該高斯的響應將低於較小的sigma。因此，SIFT使用<strong>標準歸一化的</strong> LoG濾波器，它是常規LoG乘以方差（sigma平方）。</p><p>DoG（Difference of Gaussian）近似</p><p>雖然規模標準化的LoG很好，但計算成本很高，特別是因為我們需要在許多不同的尺度上進行計算。不過，SIFT的作者提出了一種巧妙的方法來有效地計算許多尺度的LoG。</p><p>事實證明，具有相似方差的兩個高斯的差異產生的濾波器非常接近於尺度標準化的LoG：</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7ff08a5cd79d4805b93c2ff9306fab2a><p class=pgc-img-caption>兩個高斯的差異近似於高斯的拉普拉斯算子</p></div><p>DoG（Difference of Gaussian）金字塔</p><p>既然我們有一種有效的方法來逼近LoG，我們需要在多個尺度上進行計算。SIFT使用多個Octave來計算DoG。大多數人會認為計算八個圖像需要八個Octave來使用。然而，Octave實際上是一組圖像，其中最後一個圖像的模糊是第一個圖像的模糊的<strong>兩倍</strong>。</p><p>要創建這個Octave，我們首先需要選擇每個Octave中想要的圖像數量。這由s表示。然後選擇高斯濾波器的sigma為2 ^（1 / s）。由於模糊累積累加，當我們使用此濾鏡s次模糊原始圖像時，結果將具有模糊= 2 *原始模糊。</p><p>我很少看到的其他內容中的一個細節是，在每個Octave中，你實際上需要產生s + 3個圖像（包括原始圖像）。這是因為當減去相鄰級別以獲得近似的LoG Octave時，我們將獲得比Gaussian octave少一個的圖像：</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/41425698049946cf831a239b5d9dad21><p class=pgc-img-caption>用於SIFT的高斯金字塔</p></div><p>現在我們在DoG Octave中有s + 2個圖像。但是，稍後當我們在DoG中查找極值時，我們將查找當前和相鄰級別指定的鄰域的最小值或最大值。顯然，這個鄰域不能在頂層或底層獲得，所以我們有這兩個額外的層次，以便在縮放空間中定義一個完整的Octave。</p><p>在我們生成Gaussian octave之後，我們將頂級下采樣2並將其用作新Octave的底層。這些Octave組成了我所說的高斯金字塔。</p><p>履行</p><p>最後我們得到了一些代碼。首先，我們顯然需要一個高斯濾波器來創建Gaussian octave：</p><pre>def gaussian_filter(sigma):size = 2*np.ceil(3*sigma)+1x, y = np.mgrid[-size//2 + 1:size//2 + 1, -size//2 + 1:size//2 + 1] g = np.exp(-((x**2 + y**2)/(2.0*sigma**2))) / (2*np.pi*sigma**2)return g/g.sum() </pre><p>這假設numpy已經作為np導入（因為它總是應該）。我也把它放在一個名為的文件中gaussian_filter.py。接下來，為了生成Gaussian octave，我們只需要選擇sigma並用這個高斯濾波器重複卷積：</p><pre>from scipy.ndimage.filters import convolvefrom gaussian_filter import gaussian_filter  def generate_octave(init_level, s, sigma):octave = [init_level]k = 2**(1/s)kernel = gaussian_filter(k * sigma)  for _in range(s+2):next_level = convolve(octave[-1], kernel)octave.append(next_level) return octave</pre><p>正如在文中，我使用的是5。另一個需要注意的是sigma參數。此參數用於縮放k，以便每個DoG octave中的模糊來自sigma - > 2 * sigma。我為sigma使用值1.6。然後生成整個高斯金字塔：</p><pre> def generate_gaussian_pyramid(im, num_octave, s, sigma):pyr = [] for _ in range(num_octave):octave = generate_octave(im, s, sigma)pyr.append(octave)im = octave[-3][::2, ::2] return pyr</pre><p>由於我們每個Octave生成s + 3個圖像，我們使用第三個到最後一個圖像作為下一個Octave的基礎，因為那是一個模糊為2 * sigma的圖像。</p><p>現在我們有了高斯金字塔，創建DoG金字塔是很簡單的：</p><pre> def generate_DoG_octave(gaussian_octave):octave = [] for i in range(1, len(gaussian_octave)):octave.append(gaussian_octave[i] — gaussian_octave[i-1]) return np.concatenate([o[:,:,np.newaxis] for o in octave], axis=2） def generate_DoG_pyramid(gaussian_pyramid):pyr = [] for gaussian_octave in gaussian_pyramid:pyr.append(generate_DoG_octave(gaussian_octave)) return pyr</pre><p>現在我們有四個DoG octave，每個都有s + 2級模糊。我們現在可以繼續檢測尺度空間中的極值。</p><p>極值檢測</p><p>極值檢測的第一步是掃描每個標度空間DoG octave的 D值，並將每個3x3x3鄰域的中心作為關鍵點，如果它是鄰域中的最小值或最大值。</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e4070c372c6d452a9e6ae55c1d72e3e0><p class=pgc-img-caption>初始尺度空間極值檢測的鄰域</p></div><p>這就是為什麼我們在DoG octave中生成s + 2級別的原因，因為我們無法掃描頂部或底部的點，但我們仍然想要在整個Octave模糊點上獲得關鍵點。</p><p>履行</p><p>給定DoG octave，我們獲得初始候選關鍵點：</p><pre> def get_candidate_keypoints(D, w=16):candidates = []D[:,:,0] = 0D[:,:,-1] = 0 for i in range(w//2+1, D.shape[0]-w//2–1):for j in range(w//2+1, D.shape[1]-w//2–1):for k in range(1, D.shape[2]-1):patch = D[i-1:i+2, j-1:j+2, k-1:k+2]if np.argmax(patch) == 13 or np.argmin(patch) == 13:candidates.append([i, j, k]) return candidates</pre><p>這段代碼的內容解釋：</p><p>我將頂部和底部的額外級別設置為0，因為我最初只是在這些級別中獲得極值。這可能是因為DoG octave的構造不正確，但卻運行得還可以。</p><ol><li>我們有一個w / 2的填充，而不是在每個級別上使用一個填充進行掃描，其中w是創建局部描述符時使用的補丁的邊長。沒有這個，就會出錯誤。</li><li>調用argmax或argmin不調用軸參數在展平的數組上運行。由於我們的鄰域是3x3x3或27個元素長，當極值是我們檢查的像素時，argmax或argmin的值將是13。</li></ol><p>這些候選關鍵點會產生許多糟糕的選擇和噪聲，因此在下一節中我們將選擇好的關鍵點並拋棄部分不好的點。</p><p>關鍵點定位</p><p>我們將執行三個步驟來獲得更好的關鍵點：</p><ol><li>計算每個關鍵點的子像素位置</li><li>如果子像素處的比例空間值低於閾值，則丟棄該關鍵點</li><li>使用圍繞每個子像素關鍵點的Hessian消除邊緣上的關鍵點</li></ol><p>子像素定位</p><p>在許多圖像中，在分辨率不夠精確的時候很難找到穩定的關鍵點，即在多個條件下在多個圖像中的相同位置。因此，SIFT的創建者使用DoG octave的二階Taylor展開來進一步定位每個關鍵點。</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a23102a79fed48f890482e07047e3844><p class=pgc-img-caption>DoG octave的二階Taylor展開</p></div><p>這裡，x是與備選關鍵點的像素位置對應的三維矢量[x，y，sigma]。將該等式的導數相對於x並將其設置為等於零，得到關鍵點的子像素偏移：</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99b0dd8272db43a19961885f74056026><p class=pgc-img-caption>備選關鍵點偏移（二階）</p></div><p>將此偏移添加到原始關鍵點位置以實現子像素精度。</p><p><strong>實現</strong></p><p>我們需要圍繞每個候選關鍵點計算Jacobian和Hessian以獲得偏移量：</p><pre>def localize_keypoint(D, x, y, s):dx = (D[y,x+1,s]-D[y,x-1,s])/2.dy = (D[y+1,x,s]-D[y-1,x,s])/2.ds = (D[y,x,s+1]-D[y,x,s-1])/2. dxx = D[y,x+1,s]-2*D[y,x,s]+D[y,x-1,s] dxy = ((D[y+1,x+1,s]-D[y+1,x-1,s]) — (D[y-1,x+1,s]-D[y-1,x-1,s]))/4. dxs = ((D[y,x+1,s+1]-D[y,x-1,s+1]) — (D[y,x+1,s-1]-D[y,x-1,s-1]))/4. dyy = D[y+1,x,s]-2*D[y,x,s]+D[y-1,x,s]dys = ((D[y+1,x,s+1]-D[y-1,x,s+1]) — (D[y+1,x,s-1]-D[y-1,x,s-1]))/4.dss = D[y,x,s+1]-2*D[y,x,s]+D[y,x,s-1] J = np.array([dx, dy, ds])HD = np.array([ [dxx, dxy, dxs], [dxy, dyy, dys], [dxs, dys, dss]]) offset = -LA.inv(HD).dot(J)return offset, J, HD[:2,:2], x, y, s</pre><p>首先，計算雅可比行列式的一階導數。然後，我們計算Hessian的二階導數。Hessian是對稱的，所以我們只需計算六個導數而不是九個。我們返回J和H因為我們以後會需要它們。</p><p>作為旁註，當偏移的維度大於0.5時，這意味著它實際上更接近另一個像素級關鍵點。</p><p><strong>丟棄低對比度關鍵點</strong></p><p>現在可以將每個子像素關鍵點的對比度計算為：</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e58678d970304374821c292894431d8a><p class=pgc-img-caption>子像素關鍵點對比度</p></div><p>哪個子像素偏移添加到像素級位置。如果絕對值低於閾值，我們就會拋出這一點。我們這樣做是因為我們想要極端，極端，極端。</p><p>消除邊緣響應</p><p>尺度標準化的LoG將在角落和邊緣處創建高對比度響應。但是，邊緣上的關鍵點應該被丟棄，因為它們的方向是模糊的。為此，我們使用計算子像素偏移時計算的Hessian。這個過程非常類似於使用Harris角點探測器尋找角點。</p><p>我們返回的Hessian localize_keypoint的形式如下：</p><div class=pgc-img><img alt=在Python中實現SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/390ca2d7b19344338b2c787548646359><p class=pgc-img-caption>Hessian在規模空間與曲率成比例</p></div><p>如果你熟悉Harris探測器，如果H的特徵值（比如A和B）都很​​大，那麼關鍵點很可能是一個角。相反，如果一個大得多，那麼它很可能是邊緣。</p><p>即使計算這個矩陣的特徵值是很便宜的，還有另一種方法可以用來獲取H的跟蹤和行列式。我們將放棄在這裡討論。</p><p>實現</p><p>我們在以下功能中執行上述步驟：</p><pre> def find_keypoints_for_DoG_octave(D, R_th, t_c, w):candidates = get_candidate_keypoints(D, w)keypoints = [] for i, cand in enumerate(candidates):y, x, s = cand[0], cand[1], cand[2]offset, J, H, x, y, s = localize_keypoint(D, x, y, s) contrast = D[y,x,s] + .5*J.dot(offset)if abs(contrast) &lt; t_c: continue w, v = LA.eig(H)r = w[1]/w[0] R = (r+1)**2 / rif R &gt; R_th: continue kp = np.array([x, y, s]) + offsetkeypoints.append(kp) return np.array(keypoints)</pre><p>我使用來自paper的值t_c和R_th即分別為0.03和（10 + 1）2/10。</p><p>現在計算整個DoG金字塔的關鍵點是微不足道的：</p><pre> def get_keypoints(DoG_pyr, R_th, t_c, w):kps = [] for D in DoG_pyr:kps.append(find_keypoints_for_DoG_octave(D, R_th, t_c, w)) return kps</pre><p><strong>方向分配</strong></p><p>獲得關鍵點只是成功的一半。現在我們必須獲得實際的描述符。但在我們這樣做之前，我們需要確保另一種不變性：旋轉。</p><p>我們有平移不變性，因為我們在圖像上對濾波器進行卷積。由於我們使用了標度歸一化的LoG濾波器，因此我們也具有尺度不變性。現在為了施加旋轉不變性，我們在每個關鍵點周圍分配一個與其主要梯度方向相對應的方向。當我們使用梯度直方圖描述符來描述每個補丁時，這會有點用的。</p><p>為了分配方向，我們在每個關鍵點周圍採用一個補丁，其大小與該關鍵點的比例成正比。然後，我們為該補丁中的每個像素創建漸變的直方圖。</p><p>直方圖是在角度上創建的（梯度在極座標中指定）並且具有36個箱（每個箱具有10度的寬度）。當計算像素處的梯度的大小和角度時，我們的直方圖中的對應區間增長了由高斯窗口加權的梯度大小。</p><p>一旦我們得到直方圖，我們就為該關鍵點指定最大直方圖bin的方向。</p><p>實現</p><pre> def assign_orientation(kps, octave, num_bins=36):new_kps = []bin_width = 360//num_bins for kp in kps:cx, cy, s = int(kp[0]), int(kp[1]), int(kp[2])s = np.clip(s, 0, octave.shape[2]-1)sigma = kp[2]*1.5w = int(2*np.ceil(sigma)+1)kernel = gaussian_filter(sigma)L = octave[…,s]hist = np.zeros(num_bins, dtype=np.float32) for oy in range(-w, w+1):for ox in range(-w, w+1):x, y = cx+ox, cy+oyif x &lt; 0 or x &gt; octave.shape[1]-1: continueelif y &lt; 0 or y &gt; octave.shape[0]-1: continue m, theta = get_grad(L, x, y)weight = kernel[oy+w, ox+w] * mbin = quantize_orientation(theta, num_bins)hist[bin] += weight max_bin = np.argmax(hist)new_kps.append([kp[0], kp[1], kp[2], max_bin])max_val = np.max(hist) for binno, val in enumerate(hist):if binno == max_bin: continueif .8 * max_val &lt;= val:new_kps.append([kp[0], kp[1], kp[2], binno*bin_width]) return np.array(new_kps)</pre><p>關於這個函數我想提到的一件事是最後一個循環。本文規定，對於任何直方圖bin，其值大於最大值的80％，以在該位置創建新關鍵點並進行縮放但具有新方向。</p><p>此外，本文還說您應該將拋物線擬合到最接近最大值的三個直方圖值，但在此實現中省略了這一點。</p><p>此代碼中還包含一些功能。首先get_grads ，它獲得L中像素的極座標梯度：</p><pre> def cart_to_polar_grad(dx, dy):m = np.sqrt(dx**2 + dy**2)theta = (np.arctan2(dy, dx)+np.pi) * 180/np.pireturn m, theta def get_grad(L, x, y):dy = L[min(L.shape[0]-1, y+1),x] — L[max(0, y-1),x]dx = L[y,min(L.shape[1]-1, x+1)] — L[y,max(0, x-1)]return cart_to_polar_grad(dx, dy)</pre><p>然後有quantize_orientation，它只是將漸變的連續角度轉換為直方圖箱：</p><pre> </pre><p>def quantize_orientation(theta, num_bins):</p><p>bin_width = 360//num_bins</p><p>return int(np.floor(theta)//bin_width)</p><p>定位描述符創建</p><p><em>最後</em>，我們可以為每個關鍵點創建定位描述符。如前所述，我們使用“梯度直方圖”方法從每個關鍵點的周圍創建一個特徵向量。</p><p>具體來說，在每個關鍵點周圍檢查16x16補丁。然後將該補丁分成16個4x4子區域。然後將每個子區域的梯度（在極座標中）分箱成8箱直方圖。最後，所有這些直方圖被連接成4x4x8 = 128個元素的長特徵向量。</p><p>然後對該最終特徵向量進行歸一化，閾值化和重新歸一化以嘗試並確保對次要光照變化的不變性。</p><p>實現</p><pre> def get_local_descriptors(kps, octave, w=16, num_subregion=4, num_bin=8):descs = [] for kp in kps:cx, cy, s = int(kp[0]), int(kp[1]), int(kp[2])s = np.clip(s, 0, octave.shape[2]-1)kernel = gaussian_filter(w/6) # gaussian_filter multiplies sigma by 3 L = octave[…,s] t, l = max(0, cy-w//2), max(0, cx-w//2) b, r = min(L.shape[0], cy+w//2+1), min(L.shape[1], cx+w//2+1) patch = L[t:b, l:r] dx, dy = get_patch_grads(patch) if dx.shape[0] &lt; w+1:if t == 0: kernel = kernel[kernel.shape[0]-dx.shape[0]:]else: kernel = kernel[:dx.shape[0]]if dx.shape[1] &lt; w+1:if l == 0: kernel = kernel[kernel.shape[1]-dx.shape[1]:]else: kernel = kernel[:dx.shape[1]]if dy.shape[0] &lt; w+1:if t == 0: kernel = kernel[kernel.shape[0]-dy.shape[0]:]else: kernel = kernel[:dy.shape[0]]if dy.shape[1] &lt; w+1:if l == 0: kernel = kernel[kernel.shape[1]-dy.shape[1]:]else: kernel = kernel[:dy.shape[1]] m, theta = cart_to_polar_grad(dx, dy)dx, dy = dx*kernel, dy*kernel subregion_w = w//num_subregion featvec = np.zeros(num_bin * num_subregion**2, dtype=np.float32) for i in range(0, subregion_w):for j in range(0, subregion_w):t, l = i*subregion_w, j*subregion_wb, r = min(L.shape[0], (i+1)*subregion_w), min(L.shape[1], (j+1)*subregion_w) hist = get_histogram_for_subregion(m[t:b, l:r].ravel(), theta[t:b, l:r].ravel(), num_bin, kp[3]) featvec[i*subregion_w*num_bin + j*num_bin:i*subregion_w*num_bin + (j+1)*num_bin] = hist.flatten()descs.append(featvec) return np.array(descs)</pre><p>對中間形狀dx和dy中間形狀的檢查是為了避免我之前遇到的越界錯誤。如果其中一個/或小於w+1那麼相應地切斷高斯窗口以避免形狀不匹配。</p><p>首先，計算整個貼片的極性梯度。然後為每個子區域創建直方圖。</p><p>要計算補丁中的漸變：</p><pre> def get_patch_grads(p):r1 = np.zeros_like(p)r1[-1] = p[-1]r1[:-1] = p[1:] r2 = np.zeros_like(p)r2[0] = p[0]r2[1:] = p[:-1] dy = r1-r2 r1[:,-1] = p[:,-1]r1[:,:-1] = p[:,1:]r2[:,0] = p[:,0]r2[:,1:] = p[:,:-1] dx = r1-r2 return dx, dy</pre><p>只需獲取前一個和當前像素之間的差異。這比以前做雙面衍生更容易。然後為每個子區域創建直方圖：</p><pre> def get_histogram_for_subregion(m, theta, num_bin, reference_angle):hist = np.zeros(num_bin, dtype=np.float32) for mag, angle in zip(m, theta):binno = quantize_orientation(angle-reference_angle, num_bin)hist[binno] += mag hist /= max(1e-6, LA.norm(hist)) hist[hist&gt;0.2] = 0.2 hist /= max(1e-6, LA.norm(hist))return hist</pre><p>這段代碼與前面的HoG代碼非常相似，但是我們對直方圖中的每個條目執行三線性插值。這個插值是為了提供魯棒性，當一個像素的梯度從一個箱子到另一個或在一個子區域的邊緣進入一個不同的子區域。</p><p>因此，對於x和y方向，條目的權重與1-(到容器中心的距離)和1-(到子區域中心的距離)成正比。</p><p><strong>把它放在一起</strong></p><p>我們現在可以創建一個SIFT對象來封裝所有上述操作：</p><pre> class SIFT(object):def __init__(self, im, s=3, num_octave=4, s0=1.3, sigma=1.6, r_th=10, t_c=0.03, w=16):self.im = convolve(rgb2gray(im), gaussian_filter(s0))self.s = sself.sigma = sigmaself.num_octave = num_octaveself.t_c = t_cself.R_th = (r_th+1)**2 / r_thself.w = w def get_features(self):gaussian_pyr = generate_gaussian_pyramid(self.im, self.num_octave, self.s, self.sigma)DoG_pyr = generate_DoG_pyramid(gaussian_pyr)kp_pyr = get_keypoints(DoG_pyr, self.R_th, self.t_c, self.w)feats = [] for i, DoG_octave in enumerate(DoG_pyr): kp_pyr[i] =assign_orientation(kp_pyr[i], DoG_octave)feats.append(get_local_descriptors(kp_pyr[i], DoG_octave)) self.kp_pyr = kp_pyrself.feats = feats return feats</pre><p>最後一個小細節是我用1.3的sigma模糊初始圖像。</p><p>結論</p><p>文章講的可能並不是那麼清楚，但我希望你能學到一些關於理論和如何實現SIFT的知識。</p><p>只是個人學習文章。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Python</a></li><li><a>中實現</a></li><li><a>SIFT</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/6791842.html alt="OpenCV-Python SIFT尺度不變特徵變換 | 三十九" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/097cdfdfc9d741b98072398d3cb43908 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/6791842.html title="OpenCV-Python SIFT尺度不變特徵變換 | 三十九">OpenCV-Python SIFT尺度不變特徵變換 | 三十九</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html alt=Python爬蟲教程，利用Python採集QQ群成員信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d6cce76ad48405c9dbb960d4617bcef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html title=Python爬蟲教程，利用Python採集QQ群成員信息>Python爬蟲教程，利用Python採集QQ群成員信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html alt=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5d4a0000046e1bea8b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html title=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？>Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html alt=Python中的多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49dd44b999924b69bd3396709ecacaf4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html title=Python中的多進程>Python中的多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html alt="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html title="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結">Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fa274c2.html alt="七十九、Python | Leetcode 二叉樹系列（上篇）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a6c9fa6432a3419a8a60bd334f978a11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fa274c2.html title="七十九、Python | Leetcode 二叉樹系列（上篇）">七十九、Python | Leetcode 二叉樹系列（上篇）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0a927d6.html alt=Python中如何定義只讀屬性？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/60dafb43-a3bb-4456-9f60-3d55ab9e1c4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0a927d6.html title=Python中如何定義只讀屬性？>Python中如何定義只讀屬性？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68f62be6.html alt=Python文件讀寫方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/dca556bb2ffb4013b992ebb4b6a9a296 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68f62be6.html title=Python文件讀寫方法>Python文件讀寫方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d9fe5d5.html alt=Python開發常見問題彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1525506011510ee699a3e91 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d9fe5d5.html title=Python開發常見問題彙總>Python開發常見問題彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7dad731d.html alt=對於新手來說，Python中有哪些難以理解的概念？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1f4ec4c3a6484cf58453023c44e01d75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7dad731d.html title=對於新手來說，Python中有哪些難以理解的概念？>對於新手來說，Python中有哪些難以理解的概念？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>