<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？ | 极客快訊</title><meta property="og:title" content="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/S2XWraJF1wHo8F"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><meta property="article:published_time" content="2020-10-29T20:50:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:41+08:00"><meta name=Keywords content><meta name=description content="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/dffb53c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S2XWraJF1wHo8F><p>作者 | 是Yes呀</p><p>責編 | 鄭麗媛</p><p>來源 | yes的練級攻略（ID：yes_java）</p><blockquote class=pgc-blockquote-abstract toutiao-origin=blockquote><div><p>每個時代，都不會虧待會學習的人。</p></div></blockquote><p>大家好，我是 yes。</p><p>今天我們來談一談消息隊列的事務消息，一說起事務相信大家都不陌生，腦海裡蹦出來的就是 ACID。</p><p>通常我們理解的事務就是為了一些更新操作要麼都成功，要麼都失敗，不會有中間狀態的產生，而 ACID 是一個嚴格的事務實現的定義，不過在單體系統時候一般都不會嚴格的遵循 ACID 的約束來實現事務，更別說分佈式系統了。</p><p><strong>分佈式系統往往只能妥協到最終一致性</strong>，保證數據最終的完整性和一致性，主要原因就是實力不允許...因為可用性為王。</p><p>而且要保證完全版的事務實現代價很大，你想想要維護這麼多系統的數據，不允許有中間狀態數據可以被讀取，所有的操作必須不可分割，這意味著一個事務的執行是阻塞的，資源是被長時間鎖定的。</p><p>在高併發情況下資源被長時間的佔用，就是致命的傷害，舉一個有味道的例子，如廁高峰期，好了懂得都懂。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItqPGBYi2qcM><p>對了， ACID是什麼還不太清楚的同學，趕緊去查一查，這裡我就不展開說了。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p></p><h1 toutiao-origin=h2>分佈式事務</h1><p>那說到分佈式事務，常見的有 2PC、TCC 和事務消息，這篇文章重點就是事務消息，不過 2PC 和 TCC 我稍微提一下。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p></p><h1 toutiao-origin=h2>2PC</h1><p>2PC就是二階段提交，分別有協調者和參與者兩個角色，二階段分別是準備階段和提交階段。</p><p>準備階段就是協調者向各參與者發送準備命令，這個階段參與者除了事務的提交啥都做了，而提交階段就是協調者看看各個參與者準備階段都 o 不 ok，如果有ok那麼就向各個參與者發送提交命令，如果有一個不ok那麼就發送回滾命令。</p><p>這裡的重點就是 <strong>2PC 只適用於數據庫層面的事務</strong>，什麼意思呢？就是你想在數據庫裡面寫一條數據同時又要上傳一張圖片，這兩個操作 2PC 無法保證兩個操作滿足事務的約束。</p><p>而且 2PC 是一種<strong>強一致性</strong>的分佈式事務，它是<strong>同步阻塞</strong>的，即在接收到提交或回滾命令之前，所有參與者都是互相等待，特別是執行完準備階段的時候，此時的資源都是鎖定的狀態，假如有一個參與者卡了很久，其他參與者都得等它，<strong>產生長時間資源鎖定狀態下的阻塞</strong>。</p><p>總體而言效率低，並且存在單點故障問題，協調者是就是那個單點，並且在極端條件下存在數據不一致的風險，例如某個參與者未收到提交命令，此時宕機了，恢復之後數據是回滾的，而其他參與者其實都已經執行了提交事務的命令了。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p></p><h1 toutiao-origin=h2>TCC</h1><p><strong>TCC能保證業務層面的事務</strong>，也就是說它不僅僅是數據庫層面，上面的上傳圖片這種操作它也能做。</p><p>TCC 分為三個階段 try - confirm - cancel，簡單的說就是每個業務都需要有這三個方法，先都執行try方法，這一階段不會做真正的業務操作，只是先佔個坑，什麼意思呢？比如打算加10個積分，那先在預添加字段加上這10積分，這個時候用戶賬上的積分其實是沒有增加的。</p><p>然後如果都try成功了那麼就執行confirm方法，大家都來做真正的業務操作，如果有一個try失敗了那麼大家都執行cancel操作，來撤回剛才的修改。</p><p>可以看到<strong>TCC其實對業務的耦合性很大</strong>，因為業務上需要做一定的改造才能完成這三個方法，這其實就是TCC的缺點，<strong>並且confirm和cancel操作要注意冪等</strong>，因為到執行這兩步的時候沒有退路，是務必要完成的，因此需要有重試機制，所以需要保證方法冪等。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7YR5xGDl><p></p><h1 toutiao-origin=h2>事務消息</h1><p>事務消息就是今天文章的主角了，它<strong>主要是適用於異步更新的場景，並且對數據實時性要求不高的地方</strong>。</p><p>它的目的是為了<strong>解決消息生產者與消息消費者的數據一致性問題</strong>。</p><p>比如你點外賣，我們先選了炸雞加入購物車，又選了瓶可樂，然後下單，付完款這個流程就結束了。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9ItqzS7Qsy7KT><p>而購物車裡面的數據就很適合用消息通知異步刪除，因為一般而言我們下完單不會再去點開這個店家的菜單，而且就算點開了購物車裡還有這些菜品也沒有關係，影響不大。</p><p>我們希望的就是下單成功之後購物車的菜品最終會被刪除，所以要點就是<strong>下單和發消息這兩個步驟要麼都成功要麼都失敗</strong>。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7uHXU5GZc><p></p><h1 toutiao-origin=h2>RocketMQ 事務消息</h1><p>我們先來看一下 RocketMQ 是如何實現事務消息的。</p><p>RocketMQ 的事務消息也可以被認為是一個兩階段提交，簡單的說就是在事務開始的時候會先發送一個半消息給 Broker 。</p><p>半消息的意思就是這個消息此時對 Consumer 是不可見的，而且也不是存在真正要發送的隊列中，而是一個特殊隊列。</p><p>發送完半消息之後再執行本地事務，再根據本地事務的執行結果來決定是向 Broker發送提交消息，還是發送回滾消息。</p><p>此時有人說這一步發送提交或者回滾消息失敗了怎麼辦？</p><p>影響不大，<strong>Broker 會定時的向 Producer 來反查這個事務是否成功</strong>，具體的就是 Producer 需要暴露一個接口，通過這個接口 Broker 可以得知事務到底有沒有執行成功，沒成功就返回未知，因為有可能事務還在執行，會進行多次查詢。</p><p>如果成功那麼就將半消息恢復到正常要發送的隊列中，這樣消費者就可以消費這條消息了。</p><p>我們再來簡單的看下如何使用，我根據官網示例代碼簡化了下。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itr0aE69UsgH><p>可以看到使用起來還是很簡便直觀的，無非就是多加個反查事務結果的方法，然後把本地事務執行的過程寫在 TransationListener 裡面。</p><p>至此 RocketMQ 事務消息大致的流程已經清晰了，我們畫一張整體的流程圖來過一遍，其實到第四步這個消息要麼就是正常的消息，要麼就是拋棄什麼都不存在，此時這個事務消息已經結束它的生命週期了。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itr16Gqpmd7U><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTLSNam5ZxLDlM><p></p><h1 toutiao-origin=h2>RocketMQ 事務消息源碼分析</h1><p>然後我們再從源碼的角度來看看到底是怎麼做的，首先我們看下<strong toutiao-origin=span>sendMessageInTransaction</strong>方法，方法有點長，不過沒有關係結構還是很清晰的。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItruDIDTYP7><p>流程也就是我們上面分析的，將消息塞入一些屬性，標明此時這個消息還是半消息，然後發送至 Broker ，然後執行本地事務，然後將本地事務的執行狀態發送給 Broker ，我們現在<strong>再來看下 Broker 到底是怎麼處理這個消息的</strong>。</p><p>在 Broker 的 SendMessageProcessor#sendMessage 中會處理這個半消息請求，因為今天主要分析的是事務消息，所以其他流程不做分析，我大致的說一下原理。</p><p>簡單的說就是sendMessage中查到接受來的消息的屬性裡面</p><blockquote toutiao-origin=span>MessageConst.PROPERTY_TRANSACTION_PREPARED</blockquote><p>是true，那麼可以得知這個消息是事務消息，然後再判斷一下這條消息是否超過最大消費次數，是否要延遲，Broker 是否接受事務消息等操作後，將這條消息真正的topic和隊列存入屬性中，然後重置消息的 topic 為<strong toutiao-origin=span>RMQ_SYS_TRANS_HALF_TOPIC</strong>，並且隊列是 0 的隊列中，使得消費者無法讀取這個消息。</p><p>以上就是整體處理半消息的流程，我們來看一下源碼。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itruz5IdIfCg><p>就是來了波狸貓換太子，其實延時消息也是這麼實現的，最終將換了皮的消息入盤。</p><p>Broker處理提交或者回滾消息的處理方法是</p><blockquote toutiao-origin=span>EndTransactionProcessor#processRequest</blockquote><p>，我們來看一看它做了什麼操作。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9ItrvT6Fbc4dj><p>可以看到，如果是提交事務就是把皮再換回來寫入真正的topic所屬的隊列中，供消費者消費，如果是回滾則是將半消息記錄到一個 half_op 主題下，到時候後臺服務掃描半消息的時候就依據其來判斷這個消息已經處理過了。</p><p>那個後臺服務就是<strong toutiao-origin=span>TransactionalMessageCheckService</strong>服務，它會定時的掃描半消息隊列，去請求反查接口看看事務成功了沒，具體執行的就是</p><blockquote toutiao-origin=span>TransactionalMessageServiceImpl#check</blockquote><p>方法。</p><p>我大致說一下流程，這一步驟其實涉及到的代碼很多，我就不貼代碼了，有興趣的同學自行了解。不過我相信用語言也是能說清楚的。</p><p>首先取半消息 topic 即<strong toutiao-origin=span>RMQ_SYS_TRANS_HALF_TOPIC</strong>下的所有隊列，如果還記得上面內容的話，就知道半消息寫入的隊列是 id 是 0 的這個隊列，然後取出這個隊列對應的half_op主題下的隊列，即<strong toutiao-origin=span>RMQ_SYS_TRANS_OP_HALF_TOPIC</strong>主題下的隊列。</p><p>這個 half_op 主要是為了記錄這個事務消息已經被處理過，也就是說已經得知此事務消息是提交的還是回滾的消息會被記錄在 half_op 中。</p><p>然後調用 fillOpRemoveMap 方法，從half_op取一批已經處理過的消息來去重，將那些沒有記錄在half_op裡面的半消息調用<strong toutiao-origin=span>putBackHalfMsgQueue</strong>又寫入了commitlog中，然後發送事務反查請求，這個反查請求也是oneWay，即不會等待響應。當然此時的半消息隊列的消費 offset 也會推進。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itrw7GyIETzV><p>然後<strong>producer</strong>中的 ClientRemotingProcessor#processRequest 會處理這個請求，會把任務扔到 TransactionMQProducer 的線程池中進行，最終會調用上面我們發消息時候定義的<strong toutiao-origin=span>checkLocalTransactionState</strong>方法，然後將事務狀態發送給Broker，也是用oneWay的方式。</p><p>看到這裡相信大家會有一些疑問，比如為什麼要有個half_op，為什麼半消息處理了還要再寫入commitlog中別急聽我一一道來。</p><p>首先<strong>RocketMQ的設計就是順序追加寫入，所以說不會更改已經入盤的消息</strong>，那事務消息又需要更新反查的次數，超過一定反查失敗就判定事務回滾。</p><p>因此每一次要反查的時候就將以前的半消息再入盤一次，並且往前推進消費進度。而half_op又會記錄每一次反查的結果，不論是提交還是回滾都會記錄，因此下一次還循環到處理此半消息的時候，可以從 half_op 得知此事務已經結束了，因此就被過濾掉不需要處理了。</p><p>如果得到的反查的結果是 UNKNOW，那 half_op 中也不會記錄此結果，因此還能再次反查，並且更新反查次數。</p><p>到現在整個流程已經清晰了，我再畫個圖總結一下 Broker 的事務處理流程。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItrwSFc1sIUq><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTRIuPNI7JPB03><p></p><h1 toutiao-origin=h2>Kafka 事務消息</h1><p>Kafka的事務消息和RocketMQ的事務消息又不一樣了，RocketMQ解決的是本地事務的執行和發消息這兩個動作滿足事務的約束。</p><p>而Kafka事務消息則是用在一次事務中需要發送多個消息的情況，保證多個消息之間的事務約束，即多條消息要麼都發送成功，要麼都發送失敗，就像下面代碼所演示的。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItuIGCDCjxg5><p><strong>Kafka 的事務基本上是配合其冪等機制來實現 Exactly Once 語義的</strong>，所以說 Kafka 的事務消息不是我們想的那種事務消息 RocketMQ 的才是。</p><p>講到這我就想扯一下了，說到這個Exactly Once 其實不太清楚的同學很容易會誤解。</p><p>我們知道消息可靠性有三種，分別是最多一次、恰好一次、最少一次，之前在消息隊列連環問的文章我已經提到了基本上我們都是用最少一次然後配合消費者端的冪等來實現恰好一次。</p><p>消息恰好被消費一次當然我們所有人追求的，但是之前文章我已經從各方面已經分析過了，基本上難以達到。</p><p>而 Kafka 竟說它能實現 Exactly Once？這麼牛啤嗎？這其實是 Kafka 的一個噱頭，你要說他錯，他還真沒錯，你要說他對但是他實現的 Exactly Once 不是你心中想的那個 Exactly Once。</p><p>它的恰好一次只能存在一種場景，就是從<strong>Kafka 作為消息源，然後做了一番操作之後，再寫入 Kafka 中</strong>。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9ItuJbACmaken><p>那他是如何實現恰好一次的？就是通過冪等，和我們在業務上實現的一樣通過一個唯一 Id， 然後記錄下來，如果已經記錄過了就不寫入，這樣來保證恰好一次。</p><p>所以說 <strong>Kafka 實現的是在特定場景下的恰好一次，不是我們所想的利用 Kafka 來發送消息，那麼這條消息只會恰巧被消費一次</strong>。</p><p>這其實和 Redis 說他實現事務了一樣，也不是我們心想的事務。</p><p>所以開源軟件說啥啥特性開發出來了，我們一味的相信，因此其往往都是殘血的或者在特殊的場景下才能滿足，不要被誤導了，不能相信表面上的描述，還得詳細的看看文檔或者源碼。</p><p>不過從另一個角度看也無可厚非，作為一個開源軟件肯定是想更多的人用，我也沒說謊呀，我文檔上寫的很清楚的，這標題也沒騙人吧？</p><p>確實，比如你點進震驚xxxx標題的文章，人家也沒騙你啥，他自己確實震驚的呢。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItuJw9Atr89T><p>再回來談 Kafka 的事務消息，所以說這個事務消息不是我們想要的那個事務消息，其實不是今天的主題了，不過我還是簡單的說一下。</p><p>Kafka 的事務有事務協調者角色，事務協調者其實就是 Broker 的一部分。</p><p>在開始事務的時候，生產者會向事務協調者發起請求表示事務開啟，事務協調者會將這個消息記錄到特殊的日誌-事務日誌中，然後生產者再發送真正想要發送的消息，這裡 Kafka 和 RocketMQ 處理不一樣，Kafka 會像對待正常消息一樣處理這些事務消息，<strong>由消費端來過濾這個消息</strong>。</p><p>然後發送完畢之後生產者會向事務協調者發送提交或者回滾請求，由事務協調者來進行兩階段提交，如果是提交那麼會先執行預提交，即把事務的狀態置為預提交然後寫入事務日誌，然後再向所有事務有關的分區寫入一條類似事務結束的消息，這樣消費端消費到這個消息的時候就知道事務好了，可以把消息放出來了。</p><p>最後協調者會向事務日誌中再記一條事務結束信息，至此 Kafka 事務就完成了，我拿 confluent.io 上的圖來總結一下這個流程。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9ItuKO2iywlmV><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTRIuPaahjHjS><p></p><h1 toutiao-origin=h2>最後</h1><p>至此我們已經知道了 RocketMQ 和 Kakfa 的事務消息全流程，可以看到 RocketMQ 的事務消息才是我們想要的，當然你要是用的流式計算那麼 Kakfa 的事務消息也是你想要的。</p><p>需要貼代碼的文章其實很難受，這貼的多不好，貼的少又怕不清晰，真的難，如果覺得文章不錯記得點個在看喲。</p><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R69FpRH4d90a7d><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S8GRksHDcXZIUf><pre><div><div><div><div><div><div><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpbJ0CLyq7></div></div><p><strong toutiao-origin=span>點分享</strong></p></div><div><div><div><div><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S3Y8EjO3S3jH6O></div></div></div><div><div><div><img alt="消息隊列之事務消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpwDUoK9Jv></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>隊列</a></li><li><a>之事務</a></li><li><a>RocketMQ</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0155a40.html alt=消息隊列及常見消息隊列介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c780000da0d4ae15990 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0155a40.html title=消息隊列及常見消息隊列介紹>消息隊列及常見消息隊列介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a7ee8a5.html alt=消息隊列的使用之RabbitMq的選型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15404744718207c9b0a18d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a7ee8a5.html title=消息隊列的使用之RabbitMq的選型>消息隊列的使用之RabbitMq的選型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc00e68.html alt=淺談消息隊列及常見的消息中間件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99348ece13f64ce49f498270b88717c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc00e68.html title=淺談消息隊列及常見的消息中間件>淺談消息隊列及常見的消息中間件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26710420.html alt=消息隊列MQ面試專題（rabbitmq） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/S86eRASG4qdgs4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26710420.html title=消息隊列MQ面試專題（rabbitmq）>消息隊列MQ面試專題（rabbitmq）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a97678b1.html alt=消息隊列之常見消息隊列分析彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b13ad5e5ff6b478797dcb7efcb7d6331 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a97678b1.html title=消息隊列之常見消息隊列分析彙總>消息隊列之常見消息隊列分析彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd67ae90.html alt=淺談消息隊列用途及常見的消息中間件的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6b0acb1aef6b4fe792b1fbd6a18d26f4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd67ae90.html title=淺談消息隊列用途及常見的消息中間件的區別>淺談消息隊列用途及常見的消息中間件的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/199264e1.html alt=使用環形隊列解決串口打印阻塞問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6595586e75984d5e9968f9ca0cab6a2e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/199264e1.html title=使用環形隊列解決串口打印阻塞問題>使用環形隊列解決串口打印阻塞問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac006a7.html alt=如何打造可以無限擴展的分佈式消息隊列？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/47f42465ac1542a6a73d611fa70090a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac006a7.html title=如何打造可以無限擴展的分佈式消息隊列？>如何打造可以無限擴展的分佈式消息隊列？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a5a3083.html alt=豆腐塊？軍姿？隊列指揮？管他什麼東西，警校生照樣盤他！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bf0e7b78a3344611b00df1a45eb2ce93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a5a3083.html title=豆腐塊？軍姿？隊列指揮？管他什麼東西，警校生照樣盤他！>豆腐塊？軍姿？隊列指揮？管他什麼東西，警校生照樣盤他！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/046fd15.html alt=數據結構（揹包、隊列和棧） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/203693f33a664988aa20d9ff7690e62c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/046fd15.html title=數據結構（揹包、隊列和棧）>數據結構（揹包、隊列和棧）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67a95f5.html alt=結構與算法：隊列和棧結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c05974b203134951bb9284740a76fea2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67a95f5.html title=結構與算法：隊列和棧結構>結構與算法：隊列和棧結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e592b29.html alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd9e3b969124f1297a6bc7627747e80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e592b29.html title="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看">高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e47cf0b.html alt=數據結構系列：棧？隊列？這倆貨應該這麼理解和掌握 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5800d5b5ff1543b78452dfa32317b9a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e47cf0b.html title=數據結構系列：棧？隊列？這倆貨應該這麼理解和掌握>數據結構系列：棧？隊列？這倆貨應該這麼理解和掌握</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/80b0adb.html alt="第五章 棧和隊列" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f539b17725974b3fb257d8e003e0edbc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/80b0adb.html title="第五章 棧和隊列">第五章 棧和隊列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a06cd9.html alt=面試中常考的堆、棧和隊列如何理解與應用？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0a8a1934fd404a3e9bfdbe5c49d1aa74 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a06cd9.html title=面試中常考的堆、棧和隊列如何理解與應用？>面試中常考的堆、棧和隊列如何理解與應用？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>