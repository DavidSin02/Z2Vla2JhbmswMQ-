<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>關於Spring AOP的靈魂十問 | 极客快訊</title><meta property="og:title" content="關於Spring AOP的靈魂十問 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f76928765e9444fd8b608eab1ae51b90"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0013439.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0013439.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0013439.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0013439.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0013439.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0013439.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0013439.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0013439.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="關於Spring AOP的靈魂十問"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e0013439.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>關於Spring AOP的靈魂十問</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>荒腔走板</h1><p style=text-align:start>今天沒有這個環節。。。</p><h1 class=pgc-h-arrow-right>什麼是AOP？</h1><p style=text-align:start>AOP全稱是Aspect Oriented Programming，翻譯過來是“面向切面”編程。在Java語言裡，一切皆對象，所以我們通常說Java語言是一門“面向對象”編程的語言。而面向切面編程，不是要取代面向對象編程，而是對它的一種補充。</p><p style=text-align:start>AOP要解決的問題是用一個“橫切面”的方式，來統一處理很多對象都需要的，相同或相似的功能，減少程序裡面的重複代碼，讓代碼變得更乾淨，更專注於業務。</p><div class=pgc-img><img alt="關於Spring AOP的靈魂十問" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f76928765e9444fd8b608eab1ae51b90><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>AOP能做什麼？</h1><p style=text-align:start>AOP適合用來做一些<strong>比較通用的、與業務關係不大的</strong>事情。比較常見的就是調用日誌、權限控制、調用時間和性能統計、參數校驗等等。</p><p style=text-align:start>其實Spring基於AOP做了很多有用的東西，比如大家可能會經常使用的事務、緩存、重試、Validation等等，底層都是使用的AOP。</p><p style=text-align:start>自己用AOP實現一些小功能的需求也比較多。比如之前我們團隊就有這樣一個需求，我們在服務與服務之間的調用，不使用枚舉，而是換成了使用字符串，即枚舉相應字段的name。但是這樣就帶來了一個問題，如果調用方輸入了一個不屬於這個枚舉的字符串，那到後面使用就會拋異常。所以我們希望能夠在Controller層就把這個校驗做了，該拋異常拋異常。</p><p style=text-align:start>這是一個參數校驗的需求，然而Spring提供的Validation和自定義Validation都無法實現這個需求，因為字段是字符串，但每次需要校驗的枚舉類型是不同的。所以我們就基於註解和AOP自己開發了這樣一個枚舉參數校驗器。</p><h1 class=pgc-h-arrow-right>Spring AOP和AspectJ是什麼關係？</h1><p style=text-align:start>其實AOP並不是Spring的專屬，AOP最開始是一種編程模型，後來大佬們為了探討AOP的標準化，統一AOP規範，成立了一個AOP聯盟。除了Spring外，AOP的框架有很多，比如AspectJ, AspectWerkz, JBoss-AOP。</p><p style=text-align:start>最開始，Spring AOP和AspectJ是完全獨立的，Spring有自己的實現和使用語法。但是Spring的AOP使用起來太麻煩了，深受大家吐槽。於是Spring支持了廣受大家好評的AspectJ語法，通過在配置類上添加@EnableAspectJAutoProxy這個註解來開啟對AspectJ的語法。</p><p style=text-align:start>但Spring<strong>僅僅是支持了AspectJ的部分語法（有些語法是不支持的），但底層實現還是自己的一套東西</strong>。而且兩個框架的目標不同，AspectJ是一套完整的AOP解決方案，更為健壯，但使用起來比較複雜，還需要使用特殊的語法和編譯器。而Spring的目的是想要把AOP和IoC框架結合起來，讓Spring管理的Bean能夠很方便地使用AOP的功能。</p><p style=text-align:start>所以Spring AOP和AspectJ沒啥關係，只是Spring借鑑了Aspect的聲明語法。</p><blockquote><p>這裡說清楚了AOP、Spring AOP、AspectJ的關係，那下文中我就用AOP代替Spring AOP了，畢竟這是一個比較懶的作者。</p></blockquote><h1 class=pgc-h-arrow-right>如何使用Spring AOP？</h1><p style=text-align:start>學一門技術，首先要學會怎麼用，然後再學會原理，最後深入思考，舉一反三。而<strong>學習怎麼用，最好的途徑，就是看官方文檔</strong>。</p><blockquote><p>有些同學可能會覺得英文的看起不太方便，所以會去看一些中文的文章或者書。但這些中文的文章或書其實就是把官方文檔翻譯了一遍，還有可能不全甚至是錯誤的。所以還是推薦直接看官方文檔，哪怕是用自動翻譯軟件，也能看懂了。何況英語也算是程序員的必修技能之一。</p></blockquote><div class=pgc-img><img alt="關於Spring AOP的靈魂十問" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a0c76f218b5648bca181c4bea16df1c2><p class=pgc-img-caption></p></div><p style=text-align:start>AOP有一些專業的概念和術語。切面、連接點、通知、切點、引入、目標對象、代理對象、織入等。很多都是直接根據英文單詞翻譯過來的，這裡我們就不詳細介紹這些概念了，Spring官方文檔AOP那一章節開頭就有詳細的介紹。但是這篇文章會從使用的視角來順帶介紹其中的一些術語。</p><h1 class=pgc-h-arrow-right>打開AspectJ支持</h1><p style=text-align:start>本文就不介紹XML的配置了，實在是太古老了。。。</p><p style=text-align:start>使用@EnableAspectJAutoProxy這個註解可以打開AspectJ支持，以後就可以愉快地在Spring中使用AspectJ語法了。需要注意的是，<strong>如果你使用的是SpringBoot，這個註解已經默認加上了</strong>，不需要再手動寫在你的代碼裡。</p><h1 class=pgc-h-arrow-right>聲明一個切面</h1><p style=text-align:start>使用@Aspect註解可以聲明一個切面。其實就是一個類，在這個類裡面去定義切點、通知等東西。</p><h1 class=pgc-h-arrow-right>聲明一個切點</h1><p style=text-align:start>所謂“切點”，就是你要去切什麼地方。Spring只支持去切<strong>被Spring管理的Bean的方法</strong>。聲明一個切點也很簡單，在我們上面聲明的切面類裡面，用下面這種形式創建一個方法就行了：</p><pre><code>@Pointcut("execution(* transfer(..))")private void anyOldTransfer() {}</code></pre><p style=text-align:start>使用@Pointcut註解，裡面是切點的表達式。需要注意這個方法的返回值必須是void的。關於表達式，有一些Spring支持的關鍵字，這裡就不一一細講了，官方文檔上Supported Pointcut Designators這一節有詳細介紹。我們最常用的應該是execution和@annotation這兩個了。</p><p style=text-align:start>其中也有一些通配符，包括*, ., (), (..), (*), (*, string)等等，都是有不同的含義和作用。具體可以在官方文檔Examples這一節瞭解。</p><h1 class=pgc-h-arrow-right>聲明通知</h1><p style=text-align:start>“通知”，指的是在什麼時候去執行我們定義的AOP邏輯。Spring提供了這樣幾種通知：</p><ul><li>@Before</li><li>@AfterReturning</li><li>@AfterThrowing</li><li>@After，其實質是AfterFinally</li><li>@Around</li></ul><p style=text-align:start>大家看名字應該都知道是啥意思了吧。其中，@Around包含上面所有的功能，使用起來更強大、靈活。</p><p style=text-align:start>一個完整的AOP定義大概長這樣：</p><pre><code>@Aspect@Componentpublic class MyAspect {    @Pointcut("within(com.example.springbase.dao..*)")    private void myPointcut() {}​​    @Before("myPointcut()")    public void before() {        System.out.println("before...");    }}</code></pre><p style=text-align:start>需要注意的是<strong>這裡的@Component註解是必須要加的，不然Spring不會自動掃描這個類</strong>，那你定義的切面、切點和通知也就無效了。</p><p style=text-align:start>一個切面裡面可以有多個切點和多個通知，並且一個切點也可以被多個通知使用。</p><h1 class=pgc-h-arrow-right>Spring用什麼實現的AOP？</h1><p style=text-align:start>前面我們提到過AspectJ，AspectJ使用的是編譯期和類加載時進行織入，而Spring AOP利用的是<strong>運行時織入</strong>。而如果使用運行時織入，就要用到“動態代理”的技術。</p><p style=text-align:start>先來聊聊動態代理。AOP其實是設計模式中的“代理模式”的一種應用，那什麼是代理模式呢？我們舉個很常見的例子，就是遊戲代練了。</p><p style=text-align:start>遊戲代練高手收了土豪的錢，登上土豪的賬號，一路連勝打上最強王者，然後完成交易，功成身退。而遊戲中的隊友和對手，甚至遊戲官方並不知道這是一個代練，還以為是土豪本人，私下裡紛紛誇讚土豪技術了得，滿足了土豪的虛榮心。。。</p><p style=text-align:start>代理模式說簡單點，就是通過<strong>把原本的對象進行包裝，提供一些額外的能力</strong>，但是<strong>對外部而言是無感知的</strong>，並不知道或者並不在意這個對象是不是被代理了。</p><p style=text-align:start>靜態代理和動態代理的區別在於，靜態代理把要代理的類型已經寫死了，一個代理只能代理一種類型。而動態代理就不一樣了，一個代理可以代理多種類型。還是拿遊戲代練舉例，靜態代理可能就是這個代練只能代練LOL這一種遊戲。而動態代理，這個代練可以代練所有遊戲，是不是一聽就是大高玩。</p><p style=text-align:start>Spring底層使用了兩種方式來實現動態代理，一種是Java自帶的動態代理，另一種是CGLib。如果是使用JDK動態代理生成的代理對象，Debug可以看到JdkDynamicAopProxy，而如果是CGLib生成的對象，可以看到是EnhancerBySpringCGLIB。</p><p style=text-align:start>那Spring具體是使用的哪種方式呢？網上有很多文章說，Spring默認產生代理對象的行為是：如果你的Bean有對應的接口，是使用的基於JDK的動態代理，否則是使用CGLIB。但這樣說其實不準確，Spring用了下面這個配置來控制它，如果這個配置是false，才是上面我們說的這個邏輯。而如果這個配置是true，則所有的要使用AOP的Bean都使用CGLIB代理，不管它是不是有接口。而我們使用最新版的SpringBoot的話，這個值默認就是true。</p><pre><code>spring.aop.proxy-target-class=true</code></pre><p style=text-align:start>所以現在<strong>如果使用SpringBoot的話，我們的AOP代理對象都是用CGLIB生成的</strong>。</p><h1 class=pgc-h-arrow-right>JDK和CGLib動態代理有什麼區別？</h1><p style=text-align:start>兩者實現的原理不同，JDK動態代理是基於Java反射來實現的，而CGLIB動態代理是基於修改字節碼，生成子類來實現的，底層是使用的asm開源庫。</p><p style=text-align:start>兩者都有一些限制，JDK動態代理，Bean必須要有接口；CGLIB不能對final類或方法做代理。</p><h1 class=pgc-h-arrow-right>哪些方法可以被代理？</h1><p style=text-align:start>如果是使用JDK動態代理，那只有public方法可以被代理。而如果使用CGLIB，除了private方法，都可以被代理。（當然，final方法除外）。</p><p style=text-align:start>另一個比較有意思的問題是，<strong>如果兩個方法在同一個類裡面，一個方法調用另一個方法是不會走代理的</strong>。只有一個Bean調用另一個Bean的方法，才會走代理。</p><p style=text-align:start>上面兩個特性也就解釋了為什麼有時候你的@Transactional不生效的原因：</p><ul><li>在私有方法上不生效</li><li>在final方法上不生效</li><li>同一個類裡面方法互相調用不生效</li></ul><h1 class=pgc-h-arrow-right>代理對象是什麼時候生成的？</h1><p style=text-align:start>在上一篇文章中，我們瞭解了Spring的Bean是如何生成的。在Spring啟動的時候，會去調用getBean方法，完成Bean的初始化工作。而在getBan裡面，初始化Bean後，會去調用Bean的BeanPostProcessor。這個代碼可以通過getBean方法Debug找進去。這裡就不細講Debug過程了，放一張調用棧的截圖吧。</p><div class=pgc-img><img alt="關於Spring AOP的靈魂十問" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/29f5ed1d48e64673909f8f27bf5f8bc4><p class=pgc-img-caption></p></div><p style=text-align:start>從Debug可以看到，其中有一個BeanPostProcessor是AnnotationAwareAspectJAutoProxyCreator類型的，繼續Debug進去可以看到最終是用了CglibAopProxy類的getProxy()方法生成的代理對象。</p><div class=pgc-img><img alt="關於Spring AOP的靈魂十問" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/769c1b77605b404da7339f151b15e2db><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>同一個方法被多次代理怎麼辦？</h1><p style=text-align:start>一個方法是有可能被多次代理的。Spring AOP不僅僅是基於代理模式，還使用了“攔截器”模式。這個攔截器，有點像Web的攔截器一樣，在目標對象上包了一層又一層，形成一個攔截器鏈。那它們的順序是如何決定的呢？</p><p style=text-align:start>我們在前面的源碼解析中，有一個分支，邏輯是去除當前這個代理對象的所有“通知”，然後排序。代碼在AspectJAwareAdvisorAutoProxyCreator類的方法裡。調用棧：</p><div class=pgc-img><img alt="關於Spring AOP的靈魂十問" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75c1875dbb8145098224ddba37027541><p class=pgc-img-caption></p></div><p style=text-align:start>這個方法內部先取出所有的通知，然後給它們都加上一個AspectJPrecedenceComparator。這個Comparator會取出通知所在的Bean的@Order註解定義的優先級，按照這個優先級來排序。其實我們有時候使用其它Bean也會用到這個註解。</p><p style=text-align:start>所以如果你會對一個方法聲明多個通知，那可以使用@Order註解來定義這多個通知的優先級。@Order定義的值越小，其內部定義的通知對應的攔截器就會在調用鏈的越外層。</p><blockquote><p>注意，如果是同一個切面類裡面定義的多個通知，會按照方法聲明的先後順序來排序。</p></blockquote><h1 class=pgc-h-arrow-right>AOP和循環依賴的那些事？</h1><p style=text-align:start>大家可能會遇到過或者聽說過Spring的循環依賴的問題。Spring使用了“三級緩存”來解決Bean的循環依賴，但可能很多人不知道為什麼要使用三級緩存，其實這個也跟AOP有關。</p><p style=text-align:start>如果沒有AOP，其實Spring使用二級緩存就可以解決循環依賴的問題。若使用二級緩存，在AOP情形下，注入到其他Bean的，不是最終的代理對象，而是原始目標對象。</p><p style=text-align:start>因為Spring對Bean有一個生命週期的定義，而代理對象是在Bean初始化完成後，執行後置處理器的時候生成的。所以不能在二級緩存的時候就直接生成代理對象，放進緩存。</p><h1 class=pgc-h-arrow-right>使用AOP有什麼弊端？</h1><p style=text-align:start>AOP不是萬能的，使用AOP也是有一些弊端的。個人覺得對大的弊端就是<strong>讓代碼可讀性變差</strong>了，因為它並不是一個顯式的調用，所以很有可能未來接手代碼的人並不清楚這個方法被AOP代理了。</p><p style=text-align:start>筆者之前遇到過一個項目，就是使用了AOP來做權限控制，但這個權限控制不是那種簡單的Access，而是要去查數據庫裡面的一些字段，比如狀態之類的，還有複雜的邏輯判斷。這種情況下，如果使用AOP來做，代碼的可讀性就不強，出了問題比較難以排查。</p><h1 class=pgc-h-arrow-right>關於作者</h1><p style=text-align:start>我是Yasin，一個有顏有料又有趣的程序員。</p><p style=text-align:start>微信公眾號：編了個程</p><p style=text-align:start>個人網站：https://yasinshaw.com</p><p style=text-align:start>關注我的公眾號，和我一起成長~</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>關於</a></li><li><a>Spring</a></li><li><a>AOP</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html alt="Spring AOP簡介與底層實現機制——動態代理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/413780d1-cf47-4038-9471-b686d97aa99b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html title="Spring AOP簡介與底層實現機制——動態代理">Spring AOP簡介與底層實現機制——動態代理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html alt=Spring框架AOP技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/760bf32faca443cb8e28ed0b9bc20205 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html title=Spring框架AOP技術>Spring框架AOP技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面編程AOP的初步瞭解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面編程AOP的初步瞭解>Spring面向切面編程AOP的初步瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html alt=小實例理解Spring中的AOP----面向切面編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35942664cec244f88d6a0f7b1e7067cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html title=小實例理解Spring中的AOP----面向切面編程>小實例理解Spring中的AOP----面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面編程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面編程需要知道的事">Spring AOP 面向切面編程需要知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html alt="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html title="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現">Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html alt=Spring—面向切面編程（AOP）詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html title=Spring—面向切面編程（AOP）詳解>Spring—面向切面編程（AOP）詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html alt="Spring學習（4）：Spring AOP" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/be8a179a4a8040648c1fb5a0532cc84b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html title="Spring學習（4）：Spring AOP">Spring學習（4）：Spring AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html alt="Spring：AOP 面向切面編程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html title="Spring：AOP 面向切面編程">Spring：AOP 面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用註解方式配置Spring中的面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用註解方式配置Spring中的面向切面編程AOP>使用註解方式配置Spring中的面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ef7083e.html alt="溫故知新——Spring AOP（一）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ef7083e.html title="溫故知新——Spring AOP（一）">溫故知新——Spring AOP（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/430ad617.html alt=理解Spring：AOP的原理及手動實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8435d8c955b34ce68d6e3765409ff14f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/430ad617.html title=理解Spring：AOP的原理及手動實現>理解Spring：AOP的原理及手動實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>