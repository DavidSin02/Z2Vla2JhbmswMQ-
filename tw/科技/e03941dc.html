<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據結構一(哈希表)想進大廠的必備知識點 | 极客快訊</title><meta property="og:title" content="數據結構一(哈希表)想進大廠的必備知識點 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e03941dc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e03941dc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e03941dc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e03941dc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e03941dc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e03941dc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e03941dc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e03941dc.html><meta property="article:published_time" content="2020-11-14T21:07:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:42+08:00"><meta name=Keywords content><meta name=description content="數據結構一(哈希表)想進大廠的必備知識點"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e03941dc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據結構一(哈希表)想進大廠的必備知識點</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>數據結構對於編程人員是非常重要的,想要提高自己的編程水平,或者是技術職稱,都要好好的學習數據結構.那麼今天講的哈希表就是一種非常重要的數據結構,大多數學習編程的人員都搞不懂數據結構或者是其中的哈希表結構.</p><p>下面,就通過一個實現的小例子來講解說明哈希表背後的優勢和特點.便於理解.</p><h1 class=pgc-h-arrow-right>一. 認識哈希表</h1><blockquote class=default><p>我們還像其他數據結構一樣, 先來簡單的認識一下哈希表.</p></blockquote><h1 class=pgc-h-arrow-right>哈希表介紹</h1><ul><li>哈希表是一種非常重要的數據結構, 幾乎所有的編程語言都有直接或者間接的應用這種數據結構.</li><li>哈希表通常是基於數組進行實現的, 但是相對於數組, 它也很多的優勢:它可以提供非常快速的插入-刪除-查找操作無論多少數據, 插入和刪除值需要接近常量的時間: 即O(1)的時間級. 實際上, 只需要幾個機器指令即可哈希表的速度比樹還要快, 基本可以瞬間查找到想要的元素哈希表相對於樹來說編碼要容易很多.</li><li>哈希表相對於數組的一些不足:哈希表中的數據是沒有順序的, 所以不能以一種固定的方式(比如從小到大)來遍歷其中的元素.通常情況下, 哈希表中的key是不允許重複的, 不能放置相同的key, 用於保存不同的元素.</li><li>那麼, 哈希表到底是什麼呢?似乎還是沒有說它到底是什麼.這也是哈希表不好理解的地方, 不像數組和鏈表, 甚至是樹一樣直接畫出你就知道它的結構, 甚至是原理了.它的結構就是數組, 但是它神奇的地方在於對下標值的一種變換, 這種變換我們可以稱之為哈希函數, 通過哈希函數可以獲取到HashCode.不著急, 我們慢慢來認識它到底是什麼.</li></ul><h1 class=pgc-h-arrow-right>體會哈希表</h1><ul><li>案例一: 公司使用一種數據結構來保存所有員工案例介紹:假如一家公司有1000個員工, 現在我們需要將這些員工的信息使用某種數據結構來保存起來你會採用什麼數據結構呢?方案一: 數組一種方案是按照順序將所有的員工依次存入一個長度為1000的數組中. 每個員工的信息都保存在數組的某個位置上.但是我們要查看某個具體員工的信息怎麼辦呢? 一個個找嗎? 不太好找.數組最大的優勢是什麼? 通過下標值去獲取信息.所以為了可以通過數組快速定位到某個員工, 最好給員工信息中添加一個員工編號, 而編號對應的就是員工的下標值.當查找某個員工的信息時, 通過員工編號可以快速定位到員工的信息位置.方案二: 鏈表鏈表對應插入和刪除數據有一定的優勢.但是對於獲取員工的信息, 每次都必須從頭遍歷到尾, 這種方式顯然不是特別適合我們這裡.最終方案:這樣看最終方案似乎就是數組了. 但是數組還是有缺點, 什麼缺點呢?假如我想查看一下張三這位員工的信息, 但是我不知道張三的員工編號, 你怎麼辦呢?當然, 你說我可以問他. 但是你每查找一個員工都是問一下這個員工的編號嗎? 不合適.能不能有一種辦法, 讓張三的名字和它的員工編號產生直接的關係呢?也就是通過張三這個名字, 我就能獲取到它的索引值, 而再通過索引值我就能獲取到張三的信息呢?這樣的方案已經存在了, 就是使用哈希函數, 讓某個key的信息和索引值對應起來.</li><li>案例二: 設計一個數據結構, 保存聯繫人和電話.方案一: 數組?使用數組來存儲聯繫人和電話不是非常合適.因為如果需要查詢某個聯繫人, 就需要從數組中一個個取出數據和查詢的聯繫人比較. 效率非常的低.方案二: 鏈表?鏈表和數組一樣, 效率非常低.方案三: 有沒有一種方案, 可以將聯繫人和數組的下標值對應呢?那麼我們就可以讓聯繫人的名字作為下標值, 來獲取這個聯繫人對應的電話.但是聯繫人的名字(字符串)可以作為下標值嗎? 當然不可以.所以你需要一種方案將字符串轉成下標值.</li><li>案例三: 使用一種數據結構存儲單詞信息, 比如有50000個單詞. 找到單詞後每個單詞有自己的翻譯&讀音&應用等等方案一: 數組?這個案例更加明顯能感受到數組的缺陷.我拿到一個單詞Python, 我想知道這個單詞的翻譯/讀音/應用. 怎麼可以從數組中查到這個單詞的位置呢?線性查找? 50000次比較?如果你使用數組來實現這個功能, 效率會非常非常低, 而且你一定沒有學習過數據結構.方案二: 鏈表?不需要考慮了吧?方案三: 有沒有一種方案, 可以將單詞轉成數組的下標值呢?如果單詞轉成數組的下標, 那麼以後我們要查找某個單詞的信息, 直接按照下標值一步即可訪問到想要的元素.</li><li>案例三: 高級語言的編譯器事實上哈希表還有另外一個非常重要的應用場景, 就是高級語言的編譯器.它通常用哈希表來保留符號表.符號表記錄了程序員聲明的所有變量和函數名, 以及它們在內存中的地址.程序需要快速的訪問這些名字, 所以哈希表是理想的實現方式.</li></ul><h1 class=pgc-h-arrow-right>字母轉數字</h1><ul><li>但是, 怎樣才能將一個轉成數組的下標值呢?單詞轉下標值, 其實就是字母轉數字, 怎麼轉?</li><li>現在我們需要設計一種方案, 可以將單詞轉成適當的下標:其實計算機中有很多的編碼方案就是用數字代替單詞的字符.比如ASCII編碼: a是97, b是98, 依次類推122代表z我們也可以設計一個自己的編碼系統, 比如a是1, b是2, c是3, 依次類推, z是26. 當然我們可以加上空格用0代替, 就是27個字符(不考慮大寫問題)但是, 有了編碼系統後, 一個單詞如何轉成數字呢?</li><li>方案一: 數字相加一個轉換單詞的簡單方案就是把單詞每個字符的編碼求和.例如單詞cats轉成數字: 3+1+20+19=43, 那麼43就作為cats單詞的下標存在數組中.問題: 按照這種方案有一個很明顯的問題就是很多單詞最終的下標可能都是43.比如was/tin/give/tend/moan/tick等等.我們知道數組中一個下標值位置只能存儲一個數據, 如果存入後來的數據, 必然會造成數據的覆蓋.一個下標存儲這麼多單詞顯然是不合理的.</li><li>方案二: 冪的連乘現在, 我們想通過一種算法, 讓cats轉成數字後不那麼普通. 數字相加的方案就有些過於普通了.有一種方案就是使用冪的連乘, 什麼是冪的連乘呢?其實我們平時使用的大於10的數字, 可以用一種冪的連乘來表示它的唯一性:比如: 7654 = 7*10³+6*10²+5*10+4我們的單詞也可以使用這種方案來表示: 比如cats = 3*27³+1*27²+20*27+17= 60337這樣得到的數字可以幾乎保證它的唯一性, 不會和別的單詞重複.問題: 如果一個單詞是zzzzzzzzzz(一般英文單詞不會超過10個字符). 那麼得到的數字超過7000000000000. 數組可以表示這麼大的下標值嗎?而且就算能創建這麼大的數組, 事實上有很多是無效的單詞. 創建這麼大的數組是沒有意義的.</li></ul><p><br></p><div class=pgc-img><img alt=數據結構一(哈希表)想進大廠的必備知識點 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a><p class=pgc-img-caption></p></div><p><br></p><ul><li>兩種方案總結:第一種方案(把數字相加求和)產生的數組下標太少.第二種方案(與27的冪相乘求和)產生的數組下標又太多.</li></ul><h1 class=pgc-h-arrow-right>認識哈希化</h1><ul><li>現在需要一種壓縮方法, 把冪的連乘方案系統中得到的巨大整數範圍壓縮到可接受的數組範圍中.</li><li>對於英文詞典, 多大的數組才合適呢?如果只有50000個單詞, 可能會定義一個長度為50000的數組.但是實際情況中, 往往需要更大的空間來存儲這些單詞. 因為我們不能保存單詞會映射到每一個位置. (比如兩倍的大小: 100000).</li><li>如何壓縮呢?現在, 就找一種方法, 把0到超過7000000000000的範圍, 壓縮為從0到100000.有一種簡單的方法就是使用取餘操作符, 它的作用是得到一個數被另外一個數整除後的餘數..</li><li>取餘操作的實現:為了看到這個方法如何工作, 我們先來看一個小點的數字範圍壓縮到一個小點的空間中.假設把從0~199的數字, 比如使用largeNumber代表, 壓縮為從0到9的數字, 比如使用smallRange代表.下標值的結果: index = largeNumber % smallRange;當一個數被10整除時, 餘數一定在0~9之間;比如13%10=3, 157%10=7.當然, 這中間還是會有重複, 不過重複的數量明顯變小了. 因為我們的數組是100000, 而只有50000個單詞.就好比, 你在0~199中間選取5個數字, 放在這個長度為10的數組中, 也會重複, 但是重複的概率非常小. (後面我們會講到真的發生重複了應該怎麼解決)</li><li>認識情況了上面的內容, 相信你應該懂了哈希標的原理了, 我們來看看幾個概念:哈希化: 將大數字轉化成數組範圍內下標的過程, 我們就稱之為哈希化.哈希函數: 通常我們會將單詞轉成大數字, 大數字在進行哈希化的代碼實現放在一個函數中, 這個函數我們成為哈希函數.哈希表: 最終將數據插入到的這個數組, 我們就稱之為是一個哈希表</li></ul><h1 class=pgc-h-arrow-right>二. 地址的衝突</h1><blockquote class=default><p>儘管50000個單詞, 我們使用了100000個位置來存儲, 並且通過一種相對比較好的哈希函數來完成.</p><p>但是依然有可能會發生衝突, 比如melioration這個單詞, 通過哈希函數得到它數組的下標值後, 發現那個位置上已經存在一個單詞demystify, 因為它經過哈希化後和melioration得到的下標實現相同的.</p><p>這種情況我們成為衝突.</p></blockquote><h1 class=pgc-h-arrow-right>什麼是衝突?</h1><ul><li>前面前言部分我們已經簡單說明了, 什麼是衝突. 雖然我們不希望這種情況發生, 當然更希望每個下標對應一個數據項, 但是通常這是不可能的.</li></ul><p><br></p><div class=pgc-img><img alt=數據結構一(哈希表)想進大廠的必備知識點 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eeb929cde83d43c3ac46e8e9bea7c519><p class=pgc-img-caption></p></div><p><br></p><ul><li>就像之前0~199的數字選取5個放在長度為10的單元格中如果我們隨機選出來的是33, 82, 11, 45, 90, 那麼最終它們的位置會是3-2-1-5-0, 沒有發生衝突.但是如果其中有一個33, 還有一個73呢? 還是發生了衝突.</li><li>我們需要針對這種衝突提出一些解決方案, 即使衝突的可能性比較小, 你依然需要考慮到這種情況, 以便發生的時候進行對應的處理代碼.</li><li>如何解決這種衝突呢? 常見的情況有兩種方案.鏈地址法.開放地址法.</li></ul><h1 class=pgc-h-arrow-right>鏈地址法</h1><ul><li>鏈地址法是一種比較常見的解決衝突的方案.(也稱為拉鍊法)其實, 如果你理解了為什麼產生衝突, 看到圖後就可以立馬理解鏈地址法是什麼含義了.</li></ul><p><br></p><div class=pgc-img><img alt=數據結構一(哈希表)想進大廠的必備知識點 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a913b2e202ed4fccac466bbd4bb76e22><p class=pgc-img-caption></p></div><p><br></p><ul><li>圖片解析:從圖片中我們可以看出, 鏈地址法解決衝突的辦法是每個數組單元中存儲的不再是單個數據, 而是一個鏈條.這個鏈條使用什麼數據結構呢? 常見的是數組或者鏈表.比如是鏈表, 也就是每個數組單元中存儲著一個鏈表. 一旦發現重複, 將重複的元素插入到鏈表的首端或者末端即可.當查詢時, 先根據哈希化後的下標值找到對應的位置, 再取出鏈表, 依次查詢找尋找的數據.</li><li>數組還是鏈表呢?數組或者鏈表在這裡其實都可以, 效率上也差不多.因為根據哈希化的index找出這個數組或者鏈表時, 通常就會使用線性查找, 這個時候數組和鏈表的效率是差不多的.當然在某些實現中, 會將新插入的數據放在數組或者鏈表的最前面, 因為覺得心插入的數據用於取出的可能性更大.這種情況最好採用鏈表, 因為數組在首位插入數據是需要所有其他項後移的, 鏈表就沒有這樣的問題.當然, 我覺得出於這個也看業務需求, 不見得新的數據就訪問次數會更多: 比如我們微信新添加的好友, 可能是剛認識的, 聯繫的頻率不見得比我們的老朋友更多, 甚至新加的只是聊一兩句.所以, 這裡個人覺得選擇數據或者鏈表都是可以的.</li></ul><h1 class=pgc-h-arrow-right>開放地址法</h1><ul><li>開放地址法的主要工作方式是尋找空白的單元格來添加重複的數據.</li><li>我們還是通過圖片來了解開放地址法的工作方式.</li></ul><p><br></p><div class=pgc-img><img alt=數據結構一(哈希表)想進大廠的必備知識點 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/44753e667269497e915f00473380064f><p class=pgc-img-caption></p></div><p><br></p><ul><li>圖片解析:從圖片的文字中我們可以瞭解到, 開放地址法其實就是要尋找空白的位置來放置衝突的數據項.但是探索這個位置的方式不同, 有三種方法:線性探測二次探測再哈希法</li></ul><h1 class=pgc-h-arrow-right>線性探測</h1><ul><li>線性探測非常好理解: 線性的查找空白的單元.</li><li>插入的32:經過哈希化得到的index=2, 但是在插入的時候, 發現該位置已經有了82. 怎麼辦呢?線性探測就是從index位置+1開始一點點查找合適的位置來放置32, 什麼是合適的位置呢?空的位置就是合適的位置, 在我們上面的例子中就是index=3的位置, 這個時候32就會放在該位置.</li><li>查詢32呢?查詢32和插入32比較相似.首先經過哈希化得到index=2, 比如2的位置結果和查詢的數值是否相同, 相同那麼就直接返回.不相同呢? 線性查找, 從index位置+1開始查找和32一樣的.這裡有一個特別需要注意的地方: 如果32的位置我們之前沒有插入, 是否將整個哈希表查詢一遍來確定32存不存在嗎?當然不是, 查詢過程有一個約定, 就是查詢到空位置, 就停止. (因為查詢到這裡有空位置, 32之前不可能跳過空位置去其他的位置.)</li><li>刪除32呢?刪除操作和插入查詢比較類似, 但是也有一個特別注意點.注意: 刪除操作一個數據項時, 不可以將這個位置下標的內容設置為null, 為什麼呢?因為將它設置為null可能會影響我們之後查詢其他操作, 所以通常刪除一個位置的數據項時, 我們可以將它進行特殊處理(比如設置為-1).當我們之後看到-1位置的數據項時, 就知道查詢時要繼續查詢, 但是插入時這個位置可以放置數據.</li><li>線性探測的問題:線性探測有一個比較嚴重的問題, 就是聚集. 什麼是聚集呢?比如我在沒有任何數據的時候, 插入的是22-23-24-25-26, 那麼意味著下標值:2-3-4-5-6的位置都有元素. 這種一連串填充單元就叫做聚集.聚集會影響哈希表的性能, 無論是插入/查詢/刪除都會影響.比如我們插入一個32, 會發現連續的單元都不允許我們放置數據, 並且在這個過程中我們需要探索多次.二次探測可以解決一部分這個問題, 我們一起來看一看.</li></ul><h1 class=pgc-h-arrow-right>二次探測</h1><ul><li>我們剛才談到, 線性探測存在的問題: 就是如果之前的數據時連續插入的, 那麼新插入的一個數據可能需要探測很長的距離.</li><li>二次探測在線性探測的基礎上進行了優化:二次探測主要優化的是探測時的步長, 什麼意思呢?線性探測, 我們可以看成是步長為1的探測, 比如從下標值x開始, 那麼線性測試就是x+1, x+2, x+3依次探測.二次探測, 對步長做了優化, 比如從下標值x開始, x+1², x+2², x+3².這樣就可以一次性探測比較常的距離, 比避免那些聚集帶來的影響.</li><li>二次探測的問題:但是二次探測依然存在問題, 比如我們連續插入的是32-112-82-2-192, 那麼它們依次累加的時候步長的相同的.也就是這種情況下會造成步長不一的一種聚集. 還是會影響效率.怎麼根本解決這個問題呢? 讓每個人的步長不一樣, 一起來看看再哈希法吧.</li></ul><h1 class=pgc-h-arrow-right>再哈希法</h1><ul><li>為了消除線性探測和二次探測中無論步長+1還是步長+平法中存在的問題, 還有一種最常用的解決方案: 再哈希法.</li><li>再哈希法:二次探測的算法產生的探測序列步長是固定的: 1, 4, 9, 16, 依次類推.現在需要一種方法: 產生一種依賴關鍵字的探測序列, 而不是每個關鍵字都一樣.那麼, 不同的關鍵字即使映射到相同的數組下標, 也可以使用不同的探測序列.再哈希法的做法就是: 把關鍵字用另外一個哈希函數, 再做一次哈希化, 用這次哈希化的結果作為步長.對於指定的關鍵字, 步長在整個探測中是不變的, 不過不同的關鍵字使用不同的步長.</li><li>第二次哈希化需要具備如下特點:和第一個哈希函數不同. (不要再使用上一次的哈希函數了, 不然結果還是原來的位置)不能輸出為0(否則, 將沒有步長. 每次探測都是原地踏步, 算法就進入了死循環)</li><li>其實, 我們不用費腦細胞來設計了, 計算機專家已經設計出一種工作很好的哈希函數:stepSize = constant - (key - constant)其中constant是質數, 且小於數組的容量.例如: stepSize = 5 - (key % 5), 滿足需求, 並且結果不可能為0.</li></ul><h1 class=pgc-h-arrow-right>三. 哈希化的效率</h1><blockquote class=default><p>哈希表中執行插入和搜索操作可以達到O(1)的時間級，如果沒有發生衝突，只需要使用一次哈希函數和數組的引用，就可以插入一個新數據項或找到一個已經存在的數據項。</p><p>如果發生衝突，存取時間就依賴後來的探測長度。一個單獨的查找或插入時間與探測的長度成正比，這裡還要加上哈希函數的常量時間。</p><p>平均探測長度以及平均存取時間，取決於填裝因子，隨著填裝因子變大，探測長度也越來越長。</p><p>隨著填裝因子變大，效率下降的情況，在不同開放地址法方案中比鏈地址法更嚴重, 所以我們來對比一下他們的效率, 再決定我們選取的方案.</p></blockquote><h1 class=pgc-h-arrow-right>裝填因子</h1><ul><li>在分析效率之前, 我們先了解一個概念: 裝填因子.</li><li>裝填因子表示當前哈希表中已經包含的數據項和整個哈希表長度的比值.裝填因子 = 總數據項 / 哈希表長度.</li><li>開放地址法的裝填因子最大是多少呢? 1, 因為它必須尋找到空白的單元才能將元素放入.</li><li>鏈地址法的裝填因子呢? 可以大於1, 因為拉鍊法可以無限的延伸下去, 只要你願意. (當然後面效率就變低了)</li></ul><h1 class=pgc-h-arrow-right>開放地址法</h1><ul><li>我們來一個個認識一下開放地址法中每種方案的效率.</li></ul><h1 class=pgc-h-arrow-right>線性探測</h1><ul><li>下面的等式顯示了線性探測時，探測序列(P)和填裝因子(L)的關係對成功的查找: P = (1+1/(1-L))/2對不成功的查找: P=(1+1/(1-L)^2)/2</li><li>公式來自於Knuth(算法分析領域的專家, 現代計算機的先驅人物), 這些公式的推導自己去看了一下, 確實有些繁瑣, 這裡不再給出推導過程, 僅僅說明它的效率.</li><li>圖解算法的效率:</li></ul><p><br></p><div class=pgc-img><img alt=數據結構一(哈希表)想進大廠的必備知識點 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/de219174a3d54947a8803b72ea20d58a><p class=pgc-img-caption></p></div><p><br></p><ul><li>圖片解析:當填裝因子是1/2時，成功的搜索需要1.5次比較，不成功的搜索需要2.5次當填裝因子為2/3時，分別需要2.0次和5.0次比較如果填裝因子更大，比較次數會非常大。應該使填裝因子保持在2/3以下，最好在1/2以下，另一方面，填裝因子越低，對於給定數量的數據項，就需要越多的空間。實際情況中，最好的填裝因子取決於存儲效率和速度之間的平衡，隨著填裝因子變小，存儲效率下降，而速度上升。</li></ul><h1 class=pgc-h-arrow-right>二次探測和再哈希</h1><ul><li>二次探測和再哈希法的性能相當。它們的性能比線性探測略好。對成功的搜索，公式是: -log2(1 - loadFactor) / loadFactor對於不成功的搜搜, 公式是: 1 / (1-loadFactor)</li><li>對應的圖:</li></ul><p><br></p><div class=pgc-img><img alt=數據結構一(哈希表)想進大廠的必備知識點 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5504a5cd16ff4e6c81625bc6b88d1a6c><p class=pgc-img-caption></p></div><p><br></p><ul><li>圖片解析:當填裝因子是0.5時，成功和不成的查找平均需要2次比較當填裝因子為2/3時，分別需要2.37和3.0次比較當填裝因子為0.8時，分別需要2.9和5.0次因此對於較高的填裝因子，對比線性探測，二次探測和再哈希法還是可以忍受的。</li></ul><h1 class=pgc-h-arrow-right>鏈地址法</h1><ul><li>鏈地址法的效率分析有些不同, 一般來說比開放地址法簡單. 我們來分析一下這個公式應該是怎麼樣的.假如哈希表包含arraySize個數據項, 每個數據項有一個鏈表, 在表中一共包含N個數據項.那麼, 平均起來每個鏈表有多少個數據項呢? 非常簡單, N / arraySize.有沒有發現這個公式有點眼熟? 其實就是裝填因子.</li><li>OK, 那麼我們現在就可以求出查找成功和不成功的次數了成功可能只需要查找鏈表的一半即可: 1 + loadFactor/2不成功呢? 可能需要將整個鏈表查詢完才知道不成功: 1 + loadFactor.</li><li>對應的圖</li></ul><p><br></p><div class=pgc-img><img alt=數據結構一(哈希表)想進大廠的必備知識點 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5bebbe6e1a5b47f4bbb6ef53c591e63a><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>效率的結論</h1><ul><li>經過上面的比較我們可以發現, 鏈地址法相對來說效率是好於開放地址法的.</li><li>所以在真實開發中, 使用鏈地址法的情況較多, 因為它不會因為添加了某元素後性能急劇下降.比如在Java的HashMap中使用的就是鏈地址法.</li><li>代碼實現:到目前為止, 我們講了很久的哈希表原理, 依然沒有寫任何代碼.因為我覺得理解了原理, 再去寫代碼相對思路會清晰一些.後面, 我會使用鏈地址法來實現我們的哈希表(你也可以試著使用開放地址法來實現, 原理已經非常清晰了)但是, 我們還有N多的細節, 可以深入探討.欲知後事如何, 且聽下回分解!!!</li></ul><p>感謝小夥伴的閱讀,後面還會繼續更新,與大家分享.歡迎大家加入哦1023554403群,可以免費領取學習資料,不斷更新資料,一起學習,進步.</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>哈希</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html alt=一文看懂編程中的基本數據結構與算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html title=一文看懂編程中的基本數據結構與算法思想>一文看懂編程中的基本數據結構與算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html alt=數據結構與算法（7）遞歸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html title=數據結構與算法（7）遞歸>數據結構與算法（7）遞歸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/062bbe77.html alt=軟考自查：數據結構與算法基礎（內容有點多！！！） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/60f8235323314304b4dac050f8cb1e7d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/062bbe77.html title=軟考自查：數據結構與算法基礎（內容有點多！！！）>軟考自查：數據結構與算法基礎（內容有點多！！！）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>