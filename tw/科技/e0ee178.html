<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「原創」Java併發編程系列36 | FutureTask | 极客快訊</title><meta property="og:title" content="「原創」Java併發編程系列36 | FutureTask - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/SAZA4S9I6wzJm7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="「原創」Java併發編程系列36 | FutureTask"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e0ee178.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「原創」Java併發編程系列36 | FutureTask</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>★★★</strong><strong class=highlight-text toutiao-origin=span>建議</strong><strong>星標</strong><strong class=highlight-text toutiao-origin=span>我們</strong><strong>★★★</strong></p><p><strong>Java進階架構師</strong><strong>★</strong>“<strong>星標</strong>”！這樣才不會錯過每日進階架構文章呀。</p><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAZA4S9I6wzJm7><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ryxcguy98OEq9e><p><strong>2020年Java原創面試題庫連載中</strong></p><p>【000期】Java最全面試題庫思維導圖</p><p>【001期】JavaSE面試題（一）：面向對象</p><p>【002期】JavaSE面試題（二）：基本數據類型與訪問修飾符</p><p>【003期】JavaSE面試題（三）：JavaSE語法（1）</p><p>【004期】JavaSE面試題（四）：JavaSE語法（3）</p><p>【005期】JavaSE面試題（五）：String類</p><p>【006期】JavaSE面試題（六）：泛型</p><p>【007期】JavaSE面試題（七）：異常</p><p>【008期】JavaSE面試題（八）：集合之List</p><p>【009期】JavaSE面試題（九）：集合之Set</p><p>【010期】JavaSE面試題（十）：集合之Map</p><p>【011期】JavaSE面試題（十一）：多線程（1）</p><p>【012期】JavaSE面試題（十二）：多線程（2）</p><p>【013期】JavaSE面試題（十三）：多線程（3）</p><p>【014期】JavaSE面試題（十四）：基本IO流</p><p>【015期】JavaSE面試題（十五）：網絡IO流</p><p>【016期】JavaSE面試題（十六）：反射</p><p>【017期】JavaSE面試題（十七）：JVM之內存模型</p><p>【018期】JavaSE面試題（十八）：JVM之垃圾回收</p><p>【020期】JavaSE系列面試題彙總（共18篇）</p><p>【019期】JavaWeb面試題（一）：JDBC</p><p>【021期】JavaWeb面試題（二）：HTTP協議</p><p>【022期】JavaWeb面試題（三）：Cookie和Session</p><p>【023期】JavaWeb面試題（四）：JSP</p><p>【024期】JavaWeb面試題（五）：Filter和Listener</p><p>【025期】Java工具面試題（一）：版本控制工具</p><p>【026期】Java工具面試題（二）：項目管理工具</p><p>【027期】Java設計模式面試題</p><p>【028期】JavaWeb系列面試題彙總（共10篇）</p><p>【029期】JavaEE面試題（一）Web應用服務器</p><p>【030期】JavaEE面試題（二）SpringMVC</p><p>【031期】JavaEE面試題（三）Spring（1）</p><p>【032期】JavaEE面試題（四）Spring（2）</p><p>【033期】JaveEE面試題（五）MyBatis</p><p>【034期】JavaEE面試題（六）Hibernate</p><p>【035期】JavaEE面試題（七）SpringBoot（1）</p><p>更多內容，點擊上面藍字查看</p><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ryxcguy98OEq9e><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RyGixJJ21nOJYN><p>線程池源碼中出現了很多Callable、Future、FutureTask等以前沒介紹過的接口，尤其是線程池提交任務時總是把任務封裝成FutureTask，今天就來為大家解惑：</p><ol><li><p>Runnable、Callable、Future、FutureTask</p></li><li><p>FutureTask類結構</p></li><li><p>FutureTask狀態</p></li><li><p>執行任務 run方法</p></li><li><p>獲取任務返回值 get方法</p></li><li><p>取消任務 cancel方法</p></li></ol><p><strong toutiao-origin=span>1. Runnable、Callable、Future、FutureTask</strong></p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.1 Runnable</strong></h2><p>Runnable接口只有一個run方法，而run方法的返回值是void，所以線程執行完之後沒有返回值。</p><pre><code>public interface Runnable {<br>public abstract void run;<br>}<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.2 Callable</strong></h2><p>在很多場景下，我們通過線程來異步執行任務之後，希望獲取到任務的執行結果。比如RPC框架中，需要異步獲取任務返回值。這種情況下，Runnable無法獲取返回值就無法滿足需求了，因此Callable就出現了。</p><p>Callable也是一個接口，也只有一個call方法，不同的是Callable的call方法有是有返回值的，返回值的類型是一個泛型，泛型由創建Callable對象時指定。</p><pre><code>public interface Callable&lt;V&gt; {<br>V call throws Exception;<br>}<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.3 Future</strong></h2><p>要想獲得Callable的返回值就需要用到Future接口。Futrue可以監視和控制Callable任務的執行情況，如對執行結果進行取消、查詢是否完成、獲取結果等。</p><p>如：當一個任務通過線程池的submit方法提交到線程池後，線程池會返回一個Future類型的對象，我們可以通過Future對象來獲取任務在線程池中的狀態。</p><pre><code>public interface Future&lt;V&gt; {<br>boolean cancel(boolean mayInterruptIfRunning);<br>boolean isCancelled;<br>boolean isDone;<br>V get throws InterruptedException, ExecutionException;<br>V get(long timeout, TimeUnit unit)<br>throws InterruptedException, ExecutionException, TimeoutException;<br>}<br></code></pre><ul><li><div><p>cancel方法：用來取消任務，如果取消任務成功則返回true，如果取消任務失敗則返回false。</p><p>mayInterruptIfRunning參數用來表示是否需要中斷線程，如果傳true，表示需要中斷線程，那麼就會將任務的狀態設置為INTERRUPTING；如果為false，那麼就會將任務的狀態設置為CANCELLED（關於任務的狀態INTERRUPTING和CANCELLED後面會說明）</p></div></li><li><p>isCancelled方法：表示任務是否被取消成功，如果在任務正常完成前被取消成功，則返回 true</p></li><li><p>isDone方法：表示任務是否已經完成，若任務完成，則返回true</p></li><li><p>get方法：用來獲取執行結果，這個方法會產生阻塞，會一直等到任務執行完畢才返回。</p></li><li><p>get(long timeout, TimeUnit unit)方法：獲取執行結果，如果在指定時間內，還沒獲取到結果，就直接返回。</p></li></ul><p>舉例：Future獲取Callable任務的返回值</p><pre><code>public class FutureExample {<br>public static void main(String[] args) throws InterruptedException, ExecutionException {<br>ExecutorService threadPool = Executors.newCachedThreadPool;<br>Future&lt;String&gt; future = threadPool.submit(new Callable&lt;String&gt; {<br>@Override<br>public String call throws Exception {<br>Thread.sleep(2000);<br>return "結果";<br>}<br>});<br>System.out.println("Callable返回值=" + future.get);<br>}<br>}<br></code></pre><p>輸出結果：</p><pre><code>Callable返回值=結果<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.4 FutureTask</strong></h2><p>FutureTask是Runnable和Future的實現類，既可以作為Runnable被線程執行，又可以作為Future得到Callable的返回值。</p><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SAZA4Tj8Flk2sq><p>當線程池調用submit方法來向線程池中提交任務時，無論提交的是Runnable類型的任務，還是提交的是Callable類型的任務，最終都是將任務封裝成一個FutureTask對象，我們可以通過這個FutureTask對象來獲取任務在線程池中的狀態。</p><pre><code> public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {<br>if (task == ) throw new PointerException;<br>// 調用newTaskFor將Callable任務封裝成一個FutureTask<br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>// 執行任務<br>execute(ftask);<br>return ftask;<br>}<br><br>// newTaskFor<br>protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {<br>// 直接new一個FutureTask對象<br>return new FutureTask&lt;T&gt;(callable);<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>2. FutureTask類結構</h2><pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {<br>/** state變量用來保存任務的狀態 */<br>private volatile int state;<br>private static final int NEW = 0;<br>private static final int COMPLETING = 1;<br>private static final int NORMAL = 2;<br>private static final int EXCEPTIONAL = 3;<br>private static final int CANCELLED = 4;<br>private static final int INTERRUPTING = 5;<br>private static final int INTERRUPTED = 6;<br><br>/** 提交的任務，Runnable類型的任務會通過Executors.callable來轉變為Callable */<br>private Callable&lt;V&gt; callable;<br>/** 用來保存Callable的call方法的返回值 */<br>private Object outcome;<br>/** 執行Callable任務的線程 **/<br>private volatile Thread runner;<br>/**<br>* 任務未完成時，調用get方法獲取結果的線程會阻塞等待<br>* waiters用於保存這些線程<br>*/<br>private volatile WaitNode waiters;<br><br>static final class WaitNode {<br>volatile Thread thread;<br>volatile WaitNode next;<br>WaitNode { thread = Thread.currentThread; }<br>}<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>3. FutureTask狀態</h2><p>FutureTask任務的狀態如下：</p><pre><code> // 任務的初始狀態，當新建一個FutureTask任務時，state值默認為NEW<br>private static final int NEW = 0;<br>// 任務處於完成中，也就是正在執行還未設置返回值<br>private static final int COMPLETING = 1;<br>// 任務正常被執行完成，並將任務的返回值賦值給outcome屬性之後<br>private static final int NORMAL = 2;<br>// 任務出了異常，並將異常對象賦值給outcome屬性之後<br>private static final int EXCEPTIONAL = 3;<br>// 調用cancle(false)，任務被取消了<br>private static final int CANCELLED = 4;<br>// 調用cancle(true)，任務中斷，但是在線程中斷之前<br>private static final int INTERRUPTING = 5;<br>// 調用cancle(true)，任務中斷，但是在線程中斷之後<br>private static final int INTERRUPTED = 6;<br></code></pre><p>狀態變化如下圖：</p><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAZA7SU938gfW8><p></p><h2 toutiao-origin=h2>4. 執行任務run</h2><ol><li><p>執行future.callable.call，執行任務；</p></li><li><p>執行成功，設置結果outcome；</p></li><li><p>逐個喚醒waiters中的線程去獲取執行結果。</p></li></ol><pre><code>public void run {<br>/*<br>* 1. 不是NEW狀態，不能執行<br>* 2. 設置runner失敗，不能執行<br>*/<br>if (state != NEW ||<br>!UNSAFE.compareAndSwapObject(this, runnerOffset,<br>, Thread.currentThread))<br>return;<br>try {<br>Callable&lt;V&gt; c = callable;<br>if (c != &amp;&amp; state == NEW) {<br>V result;<br>boolean ran;<br>try {<br>result = c.call;// 真正執行任務<br>ran = true;// 執行成功，設置執行成功標誌<br>} catch (Throwable ex) {<br>result = ;<br>ran = false;// 有異常，執行失敗<br>setException(ex);// 設置異常<br>}<br>// 如果執行成功，則設置返回結果<br>if (ran)<br>set(result);<br>}<br>} finally {<br>runner = ;// 無論是否執行成功，把runner設置為<br>int s = state;<br>// 處理中斷<br>if (s &gt;= INTERRUPTING)<br>handlePossibleCancellationInterrupt(s);<br>}<br>}<br><br>/**<br>* 設置執行結果<br>*/<br>protected void set(V v) {<br>if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {// 執行完成，設置COMPLETING狀態<br>outcome = v;// 設置執行結果<br>UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // 設置完結果，設置NORMAL狀態<br>finishCompletion;// 逐個喚醒waiters中的線程去獲取執行結果<br>}<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>5. 獲取任務返回值get方法</h2><ol><li><p>任務狀態為NORMAL，直接返回執行結果；</p></li><li><p>任務狀態為COMPLETING，線程yield讓出CPU，因為COMPLETING到NORMAL只需要很短的時間，get線程讓出CPU的短暫時間，任務狀態就是從COMPLETING變成了NORMAL；</p></li><li><p>任務狀態為NEW，將get線程阻塞，如果設置了超時，阻塞至超時時間；如果沒有設置超時，會一直阻塞直到任務完成後喚醒。</p></li></ol><pre><code>public V get throws InterruptedException, ExecutionException {<br>int s = state;<br>// 如果狀態處於NEW或者COMPLETING狀態，表示任務還沒有執行完成，awaitDone等待<br>if (s &lt;= COMPLETING)<br>s = awaitDone(false, 0L);// 下文詳解<br>// 返回結果，下文詳解<br>return report(s);<br>}<br><br>/**<br>* 返回執行結果<br>*/<br>private V report(int s) throws ExecutionException {<br>Object x = outcome;<br>// 任務正常結束時，返回outcome<br>if (s == NORMAL)<br>return (V)x;<br>// 任務被取消了，拋出CancellationException<br>if (s &gt;= CANCELLED)<br>throw new CancellationException;<br>// 這裡只能第EXCEPTIONAL狀態，表示在執行過程中出現了異常，拋出ExecutionException。<br>throw new ExecutionException((Throwable)x);<br>}<br><br>/**<br>* 處於NEW或者COMPLETING狀態時，get線程等待<br>*/<br>private int awaitDone(boolean timed, long nanos)<br>throws InterruptedException {<br>// ......<br>for (;;) {<br>// ......<br>// 任務處於COMPLETING中，就讓當前線程先暫時放棄CPU的執行權<br>else if (s == COMPLETING) // cannot time out yet<br>Thread.yield;<br>// ......<br>// 如果設置了超時，阻塞至超時時間<br>else if (timed) {<br>nanos = deadline - System.nanoTime;<br>if (nanos &lt;= 0L) {<br>removeWaiter(q);<br>return state;<br>}<br>// 等待一段時間<br>LockSupport.parkNanos(this, nanos);<br>}<br>else<br>// 如果沒有設置超時，會一直阻塞，直到被中斷或者被喚醒<br>LockSupport.park(this);<br>}<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>6. 取消任務 cancel</h2><p>將任務狀態設置成INTERRUPTING/INTERRUPTED/CANCELLED狀態就表示取消了線程，因為在這些狀態下任務的run方法是不能執行的。</p><pre><code>public boolean cancel(boolean mayInterruptIfRunning) {<br>/*<br>* 以下情況不能取消任務：<br>* 1. 當前任務不是NEW狀態，已經被執行了，不能取消<br>* 2. 當前任務還沒有執行，state == NEW，但是CAS設置狀態失敗，不能取消<br>*/<br>if (!(state == NEW &amp;&amp;<br>UNSAFE.compareAndSwapInt(this, stateOffset, NEW,<br>mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>return false;<br>try { // in case call to interrupt throws exception<br>// 中斷<br>if (mayInterruptIfRunning) {<br>try {<br>Thread t = runner;<br>if (t != )<br>t.interrupt;// 中斷線程<br>} finally { // final state<br>// 中斷之後，設置INTERRUPTED狀態<br>UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);<br>}<br>}<br>} finally {<br>finishCompletion;// 喚醒waiters中的線程去獲取執行結果<br>}<br>return true;<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>併發系列文章彙總</h2><p>【原創】01|開篇獲獎感言</p><p>【原創】02|併發編程三大核心問題</p><p>【原創】03|重排序-可見性和有序性問題根源</p><p>【原創】04|Java 內存模型詳解</p><p>【原創】05|深入理解 volatile</p><p>【原創】06|你不知道的 final</p><p>【原創】07|synchronized 原理</p><p>【原創】08|synchronized 鎖優化</p><p>【原創】09|基礎乾貨</p><p>【原創】10|線程狀態</p><p>【原創】11|線程調度</p><p>【原創】12|揭祕 CAS</p><p>【原創】13|LockSupport</p><p>【原創】14|AQS 源碼分析</p><p>【原創】15|重入鎖 ReentrantLock</p><p>【原創】16|公平鎖與非公平鎖</p><p>【原創】17|讀寫鎖八講（上）</p><p>【原創】18|讀寫鎖八講（下）</p><p>【原創】19|JDK8新增鎖StampedLock</p><p>【原創】20|StampedLock源碼解析</p><p>【原創】21|Condition-Lock的等待通知</p><p>【原創】22|倒計時器CountDownLatch</p><p>【原創】22|倒計時器CountDownLatch</p><p>【原創】23|循環屏障CyclicBarrier</p><p>【原創】24|信號量Semaphore</p><p>【原創】25|交換器Exchangere</p><p>【原創】26|ConcurrentHashMap（上）</p><p>【原創】27|ConcurrentHashMap（下）</p><p>【原創】28|Copy-On-Write容器</p><p>【原創】29|ConcurrentLinkedQueue</p><p>【原創】30 | ThreadLocal</p><p>【原創】31 | 阻塞隊列（上）</p><p>【原創】32 | 阻塞隊列（下）</p><p>【原創】33 | 深入理解線程池（上）</p><p>【原創】34 | 深入理解線程池（下）</p><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R6Aez96HF10BZ3><pre><div><p><strong class=highlight-text toutiao-origin=span>之前，給大家發過</strong><strong class=highlight-text toutiao-origin=strong>三份Java</strong><strong class=highlight-text toutiao-origin=span>面試寶典，這次新增了一份，目前總共是</strong><strong class=highlight-text toutiao-origin=strong>四份</strong><strong class=highlight-text toutiao-origin=span>面試寶典，相信在跳槽前一個月按照面試寶典準備準備，基本沒大問題。</strong></p><ul><li><p><strong class=highlight-text toutiao-origin=strong>《java面試寶典5.0》</strong><strong class=highlight-text toutiao-origin=span>(初中級)</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《350道Java面試題：整理自100+公司》</strong><strong class=highlight-text toutiao-origin=span>（中高級）</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《資深java面試寶典-視頻版》</strong><strong class=highlight-text toutiao-origin=span>（資深）</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《Java[BAT]面試必備》</strong><strong class=highlight-text toutiao-origin=span>（資深）</strong></p></li></ul><p><strong class=highlight-text toutiao-origin=span>分別適用於</strong><strong class=highlight-text toutiao-origin=span>初中級，中高級</strong><strong class=highlight-text toutiao-origin=span>，</strong><strong class=highlight-text toutiao-origin=span>資深</strong><strong class=highlight-text toutiao-origin=span>級工程師</strong><strong class=highlight-text toutiao-origin=span>的面試複習。</strong></p><p><strong class=highlight-text toutiao-origin=span>內容包含</strong><strong class=highlight-text toutiao-origin=span>java基礎、javaweb、mysql性能優化、JVM、鎖、百萬併發、消息隊列，高性能緩存、反射、Spring全家桶原理、微服務、Zookeeper、數據結構、限流熔斷降級等等。</strong></p><div><div><div><div><div><div><div><img alt="「原創」Java併發編程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RFppAnaHsaFKbv></div><div><p><strong class=highlight-text toutiao-origin=span>看到這裡，證明有所收穫</strong></p></div></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>原創</a></li><li><a>Java</a></li><li><a>發編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html alt=Java併發編程：進程和線程之由來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/4f658919-1d85-46bc-bbf1-64aac52f4c80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html title=Java併發編程：進程和線程之由來>Java併發編程：進程和線程之由來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/581a04b6.html alt=(原創)Java的ReentrantLock(可重入鎖)下的Condition class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/dcc50577a6344f7c94cfba48ed89d04d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/581a04b6.html title=(原創)Java的ReentrantLock(可重入鎖)下的Condition>(原創)Java的ReentrantLock(可重入鎖)下的Condition</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65021e04.html alt="Java併發編程 -- 手動實現可重入Lock" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65021e04.html title="Java併發編程 -- 手動實現可重入Lock">Java併發編程 -- 手動實現可重入Lock</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24abe09b.html alt=(原創)Java的ReentrantLock(可重入鎖)詳解上篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f6ffe7fa302246e8842caeeaae9fca86 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24abe09b.html title=(原創)Java的ReentrantLock(可重入鎖)詳解上篇>(原創)Java的ReentrantLock(可重入鎖)詳解上篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b74f39.html alt=Java併發編程-cpu的流水線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7f4148aa001d409f9c216ca503586596 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b74f39.html title=Java併發編程-cpu的流水線>Java併發編程-cpu的流水線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f798649.html alt=「原創」什麼叫束裝尾纖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/65d80c15bb5f447384bf8b734846eadc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f798649.html title=「原創」什麼叫束裝尾纖？>「原創」什麼叫束裝尾纖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2320005a.html alt=「原創」為什麼使用LC光纖耦合器能夠多熔接一倍尾纖 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/88417f7f2c2647bab12e4e97f431d060 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2320005a.html title=「原創」為什麼使用LC光纖耦合器能夠多熔接一倍尾纖>「原創」為什麼使用LC光纖耦合器能夠多熔接一倍尾纖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/caf5b2c6.html alt=「原創」腫瘤放療：放射治療患者體位固定圖例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b9f89fac13ed423f9f63a48872ad9487 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/caf5b2c6.html title=「原創」腫瘤放療：放射治療患者體位固定圖例>「原創」腫瘤放療：放射治療患者體位固定圖例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>