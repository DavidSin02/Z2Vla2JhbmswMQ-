<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! | 极客快訊</title><meta property="og:title" content="什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/ebbd5bfbf9cd4533aedd8bfd15c5a121"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ede58.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ede58.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e1ede58.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ede58.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ede58.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e1ede58.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e1ede58.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ede58.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="什麼是事件循環和異步編程?5種使用async/await更好地編碼方式!"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e1ede58.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>什麼是事件循環和異步編程?5種使用async/await更好地編碼方式!</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre>長文，要有耐心</pre><h1>為什麼單線程是一個限制？</h1><p>當調用堆棧中有函數調用需要花費大量時間來處理時會發生什麼?</p><p>例如，假設在瀏覽器中運行一個複雜的<strong>圖像轉換算法</strong>。</p><p>當調用堆棧有函數要執行時，瀏覽器不能做任何其他事情——它被阻塞了。這意味著瀏覽器不能渲染，不能運行任何其他代碼，只是卡住了。那麼你的應用 UI 界面就卡住了，用戶體驗也就不那麼好了。</p><h1>JavaScript程序的構建塊</h1><p>你可能在單個.js文件中編寫 JavaScript 應用程序，但可以肯定的是，你的程序由幾個塊組成，其中只有一個正在執行，其餘的將在稍後執行。最常見的塊單元是函數。</p><p>大多數剛接觸JavaScript的開發人員似乎都有這樣的問題，就是認為所有函數都是同步完成，沒有考慮的異步的情況。如下例子：</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebbd5bfbf9cd4533aedd8bfd15c5a121><p class=pgc-img-caption></p></div><p>你可能知道標準 Ajax 請求不是同步完成的，這說明在代碼執行時 Ajax(..) 函數還沒有返回任何值來分配給變量 response。</p><p>一種等待異步函數返回的結果簡單的方式就是 <strong>回調函數：</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3fc63d8c9f0b42398144e4c5f5845db7><p class=pgc-img-caption></p></div><p>注意:實際上可以設置同步Ajax請求，但永遠不要那樣做。如果設置同步Ajax請求，應用程序的界面將被阻塞——用戶將無法單擊、輸入數據、導航或滾動。這將阻止任何用戶交互，這是一種可怕的做法。</p><p>以下是同步 Ajax 地，但是請千萬不要這樣做：</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b884622e54234fafadc4cff674fa3260><p class=pgc-img-caption></p></div><p>這裡使用Ajax請求作為示例，你可以讓任何代碼塊異步執行。</p><p>這可以通過 setTimeout(callback，milliseconds) 函數來完成。setTimeout 函數的作用是設置一個回調函數milliseconds後執行，如下：</p><pre>function first() { console.log('first');}function second() { console.log('second');}function third() { console.log('third');}first();setTimeout(second, 1000); // Invoke `second` after 1000msthird();</pre><p>輸出：</p><pre>firstthirdsecond</pre><h1>解析事件循環</h1><p>這裡從一個有點奇怪的聲明開始——儘管允許異步 JavaScript 代碼(就像上例討論的setTimeout)，但在ES6之前，JavaScript本身實際上從來沒有任何內置異步的概念，JavaScript引擎在任何給定時刻只執行一個塊。</p><p>那麼，是誰告訴JS引擎執行程序的代碼塊呢?實際上，JS引擎並不是單獨運行的——它是在一個宿主環境中運行的，對於大多數開發人員來說，宿主環境就是典型的web瀏覽器或Node.js。實際上，現在JavaScript被嵌入到各種各樣的設備中，從機器人到燈泡，每個設備代表 JS 引擎的不同類型的託管環境。所有環境中的共同點是一個稱為<strong>事件循環</strong>的內置機制，它處理程序的多個塊在一段時間內通過調用JS引擎的執行。</p><p>這意味著JS引擎只是任意JS代碼的按需執行環境，是宿主環境處理事件運行及結果。</p><p>例如，當 JavaScript 程序發出 Ajax 請求從服務器獲取一些數據時，在函數(“回調”)中設置“response”代碼，JS引擎告訴宿主環境:"我現在要推遲執行，但當完成那個網絡請求時，會返回一些數據，請回調這個函數並給數據傳給它"。</p><p>然後瀏覽器將偵聽來自網絡的響應，當監聽到網絡請求返回內容時，瀏覽器通過將回調函數插入事件循環來調度要執行的回調函數。以下是示意圖：</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bca3557a89054dc4a9092c9ecc016dd6><p class=pgc-img-caption></p></div><p>這些Web api是什麼?從本質上說，它們是無法訪問的線程，只能調用它們。它們是瀏覽器的併發部分。</p><p>這樣的迭代在事件循環中稱為<strong>(tick)標記</strong>，每個事件只是一個函數回調。</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2142705a99f24eb29ef239f48191658e><p class=pgc-img-caption></p></div><p>讓我們“執行”這段代碼，看看會發生什麼:</p><p><strong>1.初始化狀態都為空，瀏覽器控制檯是空的的，調用堆棧也是空的</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/29af4659ab0645ffa05ab51cbf084b40><p class=pgc-img-caption></p></div><p><strong>2. console.log('Hi')添加到調用堆棧中</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/481846d3da10415682241b2364153f51><p class=pgc-img-caption></p></div><p><strong>3. 執行console.log('Hi')</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/952f46dc690742959006d8019e3a3623><p class=pgc-img-caption></p></div><p><strong>4. console.log('Hi')從調用堆棧中移除。</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/66de46a245fd4c25a7d7e61098fc7c92><p class=pgc-img-caption></p></div><p><strong>5. setTimeout(function cb1() { ... }) 添加到調用堆棧。</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e41ff44726604b19bf8bf99f4ca2df76><p class=pgc-img-caption></p></div><p><strong>6. setTimeout(function cb1() { ... }) 執行，瀏覽器創建一個計時器計時，這個作為Web api的一部分。</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6508bb34e257462fb746676620a45616><p class=pgc-img-caption></p></div><p><strong>7. setTimeout(function cb1() { ... })本身執行完成，並從調用堆棧中刪除。</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d0f599a8c0d4d32a580d71933174b04><p class=pgc-img-caption></p></div><p><strong>8. console.log('Bye') 添加到調用堆棧</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/78f1f1c8ea504d5e9dbbee0c668ed6c9><p class=pgc-img-caption></p></div><p><strong>9. 執行 console.log('Bye')</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c23bb97551dd41678263f522026edce3><p class=pgc-img-caption></p></div><p><strong>10. console.log('Bye') 從調用調用堆棧移除</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6664550ee9484814a6fc57f5f80446f6><p class=pgc-img-caption></p></div><p><strong>11. 至少在5秒之後，計時器完成並將cb1回調推到回調隊列。</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/00148a03bb66441a8d3391470a708dce><p class=pgc-img-caption></p></div><p><strong>12. 事件循環從回調隊列中獲取cb1並將其推入調用堆棧。</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4155614b18b648dcb319922f2cc1456e><p class=pgc-img-caption></p></div><p><strong>13. 執行cb1並將console.log('cb1')添加到調用堆棧。</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cf9606a5e9b46a1bf66d212793458be><p class=pgc-img-caption></p></div><p><strong>14. 執行 console.log('cb1')</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6a1a948be46d43b3b561780a3431408d><p class=pgc-img-caption></p></div><p><strong>15. console.log('cb1') 從調用堆棧中移除</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ac203456619d4a56ad20c68d67fe989b><p class=pgc-img-caption></p></div><p><strong>16. cb1 從調用堆棧中移除</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5190fce9233340919fd624243398d805><p class=pgc-img-caption></p></div><p><strong>快速回顧：</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/22ee54f1e14749d687a2f9106b071a14><p class=pgc-img-caption></p></div><p>值得注意的是，ES6指定了事件循環應該如何工作，這意味著在技術上它屬於JS引擎的職責範圍，不再僅僅扮演宿主環境的角色。這種變化的一個主要原因是ES6中引入了 Promises，因為ES6需要對事件循環隊列上的調度操作進行直接、細度的控制。</p><h1>setTimeout(…) 是怎麼工作的</h1><p>需要注意的是，setTimeout(…)不會自動將回調放到事件循環隊列中。它設置了一個計時器。當計時器過期時，環境將回調放到事件循環中，以便將來某個<strong>標記(tick)</strong>將接收並執行它。請看下面的代碼:</p><pre>setTimeout(myCallback, 1000);</pre><p>這並不意味著myCallback將在1000毫秒後就立馬執行，而是在1000毫秒後，myCallback被添加到隊列中。但是，如果隊列有其他事件在前面添加回調剛必須等待前後的執行完後在執行myCallback。</p><p>有不少的文章和教程上開始使用異步JavaScript代碼,建議用setTimeout(回調,0),現在你知道事件循環和setTimeout是如何工作的:調用setTimeout 0毫秒作為第二個參數只是推遲迴調將它放到回調隊列中,直到調用堆棧是空的。</p><p>請看下面的代碼:</p><pre>console.log('Hi');setTimeout(function() { console.log('callback');}, 0);console.log('Bye');</pre><p>雖然等待時間被設置為0 ms，但在瀏覽器控制檯的結果如下:</p><pre>HiByecallback</pre><h1>ES6的任務隊列是什麼?</h1><p>ES6中引入了一個名為“任務隊列”的概念。它是事件循環隊列上的一個層。最為常見在Promises 處理的異步方式。</p><p>想像一下:任務隊列是一個附加到事件循環隊列中每個標記末尾的隊列。某些異步操作可能發生在事件循環的一個標記期間，不會導致一個全新的事件被添加到事件循環隊列中，而是將一個項目(即任務)添加到當前標記的任務隊列的末尾。</p><p>這意味著可以放心添加另一個功能以便稍後執行，它將在其他任何事情之前立即執行。</p><p>任務還可能創建更多任務添加到同一隊列的末尾。理論上，任務“循環”(不斷添加其他任務的任等等)可以無限運行，從而使程序無法獲得轉移到下一個事件循環標記的必要資源。從概念上講，這類似於在代碼中表示長時間運行或無限循環(如while (true) ..)。</p><h1>回調</h1><p>正如你已經知道的，回調是到目前為止JavaScript程序中表達和管理異步最常見的方法。實際上，回調是JavaScript語言中最基本的異步模式。無數的JS程序，甚至是非常複雜的程序，除了一些基本都是在回調異步基礎上編寫的。</p><p>然而回調方式還是有一些缺點，許多開發人員都在試圖找到更好的異步模式。但是，如果不瞭解底層的內容，就不可能有效地使用任何抽象出來的異步模式。</p><h1>嵌套回調</h1><p>請看以下代碼:</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6eff5b15aa7d422fa00120074690fc45><p class=pgc-img-caption></p></div><p>有一個由三個函數組成的鏈嵌套在一起，每個函數表示異步系列中的一個步驟。</p><p>這種代碼通常被稱為“<strong>回調地獄</strong>”。但是“回調地獄”實際上與嵌套/縮進幾乎沒有任何關係，這是一個更深層次的問題。</p><p>首先，我們<strong>等待</strong>“單擊”事件，然後<strong>等待</strong>計時器觸發，然後<strong>等待</strong>Ajax響應返回，此時可能會再次重複所有操作。</p><p>乍一看，這段代碼似乎可以將其異步性自然地對應到以下順序步驟:</p><pre>listen('click', function (e) { // ..});</pre><p>然後：</p><pre>setTimeout(function(){ // ..}, 500);</pre><p>接著：</p><pre>ajax('https://api.example.com/endpoint', function (text){ // ..});</pre><p>最後：</p><pre>if (text == "hello") { doSomething();}else if (text == "world") { doSomethingElse();}</pre><p>因此，這種連續的方式來表示異步代碼似乎更自然.</p><h1>Promises</h1><p>請看下面的代碼:</p><pre>var x = 1;var y = 2;console.log(x + y);</pre><p>這非常簡單:它對x和y的值進行求和，並將其打印到控制檯。但是，如果x或y的值<strong>丟失</strong>了，仍然需要求值，要怎麼辦?</p><p>例如，需要從服務器取回x和y的值，然後才能在表達式中使用它們。假設我們有一個函數loadX和loadY，它們分別從服務器加載x和y的值。然後，一旦x和y都被加載，假設我們有一個函數sum，它對x和y的值進行求和。</p><p><strong>它可能看起來像這樣:</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddbbf1d5c8894afdb68b7c3d23b4e61f><p class=pgc-img-caption></p></div><p>這裡有一些非常重要的事情——在這個代碼片段中，我們將x和y作為異步獲取的的值，並且執行了一個函數sum(…)(從外部)，它不關心x或y，也不關心它們是否立即可用。</p><p>當然，這種基於回調的粗略方法還有很多不足之處。 這只是一個我們不必判斷對於異步請求的值的處理方式一個小步驟而已。</p><h1>Promise Value</h1><p>用Promise來重寫上例:</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b98c32d2f03f4b7091cf0aebc243731c><p class=pgc-img-caption></p></div><p>在這個代碼片段中有兩層Promise。</p><p>fetchX 和 fetchY 先直接調用，返回一個promise，傳給 sum。 sum 創建並返回一個Promise，通過調用 then 等待 Promise，完成後，sum 已經準備好了（resolve），將會打印出來。</p><p>第二層是 sum(…) 創建的 Promise ( 通過 Promise.all([ ... ]) )然後返回 Promise，通過調用then(…)來等待。當 sum(…) 操作完成時，sum 傳入的兩個 Promise 都執行完後，可以打印出來了。這裡隱藏了在sum(…)中等待x和y未來值的邏輯。</p><p><strong>注意：</strong>在sum（...）內，Promise.all（[...]）調用創建一個 promise（等待 promiseX 和 promiseY 解析）。 然後鏈式調用 .then（...）方法裡再的創建了另一個 Promise，然後把 返回的 x 和 和（values[0] + values[1]） 進行求和 並返回 。</p><p>因此，我們在sum（...）末尾調用then（...）方法 — 實際上是在返回的第二個 Pwwromise 上運行，而不是由Promise.all([ ... ])創建 Promise。 此外，雖然沒有在第二個 Promise 結束時再調用 then方法 ，其時這裡也創建一個 Promise。</p><p>Promise.then(…) 實際上可以使用兩個函數，第一個函數用於執行成功的操作，第二個函數用於處理失敗的操作：</p><p>如果在獲取x或y時出現錯誤，或者在添加過程中出現某種失敗，sum(…) 返回的 Promise將被拒絕，傳遞給 then(…) 的第二個回調錯誤處理程序將從 Promise 接收失敗的信息。</p><p>從外部看，由於 Promise 封裝了依賴於時間的狀態（等待底層值的完成或拒絕，Promise 本身是與時間無關的），它可以按照可預測的方式組成，不需要開發者關心時序或底層的結果。一旦 Promise 決議，此刻它就成為了外部不可變的值。</p><p><strong>可鏈接調用 Promise 真的很有用：</strong></p><p>創建一個延遲2000ms內完成的 Promise ，然後我們從第一個then（...）回調中返回，這會導致第二個then（...）等待 2000ms。</p><blockquote><p>注意：因為Promise 一旦被解析，它在外部是不可變的，所以現在可以安全地將該值傳遞給任何一方，因為它不能被意外地或惡意地修改，這一點在多方遵守承諾的決議時尤其正確。一方不可能影響另一方遵守承諾決議的能力，不變性聽起來像是一個學術話題，但它實際上是承諾設計最基本和最重要的方面之一，不應該被隨意忽略。</p></blockquote><h1>使用 Promise 還是不用？</h1><p>關於 Promise 的一個重要細節是要確定某個值是否是一個實際的Promise 。換句話說，它是否具有像Promise 一樣行為？</p><p>我們知道 Promise 是由new Promise(…)語法構造的，你可能認為 p instanceof Promise是一個足夠可以判斷的類型，嗯,不完全是。</p><p>這主要是因為可以從另一個瀏覽器窗口(例如iframe)接收 Promise 值，而該窗口或框架具有自己的 Promise 值，與當前窗口或框架中的 Promise 值不同，所以該檢查將無法識別 Promise 實例。</p><p>此外，庫或框架可以選擇性的封裝自己的 Promise，而不使用原生 ES6 的Promise 來實現。事實上，很可能在老瀏覽器的庫中沒有 Promise。</p><h1>吞掉錯誤或異常</h1><p>如果在 Promise 創建中，出現了一個javascript一場錯誤(TypeError 或者 ReferenceError)，這個異常會被捕捉，並且使這個 promise 被拒絕。</p><p>但是，如果在調用 then(…) 方法中出現了 JS 異常錯誤，那麼會發生什麼情況呢?即使它不會丟失，你可能會發現它們的處理方式有點令人吃驚，直到你挖得更深一點:</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eb47a4e9868440db96886967f45e87e7><p class=pgc-img-caption></p></div><p>看起來foo.bar()中的異常確實被吞噬了，不過,它不是。然而，還有一些更深層次的問題，我們沒有注意到。 p.then(…) 調用本身返回另一個 Promise，該 Promise 將被 TypeError 異常拒絕。</p><h1>處理未捕獲異常</h1><p>許多人會說，還有其他更好的方法。</p><p>一個常見的建議是，Promise 應該添加一個 done(…)，這實際上是將 Promise 鏈標記為 “done”。done(…) 不會創建並返回 Promise ，因此傳遞給 done(..) 的回調顯然不會將問題報告給不存在的鏈接 Promise 。</p><p>Promise 對象的回調鏈，不管以 then 方法或 catch 方法結尾，要是最後一個方法拋出錯誤，都有可能無法捕捉到（因為 Promise 內部的錯誤不會冒泡到全局）。因此，我們可以提供一個 done 方法，總是處於回調鏈的尾端，保證拋出任何可能出現的錯誤。</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/80b3c995e06d4ab99286a0c8ffd327ce><p class=pgc-img-caption></p></div><h1>ES8中改進了什麼 ?Async/await （異步/等待）</h1><p>JavaScript ES8引入了 async/await，這使得使用 Promise 的工作更容易。這裡將簡要介紹async/await 提供的可能性以及如何利用它們編寫異步代碼。</p><p>使用 async 聲明異步函數。這個函數返回一個 AsyncFunction 對象。AsyncFunction 對象表示該函數中包含的代碼的異步函數。</p><p>調用使用 async 聲明函數時，它返回一個 Promise。當這個函數返回一個值時，這個值只是一個普通值而已，這個函數內部將自動創建一個承諾，並使用函數返回的值進行解析。當這個函數拋出異常時，Promise 將被拋出的值拒絕。</p><p>使用 async 聲明函數時可以包含一個 await 符號，<strong>await 暫停這個函數的執行並等待傳遞的 Promise 的解析完成</strong>，然後恢復這個函數的執行並返回解析後的值。</p><blockquote><p>async/wait 的目的是簡化使用承諾的行為</p></blockquote><p>讓看看下面的例子:</p><pre>function getNumber1() { return Promise.resolve('374');}// 這個函數與getNumber1相同async function getNumber2() { return 374;}</pre><p>類似地，拋出異常的函數等價於返回被拒絕的 Promise 的函數:</p><pre> function f1() { return Promise.reject('Some error');}async function f2() { throw 'Some error';}</pre><p>await 關鍵字只能在異步函數中使用，並允許同步等待 Promise。如果在 async 函數之外使用 Promise，仍然需要使用 then 回調:</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d4eaa5eb7f52421fb071213636f1d4d2><p class=pgc-img-caption></p></div><p>還可以使用“異步函數表達式”定義異步函數。異步函數表達式與異步函數語句非常相似，語法也幾乎相同。異步函數表達式和異步函數語句之間的主要區別是函數名，可以在異步函數表達式中省略函數名來創建匿名函數。異步函數表達式可以用作生命(立即調用的函數表達式)，一旦定義它就會運行。</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4787abe9e0b42bf8a81fa1d0109cfa5><p class=pgc-img-caption></p></div><p>更重要的是，在所有主流的瀏覽器都支持 async/await:</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b045ccb24d4443cb8ab82e4f6f2bb2e7><p class=pgc-img-caption></p></div><h1>編寫高度可維護性、非易碎異步代碼的5個技巧</h1><p><strong>1、簡介代碼: 使用 async/await 可以編寫更少的代碼。 每次使用 async/await時，都會跳過一些不必要的步驟：使用.then，創建一個匿名函數來處理響應，例如：</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d1bdb0e7811e4987b60a107469202a36><p class=pgc-img-caption></p></div><p><strong>2、錯誤處理: Async/wait 可以使用相同的代碼結構(眾所周知的try/catch語句)處理同步和異步錯誤。看看它是如何與 Promise 結合的:</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed74c865e60f4130b07572e0b7f79190><p class=pgc-img-caption></p></div><p><strong>3、條件:用async/ wait編寫條件代碼要簡單得多:</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/66c3ff073a3e437996e5fef2a3f4a0a9><p class=pgc-img-caption></p></div><p>與</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1e052bef05c24e0e925cc8f0f9c1ac90><p class=pgc-img-caption></p></div><p><strong>4、堆棧幀:與 async/await不同，從 Promise 鏈返回的錯誤堆棧不提供錯誤發生在哪裡。看看下面這些:</strong></p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04bd06d68d8742c9957cd05571e1137a><p class=pgc-img-caption></p></div><p>與：</p><div class=pgc-img><img alt=什麼是事件循環和異步編程?5種使用async/await更好地編碼方式! onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3e4f31f24cb74c94a47528c1be3afdb0><p class=pgc-img-caption></p></div><p><strong>5.調試:如果你使用過 Promise ，那麼你知道調試它們是一場噩夢。例如，如果在一個程序中設置了一個斷點，然後阻塞並使用調試快捷方式(如“停止”)，調試器將不會移動到下面，因為它只“逐步”執行同步代碼。使用async/wait，您可以逐步完成wait調用，就像它們是正常的同步函數一樣。</strong></p><hr><pre>歡迎關注</pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>什麼</a></li><li><a>循環</a></li><li><a>異步</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/41882779.html alt=什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e06e4d3087d4032ab0d9dfb3d7d2e89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/41882779.html title=什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司>什麼是熱水鍋爐循環故障？-赤峰鍋爐清洗公司</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c5e58f92.html alt=十萬個為什麼系列——正反循環鑽進的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/dd08b31f-a2ac-4d7e-89e4-f4765a91de7b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c5e58f92.html title=十萬個為什麼系列——正反循環鑽進的區別>十萬個為什麼系列——正反循環鑽進的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a54c8a.html alt=為什麼0.9循環等於1？數學分析給你答案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a54c8a.html title=為什麼0.9循環等於1？數學分析給你答案>為什麼0.9循環等於1？數學分析給你答案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1a046b.html alt=為什麼你總是陷入貧窮死循環？那是因為你單位時間價值太低！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5966f1541fbd486c867f6fc7f28a2b53 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1a046b.html title=為什麼你總是陷入貧窮死循環？那是因為你單位時間價值太低！>為什麼你總是陷入貧窮死循環？那是因為你單位時間價值太低！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdedb94f.html alt=科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d84b472b45474058bfd6bd4b87450f53 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdedb94f.html title=科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！>科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52ecc739.html alt=科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f0b8a6daf6e4f9bab21e7c06cbc9111 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52ecc739.html title=科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！>科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html alt=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1537941825042b6f495fa56 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html title=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？>長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83641773.html alt=什麼是懸挑結構？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/faebf061b82546f58e63afab5ede5fa2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83641773.html title=什麼是懸挑結構？>什麼是懸挑結構？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a27253ff.html alt=港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a3c45dcf4c374ed4be36f55d44847637 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a27253ff.html title=港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事>港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3eed9cb8.html alt=科普！港珠澳大橋為什麼是彎的！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/41bd66f3348b464c89b66628810a1aeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3eed9cb8.html title=科普！港珠澳大橋為什麼是彎的！>科普！港珠澳大橋為什麼是彎的！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/765025c9.html alt=電纜與光纜有什麼區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c289a44885646ac904fbae012632866 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/765025c9.html title=電纜與光纜有什麼區別>電纜與光纜有什麼區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c5053ab7.html alt="網站服務器是什麼 網站服務器怎麼搭建「詳解」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f9cfb6ae0c13447eab17646a80117f1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c5053ab7.html title="網站服務器是什麼 網站服務器怎麼搭建「詳解」">網站服務器是什麼 網站服務器怎麼搭建「詳解」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b60dd43.html alt=長壽者的耳朵為什麼比別人長？原來耳朵還有這個大祕密 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/616a0000c4f325f77564 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b60dd43.html title=長壽者的耳朵為什麼比別人長？原來耳朵還有這個大祕密>長壽者的耳朵為什麼比別人長？原來耳朵還有這個大祕密</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c33cb41.html alt=為什麼每天都那麼累？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S2HRVEQ6t1WhxB style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c33cb41.html title=為什麼每天都那麼累？>為什麼每天都那麼累？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f7c0fd3.html alt=什麼是場景？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f7c0fd3.html title=什麼是場景？>什麼是場景？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>