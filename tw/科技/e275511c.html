<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>源碼分析：Java集合類的AbstractCollection源碼解析 | 极客快訊</title><meta property="og:title" content="源碼分析：Java集合類的AbstractCollection源碼解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e275511c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="源碼分析：Java集合類的AbstractCollection源碼解析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e275511c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>源碼分析：Java集合類的AbstractCollection源碼解析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote class=pgc-blockquote-abstract><p>作者： liuxiaopeng</p><p>鏈接：https://www.cnblogs.com/paddix/p/5560933.html</p></blockquote><p><strong>一、Collection接口</strong></p><p>　　從《Java集合：整體結構》一文中我們知道所有的List和Set都繼承自Collection接口，該接口類提供了集合最基本的方法，雖然List接口和Set等都有一些自己獨有的方法，但是基本的操作類似。我們先看下Collection接口提供的方法：</p><p>　　</p><div class=pgc-img><img alt=源碼分析：Java集合類的AbstractCollection源碼解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671><p class=pgc-img-caption></p></div><p>總體上可以將Collection的方法分為以下幾大類：</p><p>1、增加（add/addAll）</p><p>2、刪除（remove/removeAll/clear/retainAll）</p><p>3、查詢（contain/containAll/iterator/size/isEmpty）</p><p>4、轉數組（toArray/toArray(T[])）</p><p>　　直接實現該接口的類只有AbstractCollection類，該類也只是一個抽象類，提供了對集合類操作的一些基本實現。List和Set的具體實現類基本上都直接或間接的繼承了該類。為了方便以後更清晰的理解這些類的實現，我們先看下AbstractCollection的實現。</p><p><strong>二、AbstractCollection源碼解析</strong></p><p><br></p><pre><code>package java.util; public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {     protected AbstractCollection() {    }     public abstract Iterator&lt;E&gt; iterator();     public abstract int size();     //判斷集合中是否有數據    public boolean isEmpty() {        return size() == 0;    }     /**     * 判斷是否包含指定的元素     * （1）如果參數為null，查找值為null的元素，如果存在，返回true，否則返回false。     * （2）如果參數不為null，則根據equals方法查找與參數相等的元素，如果存在，則返回true，否則返回false。     * 注意：這裡必須對null單獨處理，否則null.equals會報空指針異常     */    public boolean contains(Object o) {        Iterator&lt;E&gt; it = iterator();        if (o==null) {            while (it.hasNext())                if (it.next()==null)                    return true;        } else {            while (it.hasNext())                if (o.equals(it.next()))                    return true;        }        return false;    }     /**     * 功能：將集合元素轉換為數組     * 實現：     * （1）創建一個數組，大小為集合中元素的數量     * （2）通過迭代器遍歷集合，將當前集合中的元素複製到數組中（複製引用）     * （3）如果集合中元素比預期的少，則調用Arrays.copyOf()方法將數組的元素複製到新數組中，並返回新數組，Arrays.copyOf的源碼在後續文章中會分析.     * （4）如果集合中元素比預期的多，則調用finishToArray方法生成新數組，並返回新數組，否則返回（1）中創建的數組     */    public Object[] toArray() {        Object[] r = new Object[size()];        Iterator&lt;E&gt; it = iterator();        for (int i = 0; i &lt; r.length; i++) {            if (! it.hasNext()) // fewer elements than expected                return Arrays.copyOf(r, i);            r[i] = it.next();        }        return it.hasNext() ? finishToArray(r, it) : r;    }     /**     * 功能：通過泛型約束返回指定類型的數組     * 實現：     * （1）如果傳入數組的長度的長度大於等於集合的長度，則將當前集合的元素複製到傳入的數組中     * （2）如果傳入數組的長度小於集合的大小，則將創建一個新的數組來進行集合元素的存儲     */    public &lt;T&gt; T[] toArray(T[] a) {        // Estimate size of array; be prepared to see more or fewer elements        int size = size();        T[] r = a.length &gt;= size ? a :                  (T[])java.lang.reflect.Array                  .newInstance(a.getClass().getComponentType(), size);        Iterator&lt;E&gt; it = iterator();         for (int i = 0; i &lt; r.length; i++) {            //集合元素大小小於數組的長度            if (! it.hasNext()) { // fewer elements than expected                if (a == r) {//如果數組是參數中的數組，則將剩餘部分的值都設置為null                    r[i] = null; // null-terminate                } else if (a.length &lt; i) {//如果傳入的數組長度小於集合長度，則通過Arrays.copyOf將之前數組中的元素複製到新數組中                    return Arrays.copyOf(r, i);                } else {//如果傳入數組的長度比集合大，則將多的元素設置為空                    System.arraycopy(r, 0, a, 0, i);                    if (a.length &gt; i) {                        a[i] = null;                    }                }                return a;            }            r[i] = (T)it.next();        }        // more elements than expected        //集合元素大小大於數組的長度        return it.hasNext() ? finishToArray(r, it) : r;    }     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;     /**     *  功能：數組擴容     *  （1）當數組索引指向最後一個元素+1時，對數組進行擴容：即創建一個更長的數組，然後將原數組的內容複製到新數組中     *  （2）擴容大小：cap + cap/2 +1     *  （3）擴容前需要先判斷是否數組長度是否溢出     *  注意：這裡的迭代器是從上層的方法（toArray）傳過來的，並且這個迭代器已執行了一部分，而不是從頭開始迭代的     */    private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {        int i = r.length;        while (it.hasNext()) {            int cap = r.length;            if (i == cap) {                int newCap = cap + (cap &gt;&gt; 1) + 1;                // overflow-conscious code                if (newCap - MAX_ARRAY_SIZE &gt; 0)                    newCap = hugeCapacity(cap + 1);                r = Arrays.copyOf(r, newCap);            }            r[i++] = (T)it.next();        }        // trim if overallocated        return (i == r.length) ? r : Arrays.copyOf(r, i);    }     /**     * 判斷數組容量是否溢出，最大為整型數據的最大值     */    private static int hugeCapacity(int minCapacity) {        if (minCapacity &lt; 0) // overflow            throw new OutOfMemoryError                ("Required array size too large");        return (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;    }     /**     * 未實現     */    public boolean add(E e) {        throw new UnsupportedOperationException();    }     /**     * 功能：移除指定元素     * （1）如果參數為null，則找到第一個值為null的元素，並將其刪除，返回true，如果不存在null的元素，返回false。     * （2）如果參數不為null，則根據equals方法找到第一個與參數相等的元素，並將其刪除，返回true，如果找不到，返回false。     */    public boolean remove(Object o) {        Iterator&lt;E&gt; it = iterator();        if (o==null) {            while (it.hasNext()) {                if (it.next()==null) {                    it.remove();                    return true;                }            }        } else {            while (it.hasNext()) {                if (o.equals(it.next())) {                    it.remove();                    return true;                }            }        }        return false;    }     /**     * 遍歷參數集合，依次判斷參數集合中的元素是否在當前集合中，     * 只要有一個不存在，則返回false     * 如果參數集合中所有的元素都在當前集合中，則返回true     */    public boolean containsAll(Collection&lt;?&gt; c) {        for (Object e : c)            if (!contains(e))                return false;        return true;    }     /**     * 遍歷參數集合，依次將參數集合中的元素添加當前集合中     */    public boolean addAll(Collection&lt;? extends E&gt; c) {        boolean modified = false;        for (E e : c)            if (add(e))                modified = true;        return modified;    }     /**     * 功能：移除參數集合的元素     * （1）獲取當前集合的迭代器進行遍歷     * （2）如果當前集合中的元素包含在參數集合中，則刪除當前集合中的元素     *  注：只要參數集合中有任何一個元素在當前元素中，則返回true，表示當前集合有發送變化，否則返回false。     */    public boolean removeAll(Collection&lt;?&gt; c) {        boolean modified = false;        Iterator&lt;?&gt; it = iterator();        while (it.hasNext()) {            if (c.contains(it.next())) {                it.remove();                modified = true;            }        }        return modified;    }     /***     * 功能：求參數集合與當前集合的交集     * （1）獲取當前集合的迭代器進行遍歷     * （2）如果當前集合中的元素不在參數集合中，則將其移除。     *  注意：如果當前集合是參數集合中的子集，則返回false，表示當前集合未發送變化，否則返回true。     */    public boolean retainAll(Collection&lt;?&gt; c) {        boolean modified = false;        Iterator&lt;E&gt; it = iterator();        while (it.hasNext()) {            if (!c.contains(it.next())) {                it.remove();                modified = true;            }        }        return modified;    }     //刪除所有元素    public void clear() {        Iterator&lt;E&gt; it = iterator();        while (it.hasNext()) {            it.next();            it.remove();        }    }      public String toString() {        Iterator&lt;E&gt; it = iterator();        if (! it.hasNext())            return "[]";         StringBuilder sb = new StringBuilder();        sb.append('[');        for (;;) {            E e = it.next();            sb.append(e == this ? "(this Collection)" : e);            if (! it.hasNext())                return sb.append(']').toString();            sb.append(',').append(' ');        }    } }</code></pre><p>　　整體上來說，AbstractCollection的源碼還是比較容易理解，尤其是集合增、刪、查等操作都非常簡單。比較複雜的是關於集合轉數組的操作，有幾個點不是特別好理解，這裡解釋一下：</p><p>　　（1）MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，為什麼最大長度要減8，根據官方的解釋：</p><p>/**</p><p>* The maximum size of array to allocate.</p><p>* Some VMs reserve some header words in an array.</p><p>* Attempts to allocate larger arrays may result in</p><p>* OutOfMemoryError: Requested array size exceeds VM limit</p><p>*/</p><p>　　這段話的意思就是有的虛擬機實現，數組對象的頭部會佔用這8個字節。</p><p>　　（2）轉換為數組的操作時，為什麼長度會比size()長或者短？這個的原因還是考慮到併發情況下，當然，在併發環境上面的機制不一定可行，如在ArrayList中就重寫了該方法，遇到size()與hasNext不一致的情況會直接報錯。不過有些場景下可以通過這種方式保持弱一致性，具體後續遇到這種情況的時候再具體說明。</p><p>　　（3）這裡面執行數組拷貝時，用到兩個方法，一個是Arrays.copyOf，另一個是System.arraycopy(r, 0, a, 0, i)方法，這兩個方法的區別也會在後續文章中討論，這裡暫不細說。</p><p><strong>三、總結</strong></p><p>　　本文主要分析了AbstractCollection類的源碼，很多實現類會重寫AbstractCollection中已實現的方法。但是弄明白AbstractCollection源碼之後，再看其子類的實現，會更容易理解其源碼實現背後的設計原因，其實，很多源碼本身不難理解，難理解的地方在於其背後的設計思想和原因，這也是我們去看源碼和真正要學習的東西。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>源碼</a></li><li><a>Java</a></li><li><a>類的</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html alt="Java HashMap源碼分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a86461eb8cc4ddb9ddf740c0aa49b00 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html title="Java HashMap源碼分析">Java HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dd535810.html alt="Java源碼分析：關於 HashMap 1.8 的重大更新" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66c40005d5e8c29e8c31 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dd535810.html title="Java源碼分析：關於 HashMap 1.8 的重大更新">Java源碼分析：關於 HashMap 1.8 的重大更新</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html alt=Java——HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8ad8e7317b3047f28717cf8c6fb816bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html title=Java——HashMap源碼分析>Java——HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html alt=Java中HashMap源碼分析，絕對乾貨！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/593f0003cad0b7c22de4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html title=Java中HashMap源碼分析，絕對乾貨！>Java中HashMap源碼分析，絕對乾貨！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html alt=Java容器系列-HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10798fbb789b4217a4b19b4f307422b1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html title=Java容器系列-HashMap源碼分析>Java容器系列-HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4e9d6139.html alt=「漫畫」Java中的父子類的執行順序到底是怎麼一回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d5ea2bd94a8042dc8a2c75dc91ca9429 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4e9d6139.html title=「漫畫」Java中的父子類的執行順序到底是怎麼一回事？>「漫畫」Java中的父子類的執行順序到底是怎麼一回事？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html alt="Java源碼中>>，>>>的區別是啥？我給你徹底講清" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b12aaaf792c8469c91e2a514a666a8cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html title="Java源碼中>>，>>>的區別是啥？我給你徹底講清">Java源碼中>>，>>>的區別是啥？我給你徹底講清</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>