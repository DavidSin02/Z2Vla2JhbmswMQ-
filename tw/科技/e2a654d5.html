<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>請收藏C語言最全入門筆記 | 极客快訊</title><meta property="og:title" content="請收藏C語言最全入門筆記 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/000a3011a959479e9bd471fd45a266ca"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2a654d5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2a654d5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e2a654d5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2a654d5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2a654d5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e2a654d5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e2a654d5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2a654d5.html><meta property="article:published_time" content="2020-11-14T20:59:55+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:55+08:00"><meta name=Keywords content><meta name=description content="請收藏C語言最全入門筆記"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e2a654d5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>請收藏C語言最全入門筆記</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>c語言入門</p><p>C語言一經出現就以其功能豐富、表達能力強、靈活方便、應用面廣等特點迅速在全世界普及和推廣。C語言不但執行效率高而且可移植性好，可以用來開發應用軟件、驅動、操作系統等。C語言也是其它眾多高級語言的鼻祖語言，所以說學習C語言是進入編程世界的必修課。</p><h3 class=pgc-h-arrow-right>hello,world</h3><pre><code>#include&lt;stdio.h&gt; int main(){    /*在雙引號中間輸入Hello World*/     printf("Hello World");    return 0; }</code></pre><p>注：在最新的C標準中，main函數前的類型為int而不是void</p><h3 class=pgc-h-arrow-right>c語言的具體結構</h3><p>簡單來說，一個C程序就是由若干頭文件和函數組成。</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/000a3011a959479e9bd471fd45a266ca><p class=pgc-img-caption></p></div><p>#include &lt;stdio.h>就是一條預處理命令, 它的作用是通知C語言編譯系統在對C程序進行正式編譯之前需做一些預處理工作。</p><ul><li>函數就是實現代碼邏輯的一個小的<strong>單元</strong>。</li></ul><h3 class=pgc-h-arrow-right>必不可少之主函數</h3><p>一個C程序有且只有一個主函數，即main函數。</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/85201a926bc44074bffda0c2a1de6582><p class=pgc-img-caption></p></div><p>C程序就是執行主函數裡的代碼，也可以說這個<strong>主函數</strong>就是C語言中的<strong>唯一入口</strong>。</p><ul><li>而<strong>main</strong>前面的<strong>int</strong>就是主函數的類型.</li><li>printf()是<strong>格式輸出</strong>函數，這裡就記住它的功能就是在<strong>屏幕上輸出指定的信息</strong></li><li><strong>return</strong>是函數的返回值，根據函數類型的不同，返回的值也是不同的。</li><li>\n是轉義字符中的換行符。(注意：C程序一定是從主函數開始執行的)</li></ul><h3 class=pgc-h-arrow-right>良好習慣之規範</h3><ol start=1><li><strong>一個說明或一個語句佔一行</strong>，例如：包含頭文件、一個可執行語句結束都需要<strong>換行</strong>。</li><li>函數體內的語句要有明顯<strong>縮進</strong>，<strong>通常以按以下Tab鍵為一個縮進</strong>。</li><li>括號要<strong>成對寫</strong>，如果需要刪除的話也要<strong>成對刪除</strong>。</li><li>當一句可執行語句結束的時候末尾需要有<strong>分號</strong>。</li><li>代碼中所有符號均為<strong>英文半角符號</strong>。</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f67f83d4a3a4a9f95403c8d4fab5bb9><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>程序解釋——註釋</h3><p>註釋是寫給程序員看的，不是寫給電腦看的。</p><p>C語言註釋方法有兩種：</p><blockquote><p>多行註釋： /* 註釋內容 */</p></blockquote><blockquote><p>單行註釋： //註釋一行</p></blockquote><h3 class=pgc-h-arrow-right>有名有姓的C(標識符)</h3><p>C語言規定，標識符可以是字母(A～Z，a～z)、數字(0～9)、下劃線_組成的字符串，並且第一個字符必須是<strong>字母或下劃線</strong>。在使用標識符時還有注意以下幾點：</p><blockquote><p>標識符的長度最好不要超過8位，因為在某些版本的C中規定標識符前8位有效，當兩個標識符前8位相同時，則被認為是同一個標識符。</p></blockquote><ol start=1><li>標識符是嚴格區分大小寫的。例如Imooc和imooc 是兩個不同的標識符。</li><li>標識符最好選擇有意義的英文單詞組成做到"見名知意"，不要使用中文。</li><li>標識符不能是C語言的關鍵字。想了解更多C語言關鍵字的知識。</li></ol><h3 class=pgc-h-arrow-right>變量及賦值</h3><p>變量就是可以變化的量，而每個變量都會有一個名字（標識符）。變量佔據內存中一定的存儲單元。<strong>使用變量之前必須先定義變量</strong>，要區分<strong>變量名</strong>和<strong>變量值</strong>是兩個不同的概念。</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de10050998174395a2f800e6ed854bd4><p class=pgc-img-caption></p></div><blockquote><p>變量定義的一般形式為：數據類型 變量名;</p></blockquote><blockquote><p>多個類型相同的變量：數據類型 變量名, 變量名, 變量名...;</p></blockquote><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a62e07706514352aca979e2a7609be1><p class=pgc-img-caption></p></div><p><strong>注意:在定義中不允許連續賦值，如int a=b=c=5;是不合法的。</strong></p><p>變量的賦值分為兩種方式:</p><ol start=1><li>先聲明再賦值</li><li>聲明的同時賦值</li></ol><h3 class=pgc-h-arrow-right>基本數據類型</h3><p>C語言中，數據類型可分為：</p><ol start=1><li>基本數據類型</li><li>構造數據類型</li><li>指針類型</li><li>空類型四大類</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3245bb7516a7487fbde8b89a3eb6e212><p class=pgc-img-caption></p></div><p>最常用的<strong>整型, 實型與字符型</strong>(char,int,float,double):</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2778418d61194adeb5a6f600d57dca81><p class=pgc-img-caption></p></div><p><strong>整型數據</strong>是指不帶小數的數字(int,short int,long int, unsigned int, unsigned short int,unsigned long int):</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4f44f7e066d4bcc802c46727dc8ec90><p class=pgc-img-caption></p></div><p><strong>注：</strong></p><ul><li>int short int long int是<strong>根據編譯環境的不同，所取範圍不同。</strong></li><li>而其中short int和long int至少是表中所寫範圍, 但是int在表中是以16位編譯環境寫的取值範圍。</li><li>另外 c語言int的取值範圍在於他佔用的字節數 ，不同的編譯器，規定是不一樣。</li><li>ANSI標準定義int是佔2個字節，TC是按ANSI標準的，它的int是佔2個字節的。但是在VC裡，一個int是佔4個字節的。</li></ul><p>浮點數據是指帶小數的數字。</p><blockquote><p>生活中有很多信息適合使用浮點型數據來表示，比如：人的體重(單位：公斤)、商品價格、圓周率等等。</p></blockquote><p>因為精度的不同又分為3種(float,double,long double)：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/237453a08a264c1db16b7244d9767e0d><p class=pgc-img-caption></p></div><p>注：<strong>C語言中不存在字符串變量，字符串只能存在字符數組中,</strong>這個後面會講。</p><h3 class=pgc-h-arrow-right>格式化輸出語句</h3><p>格式化輸出語句，也可以說是<strong>佔位輸出</strong>，是將各種類型的數據按照<strong>格式化後的類型及指定的位置</strong>從計算機上顯示。</p><p>其格式為：printf("輸出格式符"，輸出項);</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5facc9b978044f57a4dbf1adcd685e24><p class=pgc-img-caption></p></div><p>當輸出語句中包含普通字符時，可以採用一下格式：</p><pre><code>printf("普通字符輸出格式符", 輸出項);</code></pre><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4fea654394264cdaaaeb21441f0bb648><p class=pgc-img-caption></p></div><p>注意：<strong>格式符</strong>的<strong>個數</strong>要與<strong>變量、常量或者表達式的個數一</strong>一對應</p><h3 class=pgc-h-arrow-right>不可改變的常量</h3><p>在程序執行過程中，值不發生改變的量稱為<strong>常量</strong>。</p><p>mtianyan: C語言的常量可以分為<strong>直接常量和符號常量。</strong></p><ul><li>直接常量也稱為<strong>字面量</strong>，是可以直接拿來使用，無需說明的量，比如：</li><ul><li>整型常量：13、0、-13；</li><li>實型常量：13.33、-24.4；</li><li>字符常量：‘a’、‘M’</li><li>字符串常量：”I love imooc!”</li></ul></ul><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/072461dd8df64b4fab0b1087d4d2557a><p class=pgc-img-caption></p></div><p>在C語言中，可以<strong>用一個標識符來表示一個常量，稱之為符號常量。</strong>符號常量在<strong>使用之前必須先定義</strong>，其一般形式為：</p><pre><code>#define 標識符 常量值</code></pre><pre><code>#include &lt;stdio.h&gt;#define POCKETMONEY 10    //定義常量及常量值int main(){    // POCKETMONEY = 12;  //小明私自增加零花錢對嗎？    printf("小明今天又得到%d元零花錢\n", POCKETMONEY);    return 0;  }</code></pre><p>符號常量不可以被改變。</p><h3 class=pgc-h-arrow-right>自動類型轉換</h3><p>數據類型存在自動轉換的情況.自動轉換髮生在<strong>不同數據類型</strong>運算時，在編譯的時候<strong>自動完成</strong>。</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b47f508e016d4445b29d5de4f72db695><p class=pgc-img-caption></p></div><p>char類型數據轉換為int類型數據遵循ASCII碼中的對應值.</p><p><strong>注:</strong></p><blockquote><p>字節小的可以向字節大的自動轉換，但字節大的不能向字節小的自動轉換</p></blockquote><blockquote><p>char可以轉換為int，int可以轉換為double，char可以轉換為double。但是不可以反向。</p></blockquote><h3 class=pgc-h-arrow-right>強制類型轉換</h3><p>強制類型轉換是通過<strong>定義類型轉換運算</strong>來實現的。其一般形式為：</p><pre><code>(數據類型) (表達式)</code></pre><p>其作用是把表達式的運算結果強制轉換成<strong>類型說明符所表示的類型</strong></p><p><strong>在使用強制轉換時應注意以下問題：</strong></p><ol start=1><li>數據類型和表達式都必須加括號, 如把(int)(x/2+y)寫成(int)x/2+y則成了把x轉換成int型之後再除2再與y相加了。</li><li><strong>轉換後不會改變原數據的類型及變量值，只在本次運算中臨時性轉換</strong>。</li><li>強制轉換後的運算結果<strong>不遵循四捨五入</strong>原則。</li></ol><h3 class=pgc-h-arrow-right>運算符號</h3><p>C語言中運算符:</p><pre><code>※ 算術運算符※ 賦值運算符※ 關係運算符※ 邏輯運算符※ 三目運算符</code></pre><h4 class=pgc-h-arrow-right>算術運算符</h4><p>c語言<strong>基本運算符:</strong></p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4947fae8ac7745028edf1c404e4751ed><p class=pgc-img-caption></p></div><p><strong>除法</strong>運算中<strong>注意</strong>：</p><blockquote><p>如果相除的兩個數都是整數的話，則結果也為整數，<strong>小數部分省略</strong>，如8/3 = 2;</p></blockquote><blockquote><p>而兩數中有一個為小數，結果則為小數，如：9.0/2 = 4.500000。</p></blockquote><p>mtianyan: <strong>取餘</strong>運算中<strong>注意</strong>：</p><blockquote><p>該運算只適合用<strong>兩個整數</strong>進行取餘運算，如：10%3 = 1；</p></blockquote><blockquote><p>mtianyan: notes: 而10.0%3則是錯誤的；<strong>運算後的符號取決於被模數的符號</strong>，如(-10)%3 = -1;而10%(-3) = 1;</p></blockquote><p>mtianyan: %%表示這裡就是一個%符.</p><p>注：<strong>C語言中沒有乘方這個運算符</strong>，也不能用×, ÷等算術符號。</p><h4 class=pgc-h-arrow-right>自增與自減運算符</h4><ul><li>自增運算符為++，其功能是使變量的值自增1</li><li>自減運算符為--，其功能是使變量值自減1。</li></ul><p>它們經常使用在循環中。自增自減運算符有以下幾種形式：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9715cef84ff542b8a6368ccb956341b0><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>賦值運算符</h4><p>C語言中賦值運算符分為<strong>簡單賦值運算符</strong>和<strong>複合賦值運算符</strong></p><p>簡單賦值運算符=號了，下面講一下複合賦值運算符：</p><p>複合賦值運算符就是在簡單賦值符=之前加上其它運算符構成.</p><blockquote><p>例如+=、-=、*=、/=、%=</p></blockquote><p>分析：定義整型變量a並賦值為3，a += 5;這個算式就等價於a = a+5; 將變量a和5相加之後再賦值給a</p><p>注意：複合運算符中<strong>運算符和等號</strong>之間是<strong>不存在空格</strong>的。</p><h4 class=pgc-h-arrow-right>關係運算符</h4><p>C語言中的<strong>關係運算符</strong>:</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/170eeaed56084ea79851ebfe27f0e2b8><p class=pgc-img-caption></p></div><p>關係表達式的值是真和假，在C程序用整數1和0表示。</p><p>注意：>=, &lt;=, ==, !=這種符號之間<strong>不能存在空格</strong>。</p><h4 class=pgc-h-arrow-right>邏輯運算符</h4><p>C語言中的邏輯運算符:</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de86e60568124b7292230ca1b3e1f092><p class=pgc-img-caption></p></div><p>邏輯運算的值也是有兩種分別為真和假，C語言中用整型的1和0來表示。其求值規則如下：</p><ul><li>與運算 &&</li></ul><blockquote><p>參與運算的兩個變量都為真時，結果才為真，否則為假。例如：5>=5 && 7>5 ，運算結果為真；</p></blockquote><ul><li>或運算 ||</li></ul><blockquote><p>參與運算的兩個變量只要有一個為真，結果就為真。兩個量都為假時，結果為假。例如：5>=5||5>8，運算結果為真；</p></blockquote><ul><li>非運算!</li></ul><blockquote><p>參與運算的變量為真時，結果為假；參與運算量為假時，結果為真。例如：!(5>8)，運算結果為真。</p></blockquote><h4 class=pgc-h-arrow-right>三目運算符</h4><p>C語言中的三目運算符：?:，其格式為：</p><pre><code>表達式1 ? 表達式2 : 表達式3;</code></pre><p>執行過程是：</p><blockquote><p>先判斷表達式1的值是否為真，如果是真的話執行表達式2；如果是假的話執行表達式3。</p></blockquote><pre><code>       #include &lt;stdio.h&gt;int main(){    //定義小編兜裡的錢    double money =12.0      ;     //定義打車回家的費用    double cost =11.5       ;      printf("小編能不能打車回家呢：");     //輸出y小編就打車回家了，輸出n小編就不能打車回家    printf("%c\n",money&gt;=cost?'y':'n'                        );    return 0;}   </code></pre><h4 class=pgc-h-arrow-right>運算符大比拼之優先級比較</h4><p>各種運算符號的順序:</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d12fef8bed384dc1a6d37f8de783adb9><p class=pgc-img-caption></p></div><p><strong>優先級別為1的優先級最高</strong>，優先級別為10的優先級別最低。</p><h3 class=pgc-h-arrow-right>分支結構之簡單if語句</h3><p>C語言中的分支結構語句中的if條件語句。</p><p>簡單if語句的基本結構如下：</p><pre><code>if(表達式){執行代碼塊;}</code></pre><p>其語義是：如果表達式的值為真，則執行其後的語句，否則不執行該語句。</p><p>注意：if()後面沒有分號，直接寫{}</p><h3 class=pgc-h-arrow-right>分支結構之簡單if-else語句</h3><p>簡單的if-else語句的基本結構:</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0bf23afc70b443a297b531f7deb0d219><p class=pgc-img-caption></p></div><p>語義是: 如果表達式的值為真，則執行代碼塊1，否則執行代碼塊2。</p><p><strong>注意：</strong></p><blockquote><p>if()後面沒有分號，直接寫{},else後面也沒有分號，直接寫{}</p></blockquote><h3 class=pgc-h-arrow-right>分支結構之多重if-else語句</h3><p>C語言中多重if-else語句，其結構如下：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c928e3c2f1994aa6a2d13440221cb9a4><p class=pgc-img-caption></p></div><p>語義是：依次判斷表達式的值，當出現某個值為真時，則執行對應代碼塊，否則執行代碼塊n。</p><p>注意：<strong>當某一條件為真的時候，則不會向下執行該分支結構的其他語句。</strong></p><h3 class=pgc-h-arrow-right>分支結構之嵌套if-else語句</h3><p>C語言中嵌套if-else語句。嵌套if-else語句的意思，就是在if-else語句中，再寫if-else語句。其一般形式為：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa4ff0c30ca34e4d986800746c49d6a8><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>循環結構之while循環</h3><p>反覆不停的執行某個動作就是江湖人稱的<strong>循環</strong> 。</p><p>C語言中有<strong>三種</strong>循環結構,先看一下C語言while循環的結構</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8836bc2f7d734fd18d1a0d5f212acb55><p class=pgc-img-caption></p></div><p>其中表達式表示<strong>循環條件</strong>，執行代碼塊為<strong>循環體</strong>。</p><blockquote><p>while語句的語義是：計算表達式的值，當值為真(非0)時， 執行循環體代碼塊。</p></blockquote><ol start=1><li>while語句中的表達式一般是關係表達或邏輯表達式，當表達式的值為假時不執行循環體，反之則循環體一直執行。</li><li>一定要記著在循環體中改變循環變量的值，否則會出現死循環（無休止的執行）。</li><li>循環體如果包括有一個以上的語句，則必須用{}括起來，組成複合語句。</li></ol><h3 class=pgc-h-arrow-right>循環結構之do-while循環</h3><p>C語言中的do-while循環，一般形式如下：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e9f0a15bab664fedb9cd140238802300><p class=pgc-img-caption></p></div><p>do-while循環語句的語義是:</p><blockquote><p>它先執行循環中的執行代碼塊，然後再判斷while中表達式是否為真，如果為真則繼續循環；如果為假，則終止循環。因此，<strong>do-while循環至少要執行一次循環語句</strong>。</p></blockquote><p>注意：mtianyan: 使用do-while結構語句時，<strong>while括號後必須有分號。</strong></p><h3 class=pgc-h-arrow-right>循環結構之for循環(一)</h3><p>c語言中<strong>for循環</strong>一般形式：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7b7e24de84a14380b1d2a64624f1bd79><p class=pgc-img-caption></p></div><p>它的執行過程如下：</p><ol start=1><li>執行表達式1，對循環變量做初始化；</li><li>判斷表達式2，若其值為<strong>真(非0)</strong>，則執行for循環體中執行代碼塊，然後向下執行；若其值為<strong>假(0)</strong>，則結束循環;</li><li>執行表達式3，(i++)等對於循環變量進行操作的語句;</li><li>執行for循環中執行代碼塊後執行第二步;第一步初始化只會執行一次。</li><li>循環結束，程序繼續向下執行。</li></ol><p>注意：for循環中的<strong>兩個分號</strong>一定要寫</p><h3 class=pgc-h-arrow-right>循環結構之for循環(二)</h3><p>在for循環中:</p><ul><li>表達式1是一個或多個<strong>賦值語句</strong>，它用來控制變量的<strong>初始值</strong>；</li><li>表達式2是一個<strong>關係表達式</strong>，它決定什麼時候退出循環；</li><li>表達式3是<strong>循環變量的步進值</strong>，定義控制循環變量每循環一次後按什麼方式變化。</li><li>這三部分之間用分號 ; 分開。</li></ul><p>使用for語句應該<strong>注意</strong>：</p><ol start=1><li>for循環中的“表達式1、2、3”均可不寫為空，但兩個分號(;;)不能缺省。</li><li>省略“表達式1（循環變量賦初值）”，表示<strong>不對循環變量賦初始值。</strong></li><li>省略“表達式2(循環條件)”，不做其它處理，循環一直執行（<strong>死循環</strong>）。</li><li>省略“表達式3(<strong>循環變量增減量</strong>)”，不做其他處理，循環一直執行（死循環）。</li><li>表達式1可以是設置循環變量的初值的賦值表達式，<strong>也可以是其他表達式</strong>。</li><li>表達式1和表達式3可以是一個簡單表達式也可以是多個表達式以逗號分割。</li><li>表達式2一般是<strong>關係表達式</strong>或<strong>邏輯表達式</strong>，但也可是數值表達式或字符表達式，<strong>只要其值非零</strong>，就執行循環體。</li><li>各表達式中的變量一定要在for循環<strong>之前定義</strong>。</li></ol><h4 class=pgc-h-arrow-right>怎麼獲得一個數的百位，十位和個位</h4><ul><li>百位數：num/100 可以獲得，因為 int 是整數型，小數部分會省略。比如 765/100 的結果是7</li><li>十位數：num%100/10 。比如765%100先得到65，65/10得到6</li><li>個位數：num%10。765%10得到5</li></ul><h3 class=pgc-h-arrow-right>循環結構之三種循環比較</h3><p>while, do-while和for三種循環在具體的使用場合上是有區別的，如下：</p><blockquote><p>在<strong>知道循環次數</strong>的情況下更適合使用for循環;</p></blockquote><ol start=1><li>在不知道循環次數的情況下適合使用while或者do-while循環:</li></ol><ul><li>如果有可能一次都不循環應考慮使用while循環</li><li>如果至少循環一次應考慮使用do-while循環。</li></ul><p>但是從本質上講，while,do-while和for循環之間是可以相互轉換的。</p><h3 class=pgc-h-arrow-right>循環結構之多重循環</h3><p><strong>多重循環</strong>就是在<strong>循環結構的循環體中又出現循環結構。</strong></p><p>在實際開發中一般最多用到<strong>三層重循環</strong>。</p><blockquote><p>因為循環層數越多，運行時間越長，程序越複雜，所以一般用2-3層多重循環就可以了。另外不同循環之間也是可以嵌套的。</p></blockquote><p>多重循環在執行的過程中，外層循環為<strong>父循環</strong>，內層循環為<strong>子循環</strong>，</p><blockquote><p><strong>父循環一次，子循環需要全部執行完，直到跳出循環。</strong>父循環再進入下一次，子循環繼續執行...</p></blockquote><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/09dbc76d5f844ef5b3ee397fdaca26ad><p class=pgc-img-caption></p></div><p>mtianyan: 打印三角形星星堆</p><pre><code>       #include &lt;stdio.h&gt;int main(){    int i, j, k;    for(i=1; i&lt;5; i++)    {        /* 觀察每行的空格數量，補全循環條件 */        for(j=i; j&lt;5; j++)          {            printf(" ");    //輸出空格        }        /* 觀察每行*號的數量，補全循環條件 */        for( k=0;k&lt;2*i-1;k++)         {            printf("*");   //每行輸出的*號        }        printf("\n");     //每次循環換行    }    return 0;}   </code></pre><h3 class=pgc-h-arrow-right>使用for循環打印9×9乘法表</h3><pre><code>#include &lt;stdio.h&gt;int main() {     // 定義相乘數字i,j以及結果result    int i, j, result;     for(i=9;i&gt;=1;i--)     {        for(j=1;j&lt;=i;j++)        {            printf("%d*%d=%d ",i,j,result=i*j);        }        printf("\n");     }    return 0;}</code></pre><h3 class=pgc-h-arrow-right>結束語句之break語句</h3><p>那麼循環5次的時候，需要中斷不繼續訓練。在C語言中，可以使用break語句進行該操作.</p><p>使用break語句時注意以下幾點：</p><blockquote><p>在沒有循環結構的情況下，break不能用在單獨的if-else語句中。</p></blockquote><ol start=1><li>在多層循環中，一個break語句只跳出當前循環。</li></ol><h3 class=pgc-h-arrow-right>結束語句之continue語句</h3><p>那麼循環5次的時候，需要中斷後繼續訓練。在C語言中，可以使用continue語句進行該操作</p><blockquote><p>continue語句的作用是結束本次循環開始執行下一次循環。</p></blockquote><p>break語句與continue語句的區別是:</p><blockquote><p>break是跳出當前整個循環，continue是結束本次循環開始下一次循環。</p></blockquote><h3 class=pgc-h-arrow-right>分支結構之switch語句</h3><p>switch語句結構如下:</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b713c16acba4220bd18d90dcd0f1a6a><p class=pgc-img-caption></p></div><p>mtianyan: switch語句時還應<strong>注意</strong>以下幾點：</p><ol start=1><li>在case後的各<strong>常量表達式</strong>的值不能相同，否則會出現錯誤。</li><li>在case子句後如果沒有<strong>break</strong>;會一直往後執行<strong>一直到遇到break;</strong>才會跳出switch語句。</li><li>switch後面的表達式語句只能是<strong>整型</strong>或者<strong>字符類型</strong>。</li><li>在case後，允許有多個語句，<strong>可以不用{}</strong>括起來。</li><li>各case和default子句的先後順序可以變動，而不會影響程序執行結果。</li><li>default子句可以省略不用。</li></ol><h3 class=pgc-h-arrow-right>mtianyan: switch與if語句的應用(計算是該年的第幾天)</h3><pre><code>       #include &lt;stdio.h&gt;int main() {     /* 定義需要計算的日期 */    int date = 0;    int year = 2008;    int month = 8;    int day = 8;    switch(month)    {        case 12:date+=30;        case 11:date+=31;        case 10:date+=30;        case 9:date+=31;        case 8:date+=31;        case 7:date+=30;        case 6:date+=31;        case 5:date+=30;        case 4:date+=31;        case 3:        if((year%4==0&amp;&amp;year%100!=0)||year%400==0)        {            date+=29;        }        else        {            date+=28;        }        case 2:        date+=31;        case 1:        date+=day;        printf("%d年%d月%d日是該年的第%d天",year,month,day,date);        break;        default:        printf("error");        break;    }    return 0;}   </code></pre><p>正確: continue只能用在循環體內</p><h3 class=pgc-h-arrow-right>臭名遠揚之goto語句</h3><p>C語言中也有這樣的語句，就是goto語句，goto語句是一種<strong>無條件分支</strong>語句.</p><blockquote><p>goto 語句的使用格式為：</p></blockquote><pre><code>goto 語句標號;</code></pre><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6d86876cb65d43c88e32a9749f7452a4><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>自創函數</h3><p>C語言提供了大量的庫函數: 比如stdio.h提供輸出函數</p><p>自定義函數的一般形式：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbf901a245454162be7404f50cc6b5b0><p class=pgc-img-caption></p></div><p><strong>注意：</strong></p><ol start=1><li>[] 包含的內容可以省略，數據類型說明省略，默認是 int 類型函數; 參數省略表示該函數是<strong>無參函數</strong>，參數不省略表示該函數是<strong>有參函數</strong>;</li><li>函數名稱遵循<strong>標識符命名規範；</strong></li><li>mtianyan: 自定義函數儘量放在 main 函數之前，如果要<strong>放在main函數後面的話</strong>, 需要在main函數之前<strong>先聲明</strong>自定義函數，聲明格式為：</li></ol><pre><code>[數據類型說明] 函數名稱（[參數]）;</code></pre><h3 class=pgc-h-arrow-right>函數調用</h3><p>我們需要用到自定義的函數的時候，就得調用它，那麼在調用的時候就稱之為<strong>函數調用</strong>。</p><p>在C語言中，函數調用的一般形式為：</p><pre><code>函數名（[參數]）;</code></pre><p>注意：</p><blockquote><p>對無參函數調用的時候可以將[]包含的省略。</p></blockquote><ol start=1><li>[]中可以是<strong>常數，變量或其它構造類型數據及表達式,</strong>多個參數之間用逗號分隔。</li></ol><h3 class=pgc-h-arrow-right>有參與無參</h3><p>在函數中不需要函數參數的稱之為<strong>無參函數</strong>，在函數中需要函數參數的稱之為<strong>有參函數。</strong></p><p>有參和無參函數的一般形式如下：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f564c8bffe64d3ab3d33c1e513002bc><p class=pgc-img-caption></p></div><p>有參函數和無參函數的<strong>唯一區別</strong>在於：函數 () 中多了一個參數列表。</p><ul><li>有參函數更為靈活，輸出的內容可以隨著n的改變而隨意變動，只要在main函數中傳遞一個參數就可以了</li><li>而在無參函數中輸出的相對就比較固定，當需要改動的時候還需要到自定義的方法內改變循環變量的值。</li></ul><h3 class=pgc-h-arrow-right>mtianyan: 形參與實參</h3><p>函數的參數分為<strong>形參</strong>和<strong>實參</strong>兩種。</p><ul><li><strong>形參</strong>是在定義函數名和函數體的時候使用的參數,目的是用來接收調用該函數時傳入的參數。</li></ul><blockquote><p>就類似小明，說了的話而不實際行動；</p></blockquote><ul><li><strong>實參</strong>是在調用時傳遞該函數的參數。</li></ul><blockquote><p>就如小剛能實際行動起來。</p></blockquote><p>函數的<strong>形參和實參</strong>具有以下特點：</p><ul><li>形參只有在被調用時才分配內存單元，在調用結束時，即刻釋放所分配的內存單元。因此，形參只有在函數內部有效。</li></ul><blockquote><p>函數調用結束返回主調函數後則不能再使用該形參變量。</p></blockquote><ul><li>實參可以是常量、變量、表達式、函數等。</li></ul><blockquote><p>無論實參是何種類型的量，在進行函數調用時，它們都必須具有<strong>確定的值</strong>，以便把這些值傳送給形參。因此應預先用賦值等辦法使實參獲得確定值。</p></blockquote><ul><li>在參數傳遞時，實參和形參在數量上，類型上，順序上應嚴格一致，否則會發生<strong>類型不匹配</strong>的錯誤。</li></ul><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8095fe7783cc490889fdff0d52743284><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>函數的返回值</h3><p>函數的<strong>返回值</strong>是指函數被調用之後，<strong>執行函數體中的程序段所取得的並返回給主調函數的值。</strong></p><p>函數的返回值要注意以下幾點：</p><ul><li>函數的值只能通過return語句返回主調函數。</li></ul><blockquote><p>return語句的一般形式為:</p></blockquote><pre><code>return 表達式 或者為：return (表達式);</code></pre><ul><li>函數值的<strong>類型</strong>和函數定義中<strong>函數的類型</strong>應保持一致。</li></ul><blockquote><p>notes: 如果兩者不一致，則以函數返回類型為準，自動進行類型轉換。</p></blockquote><ul><li><strong>沒有返回值</strong>的函數，<strong>返回類型</strong>為 void。</li></ul><p><strong>注意：</strong></p><blockquote><p>void 函數中可以有執行代碼塊，但是不能有返回值.</p></blockquote><blockquote><p>mtianyan: void函數中如果有return語句，該語句<strong>只能起到結束函數運行的功能。</strong>其格式為: return;</p></blockquote><h3 class=pgc-h-arrow-right>遞歸函數（一）</h3><p>遞歸就是一個函數在它的<strong>函數體內調用它自身。</strong></p><p>執行遞歸函數將反覆調用其自身，每調用一次就進入新的一層。</p><blockquote><p>注意遞歸函數必須有結束條件</p></blockquote><h3 class=pgc-h-arrow-right>遞歸函數（二）</h3><p>5的階乘這個例子進行一下剖析，看一看他的運算過程：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/20abc7f4e8be402d8107547cb7901d73><p class=pgc-img-caption></p></div><p>程序在計算5的階乘的時候，先執行遞推，當n=1或者n=0的時候返回1，再回推將計算並返回。由此可以看出遞歸函數必須有結束條件。</p><p>遞歸函數特點：</p><ol start=1><li>每一級函數調用時都有自己的變量，但是函數代碼並不會得到複製，如計算5的階乘時每遞推一次變量都不同；</li><li>每次調用都會有一次返回，如計算5的階乘時每遞推一次都返回進行下一次；</li><li>遞歸函數中，位於遞歸調用前的語句和各級被調用函數具有相同的執行順序；</li><li>遞歸函數中，位於遞歸調用後的語句的執行順序和各個被調用函數的順序相反；</li><li>遞歸函數中必須有終止語句。</li></ol><p>一句話總結遞歸：自我調用且有完成狀態</p><blockquote><p>任務<br>猴子第一天摘下N個桃子，當時就吃了一半，還不過癮，就又多吃了一個。第二天又將剩下的桃子吃掉一半，又多吃了一個。以後每天都吃前一天剩下的一半零一個。到第10天在想吃的時候就剩一個桃子了,問第一天共摘下來多少個桃子？並反向打印每天所剩桃子數。</p></blockquote><pre><code>       #include &lt;stdio.h&gt;int getPeachNumber(int n)  {    int num;        if(n==10)    {       return 1;          }     else    {        num = (getPeachNumber(n+1)+1)*2;          printf("第%d天所剩桃子%d個\n", n, num);     }    return num;}int main(){    int num = getPeachNumber(1);    printf("猴子第一天摘了:%d個桃子。\n", num);    return 0;}   </code></pre><h3 class=pgc-h-arrow-right>遞歸demo。</h3><p>有5個人坐在一起，問第5個人多少歲？他說比第4個人大2歲。問第4個人歲數，他說比第3個人大2歲。問第3個人，又說比第2人大兩歲。問第2個人，說比第1個人大兩歲。最後 問第1個人，他說是10歲。請問第5個人多大？</p><blockquote><p>程序分析：<br>利用遞歸的方法，遞歸分為回推和遞推兩個階段。要想知道第5個人歲數，需知道第4人的歲數，依次類推，推到第1人（10歲），再往回推。</p></blockquote><pre><code>       #include &lt;stdio.h&gt; int dfs(int n) {    return n == 1 ? 10 : dfs(n - 1) + 2;}int main() {    printf("第5個人的年齡是%d歲", dfs(5));     return 0;}    </code></pre><h3 class=pgc-h-arrow-right>局部與全局</h3><p>C語言中的變量，按作用域範圍可分為兩種，即局部變量和全局變量。</p><ul><li>局部變量也稱為內部變量。局部變量是在函數內作定義說明的。其作用域僅限於函數內， 離開該函數後再使用這種變量是非法的。在複合語句中也可定義變量，其作用域只在複合語句範圍內。</li><li>全局變量也稱為外部變量，它是在函數外部定義的變量。它不屬於哪一個函數，它屬於一個源程序文件。其作用域是整個源程序。</li></ul><h3 class=pgc-h-arrow-right>變量存儲類別</h3><p>mtianyan: C語言根據變量的生存週期來劃分，可以分為靜態存儲方式和動態存儲方式。</p><ul><li>靜態存儲方式：是指在程序運行期間分配固定的存儲空間的方式。靜態存儲區中存放了在整個程序執行過程中都存在的變量，如全局變量。</li><li>動態存儲方式：是指在程序運行期間根據需要進行動態的分配存儲空間的方式。動態存儲區中存放的變量是根據程序運行的需要而建立和釋放的，通常包括：函數形式參數；自動變量；函數調用時的現場保護和返回地址等。</li></ul><p>C語言中存儲類別又分為四類：</p><ul><li>自動（auto）、</li><li>靜態（static）、</li><li>寄存器的（register）</li><li>外部的（extern）。</li></ul><p>1、用關鍵字auto定義的變量為自動變量，auto可以省略，auto不寫則隱含定為“自動存儲類別”，屬於動態存儲方式。如：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cbfd6b5258e4ac190f5b91b651aee6e><p class=pgc-img-caption></p></div><p>2、用static修飾的為靜態變量，如果定義在函數內部的，稱之為靜態局部變量；如果定義在函數外部，稱之為靜態外部變量。如下為靜態局部變量：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8a97d885e32450b92e03727682ff874><p class=pgc-img-caption></p></div><p>注意：靜態局部變量屬於靜態存儲類別，在靜態存儲區內分配存儲單元，在程序整個運行期間都不釋放；靜態局部變量在編譯時賦初值，即只賦初值一次；如果在定義局部變量時不賦初值的話，則對靜態局部變量來說，編譯時自動賦初值0（對數值型變量）或空字符（對字符變量）。</p><p>3、為了提高效率，C語言允許將局部變量得值放在CPU中的寄存器中，這種變量叫“寄存器變量”，用關鍵字register作聲明。例如：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bd82f86f7cce438d865b605f9d41f262><p class=pgc-img-caption></p></div><p>mtianyan: 注意：只有局部自動變量和形式參數可以作為寄存器變量；一個計算機系統中的寄存器數目有限，不能定義任意多個寄存器變量；<strong>局部靜態變量不能定義為寄存器變量。</strong></p><p>4、用extern聲明的的變量是外部變量，外部變量的意義是某函數可以調用在該函數之後定義的變量。如：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/05960f7bef39467c876093298819dbd2><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>內部函數與外部函數</h3><ul><li>在C語言中不能被其他源文件調用的函數稱為內部函數 ，內部函數由static關鍵字來定義，因此又被稱謂靜態函數，形式為：<br>static [數據類型] 函數名（[參數]）</li><li>這裡的static是對函數的作用範圍的一個限定，限定該函數只能在其所處的源文件中使用，因此在不同文件中出現相同的函數名稱的內部函數是沒有問題的。</li><li>在C語言中能被其他源文件調用的函數稱為外部函數 ，外部函數由extern關鍵字來定義，形式為：<br>extern [數據類型] 函數名([參數])</li><li>C語言規定，在沒有指定函數的作用範圍時，系統會默認認為是外部函數，因此當需要定義外部函數時extern也可以省略。</li></ul><p>靜態變量只賦值一次</p><h3 class=pgc-h-arrow-right>外部函數練習</h3><p>hello.c</p><pre><code>#include &lt;stdio.h&gt;#include "test.c"   //引用test.c文件extern void printLine()     //這裡定義的方法對嗎？{   printf("**************\n");   }int main(){    say();    return 0;}</code></pre><p>test.c</p><pre><code>       #include &lt;stdio.h&gt;void printLine();static void say(){printLine();printf("I love imooc\n");printf("good good study!\n");printf("day day up!\n");printLine();}   </code></pre><p>對於hello.c來說，直接引入了test.c文件。那麼就可以調用testc中的static方法say()<br>而對於test.c並沒有引入，可以通過聲明來調用另一個源文件中暴露出來的方法。</p><h3 class=pgc-h-arrow-right>綜合練習</h3><blockquote><p>北京市出租車打車計費規則如下：</p></blockquote><ol start=1><li>每公里單價計費2.3元</li><li>起步價13元(包含3公里)</li><li>晚上23點(含)至次日凌晨5點(不含)打車，每公里單價計費加收20%。</li><li>每次乘車加收1元錢的燃油附加稅。<br>小明每天上下班都要打車，公司和家的距離為12公里，上午上班時間為9點，下午下班時間為6點。<br>請編寫一個小程序計算小明每天打車的總費用。</li></ol><pre><code>#include &lt;stdio.h&gt;float taxifee(int clock,int miles){    float money;    if(miles&lt;=3)    {        money=14;        printf("費用為14\n");    }    else    {        if(clock&gt;=23 || clock&lt;5)        {            money=13+1+2.3*(miles-3)*1.2;            printf("夜間車費為：%f\n",money);        }        else        {            money=13+1+2.3*(miles-3);            printf("日間車費為：%f\n",money);        }    }    return money;    }int main(){    printf("打的總費用：%.1f\n",taxifee(9,12)+taxifee(18,12));    return 0;}</code></pre><h3 class=pgc-h-arrow-right>數組初體驗</h3><p>程序中也需要容器，只不過該容器有點特殊，它在程序中是一塊<strong>連續的，大小固定並且裡面的數據類型一致的內存空間</strong>，它還有個好聽的名字叫數組。可以將數組理解為大小固定，所放物品為同類的一個購物袋，在該購<br>物袋中的物品是按一定順序放置的。</p><p>我們來看一下如何聲明一個數組：</p><pre><code>數據類型 數組名稱[長度];</code></pre><p>數組只聲明也不行啊，看一下數組是如何初始化的。說到初始化，C語言中的數組初始化是有三種形式的，分別是：</p><ol start=1><li>數據類型 數組名稱[長度n] = {元素1,元素2…元素n};</li><li>數據類型 數組名稱[] = {元素1,元素2…元素n};</li><li>數據類型 數組名稱[長度n]; 數組名稱[0] = 元素1; 數組名稱[1] = 元素2; 數組名稱[n-1] = 元素n;</li></ol><p>我們將數據放到數組中之後又如何獲取數組中的元素呢？</p><blockquote><p>獲取數組元素時：數組名稱[元素所對應下標];</p></blockquote><p>如：初始化一個數組 int arr[3] = {1,2,3}; 那麼arr[0]就是元素1。</p><p>注意：</p><ol start=1><li>數組的下標均以<strong>0開始</strong>；</li><li>數組在初始化的時候，數組內元素的個數不能大於聲明的數組長度；</li><li>mtianyan: 如果採用第一種初始化方式，<strong>元素個數小於數組的長度時，多餘的數組元素初始化為0；</strong></li><li>在聲明數組後沒有進行初始化的時候，<strong>靜態（static）和外部（extern）類型的數組元素初始化元素為0</strong>，自動（auto）類型的數組的元素初始化值不確定。</li></ol><h3 class=pgc-h-arrow-right>數組的遍歷</h3><p>數組就可以採用循環的方式將每個元素遍歷出來，而不用人為的每次獲取指定某個位置上的元素，例如我們用for循環遍歷一個數組：</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2b674994f4bb451493197e42eb6de6e0><p class=pgc-img-caption></p></div><p>注意以下幾點：</p><ol start=1><li>最好<strong>避免出現數組越界訪問</strong>，循環變量最好不要超出數組的長度.</li><li><strong>C語言的數組長度一經聲明，長度就是固定，無法改變</strong>，並且<strong>C語言並不提供計算數組長度的方法</strong>。</li></ol><p>由於C語言是沒有檢查數組長度改變或者數組越界的這個機制，可能會在編輯器中編譯並通過，但是結果就不能肯定了，因此還是不要越界或者改變數組的長度</p><p>c語言獲取數組長度</p><pre><code>       int length = sizeof(arr)/sizeof(arr[0]);   </code></pre><h3 class=pgc-h-arrow-right>數組作為函數參數</h3><p>數組可以由整個數組當作函數的參數，也可以由數組中的某個元素當作函數的參數：</p><ol start=1><li>整個數組當作函數參數，即把<strong>數組名稱傳入函數</strong>中，例如：</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f59d65d6f3324bfcace6b46ce7addccb><p class=pgc-img-caption></p></div><ol start=1><li>數組中的元素當作函數參數，即把數組中的參數傳入函數中，例如：</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/386ddfc3174d4956923dfd9206db5519><p class=pgc-img-caption></p></div><p>數組作為函數參數時注意以下事項：</p><ol start=1><li>數組名作為函數實參傳遞時，函數定義處作為接收參數的數組類型形參既可以指定長度也可以不指定長度。</li><li>數組元素作為函數實參傳遞時，數組元素類型必須與形參數據類型一致。</li></ol><h3 class=pgc-h-arrow-right>mtianyan: 數組的應用（一）[冒泡排序]</h3><p>以升序排序為例冒泡排序的思想：相鄰元素兩兩比較，將較大的數字放在後面，直到將所有數字全部排序。就像小學排隊時按大小個排一樣，將一個同學拉出來和後面的比比，如果高就放後面，一直把隊伍排好。</p><pre><code>#include &lt;stdio.h&gt;int main(){    double arr[]={1.78, 1.77, 1.82, 1.79, 1.85, 1.75, 1.86, 1.77, 1.81, 1.80};    int i,j;    printf("\n************排隊前*************\n");    for(i=0;i&lt;10;i++)    {        if(i != 9)               printf("%1.2f, ", arr[i]);  //%1.2f表示小數點前一位，小數點後精確到兩位        else            printf("%1.2f", arr[i]);    //%1.2f表示小數點前一位，小數點後精確到兩位    }    for(i=8; i&gt;=0; i--)    {        for(j=0;j&lt;=i;j++)        {            if( arr[j]&gt;arr[j+1])      //當前面的數比後面的數大時            {                double temp;    //定義臨時變量temp                temp=arr[j];//將前面的數賦值給temp                arr[j]=arr[j+1];             //前後之數顛倒位置                arr[j+1]=temp;//將較大的數放在後面                }                         }                    }    printf("\n************排隊後*************\n");    for(i=0;i&lt;10;i++)    {        if(i != 9)               printf("%1.2f, ", arr[i]);  //%1.2f表示小數點前一位，小數點後精確到兩位             else            printf("%1.2f", arr[i]);    //%1.2f表示小數點前一位，小數點後精確到兩位    }    return 0;    }</code></pre><h3 class=pgc-h-arrow-right>數組的應用（二）[數組查找功能]</h3><p>當我們購物之後，拎著購物袋回到家，會一一檢查購物袋中的物品看是否缺少或者都是想購之物。</p><p>那麼應用到程序中，可以使用數組查找功能，看看是否存在該數據，如果存在並返回該元素的下標。</p><pre><code>       #include &lt;stdio.h&gt;int getIndex(int arr[5],int value){    int i;    int index;    for(i=0;i&lt;5;i++)    {       /* 請完善數組查詢功能 */       if(arr[i]==value)        {            index=i;            break;        }         index=-1;    }    return index;}int main(){    int arr[5]={3,12,9,8,6};    int value = 8;    int index = getIndex(arr,value);      //這裡應該傳什麼參數呢？    if(index!=-1)    {        printf("%d在數組中存在，下標為：%d\n",value,index);                 }    else    {        printf("%d在數組中不存在。\n",value);        }    return 0;    }   </code></pre><h3 class=pgc-h-arrow-right>字符串與數組</h3><p>C語言中，是沒有辦法直接定義字符串數據類型的，但是我們可以使用數組來定義我們所要的字符串。一般有以下兩種格式：</p><ol start=1><li>char 字符串名稱[長度] = "字符串值";</li><li>char 字符串名稱[長度] = {'字符1','字符2',...,'字符n','\0'};</li></ol><p>注意：</p><ol start=1><li>[]中的長度是可以省略不寫的；</li><li>採用第2種方式的時候最後一個元素必須是'\0'，'\0'表示字符串的結束標誌；</li><li>採用第2種方式的時候在數組中不能寫中文。<br>在輸出字符串的時候要使用：printf(“%s”,字符數組名字);或者puts(字符數組名字);。</li></ol><h3 class=pgc-h-arrow-right>mtianyan:字符串函數</h3><p>常用的字符串函數如下(strlen,strcmp,strcpy,strcat,atoi):</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b04bd99cfa74a3e9bd63f5d05b26c7b><p class=pgc-img-caption></p></div><p>使用字符串函數注意以下事項：</p><ol start=1><li>strlen()獲取字符串的長度，在字符串長度中是不包括‘\0’而且漢字和字母的長度是不一樣的。比如：</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15910a76d8384296988b7507909fefc2><p class=pgc-img-caption></p></div><ol start=1><li>strcmp()在比較的時候會把字符串先轉換成ASCII碼再進行比較,返回的結果為0表示s1和s2的ASCII碼相等,返回結果為1表示s1比s2的ASCII碼大,返回結果為-1表示s1比s2的ASCII碼小，例如：</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b4ba259be1d4283933be29cc3795adb><p class=pgc-img-caption></p></div><ol start=1><li>strcpy()拷貝之後會覆蓋原來字符串且不能對字符串常量進行拷貝，比如：</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/628bae550fe14c0ba3a22e19c4378582><p class=pgc-img-caption></p></div><ol start=1><li>strcat在使用時s1與s2指的內存空間不能重疊，且s1要有足夠的空間來容納要複製的字符串，如：</li></ol><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cc52ed4f18174a00b39f189b7746a92b><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>多維數組</h3><p>多維數組的定義格式是：<br>數據類型 數組名稱[常量表達式1][常量表達式2]...[常量表達式n];</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4219da922b7a419bb1af061b2e353205><p class=pgc-img-caption></p></div><p>定義了一個名稱為num，數據類型為int的二維數組。其中第一個[3]表示第一維下標的長度，就像購物時分類存放的購物；第二個[3]表示第二維下標的長度，就像每個購物袋中的元素。</p><div class=pgc-img><img alt=請收藏C語言最全入門筆記 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f3613d32e0b74511bf3d84a36e7a702c><p class=pgc-img-caption></p></div><p>多維數組的初始化與一維數組的初始化類似也是分兩種：</p><ol start=1><li>數據類型 數組名稱[常量表達式1][常量表達式2]...[常量表達式n] = {{值1,..,值n},{值1,..,值n},...,{值1,..,值n}};</li><li>數據類型 數組名稱[常量表達式1][常量表達式2]...[常量表達式n]; 數組名稱[下標1][下標2]...[下標n] = 值;</li></ol><p>多維數組初始化要注意以下事項：</p><ol start=1><li>採用第一種始化時數組聲明必須指定列的維數。<strong>mtianyan: 因為系統會根據數組中元素的總個數來分配空間，當知道元素總個數以及列的維數後，會直接計算出行的維數；</strong></li><li>採用第二種初始化時數組聲明必須同時指定行和列的維數。</li></ol><p><strong>二維數組定義的時候，可以不指定行的數量，但是必須指定列的數量</strong></p><blockquote><p>二維數組定義的時候，可以不指定行的數量，但是必須指定列的數量。</p></blockquote><h3 class=pgc-h-arrow-right>多維數組的遍歷</h3><p>多維數組也是存在遍歷的，和一維數組遍歷一樣，也是需要用到循環。不一樣的就是多維數組需要採用嵌套循環。</p><p>注意：多維數組的每一維下標均不能越界。</p><h3 class=pgc-h-arrow-right>綜合練習：</h3><pre><code>       #include &lt;stdio.h&gt;#define N 10//打印分數 void printScore(int score[]){    int i;    printf("\n");    for(i=0;i&lt;N;i++)    {        printf("%d ",score[i]);                   }    printf("\n");     }//計算考試總分 int getTotalScore(int score[]){    int sum = 0;    int i;    for(i=0;i&lt;N;i++)    {        sum+=score[i];                    }     return sum;}//計算平均分 int getAvgScore(int score[]){    return getTotalScore(score)/N;   }//計算最高分 int getMax(int score[]){    int max = -1;    int i;    for(i=0;i&lt;N;i++)    {        if(score[i]&gt;max)        {            max = score[i];                      }                    }     return max;}//計算最低分 int getMin(int score[]){    int min =100;    int i;    for(i=0;i&lt;N;i++)    {        if(score[i]&lt; min)        {            min = score[i];                      }                    }     return min;}//分數降序排序 void sort(int score[]){    int i,j;    for(i=N-2;i&gt;=0;i--)    {        for(j=0;j&lt;=i;j++)        {            if(score[j]&lt;score[j+1])            {                int temp;                temp = score[j];                score[j] = score[j+1];                 score[j+1]=temp;                              }                         }                       }    printScore(score);     }int main(){    int score[N]={67,98,75,63,82,79,81,91,66,84};    int sum,avg,max,min;    sum = getTotalScore(score);    avg = getAvgScore(score);    max = getMax(score);    min = getMin(score);    printf("總分是：%d\n",sum);    printf("平均分是：%d\n",avg);    printf("最高分是：%d\n",max);    printf("最低分是：%d\n",min);    printf("----------成績排名---------\n");    sort(score);    return 0;    }</code></pre><p class=pgc-end-literature>電子芯吧客轉載文章！</p><p class=pgc-end-literature><br></p><p>更多幹貨請關注電子芯吧客微信公眾號！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>語言</a></li><li><a>入門</a></li><li><a>筆記</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html alt="Java入門 - 語言基礎 - 18.正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ddf3412c71244bcaa3cb911e988fed3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html title="Java入門 - 語言基礎 - 18.正則表達式">Java入門 - 語言基礎 - 18.正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a0e9a5a9.html alt=「C語言筆記」assert怎麼用？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0816bedea8784129bb9a4b65f01dc337 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a0e9a5a9.html title=「C語言筆記」assert怎麼用？>「C語言筆記」assert怎麼用？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4547cff.html alt="賽爾筆記 | 自然語言處理中的遷移學習(下)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RfXcGOlHDeeb4s style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4547cff.html title="賽爾筆記 | 自然語言處理中的遷移學習(下)">賽爾筆記 | 自然語言處理中的遷移學習(下)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4829ec8a.html alt=一文讓你入門NLP自然語言處理，看不懂你來找我 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e0409d62-8a85-4eee-848a-f939a843c1db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4829ec8a.html title=一文讓你入門NLP自然語言處理，看不懂你來找我>一文讓你入門NLP自然語言處理，看不懂你來找我</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d74ece6.html alt=C語言編程入門必做的76題（加速你的學習效率） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/76e1f716eb894036a029992b044b5036 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d74ece6.html title=C語言編程入門必做的76題（加速你的學習效率）>C語言編程入門必做的76題（加速你的學習效率）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/daee4c3b.html alt=C語言編程筆記丨利用C語言寫一個小程序——胖胖的愛心桃 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df26c625ad3d44d4b515522c28f5462c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/daee4c3b.html title=C語言編程筆記丨利用C語言寫一個小程序——胖胖的愛心桃>C語言編程筆記丨利用C語言寫一個小程序——胖胖的愛心桃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b754ba6.html alt="C語言編程筆記丨編寫第一個C語言程序'hello world'，我教你哇" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ad42f4fc-8976-4d2d-81e8-c62c3808e213 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b754ba6.html title="C語言編程筆記丨編寫第一個C語言程序'hello world'，我教你哇">C語言編程筆記丨編寫第一個C語言程序'hello world'，我教你哇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7bac32b6.html alt=入門人工智能語言Python需要哪些環境？內附學習資料 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/56810002ea180fcf9671 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7bac32b6.html title=入門人工智能語言Python需要哪些環境？內附學習資料>入門人工智能語言Python需要哪些環境？內附學習資料</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/eb1a626a.html alt=區塊鏈安全入門筆記彙編版，一文了解20種名詞解釋及26種攻擊方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153820081912869d8e48468 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/eb1a626a.html title=區塊鏈安全入門筆記彙編版，一文了解20種名詞解釋及26種攻擊方式>區塊鏈安全入門筆記彙編版，一文了解20種名詞解釋及26種攻擊方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6033abd.html alt=自然語言處理入門：簡單，快速和深入 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e8a2f1a7e8df45669983281db34d6099 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6033abd.html title=自然語言處理入門：簡單，快速和深入>自然語言處理入門：簡單，快速和深入</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc67b78.html alt=NLP入門之形式語言與自動機學習(二) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1c31fa6e79384589a883165f82068cd1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc67b78.html title=NLP入門之形式語言與自動機學習(二)>NLP入門之形式語言與自動機學習(二)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/75994ab.html alt=C語言快速入門——邏輯運算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/845b60261a8c4358ae2dc374bd22b29b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/75994ab.html title=C語言快速入門——邏輯運算>C語言快速入門——邏輯運算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html alt=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13adbab9c7f94c7fa81d49a98861b051 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html title=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式>機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html alt=什麼是梯度：用形象的語言解讀梯度的本質原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/557c7b377c5449bb885df35b2d354e03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html title=什麼是梯度：用形象的語言解讀梯度的本質原理>什麼是梯度：用形象的語言解讀梯度的本質原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>