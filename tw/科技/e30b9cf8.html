<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一年半經驗，百度、有贊、阿里面試總結 | 极客快訊</title><meta property="og:title" content="一年半經驗，百度、有贊、阿里面試總結 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e30b9cf8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e30b9cf8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e30b9cf8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e30b9cf8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e30b9cf8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e30b9cf8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e30b9cf8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e30b9cf8.html><meta property="article:published_time" content="2020-11-14T21:05:38+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:38+08:00"><meta name=Keywords content><meta name=description content="一年半經驗，百度、有贊、阿里面試總結"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e30b9cf8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一年半經驗，百度、有贊、阿里面試總結</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>作者：<strong>_</strong>楊溜溜 版權歸原作者</p><p>來源：https://segmentfault.com/a/1190000017049146</p></blockquote><h1>前言</h1><p>人家都說，前端需要每年定期出來面面試，衡量一下自己當前的技術水平以及價值，本人17年7月份，畢業到現在都沒出來試過，也沒很想換工作，就出來試試，看看自己水平咋樣。</p><p>以下為我現場面試時候的一些回答，部分因人而異的問題我就不回答了，回答的都為參考答案，也有部分錯誤的地方或者不好的地方，有更好的答案的可以在評論區評論。</p><p>百度 WEB前端工程師 連續五面 全程3約個小時</p><p>一面</p><p>先完成筆試題</p><ol><li>實現一個函數，判斷輸入是不是迴文字符串。</li></ol><pre>function run(input) { if (typeof input !== 'string') return false; return input.split('').reverse().join('') === input;}</pre><ol><li>兩種以上方式實現已知或者未知寬度的垂直水平居中。</li></ol><pre>// 1.wraper { position: relative; .box { position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; margin: -50px 0 0 -50px; }}// 2.wraper { position: relative; .box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }}// 3.wraper { .box { display: flex; justify-content:center; align-items: center; height: 100px; }}// 4.wraper { display: table; .box { display: table-cell; vertical-align: middle; }}</pre><ol><li>實現效果，點擊容器內的圖標，圖標邊框變成border 1px solid red，點擊空白處重置。</li></ol><pre>const box = document.getElementById('box');function isIcon(target) { return target.className.includes('icon');}box.onClick = function(e) { e.stopPropagation(); const target = e.target; if (isIcon(target)) { target.style.border = '1px solid red'; }}const doc = document;doc.onclick = function(e) { const children = box.children; for(let i; i &lt; children.length; i++) { if (isIcon(children[i])) { children[i].style.border = 'none'; } }}</pre><ol><li>請簡單實現雙向數據綁定mvvm。</li></ol><pre>&lt;input id="input"/&gt;const data = {};const input = document.getElementById('input');Object.defineProperty(data, 'text', { set(value) { input.value = value; this.value = value; }});input.onChange = function(e) { data.text = e.target.value;}</pre><ol><li>實現Storage，使得該對象為單例，並對localStorage進行封裝設置值setItem(key,value)和getItem(key)</li></ol><pre>var instance = null;class Storage { static getInstance() { if (!instance) { instance = new Storage(); } return instance; } setItem = (key, value) =&gt; localStorage.setItem(key, value), getItem = key =&gt; localStorage.getItem(key)}</pre><blockquote><p>Q1 你的技術棧主要是react，那你說說你用react有什麼坑點？</p></blockquote><p>1、JSX做表達式判斷時候，需要強轉為boolean類型，如：</p><pre>render() { const b = 0; return &lt;div&gt; { !!b &amp;&amp; &lt;div&gt;這是一段文本&lt;/div&gt; } &lt;/div&gt;}</pre><p>如果不使用 !!b 進行強轉數據類型，會在頁面裡面輸出 0。</p><p>2、儘量不要在 componentWillReviceProps 裡使用 setState，如果一定要使用，那麼需要判斷結束條件，不然會出現無限重渲染，導致頁面崩潰。</p><p>3、給組件添加ref時候，儘量不要使用匿名函數，因為當組件更新的時候，匿名函數會被當做新的prop處理，讓ref屬性接受到新函數的時候，react內部會先清空ref，也就是會以null為回調參數先執行一次ref這個props，然後在以該組件的實例執行一次ref，所以用匿名函數做ref的時候，有的時候去ref賦值後的屬性會取到null。</p><p>詳情見</p><p>4、遍歷子節點的時候，不要用 index 作為組件的 key 進行傳入。</p><blockquote><p>Q2 我現在有一個button，要用react在上面綁定點擊事件，要怎麼做？</p></blockquote><pre>class Demo { render() { return &lt;button onClick={(e) =&gt; { alert('我點擊了按鈕') }}&gt; 按鈕 &lt;/button&gt; }}</pre><blockquote><p>Q3 接上一個問題，你覺得你這樣設置點擊事件會有什麼問題嗎？</p></blockquote><p>由於onClick使用的是匿名函數，所有每次重渲染的時候，會把該onClick當做一個新的prop來處理，會將內部緩存的onClick事件進行重新賦值，所以相對直接使用函數來說，可能有一點的性能下降（個人認為）。</p><p>修改</p><pre>class Demo { onClick = (e) =&gt; { alert('我點擊了按鈕') } render() { return &lt;button onClick={this.onClick}&gt; 按鈕 &lt;/button&gt; }}</pre><p>當然你在內部聲明的不是箭頭函數，然後你可能需要在設置onClick的時候使用bind綁定上下文，這樣的效果和先前的使用匿名函數差不多，因為bind會返回新的函數，也會被react認為是一個新的prop。</p><blockquote><p>Q4 你說說event loop吧</p></blockquote><p>首先，js是單線程的，主要的任務是處理用戶的交互，而用戶的交互無非就是響應DOM的增刪改，使用事件隊列的形式，一次事件循環只處理一個事件響應，使得腳本執行相對連續，所以有了事件隊列，用來儲存待執行的事件，那麼事件隊列的事件從哪裡被push進來的呢。那就是另外一個線程叫事件觸發線程做的事情了，他的作用主要是在定時觸發器線程、異步HTTP請求線程滿足特定條件下的回調函數push到事件隊列中，等待js引擎空閒的時候去執行，當然js引擎執行過程中有優先級之分，首先js引擎在一次事件循環中，會先執行js線程的主任務，然後會去查找是否有微任務microtask（promise），如果有那就優先執行微任務，如果沒有，在去查找宏任務macrotask（setTimeout、setInterval）進行執行。</p><blockquote><p>Q5 說說事件流吧</p></blockquote><p>事件流分為兩種，捕獲事件流和冒泡事件流。</p><p>捕獲事件流從根節點開始執行，一直往子節點查找執行，直到查找執行到目標節點。</p><p>冒泡事件流從目標節點開始執行，一直往父節點冒泡查找執行，直到查到到根節點。</p><p>事件流分為三個階段，一個是捕獲節點，一個是處於目標節點階段，一個是冒泡階段。</p><blockquote><p>Q6 我現在有一個進度條，進度條中間有一串文字，當我的進度條覆蓋了文字之後，文字要與進度條反色，怎麼實現？</p></blockquote><p>。。。當時我給的是js的方案，在進度條寬度變化的時候，計算蓋過每一個文字的50%，如果超過，設置文字相反顏色。</p><p>當然css也有對應的方案，也就是 mix-blend-mode，我並沒有接觸過。</p><p>對應html也有對應方案，也就設置兩個相同位置但是顏色相反的dom結構在重疊在一起，頂層覆蓋底層，最頂層的進度條取overflow為hidden，其寬度就為進度。</p><p>二面</p><blockquote><p>Q1 你為什麼要離開上一家公司？</p></blockquote><p>-</p><blockquote><p>Q2 你覺得理想的前端地位是什麼？</p></blockquote><p>-</p><blockquote><p>Q3 那你意識到問題所在，你又嘗試過解決問題嗎？</p></blockquote><p>-</p><p>三面</p><blockquote><p>Q1 說一下你上一家公司的一個整體開發流程吧</p></blockquote><p>-</p><blockquote><p>Q2 react 的虛擬dom是怎麼實現的</p></blockquote><p>首先說說為什麼要使用Virturl DOM，因為操作真實DOM的耗費的性能代價太高，所以react內部使用js實現了一套dom結構，在每次操作在和真實dom之前，使用實現好的diff算法，對虛擬dom進行比較，遞歸找出有變化的dom節點，然後對其進行更新操作。為了實現虛擬DOM，我們需要把每一種節點類型抽象成對象，每一種節點類型有自己的屬性，也就是prop，每次進行diff的時候，react會先比較該節點類型，假如節點類型不一樣，那麼react會直接刪除該節點，然後直接創建新的節點插入到其中，假如節點類型一樣，那麼會比較prop是否有更新，假如有prop不一樣，那麼react會判定該節點有更新，那麼重渲染該節點，然後在對其子節點進行比較，一層一層往下，直到沒有子節點。</p><blockquote><p>Q3 react 的渲染過程中，兄弟節點之間是怎麼處理的？也就是key值不一樣的時候。</p></blockquote><p>通常我們輸出節點的時候都是map一個數組然後返回一個ReactNode，為了方便react內部進行優化，我們必須給每一個reactNode添加key，這個key prop在設計值處不是給開發者用的，而是給react用的，大概的作用就是給每一個reactNode添加一個身份標識，方便react進行識別，在重渲染過程中，如果key一樣，若組件屬性有所變化，則react只更新組件對應的屬性；沒有變化則不更新，如果key不一樣，則react先銷燬該組件，然後重新創建該組件。</p><blockquote><p>Q4 我現在有一個數組[1,2,3,4]，請實現算法，得到這個數組的全排列的數組，如[2,1,3,4]，[2,1,4,3]。。。。你這個算法的時間複雜度是多少</p></blockquote><p>這個我沒寫出來，大概給了個思路，將每一個數組拆除倆個小數組進行求它的全排列，然後得到的結果互相之間又進行全排列，然後把最後的結果連接起來。。。</p><p>感興趣的同學見數組全排列</p><blockquote><p>Q5 我現在有一個揹包，容量為m，然後有n個貨物，重量分別為w1,w2,w3...wn，每個貨物的價值是v1,v2,v3...vn，w和v沒有任何關係，請求揹包能裝下的最大價值。</p></blockquote><p>這個我也沒寫出來，也給了個思路，首先使用Q4的方法得到貨物重量數組的全組合（包括拆分成小數組的全組合），然後計算每一個組合的價值，並進行排序，然後遍歷數組，找到價值較高切剛好能裝進揹包m的組合。</p><p>本題動態規劃面試題，感興趣的同學請自行百度或者谷歌。</p><p>四面</p><blockquote><p>Q1 請說一下你的上一家公司的研發發佈流程。</p></blockquote><p>-</p><blockquote><p>Q2 你說一下webpack的一些plugin，怎麼使用webpack對項目進行優化。</p></blockquote><p>正好最近在做webpack構建優化和性能優化的事兒，當時吹了大概15~20分鐘吧，插件請見webpack插件歸納總結。</p><p>構建優化</p><p>1、減少編譯體積 ContextReplacementPugin、IgnorePlugin、babel-plugin-import、babel-plugin-transform-runtime。</p><p>2、並行編譯 happypack、thread-loader、uglifyjsWebpackPlugin開啟並行</p><p>3、緩存 cache-loader、hard-source-webpack-plugin、uglifyjsWebpackPlugin開啟緩存、babel-loader開啟緩存</p><p>4、預編譯 dllWebpackPlugin && DllReferencePlugin、auto-dll-webapck-plugin</p><p>性能優化</p><p>1、減少編譯體積 Tree-shaking、Scope Hositing。</p><p>2、hash緩存 webpack-md5-plugin</p><p>3、拆包 splitChunksPlugin、import()、require.ensure</p><blockquote><p>Q3 es6 class 的new實例和es5的new實例有什麼區別</p></blockquote><p>這個我覺得是一樣的（當時因為很少看babel編譯之後的結果），面試官說不一樣。。。後來我看了一下babel的編譯結果，發現只是類的方法聲明的過程不一樣而已，最後new的結果是一樣的。。。具體答案現在我也不知道。。。</p><blockquote><p>Q4 看你簡歷上寫了canvas，你說一下為什麼canvas的圖片為什麼過有跨域問題。</p></blockquote><p>canvas圖片為什麼跨域我不知道，至今沒查出來，也差不多，大概跨域原因和瀏覽器跨域的原因是一樣的吧。</p><blockquote><p>Q5 我現在有一個canvas，上面隨機布著一些黑塊，請實現方法，計算canvas上有多少個黑塊。</p></blockquote><p>使用getImageData獲取像素數組，然後遍歷數組，把在遍歷節點的過程中，查看節點上下左右的像素顏色是否相同，如果相同，然後設置標識，最後groupBy一下所有像素。（這是我當時的方案）</p><p>其他更好的答案見地址</p><blockquote><p>Q6 請手寫實現一個promise</p></blockquote><p>這個就不寫了，詳情見promise實現原理</p><p>注：四面是一個超級可愛的小姐姐，電腦給我讓我寫完之後，我說我寫得差不多了，然後電腦給她，然後她竟然默默的在看我的代碼，嘗試尋找我的思路，也沒有問我實現思路是啥，然後我就問她，你不應該是讓我給你解釋我的代碼思路嗎。。。你竟然在嘗試尋找我的思路，我自己都不知道我自己是思路是啥。。。然後我兩都笑了，哈哈哈。最後結束的時候我說我午飯還沒吃，她還叫了另外一個小哥哥先帶了下去吃飯，真是一個善良的小姐姐，非常感謝。</p><p>五面</p><blockquote><p>Q1 你說一下你的技術有什麼特點</p></blockquote><p>-</p><blockquote><p>Q2 說一下你覺得你最得意的一個項目？你這個項目有什麼缺陷，弊端嗎？</p></blockquote><p>-</p><blockquote><p>Q3 現在有那麼一個團隊，假如讓你來做技術架構，你會怎麼做？</p></blockquote><p>考慮到團隊每一個前端的技術棧可能不一致，這個時候我可能選擇微前端架構，讓每個人負責的模塊可以單獨開發，單獨部署，單獨回滾，不依賴於其他項目模塊，在儘可能的情況下節約團隊成員之間的學習成本，當然這肯定也有缺點，那就是每個模塊都需要一個前端項目，單獨部署，單獨回滾無疑也加大了運維成本。</p><blockquote><p>Q4 說一下你上一家公司的主要業務流程，你參與到其中了嗎？</p></blockquote><p>-</p><h1>杭州有贊</h1><p>一面 WEB前端工程師 電話面 全程43分鐘</p><blockquote><p>Q1 自我介紹</p></blockquote><p>-</p><blockquote><p>Q2 說說從輸入URL到看到頁面發生的全過程，越詳細越好。</p></blockquote><ol><li>首先瀏覽器主進程接管，開了一個下載線程。</li><li>然後進行HTTP請求（DNS查詢、IP尋址等等），中間會有三次捂手，等待響應，開始下載響應報文。</li><li>將下載完的內容轉交給Renderer進程管理。</li><li>Renderer進程開始解析css rule tree和dom tree，這兩個過程是並行的，所以一般我會把link標籤放在頁面頂部。</li><li>解析繪製過程中，當瀏覽器遇到link標籤或者script、img等標籤，瀏覽器會去下載這些內容，遇到時候緩存的使用緩存，不適用緩存的重新下載資源。</li><li>css rule tree和dom tree生成完了之後，開始合成render tree，這個時候瀏覽器會進行layout，開始計算每一個節點的位置，然後進行繪製。</li><li>繪製結束後，關閉TCP連接，過程有四次揮手。</li></ol><blockquote><p>Q3 你剛剛說了三次握手，四次揮手，那你描述一下？</p></blockquote><p>本人對計算機網絡的這些概念一直不是很熟悉，所以這個問題回答不會，這裡mark下文章，感興趣的同學查看地址</p><blockquote><p>Q4 剛剛Q2中說的CSS和JS的位置會影響頁面效率，為什麼？</p></blockquote><p>css在加載過程中不會影響到DOM樹的生成，但是會影響到Render樹的生成，進而影響到layout，所以一般來說，style的link標籤需要儘量放在head裡面，因為在解析DOM樹的時候是自上而下的，而css樣式又是通過異步加載的，這樣的話，解析DOM樹下的body節點和加載css樣式能儘可能的並行，加快Render樹的生成的速度。</p><p>js腳本應該放在底部，原因在於js線程與GUI渲染線程是互斥的關係，如果js放在首部，當下載執行js的時候，會影響渲染行程繪製頁面，js的作用主要是處理交互，而交互必須得先讓頁面呈現才能進行，所以為了保證用戶體驗，儘量讓頁面先繪製出來。</p><blockquote><p>Q5 現在有一個函數A和函數B，請你實現B繼承A</p></blockquote><pre>// 方式1function B(){}function A(){}B.prototype = new A();// 方式2function A(){}function B(){ A.call(this);}// 方式3function B(){}function A(){}B.prototype = new A();function B(){ A.call(this);}</pre><blockquote><p>Q6 剛剛你在Q5中說的幾種繼承的方式，分別說說他們的優缺點</p></blockquote><p>方式1：簡單易懂，但是無法實現多繼承，父類新增原型方法/原型屬性，子類都能訪問到</p><p>方式2：可以實現多繼承，但是隻能繼承父類的實例屬性和方法，不能繼承原型屬性/方法</p><p>方式3：可以繼承實例屬性/方法，也可以繼承原型屬性/方法，但是示例了兩個A的構造函數</p><blockquote><p>Q7 說說CSS中幾種垂直水平居中的方式</p></blockquote><p>參考前面百度一面筆試題Q2</p><blockquote><p>Q8 Q7中說的flex佈局，垂直水平居中必須知道寬度嗎？</p></blockquote><p>是的，必須知道高度(腦子進水了回答了必須知道，其實答案是不需要知道高度的)</p><blockquote><p>Q9 描述一下this</p></blockquote><p>this，函數執行的上下文，可以通過apply，call，bind改變this的指向。對於匿名函數或者直接調用的函數來說，this指向全局上下文（瀏覽器為window，nodejs為global），剩下的函數調用，那就是誰調用它，this就指向誰。當然還有es6的箭頭函數，箭頭函數的指向取決於該箭頭函數聲明的位置，在哪裡聲明，this就指向哪裡。</p><blockquote><p>Q10 說一下瀏覽器的緩存機制</p></blockquote><p>瀏覽器緩存機制有兩種，一種為強緩存，一種為協商緩存。</p><p>對於強緩存，瀏覽器在第一次請求的時候，會直接下載資源，然後緩存在本地，第二次請求的時候，直接使用緩存。</p><p>對於協商緩存，第一次請求緩存且保存緩存標識與時間，重複請求向服務器發送緩存標識和最後緩存時間，服務端進行校驗，如果失效則使用緩存。</p><p>協商緩存方案</p><p>Exprires：服務端的響應頭，第一次請求的時候，告訴客戶端，該資源什麼時候會過期。Exprires的缺陷是必須保證服務端時間和客戶端時間嚴格同步。</p><p>Cache-control：max-age，表示該資源多少時間後過期，解決了客戶端和服務端時間必須同步的問題，</p><p>If-None-Match/ETag：緩存標識，對比緩存時使用它來標識一個緩存，第一次請求的時候，服務端會返回該標識給客戶端，客戶端在第二次請求的時候會帶上該標識與服務端進行對比並返回If-None-Match標識是否表示匹配。</p><p>Last-modified/If-Modified-Since：第一次請求的時候服務端返回Last-modified表明請求的資源上次的修改時間，第二次請求的時候客戶端帶上請求頭If-Modified-Since，表示資源上次的修改時間，服務端拿到這兩個字段進行對比。</p><blockquote><p>Q11 ETag是這個字符串是怎麼生成的？</p></blockquote><p>沒答出來，我當時猜是根據文件內容或者最後修改時間進行的加密算法。其實官方沒有明確指定生成ETag值的方法。 通常，使用內容的散列，最後修改時間戳的哈希值，或簡單地使用版本號。</p><blockquote><p>Q12 現在要你完成一個Dialog組件，說說你設計的思路？它應該有什麼功能？</p></blockquote><ol><li>該組件需要提供hook指定渲染位置，默認渲染在body下面。</li><li>然後改組件可以指定外層樣式，如寬度等</li><li>組件外層還需要一層mask來遮住底層內容，點擊mask可以執行傳進來的onCancel函數關閉Dialog。</li><li>另外組件是可控的，需要外層傳入visible表示是否可見。</li><li>然後Dialog可能需要自定義頭head和底部footer，默認有頭部和底部，底部有一個確認按鈕和取消按鈕，確認按鈕會執行外部傳進來的onOk事件，然後取消按鈕會執行外部傳進來的onCancel事件。</li><li>當組件的visible為true時候，設置body的overflow為hidden，隱藏body的滾動條，反之顯示滾動條。</li><li>組件高度可能大於頁面高度，組件內部需要滾動條。</li><li>只有組件的visible有變化且為ture時候，才重渲染組件內的所有內容。</li></ol><blockquote><p>Q13 你覺得你做過的你覺得最值得炫耀的項目？</p></blockquote><h1>螞蟻金服-體驗技術部 資深數據可視化研發工程師</h1><p>一面 電話面 全程1小時24分鐘</p><blockquote><p>Q1 描述一下你最近做的可視化的項目</p></blockquote><p>-</p><blockquote><p>Q2 剛剛說的java調用js離線生成數據報告？java調用js的promise異步返回結果怎麼實現的？</p></blockquote><p>使用java的js引擎Nashorn，Nashorn不支持事件隊列，是要引進polyfill，然後java調用js方法獲得java的promise對象，然後在調用該對象的then方法，回調函數為java中的某各類的某個方法，然後while一個表示是否已執行回調的變量，如果未執行，則讓java主線程sleep，如果已經執行，則跳出循環，表示是否已執行回調的變量在傳入promise的回調函數中設置更改。詳情代碼見地址</p><blockquote><p>Q3 說說svg和canvas各自的優缺點？</p></blockquote><p>共同點：都是有效的圖形工具，對於數據較小的情況下，都很又高的性能，它們都使用 JavaScript 和 HTML；它們都遵守萬維網聯合會 (W3C) 標準。</p><p>svg優點：</p><p>矢量圖，不依賴於像素，無限放大後不會失真。</p><p>以dom的形式表示，事件綁定由瀏覽器直接分發到節點上。</p><p>svg缺點：</p><p>dom形式，涉及到動畫時候需要更新dom，性能較低。</p><p>canvas優點：</p><p>定製型更強，可以繪製繪製自己想要的東西。</p><p>非dom結構形式，用JavaScript進行繪製，涉及到動畫性能較高。</p><p>canvas缺點：</p><p>事件分發由canvas處理，繪製的內容的事件需要自己做處理。</p><p>依賴於像素，無法高效保真，畫布較大時候性能較低。</p><blockquote><p>Q4 你剛剛說的canvas渲染較大畫布的時候性能會較低？為什麼？</p></blockquote><p>因為canvas依賴於像素，在繪製過程中是一個一個像素去繪製的，當畫布足夠大，像素點也就會足夠多，那麼想能就會足夠低。</p><blockquote><p>Q6 假設我現在有5000個圓，完全繪製出來，點擊某一個圓，該圓高亮，另外4999個圓設為半透明，分別說說用svg和canvas怎麼實現？</p></blockquote><p>首先，從數據出發，我們的每個圓是一個數據，這個數據有圓的x、y、radius、isHighlight如果是svg，直接渲染節點即可，然後往節點上邊綁定點擊事件，點擊改變所有數據的高亮屬性（必須同步執行完成），然後讓瀏覽器進行繪製。如果是canvas，我們需要自己綁定事件到canvans標籤上，然後點擊的時候判斷點擊的位置是否在圓內，如果在某個圓內，則更新所有數據的高亮屬性，之後在進行一次性繪製。</p><blockquote><p>Q7 剛剛說的canvas的點擊事件，怎麼樣實現？假如不是圓，這些圖形是正方形、長方形、規則圖形、不規則圖形呢。</p></blockquote><p>針對於每一個形狀，將其抽象成shape類，每一個類有自己的方法isPointInSide來判斷節點是否在圖形內，對於不規則圖形，當做矩形處理，點擊的時候執行該方法判斷點擊位置是否在圖形內。</p><blockquote><p>Q8 那假如我的圖形可能有變形、放大、偏移、旋轉的需求呢？你的這個isPointInSide怎麼處理？</p></blockquote><p>這個我答不出來，據面試官提示，好像有相應的API處理變形、旋轉、放大等等之後的位置映射關係。</p><blockquote><p>Q9 那個這個canvas的點擊事件，點擊的時候怎麼樣快速的從這5000個圓中找到你點擊的那個圓（不完全遍歷5000個節點）？</p></blockquote><p>可以通過預查找的形式，當鼠標劃過的時候預先查找到鼠標附近的一些節點，當點擊的時候在從這些預先篩選好的節點裡查找點擊下來的節點，當然這個方法的前提是不能影響js主線程的執行，必須是異步的形式。</p><blockquote><p>Q10 那你用過@antv/g6，裡面有一個tree，說說你大學時候接觸到的tree的數據結構是怎麼實現的？</p></blockquote><p>畢業一年多，tree的結構大概忘記了，我當時是這麼回答的：</p><p>大學使用的是C++學的數據結構，是用指針的形式，首先有一個根節點，根節點裡有一個指針數組指向它的所有子節點，然後每一個子節點也是，擁有著子節點的指針數組，一層一層往下，直到為葉子節點，指針數組指向為空。</p><blockquote><p>Q11 還記得二叉樹嗎？描述二叉樹的幾種遍歷方式？</p></blockquote><p>先序遍歷：若二叉樹非空，訪問根結點，遍歷左子樹，遍歷右子樹。</p><p>中序遍歷：若二叉樹非空，遍歷左子樹；訪問根結點；遍歷右子樹。</p><p>後序遍歷：若二叉樹非空，遍歷左子樹；遍歷右子樹；訪問根結點。</p><p>所有遍歷是以遞歸的形似，直到沒有子節點。</p><blockquote><p>Q12 說說你記得的所有的排序，他們的原理是什麼？</p></blockquote><p>冒泡排序：雙層遍歷，對比前後兩個節點，如果滿足條件，位置互換，直到遍歷結束。</p><p>快速排序：去數組中間的那一個數，然後遍歷所有數，小於該數的push到一個數組，大於該數的push到另外一個數組，然後遞歸去排序這兩個數組，最後將所有結果連接起來。</p><p>選擇排序：聲明一個數組，每次去輸入數組裡面找數組中的最大值或者最小值，取出來後push到聲明的數組中，直到輸入數組為空。</p><blockquote><p>Q13 說一下你覺得你做過的最複雜的項目？中間遇到的困難，以及你是怎麼解決的？</p></blockquote><hr><p>面試官：我這邊問題差不多問完了，你還有什麼問題？</p><p>我：很驚訝今天全都是問可視化相關的，沒怎麼問js，css，html。</p><p>面試官：那我們繼續吧</p><p>我：。。。</p><hr><blockquote><p>Q14 那給我介紹一下react吧（面試官是做可視化開發的，根本不懂react）</p></blockquote><p>以前我們沒有jquery的時候，我們大概的流程是從後端通過ajax獲取到數據然後使用jquery生成dom結果然後更新到頁面當中，但是隨著業務發展，我們的項目可能會越來越複雜，我們每次請求到數據，或則數據有更改的時候，我們又需要重新組裝一次dom結構，然後更新頁面，這樣我們手動同步dom和數據的成本就越來越高，而且頻繁的操作dom，也使我我們頁面的性能慢慢的降低。</p><p>這個時候mvvm出現了，mvvm的雙向數據綁定可以讓我們在數據修改的同時同步dom的更新，dom的更新也可以直接同步我們數據的更改，這個特定可以大大降低我們手動去維護dom更新的成本，mvvm為react的特性之一，雖然react屬於單項數據流，需要我們手動實現雙向數據綁定。</p><p>有了mvvm還不夠，因為如果每次有數據做了更改，然後我們都全量更新dom結構的話，也沒辦法解決我們頻繁操作dom結構(降低了頁面性能)的問題，為了解決這個問題，react內部實現了一套虛擬dom結構，也就是用js實現的一套dom結構，他的作用是講真實dom在js中做一套緩存，每次有數據更改的時候，react內部先使用算法，也就是鼎鼎有名的diff算法對dom結構進行對比，找到那些我們需要新增、更新、刪除的dom節點，然後一次性對真實DOM進行更新，這樣就大大降低了操作dom的次數。</p><p>那麼diff算法是怎麼運作的呢，首先，diff針對類型不同的節點，會直接判定原來節點需要卸載並且用新的節點來裝載卸載的節點的位置；針對於節點類型相同的節點，會對比這個節點的所有屬性，如果節點的所有屬性相同，那麼判定這個節點不需要更新，如果節點屬性不相同，那麼會判定這個節點需要更新，react會更新並重渲染這個節點。</p><p>react設計之初是主要負責UI層的渲染，雖然每個組件有自己的state，state表示組件的狀態，當狀態需要變化的時候，需要使用setState更新我們的組件，但是，我們想通過一個組件重渲染它的兄弟組件，我們就需要將組件的狀態提升到父組件當中，讓父組件的狀態來控制這兩個組件的重渲染，當我們組件的層次越來越深的時候，狀態需要一直往下傳，無疑加大了我們代碼的複雜度，我們需要一個狀態管理中心，來幫我們管理我們狀態state。</p><p>這個時候，redux出現了，我們可以將所有的state交給redux去管理，當我們的某一個state有變化的時候，依賴到這個state的組件就會進行一次重渲染，這樣就解決了我們的我們需要一直把state往下傳的問題。redux有action、reducer的概念，action為唯一修改state的來源，reducer為唯一確定state如何變化的入口，這使得redux的數據流非常規範，同時也暴露出了redux代碼的複雜，本來那麼簡單的功能，卻需要完成那麼多的代碼。</p><p>後來，社區就出現了另外一套解決方案，也就是mobx，它推崇代碼簡約易懂，只需要定義一個可觀測的對象，然後哪個組價使用到這個可觀測的對象，並且這個對象的數據有更改，那麼這個組件就會重渲染，而且mobx內部也做好了是否重渲染組件的生命週期shouldUpdateComponent，不建議開發者進行更改，這使得我們使用mobx開發項目的時候可以簡單快速的完成很多功能，連redux的作者也推薦使用mobx進行項目開發。但是，隨著項目的不斷變大，mobx也不斷暴露出了它的缺點，就是數據流太隨意，出了bug之後不好追溯數據的流向，這個缺點正好體現出了redux的優點所在，所以針對於小項目來說，社區推薦使用mobx，對大項目推薦使用redux。</p><blockquote><p>Q15 假如我一個組件有一個狀態count為1，然後我在componentDidMount()裡面執行執行了兩次this.setState({count: this.state.count++})，然後又執行了兩次setTimeout(() => { this.setState({count: this.state.count++}) }, 0)，最後count為多少？為什麼？</p></blockquote><p>count為4，因為第二次執行setState的時候，取不到第一次this.state.count++的結果，react在一輪生命週期結束後才會更新內部的state，如果在一輪生命週期內多次使用了setState，react內部會有一個字段isBatchUpdate標識本次更新為批量更新，然後在最後render的時候將所有setState的結果提交到state中，一次性進行更新，並且把isBatchUpdate這個字段設置為false。</p><p>針對於兩次setTimeout，js引擎會把這兩個setState丟到事件隊列中，等待js空閒了去執行，而我們的渲染函數render是同步執行的（react16版本默認沒有開啟異步渲染），所以等我們render執行完全，也就是我們的state被同步完後，在取事件隊列裡面的setState進行執行，setTimeout的第二個setState也是一樣的，所以最後結果是4。</p><blockquote><p>Q16 說一下你覺得你做過的最值得你說的吧</p></blockquote><p>-</p><h1>最後</h1><p>這幾輪面試的面試官都非常和藹好交流，百度的五輪面試不知道過了沒有，只記得五面的面試官說，你稍等一下，我去問一下其他人對你還有什麼其他要求，然後過了一會兒HR就喊我先回去了，叫我等HR面的消息，如果沒通過，也不會在聯繫我了，已經過了四天了，但願後面有消息吧。然後有贊、螞蟻金服的兩個一面都過了，因為每次面完試面試官問我還有什麼問題嗎？我都會詢問一下本次面試面試官對我的評論是啥。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>半經驗</a></li><li><a>有贊</a></li><li><a>試總結</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ea4180c.html alt=百度、有贊、阿里web前端開發工程師面試總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cfdc348831e745308ac815c8a192adaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ea4180c.html title=百度、有贊、阿里web前端開發工程師面試總結>百度、有贊、阿里web前端開發工程師面試總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>