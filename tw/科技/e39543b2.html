<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀 | 极客快訊</title><meta property="og:title" content="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/S4RDmAJA74o9GY"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><meta property="article:published_time" content="2020-11-14T20:59:53+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:53+08:00"><meta name=Keywords content><meta name=description content="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e39543b2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Flink 從入門到精通 系列文章</p><p>作者：<strong class=highlight-text toutiao-origin=span>逍凱</strong>，阿里雲數據庫實習開發工程師</p><p>注：以下分析基於開源 v19.15.2.2-stable 版本進行，社區最新版本代碼改動較大，但是總體思路是不變的。</p><p>01</p><p></p><h1 toutiao-origin=h2>用戶提交一條查詢SQL背後發生了什麼</h1><p>在傳統關係型數據庫中，SQL處理器的組件主要包括以下幾種：</p><p><strong>• Query Parsing</strong></p><p>負責進行詞法和語法分析,把程序從人類高可讀的格式(即SQL)轉化成機器高可讀的格式(AST,抽象語法樹)。</p><p>詞法分析指的是把SQL中的字符序列分解成一個個獨立的詞法單元——Token(&lt;類型，值>)。</p><p>語法分析指的是從詞法分析器輸出的token中識別各類短語，並構造出一顆抽象語法樹。而按照構造抽象語法樹的方向，又可以把語法分析分成自頂向下和自底向上分析兩種。而ClickHouse採用的則是手寫一個遞歸下降的語法分析器。</p><p><strong>• Query Rewrite</strong></p><p>即通常我們說的"Logical Optimizer"或基於規則的優化器(Rule-Based Optimizer,即RBO)。</p><p>其負責應用一些啟發式規則，負責簡化和標準化查詢，無需改變查詢的語義。</p><p>常見操作有:謂詞和算子下推，視圖展開，簡化常量運算表達式，謂詞邏輯的重寫，語義的優化等。</p><p><strong>• Query Optimizer</strong></p><p>即通常我們所說的"Physical Optimizer"，負責把內部查詢表達轉化成一個高效的查詢計劃，指導DBMS如何去取表，如何進行排序，如何Join。如下圖所示，一個查詢計劃可以被認為是一個數據流圖，在這個數據流圖中，表數據會像在管道中傳輸一樣，從一個查詢操作符(operator)傳遞到另一個查詢操作符。</p><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S4RDmAJA74o9GY><p>一個查詢計劃</p><p><strong>• Query Executor</strong></p><p>查詢執行器，負責執行具體的查詢計劃，從存儲引擎中獲取數據並且對數據應用查詢計劃得到結果。</p><p>執行引擎也分為很多種，如經典的火山模型(Volcano Model)，還有ClickHouse採用的向量化執行模型(Vectorization Model)。</p><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S4RDmBB8AKErrl><p>(圖來自經典論文 Architecture Of Database System)</p><p>但不管是傳統的關係型數據庫，還是非關係型數據庫，SQL的解析和生成執行計劃過程都是大同小異的，而縱覽ClickHouse的源代碼，可以把用戶提交一條查詢SQL背後的過程總結如下：</p><p>1.服務端接收客戶端發來的SQL請求，具體形式是一個網絡包，Server的協議層需要拆包把SQL解析出來</p><p>2.Server負責初始化上下文與Network Handler，然後 Parser 對Query做詞法和語法分析，解析成AST</p><p>3.Interpreter的 SyntaxAnalyzer 會應用一些啟發式規則對AST進行優化重寫</p><p>4.Interpreter的<strong toutiao-origin=span> ExpressionAnalyzer </strong>根據上下文信息以及優化重寫後的AST生成物理執行計劃</p><p>5.物理執行計劃分發到本地或者分佈式的executor,各自從存儲引擎中獲取數據,應用執行計劃</p><p>6.Server把執行後的結果以Block流的形式輸出到Socket緩衝區,Client從Socket中讀取即可得到結果</p><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S4RDmCJBLj2cxQ><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=span>01 接收客戶端請求</strong></h2><p>我們要以服務端的視角來出發，首先來看server.cpp大概做什麼事情:</p><p>下面只挑選重要的邏輯:</p><p>• 初始化上下文</p><p>• 初始化Zookeeper(ClickHouse的副本複製機制需要依賴ZooKeeper)</p><p>• 常規配置初始化</p><p>• 綁定服務端的端口，根據網絡協議初始化Handler，對客戶端提供服務</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>int Server::main<br>{<br>// 初始化上下文<br>global_context = std::make_unique&lt;Context&gt;(Context::createGlobal);<br>global_context-&gt;setApplicationType(Context::ApplicationType::SERVER);<br><br>// zk初始化<br>zkutil::ZooKeeperNodeCache main_config_zk_node_cache([&amp;] { return global_context-&gt;getZooKeeper; });<br><br>//其他config的初始化<br>//...<br><br>//綁定端口,對外提供服務<br>auto address = make_socket_address(host, port);<br>socket.bind(address, /* reuseAddress = */ true);<br><br>//根據網絡協議建立不同的server類型<br>//現在支持的server類型有：HTTP,HTTPS,TCP,Interserver,mysql<br>//以TCP版本為例:<br>create_server("tcp_port", [&amp;](UInt16 port)<br>{<br>Poco::Net::ServerSocket socket;<br>auto address = socket_bind_listen(socket, listen_host, port);<br>servers.emplace_back(std::make_unique&lt;Poco::Net::TCPServer&gt;(<br>new TCPHandlerFactory(*this),<br>server_pool,<br>socket,<br>new Poco::Net::TCPServerParams));<br>});<br><br>//啟動server<br>for (auto &amp; server : servers)<br>server-&gt;start;<br><br>}</code></p></pre><p>客戶端發來的請求是由各自網絡協議所對應的 Handler 來進行的，server在啟動的時候 Handler 會被初始化並綁定在指定端口中。我們以TCPHandler為例，看看服務端是如何處理客戶端發來的請求的，重點關注 <strong toutiao-origin=span>TCPHandler::runImpl</strong>的函數實現:</p><p>• 初始化輸入和輸出流的緩衝區</p><p>• 接受請求報文，拆包</p><p>• 執行Query(包括整個詞法語法分析，Query重寫，物理計劃生成和生成結果)</p><p>• 把Query結果保存到輸出流，然後發送到Socket的緩衝區，等待發送回客戶端</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>void TCPHandler::runImpl<br>{<br>//實例化套接字對應的輸入和輸出流緩衝區<br>in = std::make_shared&lt;ReadBufferFromPocoSocket&gt;(socket);<br>out = std::make_shared&lt;WriteBufferFromPocoSocket&gt;(socket);<br><br>while (1){<br>// 接收請求報文<br>receivePacket;<br><br>// 執行Query<br>state.io = executeQuery(state.query, *query_context, false, state.stage, may_have_embedded_data);<br><br>//根據Query種類來處理不同的Query<br>//處理insert Query<br>processInsertQuery;<br>//併發處理普通Query<br>processOrdinaryQueryWithProcessors;<br>//單線程處理普通Query<br>processOrdinaryQuery;<br>}<br><br>}</code></p></pre><p>那CK處理客戶端發送過來的Query的具體邏輯是怎樣的呢?</p><p>我們可以在</p><blockquote toutiao-origin=span>dbms/src/Interpreters/executeQuery.cpp</blockquote><p>中一探究竟:</p><p>具體邏輯在 executeQueryImpl 函數中,挑選核心的邏輯進行講解:</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>static std::tuple&lt;ASTPtr, BlockIO&gt; executeQueryImpl<br>{<br>//構造Parser<br>ParserQuery parser(end, settings.enable_debug_queries);<br>ASTPtr ast;<br><br>//把Query轉化為抽象語法樹<br>ast = parseQuery(parser, begin, end, "", max_query_size);<br><br>//生成interpreter實例<br>auto interpreter = InterpreterFactory::get(ast, context, stage);<br><br>// interpreter解析AST,結果是BlockIO<br>res = interpreter-&gt;execute;<br><br>//返回結果是抽象語法樹和解析後的結果組成的二元組<br>return std::make_tuple(ast, res);<br>}</code></p></pre><p>該函數所做的事情：</p><p>• 構建Parser,把Query解析成AST(抽象語法樹)</p><p>• InterpreterFactory根據AST生成對應的Interpreter實例</p><p>• AST是由Interpreter來解析的，執行結果是一個BlockIO,BlockIO是對 BlockInputStream 和 BlockOutputStream 的一個封裝。</p><p>總結:</p><p>• 服務端調用 executeQuery 來處理client發送的Query，執行後的結果保存在state這個結構體的io成員中。</p><p>每一條Query都會對應一個state結構體，記錄了這條Query的id，處理狀態，壓縮算法，Query的文本和Query所處理數據對應的IO流等元信息。</p><p>• 然後服務端調用 <strong toutiao-origin=span>processOrdinaryQuery </strong>等方法把輸出流結果封裝成異步的IO流，發送到回client。</p><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S4RDmCtDHj5504><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=span>02 解析請求(Parser)</strong></h2><p>CK選擇採用手寫一個遞歸下降的Parser來對SQL進行解析，生成的結果是這個SQL對應的抽象語法樹(AST),抽象語法樹由表示各個操作的節點(IAST)表示。而本節主要介紹Parser背後的核心邏輯:</p><p>詞法分析和語法分析的核心邏輯可以在parseQuery.cpp的 tryParseQuery 中一覽無餘。</p><p>該函數利用lexer將掃描Query字符流，將其分割為一個個的Token， token_iterator 即一個Token流迭代器，然後parser再對Token流進行解析生成AST抽象語法樹。</p><pre><p><code>ASTPtr tryParseQuery<br>{<br>//Token為lexer詞法分析後的基本單位,詞法分析後生成的是Token流<br>Tokens tokens(pos, end, max_query_size);<br>IParser::Pos token_iterator(tokens);<br>ASTPtr res;<br>//Token流經過語法分析生成AST抽象語法樹<br>bool parse_res = parser.parse(token_iterator, res, expected);<br>return res;<br><br>}</code></p></pre><p>我們可以看到,語法分析的核心就在於parser執行的parse方法。parse 方法具體的實現在 ParserQuery.cpp 的 parseImpl 中。</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>bool ParserQuery::parseImpl(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)<br>{<br>ParserQueryWithOutput query_with_output_p(enable_explain);<br>ParserInsertQuery insert_p(end);<br>ParserUseQuery use_p;<br>ParserSetQuery set_p;<br>ParserSystemQuery system_p;<br><br>bool res = query_with_output_p.parse(pos, node, expected)<br>|| insert_p.parse(pos, node, expected)<br>|| use_p.parse(pos, node, expected)<br>|| set_p.parse(pos, node, expected)<br>|| system_p.parse(pos, node, expected);<br><br>return res;<br>}</code></p></pre><p>我們可以看到,這個方法粗略地把Query分為了五種,但是本質上可以歸納為兩種(第一種為有結果輸出,對應show,select,create等語句;第二種為無結果輸出,對應insert,use,set和與系統相關的語句(如exit))</p><p>• QueryWithOutput</p><p>• InsertQuery</p><p>• UseQuery</p><p>• SetQuery</p><p>• SystemQuery</p><p>每一種Query都自定義了其專屬的Parser,所以代碼邏輯是當接收到一個Query輸入的時候，會嘗試各種Query的Parser，直到成功為止。</p><p>我們可以select語句對應的parser進行分析:</p><p>核心邏輯可以總結為：</p><p>1.先給出select語句中可能出現的關鍵詞</p><p>2.在詞法分析生成的Token流中爬取這些關鍵詞</p><p>3.如果成功爬取，則 setExpression 函數會組裝該關鍵字對應的AST節點</p><p>每一種SQL語句(如select,drop,insert,create)都有對應的AST類，並且分別包含了這些語句中特有的關鍵字。</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>bool ParserSelectQuery::parseImpl(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)<br>{<br>//創建AST樹節點<br>auto select_query = std::make_shared&lt;ASTSelectQuery&gt;;<br>node = select_query;<br><br>//select語句中會出現的關鍵詞<br>ParserKeyword s_select("SELECT");<br>ParserKeyword s_distinct("DISTINCT");<br>ParserKeyword s_from("FROM");<br>ParserKeyword s_prewhere("PREWHERE");<br>ParserKeyword s_where("WHERE");<br>ParserKeyword s_group_by("GROUP BY");<br>ParserKeyword s_with("WITH");<br>ParserKeyword s_totals("TOTALS");<br>ParserKeyword s_having("HAVING");<br>ParserKeyword s_order_by("ORDER BY");<br>ParserKeyword s_limit("LIMIT");<br>ParserKeyword s_settings("SETTINGS");<br>ParserKeyword s_by("BY");<br>ParserKeyword s_rollup("ROLLUP");<br>ParserKeyword s_cube("CUBE");<br>ParserKeyword s_top("TOP");<br>ParserKeyword s_with_ties("WITH TIES");<br>ParserKeyword s_offset("OFFSET");<br><br>//...<br>//依次對Token流爬取上述關鍵字<br>ParserTablesInSelectQuery.parse(pos, tables, expected)<br><br>//根據語法分析結果設置AST的Expression屬性,可以理解為如果SQL存在該關鍵字,這個關鍵字都會轉化為AST上的一個節點<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::WITH, std::move(with_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::SELECT, std::move(select_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::TABLES, std::move(tables));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::PREWHERE, std::move(prewhere_expression));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::WHERE, std::move(where_expression));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::GROUP_BY, std::move(group_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::HAVING, std::move(having_expression));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::ORDER_BY, std::move(order_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_BY_OFFSET, std::move(limit_by_offset));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_BY_LENGTH, std::move(limit_by_length));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_BY, std::move(limit_by_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_OFFSET, std::move(limit_offset));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_LENGTH, std::move(limit_length));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::SETTINGS, std::move(settings));<br><br>}</code></p></pre><p>整個Parser的流程圖：</p><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S4RDmDP1wXvGlS><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=strong>03 執行請求(Interpreter)</strong></h2><p>解釋器(Interpreter)負責從抽象語法樹中創建查詢執行的流水線，整條流水線以 BlockInputStream 和 BlockOutputStream 進行組織。比方說"select"是基於"from"的Block輸出流來進行選擇的，選擇後的結果也會以Block輸出流的形式輸出到結果。首先我們來看:</p><blockquote toutiao-origin=span>dbms/src/Interpreters/InterpreterFactory.cpp</blockquote><p>每一種Query都會有對應的Interpreter，這個工廠方法就是根據AST的種類來實例化其對應的Interpreter,由其來具體執行對應AST的執行計劃:</p><pre><p><code>std::unique_ptr&lt;IInterpreter&gt; InterpreterFactory::get(ASTPtr &amp; query, Context &amp; context, QueryProcessingStage::Enum stage)<br>{<br>//舉個例子,如果該AST是由select語句轉化過來,<br>if (query-&gt;as&lt;ASTSelectQuery&gt;)<br>{<br>/// This is internal part of ASTSelectWithUnionQuery.<br>/// Even if there is SELECT without union, it is represented by ASTSelectWithUnionQuery with single ASTSelectQuery as a child.<br>return std::make_unique&lt;InterpreterSelectQuery&gt;(query, context, SelectQueryOptions(stage));<br>}<br>}</code></p></pre><p>我們就以 <strong toutiao-origin=span>InterpreterSelectQuery</strong>為例，瞭解其實例化的核心邏輯:</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>InterpreterSelectQuery::InterpreterSelectQuery<br>{<br>//獲取AST<br>auto &amp; query = getSelectQuery;<br><br>//對AST做進一步語法分析，對語法樹做優化重寫<br>syntax_analyzer_result = SyntaxAnalyzer(context, options).analyze(<br>query_ptr, source_header.getNamesAndTypesList, required_result_column_names, storage, NamesAndTypesList);<br><br>//每一種Query都會對應一個特有的表達式分析器,用於爬取AST生成執行計劃(操作鏈)<br>query_analyzer = std::make_unique&lt;SelectQueryExpressionAnalyzer&gt;(<br>query_ptr, syntax_analyzer_result, context,<br>NameSet(required_result_column_names.begin, required_result_column_names.end),<br>options.subquery_depth, !options.only_analyze);<br>}</code></p></pre><p>語法分析直接生成的AST轉化成執行計劃可能性能上並不是最優的，因此需要SyntaxAnalyzer 對其進行優化重寫，在其源碼中可以看到其涉及到非常多 <strong>基規則</strong><strong>優化(rule based optimization)</strong>的trick。</p><p>SyntaxAnalyzer 會逐個針對這些規則對查詢進行檢查，確定其是否滿足轉換規則，一旦滿足就會對其進行轉換。</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze<br>{<br>// 剔除冗餘列<br>removeDuplicateColumns(result.source_columns);<br><br>// 根據settings中enable_optimize_predicate_expression配置判斷是否進行謂詞下移<br>replaceJoinedTable(node);<br><br>// 根據settings中distributed_product_mode配置重寫IN 與 JOIN 表達式<br>InJoinSubqueriesPreprocessor(context).visit(query);<br><br>// 優化Query內部的布爾表達式<br>LogicalExpressionsOptimizer.perform;<br><br>// 創建一個從別名到AST節點的映射字典<br>QueryAliasesVisitor(query_aliases_data, log.stream).visit(query);<br><br>// 公共子表達式的消除<br>QueryNormalizer(normalizer_data).visit(query);<br><br>// 消除select從句後的冗餘列<br>removeUnneededColumnsFromSelectClause(select_query, required_result_columns, remove_duplicates);<br><br>// 執行標量子查詢，並且用常量替代標量子查詢結果<br>executeScalarSubqueries(query, context, subquery_depth);<br><br>// 如果是select語句還會做下列優化:<br><br>// 謂詞下移優化<br>PredicateExpressionsOptimizer(select_query, settings, context).optimize;<br><br>/// GROUP BY 從句的優化<br>optimizeGroupBy(select_query, source_columns_set, context);<br><br>/// ORDER BY 從句的冗餘項剔除<br>optimizeOrderBy(select_query);<br><br>/// LIMIT BY 從句的冗餘列剔除<br>optimizeLimitBy(select_query);<br><br>/// USING語句的冗餘列剔除<br>optimizeUsing(select_query);<br><br>}</code></p></pre><p>這裡挑選幾個簡單介紹一下:</p><p>• 公共子表達式消除(Common Subexpression Elimination)</p><p>如果表達式 x op y 先前被計算過，並且從先前的計算到現在其計算表達式對應的值沒有改變，那麼 x op y 就稱為公共子表達式。公共子表達式消除會搜索所有相同計算表達式的實例，並分析是否值得用保存計算值的單個變量來替換它們，以減少計算的開銷。</p><p>• 標量子查詢(Scala Subquery)的常量替換</p><p>標量子查詢就是返回單一值的子查詢，和公共子表達式消除相似，可以用常量來替換SQL中所有的標量子查詢結果以減少計算開銷。</p><p>• 謂詞下移(Predicate Pushdown)</p><p>把外層查詢塊中的WHERE子句的謂詞下移到較低層查詢塊如視圖，以儘可能把過濾數據的操作移動到靠近數據源的位置。提前進行數據過濾能夠大幅減少網絡傳輸或者內存讀取訪問的數據量，以提高查詢效率。</p><p>而 query_analyzer 的作用可以理解為解析優化重寫後的AST，然後對所要進行的操作組成一條操作鏈，即物理執行計劃，如:</p><pre><p><code>ExpressionActionsChain chain;<br>analyzer.appendWhere(chain);<br>chain.addStep;<br>analyzer.appendSelect(chain);<br>analyzer.appendOrderBy(chain);<br>chain.finalize;</code></p></pre><p>上述代碼把where,select,orderby操作都加入到操作鏈中，接下來就可以從Storage層讀取Block，對Block數據應用上述操作鏈的操作。而執行的核心邏輯，就在對應Interpreter的 executeImpl 方法實現中,這裡以select語句的Interpreter來了解下讀取Block數據並且對block數據進行相應操作的流程。</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>void InterpreterSelectQuery::executeImpl(TPipeline &amp; pipeline, const BlockInputStreamPtr &amp; prepared_input)<br>{<br>// 對應Query的AST<br>auto &amp; query = getSelectQuery;<br><br>AnalysisResult expressions;<br>// 物理計劃，判斷表達式是否有where,aggregate,having,order_by,litmit_by等字段<br>expressions = analyzeExpressions(<br>getSelectQuery,<br>*query_analyzer,<br>QueryProcessingStage::FetchColumns,<br>options.to_stage,<br>context,<br>storage,<br>true,<br>filter_info);<br><br>// 從Storage讀取數據<br>executeFetchColumns(from_stage, pipeline, sorting_info, expressions.prewhere_info, expressions.columns_to_remove_after_prewhere);<br><br>// eg:根據SQL的關鍵字在BlockStream流水線中執行相應的操作, 如where,aggregate,distinct都分別由一個函數負責執行<br>executeWhere(pipeline, expressions.before_where, expressions.remove_where_filter);<br><br>executeAggregation(pipeline, expressions.before_aggregation, aggregate_overflow_row, aggregate_final);<br><br>executeDistinct(pipeline, true, expressions.selected_columns);<br><br>}</code></p></pre><p>既然我們知道了執行計劃AnalysisResult(即物理執行計劃)，接下來就需要從storage層中讀取數據來執行對應的操作，核心邏輯在<strong toutiao-origin=span> executeFetchColumns </strong>中: 核心操作就是從storage層讀取所要處理列的Block，並組織成BlockStream。</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>void InterpreterSelectQuery::executeFetchColumns(<br>QueryProcessingStage::Enum processing_stage, TPipeline &amp; pipeline,<br>const SortingInfoPtr &amp; sorting_info, const PrewhereInfoPtr &amp; prewhere_info, const Names &amp; columns_to_remove_after_prewhere)<br>{<br>// 實例化Block Stream<br>auto streams = storage-&gt;read(required_columns, query_info, context, processing_stage, max_block_size, max_streams)<br>// 讀取列對應的Block,並且組織成Block Stream<br>streams = {std::make_shared&lt;BlockInputStream&gt;(storage-&gt;getSampleBlockForColumns(required_columns))};<br>streams.back = std::make_shared&lt;ExpressionBlockInputStream&gt;(streams.back, query_info.prewhere_info-&gt;remove_columns_actions);<br>}</code></p></pre><p>讀取完Block Stream之後就是對其執行各種execute操作如 executeAggregation , executeWhere 操作，詳見</p><blockquote toutiao-origin=span>InterpreterSelectQuery::executeImpl</blockquote><p>的代碼。</p><p>因此Interpreter的處理過程可以總結為:</p><p>• 對AST進行優化重寫</p><p>• 解析重寫後的AST並生成操作鏈(執行計劃)</p><p>• 從存儲引擎中讀取要處理的Block數據</p><p>• 對讀取的Block數據應用操作鏈上的操作</p><p>那我們讀取Block Stream並進行處理後，生成的結果如何寫回到storage層呢? 我們這裡以insert語句的Interpreter來了解下:</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>BlockIO InterpreterInsertQuery::execute<br>{<br>// table為存儲引擎接口<br>StoragePtr table = getTable(query);<br>BlockOutputStreamPtr out;<br><br>// 從存儲引擎讀取Block Stream<br>auto query_sample_block = getSampleBlock(query, table);<br>out = std::make_shared&lt;AddingDefaultBlockOutputStream&gt;(<br>out, query_sample_block, out-&gt;getHeader, table-&gt;getColumns.getDefaults, context);<br><br>//執行結果封裝成BlockIO<br>BlockIO res;<br>res.out = std::move(out);<br>}</code></p></pre><p>上面代碼中的StoragePtr實際上就是IStorage這個存儲引擎的接口</p><pre><p><code>using StoragePtr = std::shared_ptr&lt;IStorage&gt;;</code></p></pre><p>無論是寫入還是讀取操作都是依靠底層存儲引擎(如MergeTree)的write和read接口來實現的，關於存儲引擎的細節實現這裡暫時不贅述，這裡我們只需要知道我們從存儲引擎接口中以流方式讀取Block數據，而結果組織成BlockIO流輸出。Interpreter的流程總結如下:</p><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S4RDmlD5SJPGhe><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=span>04 返回請求結果</strong></h2><p><strong toutiao-origin=span>TCPHandler::runImpl</strong>中，執行完 executeQuery 之後需要調用各種processQuery的方法來給client返回執行SQL後的結果。</p><p>我們以 <strong toutiao-origin=span>TCPHandler::processOrdinaryQuery</strong>為例做簡單分析:</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>void TCPHandler::processOrdinaryQuery<br>{<br>//把BlockStream封裝成異步的Stream,那麼從流中讀取數據將會是異步操作<br>AsynchronousBlockInputStream async_in(state.io.in);<br><br>while(true){<br>Block block;<br>//從IO流讀取block數據<br>block = async_in.read;<br>//發送block數據<br>sendData(block);<br>}<br>}</code></p></pre><p>Server負責在 sendData 函數中把輸出結果寫入到套接字輸出緩衝區中,client只要從這個輸出緩衝區讀取就能夠得到結果。</p><p><strong class=highlight-text toutiao-origin=span>左右滑動閱覽</strong></p><pre><p><code>void TCPHandler::sendData(const Block &amp; block)<br>{<br>//初始化OutputStream的參數<br>initBlockOutput(block);<br><br>// 調用BlockOutputStream的write函數,把Block寫到輸出流<br>state.block_out-&gt;write(block);<br>state.maybe_compressed_out-&gt;next;<br>out-&gt;next;<br>}</code></p></pre><p>02</p><p></p><h1 toutiao-origin=h2>結語</h1><p>瞭解ClickHouse背後SQL的查詢整個流程，不僅能讓數據庫使用者更清晰地認識到如何編寫最優化的SQL，也能夠讓數據庫內核開發者加深對數據庫體系結構的理解，提高開發效率。</p><p>本文並沒有涉及到太深入的技術細節，諸如向量化執行引擎，SIMD，基於llvm的動態代碼生成，類MergeTree存儲引擎等CK的技術細節也沒有提及，只是從宏觀角度給讀者介紹了執行SQL背後內核到底發生了什麼。後續我們會推出更多內核源碼解讀文章，敬請關注。</p><p><strong toutiao-origin=span>END</strong></p><pre><div><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RdIEj9hARSR1DD></div><br><div><ul><li><p>基於 Apache Flink 的實時監控告警系統</p></li><li><p>關於數據中臺的深度思考與總結（乾乾貨）</p></li><li><p>日誌收集Agent，陰暗潮溼的地底世界</p></li><li><p>2020 繼續踏踏實實的做好自己</p></li></ul></div></pre><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S0FUMtl41NrEMK><img alt="深度 | 一條查詢SQL的前世今生——ClickHouse 源碼閱讀" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S0FUNTDJBxRdKz><pre><div><div><div><div><div><div><div><div><div><div><div><div><div><div><p>你點的每個贊，我都當成了喜歡</p></div></div></div></div></div></div></div></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>一條</a></li><li><a>查詢</a></li><li><a>SQL</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html alt=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/3fd8ec4e-64c1-446a-adfa-38088fb06c01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html title=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點>奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d9c446c.html alt=基於語義關聯的中文查詢糾錯框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa7ec24a3f3245009b0462435b47db27 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d9c446c.html title=基於語義關聯的中文查詢糾錯框架>基於語義關聯的中文查詢糾錯框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/15476a7c.html alt=上海黃金水道傳利好，長江口航道一條變兩條，南槽生態航道治理一期工程將完工 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/S05e8nSGv9DC2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15476a7c.html title=上海黃金水道傳利好，長江口航道一條變兩條，南槽生態航道治理一期工程將完工>上海黃金水道傳利好，長江口航道一條變兩條，南槽生態航道治理一期工程將完工</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/125dee29.html alt="SQL Server中的事務與鎖" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533794121802a9afbb22f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/125dee29.html title="SQL Server中的事務與鎖">SQL Server中的事務與鎖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html alt=SQL基礎知識——事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/773e21df09dc4e3e8403a0a62994039d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html title=SQL基礎知識——事務>SQL基礎知識——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cc5655f8.html alt=這是一條很好的焊接變形控制措施 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1537168573260313799969b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cc5655f8.html title=這是一條很好的焊接變形控制措施>這是一條很好的焊接變形控制措施</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67e44193.html alt=欽州又一條高速將開建，還是出海大通道，快看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9ef055165a7b4c7d811672236d869c77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67e44193.html title=欽州又一條高速將開建，還是出海大通道，快看>欽州又一條高速將開建，還是出海大通道，快看</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10814bda.html alt=廣東一條在建高速，雙向6車道總長度約62公里，預計2022年底通車 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1893ab71a3024143b32da97f286ca3ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10814bda.html title=廣東一條在建高速，雙向6車道總長度約62公里，預計2022年底通車>廣東一條在建高速，雙向6車道總長度約62公里，預計2022年底通車</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html alt="SQL 難點解決：記錄的引用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3a1b904121564aa389aba6a046772870 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html title="SQL 難點解決：記錄的引用">SQL 難點解決：記錄的引用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e88a3a39.html alt=壓力單位概述（壓力單位快速查詢） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/458d052864cf4e30b7372dac21d825ad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e88a3a39.html title=壓力單位概述（壓力單位快速查詢）>壓力單位概述（壓力單位快速查詢）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/328f1349.html alt=一條契稅線索，稅務機關會順藤排查企業八種稅 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/328f1349.html title=一條契稅線索，稅務機關會順藤排查企業八種稅>一條契稅線索，稅務機關會順藤排查企業八種稅</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00ace6e2.html alt=北京西城迴應入學派位查詢系統異常：代碼錯誤導致，未發現人為因素和外部入侵 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/70aaebe5d7424441a84356f3ff357715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00ace6e2.html title=北京西城迴應入學派位查詢系統異常：代碼錯誤導致，未發現人為因素和外部入侵>北京西城迴應入學派位查詢系統異常：代碼錯誤導致，未發現人為因素和外部入侵</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/78f96068.html alt="西城區教育考試中心：查詢系統異常 與派位結果無關聯" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/78f96068.html title="西城區教育考試中心：查詢系統異常 與派位結果無關聯">西城區教育考試中心：查詢系統異常 與派位結果無關聯</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>