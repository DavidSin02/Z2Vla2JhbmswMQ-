<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器 | 极客快訊</title><meta property="og:title" content="PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/423ce7eefc5d433f86a14589b1ba0043"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><meta property="article:published_time" content="2020-11-14T21:07:27+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:27+08:00"><meta name=Keywords content><meta name=description content="PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e3b6719c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h3 class=pgc-h-arrow-right><strong>​容器是什麼？</strong></h3><p>相信很多人聽說過依賴注入，依賴注入實現的基礎條件離不開容器，容器就是用來管理類依賴和注入的，負責服務的管理和解耦組件，最簡單的理解我們可以把容器理解成一個超級大、專門存對象的數組。</p><div class=pgc-img><img alt=PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/423ce7eefc5d433f86a14589b1ba0043><p class=pgc-img-caption></p></div><p>圖1</p><p>如圖所示調用者通過容器的標示獲取到對象實例，圖裡可以看出來，可以通過 ::class 的方式來獲取也可以直接通過對象標示獲取實例對象。</p><p><br></p><p><strong>IOC是什麼？</strong></p><p>大家可能都聽說過IOC容器，IOC的全稱是：(Inversion Of Control，反轉控制)。</p><p>我們來理解一下什麼是反轉控制，在我們傳統編碼中我們在類與類之間的依賴通常是我們通過編碼的方式new出來對象再傳遞的，而使用控制反轉我們可以把對象的控制權交給容器或者框架去實現。目的是為了讓我們不需要硬編碼去創建對象，看圖1可以知道，容器裡面存放著很多對象，當我們要使用的時候可以直接去用。而容器裡面的對象不需要我們在代碼中編碼創建。在需要某個類對象的時候會去容器裡面獲取對象，如果對象不存在則會自動創建。這就是省略了我們在代碼裡面去創建對象的過程，由容器去幫我們實現這個創建的過程，這就叫反轉控制。一句話總結IOC：把創建對象的控制權轉移給容器實現類的實例化。</p><p>例如：沒有使用IOC的情況下，我們想要創建類</p><pre><code>&lt;?phpclass Sunny{}$sunny = new Sunny();</code></pre><p>我們需要手動去new一個類，這種情況就是硬編碼在代碼裡面去實現的。</p><p>而使用IOC容器的代碼則可以這樣寫。</p><pre><code>&lt;?phpclass Sunny{}$sunny = Container::getBean(Sunny::class);</code></pre><p>在容器的內部去幫我們實現這個類，有同學看到這裡可能會有疑問，我使用 new Sunny 不是代碼寫得更短更簡單嗎？我們看完依賴注入再看一個例子。</p><p><strong>依賴注入</strong></p><p>現在知道了IOC是什麼，那麼一個新的問題出來了，我們在創建類的時候有些類的構造方法會需要我們傳遞參數怎麼辦？通過IOC的學習我們知道了IOC容器會幫我們解決這個對象實例創建的問題，那麼在容器裡面創建對象的時候發現類有其他依賴則會進行依賴查找，容器尋找需要對象的過程，稱為DL(Dependency Lookup, 依賴查找)。而把需要的依賴注入到代碼片段中這個稱為DI(Dependency Injection,依賴注入)。</p><p>例如IOC裡面說到的 new Sunny 這個例子。如果在類與類之間有多重依賴。</p><pre><code>&lt;?phpclass Computer{    public function run(){        echo "編程中....\n";    }}class Sunny{    private $computer;    public function __construct(Computer $computer){        $this-&gt;computer = $computer;    }    public function program(){        $this-&gt;computer-&gt;run();    }}$sunny = new Sunny(new Computer());$sunny-&gt;program();</code></pre><p>這裡可以看到 Sunny 這個類想要編程依賴類 Computer 這個類，而如果使用IOC容器實現依賴注入的話，代碼就簡單了。</p><pre><code>&lt;?phpclass Computer{    public function run(){        echo "編程中....\n";    }}class Sunny{    private $computer;    public function __construct(Computer $computer){        $this-&gt;computer = $computer;    }    public function program(){        $this-&gt;computer-&gt;run();    }}$sunny = Container::getBean(Sunny::class);$sunny-&gt;program();</code></pre><h3 class=pgc-h-arrow-right>一句話總結：解決創建類實例當中對其他類的依賴，動態的向某個對象提供它所需要的其他對象。</h3><h3 class=pgc-h-arrow-right><strong>依賴倒置</strong></h3><p>依賴倒置解決的問題是鬆耦各個模塊之間的重度依賴，上層模塊不應該依賴底層模塊，它們都應該依賴於抽象。通常簡單的理解依賴倒置就是面向接口或者面向抽象來進行編程。我們通過下面的例子來看看面向接口編程。</p><pre><code>class Cache{    public function set($key,$value){        $redis = new CFile();        $redis-&gt;set($key,$value);    }}class CFile{    public function set($key,$value){        echo "file:{$key}-&gt;{$value}\n";    }}$cache = new Cache();$cache-&gt;set("name","sunny");</code></pre><p>上面的這段代碼看似沒有什麼大問題，但是如果有一天把文件緩存改成Redis緩存呢？</p><pre><code>class Cache{    public function set($key,$value){        $redis = new CRedis();        $redis-&gt;set($key,$value);    }}class CRedis{    public function set($key,$value){        echo "redis:{$key}-&gt;{$value}\n";    }}$cache = new Cache();$cache-&gt;set("name","sunny");</code></pre><p>通過這段代碼可以看出來當一個緩存使用的驅動改變了的時候，Cache的代碼也必須作出相應的改變，因為代碼寫死在調用者身上了，耦合度變得高了。再對代碼進行改造一樣，讓程序員面向interface編程，讓代碼變得更通用，更規範。</p><pre><code>interface ICache{    public function set($key,$value);}class CRedis implements ICache {    public function set($key,$value){        echo "redis:{$key}-&gt;{$value}\n";    }}class CFile implements ICache{    public function set($key,$value){        echo "file:{$key}-&gt;{$value}\n";    }}class Cache{    private $drive;    public function __construct(ICache $drive){        $this-&gt;drive = $drive;    }    public function set($key,$value){        $this-&gt;drive-&gt;set($key,$value);    }}$cache = new Cache(new CFile());$cache-&gt;set("name","sunny");</code></pre><p>很多人看到這段代碼的時候想著，那我在構造方法直接把要的對象傳進去不就好了嗎？為什麼還要定義一個interface呢？其實定義interface是為了規範代碼，不管你使用哪個驅動，只要實現了我這個interface的都可以用，沒有interface開發者在開發驅動的時候就會不知道這個驅動裡面該有什麼方法。當我們使用interface之後大家只要面向接口編程，Cache完全不管類是怎麼實現的，Cache只是根據interface的方法進行操作。</p><p>一句話總結：依賴倒置實現鬆耦合</p><p><br></p><h1 class=pgc-h-arrow-right><strong>實戰：根據容器原理實現容器</strong></h1><pre><code>&lt;?phpclass Container{    // 當前容器對象    private static $instance;    // 存放在容器裡面到實例    protected $instances = [];    private function __construct(){    }    public static function getInstance(){        if (!self::$instance) {            self::$instance = new static();        }        return self::$instance;    }    /**     * 獲取對象實例     * @param $key     * @return mixed     */    public function get($key){        if (isset($this-&gt;instances[$key])) {            return $this-&gt;instances[$key];        }    }    /**     * 綁定對象、閉包、類到容器     * @param $key     * @param null $concrete     * @return Container     */    public function bind($key, $concrete = null){        if ($concrete instanceof Closure) {            $this-&gt;instances[$key] = $concrete;        } elseif (is_object($concrete)) {            $this-&gt;instances[$key] = $concrete;        }        return $this;    }}class Sunny{    public function getName(){        echo time() . "\n";    }}$app = Container::getInstance();$sunny = $app-&gt;bind(Sunny::class,new Sunny());$sunny = $app-&gt;get(Sunny::class);$sunny-&gt;getName();</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>實戰：實現依賴注入</strong></h1><h3 class=pgc-h-arrow-right>Container.php</h3><pre><code>&lt;?phpclass Container{    // 當前容器對象    private static $instance;    // 存放在容器裡面到實例    protected $instances = [];    private function __construct(){    }    public static function getInstance(){        if (!self::$instance) {            self::$instance = new static();        }        return self::$instance;    }    /**     * 獲取對象實例     * @param $key     * @return mixed     * @throws ReflectionException     */    public function get($key){        if (isset($this-&gt;instances[$key])) {            return $this-&gt;instances[$key];        }        return $this-&gt;make($key);    }    /**     * 綁定對象、閉包、類到容器     * @param $key     * @param null $concrete     * @return Container     * @throws ReflectionException     */    public function bind($key, $concrete = null){        if ($concrete instanceof Closure) {            $this-&gt;instances[$key] = $concrete;        } elseif (is_object($concrete)) {            $this-&gt;instances[$key] = $concrete;        } else {            $this-&gt;make($key, $concrete);        }        return $this;    }    /**     * 創建類綁定到類實例     * @param $abstract     * @param null $atgs     * @return mixed     * @throws ReflectionException     */    public function make($abstract, $atgs = null){        if (isset($this-&gt;instances[$abstract])) {            return $this-&gt;instances[$abstract];        }        $object = $this-&gt;invokeClass($abstract);        $this-&gt;instances[$abstract] = $object;        return $object;    }    /**     * 反射解析類     * @param $abstract     * @return object     * @throws ReflectionException     */    public function invokeClass($abstract){        $reflectionClass = new \ReflectionClass($abstract);        // 獲取構造方法        $construct = $reflectionClass-&gt;getConstructor();        // 獲取參數得到實例        $params = $construct ? $this-&gt;parserParams($construct) : [];        $object = $reflectionClass-&gt;newInstanceArgs($params);        return $object;    }    /**     * 解析構造方法參數     * @param $reflect     * @return array     * @throws ReflectionException     */    public function parserParams(ReflectionMethod $reflect){        $args = [];        $params = $reflect-&gt;getParameters();        if (!$params) {            return $args;        }        if (count($params) &gt; 0) {            foreach ($params as $param) {                $class = $param-&gt;getClass();                if ($class) {                    $args[] = $this-&gt;make($class-&gt;getName());                    continue;                }                // 獲取變量的名稱                $name = $param-&gt;getName();                // 默認值                $def = null;                // 如果有默認值，從默認值獲取類型                if ($param-&gt;isOptional()) {                    $def = $param-&gt;getDefaultValue();                }                $args[] = $_REQUEST[$name] ?? $def;            }        }        return $args;    }}</code></pre><h3 class=pgc-h-arrow-right>Test.php</h3><pre><code>&lt;?phpclass Test{    public $name;    private $test1;    public function __construct(Test1 $test1){        $this-&gt;test1 = $test1;        $this-&gt;name = $this-&gt;test1-&gt;getName();    }}</code></pre><h3 class=pgc-h-arrow-right>Test1.php</h3><pre><code>&lt;?phpclass Test1{    public function getName(){        return "test1返回的名字";    }}</code></pre><h3 class=pgc-h-arrow-right>Sunny.php</h3><pre><code>&lt;?phprequire_once "./Container.php";require_once "./Test.php";require_once "./Test1.php";class Sunny{    private $test;    public function __construct(Test $test){        $this-&gt;test = $test;    }    public function getName(){        echo "獲取test裡面的name：{$this-&gt;test-&gt;name}\n";    }}$app = Container::getInstance();$sunny = $app-&gt;get(Sunny::class);$sunny-&gt;getName();</code></pre><p>如果喜歡我們的文章請關注 + 轉發 讓更多人看到，我們也會持續提供更多原創的好文章。</p><div class=pgc-img><img alt=PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/379e095c9bd843c3b958f1b161a81130><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>PHP</a></li><li><a>進階</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe9184d7.html alt=PHP進階教程-實現一個簡單的MySQL連接池 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/aa2df096a4274ba1b5c8540bcb5b5c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe9184d7.html title=PHP進階教程-實現一個簡單的MySQL連接池>PHP進階教程-實現一個簡單的MySQL連接池</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9eb3d63.html alt=PHP實現各種經典算法詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15357595091626cf296dc3e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9eb3d63.html title=PHP實現各種經典算法詳解>PHP實現各種經典算法詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/740f5b7b.html alt=PHP怎麼實現分頁功能？（圖文+視頻教程） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e81c52a014dd4c34adcbfb26482bd690 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/740f5b7b.html title=PHP怎麼實現分頁功能？（圖文+視頻教程）>PHP怎麼實現分頁功能？（圖文+視頻教程）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html alt=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a646cf102cf74b4a953855ebedbc7d29 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html title=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程>PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html alt=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cce9b3fb23ce41b88311823510e419da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html title=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。>PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/637cf111.html alt=PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/bc66832213514f2996f2e48c9e9cc747 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/637cf111.html title=PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西>PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45c31c17.html alt=PHP進階教程-設計模式之建造者模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ef25f91086df41eca76e35ff3434b003 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45c31c17.html title=PHP進階教程-設計模式之建造者模式>PHP進階教程-設計模式之建造者模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b034084e.html alt=PHP進階教程-設計模式之橋接模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3719c139b93342fe9e5526fa59ca1c89 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b034084e.html title=PHP進階教程-設計模式之橋接模式>PHP進階教程-設計模式之橋接模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a89954da.html alt=PHP進階教程-設計模式之組合模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6f2acee37d624649ac7a592bfe5b29af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a89954da.html title=PHP進階教程-設計模式之組合模式>PHP進階教程-設計模式之組合模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/baec5ab6.html alt=PHP進階教程-設計模式之裝飾器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8cbbfcfedd544572a62adc6df84d2e60 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/baec5ab6.html title=PHP進階教程-設計模式之裝飾器模式>PHP進階教程-設計模式之裝飾器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/854d0c39.html alt=Android進階：快速實現自定義陰影效果 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d9b37a24c58b4f60941881773a95c9cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/854d0c39.html title=Android進階：快速實現自定義陰影效果>Android進階：快速實現自定義陰影效果</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a0586cb.html alt=PHP進階教程-設計模式之適配器模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7c5019f7addc404d8c07f18f7dda0feb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a0586cb.html title=PHP進階教程-設計模式之適配器模式>PHP進階教程-設計模式之適配器模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>