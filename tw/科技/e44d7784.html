<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>查找算法 史上最簡單清晰的紅黑樹講解 | 极客快訊</title><meta property="og:title" content="查找算法 史上最簡單清晰的紅黑樹講解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/6c3900031930ed9fb441"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e44d7784.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e44d7784.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e44d7784.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e44d7784.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e44d7784.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e44d7784.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e44d7784.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e44d7784.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="查找算法 史上最簡單清晰的紅黑樹講解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e44d7784.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>查找算法 史上最簡單清晰的紅黑樹講解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>查找（一）</h1><p>我們使用符號表這個詞來描述一張抽象的表格，我們會將信息（值）存儲在其中，然後按照指定的鍵來搜索並獲取這些信息。鍵和值的具體意義取決於不同的應用。</p><p>符號表中可能會保存很多鍵和很多信息，因此實現一張高效的符號表也是一項很有挑戰性的任務。</p><p>我們會用三種經典的數據類型來實現高效的符號表：二叉查找數、紅黑樹、散列表。</p><h1></h1><p>二分查找</p><p>我們使用有序數組存儲鍵，經典的二分查找能夠根據數組的索引大大減少每次查找所需的比較次數。</p><p>在查找時，我們先將被查找的鍵和子數組的中間鍵比較。如果被查找的鍵小於中間鍵，我們就在左子數組中繼續查找，如果大於我們就在右子數組中繼續查找，否則中間鍵就是我們要找的鍵。</p><p>一般情況下二分查找都比順序查找快的多，它也是眾多實際應用程序的最佳選擇。對於一個靜態表（不允許插入）來說，將其在初始化時就排序是值得的。</p><p>當然，二分查找也不適合很多應用。現代應用需要同時能夠支持高效的查找和插入兩種操作的符號表實現。也就是說，我們需要在構造龐大的符號表的同時能夠任意插入（也許還有刪除）鍵值對，同時也要能夠完成查找操作。</p><p>要支持高效的插入操作，我們似乎需要一種鏈式結構。當單鏈接的鏈表是無法使用二分查找的，因為二分查找的高效來自於能夠快速通過索引取得任何子數組的中間元素。為了將二分查找的效率和鏈表的靈活性結合起來，我們需要更加複雜的數據結構。</p><p>能夠同時擁有兩者的就是二叉查找樹。</p><h1></h1><p>二叉查找樹</p><p>一顆二叉查找樹（BST）是一顆二叉樹，其中每個節點都含有一個可比較的鍵（以及相關聯的值）且每個結點的鍵都大於其左子樹中的任意結點的鍵而小於右子樹的任意結點的鍵。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c3900031930ed9fb441></p><p>一顆二叉查找樹代表了一組鍵（及其相應的值）的集合，而同一個集合可以用多顆不同的二叉查找樹表示。</p><p>如果我們將一顆二叉查找樹的所有鍵投影到一條直線上，保證一個結點的左子樹中的鍵出現在它的右邊，右子樹中的鍵出現在它的右邊，那麼我們一定可以得到一條有序的鍵列。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c360005543803f4c00f></p><p>查找</p><p>在二叉查找樹中查找一個鍵的遞歸算法：</p><p>如果樹是空的，則查找未命中。如果被查找的鍵和根結點的鍵相等，查找命中。否則我們就在適當的子樹中繼續查找。如果被查找的鍵較小就選擇左子樹，較大就選擇右子樹。</p><p>在二叉查找樹中，隨著我們不斷向下查找，當前結點所表示的子樹的大小也在減小（理想情況下是減半）</p><p>插入</p><p>查找代碼幾乎和二分查找的一樣簡單，這種簡潔性是二叉查找樹的重要特性之一。而二叉查找樹的另一個更重要的特性就是插入的實現難度和查找差不多。</p><p>當查找一個不存在於樹中的結點並結束於一條空鏈接時，我們需要做的就是將鏈接指向一個含有被查找的鍵的新結點。如果被查找的鍵小於根結點的鍵，我們會繼續在左子樹中插入該鍵，否則在右子樹中插入該鍵。</p><p>分析</p><p>使用二叉查找樹的算法的運行時間取決於樹的形狀，而樹的形狀又取決於鍵被插入的先後順序。</p><p>在最好的情況下，一顆含有N個結點的樹是完全平衡的，每條空鏈接和根結點的距離都為~lgN。在最壞的情況下，搜索路徑上可能有N個結點。但在一般情況下樹的形狀和最好情況更接近。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c35000563d35da14365></p><p>我們假設鍵的插入順序是隨機的。對這個模型的分析而言，二叉查找樹和快速排序幾乎就是“雙胞胎”。樹的根結點就是快速排序中的第一個切分元素（左側的鍵都比它小，右側的鍵都比它大），而這對於所有的子樹同樣適用，這和快速排序中對於子數組的遞歸排序完全對應。</p><p>【在由N個隨機鍵構造的二叉查找樹中，查找命中平均所需的比較次數為~2lgN。 N越大這個公式越準確】</p><h1></h1><p>平衡查找樹</p><p>在一顆含有N個結點的樹中，我們希望樹高為~lgN，這樣我們就能保證所有查找都能在~lgN此比較內結束，就和二分查找一樣。不幸的是，在動態插入中保證樹的完美平衡的代價太高了。我們放鬆對完美平衡的要求，使符號表API中所有操作均能夠在對數時間內完成。</p><p>2-3查找樹</p><p>為了保證查找樹的平衡性，我們需要一些靈活性，因此在這裡我們允許樹中的一個結點保存多個鍵。</p><p>2-結點：含有一個鍵(及值)和兩條鏈接，左鏈接指向的2-3樹中的鍵都小於該結點，右鏈接指向的2-3樹中的鍵都大於該結點。</p><p>3-結點：含有兩個鍵(及值)和三條鏈接，左鏈接指向的2-3樹中的鍵都小於該結點，中鏈接指向的2-3樹中的鍵都位於該結點的兩個鍵之間，右鏈接指向的2-3樹中的鍵都大於該結點。</p><p>（2-3指的是2叉-3叉的意思）</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c32000591e1a42e6150></p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c35000563d28b657c78></p><p>一顆完美平衡的2-3查找樹中的所有空鏈接到根結點的距離都是相同的。</p><p>查找</p><p>要判斷一個鍵是否在樹中，我們先將它和根結點中的鍵比較。如果它和其中的任何一個相等，查找命中。否則我們就根據比較的結果找到指向相應區間的鏈接，並在其指向的子樹中遞歸地繼續查找。如果這是個空鏈接，查找未命中。</p><p>插入</p><p>要在2-3樹中插入一個新結點，我們可以和二叉查找樹一樣先進行一次未命中的查找，然後把新結點掛在樹的底部。但這樣的話樹無法保持完美平衡性。我們使用2-3樹的主要原因就在於它能夠在插入之後繼續保持平衡。</p><p>如果未命中的查找結束於一個2-結點，我們只要把這個2-結點替換為一個3-結點，將要插入的鍵保存在其中即可。如果未命中的查找結束於一個3-結點，事情就要麻煩一些。</p><p>熱身：</p><p>先考慮最簡單的例子：只有一個3-結點的樹，向其插入一個新鍵。</p><p>這棵樹唯一的結點中已經沒有可插入的空間了。我們又不能把新鍵插在其空結點上（破壞了完美平衡）。為了將新鍵插入，我們先臨時將新鍵存入該結點中，使之成為一個4-結點。創建一個4-結點很方便，因為很容易將它轉換為一顆由3個2-結點組成的2-3樹（如圖所示），這棵樹既是一顆含有3個結點的二叉查找樹，同時也是一顆完美平衡的2-3樹，其中所有空鏈接到根結點的距離都相等。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c3900031931cb3cb60f></p><p>向一個父結點為2-結點的3-結點中插入新鍵</p><p>假設未命中的查找結束於一個3-結點，而它的父結點是一個2-結點。在這種情況下我們需要在維持樹的完美平衡的前提下為新鍵騰出空間。</p><p>我們先像剛才一樣構造一個臨時的4-結點並將其分解，但此時我們不會為中鍵創建一個新結點，而是將其移動至原來的父結點中。（如圖所示）</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c370004f42e4f5562e2></p><p>這次轉換也並不影響（完美平衡的）2-3樹的主要性質。樹仍然是有序的，因為中鍵被移動到父結點中去了，樹仍然是完美平衡的，插入後所有的空鏈接到根結點的距離仍然相同。</p><p>向一個父結點為3-結點的3-結點中插入新鍵</p><p>假設未命中的查找結束於一個3-結點，而它的父結點是一個3-結點。</p><p>我們再次和剛才一樣構造一個臨時的4-結點並分解它，然後將它的中鍵插入它的父結點中。但父結點也是一個3-結點，因此我們再用這個中鍵構造一個新的臨時4-結點，然後在這個結點上進行相同的變換，即分解這個父結點並將它的中鍵插入到它的父結點中去。</p><p>我們就這樣一直向上不斷分解臨時的4-結點並將中鍵插入更高的父結點，直至遇到一個2-結點並將它替換為一個不需要繼續分解的3-結點，或者是到達3-結點的根。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c370004f42fe4f5ba26></p><p>總結：</p><p>先找插入結點，若結點有空(即2-結點)，則直接插入。如結點沒空(即3-結點)，則插入使其臨時容納這個元素，然後分裂此結點，把中間元素移到其父結點中。對父結點亦如此處理。（中鍵一直往上移，直到找到空位，在此過程中沒有空位就先搞個臨時的，再分裂。）</p><p>★2-3樹插入算法的根本在於這些變換都是局部的：除了相關的結點和鏈接之外不必修改或者檢查樹的其他部分。每次變換中，變更的鏈接數量不會超過一個很小的常數。所有局部變換都不會影響整棵樹的有序性和平衡性。</p><p>{你確定理解了2-3樹的插入過程了嗎？ 如果你理解了，那麼你也就基本理解了紅黑樹的插入}</p><p>構造</p><p>和標準的二叉查找樹由上向下生長不同，2-3樹的生長是由下向上的。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c390003193350b0f757></p><p>優點</p><p>2-3樹在最壞情況下仍有較好的性能。每個操作中處理每個結點的時間都不會超過一個很小的常數，且這兩個操作都只會訪問一條路徑上的結點，所以任何查找或者插入的成本都肯定不會超過對數級別。</p><p>完美平衡的2-3樹要平展的多。例如，含有10億個結點的一顆2-3樹的高度僅在19到30之間。我們最多只需要訪問30個結點就能在10億個鍵中進行任意查找和插入操作。</p><p>缺點</p><p>我們需要維護兩種不同類型的結點，查找和插入操作的實現需要大量的代碼，而且它們所產生的額外開銷可能會使算法比標準的二叉查找樹更慢。</p><p>平衡一棵樹的初衷是為了消除最壞情況，但我們希望這種保障所需的代碼能夠越少越好。</p><p>紅黑二叉查找樹</p><p>【前言：本文所討論的紅黑樹之目的在於使讀者能更簡單清晰地瞭解紅黑樹的構造，使讀者能在紙上清晰快速地畫出紅黑樹，而不是為了寫出紅黑樹的實現代碼。</p><p>若是要在代碼級理解紅黑樹，則勢必需要記住其複雜的插入和旋轉的各種情況，我認為那只有助於增加大家對紅黑樹的恐懼，實際面試和工作中幾乎不會遇到需要自己動手實現紅黑樹的情況(很多語言的標準庫中就有紅黑樹的實現)。 若對於紅黑樹的C代碼實現有興趣的，可移步至July的博客。】</p><p>（理解紅黑樹一句話就夠了：紅黑樹就是用紅鏈接表示3-結點的2-3樹。那麼紅黑樹的插入、構造就可轉化為2-3樹的問題，即：在腦中用2-3樹來操作，得到結果，再把結果中的3-結點轉化為紅鏈接即可。而2-3樹的插入，前面已有詳細圖文，實際也很簡單：有空則插，沒空硬插，再分裂。 這樣，我們就不用記那麼複雜且讓人頭疼的紅黑樹插入旋轉的各種情況了。只要清楚2-3樹的插入方式即可。 下面圖文詳細演示。）</p><p>紅黑樹的本質：</p><p>紅黑樹是對2-3查找樹的改進，它能用一種統一的方式完成所有變換。</p><p>替換3-結點</p><p>★紅黑樹背後的思想是用標準的二叉查找樹（完全由2-結點構成）和一些額外的信息（替換3-結點）來表示2-3樹。</p><p>我們將樹中的鏈接分為兩種類型：紅鏈接將兩個2-結點連接起來構成一個3-結點，黑鏈接則是2-3樹中的普通鏈接。確切地說，我們將3-結點表示為由一條左斜的紅色鏈接相連的兩個2-結點。</p><p>這種表示法的一個優點是，我們無需修改就可以直接使用標準二叉查找樹的get()方法。對於任意的2-3樹，只要對結點進行轉換，我們都可以立即派生出一顆對應的二叉查找樹。我們將用這種方式表示2-3樹的二叉查找樹稱為紅黑樹。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c35000563d1dc39b8be></p><p>紅黑樹的另一種定義是滿足下列條件的二叉查找樹：</p><p>⑴紅鏈接均為左鏈接。</p><p>⑵沒有任何一個結點同時和兩條紅鏈接相連。</p><p>⑶該樹是完美黑色平衡的，即任意空鏈接到根結點的路徑上的黑鏈接數量相同。</p><p>如果我們將一顆紅黑樹中的紅鏈接畫平，那麼所有的空鏈接到根結點的距離都將是相同的。如果我們將由紅鏈接相連的結點合併，得到的就是一顆2-3樹。</p><p>相反，如果將一顆2-3樹中的3-結點畫作由紅色左鏈接相連的兩個2-結點，那麼不會存在能夠和兩條紅鏈接相連的結點，且樹必然是完美平衡的。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6c370004f42d6fecf780></p><p>無論我們用何種方式去定義它們，紅黑樹都既是二叉查找樹，也是2-3樹。</p><p>（2-3樹的深度很小，平衡性好，效率高，但是其有兩種不同的結點，實際代碼實現比較複雜。而紅黑樹用紅鏈接表示2-3樹中另類的3-結點，統一了樹中的結點類型，使代碼實現簡單化，又不破壞其高效性。）</p><p>顏色表示：</p><p>因為每個結點都只會有一條指向自己的鏈接（從它的父結點指向它），我們將鏈接的顏色保存在表示結點的Node數據類型的布爾變量color中（若指向它的鏈接是紅色的，那麼該變量為true，黑色則為false）。</p><p>當我們提到一個結點顏色時，我們指的是指向該結點的鏈接的顏色。</p><p>旋轉</p><p>在我們實現的某些操作中可能會出現紅色右鏈接或者兩條連續的紅鏈接，但在操作完成前這些情況都會被小心地旋轉並修復。</p><p>（我們在這裡不討論旋轉的幾種情況，把紅黑樹看做2-3樹，自然可以得到正確的旋轉後結果）</p><p>插入</p><p>在插入時我們可以使用旋轉操作幫助我們保證2-3樹和紅黑樹之間的一一對應關係，因為旋轉操作可以保持紅黑樹的兩個重要性質：有序性和完美平衡性。</p><p>熱身：</p><p>向2-結點中插入新鍵</p><p>（向紅黑樹中插入操作時，想想2-3樹的插入操作。紅黑樹與2-3樹在本質上是相同的，只是它們對3結點的表示不同。</p><p>向一個只含有一個2-結點的2-3樹中插入新鍵後，2-結點變為3-結點。我們再把這個3-結點轉化為紅結點即可）</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c3a00002530d03418c4></p><p>向一顆雙鍵樹（即一個3-結點）中插入新鍵</p><p>（向紅黑樹中插入操作時，想想2-3樹的插入操作。你把紅黑樹當做2-3樹來處理插入，一切都變得簡單了）</p><p>（向2-3樹中的一個3-結點插入新鍵，這個3結點臨時成為4-結點，然後分裂成3個2結點）</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c390003193299ee1cc5></p><p>★一顆紅黑樹的構造全過程</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c32000591e20017928b></p><p>平衡二叉樹（AVL樹）</p><p>定義：平衡二叉樹(Balance Binary Tree)又稱AVL樹。它或者是一顆空樹，或者是具有下列性質的二叉樹：它的左子樹和右子樹都是平衡二叉樹，且左子樹和右子樹的深度之差的絕對值不超過1。</p><p>若將二叉樹上結點的平衡因子BF(BalanceFactor)定義為該結點的左子樹深度減去它的右子樹深度，則平衡因子的絕對值大於1。</p><p>其旋轉操作 用2-3樹的分裂來類比想象。</p><p>散列表</p><p>散列表是普通數組概念的推廣。由於對普通數組可以直接尋址，使得能在O(1)時間內訪問數組中的任意位置。在散列表中，不是直接把關鍵字作為數組的下標，而是根據關鍵字計算出相應的下標。</p><p>使用散列的查找算法分為兩步。第一步是用散列函數將被查找的鍵轉化為數組的一個索引。</p><p>我們需要面對兩個或多個鍵都會散列到相同的索引值的情況。因此，第二步就是一個處理碰撞衝突的過程，由兩種經典解決碰撞的方法：拉鍊法和線性探測法。</p><p>散列表是算法在時間和空間上作出權衡的經典例子。</p><p>如果沒有內存限制，我們可以直接將鍵作為（可能是一個超大的）數組的索引，那麼所有查找操作只需要訪問內存一次即可完成。但這種情況不會經常出現，因此當鍵很多時需要的內存太大。</p><p>另一方面，如果沒有時間限制，我們可以使用無序數組並進行順序查找，這樣就只需要很少的內存。而散列表則使用了適度的空間和時間並在這兩個極端之間找到了一種平衡。</p><p>●散列函數</p><p>我們面對的第一個問題就是散列函數的計算，這個過程會將鍵轉化為數組的索引。我們要找的散列函數應該易於計算並且能夠均勻分佈所有的鍵。</p><p>散列函數和鍵的類型有關，對於每種類型的鍵我們都需要一個與之對應的散列函數。</p><p>正整數</p><p>將整數散列最常用的方法就是除留餘數法。我們選擇大小為素數M的數組，對於任意正整數k，計算k除以M的餘數。（如果M不是素數，我們可能無法利用鍵中包含的所有信息，這可能導致我們無法均勻地散列值。）</p><p>浮點數</p><p>將鍵表示為二進制數，然後再使用除留餘數法。（讓浮點數的各個位都起作用）（Java就是這麼做的）</p><p>字符串</p><p>除留餘數法也可以處理較長的鍵，例如字符串，我們只需將它們當做大整數即可。即相當於將字符串當做一個N位的R進制值，將它除以M並取餘。</p><p>·····軟緩存</p><p>如果散列值的計算很耗時，那麼我們或許可以將每個鍵的散列值緩存起來，即在每個鍵中使用一個hash變量來保存它的hashCode()返回值。</p><p>●基於拉鍊法的散列表</p><p>一個散列函數能夠將鍵轉化為數組索引。散列算法的第二步是碰撞處理，也就是處理兩個或多個鍵的散列值相同的情況。</p><p>拉鍊法：將大小為M的數組中的每個元素指向一條鏈表，鏈表中的每個結點都存儲了散列值為該元素的索引的鍵值對。</p><p>查找分兩步：首先根據散列值找到對應的鏈表，然後沿著鏈表順序查找相應的鍵。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c36000554c04cc3ec21></p><p>拉鍊法在實際情況中很有用，因為每條鏈表確實都大約含有N/M個鍵值對。</p><p>基於拉鍊法的散列表的實現簡單。在鍵的順序並不重要的應用中，它可能是最快的（也是使用最廣泛的）符號表實現。</p><p>●基於線性探測法的散列表</p><p>實現散列表的另一種方式就是用大小為M的數組保存N個鍵值對，其中M>N。我們需要依靠數組中的空位解決碰撞衝突。基於這種策略的所有方法被統稱為開放地址散列表。</p><p>開放地址散列表中最簡單的方法叫做線性探測法：當碰撞發生時，我們直接檢查散列表中的下一個位置（將索引值加1），如果不同則繼續查找，直到找到該鍵或遇到一個空元素。</p><p>（開放地址類的散列表的核心思想是：與其將內存用作鏈表，不如將它們作為在散列表的空元素。這些空元素可以作為查找結束的標誌。）</p><p>特點：散列最主要的目的在於均勻地將鍵散佈開來，因此在計算散列後鍵的順序信息就丟失了，如果你需要快速找到最大或最小的鍵，或是查找某個範圍內的鍵，散列表都不是合適的選擇。</p><p>【應用舉例】</p><p>海量處理</p><p>給定a、b兩個文件，各存放50億個url，每個url各佔64字節，內存限制是4G，讓你找出a、b文件共同的url？</p><p>答：</p><p>可以估計每個文件安的大小為5G×64=320G，遠遠大於內存限制的4G。所以不可能將其完全加載到內存中處理。考慮採取分而治之的方法。</p><p>分而治之/hash映射：</p><p>遍歷文件a，對每個url求取，然後根據所取得的值將url分別存儲到1000個小文件（記為，這裡漏寫個了a1）中。這樣每個小文件的大約為300M。遍歷文件b，採取和a相同的方式將url分別存儲到1000小文件中（記為）。這樣處理後，所有可能相同的url都在對應的小文件（）中，不對應的小文件不可能有相同的url。然後我們只要求出1000對小文件中相同的url即可。</p><p>hash_set統計：</p><p>求每對小文件中相同的url時，可以把其中一個小文件的url存儲到hash_set中。然後遍歷另一個小文件的每個url，看其是否在剛才構建的hash_set中，如果是，那麼就是共同的url，存到文件裡面就可以了。</p><p>（此題來源於v_July_v的博客）</p><h1></h1><p>B樹（多向平衡查找樹）</p><p>B-樹是對2-3樹數據結構的擴展。它支持對保存在磁盤或者網絡上的符號表進行外部查找，這些文件可能比我們以前考慮的輸入要大的多（以前的輸入能夠保存在內存中）。</p><p>（B樹和B+樹是實現數據庫的數據結構，一般程序員用不到它。）</p><p>和2-3樹一樣，我們限制了每個結點中能夠含有的“鍵-鏈接”對的上下數量界限：一個M階的B-樹，每個結點最多含有M-1對鍵-鏈接（假設M足夠小，使得每個M向結點都能夠存放在一個頁中），最少含有M/2對鍵-鏈接，但也不能少於2對。</p><p>(B樹是用於存儲海量數據的，一般其一個結點就佔用磁盤一個塊的大小。)</p><p>【注】以下B樹部分參考自July的博客，尤其是插入及刪除示圖，為了省力直接Copy自July。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c320005924baa9e718c></p><p>B樹中的結點存放的是鍵-值對。圖中紅色方塊即為鍵對應值的指針。</p><p>B樹中的每個結點根據實際情況可以包含大量的關鍵字信息和分支(當然是不能超過磁盤塊的大小，根據磁盤驅動(diskdrives)的不同，一般塊的大小在1k~4k左右)；這樣樹的深度降低了，這就意味著查找一個元素只要很少結點從外存磁盤中讀入內存，很快訪問到要查找的數據。</p><p>查找</p><p>假如每個盤塊可以正好存放一個B樹的結點（正好存放2個文件名）。那麼一個BTNODE結點就代表一個盤塊，而子樹指針就是存放另外一個盤塊的地址。</p><p>下面，咱們來模擬下查找文件29的過程：</p><p>1. 根據根結點指針找到文件目錄的根磁盤塊1，將其中的信息導入內存。【磁盤IO操作1次】</p><p>2. 此時內存中有兩個文件名17、35和三個存儲其他磁盤頁面地址的數據。根據算法我們發現：17&lt;29&lt;35，因此我們找到指針p2。</p><p>3. 根據p2指針，我們定位到磁盤塊3，並將其中的信息導入內存。【磁盤IO操作 2次】</p><p>4. 此時內存中有兩個文件名26，30和三個存儲其他磁盤頁面地址的數據。根據算法我們發現：26&lt;29&lt;30，因此我們找到指針p2。</p><p>5. 根據p2指針，我們定位到磁盤塊8，並將其中的信息導入內存。【磁盤IO操作 3次】</p><p>6. 此時內存中有兩個文件名28，29。根據算法我們查找到文件名29，並定位了該文件內存的磁盤地址。分析上面的過程，發現需要3 3次磁盤IO操作和次磁盤IO操作和3次內存查找 次內存查找操作。關於內存中的文件名查找，由於是一個有序表結構，可以利用折半查找提高效率。至於IO操作是影響整個B樹查找效率的決定因素。</p><p>插入</p><p>想想2-3樹的插入。2-3樹結點的最大容量是2個元素，故當插入操作造成超出容量之後，就得分裂。同樣m-階B樹規定的結點的最大容量是m-1個元素，故當插入操作造成超出容量之後也得分裂，其分裂成兩個結點每個結點分m/2個元素。（副作用是在其父結點中要插入一箇中間元素，用於分隔這兩結點。和2-3樹一樣，再向父結點插入一個元素也可能會造成父結點的分裂，逐級向上操作，直到不再造成分裂為止。）</p><p>向某結點中插入一個元素使其分裂，可能會造成連鎖反應，使其之上的結點也可能造成分裂。</p><p>總結：在B樹中插入關鍵碼key的思路：</p><p>對高度為h的m階B樹，新結點一般是插在第h層。通過檢索可以確定關鍵碼應插入的結點位置。然後分兩種情況討論：</p><p>1、 若該結點中關鍵碼個數小於m-1，則直接插入即可。</p><p>2、 若該結點中關鍵碼個數等於m-1，則將引起結點的分裂。以中間關鍵碼為界將結點一分為二，產生一個新結點，並把中間關鍵碼插入到父結點(h-1層)中</p><p>重複上述工作，最壞情況一直分裂到根結點，建立一個新的根結點，整個B樹增加一層。</p><p>【例】</p><p>1、下面咱們通過一個實例來逐步講解下。插入以下字符字母到一棵空的B 樹中（非根結點關鍵字數小了（小於2個）就合併，大了（超過4個）就分裂）：C N G A H E K Q M F W L T Z D P R X Y S，首先，結點空間足夠，4個字母插入相同的結點中，如下圖：</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c36000554bcff2abf3a></p><p>2、當咱們試著插入H時，結點發現空間不夠，以致將其分裂成2個結點，移動中間元素G上移到新的根結點中，在實現過程中，咱們把A和C留在當前結點中，而H和N放置新的其右鄰居結點中。如下圖：</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6c38000407a2f63e9410></p><p>3、當咱們插入E,K,Q時，不需要任何分裂操作</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c370004f4bab583d2db></p><p>4、插入M需要一次分裂，注意M恰好是中間關鍵字元素，以致向上移到父節點中</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c370004f4b98a6a4263></p><p>5、插入F,W,L,T不需要任何分裂操作</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c350005643e53270528></p><p>6、插入Z時，最右的葉子結點空間滿了，需要進行分裂操作，中間元素T上移到父節點中，注意通過上移中間元素，樹最終還是保持平衡，分裂結果的結點存在2個關鍵字元素。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c320005924cb0de8b41></p><p>7、插入D時，導致最左邊的葉子結點被分裂，D恰好也是中間元素，上移到父節點中，然後字母P,R,X,Y陸續插入不需要任何分裂操作（別忘了，樹中至多5個孩子）。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c36000554ba8ca84141></p><p>8、最後，當插入S時，含有N,P,Q,R的結點需要分裂，把中間元素Q上移到父節點中，但是情況來了，父節點中空間已經滿了，所以也要進行分裂，將父節點中的中間元素M上移到新形成的根結點中，注意以前在父節點中的第三個指針在修改後包括D和G節點中。這樣具體插入操作的完成，下面介紹刪除操作，刪除操作相對於插入操作要考慮的情況多點。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c3a000025bf4f37605c></p><p>刪除(delete)操作</p><p>首先查找B樹中需刪除的元素,如果該元素在B樹中存在，則將該元素在其結點中進行刪除，如果刪除該元素後，首先判斷該元素是否有左右孩子結點，如果有，則上移孩子結點中的某相近元素(“左孩子最右邊的節點”或“右孩子最左邊的節點”)到父節點中，然後是移動之後的情況；如果沒有，直接刪除後，移動之後的情況。</p><p>刪除元素，移動相應元素之後，如果某結點中元素數目（即關鍵字數）小於</p><p>ceil(m/2)-1，則需要看其某相鄰兄弟結點是否豐滿（結點中元素個數大於ceil(m/2)-1）（還記得第一節中關於B樹的第5個特性中的c點麼?： c)除根結點之外的結點（包括葉子結點）的關鍵字的個數n必須滿足： （ceil(m / 2)-1）&lt;= n &lt;=m-1。m表示最多含有m個孩子，n表示關鍵字數。在本小節中舉的一顆B樹的示例中，關鍵字數n滿足：2&lt;=n&lt;=4），如果豐滿，則向父節點借一個元素來滿足條件；如果其相鄰兄弟都剛脫貧，即借了之後其結點數目小於ceil(m/2)-1，則該結點與其相鄰的某一兄弟結點進行“合併”成一個結點，以此來滿足條件。那咱們通過下面實例來詳細瞭解吧。</p><p>以上述插入操作構造的一棵5階B樹（樹中最多含有m（m=5）個孩子，因此關鍵字數最小為ceil(m/ 2)-1=2。還是這句話，關鍵字數小了（小於2個）就合併，大了（超過4個）就分裂）為例，依次刪除H,T,R,E。</p><p>1、首先刪除元素H，當然首先查找H，H在一個葉子結點中，且該葉子結點元素數目3大於最小元素數目ceil(m/2)-1=2，則操作很簡單，咱們只需要移動K至原來H的位置，移動L至K的位置（也就是結點中刪除元素後面的元素向前移動）</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c320005924912cb4856></p><p>2、下一步，刪除T,因為T沒有在葉子結點中，而是在中間結點中找到，咱們發現他的繼承者W(字母升序的下個元素)，將W上移到T的位置，然後將原包含W的孩子結點中的W進行刪除，這裡恰好刪除W後，該孩子結點中元素個數大於2，無需進行合併操作。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c3a000025c157466fa7></p><p>3、下一步刪除R，R在葉子結點中,但是該結點中元素數目為2，刪除導致只有1個元素，已經小於最小元素數目ceil(5/2)-1=2,而由前面我們已經知道：如果其某個相鄰兄弟結點中比較豐滿（元素個數大於ceil(5/2)-1=2），則可以向父結點借一個元素，然後將最豐滿的相鄰兄弟結點中上移最後或最前一個元素到父節點中（有沒有看到紅黑樹中左旋操作的影子?），在這個實例中，右相鄰兄弟結點中比較豐滿（3個元素大於2），所以先向父節點借一個元素W下移到該葉子結點中，代替原來S的位置，S前移；然後X在相鄰右兄弟結點中上移到父結點中，最後在相鄰右兄弟結點中刪除X，後面元素前移。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c3a000025c0cc9548aa></p><p>4、最後一步刪除E， 刪除後會導致很多問題，因為E所在的結點數目剛好達標，剛好滿足最小元素個數（ceil(5/2)-1=2）,而相鄰的兄弟結點也是同樣的情況，刪除一個元素都不能滿足條件，所以需要該節點與某相鄰兄弟結點進行合併操作；首先移動父結點中的元素（該元素在兩個需要合併的兩個結點元素之間）下移到其子結點中，然後將這兩個結點進行合併成一個結點。所以在該實例中，咱們首先將父節點中的元素D下移到已經刪除E而只有F的結點中，然後將含有D和F的結點和含有A,C的相鄰兄弟結點進行合併成一個結點。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c320005924a3cb14052></p><p>5、也許你認為這樣刪除操作已經結束了，其實不然，在看看上圖，對於這種特殊情況，你立即會發現父節點只包含一個元素G，沒達標（因為非根節點包括葉子結點的關鍵字數n必須滿足於2=&lt;n&lt;=4，而此處的n=1），這是不能夠接受的。如果這個問題結點的相鄰兄弟比較豐滿，則可以向父結點借一個元素。假設這時右兄弟結點（含有Q,X）有一個以上的元素（Q右邊還有元素），然後咱們將M下移到元素很少的子結點中，將Q上移到M的位置，這時，Q的左子樹將變成M的右子樹，也就是含有N，P結點被依附在M的右指針上。所以在這個實例中，咱們沒有辦法去借一個元素，只能與兄弟結點進行合併成一個結點，而根結點中的唯一元素M下移到子結點，這樣，樹的高度減少一層。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c36000554bbffc59793></p><p>為了進一步詳細討論刪除的情況，再舉另外一個實例：</p><p>這裡是一棵不同的5序B樹，那咱們試著刪除C</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c39000319bd90314f90></p><p>於是將刪除元素C的右子結點中的D元素上移到C的位置，但是出現上移元素後，只有一個元素的結點的情況。</p><p>又因為含有E的結點，其相鄰兄弟結點才剛脫貧（最少元素個數為2），不可能向父節點借元素，所以只能進行合併操作，於是這裡將含有A,B的左兄弟結點和含有E的結點進行合併成一個結點。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c38000407a1a662f6b5></p><p>這樣又出現只含有一個元素F結點的情況，這時，其相鄰的兄弟結點是豐滿的（元素個數為3>最小元素個數2），這樣就可以想父結點借元素了，把父結點中的J下移到該結點中，相應的如果結點中J後有元素則前移，然後相鄰兄弟結點中的第一個元素（或者最後一個元素）上移到父節點中，後面的元素（或者前面的元素）前移（或者後移）；注意含有K，L的結點以前依附在M的左邊，現在變為依附在J的右邊。這樣每個結點都滿足B樹結構性質。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c370004f4bb2fb504d3></p><p>從以上操作可看出：除根結點之外的結點（包括葉子結點）的關鍵字的個數n滿足：（ceil(m / 2)-1）&lt;= n &lt;= m-1，即2&lt;=n&lt;=4。這也佐證了咱們之前的觀點。刪除操作完。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c370004f4b8196ef890></p><p>（我思：）</p><p>（1、 關於B樹中指針的表示。指針就是線索，是為了指示你找到目標。在內存中用內存的線性地址表示，在磁盤上，用磁盤的柱面和磁道號表示。</p><p>（2、 B樹也是一種文件組織形式。它與OS文件系統的區別是，文件系統是面向磁盤上各種應用的文件的，所有文件的索引都被組織在一個系統文件表中。這樣，一個相關應用的文件之間就沒有體現有序性，我們對某組相關的文件進行查找，效率就會較低。 而B樹是專門對某組相關的文件進行組織，使其之間相對有序，提高查找效率。 --尤其是對於需要頻繁查找訪問文件的操作。</p><p>例如： 對10億個有序數，其分佈在1000個文件中。普通的查找（類2分查找），和構造一個B樹，普通的二分查找不僅需要多次訪問文件，且其通過OS的文件系統通過文件名來訪問文件，這樣效率低——OS需要在整張系統文件表中通過文件名查找文件。 而B樹，其是多叉樹，樹的深度比二分樹要小很多，需要查找的文件比二分查找需要的少。且其通過自己建立的B樹來索引文件（每次查找文件都通過該B樹得到文件在磁盤上的位置）。B樹是獨立於OS的文件系統的，它中的每個文件都有相應的磁盤位置，而不僅是文件名。</p><h1></h1><p>B+樹</p><p>B+ tree：是應文件系統所需而產生的一種B-tree的變形樹。</p><p>一棵m階的B+樹和m階的B樹的異同點在於：</p><p>1、有n棵子樹的結點中含有n-1 個關鍵字； (與B 樹n棵子樹有n-1個關鍵字 保持一致，)</p><p>2、所有的葉子結點中包含了全部關鍵字的信息，及指向含有這些關鍵字記錄的指針，且葉子結點本身依關鍵字的大小自小而大的順序鏈接。</p><p>3、所有的非終端結點可以看成是索引部分，結點中僅含有其子樹根結點中最大（或最小）關鍵字。</p><p>【總結：最大的區別在於，B樹是像2-3樹那樣把數據分散到所有的結點中，而B+樹的數據都集中在葉結點，上層結點只是數據的索引，並不包含數據信息】</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c36000554b82e9c857a></p><p>【應用舉例】</p><p>1、為什麼說B+-tree比B 樹更適合實際應用中操作系統的文件索引和數據庫索引？</p><p>數據庫索引採用B+樹的主要原因是 B樹在提高了磁盤IO性能的同時並沒有解決元素遍歷的效率低下的問題。正是為了解決這個問題，B+樹應運而生。</p><p>B+樹只要遍歷葉子節點就可以實現整棵樹的遍歷。而且在數據庫中基於範圍的查詢是非常頻繁的，而B樹需要遍歷整棵樹，效率太低。</p><p>2、B+-tree的應用: VSAM(虛擬存儲存取法)文件</p><p>B樹與B+樹</p><p>走進搜索引擎的作者樑斌老師針對B樹、B+樹給出了他的意見（來源於July）：</p><p>“B+樹還有一個最大的好處，方便掃庫，B樹必須用中序遍歷的方法按序掃庫，而B+樹直接從葉子結點挨個掃一遍就完了，B+樹支持range-query非常方便，而B樹不支持。這是數據庫選用B+樹的最主要原因。</p><p>比如要查 5-10之間的，B+樹一把到5這個標記，再一把到10，然後串起來就行了，B樹就非常麻煩。B樹的好處，就是成功查詢特別有利，因為樹的高度總體要比B+樹矮。不成功的情況下，B樹也比B+樹稍稍佔一點點便宜。B樹比如你的例子中查，17的話，一把就得到結果了。</p><p>有很多基於頻率的搜索是選用B樹，越頻繁query的結點越往根上走，前提是需要對query做統計，而且要對key做一些變化。</p><p>另外B樹也好B+樹也好，根或者上面幾層因為被反覆query，所以這幾塊基本都在內存中，不會出現讀磁盤IO，一般已啟動的時候，就會主動換入內存。”</p><p>"mysql 底層存儲是用B+樹實現的，因為在內存中B+樹是沒有優勢的，但是一到磁盤，B+樹的威力就出來了"。</p><p>B+樹是B樹的變形，它把所有的附屬數據都放在葉子結點中，只將關鍵字和子女指針保存於內結點，內結點完全是索引的功能，最大化了內結點的分支因子。不過是n個關鍵字對應著n個子女，子女中含有父輩的結點信息，葉子結點包含所有信息（內結點包含在葉子結點中，內結點沒有指向“附屬數據”的指針必須索引到葉子結點）。這樣的話還有一個好處就是對於每個結點所需的索引次數都是相等的，保證了穩定性。</p><p>【B*樹】</p><p>B*樹是B+樹的變體，在B+樹非根和非葉子結點再增加指向兄弟的指針；B*樹定義了非葉子結點關鍵字個數至少為(2/3)*M，即塊的最低使用率為2/3（代替B+樹的1/2）。</p><p>B+樹的分裂：當一個結點滿時，分配一個新的結點，並將原結點中1/2的數據複製到新結點，最後在父結點中增加新結點的指針；B+樹的分裂隻影響原結點和父結點，而不會影響兄弟結點，所以它不需要指向兄弟的指針；</p><p>B*樹的分裂：當一個結點滿時，如果它的下一個兄弟結點未滿，那麼將一部分數據移到兄弟結點中，再在原結點插入關鍵字，最後修改父結點中兄弟結點的關鍵字（因為兄弟結點的關鍵字範圍改變了）；如果兄弟也滿了，則在原結點與兄弟結點之間增加新結點，並各複製1/3的數據到新結點，最後在父結點增加新結點的指針；</p><p>所以，B*樹分配新結點的概率比B+樹要低，空間使用率更高；</p><p>在數據庫中的應用及性能分析</p><p>一般關係型數據庫使用B+樹來做索引，NoSQL數據庫用哈希來做索引。例如MySQL就普遍使用B+Tree實現其索引結構。</p><p>上文說過，紅黑樹等數據結構也可以用來實現索引，但是文件系統及數據庫系統普遍採用B/B+Tree作為索引結構。</p><p>因為索引本身也很大，不可能全部存儲在內存中，因此索引往往以索引文件的形式存儲的磁盤上。這樣的話，索引查找過程中就要產生磁盤I/O消耗，相對於內存存取，I/O存取的消耗要高几個數量級，所以評價一個數據結構作為索引的優劣最重要的指標就是在查找過程中磁盤I/O操作次數的漸進複雜度。</p><p>由於存儲介質的特性，磁盤本身存取就比主存慢很多，再加上機械運動耗費，磁盤的存取速度往往是主存的幾百分之一，因此為了提高效率，要儘量減少磁盤I/O。為了達到這個目的，磁盤往往不是嚴格按需讀取，而是每次都會預讀，即使只需要一個字節，磁盤也會從這個位置開始，順序向後讀取一定長度的數據放入內存。這樣做的理論依據是計算機科學中著名的局部性原理：</p><p>當一個數據被用到時，其附近的數據也通常會馬上被使用。程序運行期間所需要的數據通常比較集中。</p><p>由於磁盤順序讀取的效率很高（不需要尋道時間，只需很少的旋轉時間），因此對於具有局部性的程序來說，預讀可以提高I/O效率。</p><p>預讀的長度一般為頁（page）的整倍數。頁是計算機管理存儲器的邏輯塊，硬件及操作系統往往將主存和磁盤存儲區分割為連續的大小相等的塊，每個存儲塊稱為一頁（在許多操作系統中，頁得大小通常為4k），主存和磁盤以頁為單位交換數據。當程序要讀取的數據不在主存中時，會觸發一個缺頁異常，此時系統會向磁盤發出讀盤信號，磁盤會找到數據的起始位置並向後連續讀取一頁或幾頁載入內存中，然後異常返回，程序繼續運行。</p><p>【下面分析B/B+Tree索引的性能】</p><p>我們使用磁盤I/O次數評價索引結構的優劣。先從B Tree分析，根據B Tree的定義，可知檢索一次最多需要訪問h個節點。數據庫系統的設計者巧妙利用了磁盤預讀原理，將一個節點的大小設為等於一個頁，這樣每個節點只需要一次I/O就可以完全載入。為了達到這個目的，在實際實現中B-Tree在每次新建節點時，直接申請一個頁的空間，這樣就保證一個節點物理上也存儲在一個頁裡，加之計算機存儲分配都是按頁對齊的，就實現了一個node只需一次I/O。</p><p>B-Tree中一次檢索最多需要h-1次I/O（根節點常駐內存），漸進複雜度為O(h)=O(logdN)。一般實際應用中，出度d是非常大的數字，通常超過100，因此h非常小（通常不超過3）。</p><p>綜上所述，用B-Tree作為索引結構效率是非常高的。</p><p>而紅黑樹這種結構，h明顯要深的多。由於邏輯上很近的節點（父子）物理上可能很遠，無法利用局部性，所以紅黑樹的I/O漸進複雜度也為O(h)，效率明顯比B-Tree差很多。</p><p>B+Tree更適合外存索引，原因和內節點出度d有關。從上面分析可以看到，d越大索引的性能越好，而出度的上限取決於節點內key和data的大小，由於B+Tree內節點去掉了data域，因此可以擁有更大的出度，擁有更好的性能。</p><p>我應該使用符號表的哪種實現</p><p>對於典型的應用程序，應該在散列表和二叉查找樹之間進行選擇。</p><p>相對於二叉查找樹，散列表的優點在於代碼更簡單，且查找時間最優（常數級別）。二叉查找樹相對於散列表的優點在於抽象結構更簡單（不需要設計散列函數），紅黑樹可以保證最壞情況下的性能且它能夠支持的操作更多（如排名、選擇和範圍查找）。</p><p>大多數程序員的第一選擇都是散列表，在其他因素更重要時才會選擇紅黑樹。（”第一選擇”的例外：當鍵都是長字符串時，我們可以構造出比紅黑樹更靈活而又比散列表更高效的數據結構 Trie樹）</p><p>=================================================字符串的查找============================================</p><h1></h1><p>單詞查找樹(Trie樹)</p><p>單詞查找樹的英文單詞trie來自於E.Fredkin在1960年玩的一個文字遊戲，因為這個數據結構的作用是取出(retrieval)數據，但發音為try是為了避免與tree相混淆。</p><p>基本性質：</p><p>每個結點都含有R條鏈接，其中R為字母表的大小。（單詞查找樹一般都含有大量的空鏈接，因此在繪製一顆單詞查找樹時一般會忽略空鏈接。）</p><p>樹中的每個結點中不是包含一個或幾個關鍵字，而是隻含有組成關鍵字的符號。例如，若關鍵字是數值，則結點中只包含一個數位；若關鍵字是單詞，則結點中只包含一個字母字符。我們將每個鍵所關聯的值保存在該鍵的最後一個字母所對應的結點中。</p><p>（這種樹會給某種類型關鍵字的表的查找帶來方便。）</p><p>假設有如下關鍵字的集合</p><p>{ CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN }</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c3200059248e4fd09a3></p><p>若以樹的多重鏈表來表示Trie樹，則樹的每個結點中應含有d個指針域。</p><p>若從Trie樹中某個結點到葉子結點的路徑上每個結點都只有一個孩子，則可將該路徑上所有結點壓縮成一個“葉子結點”，且在該葉子結點中存儲關鍵字及指向記錄的指針等信息。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c350005643dc9239889></p><p>在Trie樹中有兩種結點：</p><p>分支結點：含有d個指針域和一個指示該結點中非空指針域的個數的整數域。（分支結點所表示的字符是由其指向子樹指針的索引位置決定的）</p><p>葉子結點：含有關鍵字域和指向記錄的指針域。</p><p>typedef structTrieNode</p><p>{</p><p>NodeKind kind ;</p><p>union {</p><p>struct {KeyType K; Record *infoptr} lf ; //葉子結點</p><p>struct {TrieNode *ptr[27]; int num} bh ; //分支結點</p><p>} ;</p><p>} TrieNode,*TrieTree ;</p><p>查找</p><p>在Trie樹上進行查找的過程為：從根結點出發，沿給定值相應的指針逐層向下，直至葉子結點，若葉子結點中的關鍵字和給定值相等，則查找成功。若分支結點中和給定值相應的指針為空，或葉結點中的關鍵字和給定值不相等，則查找不成功。</p><p>分割</p><p>查找操作的時間依賴於樹的深度。</p><p>我們可以對關鍵字集選擇一種合適的分割，以縮減Trie樹的深度。</p><p>例如：先按首字符不同分成多個子集之後，然後按最後一個字符不同分割每個子集，再按第二個字符……，前後交叉分割。</p><p>如下圖：在該樹上，除兩個葉子結點在第四層上外，其餘葉子結點均在第三層上。</p><p>若分割的合適，則可使每個葉子結點中只含有少數幾個同義詞。</p><p><img alt="查找算法 史上最簡單清晰的紅黑樹講解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c320005924d70b6ffa1></p><p>插入和刪除</p><p>在Trie樹上易於進行插入和刪除，只是需要相應地增加和刪除一些分支結點。</p><p>把沿途分支結點中相應的指針域置空，再把其分支結點中的num-1，然後刪除葉子結點。當分支結點中num域的值減為1時，便可刪除。</p><ul class=list-paddingleft-2><ul class=list-paddingleft-2></ul></ul><ul class=list-paddingleft-2></ul><ul class=list-paddingleft-2></ul><ul class=list-paddingleft-2></ul><ul class=list-paddingleft-2></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>簡單</a></li><li><a>紅黑樹</a></li><li><a>講解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e434ad.html alt=新手用雲服務器快速搭建個人網站簡單教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e434ad.html title=新手用雲服務器快速搭建個人網站簡單教程>新手用雲服務器快速搭建個人網站簡單教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/61d5b89d.html alt=場面描寫很簡單，讓語文老師舉例，教會你好用的寫作技巧和方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/a12e06c3-dac8-4ef1-a44b-bbf85671edb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/61d5b89d.html title=場面描寫很簡單，讓語文老師舉例，教會你好用的寫作技巧和方法>場面描寫很簡單，讓語文老師舉例，教會你好用的寫作技巧和方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ecbd05fe.html alt="比搶錢還要簡單！蘋果上架Mac Pro配件：四個輪子要五千塊" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5e07933580e64355abbbcac953abfc3d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ecbd05fe.html title="比搶錢還要簡單！蘋果上架Mac Pro配件：四個輪子要五千塊">比搶錢還要簡單！蘋果上架Mac Pro配件：四個輪子要五千塊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8234770.html alt=關於齒輪常識由淺及深講解透徹，推薦收藏！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4e18dad6a34c44ed850916d34339092b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8234770.html title=關於齒輪常識由淺及深講解透徹，推薦收藏！>關於齒輪常識由淺及深講解透徹，推薦收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/189fa616.html alt=驅動橋設計講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/eb89bb6bddcb4755b82277febac75960 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/189fa616.html title=驅動橋設計講解>驅動橋設計講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9ababaae.html alt=初中科學元素的簡單分類每日一練含答案解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cc6f0300765348b3a57404a617d32c99 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9ababaae.html title=初中科學元素的簡單分類每日一練含答案解析>初中科學元素的簡單分類每日一練含答案解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4707da0.html alt=高中化學物質分類竟如此簡單，你還記得多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b73cc7c22bc14eb9af43cf76f66e5d70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4707da0.html title=高中化學物質分類竟如此簡單，你還記得多少？>高中化學物質分類竟如此簡單，你還記得多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2aa5a357.html alt=大白話講解php多態應用實例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2aa5a357.html title=大白話講解php多態應用實例>大白話講解php多態應用實例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ec613168.html alt=十大世界足球先生，認識四位以上的人都不簡單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8bf0e55d0e30483abc88ce0fa1ac279d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ec613168.html title=十大世界足球先生，認識四位以上的人都不簡單>十大世界足球先生，認識四位以上的人都不簡單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e71fb88c.html alt=和麵、揉麵技巧，視頻詳細講解，10年和麵經驗，全部告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8cd49cb368f1488b8c4a65a3fe556d75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e71fb88c.html title=和麵、揉麵技巧，視頻詳細講解，10年和麵經驗，全部告訴你>和麵、揉麵技巧，視頻詳細講解，10年和麵經驗，全部告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35c96373.html alt=14種家常哨子面的做法，美味不油膩，簡單易學又實用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1ef1a62cd3ad4bf9b000021a38952cb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35c96373.html title=14種家常哨子面的做法，美味不油膩，簡單易學又實用>14種家常哨子面的做法，美味不油膩，簡單易學又實用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dacdca28.html alt=媽媽教的剪刀面做法，無保留分享，簡單又實用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e3e5ec81da04a70bf4d1fe077acb24c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dacdca28.html title=媽媽教的剪刀面做法，無保留分享，簡單又實用>媽媽教的剪刀面做法，無保留分享，簡單又實用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd7a84b7.html alt=鑑別被追尾車就是這麼簡單！這4個方法你都瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a51a16723af8485ab69705c547ea4fd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd7a84b7.html title=鑑別被追尾車就是這麼簡單！這4個方法你都瞭解嗎？>鑑別被追尾車就是這麼簡單！這4個方法你都瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a2d512e5.html alt=6個實用電路圖，簡單易懂！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d4ccc825dea840e0bccda3481c8a96ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a2d512e5.html title=6個實用電路圖，簡單易懂！>6個實用電路圖，簡單易懂！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>