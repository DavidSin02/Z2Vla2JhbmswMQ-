<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Golang 彙編器快速指南 | 极客快訊</title><meta property="og:title" content="Golang 彙編器快速指南 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/91a99ad4-fbdd-4b7f-aeb8-fa4ad47695d8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e45b3d7b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e45b3d7b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e45b3d7b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e45b3d7b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e45b3d7b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e45b3d7b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e45b3d7b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e45b3d7b.html><meta property="article:published_time" content="2020-11-14T21:04:32+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:32+08:00"><meta name=Keywords content><meta name=description content="Golang 彙編器快速指南"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e45b3d7b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Golang 彙編器快速指南</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="Golang 彙編器快速指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/91a99ad4-fbdd-4b7f-aeb8-fa4ad47695d8><p class=pgc-img-caption></p></div><p>彙編器基於 Plan 9 彙編器的輸入風格。詳細文檔在這裡。如果你準備寫一些彙編語言，那麼雖然此文檔是基於 Plan 9 的，你也應該通讀。本文提供了語法摘要和與其解釋內容的區別，並且描述了編寫彙編與 Go 交互時所適用的特性。</p><p>最重要的是，Go 的彙編器並不是底層的直接表示。有一些是直接的映射，有一些不是。這是因為編譯套件在常規流程中並不需要彙編器。相反，編譯器針對一種半抽象的指令集操作，而且指令選擇發生在一部分發生在代碼生成之後。彙編器工作在半抽象狀態下，所以當你看到類似指令 MOV，工具鏈實際生成的操作也許並不是移動，而是清除指令或者加載指令。或者也可能與實際指令完全對應。一般來說，特定機器的操作傾向於它們自身，而更通用的概念（如內存移動、子程序調用、返回等）則更加抽象。細節根據體系架構會有不同，我們非常抱歉關於這種不精確，情況還沒有完全定義。</p><p>彙編器程序是一種解析半抽象指令集的描述並將其轉換為輸入給鏈接器指令的方法。如果想要看到給定體系的彙編指令（如：amd64），在標準庫源碼中有很多實例（比如 runtime math/big）。你可以測試編譯器生成的彙編代碼（實際輸出可能和這裡有出入）：</p><pre><code>$ cat x.gopackage mainfunc main() {    println(3)}$ GOOS=linux GOARCH=amd64 go tool compile -S x.go        # or: go build -gcflags -S x.go"".main STEXT size=74 args=0x0 locals=0x10    0x0000 00000 (x.go:3)   TEXT    "".main(SB), $16-0    0x0000 00000 (x.go:3)   MOVQ    (TLS), CX    0x0009 00009 (x.go:3)   CMPQ    SP, 16(CX)    0x000d 00013 (x.go:3)   JLS 67    0x000f 00015 (x.go:3)   SUBQ    $16, SP    0x0013 00019 (x.go:3)   MOVQ    BP, 8(SP)    0x0018 00024 (x.go:3)   LEAQ    8(SP), BP    0x001d 00029 (x.go:3)   FUNCDATA    $0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)    0x001d 00029 (x.go:3)   FUNCDATA    $1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)    0x001d 00029 (x.go:3)   FUNCDATA    $2, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)    0x001d 00029 (x.go:4)   PCDATA  $0, $0    0x001d 00029 (x.go:4)   PCDATA  $1, $0    0x001d 00029 (x.go:4)   CALL    runtime.printlock(SB)    0x0022 00034 (x.go:4)   MOVQ    $3, (SP)    0x002a 00042 (x.go:4)   CALL    runtime.printint(SB)    0x002f 00047 (x.go:4)   CALL    runtime.printnl(SB)    0x0034 00052 (x.go:4)   CALL    runtime.printunlock(SB)    0x0039 00057 (x.go:5)   MOVQ    8(SP), BP    0x003e 00062 (x.go:5)   ADDQ    $16, SP    0x0042 00066 (x.go:5)   RET    0x0043 00067 (x.go:5)   NOP    0x0043 00067 (x.go:3)   PCDATA  $1, $-1    0x0043 00067 (x.go:3)   PCDATA  $0, $-1    0x0043 00067 (x.go:3)   CALL    runtime.morestack_noctxt(SB)    0x0048 00072 (x.go:3)   JMP 0...複製代碼</code></pre><p>FUNCDATA 和 PCDATA 包含了垃圾回收使用的信息，會在編譯器中介紹。</p><p>想要查看鏈接後放入二進制文件中的內容，使用 go tool objdump 來查看：</p><pre><code>$ go build -o x.exe x.go$ go tool objdump -s main.main x.exeTEXT main.main(SB) /tmp/x.go  x.go:3        0x10501c0       65488b0c2530000000  MOVQ GS:0x30, CX  x.go:3        0x10501c9       483b6110        CMPQ 0x10(CX), SP  x.go:3        0x10501cd       7634            JBE 0x1050203  x.go:3        0x10501cf       4883ec10        SUBQ $0x10, SP  x.go:3        0x10501d3       48896c2408      MOVQ BP, 0x8(SP)  x.go:3        0x10501d8       488d6c2408      LEAQ 0x8(SP), BP  x.go:4        0x10501dd       e86e45fdff      CALL runtime.printlock(SB)  x.go:4        0x10501e2       48c7042403000000    MOVQ $0x3, 0(SP)  x.go:4        0x10501ea       e8e14cfdff      CALL runtime.printint(SB)  x.go:4        0x10501ef       e8ec47fdff      CALL runtime.printnl(SB)  x.go:4        0x10501f4       e8d745fdff      CALL runtime.printunlock(SB)  x.go:5        0x10501f9       488b6c2408      MOVQ 0x8(SP), BP  x.go:5        0x10501fe       4883c410        ADDQ $0x10, SP  x.go:5        0x1050202       c3          RET  x.go:3        0x1050203       e83882ffff      CALL runtime.morestack_noctxt(SB)  x.go:3        0x1050208       ebb6            JMP main.main(SB)複製代碼</code></pre><h1 class=pgc-h-arrow-right>常量</h1><p>儘管彙編器遵循 Plan 9 的規範，但這是一個獨立程序，會有一些不同。其中一個就是常量評估。彙編器中的常量表達式是按照 Go 的操作符優先級來解析的，而不是類 C 的優先級。所以， 3&1&lt;&lt;2 是 4 而不是 0。它按照 (3&1)&lt;&lt;2 來解析，而不是 3&(1&lt;&lt;2)。而且，常量會被解析為 64位無符號整形。所以 -2 不是整形數減2，而是具有同樣位信息的64位無符號整形。這個區別基本沒什麼影響，除了要注意避免在對右操作數高位置位的情況下進行歧義操作、除法、右移。</p><h1 class=pgc-h-arrow-right>符號</h1><p>某些符號，例如 R1 或者 LR，已經預定義，並且指向了寄存器。具體的符號集取決於體系架構。</p><p>有4個預先聲明的符號，指向了位寄存器。它們不是真的寄存器，而是工具鏈維護的虛擬寄存器，例如棧幀指針。偽寄存器集合在所有體系架構上都是一樣的：</p><ul><li>FP: 棧幀指針：參數和本的變量；</li><li>PC: 程序計數器：跳轉和分支；</li><li>SB: 靜態基礎指針：全局符號；</li><li>SP棧指針：棧頂</li></ul><p>所有用戶定義的符號會被寫為偽寄存器 FP 和 SB 加偏移量的方式。</p><p>偽寄存器 SB 可以看做是原始內存，所以符號 foo(SB) 是 foo 在內存中的地址。這種形式被用作全局命名函數和數據。給名字加上 &lt;> ，foo&lt;>(SB) 使得名字只在當前源文件可見，類似 C文件 中頂級靜態聲明。給名字添加偏移量指向從符號的地址開始加上偏移量的地址，所以 foo+4(SB) 表示從 foo 開始偏移4個字節的地址。</p><p>偽寄存器 FP 是虛擬棧幀指針，被用作指向函數的參數。編譯器維護了一個虛擬的棧幀指針指向了棧中的參數，表示為偽寄存器+偏移量的形式。所以， 0(FP) 是函數的第一個參數，8(FP) 是第二個（64位機器上），以此類推。當指向一個函數的參數時，必須要在開頭加上名字，比如 first_arg+0(FP) 或者 second_arg+8(FP) 。</p><blockquote><p><strong>offset 的含義</strong> 棧幀指針的 offset 不同於 SB 的 offset，後者是表示了符號+偏移量的位置。</p></blockquote><p>彙編器強制做了要求，不會解析原生 0(FP) 和 8(FP) 這種形式。真實的名字是和語義無關的，但是應該被用作記錄變量的名字。這樣可以保持 FP 始終是偽寄存器，而不是一個硬件寄存器，即使是架構體系中有硬件的棧幀指針。</p><p>對於帶有 Go 原始類型的彙編函數，go vet 會檢查參數名稱和偏移量是否吻合。在32位系統上，64位值的低32位和高32位通過添加 _lo 或者 _hi 的後綴來區分，寫作 arg_lo+0(FP) 或者 arg_hi+4(FP) 。如果 Go 原始類型的返回值沒有命名，那麼彙編名字就是 ret。</p><p>偽寄存器 SP 是一個虛擬棧指針，被用作指向棧幀本的變量和函數調用的參數。它指向本地棧幀的頂部，所以引用時應該使用負的 offset 值，範圍是：[-棧幀大小，0)。比如：x-8(SP) 或者 y-4(SP) 等等。</p><p>如果體系架構帶有硬件寄存器 SP，名字前綴就會區分使用的是虛擬棧幀指針還是體系架構中的 SP 寄存器。x-8(SP) 和 -8(SP) 是不同的內存地址，前者表示虛擬棧指針為寄存器，後者表示硬件 SP 寄存器。</p><p>在機器上，SP 和 PC 是物理編號寄存器的傳統別名。在 Go 彙編器中， SP 和 PC也會被特殊處理。例如，引用 SP 需要一個符號，類似 FP。為了訪問實際的硬件寄存器，使用真實的 R 名稱，比如在 ARM 架構下， 硬件 SP 和 PC 同樣可以使用 R13/R15 來訪問。</p><p>分支和直接跳轉一直被寫作 PC + offset，或跳轉到 Labels。</p><pre><code>label:    MOVW $0, R1    JMP label複製代碼</code></pre><p>每個 label 只在其定義函數的內部可見。因為可以在一個文件中、不同的函數中定義使用相同名稱的 label。直接跳轉和調用指令可以以文字符號為目標（name(SB)），但不能是 符號+偏移量（name+4(SB)）。</p><p>指令，寄存器和彙編器指令會一直使用大寫，來提醒你彙編編程是一個大工程。</p><p>在 Go 目標文件和二進制文件中，符號的全名是包路徑後面跟一個句點和符號名：fmt.Printf 或者 math/rand.Int 。由於彙編器的解析器將句點和斜槓視作標點符號，這些字符就不能直接被用作標識名稱。而彙編器允許在標識符中使用中間點字符 U+00B7 和 分割斜槓 U+2215，並重寫為純句點和斜槓。在彙編源文件中，上面的符號被寫為 fmt·Printf/ math/rand·Int。編譯器在使用-S參數時生成的彙編列表直接顯示了句號和斜槓，而不是彙編程序要求的Unicode來替代。</p><p>大部分手寫彙編文件在符號名稱上不包含包全路徑，因為鏈接器在任何以句點開頭的名字前，插入了當前對象文件的包路徑。比如：在 math/rand 包的視線中，包中 Int 函數可以引用為 .Int。這個約定避免了在自己的源碼中硬編碼包的導入路徑，使得將代碼遷移變得更加容易。</p><h1 class=pgc-h-arrow-right>指令</h1><p>彙編器使用了多種指令將 text 和 數據整合到符號名稱上。比如，這有一個簡單的完整函數定義。TEXT 指令表明符號 runtime·profileloop ，下面的指令是函數體。TEXT 最後一條指令必須是一種跳轉指令，一般是 RET偽指令。如果沒有的話， 鏈接器會添加跳轉到自己的指令，TEXT 中沒有直接通往下一個 TEXT 的能力。符號之後，參數是標識符、幀大小、指令：</p><pre><code>TEXT runtime·profileloop(SB),NOSPLIT,$8    MOVQ    $runtime·profileloop1(SB), CX    MOVQ    CX, 0(SP)    CALL    runtime·externalthreadhandler(SB)    RET複製代碼</code></pre><p>一般情況下，棧幀大小跟著參數大小，用減號分割（不是減法，知識一種特殊語法）。棧幀大小 $24-8 表示函數有 24個字節的棧幀，而且調用時，參數是 8個字節，參數在調用方的棧幀中。如果 NOSPLIT 在 TEXT 沒有指定，則必須要提供參數大小。對於帶有 Go 原始類型的彙編函數， go vet 將會檢查參數大小是否正確。</p><p>注意，符號名稱使用中句點來分割組件，並且表示為 靜態基礎偽寄存器 SB +偏移量。這個函數可以被 runtime 包使用 profileloop 直接調用。</p><p>全局數據符號被GLOBL指令和一系列初始化的 DATA 指令所定義。每一個 DATA 指令初始化一塊對應內存。默認內存不會被初始化為0。DATA 指令一般形式是：</p><pre><code>DATA    symbol+offset(SB)/width, value複製代碼</code></pre><p>DATA 使用給定的值，在給定的偏移量和寬度上，初始化符號內存。給 DATA 指令的符號，必須寫成正偏移量。</p><p>GLOBL 指令聲明瞭一個符號是全局的。參數是可選的標誌，數據大小也被聲明為全局的，如果沒有被 DATA初始化，則將會被用0初始化。GLOBL 指令後面必須跟著對應的 DATA 指令。舉例如下：</p><pre><code>DATA divtab&lt;&gt;+0x00(SB)/4, $0xf4f8fcffDATA divtab&lt;&gt;+0x04(SB)/4, $0xe6eaedf0...DATA divtab&lt;&gt;+0x3c(SB)/4, $0x81828384GLOBL divtab&lt;&gt;(SB), RODATA, $64GLOBL runtime·tlsoffset(SB), NOPTR, $4複製代碼</code></pre><p>聲明和初始化一個只讀的4字節整數值的64字節表 divtab&lt;>，並聲明一個4字節不包含指針的0值變量 runtime·tlsoffset。</p><p>這裡可能有一兩個參數給到指令。如果有兩個，第一個是標誌位掩碼，可以將標誌寫為數字表達式，或者累加起來或者可以符號化以便人類可讀。這些值定義在標準 #include 文件 textflag.h , 它們是：</p><ul><li>NOPROF = 1 (TEXT部分) 不要分析標記的函數，這個標誌已經廢棄了。</li><li>DUPOK = 2 在一個二進制文件中可以有多個此符號實例。鏈接器會挑選一個去使用。</li><li>NOSPLIT = 4 (TEXT 部分) 不要插入序言來檢查棧是否需要被分割。協程的幀加上其調用，必須在棧幀頂部的空餘空間放得下。通常為了保護協程，例如棧拆分代碼本身。</li><li>RODATA = 8 (DATA 和 GLOBL 部分) 將數據放到只讀段。</li><li>NOPTR = 16 (DATA 和 GLOBL 部分) 此數據不包含指針，所以不需要被 GC 掃描。</li><li>WRAPPER = 32 (TEXT 部分) 這是個封裝函數，而且不應該被視為禁用 recover。</li><li>NEEDCTXT = 64 (TEXT 部分) 這個函數是閉包，所以使用其傳入的上下文寄存器。</li><li>LOCAL = 128 這個符號是在動態共享庫本地。</li><li>TLSBSS = 256 (DATA 和 GLOBL 部分) 將此數據放入線程本地存儲。</li><li>NOFRAME = 512 (TEXT 部分) 即使不是葉子函數，也不要插入指令來分配棧幀和存儲、恢復返回地址。僅在聲明棧幀大小為0時有用。</li><li>TOPFRAME = 2048 (TEXT 部分) 函數在調用棧頂部，調用追蹤在此處停止。</li></ul><h1 class=pgc-h-arrow-right>運行時的協調</h1><p>為了讓垃圾回收器正確運行，運行時必須知道所有全局數據中和大部分的棧幀中的指針所在地址。Go 編譯器在編譯 Go 源文件時會暴露這些信息，但是彙編程序必須顯式的定義它。</p><p>如果數據符號被帶有 NOPTR 標誌，就會被當做不包含運行時數據指針。如果數據符號帶有 RODATA 標誌，表示在只讀內存分配，也相當於顯示聲明 NOPTR 標記。一個數據符號總大小小於一個指針，則相當於顯示聲明 NOPTR。在彙編源文件不可能定義包含指針的符號，這種符號必須在 Go 源文件中定義。彙編源代碼還可以不用 DATA 和 GLOBL ，用名稱指向一個符號。一個好的通用經驗法則是，在 Go 中定義定義所有不是 RODATA 的符號，而不是在彙編中定義。</p><p>每個函數還需要註解，以給出在參數、返回、本地棧幀中存活指針的位置。對於沒有指針返回，也沒有本地棧幀和函數調用的彙編函數，僅要求在同包下的 Go 源文件中定義函數的 Go 原始類型。彙編函數的名字必須包含包名部分（比如：函數 Syscall 在包 syscall 下面，在它的TEXT部分應該使用名字 ·Syscall 替代相同名字 syscall·Syscall）。對於更加複雜的情形來說，需要顯示註解。這些註解使用標準 #include 文件 funcdata.h 中定義的偽寄存器。</p><p>如果函數沒有參數、返回值，那麼指針信息可以省略。這個會被 TEXT 指令下的 $*n*-0 參數大小注解指定。否則，Go源文件中函數的指針信息必須被 Go 原始類型提供，甚至不是被 Go 直接調用的彙編函數。（原型也會使用 go``vet 檢查參數引用） 函數開始的地方，參數假設已經被初始化，而返回值則假設沒有被初始化。如果調用指令期間返回值持有存活的指針，那麼函數應該以0值化的返回值開始，並且執行GO_RESULTS_INITALIZED 偽指令。這個指令記錄了返回值已經被初始化，並且應該在棧移動時或垃圾回收期間被掃描。一般來說讓彙編函數不返回指針或者不包含調用指令會更加容易一點。標準庫中沒有彙編函數使用了 GO_RESULTS_INITIALIZED。</p><p>如果一個函數沒有本地棧幀，那麼指針信息可以被省略。這個會被 TEXT 指令下的 $*n*-0 參數大小注解指定。如果函數沒有調用指令，那麼指針信息也可以被省略。除此之外，本地棧幀不得包含指針，而且彙編必須使用偽指令 NO_LOCAL_POINTERS 來確認。因為調整棧大小是通過移動棧來實現的，所以在任何函數調用期間棧指針都可能改變：即使指向棧數據的指針，也禁止保存在本地變量中。</p><p>應該始終為彙編函數提供 Go 原始類型，以便為參數和返回值提供指針信息，同時使用 go vet 檢查使用的偏移量是否正確。</p><h1 class=pgc-h-arrow-right>特殊體系架構中的細節</h1><p>列出每種機型的所有指令和其他細節是不切實際的。要查看給定機型定義了哪種指令集，比如 ARM，可以在目錄 src/cmd/internal/obj/arm 查看該架構的 obj 支持庫。在目錄下有一個文件 a.out.go，它包含了以 A 開頭的長長的常量列表，類似下面：</p><pre><code>const (    AAND = obj.ABaseARM + obj.A_ARCHSPECIFIC + iota    AEOR    ASUB    ARSB    AADD    ...複製代碼</code></pre><p>這是該架構的彙編器和鏈接器已知的指令及其拼寫列表。在列表中，每個指令以一個大寫的 A 開頭，所以 AAND 是代表了按位與指令 AND（去掉前綴 A），並在彙編代碼中寫作 AND。命令枚舉大部分按照字母順序（在 cmd/internal/obj 中定義的架構體系無關的 AXXX 指令，代表無效的指令）。名字順序和實際編碼無關。cmd/internal/obj 負責細節。</p><p>386和 AMD64 共有的指令列在了 cmd/internal/obj/x86/a.out.go</p><p>架構體系共享了一些通用尋址模式的語法，例如：(R1)間接寄存器，4(R1) 間接寄存器+偏移量，$foo(SB) 絕對地址。彙編器同樣支持每種架構體系中一些特殊的尋址模式（不一定是全部），列在了下面。</p><p>前面各節的示例證明了數據指令的流向是從左到右：MOVQ $0, CX 清除了 CX。這個規則甚至可以用於那些與常規表示相反方向的體系結構。</p><p>下面是一些在支持的體系結構下， Go特定的關鍵細節說明：</p><h1 class=pgc-h-arrow-right>32-bit Intel 386</h1><p>MMU中一些未使用的寄存器（就Go而言）維護著指向 g 結構的運行時指針。如果源碼是在 runtime 包，而且包含了特定的 header go_tls.h，那麼，會為彙編器定義一個操作系統相關的宏 get_tls:</p><pre><code>#include "go_tls.h"複製代碼</code></pre><p>在運行時中，宏 get_tls 加載 g 的指針的指針到它的參數寄存器中，g 結構體包含了一個 m 指針。這有另外一個特殊的 header 包含了 g 每個元素的偏移量，叫做 go_asm.h 。用 CX 讀取 g 和 m 的順序如下：</p><pre><code>#include "go_tls.h"#include "go_asm.h"...get_tls(CX)MOVL    g(CX), AX     // Move g into AX.MOVL    g_m(AX), BX   // Move g.m into BX.複製代碼</code></pre><p>注意：上面的代碼僅可以在 runtime 包有效， get_tls.h 也適用於 arm, amd64 and amd64p32， go_asm.h 適用於所有的體系結構。</p><p>尋址模式：</p><ul><li>(DI)(BX*2): DI 加 BX*2 的地址。</li><li>64(DI)(BX*2): DI 加 BX*2 加 64 的地址位置。這個模式僅僅接受1，2，4，8 作為比例因子。</li></ul><p>當使用 編譯器和彙編器的 -dynlink 和 -shared 模式，任何在固定內存地址加載和存儲（例如：全局變量），必須假設覆蓋了 CX。因此，為了用戶安全使用這些模式的原因，除了在內存引用上，彙編源碼應該避免使用 CX 。</p><h1 class=pgc-h-arrow-right>64-bit Intel 386 (別名 amd64)</h1><p>兩種體系在彙編器層面上，行為基本一致。64位版本的彙編代碼訪問 m 和 g 指針和32位 386 一樣，只是前者使用 MOVQ 而不是 MOVL。</p><pre><code>get_tls(CX)MOVQ    g(CX), AX     // Move g into AX.MOVQ    g_m(AX), BX   // Move g.m into BX.複製代碼</code></pre><h1 class=pgc-h-arrow-right>ARM</h1><p>R10 和 R11 寄存器被編譯器和鏈接器保留。</p><p>R10 指向 g (goroutine) 結構體。在彙編器源碼中，這個指針必須叫做 g 。不會識別R10這個名稱。</p><p>為了讓人類和編譯器更簡單的寫彙編，ARM 鏈接器允許使用單個硬件指令無法表達的普通尋址方式和偽指令，例如： DIV 和 MOD 。它用多個指令實現了這種形式，通常使用 R11 來保存臨時變量。手寫彙編可以使用 R11 ，但是要求確認鏈接器沒有同樣使用它來實現任何函數中其他的指令。</p><p>當定義一個 TEXT 時，指定棧幀大小 $-4 表示告訴鏈接器，這是一個葉子函數，也就是不需要在入口保存 LR 。</p><p>之前說過，名字 SP 總是表示一個虛擬的棧指針。如果是硬件寄存器，使用 R13。</p><p>條件代碼語法是在指令後面添加句點和一兩個字母的代碼，比如：MOVW.EQ 。可能添加多種代碼：MOVM.IA.W 。 代碼修飾符順序無關緊要。</p><p>尋址模式：</p><ul><li>R0->16 R0>>16 R0&lt;&lt;16 R0@>16: 對於 &lt;&lt; 左移 R0 16位。其他代碼是： -> 算數右移， >> 邏輯右移， @> 向右旋轉。</li><li>R0->R1 R0>>R1 R0&lt;&lt;R1 R0@>R1: 對於 &lt;&lt; 左移 R0 R1位。其他代碼是： -> 算數右移，>> 邏輯右移，@> 向右旋轉。</li><li>[R0,g,R12-R15]: 多寄存器指令中，包含 R0 g, R12-R15 的集合。</li><li>(R5, R6): 目標寄存器對。</li></ul><h1 class=pgc-h-arrow-right>ARM64</h1><p>ARM64端口處於試驗狀態。</p><p>R18 是平臺寄存器，被 Apple 平臺保留。為了不被誤用，該寄存器命名為 R18_PLATFORM。R27 和 R28 被編譯器和鏈接器保留。R29 是棧幀指針。R30 是鏈接寄存器。</p><p>指令修飾符會加在指令後，跟在句點後面。僅有 P 後遞增 和 W 預遞增 兩個修飾符：MOVW.P MOVW.W。</p><p>地址模式：</p><ul><li>R0->16 R0>>16 R0&lt;&lt;16 R0@>16: 和 32位 ARM 一樣。</li><li>$(8&lt;&lt;12): 將8 左移 12位。</li><li>8(R0): 將 R0的值 和 8 相加。</li><li>(R2)(R0): R0的值加上 R2的值。</li><li>R0.UXTB R0.UXTB&lt;&lt;imm: UXTB:</li><li>R0.SXTB R0.SXTB&lt;&lt;imm: SXTB: 提取R0的第8位，並擴展零值到R0的大小。R0.SXTB&lt;&lt;imm: 左移 R0.SXTB imm 位。imm 可以是 0，1，2，3，4。其他擴展包括 SXTH (32位) 和 SXTX(64位)。</li><li>(R5, R6): 寄存器對給LDAXP/LDP/LDXP/STLXP/STP/STP。</li></ul><p>引用: Go ARM64 Assembly Instructions Reference Manual</p><h1 class=pgc-h-arrow-right>PPC64</h1><p>GOARCH 等於 ppc64 和 ppc64le 使用此彙編器。</p><p>引用: Go PPC64 Assembly Instructions Reference Manual</p><h1 class=pgc-h-arrow-right>IBM z/Architecture, a.k.a. s390x</h1><p>R10 和 R11 兩個寄存器被保留。彙編器在彙編某些指令時用它們存放臨時值。</p><p>R13 指向了 g（goroutine）結構體。此寄存器必須使用名字 g ，R13 這個名字不會被識別。</p><p>R15 指向棧幀，它應該只能通過虛擬寄存器 SP 和 FP 訪問。</p><p>多個加載和存儲指令對一系列寄存器進行操作。寄存器的範圍由開始寄存器和結束寄存器指定。例如，LMG (R9), R5, R7 會使用 0(R9), 8(R9) 和 16(R9) 的 64位的值 加載到 R5, R6 和 R7 中。</p><p>像 MVC 和 XC 這樣的存儲-存儲指令以長度作為第一個參數。比如：XC $8, (R9), (R9) 會清空R9 特定地址的 8個字節。</p><p>如果以長度或索引作為向量指令的參數，那麼是第一個參數。比如，VLEIF $1, $16, V2 會將16加載到 v2 的 索引1 中。使用向量指令要確保他們在運行時是可用的。要使用向量指令，機器必須同時有向量功能（功能列表中的位129）和 內核支持。沒有內核的支持，向量指令是無效的（將等同於一個 NOP 指令）。</p><p>尋址模式：</p><ul><li>(R5)(R6*1): R5 值加 R6 的位置。 與x86一樣它是一種縮放模式，但只有 1 被允許。</li></ul><h1 class=pgc-h-arrow-right>MIPS, MIPS64</h1><p>通用寄存器的名字是 R0 - R31 ，浮點數寄存器是 F0 到 F31。</p><p>R30 被保留，指向 g 。R23 被用作臨時寄存器。</p><p>在 TEXT 指令中， MIPS的為棧幀大小 $-4 ，MIPS64的棧幀大小為 $-8 表示鏈接器不需要保存 LR 。</p><p>SP 表示虛擬棧指針。硬件寄存器使用 R2 。</p><p>尋址模式：</p><ul><li>16(R1): R1 + 16 的位置。</li><li>(R1): 0(R1) 的別名。</li></ul><p>通過預定義 GOMIPS_hardfloat 或者 GOMIPS_softfloat 可以使彙編代碼使用 GOMIPS 環境變量 (hardfloat 或者 softfloat) 。</p><p>通過預定義 GOMIPS64_hardfloat 或者 GOMIPS64_softfloat 可以使彙編代碼使用 GOMIPS64 環境變量 (hardfloat 或者 softfloat) 。</p><h1 class=pgc-h-arrow-right>不支持的操作碼</h1><p>彙編器的設計宗旨是為了支援編譯器，因此，不是所有體系平臺的硬件指令都被定義出來：如果編譯器不生成，那麼就沒有。如果你需要使用丟失的指令，有兩個方法。一是升級彙編器以支持指令，這是最簡單的，但是只有在多次使用時才值得去做。相反，對於簡單的一次使用的情況，可以使用 BYTE 和 WORD 指令顯示的將數據放到 TEXT 指令流中。這就是 386 運行時怎麼定義 64位 原子加載函數的。</p><pre><code>// uint64 atomicload64(uint64 volatile* addr);// so actually// void atomicload64(uint64 *res, uint64 volatile *addr);TEXT runtime·atomicload64(SB), NOSPLIT, $0-12    MOVL    ptr+0(FP), AX    TESTL   $7, AX    JZ  2(PC)    MOVL    0, AX // crash with nil ptr deref    LEAL    ret_lo+4(FP), BX    // MOVQ (%EAX), %MM0    BYTE $0x0f; BYTE $0x6f; BYTE $0x00    // MOVQ %MM0, 0(%EBX)    BYTE $0x0f; BYTE $0x7f; BYTE $0x03    // EMMS    BYTE $0x0F; BYTE $0x77    RET</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Golang</a></li><li><a>編器</a></li><li><a>指南</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f2b9e5c.html alt=自我保護指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RSAP0RrBuRac6c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f2b9e5c.html title=自我保護指南>自我保護指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a9b1eec.html alt="Golang 入門 : 理解併發與並行" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cf0d86c0222b4f50ad5ba925231b361e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a9b1eec.html title="Golang 入門 : 理解併發與並行">Golang 入門 : 理解併發與並行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d06239a.html alt=最新垃圾分類指南來了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/RjHHPc956tNSjD style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d06239a.html title=最新垃圾分類指南來了>最新垃圾分類指南來了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d26a375.html alt=腫瘤熱療——全身熱療指南分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9329cbca0e5a4bf3b5d78be60448af65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d26a375.html title=腫瘤熱療——全身熱療指南分享>腫瘤熱療——全身熱療指南分享</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adf558e7.html alt="查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/60bc9160b4bd4c319ed419be29146606 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adf558e7.html title="查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼">查看 Golang、Lua、JS、Rust、Python等語言生成的彙編代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/33c50312.html alt=編程｜彙編器和連接器的下載及彙編、連接、調試一個簡單彙編程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3746bbc8e4044ff89df7ee405b5a7281 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/33c50312.html title=編程｜彙編器和連接器的下載及彙編、連接、調試一個簡單彙編程序>編程｜彙編器和連接器的下載及彙編、連接、調試一個簡單彙編程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5858148.html alt=內存條選購指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/449c97849f104bca8982ce9ca8d86bc1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5858148.html title=內存條選購指南>內存條選購指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/04f9c895.html alt=房屋買賣合同審查指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0edf48a5-ece8-4e3d-8ec5-2c3c351aa16d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/04f9c895.html title=房屋買賣合同審查指南>房屋買賣合同審查指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/6a124111.html alt=你需要的——猛烈增長睪酮指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8046bcd05eb84b9cb21f3be18b1a99c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/6a124111.html title=你需要的——猛烈增長睪酮指南>你需要的——猛烈增長睪酮指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/e7894198.html alt=中風急救操作指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3f496015a91949df836d25379bf2a033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/e7894198.html title=中風急救操作指南>中風急救操作指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/0bb92078.html alt=到底便宜不？逛東京樂器店小指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c71f67d473914b21a5056ec27a2d931f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/0bb92078.html title=到底便宜不？逛東京樂器店小指南>到底便宜不？逛東京樂器店小指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad97b7c4.html alt=Golang還是Python？哪種語言更適合AI？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a43cda7020540a8ae69546866c11792 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad97b7c4.html title=Golang還是Python？哪種語言更適合AI？>Golang還是Python？哪種語言更適合AI？</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/6eb48b58.html alt=《無雙大蛇3》哪吒使用技巧指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/R9YCNB57GjpLoD style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/6eb48b58.html title=《無雙大蛇3》哪吒使用技巧指南>《無雙大蛇3》哪吒使用技巧指南</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/415e1fdc.html alt="《失落城堡》全面指南 特殊技巧分享" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RJ4IBBsWl8SYX style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/415e1fdc.html title="《失落城堡》全面指南 特殊技巧分享">《失落城堡》全面指南 特殊技巧分享</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/9d3e2c99.html alt="魔獸世界坐騎收集指南 第010回 （專業製造）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c5412fa0e2de486c8ab968d147c3a385 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/9d3e2c99.html title="魔獸世界坐騎收集指南 第010回 （專業製造）">魔獸世界坐騎收集指南 第010回 （專業製造）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>