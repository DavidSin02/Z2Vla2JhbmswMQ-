<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看 | 极客快訊</title><meta property="og:title" content="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/dcd9e3b969124f1297a6bc7627747e80"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e592b29.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><meta property="article:published_time" content="2020-10-29T21:05:31+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:31+08:00"><meta name=Keywords content><meta name=description content="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e592b29.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcd9e3b969124f1297a6bc7627747e80><p class=pgc-img-caption></p></div><h1><strong>鏈表</strong></h1><p>鏈表是最基本的數據結構，面試官也常常用鏈表來考察面試者的基本能力，而且鏈表相關的操作相對而言比較簡單，也適合考察寫代碼的能力。鏈表的操作也離不開指針，指針又很容易導致出錯。</p><blockquote><p>綜合多方面的原因，鏈表題目在面試中佔據著很重要的地位。</p></blockquote><pre>public class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; }}</pre><hr><p><strong>刪除節點</strong></p><p><strong>思路：</strong></p><ul><li>將下一個節點複製到當前</li></ul><pre>public void deleteNode(ListNode node) { if (node.next == null){ node = null; return; } // 取締下一節點 node.val = node.next.val node.next = node.next.next}</pre><hr><p><strong>翻轉鏈表</strong></p><p><strong>思路</strong></p><p>思路：每次都將原第一個結點之後的那個結點放在新的表頭後面。</p><p>比如1,2,3,4,5</p><ul><li>第一次：把第一個結點1後邊的結點2放到新表頭後面，變成2,1,3,4,5</li><li>第二次：把第一個結點1後邊的結點3放到新表頭後面，變成3,2,1,4,5</li><li>……</li><li>直到： 第一個結點1，後邊沒有結點為止。</li></ul><p><strong>視頻</strong></p><p>大聖算法 翻轉鏈表(Reverse Linked List ) -- LeetCode 206</p><pre>public ListNode reverse(ListNode head) { //prev表示前繼節點 ListNode prev = null; while (head != null) { //temp記錄下一個節點，head是當前節點 ListNode temp = head.next; head.next = prev; prev = head; head = temp; } return prev;}</pre><hr><p><strong>中間元素</strong></p><p><strong>思路</strong></p><p>我總結了一下，可以稱為 田忌賽馬’法</p><pre>public ListNode findMiddle(ListNode head){ if(head == null){ return null; }  ListNode slow = head; ListNode fast = head;  // fast.next = null 表示 fast 是鏈表的尾節點 while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; } return slow;}</pre><hr><p><strong>合併兩個已排序鏈表</strong></p><p><strong>思路</strong></p><ul><li>遞歸方法：首先比較給新鏈表接上一個結點，然後這個結點的next就是剩下的兩條鏈表合併的結果。</li></ul><div class=pgc-img><img alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/54012a6eeb6545808e624531fb8e4639><p class=pgc-img-caption></p></div><pre>public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode lastNode = dummy;  while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { lastNode.next = l1; l1 = l1.next; } else { lastNode.next = l2; l2 = l2.next; } lastNode = lastNode.next; }  if (l1 != null) { lastNode.next = l1; } else { lastNode.next = l2; }  return dummy.next;}</pre><hr><p><strong>鏈表排序</strong></p><p><strong>歸併排序</strong></p><ul><li>歸併排序的也是基於分治的思想，但是與快排不同的是歸併是先劃分，然後從底層開始向上合併。</li><li>歸併排序的主要思想是將兩個已經排好序的分段合併成一個有序的分段。除了找到中間節點的操作必須遍歷鏈表外，其它操作與數組的歸併排序基本相同。</li><li><strong>視頻</strong></li></ul><p>合併兩個排序鏈表</p><pre>public ListNode sortList(ListNode head) { if (head == null || head.next == null) { return head; } // 取得中間節點，將鏈表一分為二 ListNode mid = findMiddle(head); ListNode right = sortList(mid.next); mid.next = null; ListNode left = sortList(head); return mergeTwoLists(left, right);}// 查找中間元素算法public ListNode findMiddle(ListNode head){ if(head == null){ return null; }  ListNode slow = head; ListNode fast = head;  // fast.next = null 表示 fast 是鏈表的尾節點 while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; } return slow;}// 合併兩個有序鏈表public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode lastNode = dummy;  while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { lastNode.next = l1; l1 = l1.next; } else { lastNode.next = l2; l2 = l2.next; } lastNode = lastNode.next; }  if (l1 != null) { lastNode.next = l1; } else { lastNode.next = l2; }  return dummy.next;}</pre><hr><p><strong>快速排序</strong></p><p>快速排序的主要思想是：</p><ol><li>選定一個基準元素</li><li>經過一趟排序，將所有元素分成兩部分</li><li>分別對兩部分重複上述操作，直到所有元素都已排序成功</li></ol><p>因為單鏈表只能從鏈表頭節點向後遍歷，沒有prev指針，因此必須選擇頭節點作為基準元素。這樣第二步操作的時間複雜度就為O(n)。由於之後都是分別對兩部分完成上述操作，因此會將鏈表劃分為lgn個段，因此時間複雜度為O(nlgn）</p><div class=pgc-img><img alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/93834ca9475d4897b63345d7be8e99b6><p class=pgc-img-caption></p></div><pre>public ListNode sortList(ListNode head) { quickSort(head, null); return head;}private void quickSort(ListNode start, ListNode end) { if (start == end) { return; }  ListNode pt = partition(start, end); quickSort(start, pt); quickSort(pt.next, end);}// 快排 輪狀法private ListNode partition(ListNode start, ListNode end) { int pivotKey = start.val; ListNode p1 = start, p2 = start.next; while (p2 != end) { if (p2.val &lt; pivotKey) { p1 = p1.next; swapValue(p1, p2); } p2 = p2.next; }  swapValue(start, p1); return p1;}private void swapValue(ListNode node1, ListNode node2) { int tmp = node1.val; node1.val = node2.val; node2.val = tmp;}</pre><hr><p><strong>兩個鏈表是否相交</strong></p><p><strong>思路</strong></p><ol><li>如果兩個單鏈表有共同的節點</li><li>那麼從第一個節點開始，後面的節點都會重疊，直至鏈表結束</li><li>因為兩個鏈表中有一個共同節點</li><li>則從這個節點裡的指針域指向下一個節點的地址就相同</li><li>所以相交以後的節點就會相同，直至鏈表結束，總的模型就像一個“Y”</li></ol><p><strong>視頻</strong></p><p>【一起玩算法】交叉鏈表練習題講解</p><div class=pgc-img><img alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7ecb08deafca4985b436d6ab6f0a415b><p class=pgc-img-caption></p></div><pre>public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode currA = headA; ListNode currB = headB; int lengthA = 0; int lengthB = 0; // 讓長的先走到剩餘長度和短的一樣 while (currA != null) { currA = currA.next; lengthA++; } while (currB != null) { currB = currB.next; lengthB++; } currA = headA; currB = headB; while (lengthA &gt; lengthB) { currA = currA.next; lengthA--; } while (lengthB &gt; lengthA) { currB = currB.next; lengthB--; }  // 然後同時走到第一個相同的地方 while (currA != currB) { currA = currA.next; currB = currB.next; }  // 返回交叉開始的節點 return currA;}</pre><h1><strong>棧 / 隊列</strong></h1><ul><li>棧（stack）又名堆棧：</li></ul><p>它是一種運算受限的線性表。限定僅在表尾進行插入和刪除操作的線性表。這一端被稱為棧頂，相對地，把另一端稱為棧底。向一個棧插入新元素又稱作進棧、入棧或壓棧，它是把新元素放到棧頂元素的上面，使之成為新的棧頂元素；從一個棧刪除元素又稱作出棧或退棧，它是把棧頂元素刪除掉，使其相鄰的元素成為新的棧頂元素。</p><div class=pgc-img><img alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/027f14f5c02142f7abbcbb073b20cb71><p class=pgc-img-caption></p></div><ul><li>隊列是一種特殊的線性表</li></ul><p>特殊之處在於它只允許在表的前端（front）進行刪除操作，而在表的後端（rear）進行插入操作，和棧一樣，隊列是一種操作受限制的線性表。進行插入操作的端稱為隊尾，進行刪除操作的端稱為隊頭。</p><div class=pgc-img><img alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63caa1e6aeb74b0b99aa6af23e50bb32><p class=pgc-img-caption></p></div><p><strong>帶最小值操作的棧</strong></p><p>這道面試題主要考察我們對於輔助棧的使用。</p><p>常見的輔助棧包括兩種：</p><ol><li>輔助棧和數據棧同步</li><li>輔助棧和數據棧不同步</li></ol><p>我們這裡採用輔助棧和數據棧同步的方式：</p><blockquote><p>特點：編碼簡單，不用考慮一些邊界情況，就有一點不好：輔助棧可能會存一些“不必要”的元素。</p></blockquote><ol><li>輔助棧為空的時候，必須放入新進來的數；</li><li>新來的數小於或者等於輔助棧棧頂元素的時候，才放入，特別注意這裡“等於”要考慮進去，因為出棧的時候，連續的、相等的並且是最小值的元素要同步出棧；</li><li>出棧的時候，輔助棧的棧頂元素等於數據棧的棧頂元素，才出棧。</li></ol><blockquote><p>總結一下：出棧時，最小值出棧才同步；入棧時，最小值入棧才同步。</p></blockquote><pre>public class MinStack { private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; // 維護一個輔助棧，傳入當前棧的最小值  public MinStack() { stack = new Stack&lt;Integer&gt;(); minStack = new Stack&lt;Integer&gt;(); } public void push(int number) { stack.push(number); if (minStack.isEmpty()) { minStack.push(number); } else { minStack.push(Math.min(number, minStack.peek())); } } public int pop() { minStack.pop(); return stack.pop(); } public int min() { return minStack.peek(); }}</pre><p><strong>有效括號</strong></p><p><strong>思路：</strong></p><ol><li>初始化棧 S。</li><li>一次處理表達式的每個括號。</li><li>如果遇到開括號，我們只需將其推到棧上即可。這意味著我們將稍後處4理它，讓我們簡單地轉到前面的 子表達式。</li><li>如果我們遇到一個閉括號，那麼我們檢查棧頂的元素。如果棧頂的元素是一個 相同類型的 左括號，那麼我們將它從棧中彈出並繼續處理。否則，這意味著表達式無效。</li><li>如果到最後我們剩下的棧中仍然有元素，那麼這意味著表達式無效。</li></ol><div class=pgc-img><img alt="高頻算法題彙總「 鏈表 + 棧 + 隊列」高級架構師必看" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/98cb334e5f7f41fbac47e7471eb2453a><p class=pgc-img-caption></p></div><pre>public boolean isValidParentheses(String s) { Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (Character c : s.toCharArray()) { if ("({[".contains(String.valueOf(c))) { stack.push(c); } else { if (!stack.isEmpty() &amp;&amp; isValid(stack.peek(), c)) { stack.pop(); } else { return false; } } } return stack.isEmpty();}private boolean isValid(char c1, char c2) { return (c1 == '(' &amp;&amp; c2 == ')') || (c1 == '{' &amp;&amp; c2 == '}') || (c1 == '[' &amp;&amp; c2 == ']');}</pre><p><strong>用棧實現隊列</strong></p><p><strong>思路：</strong></p><ol><li>思路是有兩個棧，一個用來放數據（數據棧），一個用來輔助（輔助棧）。</li><li>數據添加時，會依次壓人棧，取數據時肯定會取棧頂元素，但我們想模擬隊列的先進先出，所以就得取棧底元素，那麼輔助棧就派上用場了</li><li>把數據棧的元素依次彈出到輔助棧，但保留最後一個元素，最後數據棧就剩下了最後一個元素，直接把元素返回，這時數據棧已經沒有了數據。</li><li>最後呢，把輔助棧的元素依次壓人數據棧，這樣，我們成功取到了棧底元素。</li></ol><p><strong>視頻</strong></p><p>圖解「劍指Offer」之使用棧實現隊列</p><pre>public class MyQueue { private Stack&lt;Integer&gt; outStack; private Stack&lt;Integer&gt; inStack; public MyQueue() { outStack = new Stack&lt;Integer&gt;(); inStack = new Stack&lt;Integer&gt;(); }  private void in2OutStack(){ while(!inStack.isEmpty()){ outStack.push(inStack.pop()); } }  public void push(int element) { inStack.push(element); } public int pop() { if(outStack.isEmpty()){ this.in2OutStack(); } return outStack.pop(); } public int top() { if(outStack.isEmpty()){ this.in2OutStack(); } return outStack.peek(); }}</pre><p><strong>逆波蘭表達式求值 (後綴)</strong></p><p><strong>思路：</strong></p><ol><li>逆波蘭表達式求解,定義一個棧輔助計算</li><li>當遇到運算符"+"、"-"、"*"、"/"時,從棧中pop出兩個數字計算,否則將數字入棧;</li></ol><pre>public int evalRPN(String[] tokens) { Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); String operators = "+-*/"; for (String token : tokens) { if (!operators.contains(token)) { s.push(Integer.valueOf(token)); continue; } // 這裡有個坑 int a = s.pop(); int b = s.pop(); // 先出的在運算符後 // 後出的在運算符前 if (token.equals("+")) { s.push(b + a); } else if(token.equals("-")) { s.push(b - a); } else if(token.equals("*")) { s.push(b * a); } else { s.push(b / a); } } return s.pop();}</pre><hr><h1><strong>Attention</strong></h1><p>為了提高文章質量，防止冗長乏味</p><p><strong>下一部分算法題</strong></p><ul><li>本片文章篇幅總結越長。我一直覺得，一片過長的文章，就像一場超長的 會議/課堂，體驗很不好，所以打算再開一篇文章來總結其餘的考點</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>高頻</a></li><li><a>鏈表</a></li><li><a>隊列</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/08743ff4.html alt=講講高頻彩票的數學邏輯吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d5895bf13c71468a883ec03133404d4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/08743ff4.html title=講講高頻彩票的數學邏輯吧>講講高頻彩票的數學邏輯吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7fd3192.html alt=易消教育：消防考試高頻考點-報警閥組的設置要求 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/584eaa76c622450bb151371b2ab66d53 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7fd3192.html title=易消教育：消防考試高頻考點-報警閥組的設置要求>易消教育：消防考試高頻考點-報警閥組的設置要求</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/99965d07.html alt=星川齒輪表面高頻感應淬火設備的效果 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/aca67886a7f04fa8bb1d655e136af221 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99965d07.html title=星川齒輪表面高頻感應淬火設備的效果>星川齒輪表面高頻感應淬火設備的效果</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8800f439.html alt=互聯網公司高頻面試題目：一網打盡二叉樹！（三十三道題目精講） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8800f439.html title=互聯網公司高頻面試題目：一網打盡二叉樹！（三十三道題目精講）>互聯網公司高頻面試題目：一網打盡二叉樹！（三十三道題目精講）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3a92b42.html alt="新興互聯網券商高頻”宕機”，零佣金之後，該拼技術了 | 超級觀點" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RuKlyaI8spq0Oc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3a92b42.html title="新興互聯網券商高頻”宕機”，零佣金之後，該拼技術了 | 超級觀點">新興互聯網券商高頻”宕機”，零佣金之後，該拼技術了 | 超級觀點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/636dec1f.html alt=數量關係高頻考點梳理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd319529eb6e424c9f62d5b5fd97d636 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/636dec1f.html title=數量關係高頻考點梳理>數量關係高頻考點梳理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4f55693b.html alt=乾貨｜高頻PCB設計中出現的干擾分析及對策 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4395057f77be469e825d4700c5296393 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4f55693b.html title=乾貨｜高頻PCB設計中出現的干擾分析及對策>乾貨｜高頻PCB設計中出現的干擾分析及對策</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/065a2d87.html alt=高頻變壓器屏蔽罩相關詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a55dfad679eb4189958b25b4e20bb1be style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/065a2d87.html title=高頻變壓器屏蔽罩相關詳解>高頻變壓器屏蔽罩相關詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/73f6269c.html alt=【考研政治】框架圖及高頻知識點0531 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8199cfc94f5c4fe1b88cc72d333f90e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/73f6269c.html title=【考研政治】框架圖及高頻知識點0531>【考研政治】框架圖及高頻知識點0531</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0155a40.html alt=消息隊列及常見消息隊列介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c780000da0d4ae15990 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0155a40.html title=消息隊列及常見消息隊列介紹>消息隊列及常見消息隊列介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a7ee8a5.html alt=消息隊列的使用之RabbitMq的選型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15404744718207c9b0a18d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a7ee8a5.html title=消息隊列的使用之RabbitMq的選型>消息隊列的使用之RabbitMq的選型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc00e68.html alt=淺談消息隊列及常見的消息中間件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99348ece13f64ce49f498270b88717c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc00e68.html title=淺談消息隊列及常見的消息中間件>淺談消息隊列及常見的消息中間件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26710420.html alt=消息隊列MQ面試專題（rabbitmq） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/S86eRASG4qdgs4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26710420.html title=消息隊列MQ面試專題（rabbitmq）>消息隊列MQ面試專題（rabbitmq）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a97678b1.html alt=消息隊列之常見消息隊列分析彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b13ad5e5ff6b478797dcb7efcb7d6331 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a97678b1.html title=消息隊列之常見消息隊列分析彙總>消息隊列之常見消息隊列分析彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd67ae90.html alt=淺談消息隊列用途及常見的消息中間件的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6b0acb1aef6b4fe792b1fbd6a18d26f4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd67ae90.html title=淺談消息隊列用途及常見的消息中間件的區別>淺談消息隊列用途及常見的消息中間件的區別</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>