<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>動態規劃基礎篇之最長公共子序列問題 | 极客快訊</title><meta property="og:title" content="動態規劃基礎篇之最長公共子序列問題 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1534911245031e5c09c7696"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><meta property="article:published_time" content="2020-11-14T21:04:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:21+08:00"><meta name=Keywords content><meta name=description content="動態規劃基礎篇之最長公共子序列問題"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e5b7f2a6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>動態規劃基礎篇之最長公共子序列問題</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>一些概念：</p><p>（1）子序列： 一個序列A ＝ a1,a2,……an,中任意刪除若干項，剩餘的序列叫做A的一個子序列。也可以認為是從序列A按原順序保留任意若干項得到的序列。</p><p>例如：</p><p>對序列 1,3,5,4,2,6,8,7來說，序列3,4,8,7 是它的一個子序列。</p><p>對於一個長度為n的序列，它一共有2^n 個子序列，有(2^n – 1)個非空子序列。</p><p>請注意：子序列不是子集，它和原始序列的元素順序是相關的。</p><p>（2）公共子序列 ： 顧名思義，如果序列C既是序列A的子序列，同時也是序列B的子序列，則稱它為序列A和序列B的公共子序列。</p><p>例如：</p><p>對序列 1,3,5,4,2,6,8,7和序列 1,4,8,6,7,5 來說</p><p>序列1,8,7是它們的一個公共子序列。</p><p>請注意： 空序列是任何兩個序列的公共子序列。</p><p>例如： 序列1,2,3和序列4,5,6的公共子序列只有空序列。</p><p>（3）最長公共子序列</p><p>A和B的公共子序列中長度最長的（包含元素最多的）叫做A和B的公共子序列。</p><p>仍然用序列1,3,5,4,2,6,8,7和序列1,4,8,6,7,5</p><p>它們的最長公共子序列是：</p><p>1,4,8,7</p><p>1,4,6,7</p><p>最長公共子序列的長度是4 。</p><p>請注意: 最長公共子序列不唯一。</p><p>請大家用集合的觀點來理解這些概念，子序列、公共子序列以及最長公共子序列都不唯一，所以我們通常說一個最長公共子序列，但顯然最長公共子序列的長度是一定的。</p><p>最長公共子序列問題就是求序列A= a1,a2,……an, 和B = b1,b2,……bm,的一個最長公共子序列。</p><p>因為最長公共子序列不唯一，讓我們把問題簡化，如何求出兩個序列的最長公共子序列長度呢？</p><p>你首先能想到的恐怕是暴力枚舉？那我們先來看看：序列A有 2^n 個子序列，序列B有 2^m 個子序列，如果任意兩個子序列一一比較，比較的子序列高達 2^(n+m) 對，這還沒有算具體比較的複雜度。</p><p>或許你說，只有長度相同的子序列才會真正進行比較。那麼忽略空序列，我們來看看：對於A長度為1的子序列有C(n,1)個，長度為2的子序列有C(n,2)個，……長度為n的子序列有C(n,n)個。對於B也可以做類似分析，即使只對序列A和序列B長度相同的子序列做比較，那麼總的比較次數高達：</p><p>C(n,1)*C(m,1)*1 + C(n,2) * C(m,2) * 2+ …+C(n,p) * C(m,p)*p</p><p>其中p = min(m, n)。</p><p>嚇著了吧？怎麼辦？試試使用動態規劃算法！</p><p>我們用Ax表示序列A的連續前x項構成的子序列，即Ax= a1,a2,……ax, By= b1,b2,……by, 我們用LCS(x, y)表示它們的最長公共子序列長度，那原問題等價於求LCS(m,n)。為了方便我們用L(x, y)表示Ax和By的一個最長公共子序列。</p><p>讓我們來看看如何求LCS(x, y)。我們令x表示子序列考慮最後一項</p><p>（1） Ax ＝ By</p><p>那麼它們L(Ax, By)的最後一項一定是這個元素！</p><p>為什麼呢？為了方便，我們令t = Ax = By, 我們用反證法：假設L(x,y)最後一項不是t，</p><p>則要麼L(x,y)為空序列（別忘了這個），要麼L(x,y)的最後一項是Aa＝Bb ≠ t, 且顯然有a &lt; x, b &lt; y。無論是哪種情況我們都可以把t接到這個L(x,y)後面,從而得到一個更長的公共子序列。矛盾！</p><p>如果我們從序列Ax中刪掉最後一項ax得到Ax-1,從序列By中也刪掉最後一項by得到By-1，(多說一句角標為0時，認為子序列是空序列)，則我們從L(x,y)也刪掉最後一項t得到的序列是L(x – 1, y - 1)。為什麼呢？和上面的道理相同，如果得到的序列不是L(x - 1, y - 1)，則它一定比L(x - 1, y - 1)短（注意L（，）是個集合！），那麼它後面接上元素t得到的子序列L(x,y)也比L(x - 1, y - 1)接上元素t得到的子序列短，這與L(x, y)是最長公共子序列矛盾。</p><p>因此L(x, y) = L(x - 1, y - 1) 最後接上元素t</p><p>LCS(Ax, By) = LCS(x - 1, y - 1) + 1</p><p>（2） Ax ≠ By</p><p>仍然設t = L(Ax, By), 或者L(Ax, By)是空序列（這時t是未定義值不等於任何值）。</p><p>則t ≠ Ax和t ≠ By至少有一個成立，因為t不能同時等於兩個不同的值嘛！</p><p>（2.1） 如果t ≠ Ax，則有L(x, y)= L(x - 1, y)，因為根本沒Ax的事嘛。</p><p>LCS(x,y) = LCS(x – 1, y)</p><p>（2.2） 如果t ≠ By,l類似L(x, y)= L(x , y - 1)</p><p>LCS(x,y) = LCS(x, y – 1)</p><p>可是，我們事先並不知道t，由定義，我們取最大的一個，因此這種情況下,有LCS(x,y) = max(LCS(x – 1, y) , LCS(x, y – 1))。</p><p>看看目前我們已經得到了什麼結論：</p><p>LCS(x,y) =</p><p>(1) LCS(x - 1,y - 1) + 1 如果Ax ＝ By</p><p>(2) max(LCS(x – 1, y) , LCS(x, y – 1)) 如果Ax ≠ By</p><p>這時一個顯然的遞推式，光有遞推可不行，初值是什麼呢？</p><p>顯然，一個空序列和任何序列的最長公共子序列都是空序列！所以我們有:</p><p>LCS(x,y) =</p><p>(1) LCS(x - 1,y - 1) + 1 如果Ax ＝ By</p><p>(2) max(LCS(x – 1, y) , LCS(x, y – 1)) 如果Ax ≠ By</p><p>(3) 0 如果x = 0或者y = 0</p><p>到此我們求出了計算最長公共子序列長度的遞推公式。我們實際上計算了一個(n + 1)行(m + 1)列的表格（行是0..n，列是0..m)，也就這個二維度數組LCS(,)。</p><p>大概的偽代碼如下：</p><p>輸入序列A, B長度分別為n，m,計算二維表 LCS(int,int):</p><ol><li><br></li><li>for x = 0 to n do</li><li>for y = 0 to m do</li><li>if (x == 0 || y == 0) then</li><li>LCS(x, y) = 0</li><li>else if (Ax == By) then</li><li>LCS(x, y) = LCS(x - 1,y - 1) + 1</li><li>else</li><li>LCS(x, y) = ) max(LCS(x – 1, y) , LCS(x, y – 1))</li><li>endif</li><li>endfor</li><li>endfor</li></ol><p>注意： 我們這裡使用了循環計算表格裡的元素值，而不是遞歸，如果使用遞歸需要已經記錄計算過的元素，防止子問題被重複計算。</p><p>現在問題來了，我們如何得到一個最長公共子序列而僅僅不是簡單的長度呢？其實我們離真正的答案只有一步之遙！</p><p>仍然考慮那個遞推式，我們LCS(x,y)的值來源的三種情況：</p><p>（1） LCS(x – 1, y – 1) + 1如果Ax ＝ By</p><p>這對應L(x,y) = L(x,- 1 y- 1)末尾接上Ax</p><p>（2.1） LCS(x – 1, y) 如果Ax ≠ By且LCS(x – 1, y) ≥LCS(x, y – 1)</p><p>這對應L(x,y)= L(x – 1, y)</p><p>（2.2） LCS(x, y – 1) 如果Ax ≠ By且LCS(x – 1, y) &lt;LCS(x, y – 1)</p><p>這對應L(x,y) = L(x, y – 1)</p><p>（3） 0 如果 x =0或者y = 0</p><p>這對應L(x,y)=空序列</p><p>注意(2.1)和(2.2) ，當LCS(x – 1, y) ＝ LCS(x, y – 1)時，其實走哪個分支都一樣，雖然長度時一樣的，但是可能對應不同的子序列，所以最長公共子序列並不唯一。</p><p>神奇吧？又一個類似的遞推公式。可見我們在計算長度LCS(x,y)的時候只要多記錄一些信息，就可以利用這些信息恢復出一個最長公共子序列來。就好比我們在迷宮裡走路，走到每個位置的時候記錄下我們時從哪個方向來的，就可以從終點回到起點一樣。</p><div class=pgc-img><img alt=動態規劃基礎篇之最長公共子序列問題 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534911245031e5c09c7696><p class=pgc-img-caption></p></div><p>另外，說一下複雜度？</p><p>時間複雜度時O(n * m)，空間也是O(n * m)</p><p>今天對LCS的講解就到這裡，聰明的你是不是已經蠢蠢欲動要AC問題啦？ 心動不如行動，趕快吧。</p><p>在這裡，本寶寶找到了兩個模板，先收藏著，等過段在細細琢磨琢磨，有新的收穫再補充。</p><p>代碼一是讓你輸入兩個序列，然後輸出最長公共子序列和長度。</p><p>代碼二是讓你輸入三個序列，然後輸出最長公共子序列的長度。</p><p>代碼一：</p><ol><li><br></li><li>#include &lt;stdio.h></li><li>#include &lt;string.h></li><li>#include &lt;stdlib.h></li><li>int LCSLength(char* str1, char* str2, int **b)</li><li>{</li><li>int i,j,length1,length2,len;</li><li>length1 = strlen(str1);</li><li>length2 = strlen(str2);</li><li></li><li>//雙指針的方法申請動態二維數組</li><li>int **c = new int*[length1+1]; //共有length1+1行</li><li>for(i = 0; i &lt; length1+1; i++)</li><li>c[i] = new int[length2+1];//共有length2+1列</li><li></li><li>for(i = 0; i &lt; length1+1; i++)</li><li>c[i][0]=0; //第0列都初始化為0</li><li>for(j = 0; j &lt; length2+1; j++)</li><li>c[0][j]=0; //第0行都初始化為0</li><li></li><li>for(i = 1; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 1; j &lt; length2+1; j++)</li><li>{</li><li>if(str1[i-1]==str2[j-1])//由於c[][]的0行0列沒有使用，c[][]的第i行元素對應str1的第i-1個元素</li><li>{</li><li>c[i][j]=c[i-1][j-1]+1;</li><li>b[i][j]=0; //輸出公共子串時的搜索方向</li><li>}</li><li>else if(c[i-1][j]>c[i][j-1])</li><li>{</li><li>c[i][j]=c[i-1][j];</li><li>b[i][j]=1;</li><li>}</li><li>else</li><li>{</li><li>c[i][j]=c[i][j-1];</li><li>b[i][j]=-1;</li><li>}</li><li>}</li><li>}</li><li>/*</li><li>for(i= 0; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length2+1; j++)</li><li>printf("%d ",c[i][j]);</li><li>printf("\n");</li><li>}</li><li>*/</li><li>len=c[length1][length2];</li><li>for(i = 0; i &lt; length1+1; i++) //釋放動態申請的二維數組</li><li>delete[] c[i];</li><li>delete[] c;</li><li>return len;</li><li>}</li><li>void PrintLCS(int **b, char *str1, int i, int j)</li><li>{</li><li>if(i==0 || j==0)</li><li>return ;</li><li>if(b[i][j]==0)</li><li>{</li><li>PrintLCS(b, str1, i-1, j-1);//從後面開始遞歸，所以要先遞歸到子串的前面，然後從前往後開始輸出子串</li><li>printf("%c",str1[i-1]);//c[][]的第i行元素對應str1的第i-1個元素</li><li>}</li><li>else if(b[i][j]==1)</li><li>PrintLCS(b, str1, i-1, j);</li><li>else</li><li>PrintLCS(b, str1, i, j-1);</li><li>}</li><li></li><li>int main(void)</li><li>{</li><li>char str1[100],str2[100];</li><li>int i,length1,length2,len;</li><li>printf("請輸入第一個字符串：");</li><li>gets(str1);</li><li>printf("請輸入第二個字符串：");</li><li>gets(str2);</li><li>length1 = strlen(str1);</li><li>length2 = strlen(str2);</li><li>//雙指針的方法申請動態二維數組</li><li>int **b = new int*[length1+1];</li><li>for(i= 0; i &lt; length1+1; i++)</li><li>b[i] = new int[length2+1];</li><li>len=LCSLength(str1,str2,b);</li><li>printf("最長公共子序列的長度為：%d\n",len);</li><li>printf("最長公共子序列為：");</li><li>PrintLCS(b,str1,length1,length2);</li><li>printf("\n");</li><li>for(i = 0; i &lt; length1+1; i++)//釋放動態申請的二維數組</li><li>delete[] b[i];</li><li>delete[] b;</li><li>system("pause");</li><li>return 0;</li><li>}</li></ol><p>代碼二：</p><ol><li><br></li><li>#include &lt;stdio.h></li><li>#include &lt;string.h></li><li>#include &lt;stdlib.h></li><li>int max1(int m,int n)</li><li>{</li><li>if(m>n)</li><li>return m;</li><li>else</li><li>return n;</li><li>}</li><li>int max2(int x,int y,int z,int k,int m,int n)</li><li>{</li><li>int max=-1;</li><li>if(x>max)</li><li>max=x;</li><li>if(y>max)</li><li>max=y;</li><li>if(z>max)</li><li>max=z;</li><li>if(k>max)</li><li>max=k;</li><li>if(m>max)</li><li>max=m;</li><li>if(n>max)</li><li>max=n;</li><li>return max;</li><li>}</li><li>int LCSLength(char* str1, char* str2, char* str3) //求得三個字符串的最大公共子序列長度並輸出公共子序列</li><li>{</li><li>int i,j,k,length1,length2,length3,len;</li><li>length1 = strlen(str1);</li><li>length2 = strlen(str2);</li><li>length3 = strlen(str3);</li><li></li><li>//申請動態三維數組</li><li>int ***c = new int**[length1+1]; //共有length1+1行</li><li>for(i = 0; i &lt; length1+1; i++)</li><li>{</li><li>c[i] = new int*[length2+1]; //共有length2+1列</li><li>for(j = 0; j&lt;length2+1; j++)</li><li>c[i][j] = new int[length3+1];</li><li>}</li><li></li><li>for(i = 0; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length2+1; j++)</li><li>c[i][j][0]=0;</li><li>}</li><li>for(i = 0; i &lt; length2+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length3+1; j++)</li><li>c[0][i][j]=0;</li><li>}</li><li>for(i = 0; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length3+1; j++)</li><li>c[i][0][j]=0;</li><li>}</li><li></li><li>for(i = 1; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 1; j &lt; length2+1; j++)</li><li>{</li><li>for(k = 1; k &lt; length3+1; k++)</li><li>{</li><li>if(str1[i-1]==str2[j-1] && str2[j-1]==str3[k-1])</li><li>c[i][j][k]=c[i-1][j-1][k-1]+1;</li><li>else if(str1[i-1]==str2[j-1] && str1[i-1]!=str3[k-1])</li><li>c[i][j][k]=max1(c[i][j][k-1],c[i-1][j-1][k]);</li><li>else if(str1[i-1]==str3[k-1] && str1[i-1]!=str2[j-1])</li><li>c[i][j][k]=max1(c[i][j-1][k],c[i-1][j][k-1]);</li><li>else if(str2[j-1]==str3[k-1] && str1[i-1]!=str2[j-1])</li><li>c[i][j][k]=max1(c[i-1][j][k],c[i][j-1][k-1]);</li><li>else</li><li>{</li><li>c[i][j][k]=max2(c[i-1][j][k],c[i][j-1][k],c[i][j][k-1],c[i-1][j-1][k],c[i-1][j][k-1],c[i][j-1][k-1]);</li><li>}</li><li>}</li><li>}</li><li>}</li><li>len=c[length1][length2][length3];</li><li>for(i = 1; i &lt; length1+1; i++) //釋放動態申請的三維數組</li><li>{</li><li>for(j = 1; j &lt; length2+1; j++)</li><li>delete[] c[i][j];</li><li>delete[] c[i];</li><li>}</li><li>delete[] c;</li><li>return len;</li><li>}</li><li></li><li>int main(void)</li><li>{</li><li>char str1[100],str2[100],str3[100];</li><li>int len;</li><li></li><li>printf("請輸入第一個字符串：");</li><li>gets(str1);</li><li>printf("請輸入第二個字符串：");</li><li>gets(str2);</li><li>printf("請輸入第三個字符串：");</li><li>gets(str3);</li><li>len=LCSLength(str1,str2,str3);</li><li>printf("最長公共子序列的長度為：%d\n",len);</li><li>system("pause");</li><li>return 0;</li><li>}</li></ol><div class=pgc-img><img alt=動態規劃基礎篇之最長公共子序列問題 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534911259487118c56b5a9><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>動態</a></li><li><a>規劃</a></li><li><a>基礎</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1eb60881.html alt=NOIP2018動態規劃複習-樹型動態規劃！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/dc30169e-7dfd-4c59-b2b3-7ff96d108dcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1eb60881.html title=NOIP2018動態規劃複習-樹型動態規劃！>NOIP2018動態規劃複習-樹型動態規劃！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f14f41a.html alt=IT基礎架構規劃方案一（網絡系統規劃） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1537435739774af851c7b9e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f14f41a.html title=IT基礎架構規劃方案一（網絡系統規劃）>IT基礎架構規劃方案一（網絡系統規劃）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html alt=素描五官基礎知識，學素描的同學可參考 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99b7762898d34e2f9a667c431fc7da6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html title=素描五官基礎知識，學素描的同學可參考>素描五官基礎知識，學素描的同學可參考</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c480db6b.html alt=梯度，散度，旋度的重要基礎：對向量場的詮釋 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c8ce2cc3bb0f4a5da0dcbc0a881f9617 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c480db6b.html title=梯度，散度，旋度的重要基礎：對向量場的詮釋>梯度，散度，旋度的重要基礎：對向量場的詮釋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html alt=動態網站和靜態網站有什麼區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6a06f21d115b4b93a7934a7075691503 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html title=動態網站和靜態網站有什麼區別>動態網站和靜態網站有什麼區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/40b3969a.html alt=專業音頻基礎概念｜數字音頻是如何工作的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3684bfc4e93447a5bdfd6d573beec22c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/40b3969a.html title=專業音頻基礎概念｜數字音頻是如何工作的？>專業音頻基礎概念｜數字音頻是如何工作的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3faa79.html alt=立體聲系統基礎篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15288739589536026ad6bae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3faa79.html title=立體聲系統基礎篇>立體聲系統基礎篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18bd39d8.html alt=齒輪基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b8e178319e2c4b88a1865f903306a26b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18bd39d8.html title=齒輪基礎知識>齒輪基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3555f615.html alt=流體粘度傳感器的基礎知識與應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7f6d9f85a08146e5a84877ef92c212d7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3555f615.html title=流體粘度傳感器的基礎知識與應用>流體粘度傳感器的基礎知識與應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html alt=SQL基礎知識——事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/773e21df09dc4e3e8403a0a62994039d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html title=SQL基礎知識——事務>SQL基礎知識——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html alt="軟件開發中數據庫必備基礎01 - 圖解事務基礎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4e00ac778db451792b955bde23add02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html title="軟件開發中數據庫必備基礎01 - 圖解事務基礎">軟件開發中數據庫必備基礎01 - 圖解事務基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/74d576ca.html alt=動態交聯重組實現了碳納米管在交聯彈性體中的單軸拉伸取向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d28c195508f40acbe0e107477931021 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/74d576ca.html title=動態交聯重組實現了碳納米管在交聯彈性體中的單軸拉伸取向>動態交聯重組實現了碳納米管在交聯彈性體中的單軸拉伸取向</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>