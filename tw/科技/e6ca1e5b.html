<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JAVA：面向對象編程的底層邏輯，深度剖析 | 极客快訊</title><meta property="og:title" content="JAVA：面向對象編程的底層邏輯，深度剖析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f7362955cbfb4eb0bb89b09491c5d9a0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6ca1e5b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6ca1e5b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e6ca1e5b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6ca1e5b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6ca1e5b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e6ca1e5b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e6ca1e5b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6ca1e5b.html><meta property="article:published_time" content="2020-10-29T21:10:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:38+08:00"><meta name=Keywords content><meta name=description content="JAVA：面向對象編程的底層邏輯，深度剖析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JAVA：面向對象編程的底層邏輯，深度剖析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=pgc-h-arrow-right>什麼是面向對象</h2><p>在目前的軟件開發領域有兩種主流的開發方法，分別是結構化開發方法和麵向對象開發方法。早期的編程語言如C、Basic、Pascal等都是結構化編程語言，隨著軟件開發技術的逐漸發展，人們發現面向對象可以提供更好的可重用性、可擴展性和可維護性，於是催生了大量的面向對象的編程語言，如C++、Java、C#和Ruby等。</p><p>面向對象程序設計即OOP，是Object-Oriented Programming的縮寫。面向對象編程技術是一種起源於20世紀60年代的Simula語言，其自身理論已經十分完善，並被多種面向對象程序設計語言（Object-Oriented Programming Langunianling，OOPL）實現。由於很多原因，國內大部分程序設計人員並沒有很深的OOP以及OOPL理論，很多人從一開始學習到工作很多年都只是接觸到C/C++、Java等靜態類型語言，而對純粹的OOP思想以及動態類型語言知之甚少。</p><p>對象的產生通常基於兩種基本方式，分別是以原型對象為基礎產生新對象和以類為基礎產生新對象。</p><h5 class=pgc-h-arrow-right>1．基於原型</h5><p>原型模型是以一個有代表性的對象為基礎來產生各種新的對象，並由此繼續產生更符合實際應用的對象。而原型—委託也是OOP中的對象抽象，是代碼共享機制中的一種。</p><h5 class=pgc-h-arrow-right>2．基於類</h5><p>一個類提供了一個或多個對象的通用性描敘。從形式化的觀點看，類與類型有關，因此，一個類相當於是從該類中產生的實例的集合。</p><h2 class=pgc-h-arrow-right>Java的面向對象編程</h2><p>面向對象編程方法學是Java編程的指導思想。在使用Java進行編程時，應該首先利用對象建模技術（OMT）來分析目標問題，抽象出相關對象的共性，對它們進行分類，並分析各類之間的關係；然後再用類來描述同一類對象，歸納出類之間的關係。Coad和Yourdon在對象建模技術、面向對象編程和知識庫系統的基礎之上設計了一整套面向對象的方法，具體來說分為面向對象分析（OOA）和麵向對象設計（OOD）。對象建模技術、面向對象分析和麵向對象設計共同構成了系統設計的過程，如圖1所示。</p><p><br></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f7362955cbfb4eb0bb89b09491c5d9a0><p class=pgc-img-caption></p></div><p>圖1　系統設計處理流程</p><h2 class=pgc-h-arrow-right>UML統一建模語言</h2><p>在進行對象建模、面向對象分析和設計的過程中，需要使用建模語言來描述分析的過程和結果。統一建模語言即UML，是Unified Modeling Langunianling的縮寫。UML是為了實現上述目標而設計的一種標準通用的設計語言。</p><h5 class=pgc-h-arrow-right>1．UML圖的類型</h5><p>UML為我們提供了多種類型的模型描述圖，當在某種給定的方法學中使用這些圖時，人們就能更容易理解和交流設計思想。UML圖可以分為如下3種類型。</p><p>（1）靜態圖。</p><p>靜態圖即Static Diagram，其功能是描述了不發生任何變化的軟件元素的邏輯結構，描繪了類、對象和數據結構及其存在於它們之間的關係。</p><p>（2）動態圖。</p><p>動態圖即Dynamic Diagram，其功能是展示軟件實體在運行期間的的變化，主要描繪了執行流程、實體改變狀態的方式。</p><p>（3）物理圖。</p><p>物理圖即Physical Diagram，其功能是顯示軟件實體不變化的物理結構，主要用來描繪庫文件、字節文件和數據文件等，以及存在於它們之間的相互關係。</p><h5 class=pgc-h-arrow-right>2．類圖和對象圖</h5><p>在Java中，通常使用類圖和對象圖來表示項目內程序類的結構和各元素間的對應關係。在下面的內容中，將簡要介紹類圖和對象圖的基本知識。</p><p>（1）類圖。</p><p>類圖表示不同的實體間的相互關係，顯示了系統的靜態結構。類圖可用於表示邏輯類，邏輯類通常是指事物的種類，比如球隊、電影之類的抽象描述。類圖還可以用於表示實現類，實現類就是程序員要編寫的類。實現類圖與邏輯類圖可能會用來描述一些相同的類。然而，實現類圖與邏輯類圖不會使用相同的描述屬性。</p><p>類圖通常用矩形表示，並在矩形內將類分為3個部分。其中最上面的部分顯示類的名稱，中間部分顯示類的屬性，最下面的部分顯示類的方法，例如圖2所示的格式。</p><p><br></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46aeb22337d240bb96e19e350619cede><p class=pgc-img-caption></p></div><p>圖2　典型類圖結構</p><p>注意</p><blockquote class="強提示 editing-block"><p>在現實應用中，最常用、最簡單的類圖就是一個在裡面顯示了類名的長方形。在大多數的UML中，多數類只要有一個能夠清楚表達的命名就可以了。</p></blockquote><p>在類名部分還可以顯示類的構造類型，類的構造型在雙角括符號“« »”之間指定，並放在類的名稱上面。常見的構造類型包括如下3類。</p><ul><li>實現類：直接顯示類的名稱。</li><li>接口：在類名上方的雙角括符號“« »”內顯示。</li><li>工具類：在類名上方的雙角括符號“« »”內顯示。</li></ul><p>如果類名用斜體表示，或者在類名下面，則表示這個類是一個抽象類。</p><p>在屬性和方法的前面可以用修飾符“+”或“-”，其功能是表示屬性或方法的作用域，具體說明如下所示。</p><ul><li>修飾符“-”：表示屬性或方法是私有的（private）。</li><li>修飾符“#”：表示屬性或方法是保護的（protected）。</li><li>修飾符“+”：表示屬性或方法是公用的（public）。</li></ul><p>通常在類的屬性或方法參數名稱的冒號後，顯示了屬性的類型或方法的參數的類型。方法的返回值類型顯示在方法後面的冒號之後。</p><p>例如圖3顯示了一個Lei類的類圖結構。</p><p><br></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbfdbbeea0e0458aa93e3910731d30b2><p class=pgc-img-caption></p></div><p>圖3　Lei類的類圖結構</p><p>（2）對象圖。</p><p>對象圖的功能是用來表示類的實例化對象。通常用一個兩層的矩形結構來表示對象圖，其中上層標識對象名和類名，下層標識對象的實例化屬性值。例如在下面的代碼中，創建了一個Lei類的對象mm。</p><pre><code>Lei mm = new Lei("mm", 'F', 24);</code></pre><p>上述mm對象的對象圖如圖4所示。</p><p><br></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0f43271f01574eb2979e7bbd99cd6437><p class=pgc-img-caption></p></div><p>圖4　對象圖示例</p><p>在同一個應用項目中，類之間可能存在如下多種類別的相互關係。</p><ul><li>繼承：即inheritance，是指一個類從其父類派生而來，繼承了父類的屬性和方法。基於類的繼承叫做一般化（generalization），基於接口的繼承，叫做實現（realization）。</li><li>關聯：即association，類之間的關聯大多用來表示變量實例持有對其他對象的引用，這種關係是半永久的，並沒有包含關係。</li><li>依賴：即dependency，是不同類實例之間的暫時相互關係。</li><li>聚合：即aggregation，是關聯的一種特殊形式，代表著一種整體和部分的關係。並且裡面的部分可以作為其他整體的部分，而部分和整體之間也沒有生命期的依賴。</li><li>組合：即composition，是聚合的一種特殊形式。組合的關聯性比聚合更強，而部分只能作為唯一的一個整體的部分，而且部分的生命週期依賴於整體的生命週期。</li></ul><p>UML是一種設計語言，它的目的不是表現細節，而是表現結構，僅僅展示必要的細節。所以UML不可能與源代碼一一對應，只是在結構上存在了某種對應關係。</p><h5 class=pgc-h-arrow-right>3．序列圖和狀態圖</h5><p>除了前面介紹的類圖和對象圖外，在Java中還可以使用序列圖和狀態圖來表示項目內程序類的結構和各元素間的對應關係。在下面的內容中，將對序列圖和狀態圖的基本知識進行簡要介紹。</p><p>（1）序列圖。</p><p>序列圖顯示具體用例（或用例的一部分）的詳細流程，它不但顯示了流程中不同對象之間的交互關係，而且還可以很詳細地顯示對不同對象的各種調用。在序列圖中有如下兩個維度。</p><ul><li>垂直維度：以發生的時間順序顯示消息/調用的序列。</li><li>水平維度：顯示對象實例之間的交互。</li></ul><p>對象之間的交互存在如下5種關係。</p><ul><li>調用：即call，一個對象調用另一個對象（或本身）的方法。</li><li>返回：即return，返回一個值作為方法調用的結果。</li><li>發送：即send，一個對象給另一個對象（或本身）異步發送一個消息。</li><li>創建：即create，一個對象實例化另一個對象。</li><li>銷燬：即destroy，一個對象銷燬另一個對象（或本身）。</li></ul><p>繪製序列圖的方法非常簡單，通常用圖頂部的框表示類的實例對象，框中的類實例名稱和類名稱之間用空格/冒號/空格來分隔。如果某個類實例向另一個類實例發送了處理消息，則繪製一條具有指向接收類實例的開箭頭的連線，並把處理的名稱放在連線上面。對於某些特別重要的消息，可以繪製一條具有指向發起類實例的開箭頭的虛線，將返回值標註在虛線上。有助於序列圖的閱讀。</p><p>（2）狀態圖。</p><p>狀態圖表示某個類所處的不同狀態和該類的狀態轉換信息。每個類都有狀態，但不是每個類都應該有一個狀態圖。只有當行為的改變和狀態有關時才創建狀態圖。一般只描述在系統活動期間具有3個或更多潛在狀態的類的狀態圖。</p><p>狀態圖中的符號集包括如下5個基本元素。</p><ul><li>初始起點：使用實心圓來繪製。</li><li>狀態轉換：使用帶箭頭的線段來繪製。</li><li>當前狀態：使用圓角矩形來繪製。</li><li>判斷點：使用空心圓來繪製。</li><li>一個或者多個終止點：使用內部包含實心圓的圓來繪製。</li></ul><p>在繪製狀態圖時，首先需要繪製起點和一條指向該類的初始狀態的轉換線段。狀態本身可以在圖上的任意位置繪製，然後只需使用狀態轉換線條將它們連接起來。</p><h2 class=pgc-h-arrow-right>對象建模技術</h2><p>對象建模技術源於通用電氣公司的一套系統開發技術，是以面向對象的思想為基礎，通過對問題進行抽象而構造出一組相關的模型。通過對象建模技術，可以全面地描述問題領域的結構。對象建模技術把分析時收集到的信息構造在如下3類模型中。</p><ul><li>功能模型：功能模型定義系統做什麼。</li><li>對象模型：對象模型定義系統對誰做。</li><li>動態模型：動態模型定義系統如何做。</li></ul><p>通過上述3個模型，可以從不同的角度對系統進行描述，首先分別著重於系統的某個側面，然後整體組合起來構成對系統的完整描述。</p><h5 class=pgc-h-arrow-right>1．功能模型</h5><p>功能模型的功能是實現系統內部數據的傳送和處理。功能模型能夠說明，從輸入數據能夠計算出什麼樣的輸出數據，但是，沒有考慮參加計算的數據按什麼時序來執行。功能模型由多個數據流圖組成，它們指明從外部輸入，通過操作和內部存儲，直到外部輸出的整個數據流情況。功能模型還包括了對象模型內部數據間的限制。功能模型中的數據流圖往往形成一個層次結構，一個數據流圖的過程可以由下一層的數據流圖作進一步的說明。UML中通常使用用例圖和活動圖來描述功能模型。</p><p>建立功能模型的主要步驟如下所示。</p><p>（1）確定輸入和輸出值。</p><p>（2）用數據流圖表示功能的依賴性。</p><p>（3）具體說明每個具體功能。</p><p>（4）確定限制。</p><p>（5）確定功能優化的準則。</p><p>上述操作的具體實現流程如圖5所示。</p><p><br></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8b1bd0ae04b74b16a7e46e2fe93d14a2><p class=pgc-img-caption></p></div><p>圖5　功能模型處理流程</p><h5 class=pgc-h-arrow-right>2．對象模型</h5><p>對象模型的功能是描述系統的靜態結構，包括類和對象，它們的屬性和操作，以及它們之間的關係。構造對象模型的主要目的是，發掘與項目應用密切相關的概念。對象模型用包含對象和對象之間關係的圖來表示，在UML中通常使用類圖和對象圖來描述對象模型。</p><p>使用OMT建立對象模型的主要步驟如下所示。</p><p>（1）確定對象類。</p><p>（2）定義數據詞典，並利用它來描述類的屬性和類之間的關係。</p><p>（3）用繼承來組織和簡化類的結構和類之間的關係。</p><p>（4）測試訪問路徑。</p><p>（5）根據對象之間的關係和對象的功能將對象分組建立模塊。</p><p>上述操作的具體實現流程如圖6所示。</p><p><br></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/13eef52974ca4840bff3853e4c4d9328><p class=pgc-img-caption></p></div><p>圖6　對象模型處理流程</p><h5 class=pgc-h-arrow-right>3．動態模型</h5><p>動態模型主要用於控制系統的邏輯，考察在任何時候對象及其關係的改變，描述這些涉及時序和改變的狀態。通常使用狀態圖和事件跟蹤圖來描述動態模型。</p><p>狀態圖是狀態和事件以及它們之間的關係所形成的網絡，側重於描述每一類對象的動態行為。而事件跟蹤圖則側重於說明系統執行過程中的一個特點場景，描述完成系統某個功能的一個事件序列。</p><p>對象到對象的單個消息叫做一個事件。在系統的一個特定環境下發生的一系列事件叫做一個場景。場景通常起始於一個系統外部的輸入事件，結束於一個系統外部的輸出事件。在一個場景中，一系列事件和交換事件的對象都可以放在一個事件跟蹤圖中表示。UML使用狀態圖和序列圖來描述動態模型，序列圖對應於事件跟蹤圖。</p><p>建立動態模型的主要步驟如下所示。</p><p>（1）預製典型的交互序列場景。</p><p>（2）確定對象之間的事件，為每個場景建立事件跟蹤圖。</p><p>（3）為每個系統預製一個事件流圖。</p><p>（4）為具有重要動態行為的類建立狀態圖。</p><p>（5）檢驗不同狀態圖中共享的事件的一致性和完整性。</p><p>上述操作的具體實現流程如圖7所示。</p><p><br></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/55913c69f76a41b8b796f4f10f24083a><p class=pgc-img-caption></p></div><p>圖7　動態模型處理流程</p><h2 class=pgc-h-arrow-right>面向對象分析</h2><p>面向對象分析屬於軟件開發過程中的問題定義階段。傳統的系統分析產生一組面向過程的文檔，定義目標系統的功能；面向對象分析則產生一種描述系統功能和問題領域的基本特徵的綜合文檔。</p><h5 class=pgc-h-arrow-right>1．面向對象分析的原則</h5><p>Java中面向對象的分析需要遵循下面的原則。</p><p>（1）抽象。</p><p>從許多事物中捨棄個別的、非本質的特徵，抽取共同的、本質性的特徵，這就是抽象。抽象是形成概念的必要手段。抽象原則具有如下兩點意義。</p><ul><li>儘管問題域中的事物是很複雜的，但是分析員並不需要了解和描述它們的一切，只需要分析研究其中與系統目標有關的事物及其本質性特徵。</li><li>通過捨棄個體事物在細節上的差異，抽取其共同特徵而得到一批事物的抽象概念。</li></ul><p>抽象是面向對象方法中使用最為廣泛的原則，抽象原則包括過程抽象和數據抽象兩個方面。</p><ul><li>過程抽象：任何一個完成確定功能的操作序列，使用者都可以把它看成一個單一的實體，儘管實際上它可能是由一系列更低級的操作完成的。</li><li>數據抽象：根據施加於數據之上的操作來定義數據類型，並限定數據的值只能由這些操作來修改和觀察。數據抽象是面向對象分析的核心原則。它強調把數據（屬性）和操作（服務）結合為一個不可分的對象，對象的外部只需要知道它做什麼，而不必知道它如何做。</li></ul><p>（2）封裝。</p><p>封裝就是把對象的屬性和服務結合為一個不可分的系統單位，並儘可能隱蔽對象的內部細節。</p><p>（3）繼承。</p><p>特殊類的對象擁有的其一般類的全部屬性與服務，這是特殊類對一般類的繼承。在面向對象分析中運用繼承原則，就是在每個由一般類和特殊類形成的結構中，把一般類的對象實例和所有特殊類的對象實例都共同具有的屬性和服務，一次性地在一般類中進行顯式定義。在特殊類中不再重複地定義一般類中已定義的東西，但是在語義上，特殊類卻自動地、隱含地擁有它的一般類（以及所有更上層的一般類）中定義的全部屬性和服務。繼承原則的好處是：使系統模型比較清晰。</p><p>（4）分類。</p><p>分類就是把具有相同屬性和服務的對象劃分為一類，用類作為這些對象的抽象描述。分類原則實際上是抽象原則運用於對象描述時的一種表現形式。</p><p>（5）聚合。</p><p>聚合的原則是：把一個複雜的事物看成若干比較簡單的事物的組裝體，從而簡化對複雜事物的描述。</p><p>（6）關聯。</p><p>通過一個事物聯想到另外的事物，能使人發生聯想的原因是事物之間確實存在著某些聯繫。</p><p>（7）消息通信。</p><p>這一原則要求對象之間只能通過消息進行通信，而不允許在對象之外直接地存取對象內部的屬性。通過消息進行通信是由於封裝原則引起的。在OOA中要求用消息連接表示出對象之間的動態聯繫。</p><p>（8）粒度控制。</p><p>考慮某部分的細節時暫時撇開其餘的部分，這就是粒度控制原則。</p><h5 class=pgc-h-arrow-right>2．面向對象分析的階段</h5><p>面向對象分析的過程分為兩個階段，分別是問題領域分析和應用分析，這兩個階段的具體說明如下所示。</p><p>（1）問題領域分析階段。</p><p>問題領域分析是軟件開發的基本組成部分，目的是使開發人員瞭解問題領域的結構，建立大致的系統實現環境。問題領域分析給出一組抽象概念作為特定系統需求開發的參考。問題領域分析實際上是一種學習過程。軟件開發人員在這個階段應該儘可能地理解當前系統中與應用有關的知識，放寬考慮的範圍，儘可能地標識與應用有關的概念。有了廣泛的問題領域知識，涉及具體的應用時，就可以更快地進入狀態，掌握應用的核心知識。而且，在用戶改變對目標系統的需求時，廣泛的分析可以幫助我們預測出目標系統在哪些方面會發生哪些變化。在分析過程中，應該標識出系統的基本概念（對象、類、方法、關係等）、識別問題領域的特徵，並把這些概念集成到問題領域的模型中。問題領域的模型必須包含概念之間的關係，以及每個概念的全部信息。標識出來的相關概念應該根據信息內容來有機地融合到問題領域的綜合視圖中。</p><p>（2）應用分析階段。</p><p>應用分析是依據在問題領域分析時建立起來的問題領域模型來進行的。應用分析時，把問題領域模型用於當前特定的應用之中。首先，通過收集到的用戶信息來對問題領域進行取捨，把用戶需求作為限制條件來使用，以縮減問題領域的信息量。因此，問題領域分析的視野大小直接影響到應用分析保留的信息量。一般來說，問題領域分析階段產生的模型並不需要用程序設計語言來表示，而應用分析階段產生的影響條件則需要用某種程序設計語言來表示。模型識別的要求可以針對一個應用，也可以針對多個應用。通常我們著重考慮兩個方面，即應用視圖和類視圖。在類視圖中，必須對每個類的屬性和操作進行細化，並表示出類之間的相互作用關係。</p><h5 class=pgc-h-arrow-right>3．面向對象分析的具體目標</h5><p>面向對象分析需要完成如下兩個目標。</p><p>（1）形式化地說明所面對的應用問題，最終形成軟件系統基本構成的對象，以及系統所必須遵從的、由應用環境所決定的規則和約束條件。</p><p>（2）明確地規定構成系統的對象如何協同工作和完成指定的功能。</p><p>通過面向對象分析所建立的系統模型是以概念為中心的，因此稱為概念模型。概念模型由一組相關的類組成。面向對象分析可以通過自頂向下地逐層分解來建立系統模型，也可以自底向上地從已經定義的類出發，逐步構造新的類。</p><p>概念模型的構造和評審由如下5個層次構成。</p><ul><li>類和對象層。</li><li>屬性層。</li><li>服務層。</li><li>結構層。</li><li>主題層。</li></ul><p>上述5個層次不是構成軟件系統的層次，而是分析過程中的層次。當5個層次的工作全部完成時，面向對象分析的任務也就完成了。</p><p>注意</p><blockquote class="強提示 editing-block"><p>在實際編程操作中，面向對象分析的目標是得出問題領域的功能模型、對象模型和動態模型，並用相應的UML圖將它們表示出來。</p></blockquote><h2 class=pgc-h-arrow-right>面向對象設計</h2><p>經過前面的分析處理後，接下來就可以進行具體設計了。面向對象設計的任務是對面向對象分析的結果進行規範化整理，以便能夠被面向對象編程直接接受。在接下來的內容中，將簡要介紹面向對象設計的基本知識。</p><h5 class=pgc-h-arrow-right>1．面向對象設計概述</h5><p>面向對象設計是一種軟件設計方法，是一種工程化規範。面向對象設計中主要的操作如下所示。</p><ul><li>確定需要的類。</li><li>給每個類提供一組完整的操作。</li><li>明確地使用繼承來表現共同點。</li></ul><p>所以說，面向對象設計就是一個根據需求決定所需的類、類的操作，以及類之間關聯的過程。</p><p>從面向對象分析到面向對象設計是一個逐步擴充模型的過程。面向對象分析以實際問題為中心，可以不考慮與軟件實現相關的任何問題，主要考慮“做什麼”的問題；面向對象設計則是面向軟件實現的實際開發活動，主要考慮“怎麼做”的問題。</p><p>面向對象設計的目標是管理程序內部各部分的相互依賴關係。為了達到這個目標，面向對象設計要求將程序分成塊，然後分別將各個塊隱藏在接口（interface）的後面，讓它們只通過接口相互交流。比如說，如果用面向對象設計的方法來設計一個客戶端—服務器應用，那麼服務器和客戶端之間不應該有直接的依賴，而是應該讓服務器的接口和客戶端的接口相互依賴。</p><h5 class=pgc-h-arrow-right>2．面向對象設計的原則</h5><p>面向對象設計所要遵循的原則如下所示。</p><p>（1）模塊化。</p><p>面向對象開發方法很自然地支持了把系統分解成模塊的設計原則：對象就是模塊。它是把數據結構和操作這些數據的方法緊密地結合在一起所構成的模塊。</p><p>（2）抽象。</p><p>面向對象方法不僅支持過程抽象，而且支持數據抽象。</p><p>（3）信息隱藏。</p><p>在面向對象方法中，信息隱藏通過對象的封裝性來實現。</p><p>（4）低聯繫。</p><p>在面向對象方法中，對象是最基本的模塊，因此，聯繫主要指不同對象之間相互關聯的緊密程度。低聯繫是設計的一個重要標準，因為這有助於使得系統中某一部分的變化對其他部分的影響降到最低。</p><h5 class=pgc-h-arrow-right>3．面向對象設計的任務</h5><p>面向對象設計有如下3個任務。</p><p>（1）對象定義規格的求精。</p><p>對於面向對象分析所抽象出來的對象、類，以及彙集的分析文檔，面向對象設計需要有一個根據設計要求整理和求精的過程，使之更能符合面向對象編程的需要，具體實施如下。</p><ul><li>根據面向對象的概念模型整理分析所確定的對象結構、屬性、方法等內容，改正錯誤的內容，刪去不必要和重複的內容等。</li><li>進行分類整理，以便於下一步數據庫設計和程序處理模塊設計的需要，整理的方法主要是進行歸類，對類、對象、屬性、方法和結構、主題進行歸類。</li></ul><p>（2）數據模型和數據庫設計。</p><p>數據模型的設計需要確定類、對象屬性的內容、消息連接的方式、系統訪問、數據模型的方法等。最後，每個對象實例的數據都必須落實到面向對象的庫結構模型中。</p><p>（3）優化。</p><p>面向對象設計的優化設計過程是從另一個角度對分析結果和處理業務過程的整理歸納，優化包括對象和結構的優化、抽象、集成。</p><h5 class=pgc-h-arrow-right>4．面向對象設計的過程和步驟</h5><p>面向對象設計的過程，是通過利用設計階段中的4個層次來建立系統的問題領域、用戶界面、任務管理和數據管理的過程。</p><p>（1）問題領域。</p><p>問題領域包括與我們所面對的應用問題直接相關的所有類和對象。主要是根據需求的變化來對面向對象分析階段產生的模型中的類和對象、結構、屬性和操作進行組合和分解，根據面向對象設計原則來增加必要的類、屬性和關係。</p><p>（2）用戶界面。</p><p>通常在面向對象分析階段給出了所需的屬性和操作，在面向對象設計階段必須根據需求把交互的細節加入用戶界面的設計中，包括有效的人機交互所必需的實際顯示和輸入。</p><p>用戶界面部分的設計主要由以下7個方面組成。</p><ul><li>用戶分類。</li><li>描述人及其任務的腳本。</li><li>設計命令層。</li><li>設計詳細的交互。</li><li>繼續擴展用戶界面原型。</li><li>設計人機交互類。</li><li>根據圖形用戶界面進行設計任務管理部分的設計。</li></ul><p>（3）任務管理。</p><p>任務是進程的別稱，是執行一系列活動的一段程序。當系統中有許多併發行為時，需要依照各個行為的協調和通信關係來劃分各種任務，以簡化併發行為的設計和編碼。任務管理主要包括任務的選擇和調整。</p><p>（4）數據管理。</p><p>數據管理提供了在數據管理系統中存儲和檢索對象的基本結構，包括對永久性數據的訪問和管理。數據管理的方法主要有3種，分別是文件管理、關係數據庫管理，以及面向對象的數據庫管理。</p><h2 class=pgc-h-arrow-right>Java的面向對象特性</h2><p>Java是一門純粹的面向對象的編程語言，完全支持封裝、繼承和多態這三大面向對象的基本特徵。Java程序的組成單位就是類，不管什麼規模的Java應用程序，都是由一個個類組成的。</p><h5 class=pgc-h-arrow-right>1．一切皆為對象</h5><p>在Java語言中，除了8個基本數據類型值之外都是對象，對象就是面向對象程序設計的中心。對象是人們要進行研究的任何事物，從最簡單的數字到複雜的航空母艦等均是對象。對象不僅能表示具體的事物，而且還能表示抽象的規則、計劃或事件。對象是具有狀態的，一個對象用數據值來描述它的狀態。Java通過為對象定義Field（以前常被稱為屬性，現在也稱為字段）來描述對象的狀態。對象也具有操作，這些操作可以改變對象的狀態，對象的操作也被稱為對象的行為，Java通過為對象定義方法來描述對象的行為。對象實現了數據和操作的結合，使數據和操作封裝於對象的統一體中。對象是Java程序裡的核心，所以，Java裡的對象具有唯一性，每個對象都有一個標識來引用它，如果某個對象失去了標識，這個對象將變成垃圾，只能等著系統垃圾回收來回收它。Java語言不允許直接訪問對象，而是通過對對象的引用來操作對象。</p><h5 class=pgc-h-arrow-right>2．類和對象</h5><p>具有相同或相似性質的一組對象的抽象就是類，類是抽象的、概念上的定義，是對一類事物的描述。對象是實際存在的該類事物的每個個體，因而也稱實例（instance）。對象的抽象是類，類的具體化就是對象，也可以說類的實例是對象。類用來描述一系列對象，類會概述每個對象應包括的數據，類概述每個對象的行為特徵。因此，我們可以把類理解成某種概念、定義，它規定了某類對象所共同具有的數據和行為特徵。</p><p>Java語言使用關鍵字class來定義一個類，Java允許程序員自定義類。在Java中定義類時，可使用關鍵字Field來描述該類對象的數據，可使用方法來描述該類對象的行為特徵。類的行為特主要是指屬性和操作，具體說明如下所示。</p><ul><li>Java中的類具有屬性，它是對象狀態的抽象，用數據結構來描述該類對象的共同數據特徵。</li><li>Java中的類具有操作，它是對象行為的抽象，用操作名和實現該操作的方法來描述該類對象的共同行為。</li></ul><p>在客觀世界中有若干類，這些類之間有一定的結構關係。通常有如下兩種主要的結構關係。</p><ul><li>一般—特殊結構：也被稱為分類結構，這種分類結構關係就是典型的繼承關係，Java語言使用關鍵字extends來表示這種分類結構，Java的子類是一種特殊的父類。因此，這種“一般—特殊”結構關係其實是一種“is a”關係。</li><li>整體—部分結構：也被稱為組裝結構，這種分類關係就是典型的組合關係，Java語言通過在一個類裡保存另一個對象的引用來實現這種組合關係，因此這種“整體—部分”結構關係其實是一種“has a”關係。</li></ul><p>程序員在定義Java類之後，就可以使用關鍵字new來創建指定類的對象，每個類可以創建任意多個對象，多個對象的Field值可以不同，這表現為不同對象的數據存在差異。</p><hr><p><strong>本文節選自《Java 開發從入門到精通》</strong></p><div class=pgc-img><img alt=JAVA：面向對象編程的底層邏輯，深度剖析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ad446b60ec704673a526e3d9be6da687><p class=pgc-img-caption></p></div><p>本書由淺入深地詳細講解了Java的開發技術，並通過具體實例的實現過程演練了各個知識點的具體使用流程。本書共20章，第1～2章講解了Java技術的基礎知識，包括Java印象和第一段Java程序；第3～9章分別講解了Java語法、條件語句、循環語句、數組、面向對象等知識，這些內容都是Java開發技術的核心知識；第10～14章分別講解了集合、類庫、泛型、異常處理、I/O和文件處理的基本知識，這些內容是Java開發技術的重點和難點；第15～19章是典型應用內容，分別講解了數據庫編程、網絡與通信編程、多線程等內容；第20章通過一個綜合實例的實現過程，介紹了Java技術在綜合項目中的使用流程。本書內容循序漸進，以“技術解惑”和“範例演練”貫穿全書，引領讀者全面掌握Java語言。</p><p>本書不但適用於Java的初學者，也適用於有一定Java基礎的讀者，還可以作為大專院校相關專業的師生學習用書和培訓學校的教材。</p><p><br></p><div class=tt-column-card data-content='{"new_thumb_url": "http://sf1-ttcdn-tos.pstatp.com/img/pgc-image/f821ab5a64f9436da89ce02f0be9ad4f", "title": "Spring Boot 2 \u6838\u5fc3\u6280\u672f\u5b9e\u6218\u57fa\u7840", "url": "", "price": 33.9, "column_id": "6781264611313189128", "content": "", "author_description": "\u5f02\u6b65\u793e\u533a", "share_price": 13.56, "thumb_url": "http://p7.pstatp.com/large/pgc-image/f821ab5a64f9436da89ce02f0be9ad4f", "sold": 24}'><p class=column-placeholder></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JAVA</a></li><li><a>對象</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html alt=什麼是面向對象的編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/be4dacb2168b48e085eec6c0640bc176 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html title=什麼是面向對象的編程思想>什麼是面向對象的編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html alt=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f2e808d6760462aafc6bfbb0e718954 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html title=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維>你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/810c487e.html alt="到底什麼是面向對象編程( OOP )？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5462f49b28c446b4b9214dae06156a7c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/810c487e.html title="到底什麼是面向對象編程( OOP )？">到底什麼是面向對象編程( OOP )？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3782027.html alt=漫畫：面向對象編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RSgLiL1LcHkAv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3782027.html title=漫畫：面向對象編程>漫畫：面向對象編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html alt=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532998144998addd88387a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html title=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則>都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html alt=面向對象編程設計的類與對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/86e56bdd947940c4b06129e01f19706a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html title=面向對象編程設計的類與對象>面向對象編程設計的類與對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30afbab.html alt="JAVA進階 深入理解面向對象" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/83f04804597d4a2f8d6c18f54334b5ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30afbab.html title="JAVA進階 深入理解面向對象">JAVA進階 深入理解面向對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3127c57.html alt=Python面向對象編程的基本概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/96a3b662b2714c5ca50be3b34b20a3d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3127c57.html title=Python面向對象編程的基本概念>Python面向對象編程的基本概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6559e37.html alt=C語言對象編程第三彈：多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f0f7f4ab1c174939a0c0f2dccebfb7e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6559e37.html title=C語言對象編程第三彈：多態>C語言對象編程第三彈：多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34766df.html alt="來談談JAVA面向對象 - 繼續說多態~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/58d42ac1398d4b5c873487092f8e5d05 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34766df.html title="來談談JAVA面向對象 - 繼續說多態~">來談談JAVA面向對象 - 繼續說多態~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b298260.html alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/403f086d79124a40aab485ad48379757 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b298260.html title=JAVA基礎——面向對象三大特性：封裝、繼承、多態>JAVA基礎——面向對象三大特性：封裝、繼承、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c802a4.html alt="Java面向對象編程三大特徵 - 多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a5bb9d2879b949319bd0cff669dad24a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c802a4.html title="Java面向對象編程三大特徵 - 多態">Java面向對象編程三大特徵 - 多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f6d25f.html alt=JAVA面向對象程序設計之創建型設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/13ac656d-76b7-4249-91ea-92b30fb1b48b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f6d25f.html title=JAVA面向對象程序設計之創建型設計模式>JAVA面向對象程序設計之創建型設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/415b5df.html alt=JAVA面向對象程序設計之對象、類和封裝 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/77a25702-72bd-453c-b973-4d2daeb06d21 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/415b5df.html title=JAVA面向對象程序設計之對象、類和封裝>JAVA面向對象程序設計之對象、類和封裝</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>