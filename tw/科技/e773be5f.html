<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>計算機基礎原來可以如此好懂！——「面向抽象編程」 | 极客快訊</title><meta property="og:title" content="計算機基礎原來可以如此好懂！——「面向抽象編程」 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/dc983f9dab1e4be196a7436614eb863d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e773be5f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e773be5f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e773be5f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e773be5f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e773be5f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e773be5f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e773be5f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e773be5f.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="計算機基礎原來可以如此好懂！——「面向抽象編程」"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e773be5f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>計算機基礎原來可以如此好懂！——「面向抽象編程」</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=計算機基礎原來可以如此好懂！——「面向抽象編程」 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc983f9dab1e4be196a7436614eb863d><p class=pgc-img-caption>題圖來自Unsplash</p></div><p>“面向抽象編程，面向接口編程”這句話流傳甚廣，它像一面旗幟插在每個人前進的道路上，引導大家前行。每個程序員都免不了和抽象打交道，差距可能在於能否更好地提煉。這句話包含兩部分含義：“面向抽象編程”本質上是對數據的抽象化，“面向接口編程”本質上是對行為的抽象化。</p><p>我們先來談談數據的抽象化——面向抽象編程。</p><h1>抽象最討厭的敵人：new</h1><p>因為直接講什麼是抽象不太好講，容易描述的話那就不是抽象了，所以我們換個角度，先聊聊抽象的反面：什麼是具體。在具體裡，有個先鋒人物，就是我們都熟悉的 new。大家知道，new 是最簡單和最常見的關鍵字，用來創建對象。但被創建出來的一定是具體的對象，所以new 代表著具體，它是抽象最討厭的敵人。</p><p>大家要有這種敏感：什麼時機創建對象，在哪裡創建，是很有講究的。為了闡述這個話題，我們先看下面這行代碼：</p><pre>Animal animal = new Tiger(); // Animal 是抽象類</pre><p>我曾經對這句簡單的賦值語句思考很久：左邊抽象，右邊具體，感覺不對等，這樣寫好不好？答案不簡單啊。</p><p>接下來，我們分成兩個方向細細討論。</p><p><strong>假設一</strong>：如果它是某個類的成員變量的定義。例如：</p><pre>private Animal animal = new Tiger();</pre><p>先下結論：如果類裡其他地方沒有對 animal 這個變量的賦值操作，此後再沒有更改它的邏輯了，那麼它基本不是好寫法（有少許例外）。那麼，什麼是好寫法？</p><p>哈，這裡先賣個關子。</p><p>這裡需要注意的是，我們討論的是左邊是抽象，右邊是具體的 new。如果 new 的兩邊是平級概念的類，例如：</p><pre>Tiger tiger = new Tiger();</pre><p>它左右兩邊沒有抽象之分，那麼不在我們討論範圍之內。</p><p><strong>假設二</strong>：如果它是某個函數內部的變量定義語句。示例如下：</p><pre>void Show() {Animal animal = new Tiger(); ...... // 出場前的準備活動 ShowAnimal(animal);}</pre><p>我曾經疑惑：為何不直接定義成子類類型？就這樣寫：</p><pre>Tiger tiger = new Tiger();</pre><p>根據繼承原理，子類能調用抽象類的方法。所以也不會影響接下來的函數調用。例如：所有的animal.Eat 替換為 tiger.Eat 一定成立。</p><p>同時根據里氏替換原則，但凡出現animal 的地方，都可以把tiger 代替進去，所以也不會影響我的參數傳遞。例如：ShowAnimal(animal)替換為ShowAnimal(tiger)也一定成立。</p><p>可一旦把 Tiger 類型上溯轉為抽象的 Animal 類型，那麼 Tiger 自身的特殊能力（例如Hunt）在“出場前的準備活動”那部分就用不了，例如：</p><pre>tiger.Hunt(); // 老虎進行狩獵animal.Hunt(); // 不能通過編譯</pre><p>也就是說，Animal animal = new Tiger();裡Animal 的抽象定義，只有限制我自由的作用，而沒有帶來任何實質的好處！這種寫法不是很糟糕嗎？</p><p>你會有一天頓悟：這種對自由的限制，恰恰是最珍貴的！大部分時候，我們缺的不是自由，而是自律。任何人的自由，都不能以損害別人的利益為代價。</p><p>ShowAnimal(animal);之前的那段“出場前的準備活動”代碼，將來很有可能是別人來維護的。在架構設計上，一定要考慮“時間”這個變量帶來的不確定性。如果你定義成：</p><pre>Tiger tiger = new Tiger();</pre><p>這看起來更靈活，但你沒法阻止這隻老虎被別人將來使用Hunt 函數濫殺無辜。</p><p>一旦定義為：</p><pre>Animal animal = new Tiger();</pre><p>那麼，這隻老虎將會是一隻溫順的老虎，只遵循普通的動物準則。</p><p>所以如果“出場前的準備活動”這部分的業務需求裡只用到Animal 的基本功能函數，那麼：</p><pre>Animal animal = new Tiger();</pre><p>要優於</p><pre>Tiger tiger = new Tiger();</pre><p>好了，等號左邊的抽象問題解決了，但等號右邊的 new 呢？這個場景裡，Animal animal =new Tiger();是函數的局部變量，也沒有傳導到全局變量中。到目前為止，這個new 是完全可以接受的。面向抽象，是要在關鍵且合適的地方去抽象，如果處處都抽象，代價會非常大，得不償失。如果滿分是 100 分的話，目前能得 95 分，已經很好了，這也是我們大多數時候的寫法。</p><p>但你還是要知道：一旦接受了這個 new，好比是和魔鬼做了契約，會付出潛在代價的。此處的代價是這段代碼不能再升級成框架性的抽象代碼了。想要完美得到 100 分，則需要消滅這個new，怎麼辦呢？</p><h1>消滅 new 的兩件武器</h1><p>上面站在理論高度“批判”了new，其實並不是說 new 真的不好，而是說很多人會濫用。就好比火是人類文明的起源，好東西，但是濫用就會造成火災。把火源限定在特定工具才能點火，隔離開，用起來才安全。new 其實也一樣，下面講的本質上不是消滅 new，而是隔離 new 的兩件武器。</p><p><strong>控制反轉——髒活讓別人去幹</strong></p><p>還記得前面賣的關子嗎？如果 animal 是類成員變量：</p><pre>private Animal animal = new Tiger();</pre><p>這並不是好寫法，那麼什麼是好寫法呢？這種情況下，比較簡單的是對它進行參數化改造：</p><pre>void setAnimal(Animal animal) { this.animal = animal;}</pre><p>然後讓客戶去調用注入：</p><pre>Tiger tiger = new Tiger();obj.setAnimal(tiger);</pre><p>有了上面的注入代碼，private Animal animal = new Tiger();這句話反而變得可以接受了。因為等號右邊的 Tiger 僅僅是默認值，默認值當然是具體的。</p><p>上面的參數化改造手法，我們可以稱為“依賴注入”，其核心思想是：不要調我，我會去調你！依賴注入分為屬性注入、構造函數注入和普通函數注入。很明顯，上面的例子是屬性注入。</p><p>依賴注入和標題的“控制反轉”還不能完全劃等號。確切地說，“依賴注入”是實現“控制反轉”的方式之一。</p><p>這種乾脆把創建對象的任務甩手不幹的事情，反而是個好寫法，境界高！這樣，你不知不覺把自己的代碼完全變成了只負責數據流轉的框架性代碼，具備了通用性。</p><p>在通往架構師的道路上，你要培養出一種感覺：要創建一個跨作用域的實體對象（不是值對象）是一件很謹慎的事情（越接觸大型項目，你對這點的體會就越深），不要隨便創建。最好不要自己創建，讓別人去創建，傳給你去調用。那麼問題來了：都不願意去創建，誰去創建？這個丟手絹的遊戲最終到底要丟給誰呢？</p><p>先把問題揣著，我們接著往下看。</p><p><strong>工廠模式——抽象的基礎設施</strong></p><p>我們回到這段Show 代碼：</p><pre>void Show() { Animal animal = new Tiger(); // 上面說過，這裡的 new 目前是可以接受的 ...... // 出場前的準備活動 ShowAnimal(animal);}</pre><p>但如果Show 方法裡創建動物的需求變得複雜，new 會變得猖狂起來：</p><pre>void Show(string name) { Animal animal; if(name == "Tiger") animal = new Tiger(); else if(name == "Lion") animal = new Lion(); ...... // 其他種類 ShowAnimal(animal);}</pre><p>此時將變得不可接受了。對付這麼多同質的 new（都是創建Animal），一般會將它們封裝進專門生產 animal 的工廠裡：</p><pre>Animal ProvideAnimal(string name) { Animal animal; if(name == "Tiger") animal = new Tiger();else if(name == "Lion") animal = new Lion(); ...... // 其他種類}</pre><p>進而優化了 Show 代碼：</p><pre>void Show(string name) { Animal animal = ProvideAnimal(name); // 等號兩邊都是同級別的抽象，這下徹底舒服了 ShowAnimal(animal);}</pre><p>因此，依賴注入和工廠模式是消滅 new 的兩種武器。此外，它們也經常結合使用。</p><p>上面的 ProvideAnimal 函數採用的是簡單工廠模式。由於工廠模式是每個人都會遇到的基本設計模式，所以這裡會對它進行更深入的闡述，讓大家能更深入地理解它。工廠模式嚴格說來有簡單工廠模式和抽象工廠模式之分，但真正算得上設計模式的，是抽象工廠模式。簡單工廠模式僅僅是比較自然的簡單封裝，有點配不上一種設計模式的稱呼。因此，很多教科書會大篇幅地介紹抽象工廠，而有意無意地忽略了簡單工廠。但實際情況正好相反，抽象工廠大部分人一輩子都用不上一次（它的出現要依賴於對多個相關類族創建對象的複雜需求場景），而簡單工廠幾乎每個人都用得上。</p><p>和一般的設計模式不一樣，有些設計模式的代碼結構哪怕你已經爛熟於心，卻依然很難想象它們的具體使用場景。工廠模式是面向抽象編程，數據的創建需求變複雜之後很自然的產物，很多人都能無師自通地去使用它。將面向抽象編程堅持到底，會自然地把創建對象的任務外包出去，丟給專門的工廠去創建。</p><p>可見，工廠模式在整個可擴展的架構中扮演的不是先鋒隊角色，而是強有力的支持“面向抽象編程”的基礎設施之一。</p><p>最後調侃一下，我面試候選人的時候，很喜歡問他們一個問題：“你最常用的設計模式有哪些？”</p><p>排第一的是“單例模式”，而“工廠模式”是當之無愧的第二名，排第三的是“觀察者模式”。這側面說明這三種模式應該是廣大程序員最容易用到的設計模式。大家學習設計模式時，首先應該仔細研究這三種模式及其變種。</p><p><strong>new 去哪裡了呢</strong></p><p>這裡回到最開始也是最關鍵的問題：如果大家都不去創建，那麼誰去創建呢？把髒活丟給別人，那別人是誰呢？下面我們從兩個方面闡述。</p><p>■ 局部變量。局部變量是指在函數內部生產又在函數內部消失的變量，外部並不知曉它的存在。在函數內部創建它們就好，這也是我們遇到的大多數情況。例如：</p><pre>void Show() { Animal animal = new Tiger(); ...... // 出場前的準備活動 ShowAnimal(animal);}</pre><p>前面說過，這段代碼裡的 new 能得95 分，沒有問題。</p><p>■ 跨作用域變量。對這類對象的創建，總是要小心一些的。</p><p>○ 如果是零散的創建，就讓各個客戶端自己去創建。這裡的客戶端是泛指的概念，不是服務器對應的客戶端。凡是調用核心模塊的發起方，均屬於客戶端。每個客戶端是知道自身具體細節的，在它內部創建無可厚非。</p><p>○ 如果寫的是框架性代碼，是基於總體規則的創建，那就在核心模塊裡採用專門的工廠去創建。</p><h1>抽象到什麼程度</h1><p>前面說過，完全具體肯定不行，缺乏彈性。但緊接著另一個問題來了：越抽象就越好嗎？不見得。我們對抽象的態度沒必要過分崇拜，下面就專門討論一下抽象和具體之間如何平衡。比如Java 語言，根上的 Object 類最抽象了，但 Object 定義滿天飛顯然不是我們想要的，例如：</p><pre>Object obj = new Tiger();</pre><p>那樣你會被迫不停地進行下溯轉換：</p><pre>Animal animal = (Animal)obj;</pre><p>所以不是越抽象越好。抽象是有等級之分的，要抽象到什麼程度呢？有一句描述美女魔鬼身材的語句是“該瘦的地方瘦，該肥的地方肥”。那麼，這句話可改編一下，即可成為抽象編程的原則，即“該實的地方實，該虛的地方虛”。也就是說，<strong>抽象和具體之間一定有個平衡點，這個平衡點正是應該時刻存在程序員大腦裡的一件東西：用戶需求！</strong></p><p>你需要做的是精確把握用戶需求，提供給用戶的是滿足用戶需求的最根上的那層數據。什麼意思呢？我們通過下面這個例子詳細闡述。</p><p>村裡的家家戶戶都要提供一種動物去參加跑步比賽，於是每家都要實現一個ProvideAnimal函數。你家裡今年養了一隻老虎，老虎屬於貓科。三層繼承關係如下：</p><pre>public abstract class Animal { public void Run();}public class Cat : Animal { public int Jump();}public class Tiger : Cat { public void Hunt(Animal animal);}</pre><p>現在有個問題：ProvideAnimal 函數的返回類型定義為什麼好呢？Animal、Cat 還是Tiger？這就要看用戶需求了。</p><p>如果此時是舉行跑步比賽，那麼只需要你的動物有跑步能力即可，此時返回Animal 類型是最好的：</p><pre>public Animal ProvideAnimal() { return new Tiger();}</pre><p>如果要舉辦跳高比賽，是Cat 層級才有的功能，那麼返回Cat 類型是最好的：</p><pre>public Cat ProvideAnimal() { return new Tiger();}</pre><p><strong>切記，你返回的類型，是客戶需求對應的最根上的那個類型節點。這是雙贏！</strong></p><p>如果函數返回值是最底下的 Tiger 子類型：</p><pre>public Tiger ProvideAnimal() { return new Tiger();}</pre><p>這會帶來如下兩個潛在的問題。</p><p><strong>問題1：給別人造成濫用的可能</strong></p><p>這給了組織者額外的雜亂信息。本來呢，對於跑步比賽，每一個參賽者只有一個 Run 函數便清晰明瞭，但在老虎身上，有 Run 的同時，還附帶了跳高 Jump 和捕獵 Hunt 的功能。這樣組織者需要思考一下到底應該用哪個功能。所以提供太多無用功能，反而給別人造成了困擾。</p><p>同時也給了組織者犯錯誤的機會。萬一，他一旦好奇，或者錯誤操作，比賽時調用了 Hunt方法，那這隻老虎就不是去參加跑步比賽，而是追捕別的小動物吃了。</p><p><strong>問題2：喪失瞭解耦子對象的機會</strong></p><p>一旦對方在等號兩邊傻傻地按照你的子類型去定義，例如：</p><pre>Tiger tiger = ProvideAnimal();</pre><p>從此組織者就指名道姓地要你家的老虎了。如果比賽當天，你的老虎生病了，你本可以換一頭獵豹去參加比賽，但因為別人預定了看你家的老虎，所以非去不可。結果便喪失了寶貴的解耦機會。</p><p>如果是Animal 類型，那麼你並不知道是哪一種動物會出現，但你知道它一定會動起來，跑成什麼樣子，你並不知道。這樣的交流，是比較高級的交流。繪畫藝術上有個高級術語叫“留白”，咱們編程玩“抽象”也算是“留白”。我先保留一些東西，一開始沒必要先確定的細節就不先確定了。那這個“留白”留多少呢？根據用戶需求而定！</p><h1>總結</h1><p>多態這門特技，成就了人們大量採用抽象去溝通，用接口去溝通。而抽象也不負眾望地讓溝通變得更加簡潔、高效；抽象也讓相互間依賴更少，架構更靈活。</p><p>參數化和工廠模式是消滅或隔離new 的兩種武器。</p><p>用戶需求是決定抽象到何種程度的決定因素。</p><p><strong>——本文選自《代碼裡的世界觀：通往架構師之路》</strong></p><div class=pgc-img><img alt=計算機基礎原來可以如此好懂！——「面向抽象編程」 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0386ece994814ca9982c50aafdcc138c><p class=pgc-img-caption>IBM架構師 餘葉 著</p></div><p class=ql-align-justify>編程中有很多通用的知識點，它們是10年甚至20年都不會淘汰的編程技術，市面上也極少有將它們綜合起來並講得有意思的書。</p><p class=ql-align-justify>上面這本書是一位IBM架構師結合了自己13年編程經驗，結合自己的理解和領悟，把許多知識點匯入到了這本書裡。它們並不是潮流的知識點，而是厚重的基礎知識。</p><h1 class=ql-align-justify>目錄</h1><p class=ql-align-justify><strong>第1章 程序世界的兩個基本元素</strong></p><p class=ql-align-justify>1.1 數據和代碼的相互偽裝</p><p class=ql-align-justify>1.2 數據和代碼的關係</p><p class=ql-align-justify><strong>第2章 用面向對象的方式去理解世界</strong></p><p class=ql-align-justify>2.1 好的程序員是安徒生</p><p class=ql-align-justify>2.2 封裝——招兵買馬，等級森嚴</p><p class=ql-align-justify>2.3 繼承——快速進化</p><p class=ql-align-justify>2.4 多態——抽象的基石</p><p class=ql-align-justify>2.5 總結</p><p class=ql-align-justify><strong>第3章 面向抽象編程——玩玩虛的更健康</strong></p><p class=ql-align-justify>3.1 抽象最討厭的敵人：new</p><p class=ql-align-justify>3.2 消滅new 的兩件武器</p><p class=ql-align-justify>3.3 抽象到什麼程度</p><p class=ql-align-justify>3.4 總結</p><p class=ql-align-justify><strong>第4章 耦合其實無處不在</strong></p><p class=ql-align-justify>4.1 耦合的種類</p><p class=ql-align-justify>4.2 耦合中既有敵人也有朋友</p><p class=ql-align-justify>4.3 壞耦合的原因</p><p class=ql-align-justify>4.4 解耦的原則</p><p class=ql-align-justify>4.5 總結</p><p class=ql-align-justify><strong>第5章 數據的種類——生命如此多嬌</strong></p><p class=ql-align-justify>5.1 常用數據類型</p><p class=ql-align-justify>5.2 按生命週期劃分數據</p><p class=ql-align-justify>5.3 兩個重要的數據容器</p><p class=ql-align-justify>5.4 對象的種類</p><p class=ql-align-justify>5.5 描述數據的數據</p><p class=ql-align-justify>5.6 總結</p><p class=ql-align-justify><strong>第6章 數據驅動——把變化抽象成數據</strong></p><p class=ql-align-justify>6.1 三個案例</p><p class=ql-align-justify>6.2 數據驅動的好幫手：反射</p><p class=ql-align-justify>6.3 總結</p><p class=ql-align-justify><strong>第7章 對象之間的關係——父子、朋友或情人</strong></p><p class=ql-align-justify>7.1 繼承——父子關係</p><p class=ql-align-justify>7.2 組合——朋友關係</p><p class=ql-align-justify>7.3 依賴——情人關係</p><p class=ql-align-justify>7.4 總結</p><p class=ql-align-justify><strong>第8章 函數的種類——迷宮的結構</strong></p><p class=ql-align-justify>8.1 面向對象的函數叫方法</p><p class=ql-align-justify>8.2 參數是函數的原材料</p><p class=ql-align-justify>8.3 返回值對函數的意義</p><p class=ql-align-justify>8.4 值傳遞、引用傳遞和指針傳遞</p><p class=ql-align-justify>8.5 有狀態函數和無狀態函數</p><p class=ql-align-justify>8.6 靜態函數和普通函數</p><p class=ql-align-justify>8.7 能駕馭其他函數的函數</p><p class=ql-align-justify>8.8 編譯器做過手腳的函數</p><p class=ql-align-justify>8.9 總結</p><p class=ql-align-justify><strong>第9章 面向接口編程——遵循契約辦事</strong></p><p class=ql-align-justify>9.1 接口和抽象類——分工其實挺明確</p><p class=ql-align-justify>9.2 接口的應用場景</p><p class=ql-align-justify>9.3 接口和函數指針</p><p class=ql-align-justify>9.4 函數指針的應用場景</p><p class=ql-align-justify>9.5 總結</p><p class=ql-align-justify><strong>第10章 if...else 的多面性</strong></p><p class=ql-align-justify>10.1 兩條兄弟語句</p><p class=ql-align-justify>10.2 if...else 的黑暗面</p><p class=ql-align-justify>10.3 開閉原則——if...else 的天敵</p><p class=ql-align-justify>10.4 化解if...else 黑暗面</p><p class=ql-align-justify>10.5 總結</p><p class=ql-align-justify><strong>第11章 挖掘一件神祕武器——static</strong></p><p class=ql-align-justify>11.1 static 神祕在哪裡</p><p class=ql-align-justify>11.2 static 的特性</p><p class=ql-align-justify>11.3 static 的應用場景</p><p class=ql-align-justify>11.4 總結</p><p class=ql-align-justify><strong>第12章 把容易變化的邏輯，放在容易修改的地方</strong></p><p class=ql-align-justify>12.1 一個和用戶的故事</p><p class=ql-align-justify>12.2 一個和銷售的故事</p><p class=ql-align-justify>12.3 一個和產品經理的故事</p><p class=ql-align-justify>12.4 一個和運維的故事</p><p class=ql-align-justify>12.5 總結</p><p class=ql-align-justify><strong>第13章 隱式約定——猶抱琵琶半遮面</strong></p><p class=ql-align-justify>13.1 撥開隱式約定的神祕面紗</p><p class=ql-align-justify>13.2 調料包數據</p><p class=ql-align-justify>13.3 越簡單的功夫越厲害</p><p class=ql-align-justify>13.4 總結</p><p class=ql-align-justify><strong>第14章 異常，天使還是魔鬼</strong></p><p class=ql-align-justify>14.1 三個江湖派別</p><p class=ql-align-justify>14.2 異常的種類</p><p class=ql-align-justify>14.3 異常的throw：手榴彈什麼時候扔</p><p class=ql-align-justify>14.4 異常的catch——能收炸彈的垃圾筐</p><p class=ql-align-justify>14.5 異常的使用技巧</p><p class=ql-align-justify>14.6 總結</p><p class=ql-align-justify><strong>第15章 多線程編程——在混沌中永生</strong></p><p class=ql-align-justify>15.1 幾個基礎概念</p><p class=ql-align-justify>15.2 互斥——相互競爭</p><p class=ql-align-justify>15.3 同步——相互協作</p><p class=ql-align-justify>15.4 異步——各忙各的</p><p class=ql-align-justify>15.5 阻塞與非阻塞</p><p class=ql-align-justify>15.6 總結</p><p class=ql-align-justify><strong>第16章 單元測試——對代碼庖丁解牛</strong></p><p class=ql-align-justify>16.1 單元測試的誕生</p><p class=ql-align-justify>16.2 單元測試的進化</p><p class=ql-align-justify>16.3 編寫單元測試的基本原則</p><p class=ql-align-justify>16.4 如何讓代碼面向單元測試</p><p class=ql-align-justify>16.5 最後的忠告：無招勝有招</p><p class=ql-align-justify>16.6 總結</p><p class=ql-align-justify><strong>第17章 代碼評審——給身體排排毒</strong></p><p class=ql-align-justify>17.1 排毒要養成習慣</p><p class=ql-align-justify>17.2 磨刀不誤砍柴工</p><p class=ql-align-justify>17.3 經驗點滴——關鍵是流程化</p><p class=ql-align-justify>17.5 總結</p><p class=ql-align-justify><strong>第18章 編程就是用代碼來寫作</strong></p><p class=ql-align-justify>18.1 程序員與作家的區別</p><p class=ql-align-justify>18.2 如何提高寫作水平</p><p class=ql-align-justify>18.3 案例解析——咬文嚼字很重要</p><p class=ql-align-justify>18.4 謹慎對待註釋</p><p class=ql-align-justify>18.5 總結</p><p class=ql-align-justify><strong>第19章 程序員的精神分裂——扮演上帝與木匠</strong></p><p class=ql-align-justify>19.1 一個腦袋，兩種身份</p><p class=ql-align-justify>19.2 上帝模式：開天闢地，指點江山</p><p class=ql-align-justify>19.3 木匠模式：致富只有勤勞一條路</p><p class=ql-align-justify>19.4 總結</p><p class=ql-align-justify><strong>第20章 程序員的技術成長——打怪升級之路</strong></p><p class=ql-align-justify>20.1 技術成長三部曲</p><p class=ql-align-justify>20.2 碼農都是好老師</p><p class=ql-align-justify>20.3 重視編程效率</p><p class=ql-align-justify>20.4 儘量通過工作去鍛鍊</p><p class=ql-align-justify>20.5 三分之一的工匠精神</p><p class=ql-align-justify>20.6 明白架構師的含義</p><p class=ql-align-justify>20.7 總結</p><p class=ql-align-justify><strong>第21章 語言到底哪種好——究竟誰是屠龍刀</strong></p><p class=ql-align-justify>21.1 軍隊的背後是國家實力的較量</p><p class=ql-align-justify>21.2 專一和多情哪個好</p><p class=ql-align-justify>21.3 如何快速學習一門新語言</p><p class=ql-align-justify>21.4 總結</p><p class=ql-align-justify><strong>第22章 程序員的組織生產——讓大家更高效和親密</strong></p><p class=ql-align-justify>22.1 敏捷開發：及時反饋，小步快跑</p><p class=ql-align-justify>22.2 雙人編程：雙人搭配，幹活超累</p><p class=ql-align-justify>22.3 封閉開發：並不是蹲大獄</p><p class=ql-align-justify>22.4 總結</p><p class=ql-align-justify><strong>第23章 程序員的職業生涯——選擇比努力更重要</strong></p><p class=ql-align-justify>23.1 程序員到底能幹多久</p><p class=ql-align-justify>23.2 程序員的中年危機</p><p class=ql-align-justify>23.3 自問一：你適不適合當程序員</p><p class=ql-align-justify>23.4 自問二：程序員是否最適合你</p><p class=ql-align-justify>23.5 自問三：問問自己有沒有雙門檻</p><p class=ql-align-justify>23.6 自問四：程序員最適合轉什麼行</p><p class=ql-align-justify>23.7 總結</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>計算機</a></li><li><a>基礎</a></li><li><a>原來</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/915806de.html alt=計算機基礎--什麼是編碼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f866a4b5dc3c4467b261c93342e48805 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/915806de.html title=計算機基礎--什麼是編碼？>計算機基礎--什麼是編碼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d965620b.html alt=速學計算機文化，計算機文化基礎筆記 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8cf2df8a69914839941df8bbecff1bb7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d965620b.html title=速學計算機文化，計算機文化基礎筆記>速學計算機文化，計算機文化基礎筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2e01fadd.html alt="彙編語言, 計算機的基礎語言" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15227659575394bd4778681 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2e01fadd.html title="彙編語言, 計算機的基礎語言">彙編語言, 計算機的基礎語言</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aecf487e.html alt=計算機網絡基礎：局域網協議相關知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b843ca1dae9a4662aa8b04d696310359 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aecf487e.html title=計算機網絡基礎：局域網協議相關知識>計算機網絡基礎：局域網協議相關知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fe52f0e.html alt=程序員編程基礎｜計算機組成原理：計算機的字符與編碼集 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1853a37aa0984496add6372fcd3ce765 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fe52f0e.html title=程序員編程基礎｜計算機組成原理：計算機的字符與編碼集>程序員編程基礎｜計算機組成原理：計算機的字符與編碼集</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/5f13116a.html alt=計算機公共基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/5f13116a.html title=計算機公共基礎知識>計算機公共基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/09ddb291.html alt=計算機網絡基礎知識--日常工作的寶庫，收藏必備 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b25621c28cb24220b71c32b4e2c0d0b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/09ddb291.html title=計算機網絡基礎知識--日常工作的寶庫，收藏必備>計算機網絡基礎知識--日常工作的寶庫，收藏必備</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/0f4669bf.html alt=計算機網絡基礎：網絡分類和拓撲結構知識筆記 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e4e39f3d95e4793a789034fa72d6081 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/0f4669bf.html title=計算機網絡基礎：網絡分類和拓撲結構知識筆記>計算機網絡基礎：網絡分類和拓撲結構知識筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/481fd454.html alt=計算機硬件基礎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/79bda471d04e4248bd11b2217010c1ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/481fd454.html title=計算機硬件基礎>計算機硬件基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629a5eb3.html alt=計算機網絡基礎之OSI七層參考模型（一、基本介紹） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b9cba7c8573b4c93ab0a1248281348c2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629a5eb3.html title=計算機網絡基礎之OSI七層參考模型（一、基本介紹）>計算機網絡基礎之OSI七層參考模型（一、基本介紹）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0c46dcdd.html alt=計算機網絡基礎總結，如果你想成為黑客，那你還不趕緊了解一下 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/239bcd8f524e4253b1f03681762dac2a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0c46dcdd.html title=計算機網絡基礎總結，如果你想成為黑客，那你還不趕緊了解一下>計算機網絡基礎總結，如果你想成為黑客，那你還不趕緊了解一下</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4b544df.html alt=計算機網絡通信基礎概念介紹和問題描述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1538184177058b18ef97641 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4b544df.html title=計算機網絡通信基礎概念介紹和問題描述>計算機網絡通信基礎概念介紹和問題描述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/173684d8.html alt=計算機網絡基礎知識總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f8f3be6848954fafa804b2059693f26e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/173684d8.html title=計算機網絡基礎知識總結>計算機網絡基礎知識總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8275797.html alt=《計算機應用基礎》考試大綱 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8275797.html title=《計算機應用基礎》考試大綱>《計算機應用基礎》考試大綱</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0c16643.html alt=原來計算機也有大腦，它的大腦是什麼呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153559109848129a4ba4b68 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0c16643.html title=原來計算機也有大腦，它的大腦是什麼呢？>原來計算機也有大腦，它的大腦是什麼呢？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>