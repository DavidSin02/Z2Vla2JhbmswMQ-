<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>來看看CALayer那些牛逼的子類 | 极客快訊</title><meta property="og:title" content="來看看CALayer那些牛逼的子類 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/322c0001962a9d0a3860"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><meta property="article:published_time" content="2020-10-29T21:09:16+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:16+08:00"><meta name=Keywords content><meta name=description content="來看看CALayer那些牛逼的子類"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/e7b4670e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>來看看CALayer那些牛逼的子類</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/322c0001962a9d0a3860></p><p><strong>CATransformLayer</strong></p><p>我們先看一下系統有沒有像之前講過的幾個子類一樣，給它一些特殊的屬性或者方法：</p><p><code>@interface CATransformLayer : CALayer</code></p><p><code>@end</code></p><p>啥都沒有，我擦嘞，但是上面好像有一段描述我們看一下：</p><p><code>/* "Transform" layers are used to create true 3D layer hierarchies.</code></p><p><code></code><code>*</code></p><p><code></code><code>* Unlike normal layers, transform layers do not project (i.e. flatten)</code></p><p><code></code><code>* their sublayers into the plane at Z=0. However due to this neither</code></p><p><code></code><code>* do they support many features of the 2D compositing model:</code></p><p><code></code><code>*</code></p><p><code></code><code>* - only their sublayers are rendered (i.e. no background, contents,</code></p><p><code></code><code>* border)</code></p><p><code></code><code>*</code></p><p><code></code><code>* - filters, backgroundFilters, compositingFilter, mask, masksToBounds</code></p><p><code></code><code>* and shadow related properties are ignored (they all assume 2D</code></p><p><code></code><code>* image processing of the projected layer)</code></p><p><code></code><code>*</code></p><p><code></code><code>* - opacity is applied to each sublayer individually, i.e. the transform</code></p><p><code></code><code>* layer does not form a compositing group.</code></p><p><code></code><code>*</code></p><p><code></code><code>* Also, the -hitTest: method should never be called on transform</code></p><p><code></code><code>* layers (they do not have a 2D coordinate space into which to map the</code></p><p><code></code><code>* supplied point.) CALayer will pass over transform layers directly to</code></p><p><code></code><code>* their sublayers, applying the effects of the transform layer's</code></p><p><code></code><code>* geometry when hit-testing each sublayer. */</code></p><p>我們從中可以看出它作為父Layer時，對他的sublayers會有3D效果，也就是說不平面化它的子圖層，大家一提到3D效果，就會想到一個神奇的東西景深，先說一下景深是個什麼東西，提到景深，那我們就一定要說CATransform3D，它定義了一個4x4 的 CGFloat值的矩陣，就是這樣的：</p><p><code>struct CATransform3D</code></p><p><code>{</code></p><p><code></code><code>CGFloat m11, m12, m13, m14;</code></p><p><code></code><code>CGFloat m21, m22, m23, m24;</code></p><p><code></code><code>CGFloat m31, m32, m33, m34;</code></p><p><code></code><code>CGFloat m41, m42, m43, m44;</code></p><p><code>}</code></p><p>其中的m34，就是上面提到的景深效果的源頭，我們寫一段代碼看一下：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>CALayer *layer_ = [CALayer layer];</code></p><p><code></code><code>layer_.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer_.position = CGPointMake(self.view.center.x, 200);</code></p><p><code></code><code>layer_.opacity = 0.6;</code></p><p><code></code><code>layer_.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer_.borderWidth = 5;</code></p><p><code></code><code>layer_.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer_.cornerRadius = 20;</code></p><p><code></code><code>layer_.masksToBounds = YES;</code></p><p><code></code><code>[self.view.layer addSublayer:layer_];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D fromValue_ = CATransform3DIdentity;</code></p><p><code></code><code>fromValue_ = CATransform3DRotate(fromValue_, M_PI_2 / 2, 0, 1, 0);</code></p><p><code></code><code>layer_.transform = fromValue_;</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.position = self.view.center;</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor blueColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor orangeColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>[self.view.layer addSublayer:layer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue.m34 = 1.0 / -500;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2 / 2, 0, 1, 0);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code>}</code></p><p>運行結果：</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/322d00042e798384e986></p><p>是不是明顯發現藍色的layer3D效果更強烈一些。</p><p>下面我們試一下這樣的代碼：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>CALayer *layer_2 = [CALayer layer];</code></p><p><code></code><code>layer_2.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer_2.opacity = 0.6;</code></p><p><code></code><code>layer_2.backgroundColor = [UIColor blueColor].CGColor;</code></p><p><code></code><code>layer_2.borderWidth = 5;</code></p><p><code></code><code>layer_2.borderColor = [[UIColor orangeColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer_2.cornerRadius = 20;</code></p><p><code></code><code>layer_2.masksToBounds = YES;</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *containerLayer = [CALayer layer];</code></p><p><code></code><code>containerLayer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>containerLayer.position = self.view.center;</code></p><p><code></code><code>layer.position = CGPointMake(50, 50);</code></p><p><code></code><code>layer_2.position = CGPointMake(50, 50);</code></p><p><code></code><code>[containerLayer addSublayer:layer];</code></p><p><code></code><code>[containerLayer addSublayer:layer_2];</code></p><p><code></code><code>[self.view.layer addSublayer:containerLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D containerTransform = CATransform3DIdentity;</code></p><p><code></code><code>containerTransform.m34 = -1.0 / 500.0;</code></p><p><code></code><code>containerLayer.transform = containerTransform;</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>fromValue = CATransform3DTranslate(fromValue, 0, 0, -10);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code></code><code>CATransform3D fromValue_2 = CATransform3DIdentity;</code></p><p><code></code><code>fromValue_2 = CATransform3DRotate(fromValue_2, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>fromValue_2 = CATransform3DTranslate(fromValue_2, 0, 0, -50);</code></p><p><code></code><code>layer_2.transform = fromValue_2;</code></p><p><code>}</code></p><p>運行結果，一片空白，啥都沒有。</p><p>我們做一處改動：</p><p>1</p><p><code>CATransformLayer *containerLayer = [CATransformLayer layer];</code></p><p>運行結果：</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/32100004d63d26bbca87></p><p>??：所以有人說CATransformLayer便是給他的子圖層添加了景深的效果。瞎搞，把設置景深的代碼containerTransform.m34 = -1.0 / 500.0;去掉，運行，你會發現還是一片空白。這就說明CATransformLayer並不是這麼個作用。那這個東西的特殊之處究竟是什麼呢？</p><p>其實就是上面說的：CATransformLayer並不平面化它的子圖層，所以它能夠用於構造一個層級分明的3D結構。</p><p>上代碼：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>CALayer *containerLayer = [CALayer layer];</code></p><p><code></code><code>containerLayer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>containerLayer.position = self.view.center;</code></p><p><code></code><code>layer.position = CGPointMake(50, 50);</code></p><p><code></code><code>layer_2.position = CGPointMake(50, 50);</code></p><p><code></code><code>[containerLayer addSublayer:layer];</code></p><p><code></code><code>[self.view.layer addSublayer:containerLayer];</code></p><p><code></code><code>CATransform3D containerTransform = CATransform3DIdentity;</code></p><p><code></code><code>containerLayer.transform = containerTransform;</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code>}</code></p><p>運行結果：不出所料，一片空白。</p><p>於是，我們把containerLayer由CALayer改成CATransformLayer ，結果，還是一片空白。</p><p>現在，你肯定覺的我也是在扯淡，下面精彩的部分來了：</p><p>我們給containerLayer添加一個新的transform，代碼也就是這樣的：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>CALayer *containerLayer = [CALayer layer];</code></p><p><code></code><code>containerLayer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>containerLayer.position = self.view.center;</code></p><p><code></code><code>layer.position = CGPointMake(50, 50);</code></p><p><code></code><code>layer_2.position = CGPointMake(50, 50);</code></p><p><code></code><code>[containerLayer addSublayer:layer];</code></p><p><code></code><code>[self.view.layer addSublayer:containerLayer];</code></p><p><code></code><code>CATransform3D containerTransform = CATransform3DIdentity;</code></p><p><code></code><code>//看這，我是新加的</code></p><p><code></code><code>containerTransform = CATransform3DRotate(containerTransform, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>//</code></p><p><code></code><code>containerLayer.transform = containerTransform;</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code>}</code></p><p>運行結果：</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/32100004d63cb1ed7d8d></p><p>現在，我們再把containerLayer由CATransformLayer改成CALayer ，結果，一片空白！你是不是明白了呢？其實還是上面那句話！</p><p>我們利用它來做一個立方體：</p><p><code>#import "ViewController.h"</code></p><p><code>@interface ViewController (){</code></p><p><code></code><code>CGPoint startPoint;</code></p><p><code></code><code>CATransformLayer *s_Cube;</code></p><p><code></code><code>float pix, piy;</code></p><p><code>}</code></p><p><code>@end</code></p><p><code>@implementation ViewController</code></p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D c1t = CATransform3DIdentity;</code></p><p><code></code><code>CALayer *cube1 = [self cubeWithTransform:c1t];</code></p><p><code></code><code>s_Cube = (CATransformLayer *)cube1;</code></p><p><code></code><code>[self.view.layer addSublayer:cube1];</code></p><p><code>}</code></p><p><code>- (CALayer *)faceWithTransform:(CATransform3D)transform color:(UIColor*)color</code></p><p><code>{</code></p><p><code></code><code>CALayer *face = [CALayer layer];</code></p><p><code></code><code>face.frame = CGRectMake(-50, -50, 100, 100);</code></p><p><code></code><code>face.backgroundColor = color.CGColor;</code></p><p><code></code><code>face.transform = transform;</code></p><p><code></code><code>return</code> <code>face;</code></p><p><code>}</code></p><p><code>- (CALayer *)cubeWithTransform:(CATransform3D)transform</code></p><p><code>{</code></p><p><code></code><code>//容器</code></p><p><code></code><code>CATransformLayer *cube = [CATransformLayer layer];</code></p><p><code></code><code>//前</code></p><p><code></code><code>CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor redColor]]];</code></p><p><code></code><code>//右</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(50, 0, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor yellowColor]]];</code></p><p><code></code><code>//上</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(0, -50, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor blueColor]]];</code></p><p><code></code><code>//下</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(0, 50, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor brownColor]]];</code></p><p><code></code><code>//左</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(-50, 0, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor greenColor]]];</code></p><p><code></code><code>//後</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(0, 0, -50);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor orangeColor]]];</code></p><p><code></code><code>//</code></p><p><code></code><code>CGSize containerSize = self.view.bounds.size;</code></p><p><code></code><code>cube.position = CGPointMake(containerSize.width / 2.0,</code></p><p><code></code><code>containerSize.height / 2.0);</code></p><p><code></code><code>cube.transform = transform;</code></p><p><code></code><code>return</code> <code>cube;</code></p><p><code>}</code></p><p><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</code></p><p><code>{</code></p><p><code></code><code>UITouch *touch = [touches anyObject];</code></p><p><code></code><code>startPoint = [touch locationInView:self.view];</code></p><p><code>}</code></p><p><code>- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event</code></p><p><code>{</code></p><p><code></code><code>UITouch *touch = [touches anyObject];</code></p><p><code></code><code>CGPoint currentPosition = [touch locationInView:self.view];</code></p><p><code></code><code>CGFloat deltaX = startPoint.x - currentPosition.x;</code></p><p><code></code><code>CGFloat deltaY = startPoint.y - currentPosition.y;</code></p><p><code></code><code>CATransform3D c1t = CATransform3DIdentity;</code></p><p><code></code><code>c1t = CATransform3DRotate(c1t, pix + M_PI_2 * deltaY / 100, 1, 0, 0);</code></p><p><code></code><code>c1t = CATransform3DRotate(c1t, piy - M_PI_2 * deltaX / 100, 0, 1, 0);</code></p><p><code></code><code>s_Cube.transform = c1t;</code></p><p><code>}</code></p><p><code>- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</code></p><p><code>{</code></p><p><code></code><code>UITouch *touch = [touches anyObject];</code></p><p><code></code><code>CGPoint currentPosition = [touch locationInView:self.view];</code></p><p><code></code><code>CGFloat deltaX = startPoint.x - currentPosition.x;</code></p><p><code></code><code>CGFloat deltaY = startPoint.y - currentPosition.y;</code></p><p><code></code><code>pix = M_PI_2 * deltaY / 100;</code></p><p><code></code><code>piy = -M_PI_2 * deltaX / 100;</code></p><p><code>}</code></p><p><code>- (void)didReceiveMemoryWarning {</code></p><p><code></code><code>[</code><code>super</code> <code>didReceiveMemoryWarning];</code></p><p><code></code><code>// Dispose of any resources that can be recreated.</code></p><p><code>}</code></p><p><code>@end</code></p><p>運行結果：</p><p>如果針對上面的解釋你還不是很理解，那麼你可以把這個立方體的CATransformLayer換成CALayer，試試看嘍。</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/321f0000b8b81b7e7f69></p><p><strong>CAReplicatorLayer</strong></p><p>通過這個名字，我就確定它和圖層複製有關，你信不信？</p><p>我們看一下系統提供的API：</p><p><code>@interface CAReplicatorLayer : CALayer</code></p><p><code>@property NSInteger instanceCount; </code><code>//複製圖層的個數，包括加到上面的</code></p><p><code>@property BOOL preservesDepth; </code><code>// 子圖層是否平面化（看上面那個CATransformLayer）</code></p><p><code>@property CFTimeInterval instanceDelay; </code><code>// 複製層動畫延遲時間</code></p><p><code>@property CATransform3D instanceTransform; </code><code>//子圖層的transform變換，一般用來決定複製圖層的初始位置以及初始試圖變換</code></p><p><code>@property(nullable) CGColorRef instanceColor; </code><code>// 複製層顏色，該顏色是與本體元素色值相乘，鬼知道是什麼顏色</code></p><p><code>@property float instanceRedOffset; </code><code>// 複製層紅色偏移量</code></p><p><code>@property float instanceGreenOffset; </code><code>// 複製層綠色偏移量</code></p><p><code>@property float instanceBlueOffset; </code><code>// 複製層藍色偏移量</code></p><p><code>@property float instanceAlphaOffset; </code><code>// 複製層透明度偏移量</code></p><p><code>@end</code></p><p>屬性雖少，變化很大，主要是於核心動畫的強強聯合，他就有無限的可能性，三種效果，您上眼：</p><p>NO.1：深夜電臺廣播</p><p><code>-(void)lineWave{</code></p><p><code></code><code>CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</code></p><p><code></code><code>replicatorLayer.bounds = self.view.frame;</code></p><p><code></code><code>replicatorLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:replicatorLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 10, 40);</code></p><p><code></code><code>layer.position = CGPointMake(50, self.view.center.y);</code></p><p><code></code><code>[replicatorLayer addSublayer:layer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CABasicAnimation *basicAni = [CABasicAnimation animationWithKeyPath:@</code><code>"transform.scale.y"</code><code>];</code></p><p><code></code><code>basicAni.toValue = @(0.1);</code></p><p><code></code><code>basicAni.duration = 0.3;</code></p><p><code></code><code>basicAni.autoreverses = YES;</code></p><p><code></code><code>basicAni.repeatCount = NSIntegerMax;</code></p><p><code></code><code>[layer addAnimation:basicAni forKey:@</code><code>"layerPosition"</code><code>];</code></p><p><code></code><code>replicatorLayer.instanceCount = 8;</code></p><p><code></code><code>CATransform3D transform = CATransform3DIdentity;</code></p><p><code></code><code>transform = CATransform3DTranslate(transform, 40, 0, 0);</code></p><p><code></code><code>replicatorLayer.instanceTransform = transform;</code></p><p><code></code><code>replicatorLayer.instanceDelay = 0.3;</code></p><p><code>}</code></p><p>運行結果：</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/320c0000bb013503c633></p><p>NO. 2：催眠等待小圈圈</p><p><code>-(void)lineRoundRoll{</code></p><p><code></code><code>CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</code></p><p><code></code><code>replicatorLayer.bounds = self.view.frame;</code></p><p><code></code><code>replicatorLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:replicatorLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 40, 40);</code></p><p><code></code><code>layer.position = CGPointMake(50, self.view.center.y);</code></p><p><code></code><code>[replicatorLayer addSublayer:layer];</code></p><p><code></code><code>layer.transform = CATransform3DMakeScale(0.01, 0.01, 0.01);</code></p><p><code></code><code>//</code></p><p><code></code><code>CABasicAnimation *basicAni = [CABasicAnimation animationWithKeyPath:@</code><code>"transform.scale"</code><code>];</code></p><p><code></code><code>basicAni.fromValue = @(1);</code></p><p><code></code><code>basicAni.toValue = @(0.1);</code></p><p><code></code><code>basicAni.duration = 0.75;</code></p><p><code></code><code>basicAni.repeatCount = NSIntegerMax;</code></p><p><code></code><code>[layer addAnimation:basicAni forKey:@</code><code>"layerPosition"</code><code>];</code></p><p><code></code><code>replicatorLayer.instanceCount = 15;</code></p><p><code></code><code>replicatorLayer.preservesDepth = YES;</code></p><p><code></code><code>CATransform3D transform = CATransform3DIdentity;</code></p><p><code></code><code>transform = CATransform3DRotate(transform, M_PI * 2 / 15.0, 0, 0, 1);</code></p><p><code></code><code>replicatorLayer.instanceTransform = transform;</code></p><p><code></code><code>replicatorLayer.instanceDelay = 0.05;</code></p><p><code></code><code>replicatorLayer.instanceAlphaOffset = -1.0 / 15.0;</code></p><p><code></code><code>//replicatorLayer.instanceBlueOffset = 1.0 / 15;</code></p><p><code></code><code>//replicatorLayer.instanceColor = [UIColor redColor].CGColor;</code></p><p><code>}</code></p><p>運行結果：</p><p>NO.3：路徑跟隨</p><p><code>-(void)followPathLayer{</code></p><p><code></code><code>UIBezierPath *path = [self followPath];</code></p><p><code></code><code>//</code></p><p><code></code><code>CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</code></p><p><code></code><code>replicatorLayer.bounds = self.view.frame;</code></p><p><code></code><code>replicatorLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:replicatorLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 5;</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 10, 10);</code></p><p><code></code><code>layer.position = CGPointMake(20, self.view.center.y);</code></p><p><code></code><code>[replicatorLayer addSublayer:layer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CAKeyframeAnimation *basicAni = [CAKeyframeAnimation animationWithKeyPath:@</code><code>"position"</code><code>];</code></p><p><code></code><code>basicAni.path = path.CGPath;</code></p><p><code></code><code>basicAni.duration = 3;</code></p><p><code></code><code>basicAni.repeatCount = NSIntegerMax;</code></p><p><code></code><code>[layer addAnimation:basicAni forKey:@</code><code>"layerPosition"</code><code>];</code></p><p><code></code><code>//</code></p><p><code></code><code>replicatorLayer.instanceCount = 15;</code></p><p><code></code><code>replicatorLayer.instanceDelay = 0.3;</code></p><p><code>}</code></p><p><code>-(UIBezierPath*)followPath{</code></p><p><code></code><code>//CAShapeLayer *shapeLayer = [CAShapeLayer layer];</code></p><p><code></code><code>UIBezierPath *path = [UIBezierPath bezierPath];</code></p><p><code></code><code>[path moveToPoint:CGPointMake(20, self.view.center.y)];</code></p><p><code></code><code>[path addCurveToPoint:CGPointMake(self.view.bounds.size.width - 20, self.view.center.y) controlPoint1:CGPointMake(130, self.view.center.y - 100) controlPoint2:CGPointMake(240, self.view.center.y + 100)];</code></p><p><code></code><code>[path closePath];</code></p><p><code></code><code>//shapeLayer.path = path.CGPath;</code></p><p><code></code><code>//shapeLayer.lineWidth = 5;</code></p><p><code></code><code>//shapeLayer.strokeColor = [UIColor grayColor].CGColor;</code></p><p><code></code><code>//shapeLayer.fillColor = [UIColor clearColor].CGColor;</code></p><p><code></code><code>//[self.view.layer addSublayer:shapeLayer];</code></p><p><code></code><code>return</code> <code>path;</code></p><p><code>}</code></p><p>運行結果：</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/32130002934cf1c3fb6d></p><p>這幾個效果只是提供幾個思路，拋磚引玉啦。（這鬼錄屏卡幀加模糊，大家將就著看。)</p><p><strong>CAScrollLayer</strong></p><p>一看到這個你一定想到了UIScrollView，其實它們並沒有什麼卵關係，並且我個人覺得這個東西好像沒有太大的用處。首先，他沒有提供有關邊界的相關思路，另外，也不能響應交互。只有一下滾到這，滾到那的方法。</p><p>同樣我們可以看到在這個文件下，還有個CALayer的CALayerScrolling的分類，不要以為它給CALayer添加了可滑動的方法，其實只是查找第一個可用的CAScrollLayer，並將制定點或者指定區域滾動到可視範圍。</p><p>不過為了看一下它的效果，使它響應時間，我們可以用UIView的子類來自己寫一個簡單的ScrollView：</p><p><code>//</code></p><p><code>// YSScrollView.m</code></p><p><code>// CAScrollLayerDemo</code></p><p><code>//</code></p><p><code>// Created by ys on 2017/3/13.</code></p><p><code>// Copyright ? 2017年 ys. All rights reserved.</code></p><p><code>//</code></p><p><code>#import "YSScrollView.h"</code></p><p><code>@implementation YSScrollView</code></p><p><code>+ (Class)layerClass</code></p><p><code>{</code></p><p><code></code><code>return</code> <code>[CAScrollLayer class];</code></p><p><code>}</code></p><p><code>- (void)setUp</code></p><p><code>{</code></p><p><code></code><code>self.layer.masksToBounds = YES;</code></p><p><code></code><code>//</code></p><p><code></code><code>UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panAction:)];</code></p><p><code></code><code>[self addGestureRecognizer:panGes];</code></p><p><code>}</code></p><p><code>- (id)initWithFrame:(CGRect)frame</code></p><p><code>{</code></p><p><code></code><code>if</code> <code>((self = [</code><code>super</code> <code>initWithFrame:frame])) {</code></p><p><code></code><code>[self setUp];</code></p><p><code></code><code>}</code></p><p><code></code><code>return</code> <code>self;</code></p><p><code>}</code></p><p><code>- (void)panAction:(UIPanGestureRecognizer *)pan</code></p><p><code>{</code></p><p><code></code><code>CGPoint offset = self.bounds.origin;</code></p><p><code></code><code>offset.x -= [pan translationInView:self].x;</code></p><p><code></code><code>offset.y -= [pan translationInView:self].y;</code></p><p><code></code><code>//</code></p><p><code></code><code>[(CAScrollLayer *)self.layer scrollToPoint:offset];</code></p><p><code></code><code>//</code></p><p><code></code><code>[pan setTranslation:CGPointZero inView:self];</code></p><p><code>}</code></p><p><code>@end</code></p><p><code>然後調用加載一張大圖：</code></p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>YSScrollView *ysSView = [[YSScrollView alloc] initWithFrame:self.view.bounds];</code></p><p><code></code><code>UIImageView* imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 700, 1040)];</code></p><p><code></code><code>imageView.image = [UIImage imageNamed:@</code><code>"0101010.jpg"</code><code>];</code></p><p><code></code><code>[self.view addSubview:ysSView];</code></p><p><code></code><code>[ysSView addSubview:imageView];</code></p><p><code>}</code></p><p>運行結果：</p><p>我們發現，其實他並沒有滑動區域的限制，本人才疏學淺，望高人指點什麼時候用這個東西。</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/321200046199b2f9e67e></p><p>CATiledLayer</p><p>一個大神必備的Layer子類，為節省內存渲染開銷提供了途徑。比如我們要去加載一個世界地圖，精確到你們村的那種，如果全部一次性加載到內存中，這無疑是吃不消的，所以我們可以把地圖一片片切開，然後按部分加載，大家聯想一下地圖應用，應該就知道大致是什麼效果。我們直接上代碼：</p><p><code>#import "ViewController.h"</code></p><p><code>@interface ViewController ()</code></p><p><code>@property (nonatomic, strong) UIScrollView *scrollView;</code></p><p><code>@end</code></p><p><code>@implementation ViewController</code></p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATiledLayer *tileLayer = [CATiledLayer layer];</code></p><p><code></code><code>tileLayer.frame = CGRectMake(0, 0, self.view.frame.size.width * 4, self.view.frame.size.height * 4);</code></p><p><code></code><code>tileLayer.tileSize = self.view.frame.size;</code></p><p><code></code><code>tileLayer.delegate = self;</code></p><p><code></code><code>//</code></p><p><code></code><code>self.scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];</code></p><p><code></code><code>[self.view addSubview:_scrollView];</code></p><p><code></code><code>self.scrollView.contentSize = tileLayer.frame.size;</code></p><p><code></code><code>[self.scrollView.layer addSublayer:tileLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>[tileLayer setNeedsDisplay];</code></p><p><code>}</code></p><p><code>-(void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx{</code></p><p><code></code><code>CGRect bounds = CGContextGetClipBoundingBox(ctx);</code></p><p><code></code><code>NSInteger x = floor(bounds.origin.x / layer.tileSize.width);</code></p><p><code></code><code>NSInteger y = floor(bounds.origin.y / layer.tileSize.height);</code></p><p><code></code><code>//</code></p><p><code></code><code>NSString *imageName = [NSString stringWithFormat: @</code><code>"image_%@_%@"</code><code>, @(x), @(y)];</code></p><p><code></code><code>NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@</code><code>"jpg"</code><code>];</code></p><p><code></code><code>UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];</code></p><p><code></code><code>//</code></p><p><code></code><code>UIGraphicsPushContext(ctx);</code></p><p><code></code><code>[tileImage drawInRect:bounds];</code></p><p><code></code><code>UIGraphicsPopContext();</code></p><p><code>}</code></p><p><code>- (void)didReceiveMemoryWarning {</code></p><p><code></code><code>[</code><code>super</code> <code>didReceiveMemoryWarning];</code></p><p><code></code><code>// Dispose of any resources that can be recreated.</code></p><p><code>}</code></p><p>@end</p><p>運行結果：</p><p>其實新加載的圖像碎片都是淡入到界面的（萬惡的錄屏軟件，根本看不出來）。這是系統自己帶的默認效果，你可以通過調節fadeDuration屬性來修改改淡入動畫的時長。</p><p><strong>CATextLayer</strong></p><p>我們還是從系統提供的API入手：</p><p><code>@property(nullable, copy) id string; </code><code>//顯示內容</code></p><p><code>@property(nullable) CFTypeRef font; </code><code>//字體</code></p><p><code>@property CGFloat fontSize; </code><code>//字號</code></p><p><code>@property(nullable) CGColorRef foregroundColor; </code><code>//文字顏色</code></p><p><code>@property(getter=isWrapped) BOOL wrapped;</code><code>//是否自適應layer的bounds的大小</code></p><p><code>@property(copy) NSString *truncationMode;</code><code>//文字省略方式，其實就是顯示不下時省略號的位置</code></p><p><code>@property(copy) NSString *alignmentMode;</code><code>// 對齊方式</code></p><p>我們來用它顯示一段文字，你可以自由修改一下它的屬性來熟悉每個屬性的作用：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>//</code></p><p><code></code><code>CATextLayer *textLayer = [CATextLayer layer];</code></p><p><code></code><code>textLayer.bounds = CGRectMake(0, 0, 200, 200);</code></p><p><code></code><code>textLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:textLayer];</code></p><p><code></code><code>textLayer.foregroundColor = [UIColor blackColor].CGColor;</code></p><p><code></code><code>textLayer.alignmentMode = kCAAlignmentLeft;</code></p><p><code></code><code>textLayer.wrapped = YES;</code></p><p><code></code><code>//以Retina方式來渲染，防止畫出來的文本模糊</code></p><p><code></code><code>textLayer.contentsScale = [UIScreen mainScreen].scale;</code></p><p><code></code><code>textLayer.truncationMode = kCATruncationEnd;</code></p><p><code></code><code>UIFont *font = [UIFont systemFontOfSize:15];</code></p><p><code></code><code>CFStringRef fontName = (__bridge CFStringRef)font.fontName;</code></p><p><code></code><code>CGFontRef fontRef = CGFontCreateWithFontName(fontName);</code></p><p><code></code><code>textLayer.font = fontRef;</code></p><p><code></code><code>textLayer.fontSize = font.pointSize;</code></p><p><code></code><code>CGFontRelease(fontRef);</code></p><p><code></code><code>NSString *text = @</code><code>"Age has reached the end of the beginning of a word. May be guilty in his seems to passing a lot of different life became the appearance of the same day; May be back in the past, to oneself the paranoid weird belief disillusionment, these days, my mind has been very messy, in my mind constantly. Always feel oneself should go to do something, or write something. Twenty years of life trajectory deeply shallow, suddenly feel something, do it."</code><code>;</code></p><p><code></code><code>textLayer.string = text;</code></p><p><code>}</code></p><p>運行結果：</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/32130002934bdf39797d></p><p><strong>CAEAGLLayer，AVPlayerLayer</strong></p><p>CAEAGLLayer看起來就很高大上，其實真的挺高大上的，沒有OpenGL知識基礎的很難理解更不用說使用了，哪天，等我學會freeStyle，我唱給你聽，呦，呦。（你寫代碼有freeStyle嗎？）</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/322d00042e7740b57f57></p><p>AVPlayerLayer它屬於AVFoundation框架，不用懷疑，它就是用來播放視頻的，+ (AVPlayerLayer *)playerLayerWithPlayer:(nullable AVPlayer *)player;它的初始化依賴於AVPlayer，當然，它既然是CALayer的子類，我們就可以對它進行酷炫的效果變換，同樣也克服了系統提供的播放器由於高度的封裝性， 使得自定義播放器變的很難的問題。改天，你有需求，我有時間，不如我們寫一個播放器啊。</p><p><img alt=來看看CALayer那些牛逼的子類 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/32120004619be2ebaf72></p><p><strong>總結</strong></p><p>CALayer的所有子類都說完了，希望在一定的程度上能給你的開發帶來方便，僅此而已，我們下期再見。</p><p>剛才說到的播放器的需求大概應該必需就是這樣的！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>CALayer</a></li><li><a>子類</a></li><li><a>看看</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5bfec3e4.html alt=拉餌？看看顆粒餌料方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1534903419032f15413c09c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5bfec3e4.html title=拉餌？看看顆粒餌料方法>拉餌？看看顆粒餌料方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/725eb250.html alt=長沙今天發佈了大量商機，需要的來看看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/486bd3cc13cd4cd487851d55fec60a18 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/725eb250.html title=長沙今天發佈了大量商機，需要的來看看>長沙今天發佈了大量商機，需要的來看看</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f7a535ee.html alt=超級有效的除鏽方法，快來看看吧！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529827073459413e9ced32 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f7a535ee.html title=超級有效的除鏽方法，快來看看吧！>超級有效的除鏽方法，快來看看吧！</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/03c5103c.html alt=汽車總跑偏？看看如何讓它改“斜”歸正 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e6352e8aee174fd7a877c414bdbcf6b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/03c5103c.html title=汽車總跑偏？看看如何讓它改“斜”歸正>汽車總跑偏？看看如何讓它改“斜”歸正</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/5b8c9228.html alt=乾貨｜要想跑的快，先看看你吃對了嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/271d9e1eeb5d4407955064f9f3173cff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/5b8c9228.html title=乾貨｜要想跑的快，先看看你吃對了嗎？>乾貨｜要想跑的快，先看看你吃對了嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0b73f3a5.html alt=時間繼電器，不是很懂的，可以看看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15325290768260571b4780e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0b73f3a5.html title=時間繼電器，不是很懂的，可以看看>時間繼電器，不是很懂的，可以看看</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/b26ed822.html alt=帶大家看看新疆真正的羅布麻 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8ddea1a1a6cd40c89021b73c5f561a94 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/b26ed822.html title=帶大家看看新疆真正的羅布麻>帶大家看看新疆真正的羅布麻</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/e771d5d3.html alt=看看有懂得嗎？給個價 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/tos-cn-i-0022/4d534628d9a74ce29aab7f537449e46f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/e771d5d3.html title=看看有懂得嗎？給個價>看看有懂得嗎？給個價</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/cdbc74a8.html alt="傅（付）氏 家譜 字輩 彙編，看看吧~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15342278358423993b2c85c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/cdbc74a8.html title="傅（付）氏 家譜 字輩 彙編，看看吧~">傅（付）氏 家譜 字輩 彙編，看看吧~</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/5fd485b6.html alt=500年的人蔘！看看長啥樣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/tos-cn-i-0022/5c6b4be87b3647d88abe5173047584cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/5fd485b6.html title=500年的人蔘！看看長啥樣>500年的人蔘！看看長啥樣</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/fc982e4d.html alt=看看世界各國人眼中的人蔘 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/4378000054a940e0b27b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/fc982e4d.html title=看看世界各國人眼中的人蔘>看看世界各國人眼中的人蔘</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/d813ffca.html alt=螃蟹腿斷了，還能吃嗎？一起來看看 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/341f64d1-6af6-4b45-8500-e16dcdea1285 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/d813ffca.html title=螃蟹腿斷了，還能吃嗎？一起來看看>螃蟹腿斷了，還能吃嗎？一起來看看</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a0fceb3.html alt=不同的茶退火多久才能喝？看看你做對了嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/13e80ba4fd6b42c3af96680af2a1ef54 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a0fceb3.html title=不同的茶退火多久才能喝？看看你做對了嗎？>不同的茶退火多久才能喝？看看你做對了嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f95d5bfd.html alt=C++子類的成員函數如何成為父類的友元函數？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/912200096040d5e4e8cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f95d5bfd.html title=C++子類的成員函數如何成為父類的友元函數？>C++子類的成員函數如何成為父類的友元函數？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9541deca.html alt=List的子類 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/0642e15b-8435-485b-857f-023548e2841d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9541deca.html title=List的子類>List的子類</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>