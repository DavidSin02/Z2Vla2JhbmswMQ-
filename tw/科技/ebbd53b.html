<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗 | 极客快訊</title><meta property="og:title" content="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ebbd53b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1）實驗平臺：【正點原子】 NANO STM32F103 開發板</strong></p><p><strong>2）摘自《正點原子STM32 F1 開發指南(NANO 板-HAL 庫版)》關注官方微信號公眾號，獲取更多資料：正點原子</strong></p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f><p class=pgc-img-caption>第十三章 定時器中斷實驗</p></div><p><strong>第十三章 定時器中斷實驗</strong></p><p>這一章，我們將向大家介紹如何使用 STM32F1 的通用定時器，STM32F1 的定時器功能十分強大，在中容量的 STM32 中有 TIME1 高級定時器，也有 TIME2~TIME4 等通用定時器，在《STM32 參考手冊》裡面，定時器的介紹佔了 1/5 的篇幅，足見其重要性。在本章中，我們將利用 TIM3 的定時器中斷來控制 DS1 的翻轉，在主函數用 DS0 的翻轉來提示程序正在運行。本章，我們選擇難度適中的通用定時器來介紹，本章將分為如下幾個部分：</p><p>13.1 STM32F1 通用定時器簡介</p><p>13.2 硬件設計</p><p>13.3 軟件設計</p><p>13.4 下載驗證</p><p>13.5 STM32CubeMX 配置定時器更新中斷功能</p><p><strong>13.1 STM32 通用定時器簡介</strong></p><p>STM32F1 的通用定時器是一個通過可編程預分頻器（PSC）驅動的 16 位自動裝載計數器（CNT）構成。STM32 的通用定時器可以被用於：測量輸入信號的脈衝長度(輸入捕獲)或者產生輸出波形(輸出比較和 PWM)等。 使用定時器預分頻器和 RCC 時鐘控制器預分頻器，脈衝長度和波形週期可以在幾個微秒到幾個毫秒間調整。STM32 的每個通用定時器都是完全獨立的，沒有互相共享的任何資源。</p><p>STM32F1 的通用 TIMx (TIM2、TIM3、TIM4)定時器功能包括：</p><p>1)16 位向上、向下、向上/向下自動裝載計數器（TIMx_CNT）。</p><p>2)16 位可編程(可以實時修改)預分頻器(TIMx_PSC)，計數器時鐘頻率的分頻係數為 1～</p><p>65535 之間的任意數值。</p><p>3）4 個獨立通道（TIMx_CH1~4），這些通道可以用來作為：</p><p>A．輸入捕獲</p><p>B．輸出比較</p><p>C．PWM 生成(邊緣或中間對齊模式)</p><p>D．單脈衝模式輸出</p><p>4）可使用外部信號（TIMx_ETR）控制定時器和定時器互連（可以用 1 個定時器控制另外</p><p>一個定時器）的同步電路。</p><p>5）如下事件發生時產生中斷/DMA：</p><p>A．更新：計數器向上溢出/向下溢出，計數器初始化(通過軟件或者內部/外部觸發)</p><p>B．觸發事件(計數器啟動、停止、初始化或者由內部/外部觸發計數)</p><p>C．輸入捕獲</p><p>D．輸出比較</p><p>E．支持針對定位的增量(正交)編碼器和霍爾傳感器電路</p><p>F．觸發輸入作為外部時鐘或者按週期的電流管理</p><p>由於 STM32 通用定時器比較複雜，這裡我們不再多介紹，請大家直接參考《STM32 參考</p><p>手冊》第 253 頁，通用定時器一章。為了深入瞭解 STM32 的通用寄存器，下面我們先介紹一</p><p>下與我們這章的實驗密切相關的幾個通用定時器的寄存器。</p><p>首先是控制寄存器 1（TIMx_CR1），該寄存器的各位描述如圖 13.1.1 所示：</p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cea3165049db4f8e806cacb7627dc917><p class=pgc-img-caption>圖 13.1.1 TIMx_CR1 寄存器各位描述</p></div><p>首先我們來看看 TIMx_CR1 的最低位，也就是計數器使能位，該位必須置 1，才能讓定時</p><p>器開始計數。從第 4 位 DIR 可以看出默認的計數方式是向上計數，同時也可以向下計數，第 5,6</p><p>位是設置計數對齊方式的。從第 8 和第 9 位可以看出，我們還可以設置定時器的時鐘分頻因子</p><p>為 1,2,4。接下來介紹第二個與我們這章密切相關的寄存器：DMA/中斷使能寄存器</p><p>（TIMx_DIER）。該寄存器是一個 16 位的寄存器，其各位描述如圖 13.1.2 所示：</p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe6e3a42d808485ea5af6b025d82e7f9><p class=pgc-img-caption>圖 13.1.2 TIMx_ DIER 寄存器各位描述</p></div><p>這裡我們同樣僅關心它的第 0 位，該位是更新中斷允許位，本章用到的是定時器的更新中</p><p>斷，所以該位要設置為 1，來允許由於更新事件所產生的中斷。</p><p>接下來我們看第三個與我們這章有關的寄存器：預分頻寄存器（TIMx_PSC）。該寄存器</p><p>用設置對時鐘進行分頻，然後提供給計數器，作為計數器的時鐘。該寄存器的各位描述如圖</p><p>13.1.3 所示：</p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dd19a63d29b348c9b6606dcb4987e264><p class=pgc-img-caption>圖 13.1.3 TIMx_ PSC 寄存器各位描述</p></div><p>這裡，定時器的時鐘來源有 4 個：</p><p>1）內部時鐘（CK_INT）</p><p>2）外部時鐘模式 1：外部輸入腳（TIx）</p><p>3）外部時鐘模式 2：外部觸發輸入（ETR）</p><p>4）內部觸發輸入（ITRx）：使用 A 定時器作為 B 定時器的預分頻器（A 為 B 提供時鐘）。</p><p>這些時鐘，具體選擇哪個可以通過 TIMx_SMCR 寄存器的相關位來設置。這裡的 CK_INT</p><p>時鐘是從 APB1 倍頻的來的，除非 APB1 的時鐘分頻數設置為 1，否則通用定時器 TIMx 的時鐘</p><p>是 APB1 時鐘的 2 倍，當 APB1 的時鐘不分頻的時候，通用定時器 TIMx 的時鐘就等於 APB1</p><p>的時鐘。這裡還要注意的就是高級定時器的時鐘不是來自 APB1，而是來自 APB2 的。</p><p>這裡順帶介紹一下 TIMx_CNT 寄存器，該寄存器是定時器的計數器，該寄存器存儲了當前</p><p>定時器的計數值。</p><p>接著我們介紹自動重裝載寄存器（TIMx_ARR），該寄存器在物理上實際對應著 2 個寄存</p><p>器。一個是程序員可以直接操作的，另外一個是程序員看不到的，這個看不到的寄存器在</p><p>《STM32 參考手冊》裡面被叫做影子寄存器。事實上真正起作用的是影子寄存器。根據</p><p>TIMx_CR1 寄存器中 APRE 位的設置：APRE=0 時，預裝載寄存器的內容可以隨時傳送到影子</p><p>寄存器，此時 2 者是連通的；而 APRE=1 時，在每一次更新事件（UEV）時，才把預裝在寄存</p><p>器的內容傳送到影子寄存器。</p><p>自動重裝載寄存器的各位描述如圖 13.1.4 所示：</p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f91ed97afae7469fa9d168a9f0e5b78d><p class=pgc-img-caption>圖 13.1.4 TIMx_ ARR 寄存器各位描述</p></div><p>最後，我們要介紹的寄存器是：狀態寄存器（TIMx_SR）。該寄存器用來標記當前與定時</p><p>器相關的各種事件/中斷是否發生。該寄存器的各位描述如圖 13.1.5 所示：</p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0804dd2540504c4196eaf3ddba2bd52b><p class=pgc-img-caption>圖 13.1.5 TIMx_ SR 寄存器各位描述</p></div><p>關於這些位的詳細描述，請參考《STM32 參考手冊》第 282 頁。</p><p>只要對以上幾個寄存器進行簡單的設置，我們就可以使用通用定時器了，並且可以產生中</p><p>斷。</p><p>這一章，我們將使用定時器產生中斷，然後在中斷服務函數裡面翻轉 DS1 上的電平，來指</p><p>示定時器中斷的產生。接下來我們以通用定時器 TIM3 為實例，來說明要經過哪些步驟，才能</p><p>達到這個要求，併產生中斷。這裡我們就對每個步驟通過庫函數的實現方式來描述。首先要提</p><p>到 的 是 ， 定 時 器 相 關 的 庫 函 數 主 要 集 中 在 HAL 庫文件 stm32f1xx_hal_tim.h 和</p><p>stm32f1xx_hal_tim.c 文件中。定時器配置步驟如下：</p><p><strong>1）TIM3 時鐘使能。</strong></p><p>HAL 中定時器使能是通過宏定義標識符來實現對相關寄存器操作的，方法如下：</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 時鐘</p><p><strong>2）初始化定時器參數,設置自動重裝值，分頻係數，計數方式等。</strong></p><p>在 HAL 庫中，定時器的初始化參數是通過初始化函數 HAL_TIM_Base_Init 實現的：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim);</p><p>該函數只有一個入口參數，就是 TIM_HandleTypeDef 類型結構體指針，結構體類型為下面</p><p>我們看看這個結構體的定義：</p><p>typedef struct</p><p>{</p><p>TIM_TypeDef *Instance;</p><p>TIM_Base_InitTypeDef Init;</p><p>HAL_TIM_ActiveChannel Channel;</p><p>DMA_HandleTypeDef *hdma[7U];</p><p>HAL_LockTypeDef Lock;</p><p>__IO HAL_TIM_StateTypeDef State;</p><p>}TIM_HandleTypeDef;</p><p>第一個參數 Instance 是寄存器基地址。和串口，看門狗等外設一樣，一般外設的初始化結</p><p>構體定義的第一個成員變量都是寄存器基地址。這在 HAL 中都定義號了，比如要初始化定時</p><p>器 1，那麼的值設置為 TIM1 即可。</p><p>第二個參數 Init 為真正的初始化結構體 TIM_Base_InitTypeDef 類型，給結構體定義如下：</p><p>typedef struct</p><p>{</p><p>uint32_t Prescaler;//預分頻係數</p><p>uint32_t CounterMode; //計數方式</p><p>uint32_t Period;//自動裝載值 ARR</p><p>uint32_t ClockDivision;//時鐘分頻因子</p><p>uint32_t RepetitionCounter;</p><p>uint32_t AutoReloadPreload;</p><p>}TIM_Base_InitTypeDef;;</p><p>該初始化結構體中，參數 Prescaler 是用來設置分頻係數的，剛才上面有講解。參數</p><p>CounterMode 是用來設置計數方式，可以設置為向上計數，向下計數方式還有中央對齊計數方</p><p>式 ， 比 較 常 用 的 是 向 上 計 數 模 塊 TIM_CouterMode_Up 和 向 上 計 數 模 式</p><p>TIM_CounterMode_Down。參數 Period 是設置自動重載計數週期值。參數 ClockDivision 是用來</p><p>設置時鐘分頻因子，也就是定時器時鐘頻率 CK_INT 與數字濾波器所使用的採樣時鐘之間的分</p><p>頻比。參數 RepetitionCounter 用來設置活躍通道。用在高級定時器中。參數 AutoReloadPerload</p><p>用來設置自動重新加載預載。</p><p>第三個參數 Channel 用來設置活躍通道。前面我們講解過，每個定時器最多有四個通道可</p><p>以用來做輸出比較，輸入捕獲等功能之用。這裡的 Channel 就是用來設置活躍通道的，取值範</p><p>圍內：HAL_TIM_ACTIVE_CHANNEL_1 ~ HAL_TIM_ACTIVE_CHANNEL_4。</p><p>第四個 hdma 是是定時器的 DMA 功能時用到，為了簡單起見，我們暫時不講解太複雜。</p><p>第五個參數 Lock 和 State，是狀態過程標識符，是 HAL 庫用來記錄和標誌定時器處理過程。</p><p>定時器初始化範例如下：</p><p>TIM_HandleTypeDef TIM3_Handler; //定時器句柄</p><p>TIM3_Handler.Instance=TIM3; //通用定時器 3</p><p>TIM3_Handler.Init.Prescaler=7199; //分頻係數</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;//向上計數器</p><p>TIM3_Handler.Init.Period=4999; //自動裝載值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//時鐘分頻因子</p><p>TIM3_Handler.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;</p><p>//使能自動重載</p><p>HAL_TIM_Base_Init(&TIM3_Handler);</p><p><strong>3）使能定時器更新中斷，使能定時器</strong></p><p>HAL 庫 中 ， 使 能 定 時 器 更 新 中 斷 和 使 能 定 時 器 兩 個 操 作 可 以 在 函 數</p><p>HAL_TIME_Base_Start_IT()中一次完成的，該函數聲明如下：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)；</p><p>該 函 數 非 常 好 理 解 ， 只 有 一 個 入 口 參 數 。 調 用 該 定 時 器 之 後 ， 會 首 先 調 用</p><p>__HAL_TIM_ENABLE_IT 宏定義使能更新中斷，然後調用宏定義__HAL_TIM_ENABLE 使能</p><p>相應的定時器。這裡我們分別列出單獨使能/關閉定時器中斷和使能/關閉定時器方法：</p><p>__HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);//使能句柄制定的定時器更新中斷</p><p>__HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);//關閉句柄指定的定時器更新中斷</p><p>__HAL_TIM_ENABLE(htim);//使能句柄 htim 制訂的定時器</p><p>__HAL_TIM_DISABLE(htim);//關閉句柄 htim 制定的定時器</p><p><strong>4）TIM3 中斷優先級設置</strong></p><p>在定時器中斷使能之後，因為要產生中斷，必不可少的要設置 NVIC 的相關寄存器，設置</p><p>中斷優先級。之前多次講解到中斷優先級的設置，這裡就不重複講解。</p><p>和串口等其他外設一樣，HAL 庫為定時器初始化定義了回調函數 HAL_TIM_Base_MspInit。</p><p>一般情況下，與 MCU 有關的使能使能，以及中斷優先級配置我們都會放在該回調函數內部。</p><p>函數聲明如下：</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)；</p><p>對於回調函數，這裡我們就不做過多講解，大家只需要重寫這個函數即可。</p><p><strong>5）編寫中斷服務函數</strong></p><p>在最後，還是要編寫定時器中斷服務函數，通過該函數來處理定時器產生的相關中斷。通</p><p>常情況下，在中斷產生後，通過狀態寄存器的值來判斷此次產生的中斷屬於什麼類型。然後執</p><p>行相關的操作，我們這裡使用的是更新（溢出）中斷，所以在狀態寄存器 SR 的最低位。在處</p><p>理完中斷之後應該向 TIM3_SR 的最低位寫 0，來清除該中斷標誌。</p><p>跟串口一樣，對於定時器中斷，HAL 庫同樣為我們封裝了處理過程。這裡我們以定時器 3</p><p>的更新中斷為例來講解。</p><p>首先，中斷服務函數是不變的，定時器 3 的中斷服務函數為：</p><p>void TIM3_IRQHandler(void)；</p><p>一般情況下我們是在中斷服務函數內部編寫中斷控制邏輯。到那時 HAL 庫為我們定義了</p><p>新的定時器中斷共用處理函數 HAL_TIM_IRQHandler，在每個定時器的中斷服務函數內部，我</p><p>們會調用該函數。該函數聲明如下：</p><p>void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)；</p><p>而函數 HAL_TIM_IRQHandler 內部，會對相應的中斷標誌進行詳細判斷，判斷確定中斷來</p><p>源後，會自動清掉該中斷標誌位，同時調用不同類型中孤單的回調函數。所以我們的中斷控制</p><p>邏輯只用編寫在中斷回調函數中，並且中斷回調函數中不需要清中斷標誌位。</p><p>比如定時器更新中斷回調函數為：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)；</p><p>跟串口中斷回調函數一樣，我們只需要重寫該函數即可。對於其他類型中斷，HAL 庫同樣</p><p>提供幾個不同的回調函數，這裡我們列出常用的幾個回調函數：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);//更新中斷</p><p>void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim);//輸出比較</p><p>void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim);//輸入捕獲</p><p>void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim);//觸發中斷</p><p>對於這些回調函數的使用方法我們在後面用到的時候會給大家詳細講解。</p><p>通過以上幾個步驟，我們就可以達到我們的目的了，使用通用定時器的更新中斷，來控制</p><p>DS1 的亮滅。</p><p><strong>13.2 硬件設計</strong></p><p>本實驗用到的硬件資源有：</p><p>1） 指示燈 DS0 和 DS1</p><p>2） 定時器 TIM3</p><p>本章將通過 TIM3 的中斷來控制 DS1 的亮滅，DS1 在前面已經有介紹了。而 TIM3 屬於</p><p>STM32 的內部資源，只需要軟件設置即可正常工作。</p><p><strong>13.3 軟件設計</strong></p><p>軟件設計我們直接打開我們光盤實驗 8 定時器中斷實驗即可。我們可以看到我們的工程中</p><p>的 HARDWARE 下面比以前多了一個 time.c 文件（包括頭文件 time.h），這兩個文件是我們自</p><p>己編寫。同時還引入了定時器相關的固件庫函數文件 stm32f1xx_hal_tim.c 和 頭文 件</p><p>stm32f1xx_hal_tim.h。下面我們來看看我們的 time.c 文件。</p><p>time.c 文件代碼：</p><p>TIM_HandleTypeDef TIM3_Handler; //定時器句柄</p><p>//通用定時器 3 中斷初始化</p><p>//arr：自動重裝值。</p><p>//psc：時鐘預分頻數</p><p>//定時器溢出時間計算方法:Tout=((arr+1)*(psc+1))/Ft us.</p><p>//Ft=定時器工作頻率,單位:Mhz</p><p>//這裡使用的是定時器 3!</p><p>void TIM3_Init(u16 arr,u16 psc)</p><p>{</p><p>TIM3_Handler.Instance=TIM3; //通用定時器 3</p><p>TIM3_Handler.Init.Prescaler=psc; //分頻係數</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP; //向上計數器</p><p>TIM3_Handler.Init.Period=arr; //自動裝載值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//時鐘分頻因子</p><p>TIM3_Handler.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;</p><p>//使能自動重載</p><p>HAL_TIM_Base_Init(&TIM3_Handler);//初始化定時器 3</p><p>HAL_TIM_Base_Start_IT(&TIM3_Handler);</p><p>//使能定時器 3 更新中斷：TIM_IT_UPDATE</p><p>}</p><p>//定時器底冊驅動，開啟時鐘，設置中斷優先級</p><p>//此函數會被 HAL_TIM_Base_Init()函數調用</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim->Instance==TIM3)</p><p>{</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 時鐘</p><p>HAL_NVIC_SetPriority(TIM3_IRQn,1,3);</p><p>//設置中斷優先級，搶佔優先級 1，子優先級 3</p><p>HAL_NVIC_EnableIRQ(TIM3_IRQn); //開啟 ITM3 中斷</p><p>}</p><p>}</p><p>//定時器 3 中斷服務函數</p><p>void TIM3_IRQHandler(void)</p><p>{</p><p>HAL_TIM_IRQHandler(&TIM3_Handler);</p><p>}</p><p>//回調函數，定時器中斷服務函數調用</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim==(&TIM3_Handler))</p><p>{</p><p>LED1=!LED1; //LED1 反轉</p><p>}</p><p>}</p><p>該文件一共有 4 個函數。第一個函數 TIM3_Init 用來初始化定時器 3，使能定時器 1 更新中</p><p>斷以及使能定時器，實現的是 13.1 小節講解的步驟 2 和步驟 3 配置功能。該函數的 2 個參數用</p><p>來設置 TIM3 的溢出時間。因為我們在 Stm32_Clock_Init 函數裡面已經初始化 APB1 的時鐘為 2</p><p>分頻，所以 APB1 的時鐘為 36M，而從 STM32 的內部時鐘樹圖得知：當 APB1 的時鐘分頻數</p><p>為 1 的時候，TIM2~7 的時鐘為 APB1 的時鐘，而如果 APB1 的時鐘分頻數不為 1，那麼 TIM2~7</p><p>的時鐘頻率將為 APB1 時鐘的兩倍。因此，TIM3 的時鐘為 72M，再根據我們設計的 arr 和 psc</p><p>的值，就可以計算中斷時間了。計算公式如下：</p><p>Tout= ((arr+1)*(psc+1))/Tclk；</p><p>其中：</p><p>Tclk：TIM3 的輸入時鐘頻率（單位為 Mhz）。</p><p>Tout：TIM3 溢出時間（單位為 us）。</p><p>第二個函數 HAL_TIM_Base_MspInit 是定時器初始化回調函數，主要是使能定時器 3 時鐘</p><p>以及定時器 3 的 NVIC 配置，實現的是 13.1 小節講解的步驟 1 和步驟 4 功能。第三個函數</p><p>TIM3_IRQHandler 是中斷服務入口函數，該函數內部只有一行代碼就是調用定時器中斷共用處</p><p>理函數 HAL_TIM_IRQHandler。根據前面的講解，函數 HAL_TIM_IRQHandler 內部會判斷中斷</p><p>來源，根據中斷來源調用不同的中斷處理回調函數。這裡我們開啟的是定時器 3 的更新中斷，</p><p>所以我們需要重定義更新中斷回調函數 HAL_TIM_PeriodElapsedCallback。第四個函數</p><p>HAL_TIM_PeriodElapsedCallback 就是更新中斷回調函數，也就是真正的中斷處理函數，該函數</p><p>內部通過判斷中斷時定時器 3 之後，然後控制 LED1 翻轉。</p><p>time.h 頭文件內容比較簡單，這裡我們就不做講解了。</p><p>最後，我們看看主函數代碼如下：</p><p>int main(void)</p><p>{</p><p>HAL_Init(); //初始化 HAL 庫</p><p>Stm32_Clock_Init(RCC_PLL_MUL9); //設置時鐘,72M</p><p>delay_init(72); //初始化延時函數</p><p>uart_init(9600);</p><p>//初始化串口</p><p>LED_Init(); //初始化 LED</p><p>TIM3_Init(5000-1,7200-1); //定時器 3 初始化，定時器時鐘為 72M，分頻係數為 7199，</p><p>//所以定時器 3 的頻率為 72M/7200=10K，自動重裝載為 4999，那麼定時器週期就是 500ms</p><p>while(1)</p><p>{</p><p>LED0=!LED0; //LED0 翻轉</p><p>delay_ms(200); //延時 200ms</p><p>}</p><p>}</p><p>這裡的代碼和之前大同小異，此段代碼對 TIM3 進行初始化之後，進入死循環等待 TIM3</p><p>溢出中斷，當 TIM3_CNT 的值等於 TIM3_ARR 的值的時候，就會產生 TIM3 的更新中斷，然</p><p>後在中斷裡面取反 LED1，TIM3_CNT 再從 0 開始計數。根據上面的公式，我們可以算出中斷</p><p>溢出時間為 500ms，即 Tout= ((4999+1)*( 7199+1))/72=500000us=500ms。</p><p><strong>13.4 下載驗證</strong></p><p>在完成軟件設計之後，我們將編譯好的文件下載到 NANO STM32 開發板上，觀看其運行</p><p>結果是否與我們編寫的一致。如果沒有錯誤，我們將看 DS0 不停閃爍（每 400ms 閃爍一次），</p><p>而 DS1 也是不停的閃爍，但是閃爍時間較 DS0 慢（1s 一次）。</p><p><strong>13.5 STM32CubeMX 配置定時器更新中斷功能</strong></p><p>我們將列出 STM32CubeMx 配置的關鍵點，然後生成工程，大家自行與光盤中提供的實驗</p><p>代碼對照學習。</p><p>定時器 3 中斷配置非常簡單。配置步驟如下：</p><p>① 在 Pinout->TIM3 配置項中，配置 Clock Source 為 Internal Clock，如下圖 13.5.1 所示：</p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5f2c61f0b08243b19da5341178be15fd><p class=pgc-img-caption>圖 13.5.1 TIM3 配置</p></div><p>② 進入 Configuration->TIM3 配置項，在彈出的界面中點擊 Parameter Settings 選項卡，Counter</p><p>Settings 配置欄下面的五個選項就是用來配置定時器的預分頻係數，自動預裝載值，計數模式、時鐘分頻因子，以及使能自動裝載功能。操作方法如下圖所示：</p><div class=pgc-img><img alt="「正點原子NANO STM32F103開發板資料連載 第13章 定時器中斷實驗" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48be5d5496dc48f1a22546647c41fbe8><p class=pgc-img-caption>圖 13.5.2 TIM3 參數設置界面</p></div><p>③ 進入 Configuration->NVIC 配置頁，在彈出的界面中點擊 NVIC 選項卡，配置 Interput Table</p><p>中 TIM3 global interupt，使能中斷，配置搶佔優先級和相應優先級。</p><p>經過上面三個步驟，生成代碼，大家對比生成的代碼和實驗工程的區別。這裡需要說明的</p><p>時，默認情況下，TIM3 的時鐘來源時內部時鐘 CK_INT，所以在我們實驗中使用的時默認配置，</p><p>沒有額外在程序中體現。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>正點</a></li><li><a>NANO</a></li><li><a>STM32F103</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html alt="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1800ef39.html title="「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器">「正點原子NANO STM32F103開發板資料連載第26章 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html alt="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f952aeb.html title="「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器">「正點原子NANO STM32開發板資料連載」第二十七 數字溫度傳感器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/258b34f.html alt="「正點原子NANO STM32開發板資料連載」第十章 外部中斷實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/258b34f.html title="「正點原子NANO STM32開發板資料連載」第十章 外部中斷實驗">「正點原子NANO STM32開發板資料連載」第十章 外部中斷實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html title=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示>正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html title="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗">正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html alt=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be3b196e.html title=正點原子開拓者NiosII資料連載第二十六章高速示波器實驗>正點原子開拓者NiosII資料連載第二十六章高速示波器實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cbd5c1.html alt=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cbd5c1.html title=正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗>正點原子開拓者FPGA開發板資料連載第二十八章EEPROM讀寫測試實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html alt="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5262661.html title="正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理">正點原子開拓者Nios II資料連載第17章uC/OSII任務管理與時間管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a1c139.html alt="STM32F103 使用TIM3產生四路PWM的代碼及註釋" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f3bca627762e429fb01ff2ae04385e59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a1c139.html title="STM32F103 使用TIM3產生四路PWM的代碼及註釋">STM32F103 使用TIM3產生四路PWM的代碼及註釋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c740aaf.html alt="STM32F103編程學習——USB HID篇" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/de9ca4bcd97c4faba76ec7c22fbb7b46 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c740aaf.html title="STM32F103編程學習——USB HID篇">STM32F103編程學習——USB HID篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e6b468.html alt="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5856d59cc4974cb9aa41181fb439c28c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e6b468.html title="「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗">「正點原子STM32Mini板資料連載」第十二章 定時器中斷實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4d61c8.html alt=調試分享：STM32F103串口UsartDMA模式，已測試 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/068d102ca60e44419488bd4c7d35af45 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4d61c8.html title=調試分享：STM32F103串口UsartDMA模式，已測試>調試分享：STM32F103串口UsartDMA模式，已測試</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f23fb6.html alt="電子那點事： STM32F103 中斷軟硬件講解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/329116c018af48f9b995c20c4b73c8fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f23fb6.html title="電子那點事： STM32F103 中斷軟硬件講解">電子那點事： STM32F103 中斷軟硬件講解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>