<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ | 极客快訊</title><meta property="og:title" content="寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/2ecf21779b21415ab0ac07e51cb9f117"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebc0bd3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebc0bd3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebc0bd3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebc0bd3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebc0bd3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebc0bd3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebc0bd3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebc0bd3.html><meta property="article:published_time" content="2020-10-29T20:50:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:28+08:00"><meta name=Keywords content><meta name=description content="寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ebc0bd3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1>TCP協議解析</h1><p>TCP是一個巨複雜的協議，因為它要解決很多問題，而這些問題又帶出了很多子問題和陰暗面。所以學習TCP本身是個比較痛苦的過程，但對於學習的過程卻能讓人有很多收穫。</p><p>之所以想寫這篇文章，目的有三個，</p><ul><li>一個是想鍛鍊一下自己是否可以用簡單的篇幅把這麼複雜的TCP協議描清楚的能力。</li><li>另一個是覺得現在的好多程序員基本上不會認認真真的讀本書，喜歡快餐文化，所以，希望這篇快餐文章可以讓你對TCP這個古典技術有所瞭解，並能體會到軟件設計中的種種難出。並且你可以從中有一些軟件設計上的收穫。</li><li>最重要的希望這些基礎知識可以讓你搞清很多以前一些似是而非的東西，並且你能意識到基礎的重要。</li></ul><p>所以，本文不會面面俱到，只是對TCP協議、算法和原理的科普。</p><p>我本來只想寫一個篇幅的文章的，但是TCP真的很複雜，比C++複雜多了，這30多年來，各種優化變種爭論和修改。所以，寫著寫著就發現只有砍成兩部分。</p><ul><li>上半部分中，主要向你介紹TCP協議的定以和丟包時的重傳機制。</li><li>下半部分中，重點介紹TCP的流迭、擁塞處理。</li></ul><p>廢話少說，首先，我們需要知道TCP在網絡OSI的七層模型中的第四層——Transport層，IP在第三層——Network層，ARP在第二層——Data Link層。在第二層上的數據，我們叫Frame，在第三層上的數據叫Packet，第四層的數據叫Segment。</p><p>首先，我們需要知道，我們程序的數據首先會打到TCP的Segment中，然後TCP的Segment會打到IP的Packet中，然後再打到以太網Ethernet的Frame中，傳到對端後，各個層解析自己的協議，然後把數據交給更高層的協議處理。</p><h1><strong>TCP頭格式</strong></h1><p>接下來，我們來看一下TCP頭的格式</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2ecf21779b21415ab0ac07e51cb9f117></div><p>你需要注意這麼幾點：</p><ul><li>TCP的包是沒有IP地址的，那是IP層上的事，但是有源端口和目標端口。</li><li>一個TCP連接需要四個元組來表示是同一個連接（src_ip, src_port, dst_ip, dst_port）準確說是五元組，還有一個是協議。但因為這裡只是說TCP協議，所以，這裡我只說四元組。</li><li>注意上圖中的四個非常重要的東西：<strong>Sequence Number</strong>是包的序號，<strong>用來解決網絡包亂序（reordering）問題。Acknowledgement Number</strong>就是ACK——用於確認收到，<strong>用來解決不丟包的問題</strong>。<strong>Window又叫Advertised-Window</strong>，也就是著名的滑動窗口（Sliding Window），<strong>用於解決流控的</strong>。<strong>TCP Flag</strong> ，也就是包的類型，<strong>主要是用於操控TCP的狀態機的</strong>。</li></ul><p>關於其它的東西，可以參看下面的圖示</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2a824964c50b4031bf35fc17dd7e098e></div><h1><strong>TCP的狀態機</strong></h1><p>其實，<strong>網絡上的傳輸是沒有連接的，包括TCP也是一樣的</strong>。而TCP所謂的“連接”，其實只不過是在通訊的雙方維護一個“連接狀態”，讓它看上去好像有連接一樣。所以，TCP的狀態變換是非常重要的。</p><p>下面是：“<strong>TCP協議的狀態機</strong>” 和 “<strong>TCP建立鏈接</strong>”、“<strong>TCP斷開鏈接</strong>”、“<strong>傳輸數據</strong>” 的對照圖，我把兩個圖並排放在一起，這樣方便在你對照著看。另外，下面這兩個圖非常非常的重要，你一定要記牢。（吐個槽：看到這樣複雜的狀態機，就知道這個協議有多複雜，複雜的東西總是有很多坑爹的事情，所以TCP協議其實也挺坑爹的）</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7a53aecc37148598d6dcdcc89717688></div><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/29f79b011379474c8647e70f19dc13d0></div><p>很多人會問，為什麼建立鏈接要3次握手，斷開鏈接需要4次揮手？</p><ul><li><strong>對於建立鏈接的3次握手，</strong>主要是要初始化Sequence Number 的初始值。通信的雙方要互相通知對方自己的初始化的Sequence Number（縮寫為ISN：Inital Sequence Number）——所以叫SYN，全稱Synchronize Sequence Numbers。也就上圖中的 x 和 y。這個號要作為以後的數據通信的序號，以保證應用層接收到的數據不會因為網絡上的傳輸的問題而亂序（TCP會用這個序號來拼接數據）。</li><li><strong>對於4次揮手，</strong>其實你仔細看是2次，因為TCP是全雙工的，所以，發送方和接收方都需要Fin和Ack。只不過，有一方是被動的，所以看上去就成了所謂的4次揮手。如果兩邊同時斷連接，那就會就進入到CLOSING狀態，然後到達TIME_WAIT狀態。下圖是 雙方同時斷連接的示意圖（你同樣可以對照著TCP狀態機看）：</li></ul><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/588ec1a4eb4f46e7acc63278d18bb33e></div><p>兩端同時斷連接</p><p>另外，有幾個事情需要注意一下：</p><ul><li><strong>關於建立連接時SYN超時</strong>。試想一下，如果server端接到了clien發的SYN後回了SYN-ACK後 client掉線了，server端沒有收到client回來的ACK，那麼，這個連接處於一箇中間狀態，即沒成功，也沒失敗。於是，server端如果 在一定時間內沒有收到的TCP會重發SYN-ACK。在Linux下，默認重試次數為5次，重試的間隔時間從1s開始每次都翻售，5次的重試時間間隔為 1s, 2s, 4s, 8s, 16s，總共31s，第5次發出後還要等32s都知道第5次也超時了，所以，總共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才會打斷開這個連接。</li><li><strong>關於SYN Flood攻擊</strong>。一些惡意的人就為此製造了SYN Flood攻擊——給服務器發了一個SYN後，就下線了，於是服務器需要默認等63s才會斷開連接，這樣，攻擊者就可以把服務器的syn連接的隊列耗盡，讓正常的連接請求不能處理。於是，Linux下給了一個叫<strong>tcp_syncookies</strong>的 參數來應對這個事——當SYN隊列滿了後，TCP會通過源地址端口、目標地址端口和時間戳打造出一個特別的Sequence Number發回去（又叫cookie），如果是攻擊者則不會有響應，如果是正常連接，則會把這個 SYN Cookie發回來，然後服務端可以通過cookie建連接（即使你不在SYN隊列中）。請注意，<strong>請先千萬別用tcp_syncookies來處理正常的大負載的連接的情況</strong>。 因為，synccookies是妥協版的TCP協議，並不嚴謹。對於正常的請求，你應該調整三個TCP參數可供你選擇，第一個 是：tcp_synack_retries 可以用它來減少重試次數；第二個是：tcp_max_syn_backlog，可以增大SYN連接數；第三個 是：tcp_abort_on_overflow 處理不過來乾脆就直接拒絕連接了。</li><li><strong>關於ISN的初始化</strong>。ISN是不能hard code的，不然會出問題的——比如：如果連接建好後始終用1來坐ISN，如果client發了30個segment過去，但是網絡斷了，於是 client重連，又用了1做ISN，但是之前連接的那些包到了，於是就被當成了新連接的包，此時，client的Sequence Number 可能是3，而Server端認為client端的這個號是30了。全亂了。RFC793中 說，ISN會和一個假的時鐘綁在一起，這個時鐘會在每4微秒對ISN做加一操作，直到超過2^32，又從0開始。這樣，一個ISN的週期大約是4.55個 小時。因為，我們假設我們的TCP Segment在網絡上的存活時間不會超過Maximum Segment Lifetime（縮寫為MSL），所以，只要MSL的值小於4.55小時，那麼，我們就不會重用到ISN。</li><li><strong>關於 MSL 和 TIME_WAIT</strong>。通過上面的ISN的描述，相信你也知道MSL是怎麼來的了。我們注意到，在TCP的狀態圖中，從TIME_WAIT狀態到CLOSED狀態，有一個超時設置，這個超時設置是 2*MSL（RFC793定 義了MSL為2分鐘，Linux設置成了30s）為什麼要這有TIME_WAIT？為什麼不直接給轉成CLOSED狀態呢？主要有兩個原 因：1）TIME_WAIT確保有足夠的時間讓對端收到了ACK，如果被動關閉的那方沒有收到Ack，就會觸發被動端重發Fin，一來一去正好2個 MSL，2）有足夠的時間讓這個連接不會跟後面的連接混在一起（你要知道，有些自做主張的路由器會緩存IP數據包，如果連接被重用了，那麼這些延遲收到的 包就有可能會跟新連接混在一起）。你可以看看這篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》</li><li><strong>關於TIME_WAIT數量太多</strong>。從上面的描述我們可以知道，TIME_WAIT是個很重要的狀態，但是如果在大併發的短鏈接下，TIME_WAIT 就會太多，這也會消耗很多系統資源。只要搜一下，你就會發現，十有八九的處理方式都是教你設置兩個參數，一個叫<strong>tcp_tw_reuse</strong>，另一個叫<strong>tcp_tw_recycle</strong>的參數，這兩個參數默認值都是被關閉的，後者recyle比前者resue更為激進，resue要溫柔一些。另外，如果使用tcp_tw_reuse，必需設置tcp_timestamps=1，否則無效。這裡，你一定要注意，<strong>打開這兩個參數會有比較大的坑——可能會讓TCP連接出一些詭異的問題</strong>（因為如上述一樣，如果不等待超時重用連接的話，新的連接可能會建不上。正如官方文檔上說的一樣“<strong>It should not be changed without advice/request of technical experts</strong>”）。</li><li><strong>關於tcp_tw_reuse</strong>。官方文檔上說tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保證協議的角度上的安全，但是你需要tcp_timestamps在兩邊都被打開（你可以讀一下tcp_twsk_unique的源碼 ）。我個人估計還是有一些場景會有問題。</li><li><strong>關於tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打開了話，會假設對端開啟了 tcp_timestamps，然後會去比較時間戳，如果時間戳變大了，就可以重用。但是，如果對端是一個NAT網絡的話（如：一個公司只用一個IP出公 網）或是對端的IP被另一臺重用了，這個事就複雜了。建鏈接的SYN可能就被直接丟掉了（你可能會看到connection time out的錯誤）（如果你想觀摩一下Linux的內核代碼，請參看源碼 tcp_timewait_state_process）。</li><li><strong>關於tcp_max_tw_buckets</strong>。這個是控制併發的TIME_WAIT的數量，默認值是180000，如果超限，那麼，系統會把多的給destory掉，然後在日誌裡打一個警告（如：time wait bucket table overflow），官網文檔說這個參數是用來對抗DDoS攻擊的。也說的默認值180000並不小。這個還是需要根據實際情況考慮。</li></ul><p><strong>Again，使用tcp_tw_reuse和tcp_tw_recycle來解決TIME_WAIT的問題是非常非常危險的，因為這兩個參數違反了TCP協議（RFC 1122）</strong></p><p>其實，TIME_WAIT表示的是你主動斷連接，所以，這就是所謂的“不作死不會死”。試想，如果讓對方斷連接，那麼這個破問題就是對方的了，呵呵。另外，如果你的服務器是於HTTP服務器，那麼設置一個HTTP的KeepAlive有多重要（瀏覽器會重用一個TCP連接來處理多個HTTP請求），然後讓客戶端去斷鏈接（你要小心，瀏覽器可能會非常貪婪，他們不到萬不得已不會主動斷連接）。</p><h1><strong>數據傳輸中的Sequence Number</strong></h1><p>下圖是我從Wireshark中截了個我在訪問coolshell.cn時的有數據傳輸的圖給你看一下，SeqNum是怎麼變的。（使用Wireshark菜單中的Statistics ->Flow Graph… ）</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2a9e61b68c1043d1af8fe67c160c959a></div><p>你可以看到，<strong>SeqNum的增加是和傳輸的字節數相關的</strong>。上圖中，三次握手後，來了兩個Len:1440的包，而第二個包的SeqNum就成了1441。然後第一個ACK回的是1441，表示第一個1440收到了。</p><p><strong>注意</strong>：如果你用Wireshark抓包程序看3次握手，你會發現SeqNum總是為0，不是這樣 的，Wireshark為了顯示更友好，使用了Relative SeqNum——相對序號，你只要在右鍵菜單中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p><h1><strong>TCP重傳機制</strong></h1><p>TCP要保證所有的數據包都可以到達，所以，必須要有重傳機制。</p><p>注意，接收端給發送端的Ack確認只會確認最後一個連續的包，比如，發送端發了1,2,3,4,5一共五份數據，接收端收到了1，2，於是回ack 3，然後收到了4（注意此時3沒收到），此時的TCP會怎麼辦？我們要知道，因為正如前面所說的，<strong>SeqNum和Ack是以字節數為單位，所以ack的時候，不能跳著確認，只能確認最大的連續收到的包</strong>，不然，發送端就以為之前的都收到了。</p><h1><strong>超時重傳機制</strong></h1><p>一種是不回ack，一直等待3，當發送方發現收不到3的ack超時後，會重傳3。一旦接收方收到3後，ack回傳4——意味著3和4都收到了。</p><p>但是，這種方式會有比較嚴重的問題，那就是因為要死等3，所以會導致4和5即便已經收到了，而發送方也完全不知道發生了什麼事，因為沒有收到Ack，所以，發送方可能會悲觀地認為也丟了，所以有可能也會導致4和5的重傳。</p><p>對此有兩種選擇：</p><ul><li>一種是僅重傳timeout的包。也就是第3份數據。</li><li>另一種是重傳timeout後所有的數據，也就是第3，4，5這三份數據。</li></ul><p>這兩種方式有好也有不好。第一種會節省帶寬，但是慢，第二種會快一點，但是會浪費帶寬，也可能會有無用功。但總體來說都不好。因為都在等timeout，timeout可能會很長（在下篇會說TCP是怎麼動態地計算出timeout的）</p><h1><strong>快速重傳機制</strong></h1><p>於是，TCP引入了一種叫<strong>Fast Retransmit</strong> 的算法，<strong>不以時間驅動，而以數據驅動重傳</strong>。也就是說，如果，包沒有連續到達，就ack最後那個可能被丟了的包，如果發送方連續收到3次相同的ack，就重傳。Fast Retransmit的好處是不用等timeout了再重傳。</p><p>比如：如果發送方發出了1，2，3，4，5份數據，第一份先到送了，於是就ack回2，結果2因為某些原因沒收到，3到達了，於是還是ack回2， 後面的4和5都到了，但是還是ack回2，因為2還是沒有收到，於是發送端收到了三個ack=2的確認，知道了2還沒有到，於是就馬上重轉2。然後，接收 端收到了2，此時因為3，4，5都收到了，於是ack回6。示意圖如下：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ad7be758a13040c0ad6edb1c6ff5454b></div><p>Fast Retransmit只解決了一個問題，就是timeout的問題，它依然面臨一個艱難的選擇，就是重裝之前的一個還是重裝所有的問題。 對於上面的示例來說，是重傳#2呢還是重傳#2，#3，#4，#5呢？因為發送端並不清楚這連續的3個ack(2)是誰傳回來的？也許發送端發了20份數 據，是#6，#10，#20傳來的呢。這樣，發送端很有可能要重傳從2到20的這堆數據（這就是某些TCP的實際的實現）。可見，這是一把雙刃劍。</p><h1><strong>SACK 方法</strong></h1><p>另外一種更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（參看RFC 2018），這種方式需要在TCP頭裡加一個SACK的東西，ACK還是Fast Retransmit的ACK，SACK則是彙報收到的數據碎版。參看下圖：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1b1bacd0ccf84765b8fa84d25a842cc8></div><p>這樣，在發送端就可以根據回傳的SACK來知道哪些數據到了，哪些沒有到。於是就優化了Fast Retransmit的算法。當然，這個協議需要兩邊都支持。在 Linux下，可以通過<strong>tcp_sack</strong>參數打開這個功能（Linux 2.4後默認打開）。</p><p>這裡還需要注意一個問題——<strong>接收方Reneging，所謂Reneging的意思就是接收方有權把已經報給發送端SACK裡的數據給丟了</strong>。這樣幹是不被鼓勵的，因為這個事會把問題複雜化了，但是，接收方這麼做可能會有些極端情況，比如要把內存給別的更重要的東西。<strong>所以，發送方也不能完全依賴SACK，還是要依賴ACK，並維護Time-Out，如果後續的ACK沒有增長，那麼還是要把SACK的東西重傳，另外，接收端這邊永遠不能把SACK的包標記為Ack。</strong></p><p>注意：SACK會消費發送方的資源，試想，如果一個攻擊者給數據發送方發一堆SACK的選項，這會導致發送方開始要重傳甚至遍歷已經發出的數據，這會消耗很多發送端的資源。詳細的東西請參看《TCP SACK的性能權衡》</p><h1><strong>Duplicate SACK – 重複收到數據的問題</strong></h1><p>Duplicate SACK又稱D-SACK，<strong>其主要使用了SACK來告訴發送方有哪些數據被重複接收了</strong>。RFC-2833 裡有詳細描述和示例。下面舉幾個例子（來源於RFC-2833）</p><p>D-SACK使用了SACK的第一個段來做標誌，</p><ul><li>如果SACK的第一個段的範圍被ACK所覆蓋，那麼就是D-SACK</li><li>如果SACK的第一個段的範圍被SACK的第二個段覆蓋，那麼就是D-SACK</li></ul><p><strong>示例一：ACK丟包</strong></p><p>下面的示例中，丟了兩個ACK，所以，發送端重傳了第一個數據包（3000-3499），於是接收端發現重複收到，於是回了一個 SACK=3000-3500，因為ACK都到了4000意味著收到了4000之前的所有數據，所以這個SACK就是D-SACK——旨在告訴發送端我收 到了重複的數據，而且我們的發送端還知道，數據包沒有丟，丟的是ACK包。</p><ol><li>TransmittedReceived ACK Sent</li><li>SegmentSegment(Including SACK Blocks)</li><li><br></li><li>3000-34993000-34993500(ACK dropped)</li><li>3500-39993500-39994000(ACK dropped)</li><li>3000-34993000-34994000, SACK=3000-3500</li><li>---------</li></ol><p><strong>示例二，網絡延誤</strong></p><p>下面的示例中，網絡包（1000-1499）被網絡給延誤了，導致發送方沒有收到ACK，而後面到達的三個包觸發了“Fast Retransmit算法”，所以重傳，但重傳時，被延誤的包又到了，所以，回了一個SACK=1000-1500，因為ACK已到了3000，所以，這 個SACK是D-SACK——標識收到了重複的包。</p><p>這個案例下，發送端知道之前因為“Fast Retransmit算法”觸發的重傳不是因為發出去的包丟了，也不是因為迴應的ACK包丟了，而是因為網絡延時了。</p><ol><li>TransmittedReceived ACK Sent</li><li>SegmentSegment(Including SACK Blocks)</li><li><br></li><li>500-999500-9991000</li><li>1000-1499(delayed)</li><li>1500-19991500-19991000, SACK=1500-2000</li><li>2000-24992000-24991000, SACK=1500-2500</li><li>2500-29992500-29991000, SACK=1500-3000</li><li>1000-14991000-14993000</li><li>1000-14993000, SACK=1000-1500</li><li>---------</li></ol><p>可見，引入了D-SACK，有這麼幾個好處：</p><p>1）可以讓發送方知道，是發出去的包丟了，還是回來的ACK包丟了。</p><p>2）是不是自己的timeout太小了，導致重傳。</p><p>3）網絡上出現了先發的包後到的情況（又稱reordering）</p><p>4）網絡上是不是把我的數據包給複製了。</p><p><strong>知道這些東西可以很好的幫助TCP瞭解網絡情況，從而可以更好的做網絡上的流控</strong>。</p><p>Linux下的tcp_dsack參數用於開啟這個功能（Linux 2.4後默認打開）。</p><h1><strong>TCP的RTT算法</strong></h1><p>從前面的TCP重傳機制我們知道Timeout的設置對於重傳非常重要。</p><ul><li>設長了，重發就慢，丟了老半天才重發，沒有效率，性能差；</li><li>設短了，會導致可能並沒有丟就重發。於是重發的就快，會增加網絡擁塞，導致更多的超時，更多的超時導致更多的重發。</li></ul><p>而且，這個超時時間在不同的網絡的情況下，根本沒有辦法設置一個死的值。只能動態地設置。 為了動態地設置，TCP引入了RTT——Round Trip Time，也就是一個數據包從發出去到回來的時間。這樣發送端就大約知道需要多少的時間，從而可以方便地設置Timeout—— RTO（Retransmission TimeOut），以讓我們的重傳機制更高效。 聽起來似乎很簡單，好像就是在發送端發包時記下t0，然後接收端再把這個ack回來時再記一個t1，於是RTT = t1 – t0。沒那麼簡單，這只是一個採樣，不能代表普遍情況。</p><h1><strong>經典算法</strong></h1><p>RFC793 中定義的經典算法是這樣的：</p><p>1）首先，先採樣RTT，記下最近好幾次的RTT值。</p><p>2）然後做平滑計算SRTT（ Smoothed RTT）。公式為：（其中的 α 取值在0.8 到 0.9之間，這個算法英文叫Exponential weighted moving average，中文叫：加權移動平均）</p><p><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p><p>3）開始計算RTO。公式如下：</p><p><strong>RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ]</strong></p><p>其中：</p><ul><li>UBOUND是最大的timeout時間，上限值</li><li>LBOUND是最小的timeout時間，下限值</li><li>β 值一般在1.3到2.0之間。</li></ul><h1><strong>Karn / Partridge 算法</strong></h1><p>但是上面的這個算法在重傳的時候會出有一個終極問題——你是用第一次發數據的時間和ack回來的時間做RTT樣本值，還是用重傳的時間和ACK回來的時間做RTT樣本值？</p><p>這個問題無論你選哪頭都是按下葫蘆起了瓢。 如下圖所示：</p><ul><li>情況（a）是ack沒回來，所以重傳。如果你計算第一次發送和ACK的時間，那麼，明顯算大了。</li><li>情況（b）是ack回來慢了，但是導致了重傳，但剛重傳不一會兒，之前ACK就回來了。如果你是算重傳的時間和ACK回來的時間的差，就會算短了。</li></ul><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4f74d9edf1ac4fb2a7647a30fa0422a5></div><p>所以1987年的時候，搞了一個叫Karn / Partridge Algorithm，這個算法的最大特點是——<strong>忽略重傳，不把重傳的RTT做採樣</strong>（你看，你不需要去解決不存在的問題）。</p><p>但是，這樣一來，又會引發一個大BUG——<strong>如果在某一時間，網絡閃動，突然變慢了，產生了比較大的延時，這個延時導致要重轉所有的包（因為之前的RTO很小），於是，因為重轉的不算，所以，RTO就不會被更新，這是一個災難</strong>。 於是Karn算法用了一個取巧的方式——只要一發生重傳，就對現有的RTO值翻倍（這就是所謂的 Exponential backoff），很明顯，這種死規矩對於一個需要估計比較準確的RTT也不靠譜。</p><h1><strong>Jacobson / Karels 算法</strong></h1><p>前面兩種算法用的都是“加權移動平均”，這種方法最大的毛病就是如果RTT有一個大的波動的話，很難被發現，因為被平滑掉了。所以，1988年，又有人推出來了一個新的算法，這個算法叫Jacobson / Karels Algorithm（參看RFC6289）。這個算法引入了最新的RTT的採樣和平滑過的SRTT的差距做因子來計算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p><p><strong>SRTT = SRTT + α (RTT – SRTT) </strong>—— 計算平滑RTT</p><p><strong>DevRTT = (1-β)*DevRTT + β*(|RTT-SRTT|) </strong>——計算平滑RTT和真實的差距（加權移動平均）</p><p><strong>RTO= µ * SRTT + ∂ *DevRTT </strong>—— 神一樣的公式</p><p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——這就是算法中的“調得一手好參數”，nobody knows why, it just works…） 最後的這個算法在被用在今天的TCP協議中（Linux的源代碼在：tcp_rtt_estimator）。</p><h1><strong>TCP滑動窗口</strong></h1><p>需要說明一下，如果你不瞭解TCP的滑動窗口這個事，你等於不瞭解TCP協議。我們都知道，<strong>TCP必需要解決的可靠傳輸以及包亂序（reordering）的問題</strong>，所以，TCP必需要知道網絡實際的數據處理帶寬或是數據處理速度，這樣才不會引起網絡擁塞，導致丟包。</p><p>所以，TCP引入了一些技術和設計來做網絡流控，Sliding Window是其中一個技術。 前面我們說過，<strong>TCP頭裡有一個字段叫Window，又叫Advertised-Window，這個字段是接收端告訴發送端自己還有多少緩衝區可以接收數據</strong>。<strong>於是發送端就可以根據這個接收端的處理能力來發送數據，而不會導致接收端處理不過來</strong>。 為了說明滑動窗口，我們需要先看一下TCP緩衝區的一些數據結構：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/83b64d8cd4b84d609a3af99f91e3903d></div><p>上圖中，我們可以看到：</p><ul><li>接收端LastByteRead指向了TCP緩衝區中讀到的位置，NextByteExpected指向的地方是收到的連續包的最後一個位置，LastByteRcved指向的是收到的包的最後一個位置，我們可以看到中間有些數據還沒有到達，所以有數據空白區。</li><li>發送端的LastByteAcked指向了被接收端Ack過的位置（表示成功發送確認），LastByteSent表示發出去了，但還沒有收到成功確認的Ack，LastByteWritten指向的是上層應用正在寫的地方。</li></ul><p>於是：</p><ul><li>接收端在給發送端回ACK中會彙報自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li><li>而發送方會根據這個窗口來控制發送數據的大小，以保證接收方可以處理。</li></ul><p>下面我們來看一下發送方的滑動窗口示意圖：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c467ac1c53ed4a9cadd59af3ea03068c></div><p>上圖中分成了四個部分，分別是：（其中那個黑模型就是滑動窗口）</p><ul><li>#1已收到ack確認的數據。</li><li>#2發還沒收到ack的。</li><li>#3在窗口中還沒有發出的（接收方還有空間）。</li><li>#4窗口以外的數據（接收方沒空間）</li></ul><p>下面是個滑動後的示意圖（收到36的ack，併發出了46-51的字節）：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b9c87859d664b28be1a7d1ac05cb0d2></div><p>下面我們來看一個接收端控制發送端的圖示：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e55ddce4e19143f7b5c7e7de8fb92cc4></div><h1><strong>Zero Window</strong></h1><p>上圖，我們可以看到一個處理緩慢的Server（接收端）是怎麼把Client（發送端）的 TCP Sliding Window給降成0的。此時，你一定會問，如果Window變成0了，TCP會怎麼樣？是不是發送端就不發數據了？是的，發送端就不發數據了，你可以想 像成“Window Closed”，那你一定還會問，如果發送端不發數據了，接收方一會兒Window size 可用了，怎麼通知發送端呢？</p><p>解決這個問題，TCP使用了Zero Window Probe技術，縮寫為ZWP，也就是說，發送端在窗口變成0後，會發ZWP的包給接收方，讓接收方來ack他的Window尺寸，一般這個值會設置成3 次，第次大約30-60秒（不同的實現可能會不一樣）。如果3次過後還是0的話，有的TCP實現就會發RST把鏈接斷了。</p><p><strong>注意</strong>：只要有等待的地方都可能出現DDoS攻 擊，Zero Window也不例外，一些攻擊者會在和HTTP建好鏈發完GET請求後，就把Window設置為0，然後服務端就只能等待進行ZWP，於是攻擊者會併發 大量的這樣的請求，把服務器端的資源耗盡。（關於這方面的攻擊，大家可以移步看一下Wikipedia的SockStress詞條）</p><p>另外，Wireshark中，你可以使用tcp.analysis.zero_window來過濾包，然後使用右鍵菜單裡的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p><h1><strong>Silly Window Syndrome</strong></h1><p>Silly Window Syndrome翻譯成中文就是“糊塗窗口綜合症”。正如你上面看到的一樣，如果我們的接收方太忙了，來不及取走Receive Windows裡的數據，那麼，就會導致發送方越來越小。到最後，如果接收方騰出幾個字節並告訴發送方現在有幾個字節的window，而我們的發送方會義 無反顧地發送這幾個字節。</p><p>要知道，我們的TCP+IP頭有40個字節，為了幾個字節，要達上這麼大的開銷，這太不經濟了。</p><p>另外，你需要知道網絡上有個MTU，對於以太網來說，MTU是1500字節，除去TCP+IP頭的40個字節，真正的數據傳輸可以有1460，這就是所謂的MSS（Max Segment Size）注意，TCP的RFC定義這個MSS的默認值是536，這是因為 RFC 791裡說了任何一個IP設備都得最少接收576尺寸的大小（實際上來說576是撥號的網絡的MTU，而576減去IP頭的20個字節就是536）。</p><p><strong>如果你的網絡包可以塞滿MTU，那麼你可以用滿整個帶寬，如果不能，那麼你就會浪費帶寬</strong>。（大於MTU的包有兩種結局，一種是直接被丟了，另一種是會被重新分塊打包發送） 你可以想像成一個MTU就相當於一個飛機的最多可以裝的人，如果這飛機裡滿載的話，帶寬最高，如果一個飛機只運一個人的話，無疑成本增加了，也而相當二。</p><p>所以，<strong>Silly Windows Syndrome這個現象就像是你本來可以坐200人的飛機裡只做了一兩個人</strong>。 要解決這個問題也不難，就是避免對小的window size做出響應，直到有足夠大的window size再響應，這個思路可以同時實現在sender和receiver兩端。</p><ul><li>如果這個問題是由Receiver端引起的，那麼就會使用 David D Clark’s 方案。在receiver端，如果收到的數據導致window size小於某個值，可以直接ack(0)回sender，這樣就把window給關閉了，也阻止了sender再發數據過來，等到receiver端處 理了一些數據後windows size 大於等於了MSS，或者，receiver buffer有一半為空，就可以把window打開讓send 發送數據過來。</li><li>如果這個問題是由Sender端引起的，那麼就會使用著名的 Nagle’s algorithm。這個算法的思路也是延時處理，他有兩個主要的條件（更多的條件可以看一下tcp_nagle_check函數）：1）要等到 Window Size>=MSS 或是 Data Size >=MSS，2）等待時間或是超時200ms，這兩個條件有一個滿足，他才會發數據，否則就是在攢數據。</li></ul><p>另外，Nagle算法默認是打開的，所以，對於一些需要小包場景的程序——<strong>比如像telnet或ssh這樣的交互性比較強的程序，你需要關閉這個算法</strong>。你可以在Socket設置TCP_NODELAY選項來關閉這個算法（關閉Nagle算法沒有全局參數，需要根據每個應用自己的特點來關閉）</p><p>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&value,sizeof(int));</p><p>另外，網上有些文章說TCP_CORK的socket option是也關閉Nagle算法，這個還不夠準確。<strong>TCP_CORK是禁止小包發送，而Nagle算法沒有禁止小包發送，只是禁止了大量的小包發送</strong>。最好不要兩個選項都設置。 <strong>老實說，我覺得Nagle算法其實只加了個延時，沒有別的什麼，我覺得最好還是把他關閉，然後由自己的應用層來控制數據，我個覺得不應該什麼事都去依賴內核算法</strong>。</p><h1><strong>TCP的擁塞處理 – Congestion Handling</strong></h1><p>上面我們知道了，TCP通過Sliding Window來做流控（Flow Control），但是TCP覺得這還不夠，因為Sliding Window需要依賴於連接的發送端和接收端，其並不知道網絡中間發生了什麼。TCP的設計者覺得，一個偉大而牛逼的協議僅僅做到流控並不夠，因為流控只 是網絡模型4層以上的事，TCP的還應該更聰明地知道整個網絡上的事。</p><p>具體一點，我們知道TCP通過一個timer採樣了RTT並計算RTO，但是，<strong>如果網絡上的延時突然增加，那麼，TCP對這個事做 出的應對只有重傳數據，但是，重傳會導致網絡的負擔更重，於是會導致更大的延遲以及更多的丟包，於是，這個情況就會進入惡性循環被不斷地放大。試想一下， 如果一個網絡內有成千上萬的TCP連接都這麼行事，那麼馬上就會形成“網絡風暴”，TCP這個協議就會拖垮整個網絡。</strong>這是一個災難。</p><p>所以，TCP不能忽略網絡上發生的事情，而無腦地一個勁地重發數據，對網絡造成更大的傷害。對此TCP的設計理念是：<strong>TCP不是一個自私的協議，當擁塞發生的時候，要做自我犧牲。就像交通阻塞一樣，每個車都應該把路讓出來，而不要再去搶路了。</strong></p><p>關於擁塞控制的論文請參看《Congestion Avoidance and Control》(PDF)</p><p>擁塞控制主要是四個算法：<strong>1）慢啟動</strong>，<strong>2）擁塞避免</strong>，<strong>3）擁塞發生</strong>，<strong>4）快速恢復</strong>。這四個算法不是一天都搞出來的，這個四算法的發展經歷了很多時間，到今天都還在優化中。 備註:</p><ul><li>1988年，TCP-Tahoe 提出了1）慢啟動，2）擁塞避免，3）擁塞發生時的快速重傳</li><li>1990年，TCP Reno 在Tahoe的基礎上增加了4）快速恢復</li></ul><h1><strong>慢熱啟動算法 – Slow Start</strong></h1><p>首先，我們來看一下TCP的慢熱啟動。慢啟動的意思是，剛剛加入網絡的連接，一點一點地提速，不要一上來就像那些特權車一樣霸道地把路佔滿。新同學上高速還是要慢一點，不要把已經在高速上的秩序給搞亂了。</p><p>慢啟動的算法如下(cwnd全稱Congestion Window)：</p><p>1）連接建好的開始先初始化cwnd = 1，表明可以傳一個MSS大小的數據。</p><p>2）每當收到一個ACK，cwnd++; 呈線性上升</p><p>3）每當過了一個RTT，cwnd = cwnd*2; 呈指數讓升</p><p>4）還有一個ssthresh（slow start threshold），是一個上限，當cwnd >= ssthresh時，就會進入“擁塞避免算法”（後面會說這個算法）</p><p>所以，我們可以看到，如果網速很快的話，ACK也會返回得快，RTT也會短，那麼，這個慢啟動就一點也不慢。下圖說明了這個過程。</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1280fc2fdb984807a81c444f04fb62f2></div><p>這裡，我需要提一下的是一篇Google的論文《An Argument for Increasing TCP’s Initial Congestion Window》Linux 3.0後採用了這篇論文的建議——把cwnd 初始化成了 10個MSS。 而Linux 3.0以前，比如2.6，Linux採用了RFC3390，cwnd是跟MSS的值來變的，如果MSS&lt; 1095，則cwnd = 4；如果MSS>2190，則cwnd=2；其它情況下，則是3。</p><h1><strong>擁塞避免算法 – Congestion Avoidance</strong></h1><p>前面說過，還有一個ssthresh（slow start threshold），是一個上限，當cwnd >= ssthresh時，就會進入“擁塞避免算法”。一般來說ssthresh的值是65535，單位是字節，當cwnd達到這個值時後，算法如下：</p><p>1）收到一個ACK時，cwnd = cwnd + 1/cwnd</p><p>2）當每過一個RTT時，cwnd = cwnd + 1</p><p>這樣就可以避免增長過快導致網絡擁塞，慢慢的增加調整到網絡的最佳值。很明顯，是一個線性上升的算法。</p><h1><strong>擁塞狀態時的算法</strong></h1><p>前面我們說過，當丟包的時候，會有兩種情況：</p><p>1）等到RTO超時，重傳數據包。TCP認為這種情況太糟糕，反應也很強烈。</p><ul><li>sshthresh = cwnd /2</li><li>cwnd 重置為 1</li><li>進入慢啟動過程</li></ul><p>2）Fast Retransmit算法，也就是在收到3個duplicate ACK時就開啟重傳，而不用等到RTO超時。</p><ul><li>TCP Tahoe的實現和RTO超時一樣。</li><li>TCP Reno的實現是：cwnd = cwnd /2sshthresh = cwnd進入快速恢復算法——Fast Recovery</li></ul><p>上面我們可以看到RTO超時後，sshthresh會變成cwnd的一半，這意味著，如果cwnd&lt;=sshthresh時出現的丟包，那麼 TCP的sshthresh就會減了一半，然後等cwnd又很快地以指數級增漲爬到這個地方時，就會成慢慢的線性增漲。我們可以看到，TCP是怎麼通過這 種強烈地震盪快速而小心得找到網站流量的平衡點的。</p><h1><strong>快速恢復算法 – Fast Recovery</strong></h1><p><strong>TCP Reno</strong></p><p>這個算法定義在RFC5681。快速重傳和快速恢復算法一般同時使用。快速恢復算法是認為，你還有3個Duplicated Acks說明網絡也不那麼糟糕，所以沒有必要像RTO超時那麼強烈。 注意，正如前面所說，進入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p><ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li></ul><p>然後，真正的Fast Recovery算法如下：</p><ul><li>cwnd = sshthresh + 3 * MSS （3的意思是確認有3個數據包被收到了）</li><li>重傳Duplicated ACKs指定的數據包</li><li>如果再收到 duplicated Acks，那麼cwnd = cwnd +1</li><li>如果收到了新的Ack，那麼，cwnd = sshthresh ，然後就進入了擁塞避免的算法了。</li></ul><p>如果你仔細思考一下上面的這個算法，你就會知道，<strong>上面這個算法也有問題，那就是——它依賴於3個重複的Acks</strong>。 注意，3個重複的Acks並不代表只丟了一個數據包，很有可能是丟了好多包。但這個算法只會重傳一個，而剩下的那些包只能等到RTO超時，於是，進入了惡 夢模式——超時一個窗口就減半一下，多個超時會超成TCP的傳輸速度呈級數下降，而且也不會觸發Fast Recovery算法了。</p><p>通常來說，正如我們前面所說的，SACK或D-SACK的方法可以讓Fast Recovery或Sender在做決定時更聰明一些，但是並不是所有的TCP的實現都支持SACK（SACK需要兩端都支持），所以，需要一個沒有 SACK的解決方案。而通過SACK進行擁塞控制的算法是FACK（後面會講）</p><p><strong>TCP New Reno</strong></p><p>於是，1995年，TCP New Reno（參見 RFC 6582 ）算法提出來，主要就是在沒有SACK的支持下改進Fast Recovery算法的——</p><ul><li>當sender這邊收到了3個Duplicated Acks，進入Fast Retransimit模式，開發重傳重複Acks指示的那個包。如果只有這一個包丟了，那麼，重傳這個包後回來的Ack會把整個已經被sender傳輸 出去的數據ack回來。如果沒有的話，說明有多個包丟了。我們叫這個ACK為Partial ACK。</li><li>一旦Sender這邊發現了Partial ACK出現，那麼，sender就可以推理出來有多個包被丟了，於是乎繼續重傳sliding window裡未被ack的第一個包。直到再也收不到了Partial Ack，才真正結束Fast Recovery這個過程</li></ul><p>我們可以看到，這個“Fast Recovery的變更”是一個非常激進的玩法，他同時延長了Fast Retransmit和Fast Recovery的過程。</p><h1><strong>算法示意圖</strong></h1><p>下面我們來看一個簡單的圖示以同時看一下上面的各種算法的樣子：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e0eb6f7d81af4bb18045dae2fe47af8c></div><h1><strong>FACK算法</strong></h1><p>FACK全稱Forward Acknowledgment 算法，論文地址在這裡（PDF）Forward Acknowledgement: Refining TCP Congestion Control 這個算法是其於SACK的，前面我們說過SACK是使用了TCP擴展字段Ack了有哪些數據收到，哪些數據沒有收到，他比Fast Retransmit的3 個duplicated acks好處在於，前者只知道有包丟了，不知道是一個還是多個，而SACK可以準確的知道有哪些包丟了。 所以，SACK可以讓發送端這邊在重傳過程中，把那些丟掉的包重傳，而不是一個一個的傳，但這樣的一來，如果重傳的包數據比較多的話，又會導致本來就很忙 的網絡就更忙了。所以，FACK用來做重傳過程中的擁塞流控。</p><ul><li>這個算法會把SACK中最大的Sequence Number 保存在<strong>snd.fack</strong>這個變量中，snd.fack的更新由ack帶來，如果網絡一切安好則和snd.una一樣（snd.una就是還沒有收到ack的地方，也就是前面sliding window裡的category #2的第一個地方）</li><li>然後定義一個<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt指向發送端sliding window中正在要被髮送的地方——前面sliding windows圖示的category#3第一個位置），這樣awnd的意思就是在網絡上的數據。（所謂awnd意為：actual quantity of data outstanding in the network）</li><li>如果需要重傳數據，那麼，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是說，awnd是傳出去的數據 + 重傳的數據。</li><li>然後觸發Fast Recovery 的條件是： (<strong> ( snd.fack – snd.una ) > (3*MSS) </strong>) || (dupacks == 3) ) 。這樣一來，就不需要等到3個duplicated acks才重傳，而是隻要sack中的最大的一個數據和ack的數據比較長了（3個MSS），那就觸發重傳。在整個重傳過程中cwnd不變。直到當第一次 丟包的snd.nxt&lt;=snd.una（也就是重傳的數據都被確認了），然後進來擁塞避免機制——cwnd線性上漲。</li></ul><p>我們可以看到如果沒有FACK在，那麼在丟包比較多的情況下，原來保守的算法會低估了需要使用的window的大小，而需要幾個RTT的時間才會完 成恢復，而FACK會比較激進地來幹這事。 但是，FACK如果在一個網絡包會被 reordering的網絡裡會有很大的問題。</p><h1><strong>其它擁塞控制算法簡介</strong></h1><h1><strong>TCP Vegas 擁塞控制算法</strong></h1><p>這個算法1994年被提出，它主要對TCP Reno 做了些修改。這個算法通過對RTT的非常重的監控來計算一個基準RTT。然後通過這個基準RTT來估計當前的網絡實際帶寬，如果實際帶寬比我們的期望的帶 寬要小或是要多的話，那麼就開始線性地減少或增加cwnd的大小。如果這個計算出來的RTT大於了Timeout後，那麼，不等ack超時就直接重傳。 （Vegas 的核心思想是用RTT的值來影響擁塞窗口，而不是通過丟包） 這個算法的論文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》這篇論文給了Vegas和 New Reno的對比：</p><div class=pgc-img><img alt=寫到頭條字數限制，你還沒搞明白TCP/IP協議嗎？你是不是飄了？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a850e1d891e947b8a7b365ff1caa1231></div><p>關於這個算法實現，你可以參看Linux源碼：/net/ipv4/tcp_vegas.h， /net/ipv4/tcp_vegas.c</p><h1><strong>HSTCP(High Speed TCP) 算法</strong></h1><p>這個算法來自RFC 3649（Wikipedia詞條）。其對最基礎的算法進行了更改，它使得Congestion Window漲得快，減得慢。其中：</p><ul><li>擁塞避免時的窗口增長方式： cwnd = cwnd + α(cwnd) / cwnd</li><li>丟包後窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li></ul><p>注：α(cwnd)和β(cwnd)都是函數，如果你要讓他們和標準的TCP一樣，那麼讓α(cwnd)=1，β(cwnd)=0.5就可以了。 對於α(cwnd)和β(cwnd)的值是個動態的變換的東西。 關於這個算法的實現，你可以參看Linux源碼：/net/ipv4/tcp_highspeed.c</p><h1><strong>TCP BIC 算法</strong></h1><p>2004年，產內出BIC算法。現在你還可以查得到相關的新聞《Google：美科學家研發BIC-TCP協議 速度是DSL六千倍》 BIC全稱Binary Increase Congestion control， 在Linux 2.6.8中是默認擁塞控制算法。BIC的發明者發這麼多的擁塞控制算法都在努力找一個合適的cwnd – Congestion Window，而且BIC-TCP的提出者們看穿了事情的本質，其實這就是一個搜索的過程，所以BIC這個算法主要用的是Binary Search——二分查找來幹這個事。 關於這個算法實現，你可以參看Linux源碼：/net/ipv4/tcp_bic.c</p><h1><strong>TCP WestWood算法</strong></h1><p>westwood採用和Reno相同的慢啟動算法、擁塞避免算法。westwood的主要改進方面：在發送端做帶寬估計，當探測到丟包時，根據帶寬值來設置擁塞窗口、慢啟動閾值。 那麼，這個算法是怎麼測量帶寬的？每個RTT時間，會測量一次帶寬，測量帶寬的公式很簡單，就是這段RTT內成功被ack了多少字節。因為，這個帶寬和用 RTT計算RTO一樣，也是需要從每個樣本來平滑到一個值的——也是用一個加權移平均的公式。 另外，我們知道，如果一個網絡的帶寬是每秒可以發送X個字節，而RTT是一個數據發出去後確認需要的時候，所以，X * RTT應該是我們緩衝區大小。所以，在這個算法中，ssthresh的值就是est_BD * min-RTT(最小的RTT值)，如果丟包是Duplicated ACKs引起的，那麼如果cwnd > ssthresh，則 cwin = ssthresh。如果是RTO引起的，cwnd = 1，進入慢啟動。 關於這個算法實現，你可以參看Linux源碼： /net/ipv4/tcp_westwood.c</p><h1><strong>其它</strong></h1><p>更多的算法，你可以從Wikipedia的 TCP Congestion Avoidance Algorithm 詞條中找到相關的線索</p><h1><strong>後記</strong></h1><p>好了，到這裡我想可以結束了，TCP發展到今天，裡面的東西可以寫上好幾本書。本文主要目的，還是把你帶入這些古典的基礎技術和知識中，希望本文能讓你瞭解TCP，更希望本文能讓你開始有學習這些基礎或底層知識的興趣和信心</p><p>當然，TCP東西太多了，不同的人可能有不同的理解，而且本文可能也會有一些荒謬之言甚至錯誤，還希望得到您的反饋和批評。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>寫到</a></li><li><a>頭條</a></li><li><a>字數</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3bdcde10.html alt=頭條百科：護欄打樁機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/09ad806f95f0466ebdfaef2e78d04df4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3bdcde10.html title=頭條百科：護欄打樁機>頭條百科：護欄打樁機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc79bddb.html alt=頭條文章--自定義方式構造Word表格中單元格區域求和子過程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/27f6f2ef47404eb48ed10e6ee379ade8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc79bddb.html title=頭條文章--自定義方式構造Word表格中單元格區域求和子過程>頭條文章--自定義方式構造Word表格中單元格區域求和子過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b76c68c3.html alt="潞安集團 新聞中心：今天的頭條介紹這個項目！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/869e48872dca4c2f9b7672d92d8d3498 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b76c68c3.html title="潞安集團 新聞中心：今天的頭條介紹這個項目！">潞安集團 新聞中心：今天的頭條介紹這個項目！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84848ca3.html alt=今日頭條，新款久保田自走式玉米聯合收穫機來了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c5e49072699b47a79da9cfcfa08f25ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84848ca3.html title=今日頭條，新款久保田自走式玉米聯合收穫機來了>今日頭條，新款久保田自走式玉米聯合收穫機來了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0464d952.html alt=邊氏頭條：最新全國邊氏宗親公務員彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2a1fe6be49c74e4a8c481d8f2cfdff86 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0464d952.html title=邊氏頭條：最新全國邊氏宗親公務員彙總>邊氏頭條：最新全國邊氏宗親公務員彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/706744e7.html alt=今日頭條推薦頁面上下滑動時卡頓，到底是誰的原因？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/706744e7.html title=今日頭條推薦頁面上下滑動時卡頓，到底是誰的原因？>今日頭條推薦頁面上下滑動時卡頓，到底是誰的原因？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fa5d77f2.html alt=頭條｜天爾儀器出新品啦！多參數水質綜合測定儀驚豔亮相 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cec21a826e3a4823bebf203cc8c0d980 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fa5d77f2.html title=頭條｜天爾儀器出新品啦！多參數水質綜合測定儀驚豔亮相>頭條｜天爾儀器出新品啦！多參數水質綜合測定儀驚豔亮相</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a103cfe0.html alt=「頭條」基氏流動度在配煤煉焦中的應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c5fff1cac86f439cbb2ac1d6f6e503a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a103cfe0.html title=「頭條」基氏流動度在配煤煉焦中的應用>「頭條」基氏流動度在配煤煉焦中的應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/31b6f1c0.html alt=EXCEL按照一列字數多少排序，思路是這樣的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/18e7c25959d042de9042647f9d7cc919 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/31b6f1c0.html title=EXCEL按照一列字數多少排序，思路是這樣的>EXCEL按照一列字數多少排序，思路是這樣的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c423b956.html alt="Word 字數統計的方法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2ac80960973f4b06ae8ebe40d3fccf45 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c423b956.html title="Word 字數統計的方法">Word 字數統計的方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/abb778e6.html alt=Word文檔如何快速查看字數？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a3f9c00623104fdda21152d44c98d6a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/abb778e6.html title=Word文檔如何快速查看字數？>Word文檔如何快速查看字數？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b6fc673.html alt=每天提升一點點：word的字數統計功能！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15234159788432afac54493 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b6fc673.html title=每天提升一點點：word的字數統計功能！>每天提升一點點：word的字數統計功能！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b4ee530.html alt=短信群發有字數限制嗎,是怎麼計算的? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b4ee530.html title=短信群發有字數限制嗎,是怎麼計算的?>短信群發有字數限制嗎,是怎麼計算的?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2dea4357.html alt=神啦！Word文檔字數統計全自動！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/111400011feccae4b305 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2dea4357.html title=神啦！Word文檔字數統計全自動！>神啦！Word文檔字數統計全自動！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35561364.html alt=論文查重系統的字數是怎樣計算的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/7560069a-cafc-4880-9689-28da99fdf700 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35561364.html title=論文查重系統的字數是怎樣計算的？>論文查重系統的字數是怎樣計算的？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>