<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>存儲類別，鏈接，內存管理 | 极客快訊</title><meta property="og:title" content="存儲類別，鏈接，內存管理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="存儲類別，鏈接，內存管理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ec8ea969.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>存儲類別，鏈接，內存管理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>c提供了多種模型，或者說存儲類別，在內存存儲數據</p><p>從硬件層面看，被存儲的每個值，都佔用一定的物理的內存，c語言成這個一塊內存稱為對象</p><p>對象可以存儲一個或者多個值，一個對象也可能並未存儲實際的值</p><p>從軟件層面看，程序需要一種方法訪問對象，可以通過聲明變量來完成</p><p>標識符可以用來指定，特定對象的內容</p><p>標識符即是軟件，指定硬件內存中對象的一種方式</p><p>變量名，不是指定對象的唯一方式</p><p>變量名不是指定對象的唯一方式</p><p>int * pt = &entity</p><p>int ranks[10]</p><p>該聲明，在內存上創建一個可以容納十個int元素的對象</p><p>pt 是一個標識符，指定一個內存上存儲地址的對象</p><p>表達式 *pt 不是標識符， 它指定了存儲地址的對象</p><p>*pt 不是一個標識符，因為他不是一個名稱，然而它確實指定了一個對象，它跟entity相同</p><p>那些指定對象的表達式，稱為左值</p><p>entity 即是標識符也是左值</p><p>*pt 即使表達式也是左值</p><p>所有這些事例中，如果可以通過左值，修改內存上對象的值，該值就稱為一個可以修改的左值（modifiable lvalue)</p><p>const char * pc = "Behond a string literal"</p><p>程序根據該聲明把字符串字面量，存儲在內存中，內含這些字符串的數組就是一個對象</p><p>由於數組中的每個字符都能被單獨訪問，所以每個字符也是一個對象</p><p>該聲明還創建了一個標識符為 pc的對象， 存儲著字符串的地址</p><p>由於可以設置pc 從新指向其他的字符，所以pc 是一個可以修改的左值</p><p>const 只能保證pc 指向的字符串不被修改</p><p>由於*pc 指定了存儲 'B'字符的數據對象</p><p>所以 *pc 是一個左值， 但是是一個不可以修改的左值</p><p>因為字符串字面量本身指定了存儲字符串的對象，所以它也是一個左值，但是一個不可以修改的左值</p><p>可以用存儲期（</p><p>storage</p><p>[ˈstɔːrɪdʒ]</p><p>duration</p><p>[djuˈreɪʃn]</p><p>)描述對象， 所謂存儲期就是對象在內存上保留了多長時間</p><p>標示符用於訪問對象</p><p>可以用作用域（scop)和鏈接（linkage</p><p>[ˈlɪŋkɪdʒ])描述標識符</p><p>標識符的 鏈接和作用域，表明了程序中那些地方可以使用它</p><p>不同存儲類別，具有不同的存儲期，作用域，鏈接</p><p>標識符，可以在源代碼多個文件中共享，可以用於特定代碼的特定函數，可僅限於函數使用，甚至函數中的某個部分</p><p>對象可以存在於程序的執行期，也可以僅存在於函數的執行期</p><p>對於併發編程 對象也可以存在特定線程的執行期間</p><p>可以通過函數調用，顯示的的分配釋放內存</p><p>作用域：</p><p>用來描述程序中標識符可以訪問的區域</p><p>一個C變量的作用域，可以分為塊作用域， 函數作用域， 函數原型， 文件作用域</p><p>本程序中使用的變量幾乎都具有塊作用域</p><p>block scope</p><p>塊： 一對花括號，括起來的代碼區域， 整個函數體是一個塊，函數中的任意複合句也是一個塊</p><p>定義在塊中變量具有塊級作用域</p><p>塊作用域變量的可見範圍，從定義處開始，到包含這塊定義末尾</p><p>雖然函數的， 形式參數， 在函數的左花括號之前，但它具有塊級，作用域，屬於函數體這個塊</p><p>聲明在內層塊中變量，期作用域僅限於該聲明所在的塊</p><p>for (int i = 0 ; i &lt; 10; i ++) {</p><p>}</p><p>上面for 循環中的變量i , 被視為for 循環的一部分， 它的作用域僅限於for 循環，一旦離開for 循環，將不能被訪問</p><p>為了適應新特性，c99 把塊的概念擴大到了，包括for循環，while 循環， do while 和if 語句的控制代碼， 即使這些代碼沒在花括號塊中， 也算塊的一部分。</p><p>函數作用域（function scope)</p><p>函數原型作用域（function prototype scope) 用於函數原型中的形參</p><p>int mighty(int mouse, double large)</p><p>函數原型作用域範圍， 從形參定義處，到原型聲明結束</p><p>編譯器在處理函數原型的形參時，只關心它的類型， 形參名，無關緊要</p><p>即使有形參名，也不必要與函數定義時候一樣</p><p>在變長數組中， 形參名才有用。</p><p>void use_a_VLA(int n, int m , ar[n][m])</p><p>方括號中，必須使用函數原型中聲明的名字</p><p>file scope</p><p>變量定義在函數外面，具有文件作用域</p><p>具有文件作用域的變量，從它的定義到文件末尾均可見</p><p>int units = 0;</p><p>void critic(void)</p><p>int main (void) {</p><p>}</p><p>void critic (void) {</p><p>}</p><p>這裡變量 untils 具有文件作用域 main critic 函數都可以使用它</p><p>（更準確的說 untils 具有外部鏈接文件作用域）由於這樣變量可以用多個函數，所以文件作用域變量也稱全局變量</p><p>翻譯單元文件：</p><p>你以為的多個文件在編譯器中可能以一個文件出現</p><p>通常在源代碼 .c 中，包含一個或者多個頭文件，頭文件一次包含其他的頭文件，所以會包含多個單獨的物理文件。</p><p>c預處理器 實際上是用包含了 頭文件的內容替換了#inclue 指令</p><p>所以編譯器源代碼文件和所有頭文件，都看成一個包含信息的單獨文件，這個文件被稱為翻譯單元</p><p>描述一個具有文件作用域的變量，實際上是整個翻譯單元</p><p>如果程序有多個源代碼文件組成，那麼該程序有多個翻譯單元組成</p><p>每個翻譯單元均對應一個源代碼文件和它的頭文件</p><p>鏈接：</p><p>c變量有三種鏈接屬性：無鏈接， 內部鏈接， 外部鏈接</p><p>無鏈接： 具有塊作用域 函數作用域 函數原型作用域變量 都是無鏈接變量，變量屬於他們塊 或者函數 私有</p><p>具有文件作用域的變量：</p><p>外部鏈接（外部鏈接變量，可以在多個文件程序使用）</p><p>內部鏈接（只能在一個翻譯單元使用）</p><p>c標準用 內部鏈接的文件作用域 （文件作用域）</p><p>描述僅限一個翻譯單元的作用域（即一個源代碼文件，和它所包含的頭文件）</p><p>外部鏈接的文件作用域 （全局作用域，程序作用域）</p><p>描述可以延伸到其他單元的作用域</p><p>如果知道文件作用域的變量，是內部鏈接或者是外部鏈接</p><p>可以查看外部定義中是否使用了存儲類別說明符 static</p><p>int giants = 5 // 文件作用域， 外部鏈接</p><p>static int doggers = 3 // 文件作用域，內部鏈接</p><p>存儲期</p><p>作用域和鏈接 描述了 標識符 可見性</p><p>存儲期 則是描述了通過標識符，訪問對象的生存期</p><p>c對象有四種存儲期</p><p>靜態存儲期</p><p>程序執行期間一致存在</p><p>文件作用域的變量具有靜態存儲期</p><p>關鍵字 static 表明了其鏈接屬性，而非存儲期</p><p>所以static 聲明的文件作用域變量具有內部鏈接屬性，但是無論是內部鏈接還是外部鏈接</p><p>所有文件作用域變量都具有靜態存儲器</p><p>線程存儲期</p><p>用於併發程序設計，程序執行可以分為多個線程</p><p>具有線程存儲期的對象，從被聲明到線程結束一直存在</p><p>以關鍵字 _Thread_local[θred] 聲明的一個對象時，每個線程都能獲得該變量的私有備份</p><p>自動存儲期</p><p>塊作用域的變量通常具有 自動存儲期， 當程序進入定義這些變量塊時，為這些變量分配 內存，當退出這些塊，釋放剛才分配內存</p><p>這種做法相當於把自動變量佔用的內存視為一個可以重複利用的工作區或暫存區</p><p>一個函數調用結束後，其變量佔用的內存可以存儲下一個函數的變量</p><p>塊作用域變量也可以擁有靜態存儲期，為了創建這樣的變量，要把變量聲明在塊中，且 加 上static 關鍵字</p><p>void more(int number) {</p><p>int index;</p><p>static int ct = 0;</p><p>}</p><p>這裡的變量 ct ，存儲在靜態內存中，它從程序被載入，到程序結束期間都存在，</p><p>它的作用域定義在more函數中，只有執行該函數時， 程序使用ct 訪問它所指定對象</p><p>c 使用作用域 鏈接和存儲期為變量定義了多種存儲方案</p><p>動態分配存儲期</p><p>存儲類別 存儲期 作用域 鏈接 聲明方式</p><p>自動 自動 塊 無 塊內</p><p>寄存器 自動 塊 無 塊內，使用關鍵字 register[ˈredʒɪstə(r)]</p><p>靜態外部鏈接 靜態 文件 外部 所有函數外</p><p>靜態內部鏈接 靜態 文件 內部 所有函數外，使用關鍵字 static</p><p>靜態無鏈接 靜態 塊 無 塊內， 使用關鍵字 static</p><p>自動變量</p><p>屬於自動存儲類別的變量，擁有自動存儲期，塊作用域 且無鏈接</p><p>為了強調不把變量改為別的存儲類別 ，可以顯試的使用關鍵字 auto</p><p>auto int plox</p><p>關鍵字 auto 是存儲類別說明符</p><p>//塊作用域無鏈接，只有在變量所定義的塊中能夠通過變量名訪問變量</p><p>// 參數用於傳遞變量的值，或者變量的地址，給另外一個函數，這是間接的方法</p><p>// 另一個函數可以使用同名的變量，但是該變量是存儲不同內存位置上的另外變量</p><p>// 變量具有自動存儲期，意味進入該變量所在塊，該變量被創建，程序退出該變量所在塊，</p><p>//原來變量所佔得到空間可做他用</p><p>int loop(int n)</p><p>{</p><p>int m;</p><p>scanf("%d", &m);</p><p>{</p><p>int i;</p><p>for ( i = m; i &lt; n ; i++) {</p><p>puts(" i is local to sub-block\n")</p><p>}</p><p>}</p><p></p><p>return m</p><p></p><p>}</p><p>循環體是整個循環塊的子塊</p><p>if 語句是一個塊，與其關聯的子語句是if塊的子塊</p><p>自動變量不會初始化</p><p>寄存器變量</p><p>變量通常存儲在內存中， 如果幸運的話，寄存器變量存儲在cpu的寄存器中</p><p>塊作用域的靜態變量</p><p>靜態變量 意思是該變量在內存中，原地不動</p><p>具有文件作用域的變量，必須具有靜態存儲期</p><p>可以創建靜態存儲期，塊作用域的局部變量</p><p>這些變量 和自動變量一樣， 具有相同的作用域，但是程序離開離開他們的函數後不會消失</p><p>也就是說變量具有塊作用域，無鏈接，但是具有靜態存儲期</p><p>計算機在多次函數調用期間會記錄他們的值 在塊中用存儲類別說明符， static 聲明這種變量</p><p>外部鏈接的靜態變量</p><p>具有文件作用域</p><p>外部鏈接</p><p>靜態存儲期</p><p></p><p>該類別有時也稱為靜態存儲類別</p><p>屬於該類別的變量有時也稱為外部變量</p><p>把變量聲明放在所有函數外面創建了外部變量</p><p>為了在函數中指出使用了外部變量</p><p>可以使用extern[ˈekstɜːn]</p><p>再次聲明</p><p>如果一個源文件，使用外部變量，定義中另外的文件中，必須使用extern 再次聲明</p><p>int Errup</p><p>double Up[100]</p><p>extern char Coal //如果 Coal 被定義在另一個文件中， 必須這樣聲明</p><p>void next(void);</p><p></p><p>int mian() {</p><p>extern int Eurrp;//可選聲明</p><p></p><p>extern double Up[];//可選聲明</p><p><br></p><p>}</p><p>初始化外部變量</p><p>如果未初始化外部變量 ，他們會自動初始化位 0</p><p>只能使用常量表達式初始化 文件作用域變量</p><p>int x = 10;</p><p>int y = 3 + 20;</p><p>size_t z = sizeof(int)</p><p>int x2 = 2 * x // 不行 x是變量</p><p>定義和聲明區別</p><p>int tern = 1 //定義變量</p><p>main()</p><p>{</p><p>extern int tern //</p><p>}</p><p>tern 被聲明瞭兩次 ， 第一次位變量預留了存儲空間，該聲明構成了變量的定義</p><p>第二次聲明告訴編譯器使用之前創建的變量 tern</p><p>1.定義式的聲明</p><p>2.引用式的聲明</p><p>外部變量只能初始化一次，且必須在該變量定義的時候</p><p>內部鏈接的靜態變量</p><p>該存儲類別的變量， 具有靜態存儲期， 文件作用域 內部鏈接</p><p>int traveler = 1;//外部鏈接</p><p>static int stayhome = 1; // 內部鏈接</p><p>複雜的C程序， 通常有多個單獨的源文件組成，有時候zhe這些文件要共享一個外部變量</p><p>c 通過在一個文件中定義聲明，在其它文件中，引用聲明，來實現引用共享</p><p>除了一個定義聲明外，其它通過 extern 只有定義聲明時，才可以初始化</p><p>如果將變量定義在外部文中，其它文件在使用變量之前，必須先聲明</p><p>在某文件中對外部變量進行定義聲明，只是但方面允許其它文件使用該變量</p><p>其它文件在用extern 聲明前不能使用</p><p>存儲類別說明符</p><p>static extern 含義取決於上下文</p><p>c 語言6個關鍵字，存儲類別說明符</p><p>auto</p><p>register</p><p>static</p><p>extern</p><p>_Thread_local</p><p>在絕大數的情況下，不能使用多個存儲類別說明符，</p><p>auto 說明符，表示變量是自動存儲期，只能用塊作用域的變量聲明</p><p>由於在塊中聲明的變量本身就是自動存儲期 ，所以在塊中使用auto,</p><p>主要是為了明確的表示使用了與外部同名的變量</p><p>register 也只能用於塊作用域，它把變量歸寄存器存儲類別，請求最快速度訪問變量，同時該保護了該變量</p><p>內存地址不被獲取</p><p>static 說明符 創建的對象具有靜態存儲期，載入程序時候創建對象</p><p>當程序結束時候對象消失</p><p>如static 用於文件作用域的聲明，作用域受限於該文件</p><p>如果static 用於塊作用域聲明，作用域受限於該塊</p><p>只要程序運行對象就存在並保留其值，但只有執行塊內代碼時候，才能通過標識符訪問，</p><p>塊作用域的變量，無鏈接</p><p>extern 說明符 表明聲明的變量在別處</p><p>如果包含extern 聲明，具有文件作用域，則引用的變量，必須具有外部鏈接</p><p>如果包含extern 聲明具有塊作用域，則引用的變量可能具有外部鏈接</p><p>存儲類別小結：</p><p>自動變量：</p><p>具有塊作用域，自動存儲期</p><p>他們是局部變量，屬於其所定義的塊私有</p><p><br></p><p>寄存器變量：</p><p>和自動變量相同，但是編譯器會用更快內存或者寄存器存儲他們</p><p>不能獲得寄存器的地址</p><p><br></p><p>具有靜態存儲期的變量</p><p>可以有外部鏈接</p><p>可以有內部鏈接</p><p>無鏈接</p><p></p><p>在同一個文件所有函數之外聲明的變量是外部變量</p><p>具有文件作用域</p><p>外部鏈接</p><p>靜態存期</p><p><br></p><p>如果在函數中使用static 聲明一個變量</p><p>則該變量</p><p>具有塊作用域</p><p>靜態存儲器</p><p>無鏈接</p><p><br></p><p>具有自動存儲期的變量</p><p>程序進入該變量所在的塊，才為其分配內存</p><p>在退出該塊時候時候，釋放之前分配的內存</p><p>如果未初始化，自動變量中是垃圾值</p><p><br></p><p>程序在編譯的時候，為具有靜態存儲期的變量分配內存，並在程序運行過程中，一直保留這塊內存</p><p>如果未初始化，這塊變量會被設置未0</p><p><br></p><p>具有塊作用域變量是局部的，屬於該塊私有</p><p><br></p><p>具有文件作用域變量，位於其聲明後的所有函數可見</p><p><br></p><p>具有外部鏈接的文件作用域變量，可以用於該程序的其它，編譯單元</p><p></p><p>具有內部鏈接的文件作用變量， 只能用於其聲明所在的文件</p><p><br></p><p>存儲類別和函數</p><p></p><p>函數也有存儲類別：</p><p>可以外部函數</p><p>可以被其它文件的函數訪問</p><p>靜態函數</p><p>只能用於定義的文件</p><p>內聯函數</p><p><br></p><p>dobule grama(double) //該函數默認為外部函數</p><p>static double beta(int , int)</p><p>extern double delta(double, int)</p><p>其它文件中函數可以調用 grama delta 不能調用 beta</p><p></p><p>應為static 存儲類別說明符，創建的函數屬於特定模塊私有，</p><p>這樣避免了名稱衝突問題，由於beta 受限於它所在的文件</p><p>所以其它文件可以使用與其同名的函數</p><p><br></p><p>用extern 聲明定義在其它文件中的函數</p><p>這樣做是為了聲明當前使用的函數定義在外部</p><p></p><p>除非使用static 關鍵字，否則函數默認聲明為extern</p><p><br></p><p>存儲類別的選擇</p><p>對於使用那種存儲類別，答案是自動存儲類別</p><p></p><p>默認的存儲類別就是自動存儲類別</p><p><br></p><p>為何不把所有變量都設置為外部變量，這樣就不必要使用參數，或者指針</p><p></p><p>在函數間傳遞信息了，</p><p><br></p><p>然而這背後隱藏著一個陷進，A函數可能違揹你意圖修改B函數使用的變量</p><p><br></p><p>多年來無數程序員經驗表明，隨意使用外部存儲類別的變量導致的後果遠遠超過它帶來的便利</p><p><br></p><p>唯一例外的是const 數據， 因為它在初始化後，就不會被修改</p><p></p><p>const int DAYS = 7;</p><p></p><p>const char * MSGS [3] = {"yes", "no", "maybe"}</p><p>保護性程序設計的法則是， 按需知道 儘量在函數內部解決函數任務</p><p>只共享那些需要共享的變量</p><p>除了自動存儲類別外，其它存儲類別也很有用， 在使用某個類別前要考慮一下，是否有必要</p><p>分配內存malloc free</p><p>我們前面選的存儲類別有一個共通之處，</p><p>在確定了存儲類別後，</p><p>根據已經制定好的內存管理規則</p><p>將自動選擇其存儲期和作用域</p><p>還有更靈活的地選擇</p><p>用函數庫管理和分配內存</p><p>所有程序都需要預留足夠的內存來存儲程序需要的數據，</p><p>這些內存有些是自動分配</p><p>float x;</p><p>char place[] = "Dance Oxen Creek"</p><p>為一個float 類型的值，和一個字符串預留足夠的空間</p><p>或者可以顯式指定分配一定數量的內存</p><p>int plates[100]</p><p>該聲明預留100個內存位置，每個位置都用來存int型， 聲明還為內存提供一個標識符</p><p>因此可以用 x place 識別數據</p><p>靜態數據在程序載入內存時候分配</p><p>動態數據在程序執行時分配</p><p>並在程序離開塊的時候銷燬</p><p>malloc 會找到合適空閒內存塊，這樣的內存是匿名的</p><p>malloc 分配的內存不會為其賦名</p><p>它返回動態分配內存塊的，首地址</p><p>可以把該定製賦給一個指針，同過該指針訪問這塊內存</p><p>指向void的指針，該類型相當於一個通用類型</p><p>malloc可以用於返回指向數據的指針，指向結構的指針</p><p>所以該函數的返回值通常會被轉換為匹配的類型</p><p>把指向void 類型的指針，賦給任意類型的指針，完全不用考慮類型匹配的問題</p><p>堅持類型轉換，提高代碼可讀性</p><p>malloc 分配內存失敗返回空指針</p><p>動態分配的存儲期，從調用調用malloc開始 直到free() 釋放為止</p><p>設想malloc 和free 管理著一個內存池，每次調用malloc 的時候，分配內存</p><p>給程序使用，free的時候釋放內存給池子</p><p>這樣便可以重複使用內存</p><p>不能用free() 釋放其它方式分配的內存</p><p>malloc free 原型都在 stdlib.h 頭文件中</p><p>如果內存失敗可以調用 exit() 結束程序</p><p>EXIT_FAILURE的值也被定義在stlib.h</p><p>標準提供了兩個值，保證所有系統正常工作</p><p>EXIT_SUCESS 表示普通程序結束</p><p>EXIT_FAILURE 表示程序異常終止</p><p>使用動態數組給程序帶來了更多靈活性，</p><p>靜態內存的數量在編譯的時候固定的，程序運行期間也不會改變</p><p>自動變量使用的內存，在程序執行期間自動增減或減少</p><p>但是動態分配的內存數量只會增減，除非用free進行釋放</p><p>存儲類別和動態內存的分配</p><p>程序把它可用的內存分為三個部分</p><p>1.一部分供具有外部鏈接，內部鏈接和無鏈接的靜態變量</p><p></p><p>2. 一部分供自動變量</p><p></p><p>3. 一部分供動態內存分配</p><p><br></p><p>靜態存儲類別所使用內存數量在編譯的時候確定</p><p>只要程序還在運行，就可以訪問存在該部分的數據</p><p>該類型的變量在程序執行時候被創建，在程序結束的時候被銷燬</p><p>自動存儲類別的變量，在程序進入變量定義所在的塊時候創建，在程序離開的時候銷燬</p><p>隨著程序調用函數和函數結束自動變量所使用的內存數量相應增加或者減少</p><p>這部分內存通常作為棧來處理， 這意味著新創建的變量按順序加入內存，然後按相反的方式銷燬</p><p>動態分配的內存在調用malloc 或相關函數的時候存在，在調用free後釋放</p><p>這部分內存有程序員管理</p><p>而不是一套規則</p><p>所以內存塊可以在一個函數中創建，在另外一個函數中銷燬</p><p>正是因為這樣，這部分內存用於動態內存分配的時候會支離破碎</p><p>也就是說未使用的內存塊，分散在已使用的內存塊之間</p><p>另外使用動態內存，通常比使用棧內存慢</p><p>總而言之，程序把靜態對象 自動對象 動態分配的對象存儲在不同區域</p><p>如上所示 靜態數據（包括字符串字面量）佔用一個區域</p><p>自動數據佔用一個區域</p><p>動態分配的數據佔用第三個區域（通常被稱為內存堆，或自由內存）</p><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>存儲類</a></li><li><a>鏈接</a></li><li><a>內存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/046f2351.html alt=C語言：存儲類、鏈接、內存管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/23f828b250b24cd0b8d7955ca1a7a754 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/046f2351.html title=C語言：存儲類、鏈接、內存管理>C語言：存儲類、鏈接、內存管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18681b55.html alt=PHP鏈接數據庫操作教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3b10e2d3b35043f8ae9cb1823878b66a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18681b55.html title=PHP鏈接數據庫操作教程>PHP鏈接數據庫操作教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html alt=內存屏障詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html title=內存屏障詳解>內存屏障詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html alt=C語言學習篇(3)-----內存編址和對齊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e039d89a145f4e258f5f6eb28d04809b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html title=C語言學習篇(3)-----內存編址和對齊>C語言學習篇(3)-----內存編址和對齊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html alt=內存按字節編址例題解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/87f6444a27d34916b6e72824f6e98572 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html title=內存按字節編址例題解析>內存按字節編址例題解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html alt="【歷史】內存的故事 (紀念DRAM量產50年)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RQUkuARBMJpAR2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html title="【歷史】內存的故事 (紀念DRAM量產50年)">【歷史】內存的故事 (紀念DRAM量產50年)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html alt=滲透測試——內存攻擊原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ae687b82fd824bafafb7c6792c260a98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html title=滲透測試——內存攻擊原理>滲透測試——內存攻擊原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84f64628.html alt=給PDF批量添加文本鏈接 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b2563acb0efb4e7394cabb8fb4a7461b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84f64628.html title=給PDF批量添加文本鏈接>給PDF批量添加文本鏈接</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html alt=內存容量如何計算，瞭解一些基礎知識，你就懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d9065c724be64660aee58a3257a23534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html title=內存容量如何計算，瞭解一些基礎知識，你就懂了！>內存容量如何計算，瞭解一些基礎知識，你就懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8820f792.html alt=內存降價了買多大容量夠用？超過這個數就浪費了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/951afe40804044ea85eb17c552656667 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8820f792.html title=內存降價了買多大容量夠用？超過這個數就浪費了>內存降價了買多大容量夠用？超過這個數就浪費了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d35198c.html alt=手機內存多少夠用64還是128？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/71eced4d7a2e4954ab09c431e7907bbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d35198c.html title=手機內存多少夠用64還是128？>手機內存多少夠用64還是128？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e839484.html alt=奇怪的知識增加了！電腦內存容量真的是越大越好嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a457a965c6064a45a93d273286d37f57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e839484.html title=奇怪的知識增加了！電腦內存容量真的是越大越好嗎？>奇怪的知識增加了！電腦內存容量真的是越大越好嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ce20ef2.html alt=計算機中，內存容量越大越有利於系統的運行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1027a7b9f31f4c8f8b0d0c46e51afdb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ce20ef2.html title=計算機中，內存容量越大越有利於系統的運行>計算機中，內存容量越大越有利於系統的運行</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>