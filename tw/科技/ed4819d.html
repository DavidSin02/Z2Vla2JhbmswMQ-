<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SpringMVC:接收到請求後的調用細節，你是否清楚？ | 极客快訊</title><meta property="og:title" content="SpringMVC:接收到請求後的調用細節，你是否清楚？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3c62f7f39c8a499fb3e7e322ceb2aa76"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed4819d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed4819d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ed4819d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed4819d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed4819d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ed4819d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ed4819d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed4819d.html><meta property="article:published_time" content="2020-10-29T21:04:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:55+08:00"><meta name=Keywords content><meta name=description content="SpringMVC:接收到請求後的調用細節，你是否清楚？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ed4819d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SpringMVC:接收到請求後的調用細節，你是否清楚？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>分享自己在Java方面的所思所想，希望你看完之後能有更多更深入的瞭解</p><p><strong>本人微信公眾號（jwfy的學習分享），歡迎關注～</strong></p></blockquote><p>接收到一個新的請求之後，spring就會去根據請求的URL信息選擇具體的代碼塊去執行操作，如圖就是接收到一個新的請求調用圖，從Tomcat開始直到把請求分發到spring中，最後到了doDispatch方法。</p><div class=pgc-img><img alt=SpringMVC:接收到請求後的調用細節，你是否清楚？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3c62f7f39c8a499fb3e7e322ceb2aa76><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>本篇學習筆記主要就是講一個新的請求被分發到spring中spring如何處理，至於如何掃描包中的controller，得到URL配置信息可以看 <a class=pgc-link data-content=mp href="https://www.toutiao.com/i6723360987501560323/?group_id=6723360987501560323" target=_blank>你是否清楚Spring MVC中的URL映射管理器的工作原理</a> ,而本篇主要介紹了</p><ul><li>獲取執行鏈</li><li>404頁面設置</li><li>獲取適配器</li><li>LastModified</li><li>內容方法調用（invoke）</li><li>視圖渲染</li></ul><p>讓我們更加清楚的知道spring中一般的方法是如何確定調用的具體方法的，適配不同的模板引擎，達到渲染的地步，再者有時候又是API一般只需要返回json結構的數據，其背後的原理是如何實現的，以及我們在使用過程中如何避免出現的各種問題。</p><h1><strong>doDispatch 方法</strong></h1><pre>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; // 初始化設置模板為null Exception dispatchException = null; // 初始化異常為null try { processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // 文件上傳的相關設置和操作 mappedHandler = getHandler(processedRequest); // 根據request獲取對應的請求執行鏈 if (mappedHandler == null || mappedHandler.getHandler() == null) { // 如果沒有對應的handler對於，則應該是定義為404，通過noHandlerFound確認 noHandlerFound(processedRequest, response); return; } // 通過handler獲得合適的handler適配器 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); String method = request.getMethod(); boolean isGet = "GET".equals(method); if (isGet || "HEAD".equals(method)) { // 是get方法或者head方法 long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); // 如果handler 是LastModified類，則獲取其lastModified值，否則返回-1 // lastModify 是spring添加了緩存機制，當重複請求同樣的內容，返回403，而不會返回真正的內容，具體可看下面的LastModified機制這一小節 if (logger.isDebugEnabled()) { logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified); } if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) { return; } } // 前置的handler預處理，就是獲取執行鏈的攔截器，對請求進行攔截處理 if (!mappedHandler.applyPreHandle(processedRequest, response)) { // 如果攔截器攔截成功，返回false，直接結束了 // 當然在這其中攔截器肯定需要特定返回自身的內容到response中，便於展示在頁面上 // 不過從頁面角度出發並沒有非常實質性的攔截器處理，這點存疑？ return; } // 真正的調用各自的執行方法，返回ModelAndView後續在invoke這一小節細說 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } applyDefaultViewName(processedRequest, mv); // 如果mv沒有包含有效的視圖，則從dispatch的viewNameTranslator屬性上獲取對應的默認視圖 mappedHandler.applyPostHandle(processedRequest, response, mv); // 攔截器的後置處理 } catch (Exception ex) { dispatchException = ex; } catch (Throwable err) { dispatchException = new NestedServletException("Handler dispatch failed", err); }  // 到這裡了可能存在異常，類似的500請求處理就是在這裡完成操作的 // 同時包含了數據回填到response中的操作 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); } catch (Exception ex) { triggerAfterCompletion(processedRequest, response, mappedHandler, ex); } catch (Throwable err) { triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", err)); } finally { if (asyncManager.isConcurrentHandlingStarted()) { // Instead of postHandle and afterCompletion if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else { // Clean up any resources used by a multipart request. if (multipartRequestParsed) { cleanupMultipart(processedRequest); } } }}</pre><p><strong>獲取執行鏈</strong></p><p><strong>AbstractHandlerMapping 類</strong></p><pre>protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { for (HandlerMapping hm : this.handlerMappings) { // 這個handlerMappings就是在掃描URL得到的URL容器信息 HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) { return handler; } } return null;}</pre><p>如圖所示就是</p><div class=pgc-img><img alt=SpringMVC:接收到請求後的調用細節，你是否清楚？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/227844fc7e344bf0ab6575bb1619e2c2><p class=pgc-img-caption></p></div><h1><strong>getHandler 方法</strong></h1><p><strong>AbstractHandlerMapping 類</strong></p><pre>public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { Object handler = getHandlerInternal(request); // 調用子類實現的具體方法，獲得執行鏈對象 if (handler == null) { handler = getDefaultHandler(); } if (handler == null) { // 到這裡意味著真的找不到可用的執行鏈對象 return null; }  if (handler instanceof String) { String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); } HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); // 重新生成一個執行鏈對象，可能會和handler是同一個對象  if (CorsUtils.isCorsRequest(request)) { // 查看request頭部信息是否包含了Origin信息，如果有則判斷成功 // cors跨域設置 CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request); // 獲取全局的跨域配置 CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig); // 結合當前handler和全局配置組合成一個新的跨域配置 executionChain = getCorsHandlerExecutionChain(request, executionChain, config); // 重新生成可用的執行鏈對象 } return executionChain;}</pre><p><strong>AbstractUrlHandlerMapping類</strong></p><pre>protected Object getHandlerInternal(HttpServletRequest request) throws Exception { String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); // 從request中獲取到URL信息 Object handler = lookupHandler(lookupPath, request); // 得到執行鏈路的對象，一般為HandlerExecutionChain if (handler == null) { // 如果沒有找到，則匹配一些特殊的請求，儘可能的匹配清楚 Object rawHandler = null; if ("/".equals(lookupPath)) { // 根路徑的handler rawHandler = getRootHandler(); } if (rawHandler == null) { // 默認路徑的handler rawHandler = getDefaultHandler(); } if (rawHandler != null) { // 根路徑或者默認路徑中的一個不為null if (rawHandler instanceof String) { String handlerName = (String) rawHandler; rawHandler = getApplicationContext().getBean(handlerName); } validateHandler(rawHandler, request); handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null); // 同樣的套路得到新的執行鏈路對象信息 } } if (handler != null &amp;&amp; logger.isDebugEnabled()) { logger.debug("Mapping [" + lookupPath + "] to " + handler); // 打個日誌，表示匹配到了相關的bean信息 } else if (handler == null &amp;&amp; logger.isTraceEnabled()) { logger.trace("No handler mapping found for [" + lookupPath + "]"); } return handler;}protected Object lookupHandler(String urlPath, HttpServletRequest request) throws Exception { // 從hanlerMap中獲取該URL對應的controller Object handler = this.handlerMap.get(urlPath); if (handler != null) { //  if (handler instanceof String) { String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); } validateHandler(handler, request); return buildPathExposingHandler(handler, urlPath, urlPath, null); } // 沒有完全匹配，採取模糊匹配，正則還是？ // 題外話，python的tornado和Django都是採用的正則匹配的 List&lt;String&gt; matchingPatterns = new ArrayList&lt;String&gt;(); for (String registeredPattern : this.handlerMap.keySet()) { if (getPathMatcher().match(registeredPattern, urlPath)) { // getPathMatcher() 返回的就是AntPathMatcher對象 // 同樣也是按照getPathMatcher的匹配規則去匹配的 matchingPatterns.add(registeredPattern); } else if (useTrailingSlashMatch()) { if (!registeredPattern.endsWith("/") &amp;&amp; getPathMatcher().match(registeredPattern + "/", urlPath)) { matchingPatterns.add(registeredPattern +"/"); } } } // 總之最後會得到一個list，包含了匹配中的URL信息 String bestMatch = null; Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath); if (!matchingPatterns.isEmpty()) { Collections.sort(matchingPatterns, patternComparator); // 模糊匹配的集合不為空,則按照urlPath定義的排序規則去重排序 if (logger.isDebugEnabled()) { logger.debug("Matching patterns for request [" + urlPath + "] are " + matchingPatterns); } bestMatch = matchingPatterns.get(0); // 第一個是最佳的匹配路徑 } if (bestMatch != null) { // 接下來的一切都是依照這個bestMatch不為null，否則就直接返回null，表示沒有合適的匹配handler handler = this.handlerMap.get(bestMatch); if (handler == null) { // 如果容器中不存在該handler if (bestMatch.endsWith("/")) { handler = this.handlerMap.get(bestMatch.substring(0, bestMatch.length() - 1)); } // 對最佳的URL路徑處理之後，還是不在對應的handler，則提示沒有具體的handler信息 if (handler == null) { throw new IllegalStateException( "Could not find handler for best pattern match [" + bestMatch + "]"); } } // 包含了對應的handler信息了 if (handler instanceof String) { String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); // 如果是string，則通過spring的容器獲取對應的bean（一般是controller） } validateHandler(handler, request); String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, urlPath); //  Map&lt;String, String&gt; uriTemplateVariables = new LinkedHashMap&lt;String, String&gt;(); for (String matchingPattern : matchingPatterns) { if (patternComparator.compare(bestMatch, matchingPattern) == 0) { Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath); Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars); uriTemplateVariables.putAll(decodedVars); } } if (logger.isDebugEnabled()) { logger.debug("URI Template variables for request [" + urlPath + "] are " + uriTemplateVariables); }  // 生成執行鏈路對象HandlerExecutionChain return buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables); } // 什麼都沒有發現，返回null return null;}protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern, String pathWithinMapping, Map&lt;String, String&gt; uriTemplateVariables) { HandlerExecutionChain chain = new HandlerExecutionChain(rawHandler); // 創建執行鏈路的對象chain chain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping)); // 添加PathExposingHandlerInterceptor攔截器 if (!CollectionUtils.isEmpty(uriTemplateVariables)) { chain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables)); } return chain;}</pre><p>如圖就是調用buildPathExposingHandler之後返回的執行鏈對象chain</p><div class=pgc-img><img alt=SpringMVC:接收到請求後的調用細節，你是否清楚？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/135a93bb7565473188e45f438fccab3a><p class=pgc-img-caption></p></div><h1><strong>404狀態碼</strong></h1><p>在沒找到合適的handler執行鏈的時候，就會進入該方法（其實就是404了）</p><pre>protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception { if (pageNotFoundLogger.isWarnEnabled()) { // 類似這種代碼其實是為了適配不同的日誌系統 pageNotFoundLogger.warn("No mapping found for HTTP request with URI [" + getRequestUri(request) + "] in DispatcherServlet with name '" + getServletName() + "'"); } if (this.throwExceptionIfNoHandlerFound) { throw new NoHandlerFoundException(request.getMethod(), getRequestUri(request), new ServletServerHttpRequest(request).getHeaders()); } else { // HttpServletResponse.SC_NOT_FOUND 就是404 // 調用的是Tomcat本身的404設置頁面返回的，可以在web.xml 中配置自定義的404頁面 response.sendError(HttpServletResponse.SC_NOT_FOUND); }}</pre><p>如圖就是採用了jdk14Logger打印出來的數據，當然了現實項目中更多的應用log4j、log4j2</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=SpringMVC:接收到請求後的調用細節，你是否清楚？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d11f176602b442d864f7d0184eba4dd><p class=pgc-img-caption></p></div><h1><strong>獲取適配器</strong></h1><pre>protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException { for (HandlerAdapter ha : this.handlerAdapters) { // handlerAdapters的值就是在initStrategies()方法中獲取到的 // 默認的適配器是三個  // org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter // org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter // org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter // 如果細看適配器的初始化過程會發現，spring會優先獲取用戶自定義的適配器，如果沒有才會默認使用這三個適配器 if (ha.supports(handler)) { return ha; } } throw new ServletException("No adapter for handler [" + handler + "]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"); // 常出現的沒有找到適配器的報錯的地方就是這裡，遍歷了所有的適配器並沒有符合handler的適配器，則提示沒有適配器}</pre><p>接下來看看三種適配器到底是如何判斷對象是符合自身的要求的</p><p><strong>HttpRequestHandlerAdapter</strong></p><pre>@Overridepublic boolean supports(Object handler) { return (handler instanceof HttpRequestHandler); // 是否是HttpRequestHandler對象}</pre><p><strong>SimpleControllerHandlerAdapter</strong></p><pre>@Overridepublic boolean supports(Object handler) { return (handler instanceof Controller); // 是否是Controller對象}</pre><p><strong>AnnotationMethodHandlerAdapter</strong></p><pre>@Overridepublic boolean supports(Object handler) { return getMethodResolver(handler).hasHandlerMethods(); // 獲取到方法處理器，再判斷其是否為空}private ServletHandlerMethodResolver getMethodResolver(Object handler) { Class&lt;?&gt; handlerClass = ClassUtils.getUserClass(handler); ServletHandlerMethodResolver resolver = this.methodResolverCache.get(handlerClass); if (resolver == null) { synchronized (this.methodResolverCache) { resolver = this.methodResolverCache.get(handlerClass); if (resolver == null) { resolver = new ServletHandlerMethodResolver(handlerClass); this.methodResolverCache.put(handlerClass, resolver); } } } return resolver;}</pre><h1><strong>LastModified 機制</strong></h1><p>組合成為一個ServletWebRequest對象後就調用該方法，確認lastModified</p><pre>public boolean checkNotModified(String etag, long lastModifiedTimestamp) { HttpServletResponse response = getResponse(); if (this.notModified || !isStatusOK(response)) { // 不需要modified機制或者 response為null或者無效更或者狀態碼不是200 return this.notModified; } if (validateIfUnmodifiedSince(lastModifiedTimestamp)) { // 其對象會存儲該請求的時間，驗證是否符合lastModified的條件 if (this.notModified) { response.setStatus(HttpStatus.PRECONDITION_FAILED.value()); } return this.notModified; } boolean validated = validateIfNoneMatch(etag); // 默認傳過來的etag是null，返回false if (!validated) { validateIfModifiedSince(lastModifiedTimestamp); // 看是否是第一次來，如果是就需要刷新其時間 } boolean isHttpGetOrHead = SAFE_METHODS.contains(getRequest().getMethod()); // 是否為get或者head請求，並且變更response的頭信息 if (this.notModified) { response.setStatus(isHttpGetOrHead ? HttpStatus.NOT_MODIFIED.value() : HttpStatus.PRECONDITION_FAILED.value()); } if (isHttpGetOrHead) { if(lastModifiedTimestamp &gt; 0 &amp;&amp; isHeaderAbsent(response, LAST_MODIFIED)) { response.setDateHeader(LAST_MODIFIED, lastModifiedTimestamp); } if (StringUtils.hasLength(etag) &amp;&amp; isHeaderAbsent(response, ETAG)) { response.setHeader(ETAG, padEtagIfNecessary(etag)); } } // 如果符合其機制，就返回true，否則返回false return this.notModified;}</pre><p><strong>invoke調用</strong></p><p>只是取了這麼個名字，在獲取到了合適的執行鏈，有了合適的適配器，有沒有被攔截器處理，最後來到了真正調用方法的地方了。</p><p>上文可知，這是由各自的適配器調用handler方法來獲取真正的內容了。</p><p>在沒看源碼前，其實我們應該能夠猜到一些細節，例如</p><ul><li>上面說的bean的name是\開頭的被SimpleControllerHandlerAdapter命中，可是在該方法中並沒有明確定義執行的方法，所以controller接口必須有一些方法要被實現，然後由適配器調用實現類達到獲取內容的目的</li><li>普通的加了requestMapping被AnnotationMethodHandlerAdapter命中，則應該是通過反射獲取所有的可行的方法，然後依次篩選，直到匹配上了合適的方法，再invoke調用返回其內容</li></ul><p><strong>SimpleControllerHandlerAdapter</strong></p><p>HttpRequestHandlerAdapter和SimpleControllerHandlerAdapter是一樣的，就只解釋一種了。</p><pre>public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return ((Controller) handler).handleRequest(request, response); // 果然不出我們期望的，就是controller接口實現的方法handleRequest去完成真正的調用 // 如下面的demo，就是調用該方法，不過此方法意味著一個類只有一個URL映射 // 不像註解那樣一個類中可以包含多種URL映射}public class NameController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { ModelAndView modelAndView=new ModelAndView(); modelAndView.setViewName("/page/404"); return modelAndView; }}</pre><p><strong>AnnotationMethodHandlerAdapter</strong></p><pre>public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Class&lt;?&gt; clazz = ClassUtils.getUserClass(handler); Boolean annotatedWithSessionAttributes = this.sessionAnnotatedClassesCache.get(clazz); if (annotatedWithSessionAttributes == null) { annotatedWithSessionAttributes = (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) != null); this.sessionAnnotatedClassesCache.put(clazz, annotatedWithSessionAttributes); }  if (annotatedWithSessionAttributes) { checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true); } else { checkAndPrepare(request, response, true); } if (this.synchronizeOnSession) { HttpSession session = request.getSession(false); if (session != null) { Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) { return invokeHandlerMethod(request, response, handler); } } } // 前面各種操作來到了inVokeMethod return invokeHandlerMethod(request, response, handler);}protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { ServletHandlerMethodResolver methodResolver = getMethodResolver(handler); Method handlerMethod = methodResolver.resolveHandlerMethod(request); // 處理request，得到對應的需要被執行的方法 // 在這個函數中還有類URL註解信息和方法註解信息的拼接匹配過程 // 返回的對象就是一個Method對象 ServletHandlerMethodInvoker methodInvoker = new ServletHandlerMethodInvoker(methodResolver); ServletWebRequest webRequest = new ServletWebRequest(request, response); ExtendedModelMap implicitModel = new BindingAwareModelMap(); Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel); // 這個是真正的調用過程，其中還包含了請求參數的處理等各種過程 // 返回的結果可以是字符串也可以是mv，看具體的方法是如何實現的 ModelAndView mav = methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest); // 獲取具體的視圖類，如果是具體業務返回，視圖為null，具體的數據已經通過response的body回填返回了 methodInvoker.updateModelAttributes(handler, (mav != null ? mav.getModel() : null), implicitModel, webRequest); // 視圖屬性更新 return mav;}</pre><p class=ql-align-center><br></p><div class=pgc-img><img alt=SpringMVC:接收到請求後的調用細節，你是否清楚？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2205336a8e1a4cfe8ee0f14626feb2e9><p class=pgc-img-caption></p></div><pre>public ModelAndView getModelAndView(Method handlerMethod, Class&lt;?&gt; handlerType, Object returnValue, ExtendedModelMap implicitModel, ServletWebRequest webRequest) throws Exception { ResponseStatus responseStatus = AnnotatedElementUtils.findMergedAnnotation(handlerMethod, ResponseStatus.class); // 查看該方法是否加了ResponseStatus註解，主要是為了替換狀態碼 if (responseStatus != null) { HttpStatus statusCode = responseStatus.code(); String reason = responseStatus.reason(); // 該執行方法存在該ResponseStatus的註解，獲取狀態碼和原因 // 不過該具體使用的時候，只能是HttpStatus枚舉類中的選項，默認是500錯誤 if (!StringUtils.hasText(reason)) { // 沒有具體原因，就只設置狀態碼，否則就返回錯誤碼 webRequest.getResponse().setStatus(statusCode.value()); } else { webRequest.getResponse().sendError(statusCode.value(), reason); } // 設置當前的請求屬性，名字為模板和狀態，值就是狀態碼 webRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, statusCode); this.responseArgumentUsed = true; } // 如果存在自定義的ModelAndView解析 if (customModelAndViewResolvers != null) { for (ModelAndViewResolver mavResolver : customModelAndViewResolvers) { ModelAndView mav = mavResolver.resolveModelAndView( handlerMethod, handlerType, returnValue, implicitModel, webRequest); // 遍歷自定義ModelAndView解析器，選擇合適的mv，並且不是初始化的視圖類 // 這個是由用戶自定義的實現類，並且切記記得適配器的設置，別沒弄好導致無合適的適配器的錯誤 // ModelAndView UNRESOLVED = new ModelAndView(); if (mav != ModelAndViewResolver.UNRESOLVED) { return mav; } } }  // 返回的類型是HttpEntity、string、ModelAndView、Model、View、Map if (returnValue instanceof HttpEntity) { // 返回值是HttpEntity類型的數據，不需要合適的視圖 // 更多的是返回json數據 handleHttpEntityResponse((HttpEntity&lt;?&gt;) returnValue, webRequest); return null; } else if (AnnotationUtils.findAnnotation(handlerMethod, ResponseBody.class) != null) { // 方法包含了ResponseBody註解，直接把returnValue 塞入response handleResponseBody(returnValue, webRequest); return null; } else if (returnValue instanceof ModelAndView) { ModelAndView mav = (ModelAndView) returnValue; mav.getModelMap().mergeAttributes(implicitModel); return mav; } else if (returnValue instanceof Model) { return new ModelAndView().addAllObjects(implicitModel).addAllObjects(((Model) returnValue).asMap()); } else if (returnValue instanceof View) { return new ModelAndView((View) returnValue).addAllObjects(implicitModel); } else if (AnnotationUtils.findAnnotation(handlerMethod, ModelAttribute.class) != null) { addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel); return new ModelAndView().addAllObjects(implicitModel); } else if (returnValue instanceof Map) { return new ModelAndView().addAllObjects(implicitModel).addAllObjects((Map&lt;String, ?&gt;) returnValue); } else if (returnValue instanceof String) { return new ModelAndView((String) returnValue).addAllObjects(implicitModel); } else if (returnValue == null) { // Either returned null or was 'void' return. if (this.responseArgumentUsed || webRequest.isNotModified()) { return null; } else { // Assuming view name translation... return new ModelAndView().addAllObjects(implicitModel); } } else if (!BeanUtils.isSimpleProperty(returnValue.getClass())) { // Assume a single model attribute... addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel); return new ModelAndView().addAllObjects(implicitModel); } else { throw new IllegalArgumentException("Invalid handler method return value: " + returnValue); } }</pre><p>在這其中的代碼快customModelAndViewResolvers，更多的細節可以看看Spring Controller層記錄日誌配置的實踐demo</p><h1><strong>視圖渲染</strong></h1><pre>private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception { boolean errorView = false; if (exception != null) { // 有異常，不能正常顯示請求內容了 if (exception instanceof ModelAndViewDefiningException) { logger.debug("ModelAndViewDefiningException encountered", exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); } else { Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); // 異常處理返回的mv，異常mv配置存放在handlerExceptionResolvers errorView = (mv != null); } } // 有可用的mv if (mv != null &amp;&amp; !mv.wasCleared()) { render(mv, request, response); // render就是渲染，回填數據到response中去 if (errorView) { // 如果有非ModelAndViewDefiningException，則清除請求的屬性信息 WebUtils.clearErrorRequestAttributes(request); } } else { // 沒有可用的視圖信息 if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Concurrent handling started during a forward return; } if (mappedHandler != null) { mappedHandler.triggerAfterCompletion(request, response, null); }}</pre><p><strong>渲染render</strong></p><pre>protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception { // Determine locale for request and apply it to the response. Locale locale = this.localeResolver.resolveLocale(request); response.setLocale(locale); View view; if (mv.isReference()) { // mv的視圖名字是string類型，則需要找到真正的視圖 // 需要使用到local字段信息 view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request); if (view == null) { // 沒有找到有效的視圖，報錯提示 throw new ServletException("Could not resolve view with name '" + mv.getViewName() + "' in servlet with name '" + getServletName() + "'"); } } else { // 否則就被認為是View對象，直接獲取就可以了 view = mv.getView(); if (view == null) { throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a " + "View object in servlet with name '" + getServletName() + "'"); } } // Delegate to the View object for rendering. if (logger.isDebugEnabled()) { logger.debug("Rendering view [" + view + "] in DispatcherServlet with name '" + getServletName() + "'"); } try { if (mv.getStatus() != null) { // 從mv中獲取http狀態碼 response.setStatus(mv.getStatus().value()); } // 來到了真正的渲染，所有的數據已經準備就緒 view.render(mv.getModelInternal(), request, response); } catch (Exception ex) { if (logger.isDebugEnabled()) { logger.debug("Error rendering view [" + view + "] in DispatcherServlet with name '" + getServletName() + "'", ex); } throw ex; }}</pre><p>其中的resolve</p><h1><strong>View 渲染</strong></h1><p>View本身是一個接口類，spring根據不同的業務實現了多個不同的View實體類，包含了html、pdf、Excel等。</p><p><strong>AbstractView 抽象視圖類</strong></p><pre>public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception { Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response); prepareResponse(request, response); renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);}</pre><p>由各自的子類去實現renderMergedOutputModel方法</p><div class=pgc-img><img alt=SpringMVC:接收到請求後的調用細節，你是否清楚？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b643785ca8f8407eb0521cdde4f2c4f4><p class=pgc-img-caption></p></div><h1 class=ql-align-center><strong>原創推薦</strong></h1><p class=ql-align-center><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6714635036563341838/?group_id=6714635036563341838" target=_blank>「系列教程」手寫RPC框架(1)，看看100個線程同時調用情況如何</a></p><p class=ql-align-center><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6711984615948550670/?group_id=6711984615948550670" target=_blank>「面試」new String("abc")和"abc"有什麼區別？反編譯看看原理吧</a></p><p class=ql-align-center><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6721928402791563783/?group_id=6721928402791563783" target=_blank>面試：你是否瞭解Spring BeanPostProcessor的原理和具體使用場景</a></p><p class=ql-align-center><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6716039801792889348/?group_id=6716039801792889348" target=_blank>「Spring源碼」XML解析BeanDefinition原理學習</a></p><p class=ql-align-center><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6722403219303039501/?group_id=6722403219303039501" target=_blank>從Tomcat入口瞭解Spring MVC的請求處理流程</a></p><p class=ql-align-center><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6711319178290135566/?group_id=6711319178290135566" target=_blank>「Spring源碼」深入學習事件通知機制</a></p><p class=ql-align-center><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6723792776560902670/?group_id=6723792776560902670" target=_blank>Spring原理：10個Spring&SpringBoot高階用法，你是否清楚？</a></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>SpringMVC</a></li><li><a>請求</a></li><li><a>調用</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/71debf3a.html alt=如何從請求、傳輸、渲染3個方面提升Web前端性能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ec3175fa2700484eac030574b8369e79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/71debf3a.html title=如何從請求、傳輸、渲染3個方面提升Web前端性能>如何從請求、傳輸、渲染3個方面提升Web前端性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f8e9216.html alt=寫個日誌請求切面，前後端甩鍋更方便 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/9ee016d0-a9b0-43a8-95a8-2d6d7b5e7e21 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f8e9216.html title=寫個日誌請求切面，前後端甩鍋更方便>寫個日誌請求切面，前後端甩鍋更方便</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ce29ef6.html alt=VBA代碼中，如何調用內置對話框，進行人機對話的交流 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8d3b2fcede384accac9f17404e14d9a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ce29ef6.html title=VBA代碼中，如何調用內置對話框，進行人機對話的交流>VBA代碼中，如何調用內置對話框，進行人機對話的交流</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f9be60b.html alt=使用OpenFileDialog調用打開對話框 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/b9c74182-1a53-488a-8f6e-e1f7d5d72656 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f9be60b.html title=使用OpenFileDialog調用打開對話框>使用OpenFileDialog調用打開對話框</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8eb8d179.html alt="如何在調用Marketing Cloud contact創建API時增加對擴展字段支持" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/09722e849c274476a14efb0ec482d174 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8eb8d179.html title="如何在調用Marketing Cloud contact創建API時增加對擴展字段支持">如何在調用Marketing Cloud contact創建API時增加對擴展字段支持</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b39a9d6.html alt=C｜函數調用與參數（形參與實參）傳遞（傳值與傳址） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/31e90001a36edcf8dfa2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b39a9d6.html title=C｜函數調用與參數（形參與實參）傳遞（傳值與傳址）>C｜函數調用與參數（形參與實參）傳遞（傳值與傳址）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ca8329c.html alt=CORS——跨域請求那些事兒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/382fe92652924d74afe3f3ee787c9042 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ca8329c.html title=CORS——跨域請求那些事兒>CORS——跨域請求那些事兒</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86d72690.html alt="HTTP請求過程（三）—— TCP四次揮手斷開連接以及異常處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522228359775acd17c0c4a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86d72690.html title="HTTP請求過程（三）—— TCP四次揮手斷開連接以及異常處理">HTTP請求過程（三）—— TCP四次揮手斷開連接以及異常處理</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/fa22d056.html alt=朱升本該是朱元璋的“首席軍師”，建立明朝後突然提出：請求歸鄉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8c3dda383222456f815c37b41ba9e547 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/fa22d056.html title=朱升本該是朱元璋的“首席軍師”，建立明朝後突然提出：請求歸鄉>朱升本該是朱元璋的“首席軍師”，建立明朝後突然提出：請求歸鄉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc82ec50.html alt=遠程服務調用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7c9c5e62ce24334ad3374c4150299d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc82ec50.html title=遠程服務調用>遠程服務調用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91b0a2d.html alt=網絡請求OkHttp3封裝支持緩存、日誌、攔截器、斷點下載、上傳等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15342286987793c1faad242 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91b0a2d.html title=網絡請求OkHttp3封裝支持緩存、日誌、攔截器、斷點下載、上傳等>網絡請求OkHttp3封裝支持緩存、日誌、攔截器、斷點下載、上傳等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/188cbaf.html alt=HTML調用打開本地文件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fee4388dfccc4aabac72da72ed00d07a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/188cbaf.html title=HTML調用打開本地文件>HTML調用打開本地文件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d147c6c.html alt="在網頁中通過調用Windows Media Player來探測特定文件" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dfa68bbd164e43c3afb1e5fae8382c40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d147c6c.html title="在網頁中通過調用Windows Media Player來探測特定文件">在網頁中通過調用Windows Media Player來探測特定文件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c758476.html alt=C語言函數的調用原理不理解？深入淺出通俗易懂，一文讀懂函數棧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/70a95ad5c35849428fddf913b0817059 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c758476.html title=C語言函數的調用原理不理解？深入淺出通俗易懂，一文讀懂函數棧>C語言函數的調用原理不理解？深入淺出通俗易懂，一文讀懂函數棧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5cf7cc6.html alt=Linux系統調用詳解（實現機制分析） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/89bc567a63c84695b0fbe8982764bbdb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5cf7cc6.html title=Linux系統調用詳解（實現機制分析）>Linux系統調用詳解（實現機制分析）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>