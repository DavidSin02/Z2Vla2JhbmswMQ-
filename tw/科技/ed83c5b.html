<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結 | 极客快訊</title><meta property="og:title" content="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f6eb68b8549e4045a802c692e82fd727"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed83c5b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed83c5b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ed83c5b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed83c5b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed83c5b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ed83c5b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ed83c5b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ed83c5b.html><meta property="article:published_time" content="2020-10-29T21:04:52+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:52+08:00"><meta name=Keywords content><meta name=description content="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ed83c5b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>引言：從斐波那契數列看動態規劃</p><p>　　<strong>斐波那契數列：Fn = Fn-1 + Fn-2 （ n = 1,2 fib(1) = fib(2) = 1）</strong></p><h4 class=pgc-h-arrow-right>練習：使用遞歸和非遞歸的方法來求解斐波那契數列的第 n 項</h4><p>　　代碼如下：</p><pre><code># _*_coding:utf-8_*_ def fibnacci(n):    if n == 1 or n == 2:        return 1    else:        return fibnacci(n - 1) + fibnacci(n - 2) # 寫這個是我們會發現計算f(5) 要算兩邊f(4)# f(5) = f(4)+f(3)# f(4) = f(3)+f(2)# f(3) = f(2)+f(1)# f(3) = f(2)+f(1)# f(2) = 1# 那麼同理，算f(6)，我們會計算兩次f(5),三次f(4)....# 當然不是說所有的遞歸都會重複計算， # 時間隨著數字越大，時間越長print(fibnacci(10))  # 55</code></pre><p>　　簡單來說，就是想要計算f（5），我們需要先計算出子問題 f(4) 和 f(3)，然後要計算 f(4) ，我們需要先計算出子問題 f(3) 和 f(2)，以此類推，最後遇到 f(1) 或者 f(2) 的時候，結果已知，就能直接返回結果，遞歸樹不再向下生長了。</p><p>　　<strong>遞歸算法的時間複雜度怎麼計算？子問題個數乘以解決一個子問題需要的時間。</strong></p><p>　　子問題個數，即遞歸樹中節點的總數。顯然二叉樹節點總數為指數級別，所以子問題個數為 O(2^n)。</p><p>　　解決一個子問題的時間，在本算法中，沒有循環，只有 f(n - 1) + f(n - 2) 一個加法操作，時間為 O(1)。</p><p>　　所以，這個算法的時間複雜度為 O(2^n)，指數級別，爆炸。</p><p>　　觀察遞歸樹，很明顯發現了算法低效的原因：存在大量重複計算，比如 f(5) 被計算了兩次，而且你可以看到，以 f(5) 為根的這個遞歸樹體量巨大，多算一遍，會耗費巨大的時間。更何況，還不止 f(5) 這一個節點被重複計算，所以這個算法及其低效。</p><p>　　這就是動態規劃問題的第一個性質：<strong>重疊子問題</strong>。下面，我們想辦法解決這個問題。</p><p>　　明確了問題，其實就已經把問題解決了一半。即然耗時的原因是重複計算，那麼我們可以造一個「備忘錄」，每次算出某個子問題的答案後別急著返回，先記到「備忘錄」裡再返回；每次遇到一個子問題先去「備忘錄」裡查一查，如果發現之前已經解決過這個問題了，直接把答案拿出來用，不要再耗時去計算了。</p><p>　　一般使用一個數組充當這個「備忘錄」，當然你也可以使用哈希表（字典），思想都是一樣的。</p><pre><code>def fibnacci_n_recurision(n):    f = [0, 1, 1]    if n &gt; 2:        for i in range(n - 2):            num = f[-1] + f[-2]            f.append(num)    return f[n]  print(fibnacci_n_recurision(10))</code></pre><p>　　實際上，帶「備忘錄」的遞歸算法，把一棵存在巨量冗餘的遞歸樹通過「剪枝」，改造成了一幅不存在冗餘的遞歸圖，極大減少了子問題（即遞歸圖中節點）的個數。</p><p>　　<strong>遞歸算法的時間複雜度怎麼算？子問題個數乘以解決一個子問題需要的時間。</strong></p><p>　　子問題個數，即圖中節點的總數，由於本算法不存在冗餘計算，子問題就是 f(1), f(2), f(3) ... f(20)，數量和輸入規模 n = 20 成正比，所以子問題個數為 O(n)。</p><p>　　解決一個子問題的時間，同上，沒有什麼循環，時間為 O(1)。</p><p>　　所以，本算法的時間複雜度是 O(n)。比起暴力算法，是降維打擊。</p><p>　　至此，帶備忘錄的遞歸解法的效率已經和動態規劃一樣了。實際上，這種解法和動態規劃的思想已經差不多了，只不過這種方法叫做「自頂向下」，動態規劃叫做「自底向上」。</p><p>　　啥叫「自頂向下」？ 就是從上向下延伸，都是從一個規模較大的原問題比如說 f(5)，向下逐漸分解規模，直到 f(1) 和 f(2) 觸底，然後逐層返回答案，這就叫「自頂向下」。</p><p>　　啥叫「自底向上」？反過來，我們直接從最底下，最簡單，問題規模最小的 f(1) 和 f(2) 開始往上推，直到推到我們想要的答案 f(5)，這就是動態規劃的思路，這也是為什麼動態規劃一般都脫離了遞歸，而是由循環迭代完成計算。</p><p>　　為了讓我們的說服更有理一些，這裡寫了一個裝飾器，我們通過運行時間看。同樣對於上面兩個函數，一個遞歸，一個非遞歸，我們輸入 n=15</p><p># cal_time.py 函數代碼如下：</p><p></p><pre><code>import time def cal_time(func):    def wrapper(*args, **kwargs):        t1 = time.time()        result = func(*arg, **kwargs)        t2 = time.time()        print("%s running time: %s secs." % (func.__name__, t2 - t1))        return result    return wrapper      運行結果： fibnacci running time: 0.01000070571899414 secs.fibnacci_n_recurision running time: 0.0 secs.</code></pre><p>　　總結來說，就是遞歸非常非常的慢，那非遞歸相對來說就比較快了。那為什麼呢？就是為什麼遞歸的效率低。我們上面代碼也說過了，就是對子問題進行重複計算了。那第二個函數為什麼快呢，我們將每次的計算結果存在了函數裡，直接調用，避免了重複計算（當然不是說所有的遞歸都會重複計算子問題），第二個函數我們其實可以看做是動態規劃的思想，從上面的代碼來看：</p><p>　　<strong>動態規劃的思想==遞推式+重複子問題</strong></p><p>　　怎麼理解呢，就是說動態規劃遵循一套固定的流程：遞歸的暴力解法 ——> 帶備忘錄的遞歸解法 ——> 非遞歸的動態規劃解法 這個過程是層次遞進的解決問題的過程，你如果沒有前面的鋪墊，直接看最終的非遞歸動態規劃解法，當然覺得難。</p><h3 class=pgc-h-arrow-right>1，什麼是動態規劃</h3><p>　　動態規劃(dynamic programming)是運籌學的一個分支，是求解決策過程(decision process)最優化的數學方法。把多階段過程轉化為一系列單階段問題，利用各階段之間的關係，逐個求解，創立了解決這類過程優化問題的新方法——動態規劃。</p><h4 class=pgc-h-arrow-right>1.1，使用動態規劃特徵</h4><ul><li>1. 求一個問題的最優解</li><li>2. 大問題可以分解為子問題，子問題還有重疊的更小的子問題</li><li>3. 整體問題最優解取決於子問題的最優解（狀態轉移方程）</li><li>4. 從上往下分析問題，從下往上解決問題</li><li>5. 討論底層的邊界問題</li></ul><h4 class=pgc-h-arrow-right>1.2，動態規劃的基本思想</h4><p>　　若要解一個給定問題，我們需要解其不同部分（即子問題），再合併子問題的解以得出原問題的解。通常許多子問題非常相似，為此動態規劃法試圖僅僅解決每個子問題一次，從而減少計算量：一旦某個給定子問題的解已經算出，則將其記憶化存儲，以便下次需要同一個子問題解之時直接查表。這種做法在重複子問題的數目關於輸入的規模呈指數增長時特別有效。</p><p>　　動態規劃最重要的有三個概念：1、最優子結構 2、邊界 3、狀態轉移方程</p><p>　　所以我們在學習動態規劃要明白三件事情：</p><p>1，目標問題</p><p>2，狀態的定義：opt[n]</p><p>3，狀態轉移方程：opt[n] = best_of(opt[n-1], opt[n-2])</p><p>　　其實狀態轉移方差直接代表著暴力解法，千萬不要看不起暴力解，動態規劃問題最難的就是寫出狀態轉移方差，即這個暴力解。</p><h3 class=pgc-h-arrow-right>2，鋼條切割問題</h3><p>　　某公司出售鋼條，出售價格與鋼條長度直接的關係如下表：</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f6eb68b8549e4045a802c692e82fd727><p class=pgc-img-caption></p></div><p>　　問題：現在有一條長度為 n 的鋼條和上面的價格表，求切割鋼條方案，使得總收益最大。</p><p>　　分析：長度為4的鋼條的所有切割方案如下：（C方案最優）</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/69c2cf5187b0438facb8dea1d420e735><p class=pgc-img-caption></p></div><p>　　思考：長度為 n 的鋼條的不同切割方案有幾種？</p><p>　　<strong>下面是當長度為n的時候，最優價格的表格（ i 表示長度為 n ，r[i] 表示最優價格）</strong></p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb41ca49dc714fa2aebfb41a9cf1ffc3><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>2.1，遞推式解決鋼條切割問題</h4><p>　　設長度為 n 的鋼條切割後最優收益值為 Rn，可以得到遞推式：</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1596279cec8b4a9a8530e28f0959252f><p class=pgc-img-caption></p></div><p>　　第一個參數Pn 表示不切割</p><p>　　其他 n-1個參數分別表示另外 n-1種不同切割方案，對方案 i=1,2,...n-1 將鋼條切割為長度為 i 和 n-i 兩段</p><p>　　方案 i 的收益為切割兩段的最優收益之和，考察所有的 i，選擇其中收益最大的方案</p><h4 class=pgc-h-arrow-right>2.2，最優子結構解決鋼條切割問題</h4><p>　　可以將求解規模為 n 的原問題，劃分為規模更小的子問題：完成一次切割後，可以將產生的兩段鋼條看成兩個獨立的鋼條切割問題。</p><p>　　組合兩個子問題的最優解，並在所有可能的兩段切割方案中選取組合收益最大的，構成原問題的最優解。</p><p>　　鋼條切割滿足<strong>最優子結構</strong>：問題的最優解由相關子問題的最優解組合而成，這些子問題可以獨立求解。</p><p>　　鋼條切割問題還存在更簡單的遞歸求解方法：</p><ul><li>從鋼條的左邊切割下長度為 i 的一段，只對右邊剩下的一段繼續進行切割，左邊的不再切割</li><li>遞推式簡化為：</li><li>不做切割的方案就可以描述為：左邊一段長度為 n，收益為 pn，剩下一段長度為0，收益為 r0=0.</li></ul><h4 class=pgc-h-arrow-right>2.3，鋼條切割問題——自頂向下遞歸代碼及其時間複雜度</h4><p>　　代碼如下：</p><pre><code>def _cut_rod(p, n):    if n == 0:        return 0    q = 0    for i in range(1, n+1):        q = max(q, p[i] + _cut_rod(p, n-i))    return q</code></pre><p>　　如下圖所示，當鋼條的長度增加時候，切割的方案次數隨著指數增加。當n=1的時候切割1次，n=2的時候切割2次，n=3的時候切割4次，n=4的時候切割8次。。。。</p><p>　　所以：自頂向下遞歸實現的時間複雜度為 <strong>O(2n)</strong></p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aa85dbc1d34a4c2ea3467bac11c54acf><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>2.4，兩種方法的代碼實現</h4><p>　　代碼如下：</p><p><br></p><pre><code># _*_coding:utf-8_*_import time  # 給遞歸函數一個裝飾器，它就遞歸的裝飾！！ 所以為了防止這樣我們再套一層即可def cal_time(func):    def wrapper(*args, **kwargs):        t1 = time.time()        result = func(*args, **kwargs)        t2 = time.time()        print('%s running time : %s secs' % (func.__name__, t2 - t1))        return result     return wrapper  # p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 21, 23, 24, 26, 27, 28, 30, 33, 36, 39, 40]p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]  def cut_rod_recurision_1(p, n):    if n == 0:        return 0    else:        res = p[n]        for i in range(1, n):            res = max(res, cut_rod_recurision_1(p, i) + cut_rod_recurision_1(p, n - i))        return res  # print(cut_rod_recurision_1(p, 9))  def cut_rod_recurision_2(p, n):    if n == 0:        return 0    else:        res = 0        for i in range(1, n + 1):            res = max(res, p[i] + cut_rod_recurision_2(p, n - i))        return res  # print(cut_rod_recurision_2(p, 9)) @cal_timedef c1(p, n):    return cut_rod_recurision_1(p, n) @cal_timedef c2(p, n):    return cut_rod_recurision_2(p, n)  print(c1(p, 10))print(c2(p, 10))'''c1 running time : 0.02000117301940918 secs30c2 running time : 0.0010001659393310547 secs30'''</code></pre><p>　　我們通過計算時間，發現第二個遞歸方法明顯比第一個遞歸方法快很多。那麼是否還有更簡單的方法呢？肯定有，下面學習動態規劃。</p><h4 class=pgc-h-arrow-right>2.5，動態規劃解決鋼條切割問題</h4><p>　　遞歸算法由於重複求解相同子問題，效率極低。即使優化過後的遞歸也效率不高。那這裡使用動態規劃。</p><p><strong>　　動態規劃的思想</strong>：</p><ol start=1><li><strong>每個子問題只求解一次，保存求解結果</strong></li><li><strong>之後需要此問題時，只需要查找保存的結果</strong></li></ol><p>　　動態規劃解法代碼：</p><pre><code>def cut_rod_dp(p, n):    r = [0 for _ in range(n+1)]    for j in range(1, n+1):        q = 0        for i in range(1, j+1):            q = max(q, p[i]+r[j-i])        r[j] = q    return r[n]</code></pre><p>　　或者便於理解這樣：</p><pre><code>def cut_rod_dp(p, n):    r = [0]    for i in range(1, n+1):        res = 0        for j in range(1, i+1):            res = max(res, p[j]+r[i-j])        r.append(res)    return r[n]</code></pre><p>　　時間複雜度： <strong>O(n2)</strong></p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebb22567c593492790fa8c604ae975ca><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>2.6，鋼條切割問題——重構解</h4><p>　　<strong>如何修改動態規劃算法，使其不僅輸出最優解，還輸出最優切割方案？</strong></p><p>　　對於每個子問題，保存切割一次時左邊切下的長度</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2e7529ce41ea4f3c9f2a11f9cc70b5e1><p class=pgc-img-caption></p></div><p>　　下圖為r[i] 表示最優切割的價格，s[i]表示切割左邊的長度。</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3c22319ec85645ab9977409e8172a744><p class=pgc-img-caption></p></div><p>　　代碼如下：</p><p><br></p><pre><code>def cut_rod_extend(p, n):    r = [0]    s = [0]    # 這個循環的意思是從底向上計算    for i in range(1, n+1):        res_r = 0  # 用來記錄價格的最優值        res_s = 0  # 用來記錄切割左邊的最優長度        for j in range(1, i+1):            if p[j] + r[i-j] &gt; res_r:                res_r = p[j] + r[i-j]                res_s = j        r.append(res_r)        s.append(res_s)    return r[n], s def cut_rod_solution(p, n):    r, s = cut_rod_extend(p, n)    ans = []    while n&gt;0:        ans.append(s[n])        n-= s[n]    return ans  print(cut_rod_extend(p, 10))# (30, [0, 1, 2, 3, 2, 2, 6, 1, 2, 3, 10])print(cut_rod_solution(p, 9))# [3, 6]</code></pre><h4 class=pgc-h-arrow-right>2.7，什麼問題可以使用動態規劃方法？</h4><p>　　1，最優子結構</p><ul><li>原問題的最優解中涉及多少個子問題</li><li>在確定最優解使用那些子問題時，需要考慮多少種選擇</li></ul><p>　　2，重疊子問題</p><p></p><h3 class=pgc-h-arrow-right>3，最長公共子序列</h3><p>　　一個序列的子序列是在該序列中刪去若干元素後得到的序列。例如：ABCD 和 BDF 都是 ABCDEFG 的子序列。</p><p>　　在一個序列中，<strong>子串是連續的，子序列可以不連續</strong>。</p><p>　　最常公共子序列（LCS）問題：給定兩個序列 X 和 Y，求 X 和 Y 長度最大的公共子序列。例如 X = ABBCBDE， Y = DBBCDB ， LCS(X, Y) = BBCD 。</p><p>　　應用場景：<strong>字符串相似度比對。</strong></p><h4 class=pgc-h-arrow-right><strong>3.</strong>1，最長公共子序列的思路——暴力窮舉法</h4><p>　　當X的長度為m，Y的長度為n，則時間複雜度為：<strong> 2^(m+n)</strong></p><p>　　雖然我們最先想到的時暴力窮舉法，但是很顯然，由其時間複雜度可知，這是不可取的。</p><h4 class=pgc-h-arrow-right>3.2，最長公共子序列的思路——LCS是否具有最優子結構性質</h4><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/91080291f41147fbafb3725e6a18271d><p class=pgc-img-caption></p></div><p>　　例如：要求 a = ABCBDAB 與 b = BDCABA 的LCS：</p><p>　　由於最後一位 B！= A</p><p>　　因此LCS（a, b）應該來源於 LCS（a[: -1], b）與 LCS(a, b[: -1]) 中更大的哪一個。</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/389644f2603e4493877cfb0371bbb624><p class=pgc-img-caption></p></div><p>　　最優解的遞推式如下：</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b652ba727e7a4067a1ef9f4808b49466><p class=pgc-img-caption></p></div><p>　　c[i,j] 表示 Xi 和 Yj 的LCS 長度。</p><h4 class=pgc-h-arrow-right>3.3，最長公共子序列的代碼</h4><p>　　代碼如下：</p><p><br></p><pre><code>def lcs_length(x, y):    m = len(x)    n = len(y)    c = [[0 for _ in range(n + 1)] for _ in range(m + 1)]    for i in range(1, m + 1):        for j in range(1, n + 1):            if x[i - 1] == y[j - 1]:  # i，j位置上的字符匹配的時候，來自於左上方                c[i][j] = c[i - 1][j - 1] + 1            else:                c[i][j] = max(c[i - 1][j], c[i][j - 1])     # 逐行打印    for _ in c:        print(_)    return c[m][n]  # 最優值出來了，但是過程沒有出來，也就是隻有最長，不知道公共子序列# print(lcs_length("ABCBDAB", "BDCABA"))'''[0, 0, 0, 0, 0, 0, 0][0, 0, 0, 0, 1, 1, 1][0, 1, 1, 1, 1, 2, 2][0, 1, 1, 2, 2, 2, 2][0, 1, 1, 2, 2, 3, 3][0, 1, 2, 2, 2, 3, 3][0, 1, 2, 2, 3, 3, 4][0, 1, 2, 2, 3, 4, 4]4'''  def lcs(x, y):    m = len(x)    n = len(y)    c = [[0 for _ in range(n + 1)] for _ in range(m + 1)]    # 1左上方 2上方 3 左方    b = [[0 for _ in range(n + 1)] for _ in range(m + 1)]    for i in range(1, m + 1):        for j in range(1, n + 1):            if x[i - 1] == y[j - 1]:  # i，j位置上的字符匹配的時候，來自於左上方                c[i][j] = c[i - 1][j - 1] + 1                b[i][j] = 1            elif c[i - 1][j] &gt; c[i][j - 1]:  # 來自於上方                c[i][j] = c[i - 1][j]                b[i][j] = 2            else:                c[i][j] = c[i][j - 1]                b[i][j] = 3     return c[m][n], b  # c, b = lcs("ABCBDAB", "BDCABA")# for _ in b:#     print(_)'''[0, 0, 0, 0, 0, 0, 0][0, 3, 3, 3, 1, 3, 1][0, 1, 3, 3, 3, 1, 3][0, 2, 3, 1, 3, 3, 3][0, 1, 3, 2, 3, 1, 3][0, 2, 1, 3, 3, 2, 3][0, 2, 2, 3, 1, 3, 1][0, 1, 2, 3, 2, 1, 3]'''  def lcs_trackback(x, y):    c, b = lcs(x, y)    i = len(x)    j = len(y)    res = []    while i &gt; 0 and j &gt; 0:        if b[i][j] == 1:  # 來自左上方 =》匹配            res.append(x[i - 1])            i -= 1            j -= 1        elif b[i][j] == 2:  # 來自上方=》 不匹配            i -= 1        else:  # ==3  來自左方 =》不匹配            j -= 1    # 因為是回溯法，所以倒著寫的，我們最後需要reverse回來    return "".join(reversed(res)) print(lcs_trackback("ABCBDAB", "BDCABA"))# BDAB</code></pre><p>　　</p><h3 class=pgc-h-arrow-right>4，最大子序和</h3><p>　　給定一個整數數組 nums ，找到一個具有最大和的連續子數組（子數組最少包含一個元素），返回其最大值。</p><p>　　<strong>示例：輸入：[-2, 1, -3, 4, -1, 2, 1, -5, 4] 輸出：輸出：6</strong></p><p>　　思路：我們首先分析題目，為什麼最大和的連續子數組不包括其他的元素而是這幾個呢？如果我們想在現有的基礎上去擴展當前連續子數組，相鄰的元素是一定要被加入的，而相鄰元素可能會減損當前的和。</p><h4 class=pgc-h-arrow-right>4.1，遍歷法</h4><p>　　算法過程：遍歷數組，用 sum 去維護當前元素加起來的和，當 sum 出現小於0的情況時，我們把它設為0，然後每次都更新全局最大值。</p><pre><code>def maxSubArray(self, nums: List[int]) -&gt; int:       sum = 0       MaxSum = nums[0]       for i in range(len(nums)):           sum += nums[i]           MaxSum = max(sum, MaxSum)           if sum &lt;0:               sum = 0       return MaxSum</code></pre><p>　　那看起來這麼簡單，如何理解呢？一開始思考數組是個空的，我們每次選一個 nums[i] 加入當前數組中新增了一個元素，也就是用動態的眼光去考慮。代碼簡單為什麼就能達到效果呢？</p><p>　　我們進行的加和是按照順序來的，當我們i 選出來後，加入當前 sum，這時候有兩種情況：</p><p>1，假設我們當前 sum 一致都大於零，那每一次計算的 sum 都是包括開頭元素的一端子序列。</p><p>2，出現小於0的時候，說明我們當前子序列第一次小於零，所以我們現在形成的連續數組不能包括之前的連續子序了，於是拋棄他們，重新開始新的子序。</p><h4 class=pgc-h-arrow-right>4.2，動態規劃</h4><p>　　設sum[i]為以第i個元素結尾的最大的連續子數組的和。假設對於元素i，所有以它前面的元素結尾的子數組的長度都已經求得，那麼以第i個元素結尾且和最大的連續子數組實際上，要麼是以第i-1個元素結尾且和最大的連續子數組加上這個元素，要麼是隻包含第i個元素，即sum[i]= max(sum[i-1] + a[i], a[i])。可以通過判斷sum[i-1] + a[i]是否大於a[i]來做選擇，而這實際上等價於判斷sum[i-1]是否大於0。由於每次運算只需要前一次的結果，因此並不需要像普通的動態規劃那樣保留之前所有的計算結果，只需要保留上一次的即可，因此算法的時間和空間複雜度都很小。</p><p>　　代碼如下：</p><pre><code>def maxSubArray4(self, nums: List[int]) -&gt; int:    length = len(nums)    for i in range(1, length):        # 當前值的大小與前面的值之和比較，若當前值更大，則取當前值，捨棄前面的值之和        subMaxSum = max(nums[i]+nums[i-1], nums[i])        # 將當前和最大的賦給 nums[i]， 新的nums 存儲的為何值        nums[i] = subMaxSum    return max(nums)</code></pre><p>　　只要遍歷一遍。nums[i]表示的是以當前這第i號元素結尾（看清了一定要包含當前的這個i）的話，最大的值無非就是看以i-1結尾的最大和的子序能不能加上我這個nums[i]，如果nums[i]>0的話，則加上。注意我代碼中沒有顯式地去這樣判斷，不過我的Max表達的就是這個意思，然後我們把nums[i]確定下來。</p><h4 class=pgc-h-arrow-right>4.3 總結</h4><p>　　計算機解決問題其實沒有任何奇技淫巧，它唯一的解決辦法就是窮舉，窮舉所有可能性。算法設計無法就是先思考“如何窮舉”，然後再追求“如何聰明的窮舉”。</p><p>　　列出動態轉移方差，就是在解決“如何窮舉”的問題，之所以說他難，一是因為很多窮舉需要遞歸實現，二是因為有的問題本身的解空間複雜，不難容易窮舉完整。</p><p>　　備忘錄，DP table 就是在追求“如何聰明地窮舉”。用空間換時間的思路，是降低時間複雜度的不二法門。</p><p>　　動態規劃需要和回溯法搭配著使用，動態規劃只負責求最優解，而回溯法則可以找到最優值的路徑。</p><h3 class=pgc-h-arrow-right>5，回溯法</h3><p>　　回溯法是一種選優搜索法，按選優條件向前搜索，以達到目標。但當探索到某一步時，發現原先選擇並不優或達不到目標，就退回一步重新選擇，這種走不通就退回再走的技術為回溯法，而滿足回溯條件的某個狀態的點稱為 “回溯點”。許多複雜的，規模較大的問題都可以使用回溯法，有“通用解題方法”的美稱。回溯法有“通用的解題法”之稱，也叫試探法，它是一種系統的搜索問題的解的方法。簡單來說，回溯法採用試錯的方法解決問題，一旦發現當前步驟失敗，回溯方法就返回上一個步驟，選擇另一種方案繼續試錯。</p><h4 class=pgc-h-arrow-right>5.1 回溯法的基本思想</h4><p>　　從一條路往前走，能進則進，不能進則退回來，換一條路再試。</p><h4 class=pgc-h-arrow-right>5.2 回溯法的一般步驟</h4><p>1，定義一個解空間（子集樹，排序樹二選一）</p><p>2，利用適用於搜索的方法組織解空間</p><p>3，利用深度優先法搜索解空間</p><p>4，利用剪枝函數避免移動到不可能產生解的子空間</p><h4 class=pgc-h-arrow-right>5.3 回溯法針對問題的特點</h4><p>　　回溯算法針對的大多數問題有以下特點：問題的答案有多個元素（可向下成走迷宮是有多個決定），答案需要一些約束（比如數獨），尋找答案的方式在每一個步驟相同。回溯算法逐步構建答案，並在確定候選元素不滿足約束後立刻放棄候選元素（一旦碰牆就返回），直到找到答案的所有元素。　　</p><h4 class=pgc-h-arrow-right>5.4回溯法題目——查找單詞</h4><p>　　問題描述：你玩過報紙上那種查找單詞的遊戲嗎？就是那種在一堆字母中橫向或豎向找出單詞的遊戲。小明在玩一個和那個很像的遊戲，只不過現在不僅可以上下左右連接字母，還可以拐彎。如圖所示，輸入world，就會輸出“找到了”。</p><div class=pgc-img><img alt="Python常用算法學習(7) 動態規劃，回溯法（原理+代碼）-最全總結" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/253ae6f8229649a9813a869de1646701><p class=pgc-img-caption></p></div><p><br></p><h4 class=pgc-h-arrow-right>5.5 回溯法題目——遍歷所有的排列方式</h4><p>　　問題描述：小米最近有四本想讀的書：《紅色的北京》，《黃色的巴黎》，《藍色的夏威夷》，《綠色的哈薩里》，如果小明每次只能從圖書館借一本書，他一共有多少種借書的順序呢？</p><p>　　回溯法是一種通過探索所有可能的候選解來找出所欲的解的算法。如果候選解被確認，不是一個解的話（或者至少不是最後一個解），回溯算法會通過在上一步進行一些變換排期該解。即回溯並且再次嘗試。</p><p>　　這裡有一個回溯函數，使用第一個整數的索引作為參數 backtrack(first)。</p><p>1，如果第一個整數有索引 n，意味著當前排列已完成。</p><p>2，遍歷索引 first 到索引 n-1 的所有整數 ，則：</p><ul><li>在排列中放置第 i 個整數，即 swap(nums[first], nums[i])</li><li>繼續生成從第 i 個整數開始的所有排列：backtrack(first +1)</li><li>現在回溯，通過 swap(nums[first], nums[i]) 還原。</li></ul><p>　　代碼如下：</p><p><br></p><pre><code>class Solution:    def permute(self, nums):        """        :type nums: List[int]        :rtype: List[List[int]]        """        def backtrack(first = 0):            # if all integers are used up            if first == n:                 output.append(nums[:])            for i in range(first, n):                # place i-th integer first                # in the current permutation                nums[first], nums[i] = nums[i], nums[first]                # use next integers to complete the permutations                backtrack(first + 1)                # backtrack                nums[first], nums[i] = nums[i], nums[first]                 n = len(nums)        output = []        backtrack()        return output</code></pre><p>　　便於理解的代碼如下：</p><p><br></p><pre><code>class solution:    def solvepermutation(self, array):        self.helper(array, [])     def helper(self, array, solution):        if len(array) == 0:            print(solution)            return        for i in range(len(array)):            newarray = array[:i] + array[i + 1:]  # 刪除書本            newsolution = solution + [array[i]]  # 加入新書            self.helper(newarray, newsolution)  # 尋找剩餘對象的排列組合  solution().solvepermutation(["紅", "黃", "藍", "綠"])</code></pre><p>　　方法二：走捷徑（直接使用Python的庫函數，迭代函數itertools）</p><pre><code>li = ['A', 'B', 'C', 'D']def solutoin(li):    import itertools    res = list(itertools.permutations(li))    return len(res)</code></pre><p>　　</p><h4 class=pgc-h-arrow-right>5.6 回溯法問題——經典問題的組合</h4><p>　　問題描述：小明想上兩門選修課，他有四種選擇：A微積分，B音樂，C烹飪，D設計，小明一共有多少種不同的選課組合？</p><p>　　當然第一個方法就是走捷徑！，直接使用python的庫函數itertools進行迭代：</p><pre><code>li = ['A', 'B', 'C', 'D']def solutoin(li):    import itertools    res = list(itertools.permutations(li, 2))    return len(res)</code></pre><p>　　下面開始回溯法的學習。</p><pre><code>class solution():    def solvecombination(self, array, n):        self.helper(array, n, [])     def helper(self, array, n, solution):        if len(solution) == n:            print(solution)            return        for i in range(len(array)):            newarray = array[i + 1:]  # 創建新的課程列表，更新列表，即選過的課程不能再選            newsolution = solution + [array[i]]  # 將科目加入新的列表組合            self.helper(newarray, n, newsolution)  solution().solvecombination(["A", "B", "C", "D"], 2)</code></pre><p>　　</p><h4 class=pgc-h-arrow-right>5.7 回溯法問題——八皇后問題</h4><p>　　問題描述：保安負責人小安面臨一個難題，他需要在一個8x8公里的區域裡修建8個保安站點，並確保每一行、每一列和每一條斜線上都只有一個保安站點。苦惱的小安試著嘗試佈置了很多遍，但每一次都不符合要求。小安求助程序員小明，沒過多久小明就把好幾個佈置方案（實際上，這個問題有92種答案）發給了小安，其中包括下面執行結果截圖，試問小明是怎麼做到的。</p><p></p><h3 class=pgc-h-arrow-right>6，算法綜合作業</h3><p>　　這是所有的算法學完後的綜合作業，當然這也是算法學習的一個總結。當然下面的問題我都有涉及，這裡不做一一解答。</p><p>1. 實現以下算法並且編寫解題報告，解題報告中需要給出題目說明、自己對</p><p>題目的理解、解題思路、對算法的說明和理解、以及算法複雜度分析等內容</p><p></p><p>2. 實現冒泡排序、插入排序、快速排序和歸併排序</p><p></p><p>3. 以儘可能多的方法解決2-sum問題並分析其時間複雜度：給定一個列表和</p><p>一個整數，從列表中找到兩個數，使得兩數之和等於給定的數，返回兩個數</p><p>的下標。題目保證有且只有一組解</p><p></p><p>4. 封裝一個雙鏈表類，並實現雙鏈表的創建、查找、插入和刪除</p><p></p><p>5. 使用至少一種算法解決迷宮尋路問題</p><p></p><p>6. 使用動態規劃算法實現最長公共子序列問題</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Python</a></li><li><a>學習</a></li><li><a>動態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html alt="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html title="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結">Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2753abe.html alt="Python學習第169課 —— Linux文件管理系統簡介" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/9ceab887-eb3f-4d3e-a202-f08f4acd2088 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2753abe.html title="Python學習第169課 —— Linux文件管理系統簡介">Python學習第169課 —— Linux文件管理系統簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f69ae29.html alt="Python 3 學習筆記：Excel 基礎操作（二）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a777a023a91a465fb317de8de7e4cd37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f69ae29.html title="Python 3 學習筆記：Excel 基礎操作（二）">Python 3 學習筆記：Excel 基礎操作（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c5098fa8.html alt=Python學習教程：Python中的基本函數及其常用用法簡析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/53d3db07382b4f6ca1c58c2b6c0ef064 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c5098fa8.html title=Python學習教程：Python中的基本函數及其常用用法簡析>Python學習教程：Python中的基本函數及其常用用法簡析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6c47495.html alt=Python基礎學習筆記（十二）文件和目錄 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/500b368c28be42739bf6ff5a5c022567 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6c47495.html title=Python基礎學習筆記（十二）文件和目錄>Python基礎學習筆記（十二）文件和目錄</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/57639995.html alt=學習Python--10（猜數字遊戲） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d2e53ac4-ee01-46b6-9641-096595806ab0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/57639995.html title=學習Python--10（猜數字遊戲）>學習Python--10（猜數字遊戲）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ec0731.html alt=Python學習第130課--蒙特卡洛模擬隨機遊走 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/553af459389e4707afb594906157e7ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ec0731.html title=Python學習第130課--蒙特卡洛模擬隨機遊走>Python學習第130課--蒙特卡洛模擬隨機遊走</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cf6eb3.html alt="學習Python語言（第八章 異常處理1 增強開發效率和容錯性）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9a2a5486919b4ed59cc79eb13875e1d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cf6eb3.html title="學習Python語言（第八章 異常處理1 增強開發效率和容錯性）">學習Python語言（第八章 異常處理1 增強開發效率和容錯性）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd57795.html alt="Python 的動態類型系統" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/541fc98f656c4bb9bf4d37b3f2de3232 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd57795.html title="Python 的動態類型系統">Python 的動態類型系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html alt=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13adbab9c7f94c7fa81d49a98861b051 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html title=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式>機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e214e6d7.html alt=深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1540372101455de0fb74774 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e214e6d7.html title=深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開>深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3767255.html alt=講透機器學習中的梯度下降 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5c80301e53424671bc22755be2e4ee33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3767255.html title=講透機器學習中的梯度下降>講透機器學習中的梯度下降</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html alt=動態網站和靜態網站有什麼區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6a06f21d115b4b93a7934a7075691503 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html title=動態網站和靜態網站有什麼區別>動態網站和靜態網站有什麼區別</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>