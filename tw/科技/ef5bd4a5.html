<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ | 极客快訊</title><meta property="og:title" content="從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1. 前言</h1><p>ThreadLocal 也是一個使用頻率較高的類，在框架中也經常見到，比如 Spring。</p><p>有關 ThreadLocal 源碼分析的文章不少，其中有個問題常被提及：ThreadLocal 是否存在內存洩漏？</p><p>不少文章對此講述比較模糊，經常讓人看完腦子還是一頭霧水，我也有此困惑。因此找時間跟小夥伴討論了一番，總算對這個問題有了一定的理解，這裡記錄和分享一下，希望對有同樣困惑的朋友們有所幫助。當然，若有理解不當的地方也歡迎指正。</p><p>囉嗦就到這裡，下面先從 ThreadLocal 的一個應用場景開始分析吧。</p><h1 class=pgc-h-arrow-right><strong>2. 應用場景</strong></h1><p>ThreadLocal 的應用場景不少，這裡舉個簡單的例子：單點登錄攔截。</p><p>也就是在處理一個 HTTP 請求之前，判斷用戶是否登錄：</p><ul><li>若未登錄，跳轉到登錄頁面；</li><li>若已登錄，獲取並保存用戶的登錄信息。</li></ul><p>先定義一個 UserInfoHolder 類保存用戶的登錄信息，其內部用 ThreadLocal 存儲，示例如下：</p><pre><code>public class UserInfoHolder {    private static final ThreadLocal&lt;Map&lt;String, String&gt;&gt; USER_INFO_THREAD_LOCAL = new ThreadLocal&lt;&gt;();    public static void set(Map&lt;String, String&gt; map) {        USER_INFO_THREAD_LOCAL.set(map);    }        public static Map&lt;String, String&gt; get() {        return USER_INFO_THREAD_LOCAL.get();    }        public static void clear() {        USER_INFO_THREAD_LOCAL.remove();    }        // ...}</code></pre><p>通過 UserInfoHolder 可以存儲和獲取用戶的登錄信息，以便在業務中使用。</p><p>Spring 項目中，如果我們想在處理一個 HTTP 請求之前或之後做些額外的處理，通常定義一個類繼承 HandlerInterceptorAdapter，然後重寫它的一些方法。舉例如下（僅供參考，省略了一些代碼）：</p><pre><code>public class LoginInterceptor extends HandlerInterceptorAdapter {    // ...        @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {                // ...        // 請求執行前，獲取用戶登錄信息並保存        Map&lt;String, String&gt; userInfoMap = getUserInfo();        UserInfoHolder.set(userInfoMap);        return true;    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        // 請求執行後，清理掉用戶信息        UserInfoHolder.clear();    }}</code></pre><p>在本例中，我們在處理一個請求之前獲取用戶的信息，在處理完請求之後，將用戶信息清空。應該有朋友在框架或者自己的項目中見過類似代碼。</p><p>下面我們深入 ThreadLocal 的內部，來分析這些方法做了些什麼，跟內存洩漏又是怎麼扯上關係的。</p><h1 class=pgc-h-arrow-right><strong>3. 源碼剖析</strong></h1><h1 class=pgc-h-arrow-right>3.1 類簽名</h1><p>先從頭開始，也就是類簽名：</p><pre><code>public class ThreadLocal&lt;T&gt; {}</code></pre><p>可見它就是一個普通的類，並沒有實現任何接口、也無父類繼承。</p><h1 class=pgc-h-arrow-right>3.2 構造器</h1><p>ThreadLocal 只有一個無參構造器：</p><pre><code>public ThreadLocal() {}</code></pre><p>此外，JDK 1.8 引入了一個使用 lambda 表達式初始化的靜態方法 withInitial，如下：</p><pre><code>public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {    return new SuppliedThreadLocal&lt;&gt;(supplier);}</code></pre><p>該方法也可以初始化一個對象，和構造器也比較接近。</p><h1 class=pgc-h-arrow-right>3.3 ThreadLocalMap</h1><h1 class=pgc-h-arrow-right>3.3.1 主要代碼</h1><p>ThreadLocalMap 是 ThreadLocal 的一個內部嵌套類。</p><p>由於 ThreadLocal 的主要操作實際都是通過 ThreadLocalMap 的方法實現的，因此先分析 ThreadLocalMap 的主要代碼：</p><pre><code>public class ThreadLocal&lt;T&gt; {    // 生成 ThreadLocal 的哈希碼，用於計算在 Entry 數組中的位置    private final int threadLocalHashCode = nextHashCode();    private static final int HASH_INCREMENT = 0x61c88647;    private static int nextHashCode() {        return nextHashCode.getAndAdd(HASH_INCREMENT);    }    // ...        static class ThreadLocalMap {        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {            Object value;            Entry(ThreadLocal&lt;?&gt; k, Object v) {                super(k);                value = v;            }        }            // 初始容量，必須是 2 的次冪        private static final int INITIAL_CAPACITY = 16;            // 存儲數據的數組        private Entry[] table;        // table 中的 Entry 數量        private int size = 0;        // 擴容的閾值        private int threshold; // Default to 0            // 設置擴容閾值        private void setThreshold(int len) {            threshold = len * 2 / 3;        }                // 第一次添加元素使用的構造器        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {            table = new Entry[INITIAL_CAPACITY];            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);            table[i] = new Entry(firstKey, firstValue);            size = 1;            setThreshold(INITIAL_CAPACITY);        }                // ...    }}</code></pre><p>ThreadLocalMap 的內部結構其實跟 HashMap 很類似，可以對比前面「JDK源碼分析-HashMap(1)」對 HashMap 的分析。</p><p>二者都是「鍵-值對」構成的數組，對哈希衝突的處理方式不同，導致了它們在結構上產生了一些區別：</p><ol start=1><li>HashMap 處理哈希衝突使用的「鏈表法」。也就是當產生衝突時拉出一個鏈表，而且 JDK 1.8 進一步引入了紅黑樹進行優化。</li><li>ThreadLocalMap 則使用了「開放尋址法」中的「線性探測」。即，當某個位置出現衝突時，從當前位置往後查找，直到找到一個空閒位置。</li></ol><p>其它部分大體是類似的。</p><h1 class=pgc-h-arrow-right>3.3.2 注意事項</h1><ul><li>弱引用</li></ul><p>有個值得注意的地方是：ThreadLocalMap 的 Entry 繼承了 WeakReference 類，也就是弱引用類型。</p><p>跟進 Entry 的父類，可以看到 ThreadLocal 最終賦值給了 WeakReference 的父類 Reference 的 referent 屬性。即，可以認為 Entry 持有了兩個對象的引用：ThreadLocal 類型的「弱引用」和 Object 類型的「強引用」，其中 ThreadLocal 為 key，Object 為 value。如圖所示：</p><div class=pgc-img><img alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c><p class=pgc-img-caption></p></div><p>ThreadLocal 在某些情況可能產生的「內存洩漏」就跟這個「弱引用」有關，後面再展開分析。</p><ul><li>尋址</li></ul><p>Entry 的 key 是 ThreadLocal 類型的，它是如何在數組中散列的呢？</p><p>ThreadLocal 有個 threadLocalHashCode 變量，每次創建 ThreadLocal 對象時，這個變量都會增加一個固定的值 HASH_INCREMENT，即 0x61c88647，這個數字似乎跟黃金分割、斐波那契數有關，但這不是重點，有興趣的朋友可以去深入研究下，這裡我們知道它的目的就行了。與 HashMap 的 hash 算法的目的近似，就是為了散列的更均勻。</p><p>下面分析 ThreadLocal 的主要方法實現。</p><h1 class=pgc-h-arrow-right>3.4 主要方法</h1><p>ThreadLocal 主要有三個方法：set、get 和 remove，下面分別介紹。</p><h1 class=pgc-h-arrow-right>3.4.1 set 方法</h1><ul><li>set 方法：新增/更新 Entry</li></ul><pre><code>public void set(T value) {    // 獲取當前線程    Thread t = Thread.currentThread();    // 從 Thread 中獲取 ThreadLocalMap    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);}ThreadLocalMap getMap(Thread t) {    return t.threadLocals;}</code></pre><p>threadLocals 是 Thread 持有的一個 ThreadLocalMap 引用，默認是 null：</p><pre><code>public class Thread implements Runnable {    // 其他代碼...    ThreadLocal.ThreadLocalMap threadLocals = null;}</code></pre><ul><li>執行流程</li></ul><p>若從當前 Thread 拿到的 ThreadLocalMap 為何，表示該屬性並未初始化，執行 createMap 初始化：</p><pre><code>void createMap(Thread t, T firstValue) {    t.threadLocals = new ThreadLocalMap(this, firstValue);}</code></pre><p>若已存在，則調用 ThreadLocalMap 的 set 方法：</p><pre><code>private void set(ThreadLocal&lt;?&gt; key, Object value) {        Entry[] tab = table;    int len = tab.length;    // 1. 計算 key 在數組中的下標 i    int i = key.threadLocalHashCode &amp; (len-1);        // 1.1 若數組下標為 i 的位置有元素    // 判斷 i 位置的 Entry 是否為空；不為空則從 i 開始向後遍歷數組    for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) {        ThreadLocal&lt;?&gt; k = e.get();                // 索引為 i 的元素就是要查找的元素，用新值覆蓋舊值，到此返回        if (k == key) {            e.value = value;            return;        }                // 索引為 i 的元素並非要查找的元素，且該位置中 Entry 的 Key 已經是 null        // Key 為 null 表明該 Entry 已經過期了，此時用新值來替換這個位置的過期值        if (k == null) {            // 替換過期的 Entry，            replaceStaleEntry(key, value, i);            return;        }    }        // 1.2 若數組下標為 i 的位置為空，將要存儲的元素放到 i 的位置    tab[i] = new Entry(key, value);    int sz = ++size;    // 若未清理過期的 Entry，且數組的大小達到閾值，執行 rehash 操作    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)        rehash();}</code></pre><p>先總結下 set 方法主要流程：</p><p>首先根據 key 的 threadLocalHashCode 計算它的數組下標：</p><ol start=1><li>如果數組下標的 Entry 不為空，表示該位置已經有元素。由於可能存在哈希衝突，因此這個位置的元素可能並不是要找的元素，所以遍歷數組去比較</li><ol start=1><li>如果找到等於當前 key 的 Entry，則用新值替換舊值，返回。</li><li>如果遍歷過程中，遇到 Entry 不為空、但是 Entry 的 key 為空的情況，則會做一些清理工作。</li></ol><li>如果數組下標的 Entry 為空，直接將元素放到這裡，必要時進行擴容。</li></ol><ul><li>replaceStaleEntry：替換過期的值，並清理一些過期的 Entry</li></ul><pre><code>private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,                               int staleSlot) {    Entry[] tab = table;    int len = tab.length;    Entry e;        // 從 staleSlot 開始向前遍歷，若遇到過期的槽（Entry 的 key 為空），更新 slotToExpunge    // 直到 Entry 為空停止遍歷    int slotToExpunge = staleSlot;    for (int i = prevIndex(staleSlot, len);         (e = tab[i]) != null;         i = prevIndex(i, len))        if (e.get() == null)            slotToExpunge = i;        // 從 staleSlot 開始向後遍歷，若遇到與當前 key 相等的 Entry，更新舊值，並將二者換位置    // 目的是把它放到「應該」在的位置    for (int i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) {        ThreadLocal&lt;?&gt; k = e.get();                if (k == key) {            // 更新舊值            e.value = value;                        // 換位置            tab[i] = tab[staleSlot];            tab[staleSlot] = e;                        // Start expunge at preceding stale entry if it exists            if (slotToExpunge == staleSlot)                slotToExpunge = i;            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);            return;        }                if (k == null &amp;&amp; slotToExpunge == staleSlot)            slotToExpunge = i;    }        // If key not found, put new entry in stale slot    // 若未找到 key，說明 Entry 此前並不存在，新增    tab[staleSlot].value = null;    tab[staleSlot] = new Entry(key, value);        // If there are any other stale entries in run, expunge them    if (slotToExpunge != staleSlot)        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);}</code></pre><p>replaceStaleEntry 的主要執行流程如下：</p><ol start=1><li>從 staleSlot 向前遍歷數組，直到 Entry 為空時停止遍歷。這一步的主要目的是查找 staleSlot 前面過期的 Entry 的數組下標 slotToExpunge。</li><li>從 staleSlot 向後遍歷數組</li><ol start=1><li>若 Entry 的 key 與給定的 key 相等，將該 Entry 與 staleSlot 下標的 Entry 互換位置。目的是為了讓新增的 Entry 放到它「應該」在的位置。</li><li>若找不到相等的 key，說明該 key 對應的 Entry 不在數組中，將新值放到 staleSlot 位置。該操作其實就是處理哈希衝突的「線性探測」方法：當某個位置已被佔用，向後探測下一個位置。</li></ol><li>若 staleSlot 前面存在過期的 Entry，則執行清理操作。</li></ol><blockquote><p>PS: 所謂 Entry「應該」在的位置，就是根據 key 的 threadLocalHashCode 與數組長度取餘計算出來的位置，即 k.threadLocalHashCode & (len - 1) ，或者哈希衝突之後的位置，這裡只是為了方便描述。</p></blockquote><ul><li>expungeStaleEntry：清理過期的 Entry</li></ul><pre><code>// staleSlot 表示過期的槽位（即 Entry 數組的下標）private int expungeStaleEntry(int staleSlot) {    Entry[] tab = table;    int len = tab.length;        // 1. 將給定位置的 Entry 置為 null    tab[staleSlot].value = null;    tab[staleSlot] = null;    size--;        // Rehash until we encounter null    Entry e;    int i;    // 遍歷數組    for (i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) {        // 獲取 Entry 的 key        ThreadLocal&lt;?&gt; k = e.get();        if (k == null) {            // 若 key 為 null，表示 Entry 過期，將 Entry 置空            e.value = null;            tab[i] = null;            size--;        } else {            // key 不為空，表示 Entry 未過期            // 計算 key 的位置，若 Entry 不在它「應該」在的位置，把它移到「應該」在的位置            int h = k.threadLocalHashCode &amp; (len - 1);            if (h != i) {                tab[i] = null;                // Unlike Knuth 6.4 Algorithm R, we must scan until                // null because multiple entries could have been stale.                while (tab[h] != null)                    h = nextIndex(h, len);                tab[h] = e;            }        }    }    return i;}</code></pre><p>該方法主要做了哪些工作呢？</p><ol start=1><li>清空給定位置的 Entry</li><li>從給定位置的下一個開始向後遍歷數組</li><ol start=1><li>若遇到 Entry 為 null，結束遍歷</li><li>若遇到 key 為空的 Entry（即過期的），就將該 Entry 置空</li><li>若遇到 key 不為空的 Entry，而且經過計算，該 Entry 並不在它「應該」在的位置，則將其移動到它「應該」在的位置</li></ol><li>返回 staleSlot 後面的、Entry 為 null 的索引下標</li></ol><ul><li>cleanSomeSlots：清理一些槽（Slot）</li></ul><pre><code>private boolean cleanSomeSlots(int i, int n) {    boolean removed = false;    Entry[] tab = table;    int len = tab.length;    do {        i = nextIndex(i, len);        Entry e = tab[i];        // Entry 不為空、key 為空，即 Entry 過期        if (e != null &amp;&amp; e.get() == null) {            n = len;            removed = true;            // 清理 i 後面連續過期的 Entry，直到 Entry 為 null，返回該 Entry 的下標            i = expungeStaleEntry(i);        }    } while ( (n &gt;&gt;&gt;= 1) != 0);    return removed;}</code></pre><p>該方法做了什麼呢？從給定位置的下一個開始掃描數組，若遇到 key 為空的 Entry（過期的），則清理該位置及其後面過期的槽。</p><p>值得注意的是，該方法循環執行的次數為 log(n)。由於該方法是在 set 方法內部被調用的，也就是新增/更新時：</p><ol start=1><li>如果不掃描和清理，set 方法執行速度很快，但是會存在一些垃圾（過期的 Entry）；</li><li>如果每次都掃描清理，不會存在垃圾，但是插入性能會降低到 O(n)。</li></ol><p>因此，這個次數其實就一種平衡策略：Entry 數組較小時，就少清理幾次；數組較大時，就多清理幾次。</p><ul><li>rehash：調整 Entry 數組</li></ul><pre><code>private void rehash() {    // 清理數組中過期的 Entry    expungeStaleEntries();    // Use lower threshold for doubling to avoid hysteresis    if (size &gt;= threshold - threshold / 4)        resize();}// 從頭開始清理整個 Entry 數組private void expungeStaleEntries() {    Entry[] tab = table;    int len = tab.length;    for (int j = 0; j &lt; len; j++) {        Entry e = tab[j];        if (e != null &amp;&amp; e.get() == null)            expungeStaleEntry(j);    }}</code></pre><p>該方法主要作用：</p><ol start=1><li>清理數組中過期的 Entry</li><li>若清理後 Entry 的數量大於等於 threshold 的 3/4，則執行 resize 方法進行擴容</li></ol><ul><li>resize 方法：Entry 數組擴容</li></ul><pre><code>/** * Double the capacity of the table. */private void resize() {    Entry[] oldTab = table;    int oldLen = oldTab.length;    int newLen = oldLen * 2; // 新長度為舊長度的兩倍    Entry[] newTab = new Entry[newLen];    int count = 0;        // 遍歷舊的 Entry 數組，將數組中的值移到新數組中    for (int j = 0; j &lt; oldLen; ++j) {        Entry e = oldTab[j];        if (e != null) {            ThreadLocal&lt;?&gt; k = e.get();            // 若 Entry 的 key 已過期，則將 Entry 清理掉            if (k == null) {                e.value = null; // Help the GC            } else {                // 計算在新數組中的位置                int h = k.threadLocalHashCode &amp; (newLen - 1);                // 哈希衝突，線性探測下一個位置                while (newTab[h] != null)                    h = nextIndex(h, newLen);                newTab[h] = e;                count++;            }        }    }        // 設置新的閾值    setThreshold(newLen);    size = count;    table = newTab;}</code></pre><p>該方法的作用是 Entry 數組擴容，主要流程：</p><ol start=1><li>創建一個新數組，長度為原數組的 2 倍；</li><li>從下標 0 開始遍歷舊數組的所有元素</li><ol start=1><li>若元素已過期（key 為空），則將 value 也置空</li><li>將未過期的元素移到新數組</li></ol></ol><h1 class=pgc-h-arrow-right>3.4.2 get 方法</h1><p>分析完了 set 方法，再看 get 方法就相對容易了不少。</p><ul><li>get 方法：獲取 ThreadLocal 對應的 Entry</li></ul><pre><code>public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) {            @SuppressWarnings("unchecked")            T result = (T)e.value;            return result;        }    }    return setInitialValue();}</code></pre><p>get 方法首先獲取當前線程的 ThreadLocalMap 並判斷：</p><ol start=1><li>若 Map 已存在，從 Map 中取值</li><li>若 Map 不存在，或者 Map 中獲取的值為空，執行 setInitialValue 方法</li></ol><ul><li>setInitialValue 方法：獲取/設置初始值</li></ul><pre><code>private T setInitialValue() {    // 獲取初始值    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);    return value;}protected T initialValue() {    return null;}</code></pre><p>選取初始值，這個初始值默認為空（該方法是 protected，可以由子類初始化）。</p><ol start=1><li>若 Thread 的 ThreadLocalMap 已初始化，則將初始值存入 Map</li><li>否則，創建 ThreadLocalMap</li><li>返回初始值</li></ol><p>除了初始值，其他邏輯跟 set 方法是一樣的，這裡不再贅述。</p><blockquote><p>PS: 可以看到初始值是惰性初始化的。</p></blockquote><ul><li>getEntry：從 Entry 數組中獲取給定 key 對應的 Entry</li></ul><pre><code>private Entry getEntry(ThreadLocal&lt;?&gt; key) {    // 計算下標    int i = key.threadLocalHashCode &amp; (table.length - 1);    Entry e = table[i];    // 查找命中    if (e != null &amp;&amp; e.get() == key)        return e;    else        return getEntryAfterMiss(key, i, e);}// key 未命中private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {    Entry[] tab = table;    int len = tab.length;        // 遍歷數組    while (e != null) {        ThreadLocal&lt;?&gt; k = e.get();        if (k == key)            return e; // 是要找的 key，返回        if (k == null)            expungeStaleEntry(i); // Entry 已過期，清理 Entry        else            i = nextIndex(i, len); // 向後遍歷        e = tab[i];    }    return null;}</code></pre><h1 class=pgc-h-arrow-right>3.4.3 remove 方法</h1><ul><li>remove 方法：移除 ThreadLocal 對應的 Entry</li></ul><pre><code>public void remove() {    ThreadLocalMap m = getMap(Thread.currentThread());    if (m != null)        m.remove(this);}</code></pre><p>這裡調用了 ThreadLocalMap 的 remove 方法：</p><pre><code>private void remove(ThreadLocal&lt;?&gt; key) {    Entry[] tab = table;    int len = tab.length;    int i = key.threadLocalHashCode &amp; (len-1);    for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) {        if (e.get() == key) {            e.clear();            expungeStaleEntry(i);            return;        }    }}</code></pre><p>其中 e.clear 調用的是 Entry 的父類 Reference 的 clear 方法：</p><pre><code>public void clear() {    this.referent = null;}</code></pre><p>其實就是將 Entry 的 key 置空。</p><p>remove 方法的主要執行流程如下：</p><ol start=1><li>獲取當前線程的 ThreadLocalMap</li><li>以當前 ThreadLocal 作為 key，從 Map 中查找相應的 Entry，將 Entry 的 key 置空</li><li>將該 ThreadLocal 對應的 Entry 置空，並向後遍歷清理 Entry 數組，也就是 expungeStaleEntry 方法的操作，前面已經分析過了，這裡不再贅述。</li></ol><h1 class=pgc-h-arrow-right>3.4.4 主要方法小結</h1><p>ThreadLocal 的主要方法 set、get 和 remove 前面已經分析過，這裡簡單做個小結。</p><p><strong>set 方法</strong></p><ul><li>以當前 ThreadLocal 為 key、新增的 Object 為 value 組成一個 Entry，放入 ThreadLocalMap，也就是 Entry 數組中。</li><li>計算 Entry 的位置後</li><ul><li>若該槽為空，直接放到這裡；並清理一些過期的 Entry，必要時進行擴容。</li><li>當遇到散列衝突時，線性探測向後查找數組中為空的、或者已經過期的槽，用新值替換。</li></ul></ul><p><strong>get 方法</strong></p><ul><li>以當前 ThreadLocal 為 key，從 Entry 數組中查找對應 Entry 的 value</li><ul><li>若 ThreadLocalMap 未初始化，則用給定初始值將其初始化</li><li>若 ThreadLocalMap 已初始化，從 Entry 數據查找 key</li></ul></ul><p><strong>remove 方法</strong>：以當前 ThreadLocal 為 key，從 Entry 數組清理掉對應的 Entry，並且在清理該位置後面的、過期的 Entry</p><p>方法雖少，但是稍微有點繞，除了做本身的功能，都執行了一些額外的清理操作。</p><p>分析了這幾個方法的源碼之後，下面就來研究一下內存洩漏的問題。</p><h1 class=pgc-h-arrow-right><strong>4. 內存洩漏分析</strong></h1><p>首先說明一點，ThreadLocal 通常作為成員變量或靜態變量來使用（也就是共享的），比如前面應用場景中的例子。因為局部變量已經在同一條線程內部了，沒必要使用 ThreadLocal。</p><p>為便於理解，這裡先給出了 Thread、ThreadLocal、ThreadLocalMap、Entry 這幾個類在 JVM 的內存示意圖：</p><div class=pgc-img><img alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dba5231875bc4d2ab20e9a14db35bfc8><p class=pgc-img-caption></p></div><p>簡單說明：</p><ul><li>當一個線程運行時，棧中存在當前 Thread 的棧幀，它持有 ThreadLocalMap 的強引用。</li><li>ThreadLocal 所在的類持有一個 ThreadLocal 的強引用；同時，ThreadLocalMap 中的 Entry 持有一個 ThreadLocal 的弱引用。</li></ul><h1 class=pgc-h-arrow-right>4.1 場景一</h1><p>若方法執行完畢、線程正常消亡，則 Thread 的 ThreadLocalMap 引用將斷開，如圖：</p><div class=pgc-img><img alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c67c517fbb87439a8773efe787506a13><p class=pgc-img-caption></p></div><p>以後 GC 發生時，弱引用也會斷開，整個 ThreadLocalMap 都會被回收掉，不存在內存洩漏。</p><h1 class=pgc-h-arrow-right>4.2 場景二</h1><p>如果是線程池中的線程呢？也就是線程一直存活。經過 GC 後 Entry 持有的 ThreadLocal 引用斷開，Entry 的 key 為空，value 不為空，如圖所示：</p><div class=pgc-img><img alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/979e33306e154bcf8a4b1523223ba434><p class=pgc-img-caption></p></div><p>此時，如果沒有任何 remove 或者 get 等清理 Entry 數組的動作，那麼該 Entry 的 value 持有的 Object 就不會被回收掉。這樣就產生了內存洩漏。</p><p>這種情況其實也很容易避免，使用完執行 remove 方法就行了。</p><h1 class=pgc-h-arrow-right><strong>5. 小結</strong></h1><p>本文分析了 ThreadLocal 的主要方法實現，並分析了它可能存在內存洩漏的場景。</p><ol start=1><li>ThreadLocal 主要用於當前線程從共享變量中保存一份「副本」，常用的一個場景就是單點登錄保存用戶的登錄信息。</li><li>ThreadLocal 將數據存儲在 ThreadLocalMap 中，ThreadLocalMap 是由 Entry 構成的數組，結構有點類似 HashMap。</li><li>ThreadLocal 使用不當可能會造成內存洩漏。避免內存洩漏的方法是在方法調用結束前執行 ThreadLocal 的 remove 方法。</li></ol></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>從源碼</a></li><li><a>ThreadLocal</a></li><li><a>內存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c9afde0.html alt="一起來談談ThreadLocal 原理吧！你需要了解！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/499a403f2b63464db8e3e12298c1a3e5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c9afde0.html title="一起來談談ThreadLocal 原理吧！你需要了解！">一起來談談ThreadLocal 原理吧！你需要了解！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html alt=多線程之ThreadLocal的那些事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/58bb67505b204eef816b6e3b75935246 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html title=多線程之ThreadLocal的那些事>多線程之ThreadLocal的那些事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4bac2fc4.html alt=這4種ThreadLocal你都知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02621283c0574fd79fbb6ff5ea971384 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4bac2fc4.html title=這4種ThreadLocal你都知道嗎？>這4種ThreadLocal你都知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html alt=內存屏障詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html title=內存屏障詳解>內存屏障詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html alt=C語言學習篇(3)-----內存編址和對齊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e039d89a145f4e258f5f6eb28d04809b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html title=C語言學習篇(3)-----內存編址和對齊>C語言學習篇(3)-----內存編址和對齊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html alt=內存按字節編址例題解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/87f6444a27d34916b6e72824f6e98572 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html title=內存按字節編址例題解析>內存按字節編址例題解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html alt="【歷史】內存的故事 (紀念DRAM量產50年)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RQUkuARBMJpAR2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html title="【歷史】內存的故事 (紀念DRAM量產50年)">【歷史】內存的故事 (紀念DRAM量產50年)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html alt=滲透測試——內存攻擊原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ae687b82fd824bafafb7c6792c260a98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html title=滲透測試——內存攻擊原理>滲透測試——內存攻擊原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html alt=內存容量如何計算，瞭解一些基礎知識，你就懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d9065c724be64660aee58a3257a23534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html title=內存容量如何計算，瞭解一些基礎知識，你就懂了！>內存容量如何計算，瞭解一些基礎知識，你就懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8820f792.html alt=內存降價了買多大容量夠用？超過這個數就浪費了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/951afe40804044ea85eb17c552656667 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8820f792.html title=內存降價了買多大容量夠用？超過這個數就浪費了>內存降價了買多大容量夠用？超過這個數就浪費了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d35198c.html alt=手機內存多少夠用64還是128？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/71eced4d7a2e4954ab09c431e7907bbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d35198c.html title=手機內存多少夠用64還是128？>手機內存多少夠用64還是128？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e839484.html alt=奇怪的知識增加了！電腦內存容量真的是越大越好嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a457a965c6064a45a93d273286d37f57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e839484.html title=奇怪的知識增加了！電腦內存容量真的是越大越好嗎？>奇怪的知識增加了！電腦內存容量真的是越大越好嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ce20ef2.html alt=計算機中，內存容量越大越有利於系統的運行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1027a7b9f31f4c8f8b0d0c46e51afdb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ce20ef2.html title=計算機中，內存容量越大越有利於系統的運行>計算機中，內存容量越大越有利於系統的運行</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>