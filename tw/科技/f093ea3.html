<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你還不明白多態實現原理，你都不好意思說自己是Java程序員 | 极客快訊</title><meta property="og:title" content="你還不明白多態實現原理，你都不好意思說自己是Java程序員 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/78ed0be9d0c34e4da9a1c3dca789c45a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><meta property="article:published_time" content="2020-10-29T20:58:49+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:49+08:00"><meta name=Keywords content><meta name=description content="你還不明白多態實現原理，你都不好意思說自己是Java程序員"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f093ea3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你還不明白多態實現原理，你都不好意思說自己是Java程序員</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p style=text-align:start>多態是Java語言重要的特性之一，它允許基類的指針或引用指向派生類的對象，而在具體訪問時實現方法的動態綁定。<strong>Java對於方法調用動態綁定的實現主要依賴於方法表，但通過引用調用（invokevitual）和接口引用調用（invokeinterface）的實現則有所不同。</strong></p><p style=text-align:start>Java多態實現原理的大致過程：首先是Java編譯器將Java源代碼編譯成class文件。在編譯過程中，會根據靜態類型將調用的符號引用寫到class文件中。在執行時，JVM根據class文件找到調用方法的符號引用，然後在靜態類型的方法表中找到偏移量，然後再根據this指針確定對象的實際類型，使用實際類型的方法表（偏移量跟靜態類型中的偏移量一樣是指 就是用的靜態類型中的偏移量，因為符號引用在靜態類型的方法表中找到的偏移量是同一個），如果在實際的方法中找到該方法（說明參數值對上了）則直接調用，否則認為沒有重寫父類的方法則按照繼承關係從下往上搜索來調用方法。</p><div class=pgc-img><img alt=你還不明白多態實現原理，你都不好意思說自己是Java程序員 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/78ed0be9d0c34e4da9a1c3dca789c45a><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><br></p><div class=pgc-img><img alt=你還不明白多態實現原理，你都不好意思說自己是Java程序員 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/543018348b9141fd936ce8da93f97f94><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=你還不明白多態實現原理，你都不好意思說自己是Java程序員 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8ab609c8ff548dab68a85cb17bb89a9><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>程序運行時，需要某個類是，類載入系統會將相應的class文件載入到JVM中，並在內部建立該類的 類型信息 （這個類型信息其實就是class文件在JVM中存儲的一種數據結構），包含java類定義的所有信息（方法代碼、類和成員變量、以及實現動態調用的核心 - 方法表 ）。這個類型信息存儲在方法區。</p><p style=text-align:start>注意：這個方法去中的類型信息跟在堆中存放的class對象是不同的。在方法區中，這個class的類型信息只有唯一的實例（所以是各個線程共享的內存區域），而在堆中可以有多個該class對象。可以通過堆中的class對象訪問到方法去中的類型信息（像Java的反射機制，通過class對象可以訪問到該類的所有信息）。</p><p style=text-align:start><strong>【重點】</strong></p><p style=text-align:start>方法表是實現動態調用的核心。上面講過方法表存放在方法區中的類型信息中。為了優化對象調用方法的速度，方法區的類型信息會增加一個指針，該指針指向一個記錄該類方法的方法表，方法表中的每一個項都是對應方法的指針。<br>這些方法中包括從父類繼承的所有方法以及自身重寫（override）的方法。</p><p style=text-align:start><strong>【拓展】</strong></p><p style=text-align:start>方法區：方法區和JAVA堆一樣，是各個線程共享的內存區域，用於存儲已被虛擬機加載的類信息、常量、靜態變量、即時編譯器編譯後的代碼等數據。<br>運行時常量池：它是方法區的一部分，Class文件中除了有類的版本、方法、字段等描述信息外，還有一項信息是常量池，用於存放編譯器生成的各種符號引用，這部分信息在類加載時進入方法區的運行時常量池中。<br>方法區的內存回收目標是針對常量池的回收及對類型的卸載。</p><h1 class=pgc-h-arrow-right>Java 的方法調用方式</h1><p style=text-align:start>Java 的方法調用有兩類，動態方法調用與靜態方法調用。</p><ul><li>靜態方法調用是指對於類的靜態方法的調用方式，是靜態綁定的</li><li>動態方法調用需要有方法調用所作用的對象，是動態綁定的。</li></ul><p style=text-align:start>類調用 (invokestatic) 是在編譯時就已經確定好具體調用方法的情況。</p><p style=text-align:start>實例調用 (invokevirtual)則是在調用的時候才確定具體的調用方法，這就是動態綁定，也是多態要解決的核心問題。</p><p style=text-align:start>JVM 的方法調用指令有四個，分別是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前兩個是靜態綁定，後兩個是動態綁定的。本文也可以說是對於JVM後兩種調用實現的考察。</p><p style=text-align:start><strong>方法表與方法調用</strong></p><p style=text-align:start>如有類定義 Person, Girl, Boy</p><pre><code>class Person {    public String toString() {        return "I'm a person.";    }    public void eat() {    }    public void speak() {    }}class Boy extends Person {    public String toString() {        return "I'm a boy";    }    public void speak() {    }    public void fight() {    }}class Girl extends Person {    public String toString() {        return "I'm a girl";    }    public void speak() {    }    public void sing() {    }}</code></pre><p style=text-align:start>當這三個類被載入到 Java 虛擬機之後，方法區中就包含了各自的類的信息。Girl 和 Boy 在方法區中的方法表可表示如下：</p><div class=pgc-img><img alt=你還不明白多態實現原理，你都不好意思說自己是Java程序員 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/19a87fb2b85f45e7891546b099d023c1><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>可以看到，Girl 和 Boy 的方法表包含繼承自 Object 的方法，繼承自直接父類 Person 的方法及各自新定義的方法。注意方法表條目指向的具體的方法地址，如 Girl 繼承自 Object 的方法中，只有 toString() 指向自己的實現（Girl 的方法代碼），其餘皆指向 Object 的方法代碼；其繼承自於 Person 的方法 eat() 和 speak() 分別指向 Person 的方法實現和本身的實現。</p><p style=text-align:start>如果子類改寫了父類的方法，那麼子類和父類的那些同名的方法共享一個方法表項。</p><p style=text-align:start>因此，方法表的偏移量總是固定的。所有繼承父類的子類的方法表中，其父類所定義的方法的偏移量也總是一個定值。<br>Person 或 Object中的任意一個方法，在它們的方法表和其子類 Girl 和 Boy 的方法表中的位置 (index) 是一樣的。這樣 JVM 在調用實例方法其實只需要指定調用方法表中的第幾個方法即可。</p><p style=text-align:start>如調用如下：</p><pre><code>class Party {    void happyHour() {        Person girl = new Girl();        girl.speak();    }}</code></pre><p style=text-align:start>當編譯 Party 類的時候，生成 girl.speak()的方法調用假設為： Invokevirtual #12</p><p style=text-align:start>設該調用代碼對應著 girl.speak(); #12 是 Party 類的常量池的索引。JVM 執行該調用指令的過程如下所示：</p><div class=pgc-img><img alt=你還不明白多態實現原理，你都不好意思說自己是Java程序員 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ba4a230cc1ac46868df8d45986b0e27f><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>（這裡有個錯誤，上圖為ClassReference常量池而非Party的常量池）<br><strong>【再次拓展】</strong></p><p style=text-align:start>常量池在邏輯上可以分成多個表，每個表包含一類的常量信息，本文只探討對於 Java 調用相關的常量池表。</p><p style=text-align:start>CONSTATNT_Method_info<strong>：</strong>類方法引用表；包含引用的任何類型方法的描述信息，主要包括類信息索引和名字類型索引。</p><p style=text-align:start>CONSTATNT_Class_info<strong>：</strong>類信息表；包含任何被引用的類或接口的 ‘符號引用’ ，每一個條目主要包含一個索引，指向&lt;u style="box-sizing: inherit;">CONSTA_Utf8_info&lt;/u>表，表示該類或接口的全限定名。</p><p style=text-align:start>CONSTATNT_NameAndType_info：名字類型表；包含引用的任意方法或字段的名稱和描述符信息在字符串常量中的索引。</p><p style=text-align:start>CONSTATNT_Utf8_info：字符串常量表； 該表包含該類所使用的所有字符串常量，比如代碼中的字符串引用、引用的類名、方法的名字、其他引用的類與方法的字符串描述等等。其餘常量池表中所涉及到的任何常量字符串都被索引至該表。</p><p style=text-align:start>可以看到，給定任意一個方法的索引，在常量池中找到對應的條目後，可以得到該方法的類索引（classindex）和名字類型索引 (nameandtypeindex), 進而得到該方法所屬的類型信息和名稱及描述符信息（參數，返回值等）——從而通過對方法的類型信息和名稱及描述符信息（參數，返回值等）來確定具體是調用哪一個方法。</p><p style=text-align:start><strong>JVM執行 &lt;u style="box-sizing: inherit;">Invokevirtual #12&lt;/u> 指令的過程：</strong></p><p style=text-align:start>（1）在常量池中找到方法調用的符號引用。 JVM 首先查看 Party（應為ClassReference常量池） 的常量池索引為 12 的條目 （此條目即指 - 查看常量池中的CONSTATNT_Method_info表，即類方法引用表），再 進一步查看常量池中的（CONSTANTClassinfo，CONSTANTNameAndTypeinfo ，CONSTANTUtf8info） 三個表。</p><p style=text-align:start>（2） 可得出要調用的方法是 Person 的 speak 方法， 查看 Person 的方法表，得出 speak 方法在該方法表中的偏移量 15，這就是該方法調用的直接引用。</p><p style=text-align:start>（3） 根據this指針得到具體的對象（即girl所指向位與堆中的對象）</p><p style=text-align:start>（4）根據對象得到該對象對應的方法表，根據偏移量15查看有無重寫（override）該方法，如果重寫，則可以直接調用（Girl的方法表的speak項指向自身的方法而非父類）；如果沒有重寫，則需要拿到按照繼承關係從下往上的基類（這裡是Person類）的方法表，同樣按照這個偏移量15查看有無該方法。</p><h1 class=pgc-h-arrow-right>最後</h1><p style=text-align:start>以上，是對Java多態實現原理翻閱兩篇博文後為便於理解而整理而出。<br>參考博文：<br>https://www.cnblogs.com/kaleidoscope/p/9790766.html<br>https://zhuanlan.zhihu.com/p/94086109<br>大家看完有什麼不懂的可以在下方留言討論.<br>謝謝你的觀看。<br>覺得文章對你有幫助的話記得關注我點個贊支持一下！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>還不</a></li><li><a>多態</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ae124314-674a-47ca-b794-c5b32a309a66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d5ee81.html title=Java多態的實現機制是什麼，看完你就知道（值得收藏）>Java多態的實現機制是什麼，看完你就知道（值得收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e27caade.html alt=python基礎知識，多態實例講解以及多態的作用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2506d9fe7f6641a6a12c35a35a9335db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e27caade.html title=python基礎知識，多態實例講解以及多態的作用>python基礎知識，多態實例講解以及多態的作用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/790fbad0.html alt=多態&動態綁定&方法匹配&方法綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533542565759f64e623e74 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/790fbad0.html title=多態&動態綁定&方法匹配&方法綁定>多態&動態綁定&方法匹配&方法綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html alt=多態的本質，java動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac000493fbc8532b5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html title=多態的本質，java動態綁定>多態的本質，java動態綁定</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>