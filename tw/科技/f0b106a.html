<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>雲原生下，如何實現高可用的MySQL？ | 极客快訊</title><meta property="og:title" content="雲原生下，如何實現高可用的MySQL？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e56da8dd35fa43e2963a165fd2d68830"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f0b106a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f0b106a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f0b106a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f0b106a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f0b106a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f0b106a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f0b106a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f0b106a.html><meta property="article:published_time" content="2020-10-29T21:06:50+08:00"><meta property="article:modified_time" content="2020-10-29T21:06:50+08:00"><meta name=Keywords content><meta name=description content="雲原生下，如何實現高可用的MySQL？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f0b106a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>雲原生下，如何實現高可用的MySQL？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e56da8dd35fa43e2963a165fd2d68830><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>前言</h1><p style=text-align:justify>MySQL 作為當前比較受歡迎的關係型數據庫(RDS)，在雲原生浪潮中仍然面臨諸多挑戰。如何用 Cloud Native 的設計原則，通過沙箱隔離、計算和數據的完全分離，實現低成本、可擴展、高可用的 Cloud RDS 方案?阿里雲數據庫團隊的姜杉彪(孟宇)同學將介紹一種雲原生分佈式 MySQL 高可用數據庫方案，分享其中的關鍵技術，並對雲原生場景下傳統數據庫的發展趨勢做簡要分析。</p><p style=text-align:justify>雲時代的到來，無論傳統行業還是互聯網行業，業務越來越多樣，迭代速度越來越快，使得整體數據量大幅提升。</p><p style=text-align:justify>近兩年，隨著 Docker + Kubernetes 等技術的興起，大家都將業務往容器化遷移，團隊的技術也在往雲原生方向演進。早期的 Kubernetes 著重解決 Stateless 和 Share Nothing 的應用部署場景，然而在如今愈發複雜的應用場景中經常會遇到有狀態保存的需求。</p><p style=text-align:justify>從 Kubernetes 1.9 開始，針對有狀態服務的資源類型 Statefulset 進入 GA，而且 Kubernetes 1.14 版本 Local Volume、CSI 等存儲功能也進入 GA 階段，Kubernetes 對有狀態服務的支持得到全面加強，這使得很多數據存儲型基礎中間件往 Kubernetes 遷移成為可能。</p><p style=text-align:justify>MySQL 作為當前比較受歡迎的開源關係型數據庫(RDS)，集可靠、易用、功能豐富、適用範圍廣等特點於一身，使其成為關係型數據庫的主要選擇。雖然備受關注，但 MySQL 在雲原生浪潮中卻也面臨著諸多挑戰。如何用 Cloud Native 的設計原則，通過沙箱隔離、計算和數據的完全分離，實現低成本、可擴展、高可用的 Cloud RDS 方案?</p><p style=text-align:justify>本文介紹一種雲原生分佈式 MySQL 高可用數據庫方案(下稱“SlightShift MySQL 高可用方案”)，並對雲原生場景下傳統數據庫的發展趨勢做簡要分析。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e85b621a6e85425996105d411e8885ee><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>一 需求&挑戰</h1><p style=text-align:justify>在考慮雲原生場景下的 MySQL 高可用架構時，主要有如下幾個方面的挑戰：</p><ul><li>故障轉移：主庫發生宕機時，集群能夠自動選主並快速轉移故障，且轉移前後數據一致。</li><li>敏捷彈性伸縮：基於副本的彈性橫向擴展，擴縮容過程不中斷業務訪問。</li><li>數據安全性：數據定時冷備/實時熱備，以便故障恢復和數據遷移。</li><li>數據強一致性：用作備份/只讀副本的Slave節點數據應該和主節點數據保持實時或半實時一致。</li></ul><h1 class=pgc-h-arrow-right>二 目標&關鍵考慮點</h1><p style=text-align:justify>SlightShift MySQL 高可用方案要達到的目標：</p><ul><li>SLA保障：一年內可接受最高 52.56 分鐘服務不可用(99.99%)。</li><li>故障轉移：主庫出現異常時主從切換耗時 &lt; 2min。</li><li>彈性擴展：從庫理論可無限擴展，擴展從庫耗時 &lt; 2min。</li><li>冷備恢復：MySQL集群出現不可恢復性問題時，從冷備恢復耗時 &lt; 10min。</li></ul><p style=text-align:justify>除以上目標外，在技術架構設計時還需重點考慮以下關鍵點：</p><ul><li>高可用</li><li>應用接入成本</li><li>資源佔用量</li><li>可擴展性</li><li>可維護性</li></ul><h1 class=pgc-h-arrow-right>三 架構設計</h1><p style=text-align:justify>該 MySQL 高可用方案使用一主多從的複製結構，主從數據複製採用半同步複製，保證了數據一致性和讀寫效率，理論上從庫可無限擴展。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/80b72f542813427b8020cd2ee0876f7e><p class=pgc-img-caption></p></div><p style=text-align:justify>在數據引擎上層添加了仲裁器，使用 Raft 分佈式一致性算法實現自動化選主和故障切換。</p><p style=text-align:justify>路由層使用 ProxySQL 作為 SQL 請求代理，能夠實現讀寫分離、負載均衡和動態配置探測。</p><p style=text-align:justify>監控告警方面，採用 Prometheus-Operator 方案實現整個 MySQL 高可用系統的資源監控告警。</p><p style=text-align:justify>運維管控方面，引入 Kubernetes Operator 的管控模型來實現 DB-Operator，能夠做到聲明式配置、集群狀態管理以及On Demand(按需創建)。另外，可以在 MySQL 控制檯上進行 MySQL 的基礎運維，例如：數據庫管理、表管理、SQL查詢，索引變更、配置變更、數據備份&恢復等。</p><h1 class=pgc-h-arrow-right>四 關鍵技術</h1><p style=text-align:justify><strong>狀態持久化</strong></p><p style=text-align:justify>容器技術誕生後，大家很快發現用它來封裝“無狀態應用”(Stateless Application)非常好用。但如果想要用容器運行“有狀態應用”，其困難程度就會直線上升。</p><p style=text-align:justify>對於 MySQL 等存儲型分佈式應用，它的多個實例之間往往有依賴關係，比如：主從關係、主備關係。各個實例往往都會在本地磁盤上保存一份數據，當實例被殺掉，即便重建出來，實例與數據之間的對應關係也已經丟失，從而導致應用失敗。</p><p style=text-align:justify>這種實例之間有不對等關係，以及實例對外部數據有依賴關係的應用，被稱為“有狀態應用”(Stateful Application)。</p><p style=text-align:justify>Kubernetes 集群中使用節點本地存儲資源的方式有 emptyDir、hostPath、Local PV 等幾種方式。其中，emptyDir 無法持久化數據，hostPath 方式需要手動管理卷的生命週期，運維壓力大。</p><p style=text-align:justify>因此在MySQL場景中，出於性能和運維成本考慮需要使用本地存儲，Local PV 是目前為止唯一的選擇。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/708f4002516048e18219332b04b32ecf><p class=pgc-img-caption></p></div><p style=text-align:justify>Local PV 利用機器上的磁盤來存放業務需要持久化的數據，和遠端存儲類似，Pod 的數據和生命週期是互相獨立的，即使業務 Pod 被刪除，數據也不會丟失。</p><p style=text-align:justify>同時，和遠端存儲相比，本地存儲可以避免網絡 IO 開銷，擁有更高的讀寫性能，所以分佈式文件系統和分佈式數據庫這類對 IO 要求很高的應用非常適合本地存儲。</p><p style=text-align:justify>不同於其他類型的存儲，Local PV 本地存儲強依賴於節點。換言之，在調度 Pod 的時候還要考慮到這些 Local PV 對容量和拓撲域的要求。</p><p style=text-align:justify>MySQL 在使用 Local PV 時，主要用到兩個特性：延遲綁定機制和 volume topology-aware scheduling。延遲綁定機制可以讓 PVC 的綁定推遲到有 MySQL Pod 使用它並且完成調度後，而 volume topology-aware scheduling 則可以讓 Kubernetes 的調度器知道卷的拓撲約束，也就是這個存儲卷只能在特定的區域或節點上使用(訪問)，讓調度器在調度 Pod 的時候必須考慮這一限制條件。</p><p style=text-align:justify>另外，MySQL 使用的 Local PV 還需通過 nodeAffinity 將 Pod 調度到正確的 Node 上。</p><p style=text-align:justify>下面展示了 MySQL 使用 Local PV 的簡單配置示例：</p><pre><code>--- apiVersion: storage.k8s.io/v1 kind: StorageClass metadata:   creationTimestamp: null   name: local-storage provisioner: kubernetes.io/no-provisioner reclaimPolicy: Delete --- apiVersion: v1 kind: PersistentVolumeClaim metadata:   annotations:     pv.kubernetes.io/bound-by-controller: "yes"   creationTimestamp: null   labels:     app: slightshift-mysql     mysql-node: "true"   name: data-slightshift-mysql-0 spec:   accessModes:   - ReadWriteOnce   resources:     requests:       storage: 10Gi   storageClassName: local-volume-storage   volumeName: mysqlha-local-pv-0 --- apiVersion: v1 kind: PersistentVolume metadata:   annotations:     helm.sh/hook: pre-install,pre-upgrade     helm.sh/resource-policy: keep     volume.alpha.kubernetes.io/node-affinity: '{ "requiredDuringSchedulingIgnoredDuringExecution":       { "nodeSelectorTerms": [ { "matchExpressions": [ { "key": "kubernetes.io/hostname",       "operator": "In", "values": ["yz2-worker004"] } ]} ]} }'   labels:     pv-label: slightshift-mysql-data-pv     type: local   name: slightshift-mysql-data-pv-0 spec:   accessModes:   - ReadWriteOnce   capacity:     storage: 500Gi   local:     path: /var/lib/ali/mysql   persistentVolumeReclaimPolicy: Retain   storageClassName: pxc-mysql-data </code></pre><p style=text-align:justify>以上是 Local PV 的基礎用法，而 MySQL 還需考慮節點的彈性伸縮，這就要求底層存儲也能夠隨著 MySQL 實例伸縮來動態配置。這裡提出兩種解決方案：</p><p style=text-align:justify>在 Kubernetes 集群中引入 LVM Manager，以 DaemonSet 形式運行，負責管理每個節點上的磁盤，彙報節點磁盤容量和剩餘容量、動態創建 PV 等;再引入 local storage scheduler 調度模塊，負責為使用本地存儲的 Pod 選擇合適(有足夠容量)的節點。</p><p style=text-align:justify>使用開源方案 OpenEBS：iSCSI 提供底層存儲功能，OpenEBS 管理 iSCSI(目前只支持PV的 ReadWriteOnce 訪問模式)。</p><p style=text-align:justify><strong>自動化選主</strong></p><p style=text-align:justify>SlightShift MySQL 高可用架構基於 Raft 強一致協議實現分佈式 MySQL 自動化選主。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c226a8b2dc943f8be0ee69fc905eebd><p class=pgc-img-caption></p></div><p style=text-align:justify>Raft 使用心跳來觸發選主，當 MySQL Server 啟動時狀態是 follower。當 server 從 leader 或者 candidate 接收到合法的RPC時，它會保持在 follower 狀態，leader 會發送週期性的心跳來表明自己是 leader。</p><p style=text-align:justify>當一個 follower 在 election timeout 時間內沒有接收到通信，那麼它會開始選主。</p><p style=text-align:justify>選主的步驟如下：</p><ul><li>增加 current term。</li><li>轉成 candidate 狀態。</li><li>選自己為主，然後把選主RPC並行地發送給其他的 server。</li><li>candidate 狀態會繼續保持，直到下述三種情況出現。</li></ul><p style=text-align:justify>candidate 會在下述三種情況下退出：</p><ul><li>server 本身成為 leader。</li><li>其他的 server 選為 leader。</li><li>一段時間後，沒有 server 成為 leader。</li></ul><p style=text-align:justify><strong>故障轉移</strong></p><p style=text-align:justify>在正常運行的主從複製環境中，故障轉移(Failover)模塊會監聽集群狀態，當 Master 發生故障時會自動觸發故障轉移。</p><p style=text-align:justify>故障轉移的第一步是自動化選主，自動化選主的邏輯在上面已介紹過;其次是數據一致性保障，需最大化保證 Dead Master的 數據被同步到 New Master。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d292367f27bd4723acb319a32eb97b4a><p class=pgc-img-caption></p></div><p style=text-align:justify>在將 Master 切換到 New Master 之前，部分 slave 可能還未接收到最新的 relay log events，故障轉移模塊也會從最新的 slave 自動識別差異的 relay log events，並 apply 差異的 event 到其他 slaves，以此保證所有 slave 的數據都是一致的。</p><p style=text-align:justify>關於代理層，ProxySQL 會實時探測 MySQL 實例的可讀寫配置，當 MySQL 實例的可讀寫配置發生變化時，ProxySQL 會自動調整MySQL 實例的讀寫分組配置，最終保證在 Failover 之後讀寫分離能正確運行。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5b67554f2c0e4ef39f3f1f9f28917614><p class=pgc-img-caption></p></div><p style=text-align:justify>SlightShift MySQL 自動故障轉移的步驟如下：</p><ul><li>HA-Manager 偵測到 Master Server 連接異常，啟動 Failover。</li><li>嘗試關閉 Dead Master 以避免腦裂(此步驟可選)。</li><li>獲取最新數據 slave 的 end_log_pos，並從 Dead Master 同步 bin-log，最終保證所有 slave 的 end_log_pos 一致。</li><li>使用 raft 分佈式算法選舉 New Master。</li><li>將 Master 切換到 New Master。</li><li>回調 ProxySQL 代碼服務，剔除 Dead Master 配置。</li><li>ProxySQL 網關檢測到各個 MySQL 實例的可讀寫配置變化，調整讀寫分離配置。</li><li>通知切換結果(郵件、釘釘群機器人)。</li></ul><p style=text-align:justify>SlightShift MySQL 能做到秒級故障轉移，5-10秒監測到主機故障，5-10秒 apply 差異 relay logs，然後註冊到新的 master，通常10-30秒即可 total downtime。另外，可在配置文件裡配置各個 slave 當選為 New Master 的優先級，這在多機房部署 MySQL 場景下很實用。</p><p style=text-align:justify><strong>故障自動恢復</strong></p><p style=text-align:justify>宕機的 Master 節點恢復時：</p><ul><li>如果恢復的節點重新創建 Mysql Pod 並加入集群，Sentinel 會配置新 Pod 為 Slave，通過獲取當前 Master Mysql 的 log file 和 Position 來實現新加入 Slave 的數據同步。</li><li>如果恢復的節點中 Mysql Pod 依然存在且可用，Sentinel 此時會發現2個 Label 為 master 的 Pod。Sentinel 會依然使用宕機期間選擇的新 Master，且把恢復的 Master 強制設置為Slave，並開啟只讀模式。</li></ul><p style=text-align:justify>宕機的 Slave 節點恢復時：</p><ul><li>如果恢復節點重新創建 Mysql Pod 並加入集群，Sentinel會配置新 Pod 為Slave，通過獲取當前 Master Mysql 的 log file 和 Position 來實現新加入 Slave 的數據同步。</li><li>如果恢復的節點中 Mysql Pod 依然存在且可用，調度器不會執行操作，proxysql-service 會監測到新加入的 Slave，並將其加入到 endpoints 列表。</li></ul><p style=text-align:justify><strong>狀態管理</strong></p><p style=text-align:justify>狀態管理並非新鮮話題，它為中心化系統分發一致的狀態，確保分佈式系統總是朝預期的狀態收斂，是中心化系統的基石之一 。</p><p style=text-align:justify>MySQL 服務由一個 Master 節點和多個從 Master 上異步複製數據的 Slave 節點組成，即一主多從複製模型。其中，Master 節點可用來處理用戶的讀寫請求，Slave 節點只能用來處理用戶的讀請求。</p><p style=text-align:justify>為了部署這樣的有狀態服務，除了 StatefulSet 之外，還需要使用許多其它類型的 k8s 資源對象，包括 ConfigMap、Headless Service、ClusterIP Service 等。正是它們間的相互配合，才能讓 MySQL 這樣的有狀態服務有條件運行在 k8s 之上。</p><p style=text-align:justify>在 MySQL 集群中，狀態轉移最常發生在 Master 發生故障，集群進行故障轉移期間。當 Master 發生故障宕機時會自動觸發選主邏輯，選主結束後會進行故障切換，直至 New Master 正常提供讀寫服務，故障轉移過程是需要時間的，在故障轉移過程中 MySQL 服務會處於不可寫狀態。</p><p style=text-align:justify>在故障轉移期間，Dead Master 實例會被 k8s 集群自動拉起，Dead Master 被拉起後會認為自己是合法的 Master，這樣會造成集群中同時存在兩個 Master，寫請求很可能會被隨機分配到兩個 Master 節點，從而造成腦裂問題。</p><p style=text-align:justify>為了解決這種場景下的腦裂問題，我們引入了 InitContainer 機制，再配合 Sentinel 就能很好的解決該問題。</p><p style=text-align:justify>InitContainer，顧名思義，在容器啟動的時候會先啟動一個或多個容器去完成一些前置性工作，如果有多個，Init Container將按照指定的順序依次執行，只有所有的 InitContainer 執行完後主容器才會啟動。</p><p style=text-align:justify>我們在每一個 MySQL 的實例中都加入了 InitContainer，在 Dead Master 被 k8s 自動拉起之後，InitContainer 會自動檢測集群中是否處於 Failover 階段，如果處於Failover 階段會進入 Sleep 輪詢狀態，直至 Failover 結束。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d947119f5b374d218d3d120fd2133b41><p class=pgc-img-caption></p></div><p style=text-align:justify>當 Failover 結束後，Sentinel 檢測到 Dead Master 被拉起，會自動將 Dead Master 設置為 New Master 的 Slave 節點，以此來完成一次完整的 Failover 過程，並避免集群出現腦裂問題。</p><p style=text-align:justify><strong>聲明式運維</strong></p><p style=text-align:justify>我們在使用 k8s 時，一般會通過 k8s 的 Resource 滿足應用管理的需求：</p><ul><li>通過 Deployment、StatefulSet 等 workload 部署服務。</li><li>通過 Service、Ingress 管理對服務的訪問。</li><li>通過 ConfigMap、Secrets 管理服務的配置。</li><li>etc.</li></ul><p style=text-align:justify>上述 Resource 表徵 User 的期望，kube-controller-mananger 中的 Controller 會監聽 Resource Events 並執行相應的動作，來實現 User 的期望。</p><p style=text-align:justify>這種操作方式給應用管理帶來了很大的便利，User 可以通過聲明式的方式管理應用，不用再關心如何使用傳統的 HTTP API、RPC 調用等。</p><p style=text-align:justify>Controller 會通過各種機制來確保實現 User 的期望，如通過不斷檢測 Object 的狀態來驅使 Object 當前狀態符合用戶期望，這種運維模式我們稱之為聲明式運維。</p><p style=text-align:justify>但如果僅僅使用 k8s 提供的基礎類型，對於 MySQL 這類複雜應用來說運維成本依然很高。如果能將聲明式運維的模式進行擴展延伸到 MySQL 應用，會極大程度降低 MySQL 應用的部署和運維成本。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ccd32817e13d410bbeb615af0c8fdcdb><p class=pgc-img-caption></p></div><p style=text-align:justify>為了解決這個問題，slightshift-mysql-operator 應運而生。</p><p style=text-align:justify>slightshift-mysql-operator 本質上是 Resource + Controller：</p><ul><li>Resource自定義資源(CRD, Custom Resource Definitions)，為 User 提供一種聲明式的方式描述對服務的期望。</li><li>Controller</li></ul><p style=text-align:justify>實現 Resource 中 User 的期望。</p><ul><li>slightshift-mysql-operator 通過組合 k8s 中已有的概念，極大降低了部署和運維 MySQL 的成本：</li></ul><p style=text-align:justify>User 通過類似使用 Deployment 的方式描述對 MySQL 的需求</p><p style=text-align:justify>在 k8s 上部署 MySQL 應用的姿勢與 k8s 官方資源的操作方式相同。</p><p style=text-align:justify>由 slightshift-mysql-operator 的 Controller 監聽、處理事件請求</p><ul><li>監聽 Resource Events。</li><li>針對不同類型 (ADD/UPDATE/DELETE) 的 Events 執行相應的動作。</li><li>不斷檢測 Object 的狀態來執行動作，驅使服務的狀態符合 User 期望。</li></ul><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f8fd755cf6b74807a485347ee6040866><p class=pgc-img-caption></p></div><p style=text-align:justify>slightshift-mysql-operator 的設計理念：</p><ul><li>聲明式配置：提升可讀性和運維效率，降低運維成本。</li><li>最終一致性：動態調整集群狀態實現最終一致性。</li></ul><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8693096a191b49fab9877fe94ca8dd35><p class=pgc-img-caption></p></div><p style=text-align:justify>slightshift-mysql-operator 極大程度上降低了在 Kubernetes 集群中使用和管理 MySQL 應用的成本，User 可以通過聲明式的 CR 創建應用，Vendor 可將管理應用的專業知識封裝，對 User 透明。</p><p style=text-align:justify>slightshift-mysql-operator 在架構層面上使用分層設計，簡化了架構複雜度，同時儘可能降低了 MySQL 多個集群實例間相互干擾，實現各個實例的自治。</p><p style=text-align:justify>部署結構如下圖所示：</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/703e0bce030b49eda2100fb4b14e588a><p class=pgc-img-caption></p></div><p style=text-align:justify><strong>備份與恢復</strong></p><p style=text-align:justify>為保證數據安全性，還需對數據進行定期備份，保證用戶數據在極端情況下(集群崩潰)時數據可恢復。</p><p style=text-align:justify>通過 Cronjob 對 Mysql 數據進行備份：</p><ul><li>在 Kubernetes 集群中創建 Cronjob，Cronjob 會定期進行數據備份。</li><li>備份數據會被打上時間標籤，並上傳到對象存儲服務器(Ceph、Minio)。</li></ul><p style=text-align:justify>通過創建 Job 對 Mysql 進行數據恢復：</p><ul><li>在集群中創建恢復 Job，Job 根據 SNAP_SHOT 到存儲服務器(OSS、Minio)上獲取備份數據。</li><li>Job 把數據恢復到 Mysql Master 實例，同時 Slave 會完成數據同步。</li></ul><h1 class=pgc-h-arrow-right>五 技術演進</h1><p style=text-align:justify>唯有進化，才能站到食物鏈頂端。</p><p style=text-align:justify>根據 Gartner 報告預測，數據庫雲平臺市場份額將會在下一個五年中翻倍，而70%的用戶將開始使用 dbPaaS 數據庫雲平臺。因此，為了滿足各類應用程序對數據庫雲平臺的需求，同時為了減少私有云部署中對大量不同類型數據存儲產品的運維複雜性，數據庫的架構演進將是未來十年數據庫轉型的主要方向之一。</p><p style=text-align:justify>雲原生數據庫是未來數據庫發展的一個重要方向，雲原生數據庫架構隨著雲化要求也需要進行相應的迭代，未來在雲原生數據庫架構的演進還會隨著需求的變化而持續發展。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e2bfc836c0f14593a300a0680028a9ae><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>六 未來展望</h1><p style=text-align:justify>中間件作為構築上層業務系統的基石和核心技術，具有高可靠性、高擴展性、強專業性等特點。</p><p style=text-align:justify>關於未來，由於中間件的這些特點，未來雲原生中間件會向著規範化、構建化、鬆耦合和平臺化的方向發展。平臺化能夠更快速響應業務變化，為業務的橫向發展提供集中的技術解決方案。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/bcb82a1422f84cccb95991d35775223f><p class=pgc-img-caption></p></div><p style=text-align:justify>從終態來看，我們想做一個企業級雲原生中間件 PaaS 平臺，涵蓋基礎中間件的部署、配置、升級、伸縮、故障處理等自動化能力。</p><p style=text-align:justify>首先談談我對中間件平臺的理解，中間件平臺應該是一系列中間件解決方案集合的能力開放式技術中臺，它形成了完整、久經考驗、開放和組件化的解決方案，旨在為複雜多變的上層業務領域提供穩定可靠的計算、存儲服務。</p><p style=text-align:justify>任何一個平臺型產品的發展歷程，都不是一開始就做平臺的，而是先有業務需求，為了解決實際業務需求而積累了某些領域的知識，進而成為了這些領域的專家，最終再向平臺轉變。換句話說，平臺是一個持續積累的過程，也是一個水到渠成的過程。</p><div class=pgc-img><img alt=雲原生下，如何實現高可用的MySQL？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7ff312f9dc01484295fa8ae36ecc65fb><p class=pgc-img-caption></p></div><p style=text-align:justify>在企業信息平臺構建過程中，有效、合理、規範化的利用中間件平臺來快速構建上層業務系統，可以為企業及時響應需求變化提供有力保障，形成企業的集約化管理，進而提升企業核心力量獲得可持續競爭的優勢。</p><blockquote class=pgc-blockquote-abstract><p>作者：阿里技術</p><p>鏈接：https://zhuanlan.51cto.com/art/202009/625144.htm#topx</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>實現</a></li><li><a>MySQL</a></li><li><a>原生</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1a1dec.html alt=MySQL中是如何實現事務提交和回滾的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0c6b8175-642c-44ff-8879-30667952a475 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1a1dec.html title=MySQL中是如何實現事務提交和回滾的？>MySQL中是如何實現事務提交和回滾的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html alt="圖解MySQL | 「原理解析」 MySQL組提交(group commit)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e5444e9094614d6b88bd3fc8ac0524fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html title="圖解MySQL | 「原理解析」 MySQL組提交(group commit)">圖解MySQL | 「原理解析」 MySQL組提交(group commit)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html alt=MySQL系列-第14篇：事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html title=MySQL系列-第14篇：事務詳解>MySQL系列-第14篇：事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html alt=MySQL進階之InnoDB事務原子性實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e1d208ac-c0ed-4238-bce5-e4b3760228c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html title=MySQL進階之InnoDB事務原子性實現原理>MySQL進階之InnoDB事務原子性實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>