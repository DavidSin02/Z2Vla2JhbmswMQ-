<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Redis 設計與實現 : Lua 腳本 | 极客快訊</title><meta property="og:title" content="Redis 設計與實現 : Lua 腳本 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f22ee5ad.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f22ee5ad.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f22ee5ad.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f22ee5ad.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f22ee5ad.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f22ee5ad.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f22ee5ad.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f22ee5ad.html><meta property="article:published_time" content="2020-11-14T21:08:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:09+08:00"><meta name=Keywords content><meta name=description content="Redis 設計與實現 : Lua 腳本"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f22ee5ad.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Redis 設計與實現 : Lua 腳本</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>Lua 腳本功能是 Reids 2.6 版本的最大亮點， 通過內嵌對 Lua 環境的支持， Redis 解決了長久以來不能高效地處理 CAS （check-and-set）命令的缺點， 並且可以通過組合使用多個命令， 輕鬆實現以前很難實現或者不能高效實現的模式。</p><p>本章先介紹 Lua 環境的初始化步驟， 然後對 Lua 腳本的安全性問題、以及解決這些問題的方法進行說明， 最後對執行 Lua 腳本的兩個命令 —— <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 和 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 的實現原理進行介紹。</p><h1><strong>初始化 Lua 環境</strong></h1><p>在初始化 Redis 服務器時， 對 Lua 環境的初始化也會一併進行。</p><p>為了讓 Lua 環境符合 Redis 腳本功能的需求， Redis 對 Lua 環境進行了一系列的修改， 包括添加函數庫、更換隨機函數、保護全局變量， 等等。</p><p>整個初始化 Lua 環境的步驟如下：</p><ol><li>調用 <a class=pgc-link href=http://www.lua.org/pil/24.1.html target=_blank>lua_open</a> 函數，創建一個新的 Lua 環境。</li><li>載入指定的 Lua 函數庫，包括：</li></ol><ul><li class=ql-indent-1>基礎庫（base lib）。</li><li class=ql-indent-1>表格庫（table lib）。</li><li class=ql-indent-1>字符串庫（string lib）。</li><li class=ql-indent-1>數學庫（math lib）。</li><li class=ql-indent-1>調試庫（debug lib）。</li><li class=ql-indent-1>用於處理 JSON 對象的 cjson 庫。</li><li class=ql-indent-1>在 Lua 值和 C 結構（struct）之間進行轉換的 struct 庫（<a class=pgc-link href=http://www.inf.puc-rio.br/~roberto/struct/ target=_blank>http://www.inf.puc-rio.br/~roberto/struct/</a>）。</li><li class=ql-indent-1>處理 MessagePack 數據的 cmsgpack 庫（<a class=pgc-link href=https://github.com/antirez/lua-cmsgpack target=_blank>https://github.com/antirez/lua-cmsgpack</a>）。</li></ul><ol><li>屏蔽一些可能對 Lua 環境產生安全問題的函數，比如 <a class=pgc-link href=http://pgl.yoyo.org/luai/i/loadfile target=_blank>loadfile</a> 。</li><li>創建一個 Redis 字典，保存 Lua 腳本，並在複製（replication）腳本時使用。字典的鍵為 SHA1 校驗和，字典的值為 Lua 腳本。</li><li>創建一個 redis 全局表格到 Lua 環境，表格中包含了各種對 Redis 進行操作的函數，包括：</li></ol><ul><li class=ql-indent-1>用於執行 Redis 命令的 redis.call 和 redis.pcall 函數。</li><li>用於發送日誌（log）的 redis.log 函數，以及相應的日誌級別（level）：</li><li class=ql-indent-2>redis.LOG_DEBUG</li><li class=ql-indent-2>redis.LOG_VERBOSE</li><li class=ql-indent-2>redis.LOG_NOTICE</li><li class=ql-indent-1>redis.LOG_WARNING</li><li class=ql-indent-1>用於計算 SHA1 校驗和的 redis.sha1hex 函數。</li><li class=ql-indent-1>用於返回錯誤信息的 redis.error_reply 函數和 redis.status_reply 函數。</li></ul><ol><li>用 Redis 自己定義的隨機生成函數，替換 math 表原有的 math.random 函數和 math.randomseed 函數，新的函數具有這樣的性質：每次執行 Lua 腳本時，除非顯式地調用 math.randomseed ，否則 math.random 生成的偽隨機數序列總是相同的。</li><li>創建一個對 Redis 多批量回復（multi bulk reply）進行排序的輔助函數。</li><li>對 Lua 環境中的全局變量進行保護，以免被傳入的腳本修改。</li><li>因為 Redis 命令必須通過客戶端來執行，所以需要在服務器狀態中創建一個無網絡連接的偽客戶端（fake client），專門用於執行 Lua 腳本中包含的 Redis 命令：當 Lua 腳本需要執行 Redis 命令時，它通過偽客戶端來向服務器發送命令請求，服務器在執行完命令之後，將結果返回給偽客戶端，而偽客戶端又轉而將命令結果返回給 Lua 腳本。</li><li>將 Lua 環境的指針記錄到 Redis 服務器的全局狀態中，等候 Redis 的調用。</li></ol><p>以上就是 Redis 初始化 Lua 環境的整個過程， 當這些步驟都執行完之後， Redis 就可以使用 Lua 環境來處理腳本了。</p><p>嚴格來說， 步驟 1 至 8 才是初始化 Lua 環境的操作， 而步驟 9 和 10 則是將 Lua 環境關聯到服務器的操作， 為了按順序觀察整個初始化過程， 我們將兩種操作放在了一起。</p><p>另外， 步驟 6 用於創建無副作用的腳本， 而步驟 7 則用於去除部分 Redis 命令中的不確定性（non deterministic）， 關於這兩點， 請看下面一節關於腳本安全性的討論。</p><h1><strong>腳本的安全性</strong></h1><p>當將 Lua 腳本複製到附屬節點， 或者將 Lua 腳本寫入 AOF 文件時， Redis 需要解決這樣一個問題： 如果一段 Lua 腳本帶有隨機性質或副作用， 那麼當這段腳本在附屬節點運行時， 或者從 AOF 文件載入重新運行時， 它得到的結果可能和之前運行的結果完全不同。</p><p>考慮以下一段代碼， 其中的 get_random_number() 帶有隨機性質， 我們在服務器 SERVER 中執行這段代碼， 並將隨機數的結果保存到鍵 number 上：</p><pre># 虛構例子，不會真的出現在腳本環境中redis&gt; EVAL "return redis.call('set', KEYS[1], get_random_number())" 1 numberOKredis&gt; GET number"10086"</pre><p>現在， 假如 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 的代碼被複制到了附屬節點 SLAVE ， 因為 get_random_number() 的隨機性質， 它有很大可能會生成一個和 10086 完全不同的值， 比如 65535 ：</p><pre># 虛構例子，不會真的出現在腳本環境中redis&gt; EVAL "return redis.call('set', KEYS[1], get_random_number())" 1 numberOKredis&gt; GET number"65535"</pre><p>可以看到， 帶有隨機性的寫入腳本產生了一個嚴重的問題： 它破壞了服務器和附屬節點數據之間的一致性。</p><p>當從 AOF 文件中載入帶有隨機性質的寫入腳本時， 也會發生同樣的問題。</p><p>只有在帶有隨機性的腳本進行寫入時， 隨機性才是有害的。</p><p>如果一個腳本只是執行只讀操作， 那麼隨機性是無害的。</p><p>比如說， 如果腳本只是單純地執行 RANDOMKEY 命令， 那麼它是無害的； 但如果在執行 RANDOMKEY 之後， 基於 RANDOMKEY 的結果進行寫入操作， 那麼這個腳本就是有害的。</p><p>和隨機性質類似， 如果一個腳本的執行對任何副作用產生了依賴， 那麼這個腳本每次執行所產生的結果都可能會不一樣。</p><p>為了解決這個問題， Redis 對 Lua 環境所能執行的腳本做了一個嚴格的限制 —— 所有腳本都必須是無副作用的純函數（pure function）。</p><p>為此，Redis 對 Lua 環境做了一些列相應的措施：</p><ul><li>不提供訪問系統狀態狀態的庫（比如系統時間庫）。</li><li>禁止使用 <a class=pgc-link href=http://pgl.yoyo.org/luai/i/loadfile target=_blank>loadfile</a> 函數。</li><li>如果腳本在執行帶有隨機性質的命令（比如 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/key/randomkey.html#randomkey target=_blank>RANDOMKEY</a> ），或者帶有副作用的命令（比如 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/server/time.html#time target=_blank>TIME</a> ）之後，試圖執行一個寫入命令（比如 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/string/set.html#set target=_blank>SET</a> ），那麼 Redis 將阻止這個腳本繼續運行，並返回一個錯誤。</li><li>如果腳本執行了帶有隨機性質的讀命令（比如 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/set/smembers.html#smembers target=_blank>SMEMBERS</a> ），那麼在腳本的輸出返回給 Redis 之前，會先被執行一個自動的<a class=pgc-link href=http://en.wikipedia.org/wiki/Lexicographical_order target=_blank>字典序排序</a>，從而確保輸出結果是有序的。</li><li>用 Redis 自己定義的隨機生成函數，替換 Lua 環境中 math 表原有的 <a class=pgc-link href=http://pgl.yoyo.org/luai/i/math.random target=_blank>math.random</a> 函數和 <a class=pgc-link href=http://pgl.yoyo.org/luai/i/math.randomseed target=_blank>math.randomseed</a> 函數，新的函數具有這樣的性質：每次執行 Lua 腳本時，除非顯式地調用 math.randomseed ，否則 math.random 生成的偽隨機數序列總是相同的。</li></ul><p>經過這一系列的調整之後， Redis 可以保證被執行的腳本：</p><ol><li>無副作用。</li><li>沒有有害的隨機性。</li><li>對於同樣的輸入參數和數據集，總是產生相同的寫入命令。</li></ol><h1><strong>腳本的執行</strong></h1><p>在腳本環境的初始化工作完成以後， Redis 就可以通過 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 命令或 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 命令執行 Lua 腳本了。</p><p>其中， <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 直接對輸入的腳本代碼體（body）進行求值：</p><pre>redis&gt; EVAL "return 'hello world'" 0"hello world"</pre><p>而 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 則要求輸入某個腳本的 SHA1 校驗和， 這個校驗和所對應的腳本必須至少被 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 執行過一次：</p><pre>redis&gt; EVAL "return 'hello world'" 0"hello world"redis&gt; EVALSHA 5332031c6b470dc5a0dd9b4bf2030dea6d65de91 0 // 上一個腳本的校驗和"hello world"</pre><p>或者曾經使用 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/script_load.html#script-load target=_blank>SCRIPT LOAD</a> 載入過這個腳本：</p><pre>redis&gt; SCRIPT LOAD "return 'dlrow olleh'""d569c48906b1f4fca0469ba4eee89149b5148092"redis&gt; EVALSHA d569c48906b1f4fca0469ba4eee89149b5148092 0"dlrow olleh"</pre><p>因為 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 是基於 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 構建的， 所以下文先用一節講解 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 的實現， 之後再講解 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 的實現。</p><h1><strong>EVAL 命令的實現</strong></h1><p><a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 命令的執行可以分為以下步驟：</p><ol><li>為輸入腳本定義一個 Lua 函數。</li><li>執行這個 Lua 函數。</li></ol><p>以下兩個小節分別介紹這兩個步驟。</p><p><strong>定義 Lua 函數</strong></p><p>所有被 Redis 執行的 Lua 腳本， 在 Lua 環境中都會有一個和該腳本相對應的無參數函數： 當調用 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 命令執行腳本時， 程序第一步要完成的工作就是為傳入的腳本創建一個相應的 Lua 函數。</p><p>舉個例子， 當執行命令 EVAL "return 'hello world'" 0 時， Lua 會為腳本 "return 'hello world'" 創建以下函數：</p><pre>function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91() return 'hello world'end</pre><p>其中， 函數名以 f_ 為前綴， 後跟腳本的 SHA1 校驗和（一個 40 個字符長的字符串）拼接而成。 而函數體（body）則是用戶輸入的腳本。</p><p>以函數為單位保存 Lua 腳本有以下好處：</p><ul><li>執行腳本的步驟非常簡單，只要調用和腳本相對應的函數即可。</li><li>Lua 環境可以保持清潔，已有的腳本和新加入的腳本不會互相干擾，也可以將重置 Lua 環境和調用 Lua GC 的次數降到最低。</li><li>如果某個腳本所對應的函數在 Lua 環境中被定義過至少一次，那麼只要記得這個腳本的 SHA1 校驗和，就可以直接執行該腳本 —— 這是實現 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 命令的基礎，稍後在介紹 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 的時候就會說到這一點。</li></ul><p>在為腳本創建函數前，程序會先用函數名檢查 Lua 環境，只有在函數定義未存在時，程序才創建函數。重複定義函數一般並沒有什麼副作用，這算是一個小優化。</p><p>另外，如果定義的函數在編譯過程中出錯（比如，腳本的代碼語法有錯）， 那麼程序向用戶返回一個腳本錯誤， 不再執行後面的步驟。</p><p><strong>執行 Lua 函數</strong></p><p>在定義好 Lua 函數之後， 程序就可以通過運行這個函數來達到運行輸入腳本的目的了。</p><p>不過， 在此之前， 為了確保腳本的正確和安全執行， 還需要執行一些設置鉤子、傳入參數之類的操作， 整個執行函數的過程如下：</p><ol><li>將 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 命令中輸入的 KEYS 參數和 ARGV 參數以全局數組的方式傳入到 Lua 環境中。</li><li>設置偽客戶端的目標數據庫為調用者客戶端的目標數據庫： fake_client->db = caller_client->db ，確保腳本中執行的 Redis 命令訪問的是正確的數據庫。</li><li>為 Lua 環境裝載超時鉤子，保證在腳本執行出現超時時可以殺死腳本，或者停止 Redis 服務器。</li><li>執行腳本對應的 Lua 函數。</li><li>如果被執行的 Lua 腳本中帶有 SELECT 命令，那麼在腳本執行完畢之後，偽客戶端中的數據庫可能已經有所改變，所以需要對調用者客戶端的目標數據庫進行更新： caller_client->db = fake_client->db 。</li><li>執行清理操作：清除鉤子；清除指向調用者客戶端的指針；等等。</li><li>將 Lua 函數執行所得的結果轉換成 Redis 回覆，然後傳給調用者客戶端。</li><li>對 Lua 環境進行一次單步的漸進式 GC 。</li></ol><p>以下是執行 EVAL "return 'hello world'" 0 的過程中， 調用者客戶端（caller）、Redis 服務器和 Lua 環境之間的數據流表示圖：</p><pre> 發送命令請求 EVAL "return 'hello world'" 0Caller ----------------------------------------&gt; Redis 為腳本 "return 'hello world'" 創建 Lua 函數Redis ----------------------------------------&gt; Lua 綁定超時處理鉤子Redis ----------------------------------------&gt; Lua 執行腳本函數Redis ----------------------------------------&gt; Lua 返回函數執行結果（一個 Lua 值）Redis &lt;---------------------------------------- Lua 將 Lua 值轉換為 Redis 回覆 並將結果返回給客戶端Caller &lt;---------------------------------------- Redis</pre><p>上面這個圖可以作為所有 Lua 腳本的基本執行流程圖， 不過它展示的 Lua 腳本中不帶有 Redis 命令調用： 當 Lua 腳本里本身有調用 Redis 命令時（執行 redis.call 或者 redis.pcall ）， Redis 和 Lua 腳本之間的數據交互會更復雜一些。</p><p>舉個例子， 以下是執行命令 EVAL "return redis.call('DBSIZE')" 0 時， 調用者客戶端（caller）、偽客戶端（fake client）、Redis 服務器和 Lua 環境之間的數據流表示圖：</p><pre> 發送命令請求 EVAL "return redis.call('DBSIZE')" 0Caller ------------------------------------------&gt; Redis 為腳本 "return redis.call('DBSIZE')" 創建 Lua 函數Redis ------------------------------------------&gt; Lua 綁定超時處理鉤子Redis ------------------------------------------&gt; Lua 執行腳本函數Redis ------------------------------------------&gt; Lua 執行 redis.call('DBSIZE')Fake Client &lt;------------------------------------- Lua 偽客戶端向服務器發送 DBSIZE 命令請求Fake Client -------------------------------------&gt; Redis 服務器將 DBSIZE 的結果 （Redis 回覆）返回給偽客戶端Fake Client &lt;------------------------------------- Redis 將命令回覆轉換為 Lua 值 並返回給 Lua 環境Fake Client -------------------------------------&gt; Lua 返回函數執行結果（一個 Lua 值）Redis &lt;------------------------------------------ Lua 將 Lua 值轉換為 Redis 回覆 並將該回復返回給客戶端Caller &lt;------------------------------------------ Redis</pre><p>因為 EVAL "return redis.call('DBSIZE')" 只是簡單地調用了一次 DBSIZE 命令， 所以 Lua 和偽客戶端只進行了一趟交互， 當腳本中的 redis.call 或者 redis.pcall 次數增多時， Lua 和偽客戶端的交互趟數也會相應地增多， 不過總體的交互方法和上圖展示的一樣。</p><h1><strong>EVALSHA 命令的實現</strong></h1><p>前面介紹 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 命令的實現時說過， 每個被執行過的 Lua 腳本， 在 Lua 環境中都有一個和它相對應的函數， 函數的名字由 f_ 前綴加上 40 個字符長的 SHA1 校驗和構成： 比如 f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91 。</p><p>只要腳本所對應的函數曾經在 Lua 裡面定義過， 那麼即使用戶不知道腳本的內容本身， 也可以直接通過腳本的 SHA1 校驗和來調用腳本所對應的函數， 從而達到執行腳本的目的 —— 這就是 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 命令的實現原理。</p><p>可以用偽代碼來描述這一原理：</p><pre>def EVALSHA(sha1): # 拼接出 Lua 函數名字 func_name = "f_" + sha1 # 查看該函數是否已經在 Lua 中定義 if function_defined_in_lua(func_name): # 如果已經定義過的話，執行函數 return exec_lua_function(func_name) else: # 沒有找到和輸入 SHA1 值相對應的函數則返回一個腳本未找到錯誤 return script_error("SCRIPT NOT FOUND")</pre><p>除了執行 <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 命令之外， <a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/script_load.html#script-load target=_blank>SCRIPT LOAD</a> 命令也可以為腳本在 Lua 環境中創建函數：</p><pre>redis&gt; SCRIPT LOAD "return 'hello world'""5332031c6b470dc5a0dd9b4bf2030dea6d65de91"redis&gt; EVALSHA 5332031c6b470dc5a0dd9b4bf2030dea6d65de91 0"hello world"</pre><p><a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/script_load.html#script-load target=_blank>SCRIPT LOAD</a> 執行的操作和前面《<a class=pgc-link href=https://redisbook.readthedocs.io/en/latest/feature/scripting.html#define-lua-function target=_blank>定義 Lua 函數</a>》小節描述的一樣。</p><h1><strong>小結</strong></h1><ul><li>初始化 Lua 腳本環境需要一系列步驟，其中最重要的包括：</li><li class=ql-indent-1>創建 Lua 環境。</li><li class=ql-indent-1>載入 Lua 庫，比如字符串庫、數學庫、表格庫，等等。</li><li class=ql-indent-1>創建 redis 全局表格，包含各種對 Redis 進行操作的函數，比如 redis.call 和 redis.log ，等等。</li><li class=ql-indent-1>創建一個無網絡連接的偽客戶端，專門用於執行 Lua 腳本中的 Redis 命令。</li><li>Reids 通過一系列措施保證被執行的 Lua 腳本無副作用，也沒有有害的寫隨機性：對於同樣的輸入參數和數據集，總是產生相同的寫入命令。</li><li><a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/eval.html#eval target=_blank>EVAL</a> 命令為輸入腳本定義一個 Lua 函數，然後通過執行這個函數來執行腳本。</li><li><a class=pgc-link href=http://redis.readthedocs.org/en/latest/script/evalsha.html#evalsha target=_blank>EVALSHA</a> 通過構建函數名，直接調用 Lua 中已定義的函數，從而執行相應的腳本。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Redis</a></li><li><a>設計</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f2ea430.html alt=串行接口是如何設計，如何實現的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4f6b7513b2d64c0e8136598de6fa3e6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f2ea430.html title=串行接口是如何設計，如何實現的？>串行接口是如何設計，如何實現的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html alt=鋼構人福利——鋼結構設計經典問題解讀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a72bd60ea48d471b8ce03ebf0ce15869 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html title=鋼構人福利——鋼結構設計經典問題解讀>鋼構人福利——鋼結構設計經典問題解讀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html alt=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153569494612546362474a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html title=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先>鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html alt=38個鋼結構設計問題，都很常見 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f1181ce8-cf01-4194-b9c2-362f43894ddb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html title=38個鋼結構設計問題，都很常見>38個鋼結構設計問題，都很常見</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html alt=步步解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d88dd927b4f2474fbe4ea261c2397ba8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html title=步步解析橋樑設計計算，不可錯過的一篇乾貨>步步解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html alt=結構設計、校對、審核三字經，速速收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html title=結構設計、校對、審核三字經，速速收藏>結構設計、校對、審核三字經，速速收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html alt=解析橋樑設計計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa4d0bcf2a204a2fac9b37978b1b0713 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html title=解析橋樑設計計算>解析橋樑設計計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html alt=解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af9ca7f120da4e23b0ca589375e05dd2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html title=解析橋樑設計計算，不可錯過的一篇乾貨>解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html alt=設計師解析橋樑設計計算，錯過了就沒有機會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e01645937bda4ae7a7f148666ff89117 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html title=設計師解析橋樑設計計算，錯過了就沒有機會>設計師解析橋樑設計計算，錯過了就沒有機會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html alt=經典設計延續至今的烏尼莫克403萬能卡車 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/132ba54553374c7eb2c0a9c155bba041 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html title=經典設計延續至今的烏尼莫克403萬能卡車>經典設計延續至今的烏尼莫克403萬能卡車</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69536588.html alt=線纜設計初級課程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532759411210988051a0cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69536588.html title=線纜設計初級課程>線纜設計初級課程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/219919c3.html alt=梯度效果的創意Logo設計案例分享（1） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15226471428904df67cc724 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/219919c3.html title=梯度效果的創意Logo設計案例分享（1）>梯度效果的創意Logo設計案例分享（1）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/29b61120.html alt=梯度效果的創意Logo設計案例分享（2） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1522647184765cbbd0b4dcd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/29b61120.html title=梯度效果的創意Logo設計案例分享（2）>梯度效果的創意Logo設計案例分享（2）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>