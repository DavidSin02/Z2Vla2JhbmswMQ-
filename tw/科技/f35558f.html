<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>發號器-達達分佈式ID生成系統 | 极客快訊</title><meta property="og:title" content="發號器-達達分佈式ID生成系統 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/02a28bb87a924ca69ab60c8f1f17e2e9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f35558f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><meta property="article:published_time" content="2020-10-29T21:00:54+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:54+08:00"><meta name=Keywords content><meta name=description content="發號器-達達分佈式ID生成系統"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f35558f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>發號器-達達分佈式ID生成系統</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>背景</strong></p><p>在分佈式系統中，經常需要對大量的數據、消息、http請求等進行唯一標識，例如：對於分佈式系統，服務間相互調用需要唯一標識，調用鏈路分析的時候需要使用這個唯一標識。這個時候數據庫自增主鍵已經不能滿足需求，需要一個能夠生成全局唯一ID的系統，這個系統需要滿足以下需求：</p><ul><li>全局唯一：不能出現重複ID。</li><li>高可用：ID生成系統是基礎系統，被許多關鍵系統調用，一旦宕機，會造成嚴重影響。</li></ul><p><strong>經典方案介紹</strong></p><p>1. UUID</p><p>UUID是Universally Unique Identifier的縮寫，它是在一定的範圍內(從特定的名字空間到全球)唯一的機器生成的標識符，UUID是16字節128位長的數字，通常以36字節的字符串表示，比如：3F2504E0-4F89-11D3-9A0C-0305E82C3301。</p><p>UUID經由一定的算法機器生成，為了保證UUID的唯一性，規範定義了包括網卡MAC地址、時間戳、名字空間(Namespace)、隨機或偽隨機數、時序等元素，以及從這些元素生成UUID的算法。UUID的複雜特性在保證了其唯一性的同時，意味著只能由計算機生成。</p><p>優點：</p><ul><li>本地生成ID，不需要進行遠程調用，時延低，性能高。</li></ul><p>缺點：</p><ul><li>UUID過長，16字節128位，通常以36長度的字符串表示，很多場景不適用，比如用UUID做數據庫索引字段。</li><li>沒有排序，無法保證趨勢遞增。</li></ul><p>2. Flicker方案</p><p>這個方案是由Flickr團隊提出，主要思路採用了MySQL自增長ID的機制(auto_increment + replace into)</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/02a28bb87a924ca69ab60c8f1f17e2e9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>replace into 跟 insert 功能類似，不同點在於：replace into 首先嚐試插入數據到表中，如果發現表中已經有此行數據(根據主鍵或者唯-索引判斷)則先刪除此行數據，然後插入新的數據， 否則直接插入新數據。</p><p>為了避免單點故障，最少需要兩個數據庫實例，通過區分auto_increment的起始值和步長來生成奇偶數的ID。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/de10b8aadb62432d87a6644a19d83884><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>優點：</p><ul><li>充分藉助數據庫的自增ID機制，可靠性高，生成有序的ID。</li></ul><p>缺點：</p><ul><li>ID生成性能依賴單臺數據庫讀寫性能。</li><li>依賴數據庫，當數據庫異常時整個系統不可用。</li></ul><p>對於依賴MySql性能問題，可用如下方案解決：</p><p>在分佈式環境中我們可以部署多臺，每臺設置不同的初始值，並且步長為機器臺數，比如部署N臺，每臺的初始值就為0，1，2，3…N-1，步長為N。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ea21f64af4d947f793bbbf8f830c9ed5><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>以上方案雖然解決了性能問題，但是也存在很大的侷限性：</p><ul><li>系統擴容困難：系統定義好步長之後，增加機器之後調整步長困難。</li><li>數據庫壓力大：每次獲取一個ID都必須讀寫一次數據庫。</li></ul><p>3. 類snowflake方案</p><p>這種方案生成一個64bit的數字，64bit被劃分成多個段，分別表示時間戳、機器編碼、序號。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90b01ddb99e94ba3807ffd32e7bc8d52><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>ID為64bit 的long 數字，由三部分組成：</p><ul><li>41位的時間序列(精確到毫秒，41位的長度可以使用69年)。</li><li>10位的機器標識(10位的長度最多支持部署1024個節點)。</li><li>12位的計數順序號(12位的計數順序號支持每個節點每毫秒產生4096個ID序號)。</li></ul><p>優點：</p><ul><li>時間戳在高位，自增序列在低位，整個ID是趨勢遞增的，按照時間有序。</li><li>性能高，每秒可生成幾百萬ID。</li><li>可以根據自身業務需求靈活調整bit位劃分，滿足不同需求。</li></ul><p>缺點：</p><ul><li>依賴機器時鐘，如果機器時鐘回撥，會導致重複ID生成。</li><li>在單機上是遞增的，但是由於涉及到分佈式環境，每臺機器上的時鐘不可能完全同步，有時候會出現不是全局遞增的情況。</li></ul><p>4. TDDL序列生成方式</p><p>TDDL是阿里的分庫分表中間件，它裡面包含了全局數據庫ID的生成方式，主要思路：</p><ul><li>使用數據庫同步ID信息。</li><li>每次批量取一定數量的可用ID在內存中，使用完後，再請求數據庫重新獲取下一批可用ID，每次獲取的可用ID數量由步長控制，實際業務中可根據使用速度進行配置。</li><li>每個業務可以給自己的序列起個唯一的名字，隔離各個業務系統的ID。</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8e98597ad9c84a3f9228d94d969ce4cb><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>優點：</p><ul><li>相比flicker方案，大大降低數據庫寫壓力，數據庫不再是性能瓶頸。</li><li>相比flicker方案，生成ID性能大幅度提高，因為獲取一個可用號段後在內存中直接分配，相對於每次讀取數據庫性能提高了幾個量級。</li><li>不同業務不同的ID需求可以用seqName字段區分，每個seqName的ID獲取相互隔離，互不影響。</li></ul><p>缺點：</p><ul><li>強依賴數據庫，當數據庫異常時整個系統不可用。</li></ul><p>發號器實現方案</p><p>綜合對比以上四種實現方案，以及我們的業務需求，最後決定採用第三種方案。</p><p><strong>主要原因：</strong></p><ul><li>業務需求：業務要求生成的ID要有遞增趨勢，全局唯一，並且為數字。</li><li>系統考慮：第三種方案性能高，穩定性高，對外部資源依賴少。</li></ul><p>依據實際業務需求和系統規劃，對算法進行局部調整，實現了發號器snowflake方案。</p><p>發號器snowflake方案</p><p>發號器snowflake方案中對bit的劃分做了如下調整：</p><ul><li>36 bit 時間戳，使用時間秒</li><li>5 bit 機器編碼</li><li>22 bit 序號</li></ul><p>機器編碼維護：</p><p>機器編碼是不同機器之間產生唯一ID的重要依據，不能重複，一旦重複，就會導致有相同機器編碼的服務器生成的ID大量重複。 如果部署的機器只是少量的，可以人工維護，如果大量，手動維護成本高，考慮到自動部署、運維等等問題，機器編碼最好由系統自動維護，有以下兩個方案可供選擇:</p><ul><li>使用mysql自增ID特性，用數據表，存儲機器的mac地址或者ip來維護。</li><li>使用ZooKeeper持久順序節點的特性。</li></ul><p>這裡我們使用ZooKeeper持久順序節點特性來配置維護WORKID.發號器的啟動順序如下：</p><ul><li>啟動發號器服務，連接ZooKeeper， 檢查根節點id_generator是否存在，如果不存在就創建系統根節點。</li><li>檢查根節點下當前機器是否已經註冊過(是否有該順序子節點)。</li><li>如果有註冊，直接取回自己的WORKID。如果沒註冊，在根節點下創建一個持久順序節點，取回順序號做WORKID。</li></ul><p>一旦取回WORKID，緩存在本地文件中，後續直接使用，不再與ZooKeeper進行任何交互，此方案對ZooKeeper依賴極小。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14192c11a6234c1f9c614c4549b13bfa><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>時鐘問題：</p><p>snowflake方案依賴系統時鐘，如果機器時鐘回撥，就有可能生成重複ID，為了保證ID唯一性，必須解決時鐘回撥問題。</p><p>可以採取以下幾種方案解決時鐘問題：</p><ul><li>關閉系統NTP同步，這樣就不會產生時鐘調整。</li><li>系統做出判斷，在時鐘回撥這段時間，不生成ID，直接返回ERROR_CODE，直到時鐘追上，恢復服務。</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca9da9ea8e47444d9f55951837ac89c4><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><ul><li>系統做出判斷，如果遇到超過容忍限度的回撥，上報報警系統，並把自身從集群節點中摘除</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/901915f0d82446058a5d1fae39fad3b2><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><ul><li>系統做兼容處理，由於nfp網絡回撥都是幾十毫秒到幾百毫秒，極少數到秒級別，這種回撥會產生以下幾種結果：</li><li>系統中緩存最近幾秒內最後的發號序號(具體範圍請根據實際需要確定)，存儲格式為：時間秒-序號。</li><li>當前秒數不變： 當前是8:30秒100毫秒，ntp回撥50毫秒，當前時間變成8:30秒50毫秒，這個時候秒數沒變，我們算法的時間戳部分不會產生重複，就不影響系統繼續發號</li><li class=ql-indent-1><br></li><li>當前秒數向前：當前是8:30秒800毫秒，ntp 向前調整300毫秒，當前時間變成8:31秒100毫秒，由於這個時間還沒發過號，不會生成重複的ID</li><li class=ql-indent-1><br></li><li class=ql-indent-1>當前秒數向後：當前是8:30秒100毫秒，ntp回撥150毫秒，當前時間變成8:29秒950毫秒，這個時候秒發生回退，就可能產生重複ID。產生重複的原因在於秒回退後，算法的時間戳部分使用了已經用過的時間戳，但是算法的序號部分，並沒有回退到29秒那個時間對應的序號，依然使用當前的序號，如果序號也同時回退到29秒時間戳所對應的最後序號，就不會重複發號。解決方案如下：</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/81ec7a3d74f84cb1aa4b577b3df4c356><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>閏秒處理：</p><p>閏秒，是指為保持協調世界時接近於世界時時刻，由國際計量局統一規定在年底或年中(也可能在季末)對協調世界時增加或減少1秒的調整。由於地球自轉的不均勻性和長期變慢性(主要由潮汐摩擦引起的)，會使世界時(民用時)和原子時之間相差超過到±0.9秒時，就把協調世界時向前撥1秒(負閏秒，最後一分鐘為59秒)或向後撥1秒(正閏秒，最後一分鐘為61秒)，閏秒一般加在公曆年末或公曆六月末。</p><p>在閏秒產生的時候系統會出現秒級時間調整，下面我們來分析閏秒對發號器的影響：</p><ul><li>負閏秒：當前23:59:58的下一秒就是第二天的00:00:00，00:00:00 這個時間我們還沒產生過ID，不會產生重複的，對發號器沒影響。</li><li>正閏秒：當天23:59:59的下一秒當記為23:59:60，然後才是第二天的00:00:00。由於我們系統時間戳部分取的從某個時間點(1970年1月1日)到現在的秒數，是一個數字，只要這個數字不重複，就不會產生重複的ID。如果在閏秒發生一段時間後ntp時間同步(為了規避閏秒風險，很多公司閏秒前關閉ntp同步，閏秒後打開ntp同步)，這個時候系統時鐘回撥,可以使用解決時鐘回撥的方案進行處理。</li></ul><p>服務部署優化</p><ul><li>部署結構</li><li>為了實現高可用，避免單點故障，系統部署採用集群水平部署，前置使用nginx做負載均衡，發號器使用springboot框架，web服務器使用springboot內嵌tomcat， 發號器和nginx之間進行心跳檢測。</li><li class=ql-align-center><br></li></ul><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f3f88a2760dc49c588549d63b6b6292a><p class=pgc-img-caption></p></div><ul><li class=ql-align-center><br></li><li>tomcat調優</li><li>使用APR</li><li>Tomcat支持三種接收請求的處理方式：BIO、NIO、APR， 性能 BIO&lt;NIO&lt;APR。APR簡單理解，就是從操作系統級別解決異步IO問題，大幅度的提高服務器的處理和響應性能，也是Tomcat運行高併發應用的首選模式。使用APR首先要安裝系統依賴庫，參考APR安裝</li><li>在springBoot程序中增加apr配置開啟APR(這裡有一個配置變量來控制是否開啟)</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/78b2f37622f74533badc27ed0c388d95><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>開發中遇到的問題</p><hr><p>整個開發過程都非常順利，測試的時候tps也很高，心情很愉快，世界很美好，突然一個意外出現，發現存在full gc現象，有內存溢出？ 於是分析了好幾遍程序，也沒找到明顯的線索，只能開始jvm調試旅程。</p><p>pingpoint 監控圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9538507cc6db427d998a39b15bff7618><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>（上圖中紅色部署表示full gc）</strong></p><p>JVM調試最直接的就是獲取full gc時的jvm dump文件，以及gc log進行分析：</p><p>為了獲取dump文件，在jvm參數中加上：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8fa9acd69e5449c8ba3be152323ecda><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>參數介紹：</strong></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be94030d10b4447aaa21c1f71df4a2d1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>配置上面的虛擬機參數後，虛擬機gc的時候會把gc相關信息輸出到文件gc.log中，full gc前後，會生成當時虛擬機的內存dump文件。從pingpoint監控圖中可以看出full gc是發生在持久區域。</p><p>使用jmap 工具，獲取JVM堆內存信息如下：</p><p>jmap -heap pid</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/be3446be29ef4a9786c622f9a758cf5c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>從上圖可以看出，使用的堆內存很少，總的堆內存只有0.84% 使用，其它使用指標也都在正常範圍，系統裝載的類也不多，沒有內存洩露。</p><p>繼續分析gc log：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2647521d94954effb0296444b6ebcc5c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>從gc log 中尋找線索：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/666961e1b03542d7966ab3811c5d3548><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>這裡發現了以下線索：</p><ul><li>從 [Full GC (Metadata GC Threshold)看出，的確產生了full gc，原因 Metadata GC Threshold。</li><li>[Metaspace: 34773K->34773K(1081344K)] full gc前後metaspace的size沒有變化說明此區域已經滿了，釋放不出內存。</li><li>仔細分析gc log，發現2次full gc記錄，第一次full gc [Metaspace: 20897K->20897K(1069056K)，這個值比第2次的要小很多。</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=發號器-達達分佈式ID生成系統 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/af73721ac48d4e72b15a99de6c15cba9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>兩次full gc原因都是 Metadata GC Threshold類型，說明pingpoint監控到的full gc是元空間引發的full gc，並非內存洩露引起，但是這個值才34m，距離最大值1081m，還有很大空間，為什麼會full gc?</p><p>經過查閱官方資料，發現MetaspaceSize的默認大小是21807104b，也就是21296k，而發生GC的時候，元空間已經使用了34722K，從而產生full gc。</p><p>方法區:</p><p>方法區也是所有線程共享。主要用於存儲類的信息、常量池、方法數據、方法代碼等。方法區邏輯上屬於堆的一部分，但是為了與堆進行區分，通常又叫“非堆”。其實，移除永久代的工作從JDK1.7就開始了。JDK1.7中，存儲在永久代的部分數據就已經轉移到了Java Heap或者是 Native Heap。但永久代仍存在於JDK1.7中，並沒完全移除，譬如符號引用(Symbols)轉移到了native heap，字符串常量轉移到了java heap，類的靜態變量(class statics)轉移到了java heap。</p><p>在JDK8中，classe metadata(the virtual machines internal presentation of Java class)，被存儲在叫做Metaspace的native memory。一些新的flags被加入：-XX:MetaspaceSize，class metadata的初始空間配額，以bytes為單位，達到該值就會觸發垃圾收集進行類型卸載，同時GC會對該值進行調整：如果釋放了大量的空間，就適當的降低該值；如果釋放了很少的空間，就會在不超過MaxMetaspaceSize(如果設置了的話)的情況下，適當的提高該值。</p><p>在虛擬機參數中增加MetaspaceSize初始化大小，-XX:MetaspaceSize=128m，重新啟動項目，不再有full gc出現。</p><p>總結</p><p>發號器-達達分佈式ID生成系統，是以snowflake算法為基礎，實現了生成全局唯一ID的功能，解決了在分佈式系統唯一ID生成問題。在實現高可用性方面，採用水平集群部署、心跳檢測等方案為系統保駕護航。該系統目前已在達達商城等項目中使用，每天提供大量服務。</p><p>參考</p><ul><li>Snowflake (https://github.com/twitter/snowflake)</li><li>TDDL</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>發號器</a></li><li><a>達達分</a></li><li><a>ID</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd1a3aef.html alt=PS+AI+ID快捷鍵，你知道嗎？初學者快快收藏吧！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/37ca00026702b139f337 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd1a3aef.html title=PS+AI+ID快捷鍵，你知道嗎？初學者快快收藏吧！>PS+AI+ID快捷鍵，你知道嗎？初學者快快收藏吧！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09950c97.html alt="重識別(re-ID)特徵適合直接用於跟蹤(tracking)問題麼？| 將門好聲音" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rnry5KBBlEk33d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09950c97.html title="重識別(re-ID)特徵適合直接用於跟蹤(tracking)問題麼？| 將門好聲音">重識別(re-ID)特徵適合直接用於跟蹤(tracking)問題麼？| 將門好聲音</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12bd0879.html alt="ID卡、IC卡、身份證、CPU卡、T57卡、HID卡門禁 梯控 通道讀卡器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2cc8b39f7cb84f06884cbb34fec8bfc7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12bd0879.html title="ID卡、IC卡、身份證、CPU卡、T57卡、HID卡門禁 梯控 通道讀卡器">ID卡、IC卡、身份證、CPU卡、T57卡、HID卡門禁 梯控 通道讀卡器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03a9911.html alt=一文教你如何設計一款“高可用高性能”的發號器？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/bb0de75005c0440bbe38c3635437b260 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03a9911.html title=一文教你如何設計一款“高可用高性能”的發號器？>一文教你如何設計一款“高可用高性能”的發號器？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/7f5b76f.html alt=文波，比賽ID：JackeyLove，英雄聯盟職業選手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f164d1588f7341c888fe60787ca79e4f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/7f5b76f.html title=文波，比賽ID：JackeyLove，英雄聯盟職業選手>文波，比賽ID：JackeyLove，英雄聯盟職業選手</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>