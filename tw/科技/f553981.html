<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一次完整的JVM堆外內存洩漏故障排查記錄 | 极客快訊</title><meta property="og:title" content="一次完整的JVM堆外內存洩漏故障排查記錄 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/15784a09582b430cb43ff878ec7c1d82"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f553981.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f553981.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f553981.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f553981.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f553981.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f553981.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f553981.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f553981.html><meta property="article:published_time" content="2020-10-29T20:53:54+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:54+08:00"><meta name=Keywords content><meta name=description content="一次完整的JVM堆外內存洩漏故障排查記錄"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f553981.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一次完整的JVM堆外內存洩漏故障排查記錄</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>前言</strong></h1><p>記錄一次線上JVM堆外內存洩漏問題的排查過程與思路，其中夾帶一些<strong>「JVM內存分配機制」</strong>以及<strong>「常用的JVM問題排查指令和工具分享」</strong>，希望對大家有所幫助。</p><p>在整個排查過程中，我也走了不少彎路，但是在文章中我仍然會把完整的思路和想法寫出來，當做一次經驗教訓，給後人參考，文章最後也總結了下內存洩漏問題快速排查的幾個原則。</p><p><strong>「本文的主要內容：」</strong></p><ul><li>故障描述和排查過程</li><li>故障原因和解決方案分析</li><li>JVM堆內內存和堆外內存分配原理</li><li>常用的進程內存洩漏排查指令和工具介紹和使用</li></ul><blockquote><p>❝</p><p>文章撰寫不易，請大家多多支持我的原創技術公眾號：後端技術漫談</p><p>❞</p></blockquote><h1 class=pgc-h-arrow-right><strong>故障描述</strong></h1><p>8月12日中午午休時間，我們商業服務收到告警，服務進程佔用容器的物理內存（16G）超過了80%的閾值，並且還在不斷上升。</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15784a09582b430cb43ff878ec7c1d82><p class=pgc-img-caption></p></div><p>監控系統調出圖表查看：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7faf4071325d44f8b3a1a95a8fb7c281><p class=pgc-img-caption></p></div><p>像是Java進程發生了內存洩漏，而我們堆內存的限制是4G，這種大於4G快要吃滿內存應該是JVM堆外內存洩漏。</p><p>確認了下當時服務進程的啟動配置：</p><pre><code>-Xms4g -Xmx4g -Xmn2g -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=80</code></pre><p>雖然當天沒有上線新代碼，但是<strong>「當天上午我們正在使用消息隊列推送歷史數據的修復腳本，該任務會大量調用我們</strong><strong>服務其</strong><strong>中的某一個接口」</strong>，所以初步懷疑和該接口有關。</p><p>下圖是該調用接口當天的訪問量變化：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/909de762d50342a0945a6042b25d4105><p class=pgc-img-caption></p></div><p>可以看到案發當時調用量相比正常情況（每分鐘200+次）提高了很多（每分鐘5000+次）。</p><p><strong>「我們暫時讓腳本停止發送消息，該接口調用量下降到每分鐘200+次，容器內存不再以極高斜率上升，一切似乎恢復了正常。」</strong></p><p>接下來排查這個接口是不是發生了內存洩漏。</p><h1 class=pgc-h-arrow-right><strong>排查過程</strong></h1><p>首先我們先回顧下Java進程的內存分配，方便我們下面排查思路的闡述。</p><p><strong>「以我們線上使用的JDK1.8版本為例」</strong>。JVM內存分配網上有許多總結，我就不再進行二次創作。</p><p>JVM內存區域的劃分為兩塊：堆區和非堆區。</p><ul><li>堆區：就是我們熟知的新生代老年代。</li><li>非堆區：非堆區如圖中所示，有元數據區和直接內存。</li></ul><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bb69f2570487487ab430a4176c3ba82b><p class=pgc-img-caption></p></div><p><strong>「這裡需要額外注意的是：永久代（JDK8的原生</strong><strong>去</strong><strong>）存放JVM運行時使用的</strong><strong>類</strong><strong>，永久代的對象在full GC時進行垃圾收集。」</strong></p><p>複習完了JVM的內存分配，讓我們回到故障上來。</p><h1 class=pgc-h-arrow-right><strong>堆內存分析</strong></h1><p>雖說一開始就基本確認與堆內存無關，因為洩露的內存佔用超過了堆內存限制4G，但是我們為了保險起見先看下堆內存有什麼線索。</p><p>我們觀察了新生代和老年代內存佔用曲線以及回收次數統計，和往常一樣沒有大問題，我們接著在事故現場的容器上dump了一份JVM堆內存的日誌。</p><h1 class=pgc-h-arrow-right><strong>堆內存Dump</strong></h1><p>堆內存快照dump命令：</p><pre><code>jmap -dump:live,format=b,file=xxxx.hprof pid</code></pre><blockquote><p>❝</p><p>畫外音：你也可以使用jmap -histo:live pid直接查看堆內存存活的對象。</p><p>❞</p></blockquote><p>導出後，將Dump文件下載回本地，然後可以使用Eclipse的MAT（Memory Analyzer）或者JDK自帶的JVisualVM打開日誌文件。</p><p>使用MAT打開文件如圖所示：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/adc413274f384946bd719f0f8c0d5ce2><p class=pgc-img-caption></p></div><p><strong>「可以看到堆內存中，有一些nio有關的大對象，比如正在接收消息隊列消息的nioChannel，還有nio.HeapByteBuffer，但是數量不多，不能作為判斷的依據，先放著觀察下。」</strong></p><p>下一步，我開始瀏覽該接口代碼，接口內部主要邏輯是調用集團的WCS客戶端，將數據庫表中數據查表後寫入WCS，沒有其他額外邏輯</p><p>發覺沒有什麼特殊邏輯後，我開始懷疑WCS客戶端封裝是否存在內存洩漏，這樣懷疑的理由是，WCS客戶端底層是由SCF客戶端封裝的，作為RPC框架，其底層通訊傳輸協議有可能會申請直接內存。</p><p><strong>「是不是我的代碼</strong><strong>出發</strong><strong>了WCS客戶端的Bug，導致不斷地申請直接內存的調用，最終吃滿內存。」</strong></p><p>我聯繫上了WCS的值班人，將我們遇到的問題和他們描述了一下，他們回覆我們，會在他們本地執行下寫入操作的壓測，看看能不能復現我們的問題。</p><p>既然等待他們的反饋還需要時間，我們就準備先自己琢磨下原因。</p><p><strong>「我將懷疑的目光停留在了直接內存上，懷疑是由於接口調用量過大，客戶端對nio使用不當，導致使用ByteBuffer申請過多的直接內存。」</strong></p><blockquote><p>❝</p><p><strong>「畫外音：最終的結果證明，這一個先入為主的思路導致排查過程走了彎路。在問題的排查過程中，用合理的猜測來縮小排查範圍是可以的，但最好先把每種可能性都列清楚，在發現自己深入某個可能性無果時，要及時回頭仔細審視其他可能性。」</strong></p><p>❞</p></blockquote><h1 class=pgc-h-arrow-right><strong>沙箱環境復現</strong></h1><p>為了能還原當時的故障場景，我在沙箱環境申請了一臺壓測機器，來確保和線上環境一致。</p><p><strong>「首先我們先模擬內存溢出的情況（大量調用接口）：」</strong></p><p>我們讓腳本繼續推送數據，調用我們的接口，我們持續觀察內存佔用。</p><p>當開始調用後，內存便開始持續增長，並且看起來沒有被限制住（沒有因為限制觸發Full GC）。</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23f7fc86dfb143febc27818c85f4be1a><p class=pgc-img-caption></p></div><p><strong>「接著我們來模擬下平時正常調用量的情況（正常量調用接口）：」</strong></p><p>我們將該接口平時正常的調用量（比較小，且每10分鐘進行一次批量調用）切到該壓測機器上，得到了下圖這樣的老生代內存和物理內存趨勢：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/97c7f2d36afc4cb6a4c1a106b753ba7d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/651352df4f254b85b4ce04df66ef7b24><p class=pgc-img-caption></p></div><p><strong>「問題來了：為何內存會不斷往上走吃滿內存呢？」</strong></p><p>當時猜測是由於JVM進程並沒有對於直接內存大小進行限制（-XX:MaxDirectMemorySize），所以堆外內存不斷上漲，並不會觸發FullGC操作。</p><p><strong>「上圖能夠得出兩個結論：」</strong></p><ul><li>在內存洩露的接口調用量很大的時候，如果恰好堆內老生代等其他情況一直不滿足FullGC條件，就一直不會FullGC，直接內存一路上漲。</li><li>而在平時低調用量的情況下， 內存洩漏的比較慢，FullGC總會到來，回收掉洩露的那部分，這也是平時沒有出問題，正常運行了很久的原因。</li></ul><p><strong>「由於上面提到，我們進程的啟動參數中並沒有限制直接內存，於是我們將-XX:MaxDirectMemorySize配置加上，再次在沙箱環境進行了測驗。」</strong></p><p>結果發現，進程佔用的物理內存依然會不斷上漲，超出了我們設置的限制，“看上去”配置似乎沒起作用。</p><p>這讓我很訝異，難道JVM對內存的限制出現了問題？</p><p><strong>「到了這裡，能夠看出我排查過程中思路執著於直接內存的洩露，一去不復返了。」</strong></p><blockquote><p>❝</p><p><strong>「畫外音：我們應該相信JVM對內存的掌握，如果發現參數失效，多從自己身上找原因，看看是不是自己使用參數有誤。」</strong></p><p>❞</p></blockquote><h1 class=pgc-h-arrow-right><strong>直接內存分析</strong></h1><p>為了更進一步的調查清楚直接內存裡有什麼，我開始對直接內存下手。由於直接內存並不能像堆內存一樣，很容易的看出所有佔用的對象，我們需要一些命令來對直接內存進行排查，我有用了幾種辦法，來查看直接內存裡到底出現了什麼問題。</p><h1 class=pgc-h-arrow-right><strong>查看進程內存信息 pmap</strong></h1><p>pmap - report memory map of a process(查看進程的內存映像信息)</p><p>pmap命令用於報告進程的內存映射關係，是Linux調試及運維一個很好的工具。</p><pre><code>pmap -x pid 如果需要排序  | sort -n -k3**</code></pre><p>執行後我得到了下面的輸出，刪減輸出如下:</p><pre><code>..00007fa2d4000000    8660    8660    8660 rw---   [ anon ]00007fa65f12a000    8664    8664    8664 rw---   [ anon ]00007fa610000000    9840    9832    9832 rw---   [ anon ]00007fa5f75ff000   10244   10244   10244 rw---   [ anon ]00007fa6005fe000   59400   10276   10276 rw---   [ anon ]00007fa3f8000000   10468   10468   10468 rw---   [ anon ]00007fa60c000000   10480   10480   10480 rw---   [ anon ]00007fa614000000   10724   10696   10696 rw---   [ anon ]00007fa6e1c59000   13048   11228       0 r-x-- libjvm.so00007fa604000000   12140   12016   12016 rw---   [ anon ]00007fa654000000   13316   13096   13096 rw---   [ anon ]00007fa618000000   16888   16748   16748 rw---   [ anon ]00007fa624000000   37504   18756   18756 rw---   [ anon ]00007fa62c000000   53220   22368   22368 rw---   [ anon ]00007fa630000000   25128   23648   23648 rw---   [ anon ]00007fa63c000000   28044   24300   24300 rw---   [ anon ]00007fa61c000000   42376   27348   27348 rw---   [ anon ]00007fa628000000   29692   27388   27388 rw---   [ anon ]00007fa640000000   28016   28016   28016 rw---   [ anon ]00007fa620000000   28228   28216   28216 rw---   [ anon ]00007fa634000000   36096   30024   30024 rw---   [ anon ]00007fa638000000   65516   40128   40128 rw---   [ anon ]00007fa478000000   46280   46240   46240 rw---   [ anon ]0000000000f7e000   47980   47856   47856 rw---   [ anon ]00007fa67ccf0000   52288   51264   51264 rw---   [ anon ]00007fa6dc000000   65512   63264   63264 rw---   [ anon ]00007fa6cd000000   71296   68916   68916 rwx--   [ anon ]00000006c0000000 4359360 2735484 2735484 rw---   [ anon ]</code></pre><p>可以看出，最下面一行是堆內存的映射，佔用4G，其他上面有非常多小的內存佔用，不過通過這些信息我們依然看不出問題。</p><h1 class=pgc-h-arrow-right><strong>堆外內存跟蹤 NativeMemoryTracking</strong></h1><blockquote><p>❝</p><p>Native Memory Tracking (NMT) 是Hotspot VM用來分析VM內部內存使用情況的一個功能。我們可以利用jcmd（jdk自帶）這個工具來訪問NMT的數據。</p><p>❞</p></blockquote><p>NMT必須先通過VM啟動參數中打開，不過要注意的是，打開NMT會帶來5%-10%的性能損耗。</p><pre><code>-XX:NativeMemoryTracking=[off | summary | detail]# off: 默認關閉# summary: 只統計各個分類的內存使用情況.# detail: Collect memory usage by individual call sites.</code></pre><p>然後運行進程，可以使用下面的命令查看直接內存：</p><pre><code>jcmd &lt;pid&gt; VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB] # summary: 分類內存使用情況.# detail: 詳細內存使用情況，除了summary信息之外還包含了虛擬內存使用情況。# baseline: 創建內存使用快照，方便和後面做對比# summary.diff: 和上一次baseline的summary對比# detail.diff: 和上一次baseline的detail對比# shutdown: 關閉NMT</code></pre><p>我們使用：</p><pre><code>jcmd pid VM.native_memory detail scale=MB &gt; temp.txt</code></pre><p>得到如圖結果：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b84f1f8e0ba34aa49dd1b9e35e744afb><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b3b39449c9e943b4a59e83b42ee5e456><p class=pgc-img-caption></p></div><p>上圖中給我們的信息，都不能很明顯的看出問題，至少我當時依然不能通過這幾次信息看出問題。</p><p>排查似乎陷入了僵局。</p><h1 class=pgc-h-arrow-right><strong>山重水複疑無路</strong></h1><p>在排查陷入停滯的時候，我們得到了來自WCS和SCF方面的回覆，<strong>「兩方都確定了他們的封裝沒有內存洩漏的存在」</strong>，WCS方面沒有使用直接內存，而SCF雖然作為底層RPC協議，但是也不會遺留這麼明顯的內存bug，否則應該線上有很多反饋。</p><h1 class=pgc-h-arrow-right><strong>查看JVM內存信息 jmap</strong></h1><p>此時，找不到問題的我再次新開了一個沙箱容器，運行服務進程，然後運行jmap命令，看一看JVM內存的<strong>「實際配置」</strong>：</p><pre><code>jmap -heap pid</code></pre><p>得到結果：</p><pre><code>Attaching to process ID 1474, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.66-b17using parallel threads in the new generation.using thread-local object allocation.Concurrent Mark-Sweep GCHeap Configuration:   MinHeapFreeRatio         = 40   MaxHeapFreeRatio         = 70   MaxHeapSize              = 4294967296 (4096.0MB)   NewSize                  = 2147483648 (2048.0MB)   MaxNewSize               = 2147483648 (2048.0MB)   OldSize                  = 2147483648 (2048.0MB)   NewRatio                 = 2   SurvivorRatio            = 8   MetaspaceSize            = 21807104 (20.796875MB)   CompressedClassSpaceSize = 1073741824 (1024.0MB)   MaxMetaspaceSize         = 17592186044415 MB   G1HeapRegionSize         = 0 (0.0MB)Heap Usage:New Generation (Eden + 1 Survivor Space):   capacity = 1932787712 (1843.25MB)   used     = 1698208480 (1619.5378112792969MB)   free     = 234579232 (223.71218872070312MB)   87.86316621615607% usedEden Space:   capacity = 1718091776 (1638.5MB)   used     = 1690833680 (1612.504653930664MB)   free     = 27258096 (25.995346069335938MB)   98.41346682518548% usedFrom Space:   capacity = 214695936 (204.75MB)   used     = 7374800 (7.0331573486328125MB)   free     = 207321136 (197.7168426513672MB)   3.4349974840697497% usedTo Space:   capacity = 214695936 (204.75MB)   used     = 0 (0.0MB)   free     = 214695936 (204.75MB)   0.0% usedconcurrent mark-sweep generation:   capacity = 2147483648 (2048.0MB)   used     = 322602776 (307.6579818725586MB)   free     = 1824880872 (1740.3420181274414MB)   15.022362396121025% used29425 interned Strings occupying 3202824 bytes</code></pre><p>輸出的信息中，看得出老年代和新生代都蠻正常的，元空間也只佔用了20M，直接內存看起來也是2g...</p><p>嗯？為什麼MaxMetaspaceSize = 17592186044415 MB？<strong>「看起來就和沒限制一樣」</strong>。</p><p>再仔細看看我們的啟動參數：</p><pre><code>-Xms4g -Xmx4g -Xmn2g -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=80</code></pre><p>配置的是-XX:PermSize=256m -XX:MaxPermSize=512m，也就是永久代的內存空間。<strong>「而1.8後，Hotspot虛擬機已經移除了永久代，使用了元空間代替。」</strong> 由於我們線上使用的是JDK1.8，<strong>「所以我們對於元空間的最大容量根本就沒有做限制」</strong>，-XX:PermSize=256m -XX:MaxPermSize=512m 這兩個參數對於1.8就是過期的參數。</p><p>下面的圖描述了從1.7到1.8，永久代的變更：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2adbac2c5c8a4d3494854c0c6f898710><p class=pgc-img-caption></p></div><p><strong>「那會不會是元空間內存洩露了呢？」</strong></p><p>我選擇了在本地進行測試，方便更改參數，也方便使用JVisualVM工具直觀的看出內存變化。</p><h1 class=pgc-h-arrow-right><strong>使用JVisualVM觀察進程運行</strong></h1><p>首先限制住元空間，使用參數-XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m，然後在本地循環調用出問題的接口。</p><p>得到如圖：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/787a38fa9aa5465a9f224ecedf5af34a><p class=pgc-img-caption></p></div><p><strong>「可以看出，在元空間耗盡時，系統出發了Full GC，元空間內存得到回收，並且卸載了很多類。」</strong></p><p>然後我們將元空間限制去掉，也就是使用之前出問題的參數：</p><pre><code>-Xms4g -Xmx4g -Xmn2g -Xss1024K -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection -XX:CMSInitiatingOccupancyFraction=80 -XX:MaxDirectMemorySize=2g -XX:+UnlockDiagnosticVMOptions</code></pre><p>得到如圖：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa69fa0d24a04686a678d7ff34baf3f5><p class=pgc-img-caption></p></div><p><strong>「可以看出，元空間在不斷上漲，並且已裝入的類隨著調用量的增加也在不斷上漲，呈現正相關趨勢。」</strong></p><h1 class=pgc-h-arrow-right><strong>柳暗花明又一村</strong></h1><p>問題一下子明朗了起來，<strong>「隨著每次接口的調用，極有可能是某個類都在不斷的被創建，佔用了元空間的內存」</strong>。</p><h1 class=pgc-h-arrow-right><strong>觀察JVM類加載情況 -verbose</strong></h1><blockquote><p>❝</p><p>在調試程序時，有時需要查看程序加載的類、內存回收情況、調用的本地接口等。這時候就需要-verbose命令。在myeclipse可以通過右鍵設置（如下），也可以在命令行輸入java -verbose來查看。</p><p>❞</p></blockquote><pre><code>-verbose:class 查看類加載情況-verbose:gc 查看虛擬機中內存回收情況-verbose:jni 查看本地方法調用的情況</code></pre><p>我們在本地環境，添加啟動參數-verbose:class循環調用接口。</p><p>可以看到生成了無數com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto:</p><pre><code>[Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar][Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar][Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar][Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar][Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar][Loaded com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto from file:/C:/Users/yangzhendong01/.m2/repository/com/alibaba/fastjson/1.2.71/fastjson-1.2.71.jar]</code></pre><p>當調用了很多次，積攢了一定的類時，我們手動執行Full GC，進行類加載器的回收，我們發現大量的fastjson相關類被回收。</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f94b75acf85046c4bb2b0c7af3ebe0aa><p class=pgc-img-caption></p></div><p><strong>「如果在回收前，使用jmap查看類加載情況，同樣也可以發現大量的fastjson相關類：」</strong></p><pre><code>jmap -clstats 7984</code></pre><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/877102a2d8514313a122f04765b2366b><p class=pgc-img-caption></p></div><p>這下有了方向，<strong>「這次仔細排查代碼」</strong>，查看代碼邏輯裡哪裡用到了fastjson，發現瞭如下代碼：</p><pre><code>/** * 返回Json字符串.駝峰轉_ * @param bean 實體類. */public static String buildData(Object bean) {    try {        SerializeConfig CONFIG = new SerializeConfig();        CONFIG.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;        return jsonString = JSON.toJSONString(bean, CONFIG);    } catch (Exception e) {        return null;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>問題根因</strong></h1><p>我們在調用wcs前將駝峰字段的實體類序列化成下劃線字段，**這需要使用fastjson的SerializeConfig，而我們在靜態方法中對其進行了實例化。SerializeConfig創建時默認會創建一個ASM代理類用來實現對目標對象的序列化。也就是上面被頻繁創建的類com.alibaba.fastjson.serializer.ASMSerializer_1_WlkCustomerDto,如果我們複用SerializeConfig，fastjson會去尋找已經創建的代理類，從而複用。但是如果new SerializeConfig()，則找不到原來生成的代理類，就會一直去生成新的WlkCustomerDto代理類。</p><p>下面兩張圖時問題定位的源碼：</p><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/974cd97436a848e096e48cc017a69ddd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bc4fb221d9404f7cb30804a6be93a575><p class=pgc-img-caption></p></div><p>我們將SerializeConfig作為類的靜態變量，問題得到了解決。</p><pre><code>private static final SerializeConfig CONFIG = new SerializeConfig();static {    CONFIG.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;}</code></pre><h1 class=pgc-h-arrow-right><strong>fastjson SerializeConfig 做了什麼</strong></h1><p>SerializeConfig介紹：</p><blockquote><p>❝</p><p>SerializeConfig的主要功能是配置並記錄每種Java類型對應的序列化類（ObjectSerializer接口的實現類），比如Boolean.class使用BooleanCodec（看命名就知道該類將序列化和反序列化實現寫到一起了）作為序列化實現類，float[].class使用FloatArraySerializer作為序列化實現類。這些序列化實現類，有的是FastJSON中默認實現的（比如Java基本類），有的是通過ASM框架生成的（比如用戶自定義類），有的甚至是用戶自定義的序列化類（比如Date類型框架默認實現是轉為毫秒，應用需要轉為秒）。當然，這就涉及到是使用ASM生成序列化類還是使用JavaBean的序列化類類序列化的問題，這裡判斷根據就是是否Android環境（環境變量"java.vm.name"為"dalvik"或"lemur"就是Android環境），但判斷不僅這裡一處，後續還有更具體的判斷。</p><p>❞</p></blockquote><p>理論上來說，每個SerializeConfig實例若序列化相同的類，都會找到之前生成的該類的代理類，來進行序列化。們的服務在每次接口被調用時，都實例化一個ParseConfig對象來配置Fastjson反序列的設置，而未禁用ASM代理的情況下，由於每次調用ParseConfig都是一個新的實例，因此永遠也檢查不到已經創建的代理類，所以Fastjson便不斷的創建新的代理類，並加載到metaspace中，最終導致metaspace不斷擴張，將機器的內存耗盡。</p><h1 class=pgc-h-arrow-right><strong>升級JDK1.8才會出現問題</strong></h1><p>導致問題發生的原因還是值得重視。為什麼在升級之前不會出現這個問題？這就要分析jdk1.8和1.7自帶的hotspot虛擬機的差異了。</p><blockquote><p>❝</p><p>從jdk1.8開始，自帶的hostspot虛擬機取消了過去的永久區，而新增了metaspace區，從功能上看，metaspace可以認為和永久區類似，其最主要的功用也是存放類元數據，但實際的機制則有較大的不同。</p><p>首先，metaspace默認的最大值是整個機器的物理內存大小，所以metaspace不斷擴張會導致java程序侵佔系統可用內存，最終系統沒有可用的內存；而永久區則有固定的默認大小，不會擴張到整個機器的可用內存。當分配的內存耗盡時，兩者均會觸發full gc，但不同的是永久區在full gc時，以堆內存回收時類似的機制去回收永久區中的類元數據（Class對象），只要是根引用無法到達的對象就可以回收掉，而metaspace判斷類元數據是否可以回收，是根據加載這些類元數據的Classloader是否可以回收來判斷的，只要Classloader不能回收，通過其加載的類元數據就不會被回收。這也就解釋了我們這兩個服務為什麼在升級到1.8之後才出現問題，因為在之前的jdk版本中，雖然每次調用fastjson都創建了很多代理類，在永久區中加載類很多代理類的Class實例，但這些Class實例都是在方法調用是創建的，調用完成之後就不可達了，因此永久區內存滿了觸發full gc時，都會被回收掉。</p><p>而使用1.8時，因為這些代理類都是通過主線程的Classloader加載的，這個Classloader在程序運行的過程中永遠也不會被回收，因此通過其加載的這些代理類也永遠不會被回收，這就導致metaspace不斷擴張，最終耗盡機器的內存了。</p><p>❞</p></blockquote><p>這個問題並不侷限於fastjson，只要是需要通過程序加載創建類的地方，就有可能出現這種問題。<strong>「尤其是在框架中，往往大量採用類似ASM、javassist等工具進行字節碼增強，而根據上面的分析，在jdk1.8之前，因為大多數情況下動態加載的Class都能夠在full gc時得到回收，因此不容易出現問題」</strong>，也因此很多框架、工具包並沒有針對這個問題做一些處理，一旦升級到1.8之後，這些問題就可能會暴露出來。</p><h1 class=pgc-h-arrow-right><strong>總結</strong></h1><p>問題解決了，接下來複盤下整個排查問題的流程，整個流程暴露了我很多問題，最主要的就是<strong>「對於JVM不同版本的內存分配還不夠熟悉」</strong>，導致了對於老生代和元空間判斷失誤，走了很多彎路，在直接內存中排查了很久，浪費了很多時間。</p><p>其次，排查需要的<strong>「一是仔細，二是全面，」</strong>，最好將所有可能性先行整理好，不然很容易陷入自己設定好的排查範圍內，走進死衚衕不出來。</p><p>最後，總結一下這次的問題帶來的收穫：</p><ul><li>JDK1.8開始，自帶的hostspot虛擬機取消了過去的永久區，而新增了metaspace區，從功能上看，metaspace可以認為和永久區類似，其最主要的功用也是存放類元數據，但實際的機制則有較大的不同。</li><li>對於JVM裡面的內存需要在啟動時進行限制，包括我們熟悉的堆內存，也要包括直接內存和元生區，這是保證線上服務正常運行最後的兜底。</li><li>使用類庫，請多注意代碼的寫法，儘量不要出現明顯的內存洩漏。</li><li>對於使用了ASM等字節碼增強工具的類庫，在使用他們時請多加小心（尤其是JDK1.8以後）。</li></ul><blockquote><p>❝</p><p>文章撰寫不易，請大家多多支持我的原創技術公眾號：後端技術漫談</p><p>❞</p></blockquote><h1 class=pgc-h-arrow-right><strong>參考</strong></h1><p>觀察程序運行時類加載的過程</p><p>blog.csdn.net/tenderhearted/article/details/39642275</p><p>Metaspace整體介紹（永久代被替換原因、元空間特點、元空間內存查看分析方法）</p><p>https://www.cnblogs.com/duanxz/p/3520829.html</p><p>java內存佔用異常問題常見排查流程（含堆外內存異常）</p><p>https://my.oschina.net/haitaohu/blog/3024843</p><p>JVM源碼分析之堆外內存完全解讀</p><p>http://lovestblog.cn/blog/2015/05/12/direct-buffer/</p><p>JVM 類的卸載</p><p>https://www.cnblogs.com/caoxb/p/12735525.html</p><p>fastjson在jdk1.8上面開啟asm</p><p>https://github.com/alibaba/fastjson/issues/385</p><p>fastjson：PropertyNamingStrategy_cn</p><p>https://github.com/alibaba/fastjson/wiki/PropertyNamingStrategy_cn</p><p>警惕動態代理導致的Metaspace內存洩漏問題</p><p>https://blog.csdn.net/xyghehehehe/article/details/78820135</p><h1 class=pgc-h-arrow-right><strong>關注我</strong></h1><p>我是一名後端開發工程師。主要關注後端開發，數據安全，爬蟲，物聯網，邊緣計算等方向，歡迎交流。</p><h1 class=pgc-h-arrow-right><strong>各大平臺都可以找到我</strong></h1><ul><li><strong>「微信公眾號：後端技術漫談」</strong></li><li><strong>「Github：@qqxx6661」</strong></li><li>CSDN：@蠻三刀把刀</li><li>知乎：@後端技術漫談</li><li>簡書：@蠻三刀把刀</li><li>掘金：@蠻三刀把刀</li><li>騰訊雲+社區：@後端技術漫談</li></ul><h1 class=pgc-h-arrow-right><strong>原創文章主要內容</strong></h1><ul><li>後端開發實戰</li><li>Java面試知識</li><li>設計模式/數據結構/算法題解</li><li>讀書筆記/逸聞趣事/程序人生</li></ul><h1 class=pgc-h-arrow-right><strong>個人公眾號：後端技術漫談</strong></h1><div class=pgc-img><img alt=一次完整的JVM堆外內存洩漏故障排查記錄 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ae38cc3eb0274e41b981a5febb303e60><p class=pgc-img-caption></p></div><p>個人公眾號：後端技術漫談</p><p><strong>「如果文章對你有幫助，不妨點贊，收藏起來~」</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JVM</a></li><li><a>堆外</a></li><li><a>內存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd1246b1.html alt=JVM—深入理解內存模型與垃圾收集機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/574c706db69f4c53802c093d6e7023d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd1246b1.html title=JVM—深入理解內存模型與垃圾收集機制>JVM—深入理解內存模型與垃圾收集機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html alt=內存屏障詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfe0c161.html title=內存屏障詳解>內存屏障詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html alt=C語言學習篇(3)-----內存編址和對齊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e039d89a145f4e258f5f6eb28d04809b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cd318a2.html title=C語言學習篇(3)-----內存編址和對齊>C語言學習篇(3)-----內存編址和對齊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html alt=內存按字節編址例題解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/87f6444a27d34916b6e72824f6e98572 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a42daf8.html title=內存按字節編址例題解析>內存按字節編址例題解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html alt="【歷史】內存的故事 (紀念DRAM量產50年)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RQUkuARBMJpAR2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c14545.html title="【歷史】內存的故事 (紀念DRAM量產50年)">【歷史】內存的故事 (紀念DRAM量產50年)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html alt=滲透測試——內存攻擊原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ae687b82fd824bafafb7c6792c260a98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ca0627f9.html title=滲透測試——內存攻擊原理>滲透測試——內存攻擊原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html alt=內存容量如何計算，瞭解一些基礎知識，你就懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d9065c724be64660aee58a3257a23534 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55e249a0.html title=內存容量如何計算，瞭解一些基礎知識，你就懂了！>內存容量如何計算，瞭解一些基礎知識，你就懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8820f792.html alt=內存降價了買多大容量夠用？超過這個數就浪費了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/951afe40804044ea85eb17c552656667 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8820f792.html title=內存降價了買多大容量夠用？超過這個數就浪費了>內存降價了買多大容量夠用？超過這個數就浪費了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d35198c.html alt=手機內存多少夠用64還是128？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/71eced4d7a2e4954ab09c431e7907bbf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d35198c.html title=手機內存多少夠用64還是128？>手機內存多少夠用64還是128？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e839484.html alt=奇怪的知識增加了！電腦內存容量真的是越大越好嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a457a965c6064a45a93d273286d37f57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e839484.html title=奇怪的知識增加了！電腦內存容量真的是越大越好嗎？>奇怪的知識增加了！電腦內存容量真的是越大越好嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ce20ef2.html alt=計算機中，內存容量越大越有利於系統的運行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1027a7b9f31f4c8f8b0d0c46e51afdb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ce20ef2.html title=計算機中，內存容量越大越有利於系統的運行>計算機中，內存容量越大越有利於系統的運行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83b274fa.html alt=買手機時，內存到底選多少合適？別再花些冤枉錢了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/04b6ac4f92af469b860e1b0875fe5c08 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83b274fa.html title=買手機時，內存到底選多少合適？別再花些冤枉錢了！>買手機時，內存到底選多少合適？別再花些冤枉錢了！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>