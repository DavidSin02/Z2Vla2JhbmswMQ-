<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>10分鐘，掌握C語言指針 | 极客快訊</title><meta property="og:title" content="10分鐘，掌握C語言指針 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/S25kjOh6BBFiP3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><meta property="article:published_time" content="2020-11-14T21:00:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:21+08:00"><meta name=Keywords content><meta name=description content="10分鐘，掌握C語言指針"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f5e3e293.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>10分鐘，掌握C語言指針</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>說到指針，估計還是有很多小夥伴都還是雲裡霧裡的，有點“知其然，而不知其所以然”。但是，不得不說，學了指針，C語言才能算是入門了。指針是C語言的<strong>「精華」</strong>，可以說，對對指針的掌握程度，<strong>「直接決定」</strong>了你C語言的編程能力。</p><p>在講指針之前，我們先來了解下變量在<strong>「內存」</strong>中是如何存放的。</p><p>在程序中定義一個變量，那麼在程序編譯的過程中，系統會根據你定義變量的類型來分配<strong>「相應尺寸」</strong>的內存空間。那麼如果要使用這個變量，只需要用變量名去訪問即可。</p><p>通過變量名來訪問變量，是一種<strong>「相對安全」</strong>的方式。因為只有你定義了它，你才能夠訪問相應的變量。這就是對內存的基本認知。但是，如果光知道這一點的話，其實你還是不知道內存是如何存放變量的，因為底層是如何工作的，你依舊不清楚。</p><p>那麼如果要繼續深究的話，你就需要把變量在內存中真正的樣子是什麼搞清楚。內存的最小索引單元是<code>1字節</code>，那麼你其實可以把內存比作一個超級大的<strong>「字符型數組」</strong>。在上一節我們講過，數組是有下標的，我們是通過數組名和下標來訪問數組中的元素。那麼內存也是一樣，只不過我們給它起了個新名字：<code>地址</code>。每個地址可以存放<strong>「1字節」</strong>的數據，所以如果我們需要定義一個整型變量，就需要佔據4個內存單元。</p><p>那麼，看到這裡你可能就明白了：其實在程序運行的過程中，完全不需要變量名的參與。變量名只是方便我們進行代碼的編寫和閱讀，只有程序員和編譯器知道這個東西的存在。而編譯器還知道具體的變量名對應的<strong>「內存地址」</strong>，這個是我們不知道的，因此編譯器就像一個橋樑。當讀取某一個變量的時候，編譯器就會找到變量名所對應的地址，讀取對應的值。</p><p></p><h1 toutiao-origin=h2>初識指針和指針變量</h1><p>那麼我們現在就來切入正題，指針是個什麼東西呢？</p><p>所謂指針，就是內存地址（下文簡稱地址）。C語言中設立了專門的<strong>「指針變量」</strong>來存儲指針，和<strong>「普通變量」</strong>不一樣的是，指針變量存儲的是<strong>「地址」</strong>。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>定義指針</strong></h2><p>指針變量也有類型，實際上取決於地址指向的值的類型。那麼如何定義指針變量呢：</p><p>很簡單：<code>類型名* 指針變量名</code></p><pre><code>char* pa;//定義一個字符變量的指針，名稱為pa<br>int* pb;//定義一個整型變量的指針，名稱為pb<br>float* pc;//定義一個浮點型變量的指針，名稱為pc<br></code></pre><p>注意，指針變量一定要和指向的變量的類型一樣，不然類型不同可能在內存中所佔的位置不同，如果定義錯了就可能導致出錯。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>取地址運算符和取值運算符</strong></h2><p>獲取某個變量的地址，使用取地址運算符<code>&</code>，如：</p><pre><code>char* pa = &amp;a;<br>int* pb = &amp;f;<br></code></pre><p>如果反過來，你要訪問指針變量指向的數據，那麼你就要使用取值運算符<code>*</code>，如：</p><pre><code>printf("%c, %d\n", *pa, *pb);<br></code></pre><p>這裡你可能發現，定義指針的時候也使用了<code>*</code>，這裡屬於符號的<strong>「重用」</strong>，也就是說這種符號在不同的地方就有不同的用意：在定義的時候表示<strong>「定義一個指針變量」</strong>，在其他的時候則用來<strong>「獲取指針變量指向的變量的值」</strong>。</p><p>直接通過變量名來訪問變量的值稱之為<code>直接訪問</code>，通過指針這樣的形式訪問稱之為<code>間接訪問</code>，因此取值運算符有時候也成為<strong>「間接運算符」</strong>。</p><p>比如：</p><pre><code>//Example 01<br>//代碼來源於網絡，非個人原創<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char a = 'f';<br>int f = 123;<br>char* pa = &amp;a;<br>int* pf = &amp;f;<br><br>printf("a = %c\n", *pa);<br>printf("f = %d\n", *pf);<br><br>*pa = 'c';<br>*pf += 1;<br><br>printf("now, a = %c\n", *pa);<br>printf("now, f = %d\n", *pf);<br><br>printf("sizeof pa = %d\n", sizeof(pa));<br>printf("sizeof pf = %d\n", sizeof(pf));<br><br>printf("the addr of a is: %p\n", pa);<br>printf("the addr of f is: %p\n", pf);<br><br>return 0;<br>}<br></code></pre><p>程序實現如下：</p><pre><code>//Consequence 01<br>a = f<br>f = 123<br>now, a = c<br>now, f = 124<br>sizeof pa = 4<br>sizeof pf = 4<br>the addr of a is: 00EFF97F<br>the addr of f is: 00EFF970<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>避免訪問未初始化的指針</strong></h2><pre><code>void <strong class=highlight-text toutiao-origin=span>f</strong><br>{<br>int* a;<br>*a = 10;<br>}<br></code></pre><p>像這樣的代碼是十分危險的。因為指針a到底指向哪裡，我們不知道。就和訪問未初始化的普通變量一樣，會返回一個<strong>「隨機值」</strong>。但是如果是在指針裡面，那麼就有可能覆蓋到<strong>「其他的內存區域」</strong>，甚至可能是系統正在使用的<strong>「關鍵區域」</strong>，十分危險。不過這種情況，系統一般會駁回程序的運行，此時程序會被<strong>「中止」</strong>並<strong>「報錯」</strong>。要是萬一中獎的話，覆蓋到一個合法的地址，那麼接下來的賦值就會導致一些有用的數據被<strong>「莫名其妙地修改」</strong>，這樣的bug是十分不好排查的，因此使用指針的時候一定要注意初始化。</p><p></p><h1 toutiao-origin=h2>指針和數組</h1><p>有些讀者可能會有些奇怪，指針和數組又有什麼關係？這倆貨明明八竿子打不著井水不犯河水。彆著急，接著往下看，你的觀點有可能會改變。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>數組的地址</strong></h2><p>我們剛剛說了，指針實際上就是變量在<strong>「內存中的地址」</strong>，那麼如果有細心的小夥伴就可能會想到，像數組這樣的一大摞變量的集合，它的地址是啥呢？</p><p>我們知道，從標準輸入流中讀取一個值到變量中，用的是<code>scanf</code>函數，一般貌似在後面都要加上<code>&</code>，這個其實就是我們剛剛說的<strong>「取地址運算符」</strong>。如果你存儲的位置是指針變量的話，那就不需要。</p><pre><code>//Example 02<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int a;<br>int* p = &amp;a;<br><br>printf("請輸入一個整數：");<br>scanf("%d", &amp;a);//此處需要&amp;<br>printf("a = %d\n", a);<br><br>printf("請再輸入一個整數：");<br>scanf("%d", p);//此處不需要&amp;<br>printf("a = %d\n", a);<br><br>return 0;<br>}<br></code></pre><p>程序運行如下：</p><pre><code>//Consequence 02<br>請輸入一個整數：1<br>a = 1<br>請再輸入一個整數：2<br>a = 2<br></code></pre><p>在普通變量讀取的時候，程序需要知道這個變量在內存中的地址，因此需要<code>&</code>來取地址完成這個任務。而對於指針變量來說，本身就是<strong>「另外一個」</strong>普通變量的<strong>「地址信息」</strong>，因此直接給出指針的值就可以了。</p><p>試想一下，我們在使用<code>scanf</code>函數的時候，是不是也有不需要使用<code>&</code>的時候？就是在讀取<strong>「字符串」</strong>的時候：</p><pre><code>//Example 03<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char url[100];<br>url[99] = '\0';<br>printf("請輸入TechZone的域名：");<br>scanf("%s", url);//此處也不用&amp;<br>printf("你輸入的域名是：%s\n", url);<br>return 0;<br>}<br></code></pre><p>程序執行如下：</p><pre><code>//Consequence 03<br>請輸入TechZone的域名：www.techzone.ltd<br>你輸入的域名是：www.techzone.ltd<br></code></pre><p>因此很好推理：數組名其實就是一個<strong>「地址信息」</strong>，實際上就是數組<strong>「第一個元素的地址」</strong>。咱們試試把第一個元素的地址和數組的地址做個對比就知道了：</p><pre><code>//Example 03 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char url[100];<br>printf("請輸入TechZone的域名：");<br>url[99] = '\0';<br>scanf("%s", url);<br>printf("你輸入的域名是：%s\n", url);<br><br>printf("url的地址為：%p\n", url);<br>printf("url[0]的地址為：%p\n", &amp;url[0]);<br><br>if (url == &amp;url[0])<br>{<br>printf("兩者一致！");<br>}<br>else<br>{<br>printf("兩者不一致！");<br>}<br>return 0;<br>}<br></code></pre><p>程序運行結果為：</p><pre><code>//Comsequense 03 V2<br>請輸入TechZone的域名：www.techzone.ltd<br>你輸入的域名是：www.techzone.ltd<br>url的地址為：0063F804<br>url[0]的地址為：0063F804<br>兩者一致！<br></code></pre><p>這麼看，應該是實錘了。那麼數組後面的元素也就是依次往後放置，有興趣的也可以自己寫代碼嘗試把它們輸出看看。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指向數組的指針</strong></h2><p>剛剛我們驗證了數組的地址就是數組第一個元素的地址。那麼指向數組的指針自然也就有兩種定義的方法：</p><pre><code>...<br>char* p;<br>//方法1<br>p = a;<br>//方法2<br>p = &amp;a[0];<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指針的運算</strong></h2><p>當指針指向數組元素的時候，可以對指針變量進行<strong>「加減」</strong>運算，<code>+n</code>表示指向p指針所指向的元素的<strong>「下n個元素」</strong>，<code>-n</code>表示指向p指針所指向的元素的<strong>「上n個元素」</strong>。並不是將地址加1。</p><p>如：</p><pre><code>//Example 04<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int a = { 1,2,3,4,5 };<br>int* p = a;<br>printf("*p = %d, *(p+1) = %d, *(p+2) = %d\n", *p, *(p + 1), *(p + 2));<br>printf("*p -&gt; %p, *(p+1) -&gt; %p, *(p+2) -&gt; %p\n", p, p + 1, p + 2);<br>return 0;<br>}<br></code></pre><p>執行結果如下：</p><pre><code>//Consequence 04<br>*p = 1, *(p+1) = 2, *(p+2) = 3<br>*p -&gt; 00AFF838, *(p+1) -&gt; 00AFF83C, *(p+2) -&gt; 00AFF840<br></code></pre><p>有的小夥伴可能會想，編譯器是怎麼知道訪問下一個元素而不是地址直接加1呢？</p><p>其實就在我們定義指針變量的時候，就已經告訴編譯器了。如果我們定義的是整型數組的指針，那麼指針加1，實際上就是加上一個<code>sizeof(int)</code>的距離。相對於標準的下標訪問，使用指針來間接訪問數組元素的方法叫做<code>指針法</code>。</p><p>其實使用指針法來訪問數組的元素，不一定需要定義一個指向數組的單獨的指針變量，因為數組名自身就是指向數組<strong>「第一個元素」</strong>的指針，因此指針法可以直接作用於數組名：</p><pre><code>...<br>printf("p -&gt; %p, p+1 -&gt; %p, p+2 -&gt; %p\n", a, a+1, a+2);<br>printf("a = %d, a+1 = %d, a+2 = %d", *a, *(a+1), *(a+2));<br>...<br></code></pre><p>執行結果如下：</p><pre><code>p -&gt; 00AFF838, p+1 -&gt; 00AFF83C, p+2 -&gt; 00AFF840<br>b = 1, b+1 = 2, b+2 = 3<br></code></pre><p>現在你是不是感覺，數組和指針有點像了呢？不過筆者先提醒，數組和指針雖然非常像，但是絕對<strong>「不是」</strong>一種東西。</p><p>甚至你還可以直接用指針來定義字符串，然後用下標法來讀取每一個元素：</p><pre><code>//Example 05<br>//代碼來源於網絡<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char* str = "I love TechZone!";<br>int i, length;<br><br>length = strlen(str);<br><br>for (i = 0; i &lt; length, i++)<br>{<br>printf("%c", str[i]);<br>}<br>printf("\n");<br><br>return 0;<br>}<br></code></pre><p>程序運行如下：</p><pre><code>//Consequence 05<br>I love TechZone!<br></code></pre><p>在剛剛的代碼裡面，我們定義了一個<strong>「字符指針」</strong>變量，並且初始化成指向一個字符串。後來的操作，不僅在它身上可以使用<strong>「字符串處理函數」</strong>，還可以用<strong>「下標法」</strong>訪問字符串中的每一個字符。</p><p>當然，循環部分這樣寫也是沒毛病的：</p><pre><code>...<br>for (i = 0, i &lt; length, i++)<br>{<br>printf("%c", *(str + i));<br>}<br></code></pre><p>這就相當於利用了指針法來讀取。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指針和數組的區別</strong></h2><p>剛剛說了許多指針和數組相互替換的例子，可能有的小夥伴又開始說：“這倆貨不就是一個東西嗎？”</p><p>隨著你對指針和數組越來越瞭解，你會發現，C語言的創始人不會這麼無聊去創建兩種一樣的東西，還叫上不同的名字。指針和數組終究是<strong>「不一樣」</strong>的。</p><p>比如筆者之前看過的一個例子：</p><pre><code>//Example 06<br>//代碼來源於網絡<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char str = "I love TechZone!";<br>int count = 0;<br><br>while (*str++ != '\0')<br>{<br>count++;<br>}<br>printf("總共有%d個字符。\n", count);<br><br>return 0;<br>}<br></code></pre><p>當編譯器報錯的時候，你可能會開始懷疑你學了假的C語言語法：</p><pre><code>//Error in Example 06<br>錯誤(活動)E0137表達式必須是可修改的左值<br>錯誤C2105“++”需要左值<br></code></pre><p>我們知道，<code>*str++ != ‘\0’</code>是一個複合表達式，那麼就要遵循<strong>「運算符優先級」</strong>來看。具體可以回顧《C語言運算符優先級及ASCII對照表》。</p><p><code>str++</code>比<code>*str</code>的優先級<strong>「更高」</strong>，但是自增運算符要在<strong>「下一條語句」</strong>的時候才能生效。所以這個語句的理解就是，先取出<code>str</code>所指向的值，判斷是否為<code>\0</code>，若是，則跳出循環，然後<code>str</code>指向下一個字符的位置。</p><p>看上去貌似沒啥毛病，但是，看看編譯器告訴我們的東西：<code>表達式必須是可修改的左值</code></p><p><code>++</code>的操作對象是<code>str</code>，那麼<code>str</code>到底是不是<strong>「左值」</strong>呢？</p><p>如果是左值的話，那麼就必須滿足左值的條件。</p><blockquote><strong toutiao-origin=span>❝</strong><ol><li><p>擁有用於識別和定位一個存儲位置的標識符</p></li><li><p>存儲值可修改</p></li></ol>❞</blockquote><p>第一點，數組名<code>str</code>是可以滿足的，因為數組名實際上就是定位數組第一個元素的位置。但是第二點就不滿足了，數組名實際上是一個地址，地址是<strong>「不可以」</strong>修改的，它是一個常量。如果非要利用上面的思路來實現的話，可以將代碼改成這樣：</p><pre><code>//Example 06 V2<br>//代碼來源於網絡<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char str = "I love TechZone!";<br>char* target = str;<br>int count = 0;<br><br>while (*target++ != '\0')<br>{<br>count++;<br>}<br>printf("總共有%d個字符。\n", count);<br><br>return 0;<br>}<br></code></pre><p>這樣就可以正常執行了：</p><pre><code>//Consequence 06 V2<br>總共有16個字符。<br></code></pre><p>這樣我們就可以得出：數組名只是一個<strong>「地址」</strong>，而指針是一個<strong>「左值」</strong>。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指針數組？數組指針？</strong></h2><p>看下面的例子，你能分辨出哪個是指針數組，哪個是數組指針嗎？</p><pre><code>int* p1[5];<br>int(*p2)[5];<br></code></pre><p>單個的我們都可以判斷，但是組合起來就有些難度了。</p><p>答案：</p><pre><code>int* p1[5];//指針數組<br>int(*p2)[5];//數組指針<br></code></pre><p>我們挨個來分析。</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>指針數組</strong></h2><p>數組下標<code></code>的優先級是最高的，因此<code>p1</code>是一個有5個元素的<strong>「數組」</strong>。那麼這個數組的類型是什麼呢？答案就是<code>int*</code>，是<strong>「指向整型變量的指針」</strong>。因此這是一個<strong>「指針數組」</strong>。</p><p>那麼這樣的數組應該怎麼樣去初始化呢？</p><p>你可以定義5個變量，然後挨個取地址來初始化。</p><p>不過這樣太繁瑣了，但是，並不是說指針數組就沒什麼用。</p><p>比如：</p><pre><code>//Example 07<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char* p1[5] = {<br>"人生苦短，我用Python。",<br>"PHP是世界上最好的語言！",<br>"One more thing...",<br>"一個好的程序員應該是那種過單行線都要往兩邊看的人。",<br>"C語言很容易讓你犯錯誤；C++看起來好一些，但當你用它時，你會發現會死的更慘。"<br>};<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%s\n", p1[i]);<br>}<br>return 0;<br>}<br></code></pre><p>結果如下：</p><pre><code>//Consequence 07<br>人生苦短，我用Python。<br>PHP是世界上最好的語言！<br>One more thing...<br>一個好的程序員應該是那種過單行線都要往兩邊看的人。<br>C語言很容易讓你犯錯誤；C++看起來好一些，但當你用它時，你會發現會死的更慘。<br></code></pre><p>這樣是不是比二維數組來的更加直接更加通俗呢？</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>數組指針</strong></h2><p><code></code>和<code></code>在優先級裡面屬於<strong>「同級」</strong>，那麼就按照<strong>「先後順序」</strong>進行。</p><p><code>int(*p2)</code>將<code>p2</code>定義為<strong>「指針」</strong>， 後面跟隨著一個5個元素的<strong>「數組」</strong>，<code>p2</code>就指向這個數組。因此，數組指針是一個<strong>「指針」</strong>，它指向的是一個數組。</p><p>但是，如果想對數組指針初始化的時候，千萬要小心，比如：</p><pre><code>//Example 08<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int(*p2)[5] = {1, 2, 3, 4, 5};<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%d\n", *(p2 + i));<br>}<br>return 0;<br>}<br></code></pre><p>Visual Studio 2019報出以下的錯誤：</p><pre><code>//Error and Warning in Example 08<br>錯誤(活動)E0146初始值設定項值太多<br>錯誤C2440“初始化”: 無法從“initializer list”轉換為“int (*)[5]”<br>警告C4477“printf”: 格式字符串“%d”需要類型“int”的參數，但可變參數 1 擁有了類型“int *”<br></code></pre><p>這其實是一個非常典型的錯誤使用指針的案例，編譯器提示說這裡有一個<strong>「整數」</strong>賦值給<strong>「指針變量」</strong>的問題，因為<code>p2</code>歸根結底還是指針，所以應該給它傳遞一個<strong>「地址」</strong>才行，更改一下：</p><pre><code>//Example 08 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int temp[5] = {1, 2, 3, 4, 5};<br>int(*p2)[5] = temp;<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%d\n", *(p2 + i));<br>}<br>return 0;<br>}<br></code></pre><pre><code>//Error and Warning in Example 08 V2<br>錯誤(活動)E0144"int *" 類型的值不能用於初始化 "int (*)[5]" 類型的實體<br>錯誤C2440“初始化”: 無法從“int [5]”轉換為“int (*)[5]”<br>警告C4477“printf”: 格式字符串“%d”需要類型“int”的參數，但可變參數 1 擁有了類型“int *”<br></code></pre><p>可是怎麼還是有問題呢？</p><p>我們回顧一下，指針是如何指向數組的。</p><pre><code>int temp[5] = {1, 2, 3, 4, 5};<br>int* p = temp;<br></code></pre><p>我們原本以為，指針<code>p</code>是指向數組的指針，但是實際上<strong>「並不是」</strong>。仔細想想就會發現，這個指針實際上是指向的數組的<strong>「第一個元素」</strong>，而不是指向數組。因為數組裡面的元素在內存中都是挨著個兒存放的，因此只需要知道第一個元素的地址，就可以訪問到後面的所有元素。</p><p>但是，這麼來看的話，指針<code>p</code>指向的就是一個<strong>「整型變量」</strong>的指針，並不是指向<strong>「數組」</strong>的指針。而剛剛我們用的數組指針，才是指向數組的指針。因此，應該將<strong>「數組的地址」</strong>傳遞給數組指針，而不是將第一個元素的地址傳入，儘管它們值相同，但是<strong>「含義」</strong>確實不一樣：</p><pre><code>//Example 08 V3<br>//Example 08 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int temp[5] = {1, 2, 3, 4, 5};<br>int(*p2)[5] = &amp;temp;//此處取地址<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%d\n", *(*p2 + i));<br>}<br>return 0;<br>}<br></code></pre><p>程序運行如下：</p><pre><code>//Consequence 08<br>1<br>2<br>3<br>4<br>5<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指針和二維數組</strong></h2><p>在上一節《C語言之數組》我們講過<strong>「二維數組」</strong>的概念，並且我們也知道，C語言的二維數組其實在內存中也是<strong>「線性存放」</strong>的。</p><p>假設我們定義了：<code>int array[4][5]</code></p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>array</strong></h2><p>array作為數組的名稱，顯然應該表示的是數組的<strong>「首地址」</strong>。由於二維數組實際上就是一維數組的<strong>「線性拓展」</strong>，因此array應該就是指的<code>指向包含5個元素的數組的指針</code>。</p><p>如果你用<code>sizeof</code>去測試<code>array</code>和<code>array+1</code>的話，就可以測試出來這樣的結論。</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>*(array+1)</strong></h2><p>首先從剛剛的問題我們可以得出，<code>array+1</code>同樣也是指的<code>指向包含5個元素的數組的指針</code>，因此<code>*(array+1)</code>就是相當於<code>array[1]</code>，而這剛好相當於<code>array[1][0]</code>的數組名。因此<code>*(array+1)</code>就是指第二行子數組的第一個元素的地址。</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>*(*(array+1)+2)</strong></h2><p>有了剛剛的結論，我們就不難推理出，這個實際上就是<code>array[1][2]</code>。是不是感覺非常簡單呢？</p><p>總結一下，就是下面的這些結論，記住就好，理解那當然更好：</p><pre><code>*(array + i) == array[i]<br>*(*(array + i) + j) == array[i][j]<br>*(*(*(array + i) + j) + k) == array[i][j][k]<br>...<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>數組指針和二維數組</strong></h2><p>我們在上一節裡面講過，在初始化二維數組的時候是可以偷懶的：</p><pre><code>int array[3] = {<br>{1, 2, 3},<br>{4, 5, 6}<br>};<br></code></pre><p>剛剛我們又說過，定義一個數組指針是這樣的：</p><pre><code>int(*p)[3];<br></code></pre><p>那麼組合起來是什麼意思呢？</p><pre><code>int(*p)[3] = array;<br></code></pre><p>通過剛剛的說明，我們可以知道，<code>array</code>是指向一個3個元素的數組的<strong>「指針」</strong>，所以這裡完全可以將<code>array</code>的值賦值給<code>p</code>。</p><p>其實C語言的指針非常靈活，同樣的代碼用不同的角度去解讀，就可以有不同的應用。</p><p>那麼如何使用指針來訪問二維數組呢？沒錯，就是使用<strong>「數組指針」</strong>：</p><pre><code>//Example 09<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int array[3][4] = {<br>{0, 1, 2, 3},<br>{4, 5, 6, 7},<br>{8, 9, 10, 11}<br>};<br>int(*p)[4];<br>int i, j;<br>p = array;<br>for (i = 0, i &lt; 3, i++)<br>{<br>for (j = 0, j &lt; 4, j++)<br>{<br>printf("%2d ", *(*(p+i) + j));<br>}<br>printf("\n");<br>}<br>return 0;<br>}<br></code></pre><p>運行結果：</p><pre><code>//Consequence 09<br>0 1 2 3<br>4 5 6 7<br>8 9 10 11<br></code></pre><p></p><h1 toutiao-origin=h2>void指針</h1><p><code>void</code>實際上是<code>無類型</code>的意思。如果你嘗試用它來定義一個變量，編譯器肯定會<strong>「報錯」</strong>，因為不同類型所佔用的內存有可能<strong>「不一樣」</strong>。但是如果定義的是一個指針，那就沒問題。<code>void</code>類型中指針可以指向<strong>「任何一個類型」</strong>的數據，也就是說，任何類型的指針都可以賦值給<code>void</code>指針。</p><p>將任何類型的指針轉換為<code>void</code>是沒有問題的。但是如果你要反過來，那就需要<strong>「強制類型轉換」</strong>。此外，不要對<code>void</code>指針<strong>「直接解引用」</strong>，因為編譯器其實並不知道<code>void</code>指針會存放什麼樣的類型。</p><pre><code>//Example 10<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int num = 1024;<br>int* pi = &amp;num;<br>char* ps = "TechZone";<br>void* pv;<br><br>pv = pi;<br>printf("pi:%p,pv:%p\n", pi, pv);<br>printf("*pv:%d\n", *pv);<br><br>pv = ps;<br>printf("ps:%p,pv:%p\n", ps, pv);<br>printf("*pv:%s\n", *pv);<br>}<br></code></pre><p>這樣會報錯：</p><pre><code>//Error in Example 10<br>錯誤C2100非法的間接尋址<br>錯誤C2100非法的間接尋址<br></code></pre><p>如果一定要這麼做，那麼可以用<strong>「強制類型轉換」</strong>：</p><pre><code>//Example 10 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int num = 1024;<br>int* pi = &amp;num;<br>char* ps = "TechZone";<br>void* pv;<br><br>pv = pi;<br>printf("pi:%p,pv:%p\n", pi, pv);<br>printf("*pv:%d\n", *(int*)pv);<br><br>pv = ps;<br>printf("ps:%p,pv:%p\n", ps, pv);<br>printf("*pv:%s\n", pv);<br>}<br></code></pre><p>當然，使用void指針一定要小心，由於void指針幾乎可以<strong>「通吃」</strong>所有類型，所以間接使得不同類型的指針轉換變得合法，如果代碼中存在不合理的轉換，編譯器也不會報錯。</p><p>因此，void指針能不用則不用，後面講函數的時候，還可以解鎖更多新的玩法。</p><p></p><h1 toutiao-origin=h2>指針</h1><p>在C語言中，如果一個指針不指向任何數據，那麼就稱之為<strong>「空指針」</strong>，用<strong>「」</strong>來表示。其實是一個宏定義：</p><pre><code><strong class=highlight-text toutiao-origin=span>#define ((void *)0)</strong><br></code></pre><p>在大部分的操作系統中，地址0通常是一個<strong>「不被使用」</strong>的地址，所以如果一個指針指向，就意味著不指向任何東西。為什麼一個指針要指向呢？</p><p>其實這反而是一種比較指的推薦的<strong>「編程風格」</strong>——當你暫時還不知道該指向哪兒的時候，就讓它指向，以後不會有太多的麻煩，比如：</p><pre><code>//Example 11<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int* p1;<br>int* p2 = ;<br>printf("%d\n", *p1);<br>printf("%d\n", *p2);<br>return 0;<br>}<br></code></pre><p>第一個指針未被初始化。在有的編譯器裡面，這樣未初始化的變量就會被賦予<strong>「隨機值」</strong>。這樣指針被稱為<strong>「迷途指針」</strong>，<strong>「野指針」</strong>或者<strong>「懸空指針」</strong>。如果後面的代碼對這類指針解引用，而這個地址又剛好是合法的話，那麼就會產生莫名其妙的結果，甚至導致程序的崩潰。因此養成良好的習慣，在暫時不清楚的情況下使用，可以節省大量的後期調試的時間。</p><p></p><h1 toutiao-origin=h2>指向指針的指針</h1><p>開始套娃了。其實只要你理解了指針的概念，也就沒什麼大不了的。</p><pre><code>//Example 12<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int num = 1;<br>int* p = &amp;num;<br>int** pp = &amp;p;<br><br>printf("num: %d\n", num);<br>printf("*p: %d\n", *p);<br>printf("**p: %d\n", **pp);<br>printf("&amp;p: %p, pp: %p\n", &amp;p, pp);<br>printf("&amp;num: %p, p: %p, *pp: %p\n", &amp;num, p, *pp);<br>return 0;<br>}<br></code></pre><p>程序結果如下：</p><pre><code>//Consequence 12<br>num: 1<br>*p: 1<br>**p: 1<br>&amp;p: 004FF960, pp: 004FF960<br>&amp;num: 004FF96C, p: 004FF96C, *pp: 004FF96C<br></code></pre><p>當然你也可以無限地套娃，一直指下去。不過這樣會讓代碼可讀性變得<strong>「很差」</strong>，過段時間可能你自己都看不懂你寫的代碼了。</p><p></p><h1 toutiao-origin=h2>指針數組和指向指針的指針</h1><p>那麼，指向指針的指針有什麼用呢？</p><p>它可不是為了去創造混亂代碼，在一個經典的實例裡面，就可以體會到它的用處：</p><pre><code>char* Books = {<br>"《C專家編程》",<br>"《C和指針》",<br>"《C的陷阱與缺陷》",<br>"《C Primer Plus》",<br>"《Python基礎教程（第三版）》"<br>};<br></code></pre><p>然後我們需要將這些書進行分類。我們發現，其中有一本是寫Python的，其他都是C語言的。這時候指向指針的指針就派上用場了。首先，我們剛剛定義了一個指針數組，也就是說，裡面的所有元素的類型<strong>「都是指針」</strong>，而數組名卻又可以用指針的形式來<strong>「訪問」</strong>，因此就可以使用<strong>「指向指針的指針」</strong>來指向指針數組：</p><pre><code>...<br>char** Python;<br>char** CLang[4];<br><br>Python = &amp;Books[5];<br>CLang[0] = &amp;Books[0];<br>CLang[1] = &amp;Books[1];<br>CLang[2] = &amp;Books[2];<br>CLang[3] = &amp;Books[3];<br>...<br></code></pre><p>因為字符串的取地址值實際上就是其<strong>「首地址」</strong>，也就是一個<strong>「指向字符指針的指針」</strong>，所以可以這樣賦值。</p><p>這樣，我們就利用指向指針的指針完成了對書籍的分類，這樣既避免了浪費多餘的內存，而且當其中的書名要修改，只需要改一次即可，代碼的靈活性和安全性都得到了提升。</p><p></p><h1 toutiao-origin=h2>常量和指針</h1><p>常量，在我們目前的認知裡面，應該是這樣的：</p><pre><code>520, 'a'<br></code></pre><p>或者是這樣的：</p><pre><code><strong class=highlight-text toutiao-origin=span>#define MAX 1000</strong><br><strong class=highlight-text toutiao-origin=span>#define B 'b'</strong><br></code></pre><p>常量和變量最大的區別，就是前者<strong>「不能夠被修改」</strong>，後者可以。那麼在C語言中，可以將變量變成像具有常量一樣的特性，利用<code>const</code>即可。</p><pre><code>const int max = 1000;<br>const char a = 'a';<br></code></pre><p>在<code>const</code>關鍵字的作用下，變量就會<strong>「失去」</strong>本來具有的可修改的特性，變成“只讀”的屬性。</p><p></p><h1 toutiao-origin=h2>指向常量的指針</h1><p>強大的指針當然也是可以指向被<code>const</code>修飾過的變量，但這就意味著<strong>「不能通過」</strong>指針來修改它所引用的值。總結一下，就是以下4點：</p><blockquote><strong toutiao-origin=span>❝</strong><ol><li><p>指針可以修改為指向不同的變量</p></li><li><p>指針可以修改為指向不同的常量</p></li><li><p>可以通過解引用來讀取指針指向的數據</p></li><li><p>不可以通過解引用來修改指針指向的數據</p></li></ol>❞</blockquote><p></p><h1 toutiao-origin=h2>常量指針</h1><h2 toutiao-origin=h3><strong toutiao-origin=span>指向非常量的常量指針</strong></h2><p>指針本身作為一種<strong>「變量」</strong>，也是可以修改的。因此，指針也是可以被<code>const</code>修飾的，只不過位置稍稍<strong>「發生了點變化」</strong>：</p><pre><code>...<br>int* const p = &amp;num;<br>...<br></code></pre><p>這樣的指針有如下的特性：</p><blockquote><strong toutiao-origin=span>❝</strong><ol><li><p>指針自身不能夠被修改</p></li><li><p>指針指向的值可以被修改</p></li></ol>❞</blockquote><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指向常量的常量指針</strong></h2><p>在定義普通變量的時候也用<code>const</code>修飾，就得到了這樣的指針。不過由於限制太多，一般很少用到：</p><pre><code>...<br>int num = 100;<br>const int cnum = 200;<br>const int* const p = &amp;cnum;<br>...</code></pre><p>http://www.techzone.ltd/post/CPointer/</p><img alt=10分鐘，掌握C語言指針 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S25kjOh6BBFiP3></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>10</a></li><li><a>分鐘</a></li><li><a>語言</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/602bcbcd.html alt="每天這樣陪玩 10 分鐘，勝過上萬元早教班" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RlIqLlfA7COpuB style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/602bcbcd.html title="每天這樣陪玩 10 分鐘，勝過上萬元早教班">每天這樣陪玩 10 分鐘，勝過上萬元早教班</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17cb0041.html alt=10分鐘的時間，學習一套企業人員數量差距分析方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/a2efe19b-b6ea-4af6-a8c9-b467e2fc69a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17cb0041.html title=10分鐘的時間，學習一套企業人員數量差距分析方案>10分鐘的時間，學習一套企業人員數量差距分析方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b4739e4.html alt=10分鐘讀懂進程線程、同步異步、阻塞非阻塞、併發並行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/8ddc2ee4-9485-44d8-a243-c8a9fe56f222 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b4739e4.html title=10分鐘讀懂進程線程、同步異步、阻塞非阻塞、併發並行>10分鐘讀懂進程線程、同步異步、阻塞非阻塞、併發並行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ffba2d4.html alt=10分鐘快速檢測新冠病毒抗體！廈門海滄一公司研發出國內首個稀土納米熒光探針新冠檢測試劑產品 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ffba2d4.html title=10分鐘快速檢測新冠病毒抗體！廈門海滄一公司研發出國內首個稀土納米熒光探針新冠檢測試劑產品>10分鐘快速檢測新冠病毒抗體！廈門海滄一公司研發出國內首個稀土納米熒光探針新冠檢測試劑產品</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68d05cd2.html alt=稀土+納米，10分鐘快速檢測新冠病毒抗體 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d6f41c50e304738b11f05e90c86714b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68d05cd2.html title=稀土+納米，10分鐘快速檢測新冠病毒抗體>稀土+納米，10分鐘快速檢測新冠病毒抗體</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2fbd962b.html alt=“早盤10分鐘”才是一天最繁忙的黃金時刻！保證預測個股行情升與跌！定一天成敗！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RP8qiMG2R97AwK style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2fbd962b.html title=“早盤10分鐘”才是一天最繁忙的黃金時刻！保證預測個股行情升與跌！定一天成敗！>“早盤10分鐘”才是一天最繁忙的黃金時刻！保證預測個股行情升與跌！定一天成敗！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d661ede9.html alt=“集合競價10分鐘”全天盯盤的黃金時刻，掌握其精髓，能精準預測個股整天漲跌，1分鐘學會受益一生 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RSy3xEXH5wCFsN style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d661ede9.html title=“集合競價10分鐘”全天盯盤的黃金時刻，掌握其精髓，能精準預測個股整天漲跌，1分鐘學會受益一生>“集合競價10分鐘”全天盯盤的黃金時刻，掌握其精髓，能精準預測個股整天漲跌，1分鐘學會受益一生</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d22b80e.html alt=早盤10分鐘就確定一天成敗！“集合競價”10分鐘卻是全天的“黃金時刻”字字經典 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RM401MpI7zDiwt style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d22b80e.html title=早盤10分鐘就確定一天成敗！“集合競價”10分鐘卻是全天的“黃金時刻”字字經典>早盤10分鐘就確定一天成敗！“集合競價”10分鐘卻是全天的“黃金時刻”字字經典</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d55ff0c.html alt=10分鐘記住腦出血核磁表現——T1、T2篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ead13a9612344ef88e28f666fef37dc1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d55ff0c.html title=10分鐘記住腦出血核磁表現——T1、T2篇>10分鐘記住腦出血核磁表現——T1、T2篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fc4d70f.html alt=1滴血10分鐘完成檢測，華西醫院成功研發多款新冠病毒檢測試劑盒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rqwkcuw7Zz6oB9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fc4d70f.html title=1滴血10分鐘完成檢測，華西醫院成功研發多款新冠病毒檢測試劑盒>1滴血10分鐘完成檢測，華西醫院成功研發多款新冠病毒檢測試劑盒</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/c2420cdf.html alt=如何讓你在10分鐘內瞭解拓撲變換 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RF8AbzrEbG3RXp style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/c2420cdf.html title=如何讓你在10分鐘內瞭解拓撲變換>如何讓你在10分鐘內瞭解拓撲變換</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/458221c1.html alt=如何10分鐘內自己製作簡易防毒面具——末日求生手工技能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a61b2e418b3242aa92c4c9729fd2f313 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/458221c1.html title=如何10分鐘內自己製作簡易防毒面具——末日求生手工技能>如何10分鐘內自己製作簡易防毒面具——末日求生手工技能</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/d3c47558.html alt=10分鐘看通透K線缺口！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ffd3a42f9a7b4416834b68beae3cab55 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/d3c47558.html title=10分鐘看通透K線缺口！>10分鐘看通透K線缺口！</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/2f1001ef.html alt=10分鐘學會開關3大基本拓撲，適合入門級工程師學習 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f364abbd-7e74-450d-a322-5ebeaf5c5ac0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/2f1001ef.html title=10分鐘學會開關3大基本拓撲，適合入門級工程師學習>10分鐘學會開關3大基本拓撲，適合入門級工程師學習</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/6ba30bdb.html alt=簡單10分鐘清除涼蓆上的可惡蟎蟲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3c61000354db3f3e261e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/6ba30bdb.html title=簡單10分鐘清除涼蓆上的可惡蟎蟲>簡單10分鐘清除涼蓆上的可惡蟎蟲</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>