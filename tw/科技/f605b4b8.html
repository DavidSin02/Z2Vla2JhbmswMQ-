<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>懂了數據結構框架思維，一切算法不過是紙老虎 | 极客快訊</title><meta property="og:title" content="懂了數據結構框架思維，一切算法不過是紙老虎 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f605b4b8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f605b4b8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f605b4b8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f605b4b8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f605b4b8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f605b4b8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f605b4b8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f605b4b8.html><meta property="article:published_time" content="2020-11-14T21:07:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:42+08:00"><meta name=Keywords content><meta name=description content="懂了數據結構框架思維，一切算法不過是紙老虎"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f605b4b8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>懂了數據結構框架思維，一切算法不過是紙老虎</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><h1 class=pgc-h-arrow-right>一、數據結構的存儲方式</h1><p><strong>數據結構的存儲方式只有兩種：數組（順序存儲）和鏈表（鏈式存儲）</strong>。</p><p>這句話怎麼理解，不是還有散列表、棧、隊列、堆、樹、圖等等各種數據結構嗎？</p><p>我們分析問題，一定要有遞歸的思想，自頂向下，從抽象到具體。你上來就列出這麼多，那些都屬於「上層建築」，而數組和鏈表才是「結構基礎」。因為那些多樣化的數據結構，究其源頭，都是在鏈表或者數組上的特殊操作，API 不同而已。</p><p>比如說「隊列」、「棧」這兩種數據結構既可以使用鏈表也可以使用數組實現。用數組實現，就要處理擴容縮容的問題；用鏈表實現，沒有這個問題，但需要更多的內存空間存儲節點指針。</p><p>「圖」的兩種表示方法，鄰接表就是鏈表，鄰接矩陣就是二維數組。鄰接矩陣判斷連通性迅速，並可以進行矩陣運算解決一些問題，但是如果圖比較稀疏的話很耗費空間。鄰接表比較節省空間，但是很多操作的效率上肯定比不過鄰接矩陣。</p><p>「散列表」就是通過散列函數把鍵映射到一個大數組裡。而且對於解決散列衝突的方法，拉鍊法需要鏈表特性，操作簡單，但需要額外的空間存儲指針；線性探查法就需要數組特性，以便連續尋址，不需要指針的存儲空間，但操作稍微複雜些。</p><p>「樹」，用數組實現就是「堆」，因為「堆」是一個完全二叉樹，用數組存儲不需要節點指針，操作也比較簡單；用鏈表實現就是很常見的那種「樹」，因為不一定是完全二叉樹，所以不適合用數組存儲。為此，在這種鏈表「樹」結構之上，又衍生出各種巧妙的設計，比如二叉搜索樹、AVL 樹、紅黑樹、區間樹、B 樹等等，以應對不同的問題。</p><p>瞭解 Redis 數據庫的朋友可能也知道，Redis 提供列表、字符串、集合等等幾種常用數據結構，但是對於每種數據結構，底層的存儲方式都至少有兩種，以便於根據存儲數據的實際情況使用合適的存儲方式。</p><p>綜上，數據結構種類很多，甚至你也可以發明自己的數據結構，但是底層存儲無非數組或者鏈表，<strong>二者的優缺點如下</strong>：</p><p><strong>數組</strong>由於是緊湊連續存儲,可以隨機訪問，通過索引快速找到對應元素，而且相對節約存儲空間。但正因為連續存儲，內存空間必須一次性分配夠，所以說數組如果要擴容，需要重新分配一塊更大的空間，再把數據全部複製過去，時間複雜度 O(N)；而且你如果想在數組中間進行插入和刪除，每次必須搬移後面的所有數據以保持連續，時間複雜度 O(N)。</p><p><strong>鏈表</strong>因為元素不連續，而是靠指針指向下一個元素的位置，所以不存在數組的擴容問題；如果知道某一元素的前驅和後驅，操作指針即可刪除該元素或者插入新元素，時間複雜度 O(1)。但是正因為存儲空間不連續，你無法根據一個索引算出對應元素的地址，所以不能隨機訪問；而且由於每個元素必須存儲指向前後元素位置的指針，會消耗相對更多的儲存空間。</p><h1 class=pgc-h-arrow-right>二、數據結構的基本操作</h1><p>對於任何數據結構，其基本操作無非遍歷 + 訪問，再具體一點就是：增刪查改。</p><p><strong>數據結構種類很多，但它們存在的目的都是在不同的應用場景，儘可能高效地增刪查改</strong>。話說這不就是數據結構的使命麼？</p><p>如何遍歷 + 訪問？我們仍然從最高層來看，各種數據結構的遍歷 + 訪問無非兩種形式：線性的和非線性的。</p><p>線性就是 for/while 迭代為代表，非線性就是遞歸為代表。再具體一步，無非以下幾種框架：</p><p>數組遍歷框架，典型的線性迭代結構：</p><pre><code>void traverse(int[] arr) {    for (int i = 0; i &lt; arr.length; i++) {        // 迭代訪問 arr[i]    }}</code></pre><p>鏈表遍歷框架，兼具迭代和遞歸結構：</p><pre><code>/* 基本的單鏈表節點 */class ListNode {    int val;    ListNode next;}void traverse(ListNode head) {    for (ListNode p = head; p != null; p = p.next) {        // 迭代訪問 p.val    }}void traverse(ListNode head) {    // 遞歸訪問 head.val    traverse(head.next);}</code></pre><p>二叉樹遍歷框架，典型的非線性遞歸遍歷結構：</p><pre><code>/* 基本的二叉樹節點 */class TreeNode {    int val;    TreeNode left, right;}void traverse(TreeNode root) {    traverse(root.left);    traverse(root.right);}</code></pre><p>你看二叉樹的遞歸遍歷方式和鏈表的遞歸遍歷方式，相似不？再看看二叉樹結構和單鏈表結構，相似不？如果再多幾條叉，N 叉樹你會不會遍歷？</p><p>二叉樹框架可以擴展為 N 叉樹的遍歷框架：</p><pre><code>/* 基本的 N 叉樹節點 */class TreeNode {    int val;    TreeNode[] children;}void traverse(TreeNode root) {    for (TreeNode child : root.children)        traverse(child);}</code></pre><p>N 叉樹的遍歷又可以擴展為圖的遍歷，因為圖就是好幾 N 叉棵樹的結合體。你說圖是可能出現環的？這個很好辦，用個布爾數組 visited 做標記就行了，這裡就不寫代碼了。</p><p><strong>所謂框架，就是套路。不管增刪查改，這些代碼都是永遠無法脫離的結構，你可以把這個結構作為大綱，根據具體問題在框架上添加代碼就行了，下面會具體舉例</strong>。</p><h1 class=pgc-h-arrow-right>三、算法刷題指南</h1><p>首先要明確的是，<strong>數據結構是工具，算法是通過合適的工具解決特定問題的方法</strong>。也就是說，學習算法之前，最起碼得了解那些常用的數據結構，瞭解它們的特性和缺陷。</p><p>那麼該如何在 LeetCode 刷題呢？之前的文章算法學習之路寫過一些，什麼按標籤刷，堅持下去云云。現在距那篇文章已經過去將近一年了，我不說那些不痛不癢的話，直接說具體的建議：</p><p><strong>先刷二叉樹，先刷二叉樹，先刷二叉樹</strong>！</p><p>這是我這刷題一年的親身體會，下圖是去年十月份的提交截圖：</p><div class=pgc-img><img alt=懂了數據結構框架思維，一切算法不過是紙老虎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355><p class=pgc-img-caption></p></div><p>公眾號文章的閱讀數據顯示，大部分人對數據結構相關的算法文章不感興趣，而是更關心動規回溯分治等等技巧。為什麼要先刷二叉樹呢，<strong>因為二叉樹是最容易培養框架思維的，而且大部分算法技巧，本質上都是樹的遍歷問題</strong>。</p><p>刷二叉樹看到題目沒思路？根據很多讀者的問題，其實大家不是沒思路，只是沒有理解我們說的「框架」是什麼。<strong>不要小看這幾行破代碼，幾乎所有二叉樹的題目都是一套這個框架就出來了</strong>。</p><pre><code>void traverse(TreeNode root) {    // 前序遍歷    traverse(root.left)    // 中序遍歷    traverse(root.right)    // 後序遍歷}</code></pre><p>比如說我隨便拿幾道題的解法出來，不用管具體的代碼邏輯，只要看看框架在其中是如何發揮作用的就行。</p><p>LeetCode 124 題，難度 Hard，讓你求二叉樹中最大路徑和，主要代碼如下：</p><pre><code>int ans = INT_MIN;int oneSideMax(TreeNode* root) {    if (root == nullptr) return 0;    int left = max(0, oneSideMax(root-&gt;left));    int right = max(0, oneSideMax(root-&gt;right));    ans = max(ans, left + right + root-&gt;val);    return max(left, right) + root-&gt;val;}</code></pre><p>你看，這就是個後序遍歷嘛。</p><p>LeetCode 105 題，難度 Medium，讓你根據前序遍歷和中序遍歷的結果還原一棵二叉樹，很經典的問題吧，主要代碼如下：</p><pre><code>TreeNode buildTree(int[] preorder, int preStart, int preEnd,     int[] inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) {    if(preStart &gt; preEnd || inStart &gt; inEnd) return null;    TreeNode root = new TreeNode(preorder[preStart]);    int inRoot = inMap.get(root.val);    int numsLeft = inRoot - inStart;    root.left = buildTree(preorder, preStart + 1, preStart + numsLeft,                           inorder, inStart, inRoot - 1, inMap);    root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd,                           inorder, inRoot + 1, inEnd, inMap);    return root;}</code></pre><p>不要看這個函數的參數很多，只是為了控制數組索引而已，本質上該算法也就是一個前序遍歷。</p><p>LeetCode 99 題，難度 Hard，恢復一棵 BST，主要代碼如下：</p><pre><code>void traverse(TreeNode* node) {    if (!node) return;    traverse(node-&gt;left);    if (node-&gt;val &lt; prev-&gt;val) {        s = (s == NULL) ? prev : s;        t = node;    }    prev = node;    traverse(node-&gt;right);}</code></pre><p>這不就是個中序遍歷嘛，對於一棵 BST 中序遍歷意味著什麼，應該不需要解釋了吧。</p><p>你看，Hard 難度的題目不過如此，而且還這麼有規律可循，只要把框架寫出來，然後往相應的位置加東西就行了，這不就是思路嗎。</p><p>對於一個理解二叉樹的人來說，刷一道二叉樹的題目花不了多長時間。那麼如果你對刷題無從下手或者有畏懼心理，不妨從二叉樹下手，前 10 道也許有點難受；結合框架再做 20 道，也許你就有點自己的理解了；刷完整個專題，再去做什麼回溯動規分治專題，<strong>你就會發現只要涉及遞歸的問題，都是樹的問題</strong>。</p><p>再舉例吧，說幾道我們之前文章寫過的問題。</p><p>動態規劃詳解說過湊零錢問題，暴力解法就是遍歷一棵 N 叉樹：</p><div class=pgc-img><img alt=懂了數據結構框架思維，一切算法不過是紙老虎 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a5139a559724bc585e94221b880c290><p class=pgc-img-caption></p></div><pre><code>def coinChange(coins: List[int], amount: int):    def dp(n):        if n == 0: return 0        if n &lt; 0: return -1        res = float('INF')        for coin in coins:            subproblem = dp(n - coin)            # 子問題無解，跳過            if subproblem == -1: continue            res = min(res, 1 + subproblem)        return res if res != float('INF') else -1    return dp(amount)</code></pre><p>這麼多代碼看不懂咋辦？直接提取出框架，就能看出核心思路了：</p><pre><code># 不過是一個 N 叉樹的遍歷問題而已def dp(n):    for coin in coins:        dp(n - coin)</code></pre><p>其實很多動態規劃問題就是在遍歷一棵樹，你如果對樹的遍歷操作爛熟於心，起碼知道怎麼把思路轉化成代碼，也知道如何提取別人解法的核心思路。</p><p>再看看回溯算法，前文回溯算法詳解乾脆直接說了，回溯算法就是個 N 叉樹的前後序遍歷問題，沒有例外。</p><p>比如 N 皇后問題吧，主要代碼如下：</p><pre><code>void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) {  if (track.size() == nums.length) {    res.add(new LinkedList(track));    return;   }    for (int i = 0; i &lt; nums.length; i++) {        if (track.contains(nums[i]))            continue;        track.add(nums[i]);        // 進入下一層決策樹        backtrack(nums, track);        track.removeLast();    }/* 提取出 N 叉樹遍歷框架 */void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) {    for (int i = 0; i &lt; nums.length; i++) {        backtrack(nums, track);}</code></pre><p>N 叉樹的遍歷框架，找出來了把～你說，樹這種結構重不重要？</p><p><strong>綜上，對於畏懼算法的朋友來說，可以先刷樹的相關題目，試著從框架上看問題，而不要糾結於細節問題</strong>。</p><p>糾結細節問題，就比如糾結 i 到底應該加到 n 還是加到 n - 1，這個數組的大小到底應該開 n 還是 n + 1 ？</p><p>從框架上看問題，就是像我們這樣基於框架進行抽取和擴展，既可以在看別人解法時快速理解核心邏輯，也有助於找到我們自己寫解法時的思路方向。</p><p>當然，如果細節出錯，你得不到正確的答案，但是只要有框架，你再錯也錯不到哪去，因為你的方向是對的。</p><p>但是，你要是心中沒有框架，那麼你根本無法解題，給了你答案，你也不會發現這就是個樹的遍歷問題。</p><p>這種思維是很重要的，動態規劃詳解中總結的找狀態轉移方程的幾步流程，有時候按照流程寫出解法，說實話我自己都不知道為啥是對的，反正它就是對了。。。</p><p><strong>這就是框架的力量，能夠保證你在快睡著的時候，依然能寫出正確的程序；就算你啥都不會，都能比別人高一個級別。</strong></p><h1 class=pgc-h-arrow-right>四、總結幾句</h1><p>數據結構的基本存儲方式就是鏈式和順序兩種，基本操作就是增刪查改，遍歷方式無非迭代和遞歸。</p><p>刷算法題建議從「樹」分類開始刷，結合框架思維，把這幾十道題刷完，對於樹結構的理解應該就到位了。這時候去看回溯、動規、分治等算法專題，對思路的理解可能會更加深刻一些。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>思維</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html alt=一文看懂編程中的基本數據結構與算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html title=一文看懂編程中的基本數據結構與算法思想>一文看懂編程中的基本數據結構與算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html alt=數據結構與算法（7）遞歸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html title=數據結構與算法（7）遞歸>數據結構與算法（7）遞歸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/062bbe77.html alt=軟考自查：數據結構與算法基礎（內容有點多！！！） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/60f8235323314304b4dac050f8cb1e7d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/062bbe77.html title=軟考自查：數據結構與算法基礎（內容有點多！！！）>軟考自查：數據結構與算法基礎（內容有點多！！！）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>