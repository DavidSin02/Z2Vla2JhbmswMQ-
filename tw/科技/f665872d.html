<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「數據庫」 redis入門到實戰 | 极客快訊</title><meta property="og:title" content="「數據庫」 redis入門到實戰 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f665872d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f665872d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f665872d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f665872d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f665872d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f665872d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f665872d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f665872d.html><meta property="article:published_time" content="2020-11-14T20:59:32+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:32+08:00"><meta name=Keywords content><meta name=description content="「數據庫」 redis入門到實戰"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f665872d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「數據庫」 redis入門到實戰</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><pre><code>- 基本介紹 	- 為什麼會用redi, 為什麼大小公司都在用redis		- 微信紅包		- 微博		- 淘寶	- 講到redis不得不將nosql		- nosql是不同於傳統的關係型數據庫管理系統的統稱, 其兩者最重要的區別是nosql不使用sql作為查詢語句		- noql數據庫可以不需要固定的表格模式, noql是基於鍵值對, 可以想象成表中的主鍵和值的對應關係		- nosql: redis, memcached, mongodb, guava(loadingCache)- redis定義	- redishi一個開源(BSD許可)的, 內存中的數據結構存儲系統, 他可以用作數據庫, 緩存和消息中間件, 它支持多種類型的數據結構, 如字符串(strings), 數列(hashes), 列表(lists),集合(sets),有序集合(sorted sets) 等- 從大家熟悉的mysql出發來認識redis	- 概念: 關係型數據庫的一個長江用法是存儲長期的報告數據, 並將這些報告數據用作固定時間範圍內的聚合數據, 收集聚合數據的常見做法是: 先將各個行插入一個報告表裡面, 之後再通過掃描這些行來收集聚合數據	- 圖解剖析mysql的執行過程(網上自己找圖看)- 分析redis和mencached和mysql之間的區別	- 從數據庫類型, 數據存儲方式, 特殊功能講解redis和mencached和mysql的區別	- 作為同款功能的內存緩存產品, redis和memcached各有什麼優勢		- 內存管理機制			- mencached默認使用Slab Allocation機制管理內存, 其主要思想按照預先規定的大小, 將分配的內存分割成特定長度的塊, 以存儲相應長度的key-value數據記錄, 以完全解決內容碎片問題, 			- redis使用現場申請內存的方式來存儲數據, 並且很少使用free-list等方式來優化內存分配, 會在一定程度上存在內存碎片		- 數據持久化方案			- memcached不支持內存數據的持久化操作, 所有的數據都以in-memory的形式存儲			- redis支持持久化操作, redi提供了兩種不同的持久化方法來將數據存儲到硬盤裡面				- 第一種是rdb形式: 基於全量護具備份, 備份的是數據				- 第二種是aof形式: append only if, 增量持久化備份, 備份的是指令 [例如: set key, del key]		- 緩存數據過期機制			- mencached在刪除失效主鍵時也是採用消極方法, 即memcached內部也不會見識主鍵是否失敗, 而是在通過get訪問主鍵時才會檢查其是否已經失敗			- 定時, 定期等多種緩存失效機制, 減少內存洩露- redis作為數據庫和作為內存緩存的兩種使用方法	- redis作為數據庫的使用有什麼優缺點:		- 優點: 沒有Schema約束, 數據結構的變更相對容易, 抗壓能力強, 性能極高		- 缺點: 沒有索引, 沒有外鍵, 缺少int/date等基本數據類型, 多條件查詢需要通過集合內聯(sinter, zintertore)和鏈接間接開發效率低, 可維護性不佳	- redis作為緩存的左右, 搭配數據庫使用的兩種方法		- jedis整合使用方案			- 第一層在緩存進行查詢, 如果得到數據則直接返回			- 第二層在數據庫進行查詢, 並且刷新緩存, 方便下次查詢		- 作為mybatis/hibernate二級緩存使用方法				- 一級緩存: sqlSession級別, 進程緩存, 單次鏈接有效	- 圖解分析加redis前後的架構區別		</code></pre><h3 class=pgc-h-arrow-right>掌握redis五中數據結構（string，list，set，sortset，hash）</h3><pre><code>- String： 是最常用的一種數據類型， 普通的key/value存儲都可以歸為此類- set/get	- 設置key對應的值為string類型的value	- 獲取key對應的值- mget	- 批量獲取多個key的值， 如果可以不存在則返回null- incr && incrby	- incr對key對應的值進行加加操作， 並返回新的值； incrby加指定值- decr && decrby	- decr對key對應的值進行減減操作， 並返回新的值； decrby減指定值- sentx	- 設置key對應的值為String類型的value， 如果key直徑存在則返回0- setex	- 設置key對應的值為string類型的value， 並設定有效時間- 其他指令	- getrange： 獲取key對應value的子字符串	- mset： 數量設置多個key的值， 如果成功表示所有值都被設置， 否則返回0表示沒有任何值被設置	- msetnx， 同mset， 不存在就設置， 不會覆蓋已有的key	- getset： 設置key的值， 並返回key舊的值	- append： 給指定key的value增加字符串， 並返回新字符串的長度</code></pre><h3 class=pgc-h-arrow-right>Hash類型</h3><pre><code>- Hash類似於HashMap 	- key / value的形式	- 格式: Map&lt;String, Map&lt;String, String&gt;&gt;		- 第一個String 就是 Map&lt;String, String&gt; 的名稱- Hash 是一個String類型的field和value之間的映射類- redis的Hash數據類型的key(hash表名稱)對應的value實際的內部存儲結構為一個HashHashMap- Hash特別適合存儲對象	- 相當於把一個對象的每個屬性存儲String類型, 將整個對象存儲在Hash類型中會佔用更少內存.- 所存儲的成員較少時數據存儲為zipmap, 當成員數量大時會自動轉成真正的HashMap, 此時encoding為ht- 運用場景:	- 如用一個對象來存儲對象信息, 商品信息, 訂單信息等等- Hash命令講解:	- hset: 設置key對應的HashMap中的field的value	- hget: 獲取key對應的HashMap中的field的value	- hgetall: 獲取所有key-value信息	- hmset: 一次設置多個屬性	- hdel: 刪除一個屬性	- hlen: 獲取set的長度</code></pre><h3 class=pgc-h-arrow-right>LIst數據類型</h3><pre><code>- lpush: 在key對應的list的頭部添加一個元素- lrange: 獲取key對應的list的指定下標範圍的元素, -1表示獲取所有元素- lpop: 從key對應的list的頭部刪除一個元素, 並返回該元素- rpush: 在key對應的list的尾部添加一個元素- rpop: 從key對應的list的尾部刪除一個元素, 並返回該元素- lrem: 刪除一定個數或者指定的元素	- lrem list 2 value2 刪除兩個值為value2的記錄- lindex: 獲取指定索引下標的值- llen: 獲取list的長度</code></pre><h3 class=pgc-h-arrow-right>set集合</h3><pre><code>- sadd: 在key對應的set中添加一個元素- smembers: 獲取key對應的set的所有元素- spop: 隨機返回並刪除key對應的set中的一個元素- suion: 求給定key對應的set並集- sinter: 求給定key對應的set交集- sdiff: 求給定key對應的set的差集</code></pre><h3 class=pgc-h-arrow-right>SortSet講解</h3><pre><code>- zadd: 在key對應的zset中添加一個元素- zrange:  獲取key對應的zset中指定範圍的元素, -1表示獲取所有元素- zrem: 刪除key對應的zset中的一個元素- zrangebyscore: 返回有序集key中, 指定分戶範圍的元素列表- zrank: 返回key對應的zet中指定member的排名, 其中member按score值遞增(從小到大), 排名以0為底, 也就是說, score值是最小的成員排名為0- zcard: 查詢sortset有多少個元素(長度)- set是通過hasmmap存儲, key對應et的元素, value是空對象- sortset是怎麼存儲並實現排序的呢, hashmap存儲, 還加了一層跳躍表- 跳躍表: 相當於雙向鏈表, 在其基礎上添加前往比當前元素大的跳躍鏈接</code></pre><h3 class=pgc-h-arrow-right>redis發佈訂閱</h3><pre><code>- 發佈訂閱作用: 類似於信息管道, 用來進行系統之間消息解耦, 類似於mq, rabbitmq, rocketmq, kafka, activemq, 主要有消息發佈者和消息訂閱者- PUBLISH: 將消息message發送到指定的平道channel, 返回收到消息的客戶端信息- SUBSCRIBE: 訂閱給指定頻道的信息- UNSUBSCRIBE: 取消訂閱指定的頻道, 如果不指定, 則取消訂閱所有的頻道</code></pre><h3 class=pgc-h-arrow-right>傳統關係型數據庫事務</h3><pre><code>- 一個數據庫事務通常包含了一個序列的對數據庫的讀寫操作, 他的存在包含有以下兩個目的	- 為數據庫操作序列提供了一個從失聯中恢復到正常狀態的方法, 同時提供了數據庫即使在異常狀態下仍然能保持一致性的方法	- 當多個應用程序在併發訪問數據庫時, 可以在這些應用程序之間提供一個隔離方法, 以防止彼此的操作互相干擾- 事務ACID四大特性	- 原子性(Atomicity): 事務作為一個整體被執行, 包含在其中的對數據庫的操作要麼全部成功, 要麼全部不成功	- 一致性(Consistency): 事務應該確保數據庫的狀態從一個狀態轉變為另一個狀態一致	- 隔離性(Isolation): 多個事務併發執行時, 一個事務的執行不會影響另外一個事務	- 持久性(Durability): 已經被提交的事務對數據的修改應該是永久保存在數據庫中- 事務隔離機制:	- read uncommitted 讀未提交	- read committed 讀已提交	- repeatable read 可重複讀	- serializable 串行化</code></pre><h3 class=pgc-h-arrow-right>redis事務機制</h3><pre><code>- MULTI 與 EXEX命令	- 以MULTI開始一個事務, 然後將多個命令如隊列到事務中, 最後由EXEC命令觸發事務, 一併執行十五中的所有命令- DISCARD命令	- DISCARD命令用於取消一個事務, 他清空客戶端整個事務隊列, 然後將客戶端從事務狀態調整回非事務狀態, 最後返回字符串OK給客戶端, 說明事務已經被取消- WATCH命令	- WATCH命令用於在事務開始之前見識任意數量的鍵. 當調用EXEC命令執行事務時, 如果任意一個被見識的鍵已經被其他客戶端修改了, 那麼整個事務不再執行, 直接返回失敗.- 圖解redis執行事務過程原理</code></pre><h3 class=pgc-h-arrow-right>redis事務與傳統關係型事務的比較</h3><pre><code>- 原子性(Automicity)	- 單個Redis命令的執行是原子性的, 但Redis沒有在事務上增加任何維持原子性的機制, 所以Redis事務的執行並不是原子性的, 如果一個事務隊列中的所有命令都被成功的執行, 那麼稱這個事務執行成功- 一致性(Consistency)	- 入隊錯誤		- 在命令入隊的過程中, 如果客戶端向服務器發送了錯誤的命令, 比如命令命令參數數量不對,等等, 那麼服務器向客戶端返回一個出錯信息, 並且將客戶端的事務狀態設為 REDIS_DIRTY_EXEC	- 執行錯誤		- 如果命令在事務執行的過程中發生錯誤, 比如說, 對一個不同類型的key執行了錯誤的錯誤, 那麼Redis只會將錯誤包含在事務的結果中, 這不會引起事務中斷或這個失敗, 不會影響已執行事務命令的結果, 也不會影響後續要執行的事務命令, 所以他對事務的一致性也沒有影響- 隔離性(Isolation)	- WATCH 命令用於在事務開始之前見識任意數量的鍵, 當調用EXEC命令執行事務時, 如果任意一個被監控的鍵被其他客戶端修改了, 那麼整個事務不再執行, 直接返回失敗- 持久性(Durability)	- 因為事務不過是用隊列包裹起了一組Redis命令, 並沒有提供任何額外的持久性功能, 所以事務的持久性由redis所使用的持久化模式決定	- redis持久化模式包括:		- rdb: 數據內存備份		- aof(append onlyif增量備份), 每個一秒做一個備份</code></pre><h3 class=pgc-h-arrow-right>springboot整合redis</h3><pre><code>- 引入依賴	&lt;dependency&gt;	    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;	    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;	    &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;	&lt;/dependency&gt;- 引入bean 	- redisTemplate的使用, 類似於: mongoTemplate, jdbcTemplate數據庫鏈接工具, RedisTemplate是從redisConnectionFactory中獲取的	- 引入jar包 spring-boot-starter-data-redis- 實例代碼	- RedisConfig.java		package cn.jishupeng.redis.config;		import org.springframework.context.annotation.Bean;		import org.springframework.context.annotation.Configuration;		import org.springframework.data.redis.connection.RedisConnectionFactory;		import org.springframework.data.redis.core.RedisTemplate;				@Configuration		public class RedisConfig {		    @Bean		    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {		        RedisTemplate&lt;String, String&gt; redisTemplate = new RedisTemplate&lt;&gt;();		        redisTemplate.setConnectionFactory(redisConnectionFactory);		        return redisTemplate;		    }		}	- textController.java		package cn.jishupeng.redis.controller;		import org.springframework.beans.factory.annotation.Autowired;		import org.springframework.data.redis.core.RedisTemplate;		import org.springframework.data.redis.core.StringRedisTemplate;		import org.springframework.web.bind.annotation.GetMapping;		import org.springframework.web.bind.annotation.RestController;				import javax.annotation.Resource;		import java.util.HashMap;		import java.util.Map;				@RestController		public class test {				    @Resource		    private RedisTemplate redisTemplate;				    @GetMapping(&#34;/setAndget&#34;)		    public String index(String name) {		        redisTemplate.opsForValue().set(&#34;name&#34;, name);				        return (String)redisTemplate.opsForValue().get(&#34;name&#34;);		    }		}		</code></pre><h3 class=pgc-h-arrow-right>redisTemplate api</h3><pre><code>- opsForValue -&gt; String- opsForSet -&gt; Set- opsForHash -&gt; Hash- opsForZset -&gt; SortSet- opsForList -&gt; List</code></pre><h3 class=pgc-h-arrow-right>springboot快速整合mybatis(極簡 mysql版本8.X)</h3><pre><code>- 加入依賴	&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.11&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.10&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;        &lt;/dependency&gt;- 配置application.properties文件	spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver	spring.datasource.url=jdbc:mysql://localhost:3306/redis?characterEncoding=utf-8&serverTimezone=UTC&useSSL=false&allowP	spring.datasource.username=root	spring.datasource.password=123456	spring.datasource.type=com.alibaba.druid.pool.DruidDataSource- 啟動類加上@MapperScan(basePackage = )註解	package cn.jishupeng.redis;	import org.mybatis.spring.annotation.MapperScan;	import org.springframework.boot.SpringApplication;	import org.springframework.boot.autoconfigure.SpringBootApplication;		@MapperScan(basePackages = &#34;cn.jishupeng.redis.mapper&#34;)	@SpringBootApplication	public class RedisApplication {		    public static void main(String[] args) {	        SpringApplication.run(RedisApplication.class, args);	    }		}	- 創建UserMapper包(該文件下都是接口文件, 每個文件都要加上@Mapper註解, 否則掃描不到)	package cn.jishupeng.redis.mapper;	import cn.jishupeng.redis.domain.User;	import org.apache.ibatis.annotations.Mapper;	import org.apache.ibatis.annotations.Select;		import java.util.List;		@Mapper	public interface UserMapper {	    @Select(&#34;select * from user&#34;)	    User find();	}	- domain/User 實體類文件	package cn.jishupeng.redis.domain;	import org.springframework.stereotype.Repository;			public class User {	    private int id;	    private String username;		    public int getId() {	        return id;	    }		    public void setId(int id) {	        this.id = id;	    }		    public String getUsername() {	        return username;	    }		    public void setUsername(String username) {	        this.username = username;	    }		    @Override	    public String toString() {	        return &#34;User{&#34; +	                &#34;id=&#34; + id +	                &#34;, username=&#39;&#34; + username + &#39;\&#39;&#39; +	                &#39;}&#39;;	    }	}- controller/TestController(常規使用, 直接使用@Autowired注入UserMapper文件, 就可以快樂玩耍啦...)	package cn.jishupeng.redis.controller;	import cn.jishupeng.redis.mapper.UserMapper;	import org.springframework.beans.factory.annotation.Autowired;	import org.springframework.data.redis.core.RedisTemplate;	import org.springframework.data.redis.core.StringRedisTemplate;	import org.springframework.web.bind.annotation.GetMapping;	import org.springframework.web.bind.annotation.RestController;		import javax.annotation.Resource;	import java.util.HashMap;	import java.util.Map;		@RestController	public class test {	    @Autowired	    private UserMapper userMapper;		    @Resource	    private RedisTemplate redisTemplate;		    @GetMapping(&#34;/setAndget&#34;)	    public String index(String name) {	        redisTemplate.opsForValue().set(&#34;name&#34;, name);		        return (String)redisTemplate.opsForValue().get(&#34;name&#34;);	    }		    @GetMapping(&#34;/getUser&#34;)	    public String getUser() {	        return (String)userMapper.find().getUsername();	    }	}</code></pre><h3 class=pgc-h-arrow-right>redis作為mybatis緩存整合</h3><pre><code>- 用戶第一次訪問的時候獲取數據庫的值, 再次訪問時直接從緩存中獲取數據- 設置緩存過期時間- 項目8080端口是對外端口(向外部暴露的端口), 區別內部進程號, 查內部端口用ps -ef|grep, 查外部端口用 lsof -i:8080- 緩存級別	- 一級緩存: sqlSession, sql建立鏈接到關閉鏈接的數據緩存	- 二級緩存: 全局- springboot cache的使用: 可以結合redis, ehcache等緩存	- @Cacheable: (查詢時使用)來劃分可緩存的方法, 即, 結果存儲在緩存中的方法, 以便在後續調用(具有相同的參數)時, 返回緩存中的值而不必實際執行該方法	- @CachePut: (更新時使用)當需要更新緩存而不干擾方法執行時, 可以使用@CachePut註釋, 也就是說, 始終執行該方法並將其結果放入緩存中(根據@CachePut選項)	- @CacheEvict:(刪除時使用) 對於從緩存中刪除舊或未使用的數據非常有用, 指示緩存範圍內的驅逐是否需要執行而不僅僅是一個條目驅逐- springboot整合cache的步驟	- 引入依賴 spring-boot-starter-cache	- 開啟緩存註解: @EnableCaching	- 在方法上面加入SpEL</code></pre><h3 class=pgc-h-arrow-right>redis分佈式緩存</h3><pre><code>- 引入依賴: 		&lt;dependency&gt;            &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;            &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;            &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;- 加入註解 @EnableRedisHttpSession(maxInactiveIntervalInSeconds = 50)- controller方法	package cn.jishupeng.redis.controller;	import org.springframework.http.HttpRequest;	import org.springframework.web.HttpRequestHandler;	import org.springframework.web.bind.annotation.GetMapping;	import org.springframework.web.bind.annotation.RequestMapping;	import org.springframework.web.bind.annotation.ResponseBody;	import org.springframework.web.bind.annotation.RestController;		import javax.servlet.http.HttpServletRequest;	import java.util.HashMap;	import java.util.Map;		@RequestMapping(&#34;/session&#34;)	@RestController	public class RedisHttpSession {	    @RequestMapping(&#34;/set&#34;)	    @ResponseBody	    public Map&lt;String, String&gt; set(HttpServletRequest request) {	        Map&lt;String, String&gt; ret = new HashMap&lt;&gt;();	        request.getSession().setAttribute(&#34;request Uri&#34;, request.getRequestURI());	        ret.put(&#34;request Uri&#34;, request.getRequestURI());	        return ret;	    }		    @RequestMapping(&#34;/get&#34;)	    @ResponseBody	    public Map&lt;String, Object&gt; get(HttpServletRequest request) {	        Map&lt;String, Object&gt; ret = new HashMap&lt;&gt;();	        Object id = request.getSession().getId();	        ret.put(&#34;request Uri&#34;, id);	        return ret;	    }	}- redis客戶端中	- keys * 查找所有的鍵	- ttl 查看超時時間</code></pre><h3 class=pgc-h-arrow-right>redis項目實戰值排行榜實現(上)</h3><pre><code>- 排行榜	- 排行榜功能是一個很普遍的需求, 使用redis中有序集合的特性來實現排行榜是又好又快的實現	- 一般排行榜都是有時效性, 比如&#34;&#34;用戶積分榜&#34;, 遊戲中活躍度排行榜, 遊戲裝備排行榜等等- 面臨問題: 數據庫設計複雜, 併發較高, 數據要求實時性高- redis實現排行榜api講解</code></pre><h3 class=pgc-h-arrow-right>淺談mysql數據庫設計</h3><pre><code>- 表設計過程中應該注意的點即數據類型	- 更小的通常更好, 控制字節長度	- 使用合適的數據類型		- 如tinyint只佔8個位, char與varchar的對比	- 儘量避免NULL NOT NULL DEFAULT &#39;&#39;		- NULL的列會讓索引統計和值比較都更復雜. 可為NULL的列會佔據更多的磁盤空間, 在Mysql中也需要更多複雜的處理程序	- 索引設計過程中更應該注意的點	- 選擇唯一性索引		- 唯一性索引的值是唯一的, 可以更快的通過該索引來確定某條記錄	- 為經常需要排序, 分組和聯合操作的字段建立索引		- 經常需要order by, group by, distinct和union等操作的字段, 排序操作會浪費更多的時間	- 長作為查詢條件的字段建立索引		- 如果某個字段常用來做查詢條件, 那麼該字段的查詢速度會影響整個表的查詢速度	- 數據少的地方不必建立索引- sql優化, explain查看執行計劃	- 能夠用between的就不要用in	- 能夠用distinct的就不要用group by	- 避免數據強轉	- 學會採用wxplain查看執行計劃</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據庫</a></li><li><a>redis</a></li><li><a>入門</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html alt=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html title=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理>解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html alt=EXCEL入門基礎：對行和列選定數據求和 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1f03f82096d240dd92410709f3e19eb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html title=EXCEL入門基礎：對行和列選定數據求和>EXCEL入門基礎：對行和列選定數據求和</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html alt=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49834ccb43ed42cb9a54c9827c3ab134 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html title=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！>工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html alt=工程造價：入門知識全套講義，30章600頁，精通造價首選之作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e1b335c343a455f8777dd3144fc1c35 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html title=工程造價：入門知識全套講義，30章600頁，精通造價首選之作>工程造價：入門知識全套講義，30章600頁，精通造價首選之作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html alt=“黑客”入門學習之“Windows組策略” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea21244d5f5c420ebef29650f3fafd1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html title=“黑客”入門學習之“Windows組策略”>“黑客”入門學習之“Windows組策略”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18681b55.html alt=PHP鏈接數據庫操作教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3b10e2d3b35043f8ae9cb1823878b66a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18681b55.html title=PHP鏈接數據庫操作教程>PHP鏈接數據庫操作教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html alt=PHP入門教程，5天86節課助力小白變大神！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4366000004d4c98fd587 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html title=PHP入門教程，5天86節課助力小白變大神！>PHP入門教程，5天86節課助力小白變大神！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html alt=Thinkphp6快速入門一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c4331ddc0ffb4c94a4aa80be95178354 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html title=Thinkphp6快速入門一>Thinkphp6快速入門一</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html alt="php新手入門教程， 最全最完整的教學視頻課程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/666a38216ab04790a716bb1451c7fe44 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html title="php新手入門教程， 最全最完整的教學視頻課程">php新手入門教程， 最全最完整的教學視頻課程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html alt=「素描入門」基礎不紮實，從排線練起 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15252166717297d7af296ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html title=「素描入門」基礎不紮實，從排線練起>「素描入門」基礎不紮實，從排線練起</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html alt=「素描入門」素描排線的繪畫技法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1530098801296ab58189790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html title=「素描入門」素描排線的繪畫技法>「素描入門」素描排線的繪畫技法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>