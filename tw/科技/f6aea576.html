<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>FPGA為什麼可編程，這篇文章來告訴你 | 极客快訊</title><meta property="og:title" content="FPGA為什麼可編程，這篇文章來告訴你 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d7abe76ede514e308d57ca293420a430"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6aea576.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6aea576.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6aea576.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6aea576.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6aea576.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6aea576.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6aea576.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6aea576.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="FPGA為什麼可編程，這篇文章來告訴你"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f6aea576.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>FPGA為什麼可編程，這篇文章來告訴你</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>介紹一篇在FPGA工程領域特別有價值的文章，雖然該文僅僅是EI檢索，連SCI檢索都不是，但其對深入理解FPGA動態可重構的概念卻具有重要的參考價值。文章闡述了Xilinx FPGA可編程的本質，逆向分析破解了FPGA編程的bit流文件，並將其與FPGA內部電路相對應，對於深度理解動態可編程及FPGA電路結構具有重要的指導價值，LUT動態可編程使得FPGA內部的資源使用起來更靈活，你可以把LUT當成BRAM使用，也可以隨時改變若干個LUT組成電路完成的硬件功能，而這些過程的實現細節網上的資料非常少，團隊研究生花費近三個月重現了該文的內容，整理完畢後會把詳細實現過程分享給大家，敬請期待。本文只是用工具把英文文章翻譯了一下分享給大家（如今的工具翻譯水平的確不錯）。希望看到的大牛們能夠給予指導。</p></blockquote><p class=ql-align-justify>論文標題：AC_ICAP靈活的高速ICAP控制器</p><p class=ql-align-justify>論文摘要：內部配置訪問端口（ICAP）是基於Xilinx SRAM的現場可編程門陣列（FPGA）中實現的任何動態部分可重配置系統的核心組件。我們開發了一種新的高速ICAP控制器，名為AC ICAP，完全採用硬件實現。除了加速部分比特流和幀的管理的類似解決方案之外，AC ICAP還支持LUT的運行時重新配置，而無需預先計算的部分比特流。<strong>通過對比特流執行逆向工程</strong>，可以實現最後的特性。此外，我們採用了這種基於硬件的解決方案，以提供可從MicroBlaze處理器訪問的IP內核。為此，擴展了控制器並實現了三個版本，以便在連接到處理器的外圍本地總線（PLB），快速單工鏈路（FSL）和AXI接口時評估其性能。因此，控制器可以利用處理器提供的靈活性，但利用硬件加速。它在Virtex-5和Kintex7 FPGA中實現。重新配置時間的結果表明，Virtex-5器件中單個LUT的運行時重新配置小於5us，這意味著與Xilinx XPS HWICAP控制器相比，速度提升超過380倍。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d7abe76ede514e308d57ca293420a430><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><h1><strong>1、引言</strong></h1><p class=ql-align-justify>現場可編程門陣列（FPGA）器件作為電子系統設計和評估的基本組件而存在。它們不斷被報告為最終實現平臺，而不僅僅是原型元素[1]。 FPGA已根據VLSI縮放技術的步伐而發展，使得可以在最先進的製造工藝中開發這些器件。例如，7系列基於Xilinx SRAM的FPGA基於28 nm，高k金屬柵極工藝技術[2]，Xilinx Virtex UltraScale +採用16 nm FinFET +，AlteraStratix 10器件採用Intel-14 nm Tri-柵極（FinFET）工藝技術[3]。這是有利於越來越多的這種設備作為ASIC的可編程替代品的原因之一。</p><p class=ql-align-justify>此外，FPGA的設計和製造方面的技術改進產生了更強大，更靈活的元件，嵌入了更大的RAM存儲器模塊（BRAM），DSP模塊，處理器和專用的硬連線組件.FPGA提供的固有可重配置特性是其中最重要的特性之一實際硬件實現和系統重新設計的優勢。</p><p class=ql-align-justify>我們專注於Xilinx器件，因為除了支持動態部分重配置（DPR）之外，還可以對比特流進行改進。這意味著可以執行對比特流結構的逆向工程，這對於我們在LUT上執行DPR的方法是必不可少的，這將在第3節中解釋。</p><p class=ql-align-justify>基於Xilinx SRAM的FPGA通過內部配置訪問端口（ICAP）支持DMA。如圖1所示，這個硬連線元件允許在運行時訪問配置存儲器。因此，可以修改系統的特定部分，而其餘部分繼續運行而不受特定運行時修改的影響。動態部分重新配置可以在不同的粒度級別使用。考慮到設備的體系結構，它可以用於修改基本邏輯組件，例如查找表（LUT）或更大的塊，例如IP核。因此，DPR廣泛應用於自適應系統的設計和關鍵系統的評估，這些系統需要在最終生產之前進行詳盡的測試。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be1c566dc0654d1face5ba9b99eea39b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>圖1：ICAP硬連線原語。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>Xilinx工具（如PlanAhead或命令行“−”）將兩個實現之間的差異用於生成部分比特流，以允許修改已定義為在運行時更改的特定部分。然後將部分比特流複製到FPGA的外部或內部存儲器中，並在系統需要新的硬件任務時將其發送到ICAP。除了特別適用於粗粒模塊的這種類型的運行時重新配置之外，還存在使用在片上處理器中執行的某些軟件功能來動態地修改諸如LUT的基本元件的替代方案。</p><p class=ql-align-justify>考慮到這一點，硬連線ICAP原語及其相關控制器成為動態運行時可重構系統設計中的基礎和不可分割的模塊.ICAP控制器負責執行訪問和修改配置存儲器的所有命令。因此，希望這種控制器滿足至少兩個基本要求：<strong>高重新配置吞吐量和靈活性。</strong></p><p class=ql-align-justify>Xilinx工具提供通用控制器來驅動ICAP，但它們將大部分處理作為處理器中的軟件程序執行。它意味著靈活性，但避免達到最大支持的重配置吞吐量。據報道，這些控制器的多種替代方案可以提高重新配置速度。它們中的大多數已經被定向為管理在設計時生成的部分比特流，並且還操縱作為最小可尋址配置存儲器的幀。</p><p class=ql-align-justify>深入瞭解設備的粒度，還應該可以使用已實現設計的LUT上的任何動態修改來增加系統的靈活性。例如，它可以在加密模塊中用於修改模塊的邏輯行為並增加對某種類型的外部攻擊的抵抗力。因此，還需要一種允許在運行時修改LUT的有效機制，因為LUT是在FPGA中實現任何邏輯功能的基本組件。 ICAP控制器應提供一種以最大支持速度在LUT中執行DPR的方法，不僅限於預生成的部分比特流，而且呈現簡單的接口，使得架構設備的複雜性對用戶透明。</p><p class=ql-align-justify>在本文中，我們提出了一種新穎的運行時重配置控制器，它完全在硬件中實現，並支持Xilinx FPGA中LUT的部分重配置。這項工作的主要貢獻是：</p><p class=ql-align-justify>（1）設計和實現支持DPR的fLUTAC ICAP控制器，並在Virtex5和Kintex7器件中驗證</p><p class=ql-align-justify>（2）將LUT座標和LUT配置值透明地片上轉換到幀位置</p><p class=ql-align-justify>（3）對於位於BRAM或閃存中的部分比特流，LUT-DPR的加速和類似的重新配置速度（與現有解決方案相比）</p><p class=ql-align-justify>（4）FSM獨立操作和IP版本適用於不同的嵌入式微處理器接口（PLB，FSL和AXI）。</p><p class=ql-align-justify>本文的其餘部分安排如下。在第2節中，我們回顧了ICAP控制器設計中最相關的工作。在第3節中，我們提出了關於細粒度部分重構的主要考慮因素。在第4節中，我們詳細介紹了新的AC ICAP控制器。在第5節中，介紹了可從片上處理器訪問的控制器擴展。在第6節中，我們描述了將控制器移植到更新的設備系列時要遵循的注意事項。在第7節中，我們給出了控制器所需的重新配置時間和區域的結果。接下來是第8節，其中控制器用於在加密模塊中對LUT進行修改，以實現針對外部攻擊的對策。最後，第9節總結了論文並提出了未來的工作。</p><h1><strong>2.相關工作</strong></h1><p class=ql-align-justify>在本節中，我們概述了FPGA動態部分重配置中使用的一些最相關的ICAP控制器實現。部分重新配置已廣泛應用於各種應用[5-7]，這些應用利用了在運行時調整硬件模塊的可能性。使用這種技術時的一個共同要求是，應該以最小的時間開銷執行硬件模塊的切換。</p><p class=ql-align-justify>實現具有DPR功能的系統的最常用方法是使用Xilinx工具中提供的ICAP控制器。 XPS HWICAP [4]，如圖2所示，AXI HWICAP和OPB HWICAP分別是設計用於連接PLB [8]，AXI和低速OPB總線的IP內核。它們用作嵌入式處理器系統（PicoBlaze或MicroBlaze）的一部分，並且通過處理器API提供的一系列軟件功能提供對部分重新配置的支持。這些功能允許處理位於存儲器中的部分比特流，訪問配置幀（XHwIcap DeviceReadFrame，XHwIcapDeviceWriteFrame）和修改LUT（XHwIcap SetClbBits，XHwIcap GetClbBits）。在[9]中詳細介紹了使用函數修改特定LUT的示例，[10]中的作者使用函數tomodify幀來模擬配置存儲器上的故障。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/eead0b2ecc7d4238a681ac230d209519><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>Xilinx功能將大部分操作作為處理器中的軟件程序執行。然後，管理ICAP和處理在處理器中執行的部分比特流報頭以及總線等待時間的命令影響部分重新配置過程的速度。因此，已經開發了各種替代控制器來克服這些限制。[11]中的作者探索了分析重新配置速度的不同ICAP控制器，並提出了三種變化來加速部分比特流的處理，但它們都需要存在處理器。</p><p class=ql-align-justify>[12,13]也是如此。在後一種情況下，使用FSL鏈路將控制器集成在處理器數據路徑中，以最小化總線延遲。相比之下，[14,15]現有的Virtex-5器件控制器能夠從BRAM和閃存中加載部分比特流，完全由硬件實現，獨立於處理器。以類似的方式，[7,16]報告了用於Virtex-4 FPGA的獨立於處理器的ICAP控制器的實現。 [17]中的作者利用DPR來設計容錯系統。這些方法顯示了在使用BRAM時可以達到最大支持吞吐量的重新配置速度的改進。此外，一些工作，例如[7,18]中提出的工作，通過對ICAP進行超頻，實現了高於技術文檔中指定速率的吞吐速度。</p><p class=ql-align-justify>所有這些工作都面向有效地訪問部分比特流並執行硬件切換任務，但不考慮完整控制器應支持的一些其他操作。魯棒控制器應該能夠回讀和寫入配置幀，並且除了僅控制部分比特流之外，還可以修改LUT。這些最後的特徵在關鍵系統的實現中至關重要，其中ICAP控制器是設計的基本部分[21]。考慮到這一點，各種方法，如[20,22-24]中報道的那些，使用改進的ICAP控制器是基於SRAM的FPGA中容錯系統的基本組成部分。在這樣的系統中，ICAP用於檢測和校正配置存儲器中的故障。要做到這一點，控制預先計算的部分比特流是不夠的，它們實現了幀的讀取和寫入，因為在此級別執行故障檢測。例如，一旦讀取幀，就可以獲得其CRC以檢查其組成位中是否存在錯誤。在錯誤值的情況下，可以校正幀並使用正確的值寫回配置存儲器。因此，這些報告的工作包括用於寫入和讀取配置幀的幀處理。</p><p class=ql-align-justify>據我們所知，在[25]中介紹了作為ICAP控制器的一部分在LUT級執行運行時重新配置的唯一工作，但它僅適用於LUT具有四個輸入的Xilinx Virtex-II器件該器件的架構與新的Xilinx系列有很大不同。這些框架覆蓋了設備的整個高度，並未詳細說明LUT配置值如何位於框架上。此外，這個家庭目前被認為已經過時。</p><p class=ql-align-justify>在這項工作中，我們開發了一個完全用硬件實現的新型ICAP控制器，支持比特流管理，幀的讀取和寫入以及LUT修改。該方法提供了LUT重新配置速度的改進，並且在不需要預先計算的部分比特流的情況下執行。此外，它可以輕鬆適應各種Xilinx FPGA系列中的片上處理器。</p><h1><strong>3. LUT的動態部分重配置</strong></h1><p class=ql-align-justify>在本節中，我們將介紹XilinxFPGA的一般架構以及部分重配置的相關概念，以Virtex-5 XC5VLX110T器件為參考。但是一般的想法也適用於較新的設備，特別是在考慮LUT時，因為它們保持不變;它是6輸入LUT，適用於Virtex-5，Virtex-6和7系列FPGA。</p><p class=ql-align-justify>FPGA被組織為連接到開關矩陣的可配置邏輯塊（CLB）陣列。圖3顯示了XC5VLX110T FPGA的配置，可以觀察到它被水平分成兩半。在頂部（0）和底部（1）兩半，我們發現固定數量的行取決於特定器件的大小。Virtex-5 LX110T FPGA分為8個水平時鐘行（HCLK）：每半個四個。每個HCLK包括確定數量的CLB，BRAM，DSP和I / O. CLB分佈在160行×54列中，覆蓋整個設備。每個CLB由兩個Slice組成，每個Slice包含4個LUT，4個觸發器，多路複用器和進位邏輯。因此，該FPGA具有17280個片，69120個LUT和69120個寄存器。</p><p class=ql-align-justify>一個CLB列定義為跨越HCLK高度的一組20×1 CLB。這意味著，在HCLK行內的每個CLB列中，有40個Slice和160個LUT。</p><p class=ql-align-justify>配置存儲器按幀組織。一幀是可以尋址的最小配置存儲器大小。因此，應該以幀為參考對配置存儲器執行任何操作。一幀由41個32位（1312位）組成.Virtex-5 LX110T需要23712個配置幀來配置整個芯片。因此，<strong>配置文件（比特流）由972464個32位字（3.7 MB）組成。它在頭部包括272個字的控制信息，其餘對應於配置幀.（FPGA器件固定，配置文件的大小也就固定了）。</strong></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9fa3ec34f5c54515a02d1ad48bb9048d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>每次我們要配置整個器件時，3.7MB的比特流包含要實現的電路的描述應該加載到配置存儲器中。</p><p class=ql-align-justify>動態部分重配置允許修改系統的特定部分;結果，不需要完整的比特流，而是使用較小的部分比特流，其中具有要修改的特定區域的信息。使用基於差異的方法在設計時生成部分比特流。 PlanAhead [26]或bitgen命令行[27]用於生成它們。該命令− 1.2.2.將每個配置（1 and 2）的兩個不同文件作為輸入，結果是部分比特流2.，它們之間存在差異。部分比特流的最小尺寸對應於用一個額外的虛擬幀和控制信息增加的一個配置幀。</p><p class=ql-align-justify>要配置CLB列，需要36幀。在36幀內，我們擁有20個CLB中存在的每個元素的信息。<strong>我們關注LUT，因為這些是實現FPGA中所有組合邏輯的基本元素。</strong></p><p class=ql-align-justify>LUT或邏輯函數發生器是六輸入元件，需要64位來定義要執行的功能。LUT的邏輯行為取決於在這64位中配置的值（INIT值）。要處理任何單個LUT，必須定義其位置和INIT值。該位置使用三個參數：（x，y，Bel）。 x和y是Slice的座標，Bel是用於選擇Slice內的單個LUT的索引。 x和y的範圍取決於FPGA的大小（在所考慮的器件中為108×160）。 Bel索引的範圍從0到3，用座標（x，y）選擇Slice內的4個LUT（LUT-A，LUT-B，LUT-C和LUTD）中的一個。一旦識別出特定的LUT，就可以通過64個配置位修改其INIT值。如第2節所述，由於Xilinx API提供的某些軟件程序，可以在運行時修改此LUT參數。函數XHwIcap GetClbBits用於讀回LUT的INIT值並將其存儲在內存中。 XHwIcap SetClbBits將系統內存中的任何INIT值複製到LUT配置字段中。這兩個函數都需要相同類型的參數：LUT（x，y和Bel）的座標和用於定位INIT值的內存地址。我們發現有關這些函數及其執行的操作的信息非常有限。這些參數的格式目標文件（.o）及其源代碼不可用。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/544a795306ff45ca899de236158acf92><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>此外，使用這些函數讀取和寫入LUT的配置值所需的時間大約為2ms，而使用XHwIcap DeviceReadFrame和XHwIcapDeviceWriteFrame函數讀取和寫入幀的時間大約為30 us。這些數字是使用基於MicroBlaze的100MHz系統實驗獲得的，為我們提供了改善LUT重新配置時間的機會。因此，<strong>我們進行了實驗以推斷出LUT參數和配置幀之間的關係</strong>。通過組合XHwIcap SetClbBits函數以使用XHwIcap DeviceReadFrame寫入特定LUT來分析幀上的編程值，我們發現使用四個幀來重新配置單個LUT。</p><p class=ql-align-justify>如圖4所示，INIT值的64位跨越四個連續幀，每幀包含16個INIT位。每個CLB列中的40個Slice可以看作是20列Slice的2列。一個Slice列包含20個Slice，在x座標上具有偶數值，而其他20個Slice包含奇數值。幀26至29包圍具有奇數x座標的20個Slice的LUT配置值，而當32座標為偶數時，幀32至35具有20個Slice的相應信息。以類似的方式，Slice-y座標確定要使用的每個幀內的特定字。對於任何CLB列，y需要20個連續值。根據此值，幀中的特定字對應於單個LUT。兩個連續的幀字具有片的4個LUT的部分信息。 16位INIT LUT-A和16位INIT LUT-B配置值在一個32位字中。類似地，LUT-C和LUT-D INIT值位於下一個字中。</p><h1><strong>4. AC_ICAP實現</strong></h1><p class=ql-align-justify>AC ICAP控制器（如圖5所示）提供與Xilinx工具中可用的XPS HWICAP和AXI HWICAP類似的功能，但AC ICAP完全在硬件中實現，而不是將大部分任務作為處理器中的軟件例程。它包括支持ReadFrames，WriteFrames，Modify LUT，以及從閃存和BRAM內存加載部分比特流。與同樣在硬件中實現幀讀取和寫入的類似方法[20]相比，我們的控制器通過LUT的運行時重新配置得到改進，而無需預先計算的部分比特流。這最後一個特性與自適應的實現相關可能需要根據運行時生成的值對硬件進行微調的系統，而不僅僅是基於預先計算的值。第8節將更詳細地討論這方面的問題。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0cc06a6df3cf414592f8465fab1586d1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>控制器及其內部模塊使用有限狀態機（FSM）根據表1中指定的輸入Op sel的值在不同的配置級別上操作。</p><p class=ql-align-justify>AC ICAP最初使用配備了Virtex-5LX110T FPGA的電路板開發，實現流程在Xilinx工具版本14.7中執行。儘管Virtex-5系列提供了詳細信息，但應注意控制器也按照第6節中的說明在7系列系列中實現。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e5c6adda158840859e271e718edeed3f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>如第3節所述，LUT的DPR需要修改幀的特定部分。因此，用於讀寫幀的兩個模塊在LUT運行時重新配置的實現中是必不可少的。我們設計了具有BRAM空間的AC ICAP控制器，能夠存儲可以重新配置4個CLB列區域的部分比特流。然後，控制器對設備中可用的總BRAM具有低影響（148）。因此，我們將7-36 Kbit BRAM元素（31.5KB）配置為雙端口存儲器。該存儲空間用於存儲讀取的幀，並且還用作要發送到ICAP的幀的源。保留初始2800字節以執行LUT修改和幀任務。剩餘的28.7KB可用於幀或部分比特流存儲，如圖6所示。當部分比特流適合可用的BRAM時，BRAM任務的負載部分比特流可以達到最大指定吞吐量，因為它們之間的直接連接。片上BRAM和額外字虛擬幀數據幀1數據幀N數據幀或部分比特流位31位0 01 699 700 8063字1 41 42字41字1字41 82 BRAM地址圖6：BRAM存儲器映射。</p><p class=ql-align-justify>ICAP通過32位鏈接。通過使用100MHz的時鐘，每個時鐘週期可以使用一個32位字，這相當於ICAP支持的最大吞吐量（3.2 Gbps）。我們遵守技術文件中規定的有關ICAP最大工作頻率的限制：100MHz [4]。但是，應該考慮到漢森等人在文獻 [18]報告了ICAP的正確操作，當它被超頻以實現更好的重配置吞吐速度。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/823e5cc5cb8e4d9cb68741cbb27bdf70><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>接下來詳細說明AC ICAP控制器的組成模塊。</p><p><strong>4.1 ReadFrames模塊</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>ReadFrames模塊使用兩個參數來定義要讀取的位置（FAddr）和幀數（Nf）。 Nf對於單幀讀取取值1或對多幀讀取取任何其他值。它受控制器上可用BRAM內存的限制。應該注意的是，對於LUT修改任務，一個BRAM塊就足夠了，但我們包括六個額外的塊來存儲幀或小的部分比特流。我們將所有讀取幀存儲在BRAM上，然後可以訪問它們以對它們執行任何操作。或者，能夠對讀取幀進行頂部處理和存儲的外部模塊可以獲得比由BRAM的大小限制的幀更多的幀。例如，所考慮的板中存在的DDR存儲器具有256MB的容量。它可用於保存佔用AC ICAP可用BRAM的31.5KB以上的配置幀。</p><p class=ql-align-justify>在多幀（Nf> 1）的情況下，FAddr是讀取過程開始的第一幀的地址。從那裡，例程將讀取Nf個連續幀。ReadFrames例程中涉及的步驟如圖7所示。當op sel =“001”並且Start信號被置位時，ICAP被配置為讀取指定的幀。這是通過寫入ICAP的某些寄存器來完成的，詳見[28]。重要的是指出CE和WRITE輸入的正確斷言以定義ICAP上的讀取或寫入操作。在CE之前，應該修改內容，以避免引起中止序列。它在圖7中的兩個框ICAPWRITE和ICAP READ中有詳細說明。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e6b1f0bd816f46acb414c6d5d5429072><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>輸入FAddr和Nf用於用輸入字標識的流程的兩個步驟。這兩個值適用於相應寄存器的格式。 FAddr應具有幀地址寄存器的格式，即一個32位字，其中包含字段：塊類型，頂部，HCLK行，列和列內的幀。 Nf用於計算讀取的字的數量（N）並生成要發送給ICAP的類型2字。用戶可以通過輸入Startaddr和NumFrames分別指定FAddr和Nf。或者它們可以由Lut2Frames模塊生成，如第4.3節中所述。</p><p class=ql-align-justify>我們必須考慮任何幀的讀取都包括在過程開始時生成的一個額外虛擬幀以及一個額外的字。考慮到這一點，Virtex-5器件的讀取字數可以計算為</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/71f8c98f943f4434a1629eea4f8afb1e><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>公式（1）適用於任何Virtex-5FPGA，因為在這些器件中，所有配置幀都具有相同的大小。這是41個32位字。偽幀由1到Nf的加法表示。最後一個添加代表了最初的字。</p><p class=ql-align-justify>來自FDRO的狀態READNWords執行組成幀的N個32位字的實際讀取。對於從ICAP的FDRO寄存器讀取的每個字，增加BRAM地址以將幀存儲在該存儲器上。圖6顯示了幀的位置和其它字。</p><p><strong>4.2 WriteFrames模塊</strong></p><p class=ql-align-justify>該模塊的設計遵循與ReadFrame中相同的方法。主要區別在於準備ICAP寫入配置存儲器所需的配置命令。當表1中定義的Op sel輸入為“010”且啟動信號有效時，WriteFrames模塊被激活。要達到最大吞吐速度，要寫入的幀的首選源是BRAM。如果幀位於AC ICAP的BRAM中，則每個時鐘週期都有一個32位字。</p><p class=ql-align-justify>由於此模塊通常與ReadFrames結合使用，因此要寫入的幀已經被讀取並存儲在BRAM上。然後，WriteFrames模塊使用相同的存儲空間，如圖6所示，其中ReadFrames放置了回讀幀。</p><p class=ql-align-justify>與ReadFrames模塊需要考慮一個虛擬幀的方式相同，在每個寫幀例程中，虛擬幀應該在進程的最後部分發送到ICAP。因此，數據幀從BRAM地址= 42開始並在地址41 *（Nf + 1）。發送數據幀後，應立即跟隨虛擬幀。為此，起始地址更改為1，並在發送41個字（1幀）時結束。地址0處的額外字不用於寫入過程。</p><p class=ql-align-justify>我們生成Op完成輸出以指示寫入過程的結束。有必要保證ICAP任務正確完成。發送完所有字後，必須發送DESYNC命令並禁用ICAP。當ICAP接收並處理DESYNC命令時，操作完成。當輸出端口O從0xDF變為0x9F時觀察到。該過程具有6個時鐘週期的延遲，與輸入CE上的值無關。</p><p><strong>4.3 DPR of LUTs with LUT2Frames 模塊</strong></p><p class=ql-align-justify>LUT2Frames模塊通過將LUT參數轉換為幀表示來允許LUT的動態部分重配置。如第3節所述，LUT的特徵在於座標（x，y，Bel）和INIT值。 LUT2Frames模塊，如圖8所示，執行兩個主要任務：（1）將x，y，Bel座標轉換為FAR格式，以及（2）將INIT（64位）LUT函數轉換為4個16位的字。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/973f02ac29d5497caa92859d16e69865><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>x，y，Bel輸入合併為一個32位字，當設置Start輸入時，LUT2Frames模塊使用INIT值。基於座標值，生成一個具有幀地址寄存器（FAddr）格式的32位字，以定義讀寫開始的幀。此外，x，y和Bel值確定字偏移量，它是需要操作的每個幀（2-41個字中的第一個）的具體字。</p><p class=ql-align-justify>從32位字開始，只有16位對應於特定的LUT。因此，信號msb lsb指示應修改32位字的哪一部分：0為字的LSB部分（LUT-A或LUT-C） 16個MSB（LUT-B或LUT-D）為1。</p><p class=ql-align-justify>與先前的處理並行地，LUT2Frames模塊生成四個16位字（fword1⋅⋅⋅fword4），其對應於變換並適應四個幀的INIT值。</p><p class=ql-align-justify>幀位置和尋址的所有複雜性對用戶是透明的。 LUT2Frames模塊實現所有轉換並計算適當的地址和內存管理，以便在需要修改整個設備中的任何LUT時允許用戶進行簡單操作。</p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/000525f8330c48769fc980fd15b5c59b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>當需要進行LUT修改時，執行由FSM控制的步驟，如圖9所示。該過程由啟動信號觸發；然後，激活LUT2Frames模塊。使用此空閒備份字生成的值修改幀寫入幀讀取幀LUT2幀 模塊，從FAddr開始的4幀被讀取並存儲在BRAM（讀取幀）中。字偏移和msb lsb表示應修改的特定字。備份這4個字（備份字），使用LUT2Frames生成的四個字進行修改，並複製回BRAM。此時，BRAM包含具有新字的幀，並且WriteFrames模塊執行對應於LUT的4幀的寫入。</p><p class=ql-align-justify>Recover LUT例程使用在備份字階段獲得的四個備份值將LUT恢復到其先前的配置值。考慮圖9，它僅執行LUT修改例程的最後兩個步驟。</p><p class=ql-align-justify>它修改了BRAM上的4個幀，然後通過WriteFrames模塊發送這些幀以將LUT恢復到其先前的INIT值。此例程在需要在修改LUT之前恢復LUT的先前功能的應用程序中非常有用。通過遵循這種方法，我們避免再次讀取四幀，因為這些已經在BRAM上。</p><p class=ql-align-justify>使用ChipScope Pro Debugger [29]驗證了控制器的正確操作。圖10顯示了LUT修改過程的詳細信息。我們指定了要修改的LUT的x，y，Bel和INIT值。圖10中所示的步驟可以在圖10中標識。LUT2Frames模塊僅需要兩個時鐘週期，並且它生成的信息用於尋址四個幀以讀取和修改這些幀中的四個特定字。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4952572b0a3a4f79ab4a67c0173aa895><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p><strong>4.4 Load Partial Bitstreams模塊</strong></p><p class=ql-align-justify>該模塊遵循類似於第2節中描述的方法，關於通過加載部分比特流來加速部分重新配置。負載部分比特流模塊執行三個主要任務：（1）從閃存加載部分比特流，（2）將部分比特流從閃存複製到BRAM，以及（3）從BRAM加載部分比特流。為此，該模塊包括一個存儲器訪問控制器，用於從閃存中讀取部分比特流。因此，從閃存讀取的數據可以直接發送到ICAP I端口，也可以複製到內部BRAM中。當部分比特流在BRAM上時，可以達到ICAP上的最大配置速度。如果部分比特流在外部存儲器上，則重新配置時間取決於訪問存儲器的延遲。在這種情況下，我們使用Intel StrataFlash存儲器28F256P30，它需要在100MHz的26個時鐘週期才能得到32位字。</p><p class=ql-align-justify>可以放置在 BRAM 上的部分比特流的大小受控制器上可用的 BRAM 存儲器的限制。從 AC ICAP 中存在的 7-36Kbit BRAM ，我們保留了 2800 字節來執行 LUT 修改和幀任務。因此，可放置的部分比特流的最大大小為 28.7KB 。它可以增加，因為 FPGA 包含更多的 BRAM （ LX110T 器件中有 148 個）但它取決於應用限制。</p><p class=ql-align-justify>部分比特流是按照標準 X ilinx 流程生成的 ; 它使用的是 PlanAhead 或 bitgen 工具。這些配置文件包括關於設備類型的標題信息，配置數據的大小，比特流的生成的日期和時間等。我們調整部分比特流以從頭部移除不必要的信息，並且僅保留與不包括頭部的部分比特流的大小（以字節為單位）對應的最後的頭部字段。因此，我們的控制器首先讀取包含部分比特流大小的字，並使用該信息計算從內存中讀取的字數（閃存為 16 位字， BRAM 為 32 位字）。使用這種方法，唯一需要的參數是部分比特流所在的初始地址。</p><p class=ql-align-justify>控制器自動計算結束地址並執行讀取過程。根據輸入Op sel選擇的操作，數據將發送到ICAP或BRAM。以類似的方式，當Op sel設置為“111”時，該模塊配置ICAP控制信號和BRAM地址以允許高吞吐量部分重新配置。</p><h1><strong>5. AC_ICAP適用於片上處理器</strong></h1><p class=ql-align-justify>為了使控制器能夠連接到基於處理器的設計，它適用於MicroBlaze系統使用的外圍本地總線和快速單工鏈路接口。為此，AC ICAP被認為是具有圖5中所示的I / O端口的黑盒子，並且這些端口適用於各自的總線。這種方法提供了更大的靈活性，因為控制器可以容易地從處理器命令。我們創建了一系列適用於每個接口的函數，以執行表1中所示的任務。這些函數（如代碼1所示）使用XilinxAPI中的特定例程來訪問PLB和FSL接口。</p><p class=ql-align-justify>代碼1、驅動AC ICAP IP的功能如下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e4bbdf29525458db99d0b13613c9f0b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>StartAddr參數指的是應根據op sel值進行調整的唯一輸入。在讀取和寫入幀的情況下，它對應於初始幀的地址（FAddr）。對於其他功能，它是存儲數據的存儲器地址。 NumFrames是要讀取或寫入的幀數，x，y bel，INIT是控制單個LUT的參數。這些是命令AC ICAP控制器所需的唯一值，因為它在內部執行所有操作，例如將x，y bel和INIT轉換為幀格式，在讀取部分比特流的大小後計算結束地址，等等。</p><p><strong>5.1 PLB IP</strong></p><p class=ql-align-justify>PLB總線用於將外圍設備連接到MicroBlaze處理器。以VHDL設計的原始AC ICAP在PLB包裝器中實例化以生成定製PLBAC ICAP IP。控制器的輸入和輸出連接到PLB總線的信號，然後處理器可以使用寄存器地址訪問它們。因此，PLB AC ICAP可以連接到任何基於MicroBlaze的系統，如圖11所示。該架構包括閃存，其中修改可重配置區域的全部和部分比特流位於其中。通過將閃存的AC ICAP連接定義為外部端口，也可以在IP設計中執行與閃存的直接連接。一旦包含在EDK的硬件設計中，處理器中運行的軟件就能夠通過使用代碼1中列出的功能來控制PLB AC ICAP外設。因此，部分重配置相關任務使用代碼1中指定的任何功能。並監視輸出操作，直到它變高為確認任務已完成。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a962ff73f1f844bcba44806bdd99cd75><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>5.2 FSL Coprocessor</strong></p><p class=ql-align-justify>Fast Simplex Link是MicroBlaze處理器的一個接口，允許包含具有高執行優先級的專用硬件例程，因此意味著與處理器通信的低延遲。在這種方法中，我們採用了類似於[13]中提出的解決方案，以便由於總線延遲而獲得最小的控制器性能下降。因此，基於VHDL的AC ICAP適用於FSL接口，可以作為協處理器輕鬆連接，從而利用處理器的所有靈活性，但利用ICAP相關任務中的硬件加速。圖12顯示了使用FSL AC ICAP協處理器的系統。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46b0c564b8b0478d83109568f1c8b4f2><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>FSL AC ICAP協處理器的訪問方式與PLB AC ICAPIP中考慮的方式類似，即通過代碼1中提供的功能集合。主要區別在於這些例程的類型功能需要todrive theFLS。在這種情況下，我們將阻塞例程putfsl和getfsl與Xilinx API結合使用，因為我們認為重新配置任務具有高優先級。</p><h1><strong>6.在較新的設備系列中使用AC_ICAP</strong></h1><p class=ql-align-justify><br></p><p class=ql-align-justify>為了驗證7系列器件中的控制器，我們使用配備Kintex7 XC7325T FPGA的KC705板[30]。</p><p class=ql-align-justify>該FPGA包含50,950個Slice，在每個Slice內部，有4個6輸入LUT和8個FF .445個BRAM對應2002 KB，比特流大小為10.9MB。為了使針對Virtex-5設計的AC ICAP適應7系列器件，需要進行某些更改。主要差異總結如下：</p><p class=ql-align-justify>（1）7系列系列中每幀的字數為101而不是41（Virtex-5）。這是因為7系列FPGA中的CLB列高50寬1寬，這意味著CLB列中存在100個 Slice。同樣，HCLK行的數量也不同;對於這個特定的設備，它是7（3頂部和4底部）。</p><p class=ql-align-justify>（2）開始讀或寫的幀的地址由FAR寄存器定義。對於7系列，該寄存器使用32位中的26位，而在Virtex5 FAR中，它使用24位。這是由於FPGA的大小增加。</p><p class=ql-align-justify>（3）與Virtex-5相反，對於7系列，在讀取幀任務開始時不需要額外的字。因此，可以根據對任何7系列FPGA有效的（2）來計算從這些設備讀取/寫入的字數（Nwords 7），因為在這些設備中所有配置幀具有相同的大小。偽幀由幀數（Nf）加1表示：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f5071e23313847d7b82aa4afd88b2041><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>（4）指示在LUT-DPR過程中應該修改幀上的特定字的字偏移現在具有0到100的範圍。對於Virtex-5，它在0到40之間變化。以類似的方式，跳過列（包含不同於CLB的資源的列：BRAM，DSP I / O）和主要列編號需要更新.Kintex7中的第一列的主要地址為2，而它為1 Virtex-5的。</p><p class=ql-align-justify>（5）在7系列中，原始ICAPE2沒有BUSY輸出。相反，我們應該在CE斷言後考慮3個時鐘週期來獲得有效數據。</p><p class=ql-align-justify>（6）WriteFrames模塊還需要進行一些更改。在Virtex-5中，可以通過設置配置寄存器（COR0-bit28）並在每次修改FAR時將值0xDEFC加載到CRC寄存器來繞過CRC計算。在7系列中，此類寄存器不存在；默認情況下，新的控制寄存器（COR1-bits15-16）設置為允許在計算CRC後對系統進行連續操作，因此刪除了這些步驟。</p><p class=ql-align-justify>（7）該電路板中可用的閃存與Virtex-5中的閃存類型相同，但由於尺寸不同，閃存控制器經過修改後還包含兩條額外的地址線。</p><p class=ql-align-justify>配置CLB列所需的幀數保持不變（36），包含LUT信息的特定幀也是如此。我們使用22個BRAM塊佔用與Virtex-5類似的百分比（5％）。</p><p class=ql-align-justify>一旦在AC ICAP中執行了所提出的更改，它就在Kintex7 FPGA中實現，並使用它支持的所有操作進行測試。在圖13中，我們再次提供了一個LUT的DPR細節，因為它涉及控制器中可用的各種任務。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d2622198b034bcc9a5533c6dbd6b9e9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>這個新的AC ICAP適用於AXI接口，因為它用於所有newXilinx系列。該IP被標識為AXI AC ICAP，並支持代碼1中提供的適用於AXI API的相同功能。</p><p class=ql-align-justify>基於前面的描述，我們有不同的控制器變體來評估：AC ICAP，獨立硬件版本; PLB AC ICAP和AXI AC ICAP，分別適用於PLB和AXI總線;和FSL AC ICAP，用作協處理器。我們使用PlanAhead 14.7和Vivado 2015.3來定義不同大小的可重新配置分區（從1到10個CLB列）並生成不同的部分比特流。</p><p class=ql-align-justify>對於基於 Xilinx 的控制器，我們實現瞭如圖 11 所示的架構，但我們不是使用 PLB AC ICAP ，而是添加了 XPS HWICAP 或 AXI HWICAP ，其參數可以實現重配置吞吐量的最佳性能（寫入 FIFO 深度 = 1024 ，讀 FIFO 深度 = 256 ，並啟用 FIFO 類型）。對於這兩種情況，還包括 Xilinx 閃存控制器，以訪問位於該存儲器中的部分比特流。在這樣做時，我們可以獲得準確的比較，因為我們使用相同的工具版本和綜合選項。</p><h1><strong>7. 實驗結果</strong></h1><p class=ql-align-justify>本節總結了有關AC ICAP控制器的各種版本的重新配置速度和資源利用率的主要結果。我們認為比較用於Virtex5的Xilinx XPS HWICAP和用於Kintex7的AXI HWICAP的主要參考，因為這些是報告的替代方案中的一個，支持大多數DPR任務的那些。我們考慮到，對於配置多達4個CLB列的部分比特流，可以將它們複製到BRAM中，因為Virtex-5限制為28.7KB，Kintex7限制為99 KB。為了記錄AC ICAP（獨立版本）的時間性能，使用了ChipScope Pro。對於適用於處理器接口的版本，系統中包含的定時器用於記錄特定任務所需的時鐘週期數。這些數字在表2中報告。這裡，我們想提一些關於Kintex7 FPGA獲得的值的問題.AXI HWICAP包含的LUT功能不支持7系列。使用最新版本的工具進行實驗（Vivado 2015.3和驅動程序hwicap v10 0），僅支持Virtex6和以前的設備，我們無法修改它們，因為源代碼不可用。功能對於使用AXI HWICAP的讀寫幀，需要修改一些頭文件，因為它們會出現一些錯誤的值。文件xhwicap ih：使用7系列中的Virtex6值，但這些值不應該相同。例如，聲明兩個族的幀中字的數量是81.但是對於7系列族，正確的值是101. FAR創建時會發生類似的情況。驅動程序使用一些對Virtex-6有效但不對Kintex7有效的參數創建FAR，並對這些參數進行了修改以獲得正確的操作。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/daba43688def430589a34ae23df76da4><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>從表2可以看出，據我們所知，使用AC ICAP的LUT的重新配置時間是報告最快的替代方案。與Virtex-5中的XPS HWICAP相比，它意味著PLB AC ICAP的速度提升超過320倍，這是最慢的版本，獨立的AC ICAP改善了LUT的重配置時間超過380次。以類似的方式，考慮到Virtex-5和Kintex7，讀寫幀任務的加速分別經歷了超過18次和21次的改進。</p><p class=ql-align-justify>對於 Virtex-5 和 Kintex7 ，來自 BRAM 的負載部分比特流（對於 AC ICAP ）的重新配置吞吐量分別為 380.47 和 381.03 MB / s 。它接近 400MB / s 的最大支持吞吐量和 [15,20] 上的報告值。對於 [15] 報告的工作，應該指出的是，估計的價值並不是在實際執行中衡量的 ; 因為該控制器不包括 BRAM 。我們的控制器與 400 MB / s 值的偏差是由於 ICAP 開始讀取 BRAM 和處理 DESYNC 命令（ 0x0D ）所需的額外時鐘週期。對於每個與 ICAP 相關的任務，我們認為在確認 DESYNC 命令時它就完成了。它是通過監視 ICAP 的 O 端口來完成的，該端口在 Vinterex-5 中從 0xDF 變為 0x9F ，在 Kintex7 中從 0xFFFFFFDB 變為 0xFFFFFF9B ，以確認完成任務是否成功。這意味著在最後一個數據發送到的後 6 個額外的時鐘週期 ICAP 。</p><p class=ql-align-justify>對於PLB，AXI和FSL版本，由於接口的延遲，時間會有一些降級，但在所有情況下，它們對來自閃存的負載部分比特流提供了超過11倍的改進。</p><p class=ql-align-justify>將部分比特流從閃存複製到BRAM的時間與從閃存加載部分比特流所需的範圍相同。這些存儲在BRAM上，而不是向ICAP發送數據。因此，當應用程序可以在執行開始之前（例如，在引導時）將部分比特流複製到BRAM時，它尤其有用。</p><p class=ql-align-justify>關於資源利用率，表 3 列出了 AC ICAP 控制器的每個模塊的詳細信息。應該注意的是， AC ICAP 包括閃存控制器，而 XPS HWICAP 和 AXI HWICAP 則不是這種情況。表 4 總結了控制器的各種選項所需的資源。 AC ICAP 的 PLB ， AXI 和 FSL 版本的額外資源是由於使控制器適應這些接口所需的包裝邏輯。可以看出，資源需求最大的方法使用了 5 ％的 Slice，這可以被認為是合理的大小，因為所有操作都是在硬件中完成的。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9735a6ac9cda4b44b54b9e6765fec39d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/634fb89036f644b196c95126a8cdbfd2><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>最後，在表5中，我們比較了完整的基於MicroBlaze的架構所需的資源，包括不同版本的ICAP控制器。我們可以看到，使用適用於PLB和FSL的AC ICAP的系統平均需要比XPS HWICAP替代方案多3％的Virtex-5 FPGA資源。這是為了加速所有重新配置任務而支付的區域開銷，例如當使用FSL AC ICAP時，LUT的重新配置時間在356x中得到改善。當我們看到Kintex7的數據時，面積百分比隨著設備的增大而降低。</p><p class=ql-align-justify>因此，隨著要管理的配置數據量變得越來越大，任務的加速變得越來越重要，但ICAP原語支持的速度和總線寬度自Virtex-4生成（32位@ 100MHz）以來保持不變。從提供的數據中，我們可以總結出最佳的性能區域權衡由AC ICAP給出，它使用3％的FPGA資源但在LUT DPR中提供380x的加速。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d097dc2e90bf4d00b18420b79c2c20cf><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>使用該方法的LUT的動態部分重新配置提供了以下優點：對於要執行的每個修改，它不需要預先計算的部分比特流。它允許使用任何布爾值修改運行時LUT，並且不受內存中部分比特流可用性的限制。這種精細的部分運行時重新配置在諸如故障注入平臺和密碼實現的應用中具有越來越大的相關性，其中硬件可以在LUT級別被修改以避免某些類型的攻擊。這些細粒度修改的案例應用將在下一節中介紹。</p><h1><strong>8. 用於LUT評估AES模塊的AC_ICAP</strong></h1><p class=ql-align-justify>在本節中，我們使用AC ICAP來評估[31]中提供的AES模塊。我們的想法是找到一種方法來識別LUT的關鍵配置值。有了這些信息，就可以設計出針對外部攻擊的對策。例如，可以採用這種方法來修改某些LUT的邏輯行為，以在不停止系統的情況下產生錯誤值。在這樣做時，AES可以持續工作，給出錯誤的正確操作感，可以將其用作對抗諸如差分功率分析之類的攻擊的對策。</p><p class=ql-align-justify>如果使用部分比特流方法來修改LUT，則每個LUT tomodify都需要部分比特流。這些應該在設計時生成並複製到存儲器中。因此，LUT的所有可能修改都應該在設計時定義，一旦系統運行，很難包含任何變化，例如新的LUT修改，因為它意味著生成新的部分比特流的耗時過程。 AC ICAP支持的LUT的DPR的優點是不需要部分比特流，並且可以動態地執行任何邏輯修改。為了評估這種方法，我們使用偽隨機數發生器（PRNG）來產生64位配置存儲器，以便對要修改的LUT進行修改。我們不關注AES或PRNG的細節。我們的目標是提供一種方法來輕鬆識別LUT及其關鍵值，以用於評估和設計關鍵模塊。</p><p class=ql-align-justify>該系統的架構如圖14所示，並在Virtex-5 FPGA中實現。我們包括兩個AES模塊的副本，用於在線比較結果，BRAM存儲LUT的信息。 AES的單個副本需要8360 FF和13952 LUT。 DUT副本在區域中受到約束，並定義為要使用的分區，以保持在初始實現中定義的路由。定義了88個CLB列（14080 LUT）的區域來放置AES。由於我們可以在其他設計中重用已實現的分區，因此使用LUT的DPR獲得的值對於不同的實現仍然有效。由FSM控制的系統使用PRNG獲得隨機配置值以配置LUT，並且AC ICAP用於通過使用 Slice的x，y座標來修改DUT區域上的LUT。一旦修改了LUT，就會對黃金和DUT組件應用一些測試臺輸入，並分析輸出以確定LUT修改是否產生錯誤值。在應用所有輸入模式之後，對這種修改的效果進行分類。如果產生錯誤值，則存儲LUT地址和配置值。 LUT恢復到先前的值並測試新的LUT。如果沒有產生錯誤的值，可以繞過它或使用新的配置值進行測試。因此，這種方法允許靈活的替代方案來徹底地或以更輕鬆的方式評估系統。然後，使用存儲在BRAM中的信息來確定在系統受到攻擊時可以採用哪些LUT及其相關配置值來有意修改邏輯功能。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=FPGA為什麼可編程，這篇文章來告訴你 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a925c908a8a245959980d8d4ff406bed><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><h1><strong>9.結論和未來工作</strong></h1><p class=ql-align-justify>我們介紹了AC ICAP，這是一種在Virtex-5和Kintex7 FPGA中驗證的新ICAP控制器。它能夠加載部分比特流，讀取和寫入幀，以及修改FPGA中的任何LUT，在最後一種情況下無需預生成的部分比特流。該控制器適用於使用PLB，FSL和AXI鏈路的嵌入式處理器系統。與Virtex-5 FPGA的XPS HWICAP功能相比，獨立於處理器的版本的重配置速度分析顯示LUT的運行時重新配置提高了380多倍。由於我們的控制器完全採用硬件實現，因此顯然需要更多資源，但無論如何它佔據了XC5VLX110T器件上可用元件的5％以上。因此，AC ICAP提供了一個完整的高速解決方案，可以執行多種動態部分重配置任務。可接受的FPGA足跡。它被用於設計AES模塊，可以修改特定的LUT作為可能的攻擊對策。</p><p class=ql-align-justify>作為未來的工作，我們計劃使用 DDR 控制器擴展 AC ICAP ，以加速重新配置任務，當這些任務基於預先計算的部分比特流由於其大小而無法複製到 BRAM 中時。因此， DDR 存儲器是克服 BRAM 可用限制的替代方案。</p><p><strong>參考文獻</strong></p><p class=ql-align-justify>[1] Keysigh t Technologies, M9451A-DPD PXIeMeasurementAccelerator, 2015.</p><p class=ql-align-justify>[2] Xilinx, 7 Series FPGAs Overview DS180 (v1.16.1), Xilinx, 2014.</p><p class=ql-align-justify>[3] Altera, A New FPGA Architecture and Leading-Edge FinFETProcess Technology Promise to Meet Next Generation System RequirementsWP-01220-1.1, Altera, SanJose, Calif, USA, 2015.</p><p class=ql-align-justify>[4] Xilinx, LogiCORE IP XPS HWICAP (v5.01a) DS586, Xilinx, 2011.</p><p class=ql-align-justify>[5] L. A. Cardona, J. Agrawal, Y. Guo, J. Oliver, and C. Ferrer, “Performance-areaimprovement by partial reconfiguration for an aerospace remote sensingapplication,” in Proceedings of the International Conference onReconfigurable Computing and FPGAs (ReConFig ’11), pp. 497–500, Cancun, Mexico, November-December 2011.</p><p class=ql-align-justify>[6] C. Claus, R. Ahmed, F. Altenried, and W. Stechele, “Towards rapiddynamic partial reconfiguration in video-based driver assistance systems,” in Reconfigurable Computing: Architectures, Tools and Applications, P. Sirisuk,F.Morgan,T.Elhazawi, and H.Amano, Eds., vol. 5992 of Lecture Notes inComputer Science, pp. 55–67, Springer, Berlin, Germany, 2010.</p><p class=ql-align-justify>[7] S. Bhandari, S. Subbaraman, S. Pujari et al., “High speed dynamicpartial reconfiguration for real timemultimedia signal processing,” in Proceedings of the 15th Euromicro Conference on Digital System Design(DSD ’12), pp. 319–326, Izmir, Turkey, September 2012.</p><p class=ql-align-justify>[8] IBM, 128-Bit Processor Local Bus Architecture Specifications, IBMCorporation, Armonk, NY, USA, 2007.</p><p class=ql-align-justify>[9] K. Glette and P. Kaufmann, “Lookup table partial reconfiguration foran evolvable hardware classifier system,” in Proceedings ofthe IEEE Congress on Evolutionary Computation (CEC ’14), pp. 1706–1713, Beijing, China, July 2014.</p><p class=ql-align-justify>[10] L. Sterpone and M. Violante, “A new partial reconfigurationbased fault-injectionsystem to evaluate SEU effects in SRAM based FPGAs,” IEEE Transactionson Nuclear Science, vol. 54, no. 4, pp. 965–970, 2007.</p><p class=ql-align-justify>[11] M. Liu, W. Kuehn, Z. Lu, and A. Jantsch, “Run-time partial reconfigurationspeed investigation and architectural design space exploration,” in Proceedings of the International Conference on Field Programmable Logicand Applications (FPL ’09),</p><p class=ql-align-justify>pp. 498–502, August 2009.</p><p class=ql-align-justify>[12] C. Claus, B. Zhang, W. Stechele, L. Braun, M. H¨ubner, and J. Becker,“A multi-platform controller allowing for maximum dynamic partialreconfiguration throughput,” in Proceedings of theInternational Conference on Field Programmable Logic and Applications (FPL ’08), pp. 535–538, Heidelberg, Germany, September2008.</p><p class=ql-align-justify>[13] M. H¨ubner, D. G¨ohringer, J. Noguera, and J. Becker, “Fast dynamicand partial reconfiguration data path with low hardware overhead on XilinxFPGAs,” in Proceedings of the IEEE International Symposium on Parallel andDistributed Processing, Workshops and Phd Forum(IPDPSW’10), pp. 1–8, IEEE,Atlanta, Ga, USA, April 2010.</p><p class=ql-align-justify>[14] S. Lamonnier, M. Thoris, and M. Ambielle, “Accelerate partial reconfigurationwith a 100% hardware solution,” Xcell Journal, no. 79, pp.44–49, 2012.</p><p class=ql-align-justify>[15] J. Tarrillo, F. A. Escobar, F. L. Kastensmidt, and C. Valderrama, “Dynamicpartial reconfiguration manager,” in Proceedings of the IEEE 5thLatin American Symposium on Circuits and Systems (LASCAS ’14), pp. 1–4, IEEE, Santiago, Chile, February2014. International Journal of Reconfigurable Computing 15</p><p class=ql-align-justify>[16] V. Lai and O. Diessel, “ICAP-I: a reusable interface for the internalreconfiguration of Xilinx FPGAs,” in Proceedings of theInternational Conference on Field-Programmable Technology (FPT ’09), pp. 357–360, Sydney, Australia, December 2009.</p><p class=ql-align-justify>[17] M. Straka, J. Kastil, and Z. Kotasek, “Generic partial dynamic reconfigurationcontroller for fault tolerant designs based on FPGA,” in Proceedings of the 28th Norchip Conference (NORCHIP ’10), pp. 1–4, IEEE, Tampere, Finland, November</p><p class=ql-align-justify>2010.</p><p class=ql-align-justify>[18] S. G. Hansen, D. Koch, and J. Torresen, “High speed partial run-timereconfiguration using enhanced ICAP hard macro,” in Proceedings ofthe 25th IEEE International Parallel and Distributed Processing Symposium,Workshops and Phd Forum (IPDPSW ’11), pp. 174–180, Shanghai,China, May 2011.</p><p class=ql-align-justify>[19] Xilinx, AXI HWICAP v3.0, Xilinx, San Jose, Calif, USA, 2015.</p><p class=ql-align-justify>[20] A. Ebrahim, K. Benkrid, X. Iturbe, and C. Hong, “A novelhighperformance</p><p class=ql-align-justify>fault-tolerant ICAP controller,” in Proceedings of theNASA/ESA Conference on Adaptive Hardware and Systems (AHS ’12), pp. 259–263, IEEE, Erlangen, Germany, June2012.</p><p class=ql-align-justify>[21] A. Ebrahim, T. Arslan, and X. Iturbe, “On enhancing the reliabilityof internal configuration controllers in FPGAs,” in Proceedings ofthe NASA/ESAConference onAdaptiveHardware and Systems (AHS ’14), pp. 83–88, IEEE, Leicester, UK, July 2014.</p><p class=ql-align-justify>[22] J. Heiner, N. Collins, and M. Wirthlin, “Fault tolerant ICAP controllerfor high-reliable internal scrubbing,” in Proceedings ofthe IEEE Aerospace Conference, pp. 1–10, IEEE, BigSky,Mont, USA, March 2008.</p><p class=ql-align-justify>[23] A. Ebrahim, K. Benkrid, X. Iturbe, and C. Hong, “Multipleclone configurationof relocatable partial bitstreams in Xilinx Virtex FPGAs,” in Proceedings of the NASA/ESA Conference on Adaptive Hardware and Systems(AHS ’13), pp. 178–183, Torino, Italy, June 2013.</p><p class=ql-align-justify>[24] U. Legat, A. Biasizzo, and F. Novak, “SEU recovery mechanism for SRAM-BasedFPGAs,” IEEE Transactions on Nuclear Science, vol. 59, no. 5, pp. 2562–2571, 2012.</p><p class=ql-align-justify>[25] C. Schuck, B. Haetzer, and J. Becker, “An interface for a decentralized2D reconfiguration on Xilinx Virtex-FPGAs for organic computing,” International Journal of Reconfigurable Computing, vol.2009,Article ID 273791, 11 pages, 2009.</p><p class=ql-align-justify>[26] Xilinx, Partial Reconfiguration User Guide UG702(V14.7), Xilinx, 2013.</p><p class=ql-align-justify>[27] Xilinx, Command Line Tools User Guide UG628 (v 14.7), Xilinx, SanJose, Calif, USA, 2013.</p><p class=ql-align-justify>[28] Xilinx, Virtex-5 FPGA Configuration Guide UG191 (V3.11), Xilinx, 2012.</p><p class=ql-align-justify>[29] Xilinx,ChipScope Pro Software and Cores, Xilinx,SanJose, Calif, USA, 2012.</p><p class=ql-align-justify>[30] Xilinx, Xilinx Kintex-7 FPGA KC705 Evaluation Kit, Xilinx, San Jose,Calif, USA, 2015.</p><p class=ql-align-justify>[31] Opencores,“AES project,” 2015, http://opencores.org/project.</p><p class=ql-align-justify>如有同學不方便下載英文原文，可把郵箱留言給我。</p><p>全文完。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>FPGA</a></li><li><a>什麼</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc3bb81.html alt=SpringAOP-什麼是面向切面編程？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/93af441322d4418ebbb68664166fb2ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc3bb81.html title=SpringAOP-什麼是面向切面編程？>SpringAOP-什麼是面向切面編程？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a3dd46e.html alt=淺談什麼是面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cec16fd5ca3f4d19b4d848f6d373e7fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a3dd46e.html title=淺談什麼是面向切面編程AOP>淺談什麼是面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09ffeb76.html alt=揭祕什麼是面向接口編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09ffeb76.html title=揭祕什麼是面向接口編程>揭祕什麼是面向接口編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f618890d.html alt=為什麼我們要面向接口編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/666365bd6f6e40b19810d1f3930abd70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f618890d.html title=為什麼我們要面向接口編程>為什麼我們要面向接口編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b74636e.html alt=程序設計中面向接口編程是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b74636e.html title=程序設計中面向接口編程是什麼>程序設計中面向接口編程是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html alt=什麼是面向對象的編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/be4dacb2168b48e085eec6c0640bc176 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html title=什麼是面向對象的編程思想>什麼是面向對象的編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html alt=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f2e808d6760462aafc6bfbb0e718954 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html title=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維>你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/810c487e.html alt="到底什麼是面向對象編程( OOP )？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5462f49b28c446b4b9214dae06156a7c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/810c487e.html title="到底什麼是面向對象編程( OOP )？">到底什麼是面向對象編程( OOP )？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdedb94f.html alt=科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d84b472b45474058bfd6bd4b87450f53 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdedb94f.html title=科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！>科普貼！丨你知道港珠澳大橋為什麼是彎的嗎！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52ecc739.html alt=科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f0b8a6daf6e4f9bab21e7c06cbc9111 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52ecc739.html title=科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！>科普！看完這篇文章，你就知道港珠澳大橋為什麼是彎的了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html alt=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1537941825042b6f495fa56 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html title=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？>長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83641773.html alt=什麼是懸挑結構？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/faebf061b82546f58e63afab5ede5fa2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83641773.html title=什麼是懸挑結構？>什麼是懸挑結構？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a27253ff.html alt=港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a3c45dcf4c374ed4be36f55d44847637 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a27253ff.html title=港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事>港珠澳大橋為什麼是曲線的？關於橋那些你不知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3eed9cb8.html alt=科普！港珠澳大橋為什麼是彎的！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/41bd66f3348b464c89b66628810a1aeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3eed9cb8.html title=科普！港珠澳大橋為什麼是彎的！>科普！港珠澳大橋為什麼是彎的！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>