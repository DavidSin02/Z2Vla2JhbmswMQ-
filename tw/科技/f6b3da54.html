<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試28k職位，面試官從HashCode到哈希給我上了一課 | 极客快訊</title><meta property="og:title" content="面試28k職位，面試官從HashCode到哈希給我上了一課 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6bf239c922a74c0c88f5f91a4c0c45b9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6b3da54.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6b3da54.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6b3da54.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6b3da54.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6b3da54.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6b3da54.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6b3da54.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6b3da54.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="面試28k職位，面試官從HashCode到哈希給我上了一課"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f6b3da54.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試28k職位，面試官從HashCode到哈希給我上了一課</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、前言</h1><p>不是面試難，而是30歲要有30歲的能力，35歲要有35歲的經歷！</p><p>☺️可能有點標題誇張，但本文通篇乾貨，要不親身實踐各項知識點，很難有這樣的深度的總結。有時候我們會抱怨找工作難，但同樣企業招聘也難，面試官向我透漏，為了招聘3個高開，以及篩選了200份簡歷，面試了70場。</p><p>本文從 HashCode 講到 HashMap，從一個小小的知識點擴展的理論實踐驗證，10來萬單詞表的數據驗證；數據分佈、擾動函數、負載因子、數據遷移等各項核心數學知識，非常適合即將跨入高開的程序員學習。</p><p>好！接下來就是我們這次面試的核心知識點總結，通篇1.6萬字，需耐心閱讀。</p><h1 class=pgc-h-arrow-right>二、HashCode為什麼使用31作為乘數</h1><ol start=1><li>固定乘積31在這用到了</li></ol><pre><code>// 獲取hashCode "abc".hashCode();public int hashCode() {    int h = hash;    if (h == 0 &amp;&amp; value.length &gt; 0) {        char val[] = value;        for (int i = 0; i &lt; value.length; i++) {            h = 31 * h + val[i];        }        hash = h;    }    return h;}</code></pre><p>在獲取hashCode的源碼中可以看到，有一個固定值31，在for循環每次執行時進行乘積計算，循環後的公式如下；<br>s[0]<em>31^(n-1) + s[1]</em>31^(n-2) + ... + s[n-1]</p><p>那麼這裡為什麼選擇31作為乘積值呢？</p><h1 class=pgc-h-arrow-right>2. 來自stackoverflow的回答</h1><p>在stackoverflow關於為什麼選擇31作為固定乘積值，有一篇討論文章，Why does Java's hashCode() in String use 31 as a multiplier? 這是一個時間比較久的問題了，摘取兩個回答點贊最多的；</p><p><strong>413個讚的回答</strong></p><p>最多的這個回答是來自《Effective Java》的內容；</p><pre><code>The value 31 was chosen because it is an odd prime. If it were even and the multiplication overflowed, information would be lost, as multiplication by 2 is equivalent to shifting. The advantage of using a prime is less clear, but it is traditional. A nice property of 31 is that the multiplication can be replaced by a shift and a subtraction for better performance: 31 * i == (i &lt;&lt; 5) - i. Modern VMs do this sort of optimization automatically.</code></pre><p>這段內容主要闡述的觀點包括；</p><p>1、31 是一個奇質數。<br>2、另外在二進制中，2個5次方是32，那麼也就是 31 * i == (i &lt;&lt; 5) - i。這主要是說乘積運算可以使用位移提升性能，同時目前的JVM虛擬機也會自動支持此類的優化。</p><p>80個讚的回答</p><pre><code>As Goodrich and Tamassia point out, If you take over 50,000 English words (formed as the union of the word lists provided in two variants of Unix), using the constants 31, 33, 37, 39, and 41 will produce less than 7 collisions in each case. Knowing this, it should come as no surprise that many Java implementations choose one of these constants.</code></pre><p>1、這個回答就很有實戰意義了，告訴你用超過5千個單詞計算hashCode，這個hashCode的運算使用31、33、37、39和41作為乘積，得到的碰撞結果，31被使用就很正常了。<br>2、他這句話就就可以作為我們實踐的指向了。</p><h1 class=pgc-h-arrow-right>3. Hash值碰撞概率統計</h1><p>接下來要做的事情並不難，只是根據stackoverflow的回答，統計出不同的乘積數對10萬個單詞的hash計算結果。</p><h1 class=pgc-h-arrow-right>3.1 讀取單詞字典表</h1><pre><code>1    a    "n.(A)As 或 A's  安(ampere(a) art.一;n.字母A /[軍] Analog.Digital,模擬/數字 /(=account of) 帳上"2    aaal    American Academy of Arts and Letters 美國藝術和文學學會3    aachen     亞琛[德意志聯邦共和國西部城市]4    aacs    Airways and Air Communications Service (美國)航路與航空通訊聯絡處5    aah    " [軍]Armored Artillery Howitzer,裝甲榴彈炮;[軍]Advanced Attack Helicopter,先進攻擊直升機"6    aal    "ATM Adaptation Layer,ATM適應層"7    aapamoor    "n.[生]丘澤,高低位鑲嵌沼澤"</code></pre><ul><li>單詞表的文件格式如上，可以自行解析</li><li>讀取文件的代碼比較簡單，這裡不展示了，可以通過資源下載進行獲取</li></ul><h1 class=pgc-h-arrow-right>3.2 Hash計算函數</h1><pre><code>public static Integer hashCode(String str, Integer multiplier) {    int hash = 0;    for (int i = 0; i &lt; str.length(); i++) {        hash = multiplier * hash + str.charAt(i);    }    return hash;}</code></pre><ul><li>這個過程比較簡單，與原hash函數對比只是替換了可變參數，用於我們統計不同乘積數的計算結果。</li></ul><h1 class=pgc-h-arrow-right>3.3 Hash碰撞概率計算</h1><p>想計算碰撞很簡單，也就是計算那些出現相同哈希值的數量，計算出碰撞總量即可。這裡的實現方式有很多，可以使用set、map也可以使用java8的stream流統計distinct。</p><pre><code>private static RateInfo hashCollisionRate(Integer multiplier, List&lt;Integer&gt; hashCodeList) {    int maxHash = hashCodeList.stream().max(Integer::compareTo).get();    int minHash = hashCodeList.stream().min(Integer::compareTo).get();    int collisionCount = (int) (hashCodeList.size() - hashCodeList.stream().distinct().count());    double collisionRate = (collisionCount * 1.0) / hashCodeList.size();    return new RateInfo(maxHash, minHash, multiplier, collisionCount, collisionRate);}</code></pre><ul><li>這裡記錄了最大hash和最小hash值，以及最終返回碰撞數量的統計結果。</li></ul><h1 class=pgc-h-arrow-right>3.4 單元測試</h1><pre><code>@Beforepublic void before() {    "abc".hashCode();    // 讀取文件，103976個英語單詞庫.txt    words = FileUtil.readWordList("E:/itstack/git/github.com/interview/interview-01/103976個英語單詞庫.txt");}@Testpublic void test_collisionRate() {    List&lt;RateInfo&gt; rateInfoList = HashCode.collisionRateList(words, 2, 3, 5, 7, 17, 31, 32, 33, 39, 41, 199);    for (RateInfo rate : rateInfoList) {        System.out.println(String.format("乘數 = %4d, 最小Hash = %11d, 最大Hash = %10d, 碰撞數量 =%6d, 碰撞概率 = %.4f%%", rate.getMultiplier(), rate.getMinHash(), rate.getMaxHash(), rate.getCollisionCount(), rate.getCollisionRate() * 100));    }}</code></pre><ul><li>以上先設定讀取英文單詞表中的10個單詞，之後做hash計算。</li><li>在hash計算中把單詞表傳遞進去，同時還有乘積數；2, 3, 5, 7, 17, 31, 32, 33, 39, 41, 199，最終返回一個list結果並輸出。</li><li>這裡主要驗證同一批單詞，對於不同乘積數會有怎麼樣的hash碰撞結果。</li></ul><h1 class=pgc-h-arrow-right>測試結果</h1><pre><code>單詞數量：103976乘數 =    2, 最小Hash =          97, 最大Hash = 1842581979, 碰撞數量 = 60382, 碰撞概率 = 58.0730%乘數 =    3, 最小Hash = -2147308825, 最大Hash = 2146995420, 碰撞數量 = 24300, 碰撞概率 = 23.3708%乘數 =    5, 最小Hash = -2147091606, 最大Hash = 2147227581, 碰撞數量 =  7994, 碰撞概率 = 7.6883%乘數 =    7, 最小Hash = -2147431389, 最大Hash = 2147226363, 碰撞數量 =  3826, 碰撞概率 = 3.6797%乘數 =   17, 最小Hash = -2147238638, 最大Hash = 2147101452, 碰撞數量 =   576, 碰撞概率 = 0.5540%乘數 =   31, 最小Hash = -2147461248, 最大Hash = 2147444544, 碰撞數量 =     2, 碰撞概率 = 0.0019%乘數 =   32, 最小Hash = -2007883634, 最大Hash = 2074238226, 碰撞數量 = 34947, 碰撞概率 = 33.6106%乘數 =   33, 最小Hash = -2147469046, 最大Hash = 2147378587, 碰撞數量 =     1, 碰撞概率 = 0.0010%乘數 =   39, 最小Hash = -2147463635, 最大Hash = 2147443239, 碰撞數量 =     0, 碰撞概率 = 0.0000%乘數 =   41, 最小Hash = -2147423916, 最大Hash = 2147441721, 碰撞數量 =     1, 碰撞概率 = 0.0010%乘數 =  199, 最小Hash = -2147459902, 最大Hash = 2147480320, 碰撞數量 =     0, 碰撞概率 = 0.0000%Process finished with exit code 0</code></pre><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6bf239c922a74c0c88f5f91a4c0c45b9><p class=pgc-img-caption></p></div><p>以上就是不同的乘數下的hash碰撞結果圖標展示，從這裡可以看出如下信息；</p><ol start=1><li>乘數是2時，hash的取值範圍比較小，基本是堆積到一個範圍內了，後面內容會看到這塊的展示。</li><li>乘數是3、5、7、17等，都有較大的碰撞概率</li><li>乘數是31的時候，碰撞的概率已經很小了，基本穩定。</li><li>順著往下看，你會發現199的碰撞概率更小，這就相當於一排奇數的茅坑量多，自然會減少碰撞。但這個範圍值已經遠超過int的取值範圍了，如果用此數作為乘數，又返回int值，就會丟失數據信息。</li></ol><h1 class=pgc-h-arrow-right>4. Hash值散列分佈</h1><p>除了以上看到哈希值在不同乘數的一個碰撞概率後，關於散列表也就是hash，還有一個非常重要的點，那就是要儘可能的讓數據散列分佈。只有這樣才能減少hash碰撞次數，也就是後面章節要講到的hashMap源碼。</p><p>那麼怎麼看散列分佈呢？如果我們能把10萬個hash值鋪到圖表上，形成的一張圖，就可以看出整個散列分佈。但是這樣的圖會比較大，當我們縮小看後，就成一個了大黑點。所以這裡我們採取分段統計，把2 ^ 32方分64個格子進行存放，每個格子都會有對應的數量的hash值，最終把這些數據展示在圖表上。</p><h1 class=pgc-h-arrow-right>4.1 哈希值分段存放</h1><pre><code>public static Map&lt;Integer, Integer&gt; hashArea(List&lt;Integer&gt; hashCodeList) {    Map&lt;Integer, Integer&gt; statistics = new LinkedHashMap&lt;&gt;();    int start = 0;    for (long i = 0x80000000; i &lt;= 0x7fffffff; i += 67108864) {        long min = i;        long max = min + 67108864;        // 篩選出每個格子裡的哈希值數量，java8流統計；https://bugstack.cn/itstack-demo-any/2019/12/10/%E6%9C%89%E7%82%B9%E5%B9%B2%E8%B4%A7-Jdk1.8%E6%96%B0%E7%89%B9%E6%80%A7%E5%AE%9E%E6%88%98%E7%AF%87(41%E4%B8%AA%E6%A1%88%E4%BE%8B).html        int num = (int) hashCodeList.parallelStream().filter(x -&gt; x &gt;= min &amp;&amp; x &lt; max).count();        statistics.put(start++, num);    }    return statistics;</code></pre><ul><li>這個過程主要統計int取值範圍內，每個哈希值存放到不同格子裡的數量。</li><li>這裡也是使用了java8的新特性語法，統計起來還是比較方便的。</li></ul><h1 class=pgc-h-arrow-right>4.2 單元測試</h1><pre><code>@Testpublic void test_hashArea() {    System.out.println(HashCode.hashArea(words, 2).values());    System.out.println(HashCode.hashArea(words, 7).values());    System.out.println(HashCode.hashArea(words, 31).values());    System.out.println(HashCode.hashArea(words, 32).values());    System.out.println(HashCode.hashArea(words, 199).values());}</code></pre><ul><li>這裡列出我們要統計的乘數值，每一個乘數下都會有對應的哈希值數量彙總，也就是64個格子裡的數量。</li><li>最終把這些統計值放入到excel中進行圖表化展示。</li></ul><h1 class=pgc-h-arrow-right>統計圖表</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d820a230793643f28acbdb72260e20c4><p class=pgc-img-caption></p></div><ul><li>以上是一個堆積百分比統計圖，可以看到下方是不同乘數下的，每個格子裡的數據統計。</li><li>除了199不能用以外，31的散列結果相對來說比較均勻。</li></ul><h1 class=pgc-h-arrow-right>4.2.1 乘數2散列</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d312f6a1b4e04cb99c5b3a75d405677c><p class=pgc-img-caption></p></div><ul><li>乘數是2的時候，散列的結果基本都堆積在中間，沒有很好的散列。</li></ul><h1 class=pgc-h-arrow-right>4.2.2 乘數31散列</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f17c52e5012e42c5a13e047ab5bfbc5b><p class=pgc-img-caption></p></div><ul><li>乘數是31的時候，散列的效果就非常明顯了，基本在每個範圍都有數據存放。</li></ul><h1 class=pgc-h-arrow-right>4.2.3 乘數199散列</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/519cdcdc3bfc427bbae05d21a5ad6fec><p class=pgc-img-caption></p></div><ul><li>乘數是199是不能用的散列結果，但是它的數據是更加分散的，從圖上能看到有兩個小山包。但因為數據區間問題會有數據丟失問題，所以不能選擇。</li></ul><h1 class=pgc-h-arrow-right>三、HashMap 數據結構與算法</h1><h1 class=pgc-h-arrow-right>1. 寫一個最簡單的HashMap</h1><p>學習HashMap前，最好的方式是先了解這是一種怎麼樣的數據結構來存放數據。而HashMap經過多個版本的迭代後，乍一看代碼還是很複雜的。就像你原來只穿個褲衩，現在還有秋褲和風衣。所以我們先來看看最根本的HashMap是什麼樣，也就是隻穿褲衩是什麼效果，之後再去分析它的源碼。</p><p>問題：假設我們有一組7個字符串，需要存放到數組中，但要求在獲取每個元素的時候時間複雜度是O(1)。也就是說你不能通過循環遍歷的方式進行獲取，而是要定位到數組ID直接獲取相應的元素。</p><p>方案：如果說我們需要通過ID從數組中獲取元素，那麼就需要把每個字符串都計算出一個在數組中的位置ID。字符串獲取ID你能想到什麼方式？ 一個字符串最直接的獲取跟數字相關的信息就是HashCode，可HashCode的取值範圍太大了[-2147483648, 2147483647]，不可能直接使用。那麼就需要使用HashCode與數組長度做與運算，得到一個可以在數組中出現的位置。如果說有兩個元素得到同樣的ID，那麼這個數組ID下就存放兩個字符串。</p><p>以上呢其實就是我們要把字符串散列到數組中的一個基本思路，接下來我們就把這個思路用代碼實現出來。</p><h1 class=pgc-h-arrow-right>1.1 代碼實現</h1><pre><code>// 初始化一組字符串List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("jlkk");list.add("lopi");list.add("小傅哥");list.add("e4we");list.add("alpo");list.add("yhjk");list.add("plop");// 定義要存放的數組String[] tab = new String[8];// 循環存放for (String key : list) {    int idx = key.hashCode() &amp; (tab.length - 1);  // 計算索引位置    System.out.println(String.format("key值=%s Idx=%d", key, idx));    if (null == tab[idx]) {        tab[idx] = key;        continue;    }    tab[idx] = tab[idx] + "-&gt;" + key;}// 輸出測試結果System.out.println(JSON.toJSONString(tab));</code></pre><p>這段代碼整體看起來也是非常簡單，並沒有什麼複雜度，主要包括以下內容；</p><ol start=1><li>初始化一組字符串集合，這裡初始化了7個。</li><li>定義一個數組用於存放字符串，注意這裡的長度是8，也就是2的倍數。這樣的數組長度才會出現一個 0111 除高位以外都是1的特徵，也是為了散列。</li><li>接下來就是循環存放數據，計算出每個字符串在數組中的位置。key.hashCode() & (tab.length - 1)。</li><li>在字符串存放到數組的過程，如果遇到相同的元素，進行連接操作模擬鏈表的過程。</li><li>最後輸出存放結果。</li></ol><h1 class=pgc-h-arrow-right>測試結果</h1><pre><code>key值=jlkk Idx=2key值=lopi Idx=4key值=小傅哥 Idx=7key值=e4we Idx=5key值=alpo Idx=2key值=yhjk Idx=0key值=plop Idx=5測試結果：["yhjk",null,"jlkk-&gt;alpo",null,"lopi","e4we-&gt;plop",null,"小傅哥"]</code></pre><ul><li>在測試結果首先是計算出每個元素在數組的Idx，也有出現重複的位置。</li><li>最後是測試結果的輸出，1、3、6，位置是空的，2、5，位置有兩個元素被鏈接起來e4we->plop。</li><li>這就達到了我們一個最基本的要求，將串元素散列存放到數組中，最後通過字符串元素的索引ID進行獲取對應字符串。這樣是HashMap的一個最基本原理，有了這個基礎後面就會更容易理解HashMap的源碼實現。</li></ul><h1 class=pgc-h-arrow-right>1.2 Hash散列示意圖</h1><p>如果上面的測試結果不能在你的頭腦中很好的建立出一個數據結構，那麼可以看以下這張散列示意圖，方便理解；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3befcabdb4ed418792e56c73df4f4513><p class=pgc-img-caption></p></div><ul><li>這張圖就是上面代碼實現的全過程，將每一個字符串元素通過Hash計算索引位置，存放到數組中。</li><li>黃色的索引ID是沒有元素存放、綠色的索引ID存放了一個元素、紅色的索引ID存放了兩個元素。</li></ul><h1 class=pgc-h-arrow-right>1.3 這個簡單的HashMap有哪些問題</h1><p>以上我們實現了一個簡單的HashMap，或者說還算不上HashMap，只能算做一個散列數據存放的雛形。但這樣的一個數據結構放在實際使用中，會有哪些問題呢？</p><ol start=1><li>這裡所有的元素存放都需要獲取一個索引位置，而如果元素的位置不夠散列碰撞嚴重，那麼就失去了散列表存放的意義，沒有達到預期的性能。</li><li>在獲取索引ID的計算公式中，需要數組長度是2的倍數，那麼怎麼進行初始化這個數組大小。</li><li>數組越小碰撞的越大，數組越大碰撞的越小，時間與空間如何取捨。</li><li>目前存放7個元素，已經有兩個位置都存放了2個字符串，那麼鏈表越來越長怎麼優化。</li><li>隨著元素的不斷添加，數組長度不足擴容時，怎麼把原有的元素，拆分到新的位置上去。</li></ol><p>以上這些問題可以歸納為；擾動函數、初始化容量、負載因子、擴容方法以及鏈表和紅黑樹轉換的使用等。接下來我們會逐個問題進行分析。</p><h1 class=pgc-h-arrow-right>2. 擾動函數</h1><p>在HashMap存放元素時候有這樣一段代碼來處理哈希值，這是java 8的散列值擾動函數，用於優化散列效果；</p><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><h1 class=pgc-h-arrow-right>2.1 為什麼使用擾動函數</h1><p>理論上來說字符串的hashCode是一個int類型值，那可以直接作為數組下標了，且不會出現碰撞。但是這個hashCode的取值範圍是[-2147483648, 2147483647]，有將近40億的長度，誰也不能把數組初始化的這麼大，內存也是放不下的。</p><p>我們默認初始化的Map大小是16個長度 DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4，所以獲取的Hash值並不能直接作為下標使用，需要與數組長度進行取模運算得到一個下標值，也就是我們上面做的散列列子。</p><p>那麼，hashMap源碼這裡不只是直接獲取哈希值，還進行了一次擾動計算，(h = key.hashCode()) ^ (h >>> 16)。把哈希值右移16位，也就正好是自己長度的一半，之後與原哈希值做異或運算，這樣就混合了原哈希值中的高位和低位，增大了隨機性。計算方式如下圖；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/128acd516d6746b0b0b1ac527c2521d0><p class=pgc-img-caption></p></div><ul><li>說白了，使用擾動函數就是為了增加隨機性，讓數據元素更加均衡的散列，減少碰撞。</li></ul><h1 class=pgc-h-arrow-right>2.2 實驗驗證擾動函數</h1><p>從上面的分析可以看出，擾動函數使用了哈希值的高半區和低半區做異或，混合原始哈希碼的高位和低位，以此來加大低位區的隨機性。</p><p>但看不到實驗數據的話，這終究是一段理論，具體這段哈希值真的被增加了隨機性沒有，並不知道。所以這裡我們要做一個實驗，這個實驗是這樣做；</p><ol start=1><li>選取10萬個單詞詞庫</li><li>定義128位長度的數組格子</li><li>分別計算在擾動和不擾動下，10萬單詞的下標分配到128個格子的數量</li><li>統計各個格子數量，生成波動曲線。如果擾動函數下的波動曲線相對更平穩，那麼證明擾動函數有效果。</li></ol><h1 class=pgc-h-arrow-right>2.2.1 擾動代碼測試</h1><p>擾動函數對比方法</p><pre><code>public class Disturb {    public static int disturbHashIdx(String key, int size) {        return (size - 1) &amp; (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16));    }    public static int hashIdx(String key, int size) {        return (size - 1) &amp; key.hashCode();    }}</code></pre><ul><li>disturbHashIdx 擾動函數下，下標值計算</li><li>hashIdx 非擾動函數下，下標值計算</li></ul><h1 class=pgc-h-arrow-right>單元測試</h1><pre><code>// 10萬單詞已經初始化到words中@Testpublic void test_disturb() {    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(16);    for (String word : words) {        // 使用擾動函數        int idx = Disturb.disturbHashIdx(word, 128);        // 不使用擾動函數        // int idx = Disturb.hashIdx(word, 128);        if (map.containsKey(idx)) {            Integer integer = map.get(idx);            map.put(idx, ++integer);        } else {            map.put(idx, 1);        }    }    System.out.println(map.values());}</code></pre><p>以上分別統計兩種函數下的下標值分配，最終將統計結果放到excel中生成圖表。</p><h1 class=pgc-h-arrow-right>2.2.2 擾動函數散列圖表</h1><p>以上的兩張圖，分別是沒有使用擾動函數和使用擾動函數的，下標分配。實驗數據；</p><ol start=1><li>10萬個不重複的單詞</li><li>128個格子，相當於128長度的數組</li></ol><p>未使用擾動函數</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6f86d9e58b8740f0ad0ee106bec88997><p class=pgc-img-caption></p></div><p>使用擾動函數</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1e8f3c53612a49ccb64c0ca5f89713c5><p class=pgc-img-caption></p></div><ul><li>從這兩種的對比圖可以看出來，在使用了擾動函數後，數據分配的更加均勻了。</li><li>數據分配均勻，也就是散列的效果更好，減少了hash的碰撞，讓數據存放和獲取的效率更佳。</li></ul><h1 class=pgc-h-arrow-right>3. 初始化容量和負載因子</h1><p>接下來我們討論下一個問題，從我們模仿HashMap的例子中以及HashMap默認的初始化大小裡，都可以知道，散列數組需要一個2的倍數的長度，因為只有2的倍數在減1的時候，才會出現01111這樣的值。</p><p>那麼這裡就有一個問題，我們在初始化HashMap的時候，如果傳一個17個的值new HashMap&lt;>(17);，它會怎麼處理呢？</p><h1 class=pgc-h-arrow-right>3.1 尋找2的倍數最小值</h1><p>在HashMap的初始化中，有這樣一段方法；</p><pre><code>public HashMap(int initialCapacity, float loadFactor) {    ...    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);}</code></pre><ul><li>閥值threshold，通過方法tableSizeFor進行計算，是根據初始化來計算的。</li><li>這個方法也就是要尋找比初始值大的，最小的那個2進制數值。比如傳了17，我應該找到的是32。</li></ul><p>計算閥值大小的方法；</p><pre><code>static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><ul><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，這個是臨界範圍，也就是最大的Map集合。</li><li>乍一看可能有點暈怎麼都在向右移位1、2、4、8、16，這主要是為了把二進制的各個位置都填上1，當二進制的各個位置都是1以後，就是一個標準的2的倍數減1了，最後把結果加1再返回即可。</li></ul><p>那這裡我們把17這樣一個初始化計算閥值的過程，用圖展示出來，方便理解；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/088c8c8127074104a2f43adc55619b23><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>3.2 負載因子</h1><pre><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre><h1 class=pgc-h-arrow-right>負載因子是做什麼的？</h1><p>負載因子，可以理解成一輛車可承重重量超過某個閥值時，把貨放到新的車上。</p><p>那麼在HashMap中，負載因子決定了數據量多少了以後進行擴容。這裡要提到上面做的HashMap例子，我們準備了7個元素，但是最後還有3個位置空餘，2個位置存放了2個元素。 所以可能即使你數據比數組容量大時也是不一定能正正好好的把數組佔滿的，而是在某些小標位置出現了大量的碰撞，只能在同一個位置用鏈表存放，那麼這樣就失去了Map數組的性能。</p><p>所以，要選擇一個合理的大小下進行擴容，默認值0.75就是說當閥值容量佔了3/4s時趕緊擴容，減少Hash碰撞。</p><p>同時0.75是一個默認構造值，在創建HashMap也可以調整，比如你希望用更多的空間換取時間，可以把負載因子調的更小一些，減少碰撞。</p><h1 class=pgc-h-arrow-right>4. 擴容元素拆分</h1><p>為什麼擴容，因為數組長度不足了。那擴容最直接的問題，就是需要把元素拆分到新的數組中。拆分元素的過程中，原jdk1.7中會需要重新計算哈希值，但是到jdk1.8中已經進行優化，不在需要重新計算，提升了拆分的性能，設計的還是非常巧妙的。</p><h1 class=pgc-h-arrow-right>4.1 測試數據</h1><pre><code>@Testpublic void test_hashMap() {    List&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add("jlkk");    list.add("lopi");    list.add("jmdw");    list.add("e4we");    list.add("io98");    list.add("nmhg");    list.add("vfg6");    list.add("gfrt");    list.add("alpo");    list.add("vfbh");    list.add("bnhj");    list.add("zuio");    list.add("iu8e");    list.add("yhjk");    list.add("plop");    list.add("dd0p");    for (String key : list) {        int hash = key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16);        System.out.println("字符串：" + key + " \tIdx(16)：" + ((16 - 1) &amp; hash) + " \tBit值：" + Integer.toBinaryString(hash) + " - " + Integer.toBinaryString(hash &amp; 16) + " \t\tIdx(32)：" + ((        System.out.println(Integer.toBinaryString(key.hashCode()) +" "+ Integer.toBinaryString(hash) + " " + Integer.toBinaryString((32 - 1) &amp; hash));    }}</code></pre><h1 class=pgc-h-arrow-right>測試結果</h1><pre><code>字符串：jlkk     Idx(16)：3     Bit值：1100011101001000010011 - 10000         Idx(32)：191100011101001000100010 1100011101001000010011 10011字符串：lopi     Idx(16)：14     Bit值：1100101100011010001110 - 0         Idx(32)：141100101100011010111100 1100101100011010001110 1110字符串：jmdw     Idx(16)：7     Bit值：1100011101010100100111 - 0         Idx(32)：71100011101010100010110 1100011101010100100111 111字符串：e4we     Idx(16)：3     Bit值：1011101011101101010011 - 10000         Idx(32)：191011101011101101111101 1011101011101101010011 10011字符串：io98     Idx(16)：4     Bit值：1100010110001011110100 - 10000         Idx(32)：201100010110001011000101 1100010110001011110100 10100字符串：nmhg     Idx(16)：13     Bit值：1100111010011011001101 - 0         Idx(32)：131100111010011011111110 1100111010011011001101 1101字符串：vfg6     Idx(16)：8     Bit值：1101110010111101101000 - 0         Idx(32)：81101110010111101011111 1101110010111101101000 1000字符串：gfrt     Idx(16)：1     Bit值：1100000101111101010001 - 10000         Idx(32)：171100000101111101100001 1100000101111101010001 10001字符串：alpo     Idx(16)：7     Bit值：1011011011101101000111 - 0         Idx(32)：71011011011101101101010 1011011011101101000111 111字符串：vfbh     Idx(16)：1     Bit值：1101110010111011000001 - 0         Idx(32)：11101110010111011110110 1101110010111011000001 1字符串：bnhj     Idx(16)：0     Bit值：1011100011011001100000 - 0         Idx(32)：01011100011011001001110 1011100011011001100000 0字符串：zuio     Idx(16)：8     Bit值：1110010011100110011000 - 10000         Idx(32)：241110010011100110100001 1110010011100110011000 11000字符串：iu8e     Idx(16)：8     Bit值：1100010111100101101000 - 0         Idx(32)：81100010111100101011001 1100010111100101101000 1000字符串：yhjk     Idx(16)：8     Bit值：1110001001010010101000 - 0         Idx(32)：81110001001010010010000 1110001001010010101000 1000字符串：plop     Idx(16)：9     Bit值：1101001000110011101001 - 0         Idx(32)：91101001000110011011101 1101001000110011101001 1001字符串：dd0p     Idx(16)：14     Bit值：1011101111001011101110 - 0         Idx(32)：141011101111001011000000 1011101111001011101110 1110</code></pre><ul><li>這裡我們隨機使用一些字符串計算他們分別在16位長度和32位長度數組下的索引分配情況，看哪些數據被重新路由到了新的地址。</li><li>同時，這裡還可以觀察出一個非常重要的信息，原哈希值與擴容新增出來的長度16，進行&運算，如果值等於0，則下標位置不變。如果不為0，那麼新的位置則是原來位置上加16。｛這個地方需要好好理解下，並看實驗數據｝</li><li>這樣一來，就不需要在重新計算每一個數組中元素的哈希值了。</li></ul><h1 class=pgc-h-arrow-right>4.2 數據遷移</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1fc462fd5e54442f94b5e64c773d2cc6><p class=pgc-img-caption></p></div><ul><li>這張圖就是原16位長度數組元素，像32位數組長度中轉移的過程。</li><li>其中黃色區域元素zuio因計算結果 hash & oldCap 不為1，則被遷移到下標位置24。</li><li>同時還是用重新計算哈希值的方式驗證了，確實分配到24的位置，因為這是在二進制計算中補1的過程，所以可以通過上面簡化的方式確定哈希值的位置。</li></ul><h1 class=pgc-h-arrow-right>四、HashMap源碼解析</h1><h1 class=pgc-h-arrow-right>1. 插入</h1><h1 class=pgc-h-arrow-right>1.1 疑問點&考題</h1><p>大家對於一個散列表數據結構的HashMap往裡面插入數據時，基本已經有了一個印象。簡單來說就是通過你的Key值取得哈希再計算下標，之後把相應的數據存放到裡面。</p><p>但再這個過程中會遇到一些問題，比如；</p><ol start=1><li>如果出現哈希值計算的下標碰撞了怎麼辦？</li><li>如果碰撞了是擴容數組還是把值存成鏈表結構，讓一個節點有多個值存放呢？</li><li>如果存放的數據的鏈表過長，就失去了散列表的性能了，怎麼辦呢？</li><li>如果想解決鏈表過長，什麼時候使用樹結構呢，使用哪種樹呢？<br>這些疑問點都會在後面的內容中逐步講解，也可以自己思考一下，如果是你來設計，你會怎麼做。</li></ol><h1 class=pgc-h-arrow-right>1.2 插入流程和源碼分析</h1><h1 class=pgc-h-arrow-right>HashMap插入數據流程圖</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0daa66c318054b139bf3730ba102d38a><p class=pgc-img-caption></p></div><p>以上就是HashMap中一個數據插入的整體流程，包括了；計算下標、何時擴容、何時鏈表轉紅黑樹等，具體如下；</p><ol start=1><li>首先進行哈希值的擾動，獲取一個新的哈希值。(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);</li><li>判斷tab是否位空或者長度為0，如果是則進行擴容操作。</li></ol><pre><code>if ((tab = table) == null || (n = tab.length) == 0)    n = (tab = resize()).length;</code></pre><ol start=3><li>根據哈希值計算下標，如果對應小標正好沒有存放數據，則直接插入即可否則需要覆蓋。tab[i = (n - 1) & hash])</li><li>判斷tab[i]是否為樹節點，否則向鏈表中插入數據，是則向樹中插入節點。</li><li>如果鏈表中插入節點的時候，鏈表長度大於等於8，則需要把鏈表轉換為紅黑樹。treeifyBin(tab, hash);</li><li>最後所有元素處理完成後，判斷是否超過閾值；threshold，超過則擴容。</li><li>treeifyBin,是一個鏈表轉樹的方法，但不是所有的鏈表長度為8後都會轉成樹，還需要判斷存放key值的數組桶長度是否小於64 MIN_TREEIFY_CAPACITY。如果小於則需要擴容，擴容後鏈表上的數據會被拆分散列的相應的桶節點上，也就把鏈表長度縮短了。</li></ol><h1 class=pgc-h-arrow-right>JDK1.8 HashMap的put方法源碼如下:</h1><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 初始化桶數組 table，table 被延遲到插入新數據時再進行初始化    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // 如果桶中不包含鍵值對節點引用，則將新鍵值對節點的引用存入桶中即可    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        // 如果鍵的值以及節點 hash 等於鏈表中的第一個鍵值對節點時，則將 e 指向該鍵值對        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;                    // 如果桶中的引用類型為 TreeNode，則調用紅黑樹的插入方法        else if (p instanceof TreeNode)              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            // 對鏈表進行遍歷，並統計鏈表長度            for (int binCount = 0; ; ++binCount) {                // 鏈表中不包含要插入的鍵值對節點時，則將該節點接在鏈表的最後                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    // 如果鏈表長度大於或等於樹化閾值，則進行樹化操作                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                                // 條件為 true，表示當前鏈表包含要插入的鍵值對，終止遍歷                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }                // 判斷要插入的鍵值對是否存在 HashMap 中        if (e != null) { // existing mapping for key            V oldValue = e.value;            // onlyIfAbsent 表示是否僅在 oldValue 為 null 的情況下更新鍵值對的值            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    // 鍵值對數量超過閾值時，則進行擴容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><h1 class=pgc-h-arrow-right>1.3 擴容機制</h1><p>HashMap是基於數組+鏈表和紅黑樹實現的，但用於存放key值得的數組桶的長度是固定的，由初始化決定。</p><p>那麼，隨著數據的插入數量增加以及負載因子的作用下，就需要擴容來存放更多的數據。而擴容中有一個非常重要的點，就是jdk1.8中的優化操作，可以不需要再重新計算每一個元素的哈希值，這在上一章節中已經講到，可以閱讀系列專題文章，機制如下圖；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b092581bf6b4c99b969e6acc90738de><p class=pgc-img-caption></p></div><p>裡我們主要看下擴容的代碼(註釋部分)；</p><pre><code>final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    // Cap 是 capacity 的縮寫，容量。如果容量不為空，則說明已經初始化。    if (oldCap &gt; 0) {        // 如果容量達到最大1 &lt;&lt; 30則不再擴容        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }                // 按舊容量和閥值的2倍計算新容量和閥值        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold            // initial capacity was placed in threshold 翻譯過來的意思，如下；        // 初始化時，將 threshold 的值賦值給 newCap，        // HashMap 使用 threshold 變量暫時保存 initialCapacity 參數的值        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        // 這一部分也是，源代碼中也有相應的英文註釋        // 調用無參構造方法時，數組桶數組容量為默認容量 1 &lt;&lt; 4; aka 16        // 閥值；是默認容量與負載因子的乘積，0.75        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }        // newThr為0，則使用閥值公式計算容量    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;        @SuppressWarnings({"rawtypes","unchecked"})        // 初始化數組桶，用於存放key        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        // 如果舊數組桶，oldCap有值，則遍歷將鍵值映射到新數組桶中        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    // 這裡split，是紅黑樹拆分操作。在重新映射時操作的。                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    // 這裡是鏈表，如果當前是按照鏈表存放的，則將鏈表節點按原順序進行分組{這裡有專門的文章介紹，如何不需要重新計算哈希值進行拆分《HashMap核心知識，擾動函數、負載因子、擴容鏈表拆分，深度學習》}                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                                        // 將分組後的鏈表映射到桶中                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><p>以上的代碼稍微有些長，但是整體的邏輯還是蠻清晰的，主要包括；</p><ol start=1><li>擴容時計算出新的newCap、newThr，這是兩個單詞的縮寫，一個是Capacity ，另一個是閥Threshold</li><li>newCap用於創新的數組桶 new Node[newCap];</li><li>隨著擴容後，原來那些因為哈希碰撞，存放成鏈表和紅黑樹的元素，都需要進行拆分存放到新的位置中。</li></ol><h1 class=pgc-h-arrow-right>1.4 鏈表樹化</h1><p>HashMap這種散列表的數據結構，最大的性能在於可以O(1)時間複雜度定位到元素，但因為哈希碰撞不得已在一個下標裡存放多組數據，那麼jdk1.8之前的設計只是採用鏈表的方式進行存放，如果需要從鏈表中定位到數據時間複雜度就是O(n)，鏈表越長性能越差。因為在jdk1.8中把過長的鏈表也就是8個，優化為自平衡的紅黑樹結構，以此讓定位元素的時間複雜度優化近似於O(logn)，這樣來提升元素查找的效率。但也不是完全拋棄鏈表，因為在元素相對不多的情況下，鏈表的插入速度更快，所以綜合考慮下設定閾值為8才進行紅黑樹轉換操作。</p><p>鏈表轉紅黑樹，如下圖</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/05ce6b342fd44ef1bf1741cac2a5cabc><p class=pgc-img-caption></p></div><p>以上就是一組鏈表轉換為紅黑樹的情況，元素包括；40、51、62、73、84、95、150、161 這些是經過實際驗證可分配到Idx：12的節點</p><p>通過這張圖，基本可以有一個鏈表換行到紅黑樹的印象，接下來閱讀下對應的源碼。</p><h1 class=pgc-h-arrow-right>鏈表樹化源碼</h1><pre><code>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    // 這塊就是我們上面提到的，不一定樹化還可能只是擴容。主要桶數組容量是否小於64 MIN_TREEIFY_CAPACITY     if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        // 又是單詞縮寫；hd = head (頭部)，tl = tile (結尾)        TreeNode&lt;K,V&gt; hd = null, tl = null;        do {            // 將普通節點轉換為樹節點，但此時還不是紅黑樹，也就是說還不一定平衡            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);            if (tl == null)                hd = p;            else {                p.prev = tl;                tl.next = p;            }            tl = p;        } while ((e = e.next) != null);        if ((tab[index] = hd) != null)            // 轉紅黑樹操作，這裡需要循環比較，染色、旋轉。關於紅黑樹，在下一章節詳細講解            hd.treeify(tab);    }}</code></pre><p>這一部分鏈表樹化的操作並不複雜，複雜點在於下一層的紅黑樹轉換上，這部分知識點會在後續章節中專門介紹；</p><p>以上源碼主要包括的知識點如下；</p><ol start=1><li>鏈表樹化的條件有兩點；鏈表長度大於等於8、桶容量大於64，否則只是擴容，不會樹化。</li><li>鏈表樹化的過程中是先由鏈表轉換為樹節點，此時的樹可能不是一顆平衡樹。同時在樹轉換過程中會記錄鏈表的順序，tl.next = p，這主要方便後續樹轉鏈表和拆分更方便。</li><li>鏈表轉換成樹完成後，在進行紅黑樹的轉換。先簡單介紹下，紅黑樹的轉換需要染色和旋轉，以及比對大小。在比較元素的大小中，有一個比較有意思的方法，tieBreakOrder加時賽，這主要是因為HashMap沒有像<br>TreeMap那樣本身就有Comparator的實現。</li></ol><h1 class=pgc-h-arrow-right>1.5 紅黑樹轉鏈</h1><p>在鏈表轉紅黑樹中我們重點介紹了一句，在轉換樹的過程中，記錄了原有鏈表的順序。</p><p>那麼，這就簡單了，紅黑樹轉鏈表時候，直接把TreeNode轉換為Node即可，源碼如下；</p><pre><code>final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {    Node&lt;K,V&gt; hd = null, tl = null;    // 遍歷TreeNode    for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {        // TreeNode替換Node        Node&lt;K,V&gt; p = map.replacementNode(q, null);        if (tl == null)            hd = p;        else            tl.next = p;        tl = p;    }    return hd;}// 替換方法Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {    return new Node&lt;&gt;(p.hash, p.key, p.value, next);}</code></pre><p>因為記錄了鏈表關係，所以替換過程很容易。所以好的數據結構可以讓操作變得更加容易。</p><h1 class=pgc-h-arrow-right>2. 查找</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77468859da1d433fad2f9f813fc19f76><p class=pgc-img-caption></p></div><p>上圖就是HashMap查找的一個流程圖，還是比較簡單的，同時也是高效的。</p><p>接下來我們在結合代碼，來分析這段流程，如下；</p><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    // 同樣需要經過擾動函數計算哈希值    return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    // 判斷桶數組的是否為空和長度值    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        // 計算下標，哈希值與數組長度-1        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            // TreeNode 節點直接調用紅黑樹的查找方法，時間複雜度O(logn)            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            // 如果是鏈表就依次遍歷查找            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><p>以上查找的代碼還是比較簡單的，主要包括以下知識點；</p><ol start=1><li>擾動函數的使用，獲取新的哈希值，這在上一章節已經講過</li><li>下標的計算，同樣也介紹過 tab[(n - 1) & hash])</li><li>確定了桶數組下標位置，接下來就是對紅黑樹和鏈表進行查找和遍歷操作了</li></ol><h1 class=pgc-h-arrow-right>3. 刪除</h1><pre><code> public V remove(Object key) {     Node&lt;K,V&gt; e;     return (e = removeNode(hash(key), key, null, false, true)) == null ?         null : e.value; } final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                           boolean matchValue, boolean movable) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;    // 定位桶數組中的下標位置，index = (n - 1) &amp; hash    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (p = tab[index = (n - 1) &amp; hash]) != null) {        Node&lt;K,V&gt; node = null, e; K k; V v;        // 如果鍵的值與鏈表第一個節點相等，則將 node 指向該節點        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            node = p;        else if ((e = p.next) != null) {            // 樹節點，調用紅黑樹的查找方法，定位節點。            if (p instanceof TreeNode)                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);            else {                // 遍歷鏈表，找到待刪除節點                do {                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key ||                         (key != null &amp;&amp; key.equals(k)))) {                        node = e;                        break;                    }                    p = e;                } while ((e = e.next) != null);            }        }                // 刪除節點，以及紅黑樹需要修復，因為刪除後會破壞平衡性。鏈表的刪除更加簡單。        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                             (value != null &amp;&amp; value.equals(v)))) {            if (node instanceof TreeNode)                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);            else if (node == p)                tab[index] = node.next;            else                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            return node;        }    }    return null;} </code></pre><ul><li>刪除的操作也比較簡單，這裡面都沒有太多的複雜的邏輯。</li><li>另外紅黑樹的操作因為被包裝了，只看使用上也是很容易。</li></ul><h1 class=pgc-h-arrow-right>4. 遍歷</h1><h1 class=pgc-h-arrow-right>4.1 問題點</h1><p>HashMap中的遍歷也是非常常用的API方法，包括；</p><p><strong>KeySet</strong></p><pre><code> for (String key : map.keySet()) {     System.out.print(key + " "); }</code></pre><p><strong>EntrySet</strong></p><pre><code> for (HashMap.Entry entry : map.entrySet()) {     System.out.print(entry + " "); }</code></pre><p>從方法上以及日常使用都知道，KeySet是遍歷是無序的，但每次使用不同方式遍歷包括keys.iterator()，它們遍歷的結果是固定的。</p><p>那麼從實現的角度來看，這些種遍歷都是從散列表中的鏈表和紅黑樹獲取集合值，那麼他們有一個什麼固定的規律嗎？</p><h1 class=pgc-h-arrow-right>4.2 用代碼測試</h1><p>測試的場景和前提；</p><ol start=1><li>這裡我們要設定一個既有紅黑樹又有鏈表結構的數據場景</li><li>為了可以有這樣的數據結構，我們最好把HashMap的初始長度設定為64，避免在鏈表超過8位後擴容，而是直接讓其轉換為紅黑樹。</li><li>找到18個元素，分別放在不同節點(這些數據通過程序計算得來)；</li><li>桶數組02節點：24、46、68</li><li>桶數組07節點：29</li><li>桶數組12節點：150、172、194、271、293、370、392、491、590</li></ol><p><strong>代碼測試</strong></p><pre><code>@Testpublic void test_Iterator() {    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(64);    map.put("24", "Idx：2");    map.put("46", "Idx：2");    map.put("68", "Idx：2");    map.put("29", "Idx：7");    map.put("150", "Idx：12");    map.put("172", "Idx：12");    map.put("194", "Idx：12");    map.put("271", "Idx：12");    System.out.println("排序01：");    for (String key : map.keySet()) {        System.out.print(key + " ");    }        map.put("293", "Idx：12");    map.put("370", "Idx：12");    map.put("392", "Idx：12");    map.put("491", "Idx：12");    map.put("590", "Idx：12");    System.out.println("\n\n排序02：");    for (String key : map.keySet()) {        System.out.print(key + " ");    }            map.remove("293");    map.remove("370");    map.remove("392");    map.remove("491");    map.remove("590");    System.out.println("\n\n排序03：");    for (String key : map.keySet()) {        System.out.print(key + " ");    }    }</code></pre><p>這段代碼分別測試了三種場景，如下；</p><ol start=1><li>添加元素，在HashMap還是隻鏈表結構時，輸出測試結果01</li><li>添加元素，在HashMap轉換為紅黑樹時候，輸出測試結果02</li><li>刪除元素，在HashMap轉換為鏈表結構時，輸出測試結果03</li></ol><h1 class=pgc-h-arrow-right>4.3 測試結果分析</h1><pre><code>排序01：24 46 68 29 150 172 194 271 排序02：24 46 68 29 271 150 172 194 293 370 392 491 590 排序03：24 46 68 29 172 271 150 194 Process finished with exit code 0</code></pre><p>從map.keySet()測試結果可以看到，如下信息；</p><ol start=1><li>01情況下，排序定位哈希值下標和鏈表信息</li></ol><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aebd1a829eaa4d89bb9b7fce10ee837f><p class=pgc-img-caption></p></div><ol start=2><li>02情況下，因為鏈表轉換為紅黑樹，樹根會移動到數組頭部。moveRootToFront()方法</li></ol><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fbe618a6ab7a416da3ead1ead596bded><p class=pgc-img-caption></p></div><ol start=3><li>03情況下，因為刪除了部分元素，紅黑樹退化成鏈表。</li></ol><h1 class=pgc-h-arrow-right>五、紅黑樹前身，2-3樹分析</h1><p>日常的學習和一部分夥伴的面試中，竟然會聽到的是；從HashMap中文紅黑樹、從數據庫索引為B+Tree，但問2-3樹的情況就不是很多了。</p><h1 class=pgc-h-arrow-right>1. 為什麼使用樹結構</h1><p>從最根本的原因來看，使用樹結構就是為了提升整體的效率；插入、刪除、查找(索引)，尤其是索引操作。因為相比於鏈表，一個平衡樹的索引時間複雜度是O(logn)，而數組的索引時間複雜度是O(n)。</p><p>從以下的圖上可以對比，兩者的索引耗時情況；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/990c82c5f17d46a89e908f0f0db57a59><p class=pgc-img-caption></p></div><ul><li>從上圖可以看到，使用樹結構有效的降低時間複雜度，提升數據索引效率。</li><li>另外這個標準的樹結構，是二叉搜索樹(Binary Search Tree)。除此之外樹形結構還有；AVL樹、紅黑樹、2-3樹等</li></ul><h1 class=pgc-h-arrow-right>2. 二叉搜索樹退化鏈表</h1><p>在樹的數據結構中，最先有點是二叉查找樹，也就是英文縮寫BST樹。在使用數據插入的過程中，理想情況下它是一個平衡的二叉樹，但實際上可能會出現二叉樹都一邊倒，讓二叉樹像列表一樣的數據結構。從而樹形結構的時間複雜度也從O(logn)升級到O(n)，如下圖；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/16417966a83c4cc7ad3adeb08a8ffa0c><p class=pgc-img-caption></p></div><ul><li>二叉搜索樹的數據插入過程是，插入節點與當前樹節點做比對，小於在左，大於在右。</li><li>隨著數據的插入順序不同，就會出現完全不同的數據結構。可能是一棵平衡二叉樹，也極有可能退化成鏈表的樹。</li><li>當樹結構退化成鏈表以後，整個樹索引的性能也跟著退化成鏈表。</li></ul><p>綜上呢，如果我們希望在插入數據後又保持樹的特點，O(logn)的索引性能，那麼就需要在插入時進行節點的調整</p><h1 class=pgc-h-arrow-right>3. 2-3樹解決平衡問題</h1><p>2-3樹是什麼結構，它怎麼解決平衡問題的。帶著問題我們繼續。</p><p>2-3樹是一種非常巧妙的結構，在保持樹結構的基礎上，它允許在一個節點中可以有兩個元素，等元素數量等於3個時候再進行調整。通過這種方式呢，來保證整個二叉搜索樹的平衡性。</p><p>這樣說可能還沒有感覺，來看下圖；</p><p><br></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5bb44bbde8cb488b944ed7076e9d68d7><p class=pgc-img-caption></p></div><ul><li>左側是二叉搜索樹，右側是2-3平衡樹，分別插入節點4、5，觀察樹形結構變化。</li><li>二叉搜索樹開始出現偏移，節點一遍倒。</li><li>2-3樹通過一個節點中存放2到3個元素，來調整樹形結構，保持平衡。所謂的保持平衡就是從根節點，到每一個最底部的自己點，鏈路長度一致。</li></ul><p>2-3樹已經可以解決平衡問題那麼，數據是怎麼存放和調整的呢，接下來我們開始實踐使用。</p><h1 class=pgc-h-arrow-right>六、紅黑樹前身，2-3樹使用</h1><h1 class=pgc-h-arrow-right>1. 樹結構定義和特點性質</h1><h1 class=pgc-h-arrow-right>2-3樹，讀法；二三樹，特性如下；</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ac5b992b653a44498f20542f14962860><p class=pgc-img-caption></p></div><p>綜上我們可以總結出，2-3樹的一些性質；</p><ol start=1><li>2-3樹所有子葉節點都在同一層</li><li>1個節點可以有1到2個數據，如果有三個需要調整樹結構</li><li>1個節點1個數據時，則有兩個子節點</li><li>1個節點2個數據時，則有三個子節點，且中間子節點是介於兩個節點間的值</li></ol><h1 class=pgc-h-arrow-right>2. 數據插入</h1><p>接下來我們就模擬在二叉搜索樹中退化成鏈表的數據，插入到2-3樹的變化過程，數據包括；1、2、3、4、5、6、7，插入過程圖如下；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/95641c1bb9904185bbdedfa6063f1878><p class=pgc-img-caption></p></div><p>以上，就是整個數據在插入過程中，2-3樹的演化過程，接下來我們具體講解每一步的變化；</p><ul><li>α，向節點1插入數據2，此時為了保持平衡，不會新產生分支，只會在一個節點中存放兩個節點。</li><li>β，繼續插入數據3，此時這個節點有三數據，1、2、3，是一個臨時區域。</li><li>γ，把三個數據的節點，中間節點拉起來，調整成樹形結構。</li><li>δ，繼續插入數據4，為了保持樹平衡，會插在節點3的右側。</li><li>ε，繼續插入數據5，插入後3、4、5共用1個節點，當一個節點上有三個數據時候，則需要進行調整。</li><li>ζ，中間節點4向上⏫調整，調整後，1節點在左、3節點在中間、5節點在右。</li><li>η ，繼續插入數據6，在保持樹平衡的情況下，與節點5公用。</li><li>θ ，繼續插入數據7，插入後，節點7會與當前的節點 5 6 共用。此時是一個臨時存放，需要調整。初步調整後，抽出6節點，向上存放，變為2 4 6共用一個節點，這是一個臨時狀態，還需要繼續調整。</li><li>ι，因為根節點有三個數據2、4、6，則繼續需要把中間節點上移，1、3和5、7 則分別成二叉落到節點2、節點6上。</li></ul><p>希臘字母：α(阿爾法)、 β(貝塔)、γ(伽馬)、δ(德爾塔)、ε(伊普西隆)、ζ(截塔)、η(艾塔)、θ(西塔)、ι(約塔)</p><h1 class=pgc-h-arrow-right>3. 數據刪除</h1><p>有了上面數據插入的學習，在看數據刪除其實就是一個逆向的過程，在刪除的主要包括這樣兩種情況；</p><ol start=1><li>刪除了3-節點，也就是包含兩個數據元素的節點，直接刪除即可，不會破壞樹平衡。</li><li>刪除了2-節點，此時會破壞樹平衡，需要將樹高縮短或者元素合併，恢復樹平衡。</li></ol><p>承接上面的例子，我們把數據再從7、6、5、4、3、2、1順序刪除，觀察2-3樹的結構變化，如下；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d73e878741af40b7a8db727647f26239><p class=pgc-img-caption></p></div><ul><li>α，刪除節點7，因為節點7只有一個數據元素，刪除節點5、6合併，但此時破壞了2-3樹的平衡性，需要縮短樹高進行調整。</li><li>β，因為刪除節點後，整個樹結構不平衡，所以需要縮短樹高，調整元素。節點2、4合併，節點1、3分別插入左側和中間。</li><li>γ，刪除節點6，這個節點是3-節點(可以分出3個叉的意思)，刪除後不會破壞樹平衡，保持不變。</li><li>δ，刪除節點5，此時會破壞樹平衡，需要把跟節點4下放，與3合併。</li><li>ε，刪除節點4，這個節點依舊是3-節點，所以不需要改變樹結構。</li><li>ζ，刪除節點3，此時只有1、2節點，需要合併。</li><li>η ，刪除節點2，此時節點依舊是3-節點，所以不需要改變樹結構。</li></ul><p>再看一個稍微複雜點2-3樹刪除：<br></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1fe2a9ea1e2043f38d4c0c450ae0f620><p class=pgc-img-caption></p></div><p>上面這張圖，就一個稍微複雜點的2-3平衡樹，樹的刪除過程主要包括；</p><ol start=1><li>刪除4，其實需要將節點3、5合併，指向節點2，保持樹平衡。</li><li>刪除7，節點8、9合併。</li><li>刪除14，節點15上移，恢復成3-叉樹。</li></ol><p>如果有時候不好理解刪除，可以試想下，這個要刪除的節點，在插入的時候是一個什麼效果。</p><h1 class=pgc-h-arrow-right>4. 數據索引</h1><p>相比於插入和刪除，索引的過程還是比較簡單的，不需要調整數據結果。基本原則就是；</p><ol start=1><li>小於當前節點值，左側尋找</li><li>大於當前節點值，右側尋找</li><li>一直到找到索引值，停止。</li></ol><p><strong>第一層尋找：</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3e7d076cf1034400b696c8ea99abaab9><p class=pgc-img-caption></p></div><p><strong>第二層尋找：</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d71bfe23f6684c009af40e7c009d5faf><p class=pgc-img-caption></p></div><p><strong>第三次尋找：</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04f8a0733e214cca9bb337ec39a220fe><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>七、紅黑樹解析</h1><p>紅黑樹，是一種高效的自平衡二叉查找樹</p><p>Rudolf Bayer 於1978年發明紅黑樹，在當時被稱為對稱二叉 B 樹(symmetric binary B-trees)。後來，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改為如今的紅黑樹。</p><p>紅黑樹具有良好的效率，它可在近似O(logN) 時間複雜度下完成插入、刪除、查找等操作，因此紅黑樹在業界也被廣泛應用，比如 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基於紅黑樹結構實現的。</p><p>死記硬背，很難學會</p><p>紅黑樹的結構和設計都非常優秀，也同樣在實現上有著複雜的處理邏輯，包括插入或者刪除節點時；顏色變化、旋轉操作等操作。但如果只把這些知識點硬背下來，什麼時候染色、什麼時候旋轉，是沒有多大意義的，用不了多久也就忘記了。<strong>所以這部分的學習，瞭解其根本更重要。</strong></p><h1 class=pgc-h-arrow-right>1、2-3樹與紅黑樹的等價性</h1><p><strong>紅黑樹規則</strong></p><pre><code>1. 根節點是黑色2. 節點是紅黑或者黑色3. 所有子葉節點都是黑色(葉子是NIL節點，默認沒有畫出來)4. 每個紅色節點必須有兩個黑色子節點(也同樣說明一條鏈路上不能有鏈路的紅色節點)5. 黑高，從任一節點到齊每個葉子節點，經過的路徑都包含相同數目的黑色節點</code></pre><p>那麼，這些規則是怎麼總結定義出來的呢？接下里我們一步步分析講解。</p><h1 class=pgc-h-arrow-right>1. 為什麼既有2-3樹要有紅黑樹</h1><p>首先2-3樹(<em>讀法：二三樹</em>)就是一個節點有1個或者2個元素，而實際上2-3樹轉紅黑樹是由概念模型2-3-4樹轉換而來的。-4叉就是一個節點裡有3個元素，這在2-3樹中會被調整，但是在概念模型中是會被保留的。</p><p>雖然2-3-4樹也是具備2-3樹同樣的平衡樹的特性，但是如果直接把這樣的模型用代碼實現就會很麻煩，且效率不高，這裡的複雜點包括；</p><ol start=1><li>2-叉、3-叉、4-叉，三種結構的節點類型，互相轉換複雜度較高</li><li>3-叉、4-叉，節點在數據比較上需要進行多次，不像2-叉節點，直接布爾類型比較即可<em>非左即右</em></li><li>代碼實現上對每種差異，都需要有額外的代碼，規則不夠標準化</li></ol><p><strong>所以</strong>，希望找到一種平衡關係，既保持2-3樹平衡和O(logn)的特性，又能在代碼實現上更加方便，那麼就誕生了紅黑樹。</p><h1 class=pgc-h-arrow-right>2. 簡單2-3樹轉紅黑樹</h1><p>2-3樹轉紅黑樹，也可以說紅黑樹是2-3樹和2-3-4樹的另外一種表現形式，也就是更利於編碼實現的形式。</p><p><strong>簡單轉換示例；</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4076ba5bd0c04710b55c3f33dca7816c><p class=pgc-img-caption></p></div><p>從上圖可以看出，2-3-4樹與紅黑樹的轉換關係，包括；</p><ol start=1><li>2-叉節點，轉換比較簡單，只是把原有節點轉換為黑色節點</li><li>3-叉節點，包括了2個元素，先用紅色線把兩個節點相連，之後拆分出來，最後調整高度黑色節點在上</li><li>4-叉節點，包括了3個元素，分別用紅黑線連接，之後拆分出來拉昇高度。這個拉昇過程和2-3樹調整一致，只是添加了顏色</li></ol><p>綜上，就是2-3-4樹的節點轉換，總結出來的規則，如下；</p><ol start=1><li>將2-3-4樹，用二叉樹的形式表示</li><li>3-叉、4-叉節點，使用紅色、黑色連線進行連接</li><li>另外，3-叉節點有兩種情況，導致轉換成二叉樹，就有左傾和右傾</li></ol><h1 class=pgc-h-arrow-right>3. 複雜2-3樹轉紅黑樹</h1><p>在簡單2-3樹轉換紅黑樹的過程中，瞭解到一個基本的轉換規則右旋定義，接下來我們在一個稍微複雜一點的2-3樹與紅黑樹的對應關係，如下圖；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/695fa1c63b524666ac1a6956ad17e86a><p class=pgc-img-caption></p></div><p>上圖是一個稍微複雜點的2-3樹，轉換為紅黑樹的過程，是不這樣一張圖讓你對紅黑樹更有感覺了，同時它也滿足一下條件；</p><ol start=1><li>從任意節點到葉子節點，所經過的黑色節點數目相同</li><li>黑色節點保持著整體的平衡性，也就是讓整個紅黑樹接近於O(logn)時間複雜度</li><li>其他紅黑樹的特點也都滿足，可以對照紅黑樹的特性進行比對</li></ol><h1 class=pgc-h-arrow-right>2、紅黑樹操作</h1><p><strong>2.1 平衡操作</strong></p><p>通過在上一章節2-3樹的學習，在插入節點時並不會插到空位置，而是與現有節點融合以及調整，保持整個樹的平衡。</p><p>而紅黑樹是2-3-4樹的一種概念模型轉換而來，在插入節點時通過紅色鏈接相連，也就是插入紅色節點。插入完成後進行調整，以保持樹接近平衡。</p><p>那麼，為了讓紅黑樹達到平衡狀態，主要包括染色、↔左右旋轉、這些做法其實都是從2-3樹演化過來的。接下來我們就分別講解幾種規則的演化過程，以此更好了解紅黑樹的平衡操作。</p><p><strong>2.1.1 左旋轉</strong></p><p>左旋定義： 把一個向右傾斜的紅節點鏈接(2-3樹，3-叉雙元素節點)，轉化為左鏈接。</p><p><br></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/713f40c946d14d39bd5010b7f3c87521><p class=pgc-img-caption></p></div><p>背景：順序插入元素，1、2、3，2-3樹保持平衡，紅黑樹暫時處於右傾斜。</p><p>接下來我們分別對比兩種樹結構的平衡操作；</p><ul><li>2-3樹，所有插入的節點都會保持在一個節點上，之後通過調整節點位置，保持平衡。</li><li>紅黑樹，則需要通過節點的左側旋轉，將元素2拉起來，元素1和元素3，分別成為左右子節點。</li></ul><p>紅黑樹的左旋，只會處理與之對應的2-3樹節點進行操作，不會整體改變。</p><p><strong>2.1.2 右旋轉</strong></p><p>右旋定義： 把一個向左傾斜的紅節點連接(2-3樹，3-叉雙元素節點)，轉換為右連接。</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dd688596d32f4c5a9080b2afaf4e971f><p class=pgc-img-caption></p></div><p>背景：順序插入元素，3、1、1，2-3樹保持平衡，紅黑樹暫時處於左傾斜。</p><p>接下來我們分別對比兩種樹結構的平衡操作；</p><p>2-3樹，所有插入的節點都會保持在一個節點上，之後通過調整節點位置，保持平衡。<br>紅黑樹，則需要通過節點的右側旋轉，將元素2拉起來，元素1和元素3，分別成為左右子節點。</p><p>你會發現，左旋與右旋是相互對應的，但在2-3樹中是保持不變的</p><p><strong>2.1.3 左右旋綜合運用</strong></p><p>左旋、右旋，我們已經有了一個基本的概念，那麼接下來我們再看一個可以綜合左右旋以及對應2-3樹的演化案例，如下；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7744e31a275a4b3e978c397ed79fc182><p class=pgc-img-caption></p></div><p>以上的例子分別演示了一個元素插入的三種情況，如下；</p><ol start=1><li>1、3，插入0，左側底部插入，與2-3樹相比，需要右旋保持平衡</li><li>1、3，插入2，中間位置插入，首先進行左旋調整元素位置，之後進行右旋進行樹平衡</li><li>1、3，插入5，右側位置插入，此時正好保持樹平衡，不需要調整</li></ol><p><strong>2.1.4 染色</strong></p><p>在2-3樹中，插入一個節點，為了保持樹平衡是不插入到空位置上的，當插入節點後元素數量有3個後則需要調整中間元素向上，來保持樹平衡。與之對應的紅黑樹則需要調整顏色，來保證紅黑樹的平衡規則，具體參考如下；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/adac807aa12a426eb75964a662bdb0fe><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2.2 旋轉+染色運用案例</h1><p>接下來我們把上面講解到的旋轉、染色，運用到一個實際案例中，如下圖；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c7ea9fbd10d42058e07bdcd68f2263c><p class=pgc-img-caption></p></div><ul><li>首先從左側開始，是一個按照順序插入生產出來的紅黑樹，插入順序；`7、2、8、1、4、3、5</li><li>α，向目前紅黑樹插入元素6，插入後右下角有三個紅色節點；3、5、6。</li><li>β，因為右下角滿足染色條件，變換後；黑色節點(3、5)、紅色節點(4、6)。</li><li>γ，之後看被紅色連線鏈接的節點7、4、2，最小節點在中間，左旋平衡樹結構。</li><li>δ，左旋完成後，紅色鏈接線的7、4、2為做傾順序節點，因此需要做右旋操作。</li><li>ε，左旋、右旋，調整完成後，又滿足了染色操作。到此恢復紅黑樹平衡。</li></ul><p>注意，所有連接紅色節點的，都是是紅色線。以此與2-3樹做對應。</p><p><strong>2.3. 刪除操作</strong></p><p>根據2-3-4樹模型的紅黑樹，在刪除的時候基本是按照2-3方式進行刪除，只不過在這個過程中需要染色和旋轉操作，以保持樹平衡。刪除過程主要可以分為如圖四種情況，如下；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bbed07dd560a45abb2b1546f091b0b7c><p class=pgc-img-caption></p></div><p><strong>2.3.1 刪除子葉紅色節點</strong></p><p>紅色子葉節點的刪除並不會破壞樹平衡，也不影響樹高，所以直接刪除即可，如下；</p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7eb3d6e0d9d74cd89878cc67cc1a8b5c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2.3.2 刪除左側節點</h1><p><strong>2.3.2.1 被刪節點兄弟為黑色&含右子節點</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2ed0a2c9e3e94a058c1de29ddcc018c8><p class=pgc-img-caption></p></div><p><br></p><p><strong>2.3.2.2 被刪節點兄弟為黑色&含左子節點</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7c88e1b220c4488299fe2bb334102a6b><p class=pgc-img-caption></p></div><p><strong>2.3.2.3 被刪節點兄弟為黑色&含雙子節點(紅)</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ba764093f01c442aa928b50fbcafa5a6><p class=pgc-img-caption></p></div><p><br></p><p><strong>2.3.2.4 被刪節點兄弟為黑色&不含子節點</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/76df4098ab19427a930ecd620a420d0f><p class=pgc-img-caption></p></div><p><br></p><p><strong>2.3.2.5 被刪節點兄弟為黑色&含雙黑節點(黑)</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8be8993f246e46f8a327dda096feebc7><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>2.3.3 刪除右側節點</h1><p><strong>2.3.3.1 被刪節點兄弟為黑色&含左子節點</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b5cd980aaa5c4a50ab5a49d5faca4b17><p class=pgc-img-caption></p></div><p><br></p><p><strong>2.3.3.2 被刪節點兄弟為黑色&含右子節點</strong></p><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bbadb568ef844437a3b85c2633e33bc0><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>2.3.3.3 被刪節點兄弟為黑色&含雙子節點(紅)</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/427d65610fc84ea185f5b813edea4b7c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2.3.2.4 被刪節點兄弟為黑色&不含子節點</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/69d6c9b65cd046f8b46581edfa128c44><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2.3.2.5 被刪節點兄弟為黑色&含雙黑節點(黑)</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/432440994c734a2ab3c0ed7b5bf2ec58><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>八、總結</h1><ul><li>HashMap的數據結構設計的非常優秀，同時也非常複雜，涉及的知識點眾多。作為高級開發的程序員雖然平時開發不需要實現這樣的功能，但是這裡的設計思想非常值得學習。</li><li>這裡的知識點基本包括了；Hash值的設計，HashMap中，1、散列表實現、2、擾動函數、3、初始化容量、4、負載因子、5、擴容元素拆分得算法的制定以及2-3-4樹到紅黑樹的轉換，都非常值得深入學習。</li><li>面試只是一份新工作的開發，就像比武招親一樣，你總要拿出自己最優秀的實力，如果當前能力還不足，那麼就可以繼續深入學習。</li></ul><h1 class=pgc-h-arrow-right>覺得文章不錯的，大家記得點點關注，後面會更新更多精彩文章內容以及最新面試寶典乾貨。</h1><div class=pgc-img><img alt=面試28k職位，面試官從HashCode到哈希給我上了一課 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb387e45220c4f9d9fab603c19f3fb72><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>28k</a></li><li><a>職位</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html alt="不怕面試被問了！二叉樹算法大盤點 | 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html title="不怕面試被問了！二叉樹算法大盤點 | 原力計劃">不怕面試被問了！二叉樹算法大盤點 | 原力計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html title="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~">別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html title=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a819fbd.html alt=面試三連二叉樹，原來二叉樹還可以講的這麼簡單，不看看嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afef1f6cac3540d785def8bbf641f8d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a819fbd.html title=面試三連二叉樹，原來二叉樹還可以講的這麼簡單，不看看嗎？>面試三連二叉樹，原來二叉樹還可以講的這麼簡單，不看看嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>