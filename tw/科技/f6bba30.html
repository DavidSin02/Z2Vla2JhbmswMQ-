<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>八、適配器模式與橋接模式詳解 | 极客快訊</title><meta property="og:title" content="八、適配器模式與橋接模式詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d055f9ada84b4227bc9c9f892143df3f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><meta property="article:published_time" content="2020-10-29T20:53:45+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:45+08:00"><meta name=Keywords content><meta name=description content="八、適配器模式與橋接模式詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f6bba30.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>八、適配器模式與橋接模式詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>11.適配器模式</p><h3 class="md-end-block md-heading">11.1.定義</h3><p><strong>適配器模式</strong>是一種結構型設計模式， 它能使接口不兼容的對象能夠相互合作。</p><p>適配器模式的英文翻譯是 <strong>Adapter Design Pattern</strong>。顧名思義，這個模式就是用來做適配的，它將不兼容的接口轉換為可兼容的接口，讓原本由於接口不兼容而不能一起工作的類可以一起工作。</p><p><strong>示意圖</strong></p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d055f9ada84b4227bc9c9f892143df3f><p class=pgc-img-caption></p></div><p><strong>生活場景：</strong>電源插轉換頭、手機充電轉換頭、顯示器轉接頭。</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d2dd6539ec843cc916f12a14446d9ff><p class=pgc-img-caption></p></div><p>你可以創建一個<strong>適配器</strong>。 這是一個特殊的對象， 能夠<strong>轉換對象接口</strong>， 使其能<strong>與其他對象進行交互</strong>。</p><p>適配器模式通過封裝對象<strong>將複雜的轉換過程藏於幕後</strong>。 被封裝的對象甚至察覺不到適配器的存在。</p><p>適配器不僅可以轉換不同格式的數據， 其還有助於採用不同接口的對象之間的合作。 它的運作方式如下：</p><ol start=0><li>適配器實現與其中一個現有對象兼容的接口。</li><li>現有對象可以使用該接口安全地調用適配器方法。</li><li>適配器方法被調用後將以另一個對象兼容的格式和順序將請求傳遞給該對象。</li></ol><p>有時你甚至可以創建一個雙向適配器來實現雙向轉換調用。</p><h3 class="md-end-block md-heading">11.2.應用場景</h3><ol start=0><li>封裝有缺陷的接口設計</li><li>統一多個類的接口設計</li><li>替換依賴的外部系統</li><li>兼容老版本接口</li><li>適配不同格式的數據</li></ol><h3 class="md-end-block md-heading">11.3.適配器角色</h3><p>Adaptee 是一組不兼容 ITarget 接口定義的接口。</p><p>ITarget 表示要轉化成的接口定義。</p><p>Adapter/Adaptor 將 Adaptee 轉化成一組符合 ITarget 接口定義的接口。</p><p>適配器有3中形式：類適配器、對象適配器、接口適配器</p><h3 class="md-end-block md-heading">11.4.類適配器</h3><p>類適配器: 基於繼承。</p><p>做法：讓Adaptor實現ITarget接口，並且繼承Adaptee，這樣Adaptor就具備ITarget和Adaptee的特性，就可以將兩者進行轉化。</p><p>UML類圖：</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5ff8fdba5fc6449da83b4fa0595e8512><p class=pgc-img-caption></p></div><pre><code> // 類適配器: 基於繼承 ​ // ITarget 表示要轉化成的接口定義 public interface ITarget {   void f1();   void f2();   void fc(); } ​ // Adaptee 是一組不兼容 ITarget 接口定義的接口 public class Adaptee {   public void fa() { //... }   public void fb() { //... }   public void fc() { //... } } ​ // Adaptor 將 Adaptee 轉化成一組符合 ITarget 接口定義的接口       public class Adaptor extends Adaptee implements ITarget {   public void f1() {     super.fa();   }      public void f2() {     //...重新實現f2()...   }      // 這裡fc()不需要實現，直接繼承自Adaptee，這是跟對象適配器最大的不同點 }</code></pre><h3 class="md-end-block md-heading">11.5.對象適配器</h3><p>對象適配器：基於組合。</p><p>做法：讓Adaptor 實現ITarget 接口，然後內部持有Adaptee實例，然後在ITarget接口規定的方法內轉換Adaptee。</p><p>URL類圖：</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92485d340cd440d5bfecd87140f4169c><p class=pgc-img-caption></p></div><pre><code> // 對象適配器：基於組合 ​ // ITarget 表示要轉化成的接口定義 public interface ITarget {   void f1();   void f2();   void fc(); } ​ // Adaptee 是一組不兼容 ITarget 接口定義的接口 public class Adaptee {   public void fa() { //... }   public void fb() { //... }   public void fc() { //... } } ​ // Adaptor 將 Adaptee 轉化成一組符合 ITarget 接口定義的接口             public class Adaptor implements ITarget {   private Adaptee adaptee;      public Adaptor(Adaptee adaptee) {     this.adaptee = adaptee;   }      public void f1() {     adaptee.fa(); //委託給Adaptee   }      public void f2() {     //...重新實現f2()...   }      public void fc() {     adaptee.fc();   } }</code></pre><h3 class="md-end-block md-heading">11.5.接口適配器</h3><p>使用接口適配器讓我們只實現我們所需要的接口方法</p><pre><code> public class CD { //這個類來自外部sdk，我們無權修改它的代碼   //...   public static void staticFunction1() { //... }      public void uglyNamingFunction2() { //... } ​   public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }      public void lowPerformanceFunction4() { //... } } ​ // 使用適配器模式進行重構 public class ITarget {   void function1();   void function2();   void fucntion3(ParamsWrapperDefinition paramsWrapper);   void function4();   //... } // 注意：適配器類的命名不一定非得末尾帶Adaptor public class CDAdaptor extends CD implements ITarget {   //...   public void function1() {      super.staticFunction1();   }      public void function2() {     super.uglyNamingFucntion2();   }      public void function3(ParamsWrapperDefinition paramsWrapper) {      super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);   }      public void function4() {     //...reimplement it...   } }</code></pre><h3 class="md-end-block md-heading">11.6.實戰</h3><p>重構第三方登錄自由適配場景</p><p>首先創建統一登陸結果ResultMsg類：</p><pre><code> @Data public class ResultMsg { ​     private int code;     private String msg;     private Object data; ​     public ResultMsg(int code, String msg, Object data) {         this.code = code;         this.msg = msg;         this.data = data;     } }</code></pre><p>假設老系統的的登錄邏輯PasswordService：</p><pre><code> public class PassportService { ​     /**      * 註冊方法      * @param username      * @param password      * @return      */     public ResultMsg regist(String username,String password){         return  new ResultMsg(200,"註冊成功",new Member());     } ​     /**      * 登錄的方法      * @param username      * @param password      * @return      */     public ResultMsg login(String username,String password){         return null;     } }</code></pre><p>遵循開閉原則，老代碼我們不修改。開啟代碼重構之路，創建Member類：</p><pre><code> @Data public class Member { ​     private String username;     private String password;     private String mid;     private String info; }</code></pre><p>運行穩定的代碼不改動。創建ITarget角色IPassportForThird接口。</p><pre><code> public interface IPassportForThird { ​     ResultMsg loginForQQ(String openId); ​     ResultMsg loginForWechat(String openId); ​     ResultMsg loginForToken(String token); ​     ResultMsg loginForTelphone(String phone, String code); }</code></pre><p>創建適配器兼容Adaptor角色PassportForThirdAdapter類</p><pre><code> public class PassportForThirdAdapter implements IPassportForThird { ​     public ResultMsg loginForQQ(String openId) {         return processLogin(openId, LoginForQQAdapter.class);     } ​     public ResultMsg loginForWechat(String openId) {         return processLogin(openId, LoginForWechatAdapter.class);     } ​     public ResultMsg loginForToken(String token) {         return processLogin(token, LoginForTokenAdapter.class);     } ​     public ResultMsg loginForTelphone(String phone, String code) {         return processLogin(phone, LoginForTelAdapter.class);     } ​     private ResultMsg processLogin(String id,Class&lt;? extends ILoginAdapter&gt; clazz){         try {             ILoginAdapter adapter = clazz.newInstance();             if (adapter.support(adapter)){                 return adapter.login(id,adapter);             }         } catch (Exception e) {             e.printStackTrace();         }         return null;     } }</code></pre><p>根據不同登錄方式，創建不同登錄Adaptor。首先，創建LoginAdapter接口：</p><pre><code>public interface ILoginAdapter {    boolean support(Object object);    ResultMsg login(String id,Object adapter);}</code></pre><p>創建一個抽象類AbstraceAdapter繼承PassportService原有功能，同時實現ILoginAdapter接口，然後分別實現不同的登錄適配。</p><p>QQ登錄</p><pre><code>public class LoginForQQAdapter extends AbstraceAdapter{    public boolean support(Object adapter) {        return adapter instanceof LoginForQQAdapter;    }    public ResultMsg login(String id, Object adapter) {        if(!support(adapter)){return null;}        //accesseToken        //time        return super.loginForRegist(id,null);    }}</code></pre><p>微信登錄</p><pre><code>public class LoginForWechatAdapter extends AbstraceAdapter{    public boolean support(Object adapter) {        return adapter instanceof LoginForWechatAdapter;    }    public ResultMsg login(String id, Object adapter) {        return super.loginForRegist(id,null);    }}</code></pre><p>手機登錄</p><pre><code>public class LoginForTelAdapter extends AbstraceAdapter{    public boolean support(Object adapter) {        return adapter instanceof LoginForTelAdapter;    }    public ResultMsg login(String id, Object adapter) {        return super.loginForRegist(id,null);    }}</code></pre><p>Token登錄</p><pre><code>public class LoginForTokenAdapter extends AbstraceAdapter {    public boolean support(Object adapter) {        return adapter instanceof LoginForTokenAdapter;    }    public ResultMsg login(String id, Object adapter) {        return super.loginForRegist(id,null);    }}</code></pre><p>創建適配器PassportForThirdAdapter類，實現目標接口IPassportForThird兼容。</p><pre><code>public class PassportForThirdAdapter implements IPassportForThird {    public ResultMsg loginForQQ(String openId) {        return processLogin(openId, LoginForQQAdapter.class);    }    public ResultMsg loginForWechat(String openId) {        return processLogin(openId, LoginForWechatAdapter.class);    }    public ResultMsg loginForToken(String token) {        return processLogin(token, LoginForTokenAdapter.class);    }    public ResultMsg loginForTelphone(String phone, String code) {        return processLogin(phone, LoginForTelAdapter.class);    }    private ResultMsg processLogin(String id,Class&lt;? extends ILoginAdapter&gt; clazz){        try {            ILoginAdapter adapter = clazz.newInstance();            if (adapter.support(adapter)){                return adapter.login(id,adapter);            }        } catch (Exception e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>客戶端測試代碼</p><pre><code>public class Test {    public static void main(String[] args) {        IPassportForThird adapter = new PassportForThirdAdapter();        adapter.loginForQQ("sdfasdfasfasfas");    }}</code></pre><p>類圖</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/159ef15e18c94b68badfa664f99f1035><p class=pgc-img-caption></p></div><p>我們為每一個適配器加上了support()方法，用來判斷是否兼容，參數是Object，來源於接口。ILoginAdapter接口是為了代碼規範。上面的代碼綜合了策略模式、簡單工廠和適配器模式。</p><h3 class="md-end-block md-heading">11.7.源碼</h3><p>Spring AOP中的AdvisorAdapter。有三個實現類MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter。</p><p>頂層接口AdvisorAdapter類</p><pre><code>public interface AdvisorAdapter {    boolean supportsAdvice(Advice var1);    MethodInterceptor getInterceptor(Advisor var1);}</code></pre><p>MethodBeforeAdviceAdapter實現。其餘兩個不貼了。</p><pre><code>class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {    AfterReturningAdviceAdapter() {    }    public boolean supportsAdvice(Advice advice) {        return advice instanceof AfterReturningAdvice;    }    public MethodInterceptor getInterceptor(Advisor advisor) {        AfterReturningAdvice advice = (AfterReturningAdvice)advisor.getAdvice();        return new AfterReturningAdviceInterceptor(advice);    }}</code></pre><p>Spring 根據不同的AOP配置確定使用相應的Advice。</p><p>下面看SpringMVC的HandlerAdapter類，它也有多個子類。</p><p>類圖：</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/860311ff5b5c4d4b8e5df465d66e4b6c><p class=pgc-img-caption></p></div><p><br></p><p>他的適配關鍵代碼在DispatcherServlet的doDispatch()方法中，我們看源碼：</p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    boolean multipartRequestParsed = false;    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);    try {        try {            ModelAndView mv = null;            Object dispatchException = null;            try {                processedRequest = this.checkMultipart(request);                multipartRequestParsed = processedRequest != request;                mappedHandler = this.getHandler(processedRequest);                if (mappedHandler == null) {                    this.noHandlerFound(processedRequest, response);                    return;                }                HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());                String method = request.getMethod();                boolean isGet = "GET".equals(method);                if (isGet || "HEAD".equals(method)) {                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                    if (this.logger.isDebugEnabled()) {                        this.logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified);                    }                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) {                        return;                    }                }                if (!mappedHandler.applyPreHandle(processedRequest, response)) {                    return;                }                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                if (asyncManager.isConcurrentHandlingStarted()) {                    return;                }                this.applyDefaultViewName(processedRequest, mv);                mappedHandler.applyPostHandle(processedRequest, response, mv);            } catch (Exception var20) {                dispatchException = var20;            } catch (Throwable var21) {                dispatchException = new NestedServletException("Handler dispatch failed", var21);            }            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);        } catch (Exception var22) {            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);        } catch (Throwable var23) {            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));        }    } finally {        if (asyncManager.isConcurrentHandlingStarted()) {            if (mappedHandler != null) {                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);            }        } else if (multipartRequestParsed) {            this.cleanupMultipart(processedRequest);        }    }}</code></pre><p>doDispatch方法調用了getHandlerAdaper方法</p><pre><code>@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {    if (this.handlerMappings != null) {        Iterator var2 = this.handlerMappings.iterator();        while(var2.hasNext()) {            HandlerMapping hm = (HandlerMapping)var2.next();            if (this.logger.isTraceEnabled()) {                this.logger.trace("Testing handler map [" + hm + "] in DispatcherServlet with name '" + this.getServletName() + "'");            }            HandlerExecutionChain handler = hm.getHandler(request);            if (handler != null) {                return handler;            }        }    }    return null;}</code></pre><p>getHandlerAdapter方法循環調用supports方法判斷是否兼容，循環迭代集合中的Adapter是在初始化時早就賦了值的。只有源碼專題繼續講解。</p><h3 class="md-end-block md-heading">11.8.適配器與裝飾器的對比</h3><p>兩者都是包裝模式</p><p><strong>適配器裝飾器</strong>形式適配器沒有層級關係，裝飾器有層級關係。特殊的適配器定義適配器與被適配者沒有必然聯繫，通常通過繼承或代理進行包裝裝飾器與被裝飾者實現同一個接口，目的是為了擴展後保留OOP關係關係has-a的關係is-a的關係功能注重兼容、轉換注重覆蓋、擴展設計後置考慮前置考慮</p><h3 class="md-end-block md-heading">11.9.適配器模式的優缺點</h3><p>優點：</p><ul class=ul-list><li><strong>單一職責原則</strong>。你可以將接口或數據轉換代碼從程序主要業務邏輯中分離。</li><li><strong>開閉原則</strong>。只要客戶端代碼通過客戶端接口與適配器進行交互， 你就能在不修改現有客戶端代碼的情況下在程序中添加新類型的適配器。</li></ul><p>缺點：</p><ul class=ul-list><li><strong>代碼整體複雜度增加</strong>， 因為你需要新增一系列接口和類。 有時直接更改服務類使其與其他代碼兼容會更簡單。</li></ul><h3 class="md-end-block md-heading">11.10.總結</h3><p>一般來說，適配器模式可以看作一種“補償模式”，用來補救設計上的缺陷。應用這種模式算是“無奈之舉”，如果在設計初期，我們就能協調規避接口不兼容的問題，那這種模式就沒有應用的機會了。那在實際的開發中，什麼情況下才會出現接口不兼容呢？我總結下了下面這樣 5 種場景：</p><ul class=ul-list><li>封裝有缺陷的接口設計</li><li>統一多個類的接口設計</li><li>替換依賴的外部系統</li><li>兼容老版本接口</li><li>適配不同格式的數據</li></ul><h2 class="md-end-block md-heading">12.橋接模式</h2><p>先複習代理模式。它在不改變原始類（或者叫被代理類）代碼的情況下，通過引入代理類來給原始類附加功能。代理模式在平時的開發經常被用到，常用在業務系統中開發一些非功能性需求，比如：監控、統計、鑑權、限流、事務、冪等、日誌。</p><p>今天學習橋接模式。橋接模式的代碼實現非常簡單，但是理解起來稍微有點難度，並且應用場景也比較侷限，所以，相當於代理模式來說，橋接模式在實際的項目中並沒有那麼常用，你只需要簡單瞭解，見到能認識就可以，並不是我們學習的重點。</p><h3 class="md-end-block md-heading">12.1.原理解析</h3><p>橋接模式，也叫作橋樑模式，英文是 Bridge Design Pattern。這個模式可以說是 23 種設計模式中最難理解的模式之一了。我查閱了比較多的書籍和資料之後發現，對於這個模式有兩種不同的理解方式。</p><p><strong>示意圖</strong></p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/bffad490149e4871a49e5dd95cece3e6><p class=pgc-img-caption></p></div><p>當然，這其中“最純正”的理解方式，當屬 GoF 的《設計模式》一書中對橋接模式的定義。畢竟，這 23 種經典的設計模式，最初就是由這本書總結出來的。在 GoF 的《設計模式》一書中，橋接模式是這麼定義的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻譯成中文就是：“將抽象和實現解耦，讓它們可以獨立變化。”</p><p>關於橋接模式，很多書籍、資料中，還有另外一種理解方式：“一個類存在兩個（或多個）獨立變化的維度，我們通過組合的方式，讓這兩個（或多個）維度可以獨立進行擴展。”通過組合關係來替代繼承關係，避免繼承層次的指數級爆炸。這種理解方式非常類似於，我們之前講過的“組合優於繼承”設計原則，所以，這裡我就不多解釋了。我們重點看下 GoF 的理解方式。</p><p>橋接模式通過組合關係來替代繼承關係，避免繼承層次的指數級爆炸。</p><h3 class="md-end-block md-heading">12.2.角色</h3><p>類圖：</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8971327982bf4c7d8cae7b806f38e3bc><p class=pgc-img-caption></p></div><p><br></p><p>橋接模式有四個角色：</p><p>抽象（Abstraction)：該類持有一個對實現角色的引用，抽象角色中的方法需要實現角色。該類一般為抽象類。</p><p>修正抽象角色（RefinedAbstraction）：Abstraction的具體實現，對Abstraction方法進行完善與擴展。</p><p>抽象實現角色（Implementor）：確定實現維度的基本操作，提供給Abstraction使用。該類一般為接口或抽象類。</p><p>具體實現角色（ConcreteImplementor）：Implementor的具體實現。</p><h3 class="md-end-block md-heading">12.3.通用寫法</h3><p>創建抽象角色</p><pre><code>// 抽象public abstract class Abstraction {    protected IImplementor mImplementor;    public Abstraction(IImplementor implementor) {        this.mImplementor = implementor;    }    public void operation() {        this.mImplementor.operationImpl();    }}</code></pre><p>修正抽象角色</p><pre><code>// 修正抽象public class RefinedAbstraction extends Abstraction {    public RefinedAbstraction(IImplementor implementor) {        super(implementor);    }    @Override    public void operation() {        super.operation();        System.out.println("refined operation");    }}</code></pre><p>抽象實現角色</p><pre><code>// 抽象實現public interface IImplementor {    void operationImpl();}</code></pre><p>具體實現角色</p><pre><code>// 具體實現public class ConcreteImplementorA implements IImplementor {    public void operationImpl() {        System.out.println("I'm ConcreteImplementor A");    }}</code></pre><p>測試代碼</p><pre><code>public class Test {    public static void main(String[] args) {        // 來一個實現化角色        IImplementor imp = new ConcreteImplementorA();        // 來一個抽象化角色，聚合實現        Abstraction abs = new RefinedAbstraction(imp);        // 執行操作        abs.operation();    }}</code></pre><p>運行結果</p><pre><code>I'm ConcreteImplementor Arefined operation</code></pre><h3 class="md-end-block md-heading">12.4.應用場景</h3><ul class=ul-list><li><strong>拆分或重組一個具有多重功能的龐雜類 （例如能與多個數據庫服務器進行交互的類），可以使用橋接模式。</strong></li><li><strong>如果你希望在幾個獨立維度上擴展一個類，可使用該模式。</strong></li><li><strong>如果你需要在運行時切換不同實現方法，可使用橋接模式。</strong></li></ul><h3 class="md-end-block md-heading">12.5.業務場景中的運用</h3><p>辦公發送郵件、短信消息或者系統消息。緊急程度分為普通消息、緊急消息、特急消息。</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/05e9710013ee4e25b7ee7e19e3aa9bd7><p class=pgc-img-caption></p></div><p>使用繼承的話，情況複雜，也不利於擴展。通過橋接來解決。</p><p>創建一個IMessage接口擔任橋接角色：</p><pre><code>public interface IMessage {    //發送消息的內容和接收人    void send(String message,String toUser);}</code></pre><p>創建郵件消息實現EmailMessage類：</p><pre><code>public class EmailMessage implements IMessage {    public void send(String message, String toUser) {        System.out.println("使用郵件消息發送" + message + "給" + toUser);    }}</code></pre><p>創建手機消息實現SmsMessage類：</p><pre><code>public class SmsMessage implements IMessage {    public void send(String message, String toUser) {        System.out.println("使用短信消息發送" + message + "給" + toUser);    }}</code></pre><p>創建橋接抽象角色AbastractMessage類</p><pre><code>public abstract class AbastractMessage {    private IMessage message;    public AbastractMessage(IMessage message) {        this.message = message;    }    void sendMessage(String message,String toUser){        this.message.send(message,toUser);    }}</code></pre><p>創建具體實現普通消息類NormalMessage：</p><pre><code>public class NomalMessage extends AbastractMessage {    public NomalMessage(IMessage message) {        super(message);    }}</code></pre><p>創建短信消息類SmsMessage：</p><pre><code>public class SmsMessage implements IMessage {    public void send(String message, String toUser) {        System.out.println("使用短信消息發送" + message + "給" + toUser);    }}</code></pre><p>創建緊急消息UrgencyMessage類：</p><pre><code>public class UrgencyMessage extends AbastractMessage {    public UrgencyMessage(IMessage message) {        super(message);    }    void sendMessage(String message, String toUser){        message = "【加急】" + message;        super.sendMessage(message,toUser);    }    public Object watch(String messageId){        return null;    }}</code></pre><p>代碼測試</p><pre><code>public class Test {    public static void main(String[] args) {        IMessage message = new SmsMessage();        AbastractMessage abastractMessage = new NomalMessage(message);        abastractMessage.sendMessage("加班申請","王總");        message = new EmailMessage();        abastractMessage = new UrgencyMessage(message);        abastractMessage.sendMessage("加班申請","王總");    }}</code></pre><p>運行效果：</p><pre><code>使用短信消息發送加班申請給王總使用郵件消息發送【加急】加班申請給王總</code></pre><h3 class="md-end-block md-heading">12.6.源碼</h3><p>JDBC API，其中Driver類就是橋接對象。使用Class.forName方法動態加載各個數據庫廠商的Driver類。</p><p>以MySQL的實現為例：</p><pre><code>//1.加載驅動Class.forName("com.mysql.jdbc.Driver");  //反射機制加載驅動類// 2.獲取連接Connection//主機:端口號/數據庫名Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "root");// 3.得到執行sql語句的對象StatementStatement stmt = conn.createStatement();// 4.執行sql語句，並返回結果</code></pre><p>我們看一下Driver接口定義：</p><pre><code>public interface Driver {    Connection connect(String url, java.util.Properties info)        throws SQLException;    boolean acceptsURL(String url) throws SQLException;    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)                         throws SQLException;    int getMajorVersion();    int getMinorVersion();    boolean jdbcCompliant();    public Logger getParentLogger() throws SQLFeatureNotSupportedException;}</code></pre><p>Driver在JDBC中沒有做任何實現，具體的功能由各個廠商完成，以MySQL的實現為例。</p><pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {    public Driver() throws SQLException {    }    static {        try {            DriverManager.registerDriver(new Driver());        } catch (SQLException var1) {            throw new RuntimeException("Can't register driver!");        }    }}</code></pre><p>當我們執行Class.forName("com.mysql.jdbc.Driver")方法的時候，就會執行com.mysql.jdbc.Drvier這個類的靜態塊中的代碼。靜態塊中的代碼只是調用了一下DriverManager的referisterDriver()方法，然後將Driver對象註冊到DriverMananger中。我們繼續跟進到DriverManager這個類中，來看相關代碼：</p><pre><code>public class DriverManager {     // List of registered JDBC drivers    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();        /* Prevent the DriverManager class from being instantiated. */    private DriverManager(){}        /**     * Load the initial JDBC drivers by checking the System property     * jdbc.properties and then use the {@code ServiceLoader} mechanism     */    static {        loadInitialDrivers();        println("JDBC DriverManager initialized");    }        public static synchronized void registerDriver(java.sql.Driver driver)        throws SQLException {        registerDriver(driver, null);    }    public static synchronized void registerDriver(java.sql.Driver driver,            DriverAction da)        throws SQLException {        /* Register the driver if it has not already been added to our list */        if(driver != null) {            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));        } else {            // This is for compatibility with the original DriverManager            throw new NullPointerException();        }        println("registerDriver: " + driver);    }}</code></pre><p>在註冊之前，將傳過來的Driver對象，封裝成了一個DriverInfo對象。接下來繼續執行客戶端代碼的第二部，調用DriverManager的getConnection方法獲取鏈接對象，跟進源碼：</p><pre><code>     @CallerSensitive     public static Connection getConnection(String url,         java.util.Properties info) throws SQLException { ​         return (getConnection(url, info, Reflection.getCallerClass()));     } ​     @CallerSensitive     public static Connection getConnection(String url,         String user, String password) throws SQLException {         java.util.Properties info = new java.util.Properties(); ​         if (user != null) {             info.put("user", user);         }         if (password != null) {             info.put("password", password);         } ​         return (getConnection(url, info, Reflection.getCallerClass()));     } ​     @CallerSensitive     public static Connection getConnection(String url)         throws SQLException { ​         java.util.Properties info = new java.util.Properties();         return (getConnection(url, info, Reflection.getCallerClass()));     } ​     //  Worker method called by the public getConnection() methods.     private static Connection getConnection(         String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {         /*          * When callerCl is null, we should check the application's          * (which is invoking this class indirectly)          * classloader, so that the JDBC driver class outside rt.jar          * can be loaded from here.          */         ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;         synchronized(DriverManager.class) {             // synchronize loading of the correct classloader.             if (callerCL == null) {                 callerCL = Thread.currentThread().getContextClassLoader();             }         } ​         if(url == null) {             throw new SQLException("The url cannot be null", "08001");         } ​         println("DriverManager.getConnection(\"" + url + "\")"); ​         // Walk through the loaded registeredDrivers attempting to make a connection.         // Remember the first exception that gets raised so we can reraise it.         SQLException reason = null; ​         for(DriverInfo aDriver : registeredDrivers) {             // If the caller does not have permission to load the driver then             // skip it.             if(isDriverAllowed(aDriver.driver, callerCL)) {                 try {                     println("    trying " + aDriver.driver.getClass().getName());                     Connection con = aDriver.driver.connect(url, info);                     if (con != null) {                         // Success!                         println("getConnection returning " + aDriver.driver.getClass().getName());                         return (con);                     }                 } catch (SQLException ex) {                     if (reason == null) {                         reason = ex;                     }                 } ​             } else {                 println("    skipping: " + aDriver.getClass().getName());             } ​         } ​         // if we got here nobody could connect.         if (reason != null)    {             println("getConnection failed: " + reason);             throw reason;         } ​         println("getConnection: no suitable driver found for "+ url);         throw new SQLException("No suitable driver found for "+ url, "08001");     }</code></pre><p>在getConnection()中又會調用各個廠商實現的Driver的connect()方法獲得鏈接對象。這樣的話，就巧妙地避開了使用繼承，為不同數據庫提供相同接口。JDBC API中DriverManager就是橋，如下圖所示：</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cc52f173e32443ba57f04ace0ec36c9><p class=pgc-img-caption></p></div><h3 class="md-end-block md-heading">12.7.橋接模式優缺點</h3><p>優點</p><ul class=ul-list><li>你可以創建與平臺無關的類和程序。</li><li>客戶端代碼僅與高層抽象部分進行互動， 不會接觸到平臺的詳細信息。</li><li>開閉原則。 你可以新增抽象部分和實現部分， 且它們之間不會相互影響。</li><li>單一職責原則。 抽象部分專注於處理高層邏輯， 實現部分處理平臺細節。</li></ul><p>缺點</p><ul class=ul-list><li>對高內聚的類使用該模式可能會讓代碼更加複雜。</li></ul><h3 class="md-end-block md-heading">12.8.代理、橋接、裝飾器、適配器 4 種設計模式的區別</h3><p>代理、橋接、裝飾器、適配器，這 4 種模式是比較常用的結構型設計模式。它們的代碼結構非常相似。籠統來說，它們都可以稱為 Wrapper 模式，也就是通過 Wrapper 類二次封裝原始類。</p><p>###</p><p><strong>代理模式：</strong>代理模式在不改變原始類接口的條件下，為原始類定義一個代理類，主要目的是控制訪問，而非加強功能，這是它跟裝飾器模式最大的不同。</p><p><strong>橋接模式：</strong>橋接模式的目的是將接口部分和實現部分分離，從而讓它們可以較為容易、也相對獨立地加以改變。</p><p><strong>裝飾器模式：</strong>裝飾者模式在不改變原始類接口的情況下，對原始類功能進行增強，並且支持多個裝飾器的嵌套使用。</p><p><strong>適配器模式：</strong>適配器模式是一種事後的補救策略。適配器提供跟原始類不同的接口，而代理模式、裝飾器模式提供的都是跟原始類相同的接口。</p><h3 class="md-end-block md-heading">12.9.作業</h3><p>1、完善第三方登錄接口，完成不修改接口也能實現自動適配的功能。</p><p>通過在接口ILoginForThird的方法參數添加泛型約束。</p><pre><code> /**  * 第三方登錄的接口，方法限制適配器的Class  */ public interface ILoginForThird {     ResultMsg loginForThird(String id, Class&lt;? extends ILoginAdapter&gt; clazz); } ​ /**  * 第三方登錄適配器實現，通過適配器對象判斷是否兼容  */ public class LoginForThirdAdapter implements ILoginForThird {     @Override     public ResultMsg loginForThird(String id, Class&lt;? extends ILoginAdapter&gt; clazz) {         try {             ILoginAdapter adapter = clazz.newInstance();             if (adapter.support(adapter)) {                 return adapter.login(id, adapter);             }         } catch (Exception e) {             e.printStackTrace();         }         return null;     } } ​ /**  * 登錄適配器接口  */ public interface ILoginAdapter {     Boolean support(Object object);     ResultMsg login(String id, Object adapter); } ​ /**  * 微博登錄適配器  */ public class LoginForWeiboAdapter extends AbstractAdapter {     @Override     public Boolean support(Object adapter) {         return adapter instanceof LoginForWeiboAdapter;     } ​     @Override     public ResultMsg login(String id, Object adapter) {         if (! support(adapter)) {             return null;         }         return super.loginForRegist(id, null);     } } ​ /**  * 抽象適配器  */ public abstract class AbstractAdapter extends PassportService implements ILoginAdapter {     protected ResultMsg loginForRegist(String username, String password) {         if(null == password){             password = "THIRD_EMPTY";         }         super.regist(username,password);         return super.login(username,password);     } } ​ // 原有的註冊與登錄方法 public class PassportService {     // 註冊方法     public ResultMsg regist(String username, String password) {         return new ResultMsg(200, "註冊成功", new Member());     } ​     // 登錄的方法     public ResultMsg login(String username, String password) {         return new ResultMsg(200, "登錄成功", new Member());     } }</code></pre><p>測試代碼</p><pre><code> public class Test {     public static void main(String[] args) {         // 新增微博登錄         ILoginForThird loginForThird = new LoginForThirdAdapter();         ResultMsg resultMsg = loginForThird.loginForThird("微博賬號", LoginForWeiboAdapter.class);         System.out.println(resultMsg.toString());     } }</code></pre><p>運行效果</p><pre><code> ResultMsg(code=200, msg=登錄成功, data=Member(username=null, password=null, mid=null, info=null))</code></pre><p>類圖</p><div class=pgc-img><img alt=八、適配器模式與橋接模式詳解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/68c636735b48427882086eeba8122392><p class=pgc-img-caption></p></div><p>2、說說你對橋接模式的理解。</p><p><strong>橋接模式</strong>是一種結構型設計模式， 可將一個大類或一系列緊密相關的類拆分為抽象和實現兩個獨立的層次結構， 從而能在開發時分別使用。</p><p><strong>橋接模式：</strong>橋接模式的目的是將接口部分和實現部分分離，從而讓它們可以較為容易、也相對獨立地加以改變。</p><p>在 GoF 的《設計模式》一書中，橋接模式被定義為：“將抽象和實現解耦，讓它們可以獨立變化。”</p><p>定義中的“抽象”，指的並非“抽象類”或“接口”，而是被抽象出來的一套“類庫”，它只包含骨架代碼，真正的業務邏輯需要委派給定義中的“實現”來完成。</p><p>而定義中的“實現”，也並非“接口的實現類”，而是的一套獨立的“類庫”。“抽象”和“實現”獨立開發，通過對象之間的組合關係，組裝在一起。</p><p>簡單的理解：“一個類存在兩個（或多個）獨立變化的維度，我們通過組合的方式，讓這兩個（或多個）維度可以獨立進行擴展。”</p><p>遵循“組合優於繼承”設計原則，通過組合關係來替代繼承關係，避免繼承層次的指數級爆炸。</p><p><br></p><hr><p>參考資料</p><ol start=0><li>Alexan­der Shvets《Dive into Design Patterns》</li><li>極客時間《設計模式之美》</li><li>咕泡學院《適配器模式與橋接模式詳解》</li></ol><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>模式</a></li><li><a>橋接</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6909bb4.html alt=虛擬製造：信息時代的全新制造模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/53f60001361786aae83a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6909bb4.html title=虛擬製造：信息時代的全新制造模式>虛擬製造：信息時代的全新制造模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html alt=詳解13項鋼筋安裝質量標準及通病防治 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fd3ff534941a487884c7a67361337cfb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html title=詳解13項鋼筋安裝質量標準及通病防治>詳解13項鋼筋安裝質量標準及通病防治</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html alt=史上最全電路圖詳解！老電工都收藏了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533138404073909636bf43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html title=史上最全電路圖詳解！老電工都收藏了！>史上最全電路圖詳解！老電工都收藏了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html alt=每一滴油力爭做到不浪費，詳解各種燃油噴射方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3ed00001d75ac552f05c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html title=每一滴油力爭做到不浪費，詳解各種燃油噴射方式>每一滴油力爭做到不浪費，詳解各種燃油噴射方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html alt="Excel萬金油套路詳解 單條件查找返回多行數據" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2633664673fd439a862a2527763e82c7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html title="Excel萬金油套路詳解 單條件查找返回多行數據">Excel萬金油套路詳解 單條件查找返回多行數據</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html alt=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7360fe7df5e241e7af4b15f75f6474fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html title=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍>詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2946ed8.html alt=詳解變配電所的佈置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9fe764b6e4db4a01b0f251f70eb4e912 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2946ed8.html title=詳解變配電所的佈置>詳解變配電所的佈置</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>