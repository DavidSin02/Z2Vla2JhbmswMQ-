<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>談談代碼的模塊化 | 极客快訊</title><meta property="og:title" content="談談代碼的模塊化 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/0645ec07-8c4a-4631-937a-ca7cd2d37054"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6c6c753.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6c6c753.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6c6c753.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6c6c753.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6c6c753.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6c6c753.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6c6c753.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6c6c753.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="談談代碼的模塊化"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f6c6c753.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>談談代碼的模塊化</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=談談代碼的模塊化 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/0645ec07-8c4a-4631-937a-ca7cd2d37054><p class=pgc-img-caption></p></div><p class=ql-align-justify>我們總是說要寫模塊化的代碼。但是到底什麼是模塊化的代碼？怎樣寫模塊化的代碼？這兩個問題不解決，模塊化就不接地氣、無法落地。</p><p class=ql-align-justify>這篇談談我對代碼模塊化的一些思考。</p><h1 class=ql-align-justify>模塊化是什麼?</h1><p class=ql-align-justify><strong>代碼分割</strong></p><p class=ql-align-justify>可能在很多人的理解中，要「模塊化」就要分割代碼。於是他們會把項目分成很多個文件，甚至分割成很多個版本倉庫（repository）。但實際上，這種分割只是手段，而不是目的。如果把這種手段錯誤地當做是目的，那可能不會帶來什麼好處，反而會帶來很多麻煩。</p><p class=ql-align-justify>例如說，我曾經參與過一個項目的開發。對於運行在網絡通信框架上的業務邏輯插件，人們為之寫了一個基類，命名為 PluginBase。而後，人們把它單獨拉出去，作為一個單獨的版本倉庫。在實際編寫插件時，再通過二進制依賴的方式，將 PluginBase 的共享對象（.so）動態<span>鏈接</span>到進程中去。這種做法其實完全沒必要，就屬於典型的錯把手段當目的。PluginBase 與 PluginFooBar 在邏輯上的結合是很緊密的——基類和派生類，因此將它們分開不合適。打個比方，在開發 PluginFooBar 時，我們可能發現之前在設計 PluginBase 時不夠完善，需要再添加一個接口。此時，我們就需要：</p><ul><li class=ql-align-justify>修改 PluginBase 的代碼；</li><li class=ql-align-justify>編譯之後發版；</li><li class=ql-align-justify>在 PluginFooBar 的版本倉庫中修改依賴配置；</li><li class=ql-align-justify>編譯 PluginFooBar；</li><li class=ql-align-justify>將新版本的 libPluginBase.so 和 libPluginFooBar.so 都拷貝到執行環境。</li></ul><p class=ql-align-justify>而如果我們能發現 PluginBase 和 PluginFooBar 在邏輯上結合很緊密，而不把它們分開在兩個版本倉庫中，這樣的修改就簡單多了：</p><ul><li class=ql-align-justify>修改 PluginBase 的代碼；</li><li class=ql-align-justify>編譯；</li><li class=ql-align-justify>將新版本的 libPlugins.so 拷貝到執行環境。</li></ul><p class=ql-align-justify><strong>按邏輯分塊</strong></p><p class=ql-align-justify>如此我們可以發現，所謂模塊化，分割是手段而非目的。那麼究竟要怎麼模塊化呢？上面的討論已經提到了一點——跟邏輯相關。這裡繼續討論。</p><p class=ql-align-justify>要搞清楚模塊化，首先要搞清楚什麼是模塊。模塊其實是一個邏輯層面的定義。它是說：如果一個東西，它有定義良好的輸入和輸出，那麼它就是一個模塊。再詳細說一點，這裡所謂的「定義良好」有兩個方面需要定義：一方面指輸入和輸出的格式，一方面指輸入和輸出的含義。</p><p class=ql-align-justify>因此，只要一個東西的行為，在邏輯上滿足這個闡述，那麼它就是一個模塊。例如一塊電路板是一個模塊；因為它接受固定格式的輸入，根據固定邏輯產出輸出。又例如一個定義良好的函數是一個模塊；因為它接受固定格式的輸入（函數參數），根據固定邏輯產出輸出。</p><p class=ql-align-justify>回到上一小節舉的例子。PluginBase 在邏輯上並沒有良好的輸入和輸出——它是基類，通常實際功能由子類完成。因此，強行把它提出去單獨管理是不合適的。</p><h1 class=ql-align-justify>怎樣寫模塊化的代碼？</h1><p class=ql-align-justify>具體到寫代碼時，模塊化這個命題主要就落在如何設計函數上了——畢竟，在代碼的世界裡，函數是最小的模塊單元。這裡提煉一些實踐中的經驗。</p><p class=ql-align-justify><strong>單一職責</strong></p><p class=ql-align-justify>設計函數時，最好讓函數的職責足夠簡單，只有一個。</p><p class=ql-align-justify>為什麼這麼說呢？我們可以考慮一下，如果一個函數既可以做這個，又可以做那個，這種函數需要怎樣設計？顯然，函數需要根據某些變量的值，或者某種條件，來選擇走哪個邏輯分支。比如可能有如下代碼：</p><p class=ql-align-justify><strong>複製</strong></p><pre class=ql-align-right>// bool flag;void foo() { if (flag == true) { bar_a(); baz_a(); } else { bar_b(); baz_b(); } qux();}</pre><p class=ql-align-justify>變量 flag 用來表示影響函數行為的外部因素。函數 foo 內，根據 flag 取值的不同，會走不同的分支。這種設計看起來不錯。比如，有人可能會認為它節省了代碼行數，寫起來爽快。但是實際上這個函數的行為某種程度上就不是良定義的了——它取決於一個外部變量。試想，一個剛接手這段代碼的人，調用 foo 函數，TA 就必須不斷去追蹤 flag 變量代表的外部環境。如果你覺得追蹤某個變量還算好的話，可以試想一下如果這個變量代表「打印機有沒有連上」這種在代碼中完全不可控的外部因素會怎樣。</p><p class=ql-align-justify>對於這種代碼，就不如把兩種不同情形分開，寫成這樣：</p><p class=ql-align-justify><strong>複製</strong></p><pre class=ql-align-right>// bool flag;void foo_a() { bar_a(); baz_a(); quz();}void foo_b() { bar_b(); baz_b(); quz();}/*if (flag == true) { foo_a();} else { foo_b();}*/</pre><p class=ql-align-justify>如此一來，foo_a 和 foo_b 的職責都很明確，接手維護的人再也不會疑惑函數的行為了。</p><p class=ql-align-justify><strong>輸入決定（input dominated）</strong></p><p class=ql-align-justify>設計函數時，儘可能使函數的行為完全由其輸入參數決定。特別地，儘可能不要讓函數的行為受到全局變量、類的成員變量的取值影響。某種意義上，這和「可重入」的概念比較像。</p><p class=ql-align-justify>這一點應該比較好理解。如果一個函數的行為取決於入參之外的因素，那麼相當於這個函數在參數之外還有其他輸入。顯然，這和「輸入良定義」是矛盾的。特別地，如果一個類的成員函數的行為依賴類的成員變量的取值，那麼使用這個成員函數時，我們就不得不膽戰心驚，逐個推演其他的成員函數有可能在某些情況下修改這些成員變量的值。</p><h1 class=ql-align-justify>自我限制</h1><p class=ql-align-justify>這部分完全是經驗之談。</p><p class=ql-align-justify>寫代碼的時候，可以做一些自我限制。例如說：不寫超過 50 行的代碼；不超過 5 行的通用功能也要拉出去做工具函數。</p><p class=ql-align-justify>人總是愛偷懶的。因此，寫代碼寫 high 的時候，往往就會忘記很多最佳實踐。因此，給自己做一些自我限制，有一些強迫症還是很有必要的。據我自己的經驗，超過 50 行的代碼，往往就會把邏輯寫得像麵條一樣，同時輸入和輸出的定義就不那麼明朗了。因此 50 行雖然沒有什麼別的意義，但是僅僅將它作為是一個強迫症式的自我限制也是不錯的。當然，你可以根據你的習慣，調整這個限制的大小。</p><p>來源：Liam Huang / https://liam.page/2018/12/12/writing-modular-codes/ ，只作分享，不作任何商業用途，版權歸原作者所有</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>談談代碼</a></li><li><a>模塊化</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bde216e9.html alt=亨內基公司用模塊化中型散裝容器站生產聚氨酯 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d5f02b099e6d4c6ebf824770b4fccfa2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bde216e9.html title=亨內基公司用模塊化中型散裝容器站生產聚氨酯>亨內基公司用模塊化中型散裝容器站生產聚氨酯</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c8a0350b.html alt=學術簡報｜混合模塊化直流固態變壓器的工作原理及穩態特性分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/bf7e5a86-df32-48f6-ab83-28e9e17b0dbe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c8a0350b.html title=學術簡報｜混合模塊化直流固態變壓器的工作原理及穩態特性分析>學術簡報｜混合模塊化直流固態變壓器的工作原理及穩態特性分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1661d52.html alt=阿里達摩院發佈十大科技趨勢：模塊化讓造芯像搭積木一樣簡單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8eada69d7d5748ee8bb655b386d782f6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1661d52.html title=阿里達摩院發佈十大科技趨勢：模塊化讓造芯像搭積木一樣簡單>阿里達摩院發佈十大科技趨勢：模塊化讓造芯像搭積木一樣簡單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97fe0ba4.html alt=什麼是小型模塊化反應堆？小型模塊化反應堆帶來的機遇和挑戰 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9bbadb2f38084622bc7293031b8d8943 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97fe0ba4.html title=什麼是小型模塊化反應堆？小型模塊化反應堆帶來的機遇和挑戰>什麼是小型模塊化反應堆？小型模塊化反應堆帶來的機遇和挑戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/b0692f7.html alt=模塊化合成番石榴多糖19糖：正交一鍋糖苷化反應策略 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d43afbebe094045a2fb357c481e46f1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/b0692f7.html title=模塊化合成番石榴多糖19糖：正交一鍋糖苷化反應策略>模塊化合成番石榴多糖19糖：正交一鍋糖苷化反應策略</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/472c715.html alt=將差分放大器模塊化 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0365b7a4288a4c72901bce20593cce9e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/472c715.html title=將差分放大器模塊化>將差分放大器模塊化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/27ffd05.html alt=吹膜模塊化擠出控制系統可最大限度提高生產線的效率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7e2a710f061b41f38c9302e3bff4c26e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/27ffd05.html title=吹膜模塊化擠出控制系統可最大限度提高生產線的效率>吹膜模塊化擠出控制系統可最大限度提高生產線的效率</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>