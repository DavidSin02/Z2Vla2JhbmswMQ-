<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「必需知道」實用，完整的HTTP cookie指南 | 极客快訊</title><meta property="og:title" content="「必需知道」實用，完整的HTTP cookie指南 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8a4624de47524aa69601b3047226a318"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7005116.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><meta property="article:published_time" content="2020-11-14T21:00:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:34+08:00"><meta name=Keywords content><meta name=description content="「必需知道」實用，完整的HTTP cookie指南"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f7005116.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「必需知道」實用，完整的HTTP cookie指南</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>Web 開發中的 cookie 是什麼?</strong></h1><p><strong>cookie 是後端可以存儲在用戶瀏覽器中的小塊數據。</strong> Cookie 最常見用例包括用戶跟蹤，個性化以及身份驗證。</p><p><strong>Cookies</strong> 具有很多隱私問題，多年來一直受到嚴格的監管。</p><p>在本文中，主要側重於技術方面：學習如何在前端和後端創建，使用 HTTP cookie。</p><h1 class=pgc-h-arrow-right><strong>後端配置</strong></h1><p>後端示例是<strong>Flask</strong>編寫的。如果你想跟著學習，可以創建一個新的Python虛擬環境，移動到其中並安裝Flask</p><pre><code>mkdir cookies &amp;&amp; cd $_python3 -m venv venvsource venv/bin/activatepip install Flask</code></pre><p>在項目文件夾中創建一個名為flask app.py的新文件，並使用本文的示例在本地進行實驗。</p><h1 class=pgc-h-arrow-right><strong>誰創建 cookies ?</strong></h1><p>首先，cookies 從何而來？誰創建 cookies ？</p><p>雖然可以使用document.cookie在瀏覽器中創建 cookie，但大多數情況下，後端的責任是在將響應客戶端請求之前在請求中設置 cookie。</p><p>後端是指可以通過以下方式創建 Cookie：</p><ul><li>後端實際應用程序的代碼(Python、JavaScript、PHP、Java)</li><li>響應請求的Web服務器（Nginx，Apache）</li></ul><p>後端可以在 HTTP 請求求中 Set-Cookie 屬性來設置 cookie，它是由鍵/值對以及可選屬性組成的相應字符串：</p><pre><code>Set-Cookie: myfirstcookie=somecookievalue</code></pre><p>什麼時候需要創建 cookie？這取決於需求。</p><p>cookie 是簡單的字符串。在項目文件夾中創建一個名為flask_app.py的Python文件，並輸入以下內容：</p><pre><code>from flask import Flask, make_responseapp = Flask(__name__)@app.route("/index/", methods=["GET"])def index():    response = make_response("Here, take some cookie!")    response.headers["Set-Cookie"] = "myfirstcookie=somecookievalue"    return response</code></pre><p>然後運行應用程序:</p><pre><code>FLASK_ENV=development FLASK_APP=flask_app.py flask run</code></pre><p>當該應用程序運行時，用戶訪問http://127.0.0.1:5000/index/，後端將設置一個具有鍵/值對的名為Set-Cookie的響應標頭。</p><p>（127.0.0.1:5000是開發中的 Flask 應用程序的默認偵聽地址/端口）。</p><p>Set-Cookie標頭是瞭解如何創建cookie的關鍵：</p><pre><code>response.headers["Set-Cookie"] = "myfirstcookie=somecookievalue"</code></pre><p>大多數框架都有自己設置 cookie 的方法，比如Flask的set_cookie()。</p><h1 class=pgc-h-arrow-right><strong>如何查看 cookies ？</strong></h1><p>訪問http://127.0.0.1:5000/index/後，後端將在瀏覽器中設置cookie。要查看此cookie，可以從瀏覽器的控制檯調用document.cookie：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a4624de47524aa69601b3047226a318><p class=pgc-img-caption></p></div><p>或者可以在開發人員工具中選中Storage選項卡。單擊cookie,會看到 cookie 具體的內容：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/61a36d7e7fae49ecabbb7c65b5c868bb><p class=pgc-img-caption></p></div><p>在命令行上，還可以使用curl查看後端設置了哪些 cookie</p><pre><code>curl -I http://127.0.0.1:5000/index/</code></pre><p>可以將 Cookie 保存到文件中以供以後使用：</p><pre><code>curl -I http://127.0.0.1:5000/index/ --cookie-jar mycookies</code></pre><p>在 stdout 上顯示 cookie:</p><pre><code>curl -I http://127.0.0.1:5000/index/ --cookie-jar -</code></pre><p>請注意，沒有HttpOnly屬性的cookie，在瀏覽器中可以使用document.cookie上訪問，如果設置了 HttpOnly 屬性，document.cookie就讀取不到。</p><pre><code>Set-Cookie: myfirstcookie=somecookievalue; HttpOnly</code></pre><p>現在，該cookie 仍將出現在 Storage 選項卡中，但是 document.cookie返回的是一個空字符串。</p><p>從現在開始，為方便起見，使用Flask的 response.set_cookie() 在後端上創建 cookie。</p><h1 class=pgc-h-arrow-right><strong>我有一個 cookie，現在怎麼辦？</strong></h1><p>你的瀏覽器得到一個 cookie。現在怎麼辦呢?一旦有了 cookie，瀏覽器就可以將cookie發送回後端。</p><p>這有許多用途發如：用戶跟蹤、個性化，以及最重要的身份驗證。</p><p>例如，一旦你登錄網站，後端就會給你一個cookie：</p><pre><code>Set-Cookie: userid=sup3r4n0m-us3r-1d3nt1f13r</code></pre><p>為了在每個後續請求中正確識別 我們的身份，後端會檢查來自請求中瀏覽器的 cookie</p><p>要發送Cookie，瀏覽器會在請求中附加一個Cookie標頭：</p><pre><code>Cookie: userid=sup3r4n0m-us3r-1d3nt1f13r</code></pre><h1 class=pgc-h-arrow-right><strong>cookie 可以設置過期時間: Max-Age 和 expires</strong></h1><p>默認情況下，cookie 在用戶關閉會話時即關閉瀏覽器時過期。要持久化cookie，我們可以通過expires或Max-Age屬性</p><pre><code>Set-Cookie: myfirstcookie=somecookievalue; expires=Tue, 09 Jun 2020 15:46:52 GMT; Max-Age=1209600</code></pre><p>注意：<strong>Max-Age</strong>優先於<strong>expires</strong>。</p><h1 class=pgc-h-arrow-right><strong>cookie的作用域是網站路徑: path 屬性</strong></h1><p>考慮該後端，該後端在訪問http://127.0.0.1:5000/時為其前端設置了一個新的 cookie。相反，在其他兩條路徑上，我們打印請求的cookie：</p><pre><code>from flask import Flask, make_response, requestapp = Flask(__name__)@app.route("/", methods=["GET"])def index():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d", path="/about/")    return response@app.route("/about/", methods=["GET"])def about():    print(request.cookies)    return "Hello world!"@app.route("/contact/", methods=["GET"])def contact():    print(request.cookies)    return "Hello world!"</code></pre><p>運行該應用程序:</p><pre><code>FLASK_ENV=development FLASK_APP=flask_app.py flask run</code></pre><p>在另一個終端中，如果我們與根路由建立連接，則可以在Set-Cookie中看到cookie：</p><pre><code>curl -I http://127.0.0.1:5000/ --cookie-jar cookiesHTTP/1.0 200 OKContent-Type: text/html; charset=utf-8Content-Length: 23Set-Cookie: id=3db4adj3d; Path=/about/Server: Werkzeug/1.0.1 Python/3.8.3Date: Wed, 27 May 2020 09:21:37 GMT</code></pre><p>請注意，此時 cookie 具有Path屬性：</p><pre><code>Set-Cookie: id=3db4adj3d; Path=/about/</code></pre><p>/about/ 路由並保存 cookit</p><pre><code>curl -I http://127.0.0.1:5000/about/ --cookie cookies</code></pre><p>在 Flask 應用程序的終端中運行如下命令，可以看到：</p><pre><code>ImmutableMultiDict([('id', '3db4adj3d')])127.0.0.1 - - [27/May/2020 11:27:55] "HEAD /about/ HTTP/1.1" 200 -</code></pre><p>正如預期的那樣，cookie 返回到後端。現在嘗試訪問 /contact/ 路由：</p><pre><code>url -I http://127.0.0.1:5000/contact/ --cookie cookies</code></pre><p>在 Flask 應用程序的終端中運行如下命令，可以看到：</p><pre><code>ImmutableMultiDict([])127.0.0.1 - - [27/May/2020 11:29:00] "HEAD /contact/ HTTP/1.1" 200 -</code></pre><p>這說明啥?cookie 的作用域是Path 。具有給定路徑屬性的cookie不能被髮送到另一個不相關的路徑，即使這兩個路徑位於同一域中。</p><p><strong>這是cookie權限的第一層。</strong></p><p>在cookie創建過程中省略Path時，瀏覽器默認為/。</p><h1 class=pgc-h-arrow-right><strong>cookie 的作用域是域名: domain 屬性</strong></h1><p>cookie 的 Domain 屬性的值控制瀏覽器是否應該接受cookie以及cookie返回的位置。</p><p>讓我們看一些例子。</p><h1 class=pgc-h-arrow-right><strong>主機不匹配（錯誤的主機）</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-wrong-domain-cookie/設置的cookie：</p><pre><code>Set-Cookie: coookiename=wr0ng-d0m41n-c00k13; Domain=api.valentinog.com</code></pre><p>這裡的 cookie 來自<strong>serene-bastion-01422.herokuapp.com</strong>，但是Domain屬性具有<strong>api.valentinog.com</strong>。</p><p>瀏覽器沒有其他選擇來拒絕這個 cookie。比如 Chrome 會給出一個警告(Firefox沒有)</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7c81fe6e3a2446dbb6b576bfad0f481e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>主機不匹配（子域名）</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-wrong-subdomain-cookie/設置的cookie：</p><pre><code>Set-Cookie: coookiename=wr0ng-subd0m41n-c00k13; Domain=secure-brushlands-44802.herokuapp.com</code></pre><p>這裡的 Cookie 來自serene-bastion-01422.herokuapp.com，但**“Domain”**屬性是secure-brushlands-44802.herokuapp.com。</p><p>它們在相同的域上，但是子域名不同。同樣，瀏覽器也拒絕此cookie：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a96594e351b44a6be4a707ee00506bf><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>主機匹配（整個域）</strong></h1><p>查看 https://www.valentinog.com/get-domain-cookie.html設置的cookie：</p><pre><code>set-cookie: cookiename=d0m41n-c00k13; Domain=valentinog.com</code></pre><p>此cookie是使用 Nginx add_header在Web服務器上設置的：</p><pre><code>add_header Set-Cookie "cookiename=d0m41n-c00k13; Domain=valentinog.com";</code></pre><p>這裡使用 Nginx 中設置cookie的多種方法。Cookie 是由 Web 服務器或應用程序的代碼設置的，對於瀏覽器來說無關緊要。</p><p>重要的是 cookie 來自哪個域。</p><p>在此瀏覽器將愉快地接受cookie，因為Domain中的主機包括cookie所來自的主機。</p><p>換句話說，valentinog.com包括子域名www.valentinog.com。</p><p>同時，對valentinog.com的新請求,cookie 都會攜帶著，以及任何對valentinog.com子域名的請求。</p><p>這是一個附加了Cookie的 www 子域請求：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9dc2184e57334a21b7116989b14435cb><p class=pgc-img-caption></p></div><p>下面是對另一個自動附加cookie的子域的請求</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/220b42278e584c89b7a7d7081dcd9cb5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>Cookies 和公共後綴列表</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-domain-cookie/:設置的 cookie：</p><pre><code>Set-Cookie: coookiename=d0m41n-c00k13; Domain=herokuapp.com</code></pre><p>這裡的 cookie 來自serene-bas-01422.herokuapp.com，Domain 屬性是herokuapp.com。瀏覽器在這裡應該做什麼</p><p>你可能認為serene-base-01422.herokuapp.com包含在herokuapp.com域中，因此瀏覽器應該接受cookie。</p><p>相反，它拒絕 cookie，因為它來自<strong>公共後綴列表</strong>中包含的域。</p><p>Public Suffix List（公共後綴列表）。此列表列舉了頂級域名和開放註冊的域名。瀏覽器禁止此列表上的域名被子域名寫入Cookie。</p><h1 class=pgc-h-arrow-right><strong>主機匹配（子域）</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-subdomain-cookie/:設置的 cookie：</p><pre><code>Set-Cookie: coookiename=subd0m41n-c00k13</code></pre><p>當域在cookie創建期間被省略時，瀏覽器會默認在地址欄中顯示原始主機，在這種情況下，我的代碼會這樣做:</p><pre><code>response.set_cookie(key="coookiename", value="subd0m41n-c00k13")</code></pre><p>當 Cookie 進入瀏覽器的 Cookie 存儲區時，我們看到已應用Domain ：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6e523e434ec47de96940fcf5fa3d1ea><p class=pgc-img-caption></p></div><p>現在，我們有來自serene-bastion-01422.herokuapp.com 的 cookie, 那 cookie 現在應該送到哪裡?</p><p>如果你訪問https://serene-bastion-01422.herokuapp.com/，則 cookie 隨請求一起出現：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14758019996745419eb718a261cde202><p class=pgc-img-caption></p></div><p>但是，如果訪問herokuapp.com，則 cookie 不會隨請求一起出現：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f38726407a5d46afa1acd29b16c93669><p class=pgc-img-caption></p></div><p>概括地說，瀏覽器使用以下啟發式規則來決定如何處理cookies(這裡的發送者主機指的是你訪問的實際網址):</p><ul><li>如果“Domain”中的域或子域與訪問的主機不匹配，則完全拒絕 Cookie</li><li>如果 Domain 的值包含在公共後綴列表中，則拒絕 cookie</li><li>如果Domain 中的域或子域與訪問在主機匹配，則接受 Cookie</li></ul><p>一旦瀏覽器接受了cookie，並且即將發出請求，它就會說：</p><ul><li>如果請求主機與我在Domain中看到的值完全匹配，則會回傳 cookie</li><li>如果請求主機是與我在“Domain”中看到的值完全匹配的子域，則將回傳 cookie</li><li>如果請求主機是sub.example.dev之類的子域，包含在example.dev之類的 Domain 中，則將回傳 cookie</li><li>如果請求主機是例如example.dev之類的主域，而 Domain 是sub.example.dev之類，則不會回傳cookie。</li></ul><p><strong>Domain 和 Path 屬性一直是 cookie 權限的第二層。</strong></p><h1 class=pgc-h-arrow-right><strong>Cookies可以通過AJAX請求傳遞</strong></h1><p>Cookies 可以通過AJAX請求傳播。<strong>AJAX 請求</strong>是使用 JS （XMLHttpRequest或Fetch）進行的異步HTTP請求，用於獲取數據並將其發送回後端。</p><p>考慮 Flask的另一個示例，其中有一個模板，該模板又會加載 JS 文件：</p><pre><code>from flask import Flask, make_response, render_templateapp = Flask(__name__)@app.route("/", methods=["GET"])def index():    return render_template("index.html")@app.route("/get-cookie/", methods=["GET"])def get_cookie():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d")    return response</code></pre><p>以下是 templates/index.html 模板：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;FETCH&lt;/button&gt;&lt;/body&gt;&lt;script src="{{ url_for('static', filename='index.js') }}"&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><p>下面是 static/index.js 的內容：</p><pre><code>const button = document.getElementsByTagName("button")[0];button.addEventListener("click", function() {  getACookie();});function getACookie() {  fetch("/get-cookie/")    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.text();    })    .then(text =&gt; console.log(text));}</code></pre><p>當訪問http://127.0.0.1:5000/時，我們會看到一個按鈕。通過單擊按鈕，我們向/get-cookie/發出獲取請求並獲取Cookie。正如預期的那樣，cookie 落在瀏覽器的 Cookie storage中。</p><p>對 Flask 應用程序進行一些更改，多加一個路由：</p><pre><code>from flask import Flask, make_response, request, render_template, jsonifyapp = Flask(__name__)@app.route("/", methods=["GET"])def index():    return render_template("index.html")@app.route("/get-cookie/", methods=["GET"])def get_cookie():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d")    return response@app.route("/api/cities/", methods=["GET"])def cities():    if request.cookies["id"] == "3db4adj3d":        cities = [{"name": "Rome", "id": 1}, {"name": "Siena", "id": 2}]        return jsonify(cities)    return jsonify(msg="Ops!")</code></pre><p>另外，調整一下 JS 代碼，用於下請求剛新增的路由：</p><pre><code>const button = document.getElementsByTagName("button")[0];button.addEventListener("click", function() {  getACookie().then(() =&gt; getData());});function getACookie() {  return fetch("/get-cookie/").then(response =&gt; {    // make sure to check response.ok in the real world!    return Promise.resolve("All good, fetch the data");  });}function getData() {  fetch("/api/cities/")    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.json();    })    .then(json =&gt; console.log(json));</code></pre><p>當訪問http://127.0.0.1:5000/時，我們會看到一個按鈕。通過單擊按鈕，我們向/get-cookie/發出獲取請求以獲取Cookie。Cookie出現後，我們就會對/api/cities/再次發出Fetch請求。</p><p>在瀏覽器的控制檯中，可以看到請求回來 的數據。另外，在開發者工具的Network選項卡中，可以看到一個名為Cookie的頭，這是通過AJAX請求傳給後端。</p><p>只要前端與後端在同一上下文中，在前端和後端之間來回交換cookie就可以正常工作：我們說它們來自同源。</p><p>這是因為默認情況下，Fetch 僅在請求到達觸發請求的來源時才發送憑據，即 Cookie。</p><h1 class=pgc-h-arrow-right><strong>cookie 不能總是通過AJAX請求傳遞</strong></h1><p>考慮另一種情況，在後端獨立運行，可以這樣啟動應用程序:</p><pre><code>FLASK_ENV=development FLASK_APP=flask_app.py flask run</code></pre><p>現在，在 Flask 應用程序之外的其他文件夾中，創建index.html：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;FETCH&lt;/button&gt;&lt;/body&gt;&lt;script src="index.js"&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><p>使用以下代碼在同一文件夾中創建一個名為index.js的 JS 文件：</p><pre><code>button.addEventListener("click", function() {  getACookie().then(() =&gt; getData());});function getACookie() {  return fetch("http://localhost:5000/get-cookie/").then(response =&gt; {    // make sure to check response.ok in the real world!    return Promise.resolve("All good, fetch the data");  });}function getData() {  fetch("http://localhost:5000/api/cities/")    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.json();    })    .then(json =&gt; console.log(json));}</code></pre><p>在同一文件夾中，從終端運行：</p><pre><code>npx serve</code></pre><p>此命令為您提供了要連接的本地地址/端口，例如http://localhost:42091/。訪問頁面並嘗試在瀏覽器控制檯打開的情況下單擊按鈕。在控制檯中，可以看到：</p><pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:5000/get-cookie/. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing)</code></pre><p>因為 http://localhost:5000/ 與http://localhost:42091/.不同。它們是不同的域，因此會 CORS 的限制。</p><h1 class=pgc-h-arrow-right><strong>處理 CORS</strong></h1><p>CORS 是一個 W3C 標準，全稱是“跨域資源共享”（Cross-origin resource sharing）。它允許瀏覽器向跨域的服務器，發出XMLHttpRequest請求，從而克服了 AJAX 只能同源使用的限制。</p><p>整個 CORS 通信過程，都是瀏覽器自動完成，不需要用戶參與。對於開發者來說，CORS 通信與普通的 AJAX 通信沒有差別，代碼完全一樣。瀏覽器一旦發現 AJAX 請求跨域，就會自動添加一些附加的頭信息，有時還會多出一次附加的請求，但用戶不會有感知。因此，實現 CORS 通信的關鍵是服務器。只要服務器實現了 CORS 接口，就可以跨域通信。</p><p>默認情況下，除非服務器設置了Access-Control-Allow-Origin的特定HTTP標頭，否則瀏覽器將阻止AJAX對非相同來源的遠程資源的請求。</p><p>要解決此第一個錯誤，我們需要為Flask配置CORS：</p><pre><code>pip install flask-cors</code></pre><p>然後將 CORS 應用於 Flask：</p><pre><code>from flask import Flask, make_response, request, render_template, jsonifyfrom flask_cors import CORSapp = Flask(__name__)CORS(app=app)@app.route("/", methods=["GET"])def index():    return render_template("index.html")@app.route("/get-cookie/", methods=["GET"])def get_cookie():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d")    return response@app.route("/api/cities/", methods=["GET"])def cities():    if request.cookies["id"] == "3db4adj3d":        cities = [{"name": "Rome", "id": 1}, {"name": "Siena", "id": 2}]        return jsonify(cities)    return jsonify(msg="Ops!")</code></pre><p>現在嘗試在瀏覽器控制檯打開的情況下再次單擊按鈕。在控制檯中你應該看到</p><pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:5000/api/cities/. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing)</code></pre><p>儘管我們犯了同樣的錯誤，但這次的罪魁禍首是第二個路由。</p><p>你可以通過查看 “Network” 標籤中的請求來確認,沒有發送此類Cookie：</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b32b26734f34c2490259a7785b8d6c4><p class=pgc-img-caption></p></div><p>為了在不同來源的Fetch請求中包含cookie，我們必須提credentials 標誌（默認情況下，它是相同來源）。</p><p>如果沒有這個標誌，Fetch 就會忽略 cookie，可以這樣修復：</p><pre><code>const button = document.getElementsByTagName("button")[0];button.addEventListener("click", function() {  getACookie().then(() =&gt; getData());});function getACookie() {  return fetch("http://localhost:5000/get-cookie/", {    credentials: "include"  }).then(response =&gt; {    // make sure to check response.ok in the real world!    return Promise.resolve("All good, fetch the data");  });}function getData() {  fetch("http://localhost:5000/api/cities/", {    credentials: "include"  })    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.json();    })    .then(json =&gt; console.log(json));}</code></pre><p>credentials: "include" 必須在第一個 Fetch 請求中出現，才能將Cookie保存在瀏覽器的Cookie storage 中：</p><pre><code>fetch("http://localhost:5000/get-cookie/", {    credentials: "include"  })</code></pre><p>它還必須在第二個請求時出現，以允許將cookie傳輸回後端</p><pre><code>  fetch("http://localhost:5000/api/cities/", {    credentials: "include"  })</code></pre><p>再試一次，我們還需要在後端修復另一個錯誤：</p><pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:5000/get-cookie/. (Reason: expected ‘true’ in CORS header ‘Access-Control-Allow-Credentials’).</code></pre><p>為了允許在CORS請求中傳輸cookie，後端還需要設置 Access-Control-Allow-Credentials標頭。</p><pre><code>CORS(app=app, supports_credentials=True)</code></pre><p>要點：為了使Cookie在不同來源之間通過AJAX請求傳遞，可以這樣做：</p><ul><li>credentials: "include" 用於前端的 fetch 請求中</li><li>Access-Control-Allow-Credentials 和 Access-Control-Allow-Origin 用於後端</li></ul><p>cookie可以通過AJAX請求傳遞，但是它們必須遵守我們前面描述的域規則。</p><h1 class=pgc-h-arrow-right><strong>Cookie 的 Secure 屬性</strong></h1><p>Secure 屬性是說如果一個 cookie 被設置了Secure=true，那麼這個cookie只能用https協議發送給服務器，用 http 協議是不發送的。換句話說，cookie 是在https的情況下創建的，而且他的Secure=true，那麼之後你一直用https訪問其他的頁面（比如登錄之後點擊其他子頁面），cookie會被髮送到服務器，你無需重新登錄就可以跳轉到其他頁面。但是如果這時你把url改成http協議訪問其他頁面，你就需要重新登錄了，因為這個cookie不能在http協議中發送。</p><p>可以這樣設置 Secure 屬性</p><pre><code>response.set_cookie(key="id", value="3db4adj3d", secure=True)</code></pre><p>如果要在真實環境中嘗試，請可以運行以下命令，並注意curl在此處是不通過HTTP保存cookie：</p><pre><code>curl -I http://serene-bastion-01422.herokuapp.com/get-secure-cookie/ --cookie-jar -</code></pre><p>相反，通過HTTPS，cookie 出現在cookie jar中：</p><pre><code>curl -I https://serene-bastion-01422.herokuapp.com/get-secure-cookie/ --cookie-jar -</code></pre><p>cookie jar 文件：</p><pre><code>serene-bastion-01422.herokuapp.com      FALSE   /       TRUE    0</code></pre><p>不要被Secure欺騙：瀏覽器通過HTTPS接受cookie，但是一旦cookie進入瀏覽器，就沒有任何保護。</p><p>因為帶有 Secure 的 Cookie 一般也不用於傳輸敏感數據.</p><h1 class=pgc-h-arrow-right><strong>Cookie 的 HttpOnly 屬性</strong></h1><p>如果cookie中設置了HttpOnly屬性，那麼通過js腳本將無法讀取到cookie信息，這樣能有效的防止XSS攻擊，竊取cookie內容，這樣就增加了cookie的安全性，即便是這樣，也不要將重要信息存入cookie。</p><blockquote><p>XSS 全稱Cross SiteScript，跨站腳本攻擊，是Web程序中常見的漏洞，XSS屬於被動式且用於客戶端的攻擊方式，所以容易被忽略其危害性。其原理是攻擊者向有XSS漏洞的網站中輸入(傳入)惡意的HTML代碼，當其它用戶瀏覽該網站時，這段HTML代碼會自動執行，從而達到攻擊的目的。如，盜取用戶Cookie、破壞頁面結構、重定向到其它網站等。</p></blockquote><p>如果有設置 HttpOnly 看起來是這樣的：</p><pre><code>Set-Cookie: "id=3db4adj3d; HttpOnly"</code></pre><p>在 Flask 中</p><pre><code>response.set_cookie(key="id", value="3db4adj3d", httponly=True)</code></pre><p>這樣，cookie 設置了HttpOnly屬性，那麼通過js腳本將無法讀取到cookie信息。如果在控制檯中進行檢查，則document.cookie將返回一個空字符串。</p><p>何時使用HttpOnly？cookie 應該始終是HttpOnly的，除非有特定的要求將它們暴露給運行時 JS。</p><h1 class=pgc-h-arrow-right><strong>可怕的 SameSite 屬性</strong></h1><h1 class=pgc-h-arrow-right><strong>first-party cookie 和 third-party cookie</strong></h1><p>查看https://serene-bastion-01422.herokuapp.com/get-cookie/ 中所攜帶的 Cookie</p><pre><code>Set-Cookie: simplecookiename=c00l-c00k13; Path=/</code></pre><p>first-party是指你登錄或使用的網站所發行的 cookie，而third-party cookie 常為一些廣告網站，有侵犯隱私以及安全隱患。</p><p>我們將這類 Cookie 稱為 first-party。也就是說，我在瀏覽器中訪問該URL，並且如果我訪問相同的URL或該站點的另一個路徑（假設Path為/），則瀏覽器會將cookie發送回該網站。</p><p>現在考慮在https://serene-bastion-01422.herokuapp.com/get-frog/上的另一個網頁。該頁面設置了一個cookie，此外，它還從https://www.valentinog.com/cookie-frog.jpg託管的遠程資源中加載圖像。</p><p>該遠程資源又會自行設置一個cookie:</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1b74edbd458949768cb0dcbf91765f8c><p class=pgc-img-caption></p></div><p>我們將這種 cookie 稱為third-party(第三方) Cookie。</p><p><strong>第三方 Cookie</strong> 除了用於 CSRF 攻擊，還可以用於用戶追蹤。比如，Facebook 在第三方網站插入一張看不見的圖片。</p><pre><code>&lt;img src="facebook.com" style="visibility:hidden;"&gt;</code></pre><p>瀏覽器加載上面代碼時，就會向 Facebook 發出帶有 Cookie 的請求，從而 Facebook 就會知道你是誰，訪問了什麼網站。</p><h1 class=pgc-h-arrow-right><strong>使用 SameSite 屬性</strong></h1><p>Cookie 的SameSite 屬性用來限制third-party Cookie，從而減少安全風險。它可以設置三個值。</p><ul><li>Strict</li><li>Lax</li><li>None</li></ul><p>Strict最為嚴格，完全禁止第三方 Cookie，跨站點時，任何情況下都不會發送 Cookie。換言之，只有當前網頁的 URL 與請求目標一致，才會帶上 Cookie。</p><pre><code>Set-Cookie: CookieName=CookieValue; SameSite=Strict;</code></pre><p>這個規則過於嚴格，可能造成非常不好的用戶體驗。比如，當前網頁有一個 GitHub 鏈接，用戶點擊跳轉就不會帶有 GitHub 的 Cookie，跳轉過去總是未登陸狀態。</p><p>Lax規則稍稍放寬，大多數情況也是不發送第三方 Cookie，但是導航到目標網址的 Get 請求除外。</p><pre><code>Set-Cookie: CookieName=CookieValue; SameSite=Lax;</code></pre><p>導航到目標網址的 GET 請求，只包括三種情況：鏈接，預加載請求，GET 表單。詳見下表。</p><div class=pgc-img><img alt="「必需知道」實用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f8c4f74cd6444e6f9bf8b6f044e6d646><p class=pgc-img-caption></p></div><p>設置了Strict或Lax以後，基本就杜絕了 CSRF 攻擊。當然，前提是用戶瀏覽器支持 SameSite 屬性。</p><p>Chrome 計劃將Lax變為默認設置。這時，網站可以選擇顯式關閉SameSite屬性，將其設為None。不過，前提是必須同時設置Secure屬性（Cookie 只能通過 HTTPS 協議發送），否則無效。</p><p>下面的設置無效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None</code></pre><p>下面的設置有效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None; Secure</code></pre><h1 class=pgc-h-arrow-right><strong>Cookies 和 認證</strong></h1><p>身份驗證是 web 開發中最具挑戰性的任務之一。關於這個主題似乎有很多困惑，因為JWT中的基於令牌的身份驗證似乎要取代“舊的”、可靠的模式，如基於會話的身份驗證。</p><p>來看看 cookie 在這裡扮演什麼角色。</p><h1 class=pgc-h-arrow-right><strong>基於會話的身份驗證</strong></h1><p>身份驗證是 cookie 最常見的用例之一。</p><p>當你訪問一個請求身份驗證的網站時，後端將通過<strong>憑據</strong>提交（例如通過表單）在後臺發送一個Set-Cookie標頭到前端。</p><p>型的會話 cookie 如下所示:</p><pre><code>Set-Cookie: sessionid=sty1z3kz11mpqxjv648mqwlx4ginpt6c; expires=Tue, 09 Jun 2020 15:46:52 GMT; HttpOnly; Max-Age=1209600; Path=/; SameSite=Lax</code></pre><p>這個Set-Cookie頭中，服務器可以包括一個名為session、session id或類似的cookie。</p><p>這是瀏覽器可以清楚看到的唯一標識符。每當通過身份驗證的用戶向後端請求新頁面時，瀏覽器就會發回會話cookie。</p><p>基於會話的身份驗證是有狀態的，因為後端必須跟蹤每個用戶的會話。這些會話的存儲可能是：</p><ul><li>數據庫</li><li>像 Redis 這樣的鍵/值存儲</li><li>文件系統</li></ul><p>在這三個會話存儲中，Redis 之類應優先於數據庫或文件系統。</p><p>請注意，基於會話的身份驗證與瀏覽器的會話存儲無關。</p><p>之所以稱為<strong>基於會話</strong>的會話，是因為用於用戶識別的相關數據存在於後端的會話存儲中，這與瀏覽器的會話存儲不同。</p><h1 class=pgc-h-arrow-right><strong>何時使用基於會話的身份驗證</strong></h1><p>只要能使用就使用它。基於會話的身份驗證是一種最簡單、安全、直接的網站身份驗證形式。默認情況下，它可以在Django等所有流行的web框架上使用。</p><p>但是，它的狀態特性也是它的主要缺點，特別是當網站是由負載均衡器提供服務時。在這種情況下，像粘貼會話，或者在集中的Redis存儲上存儲會話這樣的技術會有所幫助。</p><h1 class=pgc-h-arrow-right><strong>關於 JWT 的說明</strong></h1><p><strong>JWT</strong>是 JSON Web Tokens的縮寫，是一種身份驗證機制，近年來越來越流行。</p><p>JWT 非常適合單頁和移動應用程序，但它帶來了一系列新挑戰。想要針對API進行身份驗證的前端應用程序的典型流程如下：</p><ul><li>前端將憑證發送到後端</li><li>後端檢查憑證併發回令牌</li><li>前端在每個後續請求上帶上該令牌</li></ul><p>這種方法帶來的主要問題是：為了使用戶保持登錄狀態，我將該令牌存儲在前端的哪個地方？</p><p>對於前端開發來說，最自然的事情是將令牌保存在localStorage中。由於許多原因，這很糟糕。</p><p>localStorage很容易從 JS 代碼訪問，而且它很容易成為<strong>XSS</strong>攻擊的目標。</p><p>為了解決此問題，大多數開發人員都將<strong>JWT</strong>令牌保存在cookie中，以為HttpOnly和Secure可以保護cookie，至少可以免受XSS攻擊。</p><p>將 SameSite 設置為 strict 就可以完全保護 JWT免受CSRF攻擊</p><p>設置為SameSite = Strict的新SameSite屬性還將保護你的“熟化” JWT免受CSRF攻擊。但是，由於SameSite = Strict不會在跨域請求上發送cookie，因此，這也完全使JWT的用例無效。</p><p>那SameSite=Lax呢？此模式允許使用安全的HTTP方法（即GET，HEAD，OPTIONS和TRACE）將 cookie發送回去。POST 請求不會以任何一種方式傳輸 cookie。</p><p>實際上，將JWT標記存儲在cookie或localStorage中都不是好主意。</p><p>如果你確實要使用JWT而不是堅持使用基於會話的身份驗證並擴展會話存儲，則可能要使用帶有刷新令牌的JWT來保持用戶登錄。</p><h1 class=pgc-h-arrow-right><strong>總結</strong></h1><p>自1994年以來，HTTP cookie一直存在，它們無處不在。</p><p>Cookies是簡單的文本字符串，但可以通過<strong>Domain</strong>和Path對其權限進行控制，具有Secure的Cookie，只能通過 HTTP S進行傳輸，而可以使用 HttpOnly從 JS隱藏。</p><p>但是，對於所有預期的用途，cookie都可能使用戶暴露於攻擊和漏洞之中。</p><p>瀏覽器的供應商和Internet工程任務組（Internet Engineering Task Force）年復一年地致力於提高cookie的安全性，最近的一步是SameSite。</p><p>那麼，什麼才算是比較安全cookie？，如下幾點：</p><ul><li>僅使用 HTTPS</li><li>儘可能帶有 HttpOnly 屬性</li><li>正確的SameSite配置</li><li>不攜帶敏感數據</li></ul><p>人才們的 <strong>【三連】</strong> 就是小智不斷分享的最大動力，如果本篇博客有任何錯誤和建議，歡迎人才們留言，最後，謝謝大家的觀看。</p><hr><p>作者：valentinog 譯者：前端小智 來源：valentinog</p><p>原文：https://gizmodo.com/the-complete-guide-to-cookies-and-all-the-stuff-w-1794247382</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>實用</a></li><li><a>HTTP</a></li><li><a>cookie</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c8dddaa7.html alt="車頂預留小孔很實用 奧迪SUV車主們請注意" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/403a0000cf2a8c40c1c6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c8dddaa7.html title="車頂預留小孔很實用 奧迪SUV車主們請注意">車頂預留小孔很實用 奧迪SUV車主們請注意</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dacdca28.html alt=媽媽教的剪刀面做法，無保留分享，簡單又實用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e3e5ec81da04a70bf4d1fe077acb24c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dacdca28.html title=媽媽教的剪刀面做法，無保留分享，簡單又實用>媽媽教的剪刀面做法，無保留分享，簡單又實用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a2d512e5.html alt=6個實用電路圖，簡單易懂！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d4ccc825dea840e0bccda3481c8a96ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a2d512e5.html title=6個實用電路圖，簡單易懂！>6個實用電路圖，簡單易懂！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f35ba13a.html alt=12個實用的電路圖，熟練掌握了你就是初級電工了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8b97dc8eb0fd4558be06c6528dfe81b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f35ba13a.html title=12個實用的電路圖，熟練掌握了你就是初級電工了>12個實用的電路圖，熟練掌握了你就是初級電工了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03ac1cd8.html alt=11個最實用的Excel求和公式，各類求和情況都有模板了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1535796946527b7df391e10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03ac1cd8.html title=11個最實用的Excel求和公式，各類求和情況都有模板了！>11個最實用的Excel求和公式，各類求和情況都有模板了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce42a78b.html alt=實用經濟的小客廳全景聲4K家庭影院晒單 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fc1376d7a7e34c65b134f37430a33a87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce42a78b.html title=實用經濟的小客廳全景聲4K家庭影院晒單>實用經濟的小客廳全景聲4K家庭影院晒單</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c8d1ac6.html alt=防滑還帶耐磨層的新型地板，絕對實用！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ee487c89e3543c8ad923577ae6518a7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c8d1ac6.html title=防滑還帶耐磨層的新型地板，絕對實用！>防滑還帶耐磨層的新型地板，絕對實用！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/db890d60.html alt=2018年度最具實用價值的10個光學實驗經驗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f83c6e7c0b204acebb859b60ca4a5cb1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/db890d60.html title=2018年度最具實用價值的10個光學實驗經驗>2018年度最具實用價值的10個光學實驗經驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0597b78.html alt=自我保護早知道！實用乾貨幫你戰“疫” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RoyDw4jFfZipnT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0597b78.html title=自我保護早知道！實用乾貨幫你戰“疫”>自我保護早知道！實用乾貨幫你戰“疫”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67ee75de.html alt=「實用營商指南」企業被列入經營異常名錄，該咋辦？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67ee75de.html title=「實用營商指南」企業被列入經營異常名錄，該咋辦？>「實用營商指南」企業被列入經營異常名錄，該咋辦？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e582bbe8.html alt=3種乾花的製作方法，簡單又實用！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152998203374031197e03d3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e582bbe8.html title=3種乾花的製作方法，簡單又實用！>3種乾花的製作方法，簡單又實用！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b4e3cb5.html alt=5種超實用乾花製作方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f60989faa2b94085a8e54e27c5e6975d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b4e3cb5.html title=5種超實用乾花製作方法>5種超實用乾花製作方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55a37938.html alt=很實用的裝修問答(2) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55a37938.html title=很實用的裝修問答(2)>很實用的裝修問答(2)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d69a860.html alt=《實用知識》：汽車各部件英文縮寫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/46e70000a9a334d7255d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d69a860.html title=《實用知識》：汽車各部件英文縮寫>《實用知識》：汽車各部件英文縮寫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1531f919.html alt=超實用！50個非常實用的PS快捷鍵命令大全分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6d11d0bcd997456b828eb55bc85fa4dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1531f919.html title=超實用！50個非常實用的PS快捷鍵命令大全分享>超實用！50個非常實用的PS快捷鍵命令大全分享</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>