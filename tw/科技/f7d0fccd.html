<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>linux服務器開發-網絡編程 | 极客快訊</title><meta property="og:title" content="linux服務器開發-網絡編程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/151c99ef-10af-4e27-9913-12b1b86d777a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7d0fccd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7d0fccd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7d0fccd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7d0fccd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7d0fccd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7d0fccd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7d0fccd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7d0fccd.html><meta property="article:published_time" content="2020-11-14T21:05:10+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:10+08:00"><meta name=Keywords content><meta name=description content="linux服務器開發-網絡編程"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f7d0fccd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>linux服務器開發-網絡編程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>原文轉載於：https://cloud.tencent.com/developer/article/1075034</p></blockquote><div class=pgc-img><img alt=linux服務器開發-網絡編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/151c99ef-10af-4e27-9913-12b1b86d777a><p class=pgc-img-caption></p></div><p>半關閉</p><ul class=ul-level-0><li>當TCP鏈接中A發送FIN請求關閉，B端迴應ACK後（A端進入FIN_WAIT_2狀態），B沒有立即發送FIN給A時，A方處在半鏈接狀態，此時A可以接收B發送的數據，但是A已不能再向B發送數據。</li><li>從程序的角度，可以使用API來控制實現半連接狀態。</li></ul><ol start=1><li>#include &lt;sys/socket.h></li><li>int shutdown(int sockfd, int how);</li><li>sockfd: 需要關閉的socket的描述符</li><li>how: 允許為shutdown操作選擇以下幾種方式:</li><li>SHUT_RD(0)： 關閉sockfd上的讀功能，此選項將不允許sockfd進行讀操作。</li><li>該套接字不再接受數據，任何當前在套接字接受緩衝區的數據將被無聲的丟棄掉。</li><li>SHUT_WR(1): 關閉sockfd的寫功能，此選項將不允許sockfd進行寫操作。進程不能在對此套接字發出寫操作。</li><li>SHUT_RDWR(2): 關閉sockfd的讀寫功能。相當於調用shutdown兩次：首先是以SHUT_RD,然後以SHUT_WR。</li></ol><p>複製代碼</p><ul class=ul-level-0><li>使用close中止一個連接，但它只是減少描述符的引用計數，並不直接關閉連接，只有當描述符的引用計數為0時才關閉連接。</li><li>shutdown不考慮描述符的引用計數，直接關閉描述符。也可選擇中止一個方向的連接，只中止讀或只中止寫。</li><li>注意: 1、如果有多個進程共享一個套接字，close每被調用一次，計數減1，直到計數為0時，也就是所用進程都調用了close，套接字將被釋放。2、在多進程中如果一個進程調用了shutdown(sfd, SHUT_RDWR)後，其它的進程將無法進行通信。但，如果一個進程close(sfd)將不會影響到其它進程。</li></ul><p>2MSL</p><ul class=ul-level-0><li>2MSL (Maximum Segment Lifetime) TIME_WAIT狀態的存在有兩個理由： （1）讓4次握手關閉流程更加可靠；4次握手的最後一個ACK是是由主動關閉方發送出去的，若這個ACK丟失，被動關閉方會再次發一個FIN過來。若主動關閉方能夠保持一個2MSL的TIME_WAIT狀態，則有更大的機會讓丟失的ACK被再次發送出去。（2）防止lost duplicate對後續新建正常鏈接的傳輸造成破壞。lost uplicate在實際的網絡中非常常見，經常是由於路由器產生故障，路徑無法收斂，導致一個packet在路由器A，B，C之間做類似死循環的跳轉。IP頭部有個TTL，限制了一個包在網絡中的最大跳數，因此這個包有兩種命運，要麼最後TTL變為0，在網絡中消失；要麼TTL在變為0之前路由器路徑收斂，它憑藉剩餘的TTL跳數終於到達目的地。但非常可惜的是TCP通過超時重傳機制在早些時候發送了一個跟它一模一樣的包，並先於它達到了目的地，因此它的命運也就註定被TCP協議棧拋棄。</li><li>另外一個概念叫做incarnation connection，指跟上次的socket pair一摸一樣的新連接，叫做incarnation of previous connection。lost uplicate加上incarnation connection，則會對我們的傳輸造成致命的錯誤。</li><li>TCP是流式的，所有包到達的順序是不一致的，依靠序列號由TCP協議棧做順序的拼接；假設一個incarnation connection這時收到的seq=1000, 來了一個lost duplicate為seq=1000，len=1000, 則TCP認為這個lost duplicate合法，並存放入了receive buffer，導致傳輸出現錯誤。通過一個2MSL TIME_WAIT狀態，確保所有的lost duplicate都會消失掉，避免對新連接造成錯誤。</li><li>該狀態為什麼設計在主動關閉這一方： （1）發最後ACK的是主動關閉一方。（2）只要有一方保持TIME_WAIT狀態，就能起到避免incarnation connection在2MSL內的重新建立，不需要兩方都有。</li><li>如何正確對待2MSL TIME_WAIT?</li><li>RFC要求socket pair在處於TIME_WAIT時，不能再起一個incarnation connection。但絕大部分TCP實現，強加了更為嚴格的限制。在2MSL等待期間，socket中使用的本地端口在默認情況下不能再被使用。</li><li>若A 10.234.5.5 : 1234和B 10.55.55.60 : 6666建立了連接，A主動關閉，那麼在A端只要port為1234，無論對方的port和ip是什麼，都不允許再起服務。這甚至比RFC限制更為嚴格，RFC僅僅是要求socket pair不一致，而實現當中只要這個port處於TIME_WAIT，就不允許起連接。這個限制對主動打開方來說是無所謂的，因為一般用的是臨時端口；但對於被動打開方，一般是server，就悲劇了，因為server一般是熟知端口。比如http，一般端口是80，不可能允許這個服務在2MSL內不能起來。</li><li>解決方案是給服務器的socket設置SO_REUSEADDR選項，這樣的話就算熟知端口處於TIME_WAIT狀態，在這個端口上依舊可以將服務啟動。當然，雖然有了SO_REUSEADDR選項，但sockt pair這個限制依舊存在。比如上面的例子，A通過SO_REUSEADDR選項依舊在1234端口上起了監聽，但這時我們若是從B通過6666端口去連它，TCP協議會告訴我們連接失敗，原因為Address already in use.</li><li>RFC 793中規定MSL為2分鐘，實際應用中常用的是30秒，1分鐘和2分鐘等。</li><li>RFC (Request For Comments)，是一系列以編號排定的文件。收集了有關因特網相關資訊，以及UNIX和因特網社群的軟件文件。</li></ul><p>程序設計中的問題</p><ul class=ul-level-0><li>做一個測試，首先啟動server，然後啟動client，用Ctrl-C終止server，馬上再運行server，運行結果：</li></ul><ol start=1><li>itcast$ ./server</li><li>bind error: Address already in use</li></ol><ul class=ul-level-0><li>這是因為，雖然server的應用程序終止了，但TCP協議層的連接並沒有完全斷開，因此不能再次監聽同樣的server端口。我們用netstat命令查看一下：</li></ul><p>itcast$ netstat -apn |grep 6666 tcp 1 0 192.168.1.11:38103 192.168.1.11:6666 CLOSE_WAIT 3525/client tcp 0 0 192.168.1.11:6666 192.168.1.11:38103 FIN_WAIT2 -</p><ul class=ul-level-0><li>server終止時，socket描述符會自動關閉併發FIN段給client，client收到FIN後處於CLOSE_WAIT狀態，但是client並沒有終止，也沒有關閉socket描述符，因此不會發FIN給server，因此server的TCP連接處於FIN_WAIT2狀態。</li><li>現在用Ctrl-C把client也終止掉，再觀察現象： itcast$ netstat -apn |grep 6666 tcp 0 0 192.168.1.11:6666 192.168.1.11:38104 TIME_WAIT - itcast$ ./server bind error: Address already in use</li><li>client終止時自動關閉socket描述符，server的TCP連接收到client發的FIN段後處於TIME_WAIT狀態。TCP協議規定，主動關閉連接的一方要處於TIME_WAIT狀態，等待兩個MSL（maximum segment lifetime）的時間後才能回到CLOSED狀態，因為我們先Ctrl-C終止了server，所以server是主動關閉連接的一方，在TIME_WAIT期間仍然不能再次監聽同樣的server端口。</li><li>MSL在RFC 1122中規定為兩分鐘，但是各操作系統的實現不同，在Linux上一般經過半分鐘後就可以再次啟動server了。至於為什麼要規定TIME_WAIT的時間，可參考UNP 2.7節。</li></ul><p>端口複用</p><ul class=ul-level-0><li>在server的TCP連接沒有完全斷開之前不允許重新監聽是不合理的。因為，TCP連接沒有完全斷開指的是connfd（127.0.0.1:6666）沒有完全斷開，而我們重新監聽的是lis-tenfd（0.0.0.0:6666），雖然是佔用同一個端口，但IP地址不同，connfd對應的是與某個客戶端通訊的一個具體的IP地址，而listenfd對應的是wildcard address。解決這個問題的方法是使用setsockopt()設置socket描述符的選項SO_REUSEADDR為1，表示允許創建端口號相同但IP地址不同的多個socket描述符。</li><li>在server代碼的socket()和bind()調用之間插入如下代碼： int opt = 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));</li><li>有關setsockopt可以設置的其它選項請參考UNP第7章。</li></ul><p>TCP異常斷開心跳檢測機制</p><ul class=ul-level-0><li>在TCP網絡通信中，經常會出現客戶端和服務器之間的非正常斷開，需要實時檢測查詢鏈接狀態。常用的解決方法就是在程序中加入心跳機制。</li><li>Heart-Beat線程</li><li>這個是最常用的簡單方法。在接收和發送數據時個人設計一個守護進程(線程)，定時發送Heart-Beat包，客戶端/服務器收到該小包後，立刻返回相應的包即可檢測對方是否實時在線。</li><li>該方法的好處是通用，但缺點就是會改變現有的通訊協議！大家一般都是使用業務層心跳來處理，主要是靈活可控。</li><li>UNIX網絡編程不推薦使用SO_KEEPALIVE來做心跳檢測，還是在業務層以心跳包做檢測比較好，也方便控制。</li></ul><p>設置TCP屬性</p><ul class=ul-level-0><li>SO_KEEPALIVE 保持連接檢測對方主機是否崩潰，避免（服務器）永遠阻塞於TCP連接的輸入。設置該選項後，如果2小時內在此套接口的任一方向都沒有數據交換，TCP就自動給對方發一個保持存活探測分節(keepalive probe)。這是一個對方必須響應的TCP分節.它會導致以下三種情況：對方接收一切正常：以期望的ACK響應。2小時後，TCP將發出另一個探測分節。對方已崩潰且已重新啟動：以RST響應。套接口的待處理錯誤被置為ECONNRESET，套接 口本身則被關閉。對方無任何響應：源自berkeley的TCP發送另外8個探測分節，相隔75秒一個，試圖得到一個響應。在發出第一個探測分節11分鐘 15秒後若仍無響應就放棄。套接口的待處理錯誤被置為ETIMEOUT，套接口本身則被關閉。如ICMP錯誤是“host unreachable(主機不可達)”，說明對方主機並沒有崩潰，但是不可達，這種情況下待處理錯誤被置為EHOSTUNREACH。</li><li>根據上面的介紹我們可以知道對端以一種非優雅的方式斷開連接的時候，我們可以設置SO_KEEPALIVE屬性使得我們在2小時以後發現對方的TCP連接是否依然存在。 keepAlive = 1; setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&keepAlive, sizeof(keepAlive));</li><li>如果我們不能接受如此之長的等待時間，從TCP-Keepalive-HOWTO上可以知道一共有兩種方式可以設置，一種是修改內核關於網絡方面的 配置參數，另外一種就是SOL_TCP字段的TCP_KEEPIDLE， TCP_KEEPINTVL， TCP_KEEPCNT三個選項。</li><li>1.The tcp_keepidle parameter specifies the interval of inactivity that causes TCP to generate a KEEPALIVE transmission for an application that requests them. tcp_keepidle defaults to 14400 (two hours).</li></ul><ol start=1><li>/*開始首次KeepAlive探測前的TCP空閉時間 */</li></ol><p>2.The tcp_keepintvl parameter specifies the interval between the nine retriesthat are attempted if a KEEPALIVE transmission is not acknowledged. tcp_keep ntvldefaults to 150 (75 seconds).</p><ol start=1><li>/* 兩次KeepAlive探測間的時間間隔 */</li></ol><p>3.The tcp_keepcnt option specifies the maximum number of keepalive probes tobe sent. The value of TCP_KEEPCNT is an integer value between 1 and n, where n s the value of the systemwide tcp_keepcnt parameter.</p><pre>/* 判定斷開前的KeepAlive探測次數*/int keepIdle = 1000;int keepInterval = 10;int keepCount = 10;Setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));Setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));Setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount));</pre><ul class=ul-level-0><li>SO_KEEPALIVE設置空閒2小時才發送一個“保持存活探測分節”，不能保證實時檢測。對於判斷網絡斷開時間太長，對於需要及時響應的程序不太適應。</li><li>當然也可以修改時間間隔參數，但是會影響到所有打開此選項的套接口！關聯了完成端口的socket可能會忽略掉該套接字選項。</li></ul><p>網絡名詞術語解析路由(route)</p><ul class=ul-level-0><li>路由（名詞） 數據包從源地址到目的地址所經過的路徑，由一系列路由節點組成。</li><li>路由（動詞） 某個路由節點為數據包選擇投遞方向的選路過程。</li></ul><p>路由器工作原理</p><ul class=ul-level-0><li>路由器（Router）是連接因特網中各局域網、廣域網的設備，它會根據信道的情況自動選擇和設定路由，以最佳路徑，按前後順序發送信號的設備。</li><li>傳統地，路由器工作於OSI七層協議中的第三層，其主要任務是接收來自一個網絡接口的數據包，根據其中所含的目的地址，決定轉發到下一個目的地址。因此，路由器首先得在轉發路由表中查找它的目的地址，若找到了目的地址，就在數據包的幀格前添加下一個MAC地址，同時IP數據包頭的TTL（Time To Live）域也開始減數， 並重新計算校驗和。當數據包被送到輸出端口時，它需要按順序等待，以便被傳送到輸出鏈路上。</li><li>路由器在工作時能夠按照某種路由通信協議查找設備中的路由表。如果到某一特定節點有一條以上的路徑，則基本預先確定的路由準則是選擇最優（或最經濟）的傳輸路徑。由於各種網絡段和其相互連接情況可能會因環境變化而變化，因此路由情況的信息一般也按所使用的路由信息協議的規定而定時更新。</li><li>網絡中，每個路由器的基本功能都是按照一定的規則來動態地更新它所保持的路由表，以便保持路由信息的有效性。為了便於在網絡間傳送報文，路由器總是先按照預定的規則把較大的數據分解成適當大小的數據包，再將這些數據包分別通過相同或不同路徑發送出去。當這些數據包按先後秩序到達目的地後，再把分解的數據包按照一定順序包裝成原有的報文形式。路由器的分層尋址功能是路由器的重要功能之一，該功能可以幫助具有很多節點站的網絡來存儲尋址信息，同時還能在網絡間截獲發送到遠地網段的報文，起轉發作用；選擇最合理的路由，引導通信也是路由器基本功能；多協議路由器還可以連接使用不同通信協議的網絡段，成為不同通信協議網絡段之間的通信平臺。</li><li>路由和交換之間的主要區別就是交換髮生在OSI參考模型第二層（數據鏈路層），而路由發生在第三層，即網絡層。這一區別決定了路由和交換在移動信息的過程 中需使用不同的控制信息，所以兩者實現各自功能的方式是不同的。</li></ul><p>路由表(Routing Table)</p><ul class=ul-level-0><li>在計算機網絡中，路由表或稱路由擇域信息庫（RIB）是一個存儲在路由器或者聯網計算機中的電子表格（文件）或類數據庫。路由表存儲著指向特定網絡地址的路徑。</li></ul><p>路由條目</p><ul class=ul-level-0><li>路由表中的一行，每個條目主要由目的網絡地址、子網掩碼、下一跳地址、發送接口四部分組成，如果要發送的數據包的目的網絡地址匹配路由表中的某一行，就按規定的接口發送到下一跳地址。</li></ul><p>缺省路由條目</p><ul class=ul-level-0><li>路由表中的最後一行，主要由下一跳地址和發送接口兩部分組成，當目的地址與路由表中其它行都不匹配時，就按缺省路由條目規定的接口發送到下一跳地址。</li></ul><p>路由節點</p><ul class=ul-level-0><li>一個具有路由能力的主機或路由器，它維護一張路由表，通過查詢路由表來決定向哪個接口發送數據包。</li></ul><p>以太網交換機工作原理</p><ul class=ul-level-0><li>以太網交換機是基於以太網傳輸數據的交換機，以太網採用共享總線型傳輸媒體方式的局域網。以太網交換機的結構是每個端口都直接與主機相連，並且一般都工作在全雙工方式。交換機能同時連通許多對端口，使每一對相互通信的主機都能像獨佔通信媒體那樣，進行無衝突地傳輸數據。</li><li>以太網交換機工作於OSI網絡參考模型的第二層（即數據鏈路層），是一種基於MAC（Media Access Control，介質訪問控制）地址識別、完成以太網數據幀轉發的網絡設備。</li></ul><p>hub工作原理</p><ul class=ul-level-0><li>集線器實際上就是中繼器的一種，其區別僅在於集線器能夠提供更多的端口服務，所以集線器又叫多口中繼器。</li><li>集線器功能是隨機選出某一端口的設備，並讓它獨佔全部帶寬，與集線器的上聯設備（交換機、路由器或服務器等）進行通信。從Hub的工作方式可以看出，它在網絡中只起到信號放大和重發作用，其目的是擴大網絡的傳輸範圍，而不具備信號的定向傳送能力，是—個標準的共享式設備。其次是Hub只與它的上聯設備(如上層Hub、交換機或服務器)進行通信，同層的各端口之間不會直接進行通信，而是通過上聯設備再將信息廣播到所有端口上。 由此可見，即使是在同一Hub的不同兩個端口之間進行通信，都必須要經過兩步操作：</li><li>第一步是將信息上傳到上聯設備；</li><li>第二步是上聯設備再將該信息廣播到所有端口上。</li></ul><p>半雙工/全雙工</p><ul class=ul-level-0><li>Full-duplex（全雙工）全雙工是在通道中同時雙向數據傳輸的能力。</li><li>Half-duplex（半雙工）在通道中同時只能沿著一個方向傳輸數據。</li></ul><p>DNS服務器</p><ul class=ul-level-0><li>DNS 是域名系統 (Domain Name System) 的縮寫，是因特網的一項核心服務，它作為可以將域名和IP地址相互映射的一個分佈式數據庫，能夠使人更方便的訪問互聯網，而不用去記住能夠被機器直接讀取的IP地址串。</li><li>它是由解析器以及域名服務器組成的。域名服務器是指保存有該網絡中所有主機的域名和對應IP地址，並具有將域名轉換為IP地址功能的服務器。</li></ul><p>局域網(LAN)</p><ul class=ul-level-0><li>local area network，一種覆蓋一座或幾座大樓、一個校園或者一個廠區等地理區域的小範圍的計算機網。</li><li>1、覆蓋的地理範圍較小，只在一個相對獨立的局部範圍內聯，如一座或集中的建築群內。</li><li>2、使用專門鋪設的傳輸介質進行聯網，數據傳輸速率高（10Mb/s～10Gb/s）</li><li>3、通信延遲時間短，可靠性較高</li><li>4、局域網可以支持多種傳輸介質</li></ul><p>廣域網(WAN)</p><ul class=ul-level-0><li>wide area network，一種用來實現不同地區的局域網或城域網的互連，可提供不同地區、城市和國家之間的計算機通信的遠程計算機網。</li><li>覆蓋的範圍比局域網（LAN）和城域網（MAN）都廣。廣域網的通信子網主要使用分組交換技術。</li><li>廣域網的通信子網可以利用公用分組交換網、衛星通信網和無線分組交換網，它將分佈在不同地區的局域網或計算機系統互連起來，達到資源共享的目的。如互聯網是世界範圍內最大的廣域網。</li><li>1、適應大容量與突發性通信的要求；</li><li>2、適應綜合業務服務的要求；</li><li>3、開放的設備接口與規範化的協議；</li><li>4、完善的通信服務與網絡管理。</li></ul><p>端口</p><ul class=ul-level-0><li>邏輯意義上的端口，一般是指TCP/IP協議中的端口，端口號的範圍從0到65535，比如用於瀏覽網頁服務的80端口，用於FTP服務的21端口等等。</li><li>1、端口號小於256的定義為常用端口，服務器一般都是通過常用端口號來識別的。</li><li>2、客戶端只需保證該端口號在本機上是惟一的就可以了。客戶端口號因存在時間很短暫又稱臨時端口號；</li><li>3、大多數TCP/IP實現給臨時端口號分配1024—5000之間的端口號。大於5000的端口號是為其他服務器預留的。</li><li>我們應該在自定義端口時，避免使用well-known的端口。如：80、21等等。</li></ul><p>MTU</p><ul class=ul-level-0><li>MTU:通信術語 最大傳輸單元（Maximum Transmission Unit，MTU）</li><li>是指一種通信協議的某一層上面所能通過的最大數據包大小（以字節為單位）。最大傳輸單元這個參數通常與通信接口有關（網絡接口卡、串口等）。</li><li>以下是一些協議的MTU：</li></ul><ol start=1><li>FDDI協議：4352字節</li><li>以太網（Ethernet）協議：1500字節</li><li>PPPoE（ADSL）協議：1492字節</li><li>X.25協議（Dial Up/Modem）：576字節</li><li>Point-to-Point：4470字節</li></ol><p>複製代碼</p><p>常見網絡知識面試題</p><ul class=ul-level-0><li>1、TCP如何建立鏈接</li><li>2、TCP如何通信</li><li>3、TCP如何關閉鏈接</li><li>4、什麼是滑動窗口</li><li>5、什麼是半關閉</li><li>6、局域網內兩臺機器如何利用TCP/IP通信</li><li>7、internet上兩臺主機如何進行通信</li><li>8、如何在internet上識別唯一一個進程 答：通過“IP地址+端口號”來區分不同的服務</li><li>9、為什麼說TCP是可靠的鏈接，UDP不可靠</li><li>10、路由器和交換機的區別</li><li>11、點到點，端到端</li></ul><p>Socket編程套接字概念</p><ul class=ul-level-0><li>Socket本身有“插座”的意思，在Linux環境下，用於表示進程間網絡通信的特殊文件類型。本質為內核藉助緩衝區形成的偽文件。</li><li>既然是文件，那麼理所當然的，我們可以使用文件描述符引用套接字。與管道類似的，Linux系統將其封裝成文件的目的是為了統一接口，使得讀寫套接字和讀寫文件的操作一致。區別是管道主要應用於本地進程間通信，而套接字多應用於網絡進程間數據的傳遞。</li><li>套接字的內核實現較為複雜，不宜在學習初期深入學習。</li><li>在TCP/IP協議中，“IP地址+TCP或UDP端口號”唯一標識網絡通訊中的一個進程。“IP地址+端口號”就對應一個socket。欲建立連接的兩個進程各自有一個socket來標識，那麼這兩個socket組成的socket pair就唯一標識一個連接。因此可以用Socket來描述網絡連接的一對一關係。</li><li>套接字通信原理如下圖所示：</li></ul><div class=pgc-img><img alt=linux服務器開發-網絡編程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c788bd2fcc2426abeed179095965ca7><p class=pgc-img-caption></p></div><ul class=ul-level-0><li>在網絡通信中，套接字一定是成對出現的。一端的發送緩衝區對應對端的接收緩衝區。我們使用同一個文件描述符索發送緩衝區和接收緩衝區。</li><li>TCP/IP協議最早在BSD UNIX上實現，為TCP/IP協議設計的應用層編程接口稱為socket API。本章的主要內容是socket API，主要介紹TCP協議的函數接口，最後介紹UDP協議和UNIX Domain Socket的函數接口。</li></ul><div class=pgc-img><img alt=linux服務器開發-網絡編程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/89b92c004e954c47b43363e4d9ae6580><p class=pgc-img-caption></p></div><p>預備知識網絡字節序</p><ul class=ul-level-0><li>我們已經知道，內存中的多字節數據相對於內存地址有大端和小端之分，磁盤文件中的多字節數據相對於文件中的偏移地址也有大端小端之分。網絡數據流同樣有大端小端之分，那麼如何定義網絡數據流的地址呢？發送主機通常將發送緩衝區中的數據按內存地址從低到高的順序發出，接收主機把從網絡上接到的字節依次保存在接收緩衝區中，也是按內存地址從低到高的順序保存，因此，網絡數據流的地址應這樣規定：先發出的數據是低地址，後發出的數據是高地址。</li><li>TCP/IP協議規定，網絡數據流應採用大端字節序，即低地址高字節。例如上一節的UDP段格式，地址0-1是16位的源端口號，如果這個端口號是1000（0x3e8），則地址0是0x03，地址1是0xe8，也就是先發0x03，再發0xe8，這16位在發送主機的緩衝區中也應該是低地址存0x03，高地址存0xe8。但是，如果發送主機是小端字節序的，這16位被解釋成0xe803，而不是1000。因此，發送主機把1000填到發送緩衝區之前需要做字節序的轉換。同樣地，接收主機如果是小端字節序的，接到16位的源端口號也要做字節序的轉換。如果主機是大端字節序的，發送和接收都不需要做轉換。同理，32位的IP地址也要考慮網絡字節序和主機字節序的問題。</li><li>為使網絡程序具有可移植性，使同樣的C代碼在大端和小端計算機上編譯後都能正常運行，可以調用以下庫函數做網絡字節序和主機字節序的轉換。</li></ul><pre>#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort);</pre><ul class=ul-level-0><li>h表示host，n表示network，l表示32位長整數，s表示16位短整數。</li><li>如果主機是小端字節序，這些函數將參數做相應的大小端轉換然後返回，如果主機是大端字節序，這些函數不做轉換，將參數原封不動地返回。</li></ul><p>IP地址轉換函數</p><ul class=ul-level-0><li>早期：</li></ul><pre>#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;int inet_aton(const char *cp, struct in_addr *inp);in_addr_t inet_addr(const char *cp);char *inet_ntoa(struct in_addr in);只能處理IPv4的ip地址不可重入函數注意參數是struct in_addr</pre><pre>#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *src, void *dst);const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);支持IPv4和IPv6可重入函數其中inet_pton和inet_ntop不僅可以轉換IPv4的in_addr，還可以轉換IPv6的in6_addr。因此函數接口是void *addrptr。</pre><p>sockaddr數據結構</p><ul class=ul-level-0><li>strcut sockaddr 很多網絡編程函數誕生早於IPv4協議，那時候都使用的是sockaddr結構體,為了向前兼容，現在sockaddr退化成了（void *）的作用，傳遞一個地址給函數，至於這個函數是sockaddr_in還是sockaddr_in6，由地址族確定，然後函數內部再強制類型轉化為所需的地址類型。</li></ul><div class=pgc-img><img alt=linux服務器開發-網絡編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fdbf8f54e17245ee98c4dd8deee27f8c><p class=pgc-img-caption></p></div><pre>sockaddr數據結構struct sockaddr { sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */};</pre><p>使用 sudo grep -r "struct sockaddr_in {" /usr 命令可查看到struct sockaddr_in結構體的定義。一般其默認的存儲位置：/usr/include/linux/in.h 文件中。</p><pre>struct sockaddr_in { __kernel_sa_family_t sin_family; /* Address family */ 地址結構類型 __be16 sin_port; /* Port number */ 端口號 struct in_addr sin_addr; /* Internet address */ IP地址 /* Pad to size of `struct sockaddr'. */ unsigned char __pad[__SOCK_SIZE__ - sizeof(short int) - sizeof(unsigned short int) - sizeof(struct in_addr)];};struct in_addr { /* Internet address. */ __be32 s_addr;};struct sockaddr_in6 { unsigned short int sin6_family; /* AF_INET6 */ __be16 sin6_port; /* Transport layer port # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ __u32 sin6_scope_id; /* scope id (new in RFC2553) */};struct in6_addr { union { __u8 u6_addr8[16]; __be16 u6_addr16[8]; __be32 u6_addr32[4]; } in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32};#define UNIX_PATH_MAX 108 struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */};</pre><p>Pv4和IPv6的地址格式定義在netinet/in.h中，IPv4地址用sockaddr_in結構體表示，包括16位端口號和32位IP地址，IPv6地址用sockaddr_in6結構體表示，包括16位端口號、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定義在sys/un.h中，用sock-addr_un結構體表示。各種socket地址結構體的開頭都是相同的，前16位表示整個結構體的長度（並不是所有UNIX的實現都有長度字段，如Linux就沒有），後16位表示地址類型。IPv4、IPv6和Unix Domain Socket的地址類型分別定義為常數AF_INET、AF_INET6、AF_UNIX。這樣，只要取得某種sockaddr結構體的首地址，不需要知道具體是哪種類型的sockaddr結構體，就可以根據地址類型字段確定結構體中的內容。因此，socket API可以接受各種類型的sockaddr結構體指針做參數，例如bind、accept、connect等函數，這些函數的參數應該設計成void 類型以便接受各種類型的指針，但是sock API的實現早於ANSI C標準化，那時還沒有void 類型，因此這些函數的參數都用struct sockaddr *類型表示，在傳遞參數之前要強制類型轉換一下，例如：</p><ol start=1><li>struct sockaddr_in servaddr;</li><li>bind(listen_fd, (struct sockaddr *)&servaddr, sizeof(servaddr)); /* initialize servaddr */</li></ol><p>複製代碼</p><p>網絡套接字函數</p><ul class=ul-level-0><li>socket模型創建流程圖</li></ul><div class=pgc-img><img alt=linux服務器開發-網絡編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/074e31bba0884a56a9101b7e87ef45bc><p class=pgc-img-caption></p></div><ul class=ul-level-0><li>socket函數</li></ul><pre>#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol);domain: AF_INET 這是大多數用來產生socket的協議，使用TCP或UDP來傳輸，用IPv4的地址 AF_INET6 與上面類似，不過是來用IPv6的地址 AF_UNIX 本地協議，使用在Unix和Linux系統上，一般都是當客戶端和服務器在同一臺及其上的時候使用type: SOCK_STREAM 這個協議是按照順序的、可靠的、數據完整的基於字節流的連接。這是一個使用最多的socket類型，這個socket是使用TCP來進行傳輸。 SOCK_DGRAM 這個協議是無連接的、固定長度的傳輸調用。該協議是不可靠的，使用UDP來進行它的連接。 SOCK_SEQPACKET該協議是雙線路的、可靠的連接，發送固定長度的數據包進行傳輸。必須把這個包完整的接受才能進行讀取。 SOCK_RAW socket類型提供單一的網絡訪問，這個socket類型使用ICMP公共協議。（ping、traceroute使用該協議） SOCK_RDM 這個類型是很少使用的，在大部分的操作系統上沒有實現，它是提供給數據鏈路層使用，不保證數據包的順序protocol: 傳0 表示使用默認協議。返回值： 成功：返回指向新創建的socket的文件描述符，失敗：返回-1，設置errno</pre><ul class=ul-level-0><li>socket()打開一個網絡通訊端口，如果成功的話，就像open()一樣返回一個文件描述符，應用程序可以像讀寫文件一樣用read/write在網絡上收發數據，如果socket()調用出錯則返回-1。對於IPv4，domain參數指定為AF_INET。對於TCP協議，type參數指定為SOCK_STREAM，表示面向流的傳輸協議。如果是UDP協議，則type參數指定為SOCK_DGRAM，表示面向數據報的傳輸協議。protocol參數的介紹從略，指定為0即可。</li><li>bind函數</li></ul><pre>#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd： socket文件描述符addr: 構造出IP地址加端口號addrlen: sizeof(addr)長度返回值： 成功返回0，失敗返回-1, 設置errno</pre><ul class=ul-level-0><li>服務器程序所監聽的網絡地址和端口號通常是固定不變的，客戶端程序得知服務器程序的地址和端口號後就可以向服務器發起連接，因此服務器需要調用bind綁定一個固定的網絡地址和端口號。</li><li>bind()的作用是將參數sockfd和addr綁定在一起，使sockfd這個用於網絡通訊的文件描述符監聽addr所描述的地址和端口號。前面講過，struct sockaddr *是一個通用指針類型，addr參數實際上可以接受多種協議的sockaddr結構體，而它們的長度各不相同，所以需要第三個參數addrlen指定結構體的長度。如：</li></ul><pre>struct sockaddr_in servaddr;bzero(&amp;servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);servaddr.sin_port = htons(6666);</pre><ul class=ul-level-0><li>首先將整個結構體清零，然後設置地址類型為AF_INET，網絡地址為INADDR_ANY，這個宏表示本地的任意IP地址，因為服務器可能有多個網卡，每個網卡也可能綁定多個IP地址，這樣設置可以在所有的IP地址上監聽，直到與某個客戶端建立了連接時才確定下來到底用哪個IP地址，端口號為6666。</li></ul><pre>listen函數#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int listen(int sockfd, int backlog);sockfd: socket文件描述符backlog: 排隊建立3次握手隊列和剛剛建立3次握手隊列的鏈接數和</pre><p>查看系統默認backlog</p><ol start=1><li>cat /proc/sys/net/ipv4/tcp_max_syn_backlog</li></ol><p>典型的服務器程序可以同時服務於多個客戶端，當有客戶端發起連接時，服務器調用的accept()返回並接受這個連接，如果有大量的客戶端發起連接而服務器來不及處理，尚未accept的客戶端就處於連接等待狀態，listen()聲明sockfd處於監聽狀態，並且最多允許有backlog個客戶端處於連接待狀態，如果接收到更多的連接請求就忽略。listen()成功返回0，失敗返回-1。 accept函數</p><pre>#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockdf: socket文件描述符addr: 傳出參數，返回鏈接客戶端地址信息，含IP地址和端口號addrlen: 傳入傳出參數（值-結果）,傳入sizeof(addr)大小，函數返回時返回真正接收到地址結構體的大小返回值： 成功返回一個新的socket文件描述符，用於和客戶端通信，失敗返回-1，設置errno</pre><pre>while (1) { cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); n = read(connfd, buf, MAXLINE); ...... close(connfd);}</pre><ul class=ul-level-0><li>整個是一個while死循環，每次循環處理一個客戶端連接。由於cliaddr_len是傳入傳出參數，每次調用accept()之前應該重新賦初值。accept()的參數listenfd是先前的監聽文件描述符，而accept()的返回值是另外一個文件描述符connfd，之後與客戶端之間就通過這個connfd通訊，最後關閉connfd斷開連接，而不關閉listenfd，再次回到循環開頭listenfd仍然用作accept的參數。accept()成功返回一個文件描述符，出錯返回-1。</li><li>connect函數</li></ul><pre>#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockdf: socket文件描述符addr: 傳入參數，指定服務器端地址信息，含IP地址和端口號addrlen: 傳入參數,傳入sizeof(addr)大小返回值： 成功返回0，失敗返回-1，設置errno</pre><ul class=ul-level-0><li>客戶端需要調用connect()連接服務器，connect和bind的參數形式一致，區別在於bind的參數是自己的地址，而connect的參數是對方的地址。connect()成功返回0，出錯返回-1。</li></ul><p>C/S模型-TCP</p><ul class=ul-level-0><li>下圖是基於TCP協議的客戶端/服務器程序的一般流程：</li></ul><div class=pgc-img><img alt=linux服務器開發-網絡編程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cb2b8a9a23764dae859f7c667b60f9a8><p class=pgc-img-caption></p></div><ul class=ul-level-0><li>服務器調用socket()、bind()、listen()完成初始化後，調用accept()阻塞等待，處於監聽端口的狀態，客戶端調用socket()初始化後，調用connect()發出SYN段並阻塞等待服務器應答，服務器應答一個SYN-ACK段，客戶端收到後從connect()返回，同時應答一個ACK段，服務器收到後從accept()返回。</li><li>數據傳輸的過程： 建立連接後，TCP協議提供全雙工的通信服務，但是一般的客戶端/服務器程序的流程是由客戶端主動發起請求，服務器被動處理請求，一問一答的方式。因此，服務器從accept()返回後立刻調用read()，讀socket就像讀管道一樣，如果沒有數據到達就阻塞等待，這時客戶端調用write()發送請求給服務器，服務器收到後從read()返回，對客戶端的請求進行處理，在此期間客戶端調用read()阻塞等待服務器的應答，服務器調用write()將處理結果發回給客戶端，再次調用read()阻塞等待下一條請求，客戶端收到後從read()返回，發送下一條請求，如此循環下去。如果客戶端沒有更多的請求了，就調用close()關閉連接，就像寫端關閉的管道一樣，服務器的read()返回0，這樣服務器就知道客戶端關閉了連接，也調用close()關閉連接。注意，任何一方調用close()後，連接的兩個傳輸方向都關閉，不能再發送數據了。如果一方調用shutdown()則連接處於半關閉狀態，仍可接收對方發來的數據。</li><li>在學習socket API時要注意應用程序和TCP協議層是如何交互的： 應用程序調用某個socket函數時TCP協議層完成什麼動作，比如調用connect()會發出SYN段 應用程序如何知道TCP協議層的狀態變化，比如從某個阻塞的socket函數返回就表明TCP協議收到了某些段，再比如read()返回0就表明收到了FIN段</li></ul><p>server</p><ul class=ul-level-0><li>下面通過最簡單的客戶端/服務器程序的實例來學習socket API。</li><li>server.c的作用是從客戶端讀字符，然後將每個字符轉換為大寫並回送給客戶端。</li></ul><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define MAXLINE 80#define SERV_PORT 6666int main(void){ struct sockaddr_in servaddr, cliaddr; socklen_t cliaddr_len; int listenfd, connfd; char buf[MAXLINE]; char str[INET_ADDRSTRLEN]; int i, n; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(SERV_PORT); bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); listen(listenfd, 20); printf("Accepting connections ...\n"); while (1) { cliaddr_len = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;cliaddr_len); n = read(connfd, buf, MAXLINE); printf("received from %s at PORT %d\n", inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, sizeof(str)), ntohs(cliaddr.sin_port)); for (i = 0; i &lt; n; i++) buf[i] = toupper(buf[i]); write(connfd, buf, n); close(connfd); } return 0;}</pre><p>client</p><ul class=ul-level-0><li>client.c的作用是從命令行參數中獲得一個字符串發給服務器，然後接收服務器返回的字符串並打印。 複製代碼</li></ul><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char *argv[]){ struct sockaddr_in servaddr; char buf[MAXLINE]; int sockfd, n;char *str; if (argc != 2) { fputs("usage: ./client message\n", stderr); exit(1); }str = argv[1]; sockfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; inet_pton(AF_INET, "127.0.0.1", &amp;servaddr.sin_addr); servaddr.sin_port = htons(SERV_PORT); connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)); write(sockfd, str, strlen(str)); n = read(sockfd, buf, MAXLINE); printf("Response from server:\n"); write(STDOUT_FILENO, buf, n); close(sockfd); return 0;}</pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>linux</a></li><li><a>服務器</a></li><li><a>開發</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa93bfe3.html alt=服務器開發專題1-程序，進程的區別和併發概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1534549004517ed1429f6ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa93bfe3.html title=服務器開發專題1-程序，進程的區別和併發概念>服務器開發專題1-程序，進程的區別和併發概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/005f5437.html alt=哪些網站可以使用雲服務器呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad0017473d694263a74bf6ca9dd5b544 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/005f5437.html title=哪些網站可以使用雲服務器呢>哪些網站可以使用雲服務器呢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24092427.html alt=在自己的電腦上搭建服務器，發佈自己的網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24092427.html title=在自己的電腦上搭建服務器，發佈自己的網站>在自己的電腦上搭建服務器，發佈自己的網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f24146de.html alt=怎麼租用服務器，哪種建站最好？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/52874987-e2c8-4404-99f4-38f53bad4aec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f24146de.html title=怎麼租用服務器，哪種建站最好？>怎麼租用服務器，哪種建站最好？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/614becd5.html alt=服務器安裝網站教程「網站三件套——LNMP」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/4c7b778f1e284e98825354694986f6c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/614becd5.html title=服務器安裝網站教程「網站三件套——LNMP」>服務器安裝網站教程「網站三件套——LNMP」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c37b69f8.html alt=服務器成為了當今網絡時代的寵兒，如何選擇網站適合獨立服務器？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2308cb41360841aa8df684a5bc19c92c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c37b69f8.html title=服務器成為了當今網絡時代的寵兒，如何選擇網站適合獨立服務器？>服務器成為了當今網絡時代的寵兒，如何選擇網站適合獨立服務器？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d28cf747.html alt=服務器網站運行環境寶塔面板安裝教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8e911d07ba5b4d8c89535809fed5021b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d28cf747.html title=服務器網站運行環境寶塔面板安裝教程>服務器網站運行環境寶塔面板安裝教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8abf55d.html alt=虛擬主機服務器適用哪些類型網站？其選擇看什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/e73b4b7a-50c7-4687-823c-30a7523d8c4a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8abf55d.html title=虛擬主機服務器適用哪些類型網站？其選擇看什麼？>虛擬主機服務器適用哪些類型網站？其選擇看什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c77e1c3.html alt=跟著一起來基於Apache服務器部署WEB網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/221ad8e63e62434eb3b54b7f20b6154c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c77e1c3.html title=跟著一起來基於Apache服務器部署WEB網站>跟著一起來基於Apache服務器部署WEB網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/041eb04f.html alt=阿里雲服務器快速建網站_安裝BT寶塔面板和wordpress class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f2aaf81828344428b39b2102e2a62c2a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/041eb04f.html title=阿里雲服務器快速建網站_安裝BT寶塔面板和wordpress>阿里雲服務器快速建網站_安裝BT寶塔面板和wordpress</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b358c898.html alt=雲服務器搭建網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6287f5e2eabd48a59cdd9b8b1853dbf2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b358c898.html title=雲服務器搭建網站>雲服務器搭建網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50218ed7.html alt=5分鐘教你搭建自己的服務器和解析域名 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/733737e9f0714b50b7164eb128f72341 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50218ed7.html title=5分鐘教你搭建自己的服務器和解析域名>5分鐘教你搭建自己的服務器和解析域名</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html alt=不會買服務器？一個辦法讓你輕鬆搭網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84d9c54578de46058796824f1bcb6a9b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html title=不會買服務器？一個辦法讓你輕鬆搭網站>不會買服務器？一個辦法讓你輕鬆搭網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f1de35c.html alt=使用Windows服務器IIS搭建個人網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/94b8a85895c04c9b83d5d35b6b24df9c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f1de35c.html title=使用Windows服務器IIS搭建個人網站>使用Windows服務器IIS搭建個人網站</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>