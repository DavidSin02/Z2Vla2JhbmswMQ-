<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>炫酷！這些都是Android中不規則形狀View的佈局實現 | 极客快訊</title><meta property="og:title" content="炫酷！這些都是Android中不規則形狀View的佈局實現 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/ae7c8e55a2ae47c585d019f230b5938c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8851340.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8851340.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8851340.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8851340.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8851340.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8851340.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8851340.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8851340.html><meta property="article:published_time" content="2020-10-29T21:08:51+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:51+08:00"><meta name=Keywords content><meta name=description content="炫酷！這些都是Android中不規則形狀View的佈局實現"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f8851340.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>炫酷！這些都是Android中不規則形狀View的佈局實現</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ae7c8e55a2ae47c585d019f230b5938c><p class=pgc-img-caption></p></div><p>在Android中不管是View還是ViewGroup,都是方的! 方的! 方的!</p><p>而對於非方形的,Android官方並沒有給出非常好的解決方案.有的無非就是自定義View了. 然而自定義View非常麻煩,需要重寫很多方法,而且稍微不注意可能就會喪失一些特性或者造成一些Bug。</p><p>而且即便是自定義View,其實那個自定義View還是方的!!!,自定義View所能做的也就是繪製非方的圖形,但是其觸摸區域還是方的,如果需要讓一些區域觸摸無效,需要在onTouchEvent中嚴謹的計算,而這只是僅僅針對View而言,如果這個View是ViewGroup,則需要重寫dispa tchTouchEvent,dispatchToucEvent的邏輯相比於onTouchEvent的處理邏輯複雜多了。</p><p>而此時此刻，ClipPathLayout孕育而生,非常好的解決了這個問題.</p><p>何為ClipPathLayout,顧名思義,這就是一個可以對子View的Path進行裁剪的佈局.</p><p>那麼這個佈局有什麼作用呢?</p><p>問的好,這個佈局可以對其子View的繪製範圍和觸摸範圍進行裁剪,進而實現不規則形狀的View。</p><p>光說有啥用？</p><p>那就亮出來給你們看看效果。</p><h1 class=pgc-h-arrow-right>效果展示</h1><p>將方形圖片裁剪成圓形並且讓圓形View的4角不接收觸摸事件</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/88fe90495a214ff2a43b8469b5f50808><p class=pgc-img-caption></p></div><p>很多遊戲都會有方向鍵，曾經我也做過一個小遊戲 ，但是在做方向鍵的時候遇到一個問題，4個方向按鈕的位置會有重疊，導致局部地方會發生誤觸。</p><p>當時沒有特別好的解決辦法，只能做自定義View，而自定義View特別麻煩,需要重寫onTouchEvent和onDraw計算落點屬於哪個方向，並增加點擊效果。</p><p>簡單的自定義View會喪失很多Android自帶的一些特性，要支持這些特性又繁瑣而複雜。下面藉助於ClipPathLayout用4個菱形按鈕實現的方向控制鍵很好的解決了這個問題。</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37b552aca7f04cb297615b1fe248db62><p class=pgc-img-caption></p></div><p>對於遙控器的按鍵的模擬同樣有上述問題，一般只能採用自定義View實現,較為繁瑣。以下是藉助於ClipPathLayout實現的遙控器按鈕，由於沒有美工切圖，比較醜，將就下吧。</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c543e878b7748ff98a56083b3698cb2><p class=pgc-img-caption></p></div><p>甚至我們可以將不連續的圖形變成一個View，比如做一個陰陽魚的按鈕</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec8a01c13419413abea7cbe21784328f><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>使用</h1><p>效果展示完了，那麼如何使用呢?使用太麻煩也是白搭。</p><p>那麼接下來就講下如何使用。</p><h1 class=pgc-h-arrow-right>添加依賴</h1><p>庫已經上傳jcenter,Android Studio自帶jcenter依賴， 如果沒有添加，請在項目根build.gradle中添加jcenter Maven</p><pre><code>buildscript {        repositories {        google()        jcenter()    }    dependencies {        classpath 'com.android.tools.build:gradle:3.1.0'         // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }}allprojects {    repositories {        google()        jcenter()    }}</code></pre><p>在app module中的build.gradle中添加依賴</p><pre><code>implementation 'com.yxf:clippathlayout:1.0.+'</code></pre><p>其實ClipPathLayout只是一個接口，大部分的ViewGroup，實現這個接口都可以實現對不規則圖形的佈局，並且保留父類ViewGroup的特性。</p><p>當前實現了三個不規則圖形的佈局，分別是</p><ul><li>ClipPathFrameLayout</li><li>ClipPathLinearLayout</li><li>ClipPathRelativeLayout</li></ul><p>如果有其他佈局要求請自定義，參見自定義ClipPathLayout</p><p>那麼父佈局要如何知道其子View應該是何形狀呢？那必然需要給子View做自定義屬性吧，很顯然去重寫子View添加自定義屬性是不合理的。那麼就採用外部關聯的方式好了，還有一個問題，什麼屬性可以定義各種各樣的形狀呢？思來想去怕是也只有閉合的Path了吧，嗯，沒錯，就是藉助於Path，並且讓子View和這個Path關聯，然後把這些信息告訴父佈局，這樣父佈局才知道應該如何去控制這個子View的形狀。</p><p>光說理論有什麼用，來點實際的啊!</p><p>好，那就來點實際的，這裡以最簡單的圓形View為例。</p><p>在一個實現了ClipPathLayout接口的ViewGroup(以ClipPathFrameLayout為例)中添加一個子View(ImageView)。</p><pre><code>&lt;com.yxf.clippathlayout.impl.ClipPathFrameLayout xmlns:android="http://schemas.android.com/apk/res/android"    android:id="@+id/clip_path_frame_layout"    android:layout_width="match_parent"    android:layout_height="match_parent"&gt;    &lt;ImageView        android:id="@+id/image"        android:layout_width="300dp"        android:layout_height="300dp"        android:layout_gravity="center"        android:src="@mipmap/image" /&gt;&lt;/com.yxf.clippathlayout.impl.ClipPathFrameLayout&gt;</code></pre><pre><code>mImageView = mLayout.findViewById(R.id.image);</code></pre><p>然後構建一個PathInfo對象</p><pre><code>new PathInfo.Builder(new CirclePathGenerator(), mImageView)    .setApplyFlag(mApplyFlag)    .setClipType(mClipType)    .setAntiAlias(false)    .create()    .apply();</code></pre><p>搞定!運行就可以看到一個圓形的View。</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/88fe90495a214ff2a43b8469b5f50808><p class=pgc-img-caption></p></div><p>和效果展示上的這個圖差不多，不過這張圖多了幾個按鈕，然後那個圓形View有個綠色背景，那個是用來做對比的，在那個View之下添加了一個綠色的View，不要在意這些細節......</p><p>對其中使用到的參數和方法做下說明。</p><h1 class=pgc-h-arrow-right>PathInfo.Builder</h1><p>PathInfo創建器,用於配置和生成PathInfo.</p><p>構造方法定義如下</p><pre><code>        /**         * @param generator Path生成器         * @param view 實現了ClipPathLayout接口的ViewGroup的子View         */        public Builder(PathGenerator generator, View view) {                }</code></pre><h1 class=pgc-h-arrow-right>PathGenerator</h1><p>CirclePathGenerator是一個PathGenerator接口的實現類，用於生成圓形的Path。</p><p>PathGenerator定義如下：</p><pre><code>public interface PathGenerator {    /**     * @param old 以前使用過的Path,如果以前為null,則可能為null     * @param view Path關聯的子View對象     * @param width 生成Path所限定的範圍寬度,一般是子View寬度     * @param height 生成Path所限定的範圍高度,一般是子View高度     * @return 返回一個Path對象,必須為閉合的Path,將用於裁剪子View     *      * 其中Path的範圍即left : 0 , top : 0 , right : width , bottom : height     */    Path generatePath(Path old, View view, int width, int height);}</code></pre><p>} PathGenerator是使用的核心，父佈局將根據這個來對子View進行裁剪來實現不規則圖形。</p><p>此庫內置了4種Path生成器</p><ul><li>CirclePathGenerator(圓形Path生成器)</li><li>OvalPathGenerator(橢圓Path生成器)</li><li>RhombusPathGenerator(菱形Path生成器)</li><li>OvalRingPathGenerator(橢圓環Path生成器) 如果有其他複雜的Path，可以自己實現PathGenerator，可以參考示例中的陰陽魚Path的生成。</li></ul><h1 class=pgc-h-arrow-right>ApplyFlag</h1><p>Path的應用標誌,有如下幾種</p><ul><li>APPLY_FLAG_DRAW_ONLY(只用於繪製)</li><li>APPLY_FLAG_TOUCH_ONLY(只用於觸摸事件)</li><li>APPLY_FLAG_DRAW_AND_TOUCH(繪製和觸摸事件一起應用)</li></ul><p>默認不設置的話是APPLY_FLAG_DRAW_AND_TOUCH。</p><p>切換效果如下</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/70c2e9e0fce443f792d70e7abd4a5e46><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>ClipType</h1><p>Path的裁剪模式,有如下兩種</p><ul><li>CLIP_TYPE_IN(取Path內範圍作為不規則圖形子View)</li><li>CLIP_TYPE_OUT(取Path外範圍作為不規則圖形子View) 默認不設置為CLIP_TYPE_IN.</li></ul><p>切換效果如下</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/13ae7f5b0d48438bb84bb30798ce022a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>AntiAlias</h1><p>抗鋸齒，true表示開啟，false關閉，默認關閉。</p><p>請慎用此功能，此功能會關閉硬件加速並且會新建圖層，在View繪製期間還有一個圖片生成過程，所以此功能開啟會嚴重降低繪製性能，並且如果頻繁刷新界面會導致內存抖動。所以這個功能只建議在靜態而且不常刷新的情況下使用。</p><h1 class=pgc-h-arrow-right>自定義ClipPathLayout</h1><p>只有三種父佈局是不是有點坑？萬一我要用ConstraintLayout呢?那豈不是涼涼。</p><p>沒有ConstraintLayout這都被你發現了，由於ConstraintLayout並不存在於系統標準庫中,而存在於支持庫中，為了減少不必要的引用，讓庫擁有良好的獨立性，故而沒有實現(其實是因為懶...)。</p><p>好了，其實也可以自己實現了，也是很簡單的操作。</p><p>自定義一個ClipPathLayout很簡單，首先選擇一個ViewGroup，然後實現ClipPathLayout接口。</p><p>然後再在自定義的ViewGroup中創建一個ClipPathLayoutDelegate對象。</p><pre><code>ClipPathLayoutDelegate mClipPathLayoutDelegate = new ClipPathLayoutDelegate(this);</code></pre><p>並將所有ClipPathLayout接口的實現都委派給ClipPathLayoutDelegate去實現。</p><p>這裡需要注意兩點:</p><ul><li>需要重寫ViewGroup的drawChild,按如下實現即可</li></ul><pre><code>    @Override    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {        beforeDrawChild(canvas, child, drawingTime);        boolean result = super.drawChild(canvas, child, drawingTime);        afterDrawChild(canvas, child, drawingTime);        return result;    }</code></pre><p>requestLayout方法也需要重寫，這屬於ViewGroup和ClipPathLayout共有的方法，這個方法會在父類的ViewGroup的構造方法中調用，在父類構造方法被調用時，mClipPathLayoutDelegate還沒有初始化，如果直接調用會報空指針，所以需要添加空判斷。</p><pre><code>    @Override    public void requestLayout() {        super.requestLayout();        // the request layout method would be invoked in the constructor of super class        if (mClipPathLayoutDelegate == null) {            return;        }        mClipPathLayoutDelegate.requestLayout();    }</code></pre><p>這裡將整個ClipPathFrameLayout源碼貼出作為參考</p><pre><code>public class ClipPathFrameLayout extends FrameLayout implements ClipPathLayout {    ClipPathLayoutDelegate mClipPathLayoutDelegate = new ClipPathLayoutDelegate(this);    public ClipPathFrameLayout(@NonNull Context context) {        this(context, null);    }    public ClipPathFrameLayout(@NonNull Context context, @Nullable AttributeSet attrs) {        this(context, attrs, 0);    }    public ClipPathFrameLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);    }    @Override    public boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) {        return mClipPathLayoutDelegate.isTransformedTouchPointInView(x, y, child, outLocalPoint);    }    @Override    public void applyPathInfo(PathInfo info) {        mClipPathLayoutDelegate.applyPathInfo(info);    }    @Override    public void cancelPathInfo(View child) {        mClipPathLayoutDelegate.cancelPathInfo(child);    }    @Override    public void beforeDrawChild(Canvas canvas, View child, long drawingTime) {        mClipPathLayoutDelegate.beforeDrawChild(canvas, child, drawingTime);    }    @Override    public void afterDrawChild(Canvas canvas, View child, long drawingTime) {        mClipPathLayoutDelegate.afterDrawChild(canvas, child, drawingTime);    }    //the drawChild method is not belong to ClipPathLayout ,    //but you should rewrite it without changing the return value of the method    @Override    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {        beforeDrawChild(canvas, child, drawingTime);        boolean result = super.drawChild(canvas, child, drawingTime);        afterDrawChild(canvas, child, drawingTime);        return result;    }    //do not forget to rewrite the method    @Override    public void requestLayout() {        super.requestLayout();        // the request layout method would be invoked in the constructor of super class        if (mClipPathLayoutDelegate == null) {            return;        }        mClipPathLayoutDelegate.requestLayout();    }    @Override    public void notifyPathChanged(View child) {        mClipPathLayoutDelegate.notifyPathChanged(child);    }    @Override    public void notifyAllPathChanged() {        mClipPathLayoutDelegate.notifyAllPathChanged();    }}</code></pre><h1 class=pgc-h-arrow-right>原理實現</h1><p>看完了使用，有沒有覺得非常之簡單，簡單是必須的。</p><p>那麼想不想了解下原理呢?</p><p>不想!</p><p>不，我知道，你想!</p><p>既然你誠心誠意的想知道，那麼我就大發慈悲的告訴你。</p><p>故事說來話長，我們長話短說，不，我們還是慢慢說吧，很久很久以前，有這樣一位少年,這位少年苦修Android，立志要在Android上做一個貪吃蛇遊戲。然後這位少年，終於神功有成，開始寫起了他的貪吃蛇遊戲。</p><p>然而，當他寫著寫著，他居然寫出來了。</p><p>操，點的按鍵明明是上鍵怎麼沒有效果，log怎麼打印是左鍵!!!</p><p>少年心中有一萬匹草泥馬在心中奔騰。</p><p>然後少年開始分析，這是為什麼，老天爺為什麼要這樣對他。</p><p>哇，居然讓他分析出來了......</p><p>原來少年的方向按鍵是這個樣子的(原諒我沒有特別好的作圖工具,將就下吧)</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/417ddf6c9aa9463e9cb1b2f521f2fd7f><p class=pgc-img-caption></p></div><p>很明顯，這4個方向鍵有很多重合的地方，重合的地方就會有一個問題，在重合的地方只有上面的View收得到觸摸事件。那麼少年的問題就是觸摸到了重合的地方導致的。</p><p>當時少年很鬱悶啊，網上找了很久，都沒有解決這個問題。然後只好用自定義View的方式，將4個方向鍵做成一個自定義View。問題也算解決了，但是自定義View很麻煩，也不完美，這在少年心裡一直是個疙瘩。</p><p>前段時間少年不小心給老闆發了一張圖片</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9370b6531e2443b6a52dcda46987f5a3><p class=pgc-img-caption></p></div><p>然後這位少年意外的獲得了自由 ，在獲得自由後，少年想起來了久久不能平靜的疙瘩。</p><p>少年決定一定要讓這個疙瘩平靜下去，於是少年開始了他新的腦細胞死亡之路。</p><p>少年很快的想到了Path這個可以實現不規則圖形的關鍵點，但是要如何應用這個Path呢？應用從兩個方面考慮，一個是繪製，一個是觸摸事件、。</p><h1 class=pgc-h-arrow-right>繪製</h1><p>先說繪製，繪製的過程比較簡單，查閱下源碼無非就是以下兩種情況</p><p>類型過程Viewdraw -> onDrawViewGroupdraw ->dispatchDraw -> drawChild -> child.draw</p><p>draw是final方法沒法重寫，沒戲。View的onDraw，難道每個View都要重寫嗎?那怕不是石樂志。那麼只能是diapatchDraw和drawChild了，dispatchDraw邏輯複雜，drawChild很簡單，很自然的重寫drawChild了。</p><pre><code>    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {        return child.draw(canvas, this, drawingTime);    }</code></pre><p>drawChild的實現非常簡單，這是一個非常好的劫持繪製過程的時機。</p><p>少年想到只要在這裡將Canvas根據Path進行裁剪，那麼不管子View如何繪製，被裁剪掉的部分都不會顯示，這樣說不定還能減少過度繪製的問題。</p><p>然後少年修改了drawChild方法</p><pre><code>    @Override    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {        beforeDrawChild(canvas, child, drawingTime);        boolean result = super.drawChild(canvas, child, drawingTime);        afterDrawChild(canvas, child, drawingTime);        return result;    }            @Override    public void beforeDrawChild(Canvas canvas, View child, long drawingTime) {        canvas.save();        canvas.translate(child.getLeft(), child.getTop());        if (hasLayoutRequest) {            hasLayoutRequest = false;            notifyAllPathChangedInternal(false);        }        ViewGetKey key = getTempViewGetKey(child.hashCode(), child);        PathInfo info = mPathInfoMap.get(key);        if (info != null) {            if ((info.getApplyFlag() &amp; PathInfo.APPLY_FLAG_DRAW_ONLY) != 0) {                Path path = info.getPath();                if (path != null) {                    Utils.clipPath(canvas, path, info.getClipType());                } else {                    Log.d(TAG, "beforeDrawChild: path is null , hash code : " + info.hashCode());                }            }        }        resetTempViewGetKey();        canvas.translate(-child.getLeft(), -child.getTop());    }    @Override    public void afterDrawChild(Canvas canvas, View child, long drawingTime) {        canvas.restore();    }</code></pre><p>少年成功的劫持了Canvas，然後通過Canvas.clipPath對Canvas進行裁剪，將裁剪後的Canvas再交給子View處理，完美!</p><h1 class=pgc-h-arrow-right>觸摸</h1><p>至於觸摸事件，那就麻煩了，麻煩到炸了好吧。如何應用到Path到觸摸事件呢?重寫dispatchTouchEvent嗎?當少年打開ViewGroup的源碼，看到200多行，裡面還摻雜著各種hide,各種private的方法和成員變量時，少年秒慫了。</p><p>但是前段時間知乎大佬出了一個嵌套滑動的庫NestedTouchScrollingLayout給了少年一些靈感，幹嘛不直接把onInterceptTouchEvent返回true，然後在onTouchEvent裡重寫做事件分發呢?哇好像可以耶。但是少年又想了想，如果直接攔截。自己又重寫onTouchEvent，這樣子和直接重寫dispatchTouchEvent真的有區別嗎?在onTouchEvent裡寫直接讓原來dispatchTouchEvent的邏輯廢了，還增加了一段流程,可能還會喪失很多特性,製造一些bug，而且onInterceptTouchEvent和onTouchEvent這兩個方法將被佔用，後續繼承的子View可能不能很好的重寫。當然直接廢棄掉原生代碼,自己寫一些簡單的操作確實是可行的，但是作為一個有追求的少年，這樣做疙瘩是得不到平靜的，為了讓疙瘩平靜下來，少年開始尋找dispatchTouchEvent中有沒有可以見縫插針的地方。</p><p>終於少年找到了這樣一段代碼</p><pre><code>        //...................................        if (!canViewReceivePointerEvents(child)                || !isTransformedTouchPointInView(x, y, child, null)) {            ev.setTargetAccessibilityFocus(false);            continue;        }        //...................................                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {            //...............................        }</code></pre><p>其中canViewReceivePointerEvents是判斷子View是否有資格接收點擊事件的;isTransformedTouchPointInView是判斷觸摸點是否在View中的;而dispatchTransformedTouchEvent，就是判斷是否攔截事件或者分發給子View的地方。</p><p>少年的想法是對View根據Path進行裁剪實現不規則形狀的View。那麼如果能在isTransformedTouchPointInView中判斷是否在Path內，則可以實現讓不在Path內的點的流程直接continue掉，從而不走dispatchTransformedTouchEvent。</p><p>找到一個非常好的想法，少年非常激動，然後點進去isTransformedTouchPointInView方法被潑了一身冷水。</p><pre><code>    /**     * Returns true if a child view contains the specified point when transformed     * into its coordinate space.     * Child must not be null.     * @hide     */    protected boolean isTransformedTouchPointInView(float x, float y, View child,            PointF outLocalPoint) {        final float[] point = getTempPoint();        point[0] = x;        point[1] = y;        transformPointToViewLocal(point, child);        final boolean isInView = child.pointInView(point[0], point[1]);        if (isInView &amp;&amp; outLocalPoint != null) {            outLocalPoint.set(point[0], point[1]);        }        return isInView;    }</code></pre><p>這個方法居然是hide的!!!!!少年有句mmp當時就講了，過了一會少年心情稍微平靜下來，等等，hide的方法只是不能調用，但是沒定義不能重寫啊，而且這個方法是protected的，完全具備重寫條件.少年又有了激情。</p><p>少年繼續跟蹤裡面的transformPointToViewLocal方法</p><pre><code>    /**     * @hide     */    public void transformPointToViewLocal(float[] point, View child) {        point[0] += mScrollX - child.mLeft;        point[1] += mScrollY - child.mTop;        if (!child.hasIdentityMatrix()) {            child.getInverseMatrix().mapPoints(point);        }    }</code></pre><p>mmp,這又是一個hide方法，但是這下需要的就不是重寫而是調用了........那麼用反射調用嗎?反射會降低性能啊，Android p又禁反射了，而且各個版本系統代碼不一樣，還不一定有這個方法，呵呵呵，還真被少年猜中了，Android4.4的源碼中沒有這個方法............谷歌，少年一口鹽汽水噴死你!</p><p>既然沒有辦法調用就想想替代方案唄，瞭解下這個方法幹嘛的，不用看都知道，這個方法是將點座標通過View變幻的逆矩陣映射回去看點是否在View內。很容易重寫嘛，然而谷歌爸爸會讓你這麼簡單成功嗎?naive!</p><pre><code>    /**     * Utility method to retrieve the inverse of the current mMatrix property.     * We cache the matrix to avoid recalculating it when transform properties     * have not changed.     *     * @return The inverse of the current matrix of this view.     * @hide     */    public final Matrix getInverseMatrix() {        ensureTransformationInfo();        if (mTransformationInfo.mInverseMatrix == null) {            mTransformationInfo.mInverseMatrix = new Matrix();        }        final Matrix matrix = mTransformationInfo.mInverseMatrix;        mRenderNode.getInverseMatrix(matrix);        return matrix;    }</code></pre><p>View的getInverseMatrix方法是hide的,驚不驚喜,意不意外!</p><p>不是還有mRenderNode.getInverseMatrix嗎?</p><pre><code>    public void getInverseMatrix(@NonNull Matrix outMatrix) {        nGetInverseTransformMatrix(mNativeRenderNode, outMatrix.native_instance);    }``RenderNode的`getInverseMatrix`的方法是public的,是不是很高興?```java * * @hide */public class RenderNode {    //...................}</code></pre><p>然而RenderNode連class都是hide的，是不是更高興了，連怎麼獲取RenderNode對象都不需要考慮了。</p><p>少年並沒有氣餒，不就是個逆矩陣嗎,少年默默在心裡念著"谷歌,要是我搞不定,吃我翔"。</p><p>既然逆矩陣獲取不到那就獲得原矩陣嘛。</p><pre><code>    /**     * The transform matrix of this view, which is calculated based on the current     * rotation, scale, and pivot properties.     *     * @see #getRotation()     * @see #getScaleX()     * @see #getScaleY()     * @see #getPivotX()     * @see #getPivotY()     * @return The current transform matrix for the view     */    public Matrix getMatrix() {        ensureTransformationInfo();        final Matrix matrix = mTransformationInfo.mMatrix;        mRenderNode.getMatrix(matrix);        return matrix;    }</code></pre><p>很幸運，View的getMatrix是public的,而且沒有hide。</p><p>逆的過程也很簡單，Android的Matrix提供了一個invert的方法，最終可以用如下方法代替transformPointToViewLocal。</p><pre><code>    private void transformPointToViewLocal(float[] point, View child) {        point[0] += mParent.getScrollX() - child.getLeft();        point[1] += mParent.getScrollY() - child.getTop();        Matrix matrix = child.getMatrix();        if (!matrix.isIdentity()) {            Matrix invert = getTempMatrix();            boolean result = matrix.invert(invert);            if (result) {                invert.mapPoints(point);            }        }    }</code></pre><p>然後還有一個問題,關於如何判斷點是否在Path內呢?</p><p>這個問題少年只想到了一種比較耗費內存的辦法，就是將Path用Canvas繪製成圖片，然後根據點是否符合圖片裡Path內的顏色來判斷。這是一種用內存換時間的策略，臥槽，講道理豈止是浪費,簡直是鋪張浪費。少年為了節約內存，將圖片大小縮小了16倍。這樣問題應該不大了，少年百度查了下，貌似還有一個Region類可以實現是否在Path內判斷，但是資料其實不多,而且估計每次點都需要計算是否在Path內，少年覺得這種方式沒有轉化成圖片穩,所以當時默認採用了圖片的方式作為判斷。</p><p>然後這裡出現了一個轉折，鴻神看到這部分問題的時候給了少年一個方案，就是用自帶的Region類來實現，既然大佬都覺得這個方式更為合適，少年決定去嘗試一波，通過Region類實現PathRegion接口替換掉原來的BitmapPathRegion，確實實現了對是否在Path閉合空間的判斷,不過少年有點在意其性能是否會比用Bitmap的方式更好呢?少年追蹤了下Region類的實現，發現其實現基本上是調用jni實現的，然後jni中的Region類也只是對skia庫中SkRegion的裝封而已。也就是說最終實現是由skia庫的SkRegion實現的，以前沒怎麼注意，追下源碼才發現，Path類其實也是skia裡的，百度查了下才知道,Android的2D繪圖都是skia實現的.大概的查閱了下SkRegion.contains的方法。</p><pre><code>bool SkRegion::contains(int32_t x, int32_t y) const {    SkDEBUGCODE(this-&gt;validate();)    if (!fBounds.contains(x, y)) {        return false;    }    if (this-&gt;isRect()) {        return true;    }    SkASSERT(this-&gt;isComplex());    const RunType* runs = fRunHead-&gt;findScanline(y);    // Skip the Bottom and IntervalCount    runs += 2;    // Just walk this scanline, checking each interval. The X-sentinel will    // appear as a left-inteval (runs[0]) and should abort the search.    //    // We could do a bsearch, using interval-count (runs[1]), but need to time    // when that would be worthwhile.    //    for (;;) {        if (x &lt; runs[0]) {            break;        }        if (x &lt; runs[1]) {            return true;        }        runs += 2;    }    return false;}</code></pre><p>發現其對於非矩形的區域的實現是以y作為掃描線，然後獲得這個掃描線上的數組,數組中兩個相鄰值儲存著一個區間，如果前一個區間沒找到則繼續在下一個區間尋找，找到則返回true,理解不深，不知道理解是否有不合理之處,歡迎指正。</p><p>這種方式比bitmap省了很多空間，然後2D繪製這些本就是skia這一套的東西，又是C++實現,所以可以認為這種方式確實比使用Bitmap更為合適,當前已經在源碼中默認使用這種方式作為點是否在Path中的判斷。</p><p>那麼原理就講到這裡就講完了，具體如何實現的,自己看源碼去吧，文章底放GitHub地址。</p><h1 class=pgc-h-arrow-right>轉場動畫擴展</h1><p>基於ClipPathLayout還可以實現轉場動畫的擴展，先放些效果。</p><p>兩個View的場景切換效果，Android原生自帶的場景切換效果大部分是由動畫實現的平移，縮小，暗淡。</p><p>原生比較少帶有那種PPT播放的切換效果，一些第三方庫實現的效果一般是由在DecorView中添加一層View來實現較為和諧的切換。</p><p>滬江開心詞場裡使用的就是這種動畫，這種動畫很棒，但是也有一個小缺點,就是在切換的過程中,切換用的View和即將要切換的View沒有什麼關係，只是顏色類似。</p><p>藉助於ClipPathLayout擴展的TransitionFrameLayout也可以實現較為和諧的切換效果，由於是示例，不寫太複雜的場景,以下僅用兩個TextView作為展示。</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bbfbab3d169744ff94e0a895bfc620cf><p class=pgc-img-caption></p></div><p>在瀏覽QQ空間和使用QQ瀏覽器的過程看到騰訊的廣告切換效果也是很不錯的,這裡藉助於TransitionFrameLayout也可以實現這種效果。</p><p><br></p><p>其實大部分的場景切換應該是用在Fragment中，這裡也用TransitionFragmentContainer實現了Fragment的場景切換效果。</p><div class=pgc-img><img alt=炫酷！這些都是Android中不規則形狀View的佈局實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5bf911866fb244378fd4599000795d8f><p class=pgc-img-caption></p></div><p>GitHub地址：https://github.com/dqh147258/ClipPathLayout</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>炫酷</a></li><li><a>這些</a></li><li><a>Android</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a9681862.html alt=停電通知：涉及西安這些區域，最長超過48小時 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RqALLGVINNInKI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a9681862.html title=停電通知：涉及西安這些區域，最長超過48小時>停電通知：涉及西安這些區域，最長超過48小時</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2d6fc9f.html alt=包頭這些地方要停電 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/859d3095cd1d477ab613027b9ce219c2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2d6fc9f.html title=包頭這些地方要停電>包頭這些地方要停電</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c4b6b45.html alt=明天起西安這些地方停水、停電，最長24小時！雨還來嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/23f74c70f3344e2b98c87cf66a594d8d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c4b6b45.html title=明天起西安這些地方停水、停電，最長24小時！雨還來嗎？>明天起西安這些地方停水、停電，最長24小時！雨還來嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4375da16.html alt="滾輪鍵按一下 這些功能超方便" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b646e119c9604f76ad8267cd63a6b661 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4375da16.html title="滾輪鍵按一下 這些功能超方便">滾輪鍵按一下 這些功能超方便</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf03ccfb.html alt=想要更好的藍牙音質？這些藍牙音頻編碼你要知道 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RAVmUNPA9yJDfa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf03ccfb.html title=想要更好的藍牙音質？這些藍牙音頻編碼你要知道>想要更好的藍牙音質？這些藍牙音頻編碼你要知道</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a60af1ac.html alt="耳機小白必讀 這些常見音頻編碼一定要了解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RN7gZcbAxeBjkW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a60af1ac.html title="耳機小白必讀 這些常見音頻編碼一定要了解">耳機小白必讀 這些常見音頻編碼一定要了解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfee15a7.html alt=建築層高和淨高知識彙總，這些你都知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/f5a612c7-aeab-4603-af94-2d692cfc5e76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfee15a7.html title=建築層高和淨高知識彙總，這些你都知道嗎？>建築層高和淨高知識彙總，這些你都知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7206f327.html alt=這些方法可以讓發硬的紅糖變軟 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7206f327.html title=這些方法可以讓發硬的紅糖變軟>這些方法可以讓發硬的紅糖變軟</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea55b21f.html alt=趁著疫情來騙錢！闢謠：這些號稱能預防新冠毒肺炎的七個產品 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/59694987d69649508d0f4701be15daf6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea55b21f.html title=趁著疫情來騙錢！闢謠：這些號稱能預防新冠毒肺炎的七個產品>趁著疫情來騙錢！闢謠：這些號稱能預防新冠毒肺炎的七個產品</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9692432a.html alt=中國這些超級鹽湖，實力與魅力並存 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15379278320496657273e6c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9692432a.html title=中國這些超級鹽湖，實力與魅力並存>中國這些超級鹽湖，實力與魅力並存</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/813d5912.html alt=關於Facebook像素，這些你瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RM0p5dK51SH9EU style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/813d5912.html title=關於Facebook像素，這些你瞭解嗎？>關於Facebook像素，這些你瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4e33540.html alt="收藏 | 這些航測必備的知識點你瞭解嗎？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4e33540.html title="收藏 | 這些航測必備的知識點你瞭解嗎？">收藏 | 這些航測必備的知識點你瞭解嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/28238c20.html alt=焊工考試這些題你會做嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/28238c20.html title=焊工考試這些題你會做嗎？>焊工考試這些題你會做嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9ebdb58.html alt=升冪、降冪、二倍、半角這些繞暈你的變換你會嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/23ec864c961f438d9141a0eacd5d8792 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9ebdb58.html title=升冪、降冪、二倍、半角這些繞暈你的變換你會嗎？>升冪、降冪、二倍、半角這些繞暈你的變換你會嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cff57476.html alt=北海的這些樣子，你都見過嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6f8a3f9c96b94f39a96334bdab83920b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cff57476.html title=北海的這些樣子，你都見過嗎？>北海的這些樣子，你都見過嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>