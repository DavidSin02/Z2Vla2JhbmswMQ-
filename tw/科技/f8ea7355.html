<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>計算機考研複試面試常問問題 操作系統篇 | 极客快訊</title><meta property="og:title" content="計算機考研複試面試常問問題 操作系統篇 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/25ee633687484ed183f80bf4bfe6e1c7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8ea7355.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8ea7355.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8ea7355.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8ea7355.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8ea7355.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8ea7355.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8ea7355.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8ea7355.html><meta property="article:published_time" content="2020-11-14T21:04:10+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:10+08:00"><meta name=Keywords content><meta name=description content="計算機考研複試面試常問問題 操作系統篇"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f8ea7355.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>計算機考研複試面試常問問題 操作系統篇</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>計算機考研複試面試常問問題 操作系統篇</p><blockquote><p>在複習過程中，我用心查閱並整理了在<strong>考研複試面試</strong>中可能問到的大部分問題，並<strong>分點整理</strong>了答案，可以<strong>直接理解背誦並加上自己的語言潤色</strong>!極力推薦打印下來看，效率更高！</p><p>此係列一共有8篇：編程語言篇|數據結構篇|操作系統篇|組成原理篇|計算機網絡篇|數據庫篇|軟件工程篇|計算機專業英語篇(<strong>還未全部完成,敬請期待,你們的支持和關注是我最大的動力!</strong>)</p><p>個人整理，不可用於商業用途，轉載請註明出處。</p><p>作者各個平臺請搜索：<strong>程序員寶藏</strong>。快來探索屬於你的寶藏吧！</p><p>需要<strong>pdf直接打印版</strong>，可在公眾號"<strong>程序員寶藏</strong>"回覆<strong>複試上岸</strong>獲取(會持續更新)</p><p>需要<strong>408電子書2021版</strong>，可在公眾號"<strong>程序員寶藏</strong>"回覆<strong>408電子書</strong>獲取</p><p>需要<strong>408初試視頻2021版</strong>，可在公眾號"<strong>程序員寶藏</strong>"回覆<strong>408視頻</strong>獲取</p><p>需要<strong>複試機試視頻</strong>，可在公眾號"<strong>程序員寶藏</strong>"回覆<strong>機試必過</strong>獲取</p><p><strong>加油，大家都可以上岸！！！讓我們一起努力！！！</strong></p></blockquote><h2><span>第一章、計算機系統概述</span></h2><p><strong>快速喚起記憶的知識框架</strong></p><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/25ee633687484ed183f80bf4bfe6e1c7></div><h4><u>1.操作系統的目標和功能？（什麼是操作系統？）</u></h4><blockquote><p><strong>1.操作系統是計算機資源的管理者</strong></p></blockquote><blockquote><p><strong>處理機管理</strong>（進程控制、進程同步、進程通信、死鎖處理、處理機調度）</p><p><strong>存儲器管理</strong>（提高內存利用率，內存的分配與回收、地址映射、內存保護與共享、內存擴充）</p><p><strong>文件管理</strong>（計算機中的信息都是以文件的形式存在的）</p><p><strong>設備管理</strong>（完成用戶的I/O請求，方便用戶使用設備、並提高設備的利用率**）**</p></blockquote><blockquote><p><strong>2.操作系統為用戶提供使用計算機硬件系統的接口</strong></p></blockquote><blockquote><p><strong>命令接口</strong>（用戶通過控制檯或終端輸入操作命令，向系統提供各種服務要求）</p><p><strong>程序接口</strong>（由系統調用組成，用戶在程序中使用這些系統調用來請求操作系統為其提供服務）</p><p><strong>圖形接口</strong> 最常見的圖形用戶界面GUI（最終還是通過調用程序接口實現的）</p></blockquote><blockquote><p><strong>3.操作系統用作擴充機器</strong></p></blockquote><blockquote><p>沒有任何軟件支持的計算機稱為裸機，實際呈現在用戶面前的計算機系統是經過若干層軟件改造的計算機。操作系統將裸機改造成功能更強、使用更方便的機器。我們將覆蓋了軟件的機器稱為擴充機器或虛擬機。</p></blockquote><h4><u>2.操作系統的運行機制?</u></h4><blockquote><p><strong>1.內核程序和應用程序(內核態和用戶態)</strong></p></blockquote><blockquote><p>在計算機系統中，通常CPU執行兩種不同性質的程序：一種是操作系統內核程序；另一種是用戶自編程序或系統外層的應用程序。內核程序是應用程序的”管理者”。“管理程序“可以執行一些特權指令，而”被管理程序“出於安全考慮不能執行這些指令。所謂特權指令，是指計算機中不允許用戶直接使用的指令，如：I/O指令、置中斷指令，存取用於內存保護的寄存器，送程序狀態字到程序狀態字寄存器等指令。</p><p>操作系統在具體實現上劃分了用戶態（目態）和核心態（管態），以嚴格區分兩類程序。</p></blockquote><blockquote><p><strong>2.層次式結構</strong></p></blockquote><blockquote><p>操作系統的各項功能分別被設置在不同的層次上。一些與硬件關聯較緊密的模塊，諸如時鐘管理、中斷管理、設備驅動等處於最底層。其次是運行頻率較高的程序，諸如進程管理、存儲管理和設備管理等。 上面的這兩部分內容構成了操作系統的內核，這部分內容的指令操作工作在核心態。</p></blockquote><blockquote><p><strong>3.內核</strong></p></blockquote><blockquote><p>內核是計算機上配置的底層軟件，是計算機功能的延伸，包括以下4個方面的內容：</p><p>1）<strong>時鐘管理</strong> 時鐘的第一功能是計時，操作系統需要通過時鐘管理，向用戶提供標準的系統時間。其次，通過時鐘中斷的管理，可以實現進程的切換。在分時操作系統中，採用時間片輪轉調度的實現；在實時系統中，按截至時間控制運行的實現；在批處理系統中，通過時鐘管理來衡量一個作業的運行程度等。</p><p>2）<strong>中斷機制</strong> 引入中斷技術的初衷是提高多道程序運行環境中CPU的利用率，主要針對外部設備。後來逐步得到發展，形成了多種類型，成為操作系統各項操作的基礎。如，鍵盤或鼠標信息的輸入、進程的管理和調度、系統功能的調用、設備驅動、文件訪問等。都依賴於中斷機制。可以說，現代操作系統是靠中斷驅動的軟件。中斷機制中，只有一小部分功能屬於內核，負責保護和恢復中斷現場的信息，轉移控制權到相關的處理程序。這樣可以減少中斷的處理時間，提高系統的並行處理能力。</p><p>3）<strong>原語</strong> 操作系統底層是一些可被調用的公用小程序，它們各自完成一個規定的操作，其特點是：</p><p>------ 它們處於操作系統的最底層，是最接近硬件的部分。</p><p>------ 這些程序的運行具有原子性，其操作只能一氣呵成</p><p>------ 這些程序的運行時間都較短，而且調用頻繁。</p><p>定義原語的直接方法是關閉中斷，讓它的所有動作不可分割地進行完再打開中斷。</p><p>4）<strong>系統控制的數據結構及處理</strong> 系統中用來登記狀態信息的數據結構很多，比如：作業控制塊、進程控制塊、設備控制塊、各類鏈表等。為了實現有效的管理，系統需要一些基本的操作，常見的操作有以下三種：</p><p>------ 進程管理：進程狀態管理、進程調度和分配、創建和撤銷進程控制塊等。</p><p>------ 存儲器管理：存儲器的空間分配和回收、內存信息保護程序、代碼對換程序等。</p><p>------ 設備管理：緩衝區管理、設備分配和回收等。</p></blockquote><h4><u>3.中斷和異常？</u></h4><blockquote><p><strong>1.中斷的引入——為了支持CPU和設備之間的並行操作</strong></p></blockquote><blockquote><p>中斷也稱外中斷，指來自CPU執行指令以外的事件的發生，如設備發出的I/O結束中斷、時鐘中斷等。這一類中斷通常是與當前執行的指令無關的事件。</p></blockquote><blockquote><p><strong>2.異常的引入——表示CPU執行指令本身時出現的問題</strong></p></blockquote><blockquote><p>異常也稱內中斷、例外或陷入，指源自CPU執行指令內部的事件，如程序的非法操作碼、地址越界、算術溢出、缺頁異常等。對異常的處理一般要依賴與當前程序的運行現場，不能被屏蔽。</p></blockquote><blockquote><p><strong>3.中斷和異常的聯繫與區別</strong></p></blockquote><blockquote><p><br></p></blockquote><blockquote><p><strong>4.中斷執行的流程</strong></p></blockquote><blockquote><p>以上是多重中斷的流程，其中，1~3步是由硬件（中斷隱指令）完成的；4-9步是由中斷服務程序完成的。</p></blockquote><h4><u>4.系統調用？</u></h4><blockquote><p>計算機系統的各種硬件資源是有限，為了更好的管理這些資源，進程是不允許直接操作的，所有對這些資源的訪問都必須有操作系統控制。<strong>也就是說操作系統是使用這些資源的唯一入口，而這個入口就是操作系統提供的系統調用</strong>。一般地，系統調用都是通過中斷實現的，比如，linux下中斷號0x80就是進行系統調用的。</p></blockquote><blockquote><p>操作系統為用戶態進程與硬件設備進行交互提供了一組接口——系統調用:1.把用戶從底層的硬件編程中解放了出來;2.極大地提高了系統的安全性使用戶程序具有可移植性；用戶程序與具體硬件已經被抽象接口所替代。</p></blockquote><blockquote><p>系統調用流程圖如下：</p></blockquote><h4>5.<u>大內核和微內核</u></h4><blockquote><p><strong>1.大內核</strong></p></blockquote><blockquote><p>大內核是將操作系統功能作為一個緊密結合的整體放到內核。由於各模塊共享信息，因此有很高的性能。</p></blockquote><blockquote><p><strong>2.微內核</strong></p></blockquote><blockquote><p>由於操作系統不斷複雜，因此將一部分操作系統功能移出內核，從而降低內核的複雜性。移出的部分根據分層的原則劃分成若干服務，相互獨立。 在微內核結構下，操作系統被劃分成小的、定義良好的模塊，只有微內核這一個模塊運行在內核態，其餘模塊運行在用戶態。 因為需要頻繁地在用戶態和核心態之間進行切換，所以會有一定的性能損失。</p></blockquote><h2><span>第二章、進程管理</span></h2><p><strong>快速喚起記憶的知識框架</strong></p><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a538dba390a24ae4885c6e9e6e6f9dda></div><h4>6.<u>進程與線程</u>？</h4><blockquote><p><strong>1.進程的概念與定義</strong></p></blockquote><blockquote><p>在多道程序環境下，允許多個進程併發執行，此時他們將失去封閉性，並具有間斷性及不可再現性的特徵。為此引入了進程的概念，以便更好地描述和控制程序的併發執行，實現操作系統的併發性和共享性。</p><p>進程是程序的運行過程，是系統進行資源分配和調度的一個獨立單位。</p></blockquote><blockquote><p><strong>2.線程的概念和定義</strong></p></blockquote><blockquote><p>早期，在OS中能擁有資源和獨立運行的基本單位是進程，然而隨著計算機技術的發展，進程出現了很多弊端，一是由於進程是資源擁有者，創建、撤消與切換存在較大的時空開銷，因此需要引入輕型進程；二是由於對稱多處理機（SMP）出現，可以滿足多個運行單位，而多個進程並行開銷過大。</p><p>線程是操作系統能夠進行運算調度的最小單位。它被包含在進程之中，是進程中的實際運作單位。一條線程指的是進程中一個單一順序的控制流，每條線程執行不同的任務。</p></blockquote><blockquote><p><strong>3.進程和線程的區別</strong></p></blockquote><blockquote><p>1.進程（Process）是系統進行資源分配和調度的基本單位，線程（Thread）是CPU調度和分派的基本單位；</p><p>2.線程依賴於進程而存在，一個進程至少有一個線程；</p><p>3.進程有自己的獨立地址空間，線程共享所屬進程的地址空間；</p><p>4.進程是擁有系統資源的一個獨立單位，而線程自己基本上不擁有系統資源，只擁有一點在運行中必不可少的資源(如程序計數器,一組寄存器和棧)，和其他線程共享本進程的相關資源如內存、I/O、cpu等；</p><p>5.在進程切換時，涉及到整個當前進程CPU環境的保存環境的設置以及新被調度運行的CPU環境的設置，而線程切換隻需保存和設置少量的寄存器的內容，並不涉及存儲器管理方面的操作，可見，進程切換的開銷遠大於線程切換的開銷；</p><p>6.線程之間的通信更方便，同一進程下的線程共享全局變量等數據，而進程之間的通信需要以進程間通信(IPC)的方式進行；</p><p>7.多線程程序只要有一個線程崩潰，整個程序就崩潰了，但多進程程序中一個進程崩潰並不會對其它進程造成影響，因為進程有自己的獨立地址空間，因此多進程更加健壯</p></blockquote><blockquote><p>4.<strong>進程和程序的區別</strong></p></blockquote><blockquote><p>（1） 程序是永存的；進程是暫時的，是程序在數據集上的一次執行，有創建有撤銷，存在是暫時的； （2）程序是靜態的觀念，進程是動態的觀念； （3）進程具有併發性，而程序沒有； （4）進程是競爭計算機資源的基本單位，程序不是。 （5）進程和程序不是一一對應的： 一個程序可對應多個進程即多個進程可執行同一程序； 一個進程可以執行一個或幾個程序</p></blockquote><h4>7.<u>進程的通信方式</u>？</h4><blockquote><p><strong>1.共享內存</strong></p></blockquote><blockquote><p>顧名思義，共享內存就是兩個進程同時共享一塊內存，然後在這塊內存上的數據可以共同修改和讀取，達到通信的目的。</p></blockquote><blockquote><p><strong>2.無名管道</strong></p></blockquote><blockquote><p>無名管道是半雙工的通信方式；並且只能在具有親緣關係的進程之間使用（親緣關係是指進程間的父子關係，兄弟關係等），具有親緣關係的進程在創建時同時擁有一個無名管道的句柄，可以進行讀寫；無名管道不存在磁盤節點，只存在與內存中用完即銷燬。</p></blockquote><blockquote><p><strong>3.命名管道</strong></p></blockquote><blockquote><p>命名管道也是半雙工的通信方式；可以在不具有親緣關係的進程間通信；有名管道存在磁盤節點，有對應的FIFO文件，凡是可以訪問該路徑的文件的進程均可以進行通信。</p></blockquote><blockquote><p><strong>4.消息隊列</strong></p></blockquote><blockquote><p>消息隊列是由消息的鏈表，存放在內核中並由消息隊列標識符標識。消息隊列克服了信號傳遞信息少、管道只能承載無格式字節流以及緩衝區大小受限等缺點。</p></blockquote><blockquote><p><strong>5.套接字</strong></p></blockquote><blockquote><p>套接字是網絡編程的api，通過套接字可以不同的機器間的進程進行通信，常用於客戶端進程和服務器進程的通信。</p></blockquote><blockquote><p><strong>6.信號</strong></p></blockquote><blockquote><p>信號是Unix系統中使用的最古老的進程間通信的方法之一。操作系統通過信號來通知進程系統中發生了某種預先規定好的事件（一組事件中的一個），它也是用戶進程之間通信和同步的一種原始機制。一個鍵盤中斷或者一個錯誤條件（比如進程試圖訪問它的虛擬內存中不存在的位置等）都有可能產生一個信號。Shell也使用信號向它的子進程發送作業控制信號。</p></blockquote><h4><u>8.進程的5種狀態及轉換過程？</u></h4><blockquote><p><br></p></blockquote><h4><u>9.進程的調度算法有哪些？</u></h4><blockquote><p><strong>1.先來先服務 first-come first-serverd（FCFS）</strong></p></blockquote><blockquote><p>按照請求的順序進行調度。非搶佔式，開銷小，無飢餓問題，響應時間不確定（可能很慢）；</p><p>對短進程不利，對IO密集型進程不利。</p></blockquote><blockquote><p><strong>2.最短作業優先 shortest job first（SJF）</strong></p></blockquote><blockquote><p>按估計運行時間最短的順序進行調度。非搶佔式，吞吐量高，開銷可能較大，可能導致飢餓問題；</p><p>對短進程提供好的響應時間，對長進程不利</p></blockquote><blockquote><p><strong>3.優先級調度算法</strong></p></blockquote><blockquote><p>為每個進程分配一個優先級，按優先級進行調度。為了防止低優先級的進程永遠等不到調度，可以隨著時間的推移增加等待進程的優先級。</p></blockquote><blockquote><p>4.<strong>時間片輪轉</strong></p></blockquote><blockquote><p>將所有就緒進程按 FCFS 的原則排成一個隊列，用完時間片的進程排到隊列最後。搶佔式（時間片用完時），開銷小，無飢餓問題，為短進程提供好的響應時間；</p><p>若時間片小，進程切換頻繁，吞吐量低；若時間片太長，實時性得不到保證。</p></blockquote><blockquote><p>5.<strong>最高響應比優先</strong></p></blockquote><blockquote><p>響應比 = 1+ 等待時間/處理時間。同時考慮了等待時間的長短和估計需要的執行時間長短，很好的平衡了長短進程。非搶佔，吞吐量高，開銷可能較大，提供好的響應時間，無飢餓問題。</p></blockquote><blockquote><p><strong>6.多級反饋隊列調度算法</strong></p></blockquote><blockquote><p>設置多個就緒隊列1、2、3...，優先級遞減，時間片遞增。只有等到優先級更高的隊列為空時才會調度當前隊列中的進程。如果進程用完了當前隊列的時間片還未執行完，則會被移到下一隊列。</p><p>搶佔式（時間片用完時），開銷可能較大，對IO型進程有利，可能會出現飢餓問題。</p></blockquote><h4>10.<u>同步和互斥</u>？</h4><blockquote><p><strong>1.同步</strong></p></blockquote><blockquote><p>多個進程因為合作而使得進程的執行有一定的先後順序。比如某個進程需要另一個進程提供的消息，獲得消息之前進入阻塞態；</p></blockquote><blockquote><p><strong>2.互斥</strong></p></blockquote><blockquote><p>多個進程在同一時刻只有一個進程能進入臨界區</p></blockquote><blockquote><p><strong>3.同步機制的4個準則</strong></p></blockquote><blockquote><p>1.空閒讓進 當無進程處於臨界區，可允許一個請求進入臨界區的進程立即進入自己的臨界區</p><p>2.忙則等待 當已有進程進入自己的臨界區，所有企圖進入臨界區的進程必須等待</p><p>3.有限等待 對要求訪問臨界資源的進程，應保證該進程能在有限時間內進入自己的臨界區</p><p>4.讓權等待 當進程不能進入自己的臨界區，應釋放處理機</p></blockquote><h4><u>11.進程同步相關概念</u></h4><blockquote><p>為什麼需要進程同步：進程有時候會和其他進程共享一些資源，比如內存、數據庫等。當多個進程同時讀寫同一份共享資源的時候，可能會發生衝突。因此需要進程的同步，多個進程按順序訪問資源。</p></blockquote><blockquote><p><strong>互斥量</strong> Mutex：互斥量是內核對象，只有擁有互斥對象的線程才有訪問互斥資源的權限。因為互斥對象只有一個，所以可以保證互斥資源不會被多個線程同時訪問；當前擁有互斥對象的線程處理完任務後必須將互斥對象交出，以便其他線程訪問該資源；</p></blockquote><blockquote><p><strong>信號量</strong> Semaphore：信號量是內核對象，它允許同一時刻多個線程訪問同一資源，但是需要控制同一時刻訪問此資源的最大線程數量。信號量對象保存了<strong>最大資源計數</strong>和<strong>當前可用資源計數</strong>，每增加一個線程對共享資源的訪問，當前可用資源計數就減1，只要當前可用資源計數大於0，就可以發出信號量信號，如果為0，則將線程放入一個隊列中等待。線程處理完共享資源後，應在離開的同時通過ReleaseSemaphore函數將當前可用資源數加1。如果信號量的取值只能為0或1，那麼信號量就成為了互斥量；</p></blockquote><blockquote><p><strong>事件</strong> Event：允許一個線程在處理完一個任務後，主動喚醒另外一個線程執行任務。事件分為手動重置事件和自動重置事件。手動重置事件被設置為激發狀態後，會喚醒所有等待的線程，而且一直保持為激發狀態，直到程序重新把它設置為未激發狀態。自動重置事件被設置為激發狀態後，會喚醒<strong>一個</strong>等待中的線程，然後自動恢復為未激發狀態。</p></blockquote><blockquote><p><strong>臨界區</strong> Critical Section：指的是訪問資源的那段代碼，任意時刻只允許一個線程對臨界資源進行訪問。擁有臨界區對象的線程可以訪問該臨界資源，其它試圖訪問該資源的線程將被掛起，直到臨界區對象被釋放。</p></blockquote><h4><u>12.死鎖</u></h4><blockquote><p><strong>1.死鎖的定義</strong></p></blockquote><blockquote><p>是指兩個或兩個以上的進程在執行過程中，因爭奪資源而造成的一種互相等待的現象，若無外力作用，它們都將無法推進下去。此時稱系統處於死鎖狀態或系統產生了死鎖，這些永遠在互相等待的進程稱為死鎖進程。</p></blockquote><blockquote><p><strong>2.死鎖原因</strong>：</p></blockquote><blockquote><p>① 系統資源不足（對不可剝奪資源的競爭）</p><p>② 進程推進順序不當（P1擁有A申請B，P2擁有B申請A）</p></blockquote><blockquote><p><strong>3.產生死鎖的必要條件</strong>：</p></blockquote><blockquote><p>① 互斥條件：指進程對所分配到的資源進行排它性使用，即在一段時間內某資源只由一個進程佔用。</p><p>② 請求和保持條件：指進程已經保持至少一個資源，但又提出了新的資源請求，而該資源已被其它進程佔有，此時請求進程阻塞，但又對自己已獲得的其它資源保持不放。</p><p>③ 不剝奪條件：指進程已獲得的資源，在未使用完之前，不能被剝奪，只能在使用完時由自己釋放</p><p>④ 環路等待條件：指在發生死鎖時，必然存在一個進程資源的環形鏈。</p></blockquote><blockquote><p><strong>4.處理死鎖的基本方法：</strong></p></blockquote><blockquote><p>① 預防死鎖：這是一種較簡單和直觀的事先預防的方法。方法是通過設置某些限制條件，去破壞產生死鎖的四個必要條件中的一個或者幾個，來預防發生死鎖。預防死鎖是一種較易實現的方法，已被廣泛使用。但是由於所施加的限制條件往往太嚴格，可能會導致系統資源利用率和系統吞吐量降低。</p></blockquote><blockquote><p>② 避免死鎖：該方法同樣是屬於事先預防的策略，但它並不須事先採取各種限制措施去破壞產生死鎖的的四個必要條件，而是在資源的動態分配過程中，用 某種方法去防止系統進入不安全狀態，從而避免發生死鎖。</p></blockquote><blockquote><p>③ 檢測死鎖：這種方法並不須事先採取任何限制性措施，也不必檢查系統是否已經進入不安全區，此方法允許系統在運行過程中發生死鎖。但可通過系統所設置的檢測機構，及時地檢測出死鎖的發生，並精確地確定與死鎖有關的進程和資源，然後採取適當措施，從系統中將已發生的死鎖清除掉。</p></blockquote><blockquote><p>④ 解除死鎖：這是與檢測死鎖相配套的一種措施。當檢測到系統中已發生死鎖時，須將進程從死鎖狀態中解脫出來。常用的實施方法是撤銷或掛起一些進程，以便回收一些資源，再將這些資源分配給已處於阻塞狀態的進程，使之轉為就緒狀態，以繼續運行。</p></blockquote><h4><u>13.什麼是飢餓？與死鎖有什麼差別？</u></h4><blockquote><p>等待時間給進程推進和響應帶來明顯影響時成為進程飢餓。</p><p>飢餓並不代表系統已經死鎖，但至少有一個程序的執行被無限期地推遲。 差別： ① 進入飢餓的進程可以只有一個，但是死鎖必須大於等於兩個； ② 出於飢餓狀態的進程可以是一個就緒進程，但是死鎖狀態的進程必定是阻塞進程。</p></blockquote><h4><u>14.銀行家算法</u></h4><blockquote><p>主要思想是避免系統進入不安全狀態，在每次進行資源分配時，它首先檢查系統是否有足夠的資源滿足要 求，如果有，則先試行分配，並對分配後的新狀態進行安全性檢查。如果新狀態安全，則正式分配上述資 源，否則拒絕分配上述資源。這樣就保證系統始終處於安全狀態，從而避免死鎖現象的發生。</p></blockquote><h4><u>15.死鎖定理</u></h4><blockquote><p>如果資源分配圖是可以完全簡化的（能消去所有的邊），則沒有死鎖。</p></blockquote><h2><span>第三章、內存管理</span></h2><p><strong>快速喚起記憶的知識框架</strong></p><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2fa6a9c2a1974f95be5e7fc226ecf8e1></div><h4>16.<u>存儲器管理應具有的功能</u>？</h4><blockquote><p>存儲管理的主要任務是為多道程序的運行提供良好的環境，方便用戶使用存儲器，提高存儲器的利用率以 及從邏輯上擴充存儲器，故應具有以下功能：</p><p>① 內存的分配和回收：實施內存的分配，回收系統或用戶釋放的內存空間。</p><p>② 地址變換：提供地址變換功能，將邏輯地址轉換成物理地址。</p><p>③ 擴充內存：藉助於虛擬存儲技術活其他自動覆蓋技術，為用戶提供比內存空間大的地址空間，從邏輯 上擴充內存。</p><p>④ 存儲保護：保證進入內存的各道作業都在自己的存儲空間內運行，互不干擾。</p></blockquote><h4>17.<u>將用戶程序變為可在內存中執行的程序的步驟</u>？</h4><blockquote><p>1.編譯：由編譯程序將用戶源代碼編譯成若干目標模塊</p><p>2.鏈接：由鏈接程序將編譯後形成的一組目標模塊及所需的庫函數鏈接在一起，形成一個完整的裝入模塊。</p><p>3.裝入：由裝入程序將裝入模塊裝入內存中運行。</p></blockquote><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/96696478404b40e5842e8149569db045></div><h4>18.<u>程序的鏈接方式有哪些</u>？</h4><blockquote><p>① 靜態鏈接：在程序運行之前，先把各個目標模塊及所需庫鏈接為一個完整的可執行程序，以後不再拆 開。</p><p>② 裝入時動態鏈接：將應用程序編譯後所得到的一組目標模塊在裝入內存時採用邊裝入邊鏈接的鏈接方 式。</p><p>③ 運行時動態鏈接：知道程序運行過程中需要一些模塊時，才對這些模塊進行鏈接。</p></blockquote><h4>19.<u>程序的裝入方式有哪些</u>？</h4><blockquote><p>① 絕對裝入：在編譯時就知道程序將要駐留在內存的物理地址，編譯程序產生含有物理地址的目標代碼， 不適合多道程序設計。</p><p>② 可重定位裝入：根據內存當前情況，將裝入模塊裝入到內存的適當位置，地址變換通常在裝入時一次 完成，之後不再改變，也稱靜態重定位。當操作系統為程序分配一個以某地址為起始地址的連續主存 區域後，重定位時將程序中指令或操作數的邏輯地址加上這個起始地址就得到了物理地址。</p><p>③ 動態運行裝入：允許程序運行時在內存中移動位置，把裝入模塊裝入到內存後的所有地址都是相對地 址，在程序執行過程中每當訪問到相應指令或數據時，才將要 訪問的程序或數據的相對地址轉換為物 理地址。動態重定位的實現要依靠硬件地址變換機構。</p></blockquote><h4>20.<u>覆蓋技術和交換技術</u>？</h4><blockquote><p>1.覆蓋技術：</p><p>把一個大的程序劃分為一系列覆蓋，每個覆蓋是一個相對獨立的程序單位，把程序執行時並不要求同時 裝入內存的覆蓋組成一組，成為覆蓋段，這個覆蓋段分配到同一個存儲區域，這個存儲區域成為覆蓋區，它與覆蓋段一一對應。覆蓋段的大小由覆蓋段中最大的覆蓋來確定。（為了解決內存容量太小的問題，打破了必須將一個程序全部信息裝入內存後才能運行的限制）</p></blockquote><blockquote><p>2.交換技術：</p><p>把暫時不用的某個程序及數據部分從內存移到外存中去，以便騰出必要的內存空間；或者把指定的程序或數據從外存讀到相應的內存中，並將控制權交給他，讓其在系統上運行的一種內存擴充技術。處理器的中級調度就是採用交換技術。</p></blockquote><blockquote><p>3.區別： ① 與覆蓋技術相比，交換技術不要求程序員給出的 程序段之間的覆蓋結構；</p><p>② 交換技術主要在進程和作業之間進行，覆蓋技術主要在同一個進程或作業中進行；交換技術主要在進程和作業之間進行，覆蓋技術主要在同一個進程或作業中進行；</p><p>③ 覆蓋技術只能覆蓋於覆蓋程序段無關的程序段，交換進程由換出和換入兩個過程組成。覆蓋技術只能覆蓋於覆蓋程序段無關的程序段，交換進程由換出和換入兩個過程組成。</p></blockquote><h4><u>21.內存連續分配管理方式有哪些？</u></h4><blockquote><p>1.<strong>單一連續分配</strong></p></blockquote><blockquote><p>內存在此方式下分為系統區和用戶區，系統區僅提供給操作系統使用，通常在低地址部分；用戶區是為用戶提供的、除系統區之外的內存空間。這種方式無需進行內存保護。</p><p>這種方式的優點是簡單、無外部碎片，可以釆用覆蓋技術，不需要額外的技術支持。缺點是隻能用於單用戶、單任務的操作系統中，有內部碎片，存儲器的利用率極低。</p></blockquote><blockquote><p>2.<strong>固定分區分配</strong></p></blockquote><blockquote><p>固定分區分配是最簡單的一種多道程序存儲管理方式，它將用戶內存空間劃分為若干個固定大小的區域，每個分區只裝入一道作業。當有空閒分區時，便可以再從外存的後備作業隊列中,選擇適當大小的作業裝入該分區，如此循環。</p><p>固定分區分配在劃分分區時，有兩種不同的方法。</p><p>(1) 分區大小相等：用於利用一臺計算機去控制多個相同對象的場合，缺乏靈活性。</p><p>(2) 分區大小不等：劃分為含有多個較小的分區、適量的中等分區及少量的大分區。</p></blockquote><blockquote><p>3.<strong>動態分區分配</strong></p></blockquote><blockquote><p>動態分區分配又稱為可變分區分配，是一種動態劃分內存的分區方法。這種分區方法不預先將內存劃分，而是在進程裝入內存時，根據進程的大小動態地建立分區，並使分區的大小正好適合進程的需要。因此係統中分區的大小和數目是可變的。</p></blockquote><blockquote><p>4.<strong>動態分區分配算法</strong></p></blockquote><blockquote><p>在進程裝入或換入主存時，如果內存中有多個足夠大的空閒塊，操作系統必須確定分配哪個內存塊給進程使用，這就是動態分區的分配策略，考慮以下幾種算法：</p><p>(1) 首次適應(First Fit)算法：空閒分區以地址遞增的次序鏈接。分配內存時順序查找，找到大小能滿足要求的第一個空閒分區。</p><p>(2) 最佳適應(Best Fit)算法：空閒分區按容量遞增形成分區鏈，找到第一個能滿足要求的空閒分區。</p><p>(3) 最壞適應(Worst Fit)算法：又稱最大適應(Largest Fit)算法，空閒分區以容量遞減的次序鏈接。找到第一個能滿足要求的空閒分區，也就是挑選出最大的分區。</p><p>(4) 鄰近適應(Next Fit)算法：又稱循環首次適應算法，由首次適應算法演變而成。不同之處是分配內存時從上次查找結束的位置開始繼續查找。</p></blockquote><h4>22.<u>基本分頁和請求分頁內存管理方式</u>？</h4><blockquote><p>本問內容比較多，適合系統複習，都整理過來不過全面，請自行查閱相關資料（狗頭保命）。</p></blockquote><h4>23.<u>頁面置換算法有哪些</u>？</h4><blockquote><p>1.最佳（OPT）置換算法</p></blockquote><blockquote><p>從主存中移出永遠不再需要的頁面；如無這樣的頁面存在，則選擇最長時間不需要訪問的頁面。於所選擇的被淘汰頁面將是以後永不使用的，或者是在最長時間內不再被訪問的頁面，這樣可以保證獲得最低的缺頁率。 即被淘汰頁面是以後永不使用或最長時間內不再訪問的頁面。（往後看）</p></blockquote><blockquote><p>2.先進先出（FIFO）置換算法</p></blockquote><blockquote><p>是最簡單的頁面置換算法。這種算法的基本思想是：當需要淘汰一個頁面時，總是選擇駐留主存時間最長的頁面進行淘汰，即先進入主存的頁面先淘汰。其理由是：最早調入主存的頁面不再被使用的可能性最大。 即優先淘汰最早進入內存的頁面。（往前看）</p></blockquote><blockquote><p>3.最近最久未使用（LRU）算法</p></blockquote><blockquote><p>這種算法的基本思想是：利用局部性原理，根據一個作業在執行過程中過去的頁面訪問歷史來推測未來的行為。它認為過去一段時間裡不曾被訪問過的頁面，在最近的將來可能也不會再被訪問。所以，這種算法的實質是：當需要淘汰一個頁面時，總是選擇在最近一段時間內最久不用的頁面予以淘汰。 即淘汰最近最長時間未訪問過的頁面。（往前看）</p></blockquote><blockquote><p>4.時鐘(CLOCK)置換算法</p></blockquote><blockquote><p>LRU算法的性能接近於OPT,但是實現起來比較困難，且開銷大；FIFO算法實現簡單，但性能差。所以操作系統的設計者嘗試了很多算法，試圖用比較小的開銷接近LRU的性能，這類算法都是CLOCK算法的變體。 簡單的CLOCK算法是給每一幀關聯一個附加位，稱為使用位。當某一頁首次裝入主存時，該幀的使用位設置為1;當該頁隨後再被訪問到時，它的使用位也被置為1。對於頁替換算法，用於替換的候選幀集合看做一個循環緩衝區，並且有一個指針與之相關聯。當某一頁被替換時，該指針被設置成指向緩衝區中的下一幀。當需要替換一頁時，操作系統掃描緩衝區，以查找使用位被置為0的一幀。每當遇到一個使用位為1的幀時，操作系統就將該位重新置為0；如果在這個過程開始時，緩衝區中所有幀的使用位均為0，則選擇遇到的第一個幀替換；如果所有幀的使用位均為1,則指針在緩衝區中完整地循環一週，把所有使用位都置為0，並且停留在最初的位置上，替換該幀中的頁。由於該算法循環地檢查各頁面的情況，故稱為CLOCK算法，又稱為最近未用(Not Recently Used, NRU)算法。</p></blockquote><h4><u>24.什麼是頁表和快表，有什麼作用？</u></h4><blockquote><p>頁表指出邏輯地址中的頁號與所佔主存塊號的對應關係。作用：頁式存儲管理在用動態重定位方式裝入作業時，要利用頁表做地址轉換工作。快表就是存放在高速緩衝存儲器的部分頁表。它起頁表相同的作用。由於採用頁表做地址轉換，讀寫內存數據時CPU要訪問兩次主存。有了快表，有時只要訪問一次高速緩衝存儲器，一次主存，這樣可加速查找並提高指令執行速度。</p></blockquote><h4>25.<u>地址翻譯的過程</u>？</h4><blockquote><p>TLB->頁表（TLB不命中）->Cache->主存（Cache不命中）->外存</p></blockquote><h2><span>第四章、文件管理</span></h2><p><strong>本章重要程度比較低</strong></p><p><strong>快速喚起記憶知識框架</strong></p><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3236fa44605749f28034cbf8e8bd67a0></div><h4>26.<u>文件的基本操作</u>？</h4><blockquote><p>文件屬於抽象數據類型。為了恰當地定義文件，就需要考慮有關文件的操作。操作系統提供系統調用，它對文件進行創建、寫、讀、定位和截斷。</p><p>①創建文件：創建文件有兩個必要步驟，一是在文件系統中為文件找到空間；二是在目錄中為新文件創建條目，該條目記錄文件名稱、在文件系統中的位置及其他可能信息。</p><p>②寫文件：為了寫文件，執行一個系統調用，指明文件名稱和要寫入文件的內容。對於給定文件名稱，系統搜索目錄以查找文件位置。系統必須為該文件維護一個寫位置的指針。每當發生寫操作，便更新寫指針。</p><p>③讀文件：為了讀文件，執行一個系統調用，指明文件名稱和要讀入文件塊的內存位置。同樣，需要搜索目錄以找到相關目錄項，系統維護一個讀位置的指針。每當發生讀操作時，更新讀指針。一個進程通常只對一個文件讀或寫，所以當前操作位置可作為每個進程當前文件位置指針。由於讀和寫操作都使用同一指針，節省了空間也降低了系統複雜度。</p><p>④文件重定位（文件尋址）：按某條件搜索目錄，將當前文件位置設為給定值，並且不會讀、寫文件。</p><p>⑤刪除文件：先從目錄中找到要刪除文件的目錄項，使之成為空項，然後回收該文件所佔用的存儲空間。</p><p>⑥截斷文件：允許文件所有屬性不變，並刪除文件內容，即將其長度設為0並釋放其空間。</p><p>這6個基本操作可以組合執行其他文件操作。例如，一個文件的複製，可以創建新文件、 從舊文件讀出並寫入到新文件。</p></blockquote><h4>27.<u>磁盤調度算法有哪些</u>？</h4><blockquote><p><strong>1、先來先服務算法（FCFS）First Come First Service</strong></p></blockquote><blockquote><p>這是一種比較簡單的磁盤調度算法。它根據進程請求訪問磁盤的先後次序進行調度。此算法的優點是公平、簡單，且每個進程的請求都能依次得到處理，不會出現某一進程的請求長期得不到滿足的情況。此算法由於未對尋道進行優化，在對磁盤的訪問請求比較多的情況下，此算法將降低設備服務的吞吐量，致使平均尋道時間可能較長，但各進程得到服務的響應時間的變化幅度較小。</p></blockquote><blockquote><p><strong>2、最短尋道時間優先算法（SSTF） Shortest Seek Time First</strong></p></blockquote><blockquote><p>該算法選擇這樣的進程，其要求訪問的磁道與當前磁頭所在的磁道距離最近，以使每次的尋道時間最短，該算法可以得到比較好的吞吐量，但卻不能保證平均尋道時間最短。其缺點是對用戶的服務請求的響應機會不是均等的，因而導致響應時間的變化幅度很大。在服務請求很多的情況下，對內外邊緣磁道的請求將會無限期的被延遲，有些請求的響應時間將不可預期。</p></blockquote><blockquote><p><strong>3、掃描算法（SCAN）電梯調度</strong></p></blockquote><blockquote><p>掃描算法不僅考慮到欲訪問的磁道與當前磁道的距離，更優先考慮的是磁頭的當前移動方向。例如，當磁頭正在自裡向外移動時，掃描算法所選擇的下一個訪問對象應是其欲訪問的磁道既在當前磁道之外，又是距離最近的。這樣自裡向外地訪問，直到再無更外的磁道需要訪問才將磁臂換向，自外向裡移動。這時，同樣也是每次選擇這樣的進程來調度，即其要訪問的磁道，在當前磁道之內，從而避免了飢餓現象的出現。由於這種算法中磁頭移動的規律頗似電梯的運行，故又稱為電梯調度算法。此算法基本上克服了最短尋道時間優先算法的服務集中於中間磁道和響應時間變化比較大的缺點，而具有最短尋道時間優先算法的優點即吞吐量較大，平均響應時間較小，但由於是擺動式的掃描方法，兩側磁道被訪問的頻率仍低於中間磁道。</p></blockquote><blockquote><p><strong>4、循環掃描算法（CSCAN）</strong></p></blockquote><blockquote><p>循環掃描算法是對掃描算法的改進。如果對磁道的訪問請求是均勻分佈的，當磁頭到達磁盤的一端，並反向運動時落在磁頭之後的訪問請求相對較少。這是由於這些磁道剛被處理，而磁盤另一端的請求密度相當高，且這些訪問請求等待的時間較長，為了解決這種情況，循環掃描算法規定磁頭單向移動。例如，只自裡向外移動，當磁頭移到最外的被訪問磁道時，磁頭立即返回到最裡的欲訪磁道，即將最小磁道號緊接著最大磁道號構成循環，進行掃描。</p></blockquote><h2><span>第五章、輸入輸出管理</span></h2><p><strong>快速喚起記憶知識框架</strong></p><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/365f860adfbd434ab11db88eaf677bf3></div><h4>28.I/O<u>控制方式有哪些</u>？</h4><blockquote><p><strong>1.程序 I/O 方式</strong></p></blockquote><blockquote><p>早期的計算機系統中， 沒有中斷系統，所以CPU和I/O設備進行通信，傳輸數據時CPU速度遠快於I/O設備，於是CPU需要不斷測試I/O設備，看其是否完成了傳輸。</p></blockquote><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc5dfb2b99f0454eb3fef38d5a2de470></div><blockquote><p>2.<strong>中斷驅動方式</strong></p></blockquote><blockquote><p>當某進程要啟動某個 I/O 設備工作時，便由 CPU 向相應的設備控制器發出一條 I/O 命令，然後立即返回繼續執行原來的任務。僅當輸完一個數據時，才需 CPU 花費極短的時間去做些中斷處理。</p></blockquote><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1ea07d02bd04482988958549dd93f8e2></div><blockquote><p><strong>3.DMA方式（直接存儲器訪問）</strong></p></blockquote><blockquote><p>通過在I/O設備和內存之間開啟一個可以直接傳輸數據的通路，採用DMA控制器來控制一個數據塊的傳輸，CPU只需在一個數據塊傳輸開始階段設置好傳輸所需的控制信息，並在傳輸結束階段做進一步處理。</p></blockquote><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/950cd0849d0d40ae9e8514d837a9b18e></div><blockquote><p><strong>4.I/O通道控制方式</strong></p></blockquote><blockquote><p>雖然DMA方式比起中斷方式來已經顯著地減少了CPU的干預，即已由以字（節）為單位的干預減少到以數據塊為單位的干預。但CPU每發出一條I/O指令，也只能去讀/寫一個連續的數據塊。而當我們需要一次去讀多個數據塊且將它們分別傳送到不同的內存區域，或者相反時，則需由CPU分別發出多條I/O指令及進行多次中斷處理才能完成。 ---- 通道控制方式與DMA控制方式類似，也是一種以內存為中心，實現設備與內存直接交換數據的控制方式。 ---- 與DMA控制方式相比，通道方式所需要的CPU干預更少，而且可以做到一個通道控制多臺設備，從而進一步減輕了CPU負擔。 ---- 通道本質上是一個簡單的處理器，專門負責輸入、輸出控制，具有執行I/O指令的能力，並通過執行通道I/O程序來控制I/O操作。 ---- 通道的指令系統比較簡單，一般只有數據傳送指令、設備控制指令等。</p></blockquote><h4>29.<u>Spooling技術</u>？</h4><blockquote><p>虛擬性是OS的四大特性之一。如果說可以通過多道程序技術將一臺物理CPU虛擬為多臺邏輯CPU，從而允許多個用戶共享一臺主機，那麼，通過SPOOling技術便可將一臺物理I/O設備虛擬為多臺邏輯I/O設備，同樣允許多個用戶共享一臺物理I/O設備。</p></blockquote><blockquote><p>SPOOLing技術是對脫機輸入、輸出系統的模擬。相應地，SPOOLing系統必須建立在具有多道程序功能的操作系統上，而且還應有高速隨機外存的支持，這通常是採用磁盤存儲技術。</p></blockquote><blockquote><p>SPOOLing系統主要有以下三部分：</p><p>（1）輸入井和輸出井。這是在磁盤上開闢的兩個大存儲空間。輸入井是模擬脫機輸入時的磁盤設備，用於暫存I/Q設備輸入的數據；輸出井是模擬脫機輸出時的磁盤，用於暫存用戶程序的輸出數據。</p><p>（2）輸入緩衝區和輸出緩衝區。為了緩和和CPU和磁盤之間速度不匹配的矛盾，在內存中要開闢兩個緩衝區；輸入緩衝區和輸出緩衝區。輸入緩衝區用於暫存由輸入設備送來的數據，以後再傳送到輸入井。輸出緩衝區用與暫存從輸出井送來的數據，以後在傳送給輸出設備。</p><p>（3）輸入進程SPi 和輸入進程SP0。這裡利用兩個進程來模擬脫機I/O時的外圍控制機。其中，進程SPi模擬脫機輸入時的外圍控制機，將用戶要求的數據從輸入機通過輸入緩衝區再送到輸入井，當CPU需要輸入數據時，直接從輸入井讀入內存；進程SP0模擬脫機輸出時的外圍控制機，把用戶要求輸出的數據從先內存送到輸出井，待輸出設備空閒時，在將輸出井中的數據經過輸出緩衝區送到輸出設備上。</p></blockquote><blockquote><p>SPOOLing技術的特點：</p><p>(1)提高了I/O速度。從對低速I/O設備進行的I/O操作變為對輸入井或輸出井的操作，如同脫機操作一樣，提高了I/O速度，緩和了CPU與低速I/O設備速度不匹配的矛盾。</p><p>(2)將獨佔設備改造為共享設備。因為在SPOOLing系統的系統中，實際上並沒為任何進程分配設備，而知識在輸入井或輸出井中為進程分配一個存儲區和建立一張I/O請求表。這樣，便把獨佔設備改造為共享設備。</p><p>(3)實現了虛擬設備功能。多個進程同時使用一獨享設備，而對每一進程而言，都認為自己獨佔這一設備，從而實現了設備的虛擬分配。不過，該設備是邏輯上的設備。</p></blockquote><div class=pgc-img><img alt="計算機考研複試面試常問問題 操作系統篇" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5010699c5b974bfea1562fbc76dddb50></div><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>計算機</a></li><li><a>試面</a></li><li><a>試常問</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html alt=計算機中數字、文字、圖像、聲音和視頻的表示與編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8d1d3ec88f2c4a158c7efe55b21d6ed7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html title=計算機中數字、文字、圖像、聲音和視頻的表示與編碼>計算機中數字、文字、圖像、聲音和視頻的表示與編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8582e44e.html alt="計算機實驗室之樹莓派：課程 7 屏幕02" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa8f776ea6c84f08b0fbfaad451371e0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8582e44e.html title="計算機實驗室之樹莓派：課程 7 屏幕02">計算機實驗室之樹莓派：課程 7 屏幕02</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html alt="“頂點”計算機面世 登頂超級計算機榜首" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15287045778959b8cdf2283 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html title="“頂點”計算機面世 登頂超級計算機榜首">“頂點”計算機面世 登頂超級計算機榜首</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html alt=美媒揭祕最新世界最快超級計算機“頂點” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html title=美媒揭祕最新世界最快超級計算機“頂點”>美媒揭祕最新世界最快超級計算機“頂點”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html alt=計算機求解微分方程的六大數值計算方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5b33cbb521894b5aa7f4cf8e1c795cf2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html title=計算機求解微分方程的六大數值計算方法>計算機求解微分方程的六大數值計算方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html alt=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a03090d0e5804e88b4003fdcdfa7a301 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html title=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？>你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html alt=第一臺通用數字電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html title=第一臺通用數字電子計算機>第一臺通用數字電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html alt=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f30831efce324fd8ad5055d5c3312dfe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html title=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四>第一臺電子計算機的發明者諾依曼，中外發明家故事之十四</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html alt=計算機發展全歷程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/68bbbb84608c4db28b2cf2687596239a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html title=計算機發展全歷程>計算機發展全歷程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbc9d4e3.html alt=電子計算機的類別有些什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0a5e8724-b70f-4cdf-bebb-1091bfcd66d7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbc9d4e3.html title=電子計算機的類別有些什麼？>電子計算機的類別有些什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d2a4dab.html alt=五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/78bc8448e150430b99df693674b71771 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d2a4dab.html title=五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大>五分鐘帶你瞭解計算機進化史，原來第一臺電子計算機居然這麼大</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cf191e1.html alt=古代也有黑科技：周朝的智能機器人，元朝的電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b254baabbed34cccbcc700e6fb6fcbf3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cf191e1.html title=古代也有黑科技：周朝的智能機器人，元朝的電子計算機>古代也有黑科技：周朝的智能機器人，元朝的電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2346757d.html alt="揭祕新中國首臺電子計算機：佔地40平 每秒運算30次" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a0d9b66e59d04cb0a5e0c52df3a72993 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2346757d.html title="揭祕新中國首臺電子計算機：佔地40平 每秒運算30次">揭祕新中國首臺電子計算機：佔地40平 每秒運算30次</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30e4f36e.html alt=核武器研製並非全靠算盤，電子計算機擔當主力，運算能力你想不到 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a0396a228aea47449d977817792de281 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30e4f36e.html title=核武器研製並非全靠算盤，電子計算機擔當主力，運算能力你想不到>核武器研製並非全靠算盤，電子計算機擔當主力，運算能力你想不到</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62052e23.html alt=科技知識分享：現代電子計算機的發展史，分為幾個階段？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/11aea52a116e4c499e16ba32d2c36725 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62052e23.html title=科技知識分享：現代電子計算機的發展史，分為幾個階段？>科技知識分享：現代電子計算機的發展史，分為幾個階段？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>