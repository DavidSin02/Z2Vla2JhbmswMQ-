<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>邵國際：C 語言對象化設計實例——命令解析器 | 极客快訊</title><meta property="og:title" content="邵國際：C 語言對象化設計實例——命令解析器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/37f006520d4d46e09f5e0fb90c598f2d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9c0fb0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9c0fb0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9c0fb0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9c0fb0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9c0fb0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9c0fb0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9c0fb0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9c0fb0.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="邵國際：C 語言對象化設計實例——命令解析器"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f9c0fb0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>邵國際：C 語言對象化設計實例——命令解析器</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>本文系轉載，著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p><p>作者： 邵國際</p><p>來源： 微信公眾號linux閱碼場(id: linuxdev)</p><div class=pgc-img><img alt="邵國際：C 語言對象化設計實例——命令解析器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37f006520d4d46e09f5e0fb90c598f2d><p class=pgc-img-caption></p></div><p><strong>內容簡介</strong></p><p>單片機工程師常常疑惑為什麼 Linux 驅動框架要搞那麼複雜的一套，殊不知這種「複雜」才是面向對象設計的精髓。對代碼的高度抽象和封裝可大大提高軟件的複用性、可維護性。本文從一個簡單例子 —— 51 單片機上的串口命令解析器程序出發，對比過程式與對象式思維差異，分享自己對 OO 的一點淺薄看法。</p><p><strong>作者介紹</strong></p><p>邵國際，計算機專業學生，擅長動手，熱衷物聯網。用技術表達自我，雖然是個玩過單片機的渣渣，但一直想做出好玩有趣的東西（軟/硬件），並享受其中的樂趣。目前在深圳增長見識、學習嵌入式開發技術中。</p><div class=pgc-img><img alt="邵國際：C 語言對象化設計實例——命令解析器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27108458f7f544fbb67dbe3493fe0428><p class=pgc-img-caption></p></div><h1>前言</h1><p>傳統單片機 MCU 編程大多使用過程式的思維來組織程序，在單片機資源少、功能簡單、代碼規模小的情況下，「想到啥寫啥」的方法也確實能解決大部分問題。但隨著硬件的快速升級，如今的大部分嵌入式工程師已經不再需要「掐著內存」來寫代碼了。當軟件的規模越發龐大、複雜，這時如何編寫可複用、便於維護的代碼顯得尤為重要。本文通過一個在 51 單片上實現的簡單「串口命令解析器」例子，分析如何通過面向對象思想編寫出「高內聚低耦合」的 C 語言程序。</p><p>本文是學習宋寶華老師的《C語言大型軟件設計的面向對象》課程（地址：http://edu.csdn.net/course/detail/6496） 後的一些收穫。</p><p>相關閱讀：《C語言的面向對象（面向較大型軟件）》ppt分享和ppt註解https://mp.weixin.qq.com/s?__biz=MzAwMDUwNDgxOA==&mid=2652662685&idx=2&sn=74bbc8d753c7696832b5b0c827fd1d66&chksm=810f2d00b678a416807bf461879cff7d0836a445a0a4233130556df09f90b5395f158e1c112e&scene=21#wechat_redirect</p><h1>C 語言也能面向對象？</h1><p>在許多年輕人眼裡，C 是一門既「老土」又「古板」的編程語言，更可怕的是，「C 老頭」常年被人貼上「面向過程」的標籤，與 Java、Pyhon 等面向對象的高級語言格格不入。</p><p>事實上，面向對象只是一種思想，與語言無關（只不過C++、Java 在語法形式上天然支持 OO），靈活的 C 語言當然也能實現面向對象的編程 —— 這些觀點我以前也都聽過，但僅僅停留在字面意思的感受。直到看了宋老師的直播中的幾個實例，我才加深了對 C 語言面向對象的理解，更進一步體會到 OO 思想的強大。其中課程裡提到的「命令解析器」便是典型例子，下面和大家分享一下其中的思想精髓與具體實現，體會傳統過程式思維與 OO 思維的差異。</p><p>PS：由於筆者真是個菜雞，個人理解難免會有偏差，更多隻是拾人牙慧，歡迎指正。</p><h1>命令解析器</h1><div class=pgc-img><img alt="邵國際：C 語言對象化設計實例——命令解析器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03039f9be67140aeb00590462a17d1d1><p class=pgc-img-caption></p></div><p>通過命令操控計算機是一件很酷的事情，在 DOS、Linux 系統中也廣泛使用命令行的方式。命令操作的核心便是命令解析器（如 Linux 中的 Shell）。命令解析器實現接收命令字符串，解析命令並執行相應操作，在單片機程序中也常常通過串口命令為用戶提供操作接口（如 AT 指令）。</p><h1>過程式設計</h1><p>簡單來說，命令解析器的核心功能其實就是字符串比較，調用相應函數，使用 C 語言的選擇結構便可輕鬆實現，你甚至能直接想到對應代碼，於是你寫出了像這樣的程序：</p><div class=pgc-img><img alt="邵國際：C 語言對象化設計實例——命令解析器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc5781ccbdf24c96aa7e7cc227c31c43><p class=pgc-img-caption></p></div><p>你非常機智地採用模塊化編程，每個子功能都用單獨的 .c 文件存放。在 cmd.c 中進行命令的處理，通過條件語句比較命令，匹配後調用 gpio.c、spi.c、i2.c 文件中對應的操作函數，代碼一氣呵成。我的第一反應也是這樣寫，嗯，沒毛病。</p><p>這是典型的過程式思維 —— 先幹什麼後幹什麼，把所有零零散散的操作通過一根時間軸串起來，沒有絲毫拐彎抹角，非常直接。但這樣的過程式設計存在明顯的兩個問題：</p><ol start=1><li>命令增加引起跨模塊修改</li><li>大量的外部函數，模塊間高耦合</li></ol><p>下面來具體解釋一下遇到的這兩個問題。</p><p>1. 命令增加引起跨模塊修改</p><p>假設現在需求變化，要求增加 GPIO翻轉 命令產生對應的電平變化。你趕緊在 gpio.c 文件中需要增加一個電平翻轉操作函數 gpio_toggle()，同時在 cmd.c 的 switch-case 語句內部添加新增的命令及函數……</p><p>等等，這不是很怪麼？只是增加了 GPIO 相關功能，命令處理邏輯沒變（依然只是判斷字符串相等），為什麼卻要改動 cmd.c 的命令處理邏輯？而且還是沒啥技術含量地加了一條 case 語句……</p><p>改兩個文件或許咬咬牙就算了，如果工程日益增大，導致每增加一條命令都要像「砌牆」或者「擰螺絲」一樣做一堆機械重複的工作，這樣的代碼一點都不酷。</p><p>2. 大量的外部函數，模塊間高耦合</p><p>如果說跨模塊修改只是一個「麻煩點兒」的問題，勤快的人毫不在乎（好吧你們贏了），那模塊間高耦合則直接影響了代碼的複用性 —— 代碼不通用！這就不是小問題了。高複用性可謂碼農的一大追求，誰不想只寫一次代碼就可以拼湊成各種大項目，輕輕鬆鬆躺著賺錢呢？</p><p>某年後，你遇到了一個新系統，其中也需要命令解析器功能模塊，於是你興沖沖把之前寫的 cmd.c和 cmd.h 直接拿過來用，卻發現編譯報錯找不到 gpiohigh()、gpiolow()、spi_send()……你的內心是崩潰的。</p><p>由於 gpiohigh()、gpiolow() 等函數都是 gpio.c 中的外部函數，在 cmd.c 中直接通過函數名調用，兩個文件像纏綿的情侶般高度耦合，這種緊密的聯繫破壞了C 程序設計的一個基本原則 —— 模塊的獨立性。採用了模塊化編程，然而每個模塊卻不能獨立使用，意義何在？</p><h1>面向對象設計</h1><p>在前面發現的兩個問題上對症下藥，可以得到程序的改進目標：</p><ol start=1><li>增加或減少命令不影響 cmd.c</li><li>命令的處理函數要成為 static，去耦合</li></ol><h1>OO思想</h1><p>在解決這兩個問題前，讓我們回到思維層面，對比「面向對象」與「面向過程」思想的區別。當我們談論面向過程思維時，程序員的角色像一個統治者，掌管一切、什麼都要插一手。</p><p>舉個典型例子，要把大象裝到冰箱需要三步：</p><ol start=1><li>打開冰箱門</li><li>將大象放進冰箱</li><li>關閉冰箱門</li></ol><p>這一系列步驟的主動權都牢牢掌握在操作者手裡，操作者按部就班地把具體操作與時間軸綁定起來，是典型的過程思維。再回到前面匹配命令的 switch-case 語句上，每增加一條新命令都需要程序員手把手地把命令和函數寫死在程序中。於是我們就會想，能不能讓命令解析器作為一個主動的個體自己增加命令？</p><p>這裡就引入了「對象」的概念，什麼是對象？我們所關注的一切事物皆為對象。在「把大象裝到冰箱」問題中，把「大象」、「冰箱」這兩個名詞提取出來，就是兩個對象。過程式思維解決問題時考慮「需要哪些步驟」，而 OO 思想考慮「需要哪些對象」。</p><p>還是這個例子，要把大象裝到冰箱只需要兩個對象：</p><ol start=1><li>冰箱</li><li>大象</li></ol><p>如何描述一個對象呢？可以通過兩個方面，一是對象的特徵（屬性），二是對象的行為（方法/函數）。由此可以列舉出描述大象和冰箱的一些屬性和方法：</p><p>• 大象的屬性（特徵）：品種、體形、鼻長……</p><p>• 大象的方法（行為）：進食、走路、睡覺……</p><p>• 冰箱的屬性（特徵）：價格、容量、功耗……</p><p>• 冰箱的方法（行為）：開關機、開關門、除霜去冰……</p><p>對象有如此多的屬性和方法，但實際上並不都能用得上。不同問題涉及到對象的不同方面，因此可以忽略無關的屬性、方法。對於「把大象裝到冰箱」這個問題，我們只關心「大象的體形」、「冰箱的容量」、「大象走路（說不定能讓大象自己走進冰箱）」、「冰箱開關門」等這些與問題相關的屬性和方法。</p><p>於是程序就成了「冰箱開門、大象走進冰箱並告訴冰箱關門」的模式，將操作的主動權歸還對象本身時，程序員不再是霸道的統治者，而是扮演管理員的角色，協調各對象基於自身的屬性和方法完成所需功能。</p><h1>OO 版命令解析器</h1><p>迴歸正題，如何才能解決前面的兩個問題、讓命令解析器更「OO」呢？首先對最終功能 ——「命令解析器解析命令」這句話深度挖掘，注意到「命令」、「命令解析器」這兩個名詞可以抽象成對象。</p><p><strong>命令類型的封裝</strong></p><p>首先是「命令」本身可以封裝為包含「命令名」和「對應操作」兩個成員的結構體，前者是屬性，可用字符數組存儲，後者在邏輯上是行為/函數，但由於 C 語言結構體不支持函數，可用函數指針存儲。這相當於把「命令」定義成了新的數據類型，將命令與操作聯繫起來。</p><pre>// 文件名稱： cmd.h #define MAX_CMD_NAME_LENGTH 20 // 最大命令名長度，過大 51 內存會炸#define MAX_CMDS_COUNT 10 // 最大命令數，過大 51 內存會炸 typedef void (*handler)(void); // 命令操作函數指針類型 /* 命令結構體類型 */typedef struct cmd{ char cmd_name[MAX_CMD_NAME_LENGTH + 1]; // 命令名  handler cmd_operate; // 命令操作函數} CMD;</pre><p>其中宏 MAXCMDNAME_LENGTH 表示所存儲命令名的最大長度，handler 為指向命令操作函數的指針，所有命令操作函數均為無參無返回值。</p><p><strong>命令解析器的封裝</strong></p><p>同理，「命令解析器」這一模塊也可以看做一個對象，對功能模塊的封裝已經在文件結構上體現，就沒必要用結構體了，我們重點關注對象的內部（即成員變量與成員函數）。</p><p><strong>成員變量</strong></p><p>命令解析器要從一堆命令中匹配一個，因此需要一種能存儲命令集合的數據結構，這裡使用數組實現線性表：</p><pre>// 文件名稱： cmd.h /* 命令列表結構體類型 */typedef struct cmds{ CMD cmds[MAX_CMDS_COUNT]; // 列表內容 int num; // 列表長度} CMDS;</pre><p>通過結構體封裝數據類型定義成員變量類型，方便在 cmd.c 中使用：</p><pre>// 文件名稱： cmd.c static xdata CMDS commands = {NULL, 0}; // 全局命令列表，保存已註冊命令集合</pre><p>為了簡化程序，線性表的「增刪改查」等基本操作就不一一獨立實現了，而是與命令處理過程結合（命令的註冊與匹配其實就是插入與查找過程）。下面考慮對象的成員函數。</p><p><strong>成員函數</strong></p><p>命令解析器涉及到那些行為呢？首要任務當然是匹配並執行指令。其次，要對外提供增加命令的接口函數，由處理命令功能模塊主動註冊命令，而不是通過代碼寫死，從而就避免了跨模塊修改，硬件無關的代碼也提高了程序的可移植性。</p><p>編寫 match_cmd() 函數實現命令匹配，該函數接收一個待匹配的命令字符串作為參數，對命令列表進行遍歷比較操作：</p><pre>// 文件名稱： cmd.c void match_cmd(char *str){ int i;  if (strlen(str) &gt; MAX_CMD_NAME_LENGTH) { return; }  for (i = 0; i &lt; commands.num; i++) // 遍歷命令列表 { if (strcmp(commands.cmds[i].cmd_name, str) == 0) { commands.cmds[i].cmd_operate(); } }}</pre><p>接著再實現註冊命令函數，該函數接收一個命令類型數組，插入到命令解析器的命令列表中：</p><pre>// 文件名稱： cmd.c void register_cmds(CMD reg_cmds[], int length){ int i;  if (length &gt; MAX_CMDS_COUNT) { return; }  for (i = 0; i &lt; length; i++) { if (commands.num &lt; MAX_CMDS_COUNT) // 命令列表未滿 { strcpy(commands.cmds[commands.num].cmd_name, reg_cmds[i].cmd_name); commands.cmds[commands.num].cmd_operate = reg_cmds[i].cmd_operate; commands.num++; }  } }</pre><p>至此，命令解析器便大功告成！通過調用兩個函數即可完成命令的添加與匹配功能，接下來編寫 LED 燈和蜂鳴器的操作函數，測試命令解析器功能。</p><h1>命令解析器的使用</h1><p><strong>註冊和匹配命令</strong></p><p>編寫 led.c 文件，實現 LED 的亮滅操作函數，在 led_init() 函數中註冊命令並初始化硬件：</p><pre>// 文件名稱： led.c static void led_on(void){ LED1 = 0;} static void led_off(void){ LED1 = 1;} void led_init(void){ /* 填充命令結構體數組 */ CMD led_cmds[] = { {"led on", led_on}, {"led off", led_off} };  /* 註冊命令 */ register_cmds(led_cmds, ARRAY_SIZE(led_cmds));   /* 初始化硬件 */ led_off();}</pre><p>可以看到，命令處理函數 ledon() 和 ledoff() 都是 static 修飾的內部函數，在其他模塊中不能通過函數名直接調用，而是通過函數指針的方式傳遞，實現了模塊間解耦。再者，使用結構體數組註冊命令，大大增加程序擴展性。</p><p>按照同樣的套路編寫 beep.c 文件實現蜂鳴器控制命令。</p><p>最後，在主函數 while(1) 循環中接受串口字符串、解析命令並執行：</p><pre>// 文件名稱： main.c void main(){ unsigned char str[20];  uart_init(); led_init(); beep_init();  while (1) {  /* 獲取串口命令字符串 */ uart_get_string(str);  /* 匹配命令並執行 */ match_cmd(str);  /* 命令回顯 */ uart_send_string(str); uart_send_byte('\n');  }}</pre><p><strong>增加命令</strong></p><p>在經過了高度抽象封裝的命令解析器上增加一條命令，如 LED 翻轉，只需要在 led.c 中增加 led_toggle() 函數，並往待註冊的命令結構體數組初始化列表中添加一個元素，然後……就完了，即使加 100 條新命令也完全不需要動 cmd.c 中的代碼，兩個模塊彼此獨立。</p><pre>// 文件名稱： led.c static void led_toggle(void) // 增加 LED 翻轉函數{ LED1 = ~LED1;} void led_init(void){ /* 填充命令結構體數組 */ CMD led_cmds[] = { {"led on", led_on}, {"led off", led_off}, {"led toggle", led_toggle} // 增加 LED 翻轉命令 };  /* 註冊命令 */ register_cmds(led_cmds, ARRAY_SIZE(led_cmds));   /* 初始化硬件 */ led_off();}</pre><p>此外，如果 cmd.c 中改用其他數據結構存儲命令集合，也與 led.c 無關，徹底切斷兩個文件的強耦合。cmd.c 現已升級為一個通用的命令解析器。</p><h1>實驗效果</h1><div class=pgc-img><img alt="邵國際：C 語言對象化設計實例——命令解析器" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c47caa8d308e43aea06e978eaed2c963><p class=pgc-img-caption></p></div><h1>總結</h1><p>從最初手動往 cmd.c 中添加命令代碼，到最後通過函數「智能操作」，OO 思想實現把權利下放，每個模塊自己的事自己解決（功能模塊需要命令功能時自己主動註冊即可），程序員再也不用對所有細節親力親為，而是為每個對象賦予該有的能力，然後對它們說上一句：「你辦事我放心」！</p><p>工程示例代碼下載：鏈接：http://pan.baidu.com/s/1geKE2ll 密碼：e0ku</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>邵國際</a></li><li><a>語言</a></li><li><a>象化</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html alt=什麼是梯度：用形象的語言解讀梯度的本質原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/557c7b377c5449bb885df35b2d354e03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html title=什麼是梯度：用形象的語言解讀梯度的本質原理>什麼是梯度：用形象的語言解讀梯度的本質原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html alt=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S5YRqTH6awaqmG style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html title=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行>我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html alt=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/46ea0001172cab9535dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html title=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用>谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html alt=C語言經典100例004-統計各個年齡階段的人數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/98c4bb54-8d7e-4234-bf07-0d8190ba1a0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html title=C語言經典100例004-統計各個年齡階段的人數>C語言經典100例004-統計各個年齡階段的人數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html alt=CC++語言19｜靜態成員（對象共享數據成員及其成員函數） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html title=CC++語言19｜靜態成員（對象共享數據成員及其成員函數）>CC++語言19｜靜態成員（對象共享數據成員及其成員函數）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc78327d.html alt=零基礎學C語言——運算符 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/fa8bd8c0-66cc-4cf5-a447-dbe6409abebb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc78327d.html title=零基礎學C語言——運算符>零基礎學C語言——運算符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html alt="Java入門 - 語言基礎 - 18.正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ddf3412c71244bcaa3cb911e988fed3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html title="Java入門 - 語言基礎 - 18.正則表達式">Java入門 - 語言基礎 - 18.正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a4dfb108.html alt=中國的主要語言和方言分佈：你的家鄉說的是什麼話？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a57a5bd9fd3d431991bf2e3fdb12f9e8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a4dfb108.html title=中國的主要語言和方言分佈：你的家鄉說的是什麼話？>中國的主要語言和方言分佈：你的家鄉說的是什麼話？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45b722bf.html alt=第12屆自然語言處理和知識工程國際會議將在西華大學舉行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45b722bf.html title=第12屆自然語言處理和知識工程國際會議將在西華大學舉行>第12屆自然語言處理和知識工程國際會議將在西華大學舉行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49bb3bbd.html alt=第12屆自然語言處理與知識工程國際學術會議在西華大學舉行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e62000034a58600d55e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49bb3bbd.html title=第12屆自然語言處理與知識工程國際學術會議在西華大學舉行>第12屆自然語言處理與知識工程國際學術會議在西華大學舉行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4be34efa.html alt=C語言：數據結構-二叉樹的定義和基本術語和二叉樹的性質 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f9fe517ff46746b99d14e3e154a1d319 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4be34efa.html title=C語言：數據結構-二叉樹的定義和基本術語和二叉樹的性質>C語言：數據結構-二叉樹的定義和基本術語和二叉樹的性質</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8fc4504f.html alt=一招吃透C語言二叉樹的遍歷？二叉樹的遞歸遍歷與非遞歸遍歷 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/fa03f040-a2c1-4766-a88b-19499d75cf22 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8fc4504f.html title=一招吃透C語言二叉樹的遍歷？二叉樹的遞歸遍歷與非遞歸遍歷>一招吃透C語言二叉樹的遍歷？二叉樹的遞歸遍歷與非遞歸遍歷</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/14de871a.html alt=等距離股票配對量化交易策略-R語言 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b4586e2813564491aec7530eeb937930 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/14de871a.html title=等距離股票配對量化交易策略-R語言>等距離股票配對量化交易策略-R語言</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>