<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java8併發教程 - Thread和Executors | 极客快訊</title><meta property="og:title" content="Java8併發教程 - Thread和Executors - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a5ff673dd9df46ac97966318964a561b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="Java8併發教程 - Thread和Executors"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/f9e4b26d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java8併發教程 - Thread和Executors</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>Thread and Runnable</p><p>現代操作系統,都支持通過進程和線程來實現併發.進程是程序的運行時的實例.程序是靜態的,而進程是動態的.進程與進程之間,相互獨立.例如,如果你運行一個Java程序,操作系統就會生成一個和其他進程並行運行的進程.而在進程內部,我們又可以通過使用線程來併發的執行操作,並充分利用現代機器多核的優勢.</p><p>Java從JDK1.0開始,便開始支持線程了.我們在啟動一個線程之前,必須告訴它要它執行什麼操作.我們可以通過實現** Runnable**接口來告訴線程它要執行的操作,如下圖所示:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5ff673dd9df46ac97966318964a561b></div><p>我們通過lambda表達式來實現了** Runnable<strong>接口.我們讓它做的事是,將線程的名稱輸出到控制檯.在我們啟動線程之前,我們先直接啟動</strong> Runnable**,看看會發生什麼.</p><p>結果應該是這樣:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4db9da976f6149c69bd62c4375816fc6></div><p>或者是這樣:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cbc60f1cae0748a68cc90272b3b2d037></div><p>因為新創建的線程和主線程現在是並行運行,所以我們並不能確定最後的那兩行輸出的順序.而且因為這種順序的不確定性,導致併發編程比單線程編程要困難的多.</p><p>我們可以讓線程暫停一段時間.我們一般用這來模擬需要執行很長時間的任務的線程.</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a0787e5f8efe43879887cad4f0bbd3de></div><p>如果你運行上面的代碼,你會看到,第一條輸出和第二條輸出中間,間隔了一秒. ** TimeUnit**是一個很有用的枚舉,它簡化了對時間單元的處理.</p><p>使用Thread類來編程,很容易產生錯誤.所以,Java在2004年發佈的JAVA5引入了** Concurrency API<strong>.這些API位於</strong> java.util.concurrent<strong>包中,並且包含很多有用的類.從那之後,這些</strong> Concurrency API**就包含在每個Java版本中了.甚至在Java8中,又為併發引入了新的類和方法.</p><p>下面我們來看一下** Concurrency API**中,最重要的那部分- executor services.</p><p>Executors</p><p>** Concurrency API<strong>打算用</strong> ExecutorService<strong>來取代</strong> Thread<strong>.Executor能夠運行異步任務,並且管理著一個線程池.線程池中的線程都可以被複用.所以我們只需要通過一個</strong> executor service**,就能運行很多的需要併發執行的任務.</p><p>下面這個例子演示瞭如何使用** ExecutorService**:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cff8f49cfe704051b28797fbd325dfad></div><p>** Executors<strong>是一個工廠類,我們可以用它來創建各種各樣的</strong> Executor Service<strong>.這裡創建了一個只有一個線程的</strong> Executor Service**.</p><p>輸出的結果很容易理解.你可能會注意到,這個程序一直在運行,一直都不停止.實際上,我們需要手動停掉** Executor**,否則它會一直運行,來監聽新的任務.</p><p>** ExecutorService<strong>提供了兩個方法,讓我們停掉</strong> Executor<strong>.一個是</strong> shutdown()<strong>,它會等待當前正在運行的任務停止.另一個是</strong> shutdownNow()<strong>,它會中斷全部的正在運行的任務,並讓</strong> Executor**立即停止.</p><p>我們使用如下圖所示的這種方式,來停掉** Executor**更好:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/702976a8784842f9b9243a7436c76337></div><p>** Executor**會等待一段時間,讓正在運行的任務運行完.超過五秒之後,就停掉全部的正在運行的task.</p><p>Callables和Futures</p><p>除了** Runnable<strong>,</strong> Executor<strong>還接受</strong> Callable<strong>作為參數.</strong> Callable<strong>和</strong> Runnable<strong>的區別在於,</strong> Callable**是有返回值的.</p><p>下圖中的** Callable**,會先暫停一秒鐘,然後輸出一個整數:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/997f11e1ba9945b89e64ecd11311b8ca></div><p>通過** Callable<strong>來創建</strong> Executor<strong>的方式,和通過</strong> Runnable<strong>來創建</strong> Executor<strong>的方式一樣.那麼我們如何來獲取</strong> Callable<strong>的返回值呢?我們可以通過</strong> Future<strong>對象來獲取.因為</strong> submit()<strong>方法是非阻塞的,它不會等待任務完成,然後直接返回任務的返回值.而是通過返回一個</strong> Future<strong>對象,其中會封裝任務的返回值.等任務完成後,我們就能通過這個</strong> Future<strong>對象,來獲取</strong> Callable**的返回值.</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a150d1f3bcd44b909c43e359e40c5c6e></div><p>在通過** submit()<strong>方法提交完任務之後,我們通過</strong> isDone()<strong>方法,來查看</strong> Future**對象是否完成.這裡當然不會,因為線程會在返回值之前,先暫停一秒.</p><p>調用** get()<strong>方法,會阻塞當前線程,直到</strong> callable<strong>執行完畢.現在</strong> Future**對象完成了,我們可以在控制檯中,看到如下結果:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/bc985709719f4aaf9d95f77fd9d2a7a7></div><p>** Future<strong>對象和</strong> Executor Service<strong>之間,有輕微的耦合.需要注意的是,如果你在</strong> Future<strong>完成之前,結束</strong> Executor**,那麼它會拋出異常.</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e9a6f84a035847a084c79551e97673a3></div><p>你可能已經注意到了,這裡我們是通過** newFixedThreadPool(1)<strong>方法,來創建的</strong> ExecutorService<strong>,它會創建一個只有一個線程的線程池.其等價與</strong> newSingleThreadExecutor**.但是我們可以通過調整其參數來改變該線程池的大小.</p><p>Timeouts</p><p>** future.get()<strong>方法,會阻塞當前線程,直到</strong> Callable<strong>執行完畢.那如果</strong>Callable**執行的是一個死循環呢?這會導致我們的程序失去響應.我們可以通過設置超時時間,來解決這個問題:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5fde1cc38d574c92b76034b6c9c7cdd3></div><p>上面的代碼會拋出** TimeoutException**:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5abf8ce5937b4a9d9f5d26096c9ce872></div><p>你應該知道為何拋出這個異常:我們設置其最多等待1秒,但是** Callable**執行卻需要兩秒.</p><p>InvokeAll</p><p>** Executor Service<strong>支持通過調用</strong> invokeAll()<strong>方法,來傳入多個</strong> Callable<strong>,實現一次執行多個任務的目的.這個方法,其參數是</strong> Callable<strong>的集合,其返回值,是</strong> Future**對象的集合.</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a89bdcc005a54d1980e54200ff6f1ddf></div><p>InvokeAny</p><p>另一個一次執行多個任務的方法是** invokeAny()<strong>方法,這個方法和</strong> invokeAll()<strong>方法,有一些不同.這個方法不會返回</strong> Future<strong>對象,它會一直等到第一個</strong> Callable**運行結束,然後返回其返回值.</p><p>我們使用下面的幫助類,來生成** Callable**.</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba4dc26625904be8b981fd6c9b3deb57></div><p>然後執行下面的代碼,它會返回需要執行的時間最短的任務的返回值:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a8e000470f64559a37b96875b7875ad></div><p>上面的代碼中,通過** newWorkStealingPool()<strong>來創建了另一種</strong> ExecutorService<strong>.這種</strong> ExecutorService**,其線程池中的線程的數量,默認為我們的機器的核數.</p><p>Scheduled Executors</p><p>我們現在已經知道如何來通過** Executor Service**啟動線程了.那如果有一個任務,需要重複運行很多次,或者定時執行,那我們該怎麼辦呢?</p><p>我們可以使用** Scheduled Executors**.</p><p>下面的代碼,會在三秒後,啟動一個線程來執行任務:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bdb1fb8ae5cd4f0aae218ad36bf68f55></div><p>** schedule()<strong>方法,會返回一個</strong> ScheduleFuture<strong>,相對於普通的</strong> Future<strong>來說,它增加了一個</strong> getDelay**方法,來查看還剩多少時間來啟動線程執行任務.</p><p>** ScheduleExecutorService<strong>提供了</strong> scheduleAtFixedRate()<strong>和</strong> scheduleWithFixedDelay()**這兩個方法.前者會按一定的頻率來執行任務.下面的例子會每秒執行一次任務:</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed7448d4a7a3436cb65b81ada1b61fe5></div><p>** scheduleAtFixedRate()**方法指定的間隔,不包括任務執行的時間.所以,如果你讓那些需要兩秒來執行的任務,每隔一秒執行一次,線程池會很快達到容量上限.</p><p>針對上面的那種情況,你應當使用** scheduleWithFixedDelay()**方法.這個方法的參數,是一個任務完成後,再過多久才執行下一個任務.</p><div class=pgc-img><img alt="Java8併發教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8e68d87ec2974ee0a42c42ba6a9ff1f6></div><p>作者：AlstonWilliams</p><p>鏈接：https://www.jianshu.com/p/590cd048c11c</p><p>來源：簡書</p><p>簡書著作權歸作者所有，任何形式的轉載都請聯繫作者獲得授權並註明出處。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java8</a></li><li><a>Thread</a></li><li><a>Executors</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>