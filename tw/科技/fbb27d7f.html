<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Redis結合AQS實現Java版的可重入分佈式鎖 | 极客快訊</title><meta property="og:title" content="Redis結合AQS實現Java版的可重入分佈式鎖 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fc01434c4f24445293d68f0f8778c76f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fbb27d7f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fbb27d7f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fbb27d7f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fbb27d7f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fbb27d7f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fbb27d7f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fbb27d7f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fbb27d7f.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="Redis結合AQS實現Java版的可重入分佈式鎖"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/fbb27d7f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Redis結合AQS實現Java版的可重入分佈式鎖</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=Redis結合AQS實現Java版的可重入分佈式鎖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fc01434c4f24445293d68f0f8778c76f></div><h1>前言</h1><p>對於java的單進程應用來說，存在資源競爭的場景可以使用synchronized關鍵字和Lock來對資源進行加鎖，使整個操作具有原子性。但是對於多進程或者分佈式的應用來說，上面提到的鎖不共享，做不到互相通訊，所以就需要分佈式鎖來解決問題了。</p><p>廢話不多說，直接進入正題，下面結合AQS和Redis來實現分佈式鎖。</p><p>代碼中大部分都是參考ReentrantLock來實現的，所以讀者可以先去了解一下ReentranLock和AQS</p><p>參閱：</p><p>http://www.importnew.com/27477.html</p><p>http://cmsblogs.com/?p=2210</p><h1>加鎖</h1><p>@Override</p><p>protected boolean tryAcquire(int acquires) throws AcquireLockTimeoutException {</p><p>final Thread current = Thread.currentThread();</p><p>int c = getState();</p><p>if (c == 0) {</p><p>if (!hasQueuedPredecessors() &&</p><p>compareAndSetState(0, 1)) { // 標註1</p><p>setExclusiveOwnerThread(current);</p><p>// 如果是線程被中斷失敗的話，返回false，如果超時失敗的話，捕獲異常</p><p>return tryAcquireRedisLock(TimeUnit.MILLISECONDS.toNanos(redisLockTimeout));</p><p>}</p><p>//可重入</p><p>} else if (current == getExclusiveOwnerThread()) { //標註2</p><p>int nextc = c + acquires;</p><p>if (nextc &lt; 0) {</p><p>throw new Error("Maximum lock count exceeded");</p><p>}</p><p>setState(nextc);</p><p>return true;</p><p>}</p><p>return false;</p><p>}</p><p>下面會把進程內的鎖稱為進程鎖，如果有更專業的描述方法的話，歡迎指出。</p><p>對上面的步驟分析：</p><p>1. 首先看標註1，通過compareAndSetState獲取到進程鎖，只有獲取到進程鎖，才有資格去競爭redis鎖， 這樣的好處就是對於同一個進程裡面的所有加鎖請求，在某一個時刻只有一個請求能去請求獲取redis鎖，有效降低redis的壓力，總的來說就是把部分競爭交給進程自己去解決了，也就是先競爭進程鎖。</p><p>2. 再看標註2，能進行到這一步，首先能確保已經獲取了進程鎖，但是是否一定獲取了redis鎖了呢，不一定，所以在tryAcquireRedisLock的過程中如果拋出異常，一定要保證使用finally代碼塊把進程鎖釋放掉，避免誤以為已經同時獲取了進程鎖和redis鎖。</p><h1>獲取redis鎖</h1><p>private final boolean tryAcquireRedisLock(long nanosTimeout) {</p><p>if (nanosTimeout &lt;= 0L) {</p><p>return false;</p><p>}</p><p>final long deadline = System.nanoTime() + nanosTimeout;</p><p>int count = 0;</p><p>boolean interrupted = false;</p><p>Jedis jedis = null;</p><p>try {</p><p>jedis = redisHelper.getJedisInstance();</p><p>while (true) {</p><p>nanosTimeout = deadline - System.nanoTime();</p><p>if (nanosTimeout &lt;= 0L) {</p><p>throw new AcquireLockTimeoutException();</p><p>}</p><p>String value = String.format(valueFormat, Thread.currentThread().getId());</p><p>//避免系統宕機鎖不釋放，設置過期時間</p><p>String response = jedis.set(lockKey, value, NX, PX, redisLockTimeout);</p><p>if (OK.equals(response)) {</p><p>//如果線程被中斷同時也是失敗的</p><p>return !interrupted;</p><p>}</p><p>// 超過嘗試次數</p><p>if (count > RETRY_TIMES && nanosTimeout > SPIN_FOR_TIMEOUT_THRESHOLD && parkAndCheckInterrupt()) {</p><p>interrupted = true;</p><p>}</p><p>count++;</p><p>}</p><p>} finally {</p><p>redisHelper.returnResouce(jedis);</p><p>}</p><p>}</p><p>final boolean parkAndCheckInterrupt() {</p><p>LockSupport.parkNanos(TimeUnit.NANOSECONDS.toNanos(PARK_TIME));</p><p>return Thread.interrupted();</p><p>}</p><p>分析：</p><p>1. 為了避免獲取redis鎖的過程無休止的運行下去，使用超時策略，如果超時了，直接返回失敗</p><p>2. 如果還在有效時間內，則通過自旋不斷嘗試獲取鎖，如果超過了嘗試次數，暫時掛起，讓出時間片，但是不可以掛起太長的時間，幾個時間片內為好。</p><h1>解鎖</h1><p>//RedisDistributedLock.java</p><p>@Override</p><p>public void unlock() {</p><p>sync.unlock();</p><p>}</p><p>//Sync.java</p><p>public void unlock() {</p><p>release(1);</p><p>}</p><p>@Override</p><p>protected final boolean tryRelease(int releases) {</p><p>int c = getState() - releases;</p><p>if (Thread.currentThread() != getExclusiveOwnerThread())</p><p>throw new IllegalMonitorStateException();</p><p>boolean free = false;</p><p>if (c == 0) {</p><p>Jedis jedis = null;</p><p>try {</p><p>jedis = redisHelper.getJedisInstance();</p><p>String value = String.format(valueFormat, Thread.currentThread().getId());</p><p>jedis.eval(UNLOCK_SCRIPT, Arrays.asList(lockKey), Arrays.asList(value));</p><p>} finally {</p><p>redisHelper.returnResouce(jedis);</p><p>}</p><p>free = true;</p><p>setExclusiveOwnerThread(null);</p><p>}</p><p>setState(c);</p><p>return free;</p><p>}</p><p>分析：</p><p>1. 可以注意到value在加鎖和解鎖的過程都有，這個value是用來標識鎖的唯一性的，避免別的進程誤刪了該鎖。</p><p>private final UUID uuid = UUID.randomUUID();</p><p>private final String valueFormat = "%d:" + uuid.toString();</p><h1>驗證</h1><p>@Override</p><p>public void run() {</p><p>SqlSession session = MybatisHelper.instance.openSession(true);</p><p>try {</p><p>KeyGeneratorMapper generatorMapper = session.getMapper(KeyGeneratorMapper.class);</p><p>KeyFetchRecordMapper recordMapper = session.getMapper(KeyFetchRecordMapper.class);</p><p>while (true) {</p><p>try {</p><p>lock.lock();</p><p>KeyGenerator keyGenerator = generatorMapper.select(1);</p><p>if (keyGenerator.getKey() >= MAX_KEY) {</p><p>System.exit(0);</p><p>}</p><p>recordMapper.insert(new KeyFetchRecord(keyGenerator.getKey(), server));</p><p>generatorMapper.increase(1, 1);</p><p>session.commit();</p><p>} catch (RuntimeException e) {</p><p>e.printStackTrace();</p><p>continue;</p><p>} finally {</p><p>lock.unlock();</p><p>}</p><p>}</p><p>} finally {</p><p>session.close();</p><p>}</p><p>}</p><p>開啟5個進程，每個進程5個線程，進行獲取一個key值，獲取到後加1，然後記錄到數據庫，這個過程不要是原子的，因為把沒有原子性的過程變成有原子性的過程，才證明了這個鎖的有效性。</p><h1>結果如下</h1><div class=pgc-img><img alt=Redis結合AQS實現Java版的可重入分佈式鎖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f66948d9fbec4ed783260fea6a55feae></div><div class=pgc-img><img alt=Redis結合AQS實現Java版的可重入分佈式鎖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/709528fc82694db98923b27b23820c4d></div><p>沒有重複的key,成功！</p><p><strong>詳細實現</strong></p><p>https://github.com/dhhua/common-util/tree/master/util-lock</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Redis</a></li><li><a>結合</a></li><li><a>AQS</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b1934bd.html alt=技巧/場面作文如何寫？點面結合不畏難 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/739a7908cf6241d495e4d9db53f5b3b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b1934bd.html title=技巧/場面作文如何寫？點面結合不畏難>技巧/場面作文如何寫？點面結合不畏難</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/826583eb.html alt=疏堵結合提升砂石資源保障能力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/826583eb.html title=疏堵結合提升砂石資源保障能力>疏堵結合提升砂石資源保障能力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3b146d8.html alt=那些與瀝青結合的材料“伴侶” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c63762689d6a4d5aa9a0c2804e673d4a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3b146d8.html title=那些與瀝青結合的材料“伴侶”>那些與瀝青結合的材料“伴侶”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3456552a.html alt=機械電子結合的怪產物磁帶攝像機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3d069f4dab484b7aa46a55e789b38d62 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3456552a.html title=機械電子結合的怪產物磁帶攝像機>機械電子結合的怪產物磁帶攝像機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d0c5523.html alt=Redis的5種數據類型與編碼結構分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b51e65c8c7cf429aa2911bb775b98cc4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d0c5523.html title=Redis的5種數據類型與編碼結構分析>Redis的5種數據類型與編碼結構分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cec478ea.html alt=新型邏輯器件：結合了光、電、化學！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/21c4fbc4ab06455cb3286f0d2e0414b8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cec478ea.html title=新型邏輯器件：結合了光、電、化學！>新型邏輯器件：結合了光、電、化學！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dcba474b.html alt=高併發架構系列：Redis緩存和MySQL數據一致性方案詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/c71c1aad-32fd-4370-a372-8d2231bde9ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dcba474b.html title=高併發架構系列：Redis緩存和MySQL數據一致性方案詳解>高併發架構系列：Redis緩存和MySQL數據一致性方案詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9806fac.html alt="程序員都需要的乾貨之springcloud 高效率本地加Redis雙級緩存" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cd3e731c0e64105beb94beeaf67f702 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9806fac.html title="程序員都需要的乾貨之springcloud 高效率本地加Redis雙級緩存">程序員都需要的乾貨之springcloud 高效率本地加Redis雙級緩存</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fde052d1.html alt=當搓澡巾與人體工學科技結合，從身上搓下來的不止是“泥” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e73df779a9764b8e8d3121ecc3e638bc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fde052d1.html title=當搓澡巾與人體工學科技結合，從身上搓下來的不止是“泥”>當搓澡巾與人體工學科技結合，從身上搓下來的不止是“泥”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8281ce27.html alt="膽石結合，Cayin N8便攜數字播放的巔峰之作，躋身HIEND行列" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fc0a96a3df674a8cb732d70f651cdfc6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8281ce27.html title="膽石結合，Cayin N8便攜數字播放的巔峰之作，躋身HIEND行列">膽石結合，Cayin N8便攜數字播放的巔峰之作，躋身HIEND行列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c28f96c.html alt=復旦大學結合硬模板法、原子層沉積技術與水熱工藝，在新型氣敏材料及MEMS器件獲得新進展 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RzV98PMBmkOOE2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c28f96c.html title=復旦大學結合硬模板法、原子層沉積技術與水熱工藝，在新型氣敏材料及MEMS器件獲得新進展>復旦大學結合硬模板法、原子層沉積技術與水熱工藝，在新型氣敏材料及MEMS器件獲得新進展</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a67e574.html alt=人工智能與超材料結合：突破衍射極限，實現聲波高分辨率成像 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/aa87d47cb8c7488b8164b5b12effcff0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a67e574.html title=人工智能與超材料結合：突破衍射極限，實現聲波高分辨率成像>人工智能與超材料結合：突破衍射極限，實現聲波高分辨率成像</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2878d866.html alt=語文考試時注意結合語境分析詞句，弄懂成績瞬間提10分以上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/83c111465d4e46679645001c69f174df style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2878d866.html title=語文考試時注意結合語境分析詞句，弄懂成績瞬間提10分以上>語文考試時注意結合語境分析詞句，弄懂成績瞬間提10分以上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4b1b927.html alt="PCB Layout 結合生產的設計規則" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15325758905468964effece style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4b1b927.html title="PCB Layout 結合生產的設計規則">PCB Layout 結合生產的設計規則</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>