<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JVM—深入理解內存模型與垃圾收集機制 | 极客快訊</title><meta property="og:title" content="JVM—深入理解內存模型與垃圾收集機制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/574c706db69f4c53802c093d6e7023d4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="JVM—深入理解內存模型與垃圾收集機制"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/fd1246b1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JVM—深入理解內存模型與垃圾收集機制</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p><strong>為了感謝支持我的朋友！整理了一份Java高級架構資料、Spring源碼分析、Dubbo、Redis、Netty、zookeeper、Spring cloud、分佈式等資。關注私信回覆：555領取</strong></p></blockquote><p>前言</p><p>Java是一種跨平臺的語言，當初其設計初衷也是為了解決各個平臺編譯環境具有差異，對程序移植性問題造成困難這一痛點，於是推出了Java語言。這麼多年Java受業界追捧的原因除了其面向對象的特性以外就是其可移植性強，而可移植性這一特性正式建立在JVM虛擬機這一基礎上的，JVM在其內存模型和垃圾回收機制的設計上堪稱神作，瞭解JVM虛擬機是每一個Java開發工程師必備的技能。</p><p>你瞭解Java的內存模型嗎</p><ul><li>內存簡介</li></ul><p>要說清楚內存，首先要提計算機程序是如何運行的。計算機<strong>程序</strong>指的就是可以讓計算機運行的一些指令集合，簡單地說就是我們平時寫的代碼，而真正在計算機中運行的是<strong>進程</strong>，<strong>進程=代碼+數據</strong>，而要操作數據，則應該先將數據加載進內存中，才能對其進行進一步的操作。而內存就是一系列<strong>地址空間</strong>，地址空間又分為<strong>內核空間</strong>和<strong>用戶空間</strong>，<strong>內核空間</strong>是計算機操作系統運行時所需的空間，如虛擬內存、聯網、操作系統調度等所需的空間，而Java進程實際運行時使用的空間是我們的<strong>用戶空間</strong>。</p><ul><li>JVM架構圖</li></ul><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/574c706db69f4c53802c093d6e7023d4><p class=pgc-img-caption></p></div><ul><li><br></li><li>類裝載器(ClassLoader):依據特定格式，class文件加載到內存。</li><li>執行引擎(Execution Engine):對命令進行解析。</li><li>本地庫接口(Native Interface):融合不同開發語言的原生庫為Java所用。</li><li><strong>內存區域(Runtime Data Area)</strong>:JVM內存空間結構模型。</li><li>劃分</li><li>從Java的內存區域中可以看到，其分為五個區，分別是 <strong>1.程序計數器、2.虛擬機棧、3.本地方法棧、4.堆區、5.方法區</strong>(<strong>元空間</strong>)而在這五個區中，分為<strong>線程私有</strong>和<strong>共享區域</strong>。</li><li>線程私有</li></ul><p><strong>1.程序計數器（Program Counter Register）</strong>：當前線程所執行字節碼（class文件）行號指示器（邏輯），它改變自身的計數器的值來選取下一條需要執行的字節碼指令，為了程序執行不互相沖突，所以每個線程必須私有程序計數器，保證程序運行不衝突。<strong>注：如果是執行Native方法，則計數器值為Undefined。</strong> 程序計數器中存儲的數據所佔空間的大小不會隨程序的執行而發生改變， 所以此區域不會出現 OutOfMemoryError 的情況。</p><p><strong>2.Java虛擬機棧（Stack）</strong>：Java虛擬機棧即我們平時所說的Java內存模型裡的棧內存，其存放的最小單位為<strong>棧幀</strong>，Java虛擬機棧中的每個棧幀主要存儲<strong>局部變量表、操作數棧、動態鏈接、返回地址</strong>，當方法調用結束時，該棧幀隨機被銷燬，棧幀內的局部變量也隨機被銷燬。這裡說一下<strong>局部變量表</strong>和<strong>操作棧</strong>，<strong>局部變量表</strong>包含了方法執行過程中的所有變量，而<strong>操作數棧</strong>主要實現入棧、出棧、複製、交換、產生消費變量等。該區域會產生兩種異常，即 當線程請求的棧大小超過棧的總深度，拋出StackOverflowError異常（例如遞歸），當棧進行擴展時無法得到足夠的內存，則拋出OutOfMemoryError異常。</p><p>3.<strong>本地方法棧（Native Method Stack）</strong>：與虛擬機棧相似，主要存非Java語言的方法。同樣會拋出StackOverflowError和OutOfMemoryError異常</p><ul><li>所有線程共享</li></ul><p><strong>1.方法區（Method Area）</strong>：方法區主要存儲Class的相關信息，包括Method和field等等，說這個之前首先說<strong>元空間（MetaSpace）和永久代（PermGen）的區別，在Java1.7後，將方法區中的字符串常量池移動到Java堆中，並且Java1.7之後將永久代變為元空間，它們兩個最大的區別就是元空間使用本地內存</strong>而永久代使用<strong>JVM內存</strong>，這一改變最大的變化就是，不會再看到ParmGen出現內存溢出的異常了，而且字符串常量池存在永久代中，容易出現性能問題和內存溢出，類和方法的信息大小難以確定，給永久代的大小指定帶來困難。</p><p><strong>2.Java堆（Heap）</strong>：該區域是Java內存模型中最大的一塊，該區域<strong>存儲所有對象的實例</strong>，即我們在寫代碼時new出來的對象，都存在堆區，當堆無法再分配內存時，將會拋出OutOfMemoryError異常。該區域<strong>是GC管理的主要區域</strong>，因此Java堆又被稱為GC堆，由於GC在垃圾回收的時候使用分代收集，所以堆內存也可以被分為<strong>新生代</strong>和<strong>老年代</strong>，老年代佔堆內存的2/3，新生代佔1/3，新生代又可以細分為<strong>Eden區</strong>、<strong>From區</strong>、<strong>To區</strong>，Eden區的<strong>Eden</strong>即<strong>伊甸園</strong>的意思，<strong>聖經記載，亞當和夏娃在伊甸園偷食禁果</strong>，所以伊甸區是人類的起源地，名字也就來源於此，我們在程序中new出的對象（除大對象，大對象直接進入老年代），都存在於Eden區，<strong>當多次GC後沒有被回收，則會進入老年代</strong>，這一塊在說垃圾回收機制的時候會細說，這裡只要知道Java堆大概分為這幾個區域即可。</p><p>關於Java內存模型的面試題</p><ul><li>JVM三大性能調優參數-Xms -Xmx -Xss的含義</li><li>答： 1.-Xss：規定了每個線程虛擬機棧（堆棧）的大小。</li><li>2.-Xms：堆的初始值。</li><li>3.-Xmx：堆能達到的最大值。通常將堆的初始值和最大值設為相同值，防止堆擴容時產生內存抖動問題。</li><li>Java內存模型中堆和棧的區別——內存分配策略</li><li>靜態存儲：編譯時確定每個數據目標在運行時的存儲空間需求。</li><li>棧式存儲：數據區需求在編譯時未知，運行時模塊入口前確定。</li><li>堆式存儲：編譯時或運行時模塊入口都無法確定，動態存儲。</li><li>堆和棧的聯繫，引用對象、數組時，棧裡定義變量保存堆中對象目標的首地址。</li><li>堆和棧的不同，棧中的變量在方法運行結束後立即被清除（自動釋放），而堆中的對象即使失去引用變為不可達對象，也需等待GC才會被清除，即清除時間時不確定的（需要GC）。</li><li>棧的空間較堆空間小，且棧產生的碎片遠小於堆。</li><li>棧的效率比堆高。</li></ul><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d70e0a1afa2843f0a9f8a5e3f2a33bab><p class=pgc-img-caption></p></div><ul><li><br></li><li>JDK6和JDK6之後的版本對intern()方法的區別</li></ul><blockquote><p>JDK6:當調用intern方法時，如果字符串常量池先前已創建出該字符串對象，則返回池中的該字符串的引用。否則，將此字符串對象添加到字符串常量池中，並且返回該字符串對象的引用。JDK6+：當調用intern方法時，如果字符串常量池先前已創建出該字符串對象，則返回池中的該字符串的引用，否則，如果該字符串對象已經存在於Java堆中，則將堆中對此對象的引用添加到字符串常量池中，並且返回該引用；如果堆中不存在，則在池中創建該字符串並返回其引用。</p></blockquote><ul><li><strong>注：Java1.8中 已經將字符串常量池已經從方法區移動到堆中</strong>。</li></ul><p>Java垃圾回收機制</p><p>對象被判定為垃圾的標準</p><p>在垃圾回收機制中，把<strong>沒有被其它對象引用的對象</strong>判定為垃圾，而垃圾回收機制的各種算法也是基於這一標準，主要的中心即放在<strong>如何判定一個對象是否被引用</strong>和<strong>如何被回收</strong>。</p><p>引用計數算法</p><p>在<strong>引用計數算法</strong>中，主要是通過<strong>計算一個對象的引用數量</strong>來判斷對象是否為垃圾，是否應該被回收。其實現方式是對存在於堆中的每一個對象都置一個<strong>引用數量計數器</strong>。當創建一個對象時，將該對象實例分配給一個引用對象，則將該對象的引用數量計數器的值<strong>加一</strong>，完成引用則<strong>減一</strong>。因此，當該實例對象的引用計數器值為0時，則可以將該對象視為垃圾，在GC調用時，則將會回收該對象的空間。</p><p><strong>引用計數算法</strong>的優劣：引用計數算法其<strong>優點</strong>是執行效率高，程序執行受影響較小，因為其運行時只需將引用數量計數器的值加一或減一，運算量極小，效率極高，可以交織在程序運行中。其<strong>缺點</strong>也是十分明顯的，引用計數算法有一個致命的缺陷，就是它無法處理<strong>循環引用</strong>的情況，所謂循環引用就是<strong>當A引用B，B又引用A，兩個對象互相引用</strong>，實際上這兩個對象是可以被回收的，但由於其引用計數器的值均為1，所以造成了此種算法判定這兩個對象為不可回收，導致內存洩漏。所以Java中的GC並不會採用此種算法。</p><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/263833c06b2f4970873c29b3111072ad><p class=pgc-img-caption></p></div><p>可達性分析算法</p><p><strong>可達性分析算法</strong>是通過判斷對象的<strong>引用鏈是否可達</strong>，來決定對象是否可以被回收，該算法從離散數學中的圖論引入，程序之間的引用關係可以看作是一個十分複雜的圖，通過一系列的名為<strong>GC Root</strong>的節點作為起始點，向下搜索，搜索中走過的路徑就被稱為<strong>引用鏈（Reference Chain）</strong>，當一個對象從GC Root沒有任何的引用鏈，則證明該對象是<strong>不可達</strong>的，該對象就會被標記為垃圾。</p><p>例如圖中Object5、Object6、Object7均為<strong>不可達</strong>，所以這三個對象將會在下一次GC中被清除。</p><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f560d6d7ac1b4257895ac09e851c6b3b><p class=pgc-img-caption></p></div><ul><li>可作為GC Root的對象： 1.虛擬機棧中引用的對象（棧幀中的局部變量表）</li><li>2.方法區中常量引用的對象</li><li>3.方法區中類靜態屬性引用的對象</li><li>4.本地方法棧中Native方法中的引用對象</li><li>5.活躍線程的引用對象</li><li>簡單來說：就是所有被引用的對象（包括靜態對象和非靜態對象）+線程+Native方法中的對象，都可以作為GC Root的對象。</li></ul><p>垃圾回收算法</p><p>這裡可能有人會蒙，剛才不是談了垃圾回收算法了嗎，怎麼又開始說垃圾回收算法了，其實從這裡開始，才是真正的垃圾回收算法，上面的兩個算法可以算是垃圾回收前的準備工作，即<strong>對要回收的對象進行標記判斷</strong>。這個對象是否應該被回收，是上面那兩個算法的工作，而這個對象應該怎麼被回收，回收後要對內存做哪些工作，這就是<strong>垃圾回收算法</strong>所要考慮的事情。</p><p>標記-清除算法（Mark and Sweep）</p><p><strong>標記-清除算法</strong>將算法分為兩個步驟，即<strong>標記</strong>和<strong>清除</strong>，所謂標記，就是<strong>從根節點進行掃描，對存活的對象進行標記。所謂清除，就是對堆內存中從頭到尾進行線性遍歷，回收未被標記的對象內存，即不可達對象內存，最後將原來做過標記對象的標記清空，為下一次GC做準備</strong>。</p><p>標記-清除算法的<strong>優缺點</strong>：標記-清除算法的優勢是其效率高，僅需掃描一遍內存即可將所有的垃圾進行回收。但是其缺陷也是十分的明顯，在標記-清除算法中，只要某對象被標記為垃圾，則調用GC時就會直接進行回收，這勢必會帶來一個問題，就是<strong>內存的碎片化</strong>。所謂內存碎片化，即在GC過程中，由於垃圾所處的內存空間並不連續，導致回收過後會存在很多的不連續的內存空間。</p><p>舉個例子，<strong>有兩個對象A and B，A佔用1B內存，B佔用1B內存，他們兩個所處的位置並不連續，而當它們被同時標記為垃圾並被回收了之後，就會產生兩塊1B的內存，此時來了一個2B的對象，但是它就無法使用這兩塊不連續的1B存儲空間了</strong>。如果此時內存已滿，將會拋出OutOfMemoryException，這就是內存碎片所造成的後果。</p><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b31c45410eaf476d91cf4eadaf13e8c6><p class=pgc-img-caption></p></div><p>複製算法（Copying）</p><p><strong>複製算法</strong>，將內存分為<strong>對象面</strong>和<strong>空閒面</strong>，對象只存在於對象面上。當複製算法運行時，首先會像標誌-清除算法一樣，對<strong>存在引用的對象</strong>做標記，然後將<strong>帶有標記的對象</strong>複製到<strong>空閒面</strong>上，並且按照內存順序存儲，當全部帶標記的對象都被移動到空閒面上後，將對象面的所有對象一併清除，然後將空閒面和對象面進行互相轉換，即此時對象面變為空閒面，空閒面變為對象面。由於複製操作也存在效率問題，所以這種算法適用於<strong>對象存活率低</strong>的場景，因為這樣就不會有很多的對象需要複製。實際上這種算法是應用在<strong>堆內存中的新生代</strong>中的，因為在大量的實踐中證明，在新生代區的對象，最後存活下來的比例大概只有10%，所以相當適合這種算法。至於在新生代中這種算法的運行步驟是怎樣的，放在下文中說。</p><p>由於複製算法對複製後的對象按照內存順序存儲，所以它解決了標記-清除算法中內存碎片化的問題。</p><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4839027206684753b67d76db97005169><p class=pgc-img-caption></p></div><p>標記-整理算法（Compacting）</p><p><strong>標記-整理算法</strong>採用和標記-清除算法一樣的步驟，從根集合進行掃描，對存活的對象進行標記，但在<strong>清除時</strong>，這個算法會移動所有存活的對象，且按照內存地址次序依次進行排列，然後將末端內存地址以後的內存全部進行回收。由於此種算法在標記-清除的基礎上，加之對對象進行整理，所以其效率更低，但解決了內存碎片化的問題。</p><p>該算法由於一次GC會有較高的資源消耗，所以該算法適用於存活率高的場景，例如堆內存中的<strong>老年代</strong>。</p><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d2753a9b2fa4e9d8c699fb45bd16d2a><p class=pgc-img-caption></p></div><p>分代收集算法（Generational Collector）</p><p>有了上述三種的垃圾回收算法，有些同學可能心存疑慮，到底JVM中使用的是哪一種算法來對垃圾進行回收呢？其實JVM使用了上述幾種算法的<strong>組合拳</strong>，即<strong>分代收集算法</strong>。從嚴格意義上來說，分代收集算法並不是一種新的算法，它只是將上述幾種算法進行了一個整合。按照對象生命週期的不同劃分區域，採用不同的垃圾回收算法。</p><p>這裡先說一下<strong>JVM內存模型</strong>和<strong>對象生命週期</strong>之間的關係，在我們new一個普通對象時，這個對象會在<strong>Eden</strong>區被創建，假如在一次GC過後，這個對象沒有被清除，則稱這個對象是倖存者，將其<strong>年齡</strong>屬性加一，而後將會移動到From 區或To區，這兩個區域也被統稱為Servivor區，（<strong>Eden區：From區：To區=8：1：1</strong>），當一個對象經歷了15次GC後都沒有被回收，則會直接被移動到堆區中的<strong>老年代</strong>，老年代中的對象被認為是<strong>回收可能性不大</strong>的對象，因為經歷了15次GC都沒有被回收的對象，經歷150次GC被回收的可能性也不大。</p><p>所以瞭解了這個原理之後，再說分代收集算法就將會變得簡單。上文提到，<strong>複製算法</strong>由於其複製對象到空閒區需要消耗資源，所以適合對象存活率不高的場景，而<strong>新生代</strong>就很好地滿足了這個條件，所以新<strong>新生代</strong>通常使用<strong>複製算法</strong>進行垃圾回收。在多次的實踐中證明，一批被新建的對象，最終存活率大概在10%左右，所以這一批對象將會被複制到Servivor區，而複製完成後立即回收Eden區。而新生代中的From區和To區又和複製算法中的空閒區和對象區相對應。這就對複製算法的施行製造了很好的環境。</p><p><strong>老年代</strong>由於其存儲的對象具有<strong>不易被GC</strong>這個特點，所以上文中提到的<strong>標記-整理算法</strong>將會變得十分合適，標記-整理算法由於需要在清除後對存活的對象進行一次整理以消除內存碎片化，所以如果有大量的內存碎片，將非常不利於這種算法的運行，而老年代則給了適合這種算法的土壤。</p><p>在分代收集算法中還有兩個重要的概念是未曾提到的<strong>Minor GC</strong> 和 <strong>Full GC</strong>，存在於新生代的GC由於其垃圾回收範圍較小，被稱為MinorGC，而在老年代的GC中通常伴隨著所有內存的GC，所以其又被稱為Full GC。Full GC效率低，但是不常被觸發。</p><ul><li><strong>觸發Full GC的條件</strong></li><li>1.老年代空間不足</li><li>2.永久代空間不足（已移除）</li><li>3.CMS GC時出現Promotion failed，concurrent mode failure</li><li>4.Minor GC晉升到老年代的平均大小大於老年代的剩餘空間</li><li>5.調用System.gc()</li><li>6.使用RMI進行RPC或管理的JDK應用，每小時執行一次Full GC</li><li><strong>常用的調優參數</strong>：</li><li>1.-XX：SurvivalRatio:Eden和Servivor的比值，默認8:1</li><li>2.-XX：NewRatio：老年代和年輕代的內存大小的比例</li><li>3.-XX:MaxTenuriingThreshold：對象從年輕代晉升到老年代經過GC的最大閾值</li></ul><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f8876575d4a442048fae18cd602430aa><p class=pgc-img-caption></p></div><p>常用的垃圾收集器</p><p>在說垃圾收集器之前，先得明白兩個概念</p><ul><li>Stop-the-World</li><li>什麼是Stop-the-World？JVM由於要執行GC，而停止應用程序的執行，這就是Stop-the-World，這種現象在任何一種GC算法中都會發生，所以如何讓Stop-the-World發生的次數越來越少，以優化GC性能，是大多數垃圾收集器優化GC的策略。</li><li>Safe Point</li><li>這個詞相對來說很好理解，在GC過程中，會有程序不斷地產生垃圾對象，這會造成<strong>一邊打掃一邊扔</strong>的效果，所以GC是以快照方式進行垃圾回收的，在程序運行到特定位置時，例如跳轉，會生成一個Safe Point，而GC將會根據這個Safe Point中的垃圾進行回收。</li></ul><p>垃圾收集器</p><div class=pgc-img><img alt=JVM—深入理解內存模型與垃圾收集機制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0dd8f268a0af4e19b4dc09c80675788f><p class=pgc-img-caption></p></div><p>上圖中上半部分為新生代垃圾收集器，下半部分為老年代垃圾收集器。</p><p>兩個垃圾收集器之間如果有連線，代表可以配合使用。</p><p><strong>新生代垃圾收集器</strong></p><p><strong>Serial收集器</strong>是目前JVM運行在Client模式下的默認收集器，使用複製算法。因為它是單線程收集的，進行垃圾收集時必須暫停所有工作線程。</p><p><strong>ParNew收集器</strong> 是多線程垃圾收集器，除了多線程這個特點，其餘的行為、特點和Serial收集器一樣。它是Server模式下JVM默認的垃圾收集器。</p><p><strong>老年代垃圾收集器</strong></p><p><strong>Serial Old收集器</strong> 使用標記-整理算法，單線程收集，進行垃圾收集時，必須暫停所有工作線程。簡單高效，是Client模式下默認的老年代垃圾收集器。</p><p><strong>CMS收集器</strong> 使用標記-整理算法，多線程收集，GC線程幾乎可以和工作線程同時工作。</p><p>GC相關面試題</p><ul><li><strong>Object的finalize()方法作用是否與C++的析構函數作用相同</strong></li><li>答：Object的finalize()方法不能保證在調用時立即回收目標對象，而是要等一次GC才能開始回收，因此它是不確定的。而C++中的析構函數是確定的。</li><li><strong>Java中的強引用、軟引用、弱引用、虛引用有什麼用。</strong></li><li><strong>強引用</strong>：指該對象存在至少一個引用對象引用的情況，這時GC絕不會回收該對象，當內存不足時，即使報OutOfMemoryException也不會回收該對象。</li><li><strong>軟引用</strong>：對象處於有用但非必須的狀態，只有當內存不足時，GC才會回收該引用的內存。可用來實現內存敏感的高速緩存，因為在內存不足就被回收這一特性，我們不用太擔心OutOfMenoryException這一異常 用法：</li></ul><pre>String str = new String("abc");//強引用SoftReference&lt;String&gt; softRef = new SoftReference&lt;String&gt;(str);//軟引用</pre><ul><li><strong>弱引用</strong>：非必須的對象，比軟引用更弱一些，GC時會被回收。被回收的概率也不大，因為GC線程優先級比較低，適用於偶爾被使用且不影響垃圾收集的對象。</li><li>用法：</li></ul><pre>String str = new String("abc");//強引用WeakReference&lt;String&gt; weakRef = new WeakReferences&lt;String&gt;(str);//弱引用</pre><ul><li><strong>虛引用</strong>：不會決定對象的生命週期，在任何時候都可能被垃圾收集器回收，它可以跟蹤對象被垃圾收集器回收的活動。必須與ReferenceQueue聯用。</li><li>用法：</li></ul><pre>String str = new String("abc");ReferenceQueue queue = new ReferenceQueue();PhantomReference ref = new PhantomReference(str,queue);</pre><ul><li>綜上，強引用>軟引用>弱引用>虛引用</li></ul><p>結語</p><p>關注公眾號領資料</p><p>搜索公眾號【Java耕耘者】,回覆【Java】，即可獲取大量優質電子書和一份Java高級架構資料、Spring源碼分析、Dubbo、Redis、Netty、zookeeper、Spring cloud、分佈式等視頻資料</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JVM</a></li><li><a>內存</a></li><li><a>機制</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f553981.html alt=一次完整的JVM堆外內存洩漏故障排查記錄 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15784a09582b430cb43ff878ec7c1d82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f553981.html title=一次完整的JVM堆外內存洩漏故障排查記錄>一次完整的JVM堆外內存洩漏故障排查記錄</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html alt=事務機制和鎖機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5a547c8c402142cca7ed81d05fe0e3e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html title=事務機制和鎖機制>事務機制和鎖機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html alt=連mysql鎖的機制都不瞭解，怎麼做架構師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html title=連mysql鎖的機制都不瞭解，怎麼做架構師>連mysql鎖的機制都不瞭解，怎麼做架構師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html alt=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html title=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位>天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html alt=市稅務局創新制度機制爭創“模範機關” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d879650a7d06416c90fb7286175f1f59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html title=市稅務局創新制度機制爭創“模範機關”>市稅務局創新制度機制爭創“模範機關”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html alt="機制砂 | 大家知多少？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54b1eea319b842bcb8483f4056798bec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html title="機制砂 | 大家知多少？">機制砂 | 大家知多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html alt=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2b6d9a5dccf246aeaba80b2a1ecb9f0a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html title=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？>機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html alt=幾種基於可靠性指標的容量支持機制分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZYfwddDNSSyQW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html title=幾種基於可靠性指標的容量支持機制分析>幾種基於可靠性指標的容量支持機制分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html alt=java反射機制的講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad2c92f100a4d2e8213dcf70d4781c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html title=java反射機制的講解>java反射機制的講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/496f3f6a.html alt=劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7737ac36f58f40a98a798a5cbf5d5295 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/496f3f6a.html title=劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要>劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>