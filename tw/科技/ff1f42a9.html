<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 | 极客快訊</title><meta property="og:title" content="多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f31195000b32401b8a5173b87a78fb6f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff1f42a9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff1f42a9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ff1f42a9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff1f42a9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff1f42a9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ff1f42a9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ff1f42a9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff1f42a9.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ff1f42a9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>手把手教你做中間件、高性能服務器、分佈式存儲等(redis、memcache、nginx、大容量redis pika、rocksdb、mongodb、wiredtiger存儲引擎、高性能代理中間件)</p></blockquote><p><strong><em>1. 開發背景</em></strong></p><p>現有開源緩存代理中間件有twemproxy、codis等，其中twemproxy為單進程單線程模型，只支持memcache單機版和redis單機版，都不支持集群版功能。</p><p>由於twemproxy無法利用多核特性，因此性能低下，短連接QPS大約為3W，長連接QPS大約為13W，同時某些場景時延抖動厲害。</p><p>為了適應公有云平臺上業務方的高併發需求，因此決定藉助於twemproxy來做二次開發，把nginx的高性能、高可靠、高併發機制引入到twemproxy中，通過master+多worker進程來實現七層轉發功能。</p><p><strong><em>2 Twemproxy</em></strong></p><p><strong><em>2.1 Twemproxy簡介</em></strong></p><p>Twemproxy 是一個快速的單線程代理程序，支持 Memcached ASCII協議和更新的Redis協議。它全部用C寫成，使用Apache 2.0 License授權。支持以下特性：</p><ul><li>i)速度快</li><li>ii)輕量級</li><li>iii)維護持久的服務器連接</li><li>iiii)啟用請求和響應的管道</li><li>iiiii)支持代理到多個後端緩存服務器</li><li>iiiii)同時支持多個服務器池</li><li>iiiiii)多個服務器自動分享數據</li><li>iiiiiii)可同時連接後端多個緩存集群</li><li>iiiiiiii)實現了完整的 memcached ascii 和 redis 協議.</li><li>iiiiiiiii)服務器池配置簡單，通過一個 YAML 文件即可</li><li>iiiiiiiiii)一致性hash</li><li>iiiiiiiiii)詳細的監控統計信息</li><li>iiiiiiiiiii)支持 Linux, *BSD, OS X and Solaris (SmartOS)</li><li>iiiiiiiiiiii)支持設置HashTag</li><li>iiiiiiiiiiiiiii)連接複用，內存複用，提高效率</li></ul><p><strong><em>2.2 memcache緩存集群拓撲結構</em></strong></p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f31195000b32401b8a5173b87a78fb6f><p class=pgc-img-caption>twemproxy緩存集群拓撲圖</p></div><p>如上圖所示，實際應用中業務程序通過輪詢不同的twemproxy來提高qps，同時實現負載均衡。</p><p><strong><em>說明:官方memcache沒有集群版和持久化功能，集群版和持久化功能由我們自己內部開發完成。</em></strong></p><p><strong><em>2.3 推特原生twemproxy瓶頸</em></strong></p><p>如今twemproxy憑藉其高性能的優勢, 在很多互聯網公司得到了廣泛的應用，已經佔據了其不可動搖的地位, 然而在實際的生產環境中, 存在以下缺陷，如下：</p><p>i)單進程單線程, 無法充分發揮服務器多核cpu的性能</p><p>ii)當twemproxy qps短連接達到8000後，消耗cpu超過70%，時延陡增。</p><p>iii)大流量下造成IO阻塞，無法處理更多請求，qps上不去，業務時延飆升</p><p>iiii)維護成本高，如果想要充分發揮服務器的所有資源包括cpu、 網絡io等，就必須建立多個twemproxy實例，維護成本高</p><p>iiiii)擴容、升級不便</p><p>原生twemproxy進程呈現了下圖現象：一個人幹活，多個人圍觀。多核服務器只有一個cpu在工作，資源沒有得到充分利用。</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f7d7f6f3f8414aee82b5d3d853fcb536><p class=pgc-img-caption></p></div><p><strong><em>3. Nginx</em></strong></p><p>nginx是俄羅斯軟件工程師Igor Sysoev開發的免費開源web服務器軟件，聚焦於高性能，高併發和低內存消耗問題，因此成為業界公認的高性能服務器，並逐漸成為業內主流的web服務器。主要特點有：</p><p>i)完全藉助epoll機制實現異步操作，避免阻塞。</p><p>ii)重複利用現有服務器的多核資源。</p><p>iii)充分利用CPU 親和性（affinity），把每個進程與固定CPU綁定在一起，給定的 CPU 上儘量長時間地運行而不被遷移到其他處理器的傾向性，減少進程調度開銷。</p><p>iiii)請求響應快</p><p>iiiii)支持模塊化開發，擴展性好</p><p>iiiii)Master+多worker進程方式，確保worker進程可靠工作。當worker進程出錯時，可以快速拉起新的worker子進程來提供服務。</p><p>iiiiii)內存池、連接池等細節設計保障低內存消耗。</p><p>iiiiii)熱部署支持，master與worker進程分離設計模式，使其具有熱部署功能。</p><p>iiiiiii)升級方便，升級過程不會對業務造成任何傷害。</p><p>Nginx多進程提供服務過程如下圖所示：</p><p><strong><em>4 Nginx master+worker多進程機制在twemproxy中的應用</em></strong></p><p><strong><em>4.1 為什麼選擇nginx多進程機制</em></strong><strong><em>做為參考</em></strong><strong><em>？</em></strong></p><p>Twemproxy和nginx都屬於網絡io密集型應用，都屬於七層轉發應用，時延要求較高，應用場景基本相同。</p><p>Nginx充分利用了多核cpu資源，性能好，時延低。</p><p><strong><em>4.2 Master-worker多進程機制原理</em></strong></p><p>Master-worker進程機制採用一個master進程來管理多個worker進程。每一個worker進程都是繁忙的，它們在真正地提供服務，master進程則很“清閒”，只負責監控管理worker進程, 包含：接收來自外界的信號，向各worker進程發送信號，監控worker進程的運行狀態，當worker進程退出後(異常情況下)，會自動重新啟動新的worker進程。</p><p>worker進程負責處理客戶端的網絡請求，多個worker進程同時處理來自客戶端的不同請求，worker進程數可配置。</p><p><strong><em>4.3 多進程關鍵性能問題點</em></strong></p><p>master-worker多進程模式需要解決的問題主要有：</p><p>i)linux內核低版本(2.6以下版本), “驚群”問題</p><p>ii) linux內核低版本(2.6以下版本),負載均衡問題</p><p>iii)linux內核高版本(3.9以上版本)新特性如何利用</p><p>iii)如何確保進程見高可靠通信</p><p>iiii)如何減少worker進程在不同cpu切換的開銷</p><p>iiiii)master進程如何彙總各個工作進程的監控數據</p><p>iiiiii)worker進程異常，如何快速恢復</p><p><em></em><strong><em>4.3.1 linux內核低版本關鍵技術問題</em></strong></p><p>由於linux低內核版本缺陷，因此存在”驚群”、負載不均問題，解決辦法完全依賴應用層代碼保障。</p><p><strong><em>4.3.1.1 如何解決“驚群”問題</em></strong></p><p>當客戶端發起連接後，由於所有的worker子進程都監聽著同一個端口，內核協議棧在檢測到客戶端連接後，會激活所有休眠的worker子進程，最終只會有一個子進程成功建立新連接，其他子進程都會accept失敗。</p><p>Accept失敗的子進程是不應該被內核喚醒的，因為它們被喚醒的操作是多餘的，佔用本不應該被佔用的系統資源，引起不必要的進程上下文切換，增加了系統開銷，同時也影響了客戶端連接的時延。</p><p>“驚群”問題是多個子進程同時監聽同一個端口引起的，因此解決的方法是同一時刻只讓一個子進程監聽服務器端口，這樣新連接事件只會喚醒唯一正在監聽端口的子進程。</p><p>因此“驚群”問題通過非阻塞的accept鎖來實現進程互斥accept()，其原理是：在worker進程主循環中非阻塞trylock獲取accept鎖，如果trylock成功，則此進程把監聽端口對應的fd通過epoll_ctl()加入到本進程自由的epoll事件集；如果trylock失敗，則把監聽fd從本進程對應的epoll事件集中清除。</p><p>Nginx實現了兩套互斥鎖：基於原子操作和信號量實現的互斥鎖、基於文件鎖封裝的互斥鎖。考慮到鎖的平臺可移植性和通用性，改造twemproxy選擇時，選擇文件鎖實現。</p><p>如果獲取accept鎖成功的進程佔用鎖時間過長，那麼其他空閒進程在這段時間內無法獲取到鎖，從而無法接受新的連接。最終造成客戶端連接相應時間變長，qps低，同時引起負載嚴重不均衡。為了解決該問題，選擇通過post事件隊列方式來提高性能，trylock獲取到accept鎖成功的進程，其工作流程如下：</p><p>1.trylock獲取accept鎖成功</p><p>2.通過epoll_wait獲取所有的事件信息，把監聽到的所有accept事件信息加入accept_post列表，把已有連接觸發的讀寫事件信息加入read_write_post列表。</p><p>3.執行accept_post列表中的所有事件</p><p>4.Unlock鎖</p><p>5.執行read_write_post列表中的事件。</p><p>Worker進程主循環工作流程圖如下：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bc2447109ab14f869e07e77aaee1c8b7><p class=pgc-img-caption></p></div><p>從上圖可以看出，worker進程藉助epoll來實現網絡異步收發，客戶端連接twemproxy的時候，worker進程循環檢測客戶端的各種網絡事件和後端memcached的網絡事件，並進行相應的處理。</p><p>twemproxy各個進程整體網絡i/o處理過程圖如下：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14edb801584946e0b8f802c1544fef90><p class=pgc-img-caption></p></div><p><strong><em>4.3.1.2 如何解決“負載均衡“問題</em></strong></p><p>在多個子進程爭搶處理同一個新連接事件時，一定只有一個worker子進程最終會成功建立連接，隨後，它會一直處理這個連接直到連接關閉。這樣，如果有的子進程“運氣”很好，它們搶著建立並處理了大部分連接，其他子進程就只能處理少量連接，這對多核cpu架構下的應用很不利。理想情況下，每個子進程應該是平等的，每個worker子進程應該大致平均的處理客戶端連接請求。如果worker子進程負載不均衡，必然影響整體服務的性能。</p><p>nginx通過連接閾值機制來實現負載均衡，其原理如下：每個進程都有各自的最大連接數閾值max_threshold和當前連接閾值數local_threshold，和當前連接數閾值，進程每接收一個新的連接，local_threshold增一，連接斷開後，local_threashold減一。如果local_threshold超過max_threshold，則不去獲取accept鎖，把accept機會留給其他進程，同時把local_threshold減1，這樣下次就有機會獲取accept鎖，接收客戶端連接了。</p><p>在實際業務應用中，有的業務採用長連接和twemproxy建立連接，連接數最大可能就幾百連接，如果設置max_threshold閾值過大，多個連接如果同時壓到twemproxy，則很容易引起所有連接被同一個進程獲取從而造成不均衡。</p><p>為了儘量減少負載不均衡，在實際應用中，新增了epoll_wait超時時間配置選項，把該超時時間設短，這樣減少空閒進程在epoll_wait上的等待事件，從而可以更快相應客戶端連接，並有效避免負載不均衡。</p><p><strong>4.3.2 Linux內核高版本TCP REUSEPORT特性如何利用</strong></p><p><strong><em>4.3.2.1 什麼是reuseport？</em></strong></p><p>reuseport是一種套接字複用機制，它允許你將多個套接字bind在同一個IP地址/端口對上，這樣一來，就可以建立多個服務來接受到同一個端口的連接。</p><p><strong><em>4.3.2.2 支持reuseport和不支持reuseport的區別</em></strong></p><p>如果linux內核版本小於3.9，則不支持reuseport(注:部分centos發行版在低版本中已經打了reuseport patch,所以部分linux低版本發行版本也支持該特性)。</p><p>不支持該特性的內核，一個ip+port組合，只能被監聽bind一次。這樣在多核環境下，往往只能有一個線程（或者進程）是listener，也就是同一時刻只能由一個進程或者線程做accept處理，在高併發情況下，往往這就是性能瓶頸。其網絡模型如下:</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/663db8e6ea80421fa1262eb068c16ec7><p class=pgc-img-caption></p></div><p>在Linux kernel 3.9帶來了reuseport特性，它可以解決上面的問題，其網絡模型如下:</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf21ad3e6a844290b04159f1cbd7bc64><p class=pgc-img-caption></p></div><p>reuseport是支持多個進程或者線程綁定到同一端口，提高服務器程序的吞吐性能，其優點體現在如下幾個方面:</p><p>i)允許多個套接字 bind()/listen() 同一個TCP/UDP端口</p><p>ii)每一個線程擁有自己的服務器套接字</p><p>iii)在服務器套接字上沒有了鎖的競爭，因為每個進程一個服務器套接字</p><p>iiii)內核層面實現負載均衡</p><p>iiiii)安全層面，監聽同一個端口的套接字只能位於同一個用戶下面</p><p><strong><em>4.3.3 Master進程和worker進程如何通信？</em></strong></p><p>由於master進程需要實時獲取worker進程的工作狀態，並實時彙總worker進程的各種統計信息，所以選擇一種可靠的進程間通信方式必不可少。</p><p>在twemproxy改造過程中，直接參考nginx的信號量機制和channel機制(依靠socketpair)來實現父子進程見通信。Master進程通過信號量機制來檢測子進程是否異常，從而快速直接的反應出來；此外，藉助socketpair，封裝出channel接口來完成父子進程見異步通信，master進程依靠該機制來統計子進程的各種統計信息並彙總，通過獲取來自master的彙總信息來判斷整個twemproxy中間件的穩定性、可靠性。</p><p>配置下發過程：主進程接收實時配置信息，然後通過channel機制發送給所有的worker進程，各個worker進程收到配置信息後應答給工作進程。流程如下:</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dbf1055b208545dc87c6978701001d21><p class=pgc-img-caption></p></div><p>獲取監控信息流程和配置下發流程基本相同，master進程收到各個工作進程的應答後，由master進程做統一彙總，然後發送給客戶端。</p><p><strong><em>4.3.4 如何減少worker進程在不同cpu切換的開銷</em></strong></p><p>CPU 親和性（affinity） 就是進程要在某個給定的 CPU 上儘量長時間地運行而不被遷移到其他處理器的傾向性。</p><p>Linux 內核進程調度器天生就具有被稱為 軟 CPU 親和性（affinity） 的特性，這意味著進程通常不會在處理器之間頻繁遷移。這種狀態正是我們希望的，因為進程遷移的頻率小就意味著產生的負載小。具體參考sched_setaffinity函數。</p><p><strong><em>4.3.5 worker進程異常如何減少對業務的影響？</em></strong></p><p>在實際線上環境中，經常出現這樣的情況:某個多線程服務跑幾個月後，因為未知原因進程掛了，最終造成整個服務都會不可用。</p><p>這時候，master+多worker的多進程模型就體現了它的優勢，如果代碼有隱藏的並且不容易觸發的bug，某個時候如果某個請求觸發了這個bug，則處理這個請求的worker進程會段錯誤退出。但是其他worker進程不會收到任何的影響，也就是說如果一個改造後的twemproxy起了20個worker進程，某個時候一個隱藏bug被某個請求觸發，則只有處理該請求的進程段錯誤異常，其他19個進程不會受到任何影響，該隱藏bug觸發後影響面僅為5%。如果是多線程模型，則影響面會是100%。</p><p>如果某個worker進程掛了，master父進程會感知到這個信號，然後重新拉起一個worker進程，實現瞬間無感知”拉起”恢復。以下為模擬觸發異常段錯誤流程：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4219445e726b48089120f6fff4108787><p class=pgc-img-caption></p></div><p>如上圖所示，殺掉31420 worker進程後，master進程會立馬在拉起一個31451工作進程，實現了快速恢復。</p><p>多進程異常，自動”拉起”功能源碼，可以參考如下demo：</p><p>https://github.com/y123456yz/reading-code-of-nginx-1.9.2/blob/master/nginx-1.9.2/src/demo.c</p><p><strong><em>5 網絡優化</em></strong></p><p><strong><em>5.1 網卡多隊列</em></strong></p><p>在實際上線後，發現軟中斷過高，幾乎大部分都集中在一個或者幾個CPU上，嚴重影響客戶端連接和數據轉發，qps上不去，時延抖動厲害。</p><p>RSS（Receive Side Scaling）是網卡的硬件特性，實現了多隊列，可以將不同的流分發到不同的CPU上。支持RSS的網卡，通過多隊列技術，每個隊列對應一箇中斷號，通過對每個中斷的綁定，可以實現網卡中斷在cpu多核上的分配，最終達到負載均衡的作用。</p><p><strong><em>5.2 可怕的40ms</em></strong></p><p>原生twemproxy在線上跑得過程中，發現時延波動很大，抓包發現其中部分數據包應答出現了40ms左右的時延，拉高了整體時延抓包如下(藉助tcprstat工具)：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/89d91e4dbbef412ea7bb6ab36a1d5c9b><p class=pgc-img-caption></p></div><p>解決辦法如下：在recv系統調用後，調用一次setsockopt函數，設置TCP_QUICKACK。代碼修改如下：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e019c1524f6e463195ec855331cdd729><p class=pgc-img-caption></p></div><p><strong><em>6 Twemproxy改造前後性能對比 (時延、qps對比)</em></strong></p><p><strong><em>6.1 線上真實流量時延對比</em></strong></p><p><strong><em>6.1.1 改造前線上twemproxy集群時延</em></strong></p><p>線上集群完全採用開源twemproxy做代理，架構如下：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c8dfd2c9e8b4eb38ba5971209483f8e><p class=pgc-img-caption></p></div><p>未改造前線上twemproxy+memcache集群，qps=5000~6000，長連接，客戶端時延分佈如下圖所示：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/35d09e10ea8f4ea4a26109e4d146ef11><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/55076fd6e6b94ff2b093b93fbfd66fb1><p class=pgc-img-caption></p></div><p>在twemproxy機器上使用tcprstat監控到的網卡時延如下:</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9fb3ce953bf2445eb754c607e599d4ce><p class=pgc-img-caption></p></div><p>從上面兩個圖可以看出，採用原生twemproxy,時延高，同時抖動厲害。</p><p><strong>6.1.2 參照nginx改造後的twemproxy時延</strong></p><p>線上集群一個twemproxy採用官方原生twemproxy，另一個為改造後的twemproxy，其中改造後的twemproxy配置worker進程數為1，保持和原生開源twemproxy進程數一致，架構如下：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/88ca75b3638e4ac7bcc8bd98722f235d><p class=pgc-img-caption></p></div><p>替換線上集群兩個代理中的一個後(影響50%流量)，長連接，qps=5000~6000，客戶端埋點監控時延分佈如下:</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fac54beb46c641f58749414989873bef><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d5908cd7cb834da7ae0361ac77b42d40><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/698cbf09e3504316b0c5873ed1327f06><p class=pgc-img-caption></p></div><p>替換兩個proxy中的一個後，使用tcprstat在代理集群上面查看兩個代理的時延分佈如下:</p><p>原生twemproxy節點機器上的時延分佈:</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7107eff7e3f94908889d257bca56f157><p class=pgc-img-caption></p></div><p>另一個改造後的twemproxy節點機器上的時延分佈：</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62657b1296a44cd497934ace7a47d221><p class=pgc-img-caption></p></div><p>總結：替換線上兩個proxy中的一個後，客戶端時間降低了一倍，如果線上集群兩個代理都替換為改造後的twemproxy，客戶端監控時延預計會再降低一倍，總體時延降低3倍左右。</p><p>此外，從監控可以看出，改造後的twemproxy時延更低，更加穩定，無任何波動。</p><p><strong><em>6.2 參考nginx多進程改造後的twemproxy線下壓測結果(開啟reuseport功能)</em></strong></p><p>監聽同一個端口，數據長度100字節，壓測結果如下：</p><p>linux內核版本:linux-3.10</p><p>物理機機型： M10(48 cpu)</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/852f6969843b4793a490acf809f09b64><p class=pgc-img-caption></p></div><p>多進程監聽同一個端口，數據長度150字節，壓測結果如下：</p><p>linux內核版本:linux-3.10</p><p>物理機機型： TS60 (24 cpu)</p><div class=pgc-img><img alt=多進程高併發、低時延、高可靠機制在緩存twemproxy代理中的應用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e82c5c0e13de40cbb7ff2bdb1f26a990><p class=pgc-img-caption></p></div><p><strong><em>7 總結</em></strong></p><p><strong><em>7.1 多進程、多線程機制選擇</em></strong></p><p>選擇參照nginx多進程機制，而不選擇多線程實現原因主要有:</p><p>1) 多進程機制無鎖操作，實現更容易</p><p>2) 多進程的代理，整個worker進程無任何鎖操作，性能更好</p><p>3) 如果是多線程方式，如果代碼出現bug段錯誤，則整個進程掛掉，整個服務不可用。而如果是多進程方式，因為bug觸發某個worker進程段錯誤異常，其他工作進程不會受到如何影響，20個worker進程，如果觸發異常，同一時刻只有有1/20的流量受到影響。而如果是多線程模式，則100%的流量會受到影響。</p><p>4) worker進程異常退出後，master進程立馬感知拉起一個新進程提供服務，可靠性更高。</p><p>5) 配置熱加載、程序熱升級功能實現更加容易</p><p><strong><em>7.2 參照nginx改造後的twemproxy特性</em></strong></p><p>支持nginx幾乎所有的優秀特性，同時也根據自己實際情況新增加了自有特性:</p><p>1) master+多worker進程機制</p><p>2) 適配所有linux內核版本，內核低版本驚群問題避免支持</p><p>3) quic_ack支持</p><p>4) reuser_port適配支持</p><p>5) worker進程異常，master進程自動拉起功能支持</p><p>6) 90%、95%、98%、100%平均時延統計功能支持</p><p>7) memcache單機版、集群版支持</p><p>8) redis單機版、集群版支持</p><p>9) 二進制協議、文本協議同時支持</p><p>10) redis、memcache集群在線擴容、縮容、數據遷移支持，擴縮容、數據遷移過程對業務無任何影響。</p><p>11) 多租戶支持，一個代理可以接多個memcache、redis集群，並支持混部。</p><p>12) mget、gets、sets等批量處理命令優化處理</p><p>13) 慢響應日誌記錄功能支持</p><p>14) 內存參數實時修改支持</p><p>15) 詳細的集群監控統計功能</p><p>16) CPU親緣性自添加</p><p>17)內存配置動態實時修改</p><p><strong><em>7.3後期計劃</em></strong></p><p>添加如下功能:</p><p>i) 配置文件熱加載支持。</p><p>ii) 代碼熱升級功能支持。</p><p><strong><em>7.4 長遠規劃展望</em></strong></p><p>抽象出一款類似nginx的高性能代理軟件，nginx支持http協議，我們的支持tcp協議代理，覆蓋nginx所有功能，包括前面提到的所有功能，同時支持模塊化開發。這樣，很多的tcp協議代理就無需關心網絡架構底層實現，只需要根據需要開發對應的協議解析模塊，和自己關心的統計、審計等功能功能，降低開發成本。現有開源的中間件，很大一部分都是tcp的，有自己的私有tcp協議，把這個抽象出來，開發成本會更低</p><p><strong>end：如果你覺得本文對你有幫助的話，記得關注點贊轉發，你的支持就是我更新動力。</strong></p><p><strong>如果您有不同的看法，歡迎在評論區留言與我們一起討論</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>進程</a></li><li><a>低時延</a></li><li><a>機制</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html alt=世界發展進程中的耀眼篇章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RCLmM9dF1KnwoT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html title=世界發展進程中的耀眼篇章>世界發展進程中的耀眼篇章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html alt=事務機制和鎖機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5a547c8c402142cca7ed81d05fe0e3e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html title=事務機制和鎖機制>事務機制和鎖機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html alt=連mysql鎖的機制都不瞭解，怎麼做架構師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html title=連mysql鎖的機制都不瞭解，怎麼做架構師>連mysql鎖的機制都不瞭解，怎麼做架構師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html alt=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html title=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位>天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html alt=市稅務局創新制度機制爭創“模範機關” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d879650a7d06416c90fb7286175f1f59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html title=市稅務局創新制度機制爭創“模範機關”>市稅務局創新制度機制爭創“模範機關”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html alt="機制砂 | 大家知多少？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54b1eea319b842bcb8483f4056798bec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html title="機制砂 | 大家知多少？">機制砂 | 大家知多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html alt=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2b6d9a5dccf246aeaba80b2a1ecb9f0a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html title=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？>機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html alt=幾種基於可靠性指標的容量支持機制分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZYfwddDNSSyQW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html title=幾種基於可靠性指標的容量支持機制分析>幾種基於可靠性指標的容量支持機制分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html alt=java反射機制的講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad2c92f100a4d2e8213dcf70d4781c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html title=java反射機制的講解>java反射機制的講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09d5d35b.html alt=加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09d5d35b.html title=加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人>加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/496f3f6a.html alt=劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7737ac36f58f40a98a798a5cbf5d5295 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/496f3f6a.html title=劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要>劣質機制砂產生的4類原因分析！工藝設計和設備選型非常重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html alt=Java併發編程：進程和線程之由來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/4f658919-1d85-46bc-bbf1-64aac52f4c80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html title=Java併發編程：進程和線程之由來>Java併發編程：進程和線程之由來</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>