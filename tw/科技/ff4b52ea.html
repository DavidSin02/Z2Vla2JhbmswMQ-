<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大廠面試官：說一下JDK1.8 HashMap有哪些亮點？ | 极客快訊</title><meta property="og:title" content="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/b7654aee-bb6d-4c0d-906a-a0021a4438b6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff4b52ea.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff4b52ea.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ff4b52ea.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff4b52ea.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff4b52ea.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ff4b52ea.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ff4b52ea.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ff4b52ea.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/ff4b52ea.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大廠面試官：說一下JDK1.8 HashMap有哪些亮點？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/b7654aee-bb6d-4c0d-906a-a0021a4438b6><p class=pgc-img-caption></p></div><p>上篇我們介紹了JDK1.7版的HashMap，今天我們來講解下JDK1.8版的HashMap。</p><p style=text-align:start>JDK1.7的實現大家看出有沒有需要優化的地方？</p><p style=text-align:start>其實一個很明顯的地方就是：<strong>當 Hash 衝突嚴重時，</strong><strong>在</strong><strong>桶上形成的鏈表會</strong><strong>變的</strong><strong>越來越長，這樣在查詢時的效率就會越來越低；時間複雜度為 O(N)。</strong></p><p style=text-align:start>因此JDK1.8 中重點優化了這個查詢效率。</p><h1 class=pgc-h-arrow-right>1、JDK1.8 HashMap 數據結構圖</h1><div class=pgc-img><img alt="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9f8b0c626dd4e09afa66d734860c448><p class=pgc-img-caption></p></div><p>我們會發現優化的部分就是把鏈表結構變成了紅黑樹。原來jdk1.7的優點是增刪效率高，於是在jdk1.8的時候，不僅僅增刪效率高，而且查找效率也提升了。</p><p style=text-align:start>注意：<strong>不是說變成了紅黑樹效率就一定提高了，只有在鏈表的長度不小於8，而且</strong><strong>數組</strong><strong>的長度不小於64的時候才會將鏈表轉化為紅黑樹。</strong></p><p style=text-align:start><strong>問題一：什麼是紅黑樹呢？</strong></p><p style=text-align:start>紅黑樹是一個自平衡的二叉查找樹，也就是說紅黑樹的查找效率是非常的高，查找效率會從鏈表的o(n)降低為o(logn)。如果之前沒有了解過紅黑樹的話，也沒關係，你就記住紅黑樹的查找效率很高就OK了。</p><p style=text-align:start><strong>問題二：為什麼不一下子把整個鏈表變為紅黑樹呢？</strong></p><p style=text-align:start>這個問題的意思是這樣的，就是說我們為什麼非要等到鏈表的長度大於等於8的時候，才轉變成紅黑樹？在這裡可以從兩方面來解釋</p><p style=text-align:start>（1）構造紅黑樹要比構造鏈表複雜，在鏈表的節點不多的時候，從整體的性能看來， 數組+鏈表+紅黑樹的結構可能不一定比數組+鏈表的結構性能高。就好比殺雞焉用牛刀的意思。</p><p style=text-align:start>（2）HashMap頻繁的擴容，會造成底部紅黑樹不斷的進行拆分和重組，這是非常耗時的。因此，也就是鏈表長度比較長的時候轉變成紅黑樹才會顯著提高效率。</p><h1 class=pgc-h-arrow-right>2、HashMap構造方法</h1><p style=text-align:start>構造方法一共有四個：</p><pre><code>public HashMap() {     this.loadFactor = DEFAULT_LOAD_FACTOR; }public HashMap(int initialCapacity) {     this(initialCapacity, DEFAULT_LOAD_FACTOR);}public HashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);}public HashMap(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException("Illegal initial capacity: " +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException("Illegal load factor: " +                                           loadFactor);    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);}</code></pre><p>這四個構造方法很明顯第四個最麻煩，我們就來分析一下第四個構造方法，其他三個自然而然也就明白了。上面出現了兩個新的名詞：loadFactor和initialCapacity。我們一個一個來分析：</p><p style=text-align:start>（1）initialCapacity初始容量</p><p style=text-align:start>官方要求我們要輸入一個2的N次冪的值，比如說2、4、8、16等等這些，但是我們忽然一個不小心，輸入了一個20怎麼辦？沒關係，虛擬機會根據你輸入的值，找一個離20最近的2的N次冪的值，比如說16離他最近，就取16為初始容量。</p><p style=text-align:start>（2）loadFactor負載因子</p><p style=text-align:start>負載因子，默認值是0.75。負載因子表示一個散列表的空間的使用程度，有這樣一個公式：initailCapacity*loadFactor=HashMap的容量。 所以負載因子越大則散列表的裝填程度越高，也就是能容納更多的元素，元素多了，鏈表大了，所以此時索引效率就會降低。反之，負載因子越小則鏈表中的數據量就越稀疏，此時會對空間造成爛費，但是此時索引效率高。</p><h1 class=pgc-h-arrow-right>3、put方法</h1><p style=text-align:start>我們在存儲一個元素的時候，大多是使用下面的這種方式。</p><pre><code>public class Test {    public static void main(String[] args) {        HashMap&lt;String, Integer&gt; map= new HashMap&lt;&gt;();        //存儲一個元素        map.put("張三", 20);    }}</code></pre><p>在這裡HashMap&lt;String, Integer>，第一個參數是鍵，第二個參數是值，合起來叫做鍵值對。存儲的時候只需要調用put方法即可。那底層的實現原理是怎麼樣的呢？這裡還是先給出一個流程圖：</p><div class=pgc-img><img alt="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ece71a757d8f480d8780a82e9efd1173><p class=pgc-img-caption></p></div><p>上面這個流程，不知道你能否看到，紅色字跡的是三個判斷框，也是轉折點，我們使用文字來梳理一下這個流程：</p><p style=text-align:start>（1）第一步：調用put方法傳入鍵值對</p><p style=text-align:start>（2）第二步：使用hash算法計算hash值</p><p style=text-align:start>（3）第三步：根據hash值確定存放的位置，判斷是否和其他鍵值對位置發生了衝突</p><p style=text-align:start>（4）第四步：若沒有發生衝突，直接存放在數組中即可</p><p style=text-align:start>（5）第五步：若發生了衝突，還要判斷此時的數據結構是什麼？</p><p style=text-align:start>（6）第六步：若此時的數據結構是紅黑樹，那就直接插入紅黑樹中</p><p style=text-align:start>（7）第七步：若此時的數據結構是鏈表，判斷插入之後是否大於等於8</p><p style=text-align:start>（8）第八步：插入之後大於8了，就要先調整為紅黑樹，在插入</p><p style=text-align:start>（9）第九步：插入之後不大於8，那麼就直接插入到鏈表尾部即可。</p><p style=text-align:start>上面就是插入數據的整個流程，光看流程還不行，我們還需要深入到源碼中去看看底部是如何按照這個流程寫代碼的。</p><p style=text-align:start>鼠標聚焦在put方法上面，按一下F3，我們就能進入put的源碼。來看一下：</p><pre><code>public V put(K key, V value) {     return putVal(hash(key), key, value, false, true);}</code></pre><p>也就是說，put方法其實調用的是putVal方法。putVal方法有5個參數：</p><p style=text-align:start>（1）第一個參數hash：調用了hash方法計算hash值</p><p style=text-align:start>（2）第二個參數key：就是我們傳入的key值，也就是例子中的張三</p><p style=text-align:start>（3）第三個參數value：就是我們傳入的value值，也就是例子中的20</p><p style=text-align:start>（4）第四個參數onlyIfAbsent：也就是當鍵相同時，不修改已存在的值</p><p style=text-align:start>（5）第五個參數evict ：如果為false，那麼數組就處於創建模式中，所以一般為true。</p><p style=text-align:start>知道了這5個參數的含義，我們就進入到這個putVal方法中。</p><pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    //第一部分    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    //第二部分    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    //第三部分    else {        Node&lt;K,V&gt; e; K k;        //第三部分第一小節        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        //第三部分第二小節        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        //第三部分第三小節        else {            for (int binCount = 0; ; ++binCount) {                //第三小節第一段                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                //第三小節第一段                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                //第三小節第三段                p = e;            }        }        //第三部分第四小節        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    //第四部分    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p>乍一看，這代碼完全沒有讀下去的慾望，第一次看的時候真實噁心到想吐，但是結合上一開始畫的流程圖再來分析，相信就會好很多。我們把代碼進行拆分（整體分了四大部分）：</p><p style=text-align:start>（1）Node&lt;K,V>[] tab中tab表示的就是數組。Node&lt;K,V> p中p表示的就是當前插入的節點</p><p style=text-align:start>（2）第一部分：</p><pre><code>if ((tab = table) == null || (n = tab.length) == 0)       n = (tab = resize()).length;</code></pre><p>這一部分表示的意思是如果數組是空的，那麼就通過resize方法來創建一個新的數組。在這裡resize方法先不說明，在下一小節擴容的時候會提到。</p><p style=text-align:start>（3）第二部分：</p><pre><code>if ((p = tab[i = (n - 1) &amp; hash]) == null)      tab[i] = newNode(hash, key, value, null);</code></pre><p>i表示在數組中插入的位置，計算的方式為(n - 1) & hash。在這裡需要判斷插入的位置是否是衝突的，如果不衝突就直接newNode，插入到數組中即可，這就和流程圖中第一個判斷框對應了。</p><p style=text-align:start>如果插入的hash值衝突了，那就轉到第三部分，處理衝突</p><p style=text-align:start>（4）第三部分：</p><pre><code>else {    Node&lt;K,V&gt; e; K k;    //第三部分a    if (p.hash == hash &amp;&amp;        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))        e = p;    //第三部分b    else if (p instanceof TreeNode)        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);    //第三部分c    else {        for (int binCount = 0; ; ++binCount) {            //第三小節第一段            if ((e = p.next) == null) {                p.next = newNode(hash, key, value, null);                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                    treeifyBin(tab, hash);                break;            }            //第三小節第一段            if (e.hash == hash &amp;&amp;                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                break;            //第三小節第三段            p = e;        }    }    //第三部分d    if (e != null) { // existing mapping for key        V oldValue = e.value;        if (!onlyIfAbsent || oldValue == null)            e.value = value;        afterNodeAccess(e);        return oldValue;    }}</code></pre><p>我們會看到，處理衝突還真是麻煩，好在我們對這一部分又進行了劃分</p><p style=text-align:start>a）第三部分第一小節：</p><pre><code>if (p.hash == hash      &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))     e = p;</code></pre><p>在這裡判斷table[i]中的元素是否與插入的key一樣，若相同那就直接使用插入的值p替換掉舊的值e。</p><p style=text-align:start>b）第三部分第二小節：</p><pre><code>else if (p instanceof TreeNode)       e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</code></pre><p>判斷插入的數據結構是紅黑樹還是鏈表，在這裡表示如果是紅黑樹，那就直接putTreeVal到紅黑樹中。這就和流程圖裡面的第二個判斷框對應了。</p><p style=text-align:start>c）第三部分第三小節：</p><pre><code>//第三部分celse {     for (int binCount = 0; ; ++binCount) {        //第三小節第一段         if ((e = p.next) == null) {              p.next = newNode(hash, key, value, null);              if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                  treeifyBin(tab, hash);                  break;         }         //第三小節第一段         if (e.hash == hash &amp;&amp;               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))              break;         //第三小節第三段         p = e;    }}</code></pre><p>如果數據結構是鏈表，首先要遍歷table數組是否存在，如果不存在直接newNode(hash, key, value, null)。如果存在了直接使用新的value替換掉舊的。</p><p style=text-align:start>注意一點：不存在並且在鏈表末尾插入元素的時候，會判斷binCount >= TREEIFY_THRESHOLD - 1。也就是判斷當前鏈表的長度是否大於閾值8，如果大於那就會把當前鏈表轉變成紅黑樹，方法是treeifyBin。這也就和流程圖中第三個判斷框對應了。</p><p style=text-align:start>（5）第四部分：</p><pre><code>if (++size &gt; threshold)        resize();afterNodeInsertion(evict);return null;</code></pre><p>插入成功之後，還要判斷一下實際存在的鍵值對數量size是否大於閾值threshold。如果大於那就開始擴容了。</p><h1 class=pgc-h-arrow-right>4、resize方法</h1><p style=text-align:start>為什麼擴容呢？很明顯就是當前容量不夠，也就是put了太多的元素。為此我們還是先給出一個流程圖，再來進行分析。</p><div class=pgc-img><img alt="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/098abf61655b41e297aff192b6806eaf><p class=pgc-img-caption></p></div><p>這個擴容就比較簡單了，HaspMap擴容就是就是先計算 新的hash表容量和新的容量閥值，然後初始化一個新的hash表，將舊的鍵值對重新映射在新的hash表裡。如果在舊的hash表裡涉及到紅黑樹，那麼在映射到新的hash表中還涉及到紅黑樹的拆分。整個流程也符合我們正常擴容一個容量的過程，我們根據流程圖結合代碼來分析：</p><pre><code>final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    //第一部分：擴容    if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    //第二部分：設置閾值    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    @SuppressWarnings({"rawtypes","unchecked"})        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    //第三部分：舊數據保存在新數組裡面    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                //只有一個節點，通過索引位置直接映射                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                //如果是紅黑樹，需要進行樹拆分然後映射                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else {                     //如果是多個節點的鏈表，將原鏈表拆分為兩個鏈表                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    //鏈表1存於原索引                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    //鏈表2存於原索引加上原hash桶長度的偏移量                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><p>這代碼量同樣讓人噁心，不過我們還是分段來分析：</p><p style=text-align:start>（1）第一部分：</p><pre><code>//第一部分：擴容if (oldCap &gt; 0) {      if (oldCap &gt;= MAXIMUM_CAPACITY) {           threshold = Integer.MAX_VALUE;           return oldTab;      }      else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;          oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold}</code></pre><p>根據代碼也能看明白：首先如果超過了數組的最大容量，那麼就直接將閾值設置為整數最大值，然後如果沒有超過，那就擴容為原來的2倍，這裡要注意是oldThr &lt;&lt; 1，移位操作來實現的。</p><p style=text-align:start>（2）第二部分：</p><pre><code>//第二部分：設置閾值else if (oldThr &gt; 0) //閾值已經初始化了，就直接使用      newCap = oldThr;else {    // 沒有初始化閾值那就初始化一個默認的容量和閾值      newCap = DEFAULT_INITIAL_CAPACITY;      newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);}if (newThr == 0) {      float ft = (float)newCap * loadFactor;      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);}//為當前的容量閾值賦值threshold = newThr;@SuppressWarnings({"rawtypes","unchecked"})Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];table = newTab;</code></pre><p>首先第一個else if表示如果閾值已經初始化過了，那就直接使用舊的閾值。然後第二個else表示如果沒有初始化，那就初始化一個新的數組容量和新的閾值。</p><p style=text-align:start>（3）第三部分</p><p style=text-align:start>第三部分同樣也很複雜，就是把舊數據複製到新數組裡面。這裡面需要注意的有下面幾種情況：</p><p style=text-align:start>A：擴容後，若hash值新增參與運算的位=0，那麼元素在擴容後的位置=原始位置</p><p style=text-align:start>B：擴容後，若hash值新增參與運算的位!=0，那麼元素在擴容後的位置=原始位置+擴容後的舊位置。</p><p style=text-align:start>這裡面有一個非常好的設計理念，<strong>擴容後長度為原hash表的2倍，於是把hash表分為兩半，分為低位和高位，如果能把原鏈表的鍵值對， 一半放在低位，一半放在高位</strong>，而且是通過e.hash & oldCap == 0來判斷，這個判斷有什麼優點呢？</p><p style=text-align:start>舉個例子：n = 16，二進制為10000，第5位為1，e.hash & oldCap 是否等於0就取決於e.hash第5 位是0還是1，這就相當於有50%的概率放在新hash表低位，50%的概率放在新hash表高位。</p><h1 class=pgc-h-arrow-right>5、hash方法</h1><p style=text-align:start>Java 8中的散列值優化函數：</p><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>源碼中模運算就是把散列值和數組長度做一個"與"操作：</p><pre><code>if ((p = tab[i = (n - 1) &amp; hash]) == null)</code></pre><p>這也正好解釋了為什麼HashMap的數組長度要取2的整次冪，因為這樣（數組長度-1）正好相當於一個“低位掩碼”，“與”操作的結果就是散列值的高位全部歸零，只保留低位值，用來做數組下標訪問。</p><p style=text-align:start>以初始長度16為例，16-1=15，2進製表示是00000000 00000000 00001111，和某散列值做“與”操作如下，結果就是截取了最低的四位值：</p><div class=pgc-img><img alt="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9bca5eda8f8e430b85d0b9e95f8ba898><p class=pgc-img-caption></p></div><p>但這時候問題就來了：這樣就算我的散列值分佈再鬆散，要是隻取最後幾位的話，碰撞也會很嚴重，這時候“擾動函數”的價值就體現出來了：</p><div class=pgc-img><img alt="大廠面試官：說一下JDK1.8 HashMap有哪些亮點？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a8ab38992a99423388da0f4097aec857><p class=pgc-img-caption></p></div><p><strong>右位移16位，正好是32位一半，自己的高半區和低半區做異或，就是為了混合原始hashCode的高位和低位，以此來加大低位的隨機性，而且混合後的低位摻雜了高位的部分特徵，這樣高位的信息也被變相保留下來，即降低了哈希衝突的風險又不會帶來太大的性能問題</strong>。這個設計很巧妙！</p><h1 class=pgc-h-arrow-right>6、hash衝突</h1><p style=text-align:start>通過異或運算能夠是的計算出來的hash比較均勻，不容易出現衝突。但是偏偏出現了衝突現象，這時候該如何去解決呢？</p><p style=text-align:start>在數據結構中，我們處理hash衝突常使用的方法有：<strong>開發定址法、再哈希法、鏈地址法、建立公共溢出區。而hashMap中處理hash衝突的方法就是鏈地址法。</strong></p><p style=text-align:start>這種方法的基本思想是將所有哈希地址為i的元素構成一個稱為同義詞鏈的單鏈表，並將單鏈表的頭指針存在哈希表的第i個單元中，因而查找、插入和刪除主要在同義詞鏈中進行。鏈地址法適用於經常進行插入和刪除的情況。</p><h1 class=pgc-h-arrow-right>7、table數組用transient修飾</h1><pre><code>/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */transient Node&lt;K,V&gt;[] table;</code></pre><p>從HashMap 的源碼，會發現桶數組 table 被申明為 transient。transient 表示易變的意思，在 Java 中，被該關鍵字修飾的變量不會被默認的序列化機制序列化。我們再回到源碼中，考慮一個問題：桶數組 table 是 HashMap 底層重要的數據結構，不序列化的話，別人還怎麼還原呢？</p><p style=text-align:start>這裡簡單說明一下吧，HashMap 並沒有使用默認的序列化機制，而是<strong>通過實現readObject/writeObject兩個方法自定義了序列化的內容</strong>。這樣做是有原因的，試問一句，HashMap 中存儲的內容是什麼？不用說，大家也知道是鍵值對。所以只要我們把鍵值對序列化了，我們就可以根據鍵值對數據重建 HashMap。有的朋友可能會想，序列化 table 不是可以一步到位，後面直接還原不就行了嗎？這樣一想，倒也是合理。但序列化 talbe 存在著兩個問題：</p><p style=text-align:start>1）table 多數情況下是無法被存滿的，序列化未使用的部分，浪費空間。<br>2）<strong>同一個鍵值對在不同 JVM 下，所處的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能會發生錯誤。</strong></p><p style=text-align:start>以上兩個問題中，第一個問題比較好理解，第二個問題解釋一下。HashMap 的get/put/remove等方法第一步就是根據 hash 找到鍵所在的桶位置，但如果鍵沒有覆寫 hashCode 方法，計算 hash 時最終調用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能會有不同的實現，產生的 hash 可能也是不一樣的。也就是說同一個鍵在不同平臺下可能會產生不同的 hash，此時再對在同一個 table 繼續操作，就會出現問題。</p><p style=text-align:start>綜上所述，大家應該能明白 HashMap 不序列化 table 的原因了，下面是HashMap自定義的序列化代碼：</p><pre><code>private void writeObject(java.io.ObjectOutputStream s)    throws IOException {    int buckets = capacity();    // Write out the threshold, loadfactor, and any hidden stuff    // 寫入一些屬性值，待反序列化時用到    s.defaultWriteObject();    s.writeInt(buckets);    s.writeInt(size);    internalWriteEntries(s);} // Called only from writeObject, to ensure compatible ordering.    void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException {   Node&lt;K,V&gt;[] tab;    if (size &gt; 0 &amp;&amp; (tab = table) != null) {        for (int i = 0; i &lt; tab.length; ++i) {            for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {            	 //寫入鍵值對                s.writeObject(e.key);                s.writeObject(e.value);            }        }    }}private void readObject(java.io.ObjectInputStream s)        throws IOException, ClassNotFoundException {    // Read in the threshold (ignored), loadfactor, and any hidden stuff    s.defaultReadObject();    reinitialize();    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new InvalidObjectException("Illegal load factor: " +                                         loadFactor);    s.readInt();                // Read and ignore number of buckets    int mappings = s.readInt(); // Read number of mappings (size)    if (mappings &lt; 0)        throw new InvalidObjectException("Illegal mappings count: " +                                         mappings);    else if (mappings &gt; 0) { // (if zero, use defaults)        // Size the table using given load factor only if within        // range of 0.25...4.0        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);        float fc = (float)mappings / lf + 1.0f;        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?                   DEFAULT_INITIAL_CAPACITY :                   (fc &gt;= MAXIMUM_CAPACITY) ?                   MAXIMUM_CAPACITY :                   tableSizeFor((int)fc));        float ft = (float)cap * lf;        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?                     (int)ft : Integer.MAX_VALUE);        @SuppressWarnings({"rawtypes","unchecked"})            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];        table = tab;        // Read the keys and values, and put the mappings in the HashMap        // 讀出鍵值對，放入hashMap        for (int i = 0; i &lt; mappings; i++) {            @SuppressWarnings("unchecked")                K key = (K) s.readObject();            @SuppressWarnings("unchecked")                V value = (V) s.readObject();            putVal(hash(key), key, value, false, false);        }    }}</code></pre><h1 class=pgc-h-arrow-right>8、HashMap非線程安全</h1><p style=text-align:start>HashMap源碼裡面方法是沒有synchronized或lock處理的，無法保證線程安全。於是出現了線程安全的ConcurrentHashMap，這個我們後續講解。</p><p style=text-align:start>歡迎小夥伴們留言交流~~</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>大廠</a></li><li><a>面試</a></li><li><a>JDK1.8</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f192b47.html alt=大廠面試必問的數據結構--棧和隊列基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c7607ef07fe84842957cc74a9be92140 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f192b47.html title=大廠面試必問的數據結構--棧和隊列基礎知識>大廠面試必問的數據結構--棧和隊列基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3127ea3b.html alt=大廠硬核乾貨！深入分析彈性動效的應用及原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d3fcf924c8e43bf92b4e6820af0176c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3127ea3b.html title=大廠硬核乾貨！深入分析彈性動效的應用及原理>大廠硬核乾貨！深入分析彈性動效的應用及原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html alt="不怕面試被問了！二叉樹算法大盤點 | 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html title="不怕面試被問了！二叉樹算法大盤點 | 原力計劃">不怕面試被問了！二叉樹算法大盤點 | 原力計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html title="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~">別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html title=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>