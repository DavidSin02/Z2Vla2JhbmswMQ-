<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python中的遺傳算法完整實現 | 极客快訊</title><meta property="og:title" content="Python中的遺傳算法完整實現 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/1531731137721602bd9c18c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/1c10283.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/1c10283.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/1c10283.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/1c10283.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/1c10283.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/1c10283.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/1c10283.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/1c10283.html><meta property="article:published_time" content="2020-10-29T20:46:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:33+08:00"><meta name=Keywords content><meta name=description content="Python中的遺傳算法完整實現"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/1c10283.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python中的遺傳算法完整實現</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><div><p>本教程將基於一個簡單的示例在Python中實現遺傳算法優化技術，在這個示例中，我們試圖最大化一個方程的輸出。本教程使用十進制表示的基因，單點交叉，和均勻變異。</p><div class=pgc-img><img alt=Python中的遺傳算法完整實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/1531731137721602bd9c18c><p class=pgc-img-caption></p></div><h1>遺傳算法概述</h1><p>遺傳算法（GA）的流程圖如圖1所示。遺傳算法中涉及的每個步驟都有一些變化。</p><div class=pgc-img><img alt=Python中的遺傳算法完整實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/1531731168330b5dc664bad><p class=pgc-img-caption>圖1.遺傳算法流程圖</p></div><p>例如，基因的表示有不同類型，例如二進制，十進制，整數等。每種類型都有不同的對待。存在不同類型的突變，例如位翻轉，交換，反轉，均勻，非均勻，高斯，收縮等。此外，交叉具有不同的類型，例如混合，單點，兩點，均勻等。本教程不會實現所有這些，只是實現了GA中涉及的每個步驟的一種類型。本教程使用基因的十進制表示，單點交叉和均勻變異。</p><h1>示例</h1><p>本教程首先介紹我們將要實現的等式。等式如下所示：</p><p>Y = w1x1 + w2x2 + w3x3 + w4x4 + w5x5 + w6x6</p><p>該方程有6個輸入（x1到x6）和6個權重（w1到w6），如圖所示，輸入值為（x1，x2，x3，x4，x5，x6）=（4，-2,7,5,11， 1）。我們正在尋找最大化這種方程的參數（權重）。最大化這種方程的想法似乎很簡單。正輸入乘以最大可能的正數，負數乘以最小可能的負數。但我們希望實現的想法是如何讓GA做到這一點，以便知道使用正輸入和負輸入的負權重更好。讓我們開始實施GA。</p><p>首先，讓我們創建一個包含6個輸入的列表和一個用於保存權重數量的變量，如下所示：</p><blockquote><p># Inputs of the equation.</p><p>equation_inputs = [4,-2,3.5,5,-11,-4.7]</p><p># Number of the weights we are looking to optimize.</p><p>num_weights = 6</p></blockquote><p>下一步是定義初始總體。根據權重的數量，每個染色體(溶液或個體)肯定有6個基因，每個權重對應一個基因。但是問題是每個群體有多少個解決方案?沒有固定的值，我們可以選擇適合我們問題的值。但是我們可以保留它的通用性，以便在代碼中修改它。接下來，我們創建一個變量來表示每個群體的解決方案數量，另一個變量來表示群體的大小，最後，一個變量來表示實際的初始群體數量:</p><blockquote><p>import numpy</p><p>sol_per_pop = 8</p><p># Defining the population size.</p><p>pop_size = (sol_per_pop,num_weights) # The population will have sol_per_pop chromosome where each chromosome has num_weights genes.</p><p>#Creating the initial population.</p><p>new_population = numpy.random.uniform(low=-4.0, high=4.0, size=pop_size)</p></blockquote><p>導入numpy庫後，我們可以使用numpy.random.uniform函數隨機創建初始種群。根據所選參數，它將具有形狀（8,6）。這是8條染色體，每條染色體有6個基因，每個權重一個。運行此代碼後，群體如下：</p><blockquote><p>[[-2.19134006 -2.88907857 2.02365737 -3.97346034 3.45160502 2.05773249]</p><p>[ 2.12480298 2.97122243 3.60375452 3.78571392 0.28776565 3.5170347 ]</p><p>[ 1.81098962 0.35130155 1.03049548 -0.33163294 3.52586421 2.53845644]</p><p>[-0.63698911 -2.8638447 2.93392615 -1.40103767 -1.20313655 0.30567304]</p><p>[-1.48998583 -1.53845766 1.11905299 -3.67541087 1.33225142 2.86073836]</p><p>[ 1.14159503 2.88160332 1.74877772 -3.45854293 0.96125878 2.99178241]</p><p>[ 1.96561297 0.51030292 0.52852716 -1.56909315 -2.35855588 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -0.72163167 0.7516408 0.00677938]]</p></blockquote><p>請注意，它是隨機生成的，因此在再次運行時肯定會發生變化。</p><p>在準備群體之後，接下來將遵循圖1中的流程圖。基於適應度函數，我們將選擇當前群體中的最佳個體作為交配的父母。接下來是應用GA變體（交叉和變異）來產生下一代的後代，通過附加父母和後代來創建新的群體，並且重複這些步驟進行多次迭代/生成。下一個Python代碼應用以下步驟：</p><blockquote><p>import GA</p><p>num_generations = 5</p><p>num_parents_mating = 4</p><p>for generation in range(num_generations):</p><p># Measuring the fitness of each chromosome in the population.</p><p>fitness = GA.cal_pop_fitness(equation_inputs, new_population)</p><p># Selecting the best parents in the population for mating.</p><p>parents = GA.select_mating_pool(new_population, fitness,</p><p>num_parents_mating)</p><p># Generating next generation using crossover.</p><p>offspring_crossover = GA.crossover(parents,</p><p>offspring_size=(pop_size[0]-parents.shape[0], num_weights))</p><p># Adding some variations to the offsrping using mutation.</p><p>offspring_mutation = GA.mutation(offspring_crossover)</p><p># Creating the new population based on the parents and offspring.</p><p>new_population[0:parents.shape[0], :] = parents</p><p>new_population[parents.shape[0]:, :] = offspring_mutation</p></blockquote><p>現在的代數是5。在本教程中，它被選為小以顯示所有代的結果。</p><p>第一步是使用GA求總體中的每個解的適應度值。cal_pop_fitness函數。該函數在GA模塊內的實現如下:</p><blockquote><p>def cal_pop_fitness(equation_inputs, pop):</p><p># Calculating the fitness value of each solution in the current population.</p><p># The fitness function calculates the sum of products between each input and its corresponding weight.</p><p>fitness = numpy.sum(pop*equation_inputs, axis=1)</p><p>return fitness</p></blockquote><p>除了總體之外，適應度函數還接受方程輸入值（x1到x6）。根據我們的函數，將適應度值計算為每個輸入與其對應基因（權重）之間的乘積（SOP）之和。根據每個群體的解決方案數量，將有一些SOP。正如我們之前在變量命名sol_per_pop中將解決方案的數量設置為8 ，將有8個SOP，如下所示：</p><blockquote><p>[-63.41070188 14.40299221 -42.22532674 18.24112489 -45.44363278 -37.00404311 15.99527402 17.0688537 ]</p></blockquote><p>注意，適應度值越高，解決方案就越好。</p><p>在計算所有解決方案的適應度值之後，下一步是根據下一個函數GA.select_mating_pool，在匹配池中選擇其中最好的作為父類。該函數接受群體、適合度值和所需的父母數量。它返回所選的父類。其在GA模塊內的實現如下:</p><blockquote><p>def select_mating_pool(pop, fitness, num_parents):</p><p># Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.</p><p>parents = numpy.empty((num_parents, pop.shape[1]))</p><p>for parent_num in range(num_parents):</p><p>max_fitness_idx = numpy.where(fitness == numpy.max(fitness))</p><p>max_fitness_idx = max_fitness_idx[0][0]</p><p>parents[parent_num, :] = pop[max_fitness_idx, :]</p><p>fitness[max_fitness_idx] = -99999999999</p><p>return parents</p></blockquote><p>根據變量num_parents_match中定義的父類的數量，該函數創建一個空數組來保存它們，就像在這一行中一樣:</p><blockquote><p>parents = numpy.empty（（num_parents，pop.shape [1]））</p></blockquote><p>循環遍歷當前群體，該函數獲得最高適應度值的索引，因為它是根據此行選擇的最佳解決方案：</p><blockquote><p>max_fitness_idx = numpy.where（fitness == numpy.max（fitness））</p></blockquote><p>此索引用於使用以下行檢索與此適合度值對應的解決方案：</p><blockquote><p>parent [parent_num，：] = pop [max_fitness_idx，：]</p></blockquote><p>為了避免再次選擇這種解決方案，它的適應度值被設置為一個非常小的值，這個值很可能不會被再次選中，即- 99999999999999999。最後返回父數組，根據我們的示例如下所示:</p><blockquote><p>[[-0.63698911 -2.8638447 2.93392615 -1.40103767 -1.20313655 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -0.72163167 0.7516408 0.00677938]</p><p>[ 1.96561297 0.51030292 0.52852716 -1.56909315 -2.35855588 2.29682254]</p><p>[ 2.12480298 2.97122243 3.60375452 3.78571392 0.28776565 3.5170347 ]]</p></blockquote><p>注意，這三個父類是當前群體中最好的個體，基於他們的適合度值分別為18.24112489,17.0688537,15.99527402和14.40299221。</p><p>下一步是使用這樣選擇的親本進行交配以產生後代。根據功能，交配從交叉操作開始GA.crossover。此函數接受父母和後代的大小。它使用後代大小來了解從這些父母那裡生產的後代的數量。這樣的功能在GA模塊內部實現如下：</p><blockquote><p>def crossover(parents, offspring_size):</p><p>offspring = numpy.empty(offspring_size)</p><p># The point at which crossover takes place between two parents. Usually, it is at the center.</p><p>crossover_point = numpy.uint8(offspring_size[1]/2)</p><p>for k in range(offspring_size[0]):</p><p># Index of the first parent to mate.</p><p>parent1_idx = k%parents.shape[0]</p><p># Index of the second parent to mate.</p><p>parent2_idx = (k+1)%parents.shape[0]</p><p># The new offspring will have its first half of its genes taken from the first parent.</p><p>offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]</p><p># The new offspring will have its second half of its genes taken from the second parent.</p><p>offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]</p><p>return offspring</p></blockquote><p>該函數首先根據後代大小創建一個空數組，如下所示：</p><blockquote><p>offspring = numpy.empty（offspring_size）</p></blockquote><p>因為我們使用單點交叉，所以我們需要指定交叉發生的點。選擇該點以根據此行將解決方案劃分為兩個相等的一半：</p><blockquote><p>crossover_point = numpy.uint8（offspring_size [1] / 2）</p></blockquote><p>然後我們需要選擇兩個父母進行交叉。根據這兩行選擇這些父母的指數：</p><blockquote><p>parent1_idx = k％parents.shape [0]</p><p>parent2_idx =（k + 1）％parents.shape [0]</p></blockquote><p>父母的選擇方式類似於戒指。第一個指標為0和1的物種首先被選擇產生兩個後代。如果仍有剩餘的後代要繁殖，那麼我們選擇雙親1和雙親2的後代。如果我們需要更多的後代，那麼我們選擇第二個有索引2和3的父母。通過索引3，我們到達了最後一個父元素。如果我們需要生成更多的後代，那麼我們選擇帶有索引3的父節點，然後返回索引0的父節點，以此類推。</p><p>將交叉操作應用於父項後的解決方案存儲在offspring 變量中，它們如下所示：</p><blockquote><p>[[-0.63698911 -2.8638447 2.93392615 -0.72163167 0.7516408 0.00677938]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.35855588 2.29682254]</p><p>[ 1.96561297 0.51030292 0.52852716 3.78571392 0.28776565 3.5170347 ]</p><p>[ 2.12480298 2.97122243 3.60375452 -1.40103767 -1.20313655 0.30567304]]</p></blockquote><p>接下來是offspring 使用GA.mutationGA模塊內部的函數將第二個GA變體mut變量應用於存儲在變量中的交叉結果。這種函數接受交叉後代並在應用均勻突變後返回它們。該功能實現如下：</p><blockquote><p>def mutation(offspring_crossover):</p><p># Mutation changes a single gene in each offspring randomly.</p><p>for idx in range(offspring_crossover.shape[0]):</p><p># The random value to be added to the gene.</p><p>random_value = numpy.random.uniform(-1.0, 1.0, 1)</p><p>offspring_crossover[idx, 4] = offspring_crossover[idx, 4] + random_value</p><p>return offspring_crossover</p></blockquote><p>它循環遍歷每個後代，並根據以下行添加一個均勻生成的隨機數，範圍從-1到1：</p><blockquote><p>random_value = numpy.random.uniform（-1.0,1.0,1）</p></blockquote><p>然後根據此行將這樣的隨機數添加到後代的索引4的基因中：</p><blockquote><p>offspring_crossover [idx，4] = offspring_crossover [idx，4] + random_value</p></blockquote><p>請注意，索引可以更改為任何其他索引。應用突變後的後代如下：</p><blockquote><p>[[-0.63698911 -2.8638447 2.93392615 -0.72163167 1.66083721 0.00677938]</p><p>[3.00912373 -2.745417 3.27131287 -1.56909315 -1.94513681 2.29682254]</p><p>[1.96561297 0.51030292 0.52852716 3.78571392 0.45337472 3.5170347]</p><p>[2.12480298 2.97122243 3.60375452 -1.40103767 -1.5781162 0.30567304]]</p></blockquote><p>這些結果被添加到變量中offspring_crossover並由函數返回。</p><p>在這一點上，我們成功地從4個選定的父母中產生了4個後代，我們準備創造下一代的新種群。</p><p>請注意，GA是一種基於隨機的優化技術。它試圖通過對它們應用一些隨機變化來增強當前的解決方案。因為這些變化是隨機的，我們不確定它們會產生更好的解決方案。出於這個原因，優選在新的群體中保留先前的最佳解決方案（父母）。在最糟糕的情況下，當所有新的後代都比這樣的父母更糟糕時，我們將繼續使用這樣的父母。因此，我們保證新一代將至少保留以前的良好結果，並且不會變得更糟。新人口將擁有前父母的前4個解決方案。最後4個解決方案來自應用交叉和變異後創建的後代：</p><blockquote><p>new_population [0：parents.shape [0]</p><p>，：] = parent new_population [parents.shape [0]：，：] = offspring_mutation</p></blockquote><p>通過計算第一代所有解決方案（父母和後代）的適應度，他們的適應度如下：</p><blockquote><p>[18.24112489 17.0688537 15.99527402 14.40299221 -8.46075629 31.73289712 6.10307563 24.08733441]</p></blockquote><p>之前的最高適應度是18.24112489，但現在是31.7328971158。這意味著隨機變化趨向於更好的解決方案。這很棒。但這種結果可以通過更多代來增強。以下是另外4代的每個步驟的結果：</p><blockquote><p>Generation : 1</p><p>Fitness values:</p><p>[ 18.24112489 17.0688537 15.99527402 14.40299221 -8.46075629 31.73289712 6.10307563 24.08733441]</p><p>Selected parents:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.94513681 2.29682254]</p><p>[ 2.12480298 2.97122243 3.60375452 -1.40103767 -1.5781162 0.30567304]</p><p>[-0.63698911 -2.8638447 2.93392615 -1.40103767 -1.20313655 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -0.72163167 0.7516408 0.00677938]]</p><p>Crossover result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.5781162 0.30567304]</p><p>[ 2.12480298 2.97122243 3.60375452 -1.40103767 -1.20313655 0.30567304]</p><p>[-0.63698911 -2.8638447 2.93392615 -0.72163167 0.7516408 0.00677938]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.94513681 2.29682254]]</p><p>Mutation result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.2392086 0.30567304]</p><p>[ 2.12480298 2.97122243 3.60375452 -1.40103767 -0.38610586 0.30567304]</p><p>[-0.63698911 -2.8638447 2.93392615 -0.72163167 1.33639943 0.00677938]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.13941727 2.29682254]]</p><p>Best result after generation 1 : 34.1663669207</p><p>Generation : 2</p><p>Fitness values:</p><p>[ 31.73289712 24.08733441 18.24112489 17.0688537 34.16636692 10.97522073 -4.89194068 22.86998223]</p><p>Selected Parents:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.2392086 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.94513681 2.29682254]</p><p>[ 2.12480298 2.97122243 3.60375452 -1.40103767 -1.5781162 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.13941727 2.29682254]]</p><p>Crossover result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.94513681 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.5781162 0.30567304]</p><p>[ 2.12480298 2.97122243 3.60375452 -1.56909315 -1.13941727 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.2392086 0.30567304]]</p><p>Mutation result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.20515009 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -0.73543721 0.30567304]</p><p>[ 2.12480298 2.97122243 3.60375452 -1.56909315 -0.50581509 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.20089639 0.30567304]]</p><p>Best result after generation 2: 34.5930432629</p><p>Generation : 3</p><p>Fitness values:</p><p>[ 34.16636692 31.73289712 24.08733441 22.86998223 34.59304326 28.6248816 2.09334217 33.7449326 ]</p><p>Selected parents:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.20515009 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.2392086 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.20089639 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.94513681 2.29682254]]</p><p>Crossover result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.2392086 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.20089639 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -1.94513681 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.20515009 2.29682254]]</p><p>Mutation result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.40103767 -2.20744102 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.16589294 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.37553107 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.44124005 2.29682254]]</p><p>Best result after generation 3: 44.8169235189</p><p>Generation : 4</p><p>Fitness values</p><p>[ 34.59304326 34.16636692 33.7449326 31.73289712 44.81692352</p><p>33.35989464 36.46723397 37.19003273]</p><p>Selected parents:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.40103767 -2.20744102 0.30567304]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.44124005 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.37553107 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.20515009 2.29682254]]</p><p>Crossover result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.37553107 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.20515009 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -2.20744102 0.30567304]]</p><p>Mutation result:</p><p>[[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.13382082 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.98105233 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.56909315 -2.27638584 2.29682254]</p><p>[ 3.00912373 -2.745417 3.27131287 -1.40103767 -1.70558545 0.30567304]]</p><p>Best result after generation 4: 44.8169235189</p></blockquote><p>在上述5代之後，最佳結果現在具有等於44.8169235189的適應值，而第一代之後的最佳結果是18.24112489。</p><p>最佳解決方案具有以下權重：</p><p>[3.00912373 -2.745417 3.27131287 -1.40103767 -2.20744102 0.30567304]</p><h1>完整的Python實現</h1><p>實現GA的完整代碼如下：</p><blockquote><p>import numpy</p><p>import GA</p><p>"""</p><p>The y=target is to maximize this equation ASAP:</p><p>y = w1x1+w2x2+w3x3+w4x4+w5x5+6wx6</p><p>where (x1,x2,x3,x4,x5,x6)=(4,-2,3.5,5,-11,-4.7)</p><p>What are the best values for the 6 weights w1 to w6?</p><p>We are going to use the genetic algorithm for the best possible values after a number of generations.</p><p>"""</p><p># Inputs of the equation.</p><p>equation_inputs = [4,-2,3.5,5,-11,-4.7]</p><p># Number of the weights we are looking to optimize.</p><p>num_weights = 6</p><p>"""</p><p>Genetic algorithm parameters:</p><p>Mating pool size</p><p>Population size</p><p>"""</p><p>sol_per_pop = 8</p><p>num_parents_mating = 4</p><p># Defining the population size.</p><p>pop_size = (sol_per_pop,num_weights) # The population will have sol_per_pop chromosome where each chromosome has num_weights genes.</p><p>#Creating the initial population.</p><p>new_population = numpy.random.uniform(low=-4.0, high=4.0, size=pop_size)</p><p>print(new_population)</p><p>num_generations = 5</p><p>for generation in range(num_generations):</p><p>print("Generation : ", generation)</p><p># Measing the fitness of each chromosome in the population.</p><p>fitness = GA.cal_pop_fitness(equation_inputs, new_population)</p><p># Selecting the best parents in the population for mating.</p><p>parents = GA.select_mating_pool(new_population, fitness,</p><p>num_parents_mating)</p><p># Generating next generation using crossover.</p><p>offspring_crossover = GA.crossover(parents,</p><p>offspring_size=(pop_size[0]-parents.shape[0], num_weights))</p><p># Adding some variations to the offsrping using mutation.</p><p>offspring_mutation = GA.mutation(offspring_crossover)</p><p># Creating the new population based on the parents and offspring.</p><p>new_population[0:parents.shape[0], :] = parents</p><p>new_population[parents.shape[0]:, :] = offspring_mutation</p><p># The best result in the current iteration.</p><p>print("Best result : ", numpy.max(numpy.sum(new_population*equation_inputs, axis=1)))</p><p># Getting the best solution after iterating finishing all generations.</p><p>#At first, the fitness is calculated for each solution in the final generation.</p><p>fitness = GA.cal_pop_fitness(equation_inputs, new_population)</p><p># Then return the index of that solution corresponding to the best fitness.</p><p>best_match_idx = numpy.where(fitness == numpy.max(fitness))</p><p>print("Best solution : ", new_population[best_match_idx, :])</p><p>print("Best solution fitness : ", fitness[best_match_idx])</p></blockquote><p><strong>GA模塊如下：</strong></p><blockquote><p>import numpy</p><p>def cal_pop_fitness(equation_inputs, pop):</p><p># Calculating the fitness value of each solution in the current population.</p><p># The fitness function caulcuates the sum of products between each input and its corresponding weight.</p><p>fitness = numpy.sum(pop*equation_inputs, axis=1)</p><p>return fitness</p><p>def select_mating_pool(pop, fitness, num_parents):</p><p># Selecting the best individuals in the current generation as parents for producing the offspring of the next generation.</p><p>parents = numpy.empty((num_parents, pop.shape[1]))</p><p>for parent_num in range(num_parents):</p><p>max_fitness_idx = numpy.where(fitness == numpy.max(fitness))</p><p>max_fitness_idx = max_fitness_idx[0][0]</p><p>parents[parent_num, :] = pop[max_fitness_idx, :]</p><p>fitness[max_fitness_idx] = -99999999999</p><p>return parents</p><p>def crossover(parents, offspring_size):</p><p>offspring = numpy.empty(offspring_size)</p><p># The point at which crossover takes place between two parents. Usually it is at the center.</p><p>crossover_point = numpy.uint8(offspring_size[1]/2)</p><p>for k in range(offspring_size[0]):</p><p># Index of the first parent to mate.</p><p>parent1_idx = k%parents.shape[0]</p><p># Index of the second parent to mate.</p><p>parent2_idx = (k+1)%parents.shape[0]</p><p># The new offspring will have its first half of its genes taken from the first parent.</p><p>offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point]</p><p># The new offspring will have its second half of its genes taken from the second parent.</p><p>offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:]</p><p>return offspring</p><p>def mutation(offspring_crossover):</p><p># Mutation changes a single gene in each offspring randomly.</p><p>for idx in range(offspring_crossover.shape[0]):</p><p># The random value to be added to the gene.</p><p>random_value = numpy.random.uniform(-1.0, 1.0, 1)</p><p>offspring_crossover[idx, 4] = offspring_crossover[idx, 4] + random_value</p><p>return offspring_crossover</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Python</a></li><li><a>遺傳</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html alt=一文讀懂遺傳算法工作原理！附Python實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/fde5cfc48c5a45d4891d621c7b4cc5e4 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html title=一文讀懂遺傳算法工作原理！附Python實現>一文讀懂遺傳算法工作原理！附Python實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4f88802b.html alt=Python實現文章自動生成 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4f88802b.html title=Python實現文章自動生成>Python實現文章自動生成</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8f304b3.html alt=利用Python實現財務報表下載小助手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/eccf200c-28b1-4270-a7be-3ff719f3d4f6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8f304b3.html title=利用Python實現財務報表下載小助手>利用Python實現財務報表下載小助手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/db784eae.html alt=使用Python實現文件的精確查找、模糊查找、範圍查找 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea247283ffd149a3bc2a1a4498569298 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/db784eae.html title=使用Python實現文件的精確查找、模糊查找、範圍查找>使用Python實現文件的精確查找、模糊查找、範圍查找</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/834ba338.html alt="Python 實現生命遊戲" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ef717db639fa4cd196ebe68fdbac71e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/834ba338.html title="Python 實現生命遊戲">Python 實現生命遊戲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdad3e1a.html alt=Python實現詞頻分析器，查看文章各種詞語的使用次數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/eb3e9379e45b437190986372fd452276 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdad3e1a.html title=Python實現詞頻分析器，查看文章各種詞語的使用次數>Python實現詞頻分析器，查看文章各種詞語的使用次數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c782b4f.html alt=Python實現連續變量GHMM高斯隱馬爾可夫模型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1b32a7d6eec44094a2f173b6555856ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c782b4f.html title=Python實現連續變量GHMM高斯隱馬爾可夫模型>Python實現連續變量GHMM高斯隱馬爾可夫模型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc520d9.html alt=用Python實現批量高效文件處理，解放你的雙手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6a8aade78d34491189c3149331390715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc520d9.html title=用Python實現批量高效文件處理，解放你的雙手>用Python實現批量高效文件處理，解放你的雙手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4af47b.html alt="性能利器，Python Flashtext 實現查找或替換文本中關鍵詞" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5377cc554f4d45d3a268141141ad00c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4af47b.html title="性能利器，Python Flashtext 實現查找或替換文本中關鍵詞">性能利器，Python Flashtext 實現查找或替換文本中關鍵詞</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html alt=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/dfic-imagehandler/f1d21356-1ef5-4ec5-a4a5-c5699b12bee1 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html title=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題>Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html alt=基於Python的遺傳算法特徵約簡（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/4cf33c81f091401a93c3d1b5db2213de style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html title=基於Python的遺傳算法特徵約簡（附代碼）>基於Python的遺傳算法特徵約簡（附代碼）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html alt="遺傳算法(Python) #2 基本運算方法詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/c3dcdafb8df8476dbc472615f3131b59 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html title="遺傳算法(Python) #2 基本運算方法詳解">遺傳算法(Python) #2 基本運算方法詳解</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html alt="遺傳算法(Python) #3 從零開始解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/5d69e28f41a44f81b8dd0bbe9f2f2b6f style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html title="遺傳算法(Python) #3 從零開始解決OneMax問題">遺傳算法(Python) #3 從零開始解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html alt="遺傳算法(Python) #5 用DEAP框架解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/3279ffb8082c491a967c683ae24bdfcb style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html title="遺傳算法(Python) #5 用DEAP框架解決OneMax問題">遺傳算法(Python) #5 用DEAP框架解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html alt=遺傳算法綜合指南（以及如何Python編碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/15354276244373403483b2e style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html title=遺傳算法綜合指南（以及如何Python編碼）>遺傳算法綜合指南（以及如何Python編碼）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>