<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>遺傳算法(Python) #3 從零開始解決OneMax問題 | 极客快訊</title><meta property="og:title" content="遺傳算法(Python) #3 從零開始解決OneMax問題 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/5d69e28f41a44f81b8dd0bbe9f2f2b6f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/2c5f63f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/2c5f63f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/2c5f63f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/2c5f63f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/2c5f63f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/2c5f63f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/2c5f63f.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/2c5f63f.html><meta property="article:published_time" content="2020-10-29T20:46:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:33+08:00"><meta name=Keywords content><meta name=description content="遺傳算法(Python) #3 從零開始解決OneMax問題"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/2c5f63f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>遺傳算法(Python) #3 從零開始解決OneMax問題</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6822898083571958286/?group_id=6822898083571958286" rel="noopener noreferrer" target=_blank>上一期</a></p><h2 class=pgc-h-arrow-right>1. OneMax問題(OneMax Problem)</h2><p>OneMax問題是遺傳算法的入門問題，其內容是：如何使一段長度固定的二進制字符串所有位置上數字之和最大。</p><p>讓我們用一個長度為5的二進制字符串為例：</p><ul><li>10010 -> 和為2</li><li>00111 -> 和為3</li><li>11111 -> 和為5(最大值)</li></ul><p>對一般人，顯而易見，當所有位數都為1時，該字符串的和最大，但在我們用遺傳算法解決該問題時，遺傳算法本身並沒有這樣的知識。接下來我們將不依靠任何遺傳算法的包，從頭開始用遺傳算法解決OneMax問題。</p><h2 class=pgc-h-arrow-right>2.問題的解決思路</h2><p>首先，我們得把這個問題轉換成一個遺傳算法問題，即：我們得定義個體、種群，選擇、雜交、突變方法、適應度函數等。假設有一個長度為100的字符串，我們可以做出以下定義：</p><ul><li>個體：個體即為問題的解，這個問題中個體可以直觀的定義為一個長度為100列表（List），列表上每個元素為0或1.</li><li>種群：種群即所有個體的合集，我們可以把種群定義為所有個體組成的列表。</li><li>選擇：使用錦標賽法(Tournament Selection)</li><li>雜交：使用單點雜交法(Singe-Point Crossover)</li><li>突變：使用位翻轉突變法(Flip Bit Mutation)</li><li>適應度函數： 我們的目標是使字符串上所有數字之和最大，適應度函數可以直觀的定義為列表中所有數字之和。</li></ul><p>若對上述定義不太瞭解的，可以回看遺傳算法系列的第二期。</p><h2 class=pgc-h-arrow-right>3.用Python實現遺傳算法</h2><p>以下將分步驟解釋每一部分的代碼，完整代碼在本文的最後可見。</p><h3 class=pgc-h-arrow-right>3.0.準備工作</h3><pre><code>import randomimport matplotlib.pyplot as pltrandom.seed(39)</code></pre><p>導入所有需要的包：</p><ul><li>random： 用於生成隨機數</li><li>matplotlib： 用於畫圖</li><li>random.seed: 確定種子（即隨機狀態），這樣每次運算我們都能得到同樣的結果</li></ul><h3 class=pgc-h-arrow-right>3.1.定義個體和種群</h3><pre><code># 1. define individual and populationdef CreateIndividual():    return([random.randint(0,1) for _ in range(100)])def CreatePopulation(size):    return([CreateIndividual() for _ in range(size)])</code></pre><ul><li>CreateIndividual：個體即為一個長度為100的列表，每個元素（基因）為0或1。</li><li>CreatePopulation： 種群即多個個體組成的列表。</li></ul><h3 class=pgc-h-arrow-right>3.2.定義選擇、雜交、突變方法和適應度函數</h3><h4 class=pgc-h-arrow-right>3.2.1.選擇</h4><pre><code># 2.1. define select functiondef tournament(population,size):    participants = random.sample(population,size)    # evaluate function is defined in 3.4    winner = max(participants,key=lambda ind:evaluate(ind))    return(winner.copy())def select(population,size):    return([tournament(population,size) for _ in range(len(population))])</code></pre><ul><li>tournament：從種群中隨機抽取size個個體，從中選取適應度最高的個體。注意使用.copy以防同一個列表被多次引用。</li><li>select：為了保持種群的大小不變，錦標賽的次數應與種群中個體的數量相同</li></ul><h4 class=pgc-h-arrow-right>3.2.2.雜交</h4><pre><code># 2.2. define mate functiondef SinglePointCrossover(ind1,ind2):    loc = random.randint(0,len(ind1)-1)    genes1 = ind1[loc:]    genes2 = ind2[loc:]    ind1[loc:] = genes2    ind2[loc:] = genes1    return([ind1.copy(),ind2.copy()])def mate(population,probability):    new_population = []    for i in range(0,len(population),2):        ind1 = population[i].copy()        ind2 = population[i+1].copy()        if random.random() &lt; probability:            new_population.extend(SinglePointCrossover(ind1,ind2))        else:            new_population.extend([ind1,ind2])    return(new_population)</code></pre><ul><li>SinglePointCrossover：單點雜交法的實現，兩個個體交換隨機位置及其後面的基因</li><li>mate：對種群進行雜交，按一定概率每兩個相鄰的個體進行雜交probability參數：每次生成一個0至1之間的隨機數，若隨機數小於該概率，則進行雜交，否則對應的兩個個體被克隆。</li></ul><h4 class=pgc-h-arrow-right>3.2.3.突變</h4><pre><code># 2.3. define mutate functiondef flipOneGene(ind):    loc = random.randint(0,len(ind)-1)    ind[loc] = 1 - ind[loc] # 0-&gt;1 or 1-&gt;0    return(ind.copy())def mutate(population,probability):    new_population = []    for ind in population:        if random.random() &lt; probability:            new_population.append(flipOneGene(ind))        else:            new_population.append(ind.copy())    return(new_population)</code></pre><ul><li>flipOneGene:位翻轉突變，個體上的一個隨機基因進行突變。</li><li>mutate: 每個個體都以一定概率突變，若不突變，則該個體被克隆。</li></ul><h4 class=pgc-h-arrow-right>3.2.4.適應度函數</h4><pre><code># 2.4. define evaluate functiondef evaluate(individual):    return(sum(individual))</code></pre><p>OneMax的適應度函數就是列表中所有數字之和。</p><h4 class=pgc-h-arrow-right>3.2.5.統計種群數據</h4><pre><code># 2.5. define statistical metrics to monitor algorithm performancedef population_score_max(population):    return(max([evaluate(ind) for ind in population]))def population_score_mean(population):    return(sum([evaluate(ind) for ind in population])/len(population))</code></pre><p>為了追蹤算法的進度和發現算法中可能出現的錯誤，我們可以統計每次迭代中種群適應度的最大值與均值。</p><h3 class=pgc-h-arrow-right>3.3.運行遺傳算法</h3><pre><code># 3. Run genetic algorithmdef main(    POPULATION_SIZE = 100,    TOURNAMENT_SIZE = 3,    CROSSOVER_PROB = 0.9,    MUTATE_PROB = 0.1,    MAX_GENERATIONS = 100):    generation = 0    population = CreatePopulation(POPULATION_SIZE)    max_scores = [population_score_max(population)]    mean_scores = [population_score_mean(population)]    best_individual = []    while generation &lt; MAX_GENERATIONS:        population = select(population,TOURNAMENT_SIZE)        population = mate(population,CROSSOVER_PROB)        population = mutate(population,MUTATE_PROB)        # collect statistics        max_scores.append(population_score_max(population))        mean_scores.append(population_score_mean(population))        best_individual = max(            best_individual,            max(population,key=lambda ind: evaluate(ind))        ).copy()        generation += 1        print("Best Solution:")    print(best_individual)    plt.plot(max_scores, color='red',label="Max Score")    plt.plot(mean_scores, color='green',label="Mean Score")    plt.legend()    plt.xlabel("Generations")    plt.ylabel("Fitness Score")    plt.grid()    plt.show()   if __name__ == "__main__":    main()</code></pre><p>在運行算法前，我們首先得定義一些參數：</p><ul><li>種群大小(Population Size):一般而言種群越大，越容易在較小的代數內獲得最優解，但代價是每一代的運算量會變大。</li><li>錦標賽大小（Tournament Size）: 錦標賽的大小一般不要取的太大，否則種群容易因過早地失去多樣性而過早收斂。舉一個極端例子，當種群大小為100且錦標賽大小也為100時，第一次選擇後所有的個體都會變成同一個個體，算法便很難再有改善的空間。</li><li>雜交概率（Crossover Probability）：雜交的概率應取一個較大的值，比如0.7,0.8,0.9等，具體數值應視具體情況而定。</li><li>突變概率（Mutate Probability）：突變概率應取一個較小的值，如0.05，0.1，0.2等，若取值太大，則種群的隨機性太強，不利於保存適應度高的個體，從而使遺傳算法變成完全隨機的搜索。</li><li>最大代數(Max Generation):遺傳算法不可能無止盡的運行下去，一般而言，我們都會設置終止條件，這個問題中，我們以最大代數為終止條件，當迭代進行到一定次數時算法終止。</li></ul><p>在迭代過程中，每一代裡我們都進行選擇(select),雜交(mate)，突變(mate)運算，並收集種群的最大和平均適應度數據，用以追蹤算法的進度，或發現算法中存在的問題。視問題而定，我們還可以記錄下每代中適應度最高的個體(best individual)，以防止其因雜交和突變而消失。</p><p>最後，我們觀察最優解與種群的數據。</p><h3 class=pgc-h-arrow-right>4.算法結果</h3><p>我們成功獲得了OneMax的最優解(所有位置上都是1)：[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</p><p>種群的進化過程如下圖所示，我們可以觀察到種群的進化速度由快到慢，且在61代左右停止進化，且在第58代時已經產生了最優解。</p><p><br></p><div class=pgc-img><img alt="遺傳算法(Python) #3 從零開始解決OneMax問題" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/5d69e28f41a44f81b8dd0bbe9f2f2b6f><p class=pgc-img-caption></p></div><p><br></p><h3 class=pgc-h-arrow-right>5. 完整代碼</h3><pre><code>import randomimport matplotlib.pyplot as pltrandom.seed(39)# 1. define individual and populationdef CreateIndividual():    return([random.randint(0,1) for _ in range(100)])def CreatePopulation(size):    return([CreateIndividual() for _ in range(size)])# 2. define select, mate, mutate, evaluate function ----# 2.1. define select functiondef tournament(population,size):    participants = random.sample(population,size)    # evaluate function is defined in 3.4    winner = max(participants,key=lambda ind:evaluate(ind))    return(winner.copy())def select(population,size):    return([tournament(population,size) for _ in range(len(population))])# 2.2. define mate functiondef SinglePointCrossover(ind1,ind2):    loc = random.randint(0,len(ind1)-1)    genes1 = ind1[loc:]    genes2 = ind2[loc:]    ind1[loc:] = genes2    ind2[loc:] = genes1    return([ind1.copy(),ind2.copy()])def mate(population,probability):    new_population = []    for i in range(0,len(population),2):        ind1 = population[i].copy()        ind2 = population[i+1].copy()        if random.random() &lt; probability:            new_population.extend(SinglePointCrossover(ind1,ind2))        else:            new_population.extend([ind1,ind2])    return(new_population)# 2.3. define mutate functiondef flipOneGene(ind):    loc = random.randint(0,len(ind)-1)    ind[loc] = 1 - ind[loc] # 0-&gt;1 or 1-&gt;0    return(ind.copy())def mutate(population,probability):    new_population = []    for ind in population:        if random.random() &lt; probability:            new_population.append(flipOneGene(ind))        else:            new_population.append(ind.copy())    return(new_population)# 2.4. define evaluate functiondef evaluate(individual):    return(sum(individual))# 2.5. define statistical metrics to monitor algorithm performancedef population_score_max(population):    return(max([evaluate(ind) for ind in population]))def population_score_mean(population):    return(sum([evaluate(ind) for ind in population])/len(population))# 3. Run genetic algorithmdef main(    POPULATION_SIZE = 100,    TOURNAMENT_SIZE = 3,    CROSSOVER_PROB = 0.9,    MUTATE_PROB = 0.1,    MAX_GENERATIONS = 100):    generation = 0    population = CreatePopulation(POPULATION_SIZE)    max_scores = [population_score_max(population)]    mean_scores = [population_score_mean(population)]    best_individual = []    while generation &lt; MAX_GENERATIONS:        population = select(population,TOURNAMENT_SIZE)        population = mate(population,CROSSOVER_PROB)        population = mutate(population,MUTATE_PROB)        # collect statistics        max_scores.append(population_score_max(population))        mean_scores.append(population_score_mean(population))        best_individual = max(            best_individual,            max(population,key=lambda ind: evaluate(ind))        ).copy()        generation += 1        print("Best Solution:")    print(best_individual)    plt.plot(max_scores, color='red',label="Max Score")    plt.plot(mean_scores, color='green',label="Mean Score")    plt.legend()    plt.xlabel("Generations")    plt.ylabel("Fitness Score")    plt.grid()    plt.show()   if __name__ == "__main__":    main()</code></pre><h2 class=pgc-h-arrow-right>4.小結</h2><p>為了深入的解釋遺傳算法，本文中沒有使用任何的遺傳算法包來解決OneMax問題。而下一期，我們會介紹DEAP(Distributed Evolutionary Algorithm in Python)包,並在之後的文章裡用DEAP框架來解決遺傳算法問題。</p><p>本人近期剛開始寫文章，歡迎交流學習！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>遺傳</a></li><li><a>Python</a></li><li><a>零開始</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html alt=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/dfic-imagehandler/f1d21356-1ef5-4ec5-a4a5-c5699b12bee1 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html title=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題>Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html alt=Python中的遺傳算法完整實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1531731137721602bd9c18c style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html title=Python中的遺傳算法完整實現>Python中的遺傳算法完整實現</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html alt=一文讀懂遺傳算法工作原理！附Python實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/fde5cfc48c5a45d4891d621c7b4cc5e4 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html title=一文讀懂遺傳算法工作原理！附Python實現>一文讀懂遺傳算法工作原理！附Python實現</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html alt=基於Python的遺傳算法特徵約簡（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/4cf33c81f091401a93c3d1b5db2213de style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html title=基於Python的遺傳算法特徵約簡（附代碼）>基於Python的遺傳算法特徵約簡（附代碼）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html alt="遺傳算法(Python) #2 基本運算方法詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/c3dcdafb8df8476dbc472615f3131b59 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html title="遺傳算法(Python) #2 基本運算方法詳解">遺傳算法(Python) #2 基本運算方法詳解</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html alt="遺傳算法(Python) #5 用DEAP框架解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/3279ffb8082c491a967c683ae24bdfcb style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html title="遺傳算法(Python) #5 用DEAP框架解決OneMax問題">遺傳算法(Python) #5 用DEAP框架解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html alt=遺傳算法綜合指南（以及如何Python編碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/15354276244373403483b2e style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html title=遺傳算法綜合指南（以及如何Python編碼）>遺傳算法綜合指南（以及如何Python編碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f74c4fe8.html alt=從零開始服務器搭建wordpress網站詳細建站教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/991db5d6ab1c4209bc6bb9fb185a69b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f74c4fe8.html title=從零開始服務器搭建wordpress網站詳細建站教程>從零開始服務器搭建wordpress網站詳細建站教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html alt="web前端（從零開始），每天更新學習筆記 HTML5元素分類" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/46d70004fcd55e1ddad3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html title="web前端（從零開始），每天更新學習筆記 HTML5元素分類">web前端（從零開始），每天更新學習筆記 HTML5元素分類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html alt=Python爬蟲教程，利用Python採集QQ群成員信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d6cce76ad48405c9dbb960d4617bcef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html title=Python爬蟲教程，利用Python採集QQ群成員信息>Python爬蟲教程，利用Python採集QQ群成員信息</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>