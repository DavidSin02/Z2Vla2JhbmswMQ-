<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>理解MySQL鎖和事務，看這篇如何？ | 极客快訊</title><meta property="og:title" content="理解MySQL鎖和事務，看這篇如何？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p9.pstatp.com/large/pgc-image/7d492527c2f844faa901dffcd4bd02c4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3744391.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3744391.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/3744391.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3744391.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3744391.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/3744391.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/3744391.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3744391.html><meta property="article:published_time" content="2020-10-29T20:46:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:28+08:00"><meta name=Keywords content><meta name=description content="理解MySQL鎖和事務，看這篇如何？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/3744391.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>理解MySQL鎖和事務，看這篇如何？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><div><p>本文希望幫助讀者更加深刻地理解 MySQL 中的鎖和事務，從而在業務系統開發過程中更好地優化與數據庫的交互。</p><div class=pgc-img><img alt=理解MySQL鎖和事務，看這篇如何？ onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/7d492527c2f844faa901dffcd4bd02c4><p class=pgc-img-caption></p></div><p class=ql-align-center><em>圖片來自 Pexels</em></p><p>鎖的分類及特性</p><p>數據庫鎖定機制簡單來說，就是數據庫為了保證數據的一致性，而使各種共享資源在被併發訪問時變得有序所設計的一種規則。</p><p class=ql-align-justify>對於任何一種數據庫來說都需要有相應的鎖定機制，所以 MySQL 自然也不能例外。</p><p class=ql-align-justify>MySQL 數據庫由於其自身架構的特點，存在多種數據存儲引擎，每種存儲引擎所針對的應用場景特點都不太一樣。</p><p class=ql-align-justify>為了滿足各自特定應用場景的需求，每種存儲引擎的鎖定機制都是為各自所面對的特定場景而優化設計，所以各存儲引擎的鎖定機制也有較大區別。</p><p class=ql-align-justify>MySQL 各存儲引擎使用了三種類型（級別）的鎖定機制：</p><ul><li class=ql-align-justify><strong>表級鎖定</strong></li><li class=ql-align-justify><strong>行級鎖定</strong></li><li class=ql-align-justify><strong>頁級鎖定</strong></li></ul><p class=ql-align-justify><br></p><p><strong>表級鎖定（table-level）</strong></p><p class=ql-align-justify>表級別的鎖定是 MySQL 各存儲引擎中最大顆粒度的鎖定機制。該鎖定機制最大的特點是實現邏輯非常簡單，帶來的系統負面影響最小。</p><p class=ql-align-justify>所以獲取鎖和釋放鎖的速度很快。由於表級鎖定一次會將整個表鎖定，所以可以很好的避免困擾我們的死鎖問題。</p><p class=ql-align-justify>當然，鎖定顆粒度大所帶來最大的負面影響就是出現鎖定資源爭用的概率也會最高，致使並大度大打折扣。</p><p class=ql-align-justify>使用表級鎖定的主要是 MyISAM，MEMORY，CSV 等一些非事務性存儲引擎。</p><p><strong>行級鎖定（row-level）</strong></p><p class=ql-align-justify>行級鎖定最大的特點就是鎖定對象的顆粒度很小，也是目前各大數據庫管理軟件所實現的鎖定顆粒度最小的。</p><p class=ql-align-justify>由於鎖定顆粒度很小，所以發生鎖定資源爭用的概率也最小，能夠給予應用程序儘可能大的併發處理能力而提高一些需要高併發應用系統的整體性能。</p><p class=ql-align-justify>雖然能夠在併發處理能力上面有較大的優勢，但是行級鎖定也因此帶來了不少弊端。</p><p class=ql-align-justify>由於鎖定資源的顆粒度很小，所以每次獲取鎖和釋放鎖需要做的事情也更多，帶來的消耗自然也就更大了。</p><p class=ql-align-justify>此外，行級鎖定也最容易發生死鎖。使用行級鎖定的主要是 InnoDB 存儲引擎。</p><p><strong>頁級鎖定（page-level）</strong></p><p class=ql-align-justify>頁級鎖定是 MySQL 中比較獨特的一種鎖定級別，在其他數據庫管理軟件中也並不是太常見。</p><p class=ql-align-justify>頁級鎖定的特點是鎖定顆粒度介於行級鎖定與表級鎖之間，所以獲取鎖定所需要的資源開銷，以及所能提供的併發處理能力也同樣是介於上面二者之間。另外，頁級鎖定和行級鎖定一樣，會發生死鎖。</p><p class=ql-align-justify>在數據庫實現資源鎖定的過程中，隨著鎖定資源顆粒度的減小，鎖定相同數據量的數據所需要消耗的內存數量是越來越多的，實現算法也會越來越複雜。</p><p class=ql-align-justify>不過，隨著鎖定資源顆粒度的減小，應用程序的訪問請求遇到鎖等待的可能性也會隨之降低，系統整體併發度也隨之提升。使用頁級鎖定的主要是 BerkeleyDB 存儲引擎。</p><p class=ql-align-justify>總的來說，MySQL 這三種鎖的特性可大致歸納如下：</p><ul><li class=ql-align-justify><strong>表級鎖：</strong>開銷小，加鎖快；不會出現死鎖；鎖定粒度大，發生鎖衝突的概率最高，併發度最低。</li><li class=ql-align-justify><strong>行級鎖：</strong>開銷大，加鎖慢；會出現死鎖；鎖定粒度最小，發生鎖衝突的概率最低，併發度也最高。</li><li class=ql-align-justify><strong>頁面鎖：</strong>開銷和加鎖時間界於表鎖和行鎖之間；會出現死鎖；鎖定粒度界於表鎖和行鎖之間，併發度一般。</li></ul><p class=ql-align-justify><strong>適用：</strong>從鎖的角度來說，表級鎖更適合於以查詢為主，只有少量按索引條件更新數據的應用，如 Web 應用。</p><p class=ql-align-justify>而行級鎖則更適合於有大量按索引條件併發更新少量不同數據，同時又有併發查詢的應用，如一些在線事務處理（OLTP）系統。</p><p>表級鎖定（MyISAM 舉例）</p><p class=ql-align-justify>由於 MyISAM 存儲引擎使用的鎖定機制完全是由 MySQL 提供的表級鎖定實現，所以下面我們將以 MyISAM 存儲引擎作為示例存儲引擎。</p><p><strong>MySQL 表級鎖的鎖模式</strong></p><p class=ql-align-justify>MySQL 的表級鎖有兩種模式：</p><ul><li class=ql-align-justify>表共享讀鎖（Table Read Lock）</li><li class=ql-align-justify>表獨佔寫鎖（Table Write Lock）</li></ul><p class=ql-align-justify>鎖模式的兼容性：</p><ul><li class=ql-align-justify>對 MyISAM 表的讀操作，不會阻塞其他用戶對同一表的讀請求，但會阻塞對同一表的寫請求。</li><li class=ql-align-justify>對 MyISAM 表的寫操作，則會阻塞其他用戶對同一表的讀和寫操作。</li><li class=ql-align-justify>MyISAM 表的讀操作與寫操作之間，以及寫操作之間是串行的。當一個線程獲得對一個表的寫鎖後，只有持有鎖的線程可以對錶進行更新操作。其他線程的讀、寫操作都會等待，直到鎖被釋放為止。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>總結：</strong>表鎖，讀鎖會阻塞寫，不會阻塞讀。而寫鎖則會把讀寫都阻塞。</p><p><strong>如何加表鎖</strong></p><p class=ql-align-justify>MyISAM 在執行查詢語句（SELECT）前，會自動給涉及的所有表加讀鎖，在執行更新操作（UPDATE、DELETE、INSERT等）前，會自動給涉及的表加寫鎖。</p><p class=ql-align-justify>這個過程並不需要用戶干預，因此，用戶一般不需要直接用 LOCK TABLE 命令給 MyISAM 表顯式加鎖。</p><p class=ql-align-justify>顯示加鎖：</p><ul><li class=ql-align-justify><strong>共享讀鎖：</strong>lock table tableName read</li><li class=ql-align-justify><strong>獨佔寫鎖：</strong>lock table tableName write</li><li class=ql-align-justify><strong>同時加多鎖：</strong>lock table t1 write，t2 read</li><li class=ql-align-justify><strong>批量解鎖：</strong>unlock tables</li></ul><p class=ql-align-justify><br></p><p><strong>MyISAM 表鎖優化建議</strong></p><p class=ql-align-justify>對於 MyISAM 存儲引擎，雖然使用表級鎖定在鎖定實現的過程中比實現行級鎖定或者頁級鎖定所帶來的附加成本都要小，鎖定本身所消耗的資源也是最少。</p><p class=ql-align-justify>但是由於鎖定的顆粒度比較大，所以造成鎖定資源的爭用情況也會比其他的鎖定級別都要多，從而在較大程度上會降低併發處理能力。</p><p class=ql-align-justify>所以，在優化 MyISAM 存儲引擎鎖定問題的時候，最關鍵的就是如何讓其提高併發度。</p><p class=ql-align-justify>由於鎖定級別是不可能改變的了，所以我們首先需要儘可能讓鎖定的時間變短，然後就是讓可能併發進行的操作儘可能的併發。</p><p class=ql-align-justify><strong>①查詢表級鎖爭用情況</strong></p><p>MySQL 內部有兩組專門的狀態變量記錄系統內部鎖資源爭用情況：</p><pre>mysql&gt; show status like 'table%';+----------------------------+---------+| Variable_name | Value |+----------------------------+---------+| Table_locks_immediate | 100 || Table_locks_waited | 11 |+----------------------------+---------+</pre><p class=ql-align-justify>這裡有兩個狀態變量記錄 MySQL 內部表級鎖定的情況，兩個變量說明如下：</p><ul><li class=ql-align-justify><strong>Table_locks_immediate：</strong>產生表級鎖定的次數。</li><li class=ql-align-justify><strong>Table_locks_waited：</strong>出現表級鎖定爭用而發生等待的次數；此值越高則說明存在著越嚴重的表級鎖爭用情況。</li></ul><p class=ql-align-justify>此外，MyISAM 的讀寫鎖調度是寫優先，這也是 MyISAM 不適合做寫為主表的存儲引擎的原因。</p><p class=ql-align-justify>因為寫鎖後，其他線程不能做任何操作，大量的更新會使查詢很難得到鎖，從而造成永久阻塞。</p><p class=ql-align-justify>兩個狀態值都是從系統啟動後開始記錄，出現一次對應的事件則數量加 1。如果這裡的 Table_locks_waited 狀態值比較高，那麼說明系統中表級鎖定爭用現象比較嚴重，就需要進一步分析為什麼會有較多的鎖定資源爭用了。</p><p class=ql-align-justify><strong>②縮短鎖定時間</strong></p><p class=ql-align-justify>如何讓鎖定時間儘可能的短呢？唯一的辦法就是讓我們的 Query 執行時間儘可能的短：</p><ul><li class=ql-align-justify>儘量減少大的複雜 Query，將複雜 Query 分拆成幾個小的 Query 分佈進行。</li><li class=ql-align-justify>儘可能的建立足夠高效的索引，讓數據檢索更迅速。</li><li class=ql-align-justify>儘量讓 MyISAM 存儲引擎的表只存放必要的信息，控制字段類型。</li><li class=ql-align-justify>利用合適的機會優化 MyISAM 表數據文件。</li></ul><p class=ql-align-justify><strong>③分離能並行的操作</strong></p><p class=ql-align-justify>說到 MyISAM 的表鎖，而且是讀寫互相阻塞的表鎖，可能有些人會認為在 MyISAM 存儲引擎的表上就只能是完全的串行化，沒辦法再並行了。</p><p class=ql-align-justify>大家不要忘記了，MyISAM 的存儲引擎還有一個非常有用的特性，那就是 Concurrent Insert（併發插入）的特性。</p><p class=ql-align-justify>MyISAM 存儲引擎有一個控制是否打開 Concurrent Insert 功能的參數選項：concurrent_insert，可以設置為 0，1 或者 2。</p><p class=ql-align-justify>三個值的具體說明如下：</p><ul><li class=ql-align-justify><strong>concurrent_insert=2，</strong>無論 MyISAM 表中有沒有空洞，都允許在表尾併發插入記錄。</li><li class=ql-align-justify><strong>concurrent_insert=1，</strong>如果 MyISAM 表中沒有空洞（即表的中間沒有被刪除的行），MyISAM 允許在一個進程讀表的同時，另一個進程從表尾插入記錄。這也是 MySQL 的默認設置。</li><li class=ql-align-justify><strong>concurrent_insert=0，</strong>不允許併發插入。</li></ul><p class=ql-align-justify>可以利用 MyISAM 存儲引擎的併發插入特性，來解決應用中對同一表查詢和插入的鎖爭用。</p><p class=ql-align-justify>例如，將 concurrent_insert 系統變量設為 2，總是允許併發插入；同時，通過定期在系統空閒時段執行 OPTIMIZE TABLE 語句來整理空間碎片，收回因刪除記錄而產生的中間空洞。</p><p class=ql-align-justify><strong>④合理利用讀寫優先級</strong></p><p class=ql-align-justify>MyISAM 存儲引擎的讀寫是互相阻塞的，那麼，一個進程請求某個 MyISAM 表的讀鎖，同時另一個進程也請求同一表的寫鎖，MySQL 如何處理呢？</p><p class=ql-align-justify>答案是寫進程先獲得鎖。不僅如此，即使讀請求先到鎖等待隊列，寫請求後到，寫鎖也會插到讀鎖請求之前。</p><p class=ql-align-justify>這是因為 MySQL 的表級鎖定對於讀和寫是有不同優先級設定的，默認情況下是寫優先級要大於讀優先級。</p><p class=ql-align-justify>所以，如果我們可以根據各自系統環境的差異決定讀與寫的優先級：</p><p class=ql-align-justify>通過執行命令 SET LOW_PRIORITY_UPDATES=1，使該連接讀比寫的優先級高。</p><p class=ql-align-justify>如果我們的系統是一個以讀為主，可以設置此參數，如果以寫為主，則不用設置。</p><p class=ql-align-justify>通過指定 INSERT、UPDATE、DELETE 語句的 LOW_PRIORITY 屬性，降低該語句的優先級。</p><p class=ql-align-justify>雖然上面方法都是要麼更新優先，要麼查詢優先的方法，但還是可以用其來解決查詢相對重要的應用（如用戶登錄系統）中，讀鎖等待嚴重的問題。</p><p class=ql-align-justify>另外，MySQL 也提供了一種折中的辦法來調節讀寫衝突，即給系統參數 max_write_lock_count 設置一個合適的值，當一個表的讀鎖達到這個值後，MySQL 就暫時將寫請求的優先級降低，給讀進程一定獲得鎖的機會。</p><p class=ql-align-justify><strong>這裡還要強調一點：</strong>一些需要長時間運行的查詢操作，也會使寫進程“餓死”。</p><p class=ql-align-justify>因此，應用中應儘量避免出現長時間運行的查詢操作，不要總想用一條 SELECT 語句來解決問題，因為這種看似巧妙的 SQL 語句，往往比較複雜，執行時間較長。</p><p class=ql-align-justify>在可能的情況下可以通過使用中間表等措施對 SQL 語句做一定的“分解”，使每一步查詢都能在較短時間完成，從而減少鎖衝突。</p><p class=ql-align-justify>如果複雜查詢不可避免，應儘量安排在數據庫空閒時段執行，比如一些定期統計可以安排在夜間執行。</p><p class=ql-align-justify>InnoDB 默認採用行鎖，在未使用索引字段查詢時升級為表鎖。MySQL 這樣設計並不是給你挖坑。它有自己的設計目的。</p><p class=ql-align-justify>即便你在條件中使用了索引字段，MySQL 會根據自身的執行計劃，考慮是否使用索引（所以 explain 命令中會有 possible_key 和 key）。</p><p class=ql-align-justify>如果 MySQL 認為全表掃描效率更高，它就不會使用索引，這種情況下 InnoDB 將使用表鎖，而不是行鎖。</p><p class=ql-align-justify>因此，在分析鎖衝突時，別忘了檢查 SQL 的執行計劃，以確認是否真正使用了索引。</p><p class=ql-align-justify><strong>關於執行計劃，第一種情況：全表更新。</strong>事務需要更新大部分或全部數據，且表又比較大。</p><p class=ql-align-justify>若使用行鎖，會導致事務執行效率低，從而可能造成其他事務長時間鎖等待和更多的鎖衝突。</p><p class=ql-align-justify><strong>第二種情況：</strong>多表級聯。事務涉及多個表，比較複雜的關聯查詢，很可能引起死鎖，造成大量事務回滾。</p><p class=ql-align-justify>這種情況若能一次性鎖定事務涉及的表，從而可以避免死鎖、減少數據庫因事務回滾帶來的開銷。</p><p>行級鎖定</p><p class=ql-align-justify>行級鎖定不是 MySQL 自己實現的鎖定方式，而是由其他存儲引擎自己所實現的，如廣為大家所知的 InnoDB 存儲引擎，以及 MySQL 的分佈式存儲引擎 NDB Cluster 等都是實現了行級鎖定。</p><p class=ql-align-justify>考慮到行級鎖定均由各個存儲引擎自行實現，而且具體實現也各有差別，而 InnoDB 是目前事務型存儲引擎中使用最為廣泛的存儲引擎，所以這裡我們就主要分析一下 InnoDB 的鎖定特性。</p><p><strong>InnoDB 鎖定模式及實現機制</strong></p><p class=ql-align-justify>總的來說，InnoDB 的鎖定機制和 Oracle 數據庫有不少相似之處。InnoDB 的行級鎖定同樣分為兩種類型，共享鎖和排他鎖，而在鎖定機制的實現過程中為了讓行級鎖定和表級鎖定共存，InnoDB 也同樣使用了意向鎖（表級鎖定）的概念，也就有了意向共享鎖和意向排他鎖這兩種。</p><p class=ql-align-justify>當一個事務需要給自己需要的某個資源加鎖的時候，如果遇到一個共享鎖正鎖定著自己需要的資源的時候，自己可以再加一個共享鎖，不過不能加排他鎖。</p><p class=ql-align-justify>但是，如果遇到自己需要鎖定的資源已經被一個排他鎖佔有之後，則只能等待該鎖定釋放資源之後自己才能獲取鎖定資源並添加自己的鎖定。</p><p class=ql-align-justify>而意向鎖的作用就是當一個事務在需要獲取資源鎖定的時候，如果遇到自己需要的資源已經被排他鎖佔用的時候，該事務需要在鎖定行的表上面添加一個合適的意向鎖。</p><p class=ql-align-justify>如果自己需要一個共享鎖，那麼就在表上面添加一個意向共享鎖。而如果自己需要的是某行（或者某些行）上面添加一個排他鎖的話，則先在表上面添加一個意向排他鎖。</p><p class=ql-align-justify>意向共享鎖可以同時並存多個，但是意向排他鎖同時只能有一個存在。</p><p class=ql-align-justify>所以，可以說 InnoDB 的鎖定模式實際上可以分為四種：</p><ul><li class=ql-align-justify>共享鎖（S）</li><li class=ql-align-justify>排他鎖（X）</li><li class=ql-align-justify>意向共享鎖（IS）</li><li class=ql-align-justify>意向排他鎖（IX）</li></ul><p>我們可以通過以下表格來總結上面這四種鎖的共存邏輯關係：</p><div class=pgc-img><img alt=理解MySQL鎖和事務，看這篇如何？ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/90852cd96fca4ae094443f3e501597d8><p class=pgc-img-caption></p></div><p class=ql-align-justify>如果一個事務請求的鎖模式與當前的鎖兼容，InnoDB 就將請求的鎖授予該事務；反之，如果兩者不兼容，該事務就要等待鎖釋放。</p><p class=ql-align-justify>意向鎖是 InnoDB 自動加的，不需用戶干預：</p><ul><li class=ql-align-justify>對於 UPDATE、DELETE 和 INSERT 語句，InnoDB 會自動給涉及數據集加排他鎖（X)。</li><li class=ql-align-justify>對於普通 SELECT 語句，InnoDB 不會加任何鎖。</li></ul><p>事務可以通過以下語句顯示給記錄集加共享鎖或排他鎖：</p><pre>共享鎖（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE排他鎖（X)：SELECT * FROM table_name WHERE ... FOR UPDATE</pre><p class=ql-align-justify>用 SELECT ... IN SHARE MODE 獲得共享鎖，主要用在需要數據依存關係時來確認某行記錄是否存在，並確保沒有人對這個記錄進行 UPDATE 或者 DELETE 操作。</p><p class=ql-align-justify>但是如果當前事務也需要對該記錄進行更新操作，則很有可能造成死鎖，對於鎖定行記錄後需要進行更新操作的應用，應該使用 SELECT... FOR UPDATE 方式獲得排他鎖。</p><p><strong>InnoDB 行鎖實現方式</strong></p><p class=ql-align-justify>InnoDB 行鎖是通過給索引上的索引項加鎖來實現的，只有通過索引條件檢索數據，InnoDB 才使用行級鎖，否則，InnoDB 將使用表鎖。</p><p class=ql-align-justify>在實際應用中，要特別注意 InnoDB 行鎖的這一特性，不然的話，可能導致大量的鎖衝突，從而影響併發性能。</p><p class=ql-align-justify>下面通過一些實際例子來加以說明：</p><ul><li class=ql-align-justify>在不通過索引條件查詢的時候，InnoDB 確實使用的是表鎖，而不是行鎖。</li><li class=ql-align-justify>由於 MySQL 的行鎖是針對索引加的鎖，不是針對記錄加的鎖，所以雖然是訪問不同行的記錄，但是如果是使用相同的索引鍵，是會出現鎖衝突的。</li><li class=ql-align-justify>當表有多個索引的時候，不同的事務可以使用不同的索引鎖定不同的行，另外，不論是使用主鍵索引、唯一索引或普通索引，InnoDB 都會使用行鎖來對數據加鎖。</li><li class=ql-align-justify>即便在條件中使用了索引字段，但是否使用索引來檢索數據是由 MySQL 通過判斷不同執行計劃的代價來決定的，如果 MySQL 認為全表掃描效率更高，比如對一些很小的表，它就不會使用索引。</li><li class=ql-align-justify>這種情況下 InnoDB 將使用表鎖，而不是行鎖。因此，在分析鎖衝突時，別忘了檢查 SQL 的執行計劃，以確認是否真正使用了索引。</li></ul><p class=ql-align-justify><br></p><p><strong>間隙鎖（Next-Key鎖）</strong></p><p class=ql-align-justify>當我們用範圍條件而不是相等條件檢索數據，並請求共享或排他鎖時，InnoDB 會給符合條件的已有數據記錄的索引項加鎖。</p><p class=ql-align-justify>對於鍵值在條件範圍內但並不存在的記錄，叫做“間隙（GAP)”，InnoDB 也會對這個“間隙”加鎖，這種鎖機制就是所謂的間隙鎖（Next-Key鎖）。</p><p>假如 emp 表中只有 101 條記錄，其 empid 的值分別是 1,2,...,100,101，下面的 SQL：</p><pre>mysql&gt; select * from emp where empid &gt; 100 for update;</pre><p class=ql-align-justify>這是一個範圍條件的檢索，InnoDB 不僅會對符合條件的 empid 值為 101 的記錄加鎖，也會對 empid 大於 101（這些記錄並不存在）的“間隙”加鎖。</p><p class=ql-align-justify>InnoDB 使用間隙鎖的目的：</p><ul><li class=ql-align-justify>防止幻讀，以滿足相關隔離級別的要求（關於事務的隔離級別）。對於上面的例子，要是不使用間隙鎖，如果其他事務插入了 empid 大於 100 的任何記錄，那麼本事務如果再次執行上述語句，就會發生幻讀。</li><li class=ql-align-justify>為了滿足其恢復和複製的需要。很顯然，在使用範圍條件檢索並鎖定記錄時，即使某些不存在的鍵值也會被無辜的鎖定，而造成在鎖定的時候無法插入鎖定鍵值範圍內的任何數據。在某些場景下這可能會對性能造成很大的危害。</li></ul><p class=ql-align-justify>除了間隙鎖給 InnoDB 帶來性能的負面影響之外，通過索引實現鎖定的方式還存在其他幾個較大的性能隱患：</p><ul><li class=ql-align-justify>當 Query 無法利用索引的時候，InnoDB 會放棄使用行級別鎖定而改用表級別的鎖定，造成併發性能的降低。</li><li class=ql-align-justify>當 Query 使用的索引並不包含所有過濾條件的時候，數據檢索使用到的索引鍵所指向的數據可能有部分並不屬於該 Query 的結果集的行列，但是也會被鎖定，因為間隙鎖鎖定的是一個範圍，而不是具體的索引鍵。</li><li class=ql-align-justify>當 Query 在使用索引定位數據的時候，如果使用的索引鍵一樣但訪問的數據行不同的時候（索引只是過濾條件的一部分），一樣會被鎖定。</li></ul><p class=ql-align-justify>因此，在實際應用開發中，尤其是併發插入比較多的應用，我們要儘量優化業務邏輯，儘量使用相等條件來訪問更新數據，避免使用範圍條件。</p><p class=ql-align-justify>還要特別說明的是，InnoDB 除了通過範圍條件加鎖時使用間隙鎖外，如果使用相等條件請求給一個不存在的記錄加鎖，InnoDB 也會使用間隙鎖。</p><p><strong>死鎖</strong></p><p class=ql-align-justify>上文講過，MyISAM 表鎖是 deadlock free 的，這是因為 MyISAM 總是一次獲得所需的全部鎖，要麼全部滿足，要麼等待，因此不會出現死鎖。</p><p class=ql-align-justify>但在 InnoDB 中，除單個 SQL 組成的事務外，鎖是逐步獲得的，當兩個事務都需要獲得對方持有的排他鎖才能繼續完成事務，這種循環鎖等待就是典型的死鎖。</p><p class=ql-align-justify>在 InnoDB 的事務管理和鎖定機制中，有專門檢測死鎖的機制，會在系統中產生死鎖之後的很短時間內就檢測到該死鎖的存在。</p><p class=ql-align-justify>當 InnoDB 檢測到系統中產生了死鎖之後，InnoDB 會通過相應的判斷來選這產生死鎖的兩個事務中較小的事務來回滾，而讓另外一個較大的事務成功完成。</p><p class=ql-align-justify>那 InnoDB 是以什麼來為標準判定事務的大小的呢？MySQL 官方手冊中也提到了這個問題，實際上在 InnoDB 發現死鎖之後，會計算出兩個事務各自插入、更新或者刪除的數據量來判定兩個事務的大小。也就是說哪個事務所改變的記錄條數越多，在死鎖中就越不會被回滾掉。</p><p class=ql-align-justify>但是有一點需要注意的就是，當產生死鎖的場景中涉及到不止 InnoDB 存儲引擎的時候，InnoDB 是沒辦法檢測到該死鎖的，這時候就只能通過鎖定超時限制參數 InnoDB_lock_wait_timeout 來解決。</p><p class=ql-align-justify>需要說明的是，這個參數並不是只用來解決死鎖問題，在併發訪問比較高的情況下，如果大量事務因無法立即獲得所需的鎖而掛起，會佔用大量計算機資源，造成嚴重性能問題，甚至拖跨數據庫。我們通過設置合適的鎖等待超時閾值，可以避免這種情況發生。</p><p class=ql-align-justify>通常來說，死鎖都是應用設計的問題，通過調整業務流程、數據庫對象設計、事務大小，以及訪問數據庫的 SQL 語句，絕大部分死鎖都可以避免。</p><p class=ql-align-justify>下面就通過實例來介紹幾種避免死鎖的常用方法：</p><ul><li class=ql-align-justify>在應用中，如果不同的程序會併發存取多個表，應儘量約定以相同的順序來訪問表，這樣可以大大降低產生死鎖的機會。</li><li class=ql-align-justify>在程序以批量方式處理數據的時候，如果事先對數據排序，保證每個線程按固定的順序來處理記錄，也可以大大降低出現死鎖的可能。</li><li class=ql-align-justify>在事務中，如果要更新記錄，應該直接申請足夠級別的鎖，即排他鎖，而不應先申請共享鎖，更新時再申請排他鎖，因為當用戶申請排他鎖時，其他事務可能又已經獲得了相同記錄的共享鎖，從而造成鎖衝突，甚至死鎖。</li><li class=ql-align-justify>在 REPEATABLE-READ 隔離級別下，如果兩個線程同時對相同條件記錄用 SELECT...FOR UPDATE 加排他鎖，在沒有符合該條件記錄情況下，兩個線程都會加鎖成功。</li><li class=ql-align-justify>程序發現記錄尚不存在，就試圖插入一條新記錄，如果兩個線程都這麼做，就會出現死鎖。這種情況下，將隔離級別改成 READ COMMITTED，就可避免問題。</li><li class=ql-align-justify>當隔離級別為 READ COMMITTED 時，如果兩個線程都先執行 SELECT...FOR UPDATE，判斷是否存在符合條件的記錄，如果沒有，就插入記錄。</li><li class=ql-align-justify>此時，只有一個線程能插入成功，另一個線程會出現鎖等待，當第一個線程提交後，第二個線程會因主鍵重出錯，但雖然這個線程出錯了，卻會獲得一個排他鎖。這時如果有第三個線程又來申請排他鎖，也會出現死鎖。</li><li class=ql-align-justify>對於這種情況，可以直接做插入操作，然後再捕獲主鍵重異常，或者在遇到主鍵重錯誤時，總是執行 ROLLBACK 釋放獲得的排他鎖。</li></ul><p><strong>什麼時候使用表鎖</strong></p><p class=ql-align-justify>對於 InnoDB 表，在絕大部分情況下都應該使用行級鎖，因為事務和行鎖往往是我們之所以選擇 InnoDB 表的理由。</p><p class=ql-align-justify>但在個別特殊事務中，也可以考慮使用表級鎖：</p><ul><li class=ql-align-justify>事務需要更新大部分或全部數據，表又比較大，如果使用默認的行鎖，不僅這個事務執行效率低，而且可能造成其他事務長時間鎖等待和鎖衝突，這種情況下可以考慮使用表鎖來提高該事務的執行速度。</li><li class=ql-align-justify>事務涉及多個表，比較複雜，很可能引起死鎖，造成大量事務回滾。這種情況也可以考慮一次性鎖定事務涉及的表，從而避免死鎖、減少數據庫因事務回滾帶來的開銷。</li></ul><p class=ql-align-justify>當然，應用中這兩種事務不能太多，否則，就應該考慮使用 MyISAM 表了。</p><p class=ql-align-justify>在 InnoDB 下，使用表鎖要注意以下兩點：</p><ul><li class=ql-align-justify>使用 LOCK TABLES 雖然可以給 InnoDB 加表級鎖，但必須說明的是，表鎖不是由 InnoDB 存儲引擎層管理的，而是由其上一層──MySQL Server 負責的。</li><li class=ql-align-justify>僅當 autocommit=0（不自動提交，默認是自動提交的）、InnoDB_table_locks=1（默認設置）時，InnoDB 層才能知道 MySQL 加的表鎖，MySQL Server 也才能感知 InnoDB 加的行鎖。</li><li class=ql-align-justify>這種情況下，InnoDB 才能自動識別涉及表級鎖的死鎖，否則，InnoDB 將無法自動檢測並處理這種死鎖。</li><li class=ql-align-justify>在用 LOCK TABLES 對 InnoDB 表加鎖時要注意，要將 AUTOCOMMIT 設為 0，否則 MySQL 不會給表加鎖。</li><li class=ql-align-justify>事務結束前，不要用 UNLOCK TABLES 釋放表鎖，因為 UNLOCK TABLES 會隱含地提交事務。</li><li class=ql-align-justify>COMMIT 或 ROLLBACK 並不能釋放用 LOCK TABLES 加的表級鎖，必須用 UNLOCK TABLES 釋放表鎖。</li></ul><p>正確的方式見如下語句，例如，如果需要寫表 t1 並從表 t 讀，可以按如下做：</p><pre>SET AUTOCOMMIT=0;LOCK TABLES t1 WRITE, t2 READ, ...;[do something with tables t1 and t2 here];COMMIT;UNLOCK TABLES;</pre><p><strong>InnoDB 行鎖優化建議</strong></p><p class=ql-align-justify>InnoDB 存儲引擎由於實現了行級鎖定，雖然在鎖定機制的實現方面所帶來的性能損耗可能比表級鎖定會要更高一些，但是在整體併發處理能力方面要遠遠優於 MyISAM 的表級鎖定的。</p><p class=ql-align-justify>當系統併發量較高的時候，InnoDB 的整體性能和 MyISAM 相比就會有比較明顯的優勢了。</p><p class=ql-align-justify>但是，InnoDB 的行級鎖定同樣也有其脆弱的一面，當我們使用不當的時候，可能會讓 InnoDB 的整體性能表現不僅不能比 MyISAM 高，甚至可能會更差。</p><p class=ql-align-justify>①要想合理利用 InnoDB 的行級鎖定，做到揚長避短，我們必須做好以下工作：</p><ul><li class=ql-align-justify>儘可能讓所有的數據檢索都通過索引來完成，從而避免 InnoDB 因為無法通過索引鍵加鎖而升級為表級鎖定。</li><li class=ql-align-justify>合理設計索引，讓 InnoDB 在索引鍵上面加鎖的時候儘可能準確，儘可能的縮小鎖定範圍，避免造成不必要的鎖定而影響其他 Query 的執行。</li><li class=ql-align-justify>儘可能減少基於範圍的數據檢索過濾條件，避免因為間隙鎖帶來的負面影響而鎖定了不該鎖定的記錄。</li><li class=ql-align-justify>儘量控制事務的大小，減少鎖定的資源量和鎖定時間長度。</li><li class=ql-align-justify>在業務環境允許的情況下，儘量使用較低級別的事務隔離，以減少 MySQL 因為實現事務隔離級別所帶來的附加成本。</li></ul><p class=ql-align-justify>②由於 InnoDB 的行級鎖定和事務性，所以肯定會產生死鎖，下面是一些比較常用的減少死鎖產生概率的小建議：</p><ul><li class=ql-align-justify>類似業務模塊中，儘可能按照相同的訪問順序來訪問，防止產生死鎖。</li><li class=ql-align-justify>在同一個事務中，儘可能做到一次鎖定所需要的所有資源，減少死鎖產生概率。</li><li class=ql-align-justify>對於非常容易產生死鎖的業務部分，可以嘗試使用升級鎖定顆粒度，通過表級鎖定來減少死鎖產生的概率。</li></ul><p>③可以通過檢查 InnoDB_row_lock 狀態變量來分析系統上的行鎖的爭奪情況：</p><pre>mysql&gt; show status like 'InnoDB_row_lock%';+-------------------------------+-------+| Variable_name | Value |+-------------------------------+-------+| InnoDB_row_lock_current_waits | 0 || InnoDB_row_lock_time | 0 || InnoDB_row_lock_time_avg | 0 || InnoDB_row_lock_time_max | 0 || InnoDB_row_lock_waits | 0 |+-------------------------------+-------+</pre><p class=ql-align-justify>InnoDB 的行級鎖定狀態變量不僅記錄了鎖定等待次數，還記錄了鎖定總時長，每次平均時長，以及最大時長，此外還有一個非累積狀態量顯示了當前正在等待鎖定的等待數量。</p><p class=ql-align-justify>對各個狀態量的說明如下：</p><ul><li class=ql-align-justify><strong>InnoDB_row_lock_current_waits：</strong>當前正在等待鎖定的數量。</li><li class=ql-align-justify><strong>InnoDB_row_lock_time：</strong>從系統啟動到現在鎖定總時間長度。</li><li class=ql-align-justify><strong>InnoDB_row_lock_time_avg：</strong>每次等待所花平均時間。</li><li class=ql-align-justify><strong>InnoDB_row_lock_time_max：</strong>從系統啟動到現在等待最常的一次所花的時間。</li><li class=ql-align-justify><strong>InnoDB_row_lock_waits：</strong>系統啟動後到現在總共等待的次數。</li></ul><p class=ql-align-justify>對於這五個狀態變量，比較重要的三項是：</p><ul><li class=ql-align-justify><strong>InnoDB_row_lock_time_avg（等待平均時長）</strong></li><li class=ql-align-justify><strong>InnoDB_row_lock_waits（等待總次數）</strong></li><li class=ql-align-justify><strong>InnoDB_row_lock_time（等待總時長）</strong></li></ul><p class=ql-align-justify>尤其是當等待次數很高，而且每次等待時長也不小的時候，我們就需要分析系統中為什麼會有如此多的等待，然後根據分析結果著手指定優化計劃。</p><p class=ql-align-justify>如果發現鎖爭用比較嚴重，如 InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值比較高。</p><p class=ql-align-justify>還可以通過設置 InnoDB Monitors 來進一步觀察發生鎖衝突的表、數據行等，並分析鎖爭用的原因。</p><p>鎖衝突的表、數據行等，並分析鎖爭用的原因。具體方法如下：</p><pre>mysql&gt; create table InnoDB_monitor(a INT) engine=InnoDB;</pre><p>然後就可以用下面的語句來進行查看：</p><p>mysql> show engine InnoDB status;</p><p>監視器可以通過發出下列語句來停止查看：</p><pre>mysql&gt; drop table InnoDB_monitor;</pre><p class=ql-align-justify>設置監視器後，會有詳細的當前鎖等待的信息，包括表名、鎖類型、鎖定記錄的情況等，便於進行進一步的分析和問題的確定。可能會有讀者朋友問為什麼要先創建一個叫 InnoDB_monitor 的表呢？</p><p class=ql-align-justify>因為創建該表實際上就是告訴 InnoDB 我們開始要監控他的細節狀態了，然後 InnoDB 就會將比較詳細的事務以及鎖定信息記錄進入 MySQL 的 errorlog 中，以便我們後面做進一步分析使用。</p><p class=ql-align-justify>打開監視器以後，默認情況下每 15 秒會向日志中記錄監控的內容，如果長時間打開會導致 .err 文件變得非常的巨大。</p><p class=ql-align-justify>所以用戶在確認問題原因之後，要記得刪除監控表以關閉監視器，或者通過使用“--console”選項來啟動服務器以關閉寫日誌文件。</p><p>查看死鎖、解除鎖</p><p class=ql-align-justify>結合上面對錶鎖和行鎖的分析情況，解除正在死鎖的狀態有兩種方法：</p><p><strong>第一種</strong></p><p>①查詢是否鎖表</p><pre>show OPEN TABLES where In_use &gt; 0;</pre><p>②查詢進程（如果您有 SUPER 權限，您可以看到所有線程。否則，您只能看到您自己的線程）</p><pre>show processlist</pre><p>③殺死進程 id（就是上面命令的 id 列）</p><pre>kill id</pre><p><strong>第二種</strong></p><p>①查看下在鎖的事務</p><pre>SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</pre><p>②殺死進程 id（就是上面命令的 trx_mysql_thread_id 列）</p><pre>kill 線程ID</pre><p class=ql-align-justify>例子：</p><ul><li class=ql-align-justify>查出死鎖進程：SHOW PROCESSLIST</li><li class=ql-align-justify>殺掉進程：KILL 420821</li></ul><p class=ql-align-justify>其他關於查看死鎖的命令：</p><p>①查看當前的事務</p><pre>SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;</pre><p>②查看當前鎖定的事務</p><pre>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</pre><p>③查看當前等鎖的事務</p><pre>SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</pre><p>事務</p><p><strong>MySQL 事務屬性</strong></p><p class=ql-align-justify>事務是由一組 SQL 語句組成的邏輯處理單元，事務具有 ACID 屬性：</p><ul><li class=ql-align-justify><strong>原子性（Atomicity）：</strong>事務是一個原子操作單元。在當時原子是不可分割的最小元素，其對數據的修改，要麼全部成功，要麼全部都不成功。</li><li class=ql-align-justify><strong>一致性（Consistent）：</strong>事務開始到結束的時間段內，數據都必須保持一致狀態。</li><li class=ql-align-justify><strong>隔離性（Isolation）：</strong>數據庫系統提供一定的隔離機制，保證事務在不受外部併發操作影響的"獨立"環境執行。</li><li class=ql-align-justify><strong>持久性（Durable）：</strong>事務完成後，它對於數據的修改是永久性的，即使出現系統故障也能夠保持。</li></ul><p><strong>事務常見問題</strong></p><p class=ql-align-justify><strong>①更新丟失（Lost Update）</strong></p><p class=ql-align-justify>原因：當多個事務選擇同一行操作，並且都是基於最初選定的值，由於每個事務都不知道其他事務的存在，就會發生更新覆蓋的問題。類比 Github 提交衝突。</p><p class=ql-align-justify><strong>②髒讀（Dirty Reads）</strong></p><p class=ql-align-justify>原因：事務 A 讀取了事務 B 已經修改但尚未提交的數據。若事務 B 回滾數據，事務 A 的數據存在不一致性的問題。</p><p class=ql-align-justify><strong>③不可重複讀（Non-Repeatable Reads）</strong></p><p class=ql-align-justify>原因：事務 A 第一次讀取最初數據，第二次讀取事務 B 已經提交的修改或刪除數據。導致兩次讀取數據不一致。不符合事務的隔離性。</p><p class=ql-align-justify><strong>④幻讀（Phantom Reads）</strong></p><p class=ql-align-justify>原因：事務 A 根據相同條件第二次查詢到事務 B 提交的新增數據，兩次數據結果集不一致。不符合事務的隔離性。</p><p class=ql-align-justify>幻讀和髒讀有點類似，髒讀是事務 B 裡面修改了數據，幻讀是事務 B 裡面新增了數據。</p><p><strong>事務的隔離級別</strong></p><p class=ql-align-justify>數據庫的事務隔離越嚴格，併發副作用越小，但付出的代價也就越大。這是因為事務隔離實質上是將事務在一定程度上"串行"進行，這顯然與"併發"是矛盾的。</p><p class=ql-align-justify>根據自己的業務邏輯，權衡能接受的最大副作用。從而平衡了"隔離" 和 "併發"的問題。MySQL 默認隔離級別是可重複讀。</p><p>髒讀，不可重複讀，幻讀，其實都是數據庫讀一致性問題，必須由數據庫提供一定的事務隔離機制來解決：</p><pre>+------------------------------+---------------------+--------------+--------------+--------------+| 隔離級別 | 讀數據一致性 | 髒讀 | 不可重複 讀 | 幻讀 |+------------------------------+---------------------+--------------+--------------+--------------+| 未提交讀(Read uncommitted) | 最低級別 | 是 | 是 | 是 | +------------------------------+---------------------+--------------+--------------+--------------+| 已提交讀(Read committed) | 語句級 | 否 | 是 | 是 |+------------------------------+---------------------+--------------+--------------+--------------+| 可重複讀(Repeatable read) | 事務級 | 否 | 否 | 是 |+------------------------------+---------------------+--------------+--------------+--------------+| 可序列化(Serializable) | 最高級別，事務級 | 否 | 否 | 否 |+------------------------------+---------------------+--------------+--------------+--------------+</pre><pre class=ql-align-justify>查看當前數據庫的事務隔離級別：show variables like 'tx_isolation'。mysql&gt; show variables like 'tx_isolation';+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| tx_isolation | REPEATABLE-READ |+---------------+-----------------+</pre><p><strong>事務級別的設置</strong></p><p class=ql-align-justify><br></p><pre>1.未提交讀（READ UNCOMMITED） 解決的障礙：無； 引入的問題：髒讀 set SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;2.已提交讀 （READ COMMITED） 解決的障礙：髒讀； 引入的問題：不可重複讀 set SESSION TRANSACTION ISOLATION LEVEL read committed;3.可重複讀（REPEATABLE READ）解決的障礙：不可重複讀； 引入的問題： set SESSION TRANSACTION ISOLATION LEVEL repeatable read;4.可串行化（SERIALIZABLE）解決的障礙：可重複讀； 引入的問題：鎖全表，性能低下 set SESSION TRANSACTION ISOLATION LEVEL repeatable read;</pre><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>總結：</strong>事務隔離級別為可重複讀時，如果有索引（包括主鍵索引）的時候，以索引列為條件更新數據，會存在間隙鎖間、行鎖、頁鎖的問題，從而鎖住一些行；如果沒有索引，更新數據時會鎖住整張表。</p><p class=ql-align-justify>事務隔離級別為串行化時，讀寫數據都會鎖住整張表，隔離級別越高，越能保證數據的完整性和一致性，但是對併發性能的影響也越大。</p><p class=ql-align-justify>對於多數應用程序，可以優先考慮把數據庫系統的隔離級別設為 Read Committed，它能夠避免髒讀取，而且具有較好的併發性能。</p><p><strong>事務保存點，實現部分回滾</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>定義保存點，以及回滾到指定保存點前狀態的語法如下：</p><ul><li class=ql-align-justify><strong>定義保存點：</strong>SAVEPOINT 保存點名。</li><li class=ql-align-justify><strong>回滾到指定保存點：</strong>ROLLBACK TO SAVEPOINT 保存點名。</li></ul><pre>1、查看user表中的數據mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu | 1 | NULL |+-----+----------+-----+------+2 rows in set (0.05 sec)2、mysql事務開始mysql&gt; BEGIN; -- 或者start transaction；Query OK, 0 rows affected (0.00 sec)3、向表user中插入2條數據mysql&gt; INSERT INTO user VALUES ('3','one','0','');Query OK, 1 row affected (0.08 sec)mysql&gt; INSERT INTO user VALUES ('4,'two','0','');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu | 1 | NULL || 3 | one | 0 | || 4 | two | 0 | |+-----+----------+-----+------+4 rows in set (0.00 sec)4、指定保存點，保存點名為testmysql&gt; SAVEPOINT test;Query OK, 0 rows affected (0.00 sec)5、向表user中插入第3條數據mysql&gt; INSERT INTO user VALUES ('5','three','0','');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu | 1 | NULL || 3 | one | 0 | || 4 | two | 0 | || 5 | three | 0 | |+-----+----------+-----+------+5 rows in set (0.02 sec)6、回滾到保存點testmysql&gt; ROLLBACK TO SAVEPOINT test;Query OK, 0 rows affected (0.31 sec)mysql&gt; select * from user;+-----+----------+-----+------+| mid | name | scx | word |+-----+----------+-----+------+| 1 | zhangsan | 0 | NULL || 2 | wangwu | 1 | NULL || 3 | one | 0 | || 4 | two | 0 | |+-----+----------+-----+------+4 rows in set (0.00 sec)</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>我們可以看到保存點 test 以後插入的記錄沒有顯示了，即成功團滾到了定義保存點 test 前的狀態。利用保存點可以實現只提交事務中部分處理的功能。</p><p><strong>事務控制語句</strong></p><pre>BEGIN或START TRANSACTION；顯式地開啟一個事務；COMMIT； 也可以使用COMMIT WORK，不過二者是等價的。COMMIT會提交事務，並使已對數據庫進行的所有修改成為永久性的；ROLLBACK； 有可以使用ROLLBACK WORK，不過二者是等價的。回滾會結束用戶的事務，並撤銷正在進行的所有未提交的修改；SAVEPOINT identifier； SAVEPOINT允許在事務中創建一個保存點，一個事務中可以有多個SAVEPOINT；RELEASE SAVEPOINT identifier； 刪除一個事務的保存點，當沒有指定的保存點時，執行該語句會拋出一個異常；ROLLBACK TO identifier； 把事務回滾到標記點；SET TRANSACTION； 用來設置事務的隔離級別。InnoDB存儲引擎提供事務的隔離級別有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。 用 BEGIN, ROLLBACK, COMMIT來實現 BEGIN 開始一個事務 ROLLBACK 事務回滾 COMMIT 事務確認 直接用 SET 來改變 MySQL 的自動提交模式: SET AUTOCOMMIT=0或者off 禁止自動提交 SET AUTOCOMMIT=1或者on 開啟自動提交</pre><p><em>作者：愛文飛翔</em></p><p class=ql-align-justify><em>編輯：陶家龍、孫淑娟</em></p><p class=ql-align-justify><em>出處：https://www.cnblogs.com/an-wen/p/11295186.html</em></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>MySQL</a></li><li><a>鎖和事務</a></li><li><a>這篇</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html alt="圖解MySQL | 「原理解析」 MySQL組提交(group commit)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e5444e9094614d6b88bd3fc8ac0524fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html title="圖解MySQL | 「原理解析」 MySQL組提交(group commit)">圖解MySQL | 「原理解析」 MySQL組提交(group commit)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html alt=MySQL系列-第14篇：事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html title=MySQL系列-第14篇：事務詳解>MySQL系列-第14篇：事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html alt=MySQL進階之InnoDB事務原子性實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e1d208ac-c0ed-4238-bce5-e4b3760228c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html title=MySQL進階之InnoDB事務原子性實現原理>MySQL進階之InnoDB事務原子性實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html alt="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html title="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務">技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html alt=深入學習MySQL事務：ACID特性的實現原理「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cdc702d66d6943499997d11e931425eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html title=深入學習MySQL事務：ACID特性的實現原理「轉」>深入學習MySQL事務：ACID特性的實現原理「轉」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html alt=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html title=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理>解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>