<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基於RocketMQ分佈式事務 - 完整示例 | 极客快訊</title><meta property="og:title" content="基於RocketMQ分佈式事務 - 完整示例 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/388a9665bf45413eb391e47c6d10ca12"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3ff1309.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3ff1309.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/3ff1309.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3ff1309.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3ff1309.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/3ff1309.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/3ff1309.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/3ff1309.html><meta property="article:published_time" content="2020-10-29T20:46:29+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:29+08:00"><meta name=Keywords content><meta name=description content="基於RocketMQ分佈式事務 - 完整示例"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/3ff1309.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基於RocketMQ分佈式事務 - 完整示例</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p>之前我們說到，分佈式事務是一個複雜的技術問題。沒有通用的解決方案，也缺乏簡單高效的手段。</p><p>不過，如果我們的系統不追求強一致性，那麼最常用的還是最終一致性方案。今天，我們就基於 RocketMQ來實現消息最終一致性方案的分佈式事務。</p><p>本文代碼不只是簡單的demo，考慮到一些異常情況、冪等性消費和死信隊列等情況，儘量向可靠業務場景靠攏。</p><p>另外，在最後還有《RocketMQ技術內幕》一書中，關於分佈式事務示例代碼的錯誤流程分析，所以篇幅較長，希望大家耐心觀看。</p><h1 class=pgc-h-arrow-right>一、事務消息</h1><p>在這裡，筆者不想使用大量的文字贅述 RocketMQ事務消息的原理，我們只需要搞明白兩個概念。</p><ul><li>Half Message，半消息</li></ul><p>暫時不能被 Consumer消費的消息。Producer已經把消息發送到 Broker端，但是此消息的狀態被標記為不能投遞，處於這種狀態下的消息稱為半消息。事實上，該狀態下的消息會被放在一個叫做 RMQ_SYS_TRANS_HALF_TOPIC的主題下。</p><p>當 Producer端對它二次確認後，也就是 Commit之後，Consumer端才可以消費到；那麼如果是Rollback，該消息則會被刪除，永遠不會被消費到。</p><ul><li>事務狀態回查</li></ul><p>我們想，可能會因為網絡原因、應用問題等，導致Producer端一直沒有對這個半消息進行確認，那麼這時候 Broker服務器會定時掃描這些半消息，主動找Producer端查詢該消息的狀態。</p><p>當然，什麼時候去掃描，包含掃描幾次，我們都可以配置，在後文我們再細說。</p><p>簡而言之，RocketMQ事務消息的實現原理就是基於兩階段提交和事務狀態回查，來決定消息最終是提交還是回滾的。</p><p>在本文，我們的代碼就以 訂單服務、積分服務 為例。結合上文來看，整體流程如下：</p><p><br></p><div class=pgc-img><img alt="基於RocketMQ分佈式事務 - 完整示例" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/388a9665bf45413eb391e47c6d10ca12><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>二、訂單服務</h1><p>在訂單服務中，我們接收前端的請求創建訂單，保存相關數據到本地數據庫。</p><h1 class=pgc-h-arrow-right>1、事務日誌表</h1><p>在訂單服務中，除了有一張訂單表之外，還需要一個事務日誌表。 它的定義如下：</p><pre><code>CREATE TABLE `transaction_log` (  `id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '事務ID',  `business` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '業務標識',  `foreign_key` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '對應業務表中的主鍵',  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;</code></pre><p>這張表專門作用於事務狀態回查。當提交業務數據時，此表也插入一條數據，它們共處一個本地事務中。通過事務ID查詢該表，如果返回記錄，則證明本地事務已提交；如果未返回記錄，則本地事務可能是未知狀態或者是回滾狀態。</p><h1 class=pgc-h-arrow-right>2、TransactionMQProducer</h1><p>我們知道，通過 RocketMQ發送消息，需先創建一個消息發送者。值得注意的是，如果發送事務消息，在這裡我們的創建的實例必須是 TransactionMQProducer。</p><pre><code>@Componentpublic class TransactionProducer {	    private String producerGroup = "order_trans_group";    private TransactionMQProducer producer;    //用於執行本地事務和事務狀態回查的監聽器    @Autowired    OrderTransactionListener orderTransactionListener;    //執行任務的線程池    ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 60,            TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(50));                @PostConstruct    public void init(){        producer = new TransactionMQProducer(producerGroup);        producer.setNamesrvAddr("127.0.0.1:9876");        producer.setSendMsgTimeout(Integer.MAX_VALUE);        producer.setExecutorService(executor);        producer.setTransactionListener(orderTransactionListener);        this.start();    }    private void start(){        try {            this.producer.start();        } catch (MQClientException e) {            e.printStackTrace();        }    }    //事務消息發送     public TransactionSendResult send(String data, String topic) throws MQClientException {        Message message = new Message(topic,data.getBytes());        return this.producer.sendMessageInTransaction(message, null);    }}</code></pre><p>上面的代碼中，主要就是創建事務消息的發送者。在這裡，我們重點關注 OrderTransactionListener，它負責執行本地事務和事務狀態回查。</p><h1 class=pgc-h-arrow-right>3、OrderTransactionListener</h1><pre><code>@Componentpublic class OrderTransactionListener implements TransactionListener {    @Autowired    OrderService orderService;    @Autowired    TransactionLogService transactionLogService;    Logger logger = LoggerFactory.getLogger(this.getClass());    @Override    public LocalTransactionState executeLocalTransaction(Message message, Object o) {        logger.info("開始執行本地事務....");        LocalTransactionState state;        try{            String body = new String(message.getBody());            OrderDTO order = JSONObject.parseObject(body, OrderDTO.class);            orderService.createOrder(order,message.getTransactionId());            state = LocalTransactionState.COMMIT_MESSAGE;            logger.info("本地事務已提交。{}",message.getTransactionId());        }catch (Exception e){            logger.info("執行本地事務失敗。{}",e);            state = LocalTransactionState.ROLLBACK_MESSAGE;        }        return state;    }    @Override    public LocalTransactionState checkLocalTransaction(MessageExt messageExt) {        logger.info("開始回查本地事務狀態。{}",messageExt.getTransactionId());        LocalTransactionState state;        String transactionId = messageExt.getTransactionId();        if (transactionLogService.get(transactionId)&gt;0){            state = LocalTransactionState.COMMIT_MESSAGE;        }else {            state = LocalTransactionState.UNKNOW;        }        logger.info("結束本地事務狀態查詢：{}",state);        return state;    }}</code></pre><p>在通過 producer.sendMessageInTransaction發送事務消息後，如果消息發送成功，就會調用到這裡的executeLocalTransaction方法，來執行本地事務。在這裡，它會完成訂單數據和事務日誌的插入。</p><p>該方法返回值 LocalTransactionState 代表本地事務狀態，它是一個枚舉類。</p><pre><code>public enum LocalTransactionState {    //提交事務消息，消費者可以看到此消息    COMMIT_MESSAGE,    //回滾事務消息，消費者不會看到此消息    ROLLBACK_MESSAGE,    //事務未知狀態，需要調用事務狀態回查，確定此消息是提交還是回滾    UNKNOW;}</code></pre><p>那麼， checkLocalTransaction 方法就是用於事務狀態查詢。在這裡，我們通過事務ID查詢transaction_log這張表，如果可以查詢到結果，就提交事務消息；如果沒有查詢到，就返回未知狀態。</p><p>注意，這裡還涉及到另外一個問題。如果是返回未知狀態，RocketMQ Broker服務器會以1分鐘的間隔時間不斷回查，直至達到事務回查最大檢測數，如果超過這個數字還未查詢到事務狀態，則回滾此消息。</p><p>當然，事務回查的頻率和最大次數，我們都可以配置。在 Broker 端，可以通過這樣來配置它：</p><pre><code>brokerConfig.setTransactionCheckInterval(10000); //回查頻率10秒一次brokerConfig.setTransactionCheckMax(3);  //最大檢測次數為3</code></pre><h1 class=pgc-h-arrow-right>4、業務實現類</h1><pre><code>@Servicepublic class OrderServiceImpl implements OrderService {    @Autowired    OrderMapper orderMapper;    @Autowired    TransactionLogMapper transactionLogMapper;    @Autowired    TransactionProducer producer;    Snowflake snowflake = new Snowflake(1,1);    Logger logger = LoggerFactory.getLogger(this.getClass());    //執行本地事務時調用，將訂單數據和事務日誌寫入本地數據庫    @Transactional    @Override    public void createOrder(OrderDTO orderDTO,String transactionId){        //1.創建訂單        Order order = new Order();        BeanUtils.copyProperties(orderDTO,order);        orderMapper.createOrder(order);        //2.寫入事務日誌        TransactionLog log = new TransactionLog();        log.setId(transactionId);        log.setBusiness("order");        log.setForeignKey(String.valueOf(order.getId()));        transactionLogMapper.insert(log);        logger.info("訂單創建完成。{}",orderDTO);    }    //前端調用，只用於向RocketMQ發送事務消息    @Override    public void createOrder(OrderDTO order) throws MQClientException {        order.setId(snowflake.nextId());        order.setOrderNo(snowflake.nextIdStr());        producer.send(JSON.toJSONString(order),"order");    }}</code></pre><p>在訂單業務服務類中，我們有兩個方法。一個用於向RocketMQ發送事務消息，一個用於真正的業務數據落庫。</p><p>至於為什麼這樣做，其實有一些原因的，我們後面再說。</p><h1 class=pgc-h-arrow-right>5、調用</h1><pre><code>@RestControllerpublic class OrderController {    @Autowired    OrderService orderService;    Logger logger = LoggerFactory.getLogger(this.getClass());    @PostMapping("/create_order")    public void createOrder(@RequestBody OrderDTO order) throws MQClientException {        logger.info("接收到訂單數據：{}",order.getCommodityCode());        orderService.createOrder(order);    }}</code></pre><h1 class=pgc-h-arrow-right>6、總結</h1><p>目前已經完成了訂單服務的業務邏輯。我們總結流程如下：</p><p><br></p><div class=pgc-img><img alt="基於RocketMQ分佈式事務 - 完整示例" onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/b3b5d78bc2924cbd8d410df5f6827807><p class=pgc-img-caption></p></div><p><br></p><p>考慮到異常情況，這裡的要點如下：</p><ul><li>第一次調用createOrder，發送事務消息。如果發送失敗，導致報錯，則將異常返回，此時不會涉及到任何數據安全。</li><li>如果事務消息發送成功，但在執行本地事務時發生異常，那麼訂單數據和事務日誌都不會被保存，因為它們是一個本地事務中。</li><li>如果執行完本地事務，但未能及時的返回本地事務狀態或者返回了未知狀態。那麼，會由Broker定時回查事務狀態，然後根據事務日誌表，就可以判斷訂單是否已完成，並寫入到數據庫。</li></ul><p>基於這些要素，我們可以說，已經保證了訂單服務和事務消息的一致性。那麼，接下來就是積分服務如何正確的消費訂單數據並完成相應的業務操作。</p><h1 class=pgc-h-arrow-right>三、積分服務</h1><p>在積分服務中，主要就是消費訂單數據，然後根據訂單內容，給相應用戶增加積分。</p><h1 class=pgc-h-arrow-right>1、積分記錄表</h1><pre><code>CREATE TABLE `t_points` (  `id` bigint(16) NOT NULL COMMENT '主鍵',  `user_id` bigint(16) NOT NULL COMMENT '用戶id',  `order_no` bigint(16) NOT NULL COMMENT '訂單編號',  `points` int(4) NOT NULL COMMENT '積分',  `remarks` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '備註',  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;</code></pre><p>在這裡，我們重點關注order_no字段，它是實現冪等消費的一種選擇。</p><h1 class=pgc-h-arrow-right>2、消費者啟動</h1><pre><code>@Componentpublic class Consumer {    String consumerGroup = "consumer-group";    DefaultMQPushConsumer consumer;    @Autowired    OrderListener orderListener;        @PostConstruct    public void init() throws MQClientException {        consumer = new DefaultMQPushConsumer(consumerGroup);        consumer.setNamesrvAddr("127.0.0.1:9876");        consumer.subscribe("order","*");        consumer.registerMessageListener(orderListener);        consumer.start();    }}</code></pre><p>啟動一個消費者比較簡單，我們指定要消費的 topic 和監聽器就好了。</p><h1 class=pgc-h-arrow-right>3、消費者監聽器</h1><pre><code>@Componentpublic class OrderListener implements MessageListenerConcurrently {    @Autowired    PointsService pointsService;    Logger logger = LoggerFactory.getLogger(this.getClass());    @Override    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext context) {        logger.info("消費者線程監聽到消息。");        try{            for (MessageExt message:list) {                logger.info("開始處理訂單數據，準備增加積分....");                OrderDTO order  = JSONObject.parseObject(message.getBody(), OrderDTO.class);                pointsService.increasePoints(order);            }            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;        }catch (Exception e){            logger.error("處理消費者數據發生異常。{}",e);            return ConsumeConcurrentlyStatus.RECONSUME_LATER;        }    }}</code></pre><p>監聽到消息之後，調用業務服務類處理即可。處理完成則返回CONSUME_SUCCESS以提交，處理失敗則返回RECONSUME_LATER來重試。</p><h1 class=pgc-h-arrow-right>4、增加積分</h1><p>在這裡，主要就是對積分數據入庫。但注意，入庫之前需要先做判斷，來達到冪等性消費。</p><pre><code>@Servicepublic class PointsServiceImpl implements PointsService {    @Autowired    PointsMapper pointsMapper;    Snowflake snowflake = new Snowflake(1,1);    Logger logger = LoggerFactory.getLogger(this.getClass());    @Override    public void increasePoints(OrderDTO order) {		        //入庫之前先查詢，實現冪等        if (pointsMapper.getByOrderNo(order.getOrderNo())&gt;0){            logger.info("積分添加完成，訂單已處理。{}",order.getOrderNo());        }else{            Points points = new Points();            points.setId(snowflake.nextId());            points.setUserId(order.getUserId());            points.setOrderNo(order.getOrderNo());            Double amount = order.getAmount();            points.setPoints(amount.intValue()*10);            points.setRemarks("商品消費共【"+order.getAmount()+"】元，獲得積分"+points.getPoints());            pointsMapper.insert(points);            logger.info("已為訂單號碼{}增加積分。",points.getOrderNo());        }    }}</code></pre><h1 class=pgc-h-arrow-right>5、冪等性消費</h1><p>實現冪等性消費的方式有很多種，具體怎麼做，根據自己的情況來看。</p><p>比如，在本例中，我們直接將訂單號和積分記錄綁定在同一個表中，在增加積分之前，就可以先查詢此訂單是否已處理過。</p><p>或者，我們也可以額外創建一張表，來記錄訂單的處理情況。</p><p>再者，也可以將這些信息直接放到redis緩存裡，在入庫之前先查詢緩存。</p><p>不管以哪種方式來做，總的思路就是在執行業務前，必須先查詢該消息是否被處理過。那麼這裡就涉及到一個數據主鍵問題，在這個例子中，我們以訂單號為主鍵，也可以用事務ID作主鍵，如果是普通消息的話，我們也可以創建唯一的消息ID作為主鍵。</p><h1 class=pgc-h-arrow-right>6、消費異常</h1><p>我們知道，當消費者處理失敗後會返回 RECONSUME_LATER ，讓消息來重試，默認最多重試16次。</p><p>那，如果真的由於特殊原因，消息一直不能被正確處理，那怎麼辦 ？</p><p>我們考慮兩種方式來解決這個問題。</p><p>第一，在代碼中設置消息重試次數，如果達到指定次數，就發郵件或者短信通知業務方人工介入處理。</p><pre><code>@Componentpublic class OrderListener implements MessageListenerConcurrently {    Logger logger = LoggerFactory.getLogger(this.getClass());    @Override    public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext context) {        logger.info("消費者線程監聽到消息。");        for (MessageExt message:list) {            if (!processor(message)){                return ConsumeConcurrentlyStatus.RECONSUME_LATER;            }        }        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;    }    /**     * 消息處理，第3次處理失敗後，發送郵件通知人工介入     * @param message     * @return     */    private boolean processor(MessageExt message){        String body = new String(message.getBody());        try {            logger.info("消息處理....{}",body);            int k = 1/0;            return true;        }catch (Exception e){            if(message.getReconsumeTimes()&gt;=3){                logger.error("消息重試已達最大次數，將通知業務人員排查問題。{}",message.getMsgId());                sendMail(message);                return true;            }            return false;        }    }}</code></pre><p>第二，等待消息重試最大次數後，進入死信隊列。</p><p>消息重試最大次數默認是16次，我們也可以在消費者端設置這個次數。</p><pre><code>consumer.setMaxReconsumeTimes(3);//設置消息重試最大次數</code></pre><p>死信隊列的主題名稱是 %DLQ% + 消費者組名稱，比如在訂單數據中，我們設置了消費者組名：</p><p>String consumerGroup = "order-consumer-group";</p><p>那麼這個消費者，對應的死信隊列主題名稱就是%DLQ%order-consumer-group</p><p><br></p><div class=pgc-img><img alt="基於RocketMQ分佈式事務 - 完整示例" onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/4fe687e23ea642e2b6a43ccc5513ef89><p class=pgc-img-caption></p></div><p><br></p><p>如上圖，我們還需要點擊TOPIC配置，來修改裡面的 perm 屬性，改為 6 即可。</p><p><br></p><div class=pgc-img><img alt="基於RocketMQ分佈式事務 - 完整示例" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/5ae23a50311f4aee807e009315c46e30><p class=pgc-img-caption></p></div><p><br></p><p>最後就可以通過程序代碼監聽這個主題，來通知人工介入處理或者直接在控制檯查看處理了。通過冪等性消費和對死信消息的處理，基本上就能保證消息一定會被處理。</p><h1 class=pgc-h-arrow-right>四、《RocketMQ技術內幕》中的代碼示例</h1><p>筆者手裡有一本書《RocketMQ技術內幕》，在 9.4 章節有一段分佈式事務的代碼。</p><p>不過，筆者在看了之後，感覺它裡面的流程是有問題的，會造成本地事務的不一致，下面我們就來分析一下。</p><p>在這裡，我們主要是關注書中訂單業務服務類和事務監聽器的流程。</p><p>在書中，訂單下單偽代碼如下：</p><pre><code>public Map createOrder(){    Map result = new HashMap();    //執行下訂單相關的業務流程，例如操作本地數據庫落庫相關代碼    //生成事務消息唯一業務標識，將該業務標識組裝到待發送的消息體中，方便消息端進行冪等消費。    //調用消息客戶端API，發送事務prepare消息。    //返回結果，提交事務    return result;}</code></pre><p>上述是第一步，發送事務消息，接下來需要實現TransactionListener，實現執行本地事務與本地事務回查。</p><pre><code>public class OrderTransactionListenerImpl implements TransactionListener {    @Override    public LocalTransactionState executeLocalTransaction(Message message, Object o) {        //從消息體中獲取業務唯一ID        String bizUniNo = message.getUserProperty("bizUniNo");        //將bizUniNo入庫，表名：t_message_transaction，表結構 bizUniNo（主鍵），業務類型。        return LocalTransactionState.UNKNOW;    }    @Override    public LocalTransactionState checkLocalTransaction(MessageExt message) {        //從消息體中獲取業務唯一ID        String bizUniNo = message.getUserProperty("bizUniNo");        //如果本地事務表(t_message_transaction)存在記錄，則認為提交；如果不存在返回未知。        //如果多次回查還是未查到消息，則回滾。        if (query(bizUniNo)&gt;0){            return LocalTransactionState.COMMIT_MESSAGE;        }else{            return LocalTransactionState.UNKNOW;        }    }    //查詢數據庫是否存在記錄    public int query(String bizUniNo){        //select count(1) from t_message_transaction where biz_uni_no = #{bizUniNo}        return 1;    }}</code></pre><p>上面的代碼是筆者在這本書裡，抄錄出來的，如果是按照這種做法， 實際上是有問題的，我們來分析一下。</p><h1 class=pgc-h-arrow-right>1、下單異常</h1><p>我們看上面的訂單下單的偽代碼，裡面包含兩個操作：訂單入庫和事務消息發送。</p><p>那麼我們繼續思考：</p><ul><li>如果訂單入庫的時候發生異常，這個沒問題，因為事務消息也不會發送；</li><li>如果訂單入庫執行完畢，但發送事務消息報錯。這個也沒問題，訂單數據會回滾；</li><li>如果訂單入庫執行完畢，發送事務消息也沒有報錯。但返回的不是SEND_OK狀態，這個是有問題的。</li></ul><p>因為只有發送事務消息成功，並且發送狀態為SEND_OK，才會執行監聽器中的本地事務，向t_message_transaction表寫入事務日誌。</p><p>那麼就會造成一個現場：本地訂單數據已經入庫，但是由於沒有返回SEND_OK狀態，導致不會執行本地事務中的事務日誌。那麼這條事務消息早晚會被回滾，最後的問題就是用戶下單成功，但沒有增加積分。</p><h1 class=pgc-h-arrow-right>2、本地事務執行異常</h1><p>事實上，第一個問題也可以規避。那就是在發送完事務消息後，再判斷下發送狀態是不是SEND_OK，如果不是的話，就通過拋異常的方式來回滾訂單數據。</p><p>但是，還有第二個問題：</p><p>如果訂單數據和事務消息發送都沒有問題，但是在執行本地事務時，寫入事務日誌時發生異常怎麼辦 ？</p><p>如果是這樣，也會導致本地訂單數據已經入庫，但是事務日誌沒有寫入，在事務狀態回查的時候一直查詢不到此記錄，最後只能回滾事務消息。最後的現象同樣是用戶下單成功，但沒有增加積分。</p><p>但是在書中，作者有這樣一段話：</p><blockquote><p>executeLocalTransaction，該方法主要設置本地事務狀態，與業務代碼在一個事務中。例如在OrderService#createOrder中，只要本地事務提交成功，該方法也會提交成功。故在這裡，主要是向t_message_transaction添加一條記錄，在事務回查時，如果存在記錄，就認為該消息需要提交。</p></blockquote><p>作者這段話的意思，我理解是說他們都處於一個本地事務中。如果createOrder方法執行成功，則executeLocalTransaction方法也會執行成功；如果任何一方出錯，都會回滾事務。</p><p>但是，我們從源碼中分析的話，如果本地事務執行報錯，訂單數據是不會回滾的。</p><h1 class=pgc-h-arrow-right>3、源碼分析</h1><p>首先，我們要知道，executeLocalTransaction方法和createOrder方法確實在一個事務裡。</p><p>這是因為executeLocalTransaction方法，是在發送事務消息之後，同步調用到的，所以它們在一個事務裡。</p><p>我們來看源碼中，事務消息發送的過程：</p><pre><code>public TransactionSendResult sendMessageInTransaction(Message msg,                         LocalTransactionExecuter localTransactionExecuter,                         Object arg)throws MQClientException {	    //發送事務消息返回結果    SendResult sendResult = null;    //如果發送消息失敗，拋出異常    try {    	sendResult = this.send(msg);    } catch (Exception var11) {    	throw new MQClientException("send message Exception", var11);    }    //初始化本地事務狀態：未知狀態    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;    Throwable localException = null;    switch(sendResult.getSendStatus()) {    //如果發送事務消息狀態為send_ok    case SEND_OK:        try {            //執行本地事務方法            if (transactionListener != null) {                this.log.debug("Used new transaction API");                localTransactionState = transactionListener.executeLocalTransaction(msg, arg);            }        } catch (Throwable var10) {            this.log.info("executeLocalTransactionBranch exception", var10);            this.log.info(msg.toString());            localException = var10;        }        break;	//如果發送事務狀態不是send_ok,該事務消息會被回滾	case FLUSH_DISK_TIMEOUT:	case FLUSH_SLAVE_TIMEOUT:	case SLAVE_NOT_AVAILABLE:	    localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;	}	//結束事務，就是根據本地事務狀態，執行提交、回滾或暫不處理事務	try {	    this.endTransaction(sendResult, localTransactionState, localException);	} catch (Exception var9) {	    this.log.warn("", var9);	}    TransactionSendResult transactionSendResult = new TransactionSendResult();    transactionSendResult.setSendStatus(sendResult.getSendStatus());    transactionSendResult.setMessageQueue(sendResult.getMessageQueue());    transactionSendResult.setMsgId(sendResult.getMsgId());    transactionSendResult.setQueueOffset(sendResult.getQueueOffset());    transactionSendResult.setTransactionId(sendResult.getTransactionId());    transactionSendResult.setLocalTransactionState(localTransactionState);    return transactionSendResult;}</code></pre><p>上面的代碼，就是發送事務消息的過程。我們重點來看，如果事務消息發送成功，並且返回狀態為SEND_OK，那麼就去執行監聽器中的executeLocalTransaction方法，這說明它們在一個事務中。</p><p>但是，在執行過程中，它手動捕獲了 Throwable 異常。這就說明，即便執行本地事務失敗，也不會觸發回滾的。</p><p>至此，我們已經非常明確了，如果按照書裡的流程來寫代碼，這塊就會成為一個隱患點。</p><p>如果想規避這個問題，我們只能修改rocket-client中的代碼，比如：</p><pre><code>try {    //執行本地事務方法    if (transactionListener != null) {        this.log.debug("Used new transaction API");        localTransactionState = transactionListener.executeLocalTransaction(msg, arg);    }} catch (Throwable var10) {    this.log.info("executeLocalTransactionBranch exception", var10);    this.log.info(msg.toString());    localException = var10;    throw new MQClientException(e.getMessage(),e);}   </code></pre><p>筆者通過修改源碼，並測試了一下，通過這種手動拋出異常的方式也是可以的。這樣的話如果執行本地事務的時候出錯，也會回滾訂單數據。</p><p>到這裡，就能回答筆者本文2.4章節裡的一個問題：</p><p>為什麼在訂單業務服務類中，需要有兩個方法。一個用於向RocketMQ發送事務消息，一個用於真正的業務數據落庫。</p><h1 class=pgc-h-arrow-right>總結</h1><p>本文重點闡述了基於RocketMQ來實現最終一致性的分佈式事務案例。</p><p>另外，也分享了關於《RocketMQ技術內幕》一書中，分佈式事務示例代碼，可能出現的異常問題。關於這一點，也希望朋友們如果有不同看法，積極留言，共同交流。</p><p class=pgc-end-literature><br>作者：清幽之地<br>鏈接：https://juejin.im/post/5e737d155188254943200ed0<br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>示例</a></li><li><a>RocketMQ</a></li><li><a>事務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/15b0178.html alt=一定能看懂的RocketMQ事務消息源碼介紹(乾貨) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9893da5524c1439f8a11cb24322c57a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15b0178.html title=一定能看懂的RocketMQ事務消息源碼介紹(乾貨)>一定能看懂的RocketMQ事務消息源碼介紹(乾貨)</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/720ab20.html alt=MySQL事務管理的介紹（附示例） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/720ab20.html title=MySQL事務管理的介紹（附示例）>MySQL事務管理的介紹（附示例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html alt=Mysql事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html title=Mysql事務>Mysql事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html alt=SpringBoot事務詳細簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html title=SpringBoot事務詳細簡介>SpringBoot事務詳細簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html alt=SqlServer使用事務注意事項，高級程序員必背 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html title=SqlServer使用事務注意事項，高級程序員必背>SqlServer使用事務注意事項，高級程序員必背</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>