<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>遺傳算法(Python) #2 基本運算方法詳解 | 极客快訊</title><meta property="og:title" content="遺傳算法(Python) #2 基本運算方法詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/c3dcdafb8df8476dbc472615f3131b59"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/60f30bd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/60f30bd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/60f30bd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/60f30bd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/60f30bd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/60f30bd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/60f30bd.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/60f30bd.html><meta property="article:published_time" content="2020-10-29T20:46:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:33+08:00"><meta name=Keywords content><meta name=description content="遺傳算法(Python) #2 基本運算方法詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/60f30bd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>遺傳算法(Python) #2 基本運算方法詳解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><p><a class=pgc-link data-content=mp href=https://www.toutiao.com/item/6821767056489185796/ rel="noopener noreferrer" target=_blank>上一期</a></p><h2 class=pgc-h-arrow-right>1.遺傳算法主要流程</h2><p>用遺傳算法來解決最優化問題的解的基本如下流程如下：</p><p><br></p><div class=pgc-img><img alt="遺傳算法(Python) #2 基本運算方法詳解" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c3dcdafb8df8476dbc472615f3131b59><p class=pgc-img-caption></p></div><p><br></p><p>流程簡介：</p><ol start=1><li>定義種群與個體：遺傳算法中每個個體即為問題的解，一般個體按照一定方法隨機生成。</li><li>定義個體與種群的適應度函數：個體的適應度函數可以用於選擇個體，而種群的適應度函數可以用來追蹤算法的進度。</li><li>循環選擇、雜交、突變與適應度計算：這一系列操作可以生成下一代的個體選擇：一般而言以更大的概率選擇適應度更高的個體雜交：交換不同個體之間的基因突變：隨機在個體的基因中產生突變計算該世代的適應度：每個世代的總/平均適應度或適應度的方差等可以用來追蹤算法的進度。</li><li>檢測終止條件：若滿足終止條件，則停止迭代</li><li>獲得最優解：一般選擇適應度最高的個體作為解</li></ol><p>之後本文將對每一步的具體做法做出詳細說明。</p><h2 class=pgc-h-arrow-right>2. 定義種群與個體</h2><h3 class=pgc-h-arrow-right>1. 定義個體</h3><p>因為每個個體都由一系列基因組成，所以一般而言可以將個體定義為一個列表(List)。當然，也可以將個體定義為一個字典（Dictionary）或類（Class），從而運用更多python中的方法。具體問題需要具體分析。若使用專門的遺傳算法框架（如DEAP, Pybrain等），則可使用框架內提供方法，一般而言利用框架可以極大的減少代碼量。</p><h3 class=pgc-h-arrow-right>2. 定義種群</h3><p>一系列個體可以構成種群，所以一般可以將種群定義為由所有個體組成的列表。 當然，你可以進一步將該列表封裝成一個類，或使用遺傳算法的框架來定義。</p><h2 class=pgc-h-arrow-right>3. 定義種群與個體的適應度函數</h2><h3 class=pgc-h-arrow-right>1. 個體的適應度函數</h3><p>通過適應度函數，我們可以計算每個個體的適應值，並用於個體的選擇（Select）.一般而言取最大值，但如果某個問題時需要求最小值，我們給適應度函數乘以-1。</p><h3 class=pgc-h-arrow-right>2. 種群的適應度函數</h3><p>種群的適應度函數可以用來追蹤遺傳算法的進度，比如當種群的適應度函數在100次迭代中都沒有明顯的變化，我們可以認為該種群已經不再進化，可以停止迭代過程。一般而言，我們可以定義種群的適應度函數為所有個體的最大值、平均值、方差等。</p><h2 class=pgc-h-arrow-right>4. 循環進行選擇，雜交、突變與適應度計算</h2><h3 class=pgc-h-arrow-right>1. 選擇(Selection)</h3><p>每次迭代中，我們一般以更高的概率選擇適應度更高的個體.假如我們的種群中有以下五個個體：</p><ul><li>個體A：適應度 20，佔比 38.5%</li><li>個體B: 適應度 15，佔比 28.8%</li><li>個體C：適應度 10，佔比 19.2%</li><li>個體D：適應度 5，佔比 9.6%</li><li>個體E：適應度 2，佔比 3.8%</li></ul><p>主要的選擇方法如下：</p><h4 class=pgc-h-arrow-right>1.錦標賽法 (Rank-Based Selection)</h4><p>如字面意思一樣，錦標賽法就是從種群的n個個體中隨機抽取k個個體，並按照錦標賽的方法選擇出適應度更高的個體：</p><ul><li>方法一：從種群的n個個體中隨機抽取k個個體，直接選擇適應度最高的個體。無需真正讓個體兩兩之間進行一輪一輪的錦標賽，因為適應度最高的個體必將勝出。</li><li>方法二：從種群的n個個體中隨機抽取k個個體，進行兩兩錦標賽，並按概率選擇排名靠前的j個個體。（j &lt; k &lt; n）</li></ul><p>以ABCDE組成的種群為例，假設在一次錦標賽中我們隨機抽取了BDE三個個體：</p><ul><li>方法一：因為B的適應度最高，所以我們直接選擇B</li><li>方法二：假設我們以更高的概率選取錦標賽中的前兩名第一輪：B與D進行錦標賽，B勝出第二輪：E輪空，直接進入決賽第三輪：B與E進行錦標賽，B第一名，E第二名（雖然E的適應度比D還要小）最後，我們可以0.9的概率選擇B，並以0.1的概率選擇E。</li></ul><p>通過比較方法一與方法二可見，按照方法二進行錦標賽可以增加一些隨機性，從而降低算法提前收斂的概率。</p><h4 class=pgc-h-arrow-right>2.輪盤法(Roulette Wheel selection)</h4><p>輪盤法就是按照適應度比例隨機選取個體，示意圖如下：</p><p><br></p><div class=pgc-img><img alt="遺傳算法(Python) #2 基本運算方法詳解" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/ca40e0402cea45a5980e60b7e1542f77><p class=pgc-img-caption></p></div><p><br></p><p>假設選擇點如圖所示，我們可以轉動轉盤，並選擇選擇點所指向的個體，為了保持種群大小不變，我們可以轉動轉盤五次並隨機選擇五個對應的個體。</p><h4 class=pgc-h-arrow-right>3.隨機普遍取樣法（Stochastic Universal Sampling）</h4><p>如圖所示，雖然仍然使用同樣的輪盤，但我們只旋轉輪盤一次，取等距的五個選擇點，並選擇對應的個體，與普通的輪盤法相比，隨機普遍採樣可以增加適應度較低的個體被選中的概率，從而增加種群的多樣性。</p><p><br></p><div class=pgc-img><img alt="遺傳算法(Python) #2 基本運算方法詳解" onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/9d83477c8fcb4cfcbd1c5bf6c87d55e5><p class=pgc-img-caption></p></div><p><br></p><h4 class=pgc-h-arrow-right>4.排名法(Rank-Based Selection)</h4><p>排名法仍然用輪盤法或隨機普遍取樣法來選取個體，但區別是排名法用個體的適應度排名排名來計算被選擇的概率，而不是適應度本身，示意圖如下：</p><p><br></p><div class=pgc-img><img alt="遺傳算法(Python) #2 基本運算方法詳解" onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/2cf5dc63ab31466f8aa6e3c7d30f725f><p class=pgc-img-caption></p></div><p><br></p><p>假設有五個個體VWXYZ(如上圖)，其適應度，適應度佔比，排名，排名（由小到大）佔比為</p><ol start=1><li>個體 V: 適應度 50，佔比 61.7%;排名5，排名佔比 33.3%</li><li>個體 W: 適應度 10，佔比 12.3%;排名4，排名佔比 26.7%</li><li>個體 X: 適應度 8，佔比 9.9%;排名3，排名佔比 20.0%</li><li>個體 Y: 適應度 7，佔比 8.6%;排名2，排名佔比 13.3%</li><li>個體 Z: 適應度 6，佔比 7.4%;排名1，排名佔比 6.7%</li></ol><p>由上圖比較可以看出，當不同個體之間的適應度差異較大時，使用排名法可以讓適應度小的個體更容易被選中，某些情況下使用排名法更恰當。</p><h4 class=pgc-h-arrow-right>5.適應度的線性變換</h4><p>與排名法類似，有時直接用適應度選擇會導致適應度高的個體太容易被選中，而適應度低的個體不容易被選中，若遇到這樣的情況，我們可對適應度進行線性變化，從而讓適應度低的個體更容易被選中，選擇時，我們同樣可以採取輪盤法或隨機普遍採樣法：</p><p><br></p><div class=pgc-img><img alt="遺傳算法(Python) #2 基本運算方法詳解" onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/a27c2a24846449478d250645635ecbee><p class=pgc-img-caption></p></div><p><br></p><p>假設有五個個體VWXYZ(如上圖)，為了讓適應度低的個體更容易被選中，我們對適應度進行以下線性變換： 新適應度 = 0.5 * 原適應度 + 10</p><p>其適應度，適應度佔比，變換後適應度，變換後適應度佔比分別為</p><ol start=1><li>個體 V: 適應度50，佔比61.7%;適應度35，適應度佔比 38.7%</li><li>個體 W: 適應度10，佔比12.3%;適應度15，適應度佔比 16.6%</li><li>個體 X: 適應度8，佔比9.9%;適應度14，適應度佔比 15.5%</li><li>個體 Y: 適應度7，佔比8.6%;適應度13.5，適應度佔比 14.9%</li><li>個體 Z: 適應度6，佔比7.4%;適應度13，適應度佔比 14.4%</li></ol><p>可見，通過線性變換，我們可以改變個體被選擇的概率，上述例子裡我們提高了適應度低的個體被選中的概率，按照需求不同，我們也可以降低適應度低的個體被選擇的概率。</p><h4 class=pgc-h-arrow-right>6.精英策略(Elitism)</h4><p>精英策略就是每次迭代中，在種群的n個個體中，選擇適應度最高的k個個體（k 遠小於 n)，不進行雜交或突變而進入下一次迭代。</p><p>雖然一般而言，種群的整體適應度都會向著更高的方向發展，但雜交和突變降低個體的適應度，舉一個直觀的例子，假設適應度對應人的美觀程度，爸媽是帥哥美女，但生出來一個醜孩子的情況雖然少，但也可能發生。為了防止這樣的情況發生，我們可以保留（或克隆）適應度高的個體，不進行雜交和突變，直接進入下一次的迭代。</p><h3 class=pgc-h-arrow-right>2. 雜交(Crossover)</h3><p>遺傳算法中的雜交類似於自然界中的雜交： 親代相互交換遺傳物質（基因組/染色體片段）併產生後代。在遺傳算法中，為了保持種群數量不變，親代雜交一般產生兩個後代。</p><h4 class=pgc-h-arrow-right>1.單點雜交(Single-Point Crossover)</h4><p>單點雜交即在基因組中隨機選取一點，親代在該點之後的基因進行交換。</p><p>若個體的基因組由二進制字符串來表示，如下所示，上下兩個親代（左）進行雜交併產生兩個後代（右）,其中“|”代表雜交點：</p><ul><li>親代1：1001|1111 -> 後代1：1001|0000</li><li>親代2：1000|0000 -> 後代2：1000|1111</li></ul><h4 class=pgc-h-arrow-right>2.兩點雜交（Two-Point Crossover）</h4><p>兩點雜交即在基因組中隨機選取兩點，親代兩點之間的基因進行交換。</p><p>若個體的基因組由二進制字符串來表示，如下所示，上下兩個親代（左）進行雜交併產生兩個後代（右）,其中“|”代表雜交點：</p><ul><li>親代1：1001|11|11 -> 後代1：1001|00|11</li><li>親代2：1000|00|00 -> 後代2：1000|11|00</li></ul><h4 class=pgc-h-arrow-right>3.多點雜交（k-Point Crossover）</h4><p>多點雜交即在基因組中隨機選取k個點，親代在k個點所組成的片段之間交換基因。</p><p>若個體的基因組由二進制字符串來表示，如下所示，上下兩個親代（左）進行雜交併產生兩個後代（右）,其中“|”代表雜交點,親代交換第1、2和3、4個雜交點之間的基因：</p><ul><li>親代1：100|11|1|1|1 -> 後代1：100|00|1|0|1</li><li>親代2：100|00|0|0|0 -> 後代2：100|11|0|1|0</li></ul><h4 class=pgc-h-arrow-right>4.均勻雜交（Uniform Crossover）</h4><p>均勻雜交即基因組的每個基因都以p的概率進行雜交(0&lt;p&lt;1)，p的概率越高，則雜交概率越高。</p><p>若基因組中每個基因用數字0~9來表示，並且p取50%，則每個基因都有50%的概率進行雜交，示意圖如下(假設第1，3，5個基因進行了雜交)：</p><ul><li>親代1：123456 -> 後代1：624426</li><li>親代2：654321 -> 後代2：153351</li></ul><h4 class=pgc-h-arrow-right>5.有序雜交（Ordered Crossover）</h4><p>根據定義不同，假如基因用有序序列來表示，為了儘量不改變親代中原有順序，可用以下方式來進行雜交,其中“|”代表突變點，“*”代表待確定的基因：</p><ol start=1><li>隨機選取兩個突變點，並交換突變點之間的基因，突變點外的基因待定：</li></ol><ul><li>親代1：1|23|45 -> 後代1：*|31|**</li><li>親代2：2|31|54 -> 後代2：*|23|**</li></ul><ol start=2><li>以親代1為後代1的藍圖，逐一確定*位置的基因：</li></ol><ul><li>從親代1的突變點後一位開始，4不存在於後代1中，將4填入後代1突變點後第一個位置，後代1變為：*|31|4*</li><li>親代1中4的下一位是5，5不存在於後代1中，將5填入後代1，後代1變為：*|31|45</li><li>親代1中5的下一位是1，1已存在於後代1中，跳過</li><li>親代1中1的下一位是2，2不存在於後代1中，將1填入後代1，後代1變為：2|31|45</li></ul><ol start=3><li>以親代2為後代2的藍圖，逐一確定*位置的基因：</li></ol><ul><li>從親代2的突變點後一位開始，5不存在於後代2中，將5填入後代2突變點後第一個位置，後代2變為：*|23|5*</li><li>親代2中5的下一位是4，4不存在於後代2中，將4填入後代2，後代2變為：*|23|54</li><li>親代2中4的下一位是2，2已存在於後代2中，跳過</li><li>親代2中2的下一位是3，3已存在於後代2中，跳過</li><li>親代2中3的下一位是1，1不存在於後代2中，將1填入後代2，後代2變為：1|23|54</li></ul><p>通過以上方法，可以在雜交的同時保持親代基因的順序，這種雜交方法可以用於某些特定的問題，比如旅行推銷員問題(Travelling Salesman Problem)。</p><h4 class=pgc-h-arrow-right>6. 混合雜交(Blend Crossover)</h4><p>假設個體的基因組用實數表示，直接交換對應基因上的數字意義不大，這個時候我們可以用混合雜交法，即後代的基因隨機取值於由親代基因構成的範圍之內，而這個範圍是：</p><p>[p1 - a(p2-p1),p2+a(p2-p1)]</p><ul><li>其中p1,p2分別代表親代中對應基因的數值（p1 &lt; p2）</li><li>a是一個常數（遺傳算法中一般取a=0.5）</li></ul><p>不難發現，該公式有以下性質：</p><ol start=1><li>a=0時，後代基因的取值範圍是[p1,p2]，即後代基因的取值範圍不可能超過親代。</li><li>a=0.5時，後代基因的取值範圍是[1.5p1 - 0.5p2,-0.5p1 + 1.5p2]，該範圍的大小是2(p2-p1),為a=0時的兩倍</li><li>a=1時，後代基因的取值範圍是[2p1 - p2,-p1 + 2p2],該範圍大小是3(p2-p1),為a=0時的三倍</li></ol><p>假設我們有以下兩個個體，並且a=0.5：</p><ul><li>親代1： [10.0, 5.0 , 8.0]</li><li>親代2： [2.0 , 12.0, 6.0]</li></ul><p>套用公式：[p1 - a(p2-p1),p2+a(p2-p1)]，則雜交產生的後代每個基因的取值範圍分別是：</p><ul><li>基因1：[-2.0, 14.0]</li><li>基因2：[1.5 , 15.5]</li><li>基因3：[5.0 , 9.0]</li></ul><h4 class=pgc-h-arrow-right>7. 模擬二進制雜交(Simulated Binary Crossover)</h4><p>當個體基因由實數表示時，模擬二進制雜交借用了單點雜交（Single-Point Crossover）的概念，其目的是模擬單點雜交中後代基因的均值與親代相同的這一性質，後代的基因數值可由以下公式求得：</p><ul><li>o1 = 0.5( (1+a)p1 + (1-a)p2)</li><li>o2 = 0.5( (1-a)p1 + (1+a)p2)</li></ul><p>其中：</p><ul><li>o1,o2表示後代1與後代2基因的數值</li><li>p1,p2表示親代1與親代2基因的數值</li><li>a為常數，且 a >= 0</li></ul><p>不難發現該公式有以下性質：</p><ol start=1><li>後代基因的均值永遠和親代相同</li><li>a=0時，o1 = o2 = 0.5(p1 + p2),後代基因為親代基因的均值</li><li>0 &lt; a &lt; 1時，相對親代而言，後代之間基因的值更加接近</li><li>a = 1時，o1 = p1, o2 = p2， 後代與親代相同</li><li>a > 1時，相對親代而言，後代之間的基因值差異更大</li></ol><h3 class=pgc-h-arrow-right>3. 突變(Mutation)</h3><p>與生物學中突變的概念類似，遺傳算法中的突變即個體的基因發生隨機的改變，而突變主要有以下方法， 不同的突變方法適用於不同的具體問題。</p><h4 class=pgc-h-arrow-right>1. 位翻轉突變法(Flip Bit Mutation)</h4><p>位反轉突變即染色體上的一個或多個位置發生隨機的改變，如：</p><p>10001 -> 11001， 第二個位置的0突變為1。</p><h4 class=pgc-h-arrow-right>2. 交換突變法(Swap Mutation)</h4><p>交換突變即染色體上隨機的兩個基因位置交換，如：</p><p>12345 -> 52341， 第一個和最後一個基因交換。</p><h4 class=pgc-h-arrow-right>3. 反轉突變法(Inversion Mutation)</h4><p>反轉突變即染色體上的一段基因順序逆轉，如：</p><p>123456 -> 126543， 第二至第六個位置發生反轉突變。</p><h4 class=pgc-h-arrow-right>4. 隨機打亂突變法(Scramble Mutation)</h4><p>隨機打亂突變即染色體上的一段基因順序被打亂後重組，如：</p><p>123456 -> 126345， 第二至第六個位置的基因被打亂後重組。</p><h4 class=pgc-h-arrow-right>5. 實數突變法(Real Mutation)</h4><p>當個體的基因用實數表達時，可使用實數突變法來產生變異。</p><p>其具體方法是，我們首先人為規定一個能產生隨機數的函數（一般取正態分佈函數，且一般均值取0以保證突變方向的隨機性，而標準差可以依問題而定）。突變後基因的值 = 突變前基因的值 + 隨機數。</p><p><br></p><div class=pgc-img><img alt="遺傳算法(Python) #2 基本運算方法詳解" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/0e807026c8d1479f9db0c9428ece37e9><p class=pgc-img-caption></p></div><p><br></p><h3 class=pgc-h-arrow-right>4. 重新計算個體與種群的適應度(Evaluation)</h3><p>每當一次迭代結束時（已經完成選擇，雜交和突變），我們都應該計算並儲存個體與種群的適應度，這些數據有利於我們追蹤基因算法的進度，並判斷算法是否應該中止。若實時追蹤每次迭代後的種群的適應度，我們還可以判斷我們的算法是否出現了問題，及時停止迭代並對算法做出修正。</p><h2 class=pgc-h-arrow-right>5. 定義算法的終止條件(Stopping Condition)</h2><p>一個算法一般而言不會無限的運行下去，我們需要定義一些條件來判斷算法是否需要被終止，常見的終止條件如下：</p><ol start=1><li>按照時間來決定是否終止：從程序開始運行時已經過一定時間，或已經迭代一定次數。</li><li>按照成本來決定是否終止：迭代到一定次數時是否已消耗一定的CPU，內存或硬盤儲存空間。</li><li>按種群性質來決定是否終止：種群是否已經喪失多樣性，停止進化，種群適應度是否已經無顯著提高。</li></ol><h2 class=pgc-h-arrow-right>6. 獲得最優解</h2><p>一般而言，當迭代結束時，適應度最高的個體即為最優解。然而，在迭代中最優的個體可能因為雜交或突變而在某一時刻丟失，為了防止這樣的情況發生，我們可以創建一個列表來儲存每次迭代中的最優個體，並在迭代結束後從中選擇適應度最高的個體作為解。</p><h2 class=pgc-h-arrow-right>7. 小結</h2><p>本文章介紹了遺傳算法中如何定義個體與種群，如何進行選擇、雜交、突變與適應度的計算，本系列的下一篇文章中我們將不依靠任何已有的框架，用Python來實現遺傳算法在OneMax問題中的應用。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>遺傳</a></li><li><a>Python</a></li><li><a>運算</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html alt=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/dfic-imagehandler/f1d21356-1ef5-4ec5-a4a5-c5699b12bee1 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html title=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題>Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html alt=Python中的遺傳算法完整實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1531731137721602bd9c18c style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html title=Python中的遺傳算法完整實現>Python中的遺傳算法完整實現</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html alt=一文讀懂遺傳算法工作原理！附Python實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/fde5cfc48c5a45d4891d621c7b4cc5e4 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html title=一文讀懂遺傳算法工作原理！附Python實現>一文讀懂遺傳算法工作原理！附Python實現</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html alt=基於Python的遺傳算法特徵約簡（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/4cf33c81f091401a93c3d1b5db2213de style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html title=基於Python的遺傳算法特徵約簡（附代碼）>基於Python的遺傳算法特徵約簡（附代碼）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html alt="遺傳算法(Python) #3 從零開始解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/5d69e28f41a44f81b8dd0bbe9f2f2b6f style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html title="遺傳算法(Python) #3 從零開始解決OneMax問題">遺傳算法(Python) #3 從零開始解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html alt="遺傳算法(Python) #5 用DEAP框架解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/3279ffb8082c491a967c683ae24bdfcb style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html title="遺傳算法(Python) #5 用DEAP框架解決OneMax問題">遺傳算法(Python) #5 用DEAP框架解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html alt=遺傳算法綜合指南（以及如何Python編碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/15354276244373403483b2e style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html title=遺傳算法綜合指南（以及如何Python編碼）>遺傳算法綜合指南（以及如何Python編碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html alt=Python爬蟲教程，利用Python採集QQ群成員信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d6cce76ad48405c9dbb960d4617bcef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html title=Python爬蟲教程，利用Python採集QQ群成員信息>Python爬蟲教程，利用Python採集QQ群成員信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html alt=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5d4a0000046e1bea8b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html title=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？>Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html alt=Python中的多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49dd44b999924b69bd3396709ecacaf4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html title=Python中的多進程>Python中的多進程</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>