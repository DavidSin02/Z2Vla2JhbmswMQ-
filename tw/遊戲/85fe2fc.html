<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>教你設計一個通用分佈式事務框架 | 极客快訊</title><meta property="og:title" content="教你設計一個通用分佈式事務框架 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p3.pstatp.com/large/pgc-image/b222c462e5a34419bf6d7367e0658bb6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/85fe2fc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/85fe2fc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/85fe2fc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/85fe2fc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/85fe2fc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/85fe2fc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/85fe2fc.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/85fe2fc.html><meta property="article:published_time" content="2020-10-29T20:46:29+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:29+08:00"><meta name=Keywords content><meta name=description content="教你設計一個通用分佈式事務框架"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/85fe2fc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>教你設計一個通用分佈式事務框架</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><div><pre>作者：Eray來源：www.bytesoft.org</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>一個TCC事務框架需要解決的當然是分佈式事務的管理。關於TCC事務機制的介紹，可以參考TCC事務機制簡介。</p><p class=ql-align-justify>TCC事務模型雖然說起來簡單，然而要基於TCC實現一個通用的分佈式事務框架，卻比它看上去要複雜的多，不只是簡單的調用一下Confirm/Cancel業務就可以了的。</p><p class=ql-align-justify>本文將以Spring容器為例，試圖分析一下，實現一個通用的TCC分佈式事務框架需要注意的一些問題。</p><p class=ql-align-justify><strong>一、TCC全局事務必須基於RM本地事務來實現</strong></p><p class=ql-align-justify>TCC服務是由Try/Confirm/Cancel業務構成的，其Try/Confirm/Cancel業務在執行時，會訪問資源管理器（Resource Manager，下文簡稱RM）來存取數據。</p><p class=ql-align-justify>這些存取操作，必須要參與RM本地事務，以使其更改的數據要麼都commit，要麼都rollback。</p><p class=ql-align-justify>這一點不難理解，考慮一下如下場景：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=教你設計一個通用分佈式事務框架 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/b222c462e5a34419bf6d7367e0658bb6><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>假設圖中的服務B沒有基於RM本地事務（以RDBS為例，可通過設置auto-commit為true來模擬），那麼一旦[B:Try]操作中途執行失敗，TCC事務框架後續決定回滾全局事務時，該[B:Cancel]則需要判斷[B:Try]中哪些操作已經寫到DB、哪些操作還沒有寫到DB.</p><p class=ql-align-justify>假設[B:Try]業務有5個寫庫操作，[B:Cancel]業務則需要逐個判斷這5個操作是否生效，並將生效的操作執行反向操作。</p><p class=ql-align-justify>不幸的是，由於[B:Cancel]業務也有n（0&lt;=n&lt;=5）個反向的寫庫操作，此時一旦[B:Cancel]也中途出錯，則後續的[B:Cancel]執行任務更加繁重。</p><p class=ql-align-justify>因為相比第一次[B:Cancel]操作，後續的[B:Cancel]操作還需要判斷先前的[B:Cancel]操作的n（0&lt;=n&lt;=5）個寫庫中哪幾個已經執行、哪幾個還沒有執行.</p><p class=ql-align-justify>這就涉及到了冪等性問題，而對冪等性的保障，又很可能還需要涉及額外的寫庫操作，該寫庫操作又會因為沒有RM本地事務的支持而存在類似問題。。。</p><p class=ql-align-justify>可想而知，如果不基於RM本地事務，TCC事務框架是無法有效的管理TCC全局事務的。</p><p class=ql-align-justify>反之，基於RM本地事務的TCC事務，這種情況則會很容易處理。</p><p class=ql-align-justify>[B:Try]操作中途執行失敗，TCC事務框架將其參與RM本地事務直接rollback即可。後續TCC事務框架決定回滾全局事務時，在知道“[B:Try]操作涉及的RM本地事務已經rollback”的情況下，根本無需執行[B:Cancel]操作。</p><p class=ql-align-justify>換句話說，基於RM本地事務實現TCC事務框架時，一個TCC型服務的cancel業務要麼執行，要麼不執行，不需要考慮部分執行的情況。</p><p class=ql-align-justify><strong>二、TCC事務框架應該接管Spring容器的TransactionManager</strong></p><p class=ql-align-justify>基於RM本地事務的TCC事務框架，可以將各Try/Confirm/Cancel業務看成一個原子服務：一個RM本地事務提交，參與該RM本地事務的所有Try/Confirm/Cancel業務操作都生效；反之，則都不生效。</p><p class=ql-align-justify>掌握每個RM本地事務的狀態以及它們與Try/Confirm/Cancel業務方法之間的對應關係，以此為基礎，TCC事務框架才能有效的構建TCC全局事務。</p><p class=ql-align-justify>TCC服務的Try/Confirm/Cancel業務方法在RM上的數據存取操作，其RM本地事務是由Spring容器的PlatformTransactionManager來commit/rollback的，TCC事務框架想要了解RM本地事務的狀態，只能通過接管Spring的事務管理器功能。</p><p class=ql-align-justify><strong>2.1. 為什麼TCC事務框架需要掌握RM本地事務的狀態？</strong></p><p class=ql-align-justify>首先，根據TCC機制的定義，TCC事務是通過執行Cancel業務來達到回滾效果的。仔細分析一下，這裡暗含一個事實：只有生效的Try業務操作才需要執行對應的Cancel業務操作。</p><p class=ql-align-justify>換句話說，只有Try業務操作所參與的RM本地事務被commit了，後續TCC全局事務回滾時才需要執行其對應的Cancel業務操作</p><p class=ql-align-justify>否則，如果Try業務操作所參與的RM本地事務被rollback了，後續TCC全局事務回滾時就不能執行其Cancel業務，此時若盲目執行Cancel業務反而會導致數據不一致。</p><p class=ql-align-justify>其次，Confirm/Cancel業務操作必須保證生效。Confirm/Cancel業務操作也會涉及RM數據存取操作，其參與的RM本地事務也必須被commit。</p><p class=ql-align-justify>TCC事務框架需要在確切的知道所有Confirm/Cancel業務操作參與的RM本地事務都被成功commit後，才能將標記該TCC全局事務為完成。</p><p class=ql-align-justify>如果TCC事務框架誤判了Confirm/Cancel業務參與RM本地事務的狀態，就會造成全局事務不一致。</p><p class=ql-align-justify>最後，未完成的TCC全局，TCC事務框架必須重新嘗試提交/回滾操作。重試時會再次調用各TCC服務的Confirm/Cancel業務操作。</p><p class=ql-align-justify>如果某個服務的Confirm/Cancel業務之前已經生效（其參與的RM本地事務已經提交），重試時就不應該再次被調用。否則，其Confirm/Cancel業務被多次調用，就會有“服務冪等性”的問題。</p><p class=ql-align-justify><strong>2.2. 攔截TCC服務的Try/Confirm/Cancel業務方法的執行，根據其異常信息可否知道其RM本地事務是否commit/rollback了呢？</strong></p><p class=ql-align-justify>基本上很難做到，為什麼這麼說？</p><p class=ql-align-justify><strong>第一</strong>，事務是可以在多個（本地/遠程）服務之間互相傳播其事務上下文的，一個業務方法（Try/Confirm/Cancel）執行完畢並不一定會觸發當前事務的commit/rollback操作。</p><p class=ql-align-justify>比如，被傳播事務上下文的業務方法，在它開始執行時，容器並不會為其創建新的事務，而是它的調用方參與的事務，使得二者操作在同一個事務中；同樣，在它執行完畢時，容器也不會提交/回滾它參與的事務的。</p><p class=ql-align-justify>因此，這類業務方法上的異常情況並不能反映他們是否生效。不接管Spring的TransactionManager，就無法瞭解事務於何時被創建，也無法瞭解它於何時被提交/回滾。</p><p class=ql-align-justify><strong>第二</strong>、一個業務方法可能會包含多個RM本地事務的情況。</p><p class=ql-align-justify>比如：A(REQUIRED)->B(REQUIRES_NEW)->C(REQUIRED)，這種情況下，A服務所參與的RM本地事務被提交時，B服務和C服務參與的RM本地事務則可能會被回滾。</p><p class=ql-align-justify><strong>第三</strong>、並不是拋出了異常的業務方法，其參與的事務就回滾了。</p><p class=ql-align-justify>Spring容器的聲明式事務定義了兩類異常，其事務完成方向都不一樣：系統異常（一般為Unchecked異常，默認事務完成方向是rollback）、應用異常（一般為Checked異常，默認事務完成方向是commit）。</p><p class=ql-align-justify>二者的事務完成方向又可以通過@Transactional配置顯式的指定，如rollbackFor/noRollbackFor等。</p><p class=ql-align-justify><strong>第四</strong>、Spring容器還支持使用setRollbackOnly的方式顯式的控制事務完成方向；</p><p class=ql-align-justify>最後，自行攔截業務方法的攔截器和Spring的事務處理的攔截器還會存在執行先後、攔截範圍不同等問題。</p><p class=ql-align-justify>例如，如果自行攔截器執行在前，就會出現業務方法雖然已經執行完畢但此時其參與的RM本地事務還沒有commit/rollback。</p><p class=ql-align-justify>TCC事務框架的定位應該是一個TransactionManager，其職責是負責commit/rollback事務。</p><p class=ql-align-justify>而一個事務應該commit、還是rollback，則應該是由Spring容器來決定的：</p><p class=ql-align-justify>Spring決定提交事務時，會調用TransactionManager來完成commit操作；Spring決定回滾事務時，會調用TransactionManager來完成rollback操作。</p><p class=ql-align-justify>接管Spring容器的TransactionManager，TCC事務框架可以明確的得到Spring的事務性指令，並管理Spring容器中各服務的RM本地事務。</p><p class=ql-align-justify>否則，如果通過自行攔截的機制，則使得業務系統存在TCC事務處理、RM本地事務處理兩套事務處理邏輯，二者互不通信，各行其是。</p><p class=ql-align-justify>這種情況下要協調TCC全局事務，基本上可以說是緣木求魚，本地事務尚且無法管理，更何談管理分佈式事務？</p><p class=ql-align-justify><strong>三、TCC事務框架應該具備故障恢復機制</strong></p><p class=ql-align-justify>一個TCC事務框架，若是沒有故障恢復的保障，是不成其為分佈式事務框架的。</p><p class=ql-align-justify>分佈式事務管理框架的職責，不是做出全局事務提交/回滾的指令，而是管理全局事務提交/回滾的過程。</p><p class=ql-align-justify>它需要能夠協調多個RM資源、多個節點的分支事務，保證它們按全局事務的完成方向各自完成自己的分支事務。</p><p class=ql-align-justify>這一點，是不容易做到的。因為，實際應用中，會有各種故障出現，很多都會造成事務的中斷，從而使得統一提交/回滾全局事務的目標不能達到，甚至出現”一部分分支事務已經提交，而另一部分分支事務則已回滾”的情況。</p><p class=ql-align-justify>比較常見的故障，比如：業務系統服務器宕機、重啟；數據庫服務器宕機、重啟；網絡故障；斷電等。這些故障可能單獨發生，也可能會同時發生。</p><p class=ql-align-justify>作為分佈式事務框架，應該具備相應的故障恢復機制，無視這些故障的影響是不負責任的做法。</p><p class=ql-align-justify>一個完整的分佈式事務框架，應該保障即使在最嚴苛的條件下也能保證全局事務的一致性，而不是只能在最理想的環境下才能提供這種保障。退一步說，如果能有所謂“理想的環境”，那也無需使用分佈式事務了。</p><p class=ql-align-justify>TCC事務框架要支持故障恢復，就必須記錄相應的事務日誌。事務日誌是故障恢復的基礎和前提，它記錄了事務的各項數據。</p><p class=ql-align-justify>TCC事務框架做故障恢復時，可以根據事務日誌的數據將中斷的事務恢復至正確的狀態，並在此基礎上繼續執行先前未完成的提交/回滾操作。</p><p class=ql-align-justify><strong>四、TCC事務框架應該提供Confirm/Cancel服務的冪等性保障</strong></p><p class=ql-align-justify>一般認為，服務的冪等性，是指針對同一個服務的多次(n>1)請求和對它的單次(n=1)請求，二者具有相同的副作用。</p><p class=ql-align-justify>在TCC事務模型中，Confirm/Cancel業務可能會被重複調用，其原因很多。</p><p class=ql-align-justify>比如，全局事務在提交/回滾時會調用各TCC服務的Confirm/Cancel業務邏輯。執行這些Confirm/Cancel業務時，可能會出現如網絡中斷的故障而使得全局事務不能完成。</p><p class=ql-align-justify>因此，故障恢復機制後續仍然會重新提交/回滾這些未完成的全局事務，這樣就會再次調用參與該全局事務的各TCC服務的Confirm/Cancel業務邏輯。</p><p class=ql-align-justify>既然Confirm/Cancel業務可能會被多次調用，就需要保障其冪等性。</p><p class=ql-align-justify>那麼，應該由TCC事務框架來提供冪等性保障？還是應該由業務系統自行來保障冪等性呢？</p><p class=ql-align-justify>個人認為，應該是由TCC事務框架來提供冪等性保障。如果僅僅只是極個別服務存在這個問題的話，那麼由業務系統來負責也是可以的；</p><p class=ql-align-justify>然而，這是一類公共問題，毫無疑問，所有TCC服務的Confirm/Cancel業務存在冪等性問題。TCC服務的公共問題應該由TCC事務框架來解決；</p><p class=ql-align-justify>而且，考慮一下由業務系統來負責冪等性需要考慮的問題，就會發現，這無疑增大了業務系統的複雜度。</p><p class=ql-align-justify><strong>五、TCC事務框架不能盲目的依賴Cancel業務來回滾事務</strong></p><p class=ql-align-justify>前文以及提到過，TCC事務通過Cancel業務來對Try業務進行回撤的機制暗含了一個事實：Try操作已經生效。</p><p class=ql-align-justify>也就是說，只有Try操作所參與的RM本地事務已經提交的情況下，才需要執行其Cancel操作進行回撤。沒有執行、或者執行了但是其RM本地事務被rollback的Try業務，是一定不能執行其Cancel業務進行回撤的。</p><p class=ql-align-justify>因此，TCC事務框架在全局事務回滾時，應該根據TCC服務的Try業務的執行情況選擇合適的處理機制。而不能盲目的執行Cancel業務，否則就會導致數據不一致。</p><p class=ql-align-justify>一個TCC服務的Try操作是否生效，這是TCC事務框架應該知道的，因為其Try業務所參與的RM事務也是由TCC事務框架所commit/rollbac的（前提是TCC事務框架接管了Spring的事務管理器）。</p><p class=ql-align-justify>所以，TCC事務回滾時，TCC事務框架可考慮如下處理策略：</p><ol><li class=ql-align-justify>如果TCC事務框架發現某個服務的Try操作的本地事務尚未提交，應該直接將其回滾，而後就不必再執行該服務的cancel業務；</li><li class=ql-align-justify>如果TCC事務框架發現某個服務的Try操作的本地事務已經回滾，則不必再執行該服務的cancel業務；</li><li class=ql-align-justify>如果TCC事務框架發現某個服務的Try操作尚未被執行過，那麼，也不必再執行該服務的cancel業務。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify>總之，TCC事務框架應該保障：</p><ol><li class=ql-align-justify>已生效的Try操作應該被其Cancel操作所回撤；</li><li class=ql-align-justify>尚未生效的Try操作，則不應該執行其Cancel操作。這一點，不是冪等性所能解決的問題。如上文所述，冪等性是指服務被執行一次和被執行n(n>0)次所產生的影響相同。但是，未被執行和被執行過，二者效果肯定是不一樣的，這不屬於冪等性的範疇。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>六、Cancel業務與Try業務並行，甚至先於Try操作完成</strong></p><p class=ql-align-justify>這應該算TCC事務機制特有的一個不可思議的陷阱。</p><p class=ql-align-justify>一般來說，一個特定的TCC服務，其Try操作的執行，是應該在其Confirm/Cancel操作之前的。</p><p class=ql-align-justify>Try操作執行完畢之後，Spring容器再根據Try操作的執行情況，指示TCC事務框架提交/回滾全局事務。然後，TCC事務框架再去逐個調用各TCC服務的Confirm/Cancel操作。</p><p class=ql-align-justify>然而，超時、網絡故障、服務器的重啟等故障的存在，使得這個順序會被打亂。比如：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=教你設計一個通用分佈式事務框架 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/551e4a057e924481b919613355cf24d2><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>上圖中，假設[B:Try]操作執行過程中，網絡閃斷，[A:Try]會收到一個RPC遠程調用異常。</p><p class=ql-align-justify>A不處理該異常，導致全局事務決定回滾，TCC事務框架就會去調用[B:Cancel]，而此刻A、B之間網絡剛好已經恢復。如果[B:Try]操作耗時較長（網絡阻塞/數據庫操作阻塞），就會出現[B:Try]和[B:Cancel]二者並行處理的現象，甚至[B:Cancel]先完成的現象。</p><p class=ql-align-justify>這種情況下，由於[B:Cancel]執行時，[B:Try]尚未生效（其RM本地事務尚未提交），因此，[B:Cancel]是不能執行的，至少是不能生效（執行了其RM本地事務也要rollback）的。</p><p class=ql-align-justify>然而，當[B:Cancel]處理完畢（跳過執行、或者執行後rollback其RM本地事務）後，[B:Try]操作完成又生效了（其RM本地事務成功提交），這就會使得[B:Cancel]雖然提供了，但卻沒有起到回撤[B:Try]的作用，導致數據的不一致。</p><p class=ql-align-justify>所以，TCC框架在這種情況下，需要：</p><ol><li class=ql-align-justify>將[B:Try]的本地事務標註為rollbackOnly，阻止其後續生效；</li><li class=ql-align-justify>禁止其再次將事務上下文傳遞給其他遠程分支，否則該問題將在其他分支上出現；</li><li class=ql-align-justify>相應地，[B:Cancel]也不必執行，至少不能生效。</li></ol><blockquote>當然，TCC事務框架也可以簡單的選擇阻塞[B:Cancel]的處理，待[B:Try]執行完畢後，再根據它的執行情況判斷是否需要執行[B:Cancel]。不過，這種處理方式因為需要等待，所以，處理效率上會有所不及。</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>同樣的情況也會出現在confirm業務上，只不過，發生在Confirm業務上的處理邏輯與發生在Cancel業務上的處理邏輯會不一樣。</p><p class=ql-align-justify>TCC框架必須保證：</p><ol><li class=ql-align-justify>Confirm業務在Try業務之後執行，若發現並行，則只能阻塞相應的Confirm業務操作；</li><li class=ql-align-justify>在進入Confirm執行階段之後，也不可以再提交同一全局事務內的新的Try操作的RM本地事務。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>七、TCC服務複用性是不是相對較差？</strong></p><p class=ql-align-justify>TCC事務機制的定義，決定了一個服務需要提供三個業務實現：Try業務、Confirm業務、Cancel業務。</p><p class=ql-align-justify>可能會有人因此認為TCC服務的複用性較差。怎麼說呢，要是將 Try/Confirm/Cancel業務邏輯單獨拿出來複用，其複用性當然是不好的。</p><p class=ql-align-justify>Try/Confirm/Cancel 邏輯作為TCC型服務中的一部分，是不能單獨作為一個組件來複用的。Try、Confirm、Cancel業務共同才構成一個組件，如果要複用，應該是複用整個TCC服務組件，而不是單獨的Try/Confirm/Cancel業務。</p><p class=ql-align-justify><strong>八、TCC服務是否需要對外暴露三個服務接口？</strong></p><p class=ql-align-justify>不需要。TCC服務與普通的服務一樣，只需要暴露一個接口，也就是它的Try業務。</p><p class=ql-align-justify>Confirm/Cancel業務邏輯，只是因為全局事務提交/回滾的需要才提供的，因此Confirm/Cancel業務只需要被TCC事務框架發現即可，不需要被調用它的其他業務服務所感知。</p><p class=ql-align-justify>換句話說，業務系統的其他服務在需要調用TCC服務時，根本不需要知道它是否為TCC型服務。</p><p class=ql-align-justify>因為，TCC服務能被其他業務服務調用的也僅僅是其Try業務，Confirm/Cancel業務是不能被其他業務服務直接調用的。</p><p class=ql-align-justify><strong>九、TCC服務A的Confirm/Cancel業務中能否調用它依賴的TCC服務B的Confirm/Cancel業務？</strong></p><p class=ql-align-justify>最好不要這樣做。</p><p class=ql-align-justify>首先，沒有必要。TCC服務A依賴TCC服務B，那麼[A:Try]已經將事務上下文傳播給[B:Try]了，後續由TCC事務框架來調用各自的Confirm/Cancel業務即可；</p><p class=ql-align-justify>其次，Confirm/Cancel業務如果被允許調用其他服務，那麼它就有可能再次發起新的TCC全局事務。如此遞歸下去，將會導致全局事務關係混亂且不可控。</p><p class=ql-align-justify>TCC全局事務，應該儘量在Try操作階段傳播事務上下文。Confirm/Cancel操作階段僅需要完成各自Try業務操作的確認操作/補償操作即可，不適合再做遠程調用，更不能再對外傳播事務上下文。</p><p class=ql-align-justify>綜上所述，本文傾向於認為，實現一個通用的TCC分佈式事務管理框架，還是相對比較複雜的。一般業務系統如果需要使用TCC事務機制，並不推薦自行設計實現。</p><p class=ql-align-justify>這裡，給大家推薦一款開源的TCC分佈式事務管理器ByteTCC</p><p class=ql-align-justify>https://github.com/liuyangming/ByteTCC</p><p class=ql-align-justify>ByteTCC基於Try/Confirm/Cancel機制實現，可與Spring容器無縫集成，兼容Spring的聲明式事務管理。提供對dubbo框架、Spring Cloud的開箱即用的支持，可滿足多數據源、跨應用、跨服務器等各種分佈式事務場景的需求。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>設計</a></li><li><a>一個</a></li><li><a>事務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/09d03a85.html alt=垂直簾創新設計，一個簡單的裝置就可以改變世界 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ebdbcb9549954b97a575d2f13e13de62 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09d03a85.html title=垂直簾創新設計，一個簡單的裝置就可以改變世界>垂直簾創新設計，一個簡單的裝置就可以改變世界</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6448fbf.html alt=一個登陸功能究竟如何設計測試用例？我把文章都整理好了，收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6090b10ff8b34110a3cdbedd89424db0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6448fbf.html title=一個登陸功能究竟如何設計測試用例？我把文章都整理好了，收藏>一個登陸功能究竟如何設計測試用例？我把文章都整理好了，收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf666261.html alt=設計一個電子束光刻機原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf666261.html title=設計一個電子束光刻機原理>設計一個電子束光刻機原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/041e4095.html alt=如何設計一個安全對外的接口？加簽驗簽了解一下 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/75d54ee4e7cf4557ae1f70b4655a74a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/041e4095.html title=如何設計一個安全對外的接口？加簽驗簽了解一下>如何設計一個安全對外的接口？加簽驗簽了解一下</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7df5800c.html alt=用SW設計一個帶滑塊停留的連桿機構，所用的零件都是入門級的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/184a185c5dbe4d49a9bbc6c9a982063f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7df5800c.html title=用SW設計一個帶滑塊停留的連桿機構，所用的零件都是入門級的>用SW設計一個帶滑塊停留的連桿機構，所用的零件都是入門級的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16f06603.html alt=手把手教你設計一個自動旋轉工作臺，看到即是賺到。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/562f9337-6531-4b2d-91e5-7933e2832e81 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16f06603.html title=手把手教你設計一個自動旋轉工作臺，看到即是賺到。>手把手教你設計一個自動旋轉工作臺，看到即是賺到。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24095cc.html alt=一個開關電源工程師的設計筆記（三）變壓器設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/97b4147ba9ef4bf99dec61784b728511 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24095cc.html title=一個開關電源工程師的設計筆記（三）變壓器設計>一個開關電源工程師的設計筆記（三）變壓器設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95b0a0d.html alt=接地是電子設計中一個極其重要的問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95b0a0d.html title=接地是電子設計中一個極其重要的問題>接地是電子設計中一個極其重要的問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2abb7ea.html alt=「系統設計」如何設計一個“穩、準、快”的秒殺系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5f1b283fc044438c93611d0f29613b9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2abb7ea.html title=「系統設計」如何設計一個“穩、準、快”的秒殺系統>「系統設計」如何設計一個“穩、準、快”的秒殺系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9359c34.html alt=如何設計一個小而美的秒殺系統？[轉] class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd5e8a47853a445abb0430ea164219f7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9359c34.html title=如何設計一個小而美的秒殺系統？[轉]>如何設計一個小而美的秒殺系統？[轉]</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62228be.html alt=看十年架構師，如何設計一個優秀的分佈式系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d8103b3dfaa14ffeab22134e2f6e0b0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62228be.html title=看十年架構師，如何設計一個優秀的分佈式系統>看十年架構師，如何設計一個優秀的分佈式系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb199be.html alt=如何從零開始設計一個億級系統架構？總結萬字的完整思路 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cbce349ae3974d7bbd85e6caf4d27ca7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb199be.html title=如何從零開始設計一個億級系統架構？總結萬字的完整思路>如何從零開始設計一個億級系統架構？總結萬字的完整思路</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/87c923e.html alt=如何設計一個高可用、高併發秒殺系統 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/276d44d4e08e46c091540e4c54b5b98c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/87c923e.html title=如何設計一個高可用、高併發秒殺系統>如何設計一個高可用、高併發秒殺系統</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/11e35eb.html alt=不要小看一個小小的螺絲孔尺寸設計，裡面大有文章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/56ed480e583d43d4850b4f43509de83c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/11e35eb.html title=不要小看一個小小的螺絲孔尺寸設計，裡面大有文章>不要小看一個小小的螺絲孔尺寸設計，裡面大有文章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b1695b.html alt=用SW設計一個無齒60度傳動裝置，具體如何實用，有待進一步開發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e2404c2aee7c47d986cebe9494de047a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b1695b.html title=用SW設計一個無齒60度傳動裝置，具體如何實用，有待進一步開發>用SW設計一個無齒60度傳動裝置，具體如何實用，有待進一步開發</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>