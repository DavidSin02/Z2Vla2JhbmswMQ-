<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>事務與一致性：剛性or柔性？ | 极客快訊</title><meta property="og:title" content="事務與一致性：剛性or柔性？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p3.pstatp.com/large/pgc-image/8a9eb977c7124ab2b454002114db9756"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/9a6fe92.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/9a6fe92.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/9a6fe92.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/9a6fe92.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/9a6fe92.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/9a6fe92.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/9a6fe92.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/9a6fe92.html><meta property="article:published_time" content="2020-10-29T20:46:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:28+08:00"><meta name=Keywords content><meta name=description content="事務與一致性：剛性or柔性？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/9a6fe92.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>事務與一致性：剛性or柔性？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><div><div class=pgc-img><img alt=事務與一致性：剛性or柔性？ onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/8a9eb977c7124ab2b454002114db9756></div><p>在高併發場景下，分佈式儲存和處理已經是常用手段。但分佈式的結構勢必會帶來“不一致”的麻煩問題，而事務正是解決這一問題而引入的一種概念和方案。我們常把它當做併發操作的基本單位。</p><h1>從MySQL事務說起（剛性事務）</h1><p>提到事務，腦海裡第一個反應當然是數據庫裡的Transaction了。緊接著就是事務的四大特性：ACID (原子性，一致性，隔離性，持久性)，所以我們先從這四大特性說起。</p><p><strong>原子性</strong></p><p>原子性是我們對事務最直觀的理解：事務就是一系列的操作，要麼全部都執行，要麼全部都不執行。</p><p>想要保證事務的原子性，就意味著需要在操作發生異常時，對該事務所有之前執行過的操作進行<strong>回滾</strong>。</p><p>在MySQL中，這個回滾是通過回滾日誌(Undo Log)實現的。簡單的說，回滾日誌就是記錄了你所有操作的<strong>逆操作</strong>，在需要回滾時，就把這個事務的回滾日誌裡的操作全部執行一次。</p><p>比如你的事務裡每一個create其實都對應了一個效果跟其相反的delete語句，他們被記錄在回滾日誌裡，當事務發生異常觸發ROLLBACK時，就按照日誌邏輯地將回滾日誌裡的操作全部執行，從而達到“撤銷”操作的效果。</p><p><strong>事務的狀態</strong></p><p>宏觀上看事務是具有原子性的，是一個密不可分的最小單位。但是它是有幾種不同的狀態的：Active,Commited,Failed，它要麼在執行中，要麼執行成功，要麼就失敗。</p><p>深入事務的內部，他就變為一系列操作的集合，不再具有原子性了，包括了很多的中間狀態，比如部分提交，參考如下的事務狀態圖：</p><div class=pgc-img><img alt=事務與一致性：剛性or柔性？ onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/e9d73470f6a6448baf43302c4ea75e6f></div><ul><li>Active 事務的初始狀態，表示正在執行</li><li>Partially Commited 部分執行，或者說在最後一條語句執行後</li><li>Failed 發現操作異常，事務無法繼續執行後</li><li>Commited 成功執行整個事務</li><li>Aborted 事務被回滾，數據庫恢復到執行前狀態後</li></ul><p><strong>並行事務的原子性</strong></p><p>正常情況下事務都是並行執行的，這就會出現很多複雜的新問題。</p><p>首先是<strong>事務依賴</strong>，舉一個直觀的例子來說明：</p><p>假設事務T1對數據A進行了讀寫，然後（T1還沒有執行完）在同時，T2讀取了數據A，然後成功提交了事務。這時候T1發生了異常，進行回滾。我們可以看到事務T2是依賴於T1所修改的數據的，如果要保證T1的原子性，那就需要同時對T2進行回滾，但是它已經被提交了，我們沒法再回滾了，這種問題被稱為“不可恢復安排”。</p><p>為了避免這種情況的出現，在出現事務的依賴時，必須遵循以下的原則：</p><p>如果事務T2依賴於事務T2，那麼T1必須在T2提交之前完成提交操作。</p><p>接下來我們還不得不面對<strong>級聯回滾</strong>，也就是出現了多個事務都依賴於事務A的時候，如果A回滾，那麼這些事務必須也一併回滾。這會導致大量的工作撤回，至於這件事情如何處理才合適，我們會在後面介紹。</p><p><strong>持久性</strong></p><p>這是理解起來相對簡單的一個特性，持久性就是指，事務一旦被提交，那麼數據一定會被寫入到數據庫中並持久儲存起來。</p><p>另外，當事務被提交後就無法再回滾，如果想要撤銷一個已經提交的事務，那就只能執行一個效果與其相反的事務，這也是持久性的一種體現。關於這點，MySQL依然是通過日誌實現的。</p><p><strong>重做日誌</strong></p><p>重做日誌由兩部分組成，一是內存中的重做日誌緩衝區，另一個是磁盤上的重做日誌文件。</p><p>這個緩衝區和日誌的關係跟我們日常IO中使用的buffer是差不多的：當我們在事務中嘗試對數據進行更改時，首先將數據從磁盤讀入內存，更新內存緩存的數據，然後會生成一條重做日誌（本次修改的逆操作）緩存，放在重做日誌緩衝區中。當事務真正提交時，再將剛才緩衝區中的日誌寫入重做日誌中做持久化保存，最後再把內存中的數據變動同步到磁盤上。</p><p>上面這個流程用圖片描述如下：</p><div class=pgc-img><img alt=事務與一致性：剛性or柔性？ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/86e266cb577649139fa6bb262ec94963></div><p>再具體一點，InnoDB中，重做日誌都是以512B的塊形式儲存的，因為磁盤的扇取也是512B，所以重做日誌的寫入就保證了原子性，即便機器斷電也不會出現日誌僅僅寫入一半而留下髒數據的情況。</p><p>另外需要注意的一點是，在原子性一節中提到的<strong>回滾日誌</strong>也是需要持久化儲存的，因此他們也會創建對應的重做日誌，在發生錯誤後，數據庫重啟時，會從重做日誌中找出未被更新到的數據庫磁盤上的日誌，重新執行來滿足事務的持久性。</p><p><strong>*事務日誌</strong></p><p>在數據庫系統中，事務的原子性和一致性是由<strong>事務日誌</strong>實現的，在具體的實現上，使用的就是之前提到的回滾日誌和重做日誌，它們保證了兩點：</p><ul><li>發生錯誤或者需要回滾的事務能夠成功回滾（原子性）</li><li>事務提交後，數據還沒來得及寫入磁盤就宕機時，重啟後能夠成功恢復數據（一致性）</li></ul><p>在數據庫中這兩者往往一起工作，因此我們可以把他們看作一個整體。一條事務日誌的內容可以抽象成下面這樣：</p><div class=pgc-img><img alt=事務與一致性：剛性or柔性？ onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/e7de9f5821544df18921bd920908510b></div><p>一條記錄同時保存了對應數據修改前後的值，就可以非常方便的實現回滾和重做兩種功能。</p><p><strong>隔離性</strong></p><p>事務的隔離性會跟併發等相關概念聯繫的非常密切，因為它主要就是為了保證並行事務處理能夠達到“互不干擾”的效果。</p><p>我們在一致性中討論過事務在併發情況下執行時，可能發生的一系列問題：雖然單個事務執行並沒有錯誤，但是它的執行可能會牽連到其他事務的執行，最終導致數據庫的整體一致性出現偏差。</p><p>談到這裡我們就要看看事務之間的互相干擾都有哪些層級，也就是我們數據庫中非常重要的概念：</p><p><strong>事務的隔離級別</strong></p><p>事務的隔離級別，其實是數據庫對數據隔離性能的一種約束，選擇不同的隔離級別會影響數據一致性的程度，同時也會影響數據庫的操作性能。</p><p>標準SQL中定義了以下4種隔離級別：</p><ul><li>未提交讀</li></ul><p>使用查詢語句不會加鎖，可能會讀到未提交的行（髒讀）</p><ul><li>提交讀</li></ul><p>只對記錄加記錄鎖，而不會在記錄之間增加間隙鎖，所以允許新的記錄被插入到被鎖定記錄附近，在多次使用查詢語句時，可能會得到不同的結果（不可重複讀）</p><ul><li>可重複讀</li></ul><p>多次讀取同一範圍的數據會返回第一次查詢的快照，不會返回不同的數據行，但是可能發生幻讀</p><p>幻讀 : 是指當事務不是獨立執行時發生的一種現象，例如第一個事務對一個表中的數據進行了修改，這種修改涉及到表中的全部數據行。 同時，第二個事務也修改這個表中的數據，這種修改是向表中插入一行新數據。那麼，以後就會發生操作第一個事務的用戶發現表中還有沒有修改的數據行，就好象 發生了幻覺一樣。</p><ul><li>串行化</li></ul><p>隱式地將全部的查詢語句都加上了共享鎖。</p><p>從上到下一致性逐漸增強，但是數據庫的讀寫性能也逐漸變差</p><p>大部分數據庫中使用提交讀作為默認的隔離級別，這是出於性能和一致性的平衡，而MySQL中則默認採用可重複讀作為配置。</p><p>對於開發者而言，不必去了解每個隔離級別具體的實現，但要能夠根據不同的場景選擇最合適的隔離級別。</p><p><strong>隔離的實現</strong></p><p>隔離的實現說到底其實是<strong>併發控制</strong>，因此不同隔離級別的實現，其實就是採用了不同的併發控制機制。</p><p><strong>1.鎖</strong></p><p>這個自然是最簡單的，也是相當常用的併發控制機制了。</p><p>不過在一個事務中，自然是不可能把整個數據庫都加鎖的，而是隻對要訪問的數據加鎖（具體的粒度有行、表等）。而這些資源鎖也是理所當然地分為共享鎖（讀鎖）和互斥鎖（寫鎖）兩種。</p><p>讀鎖可以保證操作併發執行而不受影響，寫鎖則保證了更新數據庫時不會受到其他事務的干擾。</p><p><strong>2.時間戳</strong></p><p>用時間戳實現隔離性，需要為記錄配置兩個字段</p><ul><li><strong>讀時間戳</strong>：用於保存所有訪問該記錄的事務中的最大時間戳（最後讀取時間）</li><li><strong>寫時間戳</strong>：用於保存將記錄改到當前值的事務的時間戳（最後修改時間）</li></ul><p>這樣的事務在並行執行時，用的是<strong>樂觀鎖</strong>，先任由事務對數據進行修改，在寫回去的時候在判斷記錄的時間戳有沒有修改，如果沒有被修改，就寫入，否則，就生成一個新的時間戳並再次嘗試更新數據。</p><p>PostgreSQL就使用了這種思想來控制事務。</p><p><strong>3.多版本和快照隔離</strong></p><p>通過維護多個版本的數據，數據庫便可以允許事務併發執行遇到互斥鎖時，轉而讀取舊版本的數據快照。這樣就能顯著地提升讀取的性能。我們簡稱這一手段為MVCC。</p><p><strong>級聯回滾</strong></p><p>之前在討論原子性問題時，討論過級聯回滾的問題，那是因為事務之間產生了<strong>依賴</strong>而導致的。因此我們將事務<strong>隔離</strong>之後，就不會再產生需要級聯回滾的場景了。</p><p>比如一個事務寫入了A數據，那麼這時候是需要加共享鎖的，因此其它的事務無法讀取A，當事務A回滾時不用考慮對其它事務的影響，因為其它的事務並不可能讀到數據。</p><p><strong>一致性</strong></p><p>好了，這時候我們終於迴歸到了本文所想討論的主題上來。“一致性”在數據庫領域有兩個意義，一個是ACID中的C，另一個是CAP的C，前者是我們經常討論的，也是普遍意義上的數據庫事務一致性，而後一個將是之後會展開討論的，有關分佈式事務的一致性。</p><p><strong>ACID</strong></p><p>事務的一致性定義基本可以理解為是事務對數據完整性約束的遵循。這些約束可能包括主鍵約束、外鍵約束或是一些用戶自定義約束。事務執行的前後都是合法的數據狀態，不會違背任何的數據完整性，這就是“一致”的意思。</p><p>當然這個含義中也隱含著對開發者的要求，就是不能寫出錯誤的事務邏輯，比如銀行的轉賬不能只加錢不減錢，這是應用層面的一致性要求。</p><p><strong>CAP</strong></p><p>CAP定理是分佈式系統理論的基礎。CAP告訴我們，對於一個分佈式系統（或者由於網絡隔離等原因產生的分區系統），它無法同時保證一致性、可用性和分區容忍性，而是必須要捨棄其中的一個。</p><p>p.s. 對於分佈式系統一般我們是不可能捨棄分區容忍性的（因為分區的情況是無法避免的），所以一般是根據業務，在一致性和可用性中二選一。</p><p>這裡說的一致性，具體在數據庫上，就是分佈式數據庫中，每一個節點對於同一個數據必須有相同的拷貝（每個庫裡的同一個數據內容必須是一致的）。</p><h1>分佈式事務</h1><p>現在我們來看一看，當數據分佈式儲存後，操作所帶來的一些問題。</p><p>眾所周知，現在大型服務出於性能和容災的考慮，都會使用分佈式的服務架構，這意味著一個服務會有多個數據庫，分開儲存不同的數據，這種情況下就很容易出現數據不一致的問題了，一個最簡單的例子：</p><p>A要B給轉100元。但是A和B的記錄被分在了不同的數據庫實例上，如果這時候執行的某個事務中途出現了bug，如果沒有一個好的處理方式，回滾將會是一件難以面對的事情。</p><p>所以我們可以看到，在分佈式環境下，事務的設計方案變得更加複雜，也更加重要了，下面我們來談談分佈式事務的一些常見實現方式：</p><p><strong>兩階段提交（2PC）</strong></p><p><strong>原理</strong></p><p>兩階段提交是一種提交協議，在這種協議下，事務的實現被拆分成了幾個不同的模塊，一般分為協調器和若干的事務執行者，如下圖：</p><div class=pgc-img><img alt=事務與一致性：剛性or柔性？ onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/61a59806a6cd4a088de180fffe4978eb></div><p>在分佈式系統中，每個節點雖然可以知道自己操作是否成功，但是卻無法得知其他節點上操作是否成功，因此當一個事務跨越了多個節點的時候，就需要一個協調者，能夠掌控到所有節點的執行情況，進而保證事務的ACID特性。</p><p>現在我們來分析2PC協議條件下，轉賬問題是如何被解決的（我們假設A是你的支付寶餘額，B是你的餘額寶）。</p><ol><li>A發起請求到協調器，協調器開始工作</li><li>準備憑證</li></ol><ul><li>協調器將prepare信息寫到本地日誌，這就是回滾日誌了。</li><li>向所有的參與者發起prepare信息，當然對於不同的執行者，這個prepare信息是不同的，這取決於他們的數據實例上要發生什麼樣的變動，比如這個例子中，A得到的prepare消息是通知支付寶餘額數據庫扣除100元，而B得到的prepare消息是通知餘額寶數據庫增加100元。</li></ul><ol><li>執行者收到prepare消息之後，執行本機的具體事務，但不會commit，如果成功則向協調者發送yes回執，否則發送no。</li><li>協調者判斷收集到的所有回執，如果均為yes，就向所有的執行者發送commit消息，執行器收到該消息後就會正式執行提交。反之，如果收到任何一個no，就向所有的實行者發送abort消息，執行器收到後會放棄提交併回滾相應的改動。</li></ol><p>協調器上保存的回滾日誌，可以用於某個執行器失敗後恢復的工作的場景，此時執行器可能會再次向協調器發送回執來確定自己的執行狀態。</p><p><strong>問題</strong></p><p>2PC實現的思路倒是很簡單，不過這個思路中存在著幾個非常嚴重的問題，因此幾乎不被使用：</p><ol><li>涉及多次節點間的通信，假設網絡延遲比較高，通信時長基本是不可忍受的</li><li>事務時間變長了，也意味著資源上鎖的時間變長了，性能大打折扣</li><li>如果參與者多了，協調器的工作效率會下降，而整個流程也變得複雜起來</li></ol><p>其實分佈式事務的種種實現方案基本都借鑑了2PC的思路，但很快人們就發現一個問題，在分佈式的系統中，如果仍然採用事務模型來進行數據的修改，性能將受到不可避免的影響，這在高併發的場景下是不能接受的。</p><h1>最終一致性（柔性事務）</h1><p>剛才我們講了分佈式事務在高併發場景下的敗北，其實根據CAP原則我們很容易明白，想要保證可用性的同時保證一致性是不可能的，於是現在大多數的分佈式系統中都對一致性做出了妥協：</p><p>我們不追求整個操作過程中每一時刻的一致性（強一致性），轉而追求最終結果的一致性（最終一致性）。</p><p>也即是說，在整個事務執行的流程中，我們是可以接受的短暫的數據不一致的，只要最後的結果沒問題就行。</p><p>至此，我們對於事務的研究，從滿足ACID的剛性事務，拓展到BASE（基本可用，軟狀態，最終一致性）的柔性事務。</p><p><strong>BASE</strong></p><p>BASE原則是在分佈式場景下，為了保證高可用性，而做出的一種“妥協性”思想。總的來說是允許局部的錯誤和故障，但要保證全局的穩定。事實上當前大多數的分佈式系統，或者說大多數的大型系統裡，都在運用這種思想了。</p><p>在展開柔性事務之前，我們先來補充一些基礎知識。</p><p><strong>重試與冪等</strong></p><p>在接下來講到的各種思路中，我們都無法避免一個問題，那就是接口調用或者說操作的失敗，分佈式情況下系統的狀態往往不如單機條件下確定，所以可能經常需要<strong>重試</strong>，而不是一失敗就回滾。</p><p>因此我們必須儘可能的避免重試對系統穩定性和性能的影響，於是有了冪等這個概念：</p><p><strong>冪等</strong></p><ul><li>數學定義：f(x) = f(f(x))的性質</li><li>編程定義：對同一個系統，使用同樣的條件，一次請求和重複的多次請求對系統資源的影響是一致的</li></ul><p>然後我們需要探討一下保證冪等常用的思路，我們以微博點贊這個操作為實際例子來看一下（點贊是不能重複的）：</p><ol><li>MVCC</li></ol><p>數據更新時需要比較持有數據的版本號，版本號不一致的話是無法操作成功的。</p><p>每個版本只有一次執行成功的機會，一旦失敗了就要重新獲取版本號。</p><p>這樣每次點贊操作都對應著一個不同的版本號，即便失敗重複嘗試，也不會出現點贊數錯誤增加或減少的情況。</p><ol><li>去重</li></ol><p>這個主要依賴數據庫的索引唯一性（鍵），以點贊操作為例，可以對[`user_id`,`weibo_id`]這個組合做一張“點贊操作表”，如果成功點贊，就添加一條新記錄。</p><p>如果出現了錯誤的重試，因為表的索引是唯一的，已經有了記錄自後就不會再次插入，自然也就不會出現錯誤的情況了。</p><p><strong>異步確保</strong></p><p>2PC的處理過程中一個很大的問題是，存在大量的同步等待，這便意味著操作之間的強耦合，一旦發生了失敗或是超時，造成的影響往往是災難性的。但是分佈式情況下，超時和失敗又是很可能出現的情況，所以2PC手段沒法保證系統的可用性。</p><p>那麼怎麼優化呢？可以將操作解耦，使用消息隊列（或者某種可靠的通信機制）來連接不同的實例上的操作。這樣的通信機制使操作異步化，於是我們還需要一個能夠確保消息執行成功的確保機制，以上兩點的綜合就是現在最常用的柔性事務解決方案，我們暫且叫它“異步確保”（因為這種方案並非有一個統一的叫法），核心思路其實就是：用消息隊列保證最終一致性。</p><p>下面我們一步一步深入，瞭解這種方案的基本思想和流程。</p><p><strong>問題</strong></p><p>我們依然使用經典的轉賬問題來展開討論：A要向B轉100元，但是A和B的賬戶在不同的實例上存儲。</p><p>用異步確保的思想，操作的流程應該如此處理：</p><ol><li>A所在的實例扣除A賬戶100元</li><li>向B所在的實例發送操作消息，通知它給B的賬戶增加100元</li></ol><p>這是一個很理想的情況，其實我們有很多的問題要處理。</p><p>首先是原子性，其實很容易發現，無論順序如何，如果1和2這兩個操作有任何一個失敗了，那另一個操作也必然變得沒有意義，所以必須保證1和2這兩個操作的整體原子性。</p><p>這裡很多人會想，直接利用剛性事務的ACID特性，把1和2放在同一個事務裡不就ok了。但這是不可能的，原因如下：</p><ul><li>網絡的2將軍問題：發送消息如果失敗了，發送方並沒有辦法知道，是接收方沒收到消息，還是接收方返回響應的時候出現了故障，其實已經收到了？</li><li>在DB事務裡插入網絡操作，如果出現延遲，會導致事務執行時間變長，對DB性能影響極大，嚴重的話可能block整個DB。</li></ul><p>所以事情沒那麼簡單，所以在我們得做不少額外的工作才能解決這個問題，下面是現在常用的解決思路：消息表。</p><p>先說生產方（A的實例）</p><ol><li>生產方添加一張消息表，用於記錄發送的消息以及消息的回執等內容。</li><li>生產者在向消費者發送業務操作數據時，同時也要在消息表裡增加一個消息記錄，這兩個都是對生產者DB的操作，我們要把它們放在同一個事務裡來保證一致性。舉個例子，轉賬問題在A端上這個操作的sql就是這樣的（有點隨意，會意即可）：</li></ol><p>```</p><p>begin transaction;</p><p>update account set amount = ($amount - 100) where user = A;</p><p>insert into message values('b','account','-100');</p><p>end transaction;</p><p>```</p><ol><li>對於這張消息表，我們需要一個維護者，它的職責是，不斷地把表中未發送的消息放入消息隊列，另外檢測消息的執行是否超時或失敗，如果遇到這種異常情況，就進行重試。注意：允許消息重複，但是不能丟失，順序也不會打亂。</li></ol><p>再說消費方（B的實例）</p><ol><li>消費方的接口（我們稱為下游接口），必須實現冪等。這是因為生產方可能會發來很多的重試消息，我們必須保證重試操作不會對系統產生不良影響。如果之前說的冪等手段不適用，可以簡單的為消費方準備一個判重表，利用判重表的Insert操作來實現冪等（如果這麼做，請注意在業務中保證消費操作和Insert判重表操作的原子性）。</li><li>消費方完成操作後，利用消息隊列向生產方發送確認消息就ok。</li></ol><p>可以看到這個實現方案對於業務的生產方來說，需要維護很多額外的操作，尤其是需要設計維護消息表，可能還要做後臺任務處理等，某種程度上這會增加業務端不必要的邏輯耦合，以及性能負擔。</p><p>簡要工作流程如下圖所示：</p><div class=pgc-img><img alt=事務與一致性：剛性or柔性？ onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/3122a51e7c94402b8526e3847416aca6></div><p><strong>事務消息</strong></p><p>正如上文所說，異步確保的思路中，大多數操作其實與業務無關，可以封裝到消息隊列中去。於是產生了“事務消息”這一概念，也就衍生了很多能夠很好的支持分佈式事務消息相關操作的消息隊列或者中間件，如RocketMQ和Notify。</p><p>我們來看看事務消息是如何優化和整合異步確保的邏輯的。</p><p>首先，把消息發送分成了2個階段：準備和確認階段，於是生產方步驟變為如下3步：</p><ol><li>發送prepared消息給MQ</li><li>執行本地事務</li><li>根據本地事務執行結果，確認或者取消prepared消息</li></ol><p>這裡有一個問題，就是如果1和2失敗了，還是很容易回滾和取消的，但是第三步失敗或者超時了，要怎麼做呢？</p><p>以RocketMQ為例，MQ會定期地掃描所有的prepared消息，詢問發送方，到底是要確認發送這條消息，還是要取消這條消息？這點底層是通過讓生產方實現一個約定好的Check接口來實現的，有點像訂閱者模式。</p><p>我們可以看出來，異步回調中，掃描消息表，確認或重發消息這個步驟被消息隊列實現了，減少了業務方開發的難度。</p><p>對於消費方，事務消息支持重試的特性，也就是說不必生產者去主動發起重試消息，消息隊列可以自動幫你重試這些操作，可以說是非常解放生產力了。</p><p>如果有極端情況，比如消費端異常，無論怎麼重試都失敗，是否要回滾呢？其實最好的辦法就是人工介入，人工去處理這種概率極低的case，比開發一個高複雜的自動回滾系統要可靠的多，也更簡單。</p><p><strong>事務補償（TCC)</strong></p><p>除了比較常用的異步確保，我們再介紹一種常見的實現柔性事務的思路，稱為事務補償。</p><p>總結之前的內容，我們不難發現，分佈式事務的難點在於，一方執行事務成功之後，無法確定其他參與方對應的事務是否能夠成功（除非犧牲系統可用性）。</p><p>事務補償的想法和回滾日誌有些類似。既然我們沒辦法同時保證所有的參與方事務執行都成功，不如就讓他們隨意執行，誰成功了就提交本地事務。但是每個參與方的每個操作，都要註冊（注意是註冊，不是自動生成）一個對應的補償操作，這個補償操作由人為定義，用於撤銷已執行事務帶來的影響。</p><p>當某一方的事務執行失敗時，所有已經成功提交了事務的參與方，需要按照順序（提交的倒序）去執行各自的補償事務，來將整個系統“回滾”到之前的狀態。</p><p>補償型思路的一個典型實現是<strong>TCC(Try-Confirm-Cancel)</strong>事務，其實說是事務，不如說是一種業務模式，因為Try,Confirm,Cancel這三個操作都必須由業務方實現。</p><ul><li>Try：資源預留&鎖定。事務發起方將調用服務提供方的Try方法來鎖定業務所需要的所有資源。</li><li>Confirm：確認執行業務邏輯操作。這裡使用的資源一定都是在Try中預留的資源，Try + Confirm 組合起來是一次完整的業務邏輯。</li><li>Cancel：取消執行業務邏輯。這裡和普通的補償性事務不同，因為Try階段只是預留資源，並未真正執行操作，因此取消操作只需要釋放Try階段預留的資源，而不需要執行數據庫操作來補償。</li></ul><p>其實TCC可以認為是應用層的2CP協議。網上關於TCC的相關邏輯說法很多，也比較混亂，這裡找到一個比較通俗普遍的例子來解釋TCC的流程。當然實際應用中，根據業務的場景不同，TCC的實現也不同：它只是一種思路，而並非是一種規範。</p><p>例子仍然是轉賬問題，我們把範圍稍微擴大一點，現在我們有三個用戶A,B,C分別位於三個不同的數據庫實例上，現在A,B要分別向C轉賬40元（一共80元）。</p><ol><li>Try階段：嘗試執行。</li></ol><p>- 業務檢查（一致性）：檢查A,B,C的賬戶狀態是否正常，以及A,B的賬戶餘額是否都不低於40元。</p><p>- 預留資源（準隔離性）：賬戶A、B的餘額均凍結40元。這樣保證其他併發事務不會把A、B的餘額扣成負數。</p><ol><li>Confirm階段：確認執行。</li></ol><ul><li>真正執行事務：執行實際的業務操作：A、B賬戶減少40元，C賬戶增加80元。（這一步還是需要消息傳遞機制）</li></ul><ol><li>Cancel階段：取消執行。</li></ol><ul><li>釋放A,B賬戶上被成功凍結的金額。</li></ul><h1>小結</h1><p>分佈式的結構下，事務的實現依然沒有一個放之四海而皆準的標準。但是可以看到一個統一的原則，那就是儘可能的讓服務變得更具有彈性，能夠靈活地應對多種情況。</p><p>總的來說，分佈式事務更大的挑戰在於，相關業務邏輯的開發思路：可用性與一致性的平衡。</p><p><strong>參考文章</strong></p><p>本文是學習和整理自下列文章：</p><ul><li>分佈式事務？No, 最終一致性</li><li>『淺入深出』MySQL 中事務的實現</li><li>分佈式消息隊列RocketMQ--事務消息--解決分佈式事務的最佳實踐</li><li>分佈式事務之說說TCC事務</li><li>理解分佈式事務的兩階段提交2p</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>事務</a></li><li><a>剛性</a></li><li><a>柔性</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/dfc1c73.html alt=強度和剛度、柔性接頭和剛性接頭、柔性牆體和剛性牆體區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ed16326e6b65450d904958855f0b454c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dfc1c73.html title=強度和剛度、柔性接頭和剛性接頭、柔性牆體和剛性牆體區別>強度和剛度、柔性接頭和剛性接頭、柔性牆體和剛性牆體區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html alt=Mysql事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html title=Mysql事務>Mysql事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html alt=SpringBoot事務詳細簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html title=SpringBoot事務詳細簡介>SpringBoot事務詳細簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html alt=SqlServer使用事務注意事項，高級程序員必背 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html title=SqlServer使用事務注意事項，高級程序員必背>SqlServer使用事務注意事項，高級程序員必背</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html alt=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/433259b5-1936-4cee-ab74-70aef36536ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html title=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理>（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>