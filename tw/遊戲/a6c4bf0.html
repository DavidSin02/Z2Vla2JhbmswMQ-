<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>終於有人把“分佈式事務”說清楚了！ | 极客快訊</title><meta property="og:title" content="終於有人把“分佈式事務”說清楚了！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p9.pstatp.com/large/pgc-image/fdb2895c4a3d4c7f852860370f0e4681"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/a6c4bf0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/a6c4bf0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/a6c4bf0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/a6c4bf0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/a6c4bf0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/a6c4bf0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/a6c4bf0.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/a6c4bf0.html><meta property="article:published_time" content="2020-10-29T20:46:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:28+08:00"><meta name=Keywords content><meta name=description content="終於有人把“分佈式事務”說清楚了！"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/a6c4bf0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>終於有人把“分佈式事務”說清楚了！</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><blockquote class=pgc-blockquote-abstract><p>作者：陳明羽，就職於京東零售</p><p>鏈接：https://chenmingyu.top/distributed-transaction/#分佈式事務</p></blockquote><p><br>一個複雜的系統往往都是從一個小而簡的系統發展衍化而來，為了滿足日益增長的業務需求，不斷的增加系統的複雜度，從單體架構逐步發展為分佈式架構，而分佈式系統架構的設計主要關注：高性能，高可用，高拓展。</p><h1 class=pgc-h-arrow-right>分佈式事務</h1><p>高可用是指系統無中斷的執行功能的能力，代表了系統的可用程度，是進行系統設計時必須要遵守的準則之一。</p><p>而高可用的實現方案，無外乎就是冗餘，就存儲的高可用而言，問題不在於如何進行數據備份，而在於如何規避數據不一致對業務造成的影響。</p><p>對於分佈式系統而言，要保證分佈式系統中的數據一致性就需要一種方案，可以保證數據在子系統中始終保持一致，避免業務出現問題。</p><p>這種實現方案就叫做分佈式事務，要麼一起成功，要麼一起失敗，必須是一個整體性的事務。</p><p><br></p><h1 class=pgc-h-arrow-right>理論基礎</h1><p>在講解具體方案之前，有必要了解一下分佈式中數據設計需要遵循的理論基礎，CAP 理論和 BASE 理論，為後面的實踐鋪平道路。</p><p><strong>CAP 理論</strong></p><p>CAP，Consistency Availability Partition tolerance 的簡寫：</p><ul><li><strong>Consistency：</strong>一致性，對某個客戶端來說，讀操作能夠返回最新的寫操作結果。</li><li><strong>Availability：</strong>可用性，非故障節點在合理的時間內返回合理的響應。</li><li><strong>Partition tolerance：</strong>分區容錯性，當出現網絡分區後，系統能夠繼續提供服務，你知道什麼是網絡分區嗎？</li></ul><p>因為分佈式系統中系統肯定部署在多臺機器上，無法保證網絡做到 100% 的可靠，所以網絡分區一定存在，即 P 一定存在。</p><p>在出現網絡分區後，就出現了可用性和一致性的問題，我們必須要在這兩者之間進行取捨，因此就有了兩種架構：</p><ul><li><strong>CP 架構</strong></li><li><strong>AP 架構</strong></li></ul><p><br></p><h4 class=pgc-h-arrow-right><strong>①CP 架構</strong></h4><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/fdb2895c4a3d4c7f852860370f0e4681><p class=pgc-img-caption></p></div><p>當網絡分區出現後，為了保證一致性，就必須拒接請求，否則無法保證一致性：</p><ul><li>當沒有出網絡分區時，系統 A 與系統 B 的數據一致，X=1。</li><li>將系統 A 的 X 修改為 2，X=2。</li><li>當出現網絡分區後，系統 A 與系統 B 之間的數據同步數據失敗，系統 B 的 X=1。</li><li>當客戶端請求系統 B 時，為了保證一致性，此時系統 B 應拒絕服務請求，返回錯誤碼或錯誤信息。</li></ul><p>上面這種方式就違背了可用性的要求，只滿足一致性和分區容錯，即 CP，CAP 理論是忽略網絡延遲，從系統 A 同步數據到系統 B 的網絡延遲是忽略的。</p><p>CP 架構保證了客戶端在獲取數據時一定是最近的寫操作，或者獲取到異常信息，絕不會出現數據不一致的情況。</p><p><br></p><h4 class=pgc-h-arrow-right><strong>②AP 架構</strong></h4><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/afccd04f8680404aa25ef68574224c1c><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>當網絡分區出現後，為了保證可用性，系統 B 可以返回舊值，保證系統的可用性：</h4><ul><li>當沒有出網絡分區時，系統 A 與系統 B 的數據一致，X=1。</li><li>將系統 A 的 X 修改為 2，X=2。</li><li>當出現網絡分區後，系統 A 與系統 B 之間的數據同步數據失敗，系統 B 的 X=1。</li><li>當客戶端請求系統 B 時，為了保證可用性，此時系統 B 應返回舊值，X=1。</li></ul><p>上面這種方式就違背了一致性的要求，只滿足可用性和分區容錯，即 AP，AP 架構保證了客戶端在獲取數據時無論返回的是最新值還是舊值，系統一定是可用的。</p><p>CAP 理論關注粒度是數據，而不是整體系統設計的策略。</p><p><br><strong>BASE 理論</strong></p><p><br></p><p>BASE 理論指的是基本可用 Basically Available，軟狀態 Soft State，最終一致性 Eventual Consistency，核心思想是即便無法做到強一致性，但應該採用適合的方式保證最終一致性。</p><p><br></p><p>BASE，Basically Available Soft State Eventual Consistency 的簡寫：</p><ul><li><strong>BA：</strong>Basically Available 基本可用，分佈式系統在出現故障的時候，允許損失部分可用性，即保證核心可用。</li><li><strong>S：</strong>Soft State 軟狀態，允許系統存在中間狀態，而該中間狀態不會影響系統整體可用性。</li><li><strong>E：</strong>Consistency 最終一致性，系統中的所有數據副本經過一定時間後，最終能夠達到一致的狀態。</li></ul><p><br></p><p>BASE 理論本質上是對 CAP 理論的延伸，是對 CAP 中 AP 方案的一個補充。</p><p><br></p><h1 class=pgc-h-arrow-right>分佈式事務協議</h1><p><strong>X/Open XA 協議</strong></p><p><br></p><p>XA 是一個分佈式事務協議，由 Tuxedo 提出。XA 規範主要定義了（全局）事務管理器（Transaction Manager）和（局部）資源管理器（Resource Manager）之間的接口。</p><p><br></p><p>XA 接口是雙向的系統接口，在事務管理器（Transaction Manager）以及一個或多個資源管理器（Resource Manager）之間形成通信橋樑。</p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/22d30d75d52941488df0062802420e53><p class=pgc-img-caption></p></div><p>XA 協議採用兩階段提交方式來管理分佈式事務。XA 接口提供資源管理器與事務管理器之間進行通信的標準接口。</p><p><br></p><p><strong>2PC：二階段提交協議</strong></p><p><br></p><p>二階段提交（Two-phase Commit），是指，為了使基於分佈式系統架構下的所有節點在進行事務提交時保持一致性而設計的一種算法（Algorithm）。通常，二階段提交也被稱為是一種協議（Protocol）。</p><p><br></p><p>在分佈式系統中，每個節點雖然可以知曉自己的操作是成功或者失敗，卻無法知道其他節點的操作是成功或失敗。</p><p><br></p><p>當一個事務跨越多個節點時，為了保持事務的 ACID 特性，需要引入一個作為協調者的組件來統一掌控所有節點（稱作參與者）的操作結果並最終指示這些節點是否要把操作結果進行真正的提交（比如將更新後的數據寫入磁盤等等）。</p><p><br></p><p><strong>因此，二階段提交的算法思路可以概括為：</strong>參與者將操作成敗通知協調者，再由協調者根據所有參與者的反饋情報決定各參與者是否要提交操作還是中止操作。</p><p><br></p><p>二階段提交算法的成立基於以下假設：</p><ul><li>該分佈式系統中，存在一個節點作為協調者（Coordinator），其他節點作為參與者（Cohorts）。且節點之間可以進行網絡通信。</li><li>所有節點都採用預寫式日誌，且日誌被寫入後即被保持在可靠的存儲設備上，即使節點損壞不會導致日誌數據的消失。</li><li>所有節點不會永久性損壞，即使損壞後仍然可以恢復。</li></ul><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/b953eda4f4fd4242b6e17259d4b75e24><p class=pgc-img-caption></p></div><p>二階段提交分為兩階段：</p><ul><li><strong>投票階段</strong></li><li><strong>提交階段</strong></li></ul><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/acd26014b8ab40788f52defb450a18e7><p class=pgc-img-caption></p></div><p>投票階段 Prepares：</p><ul><li>協調者向所有參與者詢問是否可以執行提交操作，並開始等待各參與者的響應。</li><li>參與者執行事務操作，如果執行成功就返回 Yes 響應，如果執行失敗就返回 No 響應。</li><li>如果協調者接受參與者響應超時，也會認為執行事務操作失敗。<br></li></ul><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/1f2fb9c775fe4e7981d462a60ad7d473><p class=pgc-img-caption></p></div><p>提交階段 Commit：</p><ul><li>如果第一階段彙總所有參與者都返回 Yes 響應，協調者向所有參與者發出提交請求，所有參與者提交事務。</li><li>如果第一階段中有一個或者多個參與者返回 No 響應，協調者向所有參與者發出回滾請求，所有參與者進行回滾操作。</li></ul><p><br></p><p><strong>二階段提交優點：</strong>儘量保證了數據的強一致，但不是 100% 一致。</p><p><br></p><p>二階段提交缺點：</p><ul><li><strong>單點故障，</strong>由於協調者的重要性，一旦協調者發生故障，參與者會一直阻塞，尤其是在第二階段，協調者發生故障，那麼所有的參與者都處於鎖定事務資源的狀態中，而無法繼續完成事務操作。</li><li><strong>同步阻塞，</strong>由於所有節點在執行操作時都是同步阻塞的，當參與者佔有公共資源時，其他第三方節點訪問公共資源不得不處於阻塞狀態。</li><li><strong>數據不一致，</strong>在第二階段中，當協調者向參與者發送提交事務請求之後，發生了局部網絡異常或者在發送提交事務請求過程中協調者發生了故障，這會導致只有一部分參與者接收到了提交事務請求。而在這部分參與者接到提交事務請求之後就會執行提交事務操作。但是其他部分未接收到提交事務請求的參與者則無法提交事務。從而導致分佈式系統中的數據不一致。</li></ul><p><br></p><p><strong>二階段提交的問題：</strong>如果協調者在第二階段發送提交請求之後掛掉，而唯一接受到這條消息的參與者執行之後也掛掉了，即使協調者通過選舉協議產生了新的協調者並通知其他參與者進行提交或回滾操作的話，都可能會與這個已經執行的參與者執行的操作不一樣。</p><p>當這個掛掉的參與者恢復之後，就會產生數據不一致的問題。</p><p><br></p><p><strong>3PC：三階段提交協議</strong></p><p>三階段提交（Three-phase commit），是為解決兩階段提交協議的缺點而設計的。與兩階段提交不同的是，三階段提交是“非阻塞”協議。</p><p>三階段提交在兩階段提交的第一階段與第二階段之間插入了一個準備階段，使得原先在兩階段提交中，參與者在投票之後，由於協調者發生崩潰或錯誤，而導致參與者處於無法知曉是否提交或者中止的“不確定狀態”所產生的可能相當長的延時的問題得以解決。</p><p>三階段提交的三個階段：</p><ul><li><strong>CanCommit</strong></li><li><strong>PreCommit</strong></li><li><strong>DoCommit</strong></li></ul><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/dc66ff23996f4b239dc45f915567127a><p class=pgc-img-caption></p></div><p><strong>①詢問階段：CanCommit</strong></p><p><br></p><p>協調者向參與者發送 Commit 請求，參與者如果可以提交就返回 Yes 響應，否則返回 No 響應。</p><p><br></p><p><strong>②準備階段：PreCommit</strong></p><p><br></p><p>協調者根據參與者在詢問階段的響應判斷是否執行事務還是中斷事務：</p><ul><li>如果所有參與者都返回 Yes，則執行事務。</li><li>如果參與者有一個或多個參與者返回 No 或者超時，則中斷事務。</li></ul><p><br></p><p>參與者執行完操作之後返回 ACK 響應，同時開始等待最終指令。</p><p><br></p><p><strong>③提交階段：DoCommit</strong></p><p><br></p><p>協調者根據參與者在準備階段的響應判斷是否執行事務還是中斷事務：</p><ul><li>如果所有參與者都返回正確的 ACK 響應，則提交事務。</li><li>如果參與者有一個或多個參與者收到錯誤的 ACK 響應或者超時，則中斷事務。</li><li>如果參與者無法及時接收到來自協調者的提交或者中斷事務請求時，會在等待超時之後，會繼續進行事務提交。</li></ul><p><br></p><p>協調者收到所有參與者的 ACK 響應，完成事務。</p><p><strong>解決二階段提交時的問題：</strong>在三階段提交中，如果在第三階段協調者發送提交請求之後掛掉，並且唯一的接受的參與者執行提交操作之後也掛掉了，這時協調者通過選舉協議產生了新的協調者。</p><p>在二階段提交時存在的問題就是新的協調者不確定已經執行過事務的參與者是執行的提交事務還是中斷事務。</p><p>但是在三階段提交時，肯定得到了第二階段的再次確認，那麼第二階段必然是已經正確的執行了事務操作，只等待提交事務了。</p><p>所以新的協調者可以從第二階段中分析出應該執行的操作，進行提交或者中斷事務操作，這樣即使掛掉的參與者恢復過來，數據也是一致的。</p><p>所以，三階段提交解決了二階段提交中存在的由於協調者和參與者同時掛掉可能導致的數據一致性問題和單點故障問題，並減少阻塞。</p><p>因為一旦參與者無法及時收到來自協調者的信息之後，他會默認執行提交事務，而不會一直持有事務資源並處於阻塞狀態。</p><p><strong>三階段提交的問題：</strong>在提交階段如果發送的是中斷事務請求，但是由於網絡問題，導致部分參與者沒有接到請求。</p><p>那麼參與者會在等待超時之後執行提交事務操作，這樣這些由於網絡問題導致提交事務的參與者的數據就與接受到中斷事務請求的參與者存在數據不一致的問題。</p><p>所以無論是 2PC 還是 3PC 都不能保證分佈式系統中的數據 100% 一致。</p><p><br></p><h1 class=pgc-h-arrow-right>解決方案</h1><p><strong>舉個</strong><strong>栗子</strong><strong>：</strong>在電商網站中，用戶對商品進行下單，需要在訂單表中創建一條訂單數據，同時需要在庫存表中修改當前商品的剩餘庫存數量。</p><p>兩步操作一個添加，一個修改，我們一定要保證這兩步操作一定同時操作成功或失敗，否則業務就會出現問題。</p><p><strong>建立時：</strong>業務量不大，用戶少，系統只是一個單體架構，訂單表與庫存表都在一個數據庫中，這時可以使用 MySQL 的本地事務保證數據一致性。</p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/1d36109a047b4aada21b5bc1aafd2f46><p class=pgc-img-caption></p></div><p><strong>發展期：</strong>業務發展迅速，用戶量變多，單數據已經出現了性能瓶頸，按照業務緯度進行分庫，分為訂單庫和庫存庫，由於跨庫跨機器，MySQL 的本地事務不能再保證訂單庫和庫存庫的數據一致性。</p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/3f2fcfab1fbb42dfa7361dd8b0490842><p class=pgc-img-caption></p></div><p><strong>成熟期：</strong>業務拓展，單體架構已經滿足不了需求，進而衍化成了分佈式系統，這時的訂單和庫存已經拆分為了兩個子系統提供服務，子系統間使用 RPC 進行通信。</p><p>但是無論系統發展成什麼樣，我們都要保證業務不出問題，保證訂單和庫存的數據一致，這時候要思考下在服務之間我們應如何保證數據一致。</p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/54700752b83742e49ef454daca018edb><p class=pgc-img-caption></p></div><p><strong>強一致性分佈式事務</strong></p><p><br></p><p>單體架構多數據源，在業務開發中，肯定是先執行對訂單庫的操作，但是不提交事務，再執行對庫存庫的操作，也不提交事務，如果兩個操作都成功，在一起提交事務，如果有一個操作失敗，則兩個都進行回滾。</p><h4 class=pgc-h-arrow-right><strong>基於 2PC/XA 協議實現的 JTA：</strong>我們已經知道了 2PC 和 XA 協議的原理，而 JTA 是 Java 規範，是 XA 在 Java 上的實現。</h4><p>JTA（Java Transaction Manager）:</p><ul><li><strong>Transaction Manager：</strong>常用方法，可以開啟，回滾，獲取事務。begin()，rollback()...</li><li><strong>XAResouce：</strong>資源管理，通過 Session 來進行事務管理，commit（xid）...</li><li><strong>XID : </strong>每一個事務都分配一個特定的 XID。</li></ul><p>JTA 主要的原理是二階段提交，當整個業務完成了之後只是第一階段提交，在第二階段提交之前會檢查其他所有事務是否已經提交。</p><p>如果前面出現了錯誤或是沒有提交，那麼第二階段就不會提交，而是直接回滾，這樣所有的事務都會做回滾操作。基於 JTA 這種方案實現分佈式事務的強一致性。</p><p><br></p><p>JTA 的特點：</p><ul><li>基於兩階段提交，有可能會出現數據不一致的情況</li><li>事務時間過長，阻塞</li><li>性能低，吞吐量低</li></ul><p>實現可以使用基於 JTA 實現的 Jar 包 Atomikos 例子可以自己百度一下。</p><p>正常架構設計中是否應該出現這種跨庫的操作，我覺得是不應該的，如果按業務拆分將數據源進行分庫，我們應該同時將服務也拆分出去才合適，應遵循一個系統只操作一個數據源（主從沒關係），避免後續可能會出現的多個系統調用一個數據源的情況。</p><p><br></p><p><strong>最終一致性分佈式事務方案</strong></p><p>JTA 方案適用於單體架構多數據源時實現分佈式事務，但對於微服務間的分佈式事務就無能為力了，我們需要使用其他的方案實現分佈式事務。</p><p><br></p><h4 class=pgc-h-arrow-right><strong>①本地消息表</strong></h4><p>本地消息表的核心思想是將分佈式事務拆分成本地事務進行處理。</p><p>以本文中例子，在訂單系統新增一條消息表，將新增訂單和新增消息放到一個事務裡完成，然後通過輪詢的方式去查詢消息表，將消息推送到 MQ，庫存系統去消費 MQ。</p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/406582f62d2741db9b6bf80f425e0057><p class=pgc-img-caption></p></div><p>執行流程：</p><ul><li>訂單系統，添加一條訂單和一條消息，在一個事務裡提交。</li><li>訂單系統，使用定時任務輪詢查詢狀態為未同步的消息表，發送到 MQ，如果發送失敗，就重試發送。</li><li>庫存系統，接收 MQ 消息，修改庫存表，需要保證冪等操作。</li><li>如果修改成功，調用 RPC 接口修改訂單系統消息表的狀態為已完成或者直接刪除這條消息。</li><li>如果修改失敗，可以不做處理，等待重試。</li></ul><p>訂單系統中的消息有可能由於業務問題會一直重複發送，所以為了避免這種情況可以記錄一下發送次數，當達到次數限制之後報警，人工接入處理；庫存系統需要保證冪等，避免同一條消息被多次消費造成數據一致。</p><p>本地消息表這種方案實現了最終一致性，需要在業務系統裡增加消息表，業務邏輯中多一次插入的 DB 操作，所以性能會有損耗，而且最終一致性的間隔主要由定時任務的間隔時間決定。</p><p><br></p><h4 class=pgc-h-arrow-right><strong>②MQ 消息事務</strong></h4><p>消息事務的原理是將兩個事務通過消息中間件進行異步解耦。</p><p>訂單系統執行自己的本地事務，併發送 MQ 消息，庫存系統接收消息，執行自己的本地事務。</p><p>乍一看，好像跟本地消息表的實現方案類似，只是省去了對本地消息表的操作和輪詢發送 MQ 的操作，但實際上兩種方案的實現是不一樣的。</p><p>消息事務一定要保證業務操作與消息發送的一致性，如果業務操作成功，這條消息也一定投遞成功。</p><p><br></p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/cf8a452263fd4bada279c2b54b3f9631><p class=pgc-img-caption></p></div><p>消息事務依賴於消息中間件的事務消息，基於消息中間件的二階段提交實現的，RocketMQ 就支持事務消息。</p><p><br></p><p>執行流程：</p><ul><li>發送 Prepare 消息到消息中間件。</li><li>發送成功後，執行本地事務。</li><li>如果事務執行成功，則 Commit，消息中間件將消息下發至消費端。</li><li>如果事務執行失敗，則回滾，消息中間件將這條 Prepare 消息刪除。</li><li>消費端接收到消息進行消費，如果消費失敗，則不斷重試。</li></ul><p><br></p><p>這種方案也是實現了最終一致性，對比本地消息表實現方案，不需要再建消息表，不再依賴本地數據庫事務了，所以這種方案更適用於高併發的場景。</p><p><br></p><h4 class=pgc-h-arrow-right><strong>③最大努力通知</strong></h4><p><br></p><p>最大努力通知相比前兩種方案實現簡單，適用於一些最終一致性要求較低的業務，比如支付通知，短信通知這種業務。</p><p><br></p><p>以支付通知為例，業務系統調用支付平臺進行支付，支付平臺進行支付，進行操作支付之後支付平臺會盡量去通知業務系統支付操作是否成功，但是會有一個最大通知次數。</p><p><br></p><p>如果超過這個次數後還是通知失敗，就不再通知，業務系統自行調用支付平臺提供一個查詢接口，供業務系統進行查詢支付操作是否成功。</p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/fd0e03c6281546c39cce510927a1756a><p class=pgc-img-caption></p></div><p>執行流程：</p><ul><li>業務系統調用支付平臺支付接口， 並在本地進行記錄，支付狀態為支付中。</li><li>支付平臺進行支付操作之後，無論成功還是失敗，都需要給業務系統一個結果通知。</li><li>如果通知一直失敗則根據重試規則進行重試，達到最大通知次數後，不再通知。</li><li>支付平臺提供查詢訂單支付操作結果接口。</li><li>業務系統根據一定業務規則去支付平臺查詢支付結果。</li></ul><p><br></p><p>這種方案也是實現了最終一致性。</p><p><br></p><h4 class=pgc-h-arrow-right><strong>④補償事務 TCC</strong></h4><p><br></p><p>TCC，Try-Confirm-Cancel 的簡稱，針對每個操作，都需要有一個其對應的確認和取消操作。</p><p><br></p><p>當操作成功時調用確認操作，當操作失敗時調用取消操作，類似於二階段提交，只不過是這裡的提交和回滾是針對業務上的，所以基於 TCC 實現的分佈式事務也可以看做是對業務的一種補償機制。</p><p><br></p><p>TCC 的三階段：</p><ul><li><strong>Try 階段：</strong>對業務系統做檢測及資源預留。</li><li><strong>Confirm 階段：</strong>對業務系統做確認提交，Try 階段執行成功並開始執行 Confirm 階段時，默認 Confirm 階段是不會出錯的。即：只要 Try 成功，Confirm 一定成功。</li><li><strong>Cancel 階段：</strong>在業務執行錯誤，需要回滾的狀態下執行的業務取消，預留資源釋放。</li></ul><p><br></p><p>在 Try 階段，是對業務系統進行檢查及資源預覽，比如訂單和存儲操作，需要檢查庫存剩餘數量是否夠用，並進行預留，預留操作的話就是新建一個可用庫存數量字段，Try 階段操作是對這個可用庫存數量進行操作。</p><p><br></p><p>比如下一個訂單減一個庫存：</p><div class=pgc-img><img alt=終於有人把“分佈式事務”說清楚了！ onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/8261b180a13f4431babf06959b5e1327><p class=pgc-img-caption></p></div><p>執行流程：</p><ul><li><strong>Try 階段：</strong>訂單系統將當前訂單狀態設置為支付中，庫存系統校驗當前剩餘庫存數量是否大於 1，然後將可用庫存數量設置為庫存剩餘數量 -1。</li><li>如果 Try 階段執行成功，執行 Confirm 階段，將訂單狀態修改為支付成功，庫存剩餘數量修改為可用庫存數量。</li><li>如果 Try 階段執行失敗，執行 Cancel 階段，將訂單狀態修改為支付失敗，可用庫存數量修改為庫存剩餘數量。</li></ul><p><br></p><p>基於 TCC 實現分佈式事務，代碼邏輯相對複雜一些，需要將原來的接口的邏輯拆分為：Try，Confirm ，Cancel 三個接口的邏輯。</p><p><br></p><p>基於 TCC 實現的分佈式事務框架：</p><ul><li>ByteTCC，github.com/liuyangming</li><li>tcc-transaction：github.com/changmingxi</li></ul><p><br></p><p>讀完之後應該對分佈式事務有了一個大致的瞭解，在實際生產中我們要儘量避免使用分佈式事務，能轉化為本地事務就用本地事務，如果必須使用分佈式事務，還需要從業務角度多思考使用哪種方案更適合，總之行動之前多思考。<br></p><blockquote class=pgc-blockquote-abstract><p>對了，在這裡說一下，我目前是在職Java開發，如果你現在正在學習Java，瞭解Java，渴望成為一名合格的Java開發工程師，在入門學習Java的過程當中缺乏基礎入門的視頻教程，可以關注並私信我：01。獲取。我這裡有最新的Java基礎全套視頻教程。</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>終於</a></li><li><a>事務</a></li><li><a>清楚</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/ab3fa24.html alt=終於有人把“TCC分佈式事務”實現原理講明白了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/5812b7b949d54aefb6f83be7b9f50aab style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/ab3fa24.html title=終於有人把“TCC分佈式事務”實現原理講明白了>終於有人把“TCC分佈式事務”實現原理講明白了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ab3719e.html alt=終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3553afe761fd4eea86e31ba84eb1ffeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ab3719e.html title=終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了>終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html alt=Mysql事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html title=Mysql事務>Mysql事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html alt=SpringBoot事務詳細簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html title=SpringBoot事務詳細簡介>SpringBoot事務詳細簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html alt=SqlServer使用事務注意事項，高級程序員必背 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html title=SqlServer使用事務注意事項，高級程序員必背>SqlServer使用事務注意事項，高級程序員必背</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>