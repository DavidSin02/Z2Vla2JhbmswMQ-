<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>50行代碼用Python實現遺傳進化算法 | 极客快訊</title><meta property="og:title" content="50行代碼用Python實現遺傳進化算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p3.pstatp.com/large/pgc-image/bbc57940a28945dd8682267e7209eae5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ab5a78b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ab5a78b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/ab5a78b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ab5a78b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ab5a78b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/ab5a78b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/ab5a78b.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ab5a78b.html><meta property="article:published_time" content="2020-10-29T20:46:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:33+08:00"><meta name=Keywords content><meta name=description content="50行代碼用Python實現遺傳進化算法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/ab5a78b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>50行代碼用Python實現遺傳進化算法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><p>學習如何用不到50行的代碼從頭開始編寫簡單的Evolutionary Algorithm，這些代碼可用於您的項目。 包含2個示例！</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/bbc57940a28945dd8682267e7209eae5><p class=pgc-img-caption>Photo by Johannes Plenio on Unsplash</p></div><p>進化算法是解決諸如優化問題之類的計算問題的特殊方法。 它們通常會在合理的時間內產生非常好的結果，而無需我們對特定於問題的屬性進行大量思考。 通常，我們只需要調整一些參數，然後運行一個相當通用的框架併為我們提供解決方案。 您將在本文中看到如何在Python中實現這種通用框架。</p><p>當處理極端困難的問題（例如NP完全問題）時，這尤其有趣。 這些是許多公司每天都必須解決的現實問題，而我們不知道任何有效的算法。 這些問題之一是旅行商問題（TSP）的優化版本，其表達方式如下：</p><blockquote class=pgc-blockquote-abstract><p>推銷員想在n個城市出售他的商品。他從城市1開始，以某種順序一次訪問其他n-1個城市，然後再次返回城市1。為了使出行距離最小化，遊覽城市的最佳順序是什麼？</p></blockquote><p>我們稍後將再次討論這個問題，作為應用我們的進化算法的一個重要例子。但是在我們去那裡之前，讓我們看看什麼是進化算法以及如何將它們應用到一個簡單的例子中。</p><h1 class=pgc-h-arrow-right>一個有趣的例子：MarI / O</h1><p>進化算法的一個有趣的應用是Seth Bling在" NEAT"論文的基礎上構建的MarI / O [3]。 使用進化算法從頭開始構建複雜的神經網絡架構，以玩經典的《超級馬里奧世界》。 懷舊開始。</p><p><br></p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/08b7eb5f9d9345afb89593c6178aeea5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>進化算法</h1><p>現在，我們將看到如何開發一種進化算法來解決一個簡單的函數最大化問題，即，我們想要找到使給定函數f的輸出最大化的輸入x。 例如，對於f（x，y）=-（x²+y²），唯一解是（x，y）=（0，0）。</p><p>該算法也可以輕鬆地用於解決TSP和其他問題。 但是首先，讓我們看看進化算法實際上是什麼。</p><p><strong>動機</strong></p><p>進化算法的設計類似於自然界的進化。其中，這三個概念是進化的核心：</p><ol start=1><li>有一群人。</li><li>個人可以繁殖和死亡。 這些事情的發生取決於它的適用性。 適應度越高，個體的屬性（DNA）在個體本身或後代中停留的時間就越長。</li><li>個人可以變異，即稍微改變其屬性。</li></ol><p>我們可以使用這些概念來創建一個元算法，即一種內部使用我們尚未指定的其他算法的算法來解決我們的問題。 不用擔心，我們會立即為您充滿生命。</p><p><strong>元算法</strong></p><ol start=1><li>隨機生成初始個體。</li><li>評估人口中每個人的健康狀況。</li><li>儘可能重複一次：a）選擇一個具有良好適應能力得分的個體進行繁殖。b）讓他們產生後代。c）對這些後代進行突變。d）評估種群中每個個體的適應性。f）讓個體具有繁殖力。 健\</li><li><br></li><li>評分不佳而死。</li><li>選擇適合度最高的個人作為解決方案。</li></ol><p>等等，這很籠統，不是嗎？ 有很多事情必須指定。</p><blockquote class=pgc-blockquote-abstract><p>什麼是個體？第一個種群中有多少個體？它們是如何產生的？哪些健身得分？多少父母產生了多少後代？ 究竟是什麼？如何變異？有多少人死亡？重複多少次？</p></blockquote><p>現在讓我們使用函數最大化的問題來說明如何具體實現元算法。</p><p><strong>一個簡單的例子</strong></p><p>讓我們以區間[0，4]上的函數f（x）=-x（x-1）（x-2）（x-3）（x-4）為例。我們希望找到一些價值，以最大限度地發揮這一作用。一個潛在的問題可能是1.4附近的局部最大值，我們不想找到它！</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/347b752449c64b30b8e65cc4d0deca6b><p class=pgc-img-caption>The x maximizing f is about 3.6, with a maximal value of also about 3.6.</p></div><p>讓我們看看是否可以使用進化算法來重現此內容。 因此，讓我們開始回答所有未解決的問題。</p><p><strong>有哪些個人？</strong></p><p>個人永遠是問題的潛在解決方案。</p><p>在我們的示例中，數字介於0和4之間，因為我們僅在此間隔內考慮此函數。 這個很容易，對吧？ 我保證，這不會比這困難得多。</p><p><strong>第一批人口中有多少個人？他們是如何產生的？</strong></p><p>個人數量是您必須組成的超參數。 如果您對解決方案一無所知，請儘可能隨機選擇初始種群。</p><p>在我們的例子中，我們如何使用10個隨機的個體，這些隨機的個體均勻地畫出0到4之間的數字？</p><p>我希望使用統一隨機元素是一個不錯的選擇，因為我們可以很好地覆蓋整個解決方案空間。 例如，如果我們使用均值為1.4的正態分佈，也許我們會將解決方案也推到1.4附近的錯誤局部最大值。</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/093d31d3e7664bc3902937be278fc5b2><p class=pgc-img-caption></p></div><blockquote class=pgc-blockquote-abstract><p>I have started with the individuals about 0.596, 1.067, 1.184, 1.431, 1.641, 1.792, 2.068, 2.495, 3.169, and 3.785.</p></blockquote><p><strong>哪個適應性得分？</strong></p><p>我們也必須彌補這一點。 我們的解決方案應具有最高的適應性得分。</p><p>我們希望最大化函數f，因此我們可以只使用函數f本身。</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/2f0d16c8fa484c19a11a9927ba069b4f><p class=pgc-img-caption></p></div><blockquote class=pgc-blockquote-abstract><p>The right-most individual has the highest fitness score of about 3.1. Some individuals have fitness scores of about 1 and three individuals even have a negative fitness score.</p></blockquote><p><strong>有多少父母生產多少後代？ 以及究竟如何？</strong></p><p>我們也必須彌補這一點。 所有的。</p><p>在我們的示例中，我們總是可以使用兩個人來產生一個後代。 我們也可以讓它們生產更多，但讓我們從這裡輕鬆開始。 因此，如果我們有兩個人（也稱為父母），那麼他們的後代可能就是他們的綜合。 例如，1.1和3.5的後代可以是2.3。 總共讓我們產生三個後代，總共使用六個不同的父母（即每個父母只有一個伴侶）。</p><p>同樣，這些都是我任意決定的事情。 您也可以使用其他策略來執行此步驟！ 每個後代使用一個或三個父母，使父母得到五個後代，一起玩。</p><p>適應度最高的六個人是數字1.792、1.184、3.169、1.641、1.431和3.785（按適應性升序排列）。 現在，假設此列表中的兩個鄰居有一個後代：</p><ul><li>1.792與1.184：1.488</li><li>3.169和1.641：2.405</li><li>1.431和3.785：2.608</li></ul><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/6470e95915234574b97a45935fcfe387><p class=pgc-img-caption>The miracle of life!</p></div><h1 class=pgc-h-arrow-right>如何變異？</h1><p>概率性地改變後代。 這是在不同地方探索更多可能解決方案的好方法，並且不會確定性地走錯路。</p><p>在我們的例子中，我們可以給每個後代加上高斯噪聲。 平均值為零，標準偏差為0.25很好。 另外，請記住：</p><p>個人必須成為潛在的解決方案！ 因此，突變一定不能將孩子趕出可行的區間[0，4]。 如果發生這種情況，請將子級設置為間隔的最近邊緣。</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/7a1728c8da5d43deb5f17a39a224b8dd><p class=pgc-img-caption>The orange points shifted a bit after the mutation.</p></div><p><strong>有多少人死亡？</strong></p><p>隨你喜歡。 在整個步驟中保持種群大小相同可能是件好事，因為否則種群數量可能會爆炸或每個人都在某個時間死亡。</p><p>由於我們現在的人口中有13個人，因此讓其中3個人死亡，最終我們會剩下10個人。 讓我們選擇適應性最差的那些，即舊個人0.596和2.495，以及新創建的個人2.121。</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/fbb7335b9fae43698ce19b9a2ad597d9><p class=pgc-img-caption>The circle of life.</p></div><h1 class=pgc-h-arrow-right>重複多久一次？</h1><p>隨你喜歡。 有時只需檢查一下，直到發現解決方案不再變得更好為止。</p><p>也許讓我們嘗試50個紀元，然後看看會發生什麼。 經過我們的人工進化，我們可以檢查所有個體並選擇得分最高的個體作為解決問題的方法。</p><p>直到時代的演變。 50個看起來像這樣：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/713149d65bfb462188cc9f80e7f5b597><p class=pgc-img-caption></p></div><p>我們可以看到該算法有效！ 但這似乎是一個緊要關頭。 直到第25個時代，人口都在x = 1.4附近聚集其他局部最大值。 幸運的是，我們有一個遠在4歲的人，從第25個時代開始就成功地將人口拉到了右側。</p><p>當查看每個時期人口中最佳個體的適應度得分時，我們還可以看到在時期25周圍的這種轉變。</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/f61704e8e84a4aeeac8f5e36eda422c8><p class=pgc-img-caption>It skyrocketed at around epoch 25.</p></div><h1 class=pgc-h-arrow-right>討論區</h1><p>好的，我們已經瞭解了算法的工作原理，並最終獲得了正確答案（或至少非常好的近似值）！ 有點運氣，但這永遠都是一樣的。 我們可能會更不幸，我們的初始人口可能始於x = 1.4的局部最大值附近。 那麼，個人突破該區域的可能性就很小，如本例所示：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/d1c809b6894f4f0cb3f07c1057c05145><p class=pgc-img-caption>A failed attempt. The algorithm only finds the wrong local maximum.</p></div><p>仍然可能是突變將一個人推向右側，這反過來又吸引了更多的人。 但這極不可能發生，因為標準偏差為0.25，因此突變在任何方向上最多將個體推向0.75的可能性> 99％。</p><p>那麼，使用更極端的變異好嗎？ 好吧，如果我們誇大其詞，個人只會跳到整個地方或聚集在x = 0和x = 4的角落。 因此，我們在這裡選擇參數時必須謹慎。</p><blockquote class=pgc-blockquote-abstract><p>從理論上講，您可以將演化算法視為高度隨機化的算法。初始種群是隨機的，個體通過或多或少的複雜操作產生後代，後代利用隨機性進行變異，所有這些重複了數百，數千，數百萬次。</p><p>因此，很難分析這些算法並對其成功概率或結果質量給出任何理論上的界限。 對於非常簡單的算法，這是可能的，例如用於最大化極簡單函數的（1 + 1）進化算法[1]或用於解決簡化多目標揹包問題[2]的算法，但是很少看到這樣的示例。</p><p>但是，如果運行不起作用，請使用相同或其他參數再次嘗試。</p></blockquote><h1 class=pgc-h-arrow-right>用Python實現</h1><p>在這裡，我將與您分享我的實現。 我試圖使它具有一般性和抽象性，因此您可以輕鬆地將其用於您的目的。</p><p>如果您以前從未使用過Abstract Base Classes，請不用擔心。 "Individual"類僅用於告訴您必須對代表個人的對象使用哪個接口。 您的個人需要一個值（有效載荷，潛在解決方案），您必須實現隨機初始化，變異和配對功能。</p><pre><code>import numpy as npfrom abc import ABC, abstractmethodclass Individual(ABC):    def __init__(self, value=None, init_params=None):        if value is not None:            self.value = value        else:            self.value = self._random_init(init_params)    @abstractmethod    def pair(self, other, pair_params):        pass    @abstractmethod    def mutate(self, mutate_params):        pass    @abstractmethod    def _random_init(self, init_params):        passclass Optimization(Individual):    def pair(self, other, pair_params):        return Optimization(pair_params['alpha'] * self.value + (1 - pair_params['alpha']) * other.value)    def mutate(self, mutate_params):        self.value += np.random.normal(0, mutate_params['rate'], mutate_params['dim'])        for i in range(len(self.value)):            if self.value[i] &lt; mutate_params['lower_bound']:                self.value[i] = mutate_params['lower_bound']            elif self.value[i] &gt; mutate_params['upper_bound']:                self.value[i] = mutate_params['upper_bound']    def _random_init(self, init_params):        return np.random.uniform(init_params['lower_bound'], init_params['upper_bound'], init_params['dim'])class Population:    def __init__(self, size, fitness, individual_class, init_params):        self.fitness = fitness        self.individuals = [individual_class(init_params=init_params) for _ in range(size)]        self.individuals.sort(key=lambda x: self.fitness(x))    def replace(self, new_individuals):        size = len(self.individuals)        self.individuals.extend(new_individuals)        self.individuals.sort(key=lambda x: self.fitness(x))        self.individuals = self.individuals[-size:]    def get_parents(self, n_offsprings):        mothers = self.individuals[-2 * n_offsprings::2]        fathers = self.individuals[-2 * n_offsprings + 1::2]        return mothers, fathersclass Evolution:    def __init__(self, pool_size, fitness, individual_class, n_offsprings, pair_params, mutate_params, init_params):        self.pair_params = pair_params        self.mutate_params = mutate_params        self.pool = Population(pool_size, fitness, individual_class, init_params)        self.n_offsprings = n_offsprings    def step(self):        mothers, fathers = self.pool.get_parents(self.n_offsprings)        offsprings = []        for mother, father in zip(mothers, fathers):            offspring = mother.pair(father, self.pair_params)            offspring.mutate(self.mutate_params)            offsprings.append(offspring)        self.pool.replace(offsprings)</code></pre><p>然後由Pool和Evolution類負責其餘的工作。 我還實現了函數最大化示例，以向您展示其外觀。 我在那裡使用了一些其他參數，但是如果將所有下限都替換為0，將所有下限替換為4，將比率替換為0.25，將dim替換為1，並且alpha = 0.5，您將再次得到我們的示例。</p><p>您可以像下面這樣使用這些類：</p><pre><code>from evo import Evolution, Optimizationdef fitness(opt):    return -opt.value[0] * (opt.value[0] - 1) * (opt.value[0] - 2) * (opt.value[0] - 3) * (opt.value[0] - 4)evo = Evolution(    pool_size=10, fitness=fitness, individual_class=Optimization, n_offsprings=3,    pair_params={'alpha': 0.5},    mutate_params={'lower_bound': 0, 'upper_bound': 4, 'rate': 0.25, 'dim': 1},    init_params={'lower_bound': 0, 'upper_bound': 4, 'dim': 1})n_epochs = 50for i in range(n_epochs):    evo.step()print(evo.pool.individuals[-1].value)</code></pre><p>然後離開！</p><p>到目前為止，我們已經對小玩具問題有了一定的信心，但是現在是時候重新回到困難的TSP了。</p><h1 class=pgc-h-arrow-right>旅行推銷員問題</h1><p>TSP旨在找到n個城市之間最短的往返路程。 使用這些作為示例：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/421b1120b820407793b70693a39a024c><p class=pgc-img-caption>Ten cities on a map.</p></div><p>TSP的解決方案如下所示：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/5aaf8ed3d4d040949825f7c65a327a51><p class=pgc-img-caption>The shortest round trip visiting all cities.</p></div><p><strong>一些事實</strong></p><p>存在許多算法來解決這一問題。 它們的範圍從詳盡的搜索（嘗試所有方法）到更復雜的算法。 但是，所有這些方法都很慢，並且如果P≠NP，我們將永遠無法期待任何快速算法。</p><p>如果可以等待幾天，詳盡的搜索將使您最多可以解決15個城市的問題。 其他方法（例如Held-Karp算法）使您可以樂觀地求解多達30–50個城市的實例。</p><p>如果您不再需要最佳解決方案，那麼1976年的Christofides算法將在很短的時間內為您提供解決方案，與最短的往返時間相比，最長可證明延長了50％。</p><blockquote class=pgc-blockquote-abstract><p>想想為什麼這是一個很棒的結果：我們甚至都不知道最短的往返長度，但是仍然可以說，這種算法的往返收益比這個未知的解決方案長不到50％！</p></blockquote><p>但是，現在，讓我們為您提供等待的結果：一種解決TSP的進化算法！</p><h1 class=pgc-h-arrow-right>一種求解TSP的進化算法</h1><p>這次，我們從20個城市開始。 數量仍然很低，無法使用Held-Karp算法解決，因此我們甚至可以檢查最終是否獲得了最佳解決方案！ 這是地圖：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/b66570e84ea14873b8ae552b98fcaaa0><p class=pgc-img-caption></p></div><blockquote class=pgc-blockquote-abstract><p>Twenty cities on a map. Let's not even bother trying an exhaustive search on this one. Maybe these cities don't even exist anymore until we get the shortest round trip.</p></blockquote><p>現在，我們必須再次回答所有問題。 讓我們首先回答更簡單的"數字問題"（如果事情不起作用，我們可以輕鬆調整的超參數）：</p><ul><li>多少代？ 1000</li><li>有多少個起始個人？ 100</li><li>有多少父母？ 60（兩個像以前一樣生出一個後代）</li><li>有多少後代？ 30</li><li>有多少垂死的人？ 30</li></ul><p>令人興奮的問題是關於我們現在必須定義的類TSP的實現。 有哪些個人？ 隨機初始化如何工作？ 配對？ 突變？ 健身得分是多少？</p><p><strong>初始人口</strong></p><p>讓我們從一個基本的開始：這裡的個人是什麼？ 提示：這不是城市。 再次：</p><p>個人永遠是問題的潛在解決方案。</p><p>對於TSP，我們搜索短程往返。 "短"是指往返中每兩個城市之間的歐幾里得距離之和。 我們可以將這樣的往返表示為n個數字的列表，例如 （0、3、1）顯示為"從城市0開始，然後轉到城市3，從那裡到城市1，然後回到城市0。"。 因此，我們的個人是一個數字列表，每個數字從0到n-1恰好包含一次，即{0，1，2，…，n-1}上的排列。</p><blockquote class=pgc-blockquote-abstract><p>在整個過程中，我們必須維護此屬性。 保留人口中的某個個體並不能代表該問題的可行解決方案是沒有意義的，因為它阻塞了人口，我們甚至可能最終選擇它，從而給我們提供了無效的解決方案。</p></blockquote><p>以及如何初始化它們？ 好吧，只是對數字從0到n-1進行隨機排列。 這應該做的工作。</p><pre><code>def _random_init(self, init_params):    return np.random.choice(        a=range(init_params['n_cities']),        size=init_params['n_cities'],        replace=False    )</code></pre><p>讓我們繼續進行突變過程。</p><p><strong>突變</strong></p><p>那麼，我們如何以一種簡單的方式改變往返行程呢？ 想象一下，我們有一個往返於五個城市的旅行，例如（3、1、4、2、0）。 一種簡單的方法是隨機交換兩個元素。 我們的示例可以更改為（0，1，4，2，2，3）或（3，4，1，2，0）。 我們還可以交換多次，並使其中的超參數速率與之前的函數最大化示例中的標準偏差相當。</p><pre><code>def mutate(self, mutate_params):    for _ in range(mutate_params['rate']):        i, j = np.random.choice(            a=range(len(self.value)),            size=2,            replace=False)        self.value[i], self.value[j] = self.value[j], self.value[i]</code></pre><p><br></p><p>顯然，這種突變保留了屬性，即個體是置換，即可行的解決方案。</p><p>這裡最有趣的事情可能是pair函數。</p><p><strong>配對</strong></p><p>讓我們假設我們有以下要用作父母的個人：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/1b419c8d9d344a0b8e076e922254bb61><p class=pgc-img-caption></p></div><p>您可以執行以下操作：將第二個人的右半部分複製到第一個人的右半部分。</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c16a35f7f0c949df8f58a158f94ae1c6><p class=pgc-img-caption></p></div><blockquote class=pgc-blockquote-abstract><p>The right half of the first individual gets replaced. The 4 replaces the old 5, 2 replaces 3, and 3 replaces 1.</p></blockquote><p>我們現在要使用更改後的第一個個體作為後代，但是由於現在有重複的數字，因此無法按原樣工作。 因此，必須首先修復變更後的第一個人的左半部分。 我們可以這樣做：</p><p>插入右半部分的4踢出了之前的5。 因此，讓我們將左半部分的4替換為5，因為現在缺少了。 用2踢出3來做同樣的事情，得出以下結果：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/393530f8fc9841b5b2a1b5699f1b8bdf><p class=pgc-img-caption></p></div><p>但是還有一個問題：我們現在兩次有3。 但是我們可以重複此過程多次，直到再次獲得可行的個體為止。 3是問題所在。 它最初以1踢出。因此用左1替換左3，然後瞧：後代是（0，5，1，4，4，2，3）。</p><p><strong>實現</strong></p><p>總的來說，我們的TSP類如下所示：</p><pre><code>class TSP(Individual):    def pair(self, other, pair_params):        self_head = self.value[:int(len(self.value) * pair_params['alpha'])].copy()        self_tail = self.value[int(len(self.value) * pair_params['alpha']):].copy()        other_tail = other.value[int(len(other.value) * pair_params['alpha']):].copy()        mapping = {other_tail[i]: self_tail[i] for i in range(len(self_tail))}        for i in range(len(self_head)):            while self_head[i] in other_tail:                self_head[i] = mapping[self_head[i]]        return TSP(np.hstack([self_head, other_tail]))    def mutate(self, mutate_params):        for _ in range(mutate_params['rate']):            i, j = np.random.choice(range(len(self.value)), 2, replace=False)            self.value[i], self.value[j] = self.value[j], self.value[i]    def _random_init(self, init_params):        return np.random.choice(range(init_params['n_cities']), init_params['n_cities'], replace=False)</code></pre><p>在這裡，我還介紹了另一個超參數alpha，它決定了在何處分割個人。 在我的示例中，我使用alpha = 0.5。</p><p><strong>適應性得分</strong></p><p>由於我們希望最小化往返行程的長度，因此我們可以使用減去往返行程的長度作為適應度得分。</p><h1 class=pgc-h-arrow-right>實驗</h1><p>讓我們用20個城市解決TSP！ 我使用以下代碼：我定義了適應度函數，一個用於計算往返長度的函數以及一個用於計算距離矩陣（兩個城市之間的成對距離）的函數。</p><pre><code>import numpy as npfrom evo import Evolution, TSPimport matplotlib.pyplot as pltdef tsp_fitness_creator(cities):    matrix = []    for city in cities:        row = []        for city_ in cities:            row.append(np.linalg.norm(city - city_))        matrix.append(row)    distances = np.array(matrix)    def fitness(tsp):        res = 0        for i in range(len(tsp.value)):            res += distances[tsp.value[i], tsp.value[(i + 1) % len(tsp.value)]]        return -res    return fitnessdef compute_distances(cities):    distances = []    for from_city in cities:        row = []        for to_city in cities:            row.append(np.linalg.norm(from_city - to_city))        distances.append(row)    return np.array(distances)def route_length(distances, route):    length = 0    for i in range(len(route)):        length += distances[route[i], route[(i + 1) % len(route)]]    return lengthdef plot_route(cities, route, distances):    length = route_length(distances, route)    plt.figure(figsize=(12, 8))    plt.scatter(x=cities[:, 0], y=cities[:, 1], s=1000, zorder=1)    for i in range(len(cities)):        plt.text(cities[i][0], cities[i][1], str(i), horizontalalignment='center', verticalalignment='center', size=16,                 c='white')    for i in range(len(route)):        plt.plot([cities[route[i]][0], cities[route[(i + 1) % len(route)]][0]],                 [cities[route[i]][1], cities[route[(i + 1) % len(route)]][1]], 'k', zorder=0)    if len(route)&gt;0:        plt.title(f'Visiting {len(route)} cities in length {length:.2f}', size=16)    else:        plt.title(f'{len(cities)} cities', size=16)    plt.show()cities = np.array([[35, 51],                   [113, 213],                   [82, 280],                   [322, 340],                   [256, 352],                   [160, 24],                   [322, 145],                   [12, 349],                   [282, 20],                   [241, 8],                   [398, 153],                   [182, 305],                   [153, 257],                   [275, 190],                   [242, 75],                   [19, 229],                   [303, 352],                   [39, 309],                   [383, 79],                   [226, 343]])fitness = tsp_fitness_creator(cities)distances = compute_distances(cities)evo = Evolution(    pool_size=100, fitness=fitness, individual_class=TSP, n_offsprings=30,    pair_params={'alpha': 0.5},    mutate_params={'rate': 1},    init_params={'n_cities': 20})n_epochs = 1000hist = []for i in range(n_epochs):    hist.append(evo.pool.fitness(evo.pool.individuals[-1]))    evo.step()plt.plot(hist)plt.show()plot_route(cities, route=evo.pool.individuals[-1].value, distances=distances)</code></pre><p>對我來說，適應度函數的行為如下：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/d368fc155dff47de830f768732cc337e><p class=pgc-img-caption></p></div><p>以下是每個時代的最佳個人：</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/999b23fdb6784f30bfbbdb6006a16c2e><p class=pgc-img-caption>The evolution of the solution. After epoch 400 nothing changes anymore.</p></div><h1 class=pgc-h-arrow-right>更多城市！</h1><p>對於最後一幕，讓我們嘗試一些非常困難的事情。 不僅有10個或20個城市，而且還有100個城市，這對於任何精確的算法來說都太多了。</p><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/c4611482bb97447b837b68defcd5c9b7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=50行代碼用Python實現遺傳進化算法 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/3f0515b987084e91b0feea67c5b7d454><p class=pgc-img-caption>From a very chaotic to a much cleaner and shorter round trip.</p></div><p>我不能告訴你這是否是最快的往返行程，但是對我來說，這絕對是一個不錯的選擇！</p><h1 class=pgc-h-arrow-right>結論</h1><p>在本文中，我們通過兩個示例瞭解了進化算法的工作原理：最大化函數並解決Traveling Salesman問題。進化算法通常用於解決我們不知道確切答案的難題。該算法可以非常快速併產生準確的結果。實施起來很容易，並且您不必成為問題所在領域的專家，例如您無需閱讀過去20年來TSP研究的論文即可編寫出性能出色的算法。</p><p>可悲的是，很難獲得任何理論結果，因為進化算法通常會以複雜的方式交互作用於許多隨機性。 因此，我們不知道給出的解決方案是好是壞，我們只能檢查它對於我們的用例是否足夠好。 在100個城市的示例中，如果我們的目標是前往每個城市的長度不超過15萬，則該算法為我們提供了一個完美的答案。</p><h1 class=pgc-h-arrow-right>參考文獻</h1><p>[1] S. Droste，T。Jansen和I. Wegener，關於（1 + 1）進化算法的分析（2002），理論計算機科學，第276卷，第1-2期，2002年4月6日，第51頁–81</p><p>[2] M. Laumanns，L。Thiele和E. Zitzler，關於簡化多目標揹包問題的進化算法的運行時間分析（2004），自然計算3，37–51</p><p>[3] K. Stanley，R。Miikkulainen，"通過增強拓撲結構演化神經網絡（2002），進化計算10（2）2002，S。99-127"</p><p><br></p><p>我希望我能教給你一些有用的東西。</p><p>謝謝閱讀！</p><p><br></p><p>(本文翻譯自Dr. Robert Kübler的文章《An extensible Evolutionary Algorithm Example in Python》，參考：https://towardsdatascience.com/an-extensible-evolutionary-algorithm-example-in-python-7372c56a557b)</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>50</a></li><li><a>行代碼</a></li><li><a>Python</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8aed1d9.html alt=魔性又健康！淄博50多名老人每天聚在一起哈哈大笑 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SBb090Q36smG7Y style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8aed1d9.html title=魔性又健康！淄博50多名老人每天聚在一起哈哈大笑>魔性又健康！淄博50多名老人每天聚在一起哈哈大笑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d7b1999c.html alt=中國有一條長達50公里內陸戈壁腹地，竟然深藏一個巨大迷宮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1538199204255b651f767a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d7b1999c.html title=中國有一條長達50公里內陸戈壁腹地，竟然深藏一個巨大迷宮>中國有一條長達50公里內陸戈壁腹地，竟然深藏一個巨大迷宮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bff930d4.html alt=50張實用電路圖，看懂這些，其他電路不攻自破 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/203d9178a98c41dda81f5ca2637faa4f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bff930d4.html title=50張實用電路圖，看懂這些，其他電路不攻自破>50張實用電路圖，看懂這些，其他電路不攻自破</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8afcf30e.html alt="北汽株洲公司享受檢定費減免50萬元  其它企業也可這樣申請" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a845614a41984085a76be7211341ad10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8afcf30e.html title="北汽株洲公司享受檢定費減免50萬元  其它企業也可這樣申請">北汽株洲公司享受檢定費減免50萬元 其它企業也可這樣申請</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html alt=Python爬蟲教程，利用Python採集QQ群成員信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d6cce76ad48405c9dbb960d4617bcef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html title=Python爬蟲教程，利用Python採集QQ群成員信息>Python爬蟲教程，利用Python採集QQ群成員信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html alt=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5d4a0000046e1bea8b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html title=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？>Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d62be41.html alt=兩臺就能驅動航母！國產50兆瓦燃氣輪機攻克，超055萬噸大驅動力 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b6f60291080c424296462ab0c2a2505c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d62be41.html title=兩臺就能驅動航母！國產50兆瓦燃氣輪機攻克，超055萬噸大驅動力>兩臺就能驅動航母！國產50兆瓦燃氣輪機攻克，超055萬噸大驅動力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ac280bd.html alt=50年的時間過去，我國的電子計算機發展到了什麼地步？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/460e4566-11a4-41c4-84f2-c7ac027f57ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ac280bd.html title=50年的時間過去，我國的電子計算機發展到了什麼地步？>50年的時間過去，我國的電子計算機發展到了什麼地步？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html alt=Python中的多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49dd44b999924b69bd3396709ecacaf4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html title=Python中的多進程>Python中的多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html alt="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html title="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結">Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>