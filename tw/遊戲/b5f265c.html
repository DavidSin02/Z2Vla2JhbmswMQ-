<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文讀懂遺傳算法工作原理！附Python實現 | 极客快訊</title><meta property="og:title" content="一文讀懂遺傳算法工作原理！附Python實現 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/fde5cfc48c5a45d4891d621c7b4cc5e4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/b5f265c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/b5f265c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/b5f265c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/b5f265c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/b5f265c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/b5f265c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/b5f265c.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/b5f265c.html><meta property="article:published_time" content="2020-10-29T20:46:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:33+08:00"><meta name=Keywords content><meta name=description content="一文讀懂遺傳算法工作原理！附Python實現"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/b5f265c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文讀懂遺傳算法工作原理！附Python實現</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><div><p>點擊上方 "程序員小樂"關注, 星標或置頂一起成長</p><p>每天凌晨00點00分, 第一時間與你相約</p><p><br></p><p>每日英文</p><p>Face your fears and wipe your tears, wake up everyday and be stronger than yesterday.</p><p>面對恐懼，擦乾眼淚，每一天醒來都要比昨天更堅強。</p><p><br></p><p>每日掏心話</p><p>我們經歷了風雨，就已不在乎人生是否有彩虹，最重要的是我們曾經走過。</p><p>來自：公眾號 機器之心 | 責編：樂樂</p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/fde5cfc48c5a45d4891d621c7b4cc5e4></div></div></p><p>程序員小樂(ID:study_tech)第 857 次推文 圖源：百度</p><p><br></p><p>往日回顧：雷軍 1994 年寫的代碼，像詩一樣優雅！不服不行！</p><p><br></p><p>正文</p><p><br></p><p>近日，Analyticsvidhya 上發表了一篇題為《Introduction to Genetic Algorithm & their application in data science》的文章，作者 Shubham Jain 現身說法，用通俗易懂的語言對遺傳算法作了一個全面而扼要的概述，並列舉了其在多個領域的實際應用，其中重點介紹了遺傳算法的數據科學應用。機器之心對該文進行了編譯，原文鏈接請見文末。</p><p>簡介</p><p><br></p><p>幾天前，我著手解決一個實際問題——大型超市銷售問題。在使用了幾個簡單模型做了一些特徵工程之後，我在排行榜上名列第 219 名。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/3caab167bcb944508c04e23013a296fa></div></div><br></p><p><br></p><p>雖然結果不錯，但是我還是想做得更好。於是，我開始研究可以提高分數的優化方法。結果我果然找到了一個，它叫遺傳算法。在把它應用到超市銷售問題之後，最終我的分數在排行榜上一下躍居前列。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/6ba9cca2b9a84821886716a8f28418aa></div></div><br></p><p><br></p><p>沒錯，僅靠遺傳算法我就從 219 名直接跳到 15 名，厲害吧！相信閱讀完本篇文章後，你也可以很自如地應用遺傳算法，而且會發現，當把它用到你自己正在處理的問題時，效果也會有很大提升。</p><p><br></p><p>目錄</p><p><br></p><p>1、遺傳算法理論的由來</p><p>2、生物學的啟發</p><p>3、遺傳算法定義</p><p>4、遺傳算法具體步驟</p><p><br></p><ul class=list-paddingleft-2><li><p>初始化<br></p></li><li><p>適應度函數<br></p></li><li><p>選擇<br></p></li><li><p>交叉<br></p></li><li><p>變異<br></p></li></ul><p><br></p><p>5、遺傳算法的應用</p><p><br></p><ul class=list-paddingleft-2><li><p>特徵選取<br></p></li><li><p>使用 TPOT 庫實現<br></p></li></ul><p><br></p><p>6、實際應用</p><p>7、結語</p><p><br></p><p>1、遺傳算法理論的由來</p><p><br></p><p>我們先從查爾斯·達爾文的一句名言開始：</p><p><br></p><p>能夠生存下來的往往不是最強大的物種，也不是最聰明的物種，而是最能適應環境的物種。</p><p><br></p><p>你也許在想：這句話和遺傳算法有什麼關係？其實遺傳算法的整個概念就基於這句話。</p><p>讓我們用一個基本例子來解釋 ：</p><p><br></p><p>我們先假設一個情景，現在你是一國之王，為了讓你的國家免於災禍，你實施了一套法案：</p><p><br></p><ul class=list-paddingleft-2><li><p>你選出所有的好人，要求其通過生育來擴大國民數量。<br></p></li><li><p>這個過程持續進行了幾代。<br></p></li><li><p>你將發現，你已經有了一整群的好人。<br></p></li></ul><p><br></p><p>這個例子雖然不太可能，但是我用它是想幫助你理解概念。也就是說，我們改變了輸入值（比如：人口），就可以獲得更好的輸出值（比如：更好的國家）。現在，我假定你已經對這個概念有了大致理解，認為遺傳算法的含義應該和生物學有關係。那麼我們就快速地看一些小概念，這樣便可以將其聯繫起來理解。</p><p><br></p><p>2、生物學的啟發</p><p><br></p><p>相信你還記得這句話：「細胞是所有生物的基石。」由此可知，在一個生物的任何一個細胞中，都有著相同的一套染色體。所謂染色體，就是指由 DNA 組成的聚合體。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c69383b7975941cf8a4224b4c72fc44c></div></div><br></p><p><br></p><p>傳統上看，這些染色體可以被由數字 0 和 1 組成的字符串表達出來。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/b366234c7dab4e84ad075f4f7eab48b6></div></div><br></p><p><br></p><p>一條染色體由基因組成，這些基因其實就是組成 DNA 的基本結構，DNA 上的每個基因都編碼了一個獨特的性狀，比如，頭髮或者眼睛的顏色。希望你在繼續閱讀之前先回憶一下這裡提到的生物學概念。結束了這部分，現在我們來看看所謂遺傳算法實際上指的是什麼？</p><p><br></p><p>3、遺傳算法定義</p><p><br></p><p>首先我們回到前面討論的那個例子，並總結一下我們做過的事情。</p><p><br></p><ul class=list-paddingleft-2><li><p>首先，我們設定好了國民的初始人群大小。<br></p></li><li><p>然後，我們定義了一個函數，用它來區分好人和壞人。<br></p></li><li><p>再次，我們選擇出好人，並讓他們繁殖自己的後代。<br></p></li><li><p>最後，這些後代們從原來的國民中替代了部分壞人，並不斷重複這一過程。<br></p></li></ul><p><br></p><p>遺傳算法實際上就是這樣工作的，也就是說，它基本上盡力地在某種程度上模擬進化的過程。</p><p><br></p><p>因此，為了形式化定義一個遺傳算法，我們可以將它看作一個優化方法，它可以嘗試找出某些輸入，憑藉這些輸入我們便可以得到最佳的輸出值或者是結果。遺傳算法的工作方式也源自於生物學，具體流程見下圖：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/220ecbb67ed446f8bfe86385363ac39d></div></div><br></p><p><br></p><p>那麼現在我們來逐步理解一下整個流程。</p><p><br></p><p>4、遺傳算法具體步驟</p><p><br></p><p>為了讓講解更為簡便，我們先來理解一下著名的組合優化問題「揹包問題」。如果你還不太懂，這裡有一個我的解釋版本。</p><p><br></p><p>比如，你準備要去野遊 1 個月，但是你只能背一個限重 30 公斤的揹包。現在你有不同的必需物品，它們每一個都有自己的「生存點數」（具體在下表中已給出）。因此，你的目標是在有限的揹包重量下，最大化你的「生存點數」。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/5ff6326005e944418bea848f4923b43d></div></div><br></p><p><br></p><p>4.1 初始化</p><p><br></p><p>這裡我們用遺傳算法來解決這個揹包問題。第一步是定義我們的總體。總體中包含了個體，每個個體都有一套自己的染色體。</p><p><br></p><p>我們知道，染色體可表達為二進制數串，在這個問題中，1 代表接下來位置的基因存在，0 意味著丟失。（譯者注：作者這裡借用染色體、基因來解決前面的揹包問題，所以特定位置上的基因代表了上方揹包問題表格中的物品，比如第一個位置上是 Sleeping Bag，那麼此時反映在染色體的『基因』位置就是該染色體的第一個『基因』。）</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/8035fcbb1f8a4ce8915f9e42221fd034></div></div><br></p><p><br></p><p>現在，我們將圖中的 4 條染色體看作我們的總體初始值。</p><p><br></p><p>4.2 適應度函數</p><p><br></p><p>接下來，讓我們來計算一下前兩條染色體的適應度分數。對於 A1 染色體 [100110] 而言，有：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/c7d860ae06894e64be644620184ae6e4></div></div><br></p><p><br></p><p>類似地，對於 A2 染色體 [001110] 來說，有：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/30b944d5bda04623b6dd492060df07ab></div></div><br></p><p><br></p><p>對於這個問題，我們認為，當染色體包含更多生存分數時，也就意味著它的適應性更強。</p><p>因此，由圖可知，染色體 1 適應性強於染色體 2。</p><p><br></p><p>4.3 選擇</p><p><br></p><p>現在，我們可以開始從總體中選擇適合的染色體，來讓它們互相『交配』，產生自己的下一代了。這個是進行選擇操作的大致想法，但是這樣將會導致染色體在幾代之後相互差異減小，失去了多樣性。因此，我們一般會進行「輪盤賭選擇法」（Roulette Wheel Selection method）。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/a020005ffe964f5f886f7afe9423da0d></div></div><br></p><p><br></p><p>想象有一個輪盤，現在我們將它分割成 m 個部分，這裡的 m 代表我們總體中染色體的個數。每條染色體在輪盤上佔有的區域面積將根據適應度分數成比例表達出來。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/39653c9f00c347e8a932eb0bb60bbac7></div></div><br></p><p><br></p><p>基於上圖中的值，我們建立如下「輪盤」。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/f7b0c9247c714f4393d37244f8a9774a></div></div><br></p><p><br></p><p>現在，這個輪盤開始旋轉，我們將被圖中固定的指針（fixed point）指到的那片區域選為第一個親本。然後，對於第二個親本，我們進行同樣的操作。有時候我們也會在途中標註兩個固定指針，如下圖：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/9cbc69b3d0fd43d89a6c661973304b69></div></div><br></p><p><br></p><p>通過這種方法，我們可以在一輪中就獲得兩個親本。我們將這種方法成為「隨機普遍選擇法」（Stochastic Universal Selection method）。</p><p><br></p><p>4.4 交叉</p><p><br></p><p>在上一個步驟中，我們已經選擇出了可以產生後代的親本染色體。那麼用生物學的話說，所謂「交叉」，其實就是指的繁殖。現在我們來對染色體 1 和 4（在上一個步驟中選出來的）進行「交叉」，見下圖：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/5613dffde3c04fae85f88cb03352c4d9></div></div><br></p><p><br></p><p>這是交叉最基本的形式，我們稱其為「單點交叉」。這裡我們隨機選擇一個交叉點，然後，將交叉點前後的染色體部分進行染色體間的交叉對調，於是就產生了新的後代。</p><p>如果你設置兩個交叉點，那麼這種方法被成為「多點交叉」，見下圖：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/f07aa3c87d4943fbbf04b4de61edc9d3></div></div><br></p><p><br></p><p>4.5 變異</p><p><br></p><p>如果現在我們從生物學的角度來看這個問題，那麼請問：由上述過程產生的後代是否有和其父母一樣的性狀呢？答案是否。在後代的生長過程中，它們體內的基因會發生一些變化，使得它們與父母不同。這個過程我們稱為「變異」，它可以被定義為染色體上發生的隨機變化，正是因為變異，種群中才會存在多樣性。</p><p><br></p><p>下圖為變異的一個簡單示例：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/4d116009ae9a41abb68a2702eefa923d></div></div><br></p><p><br></p><p>變異完成之後，我們就得到了新為個體，進化也就完成了，整個過程如下圖：</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/49aa4cee48184a16b6cfa24a80f49c7e></div></div><br></p><p><br></p><p>在進行完一輪「遺傳變異」之後，我們用適應度函數對這些新的後代進行驗證，如果函數判定它們適應度足夠，那麼就會用它們從總體中替代掉那些適應度不夠的染色體。這裡有個問題，我們最終應該以什麼標準來判斷後代達到了最佳適應度水平呢？</p><p><br></p><p>一般來說，有如下幾個終止條件：</p><p><br></p><ul class=list-paddingleft-2><li><p>在進行 X 次迭代之後，總體沒有什麼太大改變。<br></p></li><li><p>我們事先為算法定義好了進化的次數。<br></p></li><li><p>當我們的適應度函數已經達到了預先定義的值。<br></p></li></ul><p><br></p><p>好了，現在我假設你已基本理解了遺傳算法的要領，那麼現在讓我們用它在數據科學的場景中應用一番。</p><p><br></p><p>5、遺傳算法的應用</p><p><br></p><p>5.1 特徵選取</p><p><br></p><p>試想一下每當你參加一個數據科學比賽，你會用什麼方法來挑選那些對你目標變量的預測來說很重要的特徵呢？你經常會對模型中特徵的重要性進行一番判斷，然後手動設定一個閾值，選擇出其重要性高於這個閾值的特徵。</p><p><br></p><p>那麼，有沒有什麼方法可以更好地處理這個問題呢？其實處理特徵選取任務最先進的算法之一就是遺傳算法。</p><p><br></p><p>我們前面處理揹包問題的方法可以完全應用到這裡。現在，我們還是先從建立「染色體」總體開始，這裡的染色體依舊是二進制數串，「1」表示模型包含了該特徵，「0 表示模型排除了該特徵」。</p><p><br></p><p>不過，有一個不同之處，即我們的適應度函數需要改變一下。這裡的適應度函數應該是這次比賽的的精度的標準。也就是說，如果染色體的預測值越精準，那麼就可以說它的適應度更高。</p><p><br></p><p>現在我假設你已經對這個方法有點一概念了。下面我不會馬上講解這個問題的解決過程，而是讓我們先來用 TPOT 庫去實現它。</p><p><br></p><p>5.2 用 TPOT 庫來實現</p><p><br></p><p>這個部分相信是你在一開始讀本文時心裡最終想實現的那個目標。即：實現。那麼首先我們來快速瀏覽一下 TPOT 庫（Tree-based Pipeline Optimisation Technique，樹形傳遞優化技術），該庫基於 scikit-learn 庫建立。下圖為一個基本的傳遞結構。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/5c60da90fe844a3b9d4061df5da012c2></div></div><br></p><p><br></p><p>圖中的灰色區域用 TPOT 庫實現了自動處理。實現該部分的自動處理需要用到遺傳算法。</p><p>我們這裡不深入講解，而是直接應用它。為了能夠使用 TPOT 庫，你需要先安裝一些 TPOT 建立於其上的 python 庫。下面我們快速安裝它們：</p><p><br></p><p># installing DEAP, update_checker and tqdm<br><br>pip install deap update_checker tqdm<br># installling TPOT<br>pip install tpot</p><p><br></p><p>這裡，我用了 Big Mart Sales（數據集地址：https://datahack.analyticsvidhya.com/contest/practice-problem-big-mart-sales-iii/）數據集，為實現做準備，我們先快速下載訓練和測試文件，以下是 python 代碼：</p><p><br></p><p># import basic libraries<br><br>import numpy as np<br>import pandas as pd<br>import matplotlib.pyplot as plt<br>%matplotlib inline<br>from sklearn import preprocessing<br>from sklearn.metrics import mean_squared_error<br>## preprocessing<br>### mean imputations<br><br>train['Item_Weight'].fillna((train['Item_Weight'].mean()), inplace=True)<br>test['Item_Weight'].fillna((test['Item_Weight'].mean()), inplace=True)<br>### reducing fat content to only two categories<br><br>train['Item_Fat_Content'] = train['Item_Fat_Content'].replace(['low fat','LF'], ['Low Fat','Low Fat'])<br>train['Item_Fat_Content'] = train['Item_Fat_Content'].replace(['reg'], ['Regular'])<br>test['Item_Fat_Content'] = test['Item_Fat_Content'].replace(['low fat','LF'], ['Low Fat','Low Fat'])<br>test['Item_Fat_Content'] = test['Item_Fat_Content'].replace(['reg'], ['Regular'])<br>train['Outlet_Establishment_Year'] = 2013 - train['Outlet_Establishment_Year']<br>test['Outlet_Establishment_Year'] = 2013 - test['Outlet_Establishment_Year']<br><br>train['Outlet_Size'].fillna('Small',inplace=True)<br>test['Outlet_Size'].fillna('Small',inplace=True)<br><br>train['Item_Visibility'] = np.sqrt(train['Item_Visibility'])<br>test['Item_Visibility'] = np.sqrt(test['Item_Visibility'])<br><br>col = ['Outlet_Size','Outlet_Location_Type','Outlet_Type','Item_Fat_Content']<br>test['Item_Outlet_Sales'] = 0combi = train.append(test)for i in col:<br>combi[i] = number.fit_transform(combi[i].astype('str'))<br>combi[i] = combi[i].astype('object')<br>train = combi[:train.shape[0]]<br>test = combi[train.shape[0]:]<br>test.drop('Item_Outlet_Sales',axis=1,inplace=True)<br>## removing id variables<br><br>tpot_train = train.drop(['Outlet_Identifier','Item_Type','Item_Identifier'],axis=1)<br>tpot_test = test.drop(['Outlet_Identifier','Item_Type','Item_Identifier'],axis=1)<br>target = tpot_train['Item_Outlet_Sales']<br>tpot_train.drop('Item_Outlet_Sales',axis=1,inplace=True)<br># finally building model using tpot library<br><br>from tpot import TPOTRegressor<br>X_train, X_test, y_train, y_test = train_test_split(tpot_train, target,<br>train_size=0.75, test_size=0.25)<br><br>tpot = TPOTRegressor(generations=5, population_size=50, verbosity=2)<br>tpot.fit(X_train, y_train)<br>print(tpot.score(X_test, y_test))<br>tpot.export('tpot_boston_pipeline.py')</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c55a0b9f2ba94a06b2fe9db75ec76240></div></div><br></p><p><br></p><p>一旦這些代碼運行完成，tpot_exported_pipeline.py 裡就將會放入用於路徑優化的 python 代碼。我們可以發現，ExtraTreeRegressor 可以最好地解決這個問題。</p><p><br></p><p>## predicting using tpot optimised pipeline<br><br>tpot_pred = tpot.predict(tpot_test)<br>sub1 = pd.DataFrame(data=tpot_pred)<br>#sub1.index = np.arange(0, len(test)+1)<br><br>sub1 = sub1.rename(columns = {'0':'Item_Outlet_Sales'})<br>sub1['Item_Identifier'] = test['Item_Identifier']<br>sub1['Outlet_Identifier'] = test['Outlet_Identifier']<br>sub1.columns = ['Item_Outlet_Sales','Item_Identifier','Outlet_Identifier']<br>sub1 = sub1[['Item_Identifier','Outlet_Identifier','Item_Outlet_Sales']]<br>sub1.to_csv('tpot.csv',index=False)</p><p><br></p><p>如果你提交了這個 csv，那麼你會發現我一開始保證的那些還沒有完全實現。那是不是我在騙你們呢？當然不是。實際上，TPOT 庫有一個簡單的規則。如果你不運行 TPOT 太久，那麼它就不會為你的問題找出最可能傳遞方式。</p><p><br></p><p>所以，你得增加進化的代數，拿杯咖啡出去走一遭，其它的交給 TPOT 就行。此外，你也可以用這個庫來處理分類問題。進一步內容可以參考這個文檔：http://rhiever.github.io/tpot/。除了比賽，在生活中我們也有很多應用場景可以用到遺傳算法。</p><p><br></p><p>6、 實際應用</p><p><br></p><p>遺傳算法在真實世界中有很多應用。這裡我列了部分有趣的場景，但是由於篇幅限制，我不會逐一詳細介紹。</p><p><br></p><p>6.1 工程設計</p><p><br></p><p>工程設計非常依賴計算機建模以及模擬，這樣才能讓設計週期過程即快又經濟。遺傳算法在這裡可以進行優化並給出一個很好的結果。</p><p><br></p><p>相關資源：</p><p><br></p><ul class=list-paddingleft-2><li><p>論文：Engineering design using genetic algorithms<br></p></li><li><p>地址：http://lib.dr.iastate.edu/cgi/viewcontent.cgi?article=16942&context=rtd<br></p></li></ul><p><br></p><p>6.2 交通與船運路線（Travelling Salesman Problem，巡迴售貨員問題）</p><p><br></p><p>這是一個非常著名的問題，它已被很多貿易公司用來讓運輸更省時、經濟。解決這個問題也要用到遺傳算法。</p><p><br></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/928ea6e8a5ef451e8bd039dd25727094></div></div></p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/f9843b876a75448d85b2cb7a3e0f2bc3></div></div></p><p><br></p><p>6.3 機器人</p><p><br></p><p>遺傳算法在機器人領域中的應用非常廣泛。實際上，目前人們正在用遺傳算法來創造可以像人類一樣行動的自主學習機器人，其執行的任務可以是做飯、洗衣服等等。</p><p><br></p><p>相關資源：</p><p><br></p><ul class=list-paddingleft-2><li><p>論文：Genetic Algorithms for Auto-tuning Mobile Robot Motion Control<br></p></li><li><p>地址：https://pdfs.semanticscholar.org/7c8c/faa78795bcba8e72cd56f8b8e3b95c0df20c.pdf<br></p></li></ul><p><br></p><p>7、結語</p><p><br></p><p>希望通過本文介紹，你現在已經對遺傳算法有了足夠的理解，而且也會用 TPOT 庫來實現它了。但是如果你不親身實踐，本文的知識也是非常有限的。</p><p><br></p><p>所以，請各位讀者朋友一定要在無論是數據科學比賽或是生活中嘗試自己去實現它。<div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/36819f8fae4b4e81a0ac7d839b699077></div></div></p><p><br></p><p>原文鏈接：analyticsvidhya.com/blog/2017/07/introduction-to-genetic-algorithm/</p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt=一文讀懂遺傳算法工作原理！附Python實現 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/b26ed2f437a14423b76af91f9d485cb9></div></div></p><p>歡迎在留言區留下你的觀點，一起討論提高。如果今天的文章讓你有新的啟發，學習能力的提升上有新的認識，歡迎轉發分享給更多人。</p><p><br></p><p>猜你還想看</p><p><br></p><p>阿里、騰訊、百度、華為、京東最新面試題彙集</p><p>如果世界上只有一種數據結構，那麼我選擇 hash<br></p><p>為什麼阿里巴巴禁止使用存儲過程？<br></p><p>高併發之 API 接口，分佈式，防刷限流，如何做？<br><br></p><p>關注訂閱號「程序員小樂」，收看更多精彩內容<br>嘿，你在看嗎？</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>遺傳</a></li><li><a>Python</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html alt=Python中的遺傳算法完整實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1531731137721602bd9c18c style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html title=Python中的遺傳算法完整實現>Python中的遺傳算法完整實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4f88802b.html alt=Python實現文章自動生成 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4f88802b.html title=Python實現文章自動生成>Python實現文章自動生成</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8f304b3.html alt=利用Python實現財務報表下載小助手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/eccf200c-28b1-4270-a7be-3ff719f3d4f6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8f304b3.html title=利用Python實現財務報表下載小助手>利用Python實現財務報表下載小助手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/db784eae.html alt=使用Python實現文件的精確查找、模糊查找、範圍查找 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea247283ffd149a3bc2a1a4498569298 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/db784eae.html title=使用Python實現文件的精確查找、模糊查找、範圍查找>使用Python實現文件的精確查找、模糊查找、範圍查找</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/834ba338.html alt="Python 實現生命遊戲" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ef717db639fa4cd196ebe68fdbac71e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/834ba338.html title="Python 實現生命遊戲">Python 實現生命遊戲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdad3e1a.html alt=Python實現詞頻分析器，查看文章各種詞語的使用次數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/eb3e9379e45b437190986372fd452276 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdad3e1a.html title=Python實現詞頻分析器，查看文章各種詞語的使用次數>Python實現詞頻分析器，查看文章各種詞語的使用次數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c782b4f.html alt=Python實現連續變量GHMM高斯隱馬爾可夫模型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1b32a7d6eec44094a2f173b6555856ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c782b4f.html title=Python實現連續變量GHMM高斯隱馬爾可夫模型>Python實現連續變量GHMM高斯隱馬爾可夫模型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc520d9.html alt=用Python實現批量高效文件處理，解放你的雙手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6a8aade78d34491189c3149331390715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc520d9.html title=用Python實現批量高效文件處理，解放你的雙手>用Python實現批量高效文件處理，解放你的雙手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4af47b.html alt="性能利器，Python Flashtext 實現查找或替換文本中關鍵詞" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5377cc554f4d45d3a268141141ad00c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4af47b.html title="性能利器，Python Flashtext 實現查找或替換文本中關鍵詞">性能利器，Python Flashtext 實現查找或替換文本中關鍵詞</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html alt=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/dfic-imagehandler/f1d21356-1ef5-4ec5-a4a5-c5699b12bee1 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html title=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題>Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html alt=基於Python的遺傳算法特徵約簡（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/4cf33c81f091401a93c3d1b5db2213de style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/e8e338f.html title=基於Python的遺傳算法特徵約簡（附代碼）>基於Python的遺傳算法特徵約簡（附代碼）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html alt="遺傳算法(Python) #2 基本運算方法詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/c3dcdafb8df8476dbc472615f3131b59 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html title="遺傳算法(Python) #2 基本運算方法詳解">遺傳算法(Python) #2 基本運算方法詳解</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html alt="遺傳算法(Python) #3 從零開始解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/5d69e28f41a44f81b8dd0bbe9f2f2b6f style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html title="遺傳算法(Python) #3 從零開始解決OneMax問題">遺傳算法(Python) #3 從零開始解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html alt="遺傳算法(Python) #5 用DEAP框架解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/3279ffb8082c491a967c683ae24bdfcb style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html title="遺傳算法(Python) #5 用DEAP框架解決OneMax問題">遺傳算法(Python) #5 用DEAP框架解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html alt=遺傳算法綜合指南（以及如何Python編碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/15354276244373403483b2e style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html title=遺傳算法綜合指南（以及如何Python編碼）>遺傳算法綜合指南（以及如何Python編碼）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>