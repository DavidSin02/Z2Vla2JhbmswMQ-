<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>複雜性應對之道 - 領域建模 | 极客快訊</title><meta property="og:title" content="複雜性應對之道 - 領域建模 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p3.pstatp.com/large/pgc-image/d1cadab46c314f1f858c97763fdabdc8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ce0d745.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ce0d745.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/ce0d745.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ce0d745.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ce0d745.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/ce0d745.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/ce0d745.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/ce0d745.html><meta property="article:published_time" content="2020-10-29T20:46:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:28+08:00"><meta name=Keywords content><meta name=description content="複雜性應對之道 - 領域建模"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/ce0d745.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>複雜性應對之道 - 領域建模</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><div><h1 class=ql-align-justify><strong>為什麼要領域建模</strong></h1><p class=ql-align-justify>維護過企業級業務系統的同學，基本上沒有一個不抱怨業務代碼爛的，過程式的麵條代碼充斥著屏幕，程序員的心力和體力都經受著極大的考驗，怎麼破？</p><p class=ql-align-justify><strong>DDD革命</strong></p><p class=ql-align-justify>DDD革命性在於，領域模型準確反映了業務語言，而傳統J2EE或Spring+Hibernate等事務性編程模型只關心數據，這些數據對象除了簡單setter/getter方法外，沒有任何業務方法，被比喻成貧血模式。</p><p class=ql-align-justify>以銀行賬號Account為案例，Account有“存款”，“計算利息”和“取款”等業務行為，但是傳統經典的方式是將“存款”，“計算利息”和“取款”行為放在賬號的服務AccountService中，而不是放在Account對象本身之中。我們不能因為用了計算機，用了數據庫，用了框架，業務模型反而被技術框架給綁架了，就像人雖然是由母親生的，但是人的吃喝拉撒母親不能替代，更不能以母愛名義剝奪人的正常職責行為，如果是這樣，這個人就是被母愛綁架了。</p><p class=ql-align-justify><strong>DDD不是銀彈</strong></p><p class=ql-align-justify>軟件的世界裡沒有銀彈，是用事務腳本還是領域模型沒有對錯之分，關鍵看是否合適。就像自營和平臺哪個模式更好？答案是都很好，所以亞馬遜可以有三方入住，阿里也可以有自建倉嘛。</p><p class=ql-align-justify>實際上，CQRS就是對事務腳本和領域模型兩種模式的綜合，因為對於Query和報表的場景，使用領域模型往往會把簡單的事情弄複雜，此時完全可以用奧卡姆剃刀把領域層剃掉，直接訪問Infrastructure。</p><p class=ql-align-justify>我個人也是堅決反對過度設計的，因此對於簡單業務場景，我強力建議還是使用事務腳本，其優點是簡單、直觀、易上手。但對於複雜的業務場景，你再這麼玩就不行了，因為一旦業務變得複雜，事務腳本就很難應對，容易造成代碼的“一鍋粥”，系統的腐化速度和複雜性呈指數級上升。目前比較有效的治理辦法就是領域建模，因為領域模型是面向對象的，在封裝業務邏輯的同時，提升了對象的內聚性和重用性，因為使用了通用語言（Ubiquitous Language），使得隱藏的業務邏輯得到顯性化表達，使得複雜性治理成為可能。</p><p class=ql-align-justify>接下來，讓我們看一個銀行轉賬的實例，對比下事務腳本和領域模型兩者編程模型的不同。</p><h1 class=ql-align-justify><strong>DDD初體驗</strong></h1><p class=ql-align-justify><strong>銀行轉賬事務腳本實現</strong></p><p class=ql-align-justify>在事務腳本的實現中，關於在兩個賬號之間轉賬的領域業務邏輯都被寫在了MoneyTransferService的實現裡面了，而Account僅僅是getters和setters的數據結構，也就是我們說的貧血模型：</p><pre class=ql-align-right>public class MoneyTransferServiceTransactionScriptImpl implements MoneyTransferService { private AccountDao accountDao; private BankingTransactionRepository bankingTransactionRepository; . . . @Override public BankingTransaction transfer( String fromAccountId, String toAccountId, double amount) { Account fromAccount = accountDao.findById(fromAccountId); Account toAccount = accountDao.findById(toAccountId); . . . double newBalance = fromAccount.getBalance() - amount; switch (fromAccount.getOverdraftPolicy()) { case NEVER: if (newBalance &lt; 0) { throw new DebitException("Insufficient funds"); } break; case ALLOWED: if (newBalance &lt; -limit) { throw new DebitException( "Overdraft limit (of " + limit + ") exceeded: " + newBalance); } break; } fromAccount.setBalance(newBalance); toAccount.setBalance(toAccount.getBalance() + amount); BankingTransaction moneyTransferTransaction = new MoneyTranferTransaction(fromAccountId, toAccountId, amount); bankingTransactionRepository.addTransaction(moneyTransferTransaction); return moneyTransferTransaction; }}</pre><p class=ql-align-justify>上面的代碼大家看起來應該比較眼熟，因為目前大部分系統都是這麼寫的。<strong>需求評審完，工程師畫幾張UML圖完成設計，就開始向上面這樣懟業務代碼了，這樣寫基本不用太費腦，完全是面向過程的代碼風格</strong>。有些同學可能會說，我這樣寫也可以實現系統功能啊，還是那句話<strong>“just because you can, doesn’t mean you should”</strong>。說句不好聽的，正是有這麼多“沒有追求”、“不求上進”的碼農才造成了應用系統的混亂、敗壞了應用開發的名聲。這也是為什麼很多應用開發工程師覺得工作沒意思，技術含量低，覺得整天就是寫if-else的業務邏輯代碼，系統又爛，工作繁瑣、無聊、沒有成長、沒有成就感，所以轉向去做中間件啊，去寫JDK啊，覺得那個NB。實際上，應用開發一點都不簡單也不無聊，業務的變化比底層Infrastructure的變化要多得多，解決的難度也絲毫不比寫底層代碼容易，只是很多人選擇了用無聊的方式去做。<strong>其實我們是有辦法做的更優雅的，這種優雅的方式就是領域建模，唯有掌握了這種優雅你才能實現從工程師嚮應用架構的轉型</strong>。同樣的業務邏輯，接下來就讓我們看一下用DDD是怎麼做的。</p><p class=ql-align-justify><strong>銀行轉賬領域模型實現</strong></p><p class=ql-align-justify>如果用DDD的方式實現，Account實體除了賬號屬性之外，還包含了行為和業務邏輯，比如debit( )和credit( )方法。</p><pre class=ql-align-right>// @Entitypublic class Account { // @Id private String id; private double balance; private OverdraftPolicy overdraftPolicy; . . . public double balance() { return balance; } public void debit(double amount) { this.overdraftPolicy.preDebit(this, amount); this.balance = this.balance - amount; this.overdraftPolicy.postDebit(this, amount); } public void credit(double amount) { this.balance = this.balance + amount; }}</pre><p class=ql-align-justify>而且透支策略OverdraftPolicy也不僅僅是一個Enum了，而是被抽象成包含了業務規則並採用了策略模式的對象。</p><pre class=ql-align-right>public interface OverdraftPolicy { void preDebit(Account account, double amount); void postDebit(Account account, double amount);}public class NoOverdraftAllowed implements OverdraftPolicy { public void preDebit(Account account, double amount) { double newBalance = account.balance() - amount; if (newBalance &lt; 0) { throw new DebitException("Insufficient funds"); } } public void postDebit(Account account, double amount) { }}public class LimitedOverdraft implements OverdraftPolicy { private double limit; . . . public void preDebit(Account account, double amount) { double newBalance = account.balance() - amount; if (newBalance &lt; -limit) { throw new DebitException( "Overdraft limit (of " + limit + ") exceeded: " + newBalance); } } public void postDebit(Account account, double amount) { }}</pre><p class=ql-align-justify>而Domain Service只需要調用Domain Entity對象完成業務邏輯即可。</p><pre class=ql-align-right>public class MoneyTransferServiceDomainModelImpl implements MoneyTransferService { private AccountRepository accountRepository; private BankingTransactionRepository bankingTransactionRepository; . . . @Override public BankingTransaction transfer( String fromAccountId, String toAccountId, double amount) { Account fromAccount = accountRepository.findById(fromAccountId); Account toAccount = accountRepository.findById(toAccountId); . . . fromAccount.debit(amount); toAccount.credit(amount); BankingTransaction moneyTransferTransaction = new MoneyTranferTransaction(fromAccountId, toAccountId, amount); bankingTransactionRepository.addTransaction(moneyTransferTransaction); return moneyTransferTransaction; }}</pre><p class=ql-align-justify>通過上面的DDD重構後，原來在事務腳本中的邏輯，被分散到Domain Service，Domain Entity和OverdraftPolicy三個滿足SOLID的對象中，在繼續閱讀之前，我建議可以自己先體會一下DDD的好處。</p><h1 class=ql-align-justify><strong>領域建模的好處</strong></h1><p class=ql-align-justify>DDD最大的好處是：<strong>接觸到需求第一步就是考慮領域模型，而不是將其切割成數據和行為，然後數據用數據庫實現，行為使用服務實現，最後造成需求的首肢分離。DDD讓你首先考慮的是業務語言，而不是數據。DDD強調業務抽象和麵向對象編程，而不是過程式業務邏輯實現。重點不同導致編程世界觀不同</strong>。</p><p class=ql-align-justify><strong>面向對象</strong></p><ul><li class=ql-align-justify>封裝：Account的相關操作都封裝在Account Entity上，提高了內聚性和可重用性。</li><li class=ql-align-justify>多態：採用策略模式的OverdraftPolicy（多態的典型應用）提高了代碼的可擴展性。</li></ul><p class=ql-align-justify><strong>業務語義顯性化</strong></p><ul><li class=ql-align-justify>通用語言：“一個團隊，一種語言”，將模型作為語言的支柱。確保團隊在內部的所有交流中，代碼中，畫圖，寫東西，特別是講話的時候都要使用這種語言。例如賬號，轉賬，透支策略，這些都是非常重要的領域概念，如果這些命名都和我們日常討論以及PRD中的描述保持一致，將會極大提升代碼的可讀性，減少認知成本。說到這，稍微吐槽一下我們有些工程師的英語水平，有些神翻譯讓一些核心領域概念變得面目全非。</li><li class=ql-align-justify>顯性化：就是將隱式的業務邏輯從一推if-else裡面抽取出來，用通用語言去命名、去寫代碼、去擴展，讓其變成顯示概念，比如<strong>“透支策略”這個重要的業務概念，按照事務腳本的寫法，其含義完全淹沒在代碼邏輯中沒有突顯出來</strong>，看代碼的人自然也是一臉懵逼，而領域模型裡面將其用策略模式抽象出來，不僅提高了代碼的可讀性，可擴展性也好了很多。</li></ul><h1 class=ql-align-justify><strong>如何進行領域建模</strong></h1><p class=ql-align-justify><strong>初步建模</strong></p><p class=ql-align-justify>好的模型應該是建立在對業務深入理解的基礎上。就我自己的經驗而言，建模是一個不斷迭代的過程，一開始可以簡單點來。</p><p class=ql-align-justify>首先抓住一些核心概念，這些業務知識和核心概念可以通過和業務專家溝通，也可以通過頭腦風暴的形式從User Story或者Event Storming去扣。</p><p class=ql-align-justify>然後假設一些業務場景走查一下，再寫一些偽代碼驗證一下run一下，看看順不順，如果很順滑，說明沒毛病，否則就要看看是不是需要調整一下模型，隨著項目的進行和對業務理解的不斷深入，這種迭代將持續進行。</p><p class=ql-align-justify>舉個栗子，比如讓你設計一箇中介系統，一個典型的User Story可能是“小明去找工作，中介說你留個電話，有工作機會我會通知你”，這裡面的關鍵名詞很可能就是我們需要的領域對象：</p><ul><li class=ql-align-justify>小明是求職者。</li><li class=ql-align-justify>電話是求職者的屬性。</li><li class=ql-align-justify>中介包含了中介公司，中介員工兩個關鍵對象。</li><li class=ql-align-justify>工作機會肯定也是關鍵領域對象；</li><li class=ql-align-justify>通知這個動詞暗示我們這裡用觀察者模式會比較合適。</li></ul><p class=ql-align-justify><strong>然後再梳理一下領域對象之間的關係，一個求職者可以應聘多個工作機會，一個工作機會也可以被多個求職者應聘，M2M的關係，中介公司可以包含多個員工，O2M的關係</strong>。對於這樣簡單的場景，這個建模就差不多了。</p><p class=ql-align-justify>當然我們的業務場景往往比這個要複雜，而且不是所有的名詞都是領域對象也可能是屬性，也不是所有的動詞都是方法也可能是領域對象，再者，看的見實體好找，看不見的、隱藏的，需要深入理解業務，需要“無中生有”才能得到的抽象就沒那麼容易發現了，所以要具體問題具體對待，這個進化的過程需要我們有很好的業務理解力，抽象能力以及建模的經驗（知道為什麼公司的job model裡那麼強調技術人員的業務理解力和抽象能力了吧。</p><p class=ql-align-justify>比如通常情況下，價格和庫存只是訂單和商品的一個屬性，但是在阿里系電商業務場景下，價格計算和庫存扣減的複雜程度可以讓你懷疑人生，因此作為電商中臺，把價格和庫存單獨當成一個域（Domain）去對待是很必要的。</p><p class=ql-align-justify>當然這個只是最初級的模型，接下來我會通過DDD中的一些核心概念的介紹，讓大家更清楚的瞭解建模的過程。</p><p class=ql-align-justify><strong>領域事件(Domain Event)</strong></p><blockquote>An event is something that has happened in the past. A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) or domain in aonther bounded context to be aware of and potentially react to.</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>Domain Event是由一個特定領域觸因為一個用戶Command觸發的發生在過去的行為產生的事件，而這個事件是系統中其它部分感興趣的。</p><p class=ql-align-justify>為什麼Domain Event如此重要？ 因為在現在的分佈式環境下，沒有一個業務系統是割裂的，而Messaging絕對是系統之間耦合度最低，最健壯，最容易擴展的一種通信機制。因此理論上它是分佈式系統的必選項。</p><p class=ql-align-justify>但是目前大部分系統的Event都設計的很隨性，沒有統一的指導和規範，導致Event濫用和無用的情況時有發生，而Domain Event給我們一個很好的方向，指引我們該如何設計我們系統的Event。</p><p class=ql-align-justify><strong>Event命名</strong></p><blockquote>Your Domain Event type names should be a statement of a past occurrence, that is, a verb in the past tense.</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>因為表示的是過去事件，所以推薦命名為Domain Name + 動詞的過去式 + Event。這樣比較可以確切的表達業務語義。</p><p class=ql-align-justify>下面是幾個舉例：</p><ol><li class=ql-align-justify>CustomerCreatedEvent,表示客戶創建後發出的領域事件。</li><li class=ql-align-justify>OpportunityTransferedEvent，表示機會轉移後發出的領域事件。</li><li class=ql-align-justify>LeadsCreatedEvent，表示線索創建後發出的領域事件。</li></ol><p class=ql-align-justify><strong>Event內容</strong></p><p class=ql-align-justify>Event的內容有兩種形式：</p><ol><li class=ql-align-justify>Enrichment：也就是在Event的payload中儘量多多放data，這樣consumer就可以自恰（Autonomy）的處理消息了。</li><li class=ql-align-justify>Query-Back：這種是在Event中通過回調拿到更多的data，這種形式會加重系統的負載，performance也會差一些。</li></ol><p class=ql-align-justify>所以如果要在Enrichment和Query-Back之間做選擇的話，首先推薦使用Enrichment。</p><p class=ql-align-justify><strong>Event Sourcing</strong></p><p class=ql-align-justify>Event Sourcing是在Domain Event上面的一個擴展，是一個可選項。也就是要有一個Event Store保存所有的Events，其實如果你是用MetaQ作為Event機制的話，這些Events都是存儲在MetaQ當中的，只是MetaQ並沒有提供很好的Event查詢和回溯，所以如果決定使用Event Sourcing的話，最好還是自己單獨建立一個Event Store。</p><p class=ql-align-justify>使用Event Sourcing主要有以下好處，如果用不到的話，完全可以不用，但是Domain Event還是強烈建議要使用。</p><ol><li class=ql-align-justify>Event Sourcing存儲了所有發生在Core Domain上面的事件。</li><li class=ql-align-justify>基於這些事件，我們可以做系統回放，系統Debug，以及做用戶行為的分析（類似於打點）</li></ol><p class=ql-align-justify><strong>Event Storming</strong></p><p class=ql-align-justify>事件風暴是《DDD Distilled》書中提出的一個業務分析的方法論，其主要作用是從Domian事件出發，來分析用戶Command，來找到Ubiquitous Languange，來抽象Domain Entity以及Bounded Context。</p><p class=ql-align-justify>可以和User Story的方法論結合起來使用，其最大的優點是，這種分析方式即使是non-tech的人，比如產品，業務專家等也能聽得懂，也能參與進來。相比較一上來就使用UML畫領域模型圖而言。</p><p class=ql-align-justify><strong>聚合根(Aggreagte)</strong></p><p class=ql-align-justify>聚合根（Aggregate Root）是DDD中的一個概念，是一種更大範圍的封裝，把一組有相同生命週期、在業務上不可分隔的實體和值對象放在一起考慮，只有根實體可以對外暴露引用，也是一種內聚性的表現。</p><p class=ql-align-justify>確定聚合邊界要滿足固定規則（Invariant），是指在數據變化時必須保持的一致性規則，具體規則如下</p><ul><li class=ql-align-justify>根實體具有全局標識，最終負責檢查規定規則</li><li class=ql-align-justify>聚合內的實體具有本地標識，這些標識在Aggregate內部才是唯一的</li><li class=ql-align-justify>外部對象不能引用除根Entity之外的任何內部對象</li><li class=ql-align-justify>只有Aggregate的根Entity才能直接通過數據庫查詢獲取，其他對象必須通過遍歷關聯來發現</li><li class=ql-align-justify>Aggegate內部的對象可以保持對其他Aggregate根的引用</li><li class=ql-align-justify>Aggregate邊界內的任何對象修改時，整個Aggregate的所有固定規則都必須滿足</li></ul><p class=ql-align-justify>還是看銀行的例子，Account（賬號）是CustomerInfo（客戶信息）Entity和Address（值對象）的聚合根，Tansaction（交易）是流水（Journal）的聚合根，因為流水是因為交易才產生的，具有相同的生命週期。</p><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/d1cadab46c314f1f858c97763fdabdc8><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><em>最後提醒一下，聚合根是一個邏輯概念，主觀性很強，所以在建模過程中很容易產生分歧，因此在日常工作中千萬不要教條，把握住一條主要原則，我們的最終目的是為了業務語義顯現化，如果因為聚合根把模型弄的晦澀難懂那就得不償失了</em></p><p class=ql-align-justify><strong>領域服務(Domain Service)</strong></p><p class=ql-align-justify><strong>什麼是領域服務</strong></p><p class=ql-align-justify>有些領域中的動作，它們是一些動詞，看上去卻不屬於任何對象。它們代表了領域中的一個重要的行為，所以不能忽略它們或者簡單地把它們合併到某個實體或者值對象中。<strong>當這樣的行為從領域中被識別出來時，最佳實踐是將它聲明成一個服務。</strong>這樣的對象不再擁有內置的狀態。它的作用僅僅是為領域提供相應的功能。Service往往是以一個活動來命名，而不是Entity來命名。例如開篇轉賬的例子，轉賬（transfer）這個行為是一個非常重要的領域概念，但是它是發生在兩個賬號之間的，歸屬於賬號Entity並不合適，因為一個賬號Entity沒有必要去關聯他需要轉賬的賬號Entity，這種情況下，使用MoneyTransferDomainService就比較合適了。</p><p class=ql-align-justify>識別領域服務，主要看它是否滿足以下三個特徵：</p><ol><li class=ql-align-justify>服務執行的操作代表了一個領域概念，這個領域概念無法自然地隸屬於一個實體或者值對象。</li><li class=ql-align-justify>被執行的操作涉及到領域中的其他的對象。</li><li class=ql-align-justify>操作是無狀態的。</li></ol><p class=ql-align-justify><strong>領域服務陷阱</strong></p><p class=ql-align-justify>在使用領域服務時要特別當心，<strong>一個比較常見的錯誤是沒有努力為行為找到一個適當的對象，就直接抽象成領域服務，這會使我們的代碼逐漸轉化為過程式的編程</strong>，一個極端的例子是把所有的行為都放到領域服務中，而領域模型退化成只有屬性的貧血DO，那DDD就沒有任何意義了。所以一定要深入思考，既不能勉強將行為放到不符合對象定義的對象中，破壞對象的內聚性，使其語義變得模糊。也不能不加思考的都放到領域服務中，從而退化成面向過程的編程。</p><p class=ql-align-justify><strong>應用服務和領域服務如何劃分</strong></p><p class=ql-align-justify>在領域建模中，我們一般將系統劃分三個大的層次，即應用層（Application Layer），領域層（Domain Layer）和基礎實施層（Infrastructure Layer），關於這三個層次的詳細內容可以參考我的另一篇COLA框架的分層設計。可以看到在App層和Domain層都有服務（Service），這兩個Service如何劃分呢，什麼樣的功能應該放在應用層，什麼樣的功能應該放在領域層呢？</p><p class=ql-align-justify>決定一個服務（Service）應該歸屬於哪一層是很困難的。如果所執行的操作概念上屬於應用層，那麼服務就應該放到這個層。<strong>如果操作是關於領域對象的，而且確實是與領域有關的、為領域的需要服務，那麼它就應該屬於領域層。</strong>總的來說，涉及到重要領域概念的行為應該放在Domain層，而其它非領域邏輯的技術代碼放在App層，例如參數的解析，上下文的組裝，調用領域服務，消息發送等。還是銀行轉賬的case為例，下圖給出了劃分的建議：</p><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c2059577659940caa7ae86730306389d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>邊界上下文(Bounded Context)</strong></p><p class=ql-align-justify>領域實體是有邊界上下文的，比如Apple這個實體不同的上下文，表達的含義就完全不一樣，在水果店它就是水果，在蘋果專賣店它就是手機。</p><p class=ql-align-justify>所以邊界上下文（Bounded Context）在DDD裡面是一個非常重要的概念，Bounded Context明確地限定了模型的應用範圍，在Context中，要保證模型在邏輯上統一，而不用考慮它是不是適用於邊界之外的情況。在其他Context中，會使用其他模型，這些模型具有不同的術語、概念、規則和Ubiquitous Language的行話。</p><p class=ql-align-justify><strong>上下文映射(Context Mapping)</strong></p><p class=ql-align-justify>那麼不同Context下的業務要互相通信怎麼辦呢？這就涉及跨邊界的Context Mapping（上下文映射），首先不同上下文之間的通信可以是同步的，也可以是異步的，同步的話一般是RPC或者RESTFul，異步的話會推薦上文提到的Domain Event.</p><p class=ql-align-justify>Mapping的方式有很多種，有Shared Kernal（共享內核），Conformist（追隨者），以及Anti-Corruption（防腐層）等等。</p><p class=ql-align-justify>我個人比較推崇Domain Event + AC，這樣可以將系統之間的耦合降到最低。</p><p class=ql-align-justify>以我們真實的業務場景舉個例子，比如會員這個概念在ICBU網站是指網站上的Buyer，但是在CRM領域是指Customer，雖然很多的屬性都是一樣的，但是二者在不同的Context下其語義和概念是有差別的，我們需要用AC做一下轉換：</p><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/9a21521914334c54b301d82892119190><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>邊界上下文和微服務</strong></p><p class=ql-align-justify>先來說一下微服務，拋開以Docker為代表的底層容器化技術不看，微服務和我們之前的SOA麼有本質區別。</p><p class=ql-align-justify>這不是我一個人的觀點，關於這個想法我還專門求證了業界大牛Randy Shoup，問他微服務和SOA的區別，下面是他給我的回答</p><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/39e8f18b7c234ef7839558f56f2cd9e1><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>那麼如何劃分系統，才能得到一個比較合適的粒度，不會太粗，也不會太細呢。此時我們可以考慮DDD的戰略設計，即從戰略角度整體描述業務領域全貌，然後通過邊界上下文將不同的實體歸類到相對應的域裡面。</p><p class=ql-align-justify>比如在CRM領域，我們按照下面的戰略設計圖，我會自然的把CRM系統劃分成銷售服務，組織權限服務，營銷服務，售賣服務。</p><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/309ea7ae0104443c93228259d711c383><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>模型重構</strong></p><p class=ql-align-justify>最後我想強調的是，建模不是一次性的工作，也不可能是一次性的工作，業務在演化，隨之而來的模型也需要演化和重構，當模型和業務部匹配的時候，你還是要霸王硬上弓的往裡面塞，其結果可想而知。</p><p class=ql-align-justify><strong>模型統一</strong></p><p class=ql-align-justify>建模的過程很像盲人摸象，不同背景人用不同的視角看同一個東西，其理解也是不一樣的。比如兩個盲人都摸到大象鼻子，一個人認為是像蛇（活的能動），而另一個人認為像消防水管（可以噴水），那麼他們將很難集成。雙方都無法接受對方的模型，因為那不符合自己的體驗。<strong>事實上，他們需要一個新的抽象，這個抽象需要把蛇的“活著的特性”與消防水管的“噴水功能”合併到一起</strong>，而這個抽象還應該排除先前兩個模型中一些不確切的含義和屬性，比如毒牙，或者捲起來放到消防車上去的行為，這就是模型的統一。統一完的模型也許還不叫大象鼻子，但是已經很接近大象鼻子的屬性和功能了，隨著我們對模型對象、對業務理解的越來越深入、越來越透徹，我們會不斷的調整演化我們的模型，所以建模不是一個one-time off的工作，而是一個持續不斷演化重構的過程。</p><p class=ql-align-justify><strong>模型演化</strong></p><p class=ql-align-justify><strong>世界上唯一不變的就是變化，模型和代碼一樣也需要不斷的重構和精化，每一次的精化之後，開發人員應該對領域知識有了更加清晰的認識。</strong>這使得理解上的突破成為可能，之後，一系列快速的改變得到了更符合用戶需要並更加切合實際的模型。其功能性及說明性急速增強，而複雜性卻隨之消失。這種突破需要我們對業務有更加深刻的領悟和思考，然後再加上重構的勇氣和能力，勇氣是項目工期很緊你敢不敢重構，能力是你有沒有完備的CI保證你的重構不破壞現有的業務邏輯。</p><p class=ql-align-justify><strong>實體在演變</strong></p><p class=ql-align-justify>以開篇的銀行賬號為例，假如一開始賬號都有withdraw（取錢）的行為，此時只需要在Account上加上withdraw方法就好了。</p><ul><li class=ql-align-justify>演變一：</li><li class=ql-align-justify>隨著業務的發展，我們需要支持ATM賬號和Online賬號，而Online賬號是不能withdraw的，此時最差的做法是保持模型不變，而是在withdraw方法中判斷如果是OnlineAccount則拋出異常。這種簡單的代碼堆砌可以滿足業務功能，但是其業務語義完全被掩蓋。更好的重構方法應該是將withdraw抽成一個接口IWithdrawable。</li><li class=ql-align-justify>演變二：</li><li class=ql-align-justify>好的，沒有什麼可以阻擋業務對變化的嚮往。現在公司出於安全性的考慮，為新開通的ATMAccount設置了取款上線，超過則不能支取。簡單做法是在IWithdrawable中再加入一個setLimit行為，可是我們並不想改動影響到老的賬號業務，所以更好的重構應該是重新寫一個ILimitedWithdrawable接口，讓其繼承老接口，這樣老的代碼就可以保持不變了。</li></ul><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/ca1cbf2b397a41e99694dc5c112e2b01><p class=pgc-img-caption></p></div><ul><li class=ql-align-justify><br></li><li class=ql-align-justify>通過上面的例子，我們可以看到領域模型和麵向對象是一對孿生兄弟，我們會用到大量的OO原則，比如上面的重構就用到了SOLID的SRP（單一職責）和OCP（開閉原則）。在實際工作中，我的確也有這樣的體會，自從踐行DDD以後，我們採用OOA和OOD的時候比以前明顯多了很多，OO的能力也在不斷的提升。</li></ul><p class=ql-align-justify><strong>引入新抽象</strong></p><p class=ql-align-justify>還是以開篇的轉賬來舉個例子，假如轉賬業務開始變的複雜，要支持現金，信用卡，支付寶，比特幣等多種通道，且沒種通道的約束不一樣，還要支持一對多的轉賬。那麼你還是用一個transfer(fromAccount, toAccount)就不合適了，可能需要抽象出一個專門的<strong>領域對象Transaction</strong>，這樣才能更好的表達業務，其演化過程如下：</p><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/68a584fd7a604a22b0e11ad2d0e4a3bc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1 class=ql-align-justify><strong>業務可視化和可配置化</strong></h1><p class=ql-align-justify>好的領域建模可以降低應用的複雜性，而可視化和可配置化主要是幫助大家（主要是非技術人員，比如產品，業務和客戶）直觀地瞭解系統和配置系統，提供了一種“code free”的解決方案，也是SaaS軟件的主要賣點。要注意的是可視化和可配置化難免會給系統增加額外的複雜度，必須慎之又慎，最好是能使可視化和配置化的邏輯與業務邏輯儘量少的耦合，否則破壞了原有的架構，把事情搞的更復雜就得不償失了。</p><p class=ql-align-justify>在可擴展設計中，我已經介紹了我們SOFA架構是如何通過擴展點的設計來支撐不同業務差異化的需求的，<strong>那麼可否更進一步，我們將領域的行為（也叫能力）和擴展點用可視化的方式呈現出來，並對於一些不需要編碼實現的擴展點用配置的方式去完成呢。</strong>當然是可以的，比如還是開篇轉賬的例子，對於透支策略OverdraftPolicy這個業務擴展點，新來一個業務說透支額度不能超過1000，我們可以完全結合規則引擎進行配置化完成，而不需要編碼。</p><p class=ql-align-justify>所以我能想到的一種還比較優雅的方式，是通過Annotation註解的方式對領域能力和擴展點進行標註，然後在系統bootstrap階段，通過代碼掃描的方式，將這些能力點和擴展點收集起來上傳到中心服務器，然後再通過GUI的方式呈現出來，從而做到業務的可視化和可配置化。大概的示意圖如下：</p><div class=pgc-img><img alt="複雜性應對之道 - 領域建模" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/5117df0f34674c328557362eb3c22824><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>有同學可能會問流程要不要可視化，<strong>這裡要分清楚兩個概念，業務邏輯流和工作流，很多同學混淆了這兩個概念</strong>。業務邏輯流是響應一次用戶請求的業務處理過程，其本身就是業務邏輯，對其編排和可視化的意義並不是很大，無外乎只是把代碼邏輯可視化了，在我們的SOFA框架中，是通過擴展點和策略模式來處理業務的分支情況，而我看到我們阿里很多的內部系統將這種響應一次用戶請求的業務邏輯用很重的工作流引擎來做，美其名曰流程可編排，實質上往往是把簡單的事情複雜化了。而工作流是指完成一項任務所需要不同節點的連接，<strong>節點主要分為自動節點和人工節點</strong>，其中每個人工節點都需要用戶的參與，也就是響應一次用戶的請求，比如審批流程中的經理審批節點，CRM銷售過程的業務員的處理節點等等。此時可以考慮使用工作流引擎，特別是當你的系統需要讓用戶自定義流程的時候，那就不得不使用可視化和可配置的工作流引擎了，除此之外，最好不要自找麻煩。我曾在銀行工作過，親眼看見過IBM是怎麼忽悠銀行使用它們的BPM系統，然後把系統弄的巨複雜無比，所以我對工作流引擎的印象並不好，當然也不排除有用的特別合適的案例，只是我還沒看見，如果有看見的同學麻煩告訴我一聲，學習一下。因為我們現在還沒有讓用戶自定義流程的訴求，所以使用工作流引擎並不在我們現階段的考慮範圍之內。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>雜性</a></li><li><a>領域</a></li><li><a>建模</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e4be374.html alt=鈦及鈦合金鑄件的應用領域​ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/Rca7hqUCttQBq0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e4be374.html title=鈦及鈦合金鑄件的應用領域​>鈦及鈦合金鑄件的應用領域​</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1700411d.html alt="四大領域“亮眼”表現 勾畫高端製造裝備產業格局" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/78b5000c7833f5cc29af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1700411d.html title="四大領域“亮眼”表現 勾畫高端製造裝備產業格局">四大領域“亮眼”表現 勾畫高端製造裝備產業格局</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2e623b5.html alt=工業耐磨陶瓷主要應用在哪些領域 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e25119604b714ee4bac2538dbb036093 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2e623b5.html title=工業耐磨陶瓷主要應用在哪些領域>工業耐磨陶瓷主要應用在哪些領域</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ba772a95.html alt=在該領域不再被“卡脖子”，中國成功研出50MW重型燃氣輪機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f01ff61edf6d4c44a6ecd1c8529e7597 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ba772a95.html title=在該領域不再被“卡脖子”，中國成功研出50MW重型燃氣輪機>在該領域不再被“卡脖子”，中國成功研出50MW重型燃氣輪機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9b6a31c5.html alt=早知道就買一個回家過年了：反恐領域CBRN呼吸道防護裝備發展方向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RoAFZJY2s3oqDd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9b6a31c5.html title=早知道就買一個回家過年了：反恐領域CBRN呼吸道防護裝備發展方向>早知道就買一個回家過年了：反恐領域CBRN呼吸道防護裝備發展方向</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c078eace.html alt=BIM輕量化圖形引擎領域研發取得重大突破 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ROLNl1UCgFXKU0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c078eace.html title=BIM輕量化圖形引擎領域研發取得重大突破>BIM輕量化圖形引擎領域研發取得重大突破</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1e2ced7.html alt="正泰能源物聯網領域新突破 | 電蓄熱調峰項目將正式啟動" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/eb7f0ef4d178485982667d1bc011bc98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1e2ced7.html title="正泰能源物聯網領域新突破 | 電蓄熱調峰項目將正式啟動">正泰能源物聯網領域新突破 | 電蓄熱調峰項目將正式啟動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acb734b8.html alt=加強重要領域立法以良法保障國家善治 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acb734b8.html title=加強重要領域立法以良法保障國家善治>加強重要領域立法以良法保障國家善治</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0170174e.html alt="三星立下豪言 2030年成為邏輯芯片領域的世界第一！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/59d4664a69db4d5f9bbd80fe523064e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0170174e.html title="三星立下豪言 2030年成為邏輯芯片領域的世界第一！">三星立下豪言 2030年成為邏輯芯片領域的世界第一！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cf92aa2.html alt=計算機領域三十年的難題，這位華人數學家僅用2頁紙就解決了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1b98507605614f07bebec6fb1fc3254e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cf92aa2.html title=計算機領域三十年的難題，這位華人數學家僅用2頁紙就解決了>計算機領域三十年的難題，這位華人數學家僅用2頁紙就解決了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a07cadb.html alt=水晶卷閘門應用領域詳解-深圳祥達電動卷閘門 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a07cadb.html title=水晶卷閘門應用領域詳解-深圳祥達電動卷閘門>水晶卷閘門應用領域詳解-深圳祥達電動卷閘門</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/137f88ad.html alt=二手反應釜可以運用到什麼領域 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5e8900036d2d17e0f2b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/137f88ad.html title=二手反應釜可以運用到什麼領域>二手反應釜可以運用到什麼領域</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4ea317a.html alt=國內環境修復領域的研究進展 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1c30ceded3974f9ab275065c1cb637c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4ea317a.html title=國內環境修復領域的研究進展>國內環境修復領域的研究進展</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3da03ec1.html alt=二維MoS2在催化領域的興起 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532925953421e711a644ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3da03ec1.html title=二維MoS2在催化領域的興起>二維MoS2在催化領域的興起</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>