<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基於Python的遺傳算法特徵約簡（附代碼） | 极客快訊</title><meta property="og:title" content="基於Python的遺傳算法特徵約簡（附代碼） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p3.pstatp.com/large/pgc-image/4cf33c81f091401a93c3d1b5db2213de"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/e8e338f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/e8e338f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/e8e338f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/e8e338f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/e8e338f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/e8e338f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e9%81%8a%e6%88%b2/e8e338f.html><link rel=canonical href=https://geekbank.cf/tw/%e9%81%8a%e6%88%b2/e8e338f.html><meta property="article:published_time" content="2020-10-29T20:46:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:33+08:00"><meta name=Keywords content><meta name=description content="基於Python的遺傳算法特徵約簡（附代碼）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E9%81%8A%E6%88%B2/e8e338f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基於Python的遺傳算法特徵約簡（附代碼）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E9%81%8A%E6%88%B2.html>遊戲</a></span></div><div class=post-content><div><div class=pgc-img><img alt=基於Python的遺傳算法特徵約簡（附代碼） onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/4cf33c81f091401a93c3d1b5db2213de><p class=pgc-img-caption></p></div><p class=ql-align-justify>作者：Ahmed Gad</p><p class=ql-align-justify>翻譯：張睿毅</p><p class=ql-align-justify>校對：丁楠雅</p><p class=ql-align-justify>本文<strong>4700</strong>字，建議閱讀<strong>15分鐘。</strong></p><p class=ql-align-justify>本教程主要使用numpy和sklearn來討論如何使用遺傳算法（genetic algorithm，GA）來減少從python中的Fruits360數據集提取的特徵向量。</p><p class=ql-align-justify><strong>標籤：</strong>深度學習，特徵工程，遺傳算法，神經網絡，numpy，python，scikit-learn</p><p class=ql-align-justify></p><p class=ql-align-justify>本教程主要使用numpy和sklearn來討論如何使用遺傳算法（genetic algorithm，GA）來減少從python中的Fruits360數據集提取的特徵向量。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=基於Python的遺傳算法特徵約簡（附代碼） onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c4e4fa77f551400ea801446b9704e694><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><h1 class=ql-align-justify><strong>導言</strong></h1><p class=ql-align-justify>在某些情況下，使用原始數據訓練機器學習算法可能不是合適的選擇。該算法在接受原始數據訓練時，必須進行特徵挖掘，以檢測不同組之間的差異。但這需要大量的數據來自動執行特徵挖掘。對於小數據集，數據科學家最好自己進行特徵挖掘步驟，之後告訴機器學習算法要使用哪個特徵集。</p><p class=ql-align-justify>使用的特徵集必須能代表數據樣本，因此我們必須注意選擇最佳特徵。數據科學家建議使用一些類型的特徵，這些特徵似乎有助於根據以前的經驗來表示數據樣本。一些特徵可以證明它們在表示樣本時的穩健性，而其他特徵則不能。</p><p class=ql-align-justify>可能存在一些類型的特徵，會降低分類問題的準確性或增加回歸問題的誤差，進而影響訓練模型的結果。例如，特徵向量中可能存在一些噪音元素，因此它們應該被刪除。特徵向量也可能包含2個或更多相關元素。只使用一個元素就可以替代另一個元素。為了刪除這些類型的元素，有兩個有用的步驟，即特徵選擇和約簡。本教程重點介紹特徵約簡。</p><p class=ql-align-justify>假設有3個特徵f1、f2和f3，每個特徵都有3個特徵元素。因此，特徵向量長度為3x3=9。特徵選擇只選擇特定類型的特徵，不包括其他類型的特徵。例如，只需選擇f1和f3並刪除f3。特徵向量長度變成了6而不是9。在特徵約簡中，可以排除每個特徵的特定元素。例如，此步驟可能會在保留第二個元素的同時從f3中刪除第一個和第三個元素。因此，特徵向量長度從9減少到7。</p><p class=ql-align-justify><strong>在開始本教程之前，值得一提的是，它是我的LinkedIn配置文件中先前發佈的2個教程的擴展。</strong></p><p class=ql-align-justify>第一個教程的標題是<strong>“使用numpy的人工神經網絡實現Fruits360圖像數據集的分類”。</strong>它首先從Fruits360數據集的4個類中提取長度為360的特徵向量。然後，利用numpy從零開始構建人工神經網絡（ANN），對數據集進行分類。</p><blockquote><strong>第一個教程可從以下網址獲取：</strong>https://www.linkedin.com/pulse/artificial-neural-network-implementation-using-numpy-fruits360-gad<strong>其Github項目可從以下網址獲得：</strong>https://github.com/ahmedfgad/NumPyAN</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>第二個教程是<strong>“使用遺傳算法的人工神經網絡優化”</strong>。建立並使用遺傳算法對神經網絡參數進行優化，以提高分類精度。</p><blockquote><strong>第二個教程可從以下網址獲取：</strong>https://www.linkedin.com/pulse/artificial-neural-networks-optimization-using-genetic-ahmed-gad。<strong>其Github項目也可從以下網址獲得：</strong>https://github.com/ahmedfgad/NeuralGeneti</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>本教程討論瞭如何使用遺傳算法來減少從長度360的Fruits360數據集中提取的特徵向量。本教程首先討論要遵循的步驟。其次通過使用NumPy和Sklearn在python實現這些步驟。</p><blockquote><strong>本教程的實現可在我的Github頁面中找到：</strong>https://github.com/ahmedfgad/FeatureReductionGeneti</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>遺傳算法從一個初始群體開始，該群體由若干染色體（即解決方法）組成，其中每個染色體都有一系列基因。使用適應函數，遺傳算法選擇最佳的解決方案作為父母來創建一個新的群體。在這樣一個新的群體中，通過在雙親上應用兩個操作，即雜交和變異來創建新的解決方案。當把遺傳算法應用到一個給定的問題上時，我們必須確定基因的表示、合適的適應函數以及雜交和變異是如何應用的。接下來讓我們看看運行原理。</p><h1 class=ql-align-center><strong>更多關於遺傳算法的信息</strong></h1><p class=ql-align-justify>你可以從我準備的如下資源中讀到關於遺傳算法的更多知識：</p><p class=ql-align-justify><strong>1. 遺傳算法優化介紹</strong></p><blockquote>https://www.linkedin.com/pulse/introduction-optimization-genetic-algorithm-ahmed-gad/https://www.kdnuggets.com/2018/03/introduction-optimization-with-genetic-algorithm.htmlhttps://towardsdatascience.com/introduction-to-optimization-with-genetic-algorithm-2f5001d9964b</blockquote><p class=ql-align-justify><strong>2. 遺傳算法優化-逐步示例</strong></p><blockquote>https://www.slideshare.net/AhmedGadFCIT/genetic-algorithm-ga-optimization-stepbystep-example</blockquote><p class=ql-align-justify><strong>3. python中的遺傳算法實現</strong></p><blockquote>https://www.linkedin.com/pulse/genetic-algorithm-implementation-python-ahmed-gad/https://www.kdnuggets.com/2018/07/genetic-algorithm-implementation-python.htmlhttps://towardsdatascience.com/genetic-algorithm-implementation-in-python-5ab67bb124a6https://github.com/ahmedfgad/GeneticAlgorithmPython</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>我在2018年還寫了一本書，其中一章介紹了遺傳算法。這本書的標題是“利用CNN進行深度學習的實用計算機視覺應用”，可在Springer上找到。</p><blockquote><strong>Springer鏈接：</strong>https://www.springer.com/us/book/978148424166</blockquote><p class=ql-align-justify><br></p><h1 class=ql-align-center><strong>染色體的表達</strong></h1><p class=ql-align-justify>遺傳算法中的基因是染色體的組成部分。首先，我們需要確定染色體內的基因。為此，考慮到可能影響結果的每一種屬性都應被視為一個基因。因為我們問題的目標是選擇最好的一組特徵元素，所以如果選擇或不選擇，每個特徵元素都可能影響結果。因此，每個特徵元素都被視為一個基因。染色體將由所有基因（即所有特徵元素）組成。因為有360個特徵元素，那麼就有360個基因。一個很好的信息現在很清楚，染色體的長度是360。</p><p class=ql-align-justify>在確定所選基因是什麼之後，下一步就是確定基因的表達。有不同的表示形式，如十進制、二進制、浮點、字符串等。我們的目標是知道基因（即特徵元素）是否在減少的特徵集中被選擇。因此，分配給基因的值應該反映它是否被選擇。基於這種描述，很明顯每個基因有兩個可能的值。一個值表示該基因已被選中，另一個值表示未被選中。因此，二進制表示是最佳選擇。當基因值為1時，將在減少的特徵集中進行選擇。當為0時，則忽略它。</p><p class=ql-align-justify>總之，染色體將由360個基因組成，以二進制表示。根據下一個圖，特徵向量和染色體之間有一對一的映射。這是染色體中的第一個基因與特徵向量中的第一個元素相連。當該基因的值為1時，這意味著選擇了特徵向量中的第一個元素。</p><p class=ql-align-justify></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=基於Python的遺傳算法特徵約簡（附代碼） onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/a1028e1f52114094bf7e04bed193e45e><p class=pgc-img-caption></p></div><h1 class=ql-align-center><strong>適應函數</strong></h1><p class=ql-align-justify>通過了解如何創建染色體，可以很容易地對初始種群進行隨機初始化。初始化後，將選擇父級。遺傳算法基於達爾文的“適者生存”理論。這是目前選擇的最佳解決方案進行組合，以產生更好的解決方案。通過保留好的解和消除壞的解，我們可以得到最優或半最優解。</p><p class=ql-align-justify>選擇雙親的標準是與每個解決方案（即染色體）相關聯的適應值。適合度越高，解決方案越好。使用適應度函數計算適應度值。那麼，在我們的問題中，最適合使用的功能是什麼？我們問題的目標是創建一個約簡的特徵向量，以提高分類精度。因此，判斷一個解是否好的標準是分類的準確性。因此，fitness函數將返回一個數字，指定每個解決方案的分類精度。精度越高，解決方案越好。</p><p class=ql-align-justify>為了返回分類的準確度，必須有一個機器學習模型來通過每個解決方案返回的特徵元素進行訓練。對於這種情況，我們將使用支持向量分類器（SVC）。</p><p class=ql-align-justify>數據集分為訓練樣本和測試樣本。根據訓練數據，SVC將使用人群中每個解決方案選擇的特徵元素進行訓練。經過訓練後，根據測試數據進行測試。</p><p class=ql-align-justify>根據每個解的適合度值，我們可以選擇其中最好的作為父母。這些父母被放在一起組合以產生後代，這將是下一代的新人口的成員。這種後代是通過對選定的親本應用交叉和突變操作而產生的。讓我們按照下面討論的方式配置這些操作。</p><h1 class=ql-align-justify><strong>遺傳和變異</strong></h1><p class=ql-align-justify>基於適應度函數，我們可以篩選出當前群體中的最優解，即父輩。遺傳算法假設匹配2個好的解決方案將產生第三個更好的解決方案。組合意味著從兩個父母那裡交換一些基因。使用遺傳操作交換基因。有不同的方法可以應用這種操作。本教程使用單點交叉，其中一個點分割染色體。點前的基因取自一組解，點後的基因取自另一組解。</p><p class=ql-align-justify>通過應用遺傳，所有的基因都來自於以前的父母。在新的後代中沒有引入新的基因。如果所有的父母都有一個壞基因，那麼這個基因就會轉移到後代身上。正因為如此，為了在後代中引入新的基因，採用了突變操作。在基因的二元表示中，突變是通過翻轉一些隨機選擇的基因的值來實現的。如果基因值為1，則為0，反之亦然。</p><p class=ql-align-justify>在產生後代之後，我們可以創造下一代的新種群。除了後代之外，這個群體還包括以前的父輩。</p><p class=ql-align-justify>此時，將討論所有步驟。接下來是用Python實現它們。注意，我以前寫過一篇題為“Python中的遺傳算法實現”的教程，用於在Python中實現遺傳算法，我將修改它的代碼來解決我們的問題。最好讀一下。</p><h1 class=ql-align-justify><strong>利用Python實現</strong></h1><p class=ql-align-justify>該項目分為兩個文件。一個文件名為GA.py，它將遺傳算法步驟的實現保存為函數。另一個文件是主文件，它只導入這個文件，並在循環中調用它的函數，該循環將迭代幾代。</p><p class=ql-align-justify>根據下面的代碼，主文件首先讀取從Fruits360數據集提取的特性。這些特性返回到數據輸入變量中。有關提取這些功能的詳細信息，請參閱本教程開頭提到的2個教程。該文件還讀取與數據輸出變量中的樣本相關聯的類標籤。</p><p class=ql-align-justify>選擇一些樣本進行訓練，其索引存儲在train_indices變量中。同樣，測試樣本索引存儲在test_indices變量中。</p><p class=ql-align-justify></p><pre class=ql-align-justify>import numpyimport GAimport pickleimport matplotlib.pyplotf = open("dataset_features.pkl", "rb")data_inputs = pickle.load(f)f.close()f = open("outputs.pkl", "rb")data_outputs = pickle.load(f)f.close()num_samples = data_inputs.shape[0]num_feature_elements = data_inputs.shape[1]train_indices = numpy.arange(1, num_samples, 4)test_indices = numpy.arange(0, num_samples, 4)print("Number of training samples: ", train_indices.shape[0])print("Number of test samples: ", test_indices.shape[0])"""Genetic algorithm parameters: Population size Mating pool size Number of mutations"""sol_per_pop = 8 # Population size.num_parents_mating = 4 # Number of parents inside the mating pool.num_mutations = 3 # Number of elements to mutate.# Defining the population shape.pop_shape = (sol_per_pop, num_feature_elements)# Creating the initial population.new_population = numpy.random.randint(low=0, high=2, size=pop_shape)print(new_population.shape)best_outputs = []num_generations = 100</pre><p class=ql-align-justify></p><p class=ql-align-justify>它初始化了遺傳算法的所有參數。這包括根據sol_per_pop變量設置為8的每個群體的解的數量、num _parents_mating變量設置為4的子代數量以及num_mutations變量設置為3的突變數量。之後，它會在一個名為“new_population”的變量中隨機創建初始總體。</p><p class=ql-align-justify>有一個名為best_outputs的空列表，它在每一代之後都保存著最好的結果。這有助於可視化遺傳算法在完成所有代之後的進展。num_generations變量中的代數設置為100。請注意，您可以更改所有這些參數，從而獲得更好的結果。</p><p class=ql-align-justify>在準備好特性、類標籤和算法參數之後，我們可以根據下一個代碼對算法進行迭代。首先，通過調用GA文件中定義的名為cal_pop_fitness（）的適應函數來計算所有解決方案的適應值。此函數接受當前總體、提取的特徵、類標籤、列車索引和測試索引。函數返回名為fitness的變量中所有解的適應值。請記住，適合度值表示分類精度。最佳（即最高）分類精度保存在最佳輸出列表中。</p><p class=ql-align-justify>根據計算出的適合度值，使用GA.py文件中定義的select_matching_pool（）函數選擇分類精度最高的最佳解決方案作為匹配池中的父級。它接受當前的人口、適合度值和要返回的父母人數。它將所選雙親返回到父級變量中。</p><p class=ql-align-justify></p><pre class=ql-align-justify>for generation in range(num_generations): print("Generation : ", generation)  # Measuring the fitness of each chromosome in the population. fitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices) best_outputs.append(numpy.max(fitness)) # The best result in the current iteration. print("Best result : ", best_outputs[-1])  # Selecting the best parents in the population for mating parents = GA.select_mating_pool(new_population, fitness, num_parents_mating)  # Generating next generation using crossover offspring_crossover = GA.crossover(parents, offspring_size=(pop_shape[0]-parents.shape[0], num_feature_elements))  # Adding some variations to the offspring using mutation. offspring_mutation = GA.mutation(offspring_crossover, num_mutations=num_mutations) # Creating the new population based on the parents and offspring. new_population[0:parents.shape[0], :] = parents new_population[parents.shape[0]:, :] = offspring_mutation</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>接下來是對選定的父代應用組合操作以創建子代。這是在GA.py文件中定義的crossover（）函數內完成的。它接受父數組和子數組的形狀，以便稍後返回到offspring_crossover變量中。然後，使用在GA.py文件中也可用的mutation（）函數在該數組上應用突變操作。除了交叉結果，這個函數接受突變的數量。</p><p class=ql-align-justify>因為新的種群由選定的親本和後代組成，所以親本和offspring_crossover數組都保存到new_population變量中。在那之後，新一代被應用於新的人口。</p><p class=ql-align-justify>在所有代完成後，將執行下一個代碼，以返回最佳選擇的功能元素集和所選元素的數量。在100代完成後，該算法使用174個特徵元素，以達到99.59%的精度。</p><p class=ql-align-justify></p><pre class=ql-align-justify>fitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices)# Then return the index of that solution corresponding to the best fitness.best_match_idx = numpy.where(fitness == numpy.max(fitness))[0]best_match_idx = best_match_idx[0]best_solution = new_population[best_match_idx, :]best_solution_indices = numpy.where(best_solution == 1)[0]best_solution_num_elements = best_solution_indices.shape[0]best_solution_fitness = fitness[best_match_idx]print("best_match_idx : ", best_match_idx)print("best_solution : ", best_solution)print("Selected indices : ", best_solution_indices)print("Number of selected elements : ", best_solution_num_elements)print("Best solution fitness : ", best_solution_fitness)matplotlib.pyplot.plot(best_outputs)matplotlib.pyplot.xlabel("Iteration")matplotlib.pyplot.ylabel("Fitness")matplotlib.pyplot.show()</pre><p class=ql-align-justify></p><p class=ql-align-justify>上面的代碼展示了一張圖，顯示了算法在所有代中的進度，如下所示。</p><p class=ql-align-justify></p><p class=ql-align-justify>以下是主文件中的完整代碼。</p><p class=ql-align-justify></p><pre class=ql-align-justify>import numpyimport GAimport pickleimport matplotlib.pyplotf = open("dataset_features.pkl", "rb")data_inputs = pickle.load(f)f.close()f = open("outputs.pkl", "rb")data_outputs = pickle.load(f)f.close()num_samples = data_inputs.shape[0]num_feature_elements = data_inputs.shape[1]train_indices = numpy.arange(1, num_samples, 4)test_indices = numpy.arange(0, num_samples, 4)print("Number of training samples: ", train_indices.shape[0])print("Number of test samples: ", test_indices.shape[0])"""Genetic algorithm parameters: Population size Mating pool size Number of mutations"""sol_per_pop = 8 # Population sizenum_parents_mating = 4 # Number of parents inside the mating pool.num_mutations = 3 # Number of elements to mutate.# Defining the population shape.pop_shape = (sol_per_pop, num_feature_elements)# Creating the initial population.new_population = numpy.random.randint(low=0, high=2, size=pop_shape)print(new_population.shape)best_outputs = []num_generations = 100for generation in range(num_generations): print("Generation : ", generation) # Measuring the fitness of each chromosome in the population. fitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices) best_outputs.append(numpy.max(fitness)) # The best result in the current iteration. print("Best result : ", best_outputs[-1]) # Selecting the best parents in the population for mating. parents = GA.select_mating_pool(new_population, fitness, num_parents_mating)  # Generating next generation using crossover. offspring_crossover = GA.crossover(parents, offspring_size=(pop_shape[0]-parents.shape[0], num_feature_elements)) # Adding some variations to the offspring using mutation. offspring_mutation = GA.mutation(offspring_crossover, num_mutations=num_mutations) # Creating the new population based on the parents and offspring. new_population[0:parents.shape[0], :] = parents new_population[parents.shape[0]:, :] = offspring_mutation # Getting the best solution after iterating finishing all generations.# At first, the fitness is calculated for each solution in the final generation.fitness = GA.cal_pop_fitness(new_population, data_inputs, data_outputs, train_indices, test_indices)# Then return the index of that solution corresponding to the best fitness.best_match_idx = numpy.where(fitness == numpy.max(fitness))[0]best_match_idx = best_match_idx[0]best_solution = new_population[best_match_idx, :]best_solution_indices = numpy.where(best_solution == 1)[0]best_solution_num_elements = best_solution_indices.shape[0]best_solution_fitness = fitness[best_match_idx]print("best_match_idx : ", best_match_idx)print("best_solution : ", best_solution)print("Selected indices : ", best_solution_indices)print("Number of selected elements : ", best_solution_num_elements)print("Best solution fitness : ", best_solution_fitness)matplotlib.pyplot.plot(best_outputs)matplotlib.pyplot.xlabel("Iteration")matplotlib.pyplot.ylabel("Fitness")matplotlib.pyplot.show()</pre><p class=ql-align-justify></p><h1 class=ql-align-center><strong>GA.py的實現</strong></h1><p class=ql-align-justify>GA.py文件的實現如下所示。在cal_pop_fitness（）函數中，SVC根據每個解決方案選擇的特徵元素進行培訓。在訓練前，根據所選的基因值為1的元素過濾特徵。這是在reduce_features（）函數中完成的。除了所有示例的完整功能外，它還接受當前的解決方案。</p><p class=ql-align-justify>訓練後，使用reduce_features（）函數計算分類精度。此函數返回存儲在cal pop_fitness（）函數中名為accuracies的數組中的精度。</p><p class=ql-align-justify>crossover（）和mutation（）函數的實現與我之前的教程“Python中的遺傳算法實現”中討論的非常相似。一個主要的區別是，mutation（）函數通過翻轉隨機選擇的基因的值來改變它們，因為我們使用的是二進制表示。</p><p class=ql-align-justify></p><pre class=ql-align-justify>import numpyimport sklearn.svmdef reduce_features(solution, features): selected_elements_indices = numpy.where(solution == 1)[0] reduced_features = features[:, selected_elements_indices] return reduced_featuresdef classification_accuracy(labels, predictions): correct = numpy.where(labels == predictions)[0] accuracy = correct.shape[0]/labels.shape[0] return accuracydef cal_pop_fitness(pop, features, labels, train_indices, test_indices): accuracies = numpy.zeros(pop.shape[0]) idx = 0 for curr_solution in pop: reduced_features = reduce_features(curr_solution, features) train_data = reduced_features[train_indices, :] test_data = reduced_features[test_indices, :] train_labels = labels[train_indices] test_labels = labels[test_indices] SV_classifier = sklearn.svm.SVC(gamma='scale') SV_classifier.fit(X=train_data, y=train_labels) predictions = SV_classifier.predict(test_data) accuracies[idx] = classification_accuracy(test_labels, predictions) idx = idx + 1 return accuraciesdef select_mating_pool(pop, fitness, num_parents): # Selecting the best individuals in the current generation as parents for producing the offspring of the next generation. parents = numpy.empty((num_parents, pop.shape[1])) for parent_num in range(num_parents): max_fitness_idx = numpy.where(fitness == numpy.max(fitness)) max_fitness_idx = max_fitness_idx[0][0] parents[parent_num, :] = pop[max_fitness_idx, :] fitness[max_fitness_idx] = -99999999999 return parentsdef crossover(parents, offspring_size): offspring = numpy.empty(offspring_size) # The point at which crossover takes place between two parents. Usually, it is at the center. crossover_point = numpy.uint8(offspring_size[1]/2) for k in range(offspring_size[0]): # Index of the first parent to mate. parent1_idx = k%parents.shape[0] # Index of the second parent to mate. parent2_idx = (k+1)%parents.shape[0]  # The new offspring will have its first half of its genes taken from the first parent. offspring[k, 0:crossover_point] = parents[parent1_idx, 0:crossover_point] # The new offspring will have its second half of its genes taken from the second parent. offspring[k, crossover_point:] = parents[parent2_idx, crossover_point:] return offspringdef mutation(offspring_crossover, num_mutations=2): mutation_idx = numpy.random.randint(low=0, high=offspring_crossover.shape[1], size=num_mutations) # Mutation changes a single gene in each offspring randomly. for idx in range(offspring_crossover.shape[0]): # The random value to be added to the gene. offspring_crossover[idx, mutation_idx] = 1 - offspring_crossover[idx, mutation_idx] return offspring_crossover</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>原文標題：</p><p class=ql-align-justify><strong>Feature Reduction using Genetic Algorithm with Python</strong></p><p class=ql-align-justify>原文鏈接：</p><blockquote>https://www.kdnuggets.com/2019/03/feature-reduction-genetic-algorithm-python.html</blockquote><p class=ql-align-justify><strong>譯者簡介</strong></p><div class=pgc-img><img alt=基於Python的遺傳算法特徵約簡（附代碼） onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/5bd2c3a0071e4648836a88717cdaeafc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>張睿毅</strong>，北京郵電大學大二物聯網在讀。我是一個愛自由的人。在郵電大學讀第一年書我就四處跑去蹭課，折騰整一年驚覺，與其在當下焦慮，不如在前輩中沉澱。於是在大二以來，堅持讀書，不敢稍歇。資本主義國家的科學觀不斷刷新我的認知框架，同時因為出國考試很早出分，也更早地感受到自己才是那個一直被束縛著的人。太多真英雄在社會上各自閃耀著光芒。這才開始，立志終身向遇到的每一個人學習。做一個純粹的計算機科學裡面的小學生。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Python</a></li><li><a>遺傳</a></li><li><a>特徵約</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html alt=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/dfic-imagehandler/f1d21356-1ef5-4ec5-a4a5-c5699b12bee1 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/388a5f0.html title=Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題>Python編寫遺傳算法實戰，整數編碼，啟發式搜索解決旅行商問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html alt=Python中的遺傳算法完整實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/1531731137721602bd9c18c style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/1c10283.html title=Python中的遺傳算法完整實現>Python中的遺傳算法完整實現</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html alt=一文讀懂遺傳算法工作原理！附Python實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/fde5cfc48c5a45d4891d621c7b4cc5e4 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/b5f265c.html title=一文讀懂遺傳算法工作原理！附Python實現>一文讀懂遺傳算法工作原理！附Python實現</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html alt="遺傳算法(Python) #2 基本運算方法詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/c3dcdafb8df8476dbc472615f3131b59 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/60f30bd.html title="遺傳算法(Python) #2 基本運算方法詳解">遺傳算法(Python) #2 基本運算方法詳解</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html alt="遺傳算法(Python) #3 從零開始解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/5d69e28f41a44f81b8dd0bbe9f2f2b6f style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/2c5f63f.html title="遺傳算法(Python) #3 從零開始解決OneMax問題">遺傳算法(Python) #3 從零開始解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html alt="遺傳算法(Python) #5 用DEAP框架解決OneMax問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/3279ffb8082c491a967c683ae24bdfcb style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/4a7d591.html title="遺傳算法(Python) #5 用DEAP框架解決OneMax問題">遺傳算法(Python) #5 用DEAP框架解決OneMax問題</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html alt=遺傳算法綜合指南（以及如何Python編碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/15354276244373403483b2e style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/00fec97.html title=遺傳算法綜合指南（以及如何Python編碼）>遺傳算法綜合指南（以及如何Python編碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html alt=Python爬蟲教程，利用Python採集QQ群成員信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d6cce76ad48405c9dbb960d4617bcef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html title=Python爬蟲教程，利用Python採集QQ群成員信息>Python爬蟲教程，利用Python採集QQ群成員信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html alt=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5d4a0000046e1bea8b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html title=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？>Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html alt=Python中的多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49dd44b999924b69bd3396709ecacaf4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html title=Python中的多進程>Python中的多進程</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>